import imports
lemma new_lemma_64000 (h0 : function.extfun Type topological_space) : @locally_compact_space.{0} (has_norm.{0} linarith.ineq) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_norm.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_64001 (h0 : function.extfun Type filter) : countable_Inter_filter (function.extfun_app h0 (generalized_boolean_algebra linarith.comp)) := sorry --non-trivial
lemma new_lemma_64002 (h0 : add_group (dlist (multiplicative to_additive.value_type))) : is_add_cyclic (dlist (multiplicative to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_64003 (h0 : not (function.extfun Type topological_space -> false)) : @totally_disconnected_space.{0} (has_one.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (has_one.{0} num))  := sorry --non-trivial
lemma new_lemma_64004 (h0 : function.extfun Type filter) : filter.ne_bot (function.extfun_app h0 (has_nndist (option (linear_ordered_comm_group ennreal)))) := sorry --non-trivial
lemma new_lemma_64005 (h0 : topological_space (random_gen (random_gen (random_gen (random_gen (random_gen string_imp)))))) : t0_space (random_gen (random_gen (random_gen (random_gen (random_gen string_imp))))) := sorry --non-trivial
lemma new_lemma_64006 (h0 : function.extfun Type (functor.add_const (complete_lattice auto.case_option))) : @complete_lattice.is_Sup_finite_compact.{0} auto.case_option (@functor.add_const.run.{0 0} (complete_lattice.{0} auto.case_option) (option.{0} empty) (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (complete_lattice.{0} auto.case_option)) h0 (option.{0} empty)))  := sorry --non-trivial
lemma new_lemma_64007 (h0 : has_mem.mem (with_one fun_info) has_emptyc.emptyc) : @irreducible_space.{0} (with_one.{0} fun_info) (@finset.pi.empty.{1 0} Type topological_space.{0} (with_one.{0} fun_info) h0)  := sorry --non-trivial
lemma new_lemma_64008 (h0 : topological_space (semigroup (comm_group (comm_group pos)))) : irreducible_space (semigroup (comm_group (comm_group pos))) := sorry --non-trivial
lemma new_lemma_64009 (h0 : functor.add_const (add_group (has_nndist name)) unsigned) : @is_add_cyclic.{0} (has_nndist.{0} name) (@functor.add_const.run.{0 0} (add_group.{0} (has_nndist.{0} name)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_64010 (h0 : uniform_space (has_norm (has_norm empty))) : separated_space (has_norm (has_norm empty)) := sorry --non-trivial
lemma new_lemma_64011 (h0 : ring (add_cancel_monoid (has_add (has_pos_part pos)))) : is_domain (add_cancel_monoid (has_add (has_pos_part pos))) := sorry --non-trivial
lemma new_lemma_64012 (h0 : functor.add_const (ring (semigroup unsigned)) linarith.comp) : @strong_rank_condition.{0} (semigroup.{0} unsigned) (@functor.add_const.run.{0 0} (ring.{0} (semigroup.{0} unsigned)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_64013 (h0 : group (measurable_space (ordered_comm_semiring congr_arg_kind))) : is_cyclic (measurable_space (ordered_comm_semiring congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_64014 (h0 : group (generalized_boolean_algebra real)) : is_simple_group (generalized_boolean_algebra real) := sorry --non-trivial
lemma new_lemma_64015 (h0 : function.extfun (Type 1) topological_space) : @totally_separated_space.{1} (has_neg_part.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} h0 (has_neg_part.{1} Type))  := sorry --non-trivial
lemma new_lemma_64016 (h0 : monoid (has_emptyc (has_inv (has_inv (has_inv fun_info))))) : monoid.fg (has_emptyc (has_inv (has_inv (has_inv fun_info)))) := sorry --non-trivial
lemma new_lemma_64017 (h0 : functor.add_const (topological_space (has_star num)) num) : @loc_path_connected_space.{0} (has_star.{0} num) (@functor.add_const.run.{0 0} (topological_space.{0} (has_star.{0} num)) num h0)  := sorry --non-trivial
lemma new_lemma_64018 (h0 : functor.add_const (topological_space (bin_tree empty)) num) : @path_connected_space.{0} (bin_tree.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (bin_tree.{0} empty)) num h0)  := sorry --non-trivial
lemma new_lemma_64019 (h0 : ring (with_bot (semiring (has_norm unsigned)))) : rank_condition (with_bot (semiring (has_norm unsigned))) := sorry --non-trivial
lemma new_lemma_64020 (h0 : functor.add_const (function.extfun (Type 1) ordered_add_comm_monoid) Type) : @archimedean.{1} (has_zero.{1} Type) (@function.extfun_app.{3 2} (Type 1) ordered_add_comm_monoid.{1} (@functor.add_const.run.{2 1} (function.extfun.{3 2} (Type 1) ordered_add_comm_monoid.{1}) Type h0) (has_zero.{1} Type))  := sorry --non-trivial
lemma new_lemma_64021 (h0 : set (prod Type Type)) : symmetric_rel h0 := sorry --non-trivial
lemma new_lemma_64022 (h0 : topological_space (comm_group (has_neg_part ennreal))) : preirreducible_space (comm_group (has_neg_part ennreal)) := sorry --non-trivial
lemma new_lemma_64023 (h0 : function.extfun Type group) : @is_simple_group.{0} (boolean_algebra.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type group.{0} h0 (boolean_algebra.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_64024 (h0 : functor.add_const (group (has_add linarith.comp)) linarith.comp) : @normalizer_condition.{0} (has_add.{0} linarith.comp) (@functor.add_const.run.{0 0} (group.{0} (has_add.{0} linarith.comp)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_64025 (h0 : cancel_comm_monoid_with_zero (generalized_boolean_algebra (has_Inf (has_Inf Type)))) : unique_factorization_monoid (generalized_boolean_algebra (has_Inf (has_Inf Type))) := sorry --non-trivial
lemma new_lemma_64026 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_add_cyclic.{0} (add_comm_monoid.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type add_group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 add_group.{0}) (add_comm_monoid.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_64027 (h0 : topological_space (boolean_algebra (normed_comm_ring environment.implicit_infer_kind))) : irreducible_space (boolean_algebra (normed_comm_ring environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_64028 (h0 : topological_space (uniform_space (mul_one_class reducibility_hints))) : totally_disconnected_space (uniform_space (mul_one_class reducibility_hints)) := sorry --non-trivial
lemma new_lemma_64029 (h0 : topological_space (add_comm_monoid (has_nndist linarith.comp))) : regular_space (add_comm_monoid (has_nndist linarith.comp)) := sorry --non-trivial
lemma new_lemma_64030 (h0 : filter (omega_complete_partial_order empty)) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_64031 (h0 : group (semi_normed_comm_ring (has_nnnorm (has_nnnorm (has_nnnorm fun_info))))) : group.fg (semi_normed_comm_ring (has_nnnorm (has_nnnorm (has_nnnorm fun_info)))) := sorry --non-trivial
lemma new_lemma_64032 (h0 : function.extfun Type filter) : countable_Inter_filter (function.extfun_app h0 (has_to_string ennreal)) := sorry --non-trivial
lemma new_lemma_64033 (h0 : topological_space (sub_neg_monoid name)) : preconnected_space (sub_neg_monoid name) := sorry --non-trivial
lemma new_lemma_64034 (h1 : measurable_space (mul_one_class enat)) (h2 : filter (mul_one_class enat)) : filter.is_measurably_generated h2 := sorry --non-trivial
lemma new_lemma_64035 (h0 : cancel_comm_monoid_with_zero (add_comm_monoid (has_add unsigned))) : unique_factorization_monoid (add_comm_monoid (has_add unsigned)) := sorry --non-trivial
lemma new_lemma_64036 (h0 : ring (add_comm_semigroup fun_info)) (h1 : prod (ring.positive_cone (add_comm_semigroup fun_info)) (ring.positive_cone (add_comm_semigroup fun_info))) : set.diagonal (ring.positive_cone (add_comm_semigroup fun_info)) h1 := sorry --non-trivial
lemma new_lemma_64037 (h0 : functor.add_const (complete_lattice (add_cancel_monoid empty)) (option (option (option empty)))) : @complete_lattice.is_Sup_finite_compact.{0} (add_cancel_monoid.{0} empty) (@functor.add_const.run.{0 0} (complete_lattice.{0} (add_cancel_monoid.{0} empty)) (option.{0} (option.{0} (option.{0} empty))) h0)  := sorry --non-trivial
lemma new_lemma_64038 (h2 : not (ring (measurable_space linarith.comp_source) -> false)) : @is_domain.{0} (measurable_space.{0} linarith.comp_source) (@classical.by_contradiction'.{1} (ring.{0} (measurable_space.{0} linarith.comp_source)) h2)  := sorry --non-trivial
lemma new_lemma_64039 (h0 : not (complete_lattice (has_union num) -> false)) : @is_compactly_generated.{0} (has_union.{0} num) (@classical.by_contradiction'.{1} (complete_lattice.{0} (has_union.{0} num)) h0)  := sorry --non-trivial
lemma new_lemma_64040 (h0 : ring (mul_zero_class environment.implicit_infer_kind)) : is_principal_ideal_ring (mul_zero_class environment.implicit_infer_kind) := sorry --non-trivial
lemma new_lemma_64041 (h0 : functor.add_const (list (measure_theory.measure_space empty)) (semiring empty)) : list.nodup (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_64042 (h0 : ring (has_norm (random_gen linarith.ineq))) : rank_condition (has_norm (random_gen linarith.ineq)) := sorry --non-trivial
lemma new_lemma_64043 (h0 : functor.comp uniform_space canonically_ordered_comm_semiring name) : @separated_space.{0} (canonically_ordered_comm_semiring.{0} name) (@functor.comp.run.{0 0 0} uniform_space.{0} canonically_ordered_comm_semiring.{0} name h0)  := sorry --non-trivial
lemma new_lemma_64044 (h0 : uniform_space (add_right_cancel_monoid congr_arg_kind)) : separated_space (add_right_cancel_monoid congr_arg_kind) := sorry --non-trivial
lemma new_lemma_64045 (h0 : complete_lattice (normed_comm_ring (mul_one_class Type))) : is_compactly_generated (normed_comm_ring (mul_one_class Type)) := sorry --non-trivial
lemma new_lemma_64046 (h0 : functor.add_const (finset (has_to_string name)) unsigned) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_64047 (h0 : topological_space (monoid_with_zero num)) : loc_path_connected_space (monoid_with_zero num) := sorry --non-trivial
lemma new_lemma_64048 (h0 : topological_space (ordered_comm_ring (ring (has_neg linarith.comp)))) : path_connected_space (ordered_comm_ring (ring (has_neg linarith.comp))) := sorry --non-trivial
lemma new_lemma_64049 (h0 : functor.add_const (topological_space (add_group num)) (semiring num)) : @t1_space.{0} (add_group.{0} num) (@functor.add_const.run.{0 0} (topological_space.{0} (add_group.{0} num)) (semiring.{0} num) h0)  := sorry --non-trivial
lemma new_lemma_64050 (h0 : functor.add_const (filter (semigroup linarith.comp)) pos) : filter.ne_bot (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_64051 (h0 : complete_lattice (sub_neg_monoid (has_add (has_add real)))) : is_compactly_generated (sub_neg_monoid (has_add (has_add real))) := sorry --non-trivial
lemma new_lemma_64052 (h0 : functor.add_const (add_monoid (add_comm_monoid pos)) pos) : @add_monoid.fg.{0} (add_comm_monoid.{0} pos) (@functor.add_const.run.{0 0} (add_monoid.{0} (add_comm_monoid.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_64053 (h0 : functor.add_const (add_group (has_zero Type)) (has_neg_part pos)) : @is_add_cyclic.{1} (has_zero.{1} Type) (@functor.add_const.run.{1 0} (add_group.{1} (has_zero.{1} Type)) (has_neg_part.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_64054 (h0 : functor.add_const (group (add_comm_monoid Type)) (has_to_string (has_to_string Type))) : @normalizer_condition.{1} (add_comm_monoid.{1} Type) (@functor.add_const.run.{1 1} (group.{1} (add_comm_monoid.{1} Type)) (has_to_string.{1} (has_to_string.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_64055 (h0 : function.extfun (finset (Type -> Type)) (has_mem.mem add_group)) : @is_add_cyclic.{0} (has_norm.{0} fun_info) (@function.extfun_app.{2 1} Type add_group.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) add_group.{0} (@function.extfun_app.{2 0} (finset.{1} (Type → Type)) (@has_mem.mem.{1 1} (Type → Type) (finset.{1} (Type → Type)) (@finset.has_mem.{1} (Type → Type)) add_group.{0}) h0 (@has_emptyc.emptyc.{1} (finset.{1} (Type → Type)) (@finset.has_emptyc.{1} (Type → Type))))) (has_norm.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_64056 (h0 : group (add_comm_monoid (ring (ring (ring linarith.comp))))) : is_simple_group (add_comm_monoid (ring (ring (ring linarith.comp)))) := sorry --non-trivial
lemma new_lemma_64057 (h0 : function.extfun Type complete_lattice) : @complete_lattice.is_Sup_finite_compact.{0} (has_Sup.{0} num) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (has_Sup.{0} num))  := sorry --non-trivial
lemma new_lemma_64058 (h0 : topological_space (linear_ordered_comm_monoid_with_zero (option (option empty)))) : normal_space (linear_ordered_comm_monoid_with_zero (option (option empty))) := sorry --non-trivial
lemma new_lemma_64059 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : list.nodup (function.extfun_app (function.extfun_app h0 list) (finset ennreal)) := sorry --non-trivial
lemma new_lemma_64060 (h0 : ring (has_bot (has_Inf (sub_neg_monoid (sub_neg_monoid pos))))) : is_principal_ideal_ring (has_bot (has_Inf (sub_neg_monoid (sub_neg_monoid pos)))) := sorry --non-trivial
lemma new_lemma_64061 (h0 : topological_space (ordered_comm_monoid (has_neg name))) : normal_space (ordered_comm_monoid (has_neg name)) := sorry --non-trivial
lemma new_lemma_64062 (h0 : ring (add_comm_monoid (has_add linarith.comp))) : rank_condition (add_comm_monoid (has_add linarith.comp)) := sorry --non-trivial
lemma new_lemma_64063 (h0 : functor.add_const (function.extfun (Type 1) topological_space) linarith.comp) : @preconnected_space.{1} (has_Inf.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) topological_space.{1}) linarith.comp h0) (has_Inf.{1} Type))  := sorry --non-trivial
lemma new_lemma_64064 (h0 : topological_space (has_ssubset string.iterator_imp)) : t0_space (has_ssubset string.iterator_imp) := sorry --non-trivial
lemma new_lemma_64065 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @t0_space.{0} (has_to_string.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_to_string.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_64066 (h0 : functor.add_const (group (non_assoc_semiring unsigned)) empty) : @is_cyclic.{0} (non_assoc_semiring.{0} unsigned) (@functor.add_const.run.{0 0} (group.{0} (non_assoc_semiring.{0} unsigned)) empty h0)  := sorry --non-trivial
lemma new_lemma_64067 (h0 : function.extfun (Type 1) topological_space) : @irreducible_space.{1} (has_Inf.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} h0 (has_Inf.{1} Type))  := sorry --non-trivial
lemma new_lemma_64068 (h0 : filter Prop -> filter Prop) (h1 : nat) (h2 : filter Prop) : @filter.Liminf.{0} Prop (@complete_lattice.to_conditionally_complete_lattice.{0} Prop Prop.complete_lattice) (@nat.iterate.{1} (filter.{0} Prop) h0 h1 h2)  := sorry --non-trivial
lemma new_lemma_64069 (h0 : topological_space (has_pos_part (ring pos))) : preirreducible_space (has_pos_part (ring pos)) := sorry --non-trivial
lemma new_lemma_64070 (h0 : uniform_space (has_zero (has_neg (finset linarith.comp)))) : separated_space (has_zero (has_neg (finset linarith.comp))) := sorry --non-trivial
lemma new_lemma_64071 (h0 : not (function.extfun Type topological_space -> false)) : @totally_disconnected_space.{0} (complete_semilattice_Sup.{0} char) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (complete_semilattice_Sup.{0} char))  := sorry --non-trivial
lemma new_lemma_64072 (h0 : prod (add_comm_monoid empty) (add_comm_monoid empty)) : id_rel h0 := sorry --non-trivial
lemma new_lemma_64073 (h0 : functor.comp uniform_space complete_distrib_lattice name) : @complete_space.{0} (complete_distrib_lattice.{0} name) (@functor.comp.run.{0 0 0} uniform_space.{0} complete_distrib_lattice.{0} name h0)  := sorry --non-trivial
lemma new_lemma_64074 (h0 : topological_space (linear_ordered_semiring (random_gen fun_info))) : irreducible_space (linear_ordered_semiring (random_gen fun_info)) := sorry --non-trivial
lemma new_lemma_64075 (h0 : complete_lattice (boolean_algebra (has_neg linarith.comp))) : is_compactly_generated (boolean_algebra (has_neg linarith.comp)) := sorry --non-trivial
lemma new_lemma_64076 (h0 : complete_lattice (has_inner (option (option (option empty))) unsigned)) : is_compactly_generated (has_inner (option (option (option empty))) unsigned) := sorry --non-trivial
lemma new_lemma_64077 (h0 : topological_space (ring (has_add environment.implicit_infer_kind))) : totally_disconnected_space (ring (has_add environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_64078 (h0 : function.extfun nat fin) : @preirreducible_space.{1} (canonically_ordered_monoid.{1} Type) (@matrix.vec_empty.{1} (topological_space.{1} (canonically_ordered_monoid.{1} Type)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_64079 (h0 : has_lt (non_unital_non_assoc_semiring string.iterator_imp)) : no_max_order (non_unital_non_assoc_semiring string.iterator_imp) := sorry --non-trivial
lemma new_lemma_64080 (h0 : fin has_zero.zero) : @topological_space.separable_space.{1} (generalized_boolean_algebra.{1} Type) (@matrix.vec_empty.{1} (topological_space.{1} (generalized_boolean_algebra.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_64081 (h0 : topological_space (ordered_cancel_add_comm_monoid unsigned)) : normal_space (ordered_cancel_add_comm_monoid unsigned) := sorry --non-trivial
lemma new_lemma_64082 (h3 : ring (semi_normed_ring to_additive.value_type)) : is_domain (semi_normed_ring to_additive.value_type) := sorry --non-trivial
lemma new_lemma_64083 (h0 : topological_space (canonically_linear_ordered_monoid (finset (has_add Type)))) : loc_path_connected_space (canonically_linear_ordered_monoid (finset (has_add Type))) := sorry --non-trivial
lemma new_lemma_64084 (h0 : has_mem.mem topological_space has_emptyc.emptyc) : @irreducible_space.{0} (semiring.{0} linarith.ineq) (@function.extfun_app.{2 1} Type topological_space.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) topological_space.{0} h0) (semiring.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_64085 (h0 : group (normed_group (semiring congr_arg_kind))) : normalizer_condition (normed_group (semiring congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_64086 (h0 : function.extfun (nat -> Type) (function.extfun nat)) : @complete_space.{1} (simple_graph.{1} Type) (@matrix.vec_empty.{1} (uniform_space.{1} (simple_graph.{1} Type)) (@function.extfun_app.{1 1} nat fin (@function.extfun_app.{2 1} (nat → Type) (function.extfun.{1 1} nat) h0 fin) (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_64087 (h0 : functor.add_const (ordered_add_comm_monoid (canonically_ordered_comm_semiring unsigned)) pos) : @archimedean.{0} (canonically_ordered_comm_semiring.{0} unsigned) (@functor.add_const.run.{0 0} (ordered_add_comm_monoid.{0} (canonically_ordered_comm_semiring.{0} unsigned)) pos h0)  := sorry --non-trivial
lemma new_lemma_64088 (h0 : topological_space (normed_field environment.projection_info)) : path_connected_space (normed_field environment.projection_info) := sorry --non-trivial
lemma new_lemma_64089 (h0 : functor.add_const (function.extfun Type add_group) linarith.comp) : @is_add_cyclic.{0} pos (@function.extfun_app.{2 1} Type add_group.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type add_group.{0}) linarith.comp h0) pos)  := sorry --non-trivial
lemma new_lemma_64090 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @normalizer_condition.{0} unsigned (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) unsigned)  := sorry --non-trivial
lemma new_lemma_64091 (h0 : topological_space (add_cancel_monoid num)) : irreducible_space (add_cancel_monoid num) := sorry --non-trivial
lemma new_lemma_64092 (h0 : topological_space (ordered_comm_monoid linarith.comp)) : path_connected_space (ordered_comm_monoid linarith.comp) := sorry --non-trivial
lemma new_lemma_64093 (h0 : function.extfun (finset Type -> Prop) (function.extfun (finset Type))) : @path_connected_space.{0} num (@finset.pi.empty.{1 0} Type topological_space.{0} num (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) num) (@function.extfun_app.{2 0} (finset.{1} Type → Prop) (function.extfun.{2 0} (finset.{1} Type)) h0 (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) num)) (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_64094 (h0 : uniform_space (normed_group (semiring (has_norm congr_arg_kind)))) : complete_space (normed_group (semiring (has_norm congr_arg_kind))) := sorry --non-trivial
lemma new_lemma_64095 (h0 : uniform_space (normed_field (random_gen (random_gen (random_gen (random_gen (random_gen char))))))) : complete_space (normed_field (random_gen (random_gen (random_gen (random_gen (random_gen char)))))) := sorry --non-trivial
lemma new_lemma_64096 (h0 : group (normed_lattice_add_comm_group pos)) : group.fg (normed_lattice_add_comm_group pos) := sorry --non-trivial
lemma new_lemma_64097 (h0 : topological_space (ring (has_nndist (ring (finset Type))))) : regular_space (ring (has_nndist (ring (finset Type)))) := sorry --non-trivial
lemma new_lemma_64098 (h0 : not (function.extfun Type ring -> false)) : @is_domain.{0} (add_group.{0} linarith.comp) (@function.extfun_app.{2 1} Type ring.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type ring.{0}) h0) (add_group.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_64099 (h0 : ring (has_lt (has_nnnorm (mul_one_class linarith.ineq)))) : is_domain (has_lt (has_nnnorm (mul_one_class linarith.ineq))) := sorry --non-trivial
lemma new_lemma_64100 (h0 : add_group (semigroup Type)) : is_add_cyclic (semigroup Type) := sorry --non-trivial
lemma new_lemma_64101 (h0 : set (non_unital_non_assoc_semiring linarith.ineq)) : set.finite h0 := sorry --non-trivial
lemma new_lemma_64102 (h0 : uniform_space (add_comm_monoid linarith.comp)) : complete_space (add_comm_monoid linarith.comp) := sorry --non-trivial
lemma new_lemma_64103 (h0 : topological_space (has_compl enat)) : t0_space (has_compl enat) := sorry --non-trivial
lemma new_lemma_64104 (h0 : functor.add_const (topological_space (has_pos_part environment.implicit_infer_kind)) pos) : @totally_disconnected_space.{0} (has_pos_part.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (has_pos_part.{0} environment.implicit_infer_kind)) pos h0)  := sorry --non-trivial
lemma new_lemma_64105 (h0 : topological_space (has_union (has_top linarith.comp))) : normal_space (has_union (has_top linarith.comp)) := sorry --non-trivial
lemma new_lemma_64106 (h0 : function.extfun ((Type -> Type) -> Type 1) (function.extfun (Type -> Type))) : @t0_space.{0} (distrib_lattice.{0} linarith.ineq) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) (@function.extfun_app.{3 2} ((Type → Type) → Type 1) (function.extfun.{2 2} (Type → Type)) h0 (function.extfun.{2 1} Type)) topological_space.{0}) (distrib_lattice.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_64107 (h1 : topological_space (has_ssubset char)) : path_connected_space (has_ssubset char) := sorry --non-trivial
lemma new_lemma_64108 (h0 : semiring (option (semiring (semiring (semiring (semiring (semiring (semiring empty)))))))) : is_noetherian_ring (option (semiring (semiring (semiring (semiring (semiring (semiring empty))))))) := sorry --non-trivial
lemma new_lemma_64109 (h0 : ordered_comm_monoid (cancel_monoid (has_to_string pos))) : has_exists_mul_of_le (cancel_monoid (has_to_string pos)) := sorry --non-trivial
lemma new_lemma_64110 (h0 : function.extfun Type topological_space) : normal_space nnreal := sorry --non-trivial
lemma new_lemma_64111 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @loc_path_connected_space.{0} (add_cancel_monoid.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (add_cancel_monoid.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_64112 (h0 : functor.add_const (add_monoid (bin_tree num)) num) : @add_monoid.fg.{0} (bin_tree.{0} num) (@functor.add_const.run.{0 0} (add_monoid.{0} (bin_tree.{0} num)) num h0)  := sorry --non-trivial
lemma new_lemma_64113 (h0 : functor.add_const (topological_space (has_dist unsigned)) num) : @loc_path_connected_space.{0} (has_dist.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (has_dist.{0} unsigned)) num h0)  := sorry --non-trivial
lemma new_lemma_64114 (h0 : topological_space (free_add_monoid (semiring unsigned))) : totally_separated_space (free_add_monoid (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_64115 (h0 : group (linear_ordered_add_comm_group (random_gen (random_gen string_imp)))) : group.fg (linear_ordered_add_comm_group (random_gen (random_gen string_imp))) := sorry --non-trivial
lemma new_lemma_64116 (h0 : set (add_comm_semigroup (simple_graph linarith.ineq) -> char)) : set.separates_points h0 := sorry --non-trivial
lemma new_lemma_64117 (h0 : group (has_add congr_arg_kind)) : is_cyclic (has_add congr_arg_kind) := sorry --non-trivial
lemma new_lemma_64118 (h0 : function.extfun Type (functor.add_const (list (partial_order congr_arg_kind)))) : palindrome (functor.add_const.run (function.extfun_app h0 unsigned)) := sorry --non-trivial
lemma new_lemma_64119 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @path_connected_space.{0} (non_assoc_semiring.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (non_assoc_semiring.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_64120 (h0 : functor.add_const (list (add_cancel_monoid Type)) (has_neg_part pos)) : palindrome (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_64121 (h0 : group (semi_normed_comm_ring (has_nnnorm linarith.ineq))) : is_cyclic (semi_normed_comm_ring (has_nnnorm linarith.ineq)) := sorry --non-trivial
lemma new_lemma_64122 (h0 : functor.add_const (topological_space (has_neg environment.implicit_infer_kind)) pos) : @discrete_topology.{0} (has_neg.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (has_neg.{0} environment.implicit_infer_kind)) pos h0)  := sorry --non-trivial
lemma new_lemma_64123 (h0 : functor.add_const (function.extfun (Type 1) ring) environment.implicit_infer_kind) : @is_principal_ideal_ring.{1} (normed_comm_ring.{1} Type) (@function.extfun_app.{3 2} (Type 1) ring.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) ring.{1}) environment.implicit_infer_kind h0) (normed_comm_ring.{1} Type))  := sorry --non-trivial
lemma new_lemma_64124 (h0 : ring (measurable_space (random_gen num))) : rank_condition (measurable_space (random_gen num)) := sorry --non-trivial
lemma new_lemma_64125 (h0 : functor.add_const (ordered_comm_monoid (has_zero unsigned)) (normed_comm_ring environment.implicit_infer_kind)) : @has_exists_mul_of_le.{0} (has_zero.{0} unsigned) (@functor.add_const.run.{0 0} (ordered_comm_monoid.{0} (has_zero.{0} unsigned)) (normed_comm_ring.{0} environment.implicit_infer_kind) h0)  := sorry --non-trivial
lemma new_lemma_64126 (h0 : functor.add_const (topological_space pos) pos) : @normal_space.{0} pos (@functor.add_const.run.{0 0} (topological_space.{0} pos) pos h0)  := sorry --non-trivial
lemma new_lemma_64127 (h0 : topological_space (boolean_algebra.core (finset (finset pos)))) : locally_compact_space (boolean_algebra.core (finset (finset pos))) := sorry --non-trivial
lemma new_lemma_64128 (h0 : functor.add_const (topological_space (has_dist unsigned)) num) : @irreducible_space.{0} (has_dist.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (has_dist.{0} unsigned)) num h0)  := sorry --non-trivial
lemma new_lemma_64129 (h0 : has_Inf (has_Inf (ordered_comm_monoid name)) -> has_Inf (has_Inf (ordered_comm_monoid name)) -> Prop) : total h0 := sorry --non-trivial
lemma new_lemma_64130 (h0 : topological_space (with_bot (has_norm num))) : locally_compact_space (with_bot (has_norm num)) := sorry --non-trivial
lemma new_lemma_64131 (h0 : functor.add_const (topological_space (has_pos_part real)) real) : @preconnected_space.{0} (has_pos_part.{0} real) (@functor.add_const.run.{0 0} (topological_space.{0} (has_pos_part.{0} real)) real h0)  := sorry --non-trivial
lemma new_lemma_64132 (h0 : topological_space (linear_order empty)) : irreducible_space (linear_order empty) := sorry --non-trivial
lemma new_lemma_64133 (h0 : topological_space (semiring (has_norm linarith.comp))) : totally_separated_space (semiring (has_norm linarith.comp)) := sorry --non-trivial
lemma new_lemma_64134 (h0 : functor.add_const (function.extfun Type group) unsigned) : @group.fg.{0} nnreal (@function.extfun_app.{2 1} Type group.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type group.{0}) unsigned h0) nnreal)  := sorry --non-trivial
lemma new_lemma_64135 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @unique_factorization_monoid.{0} (add_cancel_monoid.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type cancel_comm_monoid_with_zero.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 cancel_comm_monoid_with_zero.{0}) (add_cancel_monoid.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_64136 (h0 : not (complete_lattice (has_norm (has_top num)) -> false)) : @is_atomistic.{0} (has_norm.{0} (has_top.{0} num)) (@classical.by_contradiction'.{1} (complete_lattice.{0} (has_norm.{0} (has_top.{0} num))) h0)  := sorry --non-trivial
lemma new_lemma_64137 (h0 : topological_space (has_add (has_nnnorm fun_info))) : totally_disconnected_space (has_add (has_nnnorm fun_info)) := sorry --non-trivial
lemma new_lemma_64138 (h0 : function.extfun Type topological_space) : @totally_disconnected_space.{0} (has_union.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_union.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_64139 (h0 : function.extfun ((Type -> Type) -> Type 1) (function.extfun (Type -> Type))) : @normalizer_condition.{0} (option.{0} ennreal) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) (@function.extfun_app.{3 2} ((Type → Type) → Type 1) (function.extfun.{2 2} (Type → Type)) h0 (function.extfun.{2 1} Type)) group.{0}) (option.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_64140 (h0 : functor.add_const (function.extfun Type add_monoid) Type) : @add_monoid.fg.{0} (finset.{0} pos) (@function.extfun_app.{2 1} Type add_monoid.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type add_monoid.{0}) Type h0) (finset.{0} pos))  := sorry --non-trivial
lemma new_lemma_64141 (h0 : semiring (has_union (has_norm congr_arg_kind))) : is_noetherian_ring (has_union (has_norm congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_64142 (h0 : topological_space (complete_distrib_lattice num)) : normal_space (complete_distrib_lattice num) := sorry --non-trivial
lemma new_lemma_64143 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_add_cyclic.{0} to_additive.value_type (@function.extfun_app.{2 1} Type add_group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 add_group.{0}) to_additive.value_type)  := sorry --non-trivial
lemma new_lemma_64144 (h0 : set (has_compl (mul_one_class (normed_field string_imp)))) : set.subsingleton h0 := sorry --non-trivial
lemma new_lemma_64145 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @group.fg.{0} (has_add.{0} name) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (has_add.{0} name))  := sorry --non-trivial
lemma new_lemma_64146 (h0 : group (finset (has_add pos))) : normalizer_condition (finset (has_add pos)) := sorry --non-trivial
lemma new_lemma_64147 (h0 : topological_space (has_zero (has_add Type))) : irreducible_space (has_zero (has_add Type)) := sorry --non-trivial
lemma new_lemma_64148 (h0 : function.extfun Type complete_lattice) : @is_atomistic.{0} (non_assoc_semiring.{0} num) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (non_assoc_semiring.{0} num))  := sorry --non-trivial
lemma new_lemma_64149 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @add_monoid.fg.{0} (has_zero.{0} name) (@function.extfun_app.{2 1} Type add_monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 add_monoid.{0}) (has_zero.{0} name))  := sorry --non-trivial
lemma new_lemma_64150 (h0 : complete_lattice (complete_semilattice_Sup (has_top to_additive.value_type))) : complete_lattice.is_Sup_finite_compact (complete_semilattice_Sup (has_top to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_64151 (h0 : topological_space (ordered_comm_ring (sub_neg_monoid pos))) : locally_compact_space (ordered_comm_ring (sub_neg_monoid pos)) := sorry --non-trivial
lemma new_lemma_64152 (h0 : ring (add_comm_monoid pos)) : is_domain (add_comm_monoid pos) := sorry --non-trivial
lemma new_lemma_64153 (h0 : functor.add_const (ring (add_left_cancel_semigroup unsigned)) empty) : @is_principal_ideal_ring.{0} (add_left_cancel_semigroup.{0} unsigned) (@functor.add_const.run.{0 0} (ring.{0} (add_left_cancel_semigroup.{0} unsigned)) empty h0)  := sorry --non-trivial
lemma new_lemma_64154 (h0 : ring (is_R_or_C (option unsigned))) : rank_condition (is_R_or_C (option unsigned)) := sorry --non-trivial
lemma new_lemma_64155 (h0 : not (topological_space (mul_one_class linarith.comp_source) -> false)) : @path_connected_space.{0} (mul_one_class.{0} linarith.comp_source) (@classical.by_contradiction'.{1} (topological_space.{0} (mul_one_class.{0} linarith.comp_source)) h0)  := sorry --non-trivial
lemma new_lemma_64156 (h0 : functor.add_const (topological_space (canonically_ordered_comm_semiring name)) name) : @preconnected_space.{0} (canonically_ordered_comm_semiring.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (canonically_ordered_comm_semiring.{0} name)) name h0)  := sorry --non-trivial
lemma new_lemma_64157 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @normal_space.{0} (has_pos_part.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_pos_part.{0} pos))  := sorry --non-trivial
lemma new_lemma_64158 (h0 : topological_space (has_add (has_add pos))) : normal_space (has_add (has_add pos)) := sorry --non-trivial
lemma new_lemma_64159 (h0 : set (nondiscrete_normed_field (mul_one_class linarith.ineq))) : set.finite h0 := sorry --non-trivial
lemma new_lemma_64160 (h0 : ring (has_nnnorm environment.projection_info)) : strong_rank_condition (has_nnnorm environment.projection_info) := sorry --non-trivial
lemma new_lemma_64161 (h0 : topological_space (generalized_boolean_algebra (ring Type))) : locally_compact_space (generalized_boolean_algebra (ring Type)) := sorry --non-trivial
lemma new_lemma_64162 (h0 : cancel_comm_monoid_with_zero (canonically_ordered_add_monoid empty)) : unique_factorization_monoid (canonically_ordered_add_monoid empty) := sorry --non-trivial
lemma new_lemma_64163 (h0 : functor.add_const (add_group (ring Type)) environment.implicit_infer_kind) : @is_add_cyclic.{1} (ring.{1} Type) (@functor.add_const.run.{1 0} (add_group.{1} (ring.{1} Type)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_64164 (h0 : ordered_add_comm_monoid (canonically_ordered_comm_semiring (has_add ennreal))) : archimedean (canonically_ordered_comm_semiring (has_add ennreal)) := sorry --non-trivial
lemma new_lemma_64165 (h0 : function.extfun (finset Type) (has_mem.mem (with_bot fun_info))) : @is_compactly_generated.{0} (with_bot.{0} fun_info) (@finset.pi.empty.{1 0} Type complete_lattice.{0} (with_bot.{0} fun_info) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (with_bot.{0} fun_info)) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_64166 (h1 : topological_space (complete_semilattice_Sup string_imp)) : locally_compact_space (complete_semilattice_Sup string_imp) := sorry --non-trivial
lemma new_lemma_64167 (h0 : topological_space (is_R_or_C congr_arg_kind)) : normal_space (is_R_or_C congr_arg_kind) := sorry --non-trivial
lemma new_lemma_64168 (h0 : complete_lattice (complete_linear_order (semiring (semiring unsigned)))) : is_compactly_generated (complete_linear_order (semiring (semiring unsigned))) := sorry --non-trivial
lemma new_lemma_64169 (h0 : list (has_neg (has_add (has_add (has_add unsigned))))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_64170 (h0 : ring (id empty)) : is_domain (id empty) := sorry --non-trivial
lemma new_lemma_64171 (h0 : not (topological_space (semi_normed_comm_ring fun_info) -> false)) : @t0_space.{0} (semi_normed_comm_ring.{0} fun_info) (@classical.by_contradiction'.{1} (topological_space.{0} (semi_normed_comm_ring.{0} fun_info)) h0)  := sorry --non-trivial
lemma new_lemma_64172 (h0 : add_group (dlist linarith.ineq)) : is_add_cyclic (dlist linarith.ineq) := sorry --non-trivial
lemma new_lemma_64173 (h0 : functor.add_const (finset (boolean_algebra pos)) linarith.comp) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_64174 (h0 : ring (non_unital_non_assoc_semiring string_imp)) : strong_rank_condition (non_unital_non_assoc_semiring string_imp) := sorry --non-trivial
lemma new_lemma_64175 (h0 : function.extfun ((Type -> Type) -> Type 1) (function.extfun (Type -> Type))) : @totally_separated_space.{0} fun_info (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) (@function.extfun_app.{3 2} ((Type → Type) → Type 1) (function.extfun.{2 2} (Type → Type)) h0 (function.extfun.{2 1} Type)) topological_space.{0}) fun_info)  := sorry --non-trivial
lemma new_lemma_64176 (h0 : topological_space (canonically_linear_ordered_monoid num)) : normal_space (canonically_linear_ordered_monoid num) := sorry --non-trivial
lemma new_lemma_64177 (h0 : list (semi_normed_comm_ring (has_norm (has_ssubset fun_info)))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_64178 (h0 : finset (mul_zero_class num)) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_64179 (h0 : filter (option (mul_zero_class unsigned))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_64180 (h0 : fin has_zero.zero) : @is_compactly_generated.{0} (finset.{0} linarith.comp) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@matrix.vec_empty.{1} (function.extfun.{2 1} Type complete_lattice.{0}) h0) (finset.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_64181 (h4 : ring (fintype to_additive.value_type)) : is_domain (fintype to_additive.value_type) := sorry --non-trivial
lemma new_lemma_64182 (h0 : function.extfun Type monoid) : @monoid.fg.{0} (with_bot.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type monoid.{0} h0 (with_bot.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_64183 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @normalizer_condition.{0} (comm_semigroup.{0} real) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (comm_semigroup.{0} real))  := sorry --non-trivial
lemma new_lemma_64184 (h0 : functor.add_const (filter (ring unsigned)) name) : filter.ne_bot (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_64185 (h0 : topological_space (normed_group (has_top num))) : t0_space (normed_group (has_top num)) := sorry --non-trivial
lemma new_lemma_64186 (h0 : topological_space (with_zero (random_gen (has_ssubset (random_gen fun_info))))) : path_connected_space (with_zero (random_gen (has_ssubset (random_gen fun_info)))) := sorry --non-trivial
lemma new_lemma_64187 (h0 : function.extfun Type cancel_comm_monoid_with_zero) : @unique_factorization_monoid.{0} (has_bot.{0} name) (@function.extfun_app.{2 1} Type cancel_comm_monoid_with_zero.{0} h0 (has_bot.{0} name))  := sorry --non-trivial
lemma new_lemma_64188 (h0 : ring (add_left_cancel_monoid to_additive.value_type)) : is_domain (add_left_cancel_monoid to_additive.value_type) := sorry --non-trivial
lemma new_lemma_64189 (h1 : complete_lattice (distrib (has_append linarith.comp_source))) : complete_lattice.is_Sup_finite_compact (distrib (has_append linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_64190 (h0 : add_group (with_bot (has_inv to_additive.value_type))) : is_add_cyclic (with_bot (has_inv to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_64191 (h0 : filter (has_nndist (finset unsigned))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_64192 (h0 : functor.add_const (group (boolean_algebra name)) linarith.comp) : @group.fg.{0} (boolean_algebra.{0} name) (@functor.add_const.run.{0 0} (group.{0} (boolean_algebra.{0} name)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_64193 (h0 : topological_space (normed_comm_ring (finset linarith.comp))) : t1_space (normed_comm_ring (finset linarith.comp)) := sorry --non-trivial
lemma new_lemma_64194 (h0 : topological_space (cancel_monoid (finset (has_nndist (add_comm_monoid ennreal))))) : path_connected_space (cancel_monoid (finset (has_nndist (add_comm_monoid ennreal)))) := sorry --non-trivial
lemma new_lemma_64195 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @irreducible_space.{0} (semiring.{0} fun_info) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (semiring.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_64196 (h0 : topological_space (normed_lattice_add_comm_group (has_add (has_add (has_Inf real))))) : regular_space (normed_lattice_add_comm_group (has_add (has_add (has_Inf real)))) := sorry --non-trivial
lemma new_lemma_64197 (h0 : topological_space (metric_space (semiring linarith.comp))) : preirreducible_space (metric_space (semiring linarith.comp)) := sorry --non-trivial
lemma new_lemma_64198 (h0 : semiring (add_cancel_monoid (normed_comm_ring name))) : is_noetherian_ring (add_cancel_monoid (normed_comm_ring name)) := sorry --non-trivial
lemma new_lemma_64199 (h1 : filter (encodable to_additive.value_type)) : filter.ne_bot h1 := sorry --non-trivial
lemma new_lemma_64200 (h0 : topological_space (ring (has_neg linarith.comp))) : preirreducible_space (ring (has_neg linarith.comp)) := sorry --non-trivial
lemma new_lemma_64201 (h0 : pseudo_metric_space fun_info) (h1 : add_monoid fun_info) : has_lipschitz_add fun_info := sorry --non-trivial
lemma new_lemma_64202 (h0 : fin has_zero.zero) : @has_exists_mul_of_le.{1} (has_bot.{1} Type) (@matrix.vec_empty.{1} (ordered_comm_monoid.{1} (has_bot.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_64203 (h0 : function.extfun Type topological_space) : @t0_space.{0} (has_neg.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_neg.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_64204 (h0 : topological_space (semigroup (has_add environment.implicit_infer_kind))) : totally_separated_space (semigroup (has_add environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_64205 (h0 : ordered_comm_monoid (has_neg ennreal)) : has_exists_mul_of_le (has_neg ennreal) := sorry --non-trivial
lemma new_lemma_64206 (h0 : functor.add_const (ordered_comm_monoid (has_to_string unsigned)) (boolean_algebra linarith.comp)) : @has_exists_mul_of_le.{0} (has_to_string.{0} unsigned) (@functor.add_const.run.{0 0} (ordered_comm_monoid.{0} (has_to_string.{0} unsigned)) (boolean_algebra.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_64207 (h0 : list (has_neg_part (option pos))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_64208 (h0 : ring (id (has_norm num))) : rank_condition (id (has_norm num)) := sorry --non-trivial
lemma new_lemma_64209 (h0 : functor.add_const (functor.add_const Prop (has_nndist linarith.comp)) name) : functor.add_const.run (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_64210 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_principal_ideal_ring.{0} (monoid_with_zero.{0} unsigned) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (monoid_with_zero.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_64211 (h0 : fin has_zero.zero) : @is_principal_ideal_ring.{0} (has_bot.{0} real) (@function.extfun_app.{2 1} Type ring.{0} (@matrix.vec_empty.{1} (function.extfun.{2 1} Type ring.{0}) h0) (has_bot.{0} real))  := sorry --non-trivial
lemma new_lemma_64212 (h0 : function.extfun Type topological_space) : @loc_path_connected_space.{0} (linear_ordered_cancel_comm_monoid.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (linear_ordered_cancel_comm_monoid.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_64213 (h0 : add_group (has_nnnorm (has_compl linarith.comp_source))) : is_add_cyclic (has_nnnorm (has_compl linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_64214 (h0 : ordered_comm_monoid (generalized_boolean_algebra (finset (has_add pos)))) : has_exists_mul_of_le (generalized_boolean_algebra (finset (has_add pos))) := sorry --non-trivial
lemma new_lemma_64215 (h0 : topological_space (normed_group (semiring num))) : totally_separated_space (normed_group (semiring num)) := sorry --non-trivial
lemma new_lemma_64216 (h0 : topological_space (add_comm_monoid name)) : sequential_space (add_comm_monoid name) := sorry --non-trivial
lemma new_lemma_64217 (h0 : ring (comm_semigroup (has_add (sub_neg_monoid real)))) : strong_rank_condition (comm_semigroup (has_add (sub_neg_monoid real))) := sorry --non-trivial
lemma new_lemma_64218 (h0 : ring (monoid_with_zero (option ennreal))) : is_domain (monoid_with_zero (option ennreal)) := sorry --non-trivial
lemma new_lemma_64219 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @preirreducible_space.{0} (ordered_comm_ring.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (ordered_comm_ring.{0} name))  := sorry --non-trivial
lemma new_lemma_64220 (h0 : functor.add_const (topological_space (has_neg pos)) linarith.comp) : @loc_path_connected_space.{0} (has_neg.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (has_neg.{0} pos)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_64221 (h0 : topological_space (has_dist (option (option (option num))))) : t0_space (has_dist (option (option (option num)))) := sorry --non-trivial
lemma new_lemma_64222 (h0 : functor.add_const (topological_space (finset Type)) name) : @normal_space.{1} (finset.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (finset.{1} Type)) name h0)  := sorry --non-trivial
lemma new_lemma_64223 (h0 : list (random_gen congr_arg_kind)) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_64224 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @complete_lattice.is_Sup_finite_compact.{0} (ordered_cancel_add_comm_monoid.{0} empty) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (ordered_cancel_add_comm_monoid.{0} empty))  := sorry --non-trivial
lemma new_lemma_64225 (h0 : add_group (boolean_algebra.core (has_add name))) : is_add_cyclic (boolean_algebra.core (has_add name)) := sorry --non-trivial
lemma new_lemma_64226 (h0 : function.extfun nat fin) : @t1_space.{0} (has_add.{0} real) (@matrix.vec_empty.{0} (topological_space.{0} (has_add.{0} real)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_64227 (h0 : uniform_space (left_cancel_monoid (semiring unsigned))) : complete_space (left_cancel_monoid (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_64228 (h0 : functor.add_const (topological_space (has_zero environment.implicit_infer_kind)) pos) : @totally_disconnected_space.{0} (has_zero.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (has_zero.{0} environment.implicit_infer_kind)) pos h0)  := sorry --non-trivial
lemma new_lemma_64229 (h0 : topological_space (omega_complete_partial_order empty)) : locally_compact_space (omega_complete_partial_order empty) := sorry --non-trivial
lemma new_lemma_64230 (h0 : function.extfun Type group) : @group.fg.{0} (comm_group.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type group.{0} h0 (comm_group.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_64231 (h0 : topological_space (has_nndist (has_Inf (finset pos)))) : loc_path_connected_space (has_nndist (has_Inf (finset pos))) := sorry --non-trivial
lemma new_lemma_64232 (h0 : uniform_space (pseudo_metric_space congr_arg_kind)) : complete_space (pseudo_metric_space congr_arg_kind) := sorry --non-trivial
lemma new_lemma_64233 (h0 : topological_space (monoid unsigned)) : locally_compact_space (monoid unsigned) := sorry --non-trivial
lemma new_lemma_64234 (h0 : functor.add_const (ring (ordered_ring congr_arg_kind)) unsigned) : @is_domain.{0} (ordered_ring.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (ring.{0} (ordered_ring.{0} congr_arg_kind)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_64235 (h1 : topological_space (with_bot linarith.comp_source)) : totally_disconnected_space (with_bot linarith.comp_source) := sorry --non-trivial
lemma new_lemma_64236 (h0 : list (option (comm_group pos))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_64237 (h0 : function.extfun Type ordered_comm_monoid) : @has_exists_mul_of_le.{0} (has_add.{0} ennreal) (@function.extfun_app.{2 1} Type ordered_comm_monoid.{0} h0 (has_add.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_64238 (h0 : ordered_add_comm_monoid (add_comm_monoid empty)) : archimedean (add_comm_monoid empty) := sorry --non-trivial
lemma new_lemma_64239 (h0 : topological_space (complete_distrib_lattice (has_add (has_add pos)))) : normal_space (complete_distrib_lattice (has_add (has_add pos))) := sorry --non-trivial
lemma new_lemma_64240 (h0 : functor.add_const (cancel_comm_monoid_with_zero (add_semigroup unsigned)) empty) : @unique_factorization_monoid.{0} (add_semigroup.{0} unsigned) (@functor.add_const.run.{0 0} (cancel_comm_monoid_with_zero.{0} (add_semigroup.{0} unsigned)) empty h0)  := sorry --non-trivial
lemma new_lemma_64241 (h0 : not (topological_space (has_norm (has_norm unsigned)) -> false)) : @locally_compact_space.{0} (has_norm.{0} (has_norm.{0} unsigned)) (@classical.by_contradiction'.{1} (topological_space.{0} (has_norm.{0} (has_norm.{0} unsigned))) h0)  := sorry --non-trivial
lemma new_lemma_64242 (h0 : function.extfun Type complete_lattice) : @is_compactly_generated.{0} (non_assoc_semiring.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (non_assoc_semiring.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_64243 (h0 : fin has_zero.zero) : @is_atomistic.{0} (has_Inf.{0} real) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@matrix.vec_empty.{1} (function.extfun.{2 1} Type complete_lattice.{0}) h0) (has_Inf.{0} real))  := sorry --non-trivial
lemma new_lemma_64244 (h0 : complete_lattice (linear_ordered_add_comm_group linarith.comp_source)) : complete_lattice.is_Sup_finite_compact (linear_ordered_add_comm_group linarith.comp_source) := sorry --non-trivial
lemma new_lemma_64245 (h0 : function.extfun Type (functor.add_const (topological_space pos))) : @path_connected_space.{0} pos (@functor.add_const.run.{0 0} (topological_space.{0} pos) ennreal (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (topological_space.{0} pos)) h0 ennreal))  := sorry --non-trivial
lemma new_lemma_64246 (h0 : functor.add_const (add_monoid (has_to_string linarith.comp)) Type) : @add_monoid.fg.{0} (has_to_string.{0} linarith.comp) (@functor.add_const.run.{0 1} (add_monoid.{0} (has_to_string.{0} linarith.comp)) Type h0)  := sorry --non-trivial
lemma new_lemma_64247 (h0 : function.extfun Type (prod (add_right_cancel_monoid congr_arg_kind))) : id_rel (function.extfun_app h0 (add_right_cancel_monoid congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_64248 (h0 : not (topological_space (has_add linarith.ineq) -> false)) : @t0_space.{0} (has_add.{0} linarith.ineq) (@classical.by_contradiction'.{1} (topological_space.{0} (has_add.{0} linarith.ineq)) h0)  := sorry --non-trivial
lemma new_lemma_64249 (h0 : function.extfun Type ordered_add_comm_monoid) : @archimedean.{0} (preorder.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type ordered_add_comm_monoid.{0} h0 (preorder.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_64250 (h0 : set (set (has_ssubset linarith.comp_source))) (h1 : set (has_ssubset linarith.comp_source)) : measurable_space.dynkin_system.generate_has h0 h1 := sorry --non-trivial
lemma new_lemma_64251 (h0 : filter (has_neg_part (comm_group ennreal))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_64252 (h0 : functor.add_const (add_group (ring environment.implicit_infer_kind)) Type) : @is_add_cyclic.{0} (ring.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 1} (add_group.{0} (ring.{0} environment.implicit_infer_kind)) Type h0)  := sorry --non-trivial
lemma new_lemma_64253 (h0 : function.extfun Type list) : palindrome (function.extfun_app h0 (has_neg congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_64254 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @complete_space.{0} (linear_ordered_add_comm_group.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type uniform_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 uniform_space.{0}) (linear_ordered_add_comm_group.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_64255 (h0 : functor.add_const (ring (generalized_boolean_algebra Type)) (has_to_string pos)) : @strong_rank_condition.{1} (generalized_boolean_algebra.{1} Type) (@functor.add_const.run.{1 0} (ring.{1} (generalized_boolean_algebra.{1} Type)) (has_to_string.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_64256 (h0 : functor.add_const Prop (add_comm_monoid (option (option (option (option (option (option ennreal)))))))) : functor.add_const.run h0 := sorry --non-trivial
lemma new_lemma_64257 (h0 : add_group (comm_group (option name))) : is_add_cyclic (comm_group (option name)) := sorry --non-trivial
lemma new_lemma_64258 (h0 : complete_lattice (linear_ordered_comm_group congr_arg_kind)) : complete_lattice.is_Sup_finite_compact (linear_ordered_comm_group congr_arg_kind) := sorry --non-trivial
lemma new_lemma_64259 (h0 : functor.add_const (topological_space (normed_comm_ring unsigned)) Type) : @irreducible_space.{0} (normed_comm_ring.{0} unsigned) (@functor.add_const.run.{0 1} (topological_space.{0} (normed_comm_ring.{0} unsigned)) Type h0)  := sorry --non-trivial
lemma new_lemma_64260 (h0 : topological_space (preorder unsigned)) : path_connected_space (preorder unsigned) := sorry --non-trivial
lemma new_lemma_64261 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @complete_space.{0} (linear_ordered_comm_group.{0} num) (@function.extfun_app.{2 1} Type uniform_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 uniform_space.{0}) (linear_ordered_comm_group.{0} num))  := sorry --non-trivial
lemma new_lemma_64262 (h0 : functor.add_const (topological_space (has_zero name)) linarith.comp) : @discrete_topology.{0} (has_zero.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (has_zero.{0} name)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_64263 (h0 : ring (uniform_space (uniform_space linarith.ineq))) : strong_rank_condition (uniform_space (uniform_space linarith.ineq)) := sorry --non-trivial
lemma new_lemma_64264 (h0 : function.extfun Type topological_space) : @irreducible_space.{0} (comm_group.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (comm_group.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_64265 (h1 : group to_additive.value_type) : is_cyclic to_additive.value_type := sorry --non-trivial
lemma new_lemma_64266 (h0 : complete_lattice (random_gen (random_gen num))) : is_compactly_generated (random_gen (random_gen num)) := sorry --non-trivial
lemma new_lemma_64267 (h1 : filter (measurable_space linarith.comp)) : filter.ne_bot h1 := sorry --non-trivial
lemma new_lemma_64268 (h0 : filter (with_bot (has_inv (with_bot (has_top (with_bot (random_gen to_additive.value_type))))))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_64269 (h0 : has_norm (semiring empty) -> has_norm (semiring empty) -> Prop) : is_strict_order (has_norm (semiring empty)) h0 := sorry --non-trivial
lemma new_lemma_64270 (h0 : topological_space (is_R_or_C num)) : topological_space.separable_space (is_R_or_C num) := sorry --non-trivial
lemma new_lemma_64271 (h0 : topological_space (has_neg_part (has_neg_part ennreal))) : topological_space.separable_space (has_neg_part (has_neg_part ennreal)) := sorry --non-trivial
lemma new_lemma_64272 (h0 : function.extfun Type monoid) : @monoid.fg.{0} (measurable_space.{0} unsigned) (@function.extfun_app.{2 1} Type monoid.{0} h0 (measurable_space.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_64273 (h0 : topological_space (with_bot (has_union linarith.comp))) : discrete_topology (with_bot (has_union linarith.comp)) := sorry --non-trivial
lemma new_lemma_64274 (h0 : group (has_nndist (has_add (has_add (has_nndist name))))) : is_cyclic (has_nndist (has_add (has_add (has_nndist name)))) := sorry --non-trivial
lemma new_lemma_64275 (h0 : functor.add_const (topological_space (ordered_ring congr_arg_kind)) congr_arg_kind) : @topological_space.separable_space.{0} (ordered_ring.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (ordered_ring.{0} congr_arg_kind)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_64276 (h0 : topological_space (as_linear_order (option (option empty)))) : totally_separated_space (as_linear_order (option (option empty))) := sorry --non-trivial
lemma new_lemma_64277 (h0 : topological_space (canonically_ordered_comm_semiring (ring (has_to_string ennreal)))) : totally_separated_space (canonically_ordered_comm_semiring (ring (has_to_string ennreal))) := sorry --non-trivial
lemma new_lemma_64278 (h0 : not (group (has_compl reducibility_hints) -> false)) : @is_cyclic.{0} (has_compl.{0} reducibility_hints) (@classical.by_contradiction'.{1} (group.{0} (has_compl.{0} reducibility_hints)) h0)  := sorry --non-trivial
lemma new_lemma_64279 (h1 : group (div_inv_monoid (has_nnnorm (has_nnnorm char)))) : is_cyclic (div_inv_monoid (has_nnnorm (has_nnnorm char))) := sorry --non-trivial
lemma new_lemma_64280 (h0 : topological_space (monoid pos)) : totally_separated_space (monoid pos) := sorry --non-trivial
lemma new_lemma_64281 (h0 : uniform_space (boolean_algebra (has_to_string (has_neg (group_with_zero pos))))) : separated_space (boolean_algebra (has_to_string (has_neg (group_with_zero pos)))) := sorry --non-trivial
lemma new_lemma_64282 (h0 : fin has_zero.zero) : @normal_space.{0} (add_comm_monoid.{0} real) (@matrix.vec_empty.{0} (topological_space.{0} (add_comm_monoid.{0} real)) h0)  := sorry --non-trivial
lemma new_lemma_64283 (h0 : function.extfun Type group) : @group.fg.{0} real.angle (@function.extfun_app.{2 1} Type group.{0} h0 real.angle)  := sorry --non-trivial
lemma new_lemma_64284 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @group.fg.{0} (has_top.{0} linarith.comp) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (has_top.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_64285 (h0 : uniform_space (ordered_comm_ring (has_add name))) : separated_space (ordered_comm_ring (has_add name)) := sorry --non-trivial
lemma new_lemma_64286 (h0 : topological_space (linear_ordered_comm_group (option unsigned))) : topological_space.separable_space (linear_ordered_comm_group (option unsigned)) := sorry --non-trivial
lemma new_lemma_64287 (h0 : complete_lattice (canonically_ordered_monoid (has_Inf name))) : complete_lattice.is_Sup_finite_compact (canonically_ordered_monoid (has_Inf name)) := sorry --non-trivial
lemma new_lemma_64288 (h0 : function.extfun Type (functor.comp list has_nndist)) : palindrome (functor.comp.run (function.extfun_app h0 ennreal)) := sorry --non-trivial
lemma new_lemma_64289 (h0 : not (topological_space (has_append reducibility_hints) -> false)) : @t0_space.{0} (has_append.{0} reducibility_hints) (@classical.by_contradiction'.{1} (topological_space.{0} (has_append.{0} reducibility_hints)) h0)  := sorry --non-trivial
lemma new_lemma_64290 (h0 : group (boolean_algebra.core (has_add (semigroup Type)))) : is_cyclic (boolean_algebra.core (has_add (semigroup Type))) := sorry --non-trivial
lemma new_lemma_64291 (h0 : topological_space (has_nndist (has_add environment.implicit_infer_kind))) : regular_space (has_nndist (has_add environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_64292 (h0 : topological_space (normed_lattice_add_comm_group name)) : topological_space.separable_space (normed_lattice_add_comm_group name) := sorry --non-trivial
lemma new_lemma_64293 (h0 : complete_lattice (add_cancel_comm_monoid (option unsigned))) : is_compactly_generated (add_cancel_comm_monoid (option unsigned)) := sorry --non-trivial
lemma new_lemma_64294 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_compactly_generated.{0} (ordered_comm_ring.{0} linarith.comp) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (ordered_comm_ring.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_64295 (h0 : add_monoid (canonically_linear_ordered_monoid (has_add Type))) : add_monoid.fg (canonically_linear_ordered_monoid (has_add Type)) := sorry --non-trivial
lemma new_lemma_64296 (h0 : has_neg (nondiscrete_normed_field linarith.ineq)) (h2 : measurable_space (nondiscrete_normed_field linarith.ineq)) : has_measurable_neg (nondiscrete_normed_field linarith.ineq) := sorry --non-trivial
lemma new_lemma_64297 (h0 : topological_space (semigroup (normed_comm_ring environment.implicit_infer_kind))) : irreducible_space (semigroup (normed_comm_ring environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_64298 (h0 : topological_space (non_unital_non_assoc_semiring std_gen)) (h1 : preorder (non_unital_non_assoc_semiring std_gen)) : order_topology (non_unital_non_assoc_semiring std_gen) := sorry --non-trivial
lemma new_lemma_64299 (h0 : ring (comm_ring (metric_space char))) : strong_rank_condition (comm_ring (metric_space char)) := sorry --non-trivial
lemma new_lemma_64300 (h0 : function.extfun Type group) : @is_cyclic.{0} (complete_distrib_lattice.{0} pos) (@function.extfun_app.{2 1} Type group.{0} h0 (complete_distrib_lattice.{0} pos))  := sorry --non-trivial
lemma new_lemma_64301 (h1 : ring (distrib linarith.ineq)) : strong_rank_condition (distrib linarith.ineq) := sorry --non-trivial
lemma new_lemma_64302 (h0 : topological_space (has_norm (has_top empty))) : preirreducible_space (has_norm (has_top empty)) := sorry --non-trivial
lemma new_lemma_64303 (h0 : function.extfun Type topological_space) : @preconnected_space.{0} (finset.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (finset.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_64304 (h0 : topological_space (has_norm (semiring (semiring linarith.comp)))) : totally_separated_space (has_norm (semiring (semiring linarith.comp))) := sorry --non-trivial
lemma new_lemma_64305 (h0 : functor.add_const (topological_space (normed_comm_ring linarith.comp)) pos) : @loc_path_connected_space.{0} (normed_comm_ring.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (normed_comm_ring.{0} linarith.comp)) pos h0)  := sorry --non-trivial
lemma new_lemma_64306 (h0 : function.extfun Type ring) : @rank_condition.{0} (add_cancel_comm_monoid.{0} unsigned) (@function.extfun_app.{2 1} Type ring.{0} h0 (add_cancel_comm_monoid.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_64307 (h0 : function.extfun Type topological_space) : @irreducible_space.{0} (has_inv.{0} string_imp) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_inv.{0} string_imp))  := sorry --non-trivial
lemma new_lemma_64308 (h0 : not (group (has_norm linarith.ineq) -> false)) : @normalizer_condition.{0} (has_norm.{0} linarith.ineq) (@classical.by_contradiction'.{1} (group.{0} (has_norm.{0} linarith.ineq)) h0)  := sorry --non-trivial
lemma new_lemma_64309 (h0 : not (complete_lattice (has_top num) -> false)) : @is_atomistic.{0} (has_top.{0} num) (@classical.by_contradiction'.{1} (complete_lattice.{0} (has_top.{0} num)) h0)  := sorry --non-trivial
lemma new_lemma_64310 (h0 : topological_space (add_cancel_comm_monoid (option (option (option empty))))) : totally_separated_space (add_cancel_comm_monoid (option (option (option empty)))) := sorry --non-trivial
lemma new_lemma_64311 (h0 : not (ring (with_bot linarith.comp_source) -> false)) : @is_domain.{0} (with_bot.{0} linarith.comp_source) (@classical.by_contradiction'.{1} (ring.{0} (with_bot.{0} linarith.comp_source)) h0)  := sorry --non-trivial
lemma new_lemma_64312 (h0 : group (with_one (random_gen (has_nnnorm linarith.comp_source)))) : group.fg (with_one (random_gen (has_nnnorm linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_64313 (h0 : function.extfun Type ring) : @strong_rank_condition.{0} (cancel_monoid.{0} num) (@function.extfun_app.{2 1} Type ring.{0} h0 (cancel_monoid.{0} num))  := sorry --non-trivial
lemma new_lemma_64314 (h0 : topological_space (has_norm (has_inv fun_info))) : t0_space (has_norm (has_inv fun_info)) := sorry --non-trivial
lemma new_lemma_64315 (h0 : function.extfun Type uniform_space) : @complete_space.{0} (with_one.{0} empty) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (with_one.{0} empty))  := sorry --non-trivial
lemma new_lemma_64316 (h0 : complete_lattice (has_star empty)) : is_atomistic (has_star empty) := sorry --non-trivial
lemma new_lemma_64317 (h0 : ring (simple_graph to_additive.value_type)) : is_domain (simple_graph to_additive.value_type) := sorry --non-trivial
lemma new_lemma_64318 (h0 : functor.add_const (group (has_bot linarith.comp)) linarith.comp) : @is_cyclic.{0} (has_bot.{0} linarith.comp) (@functor.add_const.run.{0 0} (group.{0} (has_bot.{0} linarith.comp)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_64319 (h0 : topological_space (canonically_ordered_monoid (has_Inf (has_add linarith.comp)))) : discrete_topology (canonically_ordered_monoid (has_Inf (has_add linarith.comp))) := sorry --non-trivial
lemma new_lemma_64320 (h0 : not (function.extfun Type group -> false)) : @normalizer_condition.{0} real.angle (@function.extfun_app.{2 1} Type group.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type group.{0}) h0) real.angle)  := sorry --non-trivial
lemma new_lemma_64321 (h0 : function.extfun Type topological_space) : @loc_path_connected_space.{0} (add_comm_monoid.{0} real) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (add_comm_monoid.{0} real))  := sorry --non-trivial
lemma new_lemma_64322 (h0 : functor.add_const (complete_lattice (ordered_ring unsigned)) unsigned) : @is_atomistic.{0} (ordered_ring.{0} unsigned) (@functor.add_const.run.{0 0} (complete_lattice.{0} (ordered_ring.{0} unsigned)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_64323 (h1 : not (complete_lattice (mul_one_class string_imp) -> false)) : @is_compactly_generated.{0} (mul_one_class.{0} string_imp) (@classical.by_contradiction'.{1} (complete_lattice.{0} (mul_one_class.{0} string_imp)) h1)  := sorry --non-trivial
lemma new_lemma_64324 (h0 : topological_space (with_bot (has_norm (semiring num)))) : totally_disconnected_space (with_bot (has_norm (semiring num))) := sorry --non-trivial
lemma new_lemma_64325 (h0 : function.extfun Type topological_space) : @loc_path_connected_space.{0} (canonically_ordered_comm_semiring.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (canonically_ordered_comm_semiring.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_64326 (h0 : topological_space (has_zero (has_neg (finset (finset (has_add (has_add (has_pos_part Type)))))))) : regular_space (has_zero (has_neg (finset (finset (has_add (has_add (has_pos_part Type))))))) := sorry --non-trivial
lemma new_lemma_64327 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @monoid.fg.{0} (preorder.{0} unsigned) (@function.extfun_app.{2 1} Type monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 monoid.{0}) (preorder.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_64328 (h0 : function.extfun Type (functor.comp finset has_neg_part)) : finset.nonempty (functor.comp.run (function.extfun_app h0 pos)) := sorry --non-trivial
lemma new_lemma_64329 (h0 : topological_space (comm_group (comm_group pos))) : t1_space (comm_group (comm_group pos)) := sorry --non-trivial
lemma new_lemma_64330 (h0 : not (ring (has_inv linarith.ineq) -> false)) : @rank_condition.{0} (has_inv.{0} linarith.ineq) (@classical.by_contradiction'.{1} (ring.{0} (has_inv.{0} linarith.ineq)) h0)  := sorry --non-trivial
lemma new_lemma_64331 (h0 : function.extfun Type complete_lattice) : @is_atomistic.{0} (complete_distrib_lattice.{0} empty) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (complete_distrib_lattice.{0} empty))  := sorry --non-trivial
lemma new_lemma_64332 (h0 : topological_space (boolean_algebra (semigroup environment.implicit_infer_kind))) : regular_space (boolean_algebra (semigroup environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_64333 (h0 : add_group (pseudo_metric_space (has_nndist name))) : is_add_cyclic (pseudo_metric_space (has_nndist name)) := sorry --non-trivial
lemma new_lemma_64334 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @path_connected_space.{0} (has_inv.{0} linarith.ineq) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_inv.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_64335 (h0 : function.extfun Type semiring) : @is_noetherian_ring.{0} (partial_order.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type semiring.{0} h0 (partial_order.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_64336 (h2 : uniform_space (has_norm to_additive.value_type)) : complete_space (has_norm to_additive.value_type) := sorry --non-trivial
lemma new_lemma_64337 (h0 : cancel_comm_monoid_with_zero (add_right_cancel_monoid (semiring (semiring num)))) : unique_factorization_monoid (add_right_cancel_monoid (semiring (semiring num))) := sorry --non-trivial
lemma new_lemma_64338 (h0 : not (ring (has_sub empty) -> false)) : @is_principal_ideal_ring.{0} (has_sub.{0} empty) (@classical.by_contradiction'.{1} (ring.{0} (has_sub.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_64339 (h0 : ring (normed_field (has_nnnorm (comm_ring linarith.ineq)))) : is_domain (normed_field (has_nnnorm (comm_ring linarith.ineq))) := sorry --non-trivial
lemma new_lemma_64340 (h0 : group (has_bot (has_add (has_add (has_Inf (has_Inf pos)))))) : is_cyclic (has_bot (has_add (has_add (has_Inf (has_Inf pos))))) := sorry --non-trivial
lemma new_lemma_64341 (h0 : topological_space (add_comm_monoid (has_neg name))) : normal_space (add_comm_monoid (has_neg name)) := sorry --non-trivial
lemma new_lemma_64342 (h0 : cancel_comm_monoid_with_zero (has_inter empty)) : unique_factorization_monoid (has_inter empty) := sorry --non-trivial
lemma new_lemma_64343 (h0 : monoid (add_comm_monoid (has_add (comm_group linarith.comp)))) : monoid.fg (add_comm_monoid (has_add (comm_group linarith.comp))) := sorry --non-trivial
lemma new_lemma_64344 (h0 : function.extfun Type ring) : @rank_condition.{0} (canonically_ordered_monoid.{0} name) (@function.extfun_app.{2 1} Type ring.{0} h0 (canonically_ordered_monoid.{0} name))  := sorry --non-trivial
lemma new_lemma_64345 (h0 : functor.add_const (filter (boolean_algebra pos)) linarith.comp) : countable_Inter_filter (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_64346 (h0 : topological_space (semigroup (ring pos))) : sequential_space (semigroup (ring pos)) := sorry --non-trivial
lemma new_lemma_64347 (h0 : add_monoid (ordered_comm_ring (has_add (has_add (boolean_algebra.core Type))))) : add_monoid.fg (ordered_comm_ring (has_add (has_add (boolean_algebra.core Type)))) := sorry --non-trivial
lemma new_lemma_64348 (h0 : functor.add_const (topological_space (has_add real)) real) : @t0_space.{0} (has_add.{0} real) (@functor.add_const.run.{0 0} (topological_space.{0} (has_add.{0} real)) real h0)  := sorry --non-trivial
lemma new_lemma_64349 (h0 : not (topological_space (has_top empty) -> false)) : @topological_space.separable_space.{0} (has_top.{0} empty) (@classical.by_contradiction'.{1} (topological_space.{0} (has_top.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_64350 (h0 : functor.add_const (function.extfun Type finset) name) : finset.nonempty (function.extfun_app (functor.add_const.run h0) (has_nndist pos)) := sorry --non-trivial
lemma new_lemma_64351 (h0 : topological_space (mul_one_class (normed_field std_gen))) : t0_space (mul_one_class (normed_field std_gen)) := sorry --non-trivial
lemma new_lemma_64352 (h0 : topological_space (semigroup (has_add pos))) : totally_separated_space (semigroup (has_add pos)) := sorry --non-trivial
lemma new_lemma_64353 (h0 : topological_space (ring (ring (has_neg Type)))) : totally_separated_space (ring (ring (has_neg Type))) := sorry --non-trivial
lemma new_lemma_64354 (h0 : function.extfun (finset (Type -> Type)) (has_mem.mem monoid)) : @monoid.fg.{0} (with_one.{0} fun_info) (@function.extfun_app.{2 1} Type monoid.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) monoid.{0} (@function.extfun_app.{2 0} (finset.{1} (Type → Type)) (@has_mem.mem.{1 1} (Type → Type) (finset.{1} (Type → Type)) (@finset.has_mem.{1} (Type → Type)) monoid.{0}) h0 (@has_emptyc.emptyc.{1} (finset.{1} (Type → Type)) (@finset.has_emptyc.{1} (Type → Type))))) (with_one.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_64355 (h0 : functor.comp ordered_add_comm_monoid complete_distrib_lattice name) : @archimedean.{0} (complete_distrib_lattice.{0} name) (@functor.comp.run.{0 0 0} ordered_add_comm_monoid.{0} complete_distrib_lattice.{0} name h0)  := sorry --non-trivial
lemma new_lemma_64356 (h2 : group (has_norm linarith.comp_source)) : group.fg (has_norm linarith.comp_source) := sorry --non-trivial
lemma new_lemma_64357 (h0 : function.extfun (nat -> Type) (function.extfun nat)) : @loc_path_connected_space.{1} (ordered_comm_ring.{1} Type) (@matrix.vec_empty.{1} (topological_space.{1} (ordered_comm_ring.{1} Type)) (@function.extfun_app.{1 1} nat fin (@function.extfun_app.{2 1} (nat → Type) (function.extfun.{1 1} nat) h0 fin) (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_64358 (h0 : not (topological_space (measurable_space linarith.comp) -> false)) : @discrete_topology.{0} (measurable_space.{0} linarith.comp) (@classical.by_contradiction'.{1} (topological_space.{0} (measurable_space.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_64359 (h0 : complete_lattice (boolean_algebra (has_add (has_add (has_bot real))))) : complete_lattice.is_Sup_finite_compact (boolean_algebra (has_add (has_add (has_bot real)))) := sorry --non-trivial
lemma new_lemma_64360 (h0 : has_mem.mem (linear_ordered_add_comm_group num) has_emptyc.emptyc) : @totally_disconnected_space.{0} (linear_ordered_add_comm_group.{0} num) (@finset.pi.empty.{1 0} Type topological_space.{0} (linear_ordered_add_comm_group.{0} num) h0)  := sorry --non-trivial
lemma new_lemma_64361 (h0 : add_group (has_zero (finset name))) : is_add_cyclic (has_zero (finset name)) := sorry --non-trivial
lemma new_lemma_64362 (h0 : functor.add_const (topological_space (ring linarith.comp)) linarith.comp) : @path_connected_space.{0} (ring.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (ring.{0} linarith.comp)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_64363 (h0 : topological_space (has_nndist (has_pos_part (has_Inf linarith.comp)))) : t0_space (has_nndist (has_pos_part (has_Inf linarith.comp))) := sorry --non-trivial
lemma new_lemma_64364 (h0 : filter (boolean_algebra (has_add (finset pos)))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_64365 (h1 : topological_space (nondiscrete_normed_field ereal)) (h2 : add_group (nondiscrete_normed_field ereal)) : topological_add_group (nondiscrete_normed_field ereal) := sorry --non-trivial
lemma new_lemma_64366 (h0 : group (has_emptyc (has_norm num))) : normalizer_condition (has_emptyc (has_norm num)) := sorry --non-trivial
lemma new_lemma_64367 (h0 : topological_space (sub_neg_monoid linarith.comp)) : path_connected_space (sub_neg_monoid linarith.comp) := sorry --non-trivial
lemma new_lemma_64368 (h0 : functor.add_const (function.extfun (Type 1) cancel_comm_monoid_with_zero) Type) : @unique_factorization_monoid.{1} (add_comm_monoid.{1} Type) (@function.extfun_app.{3 2} (Type 1) cancel_comm_monoid_with_zero.{1} (@functor.add_const.run.{2 1} (function.extfun.{3 2} (Type 1) cancel_comm_monoid_with_zero.{1}) Type h0) (add_comm_monoid.{1} Type))  := sorry --non-trivial
lemma new_lemma_64369 (h1 : not (complete_lattice (dlist fun_info) -> false)) : @is_compactly_generated.{0} (dlist.{0} fun_info) (@classical.by_contradiction'.{1} (complete_lattice.{0} (dlist.{0} fun_info)) h1)  := sorry --non-trivial
lemma new_lemma_64370 (h0 : functor.add_const (monoid (normed_comm_ring environment.implicit_infer_kind)) name) : @monoid.fg.{0} (normed_comm_ring.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (monoid.{0} (normed_comm_ring.{0} environment.implicit_infer_kind)) name h0)  := sorry --non-trivial
lemma new_lemma_64371 (h0 : group (complete_linear_order congr_arg_kind)) : group.fg (complete_linear_order congr_arg_kind) := sorry --non-trivial
lemma new_lemma_64372 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @complete_lattice.is_Sup_finite_compact.{0} (complete_distrib_lattice.{0} pos) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (complete_distrib_lattice.{0} pos))  := sorry --non-trivial
lemma new_lemma_64373 (h0 : functor.add_const (topological_space (ring Type)) name) : @irreducible_space.{1} (ring.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (ring.{1} Type)) name h0)  := sorry --non-trivial
lemma new_lemma_64374 (h0 : functor.add_const (topological_space (complete_distrib_lattice environment.implicit_infer_kind)) name) : @normal_space.{0} (complete_distrib_lattice.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (complete_distrib_lattice.{0} environment.implicit_infer_kind)) name h0)  := sorry --non-trivial
lemma new_lemma_64375 (h0 : topological_space (has_ssubset (has_ssubset reducibility_hints))) : t0_space (has_ssubset (has_ssubset reducibility_hints)) := sorry --non-trivial
lemma new_lemma_64376 (h0 : filter (has_neg_part (finset ennreal))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_64377 (h0 : not (list (has_top string_imp) -> false)) : list.nodup (classical.by_contradiction' h0) := sorry --non-trivial
lemma new_lemma_64378 (h0 : functor.comp group has_neg Type) : @group.fg.{1} (has_neg.{1} Type) (@functor.comp.run.{1 1 1} group.{1} has_neg.{1} Type h0)  := sorry --non-trivial
lemma new_lemma_64379 (h0 : ring (add_monoid (normed_field (random_gen char)))) : rank_condition (add_monoid (normed_field (random_gen char))) := sorry --non-trivial
lemma new_lemma_64380 (h0 : function.extfun Type topological_space) : @t1_space.{0} (add_cancel_monoid.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (add_cancel_monoid.{0} name))  := sorry --non-trivial
lemma new_lemma_64381 (h1 : uniform_space (add_comm_semigroup (add_comm_semigroup char))) : complete_space (add_comm_semigroup (add_comm_semigroup char)) := sorry --non-trivial
lemma new_lemma_64382 (h0 : fin has_zero.zero) : list.head (matrix.vec_empty h0) := sorry --non-trivial
lemma new_lemma_64383 (h0 : ring (semi_normed_comm_ring (topological_space (has_nnnorm linarith.ineq)))) : is_domain (semi_normed_comm_ring (topological_space (has_nnnorm linarith.ineq))) := sorry --non-trivial
lemma new_lemma_64384 (h0 : ring (linear_ordered_comm_group_with_zero (normed_field fun_info))) : is_domain (linear_ordered_comm_group_with_zero (normed_field fun_info)) := sorry --non-trivial
lemma new_lemma_64385 (h0 : add_group (boolean_algebra (has_neg name))) : is_add_cyclic (boolean_algebra (has_neg name)) := sorry --non-trivial
lemma new_lemma_64386 (h0 : not (filter znum -> false)) : filter.ne_bot (classical.by_contradiction' h0) := sorry --non-trivial
lemma new_lemma_64387 (h0 : monoid (has_star (semiring congr_arg_kind))) : monoid.fg (has_star (semiring congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_64388 (h0 : topological_space (finset environment.implicit_infer_kind)) : t1_space (finset environment.implicit_infer_kind) := sorry --non-trivial
lemma new_lemma_64389 (h0 : function.extfun (multiset (Type -> Type)) (has_mem.mem complete_lattice)) : @is_atomistic.{0} (linear_ordered_add_comm_group.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@multiset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) complete_lattice.{0} (@function.extfun_app.{2 0} (multiset.{1} (Type → Type)) (@has_mem.mem.{1 1} (Type → Type) (multiset.{1} (Type → Type)) (@multiset.has_mem.{1} (Type → Type)) complete_lattice.{0}) h0 (@has_zero.zero.{1} (multiset.{1} (Type → Type)) (@multiset.has_zero.{1} (Type → Type))))) (linear_ordered_add_comm_group.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_64390 (h0 : list (canonically_ordered_add_monoid (option (option (option empty))))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_64391 (h0 : functor.add_const (ordered_add_comm_monoid (comm_group Type)) linarith.comp) : @archimedean.{1} (comm_group.{1} Type) (@functor.add_const.run.{1 0} (ordered_add_comm_monoid.{1} (comm_group.{1} Type)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_64392 (h0 : fin has_zero.zero) : @archimedean.{0} (ordered_comm_ring.{0} real) (@matrix.vec_empty.{0} (ordered_add_comm_monoid.{0} (ordered_comm_ring.{0} real)) h0)  := sorry --non-trivial
lemma new_lemma_64393 (h0 : list (plift (bin_tree unsigned))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_64394 (h0 : group (has_add (finset environment.implicit_infer_kind))) : is_simple_group (has_add (finset environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_64395 (h0 : functor.add_const (topological_space (has_neg_part environment.implicit_infer_kind)) linarith.comp) : @path_connected_space.{0} (has_neg_part.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (has_neg_part.{0} environment.implicit_infer_kind)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_64396 (h0 : function.extfun (Type 1) topological_space) : @totally_disconnected_space.{1} (has_zero.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} h0 (has_zero.{1} Type))  := sorry --non-trivial
lemma new_lemma_64397 (h0 : monoid (boolean_algebra.core (comm_group Type))) : monoid.fg (boolean_algebra.core (comm_group Type)) := sorry --non-trivial
lemma new_lemma_64398 (h0 : function.extfun Type group) : @normalizer_condition.{0} (comm_monoid.{0} empty) (@function.extfun_app.{2 1} Type group.{0} h0 (comm_monoid.{0} empty))  := sorry --non-trivial
lemma new_lemma_64399 (h0 : topological_space (finset (finset (finset (finset name))))) : locally_compact_space (finset (finset (finset (finset name)))) := sorry --non-trivial
lemma new_lemma_64400 (h0 : reducibility_hints -> reducibility_hints -> Prop) (h1 h2 : reducibility_hints) : eqv_gen h0 h1 h2 := sorry --non-trivial
lemma new_lemma_64401 (h0 : monoid (simple_graph (option unsigned))) : monoid.fg (simple_graph (option unsigned)) := sorry --non-trivial
lemma new_lemma_64402 (h0 : function.extfun Type group) : @group.fg.{0} (has_to_string.{0} linarith.comp) (@function.extfun_app.{2 1} Type group.{0} h0 (has_to_string.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_64403 (h0 : function.extfun (Type 1) topological_space) : @t1_space.{1} (has_neg.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} h0 (has_neg.{1} Type))  := sorry --non-trivial
lemma new_lemma_64404 (h1 : ring (nondiscrete_normed_field fun_info)) : strong_rank_condition (nondiscrete_normed_field fun_info) := sorry --non-trivial
lemma new_lemma_64405 (h0 : add_group (boolean_algebra.core (finset environment.implicit_infer_kind))) : is_add_cyclic (boolean_algebra.core (finset environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_64406 : nonempty linarith.comp_source := sorry --simp
lemma new_lemma_64407 (h0 : functor.add_const (topological_space (has_zero unsigned)) unsigned) : @discrete_topology.{0} (has_zero.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (has_zero.{0} unsigned)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_64408 (h0 : not (topological_space (add_right_cancel_monoid unsigned) -> false)) : @locally_compact_space.{0} (add_right_cancel_monoid.{0} unsigned) (@classical.by_contradiction'.{1} (topological_space.{0} (add_right_cancel_monoid.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_64409 (h0 : function.extfun Type topological_space) : @totally_separated_space.{0} (measurable_space.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (measurable_space.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_64410 (h0 : function.extfun Type ring) : @rank_condition.{0} (finset.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type ring.{0} h0 (finset.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_64411 (h0 : function.extfun Type complete_lattice) : @is_compactly_generated.{0} (has_nndist.{0} num) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (has_nndist.{0} num))  := sorry --non-trivial
lemma new_lemma_64412 (h0 : semiring linarith.comp_source) (h1 : ideal linarith.comp_source) : nonempty (ideal.fg h1) := sorry --non-trivial
lemma new_lemma_64413 (h0 : pnat) (h1 : list pnat) (h2 : with_bot (ulower pnat)) (h3 : ne h2 has_bot.bot) : pnat.coprime (list.ilast' h0 h1) (ulower.up (with_bot.unbot h2 h3)) := sorry --non-trivial
lemma new_lemma_64414 (h0 : ring (has_neg_part (add_cancel_monoid name))) : is_domain (has_neg_part (add_cancel_monoid name)) := sorry --non-trivial
lemma new_lemma_64415 (h0 : functor.add_const (function.extfun (Type 1) finset) (has_neg Type)) : finset.nonempty (function.extfun_app (functor.add_const.run h0) (finset Type)) := sorry --non-trivial
lemma new_lemma_64416 (h0 : uniform_space (boolean_algebra.core (option pos))) : separated_space (boolean_algebra.core (option pos)) := sorry --non-trivial
lemma new_lemma_64417 (h0 : function.extfun Type ordered_add_comm_monoid) : @archimedean.{0} (monoid.{0} empty) (@function.extfun_app.{2 1} Type ordered_add_comm_monoid.{0} h0 (monoid.{0} empty))  := sorry --non-trivial
lemma new_lemma_64418 (h0 : function.extfun Type filter) : filter.ne_bot (function.extfun_app h0 (with_one linarith.ineq)) := sorry --non-trivial
lemma new_lemma_64419 (h0 : functor.comp add_monoid ring unsigned) : @add_monoid.fg.{0} (ring.{0} unsigned) (@functor.comp.run.{0 0 0} add_monoid.{0} ring.{0} unsigned h0)  := sorry --non-trivial
lemma new_lemma_64420 (h0 : monoid (denumerable (has_top (has_top (has_top linarith.ineq))))) : monoid.fg (denumerable (has_top (has_top (has_top linarith.ineq)))) := sorry --non-trivial
lemma new_lemma_64421 (h0 : add_group (with_bot (semiring (semiring (semiring num))))) : is_add_cyclic (with_bot (semiring (semiring (semiring num)))) := sorry --non-trivial
lemma new_lemma_64422 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @totally_disconnected_space.{0} (add_group.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (add_group.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_64423 (h0 : topological_space (semi_normed_comm_ring (mul_one_class fun_info))) : path_connected_space (semi_normed_comm_ring (mul_one_class fun_info)) := sorry --non-trivial
lemma new_lemma_64424 (h1 : filter (add_left_cancel_monoid (has_nnnorm char))) : filter.ne_bot h1 := sorry --non-trivial
lemma new_lemma_64425 (h0 : uniform_space (normed_field (mul_one_class char))) : complete_space (normed_field (mul_one_class char)) := sorry --non-trivial
lemma new_lemma_64426 (h0 : list (has_add (has_neg (ring Type)))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_64427 (h0 : group (has_add (semigroup (finset (finset (has_zero Type)))))) : normalizer_condition (has_add (semigroup (finset (finset (has_zero Type))))) := sorry --non-trivial
lemma new_lemma_64428 (h0 : functor.add_const (topological_space (mul_zero_class Type)) pos) : @discrete_topology.{1} (mul_zero_class.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (mul_zero_class.{1} Type)) pos h0)  := sorry --non-trivial
lemma new_lemma_64429 (h0 : function.extfun Type topological_space) : @path_connected_space.{0} (has_bot.{0} real) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_bot.{0} real))  := sorry --non-trivial
lemma new_lemma_64430 (h0 : topological_space (add_right_cancel_monoid linarith.comp)) : locally_compact_space (add_right_cancel_monoid linarith.comp) := sorry --non-trivial
lemma new_lemma_64431 (h0 : not (topological_space (measurable_space.dynkin_system empty) -> false)) : @t0_space.{0} (measurable_space.dynkin_system.{0} empty) (@classical.by_contradiction'.{1} (topological_space.{0} (measurable_space.dynkin_system.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_64432 (h0 : ring (has_compl (has_inv fun_info))) : strong_rank_condition (has_compl (has_inv fun_info)) := sorry --non-trivial
lemma new_lemma_64433 (h0 : functor.add_const (group (is_R_or_C congr_arg_kind)) unsigned) : @group.fg.{0} (is_R_or_C.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (group.{0} (is_R_or_C.{0} congr_arg_kind)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_64434 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @preirreducible_space.{0} (sub_neg_monoid.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (sub_neg_monoid.{0} pos))  := sorry --non-trivial
lemma new_lemma_64435 (h0 : topological_space (generalized_boolean_algebra (has_Inf real))) : regular_space (generalized_boolean_algebra (has_Inf real)) := sorry --non-trivial
lemma new_lemma_64436 (h0 : topological_space (has_pos_part (has_add pos))) : t1_space (has_pos_part (has_add pos)) := sorry --non-trivial
lemma new_lemma_64437 (h0 : function.extfun Type ring) : @is_domain.{0} (linear_ordered_add_comm_group.{0} string_imp) (@function.extfun_app.{2 1} Type ring.{0} h0 (linear_ordered_add_comm_group.{0} string_imp))  := sorry --non-trivial
lemma new_lemma_64438 (h0 : function.extfun Type filter) : countable_Inter_filter (function.extfun_app h0 (normed_lattice_add_comm_group real)) := sorry --non-trivial
lemma new_lemma_64439 (h0 : topological_space (has_to_string pos)) : normal_space (has_to_string pos) := sorry --non-trivial
lemma new_lemma_64440 (h0 : topological_space (semiring (has_norm (has_norm linarith.comp_source)))) : irreducible_space (semiring (has_norm (has_norm linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_64441 (h0 : group (has_inv (random_gen linarith.comp_source))) : is_cyclic (has_inv (random_gen linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_64442 (h0 : topological_space (with_one (random_gen (has_inv fun_info)))) : locally_compact_space (with_one (random_gen (has_inv fun_info))) := sorry --non-trivial
lemma new_lemma_64443 (h0 : topological_space (has_dist (option ennreal))) : totally_separated_space (has_dist (option ennreal)) := sorry --non-trivial
lemma new_lemma_64444 (h0 : linarith.ineq -> linarith.ineq -> Prop) : is_refl linarith.ineq h0 := sorry --non-trivial
lemma new_lemma_64445 (h0 : list (canonically_ordered_comm_semiring (has_add name))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_64446 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : palindrome (function.extfun_app (function.extfun_app h0 list) (linear_ordered_field unsigned)) := sorry --non-trivial
lemma new_lemma_64447 (h0 : uniform_space (free_add_monoid unsigned)) : complete_space (free_add_monoid unsigned) := sorry --non-trivial
lemma new_lemma_64448 (h0 : function.extfun Type (functor.comp topological_space canonically_ordered_comm_semiring)) : @locally_compact_space.{0} (canonically_ordered_comm_semiring.{0} ennreal) (@functor.comp.run.{0 0 0} topological_space.{0} canonically_ordered_comm_semiring.{0} ennreal (@function.extfun_app.{2 1} Type (functor.comp.{0 0 0} topological_space.{0} canonically_ordered_comm_semiring.{0}) h0 ennreal))  := sorry --non-trivial
lemma new_lemma_64449 (h0 : topological_space (ring (has_add (has_add Type)))) : discrete_topology (ring (has_add (has_add Type))) := sorry --non-trivial
lemma new_lemma_64450 (h0 : function.extfun Type group) : @normalizer_condition.{0} (semigroup.{0} unsigned) (@function.extfun_app.{2 1} Type group.{0} h0 (semigroup.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_64451 (h0 : filter (boolean_algebra (semigroup name))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_64452 (h0 : not (ring (normed_group num) -> false)) : @rank_condition.{0} (normed_group.{0} num) (@classical.by_contradiction'.{1} (ring.{0} (normed_group.{0} num)) h0)  := sorry --non-trivial
lemma new_lemma_64453 (h1 : topological_space (has_top (has_norm (has_norm (random_gen linarith.ineq))))) : t0_space (has_top (has_norm (has_norm (random_gen linarith.ineq)))) := sorry --non-trivial
lemma new_lemma_64454 (h0 : topological_space (complete_distrib_lattice (has_neg (finset name)))) : preconnected_space (complete_distrib_lattice (has_neg (finset name))) := sorry --non-trivial
lemma new_lemma_64455 (h0 : not (function.extfun Type complete_lattice -> false)) : @is_atomistic.{0} (semiring.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type complete_lattice.{0}) h0) (semiring.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_64456 (h0 : list (finset (option unsigned))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_64457 (h0 : topological_space (has_bot (sub_neg_monoid pos))) : totally_disconnected_space (has_bot (sub_neg_monoid pos)) := sorry --non-trivial
lemma new_lemma_64458 (h0 : function.extfun Type semiring) : @is_noetherian_ring.{0} (semiring.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type semiring.{0} h0 (semiring.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_64459 (h0 : function.extfun Type (functor.add_const (ring (has_to_string name)))) : @strong_rank_condition.{0} (has_to_string.{0} name) (@functor.add_const.run.{0 0} (ring.{0} (has_to_string.{0} name)) name (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (ring.{0} (has_to_string.{0} name))) h0 name))  := sorry --non-trivial
lemma new_lemma_64460 (h0 : has_lt (has_sdiff linarith.comp_source)) : no_max_order (has_sdiff linarith.comp_source) := sorry --non-trivial
lemma new_lemma_64461 (h0 : functor.add_const (topological_space (has_nndist Type)) pos) : @t1_space.{1} (has_nndist.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (has_nndist.{1} Type)) pos h0)  := sorry --non-trivial
lemma new_lemma_64462 (h0 : group (add_comm_monoid (has_neg (has_neg pos)))) : group.fg (add_comm_monoid (has_neg (has_neg pos))) := sorry --non-trivial
lemma new_lemma_64463 (h0 : topological_space (has_nndist (has_to_string unsigned))) : path_connected_space (has_nndist (has_to_string unsigned)) := sorry --non-trivial
lemma new_lemma_64464 (h0 : topological_space (order_dual linarith.comp_source)) : totally_separated_space (order_dual linarith.comp_source) := sorry --non-trivial
lemma new_lemma_64465 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @locally_compact_space.{0} (linear_ordered_field.{0} ennreal) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (linear_ordered_field.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_64466 (h0 : topological_space (denumerable char)) : totally_disconnected_space (denumerable char) := sorry --non-trivial
lemma new_lemma_64467 (h0 : function.extfun Type topological_space) : @path_connected_space.{0} (linear_ordered_comm_group.{0} ennreal) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (linear_ordered_comm_group.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_64468 (h0 : topological_space (canonically_ordered_monoid real)) : t0_space (canonically_ordered_monoid real) := sorry --non-trivial
lemma new_lemma_64469 (h0 : functor.add_const (topological_space (finset ennreal)) pos) : @sequential_space.{0} (finset.{0} ennreal) (@functor.add_const.run.{0 0} (topological_space.{0} (finset.{0} ennreal)) pos h0)  := sorry --non-trivial
lemma new_lemma_64470 (h0 : function.extfun Type uniform_space) : @separated_space.{0} (bin_tree.{0} (option.{0} empty)) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (bin_tree.{0} (option.{0} empty)))  := sorry --non-trivial
lemma new_lemma_64471 (h0 : topological_space (mul_zero_class empty)) : totally_disconnected_space (mul_zero_class empty) := sorry --non-trivial
lemma new_lemma_64472 (h0 : group (has_pos_part (has_pos_part linarith.comp))) : normalizer_condition (has_pos_part (has_pos_part linarith.comp)) := sorry --non-trivial
lemma new_lemma_64473 (h1 : list (comm_ring (random_gen to_additive.value_type))) : list.nodup h1 := sorry --non-trivial
lemma new_lemma_64474 (h0 : functor.add_const (function.extfun Type topological_space) (has_neg Type)) : @discrete_topology.{0} (ring.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type topological_space.{0}) (has_neg.{1} Type) h0) (ring.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_64475 (h0 : functor.add_const (list (mul_zero_class unsigned)) pos) : palindrome (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_64476 (h0 : complete_lattice (metric_space reducibility_hints)) : complete_lattice.is_Sup_finite_compact (metric_space reducibility_hints) := sorry --non-trivial
lemma new_lemma_64477 (h0 : functor.add_const (ring (add_cancel_monoid Type)) environment.implicit_infer_kind) : @is_principal_ideal_ring.{1} (add_cancel_monoid.{1} Type) (@functor.add_const.run.{1 0} (ring.{1} (add_cancel_monoid.{1} Type)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_64478 (h1 : list (with_one (measurable_space (measurable_space (random_gen to_additive.value_type))))) : list.nodup h1 := sorry --non-trivial
lemma new_lemma_64479 (h0 : group (add_cancel_comm_monoid (denumerable (has_nnnorm char)))) : is_cyclic (add_cancel_comm_monoid (denumerable (has_nnnorm char))) := sorry --non-trivial
lemma new_lemma_64480 (h0 : topological_space (normed_field (comm_ring (random_gen string.iterator_imp)))) : t0_space (normed_field (comm_ring (random_gen string.iterator_imp))) := sorry --non-trivial
lemma new_lemma_64481 (h0 : uniform_space.core (has_nnnorm environment.projection_info)) : @totally_disconnected_space.{0} (has_nnnorm.{0} environment.projection_info) (@uniform_space.core.to_topological_space.{0} (has_nnnorm.{0} environment.projection_info) h0)  := sorry --non-trivial
lemma new_lemma_64482 (h0 : functor.add_const (list (finset pos)) (finset pos)) : palindrome (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_64483 (h0 : functor.add_const (list (boolean_algebra.core linarith.comp)) linarith.comp) : list.nodup (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_64484 (h0 : topological_space (has_add (has_Inf (has_add (has_Inf (has_Inf Type)))))) : sequential_space (has_add (has_Inf (has_add (has_Inf (has_Inf Type))))) := sorry --non-trivial
lemma new_lemma_64485 (h0 : functor.add_const (topological_space (ring Type)) environment.implicit_infer_kind) : @sequential_space.{1} (ring.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (ring.{1} Type)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_64486 (h0 : group (ring (has_pos_part pos))) : is_cyclic (ring (has_pos_part pos)) := sorry --non-trivial
lemma new_lemma_64487 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_principal_ideal_ring.{0} (monoid.{0} empty) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (monoid.{0} empty))  := sorry --non-trivial
lemma new_lemma_64488 (h0 : functor.add_const (complete_lattice (has_to_string unsigned)) (option unsigned)) : @is_compactly_generated.{0} (has_to_string.{0} unsigned) (@functor.add_const.run.{0 0} (complete_lattice.{0} (has_to_string.{0} unsigned)) (option.{0} unsigned) h0)  := sorry --non-trivial
lemma new_lemma_64489 (h0 : topological_space (preorder (semiring num))) : totally_disconnected_space (preorder (semiring num)) := sorry --non-trivial
lemma new_lemma_64490 (h0 : topological_space (linear_ordered_semiring (semiring num))) : discrete_topology (linear_ordered_semiring (semiring num)) := sorry --non-trivial
lemma new_lemma_64491 (h0 : topological_space (add_comm_monoid num)) : topological_space.separable_space (add_comm_monoid num) := sorry --non-trivial
lemma new_lemma_64492 (h0 : not (complete_lattice (distrib string_imp) -> false)) : @is_compactly_generated.{0} (distrib.{0} string_imp) (@classical.by_contradiction'.{1} (complete_lattice.{0} (distrib.{0} string_imp)) h0)  := sorry --non-trivial
lemma new_lemma_64493 (h0 : uniform_space (finset (option (option (option (option (option (option empty)))))))) : separated_space (finset (option (option (option (option (option (option empty))))))) := sorry --non-trivial
lemma new_lemma_64494 (h0 : function.extfun (Type 1) filter) : countable_Inter_filter (function.extfun_app h0 (complete_distrib_lattice Type)) := sorry --non-trivial
lemma new_lemma_64495 (h0 : topological_space (ordered_ring (semiring num))) : locally_compact_space (ordered_ring (semiring num)) := sorry --non-trivial
lemma new_lemma_64496 (h0 : functor.add_const (function.extfun (Type 1) topological_space) linarith.comp) : @locally_compact_space.{1} Type (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) topological_space.{1}) linarith.comp h0) Type)  := sorry --non-trivial
lemma new_lemma_64497 (h0 : group (simple_graph (option (option unsigned)))) : group.fg (simple_graph (option (option unsigned))) := sorry --non-trivial
lemma new_lemma_64498 (h0 : functor.add_const (ring (complete_distrib_lattice pos)) pos) : @is_domain.{0} (complete_distrib_lattice.{0} pos) (@functor.add_const.run.{0 0} (ring.{0} (complete_distrib_lattice.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_64499 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @totally_separated_space.{1} Type (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 topological_space.{1}) Type)  := sorry --non-trivial
lemma new_lemma_64500 (h0 : topological_space (has_compl (has_ssubset fun_info))) : totally_disconnected_space (has_compl (has_ssubset fun_info)) := sorry --non-trivial
lemma new_lemma_64501 (h0 : not (topological_space (non_unital_non_assoc_semiring (has_compl enat)) -> false)) : @t0_space.{0} (non_unital_non_assoc_semiring.{0} (has_compl.{0} enat)) (@classical.by_contradiction'.{1} (topological_space.{0} (non_unital_non_assoc_semiring.{0} (has_compl.{0} enat))) h0)  := sorry --non-trivial
lemma new_lemma_64502 (h0 : functor.add_const (ring (free_add_monoid (semiring congr_arg_kind))) empty) : @rank_condition.{0} (free_add_monoid.{0} (semiring.{0} congr_arg_kind)) (@functor.add_const.run.{0 0} (ring.{0} (free_add_monoid.{0} (semiring.{0} congr_arg_kind))) empty h0)  := sorry --non-trivial
lemma new_lemma_64503 (h0 : uniform_space (add_comm_monoid (boolean_algebra linarith.comp))) : separated_space (add_comm_monoid (boolean_algebra linarith.comp)) := sorry --non-trivial
lemma new_lemma_64504 (h0 : functor.add_const (monoid (has_zero unsigned)) (add_cancel_monoid linarith.comp)) : @monoid.fg.{0} (has_zero.{0} unsigned) (@functor.add_const.run.{0 0} (monoid.{0} (has_zero.{0} unsigned)) (add_cancel_monoid.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_64505 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @normalizer_condition.{0} (has_neg.{0} ennreal) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (has_neg.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_64506 (h0 : topological_space (semi_normed_comm_ring (random_gen fun_info))) : locally_compact_space (semi_normed_comm_ring (random_gen fun_info)) := sorry --non-trivial
lemma new_lemma_64507 (h0 : uniform_space (semiring (semiring (has_norm (has_norm (has_norm linarith.comp)))))) : complete_space (semiring (semiring (has_norm (has_norm (has_norm linarith.comp))))) := sorry --non-trivial
lemma new_lemma_64508 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @locally_compact_space.{0} (normed_comm_ring.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (normed_comm_ring.{0} num))  := sorry --non-trivial
lemma new_lemma_64509 (h0 : function.extfun Type complete_lattice) : @complete_lattice.is_Sup_finite_compact.{0} (pseudo_metric_space.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (pseudo_metric_space.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_64510 (h0 : uniform_space (has_zero linarith.comp)) : separated_space (has_zero linarith.comp) := sorry --non-trivial
lemma new_lemma_64511 (h0 : functor.add_const (monoid (ordered_comm_monoid linarith.comp)) linarith.comp) : @monoid.fg.{0} (ordered_comm_monoid.{0} linarith.comp) (@functor.add_const.run.{0 0} (monoid.{0} (ordered_comm_monoid.{0} linarith.comp)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_64512 (h0 : functor.add_const (topological_space (semigroup pos)) (finset pos)) : @totally_separated_space.{0} (semigroup.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (semigroup.{0} pos)) (finset.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_64513 (h0 : topological_space (generalized_boolean_algebra (sub_neg_monoid pos))) : preirreducible_space (generalized_boolean_algebra (sub_neg_monoid pos)) := sorry --non-trivial
lemma new_lemma_64514 (h0 : ring (measurable_space.dynkin_system unsigned)) : strong_rank_condition (measurable_space.dynkin_system unsigned) := sorry --non-trivial
lemma new_lemma_64515 (h0 : topological_space (has_one (semiring (has_top (semiring num))))) : preirreducible_space (has_one (semiring (has_top (semiring num)))) := sorry --non-trivial
lemma new_lemma_64516 (h0 : functor.add_const (filter (has_neg name)) environment.implicit_infer_kind) : countable_Inter_filter (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_64517 (h2 : add_group (has_ssubset string.iterator_imp)) : is_add_cyclic (has_ssubset string.iterator_imp) := sorry --non-trivial
lemma new_lemma_64518 (h0 : fin has_zero.zero) : @totally_disconnected_space.{0} (has_Inf.{0} pos) (@matrix.vec_empty.{0} (topological_space.{0} (has_Inf.{0} pos)) h0)  := sorry --non-trivial
lemma new_lemma_64519 (h0 : topological_space (with_bot (has_inv linarith.comp_source))) : locally_compact_space (with_bot (has_inv linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_64520 (h1 : topological_space (comm_ring (random_gen char))) : totally_disconnected_space (comm_ring (random_gen char)) := sorry --non-trivial
lemma new_lemma_64521 (h0 : filter (add_cancel_monoid (has_neg pos))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_64522 (h0 : functor.add_const (complete_lattice (boolean_algebra pos)) environment.implicit_infer_kind) : @is_atomistic.{0} (boolean_algebra.{0} pos) (@functor.add_const.run.{0 0} (complete_lattice.{0} (boolean_algebra.{0} pos)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_64523 (h0 : not (ring (metric_space linarith.comp) -> false)) : @is_domain.{0} (metric_space.{0} linarith.comp) (@classical.by_contradiction'.{1} (ring.{0} (metric_space.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_64524 (h0 : topological_space (has_ssubset (add_comm_semigroup environment.projection_info))) (h1 : add_group (has_ssubset (add_comm_semigroup environment.projection_info))) : topological_add_group (has_ssubset (add_comm_semigroup environment.projection_info)) := sorry --non-trivial
lemma new_lemma_64525 (h1 : add_monoid environment.projection_info) : add_monoid.fg environment.projection_info := sorry --non-trivial
lemma new_lemma_64526 (h0 : functor.add_const (function.extfun Type topological_space) Type) : @t0_space.{0} (add_cancel_monoid.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type topological_space.{0}) Type h0) (add_cancel_monoid.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_64527 (h0 : function.extfun Type finset) : finset.nonempty (function.extfun_app h0 (complete_distrib_lattice ennreal)) := sorry --non-trivial
lemma new_lemma_64528 (h0 : topological_space (has_well_founded empty)) : totally_disconnected_space (has_well_founded empty) := sorry --non-trivial
lemma new_lemma_64529 (h0 : complete_lattice (boolean_algebra real)) : complete_lattice.is_Sup_finite_compact (boolean_algebra real) := sorry --non-trivial
lemma new_lemma_64530 (h0 : functor.add_const (ring (boolean_algebra unsigned)) environment.implicit_infer_kind) : @is_principal_ideal_ring.{0} (boolean_algebra.{0} unsigned) (@functor.add_const.run.{0 0} (ring.{0} (boolean_algebra.{0} unsigned)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_64531 (h1 : add_group (id (with_bot linarith.ineq))) : is_add_cyclic (id (with_bot linarith.ineq)) := sorry --non-trivial
lemma new_lemma_64532 (h0 : add_monoid (boolean_algebra.core (has_add unsigned))) : add_monoid.fg (boolean_algebra.core (has_add unsigned)) := sorry --non-trivial
lemma new_lemma_64533 (h0 : group (has_emptyc (random_gen fun_info))) : normalizer_condition (has_emptyc (random_gen fun_info)) := sorry --non-trivial
lemma new_lemma_64534 (h0 : topological_space (distrib string.iterator_imp)) (h1 : preorder (distrib string.iterator_imp)) : order_topology (distrib string.iterator_imp) := sorry --non-trivial
lemma new_lemma_64535 (h0 : uniform_space (add_group (semiring (semiring (has_top linarith.comp))))) : separated_space (add_group (semiring (semiring (has_top linarith.comp)))) := sorry --non-trivial
lemma new_lemma_64536 (h0 : topological_space (uniform_space (uniform_space string_imp))) : totally_disconnected_space (uniform_space (uniform_space string_imp)) := sorry --non-trivial
lemma new_lemma_64537 (h0 : function.extfun Type topological_space) : @irreducible_space.{0} (ordered_comm_group.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (ordered_comm_group.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_64538 (h0 : functor.add_const (topological_space (canonically_ordered_comm_semiring name)) name) : @regular_space.{0} (canonically_ordered_comm_semiring.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (canonically_ordered_comm_semiring.{0} name)) name h0)  := sorry --non-trivial
lemma new_lemma_64539 (h0 : topological_space (has_nndist (has_neg environment.implicit_infer_kind))) : loc_path_connected_space (has_nndist (has_neg environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_64540 (h0 : topological_space (div_inv_monoid (random_gen (random_gen linarith.ineq)))) : locally_compact_space (div_inv_monoid (random_gen (random_gen linarith.ineq))) := sorry --non-trivial
lemma new_lemma_64541 (h0 : ring (has_lt linarith.comp_source)) : strong_rank_condition (has_lt linarith.comp_source) := sorry --non-trivial
lemma new_lemma_64542 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @t1_space.{0} (has_neg.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_neg.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_64543 (h0 : topological_space (dlist (comm_ring (comm_ring (random_gen to_additive.value_type))))) : irreducible_space (dlist (comm_ring (comm_ring (random_gen to_additive.value_type)))) := sorry --non-trivial
lemma new_lemma_64544 (h0 : group (with_bot (has_top (has_top linarith.ineq)))) : is_cyclic (with_bot (has_top (has_top linarith.ineq))) := sorry --non-trivial
lemma new_lemma_64545 (h0 : ring (finset (has_add (has_add linarith.comp)))) : rank_condition (finset (has_add (has_add linarith.comp))) := sorry --non-trivial
lemma new_lemma_64546 (h1 : add_group (mul_one_class (mul_one_class enat))) : is_add_cyclic (mul_one_class (mul_one_class enat)) := sorry --non-trivial
lemma new_lemma_64547 (h0 : ring (measurable_space.dynkin_system (semiring empty))) : rank_condition (measurable_space.dynkin_system (semiring empty)) := sorry --non-trivial
lemma new_lemma_64548 (h0 : functor.add_const (topological_space (has_neg_part unsigned)) name) : @preirreducible_space.{0} (has_neg_part.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (has_neg_part.{0} unsigned)) name h0)  := sorry --non-trivial
lemma new_lemma_64549 (h0 : topological_space (add_monoid to_additive.value_type)) : path_connected_space (add_monoid to_additive.value_type) := sorry --non-trivial
lemma new_lemma_64550 (h0 : not (function.extfun Type filter -> false)) : filter.ne_bot (function.extfun_app (classical.by_contradiction' h0) (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_64551 (h1 : topological_space (distrib linarith.ineq)) (h2 : preorder (distrib linarith.ineq)) : order_topology (distrib linarith.ineq) := sorry --non-trivial
lemma new_lemma_64552 (h0 : functor.add_const (list (has_neg pos)) pos) : list.nodup (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_64553 (h0 : topological_space (has_compl (has_nnnorm linarith.ineq))) : path_connected_space (has_compl (has_nnnorm linarith.ineq)) := sorry --non-trivial
lemma new_lemma_64554 (h0 : function.extfun (finset Type) (has_mem.mem string_imp)) : @complete_lattice.is_Sup_finite_compact.{0} string_imp (@finset.pi.empty.{1 0} Type complete_lattice.{0} string_imp (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) string_imp) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_64555 (h0 : functor.add_const (add_monoid (boolean_algebra linarith.comp)) pos) : @add_monoid.fg.{0} (boolean_algebra.{0} linarith.comp) (@functor.add_const.run.{0 0} (add_monoid.{0} (boolean_algebra.{0} linarith.comp)) pos h0)  := sorry --non-trivial
lemma new_lemma_64556 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : palindrome (function.extfun_app (function.extfun_app h0 list) (linear_ordered_comm_group empty)) := sorry --non-trivial
lemma new_lemma_64557 (h0 : function.extfun Type uniform_space) : @separated_space.{0} (boolean_algebra.{0} linarith.comp) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (boolean_algebra.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_64558 (h0 : functor.add_const (ordered_add_comm_monoid (semigroup empty)) unsigned) : @archimedean.{0} (semigroup.{0} empty) (@functor.add_const.run.{0 0} (ordered_add_comm_monoid.{0} (semigroup.{0} empty)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_64559 (h0 : complete_lattice (has_neg (finset Type))) : is_compactly_generated (has_neg (finset Type)) := sorry --non-trivial
lemma new_lemma_64560 (h0 : group (with_bot string_imp)) : group.fg (with_bot string_imp) := sorry --non-trivial
lemma new_lemma_64561 (h0 : topological_space (has_neg (option ennreal))) : sequential_space (has_neg (option ennreal)) := sorry --non-trivial
lemma new_lemma_64562 (h0 : functor.comp finset comm_group name) : finset.nonempty (functor.comp.run h0) := sorry --non-trivial
lemma new_lemma_64563 (h0 : preorder fun_info) (h1 : ring (locally_finite_order fun_info)) : is_domain (locally_finite_order fun_info) := sorry --non-trivial
lemma new_lemma_64564 (h0 : topological_space (topological_space (random_gen fun_info))) : path_connected_space (topological_space (random_gen fun_info)) := sorry --non-trivial
lemma new_lemma_64565 (h0 : complete_lattice (has_norm (metric_space linarith.comp))) : is_atomistic (has_norm (metric_space linarith.comp)) := sorry --non-trivial
lemma new_lemma_64566 (h1 : topological_space (measurable_space (random_gen linarith.ineq))) : totally_disconnected_space (measurable_space (random_gen linarith.ineq)) := sorry --non-trivial
lemma new_lemma_64567 (h0 : functor.add_const (function.extfun Type ring) Type) : @rank_condition.{0} (has_Inf.{0} name) (@function.extfun_app.{2 1} Type ring.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type ring.{0}) Type h0) (has_Inf.{0} name))  := sorry --non-trivial
lemma new_lemma_64568 (h0 : finset (monoid pos)) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_64569 (h0 : functor.add_const (group (cancel_monoid name)) Type) : @is_simple_group.{0} (cancel_monoid.{0} name) (@functor.add_const.run.{0 1} (group.{0} (cancel_monoid.{0} name)) Type h0)  := sorry --non-trivial
lemma new_lemma_64570 (h0 : functor.add_const (ordered_comm_monoid (add_comm_monoid linarith.comp)) linarith.comp) : @has_exists_mul_of_le.{0} (add_comm_monoid.{0} linarith.comp) (@functor.add_const.run.{0 0} (ordered_comm_monoid.{0} (add_comm_monoid.{0} linarith.comp)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_64571 (h0 : functor.add_const (uniform_space (boolean_algebra name)) linarith.comp) : @separated_space.{0} (boolean_algebra.{0} name) (@functor.add_const.run.{0 0} (uniform_space.{0} (boolean_algebra.{0} name)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_64572 (h0 : add_monoid (finset (finset (finset pos)))) : add_monoid.fg (finset (finset (finset pos))) := sorry --non-trivial
lemma new_lemma_64573 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_noetherian_ring.{0} (normed_comm_ring.{0} linarith.comp) (@function.extfun_app.{2 1} Type semiring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 semiring.{0}) (normed_comm_ring.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_64574 (h0 : function.extfun Type group) : @is_cyclic.{0} (has_to_string.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type group.{0} h0 (has_to_string.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_64575 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @archimedean.{0} (sub_neg_monoid.{0} pos) (@function.extfun_app.{2 1} Type ordered_add_comm_monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ordered_add_comm_monoid.{0}) (sub_neg_monoid.{0} pos))  := sorry --non-trivial
lemma new_lemma_64576 (h0 : list (has_nndist environment.implicit_infer_kind)) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_64577 (h0 : ring (option (semiring (semiring (semiring (semiring empty)))))) : invariant_basis_number (option (semiring (semiring (semiring (semiring empty))))) := sorry --non-trivial
lemma new_lemma_64578 (h0 : group (random_gen (has_top empty))) : group.fg (random_gen (has_top empty)) := sorry --non-trivial
lemma new_lemma_64579 (h0 : function.extfun Type topological_space) : @loc_path_connected_space.{0} (pseudo_metric_space.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (pseudo_metric_space.{0} num))  := sorry --non-trivial
lemma new_lemma_64580 (h1 : ring (random_gen (random_gen (comm_ring (comm_ring char))))) : rank_condition (random_gen (random_gen (comm_ring (comm_ring char)))) := sorry --non-trivial
lemma new_lemma_64581 (h0 : group (encodable (has_nnnorm to_additive.value_type))) : group.fg (encodable (has_nnnorm to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_64582 (h0 : functor.add_const (ring (has_neg_part pos)) (option pos)) : @strong_rank_condition.{0} (has_neg_part.{0} pos) (@functor.add_const.run.{0 0} (ring.{0} (has_neg_part.{0} pos)) (option.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_64583 (h0 : functor.add_const (topological_space (has_neg linarith.comp)) linarith.comp) : @path_connected_space.{0} (has_neg.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (has_neg.{0} linarith.comp)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_64584 (h0 : topological_space (group_with_zero num)) : locally_compact_space (group_with_zero num) := sorry --non-trivial
lemma new_lemma_64585 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_add_cyclic.{0} (add_comm_monoid.{0} pos) (@function.extfun_app.{2 1} Type add_group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 add_group.{0}) (add_comm_monoid.{0} pos))  := sorry --non-trivial
lemma new_lemma_64586 (h0 : set (has_compl (mul_one_class string.iterator_imp))) : set.finite h0 := sorry --non-trivial
lemma new_lemma_64587 (h0 : topological_space (has_div environment.projection_info)) : totally_disconnected_space (has_div environment.projection_info) := sorry --non-trivial
lemma new_lemma_64588 (h0 : finset (semigroup (mul_zero_class (option pos)))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_64589 (h0 : functor.add_const (cancel_comm_monoid_with_zero znum) empty) : @unique_factorization_monoid.{0} znum (@functor.add_const.run.{0 0} (cancel_comm_monoid_with_zero.{0} znum) empty h0)  := sorry --non-trivial
lemma new_lemma_64590 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_cyclic.{0} (finset.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (finset.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_64591 (h0 : functor.add_const (topological_space (has_Inf pos)) name) : @preconnected_space.{0} (has_Inf.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (has_Inf.{0} pos)) name h0)  := sorry --non-trivial
lemma new_lemma_64592 (h0 : topological_space (generalized_boolean_algebra Type)) : t0_space (generalized_boolean_algebra Type) := sorry --non-trivial
lemma new_lemma_64593 (h0 : topological_space (random_gen (comm_ring (random_gen to_additive.value_type)))) : locally_compact_space (random_gen (comm_ring (random_gen to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_64594 (h0 : group (has_pos_part (normed_comm_ring pos))) : normalizer_condition (has_pos_part (normed_comm_ring pos)) := sorry --non-trivial
lemma new_lemma_64595 (h0 : functor.add_const (ordered_add_comm_monoid (comm_group linarith.comp)) (has_neg pos)) : @archimedean.{0} (comm_group.{0} linarith.comp) (@functor.add_const.run.{0 0} (ordered_add_comm_monoid.{0} (comm_group.{0} linarith.comp)) (has_neg.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_64596 (h0 : topological_space (has_to_string (has_add name))) : normal_space (has_to_string (has_add name)) := sorry --non-trivial
lemma new_lemma_64597 (h0 : ring (has_nndist (add_cancel_monoid (add_cancel_monoid name)))) : is_principal_ideal_ring (has_nndist (add_cancel_monoid (add_cancel_monoid name))) := sorry --non-trivial
lemma new_lemma_64598 (h0 : functor.add_const (ring (ring ennreal)) ennreal) : @rank_condition.{0} (ring.{0} ennreal) (@functor.add_const.run.{0 0} (ring.{0} (ring.{0} ennreal)) ennreal h0)  := sorry --non-trivial
lemma new_lemma_64599 (h0 : group (with_one (random_gen (random_gen (random_gen linarith.ineq))))) : group.fg (with_one (random_gen (random_gen (random_gen linarith.ineq)))) := sorry --non-trivial
lemma new_lemma_64600 (h0 : function.extfun Type topological_space) : @regular_space.{0} (sub_neg_monoid.{0} real) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (sub_neg_monoid.{0} real))  := sorry --non-trivial
lemma new_lemma_64601 (h0 : list (has_pos_part name)) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_64602 (h0 : finset (mul_zero_class (has_add name))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_64603 (h0 : group (add_cancel_monoid (finset (ring linarith.comp)))) : normalizer_condition (add_cancel_monoid (finset (ring linarith.comp))) := sorry --non-trivial
lemma new_lemma_64604 (h0 : add_monoid (boolean_algebra (has_add environment.implicit_infer_kind))) : add_monoid.fg (boolean_algebra (has_add environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_64605 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @totally_separated_space.{0} (mul_zero_class.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (mul_zero_class.{0} pos))  := sorry --non-trivial
lemma new_lemma_64606 (h0 : functor.add_const (add_group (has_nndist environment.implicit_infer_kind)) name) : @is_add_cyclic.{0} (has_nndist.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (add_group.{0} (has_nndist.{0} environment.implicit_infer_kind)) name h0)  := sorry --non-trivial
lemma new_lemma_64607 (h0 : function.extfun Type ordered_comm_monoid) : @has_exists_mul_of_le.{0} (comm_group.{0} name) (@function.extfun_app.{2 1} Type ordered_comm_monoid.{0} h0 (comm_group.{0} name))  := sorry --non-trivial
lemma new_lemma_64608 (h0 : uniform_space (mul_one_class (mul_one_class ereal))) : complete_space (mul_one_class (mul_one_class ereal)) := sorry --non-trivial
lemma new_lemma_64609 (h0 : complete_lattice (comm_ring (linear_ordered_add_comm_group linarith.ineq))) : is_compactly_generated (comm_ring (linear_ordered_add_comm_group linarith.ineq)) := sorry --non-trivial
lemma new_lemma_64610 (h0 : list (has_edist congr_arg_kind)) : palindrome h0 := sorry --non-trivial
lemma new_lemma_64611 (h0 : topological_space (has_zero (option unsigned))) : normal_space (has_zero (option unsigned)) := sorry --non-trivial
lemma new_lemma_64612 (h0 : filter (has_top (has_norm (has_norm (comm_ring (distrib_lattice (has_norm linarith.ineq))))))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_64613 (h0 : functor.add_const (topological_space (left_cancel_monoid congr_arg_kind)) empty) : @normal_space.{0} (left_cancel_monoid.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (left_cancel_monoid.{0} congr_arg_kind)) empty h0)  := sorry --non-trivial
lemma new_lemma_64614 (h0 : functor.add_const (add_group (normed_comm_ring Type)) pos) : @is_add_cyclic.{1} (normed_comm_ring.{1} Type) (@functor.add_const.run.{1 0} (add_group.{1} (normed_comm_ring.{1} Type)) pos h0)  := sorry --non-trivial
lemma new_lemma_64615 (h0 : list (finset (finset (finset ennreal)))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_64616 (h0 : complete_lattice (has_star num)) : complete_lattice.is_Sup_finite_compact (has_star num) := sorry --non-trivial
lemma new_lemma_64617 (h0 : function.extfun nat fin) : @t1_space.{0} (boolean_algebra.{0} linarith.comp) (@matrix.vec_empty.{0} (topological_space.{0} (boolean_algebra.{0} linarith.comp)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_64618 (h0 : function.extfun ((Type -> Type) -> Type 1) (function.extfun (Type -> Type))) : @add_monoid.fg.{0} (complete_distrib_lattice.{0} num) (@function.extfun_app.{2 1} Type add_monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) (@function.extfun_app.{3 2} ((Type → Type) → Type 1) (function.extfun.{2 2} (Type → Type)) h0 (function.extfun.{2 1} Type)) add_monoid.{0}) (complete_distrib_lattice.{0} num))  := sorry --non-trivial
lemma new_lemma_64619 (h0 : fin has_zero.zero) : @archimedean.{0} (comm_semigroup.{0} real) (@matrix.vec_empty.{0} (ordered_add_comm_monoid.{0} (comm_semigroup.{0} real)) h0)  := sorry --non-trivial
lemma new_lemma_64620 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @complete_space.{0} (has_union.{0} linarith.comp) (@function.extfun_app.{2 1} Type uniform_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 uniform_space.{0}) (has_union.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_64621 (h0 : fin has_zero.zero) : @normal_space.{0} (ordered_comm_monoid.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@matrix.vec_empty.{1} (function.extfun.{2 1} Type topological_space.{0}) h0) (ordered_comm_monoid.{0} pos))  := sorry --non-trivial
lemma new_lemma_64622 (h0 : filter (linear_order unsigned)) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_64623 (h0 : functor.add_const (topological_space (has_add linarith.comp)) linarith.comp) : @locally_compact_space.{0} (has_add.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (has_add.{0} linarith.comp)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_64624 (h0 : monoid (has_nndist (ring Type))) : monoid.fg (has_nndist (ring Type)) := sorry --non-trivial
lemma new_lemma_64625 (h0 : functor.add_const (group (has_nndist unsigned)) linarith.comp) : @group.fg.{0} (has_nndist.{0} unsigned) (@functor.add_const.run.{0 0} (group.{0} (has_nndist.{0} unsigned)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_64626 (h0 : list (linear_ordered_add_comm_group (random_gen (random_gen string_imp)))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_64627 (h0 : group (sub_neg_monoid (has_add Type))) : is_cyclic (sub_neg_monoid (has_add Type)) := sorry --non-trivial
lemma new_lemma_64628 (h0 : function.extfun Type semiring) : @is_noetherian_ring.{0} (is_R_or_C.{0} num) (@function.extfun_app.{2 1} Type semiring.{0} h0 (is_R_or_C.{0} num))  := sorry --non-trivial
lemma new_lemma_64629 (h0 : ring (has_Sup num)) : strong_rank_condition (has_Sup num) := sorry --non-trivial
lemma new_lemma_64630 (h0 : not (complete_lattice (has_top empty) -> false)) : @complete_lattice.is_Sup_finite_compact.{0} (has_top.{0} empty) (@classical.by_contradiction'.{1} (complete_lattice.{0} (has_top.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_64631 (h0 : topological_space (simple_graph (ring Type))) : normal_space (simple_graph (ring Type)) := sorry --non-trivial
lemma new_lemma_64632 (h0 : function.extfun Type group) : @group.fg.{0} (normed_linear_ordered_group.{0} unsigned) (@function.extfun_app.{2 1} Type group.{0} h0 (normed_linear_ordered_group.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_64633 (h0 : topological_space (has_neg (has_add unsigned))) : totally_separated_space (has_neg (has_add unsigned)) := sorry --non-trivial
lemma new_lemma_64634 (h0 : complete_lattice (has_to_string num)) : is_atomistic (has_to_string num) := sorry --non-trivial
lemma new_lemma_64635 (h0 : function.extfun Type (functor.add_const (group (generalized_boolean_algebra linarith.comp)))) : @group.fg.{0} (generalized_boolean_algebra.{0} linarith.comp) (@functor.add_const.run.{0 0} (group.{0} (generalized_boolean_algebra.{0} linarith.comp)) name (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (group.{0} (generalized_boolean_algebra.{0} linarith.comp))) h0 name))  := sorry --non-trivial
lemma new_lemma_64636 (h0 : function.extfun Type (functor.add_const (semiring (linear_ordered_cancel_comm_monoid empty)))) : @is_noetherian_ring.{0} (linear_ordered_cancel_comm_monoid.{0} empty) (@functor.add_const.run.{0 0} (semiring.{0} (linear_ordered_cancel_comm_monoid.{0} empty)) empty (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (semiring.{0} (linear_ordered_cancel_comm_monoid.{0} empty))) h0 empty))  := sorry --non-trivial
lemma new_lemma_64637 (h0 : list (ring Type)) : palindrome h0 := sorry --non-trivial
lemma new_lemma_64638 (h0 : group (random_gen linarith.comp_source)) : group.fg (random_gen linarith.comp_source) := sorry --non-trivial
lemma new_lemma_64639 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @preconnected_space.{0} (generalized_boolean_algebra.{0} real) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (generalized_boolean_algebra.{0} real))  := sorry --non-trivial
lemma new_lemma_64640 (h0 : topological_space (finset (normed_comm_ring pos))) : irreducible_space (finset (normed_comm_ring pos)) := sorry --non-trivial
lemma new_lemma_64641 (h0 : functor.add_const (topological_space (has_neg Type)) (has_neg (has_neg name))) : @irreducible_space.{1} (has_neg.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (has_neg.{1} Type)) (has_neg.{0} (has_neg.{0} name)) h0)  := sorry --non-trivial
lemma new_lemma_64642 (h0 : topological_space (finset (finset (finset (finset (finset linarith.comp)))))) : topological_space.separable_space (finset (finset (finset (finset (finset linarith.comp))))) := sorry --non-trivial
lemma new_lemma_64643 (h0 : functor.add_const (topological_space (comm_group Type)) name) : @totally_disconnected_space.{1} (comm_group.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (comm_group.{1} Type)) name h0)  := sorry --non-trivial
lemma new_lemma_64644 (h0 : topological_space (boolean_algebra (has_neg (finset (finset Type))))) : t1_space (boolean_algebra (has_neg (finset (finset Type)))) := sorry --non-trivial
lemma new_lemma_64645 (h0 : filter (semigroup (mul_zero_class pos))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_64646 (h0 : ring (comm_ring (random_gen string_imp))) : strong_rank_condition (comm_ring (random_gen string_imp)) := sorry --non-trivial
lemma new_lemma_64647 (h0 : ring (add_comm_semigroup (mul_one_class string_imp))) : strong_rank_condition (add_comm_semigroup (mul_one_class string_imp)) := sorry --non-trivial
lemma new_lemma_64648 (h0 : topological_space (generalized_boolean_algebra (has_neg name))) : t0_space (generalized_boolean_algebra (has_neg name)) := sorry --non-trivial
lemma new_lemma_64649 (h1 : ring (has_div (mul_one_class linarith.ineq))) : strong_rank_condition (has_div (mul_one_class linarith.ineq)) := sorry --non-trivial
lemma new_lemma_64650 (h0 : list (boolean_algebra real)) : palindrome h0 := sorry --non-trivial
lemma new_lemma_64651 (h0 : topological_space (finset (boolean_algebra Type))) : t1_space (finset (boolean_algebra Type)) := sorry --non-trivial
lemma new_lemma_64652 (h0 : topological_space (topological_space to_additive.value_type)) : path_connected_space (topological_space to_additive.value_type) := sorry --non-trivial
lemma new_lemma_64653 (h0 : functor.add_const (topological_space (measurable_space.dynkin_system congr_arg_kind)) unsigned) : @topological_space.separable_space.{0} (measurable_space.dynkin_system.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (measurable_space.dynkin_system.{0} congr_arg_kind)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_64654 (h0 : group (topological_space char)) : is_cyclic (topological_space char) := sorry --non-trivial
lemma new_lemma_64655 (h1 : function.extfun (Type -> Type) (function.extfun Type)) : @is_compactly_generated.{0} (@id.{2} Type empty) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h1 complete_lattice.{0}) (@id.{2} Type empty))  := sorry --non-trivial
lemma new_lemma_64656 (h0 : function.extfun Type (functor.add_const (ring (preorder empty)))) : @is_principal_ideal_ring.{0} (preorder.{0} empty) (@functor.add_const.run.{0 0} (ring.{0} (preorder.{0} empty)) (option.{0} (option.{0} (option.{0} num))) (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (ring.{0} (preorder.{0} empty))) h0 (option.{0} (option.{0} (option.{0} num)))))  := sorry --non-trivial
lemma new_lemma_64657 (h0 : not (topological_space (id linarith.comp_source) -> false)) : @path_connected_space.{0} (@id.{2} Type linarith.comp_source) (@classical.by_contradiction'.{1} (topological_space.{0} (@id.{2} Type linarith.comp_source)) h0)  := sorry --non-trivial
lemma new_lemma_64658 (h0 : topological_space (has_top (has_top (has_top linarith.ineq)))) : irreducible_space (has_top (has_top (has_top linarith.ineq))) := sorry --non-trivial
lemma new_lemma_64659 (h0 : function.extfun Type uniform_space) : @separated_space.{0} real.angle (@function.extfun_app.{2 1} Type uniform_space.{0} h0 real.angle)  := sorry --non-trivial
lemma new_lemma_64660 (h0 : topological_space (add_cancel_monoid (comm_group (comm_group (comm_group Type))))) : loc_path_connected_space (add_cancel_monoid (comm_group (comm_group (comm_group Type)))) := sorry --non-trivial
lemma new_lemma_64661 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_atomistic.{0} (finset.{0} (option.{0} (option.{0} (option.{0} ennreal)))) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (finset.{0} (option.{0} (option.{0} (option.{0} ennreal)))))  := sorry --non-trivial
lemma new_lemma_64662 (h0 : monoid (random_gen (random_gen (random_gen (random_gen fun_info))))) : monoid.fg (random_gen (random_gen (random_gen (random_gen fun_info)))) := sorry --non-trivial
lemma new_lemma_64663 (h1 : function.extfun (Type -> Type) (function.extfun Type)) : @complete_space.{0} (with_one.{0} (with_bot.{0} to_additive.value_type)) (@function.extfun_app.{2 1} Type uniform_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h1 uniform_space.{0}) (with_one.{0} (with_bot.{0} to_additive.value_type)))  := sorry --non-trivial
lemma new_lemma_64664 (h0 : not (topological_space (add_right_cancel_monoid empty) -> false)) : @discrete_topology.{0} (add_right_cancel_monoid.{0} empty) (@classical.by_contradiction'.{1} (topological_space.{0} (add_right_cancel_monoid.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_64665 (h0 : function.extfun (nat -> Type) (function.extfun nat)) : @is_add_cyclic.{0} (canonically_ordered_comm_semiring.{0} pos) (@function.extfun_app.{2 1} Type add_group.{0} (@matrix.vec_empty.{1} (function.extfun.{2 1} Type add_group.{0}) (@function.extfun_app.{1 1} nat fin (@function.extfun_app.{2 1} (nat → Type) (function.extfun.{1 1} nat) h0 fin) (@has_zero.zero.{0} nat nat.has_zero))) (canonically_ordered_comm_semiring.{0} pos))  := sorry --non-trivial
lemma new_lemma_64666 (h0 : complete_lattice (complete_linear_order (option unsigned))) : is_atomistic (complete_linear_order (option unsigned)) := sorry --non-trivial
lemma new_lemma_64667 (h0 : functor.add_const (function.extfun (Type 1) ordered_add_comm_monoid) (has_neg Type)) : @archimedean.{1} (has_to_string.{1} Type) (@function.extfun_app.{3 2} (Type 1) ordered_add_comm_monoid.{1} (@functor.add_const.run.{2 1} (function.extfun.{3 2} (Type 1) ordered_add_comm_monoid.{1}) (has_neg.{1} Type) h0) (has_to_string.{1} Type))  := sorry --non-trivial
lemma new_lemma_64668 (h0 : functor.add_const (add_monoid (add_cancel_monoid ennreal)) num) : @add_monoid.fg.{0} (add_cancel_monoid.{0} ennreal) (@functor.add_const.run.{0 0} (add_monoid.{0} (add_cancel_monoid.{0} ennreal)) num h0)  := sorry --non-trivial
lemma new_lemma_64669 (h1 : not (topological_space (uniform_space linarith.comp_source) -> false)) : @totally_disconnected_space.{0} (uniform_space.{0} linarith.comp_source) (@classical.by_contradiction'.{1} (topological_space.{0} (uniform_space.{0} linarith.comp_source)) h1)  := sorry --non-trivial
lemma new_lemma_64670 (h0 : functor.comp add_group has_nndist pos) : @is_add_cyclic.{0} (has_nndist.{0} pos) (@functor.comp.run.{0 0 0} add_group.{0} has_nndist.{0} pos h0)  := sorry --non-trivial
lemma new_lemma_64671 (h0 : topological_space (dlist string_imp)) : path_connected_space (dlist string_imp) := sorry --non-trivial
lemma new_lemma_64672 (h0 : functor.add_const Prop (mul_zero_class pos)) : functor.add_const.run h0 := sorry --non-trivial
lemma new_lemma_64673 (h0 : topological_space (has_bot (has_neg pos))) : preconnected_space (has_bot (has_neg pos)) := sorry --non-trivial
lemma new_lemma_64674 (h0 : semiring (measurable_space.dynkin_system (semiring (semiring (semiring num))))) : is_noetherian_ring (measurable_space.dynkin_system (semiring (semiring (semiring num)))) := sorry --non-trivial
lemma new_lemma_64675 (h3 : topological_space linarith.ineq) (h4 : preorder linarith.ineq) : order_closed_topology linarith.ineq := sorry --non-trivial
lemma new_lemma_64676 (h0 : add_monoid (add_cancel_monoid ennreal)) : add_monoid.fg (add_cancel_monoid ennreal) := sorry --non-trivial
lemma new_lemma_64677 (h0 : complete_lattice (left_cancel_monoid empty)) : is_compactly_generated (left_cancel_monoid empty) := sorry --non-trivial
lemma new_lemma_64678 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @t0_space.{0} (canonically_linear_ordered_monoid.{0} ennreal) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (canonically_linear_ordered_monoid.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_64679 (h0 : semiring (has_star (semiring (semiring (semiring (semiring (semiring (semiring num)))))))) : is_noetherian_ring (has_star (semiring (semiring (semiring (semiring (semiring (semiring num))))))) := sorry --non-trivial
lemma new_lemma_64680 (h0 : topological_space (generalized_boolean_algebra (has_Inf Type))) : path_connected_space (generalized_boolean_algebra (has_Inf Type)) := sorry --non-trivial
lemma new_lemma_64681 (h1 : has_mem.mem topological_space has_emptyc.emptyc) : @totally_separated_space.{0} congr_arg_kind (@function.extfun_app.{2 1} Type topological_space.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) topological_space.{0} h1) congr_arg_kind)  := sorry --non-trivial
lemma new_lemma_64682 (h0 : topological_space (normed_comm_ring environment.implicit_infer_kind)) : t0_space (normed_comm_ring environment.implicit_infer_kind) := sorry --non-trivial
lemma new_lemma_64683 (h0 : ordered_comm_monoid (has_bot (comm_semigroup pos))) : has_exists_mul_of_le (has_bot (comm_semigroup pos)) := sorry --non-trivial
lemma new_lemma_64684 (h0 : functor.add_const (functor.add_const (filter environment.implicit_infer_kind) linarith.comp) Type) : countable_Inter_filter (functor.add_const.run (functor.add_const.run h0)) := sorry --non-trivial
lemma new_lemma_64685 (h0 : topological_space (has_to_string (finset pos))) : regular_space (has_to_string (finset pos)) := sorry --non-trivial
lemma new_lemma_64686 (h1 : ring (normed_field (has_lt reducibility_hints))) : strong_rank_condition (normed_field (has_lt reducibility_hints)) := sorry --non-trivial
lemma new_lemma_64687 (h0 : topological_space (has_neg (has_neg (has_neg (has_neg (ring (has_neg Type))))))) : locally_compact_space (has_neg (has_neg (has_neg (has_neg (ring (has_neg Type)))))) := sorry --non-trivial
lemma new_lemma_64688 (h0 : add_group (with_one (random_gen (random_gen linarith.ineq)))) : is_add_cyclic (with_one (random_gen (random_gen linarith.ineq))) := sorry --non-trivial
lemma new_lemma_64689 (h0 : functor.add_const (list (has_zero linarith.comp)) pos) : list.nodup (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_64690 (h0 : function.extfun Type ring) : @strong_rank_condition.{0} (linear_ordered_semiring.{0} empty) (@function.extfun_app.{2 1} Type ring.{0} h0 (linear_ordered_semiring.{0} empty))  := sorry --non-trivial
lemma new_lemma_64691 (h1 : not (add_group (distrib fun_info) -> false)) : @is_add_cyclic.{0} (distrib.{0} fun_info) (@classical.by_contradiction'.{1} (add_group.{0} (distrib.{0} fun_info)) h1)  := sorry --non-trivial
lemma new_lemma_64692 (h0 : topological_space (non_assoc_semiring num)) : totally_disconnected_space (non_assoc_semiring num) := sorry --non-trivial
lemma new_lemma_64693 (h0 : functor.add_const (monoid ennreal) unsigned) : monoid.fg ennreal := sorry --non-trivial
lemma new_lemma_64694 (h0 : topological_space (filter (option (option empty)))) : preirreducible_space (filter (option (option empty))) := sorry --non-trivial
lemma new_lemma_64695 (h0 : functor.add_const (ring (normed_comm_ring empty)) empty) : @is_domain.{0} (normed_comm_ring.{0} empty) (@functor.add_const.run.{0 0} (ring.{0} (normed_comm_ring.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_64696 (h0 : set (normed_field reducibility_hints)) : set.finite h0 := sorry --non-trivial
lemma new_lemma_64697 (h0 : function.extfun Type ring) : @is_domain.{0} (finset.{0} real) (@function.extfun_app.{2 1} Type ring.{0} h0 (finset.{0} real))  := sorry --non-trivial
lemma new_lemma_64698 (h0 : functor.add_const (topological_space (has_neg_part name)) name) : @discrete_topology.{0} (has_neg_part.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (has_neg_part.{0} name)) name h0)  := sorry --non-trivial
lemma new_lemma_64699 (h0 : functor.add_const (group (has_pos_part linarith.comp)) pos) : @normalizer_condition.{0} (has_pos_part.{0} linarith.comp) (@functor.add_const.run.{0 0} (group.{0} (has_pos_part.{0} linarith.comp)) pos h0)  := sorry --non-trivial
lemma new_lemma_64700 (h0 : topological_space (sub_neg_monoid (ring (has_add (has_neg name))))) : totally_separated_space (sub_neg_monoid (ring (has_add (has_neg name)))) := sorry --non-trivial
lemma new_lemma_64701 (h0 : fin has_zero.zero) : @separated_space.{0} (add_comm_monoid.{0} real) (@matrix.vec_empty.{0} (uniform_space.{0} (add_comm_monoid.{0} real)) (@matrix.vec_empty.{0} (fin (@has_zero.zero.{0} nat nat.has_zero)) (@matrix.vec_empty.{0} (fin (@has_zero.zero.{0} nat nat.has_zero)) (@matrix.vec_empty.{0} (fin (@has_zero.zero.{0} nat nat.has_zero)) h0))))  := sorry --non-trivial
lemma new_lemma_64702 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @preirreducible_space.{0} (comm_monoid.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (comm_monoid.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_64703 (h0 : functor.add_const (complete_lattice (canonically_ordered_comm_semiring Type)) (has_neg_part Type)) : @is_atomistic.{1} (canonically_ordered_comm_semiring.{1} Type) (@functor.add_const.run.{1 1} (complete_lattice.{1} (canonically_ordered_comm_semiring.{1} Type)) (has_neg_part.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_64704 (h1 : topological_space (has_div string_imp)) : path_connected_space (has_div string_imp) := sorry --non-trivial
lemma new_lemma_64705 (h0 : function.extfun Type add_group) : @is_add_cyclic.{0} (complete_semilattice_Sup.{0} (random_gen.{0} string_imp)) (@function.extfun_app.{2 1} Type add_group.{0} h0 (complete_semilattice_Sup.{0} (random_gen.{0} string_imp)))  := sorry --non-trivial
lemma new_lemma_64706 (h0 : monoid (linear_ordered_semiring (has_norm (random_gen num)))) : monoid.fg (linear_ordered_semiring (has_norm (random_gen num))) := sorry --non-trivial
lemma new_lemma_64707 (h0 : not (ring (encodable linarith.ineq) -> false)) : @strong_rank_condition.{0} (encodable.{0} linarith.ineq) (@classical.by_contradiction'.{1} (ring.{0} (encodable.{0} linarith.ineq)) h0)  := sorry --non-trivial
lemma new_lemma_64708 (h0 : group (with_one (has_nnnorm linarith.comp_source))) : group.fg (with_one (has_nnnorm linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_64709 (h0 : topological_space (id (has_top (has_top (has_top linarith.comp_source))))) : locally_compact_space (id (has_top (has_top (has_top linarith.comp_source)))) := sorry --non-trivial
lemma new_lemma_64710 (h0 : topological_space (has_nndist (measurable_space.dynkin_system (option unsigned)))) : loc_path_connected_space (has_nndist (measurable_space.dynkin_system (option unsigned))) := sorry --non-trivial
lemma new_lemma_64711 (h0 : group (mul_zero_class (finset (finset pos)))) : is_cyclic (mul_zero_class (finset (finset pos))) := sorry --non-trivial
lemma new_lemma_64712 (h0 : functor.add_const (function.extfun (Type 1) filter) pos) : countable_Inter_filter (function.extfun_app (functor.add_const.run h0) (semigroup Type)) := sorry --non-trivial
lemma new_lemma_64713 (h0 : fin has_zero.zero) : @is_domain.{1} (canonically_linear_ordered_monoid.{1} Type) (@matrix.vec_empty.{1} (ring.{1} (canonically_linear_ordered_monoid.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_64714 (h0 : functor.add_const Prop (semigroup (has_neg linarith.comp))) : functor.add_const.run h0 := sorry --non-trivial
lemma new_lemma_64715 (h0 : functor.add_const (topological_space (ring linarith.comp)) environment.implicit_infer_kind) : @preirreducible_space.{0} (ring.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (ring.{0} linarith.comp)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_64716 (h0 : uniform_space (has_add (has_neg (has_Inf real)))) : separated_space (has_add (has_neg (has_Inf real))) := sorry --non-trivial
lemma new_lemma_64717 (h0 : not (complete_lattice (encodable linarith.comp_source) -> false)) : @complete_lattice.is_Sup_finite_compact.{0} (encodable.{0} linarith.comp_source) (@classical.by_contradiction'.{1} (complete_lattice.{0} (encodable.{0} linarith.comp_source)) h0)  := sorry --non-trivial
lemma new_lemma_64718 (h1 : ring (encodable to_additive.value_type)) : strong_rank_condition (encodable to_additive.value_type) := sorry --non-trivial
lemma new_lemma_64719 (h0 : complete_lattice (simple_graph char)) : is_compactly_generated (simple_graph char) := sorry --non-trivial
lemma new_lemma_64720 (h0 : not (filter (random_gen linarith.comp) -> false)) : filter.ne_bot (classical.by_contradiction' h0) := sorry --non-trivial
lemma new_lemma_64721 (h0 : functor.add_const (function.extfun Type monoid) environment.implicit_infer_kind) : @monoid.fg.{0} (semigroup.{0} linarith.comp) (@function.extfun_app.{2 1} Type monoid.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type monoid.{0}) environment.implicit_infer_kind h0) (semigroup.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_64722 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @totally_disconnected_space.{0} (has_norm.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_norm.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_64723 (h0 : complete_lattice (nondiscrete_normed_field linarith.ineq)) : is_compactly_generated (nondiscrete_normed_field linarith.ineq) := sorry --non-trivial
lemma new_lemma_64724 (h0 : function.extfun Type complete_lattice) : @is_compactly_generated.{0} znum (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 znum)  := sorry --non-trivial
lemma new_lemma_64725 (h0 : complete_lattice (finset (option empty))) : complete_lattice.is_Sup_finite_compact (finset (option empty)) := sorry --non-trivial
lemma new_lemma_64726 (h0 : ring (has_norm (has_norm (comm_ring fun_info)))) : is_domain (has_norm (has_norm (comm_ring fun_info))) := sorry --non-trivial
lemma new_lemma_64727 (h1 : function.extfun Type list) : list.nodup (function.extfun_app h1 (complete_semilattice_Sup congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_64728 (h0 : functor.add_const (semiring (simple_graph Type)) pos) : @is_noetherian_ring.{1} (simple_graph.{1} Type) (@functor.add_const.run.{1 0} (semiring.{1} (simple_graph.{1} Type)) pos h0)  := sorry --non-trivial
lemma new_lemma_64729 (h0 : has_mem.mem (has_top (has_norm congr_arg_kind)) has_emptyc.emptyc) : @discrete_topology.{0} (has_top.{0} (has_norm.{0} congr_arg_kind)) (@finset.pi.empty.{1 0} Type topological_space.{0} (has_top.{0} (has_norm.{0} congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_64730 (h0 : functor.comp topological_space has_neg_part Type) : @regular_space.{1} (has_neg_part.{1} Type) (@functor.comp.run.{1 1 1} topological_space.{1} has_neg_part.{1} Type h0)  := sorry --non-trivial
lemma new_lemma_64731 (h0 : functor.comp topological_space boolean_algebra.core pos) : @regular_space.{0} (boolean_algebra.core.{0} pos) (@functor.comp.run.{0 0 0} topological_space.{0} boolean_algebra.core.{0} pos h0)  := sorry --non-trivial
lemma new_lemma_64732 (h0 : ordered_add_comm_monoid (normed_comm_ring Type)) : archimedean (normed_comm_ring Type) := sorry --non-trivial
lemma new_lemma_64733 (h0 : function.extfun Type (functor.comp topological_space has_zero)) : @totally_disconnected_space.{0} (has_zero.{0} unsigned) (@functor.comp.run.{0 0 0} topological_space.{0} has_zero.{0} unsigned (@function.extfun_app.{2 1} Type (functor.comp.{0 0 0} topological_space.{0} has_zero.{0}) h0 unsigned))  := sorry --non-trivial
lemma new_lemma_64734 (h0 : ring (boolean_algebra.core (boolean_algebra unsigned))) : strong_rank_condition (boolean_algebra.core (boolean_algebra unsigned)) := sorry --non-trivial
lemma new_lemma_64735 (h0 : topological_space (has_add (complete_semilattice_Sup (with_zero linarith.ineq)))) : totally_disconnected_space (has_add (complete_semilattice_Sup (with_zero linarith.ineq))) := sorry --non-trivial
lemma new_lemma_64736 (h0 : list (with_bot (random_gen (random_gen (has_norm to_additive.value_type))))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_64737 (h0 : functor.add_const (function.extfun Type topological_space) Type) : @regular_space.{0} (comm_group.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type topological_space.{0}) Type h0) (comm_group.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_64738 (h0 : complete_lattice (has_to_string (boolean_algebra linarith.comp))) : is_compactly_generated (has_to_string (boolean_algebra linarith.comp)) := sorry --non-trivial
lemma new_lemma_64739 (h0 : group (has_add (has_neg linarith.comp))) : is_cyclic (has_add (has_neg linarith.comp)) := sorry --non-trivial
lemma new_lemma_64740 (h0 : function.extfun Type monoid) : @monoid.fg.{0} (measurable_space.{0} string_imp) (@function.extfun_app.{2 1} Type monoid.{0} h0 (measurable_space.{0} string_imp))  := sorry --non-trivial
lemma new_lemma_64741 (h0 : function.extfun Type topological_space) : @discrete_topology.{0} (has_top.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_top.{0} empty))  := sorry --non-trivial
lemma new_lemma_64742 (h0 : functor.add_const (topological_space (boolean_algebra.core pos)) pos) : @t1_space.{0} (boolean_algebra.core.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (boolean_algebra.core.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_64743 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @strong_rank_condition.{0} (measure_theory.measure_space.{0} unsigned) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (measure_theory.measure_space.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_64744 (h1 : ring (has_nnnorm (add_cancel_comm_monoid linarith.comp_source))) : is_domain (has_nnnorm (add_cancel_comm_monoid linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_64745 (h0 : ring (random_gen (comm_ring to_additive.value_type))) : rank_condition (random_gen (comm_ring to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_64746 (h0 : function.extfun Type complete_lattice) : @complete_lattice.is_Sup_finite_compact.{0} (has_top.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (has_top.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_64747 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @complete_space.{0} (semigroup.{0} linarith.comp) (@function.extfun_app.{2 1} Type uniform_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 uniform_space.{0}) (semigroup.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_64748 (h0 : functor.add_const (functor.add_const (ordered_add_comm_monoid (linear_order empty)) unsigned) num) : @archimedean.{0} (linear_order.{0} empty) (@functor.add_const.run.{0 0} (ordered_add_comm_monoid.{0} (linear_order.{0} empty)) unsigned (@functor.add_const.run.{0 0} (functor.add_const.{0 0} (ordered_add_comm_monoid.{0} (linear_order.{0} empty)) unsigned) num h0))  := sorry --non-trivial
lemma new_lemma_64749 (h0 : ordered_comm_monoid (add_comm_monoid real)) : has_exists_mul_of_le (add_comm_monoid real) := sorry --non-trivial
lemma new_lemma_64750 (h0 : function.extfun Type (functor.add_const (function.extfun Type ordered_add_comm_monoid))) : @archimedean.{0} (option.{0} name) (@function.extfun_app.{2 1} Type ordered_add_comm_monoid.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type ordered_add_comm_monoid.{0}) pos (@function.extfun_app.{2 2} Type (functor.add_const.{1 0} (function.extfun.{2 1} Type ordered_add_comm_monoid.{0})) h0 pos)) (option.{0} name))  := sorry --non-trivial
lemma new_lemma_64751 (h0 : not (ring (semi_normed_ring string.iterator_imp) -> false)) : @rank_condition.{0} (semi_normed_ring.{0} string.iterator_imp) (@classical.by_contradiction'.{1} (ring.{0} (semi_normed_ring.{0} string.iterator_imp)) h0)  := sorry --non-trivial
lemma new_lemma_64752 (h0 : fin has_zero.zero) : @is_cyclic.{0} (has_to_string.{0} real) (@matrix.vec_empty.{0} (group.{0} (has_to_string.{0} real)) (@matrix.vec_empty.{0} (fin (@has_zero.zero.{0} nat nat.has_zero)) h0))  := sorry --non-trivial
lemma new_lemma_64753 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_cyclic.{0} (linear_order.{0} unsigned) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (linear_order.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_64754 (h0 : functor.add_const (topological_space (bin_tree empty)) (semiring empty)) : @discrete_topology.{0} (bin_tree.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (bin_tree.{0} empty)) (semiring.{0} empty) h0)  := sorry --non-trivial
lemma new_lemma_64755 (h0 : ring (linear_ordered_add_comm_group to_additive.value_type)) : rank_condition (linear_ordered_add_comm_group to_additive.value_type) := sorry --non-trivial
lemma new_lemma_64756 (h0 : filter (encodable (has_nnnorm (has_nnnorm linarith.ineq)))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_64757 (h0 : function.extfun Type complete_lattice) : @is_compactly_generated.{0} (complete_linear_order.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (complete_linear_order.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_64758 (h0 : ring (has_inner empty unsigned)) : is_domain (has_inner empty unsigned) := sorry --non-trivial
lemma new_lemma_64759 (h0 : topological_space (add_cancel_monoid (has_add (finset name)))) : irreducible_space (add_cancel_monoid (has_add (finset name))) := sorry --non-trivial
lemma new_lemma_64760 (h0 : monoid (has_to_string (option (option (option (option (option unsigned))))))) : monoid.fg (has_to_string (option (option (option (option (option unsigned)))))) := sorry --non-trivial
lemma new_lemma_64761 (h0 : add_monoid (comm_semigroup (sub_neg_monoid real))) : add_monoid.fg (comm_semigroup (sub_neg_monoid real)) := sorry --non-trivial
lemma new_lemma_64762 (h0 : not (ring (has_nnnorm linarith.ineq) -> false)) : @strong_rank_condition.{0} (has_nnnorm.{0} linarith.ineq) (@classical.by_contradiction'.{1} (ring.{0} (has_nnnorm.{0} linarith.ineq)) h0)  := sorry --non-trivial
lemma new_lemma_64763 (h0 : functor.add_const (list (plift num)) num) : list.nodup (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_64764 (h0 : topological_space (complete_distrib_lattice (finset Type))) : t0_space (complete_distrib_lattice (finset Type)) := sorry --non-trivial
lemma new_lemma_64765 (h0 : topological_space (ordered_comm_monoid enat)) : totally_disconnected_space (ordered_comm_monoid enat) := sorry --non-trivial
lemma new_lemma_64766 (h0 : functor.add_const (function.extfun Type topological_space) Type) : @preirreducible_space.{0} (has_zero.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type topological_space.{0}) Type h0) (has_zero.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_64767 (h0 : fin has_zero.zero) : @irreducible_space.{0} (canonically_ordered_monoid.{0} pos) (@matrix.vec_empty.{0} (topological_space.{0} (canonically_ordered_monoid.{0} pos)) h0)  := sorry --non-trivial
lemma new_lemma_64768 (h0 : topological_space (canonically_linear_ordered_monoid string.iterator_imp)) : path_connected_space (canonically_linear_ordered_monoid string.iterator_imp) := sorry --non-trivial
lemma new_lemma_64769 (h0 : function.extfun Type complete_lattice) : @is_compactly_generated.{0} (random_gen.{0} (has_top.{0} (has_top.{0} (has_norm.{0} (has_norm.{0} (has_top.{0} empty)))))) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (random_gen.{0} (has_top.{0} (has_top.{0} (has_norm.{0} (has_norm.{0} (has_top.{0} empty)))))))  := sorry --non-trivial
lemma new_lemma_64770 (h0 : ring (boolean_algebra environment.implicit_infer_kind)) : is_domain (boolean_algebra environment.implicit_infer_kind) := sorry --non-trivial
lemma new_lemma_64771 (h0 : functor.add_const (topological_space (has_to_string Type)) pos) : @t1_space.{1} (has_to_string.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (has_to_string.{1} Type)) pos h0)  := sorry --non-trivial
lemma new_lemma_64772 (h0 : uniform_space (semigroup (semigroup unsigned))) : complete_space (semigroup (semigroup unsigned)) := sorry --non-trivial
lemma new_lemma_64773 (h0 : not (functor.add_const Prop (has_star congr_arg_kind) -> false)) : functor.add_const.run (classical.by_contradiction' h0) := sorry --non-trivial
lemma new_lemma_64774 (h0 : group (has_ssubset (has_top char))) : group.fg (has_ssubset (has_top char)) := sorry --non-trivial
lemma new_lemma_64775 (h0 : complete_lattice (linear_ordered_semiring (semiring congr_arg_kind))) : complete_lattice.is_Sup_finite_compact (linear_ordered_semiring (semiring congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_64776 (h0 : not (group (random_gen linarith.ineq) -> false)) : @group.fg.{0} (random_gen.{0} linarith.ineq) (@classical.by_contradiction'.{1} (group.{0} (random_gen.{0} linarith.ineq)) h0)  := sorry --non-trivial
lemma new_lemma_64777 (h0 : function.extfun Type monoid) : @monoid.fg.{0} (denumerable.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type monoid.{0} h0 (denumerable.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_64778 (h0 : topological_space (has_nndist (lattice pos))) : t0_space (has_nndist (lattice pos)) := sorry --non-trivial
lemma new_lemma_64779 (h0 : function.extfun Type complete_lattice) : @is_atomistic.{0} (left_cancel_monoid.{0} (semiring.{0} empty)) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (left_cancel_monoid.{0} (semiring.{0} empty)))  := sorry --non-trivial
lemma new_lemma_64780 (h0 : group (canonically_linear_ordered_monoid (option ennreal))) : normalizer_condition (canonically_linear_ordered_monoid (option ennreal)) := sorry --non-trivial
lemma new_lemma_64781 (h0 : function.extfun Type ordered_comm_monoid) : @has_exists_mul_of_le.{0} (mul_zero_class.{0} pos) (@function.extfun_app.{2 1} Type ordered_comm_monoid.{0} h0 (mul_zero_class.{0} pos))  := sorry --non-trivial
lemma new_lemma_64782 (h1 : uniform_space (linear_ordered_add_comm_group linarith.comp_source)) : complete_space (linear_ordered_add_comm_group linarith.comp_source) := sorry --non-trivial
lemma new_lemma_64783 (h0 : functor.add_const (function.extfun Type topological_space) name) : @preconnected_space.{0} (add_cancel_monoid.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) name h0) (add_cancel_monoid.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_64784 (h0 : functor.add_const (topological_space (has_to_string name)) linarith.comp) : @preirreducible_space.{0} (has_to_string.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (has_to_string.{0} name)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_64785 (h0 : functor.add_const (topological_space (canonically_ordered_comm_semiring ennreal)) name) : @preconnected_space.{0} (canonically_ordered_comm_semiring.{0} ennreal) (@functor.add_const.run.{0 0} (topological_space.{0} (canonically_ordered_comm_semiring.{0} ennreal)) name h0)  := sorry --non-trivial
lemma new_lemma_64786 (h0 : uniform_space (has_top char)) : complete_space (has_top char) := sorry --non-trivial
lemma new_lemma_64787 (h0 : functor.add_const (topological_space (add_comm_monoid pos)) pos) : @irreducible_space.{0} (add_comm_monoid.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (add_comm_monoid.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_64788 (h0 : not (list (left_cancel_semigroup empty) -> false)) : list.nodup (classical.by_contradiction' h0) := sorry --non-trivial
lemma new_lemma_64789 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : countable_Inter_filter (function.extfun_app (function.extfun_app h0 filter) (semigroup pos)) := sorry --non-trivial
lemma new_lemma_64790 (h0 : functor.add_const (topological_space (free_add_monoid empty)) num) : @totally_separated_space.{0} (free_add_monoid.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (free_add_monoid.{0} empty)) num h0)  := sorry --non-trivial
lemma new_lemma_64791 (h0 : complete_semilattice_Sup empty -> complete_semilattice_Sup empty -> Prop) : is_equiv (complete_semilattice_Sup empty) h0 := sorry --non-trivial
lemma new_lemma_64792 (h0 : ordered_add_comm_monoid (has_nndist ennreal)) : archimedean (has_nndist ennreal) := sorry --non-trivial
lemma new_lemma_64793 (h0 : functor.add_const (topological_space (has_neg_part pos)) name) : @sequential_space.{0} (has_neg_part.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (has_neg_part.{0} pos)) name h0)  := sorry --non-trivial
lemma new_lemma_64794 (h0 : not (add_monoid (measure_theory.measure_space empty) -> false)) (h1 : function.extfun (Type -> Type) (function.extfun Type)) : @char_zero.{0} (measure_theory.measure_space.{0} empty) (@classical.by_contradiction'.{1} (add_monoid.{0} (measure_theory.measure_space.{0} empty)) h0) (@function.extfun_app.{2 1} Type has_one.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h1 has_one.{0}) (measure_theory.measure_space.{0} empty))  := sorry --non-trivial
lemma new_lemma_64795 (h0 : functor.add_const (ring (ordered_comm_ring linarith.comp)) name) : @strong_rank_condition.{0} (ordered_comm_ring.{0} linarith.comp) (@functor.add_const.run.{0 0} (ring.{0} (ordered_comm_ring.{0} linarith.comp)) name h0)  := sorry --non-trivial
lemma new_lemma_64796 (h0 : functor.add_const (topological_space (has_zero linarith.comp)) Type) : @irreducible_space.{0} (has_zero.{0} linarith.comp) (@functor.add_const.run.{0 1} (topological_space.{0} (has_zero.{0} linarith.comp)) Type h0)  := sorry --non-trivial
lemma new_lemma_64797 (h0 : complete_lattice (has_add (finset (has_neg (has_neg linarith.comp))))) : is_compactly_generated (has_add (finset (has_neg (has_neg linarith.comp)))) := sorry --non-trivial
lemma new_lemma_64798 (h0 : not (function.extfun Type topological_space -> false)) : @totally_separated_space.{0} (add_group.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (add_group.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_64799 (h0 : topological_space (has_to_string (has_to_string (comm_group unsigned)))) : t0_space (has_to_string (has_to_string (comm_group unsigned))) := sorry --non-trivial
lemma new_lemma_64800 (h0 : filter (semigroup (has_add environment.implicit_infer_kind))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_64801 (h0 : group (non_unital_non_assoc_semiring linarith.comp_source)) : is_cyclic (non_unital_non_assoc_semiring linarith.comp_source) := sorry --non-trivial
lemma new_lemma_64802 (h0 : list (semigroup (semiring (option congr_arg_kind)))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_64803 (h0 : function.extfun Type topological_space) : @topological_space.separable_space.{0} (normed_comm_ring.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (normed_comm_ring.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_64804 (h0 : topological_space (has_inv (has_nnnorm (has_nnnorm (has_nnnorm linarith.comp_source))))) : path_connected_space (has_inv (has_nnnorm (has_nnnorm (has_nnnorm linarith.comp_source)))) := sorry --non-trivial
lemma new_lemma_64805 (h0 : function.extfun Type (functor.add_const (complete_lattice (semigroup (semiring empty))))) : @complete_lattice.is_Sup_finite_compact.{0} (semigroup.{0} (semiring.{0} empty)) (@functor.add_const.run.{0 0} (complete_lattice.{0} (semigroup.{0} (semiring.{0} empty))) empty (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (complete_lattice.{0} (semigroup.{0} (semiring.{0} empty)))) h0 empty))  := sorry --non-trivial
lemma new_lemma_64806 (h0 : ring (normed_lattice_add_comm_group (has_Inf Type))) : rank_condition (normed_lattice_add_comm_group (has_Inf Type)) := sorry --non-trivial
lemma new_lemma_64807 (h0 : has_mem.mem (normed_group empty) has_emptyc.emptyc) : @totally_disconnected_space.{0} (normed_group.{0} empty) (@finset.pi.empty.{1 0} Type topological_space.{0} (normed_group.{0} empty) h0)  := sorry --non-trivial
lemma new_lemma_64808 (h0 : ring (has_append (has_nnnorm linarith.ineq))) : rank_condition (has_append (has_nnnorm linarith.ineq)) := sorry --non-trivial
lemma new_lemma_64809 (h0 : functor.add_const (complete_lattice (ordered_cancel_add_comm_monoid ennreal)) num) : @is_compactly_generated.{0} (ordered_cancel_add_comm_monoid.{0} ennreal) (@functor.add_const.run.{0 0} (complete_lattice.{0} (ordered_cancel_add_comm_monoid.{0} ennreal)) num h0)  := sorry --non-trivial
lemma new_lemma_64810 (h0 : function.extfun Type uniform_space) : @complete_space.{0} (is_R_or_C.{0} num) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (is_R_or_C.{0} num))  := sorry --non-trivial
lemma new_lemma_64811 (h0 : function.extfun Type cancel_comm_monoid_with_zero) : @unique_factorization_monoid.{0} (boolean_algebra.{0} real) (@function.extfun_app.{2 1} Type cancel_comm_monoid_with_zero.{0} h0 (boolean_algebra.{0} real))  := sorry --non-trivial
lemma new_lemma_64812 (h0 : topological_space (measure_theory.measure_space empty)) : preirreducible_space (measure_theory.measure_space empty) := sorry --non-trivial
lemma new_lemma_64813 (h4 : ring (random_gen string_imp)) : is_domain (random_gen string_imp) := sorry --non-trivial
lemma new_lemma_64814 (h0 : function.extfun Type monoid) : @monoid.fg.{0} (@id.{2} Type linarith.comp) (@function.extfun_app.{2 1} Type monoid.{0} h0 (@id.{2} Type linarith.comp))  := sorry --non-trivial
lemma new_lemma_64815 (h0 : topological_space (normed_linear_ordered_group (semiring num))) : discrete_topology (normed_linear_ordered_group (semiring num)) := sorry --non-trivial
lemma new_lemma_64816 (h0 : complete_lattice (has_top linarith.ineq)) : is_compactly_generated (has_top linarith.ineq) := sorry --non-trivial
lemma new_lemma_64817 (h0 : not (has_mem.mem (random_gen num) has_emptyc.emptyc -> false)) : @is_compactly_generated.{0} (random_gen.{0} num) (@finset.pi.empty.{1 0} Type complete_lattice.{0} (random_gen.{0} num) (@classical.by_contradiction'.{0} (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (random_gen.{0} num) (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))) h0))  := sorry --non-trivial
lemma new_lemma_64818 (h0 : not (group (semiring congr_arg_kind) -> false)) : @group.fg.{0} (semiring.{0} congr_arg_kind) (@classical.by_contradiction'.{1} (group.{0} (semiring.{0} congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_64819 (h0 : not (list (has_norm fun_info) -> false)) : list.nodup (classical.by_contradiction' h0) := sorry --non-trivial
lemma new_lemma_64820 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @complete_space.{0} (cancel_monoid.{0} empty) (@function.extfun_app.{2 1} Type uniform_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 uniform_space.{0}) (cancel_monoid.{0} empty))  := sorry --non-trivial
lemma new_lemma_64821 (h0 : add_group (metric_space (semiring congr_arg_kind))) : is_add_cyclic (metric_space (semiring congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_64822 (h0 : filter (has_norm string_imp)) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_64823 (h0 : function.extfun Type topological_space) : @locally_compact_space.{0} (has_ssubset.{0} char) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_ssubset.{0} char))  := sorry --non-trivial
lemma new_lemma_64824 (h0 : list (normed_group Type)) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_64825 (h0 : functor.add_const (list (comm_group pos)) unsigned) : list.nodup (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_64826 (h0 : topological_space (comm_monoid (option unsigned))) : path_connected_space (comm_monoid (option unsigned)) := sorry --non-trivial
lemma new_lemma_64827 (h0 : topological_space (add_left_cancel_semigroup (semiring (semiring unsigned)))) : path_connected_space (add_left_cancel_semigroup (semiring (semiring unsigned))) := sorry --non-trivial
lemma new_lemma_64828 (h0 : filter (distrib to_additive.value_type)) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_64829 (h1 : topological_space (has_append (denumerable char))) : t0_space (has_append (denumerable char)) := sorry --non-trivial
lemma new_lemma_64830 (h0 : ereal -> ereal -> Prop) : is_preorder ereal h0 := sorry --non-trivial
lemma new_lemma_64831 (h1 : not (group linarith.comp_source -> false)) : @is_cyclic.{0} linarith.comp_source (@classical.by_contradiction'.{1} (group.{0} linarith.comp_source) h1)  := sorry --non-trivial
lemma new_lemma_64832 (h0 : not (function.extfun Type topological_space -> false)) : @irreducible_space.{0} (random_gen.{0} fun_info) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (random_gen.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_64833 (h0 : topological_space (boolean_algebra (has_neg pos))) : sequential_space (boolean_algebra (has_neg pos)) := sorry --non-trivial
lemma new_lemma_64834 (h0 : not (function.extfun Type topological_space -> false)) : @t0_space.{0} (has_emptyc.{0} linarith.ineq) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (has_emptyc.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_64835 (h0 : not (uniform_space (comm_ring string_imp) -> false)) : @complete_space.{0} (comm_ring.{0} string_imp) (@classical.by_contradiction'.{1} (uniform_space.{0} (comm_ring.{0} string_imp)) h0)  := sorry --non-trivial
lemma new_lemma_64836 (h0 : group (partial_order congr_arg_kind)) : normalizer_condition (partial_order congr_arg_kind) := sorry --non-trivial
lemma new_lemma_64837 (h0 : ring (has_zero num)) : is_domain (has_zero num) := sorry --non-trivial
lemma new_lemma_64838 (h0 : group (cancel_monoid (has_add name))) : group.fg (cancel_monoid (has_add name)) := sorry --non-trivial
lemma new_lemma_64839 (h0 : complete_lattice (add_left_cancel_semigroup (random_gen (random_gen char)))) : complete_lattice.is_Sup_finite_compact (add_left_cancel_semigroup (random_gen (random_gen char))) := sorry --non-trivial
lemma new_lemma_64840 (h0 : ring (finset (generalized_boolean_algebra Type))) : is_principal_ideal_ring (finset (generalized_boolean_algebra Type)) := sorry --non-trivial
lemma new_lemma_64841 (h0 : ring (random_gen (has_top linarith.comp_source))) : strong_rank_condition (random_gen (has_top linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_64842 (h0 : filter Prop) : @filter.Limsup.{0} Prop (@complete_lattice.to_conditionally_complete_lattice.{0} Prop Prop.complete_lattice) h0  := sorry --non-trivial
lemma new_lemma_64843 (h0 : cancel_comm_monoid_with_zero (linear_ordered_field pos)) : unique_factorization_monoid (linear_ordered_field pos) := sorry --non-trivial
lemma new_lemma_64844 (h0 : topological_space (sub_neg_monoid (has_Inf real))) : locally_compact_space (sub_neg_monoid (has_Inf real)) := sorry --non-trivial
lemma new_lemma_64845 (h0 : functor.add_const (function.extfun Type topological_space) linarith.comp) : @discrete_topology.{0} (has_pos_part.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) linarith.comp h0) (has_pos_part.{0} pos))  := sorry --non-trivial
lemma new_lemma_64846 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @totally_disconnected_space.{0} (has_Inf.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_Inf.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_64847 (h0 : functor.add_const (topological_space (option congr_arg_kind)) unsigned) : @t0_space.{0} (option.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (option.{0} congr_arg_kind)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_64848 (h1 : topological_space (nondiscrete_normed_field ereal)) : totally_disconnected_space (nondiscrete_normed_field ereal) := sorry --non-trivial
lemma new_lemma_64849 (h0 : functor.add_const (finset (comm_group environment.implicit_infer_kind)) pos) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_64850 (h0 : functor.add_const (complete_lattice (has_to_string linarith.comp)) pos) : @is_compactly_generated.{0} (has_to_string.{0} linarith.comp) (@functor.add_const.run.{0 0} (complete_lattice.{0} (has_to_string.{0} linarith.comp)) pos h0)  := sorry --non-trivial
lemma new_lemma_64851 (h0 : functor.add_const (function.extfun (Type 1) topological_space) (has_neg name)) : @normal_space.{1} (has_pos_part.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) topological_space.{1}) (has_neg.{0} name) h0) (has_pos_part.{1} Type))  := sorry --non-trivial
lemma new_lemma_64852 (h0 : topological_space (ordered_comm_monoid (ring (ring Type)))) : preirreducible_space (ordered_comm_monoid (ring (ring Type))) := sorry --non-trivial
lemma new_lemma_64853 (h0 : group (has_add (option ennreal))) : is_simple_group (has_add (option ennreal)) := sorry --non-trivial
lemma new_lemma_64854 (h1 : uniform_space (has_emptyc (has_inv string_imp))) : complete_space (has_emptyc (has_inv string_imp)) := sorry --non-trivial
lemma new_lemma_64855 (h0 : topological_space (ordered_comm_monoid pos)) : totally_separated_space (ordered_comm_monoid pos) := sorry --non-trivial
lemma new_lemma_64856 (h0 : topological_space (id congr_arg_kind)) : normal_space (id congr_arg_kind) := sorry --non-trivial
lemma new_lemma_64857 (h0 : functor.add_const (ring (left_cancel_monoid empty)) unsigned) : @strong_rank_condition.{0} (left_cancel_monoid.{0} empty) (@functor.add_const.run.{0 0} (ring.{0} (left_cancel_monoid.{0} empty)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_64858 (h0 : functor.add_const (ring (has_neg Type)) (has_pos_part pos)) : @strong_rank_condition.{1} (has_neg.{1} Type) (@functor.add_const.run.{1 0} (ring.{1} (has_neg.{1} Type)) (has_pos_part.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_64859 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_noetherian_ring.{0} (cancel_monoid.{0} unsigned) (@function.extfun_app.{2 1} Type semiring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 semiring.{0}) (cancel_monoid.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_64860 (h0 : topological_space (has_add (has_to_string (finset pos)))) : totally_separated_space (has_add (has_to_string (finset pos))) := sorry --non-trivial
lemma new_lemma_64861 (h0 : function.extfun Type topological_space) : @irreducible_space.{0} (encodable.{0} linarith.ineq) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (encodable.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_64862 (h1 : complete_lattice (simple_graph (mul_one_class string.iterator_imp))) : is_compactly_generated (simple_graph (mul_one_class string.iterator_imp)) := sorry --non-trivial
lemma new_lemma_64863 (h0 : topological_space (has_compl (mul_one_class fun_info))) : t0_space (has_compl (mul_one_class fun_info)) := sorry --non-trivial
lemma new_lemma_64864 (h0 : semiring (complete_distrib_lattice environment.implicit_infer_kind)) : is_noetherian_ring (complete_distrib_lattice environment.implicit_infer_kind) := sorry --non-trivial
lemma new_lemma_64865 (h0 : complete_lattice (boolean_algebra (has_bot pos))) : is_compactly_generated (boolean_algebra (has_bot pos)) := sorry --non-trivial
lemma new_lemma_64866 (h0 : group (has_bot (has_bot Type))) : normalizer_condition (has_bot (has_bot Type)) := sorry --non-trivial
lemma new_lemma_64867 (h0 : topological_space (option (semiring (semiring num)))) : topological_space.separable_space (option (semiring (semiring num))) := sorry --non-trivial
lemma new_lemma_64868 (h0 : list (linear_ordered_add_comm_group (has_inv to_additive.value_type))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_64869 (h0 : functor.add_const (ordered_add_comm_monoid (cancel_monoid name)) unsigned) : @archimedean.{0} (cancel_monoid.{0} name) (@functor.add_const.run.{0 0} (ordered_add_comm_monoid.{0} (cancel_monoid.{0} name)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_64870 (h0 : topological_space (ring (has_to_string pos))) : t0_space (ring (has_to_string pos)) := sorry --non-trivial
lemma new_lemma_64871 (h0 : function.extfun Type topological_space) : @normal_space.{0} (add_group.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (add_group.{0} empty))  := sorry --non-trivial
lemma new_lemma_64872 (h0 : topological_space (measurable_space.dynkin_system (semiring num))) : topological_space.separable_space (measurable_space.dynkin_system (semiring num)) := sorry --non-trivial
lemma new_lemma_64873 (h0 : topological_space (boolean_algebra (mul_one_class (has_add pos)))) : regular_space (boolean_algebra (mul_one_class (has_add pos))) := sorry --non-trivial
lemma new_lemma_64874 (h0 : topological_space (has_nnnorm ereal)) (h1 : add_group (has_nnnorm ereal)) : topological_add_group (has_nnnorm ereal) := sorry --non-trivial
lemma new_lemma_64875 (h0 : topological_space (ordered_comm_ring (has_add Type))) : topological_space.separable_space (ordered_comm_ring (has_add Type)) := sorry --non-trivial
lemma new_lemma_64876 (h1 : has_mem.mem (has_top congr_arg_kind) has_emptyc.emptyc) : @totally_disconnected_space.{0} (has_top.{0} congr_arg_kind) (@finset.pi.empty.{1 0} Type topological_space.{0} (has_top.{0} congr_arg_kind) h1)  := sorry --non-trivial
lemma new_lemma_64877 (h0 : functor.add_const (group (ring num)) num) : @is_cyclic.{0} (ring.{0} num) (@functor.add_const.run.{0 0} (group.{0} (ring.{0} num)) num h0)  := sorry --non-trivial
lemma new_lemma_64878 (h0 : topological_space (add_cancel_monoid (has_Inf (has_pos_part (has_Inf Type))))) : topological_space.separable_space (add_cancel_monoid (has_Inf (has_pos_part (has_Inf Type)))) := sorry --non-trivial
lemma new_lemma_64879 (h0 : group (ring (has_pos_part (has_Inf (has_Inf linarith.comp))))) : is_simple_group (ring (has_pos_part (has_Inf (has_Inf linarith.comp)))) := sorry --non-trivial
lemma new_lemma_64880 (h0 : topological_space (complete_semilattice_Sup (semiring congr_arg_kind))) : totally_separated_space (complete_semilattice_Sup (semiring congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_64881 (h0 : not (add_group (random_gen empty) -> false)) : @is_add_cyclic.{0} (random_gen.{0} empty) (@classical.by_contradiction'.{1} (add_group.{0} (random_gen.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_64882 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_domain.{0} (ring.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (ring.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_64883 (h0 : topological_space (complete_semilattice_Sup (complete_semilattice_Sup linarith.comp))) : totally_disconnected_space (complete_semilattice_Sup (complete_semilattice_Sup linarith.comp)) := sorry --non-trivial
lemma new_lemma_64884 (h1 : ring (normed_field (normed_field ereal))) : is_domain (normed_field (normed_field ereal)) := sorry --non-trivial
lemma new_lemma_64885 (h0 : add_group (pseudo_metric_space (option ennreal))) : is_add_cyclic (pseudo_metric_space (option ennreal)) := sorry --non-trivial
lemma new_lemma_64886 (h0 : functor.add_const (complete_lattice (add_cancel_monoid Type)) (has_add linarith.comp)) : @is_atomistic.{1} (add_cancel_monoid.{1} Type) (@functor.add_const.run.{1 0} (complete_lattice.{1} (add_cancel_monoid.{1} Type)) (has_add.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_64887 (h0 : uniform_space (canonically_ordered_comm_semiring (option (option (option (option unsigned)))))) : complete_space (canonically_ordered_comm_semiring (option (option (option (option unsigned))))) := sorry --non-trivial
lemma new_lemma_64888 (h1 : ring (semi_normed_ring (random_gen (random_gen reducibility_hints)))) : strong_rank_condition (semi_normed_ring (random_gen (random_gen reducibility_hints))) := sorry --non-trivial
lemma new_lemma_64889 (h0 : filter (linear_ordered_add_comm_group (has_nnnorm char))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_64890 (h0 : topological_space (add_cancel_monoid pos)) : totally_disconnected_space (add_cancel_monoid pos) := sorry --non-trivial
lemma new_lemma_64891 (h0 : topological_space (cancel_monoid (has_neg name))) : normal_space (cancel_monoid (has_neg name)) := sorry --non-trivial
lemma new_lemma_64892 (h0 : function.extfun Type add_monoid) : @add_monoid.fg.{0} linarith.comp (@function.extfun_app.{2 1} Type add_monoid.{0} h0 linarith.comp)  := sorry --non-trivial
lemma new_lemma_64893 (h0 : functor.add_const (topological_space (has_neg linarith.comp)) linarith.comp) : @totally_disconnected_space.{0} (has_neg.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (has_neg.{0} linarith.comp)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_64894 (h0 : has_neg (has_nnnorm enat)) (h1 : measurable_space (has_nnnorm enat)) : has_measurable_neg (has_nnnorm enat) := sorry --non-trivial
lemma new_lemma_64895 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @complete_lattice.is_Sup_finite_compact.{0} (measure_theory.measure_space.{0} num) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (measure_theory.measure_space.{0} num))  := sorry --non-trivial
lemma new_lemma_64896 (h0 : group (with_bot (semiring (semiring (semiring linarith.comp))))) : normalizer_condition (with_bot (semiring (semiring (semiring linarith.comp)))) := sorry --non-trivial
lemma new_lemma_64897 (h0 : topological_space (normed_linear_ordered_group empty)) : totally_separated_space (normed_linear_ordered_group empty) := sorry --non-trivial
lemma new_lemma_64898 (h0 : topological_space (has_emptyc (has_top fun_info))) : irreducible_space (has_emptyc (has_top fun_info)) := sorry --non-trivial
lemma new_lemma_64899 (h0 : functor.add_const (topological_space (ring name)) pos) : @discrete_topology.{0} (ring.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (ring.{0} name)) pos h0)  := sorry --non-trivial
lemma new_lemma_64900 (h0 : topological_space (has_le char)) : totally_disconnected_space (has_le char) := sorry --non-trivial
lemma new_lemma_64901 (h0 : prod (has_sub (semiring (has_top unsigned))) (has_sub (semiring (has_top unsigned)))) : id_rel h0 := sorry --non-trivial
lemma new_lemma_64902 (h0 : group (left_cancel_monoid num)) : group.fg (left_cancel_monoid num) := sorry --non-trivial
lemma new_lemma_64903 (h0 : ring (ordered_comm_ring (has_neg pos))) : rank_condition (ordered_comm_ring (has_neg pos)) := sorry --non-trivial
lemma new_lemma_64904 (h1 : set reducibility_hints) : set.subsingleton h1 := sorry --non-trivial
lemma new_lemma_64905 (h0 : not (complete_lattice (dlist to_additive.value_type) -> false)) : @complete_lattice.is_Sup_finite_compact.{0} (dlist.{0} to_additive.value_type) (@classical.by_contradiction'.{1} (complete_lattice.{0} (dlist.{0} to_additive.value_type)) h0)  := sorry --non-trivial
lemma new_lemma_64906 (h2 : not (filter (distrib to_additive.value_type) -> false)) : filter.ne_bot (classical.by_contradiction' h2) := sorry --non-trivial
lemma new_lemma_64907 (h0 : group (add_cancel_comm_monoid (denumerable linarith.ineq))) : is_cyclic (add_cancel_comm_monoid (denumerable linarith.ineq)) := sorry --non-trivial
lemma new_lemma_64908 (h0 : ring (distrib (has_div enat))) : rank_condition (distrib (has_div enat)) := sorry --non-trivial
lemma new_lemma_64909 (h0 : functor.add_const (ring (boolean_algebra pos)) (has_neg_part (comm_group Type))) : @rank_condition.{0} (boolean_algebra.{0} pos) (@functor.add_const.run.{0 1} (ring.{0} (boolean_algebra.{0} pos)) (has_neg_part.{1} (comm_group.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_64910 (h0 : complete_lattice (mul_zero_class (boolean_algebra.core environment.implicit_infer_kind))) : is_atomistic (mul_zero_class (boolean_algebra.core environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_64911 (h0 : function.extfun Type topological_space) : @path_connected_space.{0} (with_one.{0} (comm_ring.{0} linarith.ineq)) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (with_one.{0} (comm_ring.{0} linarith.ineq)))  := sorry --non-trivial
lemma new_lemma_64912 (h0 : topological_space (has_bot (option empty))) : normal_space (has_bot (option empty)) := sorry --non-trivial
lemma new_lemma_64913 (h0 : functor.add_const (add_monoid (has_zero linarith.comp)) (has_to_string pos)) : @add_monoid.fg.{0} (has_zero.{0} linarith.comp) (@functor.add_const.run.{0 0} (add_monoid.{0} (has_zero.{0} linarith.comp)) (has_to_string.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_64914 (h0 : list (comm_group unsigned)) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_64915 (h0 : function.extfun (finset Type) (has_mem.mem (linear_ordered_semiring num))) : @group.fg.{0} (linear_ordered_semiring.{0} num) (@finset.pi.empty.{1 0} Type group.{0} (linear_ordered_semiring.{0} num) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (linear_ordered_semiring.{0} num)) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_64916 (h0 : function.extfun Type (functor.add_const (finset (ring pos)))) : finset.nonempty (functor.add_const.run (function.extfun_app h0 linarith.comp)) := sorry --non-trivial
lemma new_lemma_64917 (h0 : function.extfun Type topological_space) : @preirreducible_space.{0} (has_neg.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_neg.{0} name))  := sorry --non-trivial
lemma new_lemma_64918 (h0 : function.extfun Type topological_space) : @discrete_topology.{0} (semigroup.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (semigroup.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_64919 (h0 : functor.add_const (add_group (ordered_comm_ring Type)) (has_neg pos)) : @is_add_cyclic.{1} (ordered_comm_ring.{1} Type) (@functor.add_const.run.{1 0} (add_group.{1} (ordered_comm_ring.{1} Type)) (has_neg.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_64920 (h0 : function.extfun Type ring) : @is_domain.{0} (complete_distrib_lattice.{0} ennreal) (@function.extfun_app.{2 1} Type ring.{0} h0 (complete_distrib_lattice.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_64921 (h0 : topological_space (linear_ordered_comm_ring (semiring (semiring (semiring empty))))) : totally_disconnected_space (linear_ordered_comm_ring (semiring (semiring (semiring empty)))) := sorry --non-trivial
lemma new_lemma_64922 (h0 : topological_space (boolean_algebra.core (has_add (ring environment.implicit_infer_kind)))) : t1_space (boolean_algebra.core (has_add (ring environment.implicit_infer_kind))) := sorry --non-trivial
lemma new_lemma_64923 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @group.fg.{1} (comm_group.{1} Type) (@function.extfun_app.{3 2} (Type 1) group.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 group.{1}) (comm_group.{1} Type))  := sorry --non-trivial
lemma new_lemma_64924 (h0 : has_mem.mem (has_top num) has_emptyc.emptyc) : @is_domain.{0} (has_top.{0} num) (@finset.pi.empty.{1 0} Type ring.{0} (has_top.{0} num) h0)  := sorry --non-trivial
lemma new_lemma_64925 (h0 : functor.add_const (ring (has_to_string pos)) pos) : @is_domain.{0} (has_to_string.{0} pos) (@functor.add_const.run.{0 0} (ring.{0} (has_to_string.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_64926 (h0 : functor.add_const (group (ring Type)) (has_pos_part Type)) : @is_simple_group.{1} (ring.{1} Type) (@functor.add_const.run.{1 1} (group.{1} (ring.{1} Type)) (has_pos_part.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_64927 (h0 : function.extfun Type topological_space) : @t0_space.{0} (sub_neg_monoid.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (sub_neg_monoid.{0} pos))  := sorry --non-trivial
lemma new_lemma_64928 (h0 : complete_lattice (add_left_cancel_semigroup unsigned)) : complete_lattice.is_Sup_finite_compact (add_left_cancel_semigroup unsigned) := sorry --non-trivial
lemma new_lemma_64929 (h0 : functor.add_const (finset (partial_order num)) congr_arg_kind) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_64930 (h0 : filter (ring (has_neg linarith.comp))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_64931 (h0 : function.extfun (ring ennreal) (fun (x : ring ennreal), Prop)) (h1 : set (ring ennreal)) : set.subset (function.extfun_app h0) h1 := sorry --non-trivial
lemma new_lemma_64932 (h0 : topological_space (has_inv (with_one (has_nnnorm char)))) : locally_compact_space (has_inv (with_one (has_nnnorm char))) := sorry --non-trivial
lemma new_lemma_64933 (h0 : ring ereal) : strong_rank_condition ereal := sorry --non-trivial
lemma new_lemma_64934 (h0 : topological_space (comm_group (has_to_string (cancel_monoid ennreal)))) : totally_separated_space (comm_group (has_to_string (cancel_monoid ennreal))) := sorry --non-trivial
lemma new_lemma_64935 (h0 : function.extfun nat fin) : @regular_space.{1} (sub_neg_monoid.{1} Type) (@matrix.vec_empty.{1} (topological_space.{1} (sub_neg_monoid.{1} Type)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_64936 (h0 : function.extfun Type complete_lattice) : @complete_lattice.is_Sup_finite_compact.{0} (linear_ordered_comm_monoid_with_zero.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (linear_ordered_comm_monoid_with_zero.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_64937 (h0 : topological_space (semiring (has_norm num))) : path_connected_space (semiring (has_norm num)) := sorry --non-trivial
lemma new_lemma_64938 (h0 : topological_space (complete_distrib_lattice (ring Type))) : discrete_topology (complete_distrib_lattice (ring Type)) := sorry --non-trivial
lemma new_lemma_64939 (h0 : complete_lattice (add_cancel_monoid (finset linarith.comp))) : complete_lattice.is_Sup_finite_compact (add_cancel_monoid (finset linarith.comp)) := sorry --non-trivial
lemma new_lemma_64940 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @path_connected_space.{0} (monoid_with_zero.{0} ennreal) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (monoid_with_zero.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_64941 (h0 : function.extfun Type topological_space) : @totally_disconnected_space.{0} (canonically_linear_ordered_monoid.{0} ennreal) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (canonically_linear_ordered_monoid.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_64942 (h0 : not (complete_lattice (metric_space congr_arg_kind) -> false)) : @is_atomistic.{0} (metric_space.{0} congr_arg_kind) (@classical.by_contradiction'.{1} (complete_lattice.{0} (metric_space.{0} congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_64943 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @strong_rank_condition.{0} (has_neg_part.{0} name) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (has_neg_part.{0} name))  := sorry --non-trivial
lemma new_lemma_64944 (h0 : ring (topological_space (comm_semigroup (comm_ring char)))) : strong_rank_condition (topological_space (comm_semigroup (comm_ring char))) := sorry --non-trivial
lemma new_lemma_64945 (h0 : function.extfun Type filter) : countable_Inter_filter (function.extfun_app h0 (has_inter unsigned)) := sorry --non-trivial
lemma new_lemma_64946 (h0 : has_mem.mem (random_gen num) has_emptyc.emptyc) : @is_compactly_generated.{0} (random_gen.{0} num) (@finset.pi.empty.{1 0} Type complete_lattice.{0} (random_gen.{0} num) h0)  := sorry --non-trivial
lemma new_lemma_64947 (h0 : complete_lattice (mul_zero_class (semiring (semiring unsigned)))) : is_atomistic (mul_zero_class (semiring (semiring unsigned))) := sorry --non-trivial
lemma new_lemma_64948 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : list.nodup (function.extfun_app (function.extfun_app h0 list) (has_add ennreal)) := sorry --non-trivial
lemma new_lemma_64949 (h0 : functor.add_const (topological_space (mul_zero_class Type)) Type) : @totally_disconnected_space.{1} (mul_zero_class.{1} Type) (@functor.add_const.run.{1 1} (topological_space.{1} (mul_zero_class.{1} Type)) Type h0)  := sorry --non-trivial
lemma new_lemma_64950 (h0 : group (has_neg (finset (has_neg (finset linarith.comp))))) : normalizer_condition (has_neg (finset (has_neg (finset linarith.comp)))) := sorry --non-trivial
lemma new_lemma_64951 (h0 : group (normed_comm_ring (normed_comm_ring Type))) : group.fg (normed_comm_ring (normed_comm_ring Type)) := sorry --non-trivial
lemma new_lemma_64952 (h0 : topological_space (linear_ordered_cancel_comm_monoid num)) : discrete_topology (linear_ordered_cancel_comm_monoid num) := sorry --non-trivial
lemma new_lemma_64953 (h0 : functor.add_const (topological_space (option unsigned)) unsigned) : @normal_space.{0} (option.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (option.{0} unsigned)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_64954 (h0 : functor.add_const (function.extfun (Type 1) filter) linarith.comp) : countable_Inter_filter (function.extfun_app (functor.add_const.run h0) (boolean_algebra Type)) := sorry --non-trivial
lemma new_lemma_64955 (h0 : topological_space (finset (has_pos_part (has_pos_part (normed_comm_ring Type))))) : totally_separated_space (finset (has_pos_part (has_pos_part (normed_comm_ring Type)))) := sorry --non-trivial
lemma new_lemma_64956 (h0 : ring (ordered_comm_group (option (option empty)))) : rank_condition (ordered_comm_group (option (option empty))) := sorry --non-trivial
lemma new_lemma_64957 (h0 : set (add_comm_semigroup string.iterator_imp -> std_gen)) : set.separates_points h0 := sorry --non-trivial
lemma new_lemma_64958 (h0 : functor.comp ring cancel_monoid Type) : @is_domain.{1} (cancel_monoid.{1} Type) (@functor.comp.run.{1 1 1} ring.{1} cancel_monoid.{1} Type h0)  := sorry --non-trivial
lemma new_lemma_64959 (h0 : add_group (has_Sup (semiring (semiring (semiring empty))))) : is_add_cyclic (has_Sup (semiring (semiring (semiring empty)))) := sorry --non-trivial
lemma new_lemma_64960 (h0 : fin has_zero.zero) : @is_compactly_generated.{0} (boolean_algebra.{0} real) (@matrix.vec_empty.{0} (complete_lattice.{0} (boolean_algebra.{0} real)) h0)  := sorry --non-trivial
lemma new_lemma_64961 (h0 : add_group (generalized_boolean_algebra (has_neg Type))) : is_add_cyclic (generalized_boolean_algebra (has_neg Type)) := sorry --non-trivial
lemma new_lemma_64962 (h0 : filter (ring (option (finset name)))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_64963 (h0 : topological_space (canonically_linear_ordered_monoid (has_add Type))) : locally_compact_space (canonically_linear_ordered_monoid (has_add Type)) := sorry --non-trivial
lemma new_lemma_64964 (h0 : partial_order (has_top num)) (h1 : order_top (has_top num)) : is_coatomic (has_top num) := sorry --non-trivial
lemma new_lemma_64965 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : palindrome (function.extfun_app (function.extfun_app h0 list) (add_cancel_monoid pos)) := sorry --non-trivial
lemma new_lemma_64966 (h0 : monoid (ring (has_Inf (has_add (has_add (has_Inf linarith.comp)))))) : monoid.fg (ring (has_Inf (has_add (has_add (has_Inf linarith.comp))))) := sorry --non-trivial
lemma new_lemma_64967 (h0 : topological_space (has_sub (semiring (semiring (semiring unsigned))))) : totally_disconnected_space (has_sub (semiring (semiring (semiring unsigned)))) := sorry --non-trivial
lemma new_lemma_64968 (h0 : functor.add_const (topological_space (canonically_linear_ordered_monoid real)) Type) : @locally_compact_space.{0} (canonically_linear_ordered_monoid.{0} real) (@functor.add_const.run.{0 1} (topological_space.{0} (canonically_linear_ordered_monoid.{0} real)) Type h0)  := sorry --non-trivial
lemma new_lemma_64969 (h0 : group (has_top (random_gen (random_gen (random_gen linarith.comp_source))))) : group.fg (has_top (random_gen (random_gen (random_gen linarith.comp_source)))) := sorry --non-trivial
lemma new_lemma_64970 (h0 : topological_space (comm_group (comm_group (comm_group pos)))) : locally_compact_space (comm_group (comm_group (comm_group pos))) := sorry --non-trivial
lemma new_lemma_64971 (h0 : topological_space (has_nndist (mul_zero_class pos))) : t0_space (has_nndist (mul_zero_class pos)) := sorry --non-trivial
lemma new_lemma_64972 (h0 : function.extfun nat fin) : @is_simple_group.{0} (has_add.{0} real) (@matrix.vec_empty.{0} (group.{0} (has_add.{0} real)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_64973 (h0 : add_group (has_add (encodable linarith.ineq))) : is_add_cyclic (has_add (encodable linarith.ineq)) := sorry --non-trivial
lemma new_lemma_64974 (h0 : topological_space (has_compl (has_inv string_imp))) : path_connected_space (has_compl (has_inv string_imp)) := sorry --non-trivial
lemma new_lemma_64975 (h0 : topological_space (normed_lattice_add_comm_group (has_neg real))) : t1_space (normed_lattice_add_comm_group (has_neg real)) := sorry --non-trivial
lemma new_lemma_64976 (h0 : topological_space (add_comm_monoid (option unsigned))) : t0_space (add_comm_monoid (option unsigned)) := sorry --non-trivial
lemma new_lemma_64977 (h0 : not (function.extfun Type group -> false)) : @is_cyclic.{0} (add_right_cancel_monoid.{0} empty) (@function.extfun_app.{2 1} Type group.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type group.{0}) h0) (add_right_cancel_monoid.{0} empty))  := sorry --non-trivial
lemma new_lemma_64978 (h0 : functor.comp topological_space mul_zero_class name) : @totally_separated_space.{0} (mul_zero_class.{0} name) (@functor.comp.run.{0 0 0} topological_space.{0} mul_zero_class.{0} name (@functor.comp.run.{0 0 0} topological_space.{0} mul_zero_class.{0} name (@functor.comp.run.{0 0 0} topological_space.{0} mul_zero_class.{0} name h0)))  := sorry --non-trivial
lemma new_lemma_64979 (h0 : group (non_assoc_semiring (complete_linear_order (partial_order (option congr_arg_kind))))) : is_cyclic (non_assoc_semiring (complete_linear_order (partial_order (option congr_arg_kind)))) := sorry --non-trivial
lemma new_lemma_64980 (h0 : fin has_zero.zero) : @unique_factorization_monoid.{0} (generalized_boolean_algebra.{0} pos) (@matrix.vec_empty.{0} (cancel_comm_monoid_with_zero.{0} (generalized_boolean_algebra.{0} pos)) h0)  := sorry --non-trivial
lemma new_lemma_64981 (h0 : ring (metric_space (semiring congr_arg_kind))) : rank_condition (metric_space (semiring congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_64982 (h0 : group (filter congr_arg_kind)) : normalizer_condition (filter congr_arg_kind) := sorry --non-trivial
lemma new_lemma_64983 (h0 : ordered_add_comm_monoid (finset (has_add name))) : archimedean (finset (has_add name)) := sorry --non-trivial
lemma new_lemma_64984 (h0 : group (complete_distrib_lattice (option (option (option (option unsigned)))))) : group.fg (complete_distrib_lattice (option (option (option (option unsigned))))) := sorry --non-trivial
lemma new_lemma_64985 (h0 : functor.add_const (topological_space (add_comm_monoid name)) Type) : @totally_disconnected_space.{0} (add_comm_monoid.{0} name) (@functor.add_const.run.{0 1} (topological_space.{0} (add_comm_monoid.{0} name)) Type h0)  := sorry --non-trivial
lemma new_lemma_64986 (h0 : functor.add_const (topological_space (has_neg name)) Type) : @t1_space.{0} (has_neg.{0} name) (@functor.add_const.run.{0 1} (topological_space.{0} (has_neg.{0} name)) Type h0)  := sorry --non-trivial
lemma new_lemma_64987 (h0 : add_group (set.set_semiring string_imp)) : is_add_cyclic (set.set_semiring string_imp) := sorry --non-trivial
lemma new_lemma_64988 (h0 : group (normed_comm_ring (comm_group (comm_group ennreal)))) : is_simple_group (normed_comm_ring (comm_group (comm_group ennreal))) := sorry --non-trivial
lemma new_lemma_64989 (h0 : complete_lattice (bin_tree (semiring (semiring (semiring unsigned))))) : is_compactly_generated (bin_tree (semiring (semiring (semiring unsigned)))) := sorry --non-trivial
lemma new_lemma_64990 (h2 : function.extfun Type topological_space) : @t0_space.{0} (denumerable.{0} fun_info) (@function.extfun_app.{2 1} Type topological_space.{0} h2 (denumerable.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_64991 (h0 : uniform_space (normed_comm_ring (has_to_string (has_to_string unsigned)))) : complete_space (normed_comm_ring (has_to_string (has_to_string unsigned))) := sorry --non-trivial
lemma new_lemma_64992 (h0 : not (topological_space (has_compl linarith.comp_source) -> false)) : @t0_space.{0} (has_compl.{0} linarith.comp_source) (@classical.by_contradiction'.{1} (topological_space.{0} (has_compl.{0} linarith.comp_source)) h0)  := sorry --non-trivial
lemma new_lemma_64993 (h0 : finset (ordered_cancel_add_comm_monoid ennreal)) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_64994 (h0 : functor.comp ring complete_distrib_lattice pos) : @rank_condition.{0} (complete_distrib_lattice.{0} pos) (@functor.comp.run.{0 0 0} ring.{0} complete_distrib_lattice.{0} pos (@functor.comp.run.{0 0 0} ring.{0} complete_distrib_lattice.{0} pos h0))  := sorry --non-trivial
lemma new_lemma_64995 (h0 : functor.add_const (uniform_space (has_to_string linarith.comp)) Type) : @separated_space.{0} (has_to_string.{0} linarith.comp) (@functor.add_const.run.{0 1} (uniform_space.{0} (has_to_string.{0} linarith.comp)) Type h0)  := sorry --non-trivial
lemma new_lemma_64996 (h0 : list (finset (finset (finset ennreal)))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_64997 (h0 : function.extfun (Type 1) filter) : countable_Inter_filter (function.extfun_app h0 (ordered_comm_monoid Type)) := sorry --non-trivial
lemma new_lemma_64998 (h0 : not (function.extfun Type group -> false)) : @group.fg.{0} (has_inv.{0} (random_gen.{0} linarith.ineq)) (@function.extfun_app.{2 1} Type group.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type group.{0}) h0) (has_inv.{0} (random_gen.{0} linarith.ineq)))  := sorry --non-trivial
lemma new_lemma_64999 (h0 : function.extfun Type complete_lattice) : @complete_lattice.is_Sup_finite_compact.{0} (group_with_zero.{0} ennreal) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (group_with_zero.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_65000 (h0 : group (generalized_boolean_algebra (has_Inf real))) : is_cyclic (generalized_boolean_algebra (has_Inf real)) := sorry --non-trivial
lemma new_lemma_65001 (h0 : functor.add_const (group (add_cancel_monoid environment.implicit_infer_kind)) name) : @is_simple_group.{0} (add_cancel_monoid.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (group.{0} (add_cancel_monoid.{0} environment.implicit_infer_kind)) name h0)  := sorry --non-trivial
lemma new_lemma_65002 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @normal_space.{0} (measurable_space.dynkin_system.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (measurable_space.dynkin_system.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_65003 (h0 : function.extfun Type (functor.add_const (functor.add_const (topological_space (has_bot empty)) empty))) : @normal_space.{0} (has_bot.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (has_bot.{0} empty)) empty (@functor.add_const.run.{0 0} (functor.add_const.{0 0} (topological_space.{0} (has_bot.{0} empty)) empty) empty (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (functor.add_const.{0 0} (topological_space.{0} (has_bot.{0} empty)) empty)) h0 empty)))  := sorry --non-trivial
lemma new_lemma_65004 (h0 : topological_space (complete_distrib_lattice (has_pos_part real))) : regular_space (complete_distrib_lattice (has_pos_part real)) := sorry --non-trivial
lemma new_lemma_65005 (h0 : functor.add_const (uniform_space (partial_order congr_arg_kind)) empty) : @separated_space.{0} (partial_order.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (uniform_space.{0} (partial_order.{0} congr_arg_kind)) empty h0)  := sorry --non-trivial
lemma new_lemma_65006 (h0 : ring (cancel_monoid (cancel_monoid environment.implicit_infer_kind))) : strong_rank_condition (cancel_monoid (cancel_monoid environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_65007 (h0 : function.extfun Type list) : palindrome (function.extfun_app h0 (mul_zero_class name)) := sorry --non-trivial
lemma new_lemma_65008 (h0 : list (cancel_monoid unsigned)) : palindrome h0 := sorry --non-trivial
lemma new_lemma_65009 (h0 : uniform_space (dlist (has_nnnorm linarith.ineq))) : complete_space (dlist (has_nnnorm linarith.ineq)) := sorry --non-trivial
lemma new_lemma_65010 (h0 : functor.add_const (topological_space (has_add linarith.comp)) Type) : @totally_separated_space.{0} (has_add.{0} linarith.comp) (@functor.add_const.run.{0 1} (topological_space.{0} (has_add.{0} linarith.comp)) Type h0)  := sorry --non-trivial
lemma new_lemma_65011 (h0 : topological_space (has_bot (has_Inf (has_add linarith.comp)))) : t0_space (has_bot (has_Inf (has_add linarith.comp))) := sorry --non-trivial
lemma new_lemma_65012 (h0 : topological_space (add_comm_monoid (finset (finset (has_nndist name))))) : normal_space (add_comm_monoid (finset (finset (has_nndist name)))) := sorry --non-trivial
lemma new_lemma_65013 (h0 : functor.add_const (list nnreal) num) : palindrome (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_65014 (h0 : functor.add_const (topological_space (add_left_cancel_semigroup num)) empty) : @totally_separated_space.{0} (add_left_cancel_semigroup.{0} num) (@functor.add_const.run.{0 0} (topological_space.{0} (add_left_cancel_semigroup.{0} num)) empty h0)  := sorry --non-trivial
lemma new_lemma_65015 (h0 : functor.add_const (functor.add_const (complete_lattice Type) pos) Type) : @complete_lattice.is_Sup_finite_compact.{1} Type (@functor.add_const.run.{1 0} (complete_lattice.{1} Type) pos (@functor.add_const.run.{1 1} (functor.add_const.{1 0} (complete_lattice.{1} Type) pos) Type h0))  := sorry --non-trivial
lemma new_lemma_65016 (h0 : functor.add_const (topological_space (normed_comm_ring Type)) pos) : @totally_disconnected_space.{1} (normed_comm_ring.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (normed_comm_ring.{1} Type)) pos h0)  := sorry --non-trivial
lemma new_lemma_65017 (h0 : topological_space (add_right_cancel_monoid (semiring (semiring (semiring (semiring num)))))) : preirreducible_space (add_right_cancel_monoid (semiring (semiring (semiring (semiring num))))) := sorry --non-trivial
lemma new_lemma_65018 (h0 : topological_space (has_norm linarith.comp)) : path_connected_space (has_norm linarith.comp) := sorry --non-trivial
lemma new_lemma_65019 (h0 : topological_space (add_comm_monoid (has_add linarith.comp))) : regular_space (add_comm_monoid (has_add linarith.comp)) := sorry --non-trivial
lemma new_lemma_65020 (h0 : function.extfun Type topological_space) : @preconnected_space.{0} (canonically_ordered_comm_semiring.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (canonically_ordered_comm_semiring.{0} pos))  := sorry --non-trivial
lemma new_lemma_65021 (h0 : function.extfun Type group) : @is_cyclic.{0} (has_top.{0} string_imp) (@function.extfun_app.{2 1} Type group.{0} h0 (has_top.{0} string_imp))  := sorry --non-trivial
lemma new_lemma_65022 (h0 : function.extfun Type ring) : @is_domain.{0} (left_cancel_semigroup.{0} (semiring.{0} (option.{0} empty))) (@function.extfun_app.{2 1} Type ring.{0} h0 (left_cancel_semigroup.{0} (semiring.{0} (option.{0} empty))))  := sorry --non-trivial
lemma new_lemma_65023 (h0 : uniform_space (has_to_string (add_left_cancel_monoid Type))) : complete_space (has_to_string (add_left_cancel_monoid Type)) := sorry --non-trivial
lemma new_lemma_65024 (h0 : topological_space (complete_semilattice_Sup (dlist char))) : totally_disconnected_space (complete_semilattice_Sup (dlist char)) := sorry --non-trivial
lemma new_lemma_65025 (h0 : not (topological_space congr_arg_kind -> false)) : @topological_space.separable_space.{0} congr_arg_kind (@classical.by_contradiction'.{1} (topological_space.{0} congr_arg_kind) h0)  := sorry --non-trivial
lemma new_lemma_65026 (h1 : add_group (has_lt std_gen)) : is_add_cyclic (has_lt std_gen) := sorry --non-trivial
lemma new_lemma_65027 (h0 : uniform_space (has_norm fun_info)) : complete_space (has_norm fun_info) := sorry --non-trivial
lemma new_lemma_65028 (h0 : functor.add_const (ordered_add_comm_monoid (pseudo_metric_space unsigned)) unsigned) : @archimedean.{0} (pseudo_metric_space.{0} unsigned) (@functor.add_const.run.{0 0} (ordered_add_comm_monoid.{0} (pseudo_metric_space.{0} unsigned)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_65029 (h0 : topological_space (add_group unsigned)) : topological_space.separable_space (add_group unsigned) := sorry --non-trivial
lemma new_lemma_65030 (h0 : fin has_zero.zero) : @rank_condition.{0} (complete_distrib_lattice.{0} real) (@matrix.vec_empty.{0} (ring.{0} (complete_distrib_lattice.{0} real)) h0)  := sorry --non-trivial
lemma new_lemma_65031 (h0 : not (complete_lattice (distrib_lattice to_additive.value_type) -> false)) : @complete_lattice.is_Sup_finite_compact.{0} (distrib_lattice.{0} to_additive.value_type) (@classical.by_contradiction'.{1} (complete_lattice.{0} (distrib_lattice.{0} to_additive.value_type)) h0)  := sorry --non-trivial
lemma new_lemma_65032 (h0 : topological_space (has_to_string (add_cancel_monoid (add_cancel_monoid Type)))) : t1_space (has_to_string (add_cancel_monoid (add_cancel_monoid Type))) := sorry --non-trivial
lemma new_lemma_65033 (h2 : not (topological_space (denumerable to_additive.value_type) -> false)) : @totally_disconnected_space.{0} (denumerable.{0} to_additive.value_type) (@classical.by_contradiction'.{1} (topological_space.{0} (denumerable.{0} to_additive.value_type)) h2)  := sorry --non-trivial
lemma new_lemma_65034 (h0 : topological_space (has_to_string (has_add Type))) : loc_path_connected_space (has_to_string (has_add Type)) := sorry --non-trivial
lemma new_lemma_65035 (h0 : ring (boolean_algebra.core (has_neg (has_pos_part linarith.comp)))) : is_domain (boolean_algebra.core (has_neg (has_pos_part linarith.comp))) := sorry --non-trivial
lemma new_lemma_65036 (h0 : function.extfun Type list) : palindrome (function.extfun_app h0 (semigroup empty)) := sorry --non-trivial
lemma new_lemma_65037 (h0 : group (semigroup empty)) : group.fg (semigroup empty) := sorry --non-trivial
lemma new_lemma_65038 (h0 : ring (ordered_ring empty)) : strong_rank_condition (ordered_ring empty) := sorry --non-trivial
lemma new_lemma_65039 (h0 : functor.add_const (ring (normed_linear_ordered_group empty)) empty) : @rank_condition.{0} (normed_linear_ordered_group.{0} empty) (@functor.add_const.run.{0 0} (ring.{0} (normed_linear_ordered_group.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_65040 (h0 : functor.add_const (filter (pseudo_metric_space name)) name) : countable_Inter_filter (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_65041 (h0 : functor.comp add_group boolean_algebra name) : @is_add_cyclic.{0} (boolean_algebra.{0} name) (@functor.comp.run.{0 0 0} add_group.{0} boolean_algebra.{0} name h0)  := sorry --non-trivial
lemma new_lemma_65042 (h0 : ring (has_append (has_ssubset (has_ssubset char)))) : strong_rank_condition (has_append (has_ssubset (has_ssubset char))) := sorry --non-trivial
lemma new_lemma_65043 (h0 : functor.add_const (topological_space Type) (has_zero pos)) : @totally_disconnected_space.{1} Type (@functor.add_const.run.{1 0} (topological_space.{1} Type) (has_zero.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_65044 (h0 : topological_space (has_Inf (has_Inf (has_nndist (has_pos_part name))))) : normal_space (has_Inf (has_Inf (has_nndist (has_pos_part name)))) := sorry --non-trivial
lemma new_lemma_65045 (h0 : functor.add_const (topological_space (left_cancel_monoid empty)) empty) : @loc_path_connected_space.{0} (left_cancel_monoid.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (left_cancel_monoid.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_65046 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @rank_condition.{0} (add_comm_monoid.{0} unsigned) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (add_comm_monoid.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_65047 (h0 : function.extfun Type topological_space) : @irreducible_space.{0} (semigroup.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (semigroup.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_65048 (h0 : ordered_comm_monoid (add_cancel_monoid (has_Inf name))) : has_exists_mul_of_le (add_cancel_monoid (has_Inf name)) := sorry --non-trivial
lemma new_lemma_65049 (h0 : group (plift (semiring congr_arg_kind))) : is_cyclic (plift (semiring congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_65050 (h0 : topological_space (has_nndist (has_to_string environment.implicit_infer_kind))) : preconnected_space (has_nndist (has_to_string environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_65051 (h0 : ring (add_monoid reducibility_hints)) : rank_condition (add_monoid reducibility_hints) := sorry --non-trivial
lemma new_lemma_65052 (h0 : function.extfun Type filter) : filter.ne_bot (function.extfun_app h0 (has_to_string pos)) := sorry --non-trivial
lemma new_lemma_65053 (h0 : ring (metric_space (semiring (has_norm (semiring empty))))) : is_domain (metric_space (semiring (has_norm (semiring empty)))) := sorry --non-trivial
lemma new_lemma_65054 (h0 : topological_space (generalized_boolean_algebra (has_add (has_neg linarith.comp)))) : normal_space (generalized_boolean_algebra (has_add (has_neg linarith.comp))) := sorry --non-trivial
lemma new_lemma_65055 (h0 : topological_space (has_nndist (boolean_algebra.core name))) : preconnected_space (has_nndist (boolean_algebra.core name)) := sorry --non-trivial
lemma new_lemma_65056 (h0 : ring (normed_linear_ordered_group (option (option empty)))) : rank_condition (normed_linear_ordered_group (option (option empty))) := sorry --non-trivial
lemma new_lemma_65057 (h0 : functor.add_const (ring (has_nndist name)) (boolean_algebra (boolean_algebra (boolean_algebra Type)))) : @strong_rank_condition.{0} (has_nndist.{0} name) (@functor.add_const.run.{0 1} (ring.{0} (has_nndist.{0} name)) (boolean_algebra.{1} (boolean_algebra.{1} (boolean_algebra.{1} Type))) h0)  := sorry --non-trivial
lemma new_lemma_65058 (h0 : complete_lattice (normed_group congr_arg_kind)) : is_atomistic (normed_group congr_arg_kind) := sorry --non-trivial
lemma new_lemma_65059 (h0 : functor.add_const (add_group (add_cancel_monoid Type)) linarith.comp) : @is_add_cyclic.{1} (add_cancel_monoid.{1} Type) (@functor.add_const.run.{1 0} (add_group.{1} (add_cancel_monoid.{1} Type)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_65060 (h0 : topological_space (comm_ring (has_nnnorm (has_nnnorm char)))) : path_connected_space (comm_ring (has_nnnorm (has_nnnorm char))) := sorry --non-trivial
lemma new_lemma_65061 (h0 : function.extfun Type group) : @normalizer_condition.{0} linarith.ineq (@function.extfun_app.{2 1} Type group.{0} h0 linarith.ineq)  := sorry --non-trivial
lemma new_lemma_65062 (h0 : functor.add_const (topological_space (cancel_monoid Type)) Type) : @locally_compact_space.{1} (cancel_monoid.{1} Type) (@functor.add_const.run.{1 1} (topological_space.{1} (cancel_monoid.{1} Type)) Type h0)  := sorry --non-trivial
lemma new_lemma_65063 (h0 : topological_space (has_add (ring (ring environment.implicit_infer_kind)))) : locally_compact_space (has_add (ring (ring environment.implicit_infer_kind))) := sorry --non-trivial
lemma new_lemma_65064 (h0 : function.extfun (Type 1) ordered_add_comm_monoid) : @archimedean.{1} (has_to_string.{1} Type) (@function.extfun_app.{3 2} (Type 1) ordered_add_comm_monoid.{1} h0 (has_to_string.{1} Type))  := sorry --non-trivial
lemma new_lemma_65065 (h0 : ring (add_comm_monoid ennreal)) : strong_rank_condition (add_comm_monoid ennreal) := sorry --non-trivial
lemma new_lemma_65066 (h0 : function.extfun Type uniform_space) : @complete_space.{0} (canonically_ordered_comm_semiring.{0} empty) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (canonically_ordered_comm_semiring.{0} empty))  := sorry --non-trivial
lemma new_lemma_65067 (h0 : finset (has_nndist (has_add (has_nndist linarith.comp)))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_65068 (h0 : functor.add_const (monoid (canonically_ordered_monoid real)) real) : @monoid.fg.{0} (canonically_ordered_monoid.{0} real) (@functor.add_const.run.{0 0} (monoid.{0} (canonically_ordered_monoid.{0} real)) real h0)  := sorry --non-trivial
lemma new_lemma_65069 (h1 : ring (has_compl char)) : is_domain (has_compl char) := sorry --non-trivial
lemma new_lemma_65070 (h0 : functor.add_const (ring (boolean_algebra unsigned)) environment.implicit_infer_kind) : @is_domain.{0} (boolean_algebra.{0} unsigned) (@functor.add_const.run.{0 0} (ring.{0} (boolean_algebra.{0} unsigned)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_65071 (h0 : set (set (random_gen to_additive.value_type))) (h1 : function.extfun Type random_gen) : set.sInter h0 (function.extfun_app h1 to_additive.value_type) := sorry --non-trivial
lemma new_lemma_65072 (h2 : topological_space (add_comm_semigroup enat)) : path_connected_space (add_comm_semigroup enat) := sorry --non-trivial
lemma new_lemma_65073 (h0 : group (distrib_lattice to_additive.value_type)) : is_cyclic (distrib_lattice to_additive.value_type) := sorry --non-trivial
lemma new_lemma_65074 (h0 : topological_space (has_append (has_nnnorm (has_nnnorm (comm_ring (comm_ring linarith.comp_source)))))) : t0_space (has_append (has_nnnorm (has_nnnorm (comm_ring (comm_ring linarith.comp_source))))) := sorry --non-trivial
lemma new_lemma_65075 (h0 : add_group (with_bot (random_gen (random_gen num)))) : is_add_cyclic (with_bot (random_gen (random_gen num))) := sorry --non-trivial
lemma new_lemma_65076 (h0 : functor.add_const (function.extfun (Type 1) filter) Type) : countable_Inter_filter (function.extfun_app (functor.add_const.run h0) (ring Type)) := sorry --non-trivial
lemma new_lemma_65077 (h0 : not (function.extfun (Type -> Type) (function.extfun Type) -> false)) : @is_add_cyclic.{0} (linear_ordered_semiring.{0} fun_info) (@function.extfun_app.{2 1} Type add_group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) (@classical.by_contradiction'.{2} (function.extfun.{2 2} (Type → Type) (function.extfun.{2 1} Type)) h0) add_group.{0}) (linear_ordered_semiring.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_65078 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_domain.{0} (normed_group.{0} num) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (normed_group.{0} num))  := sorry --non-trivial
lemma new_lemma_65079 (h0 : uniform_space (add_comm_monoid (option (option pos)))) : complete_space (add_comm_monoid (option (option pos))) := sorry --non-trivial
lemma new_lemma_65080 (h0 : functor.add_const (topological_space (finset name)) ennreal) : @preirreducible_space.{0} (finset.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (finset.{0} name)) ennreal h0)  := sorry --non-trivial
lemma new_lemma_65081 (h0 : ring (monoid_with_zero (option (option (option (option unsigned)))))) : rank_condition (monoid_with_zero (option (option (option (option unsigned))))) := sorry --non-trivial
lemma new_lemma_65082 (h0 : functor.add_const (ring (finset Type)) (finset pos)) : @is_domain.{1} (finset.{1} Type) (@functor.add_const.run.{1 0} (ring.{1} (finset.{1} Type)) (finset.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_65083 (h0 : not (function.extfun Type group -> false)) : @group.fg.{0} (has_inv.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type group.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type group.{0}) h0) (has_inv.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_65084 (h0 : group (has_norm (random_gen (has_inv to_additive.value_type)))) : normalizer_condition (has_norm (random_gen (has_inv to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_65085 (h0 : topological_space (normed_lattice_add_comm_group (has_add (has_Inf (has_Inf (has_add pos)))))) : preconnected_space (normed_lattice_add_comm_group (has_add (has_Inf (has_Inf (has_add pos))))) := sorry --non-trivial
lemma new_lemma_65086 (h0 : topological_space (mul_zero_class (finset (finset (finset (has_to_string (finset name))))))) : totally_separated_space (mul_zero_class (finset (finset (finset (has_to_string (finset name)))))) := sorry --non-trivial
lemma new_lemma_65087 (h0 : ring (with_one congr_arg_kind)) : is_domain (with_one congr_arg_kind) := sorry --non-trivial
lemma new_lemma_65088 (h0 : uniform_space (has_to_string (normed_comm_ring name))) : separated_space (has_to_string (normed_comm_ring name)) := sorry --non-trivial
lemma new_lemma_65089 (h0 : topological_space (simple_graph (option (option (option (option (option empty))))))) : irreducible_space (simple_graph (option (option (option (option (option empty)))))) := sorry --non-trivial
lemma new_lemma_65090 (h0 : topological_space (boolean_algebra (has_add (boolean_algebra.core pos)))) : preirreducible_space (boolean_algebra (has_add (boolean_algebra.core pos))) := sorry --non-trivial
lemma new_lemma_65091 (h0 : topological_space (linear_ordered_add_comm_group (random_gen string_imp))) : irreducible_space (linear_ordered_add_comm_group (random_gen string_imp)) := sorry --non-trivial
lemma new_lemma_65092 (h0 : ring (finset (has_add name))) : rank_condition (finset (has_add name)) := sorry --non-trivial
lemma new_lemma_65093 (h0 : function.extfun Type topological_space) : @t1_space.{0} (comm_semigroup.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (comm_semigroup.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_65094 (h0 : functor.add_const (topological_space (has_zero Type)) pos) : @normal_space.{1} (has_zero.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (has_zero.{1} Type)) pos h0)  := sorry --non-trivial
lemma new_lemma_65095 (h0 : topological_space (has_one (semiring (semiring empty)))) : discrete_topology (has_one (semiring (semiring empty))) := sorry --non-trivial
lemma new_lemma_65096 (h0 : functor.add_const (topological_space (non_assoc_semiring num)) empty) : @topological_space.separable_space.{0} (non_assoc_semiring.{0} num) (@functor.add_const.run.{0 0} (topological_space.{0} (non_assoc_semiring.{0} num)) empty h0)  := sorry --non-trivial
lemma new_lemma_65097 (h0 : function.extfun Type uniform_space) : @separated_space.{0} (ordered_cancel_add_comm_monoid.{0} unsigned) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (ordered_cancel_add_comm_monoid.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_65098 (h0 : filter (pseudo_metric_space (has_nndist ennreal))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_65099 (h0 : complete_lattice (has_edist (semiring (semiring unsigned)))) : is_compactly_generated (has_edist (semiring (semiring unsigned))) := sorry --non-trivial
lemma new_lemma_65100 (h0 : function.extfun (Type 1) ring) : @is_principal_ideal_ring.{1} (simple_graph.{1} Type) (@function.extfun_app.{3 2} (Type 1) ring.{1} h0 (simple_graph.{1} Type))  := sorry --non-trivial
lemma new_lemma_65101 (h2 : uniform_space (semi_normed_comm_ring to_additive.value_type)) : complete_space (semi_normed_comm_ring to_additive.value_type) := sorry --non-trivial
lemma new_lemma_65102 (h0 : topological_space (has_to_string (ordered_comm_monoid real))) : path_connected_space (has_to_string (ordered_comm_monoid real)) := sorry --non-trivial
lemma new_lemma_65103 (h0 : function.extfun Type list) : list.nodup (function.extfun_app h0 (monoid fun_info)) := sorry --non-trivial
lemma new_lemma_65104 (h0 : topological_space (generalized_boolean_algebra (has_bot name))) : preconnected_space (generalized_boolean_algebra (has_bot name)) := sorry --non-trivial
lemma new_lemma_65105 (h0 : functor.add_const (topological_space (normed_comm_ring unsigned)) (has_neg linarith.comp)) : @loc_path_connected_space.{0} (normed_comm_ring.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (normed_comm_ring.{0} unsigned)) (has_neg.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_65106 (h0 : topological_space (has_to_string (normed_comm_ring (measurable_space Type)))) : t0_space (has_to_string (normed_comm_ring (measurable_space Type))) := sorry --non-trivial
lemma new_lemma_65107 (h0 : functor.add_const (ordered_add_comm_monoid (boolean_algebra pos)) linarith.comp) : @archimedean.{0} (boolean_algebra.{0} pos) (@functor.add_const.run.{0 0} (ordered_add_comm_monoid.{0} (boolean_algebra.{0} pos)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_65108 (h0 : functor.add_const (function.extfun Type topological_space) linarith.comp) : @path_connected_space.{0} (boolean_algebra.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) linarith.comp h0) (boolean_algebra.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_65109 (h0 : topological_space (has_neg_part (has_add name))) : totally_disconnected_space (has_neg_part (has_add name)) := sorry --non-trivial
lemma new_lemma_65110 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @unique_factorization_monoid.{0} (ordered_comm_group.{0} empty) (@function.extfun_app.{2 1} Type cancel_comm_monoid_with_zero.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 cancel_comm_monoid_with_zero.{0}) (ordered_comm_group.{0} empty))  := sorry --non-trivial
lemma new_lemma_65111 (h1 : topological_space (linear_ordered_comm_group_with_zero linarith.comp_source)) (h2 : preorder (linear_ordered_comm_group_with_zero linarith.comp_source)) : order_closed_topology (linear_ordered_comm_group_with_zero linarith.comp_source) := sorry --non-trivial
lemma new_lemma_65112 (h0 : topological_space (linear_ordered_comm_group_with_zero environment.projection_info)) (h1 : preorder (linear_ordered_comm_group_with_zero environment.projection_info)) : order_topology (linear_ordered_comm_group_with_zero environment.projection_info) := sorry --non-trivial
lemma new_lemma_65113 (h0 : uniform_space (normed_comm_ring name)) : separated_space (normed_comm_ring name) := sorry --non-trivial
lemma new_lemma_65114 (h1 : monoid (semiring linarith.comp_source)) : monoid.fg (semiring linarith.comp_source) := sorry --non-trivial
lemma new_lemma_65115 (h0 : topological_space (comm_group (option name))) : topological_space.separable_space (comm_group (option name)) := sorry --non-trivial
lemma new_lemma_65116 (h0 : cancel_comm_monoid_with_zero (add_comm_monoid (comm_monoid unsigned))) : unique_factorization_monoid (add_comm_monoid (comm_monoid unsigned)) := sorry --non-trivial
lemma new_lemma_65117 (h0 : complete_lattice (random_gen string_imp)) : is_atomistic (random_gen string_imp) := sorry --non-trivial
lemma new_lemma_65118 (h0 : group (has_neg num)) : group.fg (has_neg num) := sorry --non-trivial
lemma new_lemma_65119 (h0 : not (function.extfun Type group -> false)) : @is_cyclic.{0} (@id.{2} Type num) (@function.extfun_app.{2 1} Type group.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type group.{0}) h0) (@id.{2} Type num))  := sorry --non-trivial
lemma new_lemma_65120 (h0 : finset (has_neg (finset (ring Type)))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_65121 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @rank_condition.{0} (with_bot.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (with_bot.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_65122 (h0 : add_group (has_div (mul_one_class string_imp))) : is_add_cyclic (has_div (mul_one_class string_imp)) := sorry --non-trivial
lemma new_lemma_65123 (h0 : topological_space (semi_normed_ring linarith.ineq)) (h1 : add_group (semi_normed_ring linarith.ineq)) : topological_add_group (semi_normed_ring linarith.ineq) := sorry --non-trivial
lemma new_lemma_65124 (h0 : ring (has_neg Type)) : is_principal_ideal_ring (has_neg Type) := sorry --non-trivial
lemma new_lemma_65125 (h0 : topological_space (comm_group pos)) : regular_space (comm_group pos) := sorry --non-trivial
lemma new_lemma_65126 (h1 : topological_space (random_gen linarith.comp)) : t0_space (random_gen linarith.comp) := sorry --non-trivial
lemma new_lemma_65127 (h0 : function.extfun Type topological_space) : @t0_space.{0} (comm_ring.{0} fun_info) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (comm_ring.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_65128 (h0 : complete_lattice (finset num)) : is_atomistic (finset num) := sorry --non-trivial
lemma new_lemma_65129 (h0 : topological_space (linear_order (semiring empty))) : irreducible_space (linear_order (semiring empty)) := sorry --non-trivial
lemma new_lemma_65130 (h0 : functor.add_const (function.extfun (Type 1) topological_space) linarith.comp) : @locally_compact_space.{1} (has_to_string.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) topological_space.{1}) linarith.comp h0) (has_to_string.{1} Type))  := sorry --non-trivial
lemma new_lemma_65131 (h0 : functor.comp topological_space cancel_monoid Type) : @regular_space.{1} (cancel_monoid.{1} Type) (@functor.comp.run.{1 1 1} topological_space.{1} cancel_monoid.{1} Type h0)  := sorry --non-trivial
lemma new_lemma_65132 (h0 : complete_lattice (plift (semiring (semiring empty)))) : is_atomistic (plift (semiring (semiring empty))) := sorry --non-trivial
lemma new_lemma_65133 (h0 : topological_space (boolean_algebra (ring linarith.comp))) : totally_separated_space (boolean_algebra (ring linarith.comp)) := sorry --non-trivial
lemma new_lemma_65134 (h0 : add_monoid (has_to_string (finset pos))) : add_monoid.fg (has_to_string (finset pos)) := sorry --non-trivial
lemma new_lemma_65135 (h0 : functor.comp topological_space canonically_ordered_comm_semiring environment.implicit_infer_kind) : @totally_separated_space.{0} (canonically_ordered_comm_semiring.{0} environment.implicit_infer_kind) (@functor.comp.run.{0 0 0} topological_space.{0} canonically_ordered_comm_semiring.{0} environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_65136 (h0 : functor.comp topological_space comm_group unsigned) : @totally_disconnected_space.{0} (comm_group.{0} unsigned) (@functor.comp.run.{0 0 0} topological_space.{0} comm_group.{0} unsigned h0)  := sorry --non-trivial
lemma new_lemma_65137 (h0 : functor.add_const (ordered_add_comm_monoid (complete_distrib_lattice name)) name) : @archimedean.{0} (complete_distrib_lattice.{0} name) (@functor.add_const.run.{0 0} (ordered_add_comm_monoid.{0} (complete_distrib_lattice.{0} name)) name h0)  := sorry --non-trivial
lemma new_lemma_65138 (h0 : functor.add_const (complete_lattice (has_pos_part linarith.comp)) (finset (ring Type))) : @is_compactly_generated.{0} (has_pos_part.{0} linarith.comp) (@functor.add_const.run.{0 1} (complete_lattice.{0} (has_pos_part.{0} linarith.comp)) (finset.{1} (ring.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_65139 (h0 : function.extfun Type ring) : @is_domain.{0} (boolean_algebra.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type ring.{0} h0 (boolean_algebra.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_65140 (h0 : functor.add_const (topological_space (semigroup unsigned)) Type) : @normal_space.{0} (semigroup.{0} unsigned) (@functor.add_const.run.{0 1} (topological_space.{0} (semigroup.{0} unsigned)) Type h0)  := sorry --non-trivial
lemma new_lemma_65141 (h0 : function.extfun Type ordered_add_comm_monoid) : @archimedean.{0} (uniform_space.{0} empty) (@function.extfun_app.{2 1} Type ordered_add_comm_monoid.{0} h0 (uniform_space.{0} empty))  := sorry --non-trivial
lemma new_lemma_65142 (h1 : topological_space (dlist (random_gen (comm_ring char)))) : totally_disconnected_space (dlist (random_gen (comm_ring char))) := sorry --non-trivial
lemma new_lemma_65143 (h0 : function.extfun (finset Type) (has_mem.mem (has_emptyc num))) : @is_add_cyclic.{0} (has_emptyc.{0} num) (@finset.pi.empty.{1 0} Type add_group.{0} (has_emptyc.{0} num) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (has_emptyc.{0} num)) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_65144 (h0 : topological_space (finset (has_Inf (has_neg pos)))) : path_connected_space (finset (has_Inf (has_neg pos))) := sorry --non-trivial
lemma new_lemma_65145 (h0 : function.extfun (nat -> Type) (function.extfun nat)) : @t1_space.{0} (has_bot.{0} linarith.comp) (@matrix.vec_empty.{0} (topological_space.{0} (has_bot.{0} linarith.comp)) (@function.extfun_app.{1 1} nat fin (@function.extfun_app.{2 1} (nat → Type) (function.extfun.{1 1} nat) h0 fin) (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_65146 (h0 : complete_lattice (ordered_cancel_add_comm_monoid (option (option (option (option ennreal)))))) : is_atomistic (ordered_cancel_add_comm_monoid (option (option (option (option ennreal))))) := sorry --non-trivial
lemma new_lemma_65147 (h0 : topological_space (has_neg (option (option (option pos))))) : path_connected_space (has_neg (option (option (option pos)))) := sorry --non-trivial
lemma new_lemma_65148 (h0 : linarith.comp_source -> linarith.comp_source -> Prop) (h1 : list linarith.comp_source) : list.sorted h0 h1 := sorry --non-trivial
lemma new_lemma_65149 (h0 : topological_space (metric_space empty)) : totally_disconnected_space (metric_space empty) := sorry --non-trivial
lemma new_lemma_65150 (h0 : topological_space (simple_graph fun_info)) (h1 : preorder (simple_graph fun_info)) : order_closed_topology (simple_graph fun_info) := sorry --non-trivial
lemma new_lemma_65151 (h0 : topological_space (semi_normed_ring reducibility_hints)) : t0_space (semi_normed_ring reducibility_hints) := sorry --non-trivial
lemma new_lemma_65152 (h0 : functor.add_const (ring (has_bot empty)) empty) : @rank_condition.{0} (has_bot.{0} empty) (@functor.add_const.run.{0 0} (ring.{0} (has_bot.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_65153 (h0 : functor.add_const (topological_space (ordered_comm_ring linarith.comp)) (ring pos)) : @path_connected_space.{0} (ordered_comm_ring.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (ordered_comm_ring.{0} linarith.comp)) (ring.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_65154 (h0 : has_neg (has_compl (mul_one_class linarith.ineq))) (h1 : measurable_space (has_compl (mul_one_class linarith.ineq))) : has_measurable_neg (has_compl (mul_one_class linarith.ineq)) := sorry --non-trivial
lemma new_lemma_65155 (h0 : not (complete_lattice (has_div reducibility_hints) -> false)) : @is_compactly_generated.{0} (has_div.{0} reducibility_hints) (@classical.by_contradiction'.{1} (complete_lattice.{0} (has_div.{0} reducibility_hints)) h0)  := sorry --non-trivial
lemma new_lemma_65156 (h0 : function.extfun (Type 1) uniform_space) : @separated_space.{1} (has_Inf.{1} Type) (@function.extfun_app.{3 2} (Type 1) uniform_space.{1} h0 (has_Inf.{1} Type))  := sorry --non-trivial
lemma new_lemma_65157 (h0 : topological_space (mul_zero_class (semiring empty))) : totally_separated_space (mul_zero_class (semiring empty)) := sorry --non-trivial
lemma new_lemma_65158 (h0 : function.extfun Type semiring) : @is_noetherian_ring.{0} (linear_ordered_field.{0} ennreal) (@function.extfun_app.{2 1} Type semiring.{0} h0 (linear_ordered_field.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_65159 (h0 : add_monoid (random_gen num)) : add_monoid.fg (random_gen num) := sorry --non-trivial
lemma new_lemma_65160 (h0 : ring (normed_group (has_ssubset to_additive.value_type))) : is_domain (normed_group (has_ssubset to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_65161 (h0 : add_group (has_zero (ring (has_zero environment.implicit_infer_kind)))) : is_add_cyclic (has_zero (ring (has_zero environment.implicit_infer_kind))) := sorry --non-trivial
lemma new_lemma_65162 (h0 : topological_space (has_Inf linarith.comp)) : totally_disconnected_space (has_Inf linarith.comp) := sorry --non-trivial
lemma new_lemma_65163 (h0 : has_mem.mem topological_space has_emptyc.emptyc) : @discrete_topology.{0} (with_one.{0} (has_norm.{0} num)) (@function.extfun_app.{2 1} Type topological_space.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) topological_space.{0} h0) (with_one.{0} (has_norm.{0} num)))  := sorry --non-trivial
lemma new_lemma_65164 (h0 : complete_lattice (has_add (has_neg (boolean_algebra linarith.comp)))) : is_compactly_generated (has_add (has_neg (boolean_algebra linarith.comp))) := sorry --non-trivial
lemma new_lemma_65165 (h0 : functor.add_const (topological_space (as_linear_order pos)) linarith.comp) : @discrete_topology.{0} (as_linear_order.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (as_linear_order.{0} pos)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_65166 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @locally_compact_space.{0} (option.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (option.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_65167 (h0 : functor.add_const (function.extfun Type list) pos) : list.nodup (function.extfun_app (functor.add_const.run h0) (boolean_algebra name)) := sorry --non-trivial
lemma new_lemma_65168 (h0 : not (topological_space (has_emptyc linarith.comp) -> false)) : @locally_compact_space.{0} (has_emptyc.{0} linarith.comp) (@classical.by_contradiction'.{1} (topological_space.{0} (has_emptyc.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_65169 (h0 : topological_space (finset (finset linarith.comp))) : normal_space (finset (finset linarith.comp)) := sorry --non-trivial
lemma new_lemma_65170 (h0 : topological_space (has_one (has_zero empty))) : t0_space (has_one (has_zero empty)) := sorry --non-trivial
lemma new_lemma_65171 (h0 : functor.add_const (topological_space (add_comm_monoid empty)) empty) : @irreducible_space.{0} (add_comm_monoid.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (add_comm_monoid.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_65172 (h0 : function.extfun Type complete_lattice) : @complete_lattice.is_Sup_finite_compact.{0} (with_bot.{0} linarith.comp) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (with_bot.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_65173 (h0 : ring (has_norm (random_gen (random_gen (random_gen (random_gen linarith.ineq)))))) : rank_condition (has_norm (random_gen (random_gen (random_gen (random_gen linarith.ineq))))) := sorry --non-trivial
lemma new_lemma_65174 (h0 : ordered_comm_monoid (boolean_algebra.core (has_to_string unsigned))) : has_exists_mul_of_le (boolean_algebra.core (has_to_string unsigned)) := sorry --non-trivial
lemma new_lemma_65175 (h0 : functor.add_const (ring (semigroup unsigned)) linarith.comp) : @is_principal_ideal_ring.{0} (semigroup.{0} unsigned) (@functor.add_const.run.{0 0} (ring.{0} (semigroup.{0} unsigned)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_65176 (h0 : topological_space (has_edist empty)) : path_connected_space (has_edist empty) := sorry --non-trivial
lemma new_lemma_65177 (h0 : topological_space (generalized_boolean_algebra (sub_neg_monoid (sub_neg_monoid pos)))) : preconnected_space (generalized_boolean_algebra (sub_neg_monoid (sub_neg_monoid pos))) := sorry --non-trivial
lemma new_lemma_65178 (h0 : function.extfun nat fin) : @is_noetherian_ring.{1} (generalized_boolean_algebra.{1} Type) (@matrix.vec_empty.{1} (semiring.{1} (generalized_boolean_algebra.{1} Type)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_65179 (h0 : monoid (denumerable (has_inv (random_gen (has_top (random_gen (has_top linarith.comp_source))))))) : monoid.fg (denumerable (has_inv (random_gen (has_top (random_gen (has_top linarith.comp_source)))))) := sorry --non-trivial
lemma new_lemma_65180 (h1 : topological_space (normed_field reducibility_hints)) : t0_space (normed_field reducibility_hints) := sorry --non-trivial
lemma new_lemma_65181 (h0 : function.extfun Type group) : @normalizer_condition.{0} (canonically_ordered_monoid.{0} linarith.comp) (@function.extfun_app.{2 1} Type group.{0} h0 (canonically_ordered_monoid.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_65182 (h0 : topological_space (ordered_comm_monoid (ring linarith.comp))) : preconnected_space (ordered_comm_monoid (ring linarith.comp)) := sorry --non-trivial
lemma new_lemma_65183 (h0 : topological_space (measurable_space congr_arg_kind)) : preirreducible_space (measurable_space congr_arg_kind) := sorry --non-trivial
lemma new_lemma_65184 (h0 : topological_space (complete_semilattice_Sup unsigned)) : totally_separated_space (complete_semilattice_Sup unsigned) := sorry --non-trivial
lemma new_lemma_65185 (h0 : function.extfun nat fin) : @is_cyclic.{1} (ordered_comm_monoid.{1} Type) (@matrix.vec_empty.{1} (group.{1} (ordered_comm_monoid.{1} Type)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_65186 (h0 : ordered_add_comm_monoid (pseudo_metric_space (option name))) : archimedean (pseudo_metric_space (option name)) := sorry --non-trivial
lemma new_lemma_65187 (h0 : uniform_space (complete_semilattice_Sup (has_top num))) : separated_space (complete_semilattice_Sup (has_top num)) := sorry --non-trivial
lemma new_lemma_65188 (h0 : ring (canonically_ordered_monoid real)) : rank_condition (canonically_ordered_monoid real) := sorry --non-trivial
lemma new_lemma_65189 (h0 : function.extfun Type add_monoid) : @add_monoid.fg.{0} (linear_ordered_semiring.{0} linarith.comp) (@function.extfun_app.{2 1} Type add_monoid.{0} h0 (linear_ordered_semiring.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_65190 (h2 : function.extfun Type topological_space) : @path_connected_space.{0} (has_top.{0} string_imp) (@function.extfun_app.{2 1} Type topological_space.{0} h2 (has_top.{0} string_imp))  := sorry --non-trivial
lemma new_lemma_65191 (h0 : ring linarith.comp_source) : is_domain linarith.comp_source := sorry --non-trivial
lemma new_lemma_65192 (h0 : topological_space (has_add (finset pos))) : sequential_space (has_add (finset pos)) := sorry --non-trivial
lemma new_lemma_65193 (h0 : uniform_space (has_one (has_top empty))) : separated_space (has_one (has_top empty)) := sorry --non-trivial
lemma new_lemma_65194 (h0 : topological_space (normed_group (metric_space num))) : totally_separated_space (normed_group (metric_space num)) := sorry --non-trivial
lemma new_lemma_65195 (h0 : ring (has_top (has_norm fun_info))) : strong_rank_condition (has_top (has_norm fun_info)) := sorry --non-trivial
lemma new_lemma_65196 (h0 : function.extfun Type topological_space) : @sequential_space.{0} (comm_semigroup.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (comm_semigroup.{0} name))  := sorry --non-trivial
lemma new_lemma_65197 (h0 : add_monoid (linear_ordered_field num)) : add_monoid.fg (linear_ordered_field num) := sorry --non-trivial
lemma new_lemma_65198 (h0 : ring (encodable (has_ssubset (has_ssubset fun_info)))) : rank_condition (encodable (has_ssubset (has_ssubset fun_info))) := sorry --non-trivial
lemma new_lemma_65199 (h0 : ring (normed_group real)) : is_domain (normed_group real) := sorry --non-trivial
lemma new_lemma_65200 (h0 : topological_space (has_le linarith.comp_source)) : t0_space (has_le linarith.comp_source) := sorry --non-trivial
lemma new_lemma_65201 (h0 : topological_space (has_neg_part environment.implicit_infer_kind)) : locally_compact_space (has_neg_part environment.implicit_infer_kind) := sorry --non-trivial
lemma new_lemma_65202 (h0 : function.extfun Type ordered_comm_monoid) : @has_exists_mul_of_le.{0} (ordered_comm_monoid.{0} linarith.comp) (@function.extfun_app.{2 1} Type ordered_comm_monoid.{0} h0 (ordered_comm_monoid.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_65203 (h0 : has_mem.mem group has_emptyc.emptyc) : @normalizer_condition.{0} num (@function.extfun_app.{2 1} Type group.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) group.{0} h0) num)  := sorry --non-trivial
lemma new_lemma_65204 (h0 : topological_space (add_comm_monoid pos)) : path_connected_space (add_comm_monoid pos) := sorry --non-trivial
lemma new_lemma_65205 (h0 : ring (non_unital_non_assoc_semiring fun_info)) : is_domain (non_unital_non_assoc_semiring fun_info) := sorry --non-trivial
lemma new_lemma_65206 (h0 : topological_space (ordered_cancel_add_comm_monoid (option (option empty)))) : irreducible_space (ordered_cancel_add_comm_monoid (option (option empty))) := sorry --non-trivial
lemma new_lemma_65207 (h3 : group (uniform_space char)) : is_cyclic (uniform_space char) := sorry --non-trivial
lemma new_lemma_65208 (h0 : function.extfun Type group) : @normalizer_condition.{0} (finset.{0} linarith.comp) (@function.extfun_app.{2 1} Type group.{0} h0 (finset.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_65209 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : palindrome (function.extfun_app (function.extfun_app h0 list) (plift empty)) := sorry --non-trivial
lemma new_lemma_65210 (h0 : functor.add_const (list (has_edist unsigned)) empty) : list.nodup (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_65211 (h0 : topological_space (sub_neg_monoid (has_neg pos))) : totally_disconnected_space (sub_neg_monoid (has_neg pos)) := sorry --non-trivial
lemma new_lemma_65212 (h0 : complete_lattice (with_one (semi_normed_ring (random_gen linarith.comp_source)))) : is_compactly_generated (with_one (semi_normed_ring (random_gen linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_65213 (h0 : topological_space (has_zero (comm_group (comm_group pos)))) : preirreducible_space (has_zero (comm_group (comm_group pos))) := sorry --non-trivial
lemma new_lemma_65214 (h0 : uniform_space (with_one (has_top empty))) : separated_space (with_one (has_top empty)) := sorry --non-trivial
lemma new_lemma_65215 (h0 : functor.add_const (complete_lattice (has_dist empty)) num) : @is_atomistic.{0} (has_dist.{0} empty) (@functor.add_const.run.{0 0} (complete_lattice.{0} (has_dist.{0} empty)) num h0)  := sorry --non-trivial
lemma new_lemma_65216 (h0 : functor.add_const (ring (has_to_string Type)) name) : @is_domain.{1} (has_to_string.{1} Type) (@functor.add_const.run.{1 0} (ring.{1} (has_to_string.{1} Type)) name h0)  := sorry --non-trivial
lemma new_lemma_65217 (h0 : group (measurable_space congr_arg_kind)) : normalizer_condition (measurable_space congr_arg_kind) := sorry --non-trivial
lemma new_lemma_65218 (h0 : functor.comp ring has_nndist pos) : @rank_condition.{0} (has_nndist.{0} pos) (@functor.comp.run.{0 0 0} ring.{0} has_nndist.{0} pos h0)  := sorry --non-trivial
lemma new_lemma_65219 (h0 : not (function.extfun Type topological_space -> false)) : @totally_disconnected_space.{0} (add_group.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (add_group.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_65220 (h0 : topological_space (has_edist congr_arg_kind)) : discrete_topology (has_edist congr_arg_kind) := sorry --non-trivial
lemma new_lemma_65221 (h0 : measurable_space (has_Inf (has_Inf Type))) (h1 : has_div (has_Inf (has_Inf Type))) : has_measurable_div₂ (has_Inf (has_Inf Type)) := sorry --non-trivial
lemma new_lemma_65222 (h0 : function.extfun Type add_group) : @is_add_cyclic.{0} (has_star.{0} empty) (@function.extfun_app.{2 1} Type add_group.{0} h0 (has_star.{0} empty))  := sorry --non-trivial
lemma new_lemma_65223 (h0 : complete_lattice (uniform_space fun_info)) : complete_lattice.is_Sup_finite_compact (uniform_space fun_info) := sorry --non-trivial
lemma new_lemma_65224 (h0 : topological_space (canonically_ordered_comm_semiring (has_add (has_add (has_add linarith.comp))))) : discrete_topology (canonically_ordered_comm_semiring (has_add (has_add (has_add linarith.comp)))) := sorry --non-trivial
lemma new_lemma_65225 (h0 : function.extfun Type complete_lattice) : @is_compactly_generated.{0} (omega_complete_partial_order.{0} empty) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (omega_complete_partial_order.{0} empty))  := sorry --non-trivial
lemma new_lemma_65226 (h0 : topological_space (has_inter (option (option unsigned)))) : discrete_topology (has_inter (option (option unsigned))) := sorry --non-trivial
lemma new_lemma_65227 (h0 : cancel_comm_monoid_with_zero (normed_lattice_add_comm_group (has_Inf (has_neg Type)))) : unique_factorization_monoid (normed_lattice_add_comm_group (has_Inf (has_neg Type))) := sorry --non-trivial
lemma new_lemma_65228 (h0 : group (has_union (has_top (has_top empty)))) : group.fg (has_union (has_top (has_top empty))) := sorry --non-trivial
lemma new_lemma_65229 (h0 : topological_space (has_inv (with_bot string_imp))) : locally_compact_space (has_inv (with_bot string_imp)) := sorry --non-trivial
lemma new_lemma_65230 (h0 : uniform_space (cancel_monoid congr_arg_kind)) : separated_space (cancel_monoid congr_arg_kind) := sorry --non-trivial
lemma new_lemma_65231 (h0 : topological_space (has_lt (mul_one_class (mul_one_class fun_info)))) : t0_space (has_lt (mul_one_class (mul_one_class fun_info))) := sorry --non-trivial
lemma new_lemma_65232 (h0 : ordered_comm_monoid (comm_semigroup (has_Inf real))) : has_exists_mul_of_le (comm_semigroup (has_Inf real)) := sorry --non-trivial
lemma new_lemma_65233 (h0 : topological_space (ring (has_Inf name))) : discrete_topology (ring (has_Inf name)) := sorry --non-trivial
lemma new_lemma_65234 (h0 : topological_space (semigroup (finset pos))) : preirreducible_space (semigroup (finset pos)) := sorry --non-trivial
lemma new_lemma_65235 (h0 : ring (bin_tree congr_arg_kind)) : is_domain (bin_tree congr_arg_kind) := sorry --non-trivial
lemma new_lemma_65236 (h0 : ring (has_ssubset (random_gen (random_gen char)))) : is_domain (has_ssubset (random_gen (random_gen char))) := sorry --non-trivial
lemma new_lemma_65237 (h0 : ring (has_add (random_gen string_imp))) : rank_condition (has_add (random_gen string_imp)) := sorry --non-trivial
lemma new_lemma_65238 (h0 : group (option (option (option ennreal)))) : is_simple_group (option (option (option ennreal))) := sorry --non-trivial
lemma new_lemma_65239 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : countable_Inter_filter (function.extfun_app (function.extfun_app h0 filter) (ring name)) := sorry --non-trivial
lemma new_lemma_65240 (h0 : has_mem.mem empty has_emptyc.emptyc) : @is_atomistic.{0} empty (@finset.pi.empty.{1 0} Type complete_lattice.{0} empty h0)  := sorry --non-trivial
lemma new_lemma_65241 (h0 : prod (add_group num) (add_group num)) : id_rel h0 := sorry --non-trivial
lemma new_lemma_65242 (h0 : functor.add_const (ring (add_cancel_monoid pos)) environment.implicit_infer_kind) : @is_domain.{0} (add_cancel_monoid.{0} pos) (@functor.add_const.run.{0 0} (ring.{0} (add_cancel_monoid.{0} pos)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_65243 (h0 : topological_space (finset (semigroup Type))) : totally_disconnected_space (finset (semigroup Type)) := sorry --non-trivial
lemma new_lemma_65244 (h0 : complete_lattice (add_cancel_comm_monoid (option (option (option unsigned))))) : is_atomistic (add_cancel_comm_monoid (option (option (option unsigned)))) := sorry --non-trivial
lemma new_lemma_65245 (h0 : function.extfun Type finset) : finset.nonempty (function.extfun_app h0 (complete_distrib_lattice linarith.comp)) := sorry --non-trivial
lemma new_lemma_65246 (h0 : functor.add_const (filter (comm_group unsigned)) Type) : filter.ne_bot (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_65247 (h0 : uniform_space (semiring (random_gen num))) : complete_space (semiring (random_gen num)) := sorry --non-trivial
lemma new_lemma_65248 (h0 : function.extfun Type (functor.add_const (uniform_space (canonically_ordered_add_monoid empty)))) : @complete_space.{0} (canonically_ordered_add_monoid.{0} empty) (@functor.add_const.run.{0 0} (uniform_space.{0} (canonically_ordered_add_monoid.{0} empty)) empty (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (uniform_space.{0} (canonically_ordered_add_monoid.{0} empty))) h0 empty))  := sorry --non-trivial
lemma new_lemma_65249 (h0 : functor.comp topological_space add_comm_monoid Type) : @preconnected_space.{1} (add_comm_monoid.{1} Type) (@functor.comp.run.{1 1 1} topological_space.{1} add_comm_monoid.{1} Type h0)  := sorry --non-trivial
lemma new_lemma_65250 (h0 : functor.add_const (topological_space (complete_distrib_lattice pos)) pos) : @locally_compact_space.{0} (complete_distrib_lattice.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (complete_distrib_lattice.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_65251 (h0 : filter (has_neg (option pos))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_65252 (h0 : filter (has_top (random_gen linarith.comp_source))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_65253 (h0 : empty -> semiring unsigned -> Prop) : relator.right_total h0 := sorry --non-trivial
lemma new_lemma_65254 (h0 : group (generalized_boolean_algebra (boolean_algebra.core (boolean_algebra.core pos)))) : is_cyclic (generalized_boolean_algebra (boolean_algebra.core (boolean_algebra.core pos))) := sorry --non-trivial
lemma new_lemma_65255 (h0 : group (add_cancel_monoid (has_Inf (has_pos_part (ring Type))))) : is_cyclic (add_cancel_monoid (has_Inf (has_pos_part (ring Type)))) := sorry --non-trivial
lemma new_lemma_65256 (h0 : group (has_add (has_nnnorm linarith.comp_source))) : is_cyclic (has_add (has_nnnorm linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_65257 (h1 : has_neg (has_nnnorm environment.projection_info)) (h2 : measurable_space (has_nnnorm environment.projection_info)) : has_measurable_neg (has_nnnorm environment.projection_info) := sorry --non-trivial
lemma new_lemma_65258 (h0 : uniform_space (has_Inf (has_add (boolean_algebra.core (has_add Type))))) : complete_space (has_Inf (has_add (boolean_algebra.core (has_add Type)))) := sorry --non-trivial
lemma new_lemma_65259 (h0 : group (has_union num)) : group.fg (has_union num) := sorry --non-trivial
lemma new_lemma_65260 (h0 : ring (has_top (semiring unsigned))) : rank_condition (has_top (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_65261 (h0 : functor.add_const (function.extfun (Type 1) group) name) : @group.fg.{1} (simple_graph.{1} Type) (@function.extfun_app.{3 2} (Type 1) group.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) group.{1}) name h0) (simple_graph.{1} Type))  := sorry --non-trivial
lemma new_lemma_65262 (h0 : topological_space (finset (canonically_linear_ordered_monoid name))) : totally_disconnected_space (finset (canonically_linear_ordered_monoid name)) := sorry --non-trivial
lemma new_lemma_65263 (h0 : group (add_cancel_monoid (has_nndist (has_add (finset unsigned))))) : is_cyclic (add_cancel_monoid (has_nndist (has_add (finset unsigned)))) := sorry --non-trivial
lemma new_lemma_65264 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : filter.ne_bot (function.extfun_app (function.extfun_app h0 filter) (add_comm_monoid ennreal)) := sorry --non-trivial
lemma new_lemma_65265 (h0 : functor.add_const (finset (normed_comm_ring linarith.comp)) linarith.comp) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_65266 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @totally_disconnected_space.{1} (generalized_boolean_algebra.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 topological_space.{1}) (generalized_boolean_algebra.{1} Type))  := sorry --non-trivial
lemma new_lemma_65267 (h0 : topological_space (pseudo_metric_space unsigned)) : t1_space (pseudo_metric_space unsigned) := sorry --non-trivial
lemma new_lemma_65268 (h0 : function.extfun (nat -> Type) (function.extfun nat)) : @preirreducible_space.{0} (ordered_comm_monoid.{0} linarith.comp) (@matrix.vec_empty.{0} (topological_space.{0} (ordered_comm_monoid.{0} linarith.comp)) (@function.extfun_app.{1 1} nat fin (@function.extfun_app.{2 1} (nat → Type) (function.extfun.{1 1} nat) h0 fin) (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_65269 (h0 : group (has_add (has_nnnorm linarith.comp_source))) : normalizer_condition (has_add (has_nnnorm linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_65270 (h0 : function.extfun Type complete_lattice) : @is_atomistic.{0} (has_norm.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (has_norm.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_65271 (h0 : not (function.extfun (finset Type) (has_mem.mem (normed_group linarith.comp)) -> false)) : @is_domain.{0} (normed_group.{0} linarith.comp) (@finset.pi.empty.{1 0} Type ring.{0} (normed_group.{0} linarith.comp) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (normed_group.{0} linarith.comp)) (@classical.by_contradiction'.{0} (function.extfun.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (normed_group.{0} linarith.comp))) h0) (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_65272 (h0 : topological_space (has_neg_part (comm_group (has_add unsigned)))) : regular_space (has_neg_part (comm_group (has_add unsigned))) := sorry --non-trivial
lemma new_lemma_65273 (h0 : topological_space (ordered_comm_group num)) : path_connected_space (ordered_comm_group num) := sorry --non-trivial
lemma new_lemma_65274 (h0 : ordered_comm_monoid (comm_semigroup (has_bot real))) : has_exists_mul_of_le (comm_semigroup (has_bot real)) := sorry --non-trivial
lemma new_lemma_65275 (h2 : topological_space (has_emptyc (random_gen num))) : irreducible_space (has_emptyc (random_gen num)) := sorry --non-trivial
lemma new_lemma_65276 (h0 : functor.add_const (filter (semigroup pos)) Type) : countable_Inter_filter (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_65277 (h0 : has_mem.mem (measurable_space linarith.comp) has_emptyc.emptyc) : @complete_space.{0} (measurable_space.{0} linarith.comp) (@finset.pi.empty.{1 0} Type uniform_space.{0} (measurable_space.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_65278 (h0 : complete_lattice (has_zero (option pos))) : is_compactly_generated (has_zero (option pos)) := sorry --non-trivial
lemma new_lemma_65279 (h0 : complete_lattice (option (semiring (semiring congr_arg_kind)))) : is_compactly_generated (option (semiring (semiring congr_arg_kind))) := sorry --non-trivial
lemma new_lemma_65280 (h0 : topological_space (has_union (has_top (has_top empty)))) : t0_space (has_union (has_top (has_top empty))) := sorry --non-trivial
lemma new_lemma_65281 (h0 : group (normed_group (has_norm congr_arg_kind))) : normalizer_condition (normed_group (has_norm congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_65282 (h0 : add_group (linear_ordered_add_comm_group (denumerable (has_top (has_top linarith.ineq))))) : is_add_cyclic (linear_ordered_add_comm_group (denumerable (has_top (has_top linarith.ineq)))) := sorry --non-trivial
lemma new_lemma_65283 (h0 : function.extfun Type uniform_space) : @complete_space.{0} (has_inv.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (has_inv.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_65284 (h0 : complete_lattice (distrib_lattice (random_gen to_additive.value_type))) : is_compactly_generated (distrib_lattice (random_gen to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_65285 (h0 : functor.comp topological_space has_neg pos) : @t1_space.{0} (has_neg.{0} pos) (@functor.comp.run.{0 0 0} topological_space.{0} has_neg.{0} pos h0)  := sorry --non-trivial
lemma new_lemma_65286 (h0 : complete_lattice (has_div (has_ssubset enat))) : is_compactly_generated (has_div (has_ssubset enat)) := sorry --non-trivial
lemma new_lemma_65287 (h0 : functor.add_const (topological_space (measurable_space.dynkin_system num)) num) : @totally_disconnected_space.{0} (measurable_space.dynkin_system.{0} num) (@functor.add_const.run.{0 0} (topological_space.{0} (measurable_space.dynkin_system.{0} num)) num h0)  := sorry --non-trivial
lemma new_lemma_65288 (h0 : list (complete_semilattice_Sup fun_info)) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_65289 (h0 : fin has_zero.zero) : @sequential_space.{0} (ordered_comm_ring.{0} real) (@matrix.vec_empty.{0} (topological_space.{0} (ordered_comm_ring.{0} real)) (@matrix.vec_empty.{0} (fin (@has_zero.zero.{0} nat nat.has_zero)) h0))  := sorry --non-trivial
lemma new_lemma_65290 (h0 : ordered_add_comm_monoid (boolean_algebra.core (option empty))) : archimedean (boolean_algebra.core (option empty)) := sorry --non-trivial
lemma new_lemma_65291 (h0 : not (topological_space (canonically_ordered_monoid empty) -> false)) : @totally_disconnected_space.{0} (canonically_ordered_monoid.{0} empty) (@classical.by_contradiction'.{1} (topological_space.{0} (canonically_ordered_monoid.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_65292 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_compactly_generated.{0} (monoid_with_zero.{0} pos) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (monoid_with_zero.{0} pos))  := sorry --non-trivial
lemma new_lemma_65293 (h0 : topological_space (has_top (has_norm fun_info))) : discrete_topology (has_top (has_norm fun_info)) := sorry --non-trivial
lemma new_lemma_65294 (h0 : fin has_zero.zero) : @is_principal_ideal_ring.{1} (simple_graph.{1} Type) (@matrix.vec_empty.{1} (ring.{1} (simple_graph.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_65295 (h0 : topological_space (ordered_comm_monoid (finset linarith.comp))) : regular_space (ordered_comm_monoid (finset linarith.comp)) := sorry --non-trivial
lemma new_lemma_65296 (h0 : function.extfun Type topological_space) : @path_connected_space.{0} (ordered_comm_ring.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (ordered_comm_ring.{0} name))  := sorry --non-trivial
lemma new_lemma_65297 (h0 : functor.add_const (topological_space (measurable_space.dynkin_system num)) unsigned) : @locally_compact_space.{0} (measurable_space.dynkin_system.{0} num) (@functor.add_const.run.{0 0} (topological_space.{0} (measurable_space.dynkin_system.{0} num)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_65298 (h0 : topological_space (has_edist (option empty))) : discrete_topology (has_edist (option empty)) := sorry --non-trivial
lemma new_lemma_65299 (h0 : functor.add_const (topological_space (has_zero environment.implicit_infer_kind)) pos) : @preconnected_space.{0} (has_zero.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (has_zero.{0} environment.implicit_infer_kind)) pos h0)  := sorry --non-trivial
lemma new_lemma_65300 (h0 : function.extfun Type ordered_add_comm_monoid) : @archimedean.{0} (has_zero.{0} (option.{0} pos)) (@function.extfun_app.{2 1} Type ordered_add_comm_monoid.{0} h0 (has_zero.{0} (option.{0} pos)))  := sorry --non-trivial
lemma new_lemma_65301 (h0 : functor.add_const (functor.add_const (topological_space (comm_group linarith.comp)) name) name) : @loc_path_connected_space.{0} (comm_group.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (comm_group.{0} linarith.comp)) name (@functor.add_const.run.{0 0} (functor.add_const.{0 0} (topological_space.{0} (comm_group.{0} linarith.comp)) name) name h0))  := sorry --non-trivial
lemma new_lemma_65302 (h0 : linear_ordered_field (pseudo_metric_space ennreal) -> linear_ordered_field (pseudo_metric_space ennreal) -> Prop) : is_symm (linear_ordered_field (pseudo_metric_space ennreal)) h0 := sorry --non-trivial
lemma new_lemma_65303 (h0 : ring (has_ssubset char)) : is_domain (has_ssubset char) := sorry --non-trivial
lemma new_lemma_65304 (h0 : function.extfun Type filter) : filter.ne_bot (function.extfun_app h0 (id empty)) := sorry --non-trivial
lemma new_lemma_65305 (h0 : not (ring (normed_field (has_nnnorm (has_lt (add_cancel_comm_monoid string.iterator_imp)))) -> false)) : @rank_condition.{0} (normed_field.{0} (has_nnnorm.{0} (has_lt.{0} (add_cancel_comm_monoid.{0} string.iterator_imp)))) (@classical.by_contradiction'.{1} (ring.{0} (normed_field.{0} (has_nnnorm.{0} (has_lt.{0} (add_cancel_comm_monoid.{0} string.iterator_imp))))) h0)  := sorry --non-trivial
lemma new_lemma_65306 (h0 : topological_space (mul_zero_class (semiring congr_arg_kind))) : preirreducible_space (mul_zero_class (semiring congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_65307 (h0 : function.extfun Type topological_space) : @preirreducible_space.{0} (has_pos_part.{0} real) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_pos_part.{0} real))  := sorry --non-trivial
lemma new_lemma_65308 (h0 : function.extfun Type topological_space) : @totally_separated_space.{0} (left_cancel_monoid.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (left_cancel_monoid.{0} empty))  := sorry --non-trivial
lemma new_lemma_65309 (h0 : prod (has_nndist (boolean_algebra.core name)) (has_nndist (boolean_algebra.core name))) : id_rel h0 := sorry --non-trivial
lemma new_lemma_65310 (h0 : functor.add_const (uniform_space (cancel_monoid name)) name) : @separated_space.{0} (cancel_monoid.{0} name) (@functor.add_const.run.{0 0} (uniform_space.{0} (cancel_monoid.{0} name)) name h0)  := sorry --non-trivial
lemma new_lemma_65311 (h0 : functor.add_const (complete_lattice (cancel_monoid environment.implicit_infer_kind)) (ring Type)) : @is_compactly_generated.{0} (cancel_monoid.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 1} (complete_lattice.{0} (cancel_monoid.{0} environment.implicit_infer_kind)) (ring.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_65312 (h0 : functor.add_const (topological_space (has_to_string environment.implicit_infer_kind)) pos) : @t0_space.{0} (has_to_string.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (has_to_string.{0} environment.implicit_infer_kind)) pos h0)  := sorry --non-trivial
lemma new_lemma_65313 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @t1_space.{0} (boolean_algebra.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (boolean_algebra.{0} pos))  := sorry --non-trivial
lemma new_lemma_65314 (h0 : not (function.extfun Type ring -> false)) : @strong_rank_condition.{0} (linear_ordered_semiring.{0} fun_info) (@function.extfun_app.{2 1} Type ring.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type ring.{0}) h0) (linear_ordered_semiring.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_65315 (h0 : complete_lattice (denumerable (has_nnnorm (random_gen char)))) : complete_lattice.is_Sup_finite_compact (denumerable (has_nnnorm (random_gen char))) := sorry --non-trivial
lemma new_lemma_65316 (h0 : topological_space (finset (finset (finset (has_zero pos))))) : loc_path_connected_space (finset (finset (finset (has_zero pos)))) := sorry --non-trivial
lemma new_lemma_65317 (h0 : topological_space (has_Sup (semiring unsigned))) : discrete_topology (has_Sup (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_65318 (h0 : topological_space (has_bot (option unsigned))) : loc_path_connected_space (has_bot (option unsigned)) := sorry --non-trivial
lemma new_lemma_65319 (h0 : function.extfun Type ring) : @is_domain.{0} (add_comm_monoid.{0} unsigned) (@function.extfun_app.{2 1} Type ring.{0} h0 (add_comm_monoid.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_65320 (h1 : function.extfun Type list) : list.nodup (function.extfun_app h1 (with_one string_imp)) := sorry --non-trivial
lemma new_lemma_65321 (h1 : topological_space (measurable_space (with_bot string_imp))) : locally_compact_space (measurable_space (with_bot string_imp)) := sorry --non-trivial
lemma new_lemma_65322 (h0 : uniform_space (has_inf to_additive.value_type)) : complete_space (has_inf to_additive.value_type) := sorry --non-trivial
lemma new_lemma_65323 (h0 : not (complete_lattice name -> false)) : @is_atomistic.{0} name (@classical.by_contradiction'.{1} (complete_lattice.{0} name) h0)  := sorry --non-trivial
lemma new_lemma_65324 (h0 : group (has_pos_part (has_neg name))) : normalizer_condition (has_pos_part (has_neg name)) := sorry --non-trivial
lemma new_lemma_65325 (h0 : group (complete_semilattice_Sup to_additive.value_type)) : normalizer_condition (complete_semilattice_Sup to_additive.value_type) := sorry --non-trivial
lemma new_lemma_65326 (h0 : function.extfun Type topological_space) : @path_connected_space.{0} (canonically_ordered_comm_semiring.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (canonically_ordered_comm_semiring.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_65327 (h0 : measurable_space (has_nnnorm char)) (h1 : filter (has_nnnorm char)) : filter.is_measurably_generated h1 := sorry --non-trivial
lemma new_lemma_65328 (h0 : topological_space (has_top (has_top fun_info))) : irreducible_space (has_top (has_top fun_info)) := sorry --non-trivial
lemma new_lemma_65329 (h0 : topological_space (generalized_boolean_algebra (has_add linarith.comp))) : totally_separated_space (generalized_boolean_algebra (has_add linarith.comp)) := sorry --non-trivial
lemma new_lemma_65330 (h0 : functor.add_const (add_monoid (boolean_algebra.core name)) Type) : @add_monoid.fg.{0} (boolean_algebra.core.{0} name) (@functor.add_const.run.{0 1} (add_monoid.{0} (boolean_algebra.core.{0} name)) Type h0)  := sorry --non-trivial
lemma new_lemma_65331 (h0 : has_mem.mem unsigned has_emptyc.emptyc) : @monoid.fg.{0} unsigned (@finset.pi.empty.{1 0} Type monoid.{0} unsigned h0)  := sorry --non-trivial
lemma new_lemma_65332 (h0 : topological_space (has_norm (has_top (has_top (has_top linarith.comp_source))))) : totally_separated_space (has_norm (has_top (has_top (has_top linarith.comp_source)))) := sorry --non-trivial
lemma new_lemma_65333 (h0 : function.extfun Type topological_space) : @irreducible_space.{0} (has_neg.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_neg.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_65334 (h0 : topological_space (boolean_algebra (comm_group name))) : regular_space (boolean_algebra (comm_group name)) := sorry --non-trivial
lemma new_lemma_65335 (h0 : group (has_top to_additive.value_type)) : normalizer_condition (has_top to_additive.value_type) := sorry --non-trivial
lemma new_lemma_65336 (h0 : has_mem.mem fun_info has_emptyc.emptyc) : @irreducible_space.{0} fun_info (@finset.pi.empty.{1 0} Type topological_space.{0} fun_info h0)  := sorry --non-trivial
lemma new_lemma_65337 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @separated_space.{0} (option.{0} num) (@function.extfun_app.{2 1} Type uniform_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 uniform_space.{0}) (option.{0} num))  := sorry --non-trivial
lemma new_lemma_65338 (h0 : complete_lattice (left_cancel_semigroup empty)) : complete_lattice.is_Sup_finite_compact (left_cancel_semigroup empty) := sorry --non-trivial
lemma new_lemma_65339 (h0 : functor.add_const (topological_space (finset Type)) linarith.comp) : @totally_separated_space.{1} (finset.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (finset.{1} Type)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_65340 (h0 : ring (canonically_ordered_add_monoid empty)) : is_domain (canonically_ordered_add_monoid empty) := sorry --non-trivial
lemma new_lemma_65341 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_compactly_generated.{0} (semigroup.{0} name) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (semigroup.{0} name))  := sorry --non-trivial
lemma new_lemma_65342 (h0 : function.extfun Type topological_space) : @t0_space.{0} (@id.{2} Type congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (@id.{2} Type congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_65343 (h0 : add_group (conditionally_complete_linear_order string_imp)) : is_add_cyclic (conditionally_complete_linear_order string_imp) := sorry --non-trivial
lemma new_lemma_65344 (h0 : topological_space (normed_comm_ring (comm_group unsigned))) : normal_space (normed_comm_ring (comm_group unsigned)) := sorry --non-trivial
lemma new_lemma_65345 (h0 : ring (uniform_space (random_gen (random_gen char)))) : strong_rank_condition (uniform_space (random_gen (random_gen char))) := sorry --non-trivial
lemma new_lemma_65346 (h0 : functor.add_const (topological_space (add_left_cancel_semigroup unsigned)) num) : @loc_path_connected_space.{0} (add_left_cancel_semigroup.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (add_left_cancel_semigroup.{0} unsigned)) num h0)  := sorry --non-trivial
lemma new_lemma_65347 (h0 : function.extfun Type topological_space) : @irreducible_space.{0} (linear_ordered_cancel_comm_monoid.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (linear_ordered_cancel_comm_monoid.{0} empty))  := sorry --non-trivial
lemma new_lemma_65348 (h1 : topological_space (has_ssubset (random_gen char))) : path_connected_space (has_ssubset (random_gen char)) := sorry --non-trivial
lemma new_lemma_65349 (h0 : topological_space (complete_distrib_lattice linarith.comp)) : sequential_space (complete_distrib_lattice linarith.comp) := sorry --non-trivial
lemma new_lemma_65350 (h0 : uniform_space (normed_field (mul_one_class reducibility_hints))) : complete_space (normed_field (mul_one_class reducibility_hints)) := sorry --non-trivial
lemma new_lemma_65351 (h0 : uniform_space (metric_space linarith.comp)) : complete_space (metric_space linarith.comp) := sorry --non-trivial
lemma new_lemma_65352 (h0 : measurable_space (normed_field (normed_field char))) (h1 : measure_theory.measure (normed_field (normed_field char))) : measure_theory.is_finite_measure h1 := sorry --non-trivial
lemma new_lemma_65353 (h0 : function.extfun Type topological_space) : @totally_disconnected_space.{0} (group_with_zero.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (group_with_zero.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_65354 (h0 : topological_space (ordered_comm_ring (ring (boolean_algebra.core Type)))) : preconnected_space (ordered_comm_ring (ring (boolean_algebra.core Type))) := sorry --non-trivial
lemma new_lemma_65355 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @preirreducible_space.{0} (monoid_with_zero.{0} ennreal) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (monoid_with_zero.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_65356 (h0 : cancel_comm_monoid_with_zero (ring (option pos))) : unique_factorization_monoid (ring (option pos)) := sorry --non-trivial
lemma new_lemma_65357 (h0 : function.extfun Type topological_space) : @normal_space.{0} (has_sub.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_sub.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_65358 (h0 : topological_space (simple_graph (has_add (has_add linarith.comp)))) : regular_space (simple_graph (has_add (has_add linarith.comp))) := sorry --non-trivial
lemma new_lemma_65359 (h0 : ring (topological_space linarith.comp_source)) : is_domain (topological_space linarith.comp_source) := sorry --non-trivial
lemma new_lemma_65360 (h0 : topological_space (has_neg_part (mul_zero_class name))) : preconnected_space (has_neg_part (mul_zero_class name)) := sorry --non-trivial
lemma new_lemma_65361 (h0 : function.extfun Type group) : @is_cyclic.{0} (has_union.{0} num) (@function.extfun_app.{2 1} Type group.{0} h0 (has_union.{0} num))  := sorry --non-trivial
lemma new_lemma_65362 (h0 : group (has_edist congr_arg_kind)) : is_cyclic (has_edist congr_arg_kind) := sorry --non-trivial
lemma new_lemma_65363 (h0 : finset (plift (semiring empty))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_65364 (h0 : ring (random_gen (has_ssubset reducibility_hints))) : strong_rank_condition (random_gen (has_ssubset reducibility_hints)) := sorry --non-trivial
lemma new_lemma_65365 (h0 : complete_lattice (has_bot (has_bot real))) : is_atomistic (has_bot (has_bot real)) := sorry --non-trivial
lemma new_lemma_65366 (h0 : functor.add_const (ring (boolean_algebra environment.implicit_infer_kind)) Type) : @is_domain.{0} (boolean_algebra.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 1} (ring.{0} (boolean_algebra.{0} environment.implicit_infer_kind)) Type h0)  := sorry --non-trivial
lemma new_lemma_65367 (h0 : functor.add_const (topological_space (comm_group Type)) (normed_comm_ring name)) : @locally_compact_space.{1} (comm_group.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (comm_group.{1} Type)) (normed_comm_ring.{0} name) h0)  := sorry --non-trivial
lemma new_lemma_65368 (h0 : ring (boolean_algebra.core (add_comm_monoid Type))) : rank_condition (boolean_algebra.core (add_comm_monoid Type)) := sorry --non-trivial
lemma new_lemma_65369 (h0 : ring (has_zero (has_neg_part name))) : is_domain (has_zero (has_neg_part name)) := sorry --non-trivial
lemma new_lemma_65370 (h0 : function.extfun Type add_group) : @is_add_cyclic.{0} (has_ssubset.{0} fun_info) (@function.extfun_app.{2 1} Type add_group.{0} h0 (has_ssubset.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_65371 (h0 : functor.add_const (uniform_space (add_semigroup unsigned)) num) : @separated_space.{0} (add_semigroup.{0} unsigned) (@functor.add_const.run.{0 0} (uniform_space.{0} (add_semigroup.{0} unsigned)) num h0)  := sorry --non-trivial
lemma new_lemma_65372 (h0 : group (normed_group (semiring (semiring num)))) : is_cyclic (normed_group (semiring (semiring num))) := sorry --non-trivial
lemma new_lemma_65373 (h0 : has_top linarith.comp_source -> Prop) : zzz_forall h0 := sorry --non-trivial
lemma new_lemma_65374 (h0 : monoid (with_bot (has_inv (random_gen to_additive.value_type)))) : monoid.fg (with_bot (has_inv (random_gen to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_65375 (h0 : finset (add_cancel_monoid (has_neg linarith.comp))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_65376 (h0 : functor.add_const (filter (has_to_string pos)) (has_to_string Type)) : filter.ne_bot (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_65377 (h0 : complete_lattice (has_top (random_gen linarith.ineq))) : is_atomistic (has_top (random_gen linarith.ineq)) := sorry --non-trivial
lemma new_lemma_65378 (h0 : function.extfun Type uniform_space) : @separated_space.{0} (has_neg.{0} unsigned) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (has_neg.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_65379 (h0 : function.extfun (((ring empty -> false) -> Prop) -> Prop) (function.extfun ((ring empty -> false) -> Prop))) : @is_domain.{0} empty (@classical.by_contradiction'.{1} (ring.{0} empty) (@function.extfun_app.{0 0} (ring.{0} empty → false) (λ (x : ring.{0} empty → false), false) (@function.extfun_app.{1 0} ((ring.{0} empty → false) → Prop) (function.extfun.{0 0} (ring.{0} empty → false)) (@function.extfun_app.{1 0} (((ring.{0} empty → false) → Prop) → Prop) (function.extfun.{1 0} ((ring.{0} empty → false) → Prop)) h0 (function.extfun.{0 0} (ring.{0} empty → false))) (λ (x : ring.{0} empty → false), false))))  := sorry --non-trivial
lemma new_lemma_65380 (h0 : add_group (boolean_algebra.core (has_nndist Type))) : is_add_cyclic (boolean_algebra.core (has_nndist Type)) := sorry --non-trivial
lemma new_lemma_65381 (h0 : complete_lattice (has_inv (has_ssubset to_additive.value_type))) : is_compactly_generated (has_inv (has_ssubset to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_65382 (h0 : function.extfun Type topological_space) : @path_connected_space.{0} (has_sub.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_sub.{0} empty))  := sorry --non-trivial
lemma new_lemma_65383 (h0 : functor.add_const (group (has_neg ennreal)) (has_nndist environment.implicit_infer_kind)) : @group.fg.{0} (has_neg.{0} ennreal) (@functor.add_const.run.{0 0} (group.{0} (has_neg.{0} ennreal)) (has_nndist.{0} environment.implicit_infer_kind) h0)  := sorry --non-trivial
lemma new_lemma_65384 (h0 : topological_space (boolean_algebra.core (option num))) : totally_separated_space (boolean_algebra.core (option num)) := sorry --non-trivial
lemma new_lemma_65385 (h0 : function.extfun Type topological_space) : @t0_space.{0} (canonically_ordered_add_monoid.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (canonically_ordered_add_monoid.{0} empty))  := sorry --non-trivial
lemma new_lemma_65386 (h0 : functor.add_const (topological_space (has_to_string Type)) name) : @discrete_topology.{1} (has_to_string.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (has_to_string.{1} Type)) name h0)  := sorry --non-trivial
lemma new_lemma_65387 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_principal_ideal_ring.{0} (has_edist.{0} unsigned) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (has_edist.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_65388 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @add_monoid.fg.{0} (has_bot.{0} empty) (@function.extfun_app.{2 1} Type add_monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 add_monoid.{0}) (has_bot.{0} empty))  := sorry --non-trivial
lemma new_lemma_65389 (h0 : functor.add_const (functor.add_const Prop (generalized_boolean_algebra Type)) linarith.comp) : functor.add_const.run (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_65390 (h0 : group (has_sub congr_arg_kind)) : group.fg (has_sub congr_arg_kind) := sorry --non-trivial
lemma new_lemma_65391 (h0 : ordered_add_comm_monoid (ordered_comm_ring (finset (finset Type)))) : archimedean (ordered_comm_ring (finset (finset Type))) := sorry --non-trivial
lemma new_lemma_65392 (h0 : function.extfun Type group) : @is_cyclic.{0} (canonically_linear_ordered_monoid.{0} num) (@function.extfun_app.{2 1} Type group.{0} h0 (canonically_linear_ordered_monoid.{0} num))  := sorry --non-trivial
lemma new_lemma_65393 (h3 : function.extfun Type topological_space) : @locally_compact_space.{0} linarith.comp_source (@function.extfun_app.{2 1} Type topological_space.{0} h3 linarith.comp_source)  := sorry --non-trivial
lemma new_lemma_65394 (h1 : topological_space (mul_one_class (mul_one_class enat))) : totally_disconnected_space (mul_one_class (mul_one_class enat)) := sorry --non-trivial
lemma new_lemma_65395 (h0 : functor.add_const (topological_space (finset pos)) (has_neg (has_neg pos))) : @t0_space.{0} (finset.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (finset.{0} pos)) (has_neg.{0} (has_neg.{0} pos)) h0)  := sorry --non-trivial
lemma new_lemma_65396 (h1 : add_group (semi_normed_ring linarith.comp_source)) : is_add_cyclic (semi_normed_ring linarith.comp_source) := sorry --non-trivial
lemma new_lemma_65397 (h0 : filter (comm_group (comm_group (comm_group (comm_group name))))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_65398 (h0 : not (complete_lattice (semi_normed_comm_ring reducibility_hints) -> false)) : @complete_lattice.is_Sup_finite_compact.{0} (semi_normed_comm_ring.{0} reducibility_hints) (@classical.by_contradiction'.{1} (complete_lattice.{0} (semi_normed_comm_ring.{0} reducibility_hints)) h0)  := sorry --non-trivial
lemma new_lemma_65399 (h0 : has_mem.mem linarith.ineq has_emptyc.emptyc) : @totally_separated_space.{0} linarith.ineq (@finset.pi.empty.{1 0} Type topological_space.{0} linarith.ineq h0)  := sorry --non-trivial
lemma new_lemma_65400 (h0 : topological_space (finset (has_to_string (has_to_string (finset Type))))) : path_connected_space (finset (has_to_string (has_to_string (finset Type)))) := sorry --non-trivial
lemma new_lemma_65401 (h0 : set (normed_field (mul_one_class ereal) -> add_comm_semigroup std_gen)) : set.separates_points h0 := sorry --non-trivial
lemma new_lemma_65402 (h0 : topological_space (option unsigned)) : sequential_space (option unsigned) := sorry --non-trivial
lemma new_lemma_65403 (h0 : topological_space (has_add (has_add (has_Inf pos)))) : preirreducible_space (has_add (has_add (has_Inf pos))) := sorry --non-trivial
lemma new_lemma_65404 (h0 : functor.add_const (complete_lattice (has_neg_part Type)) environment.implicit_infer_kind) : @is_compactly_generated.{1} (has_neg_part.{1} Type) (@functor.add_const.run.{1 0} (complete_lattice.{1} (has_neg_part.{1} Type)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_65405 (h1 : ring (nondiscrete_normed_field linarith.ineq)) : strong_rank_condition (nondiscrete_normed_field linarith.ineq) := sorry --non-trivial
lemma new_lemma_65406 (h0 : complete_lattice (measurable_space (semiring empty))) : complete_lattice.is_Sup_finite_compact (measurable_space (semiring empty)) := sorry --non-trivial
lemma new_lemma_65407 (h0 : functor.add_const (topological_space (ordered_ring num)) num) : @loc_path_connected_space.{0} (ordered_ring.{0} num) (@functor.add_const.run.{0 0} (topological_space.{0} (ordered_ring.{0} num)) num h0)  := sorry --non-trivial
lemma new_lemma_65408 (h0 : function.extfun (Type 1) topological_space) : @irreducible_space.{1} (ring.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} h0 (ring.{1} Type))  := sorry --non-trivial
lemma new_lemma_65409 (h0 : functor.add_const (topological_space (ordered_comm_monoid name)) linarith.comp) : @normal_space.{0} (ordered_comm_monoid.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (ordered_comm_monoid.{0} name)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_65410 (h0 : not (group (has_top num) -> false)) : @normalizer_condition.{0} (has_top.{0} num) (@classical.by_contradiction'.{1} (group.{0} (has_top.{0} num)) h0)  := sorry --non-trivial
lemma new_lemma_65411 (h0 : topological_space (has_norm num)) : normal_space (has_norm num) := sorry --non-trivial
lemma new_lemma_65412 (h0 : functor.add_const (ordered_add_comm_monoid (add_cancel_monoid pos)) linarith.comp) : @archimedean.{0} (add_cancel_monoid.{0} pos) (@functor.add_const.run.{0 0} (ordered_add_comm_monoid.{0} (add_cancel_monoid.{0} pos)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_65413 (h0 : complete_lattice (comm_group (comm_group (comm_group ennreal)))) : is_compactly_generated (comm_group (comm_group (comm_group ennreal))) := sorry --non-trivial
lemma new_lemma_65414 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @separated_space.{0} (ring.{0} linarith.comp) (@function.extfun_app.{2 1} Type uniform_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 uniform_space.{0}) (ring.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_65415 (h0 : group (has_inv (has_norm fun_info))) : group.fg (has_inv (has_norm fun_info)) := sorry --non-trivial
lemma new_lemma_65416 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @preirreducible_space.{0} (has_pos_part.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_pos_part.{0} pos))  := sorry --non-trivial
lemma new_lemma_65417 (h0 : ring (boolean_algebra (has_neg Type))) : is_domain (boolean_algebra (has_neg Type)) := sorry --non-trivial
lemma new_lemma_65418 (h0 : function.extfun Type topological_space) : @t1_space.{0} (comm_group.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (comm_group.{0} pos))  := sorry --non-trivial
lemma new_lemma_65419 (h0 : functor.add_const (ring (normed_comm_ring pos)) (ring Type)) : @is_domain.{0} (normed_comm_ring.{0} pos) (@functor.add_const.run.{0 1} (ring.{0} (normed_comm_ring.{0} pos)) (ring.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_65420 (h0 : monoid (normed_group empty)) : monoid.fg (normed_group empty) := sorry --non-trivial
lemma new_lemma_65421 (h0 : group (non_assoc_semiring (option unsigned))) : is_cyclic (non_assoc_semiring (option unsigned)) := sorry --non-trivial
lemma new_lemma_65422 (h0 : ring (option unsigned)) : rank_condition (option unsigned) := sorry --non-trivial
lemma new_lemma_65423 (h0 : function.extfun ((Type 1 -> Type 1) -> Type 2) (function.extfun (Type 1 -> Type 1))) : @t1_space.{1} (ring.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) (@function.extfun_app.{4 3} ((Type 1 → Type 1) → Type 2) (function.extfun.{3 3} (Type 1 → Type 1)) h0 (function.extfun.{3 2} (Type 1))) topological_space.{1}) (ring.{1} Type))  := sorry --non-trivial
lemma new_lemma_65424 (h0 : not (add_group linarith.comp_source -> false)) : @is_add_cyclic.{0} linarith.comp_source (@classical.by_contradiction'.{1} (add_group.{0} linarith.comp_source) h0)  := sorry --non-trivial
lemma new_lemma_65425 (h0 : finset (has_add (has_Inf name))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_65426 (h0 : group (normed_comm_ring (has_add linarith.comp))) : group.fg (normed_comm_ring (has_add linarith.comp)) := sorry --non-trivial
lemma new_lemma_65427 (h0 : topological_space (has_add (option (option (option ennreal))))) : irreducible_space (has_add (option (option (option ennreal)))) := sorry --non-trivial
lemma new_lemma_65428 (h0 : topological_space (ordered_comm_group (option (option empty)))) : totally_separated_space (ordered_comm_group (option (option empty))) := sorry --non-trivial
lemma new_lemma_65429 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @regular_space.{0} (has_bot.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_bot.{0} name))  := sorry --non-trivial
lemma new_lemma_65430 (h1 : complete_lattice (with_one to_additive.value_type)) : is_compactly_generated (with_one to_additive.value_type) := sorry --non-trivial
lemma new_lemma_65431 (h0 : functor.add_const (topological_space (add_comm_monoid linarith.comp)) Type) : @normal_space.{0} (add_comm_monoid.{0} linarith.comp) (@functor.add_const.run.{0 1} (topological_space.{0} (add_comm_monoid.{0} linarith.comp)) Type h0)  := sorry --non-trivial
lemma new_lemma_65432 (h0 : functor.add_const (functor.add_const (complete_lattice pos) Type) pos) : @complete_lattice.is_Sup_finite_compact.{0} pos (@functor.add_const.run.{0 1} (complete_lattice.{0} pos) Type (@functor.add_const.run.{0 0} (functor.add_const.{0 1} (complete_lattice.{0} pos) Type) pos h0))  := sorry --non-trivial
lemma new_lemma_65433 (h0 : functor.add_const (filter (semigroup unsigned)) name) : countable_Inter_filter (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_65434 (h0 : functor.add_const (topological_space (ring environment.implicit_infer_kind)) name) : @loc_path_connected_space.{0} (ring.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (ring.{0} environment.implicit_infer_kind)) name h0)  := sorry --non-trivial
lemma new_lemma_65435 (h0 : functor.add_const (function.extfun Type group) linarith.comp) : @group.fg.{0} (semigroup.{0} pos) (@function.extfun_app.{2 1} Type group.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type group.{0}) linarith.comp h0) (semigroup.{0} pos))  := sorry --non-trivial
lemma new_lemma_65436 (h1 : topological_space (add_comm_semigroup linarith.ineq)) : totally_disconnected_space (add_comm_semigroup linarith.ineq) := sorry --non-trivial
lemma new_lemma_65437 (h0 : ring (has_star congr_arg_kind)) : strong_rank_condition (has_star congr_arg_kind) := sorry --non-trivial
lemma new_lemma_65438 (h0 : not (ring (random_gen num) -> false)) : @strong_rank_condition.{0} (random_gen.{0} num) (@classical.by_contradiction'.{1} (ring.{0} (random_gen.{0} num)) h0)  := sorry --non-trivial
lemma new_lemma_65439 (h1 : topological_space (has_ssubset (has_nnnorm char))) : totally_disconnected_space (has_ssubset (has_nnnorm char)) := sorry --non-trivial
lemma new_lemma_65440 (h0 : functor.add_const (topological_space (has_nndist unsigned)) (option pos)) : @sequential_space.{0} (has_nndist.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (has_nndist.{0} unsigned)) (option.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_65441 (h0 : topological_space (linear_ordered_semiring linarith.comp_source)) : topological_space.separable_space (linear_ordered_semiring linarith.comp_source) := sorry --non-trivial
lemma new_lemma_65442 (h0 : topological_space (option (semiring (semiring empty)))) : totally_disconnected_space (option (semiring (semiring empty))) := sorry --non-trivial
lemma new_lemma_65443 (h0 : topological_space (semi_normed_comm_ring (has_inv (has_top to_additive.value_type)))) : t0_space (semi_normed_comm_ring (has_inv (has_top to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_65444 (h0 : topological_space (finset (finset pos))) : locally_compact_space (finset (finset pos)) := sorry --non-trivial
lemma new_lemma_65445 (h0 : topological_space (ordered_comm_ring (has_nndist name))) : topological_space.separable_space (ordered_comm_ring (has_nndist name)) := sorry --non-trivial
lemma new_lemma_65446 (h0 : functor.add_const (topological_space empty) unsigned) : t0_space empty := sorry --non-trivial
lemma new_lemma_65447 (h0 : functor.add_const (monoid (ordered_comm_ring linarith.comp)) name) : @monoid.fg.{0} (ordered_comm_ring.{0} linarith.comp) (@functor.add_const.run.{0 0} (monoid.{0} (ordered_comm_ring.{0} linarith.comp)) name h0)  := sorry --non-trivial
lemma new_lemma_65448 (h0 : semiring (with_one (semiring (semiring congr_arg_kind)))) : is_noetherian_ring (with_one (semiring (semiring congr_arg_kind))) := sorry --non-trivial
lemma new_lemma_65449 (h0 : ring (dlist linarith.comp_source)) : strong_rank_condition (dlist linarith.comp_source) := sorry --non-trivial
lemma new_lemma_65450 (h0 : ring (linear_ordered_comm_group_with_zero string_imp)) : is_domain (linear_ordered_comm_group_with_zero string_imp) := sorry --non-trivial
lemma new_lemma_65451 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @topological_space.separable_space.{0} (add_comm_monoid.{0} ennreal) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (add_comm_monoid.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_65452 (h0 : fin has_zero.zero) : @is_cyclic.{1} (sub_neg_monoid.{1} Type) (@matrix.vec_empty.{1} (group.{1} (sub_neg_monoid.{1} Type)) (@matrix.vec_empty.{0} (fin (@has_zero.zero.{0} nat nat.has_zero)) h0))  := sorry --non-trivial
lemma new_lemma_65453 (h1 : ring (linear_ordered_add_comm_group (has_add to_additive.value_type))) : rank_condition (linear_ordered_add_comm_group (has_add to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_65454 (h0 : complete_lattice (ring num)) : complete_lattice.is_Sup_finite_compact (ring num) := sorry --non-trivial
lemma new_lemma_65455 (h0 : topological_space (finset (option (option ennreal)))) : path_connected_space (finset (option (option ennreal))) := sorry --non-trivial
lemma new_lemma_65456 (h0 : function.extfun Type add_monoid) : @add_monoid.fg.{0} (left_cancel_monoid.{0} empty) (@function.extfun_app.{2 1} Type add_monoid.{0} h0 (left_cancel_monoid.{0} empty))  := sorry --non-trivial
lemma new_lemma_65457 (h0 : function.extfun Type complete_lattice) : @complete_lattice.is_Sup_finite_compact.{0} (has_inv.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (has_inv.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_65458 (h0 : uniform_space (has_add (has_nndist pos))) : separated_space (has_add (has_nndist pos)) := sorry --non-trivial
lemma new_lemma_65459 (h0 : complete_lattice (add_comm_semigroup (mul_one_class string.iterator_imp))) : complete_lattice.is_Sup_finite_compact (add_comm_semigroup (mul_one_class string.iterator_imp)) := sorry --non-trivial
lemma new_lemma_65460 (h1 : set (simple_graph linarith.comp_source)) : set.finite h1 := sorry --non-trivial
lemma new_lemma_65461 (h0 : topological_space string_imp) : irreducible_space string_imp := sorry --non-trivial
lemma new_lemma_65462 (h0 : topological_space (random_gen (random_gen (has_top (has_inv (random_gen to_additive.value_type)))))) : irreducible_space (random_gen (random_gen (has_top (has_inv (random_gen to_additive.value_type))))) := sorry --non-trivial
lemma new_lemma_65463 (h0 : not (function.extfun (Type -> Type) (function.extfun Type) -> false)) : @normalizer_condition.{0} string_imp (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) (@classical.by_contradiction'.{2} (function.extfun.{2 2} (Type → Type) (function.extfun.{2 1} Type)) h0) group.{0}) string_imp)  := sorry --non-trivial
lemma new_lemma_65464 (h0 : prod (add_comm_monoid Type) (add_comm_monoid Type)) : id_rel h0 := sorry --non-trivial
lemma new_lemma_65465 (h0 : functor.add_const (topological_space (add_cancel_monoid unsigned)) linarith.comp) : @preirreducible_space.{0} (add_cancel_monoid.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (add_cancel_monoid.{0} unsigned)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_65466 (h0 : topological_space (has_emptyc (has_top (has_inv linarith.ineq)))) : irreducible_space (has_emptyc (has_top (has_inv linarith.ineq))) := sorry --non-trivial
lemma new_lemma_65467 (h0 : topological_space (measurable_space.dynkin_system (semiring (semiring congr_arg_kind)))) : totally_disconnected_space (measurable_space.dynkin_system (semiring (semiring congr_arg_kind))) := sorry --non-trivial
lemma new_lemma_65468 (h0 : not (add_group (linear_ordered_add_comm_group linarith.ineq) -> false)) : @is_add_cyclic.{0} (linear_ordered_add_comm_group.{0} linarith.ineq) (@classical.by_contradiction'.{1} (add_group.{0} (linear_ordered_add_comm_group.{0} linarith.ineq)) h0)  := sorry --non-trivial
lemma new_lemma_65469 (h0 : function.extfun Type ring) : @is_domain.{0} (has_neg.{0} pos) (@function.extfun_app.{2 1} Type ring.{0} h0 (has_neg.{0} pos))  := sorry --non-trivial
lemma new_lemma_65470 (h0 : semiring (ordered_comm_monoid (sub_neg_monoid real))) : is_noetherian_ring (ordered_comm_monoid (sub_neg_monoid real)) := sorry --non-trivial
lemma new_lemma_65471 (h0 : group (has_nndist (has_neg_part Type))) : normalizer_condition (has_nndist (has_neg_part Type)) := sorry --non-trivial
lemma new_lemma_65472 (h0 : function.extfun Type (functor.add_const (add_group (semigroup num)))) : @is_add_cyclic.{0} (semigroup.{0} num) (@functor.add_const.run.{0 0} (add_group.{0} (semigroup.{0} num)) empty (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (add_group.{0} (semigroup.{0} num))) h0 empty))  := sorry --non-trivial
lemma new_lemma_65473 (h1 : has_lt to_additive.value_type) : no_max_order to_additive.value_type := sorry --non-trivial
lemma new_lemma_65474 (h0 : filter (has_neg (has_neg name))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_65475 (h0 : uniform_space (has_emptyc (has_top linarith.comp_source))) : complete_space (has_emptyc (has_top linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_65476 (h0 : functor.add_const (topological_space (add_cancel_monoid linarith.comp)) Type) : @regular_space.{0} (add_cancel_monoid.{0} linarith.comp) (@functor.add_const.run.{0 1} (topological_space.{0} (add_cancel_monoid.{0} linarith.comp)) Type h0)  := sorry --non-trivial
lemma new_lemma_65477 (h0 : function.extfun Type complete_lattice) : @is_compactly_generated.{0} (option.{0} pos) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (option.{0} pos))  := sorry --non-trivial
lemma new_lemma_65478 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @monoid.fg.{0} (ring.{0} pos) (@function.extfun_app.{2 1} Type monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 monoid.{0}) (ring.{0} pos))  := sorry --non-trivial
lemma new_lemma_65479 (h0 : topological_space (measurable_space.dynkin_system empty)) : t1_space (measurable_space.dynkin_system empty) := sorry --non-trivial
lemma new_lemma_65480 (h0 : add_monoid (has_union linarith.comp)) : add_monoid.fg (has_union linarith.comp) := sorry --non-trivial
lemma new_lemma_65481 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @path_connected_space.{0} (has_dist.{0} (option.{0} empty)) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_dist.{0} (option.{0} empty)))  := sorry --non-trivial
lemma new_lemma_65482 (h0 : functor.add_const (function.extfun Type group) (has_pos_part (has_Inf Type))) : @is_simple_group.{0} (normed_comm_ring.{0} pos) (@function.extfun_app.{2 1} Type group.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type group.{0}) (has_pos_part.{1} (has_Inf.{1} Type)) h0) (normed_comm_ring.{0} pos))  := sorry --non-trivial
lemma new_lemma_65483 (h1 h2 : multiset (uniform_space linarith.comp_source)) : multiset.disjoint h1 h2 := sorry --non-trivial
lemma new_lemma_65484 (h0 : uniform_space (with_one (has_inv linarith.comp_source))) : complete_space (with_one (has_inv linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_65485 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @t1_space.{0} (comm_semigroup.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (comm_semigroup.{0} name))  := sorry --non-trivial
lemma new_lemma_65486 (h0 : topological_space (comm_semigroup (ordered_comm_monoid linarith.comp))) : regular_space (comm_semigroup (ordered_comm_monoid linarith.comp)) := sorry --non-trivial
lemma new_lemma_65487 (h0 : finset (has_pos_part (has_Inf Type))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_65488 (h0 : add_group (semi_normed_ring (mul_one_class fun_info))) : is_add_cyclic (semi_normed_ring (mul_one_class fun_info)) := sorry --non-trivial
lemma new_lemma_65489 (h0 : functor.add_const (topological_space (add_comm_monoid Type)) Type) : @t0_space.{1} (add_comm_monoid.{1} Type) (@functor.add_const.run.{1 1} (topological_space.{1} (add_comm_monoid.{1} Type)) Type h0)  := sorry --non-trivial
lemma new_lemma_65490 (h1 : preorder (linear_ordered_add_comm_group string_imp)) (h2 : topological_space (linear_ordered_add_comm_group string_imp)) : Sup_convergence_class (linear_ordered_add_comm_group string_imp) := sorry --non-trivial
lemma new_lemma_65491 (h0 : uniform_space (has_neg empty)) : separated_space (has_neg empty) := sorry --non-trivial
lemma new_lemma_65492 (h0 : group (fintype (has_nnnorm char))) : is_cyclic (fintype (has_nnnorm char)) := sorry --non-trivial
lemma new_lemma_65493 (h0 h2 : multiset linarith.ineq) : multiset.le h0 h2 := sorry --non-trivial
lemma new_lemma_65494 (h0 : function.extfun (finset Type) (has_mem.mem (semiring linarith.comp_source))) : @discrete_topology.{0} (semiring.{0} linarith.comp_source) (@finset.pi.empty.{1 0} Type topological_space.{0} (semiring.{0} linarith.comp_source) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (semiring.{0} linarith.comp_source)) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_65495 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : list.nodup (function.extfun_app (function.extfun_app h0 list) (distrib_lattice string_imp)) := sorry --non-trivial
lemma new_lemma_65496 (h0 : functor.add_const (ring (generalized_boolean_algebra pos)) (has_neg pos)) : @strong_rank_condition.{0} (generalized_boolean_algebra.{0} pos) (@functor.add_const.run.{0 0} (ring.{0} (generalized_boolean_algebra.{0} pos)) (has_neg.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_65497 (h1 : topological_space (simple_graph environment.projection_info)) : path_connected_space (simple_graph environment.projection_info) := sorry --non-trivial
lemma new_lemma_65498 (h0 : add_monoid (measure_theory.measure_space (semiring (semiring (semiring empty))))) : add_monoid.fg (measure_theory.measure_space (semiring (semiring (semiring empty)))) := sorry --non-trivial
lemma new_lemma_65499 (h0 : ring (metric_space linarith.comp_source)) : rank_condition (metric_space linarith.comp_source) := sorry --non-trivial
lemma new_lemma_65500 (h0 : topological_space (has_add (sub_neg_monoid (has_Inf (boolean_algebra (has_Inf pos)))))) : regular_space (has_add (sub_neg_monoid (has_Inf (boolean_algebra (has_Inf pos))))) := sorry --non-trivial
lemma new_lemma_65501 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_noetherian_ring.{0} (ring.{0} linarith.comp) (@function.extfun_app.{2 1} Type semiring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 semiring.{0}) (ring.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_65502 (h0 : functor.add_const (list (cancel_monoid environment.implicit_infer_kind)) name) : palindrome (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_65503 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_atomistic.{0} (add_group.{0} num) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (add_group.{0} num))  := sorry --non-trivial
lemma new_lemma_65504 (h0 : not (topological_space (with_bot fun_info) -> false)) : @t0_space.{0} (with_bot.{0} fun_info) (@classical.by_contradiction'.{1} (topological_space.{0} (with_bot.{0} fun_info)) h0)  := sorry --non-trivial
lemma new_lemma_65505 (h0 : ring (add_left_cancel_semigroup unsigned)) : is_domain (add_left_cancel_semigroup unsigned) := sorry --non-trivial
lemma new_lemma_65506 (h0 : list (dlist (random_gen (has_nnnorm fun_info)))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_65507 (h0 : functor.add_const (ring (finset pos)) ennreal) : @strong_rank_condition.{0} (finset.{0} pos) (@functor.add_const.run.{0 0} (ring.{0} (finset.{0} pos)) ennreal h0)  := sorry --non-trivial
lemma new_lemma_65508 (h0 : topological_space (has_repr num)) : irreducible_space (has_repr num) := sorry --non-trivial
lemma new_lemma_65509 (h1 : set (non_unital_non_assoc_semiring reducibility_hints)) : set.finite h1 := sorry --non-trivial
lemma new_lemma_65510 (h0 : filter (has_emptyc num)) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_65511 (h0 : topological_space (lex num)) : t1_space (lex num) := sorry --non-trivial
lemma new_lemma_65512 (h0 : topological_space (boolean_algebra (has_Inf (boolean_algebra (has_Inf linarith.comp))))) : loc_path_connected_space (boolean_algebra (has_Inf (boolean_algebra (has_Inf linarith.comp)))) := sorry --non-trivial
lemma new_lemma_65513 (h0 : functor.add_const (topological_space (preorder num)) empty) : @normal_space.{0} (preorder.{0} num) (@functor.add_const.run.{0 0} (topological_space.{0} (preorder.{0} num)) empty h0)  := sorry --non-trivial
lemma new_lemma_65514 (h0 : function.extfun Type complete_lattice) : @complete_lattice.is_Sup_finite_compact.{0} (left_cancel_monoid.{0} (semiring.{0} empty)) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (left_cancel_monoid.{0} (semiring.{0} empty)))  := sorry --non-trivial
lemma new_lemma_65515 (h0 : group (monoid_with_zero (option pos))) : is_simple_group (monoid_with_zero (option pos)) := sorry --non-trivial
lemma new_lemma_65516 (h0 : uniform_space (pseudo_metric_space empty)) : complete_space (pseudo_metric_space empty) := sorry --non-trivial
lemma new_lemma_65517 (h0 : filter (has_nndist (finset linarith.comp))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_65518 (h0 : topological_space (has_norm (semiring unsigned))) : t0_space (has_norm (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_65519 (h0 : ring (has_add unsigned)) : rank_condition (has_add unsigned) := sorry --non-trivial
lemma new_lemma_65520 (h0 : functor.add_const (filter (has_neg_part pos)) pos) : countable_Inter_filter (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_65521 (h0 : function.extfun Type monoid) : @monoid.fg.{0} (has_neg.{0} unsigned) (@function.extfun_app.{2 1} Type monoid.{0} h0 (has_neg.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_65522 (h0 : topological_space (has_bot (sub_neg_monoid (has_bot real)))) : preconnected_space (has_bot (sub_neg_monoid (has_bot real))) := sorry --non-trivial
lemma new_lemma_65523 (h0 : not (filter (distrib_lattice linarith.ineq) -> false)) : filter.ne_bot (classical.by_contradiction' h0) := sorry --non-trivial
lemma new_lemma_65524 (h0 : not (function.extfun Type monoid -> false)) : @monoid.fg.{0} (has_sub.{0} unsigned) (@function.extfun_app.{2 1} Type monoid.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type monoid.{0}) h0) (has_sub.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_65525 (h0 : topological_space (ring (finset pos))) : loc_path_connected_space (ring (finset pos)) := sorry --non-trivial
lemma new_lemma_65526 (h0 : functor.add_const (function.extfun Type add_group) pos) : @is_add_cyclic.{0} (complete_distrib_lattice.{0} linarith.comp) (@function.extfun_app.{2 1} Type add_group.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type add_group.{0}) pos h0) (complete_distrib_lattice.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_65527 (h0 : group (ring (ring (has_neg Type)))) : group.fg (ring (ring (has_neg Type))) := sorry --non-trivial
lemma new_lemma_65528 (h0 : functor.add_const (filter (has_add pos)) Type) : filter.ne_bot (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_65529 (h0 : finset (has_neg (has_Inf name))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_65530 (h0 : functor.add_const (function.extfun Type topological_space) linarith.comp) : @preirreducible_space.{0} (complete_distrib_lattice.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) linarith.comp h0) (complete_distrib_lattice.{0} pos))  := sorry --non-trivial
lemma new_lemma_65531 (h0 : functor.add_const (cancel_comm_monoid_with_zero (normed_comm_ring Type)) (ring linarith.comp)) : @unique_factorization_monoid.{1} (normed_comm_ring.{1} Type) (@functor.add_const.run.{1 0} (cancel_comm_monoid_with_zero.{1} (normed_comm_ring.{1} Type)) (ring.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_65532 (h0 : functor.add_const (ordered_comm_monoid (has_pos_part linarith.comp)) pos) : @has_exists_mul_of_le.{0} (has_pos_part.{0} linarith.comp) (@functor.add_const.run.{0 0} (ordered_comm_monoid.{0} (has_pos_part.{0} linarith.comp)) pos h0)  := sorry --non-trivial
lemma new_lemma_65533 (h0 : functor.add_const (topological_space (has_neg unsigned)) unsigned) : @loc_path_connected_space.{0} (has_neg.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (has_neg.{0} unsigned)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_65534 (h0 : group (canonically_linear_ordered_monoid congr_arg_kind)) : is_cyclic (canonically_linear_ordered_monoid congr_arg_kind) := sorry --non-trivial
lemma new_lemma_65535 (h0 : functor.add_const (ring (has_Inf real)) real) : @rank_condition.{0} (has_Inf.{0} real) (@functor.add_const.run.{0 0} (ring.{0} (has_Inf.{0} real)) real h0)  := sorry --non-trivial
lemma new_lemma_65536 (h0 : complete_lattice (normed_field (random_gen linarith.comp_source))) : complete_lattice.is_Sup_finite_compact (normed_field (random_gen linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_65537 (h0 : monoid (preorder (ordered_cancel_comm_monoid empty))) : monoid.fg (preorder (ordered_cancel_comm_monoid empty)) := sorry --non-trivial
lemma new_lemma_65538 (h0 : ring (has_nnnorm (random_gen string_imp))) : rank_condition (has_nnnorm (random_gen string_imp)) := sorry --non-trivial
lemma new_lemma_65539 (h0 : filter (has_to_string (has_to_string unsigned))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_65540 (h0 : complete_lattice (has_add (normed_group (normed_group string_imp)))) : complete_lattice.is_Sup_finite_compact (has_add (normed_group (normed_group string_imp))) := sorry --non-trivial
lemma new_lemma_65541 (h0 : functor.add_const (topological_space (generalized_boolean_algebra Type)) Type) : @discrete_topology.{1} (generalized_boolean_algebra.{1} Type) (@functor.add_const.run.{1 1} (topological_space.{1} (generalized_boolean_algebra.{1} Type)) Type h0)  := sorry --non-trivial
lemma new_lemma_65542 (h0 : add_group (has_inv linarith.comp_source)) : is_add_cyclic (has_inv linarith.comp_source) := sorry --non-trivial
lemma new_lemma_65543 (h0 : topological_space (linear_order congr_arg_kind)) : normal_space (linear_order congr_arg_kind) := sorry --non-trivial
lemma new_lemma_65544 (h0 : add_group (semi_normed_comm_ring (has_ssubset char))) : is_add_cyclic (semi_normed_comm_ring (has_ssubset char)) := sorry --non-trivial
lemma new_lemma_65545 (h0 : group (has_emptyc (has_inv fun_info))) : normalizer_condition (has_emptyc (has_inv fun_info)) := sorry --non-trivial
lemma new_lemma_65546 (h0 : list (has_norm (comm_ring (has_inv fun_info)))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_65547 (h0 : functor.add_const (topological_space (complete_distrib_lattice unsigned)) name) : @totally_separated_space.{0} (complete_distrib_lattice.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (complete_distrib_lattice.{0} unsigned)) name h0)  := sorry --non-trivial
lemma new_lemma_65548 (h2 : add_group (has_norm linarith.comp)) : is_add_cyclic (has_norm linarith.comp) := sorry --non-trivial
lemma new_lemma_65549 (h2 : complete_lattice (mul_one_class linarith.ineq)) : complete_lattice.is_Sup_finite_compact (mul_one_class linarith.ineq) := sorry --non-trivial
lemma new_lemma_65550 (h0 : topological_space (add_left_cancel_semigroup (option empty))) : t1_space (add_left_cancel_semigroup (option empty)) := sorry --non-trivial
lemma new_lemma_65551 (h0 : ordered_add_comm_monoid (simple_graph (option unsigned))) : archimedean (simple_graph (option unsigned)) := sorry --non-trivial
lemma new_lemma_65552 (h0 : ring (add_comm_semigroup (add_comm_semigroup string.iterator_imp))) : rank_condition (add_comm_semigroup (add_comm_semigroup string.iterator_imp)) := sorry --non-trivial
lemma new_lemma_65553 (h0 : fin has_zero.zero) : @complete_lattice.is_Sup_finite_compact.{0} (boolean_algebra.{0} pos) (@matrix.vec_empty.{0} (complete_lattice.{0} (boolean_algebra.{0} pos)) h0)  := sorry --non-trivial
lemma new_lemma_65554 (h0 : ordered_add_comm_monoid (has_neg (finset (has_nndist linarith.comp)))) : archimedean (has_neg (finset (has_nndist linarith.comp))) := sorry --non-trivial
lemma new_lemma_65555 (h0 : functor.add_const (topological_space (has_neg pos)) environment.implicit_infer_kind) : @t1_space.{0} (has_neg.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (has_neg.{0} pos)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_65556 (h0 : function.extfun Type complete_lattice) : @is_compactly_generated.{0} (group_with_zero.{0} ennreal) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (group_with_zero.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_65557 (h0 : measurable_space occurrences) (h1 : has_sub occurrences) : has_measurable_sub₂ occurrences := sorry --non-trivial
lemma new_lemma_65558 (h0 : filter Prop) : @Lim.{0} Prop sierpinski_space (@nonempty_of_inhabited.{1} Prop sort.inhabited.{0}) h0  := sorry --non-trivial
lemma new_lemma_65559 (h0 : finset (boolean_algebra.core (option pos))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_65560 (h0 : functor.add_const (add_monoid (cancel_monoid pos)) linarith.comp) : @add_monoid.fg.{0} (cancel_monoid.{0} pos) (@functor.add_const.run.{0 0} (add_monoid.{0} (cancel_monoid.{0} pos)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_65561 (h0 : function.extfun Type complete_lattice) : @complete_lattice.is_Sup_finite_compact.{0} (with_bot.{0} empty) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (with_bot.{0} empty))  := sorry --non-trivial
lemma new_lemma_65562 (h0 : uniform_space (option (option unsigned))) : separated_space (option (option unsigned)) := sorry --non-trivial
lemma new_lemma_65563 (h1 : topological_space (measurable_space (has_top (has_top to_additive.value_type)))) : path_connected_space (measurable_space (has_top (has_top to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_65564 (h0 : functor.add_const (finset (comm_group pos)) environment.implicit_infer_kind) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_65565 (h0 : prod (has_nndist (cancel_monoid name)) (has_nndist (cancel_monoid name))) : id_rel h0 := sorry --non-trivial
lemma new_lemma_65566 (h0 : monoid (add_comm_semigroup char)) (h2 : submonoid (add_comm_semigroup char)) : submonoid.fg h2 := sorry --non-trivial
lemma new_lemma_65567 (h0 : ring (comm_ring (has_lt string.iterator_imp))) : strong_rank_condition (comm_ring (has_lt string.iterator_imp)) := sorry --non-trivial
lemma new_lemma_65568 (h0 : complete_lattice (comm_semigroup (comm_semigroup (has_add Type)))) : is_atomistic (comm_semigroup (comm_semigroup (has_add Type))) := sorry --non-trivial
lemma new_lemma_65569 (h1 : filter (ordered_cancel_comm_monoid linarith.comp_source)) : filter.ne_bot h1 := sorry --non-trivial
lemma new_lemma_65570 (h0 : functor.add_const (function.extfun Type topological_space) linarith.comp) : @irreducible_space.{0} (has_nndist.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) linarith.comp h0) (has_nndist.{0} pos))  := sorry --non-trivial
lemma new_lemma_65571 (h0 : topological_space (cancel_monoid (comm_group (comm_group environment.implicit_infer_kind)))) : t0_space (cancel_monoid (comm_group (comm_group environment.implicit_infer_kind))) := sorry --non-trivial
lemma new_lemma_65572 (h0 : has_lt (linear_ordered_comm_group_with_zero linarith.ineq)) : no_max_order (linear_ordered_comm_group_with_zero linarith.ineq) := sorry --non-trivial
lemma new_lemma_65573 (h0 : not (ring (semi_normed_comm_ring char) -> false)) : @is_domain.{0} (semi_normed_comm_ring.{0} char) (@classical.by_contradiction'.{1} (ring.{0} (semi_normed_comm_ring.{0} char)) h0)  := sorry --non-trivial
lemma new_lemma_65574 (h0 : group (encodable (random_gen (random_gen linarith.ineq)))) : is_cyclic (encodable (random_gen (random_gen linarith.ineq))) := sorry --non-trivial
lemma new_lemma_65575 (h0 : monoid (has_add name)) : monoid.fg (has_add name) := sorry --non-trivial
lemma new_lemma_65576 (h0 : function.extfun Type ring) : @is_domain.{0} (with_bot.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type ring.{0} h0 (with_bot.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_65577 (h0 : functor.add_const (function.extfun Type monoid) (finset (mul_one_class pos))) : @monoid.fg.{0} (semigroup.{0} linarith.comp) (@function.extfun_app.{2 1} Type monoid.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type monoid.{0}) (finset.{0} (mul_one_class.{0} pos)) h0) (semigroup.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_65578 (h1 : not (uniform_space (semi_normed_ring string_imp) -> false)) : @complete_space.{0} (semi_normed_ring.{0} string_imp) (@classical.by_contradiction'.{1} (uniform_space.{0} (semi_normed_ring.{0} string_imp)) h1)  := sorry --non-trivial
lemma new_lemma_65579 (h0 : function.extfun Type ring) : @strong_rank_condition.{0} (linear_ordered_field.{0} empty) (@function.extfun_app.{2 1} Type ring.{0} h0 (linear_ordered_field.{0} empty))  := sorry --non-trivial
lemma new_lemma_65580 (h0 : measurable_space (has_add name)) (h1 : has_add (has_add name)) : has_measurable_add (has_add name) := sorry --non-trivial
lemma new_lemma_65581 (h0 : not (ring (semiring (semiring unsigned)) -> false)) : @is_domain.{0} (semiring.{0} (semiring.{0} unsigned)) (@classical.by_contradiction'.{1} (ring.{0} (semiring.{0} (semiring.{0} unsigned))) h0)  := sorry --non-trivial
lemma new_lemma_65582 (h0 : functor.add_const (finset (ordered_comm_ring pos)) pos) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_65583 (h0 : function.extfun Type cancel_comm_monoid_with_zero) : @unique_factorization_monoid.{0} (has_union.{0} empty) (@function.extfun_app.{2 1} Type cancel_comm_monoid_with_zero.{0} h0 (has_union.{0} empty))  := sorry --non-trivial
lemma new_lemma_65584 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @totally_separated_space.{0} (has_dist.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_dist.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_65585 (h0 : topological_space (add_comm_monoid (has_neg_part pos))) : t0_space (add_comm_monoid (has_neg_part pos)) := sorry --non-trivial
lemma new_lemma_65586 (h0 : uniform_space (has_compl fun_info)) : complete_space (has_compl fun_info) := sorry --non-trivial
lemma new_lemma_65587 (h0 : functor.add_const (ring (linear_order empty)) empty) : @strong_rank_condition.{0} (linear_order.{0} empty) (@functor.add_const.run.{0 0} (ring.{0} (linear_order.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_65588 (h0 : not (topological_space (has_nnnorm linarith.ineq) -> false)) : @totally_disconnected_space.{0} (has_nnnorm.{0} linarith.ineq) (@classical.by_contradiction'.{1} (topological_space.{0} (has_nnnorm.{0} linarith.ineq)) h0)  := sorry --non-trivial
lemma new_lemma_65589 (h0 : functor.add_const (topological_space (has_nndist Type)) name) : @t0_space.{1} (has_nndist.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (has_nndist.{1} Type)) name h0)  := sorry --non-trivial
lemma new_lemma_65590 (h0 : functor.add_const (group (plift num)) (semiring (semiring empty))) : @normalizer_condition.{1} (plift.{1} num) (@functor.add_const.run.{1 0} (group.{1} (plift.{1} num)) (semiring.{0} (semiring.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_65591 (h0 : function.extfun Type ring) : @is_principal_ideal_ring.{0} (left_cancel_semigroup.{0} unsigned) (@function.extfun_app.{2 1} Type ring.{0} h0 (left_cancel_semigroup.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_65592 (h0 : topological_space (has_bot (option (option empty)))) : loc_path_connected_space (has_bot (option (option empty))) := sorry --non-trivial
lemma new_lemma_65593 (h0 : not (topological_space (id linarith.comp) -> false)) : @preirreducible_space.{0} (@id.{2} Type linarith.comp) (@classical.by_contradiction'.{1} (topological_space.{0} (@id.{2} Type linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_65594 (h0 : functor.add_const (topological_space (bin_tree unsigned)) unsigned) : @topological_space.separable_space.{0} (bin_tree.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (bin_tree.{0} unsigned)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_65595 (h0 : group (is_R_or_C empty)) : normalizer_condition (is_R_or_C empty) := sorry --non-trivial
lemma new_lemma_65596 (h0 : monoid (has_neg_part (has_add pos))) : monoid.fg (has_neg_part (has_add pos)) := sorry --non-trivial
lemma new_lemma_65597 (h0 : topological_space (has_top (with_bot (random_gen string_imp)))) : totally_disconnected_space (has_top (with_bot (random_gen string_imp))) := sorry --non-trivial
lemma new_lemma_65598 (h1 : function.extfun Type complete_lattice) : @is_compactly_generated.{0} (has_top.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type complete_lattice.{0} h1 (has_top.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_65599 (h1 : ring (semi_normed_ring string_imp)) : strong_rank_condition (semi_normed_ring string_imp) := sorry --non-trivial
lemma new_lemma_65600 (h0 : complete_lattice (distrib_lattice (has_inv (has_inv fun_info)))) : is_atomistic (distrib_lattice (has_inv (has_inv fun_info))) := sorry --non-trivial
lemma new_lemma_65601 (h0 : topological_space (semigroup (has_add (comm_group Type)))) : path_connected_space (semigroup (has_add (comm_group Type))) := sorry --non-trivial
lemma new_lemma_65602 (h0 : functor.add_const (function.extfun Type topological_space) name) : @t1_space.{0} (has_to_string.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) name h0) (has_to_string.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_65603 (h0 : topological_space (has_to_string (has_add (finset pos)))) : preirreducible_space (has_to_string (has_add (finset pos))) := sorry --non-trivial
lemma new_lemma_65604 (h0 : functor.add_const (complete_lattice (canonically_linear_ordered_monoid name)) ennreal) : @is_compactly_generated.{0} (canonically_linear_ordered_monoid.{0} name) (@functor.add_const.run.{0 0} (complete_lattice.{0} (canonically_linear_ordered_monoid.{0} name)) ennreal h0)  := sorry --non-trivial
lemma new_lemma_65605 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @normal_space.{0} (has_union.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_union.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_65606 (h0 : list (has_norm (has_top (has_top (has_top num))))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_65607 (h0 : functor.add_const (ordered_add_comm_monoid (has_zero Type)) (ring Type)) : @archimedean.{1} (has_zero.{1} Type) (@functor.add_const.run.{1 1} (ordered_add_comm_monoid.{1} (has_zero.{1} Type)) (ring.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_65608 (h0 : topological_space (has_neg linarith.comp)) : t0_space (has_neg linarith.comp) := sorry --non-trivial
lemma new_lemma_65609 (h0 : functor.add_const (ordered_add_comm_monoid (has_pos_part name)) pos) : @archimedean.{0} (has_pos_part.{0} name) (@functor.add_const.run.{0 0} (ordered_add_comm_monoid.{0} (has_pos_part.{0} name)) pos h0)  := sorry --non-trivial
lemma new_lemma_65610 (h0 : not (ring Type -> false)) : @is_domain.{1} Type (@classical.by_contradiction'.{2} (ring.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_65611 (h0 : function.extfun Type (functor.comp topological_space mul_zero_class)) : @preconnected_space.{0} (mul_zero_class.{0} name) (@functor.comp.run.{0 0 0} topological_space.{0} mul_zero_class.{0} name (@function.extfun_app.{2 1} Type (functor.comp.{0 0 0} topological_space.{0} mul_zero_class.{0}) h0 name))  := sorry --non-trivial
lemma new_lemma_65612 (h0 : function.extfun Type topological_space) : @discrete_topology.{0} (has_to_string.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_to_string.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_65613 (h0 : functor.add_const (monoid (has_neg environment.implicit_infer_kind)) name) : @monoid.fg.{0} (has_neg.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (monoid.{0} (has_neg.{0} environment.implicit_infer_kind)) name h0)  := sorry --non-trivial
lemma new_lemma_65614 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @complete_space.{0} (ring.{0} pos) (@function.extfun_app.{2 1} Type uniform_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 uniform_space.{0}) (ring.{0} pos))  := sorry --non-trivial
lemma new_lemma_65615 (h1 : ring (with_one num)) : rank_condition (with_one num) := sorry --non-trivial
lemma new_lemma_65616 (h0 : topological_space (linear_ordered_comm_group (option (option ennreal)))) : discrete_topology (linear_ordered_comm_group (option (option ennreal))) := sorry --non-trivial
lemma new_lemma_65617 (h0 : finset (semigroup (has_zero Type))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_65618 (h0 : topological_space (add_comm_monoid empty)) : irreducible_space (add_comm_monoid empty) := sorry --non-trivial
lemma new_lemma_65619 (h0 : ordered_add_comm_monoid (has_Sup (semiring (semiring (semiring empty))))) : archimedean (has_Sup (semiring (semiring (semiring empty)))) := sorry --non-trivial
lemma new_lemma_65620 (h0 : functor.add_const (filter (has_Inf pos)) (has_pos_part (finset pos))) : countable_Inter_filter (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_65621 (h0 : functor.add_const (monoid (semigroup Type)) Type) : @monoid.fg.{1} (semigroup.{1} Type) (@functor.add_const.run.{1 1} (monoid.{1} (semigroup.{1} Type)) Type h0)  := sorry --non-trivial
lemma new_lemma_65622 (h0 : not (add_group (semi_normed_comm_ring linarith.comp_source) -> false)) : @is_add_cyclic.{0} (semi_normed_comm_ring.{0} linarith.comp_source) (@classical.by_contradiction'.{1} (add_group.{0} (semi_normed_comm_ring.{0} linarith.comp_source)) h0)  := sorry --non-trivial
lemma new_lemma_65623 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @regular_space.{0} (boolean_algebra.core.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (boolean_algebra.core.{0} pos))  := sorry --non-trivial
lemma new_lemma_65624 (h0 : functor.add_const (topological_space (ordered_comm_ring pos)) pos) : @topological_space.separable_space.{0} (ordered_comm_ring.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (ordered_comm_ring.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_65625 (h0 : function.extfun Type filter) : countable_Inter_filter (function.extfun_app h0 (has_add name)) := sorry --non-trivial
lemma new_lemma_65626 (h0 : topological_space (non_assoc_semiring (semiring congr_arg_kind))) : normal_space (non_assoc_semiring (semiring congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_65627 (h0 : complete_lattice (dlist string_imp)) : complete_lattice.is_Sup_finite_compact (dlist string_imp) := sorry --non-trivial
lemma new_lemma_65628 (h1 : filter (linear_ordered_add_comm_group (random_gen fun_info))) : filter.ne_bot h1 := sorry --non-trivial
lemma new_lemma_65629 (h0 : functor.add_const (topological_space (filter unsigned)) empty) : @locally_compact_space.{0} (filter.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (filter.{0} unsigned)) empty h0)  := sorry --non-trivial
lemma new_lemma_65630 (h0 : topological_space (add_group (has_norm unsigned))) : irreducible_space (add_group (has_norm unsigned)) := sorry --non-trivial
lemma new_lemma_65631 (h0 : functor.add_const (complete_lattice (mul_zero_class pos)) (option (option pos))) : @complete_lattice.is_Sup_finite_compact.{0} (mul_zero_class.{0} pos) (@functor.add_const.run.{0 0} (complete_lattice.{0} (mul_zero_class.{0} pos)) (option.{0} (option.{0} pos)) h0)  := sorry --non-trivial
lemma new_lemma_65632 (h0 : topological_space (dlist fun_info)) : t0_space (dlist fun_info) := sorry --non-trivial
lemma new_lemma_65633 (h0 : function.extfun Type ordered_add_comm_monoid) : @archimedean.{0} (bin_tree.{0} empty) (@function.extfun_app.{2 1} Type ordered_add_comm_monoid.{0} h0 (bin_tree.{0} empty))  := sorry --non-trivial
lemma new_lemma_65634 (h0 : topological_space (simple_graph char)) : path_connected_space (simple_graph char) := sorry --non-trivial
lemma new_lemma_65635 (h0 : functor.add_const (topological_space (comm_group unsigned)) name) : @discrete_topology.{0} (comm_group.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (comm_group.{0} unsigned)) name h0)  := sorry --non-trivial
lemma new_lemma_65636 (h0 h1 : multiset (nondiscrete_normed_field (mul_one_class (nondiscrete_normed_field environment.projection_info)))) : multiset.disjoint h0 h1 := sorry --non-trivial
lemma new_lemma_65637 (h0 : function.extfun Type group) : @is_simple_group.{0} (option.{0} ennreal) (@function.extfun_app.{2 1} Type group.{0} h0 (option.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_65638 (h0 : list (with_bot (filter Prop))) (h1 : ne (id (list.head h0)) has_bot.bot) : @Lim.{0} Prop sierpinski_space (@nonempty_of_inhabited.{1} Prop sort.inhabited.{0}) (@with_bot.unbot.{0} (filter.{0} Prop) (@id.{1} (with_bot.{0} (filter.{0} Prop)) (@list.head.{0} (with_bot.{0} (filter.{0} Prop)) (@with_bot.inhabited.{0} (filter.{0} Prop)) h0)) h1)  := sorry --non-trivial
lemma new_lemma_65639 (h0 : topological_space (cancel_monoid (ring unsigned))) : sequential_space (cancel_monoid (ring unsigned)) := sorry --non-trivial
lemma new_lemma_65640 (h0 : functor.comp topological_space semigroup environment.implicit_infer_kind) : @irreducible_space.{0} (semigroup.{0} environment.implicit_infer_kind) (@functor.comp.run.{0 0 0} topological_space.{0} semigroup.{0} environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_65641 (h1 : ring (simple_graph linarith.ineq)) : rank_condition (simple_graph linarith.ineq) := sorry --non-trivial
lemma new_lemma_65642 (h0 : function.extfun Type filter) : filter.ne_bot (function.extfun_app h0 (group_with_zero unsigned)) := sorry --non-trivial
lemma new_lemma_65643 (h0 : topological_space (preorder (semiring (semiring (semiring unsigned))))) : normal_space (preorder (semiring (semiring (semiring unsigned)))) := sorry --non-trivial
lemma new_lemma_65644 (h0 : topological_space (ordered_comm_ring (has_Inf (has_add Type)))) : normal_space (ordered_comm_ring (has_Inf (has_add Type))) := sorry --non-trivial
lemma new_lemma_65645 (h0 : topological_space (has_neg_part (finset environment.implicit_infer_kind))) : normal_space (has_neg_part (finset environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_65646 (h1 : has_mem.mem (has_norm to_additive.value_type) has_emptyc.emptyc) : @totally_separated_space.{0} (has_norm.{0} to_additive.value_type) (@finset.pi.empty.{1 0} Type topological_space.{0} (has_norm.{0} to_additive.value_type) h1)  := sorry --non-trivial
lemma new_lemma_65647 (h0 : functor.add_const (filter (complete_distrib_lattice name)) Type) : filter.ne_bot (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_65648 (h1 : group (has_emptyc linarith.comp_source)) : normalizer_condition (has_emptyc linarith.comp_source) := sorry --non-trivial
lemma new_lemma_65649 (h0 : uniform_space (normed_group fun_info)) : separated_space (normed_group fun_info) := sorry --non-trivial
lemma new_lemma_65650 (h0 : uniform_space (has_Inf (has_add (has_to_string pos)))) : complete_space (has_Inf (has_add (has_to_string pos))) := sorry --non-trivial
lemma new_lemma_65651 (h0 : add_group (comm_ring (comm_ring char))) : is_add_cyclic (comm_ring (comm_ring char)) := sorry --non-trivial
lemma new_lemma_65652 (h0 : topological_space (has_emptyc (random_gen (has_norm linarith.ineq)))) : irreducible_space (has_emptyc (random_gen (has_norm linarith.ineq))) := sorry --non-trivial
lemma new_lemma_65653 (h0 : topological_space (has_norm fun_info)) : totally_disconnected_space (has_norm fun_info) := sorry --non-trivial
lemma new_lemma_65654 (h0 : function.extfun Type topological_space) : @topological_space.separable_space.{0} (has_zero.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_zero.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_65655 (h0 : group (plift (semiring (semiring (semiring unsigned))))) : normalizer_condition (plift (semiring (semiring (semiring unsigned)))) := sorry --non-trivial
lemma new_lemma_65656 (h0 : list (has_norm (set.set_semiring fun_info))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_65657 (h0 : function.extfun Type monoid) : @monoid.fg.{0} (semiring.{0} unsigned) (@function.extfun_app.{2 1} Type monoid.{0} h0 (semiring.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_65658 (h0 : topological_space (has_one (semiring (has_norm empty)))) : totally_separated_space (has_one (semiring (has_norm empty))) := sorry --non-trivial
lemma new_lemma_65659 (h0 : ring (linear_ordered_comm_monoid_with_zero num)) : is_principal_ideal_ring (linear_ordered_comm_monoid_with_zero num) := sorry --non-trivial
lemma new_lemma_65660 (h0 : uniform_space (uniform_space (id (mul_one_class (normed_field string_imp))))) : complete_space (uniform_space (id (mul_one_class (normed_field string_imp)))) := sorry --non-trivial
lemma new_lemma_65661 (h0 : topological_space (generalized_boolean_algebra (ring pos))) : t0_space (generalized_boolean_algebra (ring pos)) := sorry --non-trivial
lemma new_lemma_65662 (h0 : prod (omega_complete_partial_order num) (omega_complete_partial_order num)) : id_rel h0 := sorry --non-trivial
lemma new_lemma_65663 (h0 : functor.add_const (ring (has_pos_part pos)) linarith.comp) : @is_principal_ideal_ring.{0} (has_pos_part.{0} pos) (@functor.add_const.run.{0 0} (ring.{0} (has_pos_part.{0} pos)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_65664 (h0 : function.extfun (Type 1) group) : @is_cyclic.{1} (complete_distrib_lattice.{1} Type) (@function.extfun_app.{3 2} (Type 1) group.{1} h0 (complete_distrib_lattice.{1} Type))  := sorry --non-trivial
lemma new_lemma_65665 (h2 : has_coe fun_info Prop) (h3 : fun_info) : @coe_b.{1 1} fun_info Prop h2 h3  := sorry --non-trivial
lemma new_lemma_65666 (h2 : ring (topological_space linarith.comp_source)) : strong_rank_condition (topological_space linarith.comp_source) := sorry --non-trivial
lemma new_lemma_65667 (h0 : functor.add_const (ring (generalized_boolean_algebra Type)) pos) : @rank_condition.{1} (generalized_boolean_algebra.{1} Type) (@functor.add_const.run.{1 0} (ring.{1} (generalized_boolean_algebra.{1} Type)) pos h0)  := sorry --non-trivial
lemma new_lemma_65668 (h0 : not (function.extfun Type complete_lattice -> false)) : @is_atomistic.{0} (add_right_cancel_monoid.{0} unsigned) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type complete_lattice.{0}) h0) (add_right_cancel_monoid.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_65669 (h0 : ring (free_add_monoid (complete_linear_order (multiset std_gen)))) : is_domain (free_add_monoid (complete_linear_order (multiset std_gen))) := sorry --non-trivial
lemma new_lemma_65670 (h0 : ring (preorder unsigned)) : is_principal_ideal_ring (preorder unsigned) := sorry --non-trivial
lemma new_lemma_65671 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @strong_rank_condition.{1} (has_zero.{1} Type) (@function.extfun_app.{3 2} (Type 1) ring.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 ring.{1}) (has_zero.{1} Type))  := sorry --non-trivial
lemma new_lemma_65672 (h0 : topological_space (ordered_comm_monoid (simple_graph Type))) : totally_disconnected_space (ordered_comm_monoid (simple_graph Type)) := sorry --non-trivial
lemma new_lemma_65673 (h0 : function.extfun Type topological_space) : @loc_path_connected_space.{0} (ring.{0} ennreal) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (ring.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_65674 (h0 : function.extfun nat fin) : @group.fg.{1} (has_bot.{1} Type) (@matrix.vec_empty.{1} (group.{1} (has_bot.{1} Type)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_65675 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @rank_condition.{0} (random_gen.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (random_gen.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_65676 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @rank_condition.{0} (has_neg.{0} ennreal) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (has_neg.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_65677 (h0 : functor.add_const (topological_space (has_nndist linarith.comp)) (has_add Type)) : @totally_disconnected_space.{0} (has_nndist.{0} linarith.comp) (@functor.add_const.run.{0 1} (topological_space.{0} (has_nndist.{0} linarith.comp)) (has_add.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_65678 (h0 : group (pseudo_metric_space (option unsigned))) : is_cyclic (pseudo_metric_space (option unsigned)) := sorry --non-trivial
lemma new_lemma_65679 (h0 : filter (add_comm_monoid (option (option num)))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_65680 (h0 : topological_space (has_top (has_top (random_gen string_imp)))) : totally_disconnected_space (has_top (has_top (random_gen string_imp))) := sorry --non-trivial
lemma new_lemma_65681 (h0 : function.extfun Type topological_space) : @locally_compact_space.{0} (measurable_space.{0} string_imp) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (measurable_space.{0} string_imp))  := sorry --non-trivial
lemma new_lemma_65682 (h0 : ordered_comm_monoid (canonically_ordered_monoid (has_Inf Type))) : has_exists_mul_of_le (canonically_ordered_monoid (has_Inf Type)) := sorry --non-trivial
lemma new_lemma_65683 (h0 : functor.add_const (list (add_cancel_monoid Type)) environment.implicit_infer_kind) : list.nodup (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_65684 (h0 : add_group (mul_one_class linarith.ineq)) : is_add_cyclic (mul_one_class linarith.ineq) := sorry --non-trivial
lemma new_lemma_65685 (h2 : group (with_one linarith.ineq)) : is_cyclic (with_one linarith.ineq) := sorry --non-trivial
lemma new_lemma_65686 (h0 : not (ring linarith.comp_source -> false)) : @is_domain.{0} linarith.comp_source (@classical.by_contradiction'.{1} (ring.{0} linarith.comp_source) h0)  := sorry --non-trivial
lemma new_lemma_65687 (h0 : not (topological_space (measurable_space.dynkin_system unsigned) -> false)) : @topological_space.separable_space.{0} (measurable_space.dynkin_system.{0} unsigned) (@classical.by_contradiction'.{1} (topological_space.{0} (measurable_space.dynkin_system.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_65688 (h0 : uniform_space (generalized_boolean_algebra (has_neg (has_add (has_neg linarith.comp))))) : complete_space (generalized_boolean_algebra (has_neg (has_add (has_neg linarith.comp)))) := sorry --non-trivial
lemma new_lemma_65689 (h0 : complete_lattice (measurable_space (has_norm (semiring (has_top (has_norm linarith.ineq)))))) : is_compactly_generated (measurable_space (has_norm (semiring (has_top (has_norm linarith.ineq))))) := sorry --non-trivial
lemma new_lemma_65690 (h0 : function.extfun (finset Type) (has_mem.mem (normed_group fun_info))) : @is_domain.{0} (normed_group.{0} fun_info) (@finset.pi.empty.{1 0} Type ring.{0} (normed_group.{0} fun_info) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (normed_group.{0} fun_info)) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_65691 (h0 : complete_lattice (boolean_algebra.core unsigned)) : is_compactly_generated (boolean_algebra.core unsigned) := sorry --non-trivial
lemma new_lemma_65692 (h0 : set (fun_info -> environment.implicit_infer_kind)) : set.separates_points h0 := sorry --non-trivial
lemma new_lemma_65693 (h0 : topological_space (random_gen (has_top (has_top (has_top (has_top linarith.ineq)))))) : t0_space (random_gen (has_top (has_top (has_top (has_top linarith.ineq))))) := sorry --non-trivial
lemma new_lemma_65694 (h0 : function.extfun Type filter) : filter.ne_bot (function.extfun_app h0 (as_linear_order unsigned)) := sorry --non-trivial
lemma new_lemma_65695 (h0 : uniform_space (mul_zero_class name)) : complete_space (mul_zero_class name) := sorry --non-trivial
lemma new_lemma_65696 (h0 : functor.comp topological_space ring environment.implicit_infer_kind) : @normal_space.{0} (ring.{0} environment.implicit_infer_kind) (@functor.comp.run.{0 0 0} topological_space.{0} ring.{0} environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_65697 (h0 : uniform_space (canonically_ordered_monoid (sub_neg_monoid (sub_neg_monoid name)))) : separated_space (canonically_ordered_monoid (sub_neg_monoid (sub_neg_monoid name))) := sorry --non-trivial
lemma new_lemma_65698 (h0 : functor.add_const (topological_space (has_neg pos)) pos) : @topological_space.separable_space.{0} (has_neg.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (has_neg.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_65699 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @loc_path_connected_space.{0} (linear_ordered_field.{0} (option.{0} unsigned)) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (linear_ordered_field.{0} (option.{0} unsigned)))  := sorry --non-trivial
lemma new_lemma_65700 (h0 : topological_space (semigroup (order_dual (has_neg linarith.comp)))) : t0_space (semigroup (order_dual (has_neg linarith.comp))) := sorry --non-trivial
lemma new_lemma_65701 (h0 : complete_lattice (sub_neg_monoid real)) : complete_lattice.is_Sup_finite_compact (sub_neg_monoid real) := sorry --non-trivial
lemma new_lemma_65702 (h0 : topological_space (has_star (semiring (has_top empty)))) : path_connected_space (has_star (semiring (has_top empty))) := sorry --non-trivial
lemma new_lemma_65703 (h1 : group (with_bot linarith.comp_source)) : is_cyclic (with_bot linarith.comp_source) := sorry --non-trivial
lemma new_lemma_65704 (h0 : topological_space (boolean_algebra.core (ring Type))) : locally_compact_space (boolean_algebra.core (ring Type)) := sorry --non-trivial
lemma new_lemma_65705 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @regular_space.{0} pos (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) pos)  := sorry --non-trivial
lemma new_lemma_65706 (h0 : list (has_to_string (complete_distrib_lattice Type))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_65707 (h0 : cancel_comm_monoid_with_zero (boolean_algebra (finset linarith.comp))) : unique_factorization_monoid (boolean_algebra (finset linarith.comp)) := sorry --non-trivial
lemma new_lemma_65708 (h2 : group (normed_field (comm_ring char))) : is_cyclic (normed_field (comm_ring char)) := sorry --non-trivial
lemma new_lemma_65709 (h0 : not (group (distrib char) -> false)) : @is_cyclic.{0} (distrib.{0} char) (@classical.by_contradiction'.{1} (group.{0} (distrib.{0} char)) h0)  := sorry --non-trivial
lemma new_lemma_65710 (h0 : add_monoid (pseudo_metric_space pos)) : add_monoid.fg (pseudo_metric_space pos) := sorry --non-trivial
lemma new_lemma_65711 (h0 : functor.add_const (list (has_nndist name)) environment.implicit_infer_kind) : palindrome (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_65712 (h0 : list (add_left_cancel_semigroup num)) : palindrome h0 := sorry --non-trivial
lemma new_lemma_65713 (h0 : topological_space (has_div (mul_one_class linarith.comp_source))) : path_connected_space (has_div (mul_one_class linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_65714 (h0 : ordered_comm_monoid (add_comm_monoid (option pos))) : has_exists_mul_of_le (add_comm_monoid (option pos)) := sorry --non-trivial
lemma new_lemma_65715 (h0 : measurable_space (nondiscrete_normed_field environment.projection_info)) (h1 : measure_theory.measure (nondiscrete_normed_field environment.projection_info)) : measure_theory.is_finite_measure h1 := sorry --non-trivial
lemma new_lemma_65716 (h0 : uniform_space (linear_ordered_comm_group_with_zero (mul_one_class char))) : complete_space (linear_ordered_comm_group_with_zero (mul_one_class char)) := sorry --non-trivial
lemma new_lemma_65717 (h0 : not (topological_space (random_gen (has_top num)) -> false)) : @path_connected_space.{0} (random_gen.{0} (has_top.{0} num)) (@classical.by_contradiction'.{1} (topological_space.{0} (random_gen.{0} (has_top.{0} num))) h0)  := sorry --non-trivial
lemma new_lemma_65718 (h0 : ring (has_zero (has_neg_part (comm_group (has_neg_part pos))))) : rank_condition (has_zero (has_neg_part (comm_group (has_neg_part pos)))) := sorry --non-trivial
lemma new_lemma_65719 (h0 : group (has_neg (finset (finset linarith.comp)))) : group.fg (has_neg (finset (finset linarith.comp))) := sorry --non-trivial
lemma new_lemma_65720 (h0 : function.extfun Type semiring) : @is_noetherian_ring.{0} (ring.{0} pos) (@function.extfun_app.{2 1} Type semiring.{0} h0 (ring.{0} pos))  := sorry --non-trivial
lemma new_lemma_65721 (h0 : topological_space (mul_zero_class congr_arg_kind)) : locally_compact_space (mul_zero_class congr_arg_kind) := sorry --non-trivial
lemma new_lemma_65722 (h0 : functor.add_const (group (normed_comm_ring name)) linarith.comp) : @normalizer_condition.{0} (normed_comm_ring.{0} name) (@functor.add_const.run.{0 0} (group.{0} (normed_comm_ring.{0} name)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_65723 (h0 : function.extfun Type topological_space) : @irreducible_space.{0} (semigroup.{0} (has_add.{0} (comm_group.{0} (has_add.{0} (has_add.{0} (has_add.{0} pos)))))) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (semigroup.{0} (has_add.{0} (comm_group.{0} (has_add.{0} (has_add.{0} (has_add.{0} pos)))))))  := sorry --non-trivial
lemma new_lemma_65724 (h0 : function.extfun Type group) : @normalizer_condition.{0} (complete_semilattice_Sup.{0} linarith.ineq) (@function.extfun_app.{2 1} Type group.{0} h0 (complete_semilattice_Sup.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_65725 (h0 : functor.add_const (list (preorder unsigned)) empty) : list.nodup (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_65726 (h0 : not (ring (complete_linear_order num) -> false)) : @rank_condition.{0} (complete_linear_order.{0} num) (@classical.by_contradiction'.{1} (ring.{0} (complete_linear_order.{0} num)) h0)  := sorry --non-trivial
lemma new_lemma_65727 (h0 : functor.add_const (topological_space (add_comm_monoid pos)) Type) : @totally_disconnected_space.{0} (add_comm_monoid.{0} pos) (@functor.add_const.run.{0 1} (topological_space.{0} (add_comm_monoid.{0} pos)) Type h0)  := sorry --non-trivial
lemma new_lemma_65728 (h0 : topological_space (comm_group (comm_group unsigned))) : regular_space (comm_group (comm_group unsigned)) := sorry --non-trivial
lemma new_lemma_65729 (h1 : ring (has_add (with_one fun_info))) : is_domain (has_add (with_one fun_info)) := sorry --non-trivial
lemma new_lemma_65730 (h0 : topological_space (has_Inf (has_add linarith.comp))) : loc_path_connected_space (has_Inf (has_add linarith.comp)) := sorry --non-trivial
lemma new_lemma_65731 (h0 : functor.add_const (ring (generalized_boolean_algebra name)) (finset (has_nndist (has_neg Type)))) : @rank_condition.{0} (generalized_boolean_algebra.{0} name) (@functor.add_const.run.{0 1} (ring.{0} (generalized_boolean_algebra.{0} name)) (finset.{1} (has_nndist.{1} (has_neg.{1} Type))) h0)  := sorry --non-trivial
lemma new_lemma_65732 (h0 : functor.add_const (topological_space (add_comm_monoid unsigned)) pos) : @t0_space.{0} (add_comm_monoid.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (add_comm_monoid.{0} unsigned)) pos h0)  := sorry --non-trivial
lemma new_lemma_65733 (h0 : function.extfun Type ring) : @rank_condition.{0} (boolean_algebra.core.{0} name) (@function.extfun_app.{2 1} Type ring.{0} h0 (boolean_algebra.core.{0} name))  := sorry --non-trivial
lemma new_lemma_65734 (h0 : uniform_space (semigroup (finset (finset name)))) : separated_space (semigroup (finset (finset name))) := sorry --non-trivial
lemma new_lemma_65735 (h0 : uniform_space (has_nnnorm (mul_one_class linarith.comp_source))) : complete_space (has_nnnorm (mul_one_class linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_65736 (h0 : functor.add_const (function.extfun Type topological_space) (has_neg name)) : @regular_space.{0} (has_nndist.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) (has_neg.{0} name) h0) (has_nndist.{0} pos))  := sorry --non-trivial
lemma new_lemma_65737 (h0 : finset (left_cancel_monoid (semiring (semiring empty)))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_65738 (h0 : topological_space (normed_comm_ring (has_add (has_add (semigroup (semigroup name)))))) : regular_space (normed_comm_ring (has_add (has_add (semigroup (semigroup name))))) := sorry --non-trivial
lemma new_lemma_65739 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_domain.{0} (normed_group.{0} string_imp) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (normed_group.{0} string_imp))  := sorry --non-trivial
lemma new_lemma_65740 (h0 : topological_space (boolean_algebra (has_Inf (finset linarith.comp)))) : path_connected_space (boolean_algebra (has_Inf (finset linarith.comp))) := sorry --non-trivial
lemma new_lemma_65741 (h0 : functor.add_const (uniform_space Type) (ring pos)) : @separated_space.{1} Type (@functor.add_const.run.{1 0} (uniform_space.{1} Type) (ring.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_65742 (h0 : add_group (normed_group (semiring (random_gen congr_arg_kind)))) : is_add_cyclic (normed_group (semiring (random_gen congr_arg_kind))) := sorry --non-trivial
lemma new_lemma_65743 (h0 : topological_space (mul_zero_class (option name))) : preconnected_space (mul_zero_class (option name)) := sorry --non-trivial
lemma new_lemma_65744 (h0 : group (boolean_algebra.core ennreal)) : is_cyclic (boolean_algebra.core ennreal) := sorry --non-trivial
lemma new_lemma_65745 (h0 : ring (has_inv (comm_ring (random_gen fun_info)))) : rank_condition (has_inv (comm_ring (random_gen fun_info))) := sorry --non-trivial
lemma new_lemma_65746 (h0 : topological_space (boolean_algebra (finset Type))) : topological_space.separable_space (boolean_algebra (finset Type)) := sorry --non-trivial
lemma new_lemma_65747 (h0 : semiring (normed_group (semiring (semiring empty)))) : is_noetherian_ring (normed_group (semiring (semiring empty))) := sorry --non-trivial
lemma new_lemma_65748 (h0 : function.extfun Type uniform_space) : @complete_space.{0} (random_gen.{0} num) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (random_gen.{0} num))  := sorry --non-trivial
lemma new_lemma_65749 (h0 : function.extfun Type group) : @is_simple_group.{0} (normed_comm_ring.{0} name) (@function.extfun_app.{2 1} Type group.{0} h0 (normed_comm_ring.{0} name))  := sorry --non-trivial
lemma new_lemma_65750 (h0 : function.extfun (Type 1) topological_space) : @discrete_topology.{1} (finset.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} h0 (finset.{1} Type))  := sorry --non-trivial
lemma new_lemma_65751 (h0 : ring (add_left_cancel_semigroup num)) : is_principal_ideal_ring (add_left_cancel_semigroup num) := sorry --non-trivial
lemma new_lemma_65752 (h0 : functor.add_const (prod (semiring empty) (semiring empty)) empty) : id_rel (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_65753 (h0 : topological_space (mul_zero_class (semiring (ordered_cancel_comm_monoid congr_arg_kind)))) : totally_disconnected_space (mul_zero_class (semiring (ordered_cancel_comm_monoid congr_arg_kind))) := sorry --non-trivial
lemma new_lemma_65754 (h0 : functor.comp list has_add pos) : palindrome (functor.comp.run h0) := sorry --non-trivial
lemma new_lemma_65755 (h0 : functor.add_const (topological_space (boolean_algebra.core Type)) pos) : @locally_compact_space.{1} (boolean_algebra.core.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (boolean_algebra.core.{1} Type)) pos h0)  := sorry --non-trivial
lemma new_lemma_65756 (h0 : cancel_comm_monoid_with_zero (add_cancel_monoid (option (option (option pos))))) : unique_factorization_monoid (add_cancel_monoid (option (option (option pos)))) := sorry --non-trivial
lemma new_lemma_65757 (h0 : functor.add_const (topological_space (has_bot pos)) name) : @regular_space.{0} (has_bot.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (has_bot.{0} pos)) name h0)  := sorry --non-trivial
lemma new_lemma_65758 (h0 : function.extfun Type ring) : @strong_rank_condition.{0} (normed_group.{0} fun_info) (@function.extfun_app.{2 1} Type ring.{0} h0 (normed_group.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_65759 (h0 : group (has_nnnorm (mul_one_class reducibility_hints))) : is_cyclic (has_nnnorm (mul_one_class reducibility_hints)) := sorry --non-trivial
lemma new_lemma_65760 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : normal_space real := sorry --non-trivial
lemma new_lemma_65761 (h0 : topological_space (add_right_cancel_monoid (semiring (semiring (semiring congr_arg_kind))))) : t1_space (add_right_cancel_monoid (semiring (semiring (semiring congr_arg_kind)))) := sorry --non-trivial
lemma new_lemma_65762 (h0 : function.extfun Type complete_lattice) : @complete_lattice.is_Sup_finite_compact.{0} (has_Sup.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (has_Sup.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_65763 (h0 : topological_space (has_star (has_top (has_top congr_arg_kind)))) : path_connected_space (has_star (has_top (has_top congr_arg_kind))) := sorry --non-trivial
lemma new_lemma_65764 (h0 : topological_space (sub_neg_monoid (has_bot (has_bot (has_bot real))))) : path_connected_space (sub_neg_monoid (has_bot (has_bot (has_bot real)))) := sorry --non-trivial
lemma new_lemma_65765 (h0 : functor.add_const (complete_lattice (add_comm_monoid name)) name) : @complete_lattice.is_Sup_finite_compact.{0} (add_comm_monoid.{0} name) (@functor.add_const.run.{0 0} (complete_lattice.{0} (add_comm_monoid.{0} name)) name h0)  := sorry --non-trivial
lemma new_lemma_65766 (h0 : topological_space (boolean_algebra (finset (finset Type)))) : discrete_topology (boolean_algebra (finset (finset Type))) := sorry --non-trivial
lemma new_lemma_65767 (h0 : ring (complete_distrib_lattice empty)) : is_principal_ideal_ring (complete_distrib_lattice empty) := sorry --non-trivial
lemma new_lemma_65768 (h0 : not (uniform_space (semiring fun_info) -> false)) : @complete_space.{0} (semiring.{0} fun_info) (@classical.by_contradiction'.{1} (uniform_space.{0} (semiring.{0} fun_info)) h0)  := sorry --non-trivial
lemma new_lemma_65769 (h0 : functor.add_const (semiring (complete_distrib_lattice pos)) Type) : @is_noetherian_ring.{0} (complete_distrib_lattice.{0} pos) (@functor.add_const.run.{0 1} (semiring.{0} (complete_distrib_lattice.{0} pos)) Type h0)  := sorry --non-trivial
lemma new_lemma_65770 (h0 : add_group (ring ennreal)) : is_add_cyclic (ring ennreal) := sorry --non-trivial
lemma new_lemma_65771 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @rank_condition.{0} (has_top.{0} unsigned) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (has_top.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_65772 (h0 : semiring (semigroup (ring (has_pos_part (finset pos))))) : is_noetherian_ring (semigroup (ring (has_pos_part (finset pos)))) := sorry --non-trivial
lemma new_lemma_65773 (h0 : not (add_group (set.set_semiring (random_gen fun_info)) -> false)) : @is_add_cyclic.{0} (set.set_semiring.{0} (random_gen.{0} fun_info)) (@classical.by_contradiction'.{1} (add_group.{0} (set.set_semiring.{0} (random_gen.{0} fun_info))) h0)  := sorry --non-trivial
lemma new_lemma_65774 (h0 : function.extfun (Type 1) ring) : @is_domain.{1} (has_neg.{1} Type) (@function.extfun_app.{3 2} (Type 1) ring.{1} h0 (has_neg.{1} Type))  := sorry --non-trivial
lemma new_lemma_65775 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @strong_rank_condition.{0} (linear_ordered_semiring.{0} unsigned) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (linear_ordered_semiring.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_65776 (h0 : functor.add_const (function.extfun Type complete_lattice) environment.implicit_infer_kind) : @complete_lattice.is_Sup_finite_compact.{0} (add_comm_monoid.{0} pos) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type complete_lattice.{0}) environment.implicit_infer_kind h0) (add_comm_monoid.{0} pos))  := sorry --non-trivial
lemma new_lemma_65777 (h0 : has_mem.mem (has_one congr_arg_kind) has_emptyc.emptyc) : @discrete_topology.{0} (has_one.{0} congr_arg_kind) (@finset.pi.empty.{1 0} Type topological_space.{0} (has_one.{0} congr_arg_kind) h0)  := sorry --non-trivial
lemma new_lemma_65778 (h0 : topological_space (normed_group (has_top (random_gen (random_gen linarith.ineq))))) : irreducible_space (normed_group (has_top (random_gen (random_gen linarith.ineq)))) := sorry --non-trivial
lemma new_lemma_65779 (h0 : functor.add_const (topological_space (has_to_string linarith.comp)) Type) : @locally_compact_space.{0} (has_to_string.{0} linarith.comp) (@functor.add_const.run.{0 1} (topological_space.{0} (has_to_string.{0} linarith.comp)) Type h0)  := sorry --non-trivial
lemma new_lemma_65780 (h0 : topological_space (has_zero (has_add (has_add (has_neg_part (has_neg_part (has_add (semigroup pos)))))))) : t1_space (has_zero (has_add (has_add (has_neg_part (has_neg_part (has_add (semigroup pos))))))) := sorry --non-trivial
lemma new_lemma_65781 (h0 : function.extfun Type complete_lattice) : @complete_lattice.is_Sup_finite_compact.{0} (has_to_string.{0} unsigned) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (has_to_string.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_65782 (h0 : complete_lattice (has_to_string num)) : complete_lattice.is_Sup_finite_compact (has_to_string num) := sorry --non-trivial
lemma new_lemma_65783 (h0 : functor.add_const (function.extfun (Type 1) group) Type) : @is_cyclic.{1} (has_nndist.{1} Type) (@function.extfun_app.{3 2} (Type 1) group.{1} (@functor.add_const.run.{2 1} (function.extfun.{3 2} (Type 1) group.{1}) Type h0) (has_nndist.{1} Type))  := sorry --non-trivial
lemma new_lemma_65784 (h0 : topological_space (ordered_comm_ring linarith.comp_source)) : t0_space (ordered_comm_ring linarith.comp_source) := sorry --non-trivial
lemma new_lemma_65785 (h0 : add_monoid (has_top (with_bot (has_norm empty)))) : add_monoid.fg (has_top (with_bot (has_norm empty))) := sorry --non-trivial
lemma new_lemma_65786 (h0 : complete_lattice (has_emptyc (with_bot (with_bot linarith.comp_source)))) : complete_lattice.is_Sup_finite_compact (has_emptyc (with_bot (with_bot linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_65787 (h0 : monoid (has_sub (semiring num))) : monoid.fg (has_sub (semiring num)) := sorry --non-trivial
lemma new_lemma_65788 (h1 : not (complete_lattice (distrib char) -> false)) : @is_compactly_generated.{0} (distrib.{0} char) (@classical.by_contradiction'.{1} (complete_lattice.{0} (distrib.{0} char)) h1)  := sorry --non-trivial
lemma new_lemma_65789 (h0 : group (has_top (comm_ring linarith.ineq))) : is_cyclic (has_top (comm_ring linarith.ineq)) := sorry --non-trivial
lemma new_lemma_65790 (h0 : cancel_comm_monoid_with_zero (complete_linear_order num)) : unique_factorization_monoid (complete_linear_order num) := sorry --non-trivial
lemma new_lemma_65791 (h0 : monoid (has_top (add_group (has_union (has_union empty))))) : monoid.fg (has_top (add_group (has_union (has_union empty)))) := sorry --non-trivial
lemma new_lemma_65792 (h0 : topological_space (has_pos_part (has_Inf (comm_semigroup real)))) : regular_space (has_pos_part (has_Inf (comm_semigroup real))) := sorry --non-trivial
lemma new_lemma_65793 (h0 : ring (random_gen reducibility_hints)) : strong_rank_condition (random_gen reducibility_hints) := sorry --non-trivial
lemma new_lemma_65794 (h0 : topological_space (semi_normed_ring (mul_one_class enat))) : path_connected_space (semi_normed_ring (mul_one_class enat)) := sorry --non-trivial
lemma new_lemma_65795 (h0 : function.extfun Type group) : @group.fg.{0} (add_comm_monoid.{0} (option.{0} unsigned)) (@function.extfun_app.{2 1} Type group.{0} h0 (add_comm_monoid.{0} (option.{0} unsigned)))  := sorry --non-trivial
lemma new_lemma_65796 (h0 : functor.add_const (ordered_add_comm_monoid (boolean_algebra pos)) (boolean_algebra name)) : @archimedean.{0} (boolean_algebra.{0} pos) (@functor.add_const.run.{0 0} (ordered_add_comm_monoid.{0} (boolean_algebra.{0} pos)) (boolean_algebra.{0} name) h0)  := sorry --non-trivial
lemma new_lemma_65797 (h0 : complete_lattice (pseudo_metric_space congr_arg_kind)) : is_atomistic (pseudo_metric_space congr_arg_kind) := sorry --non-trivial
lemma new_lemma_65798 (h0 : topological_space (with_bot (semiring (semiring (semiring num))))) : discrete_topology (with_bot (semiring (semiring (semiring num)))) := sorry --non-trivial
lemma new_lemma_65799 (h0 : functor.add_const (filter (finset ennreal)) environment.implicit_infer_kind) : filter.ne_bot (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_65800 (h0 : function.extfun Type complete_lattice) : @is_atomistic.{0} (has_neg_part.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (has_neg_part.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_65801 (h0 : function.extfun Type topological_space) : @irreducible_space.{0} (has_to_string.{0} ennreal) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_to_string.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_65802 (h0 : function.extfun (finset Type) (has_mem.mem (id empty))) : @add_monoid.fg.{0} (@id.{2} Type empty) (@finset.pi.empty.{1 0} Type add_monoid.{0} (@id.{2} Type empty) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (@id.{2} Type empty)) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_65803 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @totally_disconnected_space.{0} (boolean_algebra.core.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (boolean_algebra.core.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_65804 (h0 : function.extfun (Type 1) semiring) : @is_noetherian_ring.{1} (has_nndist.{1} Type) (@function.extfun_app.{3 2} (Type 1) semiring.{1} h0 (has_nndist.{1} Type))  := sorry --non-trivial
lemma new_lemma_65805 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @monoid.fg.{0} (denumerable.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 monoid.{0}) (denumerable.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_65806 (h0 : complete_lattice (uniform_space (mul_one_class (mul_one_class reducibility_hints)))) : is_compactly_generated (uniform_space (mul_one_class (mul_one_class reducibility_hints))) := sorry --non-trivial
lemma new_lemma_65807 (h0 : fin has_zero.zero) : @sequential_space.{1} (has_pos_part.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@matrix.vec_empty.{2} (function.extfun.{3 2} (Type 1) topological_space.{1}) h0) (has_pos_part.{1} Type))  := sorry --non-trivial
lemma new_lemma_65808 (h0 : add_group (normed_group (random_gen (random_gen to_additive.value_type)))) : is_add_cyclic (normed_group (random_gen (random_gen to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_65809 (h0 : ring (boolean_algebra (normed_comm_ring (semigroup (boolean_algebra.core name))))) : strong_rank_condition (boolean_algebra (normed_comm_ring (semigroup (boolean_algebra.core name)))) := sorry --non-trivial
lemma new_lemma_65810 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @separated_space.{0} (canonically_ordered_comm_semiring.{0} name) (@function.extfun_app.{2 1} Type uniform_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 uniform_space.{0}) (canonically_ordered_comm_semiring.{0} name))  := sorry --non-trivial
lemma new_lemma_65811 (h0 : not (topological_space (left_cancel_semigroup num) -> false)) : @t1_space.{0} (left_cancel_semigroup.{0} num) (@classical.by_contradiction'.{1} (topological_space.{0} (left_cancel_semigroup.{0} num)) h0)  := sorry --non-trivial
lemma new_lemma_65812 (h0 : functor.add_const (topological_space (has_neg linarith.comp)) linarith.comp) : @t1_space.{0} (has_neg.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (has_neg.{0} linarith.comp)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_65813 (h0 : ring (linear_ordered_field congr_arg_kind)) : rank_condition (linear_ordered_field congr_arg_kind) := sorry --non-trivial
lemma new_lemma_65814 (h1 : topological_space (topological_space char)) : t0_space (topological_space char) := sorry --non-trivial
lemma new_lemma_65815 (h0 : function.extfun Type complete_lattice) : @is_atomistic.{0} (left_cancel_semigroup.{0} unsigned) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (left_cancel_semigroup.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_65816 (h0 : topological_space (add_comm_monoid (has_neg (has_neg Type)))) : preirreducible_space (add_comm_monoid (has_neg (has_neg Type))) := sorry --non-trivial
lemma new_lemma_65817 (h0 : functor.comp finset add_comm_monoid name) : finset.nonempty (functor.comp.run h0) := sorry --non-trivial
lemma new_lemma_65818 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @strong_rank_condition.{0} (semiring.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (semiring.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_65819 (h0 : functor.add_const (ring (has_inter ennreal)) ennreal) : @is_principal_ideal_ring.{0} (has_inter.{0} ennreal) (@functor.add_const.run.{0 0} (ring.{0} (has_inter.{0} ennreal)) ennreal h0)  := sorry --non-trivial
lemma new_lemma_65820 (h0 : function.extfun Type topological_space) : @path_connected_space.{0} (normed_lattice_add_comm_group.{0} (has_add.{0} pos)) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (normed_lattice_add_comm_group.{0} (has_add.{0} pos)))  := sorry --non-trivial
lemma new_lemma_65821 (h1 h2 : multiset (has_lt linarith.comp_source)) : multiset.disjoint h1 h2 := sorry --non-trivial
lemma new_lemma_65822 (h0 : not (group (linear_ordered_comm_ring unsigned) -> false)) : @group.fg.{0} (linear_ordered_comm_ring.{0} unsigned) (@classical.by_contradiction'.{1} (group.{0} (linear_ordered_comm_ring.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_65823 (h0 : function.extfun (Type 1) uniform_space) : @separated_space.{1} (complete_distrib_lattice.{1} Type) (@function.extfun_app.{3 2} (Type 1) uniform_space.{1} h0 (complete_distrib_lattice.{1} Type))  := sorry --non-trivial
lemma new_lemma_65824 (h0 : topological_space (has_Inf (ring name))) : preconnected_space (has_Inf (ring name)) := sorry --non-trivial
lemma new_lemma_65825 (h0 : function.extfun Type add_monoid) : @add_monoid.fg.{0} (has_nndist.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type add_monoid.{0} h0 (has_nndist.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_65826 (h0 : topological_space (has_add (mul_one_class (ring (mul_one_class (mul_one_class (ring Type))))))) : regular_space (has_add (mul_one_class (ring (mul_one_class (mul_one_class (ring Type)))))) := sorry --non-trivial
lemma new_lemma_65827 (h0 : functor.add_const (add_monoid (has_neg linarith.comp)) (has_to_string environment.implicit_infer_kind)) : @add_monoid.fg.{0} (has_neg.{0} linarith.comp) (@functor.add_const.run.{0 0} (add_monoid.{0} (has_neg.{0} linarith.comp)) (has_to_string.{0} environment.implicit_infer_kind) h0)  := sorry --non-trivial
lemma new_lemma_65828 (h0 : functor.add_const (topological_space (add_cancel_monoid (option empty))) num) : @irreducible_space.{0} (add_cancel_monoid.{0} (option.{0} empty)) (@functor.add_const.run.{0 0} (topological_space.{0} (add_cancel_monoid.{0} (option.{0} empty))) num h0)  := sorry --non-trivial
lemma new_lemma_65829 (h1 : topological_space (non_unital_non_assoc_semiring linarith.comp_source)) : t0_space (non_unital_non_assoc_semiring linarith.comp_source) := sorry --non-trivial
lemma new_lemma_65830 (h0 : functor.add_const (finset (has_zero linarith.comp)) (has_Inf (has_Inf linarith.comp))) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_65831 (h0 : functor.add_const (list (has_zero pos)) linarith.comp) : list.nodup (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_65832 (h0 : not (function.extfun Type group -> false)) : @is_cyclic.{0} (has_emptyc.{0} (has_top.{0} linarith.ineq)) (@function.extfun_app.{2 1} Type group.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type group.{0}) h0) (has_emptyc.{0} (has_top.{0} linarith.ineq)))  := sorry --non-trivial
lemma new_lemma_65833 (h0 : functor.add_const (topological_space (complete_distrib_lattice ennreal)) num) : @t1_space.{0} (complete_distrib_lattice.{0} ennreal) (@functor.add_const.run.{0 0} (topological_space.{0} (complete_distrib_lattice.{0} ennreal)) num h0)  := sorry --non-trivial
lemma new_lemma_65834 (h0 : fin has_zero.zero) (h1 : pnat) : pnat.coprime (matrix.vec_empty h0) (id h1) := sorry --non-trivial
lemma new_lemma_65835 (h0 : function.extfun Type uniform_space) : @complete_space.{0} to_additive.value_type (@function.extfun_app.{2 1} Type uniform_space.{0} h0 to_additive.value_type)  := sorry --non-trivial
lemma new_lemma_65836 (h0 : group (has_Sup (comm_monoid (comm_monoid (comm_monoid (comm_monoid unsigned)))))) : is_simple_group (has_Sup (comm_monoid (comm_monoid (comm_monoid (comm_monoid unsigned))))) := sorry --non-trivial
lemma new_lemma_65837 (h0 : not (list (dlist to_additive.value_type) -> false)) : list.nodup (classical.by_contradiction' h0) := sorry --non-trivial
lemma new_lemma_65838 (h0 : setoid (uniform_space enat)) (h1 : quotient h0) : @complete_space.{0} enat (@quotient.out'.{1} (uniform_space.{0} enat) h0 h1)  := sorry --non-trivial
lemma new_lemma_65839 (h0 : not (uniform_space (linear_ordered_comm_ring num) -> false)) : @separated_space.{0} (linear_ordered_comm_ring.{0} num) (@classical.by_contradiction'.{1} (uniform_space.{0} (linear_ordered_comm_ring.{0} num)) h0)  := sorry --non-trivial
lemma new_lemma_65840 (h0 : topological_space (add_group (semiring (has_top empty)))) : preirreducible_space (add_group (semiring (has_top empty))) := sorry --non-trivial
lemma new_lemma_65841 (h0 : uniform_space (generalized_boolean_algebra (has_Inf (has_Inf linarith.comp)))) : complete_space (generalized_boolean_algebra (has_Inf (has_Inf linarith.comp))) := sorry --non-trivial
lemma new_lemma_65842 (h0 : cancel_comm_monoid_with_zero (preorder (has_top num))) : unique_factorization_monoid (preorder (has_top num)) := sorry --non-trivial
lemma new_lemma_65843 (h0 : fin has_zero.zero) : @preirreducible_space.{1} (has_pos_part.{1} Type) (@matrix.vec_empty.{1} (topological_space.{1} (has_pos_part.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_65844 (h0 : topological_space (linear_ordered_semiring (has_top empty))) : totally_separated_space (linear_ordered_semiring (has_top empty)) := sorry --non-trivial
lemma new_lemma_65845 (h0 : topological_space (complete_distrib_lattice (finset (finset ennreal)))) : totally_separated_space (complete_distrib_lattice (finset (finset ennreal))) := sorry --non-trivial
lemma new_lemma_65846 (h0 : complete_lattice (normed_field linarith.comp_source)) : complete_lattice.is_Sup_finite_compact (normed_field linarith.comp_source) := sorry --non-trivial
lemma new_lemma_65847 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @normal_space.{0} (sub_neg_monoid.{0} real) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (sub_neg_monoid.{0} real))  := sorry --non-trivial
lemma new_lemma_65848 (h0 : function.extfun Type topological_space) : @t1_space.{0} (boolean_algebra.{0} real) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (boolean_algebra.{0} real))  := sorry --non-trivial
lemma new_lemma_65849 (h0 : functor.add_const (semiring (option num)) congr_arg_kind) : @is_noetherian_ring.{0} (option.{0} num) (@functor.add_const.run.{0 0} (semiring.{0} (option.{0} num)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_65850 (h0 : topological_space (has_to_string (has_nndist environment.implicit_infer_kind))) : t0_space (has_to_string (has_nndist environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_65851 (h0 : function.extfun Type (functor.add_const (topological_space pos))) : @discrete_topology.{0} pos (@functor.add_const.run.{0 0} (topological_space.{0} pos) ennreal (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (topological_space.{0} pos)) h0 ennreal))  := sorry --non-trivial
lemma new_lemma_65852 (h0 : option (functor.add_const (topological_space (comm_group pos)) unsigned)) (h1 : function.extfun Type (functor.add_const (topological_space (comm_group pos)))) : @totally_disconnected_space.{0} (comm_group.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (comm_group.{0} pos)) unsigned (@option.get_or_else.{0} (functor.add_const.{0 0} (topological_space.{0} (comm_group.{0} pos)) unsigned) h0 (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (topological_space.{0} (comm_group.{0} pos))) h1 unsigned)))  := sorry --non-trivial
lemma new_lemma_65853 (h0 : prod (add_right_cancel_monoid (semiring empty)) (add_right_cancel_monoid (semiring empty))) : id_rel h0 := sorry --non-trivial
lemma new_lemma_65854 (h0 : functor.add_const (topological_space (has_nndist pos)) linarith.comp) : @totally_separated_space.{0} (has_nndist.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (has_nndist.{0} pos)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_65855 (h0 : function.extfun Type list) : list.nodup (function.extfun_app h0 (has_to_string unsigned)) := sorry --non-trivial
lemma new_lemma_65856 (h0 : functor.add_const (topological_space (has_neg linarith.comp)) (has_zero name)) : @irreducible_space.{0} (has_neg.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (has_neg.{0} linarith.comp)) (has_zero.{0} name) h0)  := sorry --non-trivial
lemma new_lemma_65857 (h0 : Prop -> ereal) (h1 : set Prop) (h2 : ereal) : function.inv_fun_on h0 h1 h2 := sorry --non-trivial
lemma new_lemma_65858 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @totally_separated_space.{0} (finset.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (finset.{0} empty))  := sorry --non-trivial
lemma new_lemma_65859 (h0 : functor.add_const (uniform_space (boolean_algebra.core name)) pos) : @separated_space.{0} (boolean_algebra.core.{0} name) (@functor.add_const.run.{0 0} (uniform_space.{0} (boolean_algebra.core.{0} name)) pos h0)  := sorry --non-trivial
lemma new_lemma_65860 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : t0_space empty := sorry --non-trivial
lemma new_lemma_65861 (h0 : not (function.extfun Type topological_space -> false)) : @t0_space.{0} (semiring.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (semiring.{0} empty))  := sorry --non-trivial
lemma new_lemma_65862 (h0 : monoid (has_Inf (has_Inf Type))) : monoid.fg (has_Inf (has_Inf Type)) := sorry --non-trivial
lemma new_lemma_65863 (h0 : ordered_comm_monoid (has_pos_part (ring (finset (finset (finset linarith.comp)))))) : has_exists_mul_of_le (has_pos_part (ring (finset (finset (finset linarith.comp))))) := sorry --non-trivial
lemma new_lemma_65864 (h0 : functor.add_const (add_monoid (ordered_ring empty)) num) : @add_monoid.fg.{0} (ordered_ring.{0} empty) (@functor.add_const.run.{0 0} (add_monoid.{0} (ordered_ring.{0} empty)) num h0)  := sorry --non-trivial
lemma new_lemma_65865 (h0 h1 : list char) : list.is_suffix h0 h1 := sorry --non-trivial
lemma new_lemma_65866 (h0 : not (function.extfun Type topological_space -> false)) : @locally_compact_space.{0} (has_norm.{0} linarith.ineq) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (has_norm.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_65867 (h1 : add_monoid (has_norm congr_arg_kind)) : add_monoid.fg (has_norm congr_arg_kind) := sorry --non-trivial
lemma new_lemma_65868 (h0 : functor.add_const (topological_space (has_add num)) name) : @regular_space.{0} (has_add.{0} num) (@functor.add_const.run.{0 0} (topological_space.{0} (has_add.{0} num)) name h0)  := sorry --non-trivial
lemma new_lemma_65869 (h0 : functor.add_const (topological_space (option num)) (semiring congr_arg_kind)) : @t1_space.{0} (option.{0} num) (@functor.add_const.run.{0 0} (topological_space.{0} (option.{0} num)) (semiring.{0} congr_arg_kind) h0)  := sorry --non-trivial
lemma new_lemma_65870 (h0 : cancel_comm_monoid_with_zero (non_assoc_semiring (semiring (semiring (semiring congr_arg_kind))))) : unique_factorization_monoid (non_assoc_semiring (semiring (semiring (semiring congr_arg_kind)))) := sorry --non-trivial
lemma new_lemma_65871 (h0 : functor.add_const (list (finset pos)) environment.implicit_infer_kind) : list.nodup (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_65872 (h0 : complete_lattice (has_nnnorm (has_ssubset fun_info))) : is_compactly_generated (has_nnnorm (has_ssubset fun_info)) := sorry --non-trivial
lemma new_lemma_65873 (h0 : functor.add_const (monoid (comm_group name)) (comm_group name)) : @monoid.fg.{0} (comm_group.{0} name) (@functor.add_const.run.{0 0} (monoid.{0} (comm_group.{0} name)) (comm_group.{0} name) h0)  := sorry --non-trivial
lemma new_lemma_65874 (h0 : functor.add_const (group (finset name)) linarith.comp) : @group.fg.{0} (finset.{0} name) (@functor.add_const.run.{0 0} (group.{0} (finset.{0} name)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_65875 (h0 : functor.add_const (filter (semigroup name)) unsigned) : filter.ne_bot (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_65876 : infinite (comm_semigroup unsigned) := sorry --non-trivial
lemma new_lemma_65877 (h0 : complete_lattice (has_emptyc congr_arg_kind)) : is_atomistic (has_emptyc congr_arg_kind) := sorry --non-trivial
lemma new_lemma_65878 (h0 : topological_space (add_cancel_monoid (option empty))) : t0_space (add_cancel_monoid (option empty)) := sorry --non-trivial
lemma new_lemma_65879 (h0 : functor.add_const (function.extfun (Type 1) add_monoid) linarith.comp) : @add_monoid.fg.{1} (has_zero.{1} Type) (@function.extfun_app.{3 2} (Type 1) add_monoid.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) add_monoid.{1}) linarith.comp h0) (has_zero.{1} Type))  := sorry --non-trivial
lemma new_lemma_65880 (h0 : set (mul_one_class enat)) : set.finite h0 := sorry --non-trivial
lemma new_lemma_65881 (h0 : functor.add_const (ordered_add_comm_monoid (has_add name)) linarith.comp) : @archimedean.{0} (has_add.{0} name) (@functor.add_const.run.{0 0} (ordered_add_comm_monoid.{0} (has_add.{0} name)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_65882 (h0 : finset (has_star unsigned)) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_65883 (h0 : function.extfun Type group) : @normalizer_condition.{0} (semigroup.{0} empty) (@function.extfun_app.{2 1} Type group.{0} h0 (semigroup.{0} empty))  := sorry --non-trivial
lemma new_lemma_65884 (h0 : function.extfun Type ordered_comm_monoid) : @has_exists_mul_of_le.{0} (cancel_monoid.{0} name) (@function.extfun_app.{2 1} Type ordered_comm_monoid.{0} h0 (cancel_monoid.{0} name))  := sorry --non-trivial
lemma new_lemma_65885 (h0 : functor.add_const (ring (has_to_string unsigned)) unsigned) : @is_principal_ideal_ring.{0} (has_to_string.{0} unsigned) (@functor.add_const.run.{0 0} (ring.{0} (has_to_string.{0} unsigned)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_65886 (h0 : topological_space (finset (has_neg (sub_neg_monoid name)))) : t0_space (finset (has_neg (sub_neg_monoid name))) := sorry --non-trivial
lemma new_lemma_65887 (h0 : topological_space (group_with_zero congr_arg_kind)) : topological_space.separable_space (group_with_zero congr_arg_kind) := sorry --non-trivial
lemma new_lemma_65888 (h0 : not (group (denumerable to_additive.value_type) -> false)) : @group.fg.{0} (denumerable.{0} to_additive.value_type) (@classical.by_contradiction'.{1} (group.{0} (denumerable.{0} to_additive.value_type)) h0)  := sorry --non-trivial
lemma new_lemma_65889 (h0 : topological_space (boolean_algebra (has_add name))) : locally_compact_space (boolean_algebra (has_add name)) := sorry --non-trivial
lemma new_lemma_65890 (h0 : function.extfun (Type 1) complete_lattice) : @is_atomistic.{1} (has_bot.{1} Type) (@function.extfun_app.{3 2} (Type 1) complete_lattice.{1} h0 (has_bot.{1} Type))  := sorry --non-trivial
lemma new_lemma_65891 (h0 : add_group (boolean_algebra (boolean_algebra.core environment.implicit_infer_kind))) : is_add_cyclic (boolean_algebra (boolean_algebra.core environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_65892 (h0 : functor.add_const (topological_space (comm_group unsigned)) linarith.comp) : @totally_separated_space.{0} (comm_group.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (comm_group.{0} unsigned)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_65893 (h0 : group (add_semigroup (semiring (semiring empty)))) : is_cyclic (add_semigroup (semiring (semiring empty))) := sorry --non-trivial
lemma new_lemma_65894 (h0 : functor.add_const (group (ordered_cancel_comm_monoid empty)) (semiring empty)) : @group.fg.{0} (ordered_cancel_comm_monoid.{0} empty) (@functor.add_const.run.{0 0} (group.{0} (ordered_cancel_comm_monoid.{0} empty)) (semiring.{0} empty) h0)  := sorry --non-trivial
lemma new_lemma_65895 (h1 : function.extfun Type ring) : @is_domain.{0} (linear_ordered_add_comm_group.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type ring.{0} h1 (linear_ordered_add_comm_group.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_65896 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @t0_space.{0} (normed_group.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (normed_group.{0} num))  := sorry --non-trivial
lemma new_lemma_65897 (h0 : functor.add_const (function.extfun (Type 1) complete_lattice) Type) : @complete_lattice.is_Sup_finite_compact.{1} (has_zero.{1} Type) (@function.extfun_app.{3 2} (Type 1) complete_lattice.{1} (@functor.add_const.run.{2 1} (function.extfun.{3 2} (Type 1) complete_lattice.{1}) Type h0) (has_zero.{1} Type))  := sorry --non-trivial
lemma new_lemma_65898 (h0 : filter (has_inter num)) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_65899 (h0 : ordered_add_comm_monoid (ring (ring linarith.comp))) : archimedean (ring (ring linarith.comp)) := sorry --non-trivial
lemma new_lemma_65900 (h0 : prod (has_nndist Type) (has_nndist Type)) : id_rel h0 := sorry --non-trivial
lemma new_lemma_65901 (h0 h1 : multiset (uniform_space (mul_one_class string.iterator_imp))) : multiset.disjoint h0 h1 := sorry --non-trivial
lemma new_lemma_65902 (h0 : function.extfun Type topological_space) : @topological_space.separable_space.{0} (simple_graph.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (simple_graph.{0} pos))  := sorry --non-trivial
lemma new_lemma_65903 (h0 : topological_space (ordered_comm_ring (has_pos_part Type))) : preirreducible_space (ordered_comm_ring (has_pos_part Type)) := sorry --non-trivial
lemma new_lemma_65904 (h0 : functor.add_const (topological_space (boolean_algebra.core Type)) pos) : @path_connected_space.{1} (boolean_algebra.core.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (boolean_algebra.core.{1} Type)) pos h0)  := sorry --non-trivial
lemma new_lemma_65905 (h0 : topological_space (complete_distrib_lattice real)) : loc_path_connected_space (complete_distrib_lattice real) := sorry --non-trivial
lemma new_lemma_65906 (h0 : has_mem.mem (has_top (has_norm fun_info)) has_emptyc.emptyc) : @is_domain.{0} (has_top.{0} (has_norm.{0} fun_info)) (@finset.pi.empty.{1 0} Type ring.{0} (has_top.{0} (has_norm.{0} fun_info)) h0)  := sorry --non-trivial
lemma new_lemma_65907 (h0 : functor.add_const (function.extfun (Type 1) cancel_comm_monoid_with_zero) (ring name)) : @unique_factorization_monoid.{1} Type (@function.extfun_app.{3 2} (Type 1) cancel_comm_monoid_with_zero.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) cancel_comm_monoid_with_zero.{1}) (ring.{0} name) h0) Type)  := sorry --non-trivial
lemma new_lemma_65908 (h0 : topological_space (random_gen (semiring linarith.comp))) : totally_separated_space (random_gen (semiring linarith.comp)) := sorry --non-trivial
lemma new_lemma_65909 (h0 : functor.add_const (complete_lattice (canonically_ordered_comm_semiring ennreal)) (boolean_algebra.core pos)) : @is_atomistic.{0} (canonically_ordered_comm_semiring.{0} ennreal) (@functor.add_const.run.{0 0} (complete_lattice.{0} (canonically_ordered_comm_semiring.{0} ennreal)) (boolean_algebra.core.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_65910 (h0 : topological_space (has_zero (has_add Type))) : totally_separated_space (has_zero (has_add Type)) := sorry --non-trivial
lemma new_lemma_65911 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @group.fg.{0} (has_pos_part.{0} real) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (has_pos_part.{0} real))  := sorry --non-trivial
lemma new_lemma_65912 (h0 : functor.add_const (topological_space (has_nndist Type)) name) : @t1_space.{1} (has_nndist.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (has_nndist.{1} Type)) name h0)  := sorry --non-trivial
lemma new_lemma_65913 (h0 : functor.add_const (finset (left_cancel_monoid num)) empty) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_65914 (h0 : functor.comp (functor.add_const (ordered_add_comm_monoid (has_neg_part unsigned))) option unsigned) : @archimedean.{0} (has_neg_part.{0} unsigned) (@functor.add_const.run.{0 0} (ordered_add_comm_monoid.{0} (has_neg_part.{0} unsigned)) (option.{0} unsigned) (@functor.comp.run.{0 0 0} (functor.add_const.{0 0} (ordered_add_comm_monoid.{0} (has_neg_part.{0} unsigned))) option.{0} unsigned h0))  := sorry --non-trivial
lemma new_lemma_65915 (h0 : group (complete_distrib_lattice (sub_neg_monoid pos))) : group.fg (complete_distrib_lattice (sub_neg_monoid pos)) := sorry --non-trivial
lemma new_lemma_65916 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @topological_space.separable_space.{1} (canonically_ordered_comm_semiring.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 topological_space.{1}) (canonically_ordered_comm_semiring.{1} Type))  := sorry --non-trivial
lemma new_lemma_65917 (h0 : not (topological_space (measurable_space linarith.comp) -> false)) : @totally_disconnected_space.{0} (measurable_space.{0} linarith.comp) (@classical.by_contradiction'.{1} (topological_space.{0} (measurable_space.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_65918 (h0 : function.extfun Type ring) : @is_domain.{0} (complete_distrib_lattice.{0} pos) (@function.extfun_app.{2 1} Type ring.{0} h0 (complete_distrib_lattice.{0} pos))  := sorry --non-trivial
lemma new_lemma_65919 (h0 : topological_space (mul_one_class std_gen)) (h1 : preorder (mul_one_class std_gen)) : order_closed_topology (mul_one_class std_gen) := sorry --non-trivial
lemma new_lemma_65920 (h0 : monoid Type) (h1 : conj_classes Type) : conj_classes.carrier h1 nnreal := sorry --non-trivial
lemma new_lemma_65921 (h0 : add_group (has_nndist linarith.comp)) : is_add_cyclic (has_nndist linarith.comp) := sorry --non-trivial
lemma new_lemma_65922 (h0 : has_mem.mem ring has_emptyc.emptyc) : @strong_rank_condition.{0} (complete_semilattice_Sup.{0} linarith.comp) (@function.extfun_app.{2 1} Type ring.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) ring.{0} h0) (complete_semilattice_Sup.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_65923 (h0 : not (function.extfun Type topological_space -> false)) : @locally_compact_space.{0} (has_sub.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (has_sub.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_65924 (h0 : cancel_comm_monoid_with_zero (has_zero (option (option (option pos))))) : unique_factorization_monoid (has_zero (option (option (option pos)))) := sorry --non-trivial
lemma new_lemma_65925 (h0 : not (function.extfun Type group -> false)) : @normalizer_condition.{0} (has_emptyc.{0} num) (@function.extfun_app.{2 1} Type group.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type group.{0}) h0) (has_emptyc.{0} num))  := sorry --non-trivial
lemma new_lemma_65926 (h0 : functor.add_const (ordered_comm_monoid (finset name)) (has_nndist name)) : @has_exists_mul_of_le.{0} (finset.{0} name) (@functor.add_const.run.{0 0} (ordered_comm_monoid.{0} (finset.{0} name)) (has_nndist.{0} name) h0)  := sorry --non-trivial
lemma new_lemma_65927 (h0 : complete_lattice (has_inv (random_gen string_imp))) : complete_lattice.is_Sup_finite_compact (has_inv (random_gen string_imp)) := sorry --non-trivial
lemma new_lemma_65928 (h0 : function.extfun Type group) : @is_cyclic.{0} (has_emptyc.{0} fun_info) (@function.extfun_app.{2 1} Type group.{0} h0 (has_emptyc.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_65929 (h0 : functor.add_const (list (has_add linarith.comp)) (add_comm_monoid Type)) : palindrome (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_65930 (h0 : ring (topological_space (has_nnnorm linarith.ineq))) : strong_rank_condition (topological_space (has_nnnorm linarith.ineq)) := sorry --non-trivial
lemma new_lemma_65931 (h0 : function.extfun Type list) : list.nodup (function.extfun_app h0 (simple_graph name)) := sorry --non-trivial
lemma new_lemma_65932 (h0 : functor.add_const (topological_space (has_to_string linarith.comp)) pos) : @preirreducible_space.{0} (has_to_string.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (has_to_string.{0} linarith.comp)) pos h0)  := sorry --non-trivial
lemma new_lemma_65933 (h0 : functor.add_const (ring (add_cancel_monoid name)) linarith.comp) : @rank_condition.{0} (add_cancel_monoid.{0} name) (@functor.add_const.run.{0 0} (ring.{0} (add_cancel_monoid.{0} name)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_65934 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_noetherian_ring.{0} (has_Sup.{0} empty) (@function.extfun_app.{2 1} Type semiring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 semiring.{0}) (has_Sup.{0} empty))  := sorry --non-trivial
lemma new_lemma_65935 (h0 : functor.add_const (list (has_to_string pos)) Type) : palindrome (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_65936 (h0 : functor.add_const (complete_lattice (has_add linarith.comp)) environment.implicit_infer_kind) : @complete_lattice.is_Sup_finite_compact.{0} (has_add.{0} linarith.comp) (@functor.add_const.run.{0 0} (complete_lattice.{0} (has_add.{0} linarith.comp)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_65937 (h0 : topological_space (has_to_string (has_add (boolean_algebra.core Type)))) : normal_space (has_to_string (has_add (boolean_algebra.core Type))) := sorry --non-trivial
lemma new_lemma_65938 (h0 : group (linear_ordered_semiring (random_gen congr_arg_kind))) : normalizer_condition (linear_ordered_semiring (random_gen congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_65939 (h0 : group (semigroup (ring (has_zero linarith.comp)))) : is_simple_group (semigroup (ring (has_zero linarith.comp))) := sorry --non-trivial
lemma new_lemma_65940 (h0 : functor.add_const (semiring (has_add pos)) pos) : @is_noetherian_ring.{0} (has_add.{0} pos) (@functor.add_const.run.{0 0} (semiring.{0} (has_add.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_65941 (h0 : complete_lattice (boolean_algebra (has_neg_part (has_add (has_add Type))))) : is_atomistic (boolean_algebra (has_neg_part (has_add (has_add Type)))) := sorry --non-trivial
lemma new_lemma_65942 (h0 : group (has_sub unsigned)) : group.fg (has_sub unsigned) := sorry --non-trivial
lemma new_lemma_65943 (h0 : topological_space (canonically_linear_ordered_monoid (has_neg_part pos))) : totally_disconnected_space (canonically_linear_ordered_monoid (has_neg_part pos)) := sorry --non-trivial
lemma new_lemma_65944 (h0 : cancel_comm_monoid_with_zero (canonically_ordered_comm_semiring (has_to_string unsigned))) : unique_factorization_monoid (canonically_ordered_comm_semiring (has_to_string unsigned)) := sorry --non-trivial
lemma new_lemma_65945 (h1 : topological_space (distrib (comm_ring (random_gen char)))) : path_connected_space (distrib (comm_ring (random_gen char))) := sorry --non-trivial
lemma new_lemma_65946 (h0 : not (function.extfun Type complete_lattice -> false)) : @complete_lattice.is_Sup_finite_compact.{0} (dlist.{0} char) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type complete_lattice.{0}) h0) (dlist.{0} char))  := sorry --non-trivial
lemma new_lemma_65947 (h0 : fin has_zero.zero) : @path_connected_space.{0} (sub_neg_monoid.{0} real) (@matrix.vec_empty.{0} (topological_space.{0} (sub_neg_monoid.{0} real)) h0)  := sorry --non-trivial
lemma new_lemma_65948 (h0 : ring (has_star (semiring num))) : is_principal_ideal_ring (has_star (semiring num)) := sorry --non-trivial
lemma new_lemma_65949 (h0 : ring (uniform_space reducibility_hints) -> Prop) (h1 : Exists (fun (x : ring (uniform_space reducibility_hints)), h0 x)) : @strong_rank_condition.{0} (uniform_space.{0} reducibility_hints) (@classical.some.{1} (ring.{0} (uniform_space.{0} reducibility_hints)) h0 h1)  := sorry --non-trivial
lemma new_lemma_65950 (h0 : topological_space (non_unital_non_assoc_semiring (has_nnnorm char))) (h1 : preorder (non_unital_non_assoc_semiring (has_nnnorm char))) : order_topology (non_unital_non_assoc_semiring (has_nnnorm char)) := sorry --non-trivial
lemma new_lemma_65951 (h0 : functor.add_const (function.extfun (Type 1) list) Type) : list.nodup (function.extfun_app (functor.add_const.run h0) (normed_comm_ring Type)) := sorry --non-trivial
lemma new_lemma_65952 (h0 : topological_space (random_gen (has_norm linarith.comp))) : irreducible_space (random_gen (has_norm linarith.comp)) := sorry --non-trivial
lemma new_lemma_65953 (h0 : znum) (h1 : has_mul znum) (h2 : znum) : commute h2 (znum.pred h0) := sorry --non-trivial
lemma new_lemma_65954 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @group.fg.{0} (cancel_monoid.{0} ennreal) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (cancel_monoid.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_65955 (h1 : ring (id linarith.comp)) : strong_rank_condition (id linarith.comp) := sorry --non-trivial
lemma new_lemma_65956 (h0 : functor.comp ring has_neg Type) : @strong_rank_condition.{1} (has_neg.{1} Type) (@functor.comp.run.{1 1 1} ring.{1} has_neg.{1} Type h0)  := sorry --non-trivial
lemma new_lemma_65957 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @locally_compact_space.{0} (has_ssubset.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_ssubset.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_65958 (h0 : topological_space (canonically_linear_ordered_monoid num)) : locally_compact_space (canonically_linear_ordered_monoid num) := sorry --non-trivial
lemma new_lemma_65959 (h0 : ring int) : rank_condition int := sorry --non-trivial
lemma new_lemma_65960 (h0 : not (topological_space (measurable_space (has_top linarith.comp_source)) -> false)) : @totally_disconnected_space.{0} (measurable_space.{0} (has_top.{0} linarith.comp_source)) (@classical.by_contradiction'.{1} (topological_space.{0} (measurable_space.{0} (has_top.{0} linarith.comp_source))) h0)  := sorry --non-trivial
lemma new_lemma_65961 (h0 : function.extfun Type finset) : finset.nonempty (function.extfun_app h0 (linear_ordered_comm_group empty)) := sorry --non-trivial
lemma new_lemma_65962 (h0 : topological_space (simple_graph (finset (has_add pos)))) : preconnected_space (simple_graph (finset (has_add pos))) := sorry --non-trivial
lemma new_lemma_65963 (h0 : functor.add_const (finset (boolean_algebra.core pos)) (has_add name)) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_65964 (h0 : group (random_gen (has_nnnorm (has_nnnorm (random_gen linarith.comp_source))))) : group.fg (random_gen (has_nnnorm (has_nnnorm (random_gen linarith.comp_source)))) := sorry --non-trivial
lemma new_lemma_65965 (h1 : add_group (denumerable to_additive.value_type)) : is_add_cyclic (denumerable to_additive.value_type) := sorry --non-trivial
lemma new_lemma_65966 (h0 : ring (semiring (has_norm (has_norm (has_norm num))))) : is_domain (semiring (has_norm (has_norm (has_norm num)))) := sorry --non-trivial
lemma new_lemma_65967 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : finset.nonempty (function.extfun_app (function.extfun_app h0 finset) (pseudo_metric_space num)) := sorry --non-trivial
lemma new_lemma_65968 (h0 : function.extfun Type topological_space) : @normal_space.{0} (complete_distrib_lattice.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (complete_distrib_lattice.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_65969 (h0 : function.extfun nat fin) : @is_noetherian_ring.{0} (canonically_linear_ordered_monoid.{0} real) (@function.extfun_app.{2 1} Type semiring.{0} (@matrix.vec_empty.{1} (function.extfun.{2 1} Type semiring.{0}) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero))) (canonically_linear_ordered_monoid.{0} real))  := sorry --non-trivial
lemma new_lemma_65970 (h0 : function.extfun Type ring) : @is_principal_ideal_ring.{0} (has_zero.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type ring.{0} h0 (has_zero.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_65971 (h0 : semiring (measurable_space empty)) : is_noetherian_ring (measurable_space empty) := sorry --non-trivial
lemma new_lemma_65972 (h0 : monoid (with_bot (random_gen num))) : monoid.fg (with_bot (random_gen num)) := sorry --non-trivial
lemma new_lemma_65973 (h0 : topological_space (add_cancel_monoid (has_bot (option empty)))) : t1_space (add_cancel_monoid (has_bot (option empty))) := sorry --non-trivial
lemma new_lemma_65974 (h1 : ring (normed_field (simple_graph reducibility_hints))) : strong_rank_condition (normed_field (simple_graph reducibility_hints)) := sorry --non-trivial
lemma new_lemma_65975 (h0 : function.extfun Type ordered_add_comm_monoid) : @archimedean.{0} (canonically_linear_ordered_monoid.{0} unsigned) (@function.extfun_app.{2 1} Type ordered_add_comm_monoid.{0} h0 (canonically_linear_ordered_monoid.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_65976 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @complete_lattice.is_Sup_finite_compact.{0} (has_norm.{0} fun_info) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (has_norm.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_65977 (h0 : functor.add_const (topological_space (id empty)) empty) : @irreducible_space.{0} (@id.{2} Type empty) (@functor.add_const.run.{0 0} (topological_space.{0} (@id.{2} Type empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_65978 (h0 : functor.add_const (topological_space (has_neg unsigned)) linarith.comp) : @sequential_space.{0} (has_neg.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (has_neg.{0} unsigned)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_65979 (h0 : complete_lattice (canonically_ordered_add_monoid (option (option (option (option empty)))))) : is_atomistic (canonically_ordered_add_monoid (option (option (option (option empty))))) := sorry --non-trivial
lemma new_lemma_65980 (h0 : functor.add_const (function.extfun Type monoid) (boolean_algebra linarith.comp)) : @monoid.fg.{0} (normed_comm_ring.{0} linarith.comp) (@function.extfun_app.{2 1} Type monoid.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type monoid.{0}) (boolean_algebra.{0} linarith.comp) h0) (normed_comm_ring.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_65981 (h0 : uniform_space (has_well_founded (denumerable (comm_ring (denumerable reducibility_hints))))) : complete_space (has_well_founded (denumerable (comm_ring (denumerable reducibility_hints)))) := sorry --non-trivial
lemma new_lemma_65982 (h0 : complete_lattice (has_to_string (has_add name))) : is_compactly_generated (has_to_string (has_add name)) := sorry --non-trivial
lemma new_lemma_65983 (h0 : function.extfun (finset Type) (has_mem.mem (has_emptyc num))) : @complete_space.{0} (has_emptyc.{0} num) (@finset.pi.empty.{1 0} Type uniform_space.{0} (has_emptyc.{0} num) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (has_emptyc.{0} num)) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_65984 (h0 : add_group (add_comm_semigroup (mul_one_class fun_info))) : is_add_cyclic (add_comm_semigroup (mul_one_class fun_info)) := sorry --non-trivial
lemma new_lemma_65985 (h0 : not (function.extfun Type uniform_space -> false)) : @complete_space.{0} (metric_space.{0} num) (@function.extfun_app.{2 1} Type uniform_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type uniform_space.{0}) h0) (metric_space.{0} num))  := sorry --non-trivial
lemma new_lemma_65986 (h0 : add_group (uniform_space (random_gen char))) : is_add_cyclic (uniform_space (random_gen char)) := sorry --non-trivial
lemma new_lemma_65987 (h0 : complete_lattice (normed_field string.iterator_imp)) : complete_lattice.is_Sup_finite_compact (normed_field string.iterator_imp) := sorry --non-trivial
lemma new_lemma_65988 (h0 : functor.add_const (ring (has_star empty)) num) : @is_principal_ideal_ring.{0} (has_star.{0} empty) (@functor.add_const.run.{0 0} (ring.{0} (has_star.{0} empty)) num h0)  := sorry --non-trivial
lemma new_lemma_65989 (h0 : topological_space (mul_zero_class (has_add unsigned))) : preirreducible_space (mul_zero_class (has_add unsigned)) := sorry --non-trivial
lemma new_lemma_65990 (h0 : topological_space char) (h2 : preorder char) : order_topology char := sorry --non-trivial
lemma new_lemma_65991 (h0 : functor.add_const (filter (ordered_comm_group empty)) empty) : filter.ne_bot (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_65992 (h0 : group (has_top (has_top fun_info))) : normalizer_condition (has_top (has_top fun_info)) := sorry --non-trivial
lemma new_lemma_65993 (h0 : monoid ordering) : monoid.fg ordering := sorry --non-trivial
lemma new_lemma_65994 (h0 : filter (is_R_or_C congr_arg_kind)) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_65995 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @topological_space.separable_space.{0} (boolean_algebra.core.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (boolean_algebra.core.{0} name))  := sorry --non-trivial
lemma new_lemma_65996 (h0 : functor.add_const (finset (left_cancel_monoid congr_arg_kind)) congr_arg_kind) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_65997 (h0 : functor.add_const (add_monoid (canonically_ordered_comm_semiring ennreal)) Type) : @add_monoid.fg.{0} (canonically_ordered_comm_semiring.{0} ennreal) (@functor.add_const.run.{0 1} (add_monoid.{0} (canonically_ordered_comm_semiring.{0} ennreal)) Type h0)  := sorry --non-trivial
lemma new_lemma_65998 (h0 : not (group (complete_semilattice_Sup unsigned) -> false)) : @is_cyclic.{0} (complete_semilattice_Sup.{0} unsigned) (@classical.by_contradiction'.{1} (group.{0} (complete_semilattice_Sup.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_65999 (h0 : group (has_append (has_nnnorm fun_info))) : is_cyclic (has_append (has_nnnorm fun_info)) := sorry --non-trivial
lemma new_lemma_66000 (h0 : semiring std_gen) (h1 : std_gen -> fun_info) (h2 : coe_sort (set.range h1)) : even (set.range_splitting h1 h2) := sorry --non-trivial
lemma new_lemma_66001 (h0 : functor.add_const (topological_space (partial_order congr_arg_kind)) empty) : @path_connected_space.{0} (partial_order.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (partial_order.{0} congr_arg_kind)) empty h0)  := sorry --non-trivial
lemma new_lemma_66002 (h0 : functor.add_const (topological_space auto.case_option) num) : @normal_space.{0} auto.case_option (@functor.add_const.run.{0 0} (topological_space.{0} auto.case_option) num h0)  := sorry --non-trivial
lemma new_lemma_66003 (h0 : ring (boolean_algebra linarith.comp)) : strong_rank_condition (boolean_algebra linarith.comp) := sorry --non-trivial
lemma new_lemma_66004 (h0 : topological_space (add_cancel_monoid (finset (finset pos)))) : preirreducible_space (add_cancel_monoid (finset (finset pos))) := sorry --non-trivial
lemma new_lemma_66005 (h0 : ring (semi_normed_comm_ring char)) : rank_condition (semi_normed_comm_ring char) := sorry --non-trivial
lemma new_lemma_66006 (h0 : functor.add_const (functor.add_const (topological_space name) num) empty) : @totally_separated_space.{0} name (@functor.add_const.run.{0 0} (topological_space.{0} name) num (@functor.add_const.run.{0 0} (functor.add_const.{0 0} (topological_space.{0} name) num) empty h0))  := sorry --non-trivial
lemma new_lemma_66007 (h0 : has_mem.mem topological_space has_emptyc.emptyc) : @path_connected_space.{0} (semiring.{0} fun_info) (@function.extfun_app.{2 1} Type topological_space.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) topological_space.{0} h0) (semiring.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_66008 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : finset.nonempty (function.extfun_app (function.extfun_app h0 finset) (has_to_string num)) := sorry --non-trivial
lemma new_lemma_66009 (h0 : ring unsigned -> ring unsigned -> Prop) : is_irrefl (ring unsigned) h0 := sorry --non-trivial
lemma new_lemma_66010 (h0 : fin has_zero.zero) : @topological_space.separable_space.{0} (sub_neg_monoid.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@matrix.vec_empty.{1} (function.extfun.{2 1} Type topological_space.{0}) h0) (sub_neg_monoid.{0} pos))  := sorry --non-trivial
lemma new_lemma_66011 (h0 : has_lt (has_ssubset linarith.comp_source)) : no_max_order (has_ssubset linarith.comp_source) := sorry --non-trivial
lemma new_lemma_66012 (h0 : topological_space (canonically_ordered_monoid (has_add pos))) : sequential_space (canonically_ordered_monoid (has_add pos)) := sorry --non-trivial
lemma new_lemma_66013 (h0 : topological_space (filter empty)) : discrete_topology (filter empty) := sorry --non-trivial
lemma new_lemma_66014 (h0 : ring (finset (has_Inf (has_pos_part linarith.comp)))) : is_domain (finset (has_Inf (has_pos_part linarith.comp))) := sorry --non-trivial
lemma new_lemma_66015 (h0 : function.extfun Type add_group) : @is_add_cyclic.{0} (has_sub.{0} unsigned) (@function.extfun_app.{2 1} Type add_group.{0} h0 (has_sub.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_66016 (h0 : function.extfun Type topological_space) : @preconnected_space.{0} (canonically_linear_ordered_monoid.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (canonically_linear_ordered_monoid.{0} pos))  := sorry --non-trivial
lemma new_lemma_66017 (h0 : uniform_space (metric_space linarith.comp)) : separated_space (metric_space linarith.comp) := sorry --non-trivial
lemma new_lemma_66018 (h0 : topological_space (complete_semilattice_Sup (has_top linarith.comp_source))) : path_connected_space (complete_semilattice_Sup (has_top linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_66019 (h0 : function.extfun (Type 1) (functor.comp group cancel_monoid)) : @normalizer_condition.{1} (cancel_monoid.{1} Type) (@functor.comp.run.{1 1 1} group.{1} cancel_monoid.{1} Type (@function.extfun_app.{3 2} (Type 1) (functor.comp.{1 1 1} group.{1} cancel_monoid.{1}) h0 Type))  := sorry --non-trivial
lemma new_lemma_66020 (h0 : complete_lattice (linear_order unsigned)) : is_atomistic (linear_order unsigned) := sorry --non-trivial
lemma new_lemma_66021 (h0 : topological_space (has_bot (has_neg name))) : loc_path_connected_space (has_bot (has_neg name)) := sorry --non-trivial
lemma new_lemma_66022 (h0 : topological_space (canonically_ordered_comm_semiring (canonically_ordered_comm_semiring pos))) : locally_compact_space (canonically_ordered_comm_semiring (canonically_ordered_comm_semiring pos)) := sorry --non-trivial
lemma new_lemma_66023 (h0 : function.extfun Type topological_space) : @totally_disconnected_space.{0} (has_edist.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_edist.{0} empty))  := sorry --non-trivial
lemma new_lemma_66024 (h0 : topological_space (sub_neg_monoid (has_add Type))) : preconnected_space (sub_neg_monoid (has_add Type)) := sorry --non-trivial
lemma new_lemma_66025 (h0 : functor.add_const (add_group (has_neg pos)) name) : @is_add_cyclic.{0} (has_neg.{0} pos) (@functor.add_const.run.{0 0} (add_group.{0} (has_neg.{0} pos)) name h0)  := sorry --non-trivial
lemma new_lemma_66026 (h1 : ring (has_nnnorm (random_gen (has_ssubset string_imp)))) : is_domain (has_nnnorm (random_gen (has_ssubset string_imp))) := sorry --non-trivial
lemma new_lemma_66027 (h0 : functor.add_const (list (comm_group environment.implicit_infer_kind)) Type) : list.nodup (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_66028 (h0 : topological_space (semi_normed_ring (mul_one_class fun_info))) : t0_space (semi_normed_ring (mul_one_class fun_info)) := sorry --non-trivial
lemma new_lemma_66029 (h0 h1 : multiset (has_compl (has_lt linarith.comp_source))) : multiset.subset h0 h1 := sorry --non-trivial
lemma new_lemma_66030 (h0 : ring (canonically_ordered_comm_semiring (has_add (has_add Type)))) : rank_condition (canonically_ordered_comm_semiring (has_add (has_add Type))) := sorry --non-trivial
lemma new_lemma_66031 (h0 : function.extfun Type ring) : @is_domain.{0} (cancel_monoid.{0} pos) (@function.extfun_app.{2 1} Type ring.{0} h0 (cancel_monoid.{0} pos))  := sorry --non-trivial
lemma new_lemma_66032 (h0 : functor.add_const (topological_space (has_nndist environment.implicit_infer_kind)) (has_neg name)) : @locally_compact_space.{0} (has_nndist.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (has_nndist.{0} environment.implicit_infer_kind)) (has_neg.{0} name) h0)  := sorry --non-trivial
lemma new_lemma_66033 (h0 : uniform_space (non_unital_non_assoc_semiring (mul_one_class enat))) : complete_space (non_unital_non_assoc_semiring (mul_one_class enat)) := sorry --non-trivial
lemma new_lemma_66034 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @group.fg.{0} (has_to_string.{0} ennreal) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (has_to_string.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_66035 (h0 : filter (with_bot (semiring congr_arg_kind))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_66036 (h0 : ordered_comm_monoid (has_add (has_Inf name))) : has_exists_mul_of_le (has_add (has_Inf name)) := sorry --non-trivial
lemma new_lemma_66037 (h0 : set (has_bot (dlist (mul_one_class (has_star environment.projection_info))))) : set.finite h0 := sorry --non-trivial
lemma new_lemma_66038 (h0 : topological_space (monoid congr_arg_kind)) : preconnected_space (monoid congr_arg_kind) := sorry --non-trivial
lemma new_lemma_66039 (h0 : topological_space (has_add (has_add (has_add name)))) : locally_compact_space (has_add (has_add (has_add name))) := sorry --non-trivial
lemma new_lemma_66040 (h0 : topological_space (semi_normed_ring (random_gen reducibility_hints))) : t0_space (semi_normed_ring (random_gen reducibility_hints)) := sorry --non-trivial
lemma new_lemma_66041 (h0 : topological_space (finset (finset environment.implicit_infer_kind))) : normal_space (finset (finset environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_66042 (h0 : uniform_space (has_emptyc (has_top fun_info))) : complete_space (has_emptyc (has_top fun_info)) := sorry --non-trivial
lemma new_lemma_66043 (h0 : topological_space (semiring (has_top (has_top (has_top to_additive.value_type))))) : locally_compact_space (semiring (has_top (has_top (has_top to_additive.value_type)))) := sorry --non-trivial
lemma new_lemma_66044 (h0 : function.extfun Type topological_space) : @loc_path_connected_space.{0} (complete_distrib_lattice.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (complete_distrib_lattice.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_66045 (h0 : topological_space (finset (has_add real))) : topological_space.separable_space (finset (has_add real)) := sorry --non-trivial
lemma new_lemma_66046 (h0 : ordered_add_comm_monoid (has_bot (has_add name))) : archimedean (has_bot (has_add name)) := sorry --non-trivial
lemma new_lemma_66047 (h0 : function.extfun Type ring) : @rank_condition.{0} (has_inter.{0} unsigned) (@function.extfun_app.{2 1} Type ring.{0} h0 (has_inter.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_66048 (h0 : not (filter occurrences -> false)) : filter.ne_bot (classical.by_contradiction' h0) := sorry --non-trivial
lemma new_lemma_66049 (h0 : topological_space (has_zero (boolean_algebra (add_comm_monoid Type)))) : discrete_topology (has_zero (boolean_algebra (add_comm_monoid Type))) := sorry --non-trivial
lemma new_lemma_66050 (h0 : topological_space (distrib (mul_one_class (has_nnnorm string.iterator_imp)))) : path_connected_space (distrib (mul_one_class (has_nnnorm string.iterator_imp))) := sorry --non-trivial
lemma new_lemma_66051 (h0 : function.extfun Type topological_space) : @preirreducible_space.{0} znum (@function.extfun_app.{2 1} Type topological_space.{0} h0 znum)  := sorry --non-trivial
lemma new_lemma_66052 (h0 : ring (has_ssubset (has_ssubset (has_ssubset linarith.comp_source)))) : rank_condition (has_ssubset (has_ssubset (has_ssubset linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_66053 (h0 : ring (comm_group (add_comm_monoid Type))) : is_domain (comm_group (add_comm_monoid Type)) := sorry --non-trivial
lemma new_lemma_66054 (h0 : filter (complete_linear_order (semiring (semiring congr_arg_kind)))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_66055 (h0 : function.extfun Type group) : @normalizer_condition.{0} (partial_order.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type group.{0} h0 (partial_order.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_66056 (h0 : list (has_add unsigned)) : palindrome h0 := sorry --non-trivial
lemma new_lemma_66057 (h0 : group (add_left_cancel_monoid (has_nnnorm linarith.comp_source))) : is_cyclic (add_left_cancel_monoid (has_nnnorm linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_66058 (h0 : complete_lattice (has_le fun_info)) : complete_lattice.is_Sup_finite_compact (has_le fun_info) := sorry --non-trivial
lemma new_lemma_66059 (h0 : functor.add_const (ring (preorder num)) congr_arg_kind) : @rank_condition.{0} (preorder.{0} num) (@functor.add_const.run.{0 0} (ring.{0} (preorder.{0} num)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_66060 (h0 : functor.add_const (function.extfun (Type 1) topological_space) linarith.comp) : @irreducible_space.{1} (has_nndist.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) topological_space.{1}) linarith.comp h0) (has_nndist.{1} Type))  := sorry --non-trivial
lemma new_lemma_66061 (h1 : topological_space (linear_ordered_add_comm_group string_imp)) : totally_disconnected_space (linear_ordered_add_comm_group string_imp) := sorry --non-trivial
lemma new_lemma_66062 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @t1_space.{0} (ring.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (ring.{0} pos))  := sorry --non-trivial
lemma new_lemma_66063 (h0 : functor.add_const (uniform_space (has_neg_part name)) Type) : @separated_space.{0} (has_neg_part.{0} name) (@functor.add_const.run.{0 1} (uniform_space.{0} (has_neg_part.{0} name)) Type h0)  := sorry --non-trivial
lemma new_lemma_66064 (h0 : cancel_comm_monoid_with_zero (has_nndist (option (option pos)))) : unique_factorization_monoid (has_nndist (option (option pos))) := sorry --non-trivial
lemma new_lemma_66065 (h0 : functor.add_const (ordered_comm_monoid (boolean_algebra.core Type)) Type) : @has_exists_mul_of_le.{1} (boolean_algebra.core.{1} Type) (@functor.add_const.run.{1 1} (ordered_comm_monoid.{1} (boolean_algebra.core.{1} Type)) Type h0)  := sorry --non-trivial
lemma new_lemma_66066 (h0 : function.extfun nat fin) : @has_exists_mul_of_le.{0} (ordered_comm_monoid.{0} (has_Inf.{0} name)) (@matrix.vec_empty.{0} (ordered_comm_monoid.{0} (ordered_comm_monoid.{0} (has_Inf.{0} name))) (@function.extfun_app.{1 1} nat fin (@matrix.vec_empty.{0} (function.extfun.{1 1} nat fin) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero))) (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_66067 (h0 : group (finset (has_Inf Type))) : group.fg (finset (has_Inf Type)) := sorry --non-trivial
lemma new_lemma_66068 (h0 : function.extfun (Type 1) group) : @group.fg.{1} (cancel_monoid.{1} Type) (@function.extfun_app.{3 2} (Type 1) group.{1} h0 (cancel_monoid.{1} Type))  := sorry --non-trivial
lemma new_lemma_66069 (h0 : ring (has_add (finset Type))) : is_domain (has_add (finset Type)) := sorry --non-trivial
lemma new_lemma_66070 (h0 : topological_space (ring (ring (has_add (has_add environment.implicit_infer_kind))))) : regular_space (ring (ring (has_add (has_add environment.implicit_infer_kind)))) := sorry --non-trivial
lemma new_lemma_66071 (h0 : topological_space (encodable (linear_ordered_comm_monoid_with_zero empty))) : preirreducible_space (encodable (linear_ordered_comm_monoid_with_zero empty)) := sorry --non-trivial
lemma new_lemma_66072 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @t0_space.{0} (encodable.{0} string_imp) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (encodable.{0} string_imp))  := sorry --non-trivial
lemma new_lemma_66073 (h0 : functor.add_const (ordered_add_comm_monoid (has_edist unsigned)) unsigned) : @archimedean.{0} (has_edist.{0} unsigned) (@functor.add_const.run.{0 0} (ordered_add_comm_monoid.{0} (has_edist.{0} unsigned)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_66074 (h0 : ring (has_union (semiring (semiring empty)))) : is_domain (has_union (semiring (semiring empty))) := sorry --non-trivial
lemma new_lemma_66075 (h1 : complete_lattice (semiring congr_arg_kind)) : is_compactly_generated (semiring congr_arg_kind) := sorry --non-trivial
lemma new_lemma_66076 (h0 : topological_space (random_gen unsigned)) : normal_space (random_gen unsigned) := sorry --non-trivial
lemma new_lemma_66077 (h0 : ring (random_gen fun_info)) : rank_condition (random_gen fun_info) := sorry --non-trivial
lemma new_lemma_66078 (h0 : ring (has_emptyc (with_one (has_emptyc num)))) : is_domain (has_emptyc (with_one (has_emptyc num))) := sorry --non-trivial
lemma new_lemma_66079 (h0 : functor.add_const (functor.add_const Prop (ring Type)) (has_add Type)) : functor.add_const.run (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_66080 (h0 : functor.add_const (complete_lattice (semigroup linarith.comp)) pos) : @complete_lattice.is_Sup_finite_compact.{0} (semigroup.{0} linarith.comp) (@functor.add_const.run.{0 0} (complete_lattice.{0} (semigroup.{0} linarith.comp)) pos h0)  := sorry --non-trivial
lemma new_lemma_66081 (h0 : topological_space (finset (has_add environment.implicit_infer_kind))) : normal_space (finset (has_add environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_66082 (h0 h1 : multiset (has_nnnorm fun_info)) : multiset.disjoint h0 h1 := sorry --non-trivial
lemma new_lemma_66083 (h0 : group (cancel_monoid congr_arg_kind)) : is_simple_group (cancel_monoid congr_arg_kind) := sorry --non-trivial
lemma new_lemma_66084 (h0 : add_group (add_comm_semigroup (add_comm_semigroup (mul_one_class string.iterator_imp)))) : is_add_cyclic (add_comm_semigroup (add_comm_semigroup (mul_one_class string.iterator_imp))) := sorry --non-trivial
lemma new_lemma_66085 (h0 : group (linear_ordered_comm_monoid_with_zero (option empty))) : is_cyclic (linear_ordered_comm_monoid_with_zero (option empty)) := sorry --non-trivial
lemma new_lemma_66086 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_noetherian_ring.{0} (has_one.{0} num) (@function.extfun_app.{2 1} Type semiring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 semiring.{0}) (has_one.{0} num))  := sorry --non-trivial
lemma new_lemma_66087 (h0 : has_compl (has_compl string_imp) -> string_imp) : function.bijective h0 := sorry --non-trivial
lemma new_lemma_66088 (h0 : complete_lattice (has_union (has_top empty))) : is_atomistic (has_union (has_top empty)) := sorry --non-trivial
lemma new_lemma_66089 (h0 : functor.add_const (uniform_space (add_cancel_monoid nnreal)) linarith.comp) : @separated_space.{0} (add_cancel_monoid.{0} nnreal) (@functor.add_const.run.{0 0} (uniform_space.{0} (add_cancel_monoid.{0} nnreal)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_66090 (h0 : functor.add_const (topological_space (has_zero Type)) linarith.comp) : @path_connected_space.{1} (has_zero.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (has_zero.{1} Type)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_66091 (h0 : add_monoid (ordered_comm_monoid (has_add linarith.comp))) : add_monoid.fg (ordered_comm_monoid (has_add linarith.comp)) := sorry --non-trivial
lemma new_lemma_66092 (h0 : ordered_comm_monoid (canonically_linear_ordered_monoid unsigned)) : has_exists_mul_of_le (canonically_linear_ordered_monoid unsigned) := sorry --non-trivial
lemma new_lemma_66093 (h0 : topological_space (simple_graph real)) : preirreducible_space (simple_graph real) := sorry --non-trivial
lemma new_lemma_66094 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @t0_space.{0} (has_top.{0} fun_info) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_top.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_66095 (h0 : functor.add_const (uniform_space (preorder num)) (semiring (semiring empty))) : @complete_space.{0} (preorder.{0} num) (@functor.add_const.run.{0 0} (uniform_space.{0} (preorder.{0} num)) (semiring.{0} (semiring.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_66096 (h0 : empty) (h1 : set Type) : @right_add_coset_equivalence.{1} Type (@empty.elim.{2} (has_add.{1} Type) h0) h1 (normed_lattice_add_comm_group.{0} Prop) char  := sorry --non-trivial
lemma new_lemma_66097 (h1 : function.extfun (Type -> Type) (function.extfun Type)) (h2 : to_additive.value_type -> Prop) : @finset.inf.{0 0} Prop to_additive.value_type (@lattice.to_semilattice_inf.{0} Prop (@conditionally_complete_lattice.to_lattice.{0} Prop (@complete_lattice.to_conditionally_complete_lattice.{0} Prop Prop.complete_lattice))) (@bounded_order.to_order_top.{0} Prop (@preorder.to_has_le.{0} Prop (@partial_order.to_preorder.{0} Prop (@semilattice_inf.to_partial_order.{0} Prop (@lattice.to_semilattice_inf.{0} Prop (@conditionally_complete_lattice.to_lattice.{0} Prop (@complete_lattice.to_conditionally_complete_lattice.{0} Prop Prop.complete_lattice)))))) Prop.bounded_order) (@function.extfun_app.{2 1} Type finset.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h1 finset.{0}) to_additive.value_type) h2  := sorry --non-trivial
lemma new_lemma_66098 (h0 : topological_space (add_right_cancel_monoid empty)) : discrete_topology (add_right_cancel_monoid empty) := sorry --non-trivial
lemma new_lemma_66099 (h0 : functor.add_const (ring (has_add name)) Type) : @rank_condition.{0} (has_add.{0} name) (@functor.add_const.run.{0 1} (ring.{0} (has_add.{0} name)) Type h0)  := sorry --non-trivial
lemma new_lemma_66100 (h0 : function.extfun nat fin) : @is_cyclic.{1} (add_comm_monoid.{1} Type) (@matrix.vec_empty.{1} (group.{1} (add_comm_monoid.{1} Type)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_66101 (h0 : function.extfun Type topological_space) : @loc_path_connected_space.{0} (group_with_zero.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (group_with_zero.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_66102 (h0 : fin has_zero.zero) : @preirreducible_space.{0} (normed_lattice_add_comm_group.{0} real) (@function.extfun_app.{2 1} Type topological_space.{0} (@matrix.vec_empty.{1} (function.extfun.{2 1} Type topological_space.{0}) (@matrix.vec_empty.{0} (fin (@has_zero.zero.{0} nat nat.has_zero)) h0)) (normed_lattice_add_comm_group.{0} real))  := sorry --non-trivial
lemma new_lemma_66103 (h1 : not (topological_space (normed_field linarith.comp_source) -> false)) : @t0_space.{0} (normed_field.{0} linarith.comp_source) (@classical.by_contradiction'.{1} (topological_space.{0} (normed_field.{0} linarith.comp_source)) h1)  := sorry --non-trivial
lemma new_lemma_66104 (h1 : function.extfun Type topological_space) : @normal_space.{0} (measurable_space.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} h1 (measurable_space.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_66105 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @normalizer_condition.{0} (has_top.{0} linarith.ineq) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (has_top.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_66106 (h0 : functor.add_const (function.extfun Type group) (boolean_algebra.core (has_add pos))) : @group.fg.{0} (canonically_ordered_comm_semiring.{0} pos) (@function.extfun_app.{2 1} Type group.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type group.{0}) (boolean_algebra.core.{0} (has_add.{0} pos)) h0) (canonically_ordered_comm_semiring.{0} pos))  := sorry --non-trivial
lemma new_lemma_66107 (h0 : functor.add_const (group (option empty)) empty) : @group.fg.{0} (option.{0} empty) (@functor.add_const.run.{0 0} (group.{0} (option.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_66108 (h0 : functor.add_const (filter (has_zero environment.implicit_infer_kind)) name) : filter.ne_bot (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_66109 (h0 : not (topological_space (normed_field reducibility_hints) -> false)) : @t0_space.{0} (normed_field.{0} reducibility_hints) (@classical.by_contradiction'.{1} (topological_space.{0} (normed_field.{0} reducibility_hints)) h0)  := sorry --non-trivial
lemma new_lemma_66110 (h0 : uniform_space (has_compl std_gen)) : complete_space (has_compl std_gen) := sorry --non-trivial
lemma new_lemma_66111 (h0 : function.extfun Type filter) : filter.ne_bot (function.extfun_app h0 (as_linear_order empty)) := sorry --non-trivial
lemma new_lemma_66112 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @group.fg.{0} (has_edist.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (has_edist.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_66113 (h0 : complete_lattice (with_bot (random_gen to_additive.value_type))) : is_atomistic (with_bot (random_gen to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_66114 (h0 : topological_space (simple_graph (has_compl fun_info))) : t0_space (simple_graph (has_compl fun_info)) := sorry --non-trivial
lemma new_lemma_66115 (h0 : add_group (ordered_comm_ring (has_nndist (ordered_ring (has_add Type))))) : is_add_cyclic (ordered_comm_ring (has_nndist (ordered_ring (has_add Type)))) := sorry --non-trivial
lemma new_lemma_66116 (h0 : not (topological_space (linear_ordered_comm_ring empty) -> false)) : @irreducible_space.{0} (linear_ordered_comm_ring.{0} empty) (@classical.by_contradiction'.{1} (topological_space.{0} (linear_ordered_comm_ring.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_66117 (h0 : add_monoid (has_one (semiring empty))) : add_monoid.fg (has_one (semiring empty)) := sorry --non-trivial
lemma new_lemma_66118 (h0 : not (function.extfun Type ring -> false)) : @strong_rank_condition.{0} empty (@function.extfun_app.{2 1} Type ring.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type ring.{0}) h0) empty)  := sorry --non-trivial
lemma new_lemma_66119 (h0 : group (add_comm_monoid (finset Type))) : is_cyclic (add_comm_monoid (finset Type)) := sorry --non-trivial
lemma new_lemma_66120 (h0 : functor.add_const (function.extfun Type topological_space) Type) : @preconnected_space.{0} (has_zero.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type topological_space.{0}) Type h0) (has_zero.{0} name))  := sorry --non-trivial
lemma new_lemma_66121 (h0 : functor.add_const (ring (preorder num)) congr_arg_kind) : @is_domain.{0} (preorder.{0} num) (@functor.add_const.run.{0 0} (ring.{0} (preorder.{0} num)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_66122 (h0 : add_monoid (plift empty)) : add_monoid.fg (plift empty) := sorry --non-trivial
lemma new_lemma_66123 (h0 : uniform_space (canonically_linear_ordered_monoid (option (option (option num))))) : complete_space (canonically_linear_ordered_monoid (option (option (option num)))) := sorry --non-trivial
lemma new_lemma_66124 (h0 : has_inv linarith.comp_source -> Prop) : Exists h0 := sorry --non-trivial
lemma new_lemma_66125 (h0 : function.extfun Type topological_space) : @preconnected_space.{0} (has_inter.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_inter.{0} num))  := sorry --non-trivial
lemma new_lemma_66126 (h0 : function.extfun Type filter) : filter.ne_bot (function.extfun_app h0 (omega_complete_partial_order num)) := sorry --non-trivial
lemma new_lemma_66127 (h0 : topological_space (canonically_linear_ordered_add_monoid (option empty))) : totally_separated_space (canonically_linear_ordered_add_monoid (option empty)) := sorry --non-trivial
lemma new_lemma_66128 (h0 : topological_space (has_add (normed_comm_ring pos))) : locally_compact_space (has_add (normed_comm_ring pos)) := sorry --non-trivial
lemma new_lemma_66129 (h0 : functor.add_const (semiring (normed_comm_ring name)) (has_nndist Type)) : @is_noetherian_ring.{0} (normed_comm_ring.{0} name) (@functor.add_const.run.{0 1} (semiring.{0} (normed_comm_ring.{0} name)) (has_nndist.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_66130 (h0 : topological_space (canonically_linear_ordered_monoid name)) : path_connected_space (canonically_linear_ordered_monoid name) := sorry --non-trivial
lemma new_lemma_66131 (h0 : topological_space (has_zero unsigned)) : regular_space (has_zero unsigned) := sorry --non-trivial
lemma new_lemma_66132 (h0 : functor.add_const (topological_space (ordered_comm_ring pos)) pos) : @locally_compact_space.{0} (ordered_comm_ring.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (ordered_comm_ring.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_66133 (h0 : topological_space (has_div string_imp)) (h1 : preorder (has_div string_imp)) : order_topology (has_div string_imp) := sorry --non-trivial
lemma new_lemma_66134 (h0 : functor.add_const (function.extfun (Type 1) topological_space) pos) : @regular_space.{1} (finset.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) topological_space.{1}) pos h0) (finset.{1} Type))  := sorry --non-trivial
lemma new_lemma_66135 (h0 : functor.add_const (group (add_cancel_monoid linarith.comp)) Type) : @is_cyclic.{0} (add_cancel_monoid.{0} linarith.comp) (@functor.add_const.run.{0 1} (group.{0} (add_cancel_monoid.{0} linarith.comp)) Type h0)  := sorry --non-trivial
lemma new_lemma_66136 (h0 : has_coe ereal Prop) (h1 : ereal) : @coe_b.{1 1} ereal Prop h0 h1  := sorry --non-trivial
lemma new_lemma_66137 (h0 : topological_space (normed_field reducibility_hints)) : t0_space (normed_field reducibility_hints) := sorry --non-trivial
lemma new_lemma_66138 (h0 : topological_space linarith.comp) (h1 : function.extfun Type topological_space) : @totally_disconnected_space.{0} (@measure_theory.content.{0} linarith.comp h0) (@function.extfun_app.{2 1} Type topological_space.{0} h1 (@measure_theory.content.{0} linarith.comp h0))  := sorry --non-trivial
lemma new_lemma_66139 (h0 : topological_space (has_compl ereal)) : totally_disconnected_space (has_compl ereal) := sorry --non-trivial
lemma new_lemma_66140 (h0 : topological_space (monoid (option num))) : discrete_topology (monoid (option num)) := sorry --non-trivial
lemma new_lemma_66141 (h0 : not (topological_space (normed_group unsigned) -> false)) : @discrete_topology.{0} (normed_group.{0} unsigned) (@classical.by_contradiction'.{1} (topological_space.{0} (normed_group.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_66142 (h1 : complete_semilattice_Sup (denumerable to_additive.value_type) -> Prop) : @infi.{0 1} Prop (@conditionally_complete_lattice.to_has_Inf.{0} Prop (@complete_lattice.to_conditionally_complete_lattice.{0} Prop Prop.complete_lattice)) (complete_semilattice_Sup.{0} (denumerable.{0} to_additive.value_type)) h1  := sorry --non-trivial
lemma new_lemma_66143 (h0 : group (id (random_gen (random_gen fun_info)))) : group.fg (id (random_gen (random_gen fun_info))) := sorry --non-trivial
lemma new_lemma_66144 (h0 : prod (mul_zero_class pos) (mul_zero_class pos)) : id_rel h0 := sorry --non-trivial
lemma new_lemma_66145 (h0 : add_monoid (cancel_monoid (semigroup environment.implicit_infer_kind))) : add_monoid.fg (cancel_monoid (semigroup environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_66146 (h0 : functor.add_const (complete_lattice (has_zero Type)) pos) : @is_compactly_generated.{1} (has_zero.{1} Type) (@functor.add_const.run.{1 0} (complete_lattice.{1} (has_zero.{1} Type)) pos h0)  := sorry --non-trivial
lemma new_lemma_66147 (h0 : topological_space (canonically_linear_ordered_monoid congr_arg_kind)) : t0_space (canonically_linear_ordered_monoid congr_arg_kind) := sorry --non-trivial
lemma new_lemma_66148 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @preconnected_space.{0} (linear_ordered_field.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (linear_ordered_field.{0} num))  := sorry --non-trivial
lemma new_lemma_66149 (h0 : ordered_add_comm_monoid (has_zero (has_neg (boolean_algebra (has_add pos))))) : archimedean (has_zero (has_neg (boolean_algebra (has_add pos)))) := sorry --non-trivial
lemma new_lemma_66150 (h0 : function.extfun (nat -> Type) (function.extfun nat)) : @path_connected_space.{0} (sub_neg_monoid.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@matrix.vec_empty.{1} (function.extfun.{2 1} Type topological_space.{0}) (@function.extfun_app.{1 1} nat fin (@function.extfun_app.{2 1} (nat → Type) (function.extfun.{1 1} nat) h0 fin) (@has_zero.zero.{0} nat nat.has_zero))) (sub_neg_monoid.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_66151 (h0 : function.extfun Type ring) : @strong_rank_condition.{0} (with_one.{0} num) (@function.extfun_app.{2 1} Type ring.{0} h0 (with_one.{0} num))  := sorry --non-trivial
lemma new_lemma_66152 (h0 : not (uniform_space (semiring (has_top num)) -> false)) : @separated_space.{0} (semiring.{0} (has_top.{0} num)) (@classical.by_contradiction'.{1} (uniform_space.{0} (semiring.{0} (has_top.{0} num))) h0)  := sorry --non-trivial
lemma new_lemma_66153 (h0 : topological_space (has_Inf (ordered_ring (ring (ring Type))))) : normal_space (has_Inf (ordered_ring (ring (ring Type)))) := sorry --non-trivial
lemma new_lemma_66154 (h0 : monoid (measurable_space to_additive.value_type)) : monoid.fg (measurable_space to_additive.value_type) := sorry --non-trivial
lemma new_lemma_66155 (h0 : function.extfun Type uniform_space) : @complete_space.{0} (semigroup.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (semigroup.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_66156 (h0 : topological_space (has_compl string.iterator_imp)) : path_connected_space (has_compl string.iterator_imp) := sorry --non-trivial
lemma new_lemma_66157 (h0 : complete_lattice (encodable (has_nnnorm linarith.ineq))) : complete_lattice.is_Sup_finite_compact (encodable (has_nnnorm linarith.ineq)) := sorry --non-trivial
lemma new_lemma_66158 (h0 : group (has_inv (has_ssubset (random_gen (random_gen (random_gen (random_gen (has_top char)))))))) : group.fg (has_inv (has_ssubset (random_gen (random_gen (random_gen (random_gen (has_top char))))))) := sorry --non-trivial
lemma new_lemma_66159 (h0 : function.extfun (Type 1) topological_space) : @totally_disconnected_space.{1} (plift.{1} congr_arg_kind) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} h0 (plift.{1} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_66160 (h0 : function.extfun nat fin) : @archimedean.{0} (add_comm_monoid.{0} real) (@matrix.vec_empty.{0} (ordered_add_comm_monoid.{0} (add_comm_monoid.{0} real)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_66161 (h0 : uniform_space (add_semigroup empty)) : separated_space (add_semigroup empty) := sorry --non-trivial
lemma new_lemma_66162 (h0 : topological_space (option num)) : totally_separated_space (option num) := sorry --non-trivial
lemma new_lemma_66163 (h0 : function.extfun (Type 1) (functor.comp ring comm_group)) : @is_domain.{1} (comm_group.{1} Type) (@functor.comp.run.{1 1 1} ring.{1} comm_group.{1} Type (@function.extfun_app.{3 2} (Type 1) (functor.comp.{1 1 1} ring.{1} comm_group.{1}) h0 Type))  := sorry --non-trivial
lemma new_lemma_66164 (h0 : topological_space (has_neg_part (boolean_algebra (semigroup name)))) : preconnected_space (has_neg_part (boolean_algebra (semigroup name))) := sorry --non-trivial
lemma new_lemma_66165 (h0 : function.extfun Type topological_space) : @totally_separated_space.{0} (random_gen.{0} fun_info) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (random_gen.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_66166 (h0 : functor.add_const (uniform_space (has_zero linarith.comp)) Type) : @separated_space.{0} (has_zero.{0} linarith.comp) (@functor.add_const.run.{0 1} (uniform_space.{0} (has_zero.{0} linarith.comp)) Type h0)  := sorry --non-trivial
lemma new_lemma_66167 (h0 : functor.add_const (topological_space (complete_distrib_lattice pos)) environment.implicit_infer_kind) : @totally_separated_space.{0} (complete_distrib_lattice.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (complete_distrib_lattice.{0} pos)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_66168 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @complete_lattice.is_Sup_finite_compact.{0} (free_add_monoid.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (free_add_monoid.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_66169 (h0 : list (has_add (has_neg linarith.comp))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_66170 (h0 : functor.add_const (topological_space (add_cancel_monoid linarith.comp)) linarith.comp) : @totally_disconnected_space.{0} (add_cancel_monoid.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (add_cancel_monoid.{0} linarith.comp)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_66171 (h0 : uniform_space (comm_semigroup (comm_semigroup (sub_neg_monoid real)))) : complete_space (comm_semigroup (comm_semigroup (sub_neg_monoid real))) := sorry --non-trivial
lemma new_lemma_66172 (h0 : functor.add_const (complete_lattice (has_neg Type)) linarith.comp) : @is_compactly_generated.{1} (has_neg.{1} Type) (@functor.add_const.run.{1 0} (complete_lattice.{1} (has_neg.{1} Type)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_66173 (h0 : function.extfun Type topological_space) : @regular_space.{0} (mul_zero_class.{0} ennreal) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (mul_zero_class.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_66174 (h0 : functor.add_const (topological_space (bin_tree num)) empty) : @path_connected_space.{0} (bin_tree.{0} num) (@functor.add_const.run.{0 0} (topological_space.{0} (bin_tree.{0} num)) empty h0)  := sorry --non-trivial
lemma new_lemma_66175 (h0 : ring (boolean_algebra.core (finset (finset ennreal)))) : strong_rank_condition (boolean_algebra.core (finset (finset ennreal))) := sorry --non-trivial
lemma new_lemma_66176 (h0 : group (add_semigroup congr_arg_kind)) : group.fg (add_semigroup congr_arg_kind) := sorry --non-trivial
lemma new_lemma_66177 (h0 : not (topological_space (has_append (has_ssubset (has_nnnorm char))) -> false)) : @totally_disconnected_space.{0} (has_append.{0} (has_ssubset.{0} (has_nnnorm.{0} char))) (@classical.by_contradiction'.{1} (topological_space.{0} (has_append.{0} (has_ssubset.{0} (has_nnnorm.{0} char)))) h0)  := sorry --non-trivial
lemma new_lemma_66178 (h0 : function.extfun Type topological_space) : @t0_space.{0} (ordered_ring.{0} (option.{0} (option.{0} unsigned))) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (ordered_ring.{0} (option.{0} (option.{0} unsigned))))  := sorry --non-trivial
lemma new_lemma_66179 (h0 : functor.add_const (monoid (complete_distrib_lattice linarith.comp)) linarith.comp) : @monoid.fg.{0} (complete_distrib_lattice.{0} linarith.comp) (@functor.add_const.run.{0 0} (monoid.{0} (complete_distrib_lattice.{0} linarith.comp)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_66180 (h0 : function.extfun Type topological_space) : @normal_space.{0} (mul_zero_class.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (mul_zero_class.{0} name))  := sorry --non-trivial
lemma new_lemma_66181 (h0 : function.extfun Type uniform_space) : @complete_space.{0} (comm_group.{0} name) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (comm_group.{0} name))  := sorry --non-trivial
lemma new_lemma_66182 (h0 : function.extfun (finset Type) (has_mem.mem (linear_ordered_semiring num))) : @discrete_topology.{0} (linear_ordered_semiring.{0} num) (@finset.pi.empty.{1 0} Type topological_space.{0} (linear_ordered_semiring.{0} num) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (linear_ordered_semiring.{0} num)) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_66183 (h0 : not (group (div_inv_monoid fun_info) -> false)) : @group.fg.{0} (div_inv_monoid.{0} fun_info) (@classical.by_contradiction'.{1} (group.{0} (div_inv_monoid.{0} fun_info)) h0)  := sorry --non-trivial
lemma new_lemma_66184 (h0 : topological_space (comm_group (has_neg_part unsigned))) : normal_space (comm_group (has_neg_part unsigned)) := sorry --non-trivial
lemma new_lemma_66185 (h0 : not (ring (has_inv linarith.ineq) -> false)) : @is_domain.{0} (has_inv.{0} linarith.ineq) (@classical.by_contradiction'.{1} (ring.{0} (has_inv.{0} linarith.ineq)) h0)  := sorry --non-trivial
lemma new_lemma_66186 (h0 : function.extfun Type filter) : countable_Inter_filter (function.extfun_app h0 (linear_ordered_field pos)) := sorry --non-trivial
lemma new_lemma_66187 (h0 : set (set (add_comm_semigroup (add_comm_semigroup fun_info)))) (h1 : set (add_comm_semigroup (add_comm_semigroup fun_info))) : filter.generate_sets h0 h1 := sorry --non-trivial
lemma new_lemma_66188 (h0 : uniform_space (has_to_string (has_neg Type))) : complete_space (has_to_string (has_neg Type)) := sorry --non-trivial
lemma new_lemma_66189 (h0 : group (has_nnnorm (has_nnnorm (random_gen to_additive.value_type)))) : is_cyclic (has_nnnorm (has_nnnorm (random_gen to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_66190 (h0 : functor.comp ring has_add name) : @is_principal_ideal_ring.{0} (has_add.{0} name) (@functor.comp.run.{0 0 0} ring.{0} has_add.{0} name h0)  := sorry --non-trivial
lemma new_lemma_66191 (h0 : not (ring (add_left_cancel_monoid fun_info) -> false)) : @strong_rank_condition.{0} (add_left_cancel_monoid.{0} fun_info) (@classical.by_contradiction'.{1} (ring.{0} (add_left_cancel_monoid.{0} fun_info)) h0)  := sorry --non-trivial
lemma new_lemma_66192 (h1 : has_le (nondiscrete_normed_field enat)) (h2 : ring (order_bot (nondiscrete_normed_field enat))) : rank_condition (order_bot (nondiscrete_normed_field enat)) := sorry --non-trivial
lemma new_lemma_66193 (h1 : ring (non_unital_non_assoc_semiring (has_compl linarith.comp_source))) : rank_condition (non_unital_non_assoc_semiring (has_compl linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_66194 (h0 : functor.add_const (topological_space (boolean_algebra.core Type)) (has_neg environment.implicit_infer_kind)) : @sequential_space.{1} (boolean_algebra.core.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (boolean_algebra.core.{1} Type)) (has_neg.{0} environment.implicit_infer_kind) h0)  := sorry --non-trivial
lemma new_lemma_66195 (h0 : functor.add_const (semiring (canonically_ordered_comm_semiring Type)) name) : @is_noetherian_ring.{1} (canonically_ordered_comm_semiring.{1} Type) (@functor.add_const.run.{1 0} (semiring.{1} (canonically_ordered_comm_semiring.{1} Type)) name h0)  := sorry --non-trivial
lemma new_lemma_66196 (h0 : add_group (dlist (has_nnnorm (has_nnnorm (has_nnnorm linarith.ineq))))) : is_add_cyclic (dlist (has_nnnorm (has_nnnorm (has_nnnorm linarith.ineq)))) := sorry --non-trivial
lemma new_lemma_66197 (h0 : not (function.extfun Type topological_space -> false)) : @t0_space.{0} (measure_theory.measure_space.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (measure_theory.measure_space.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_66198 (h0 : group (has_one (semiring (semiring unsigned)))) : is_cyclic (has_one (semiring (semiring unsigned))) := sorry --non-trivial
lemma new_lemma_66199 (h0 : functor.add_const (monoid (canonically_ordered_comm_semiring Type)) linarith.comp) : @monoid.fg.{1} (canonically_ordered_comm_semiring.{1} Type) (@functor.add_const.run.{1 0} (monoid.{1} (canonically_ordered_comm_semiring.{1} Type)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_66200 (h0 : monoid (has_dist (option (option ennreal)))) : monoid.fg (has_dist (option (option ennreal))) := sorry --non-trivial
lemma new_lemma_66201 (h0 : topological_space (add_comm_semigroup (add_comm_semigroup environment.projection_info))) : t0_space (add_comm_semigroup (add_comm_semigroup environment.projection_info)) := sorry --non-trivial
lemma new_lemma_66202 (h0 : measurable_space (add_cancel_monoid Type)) (h1 : functor.add_const (measure_theory.measure (add_cancel_monoid Type)) linarith.comp) : measure_theory.is_probability_measure (functor.add_const.run h1) := sorry --non-trivial
lemma new_lemma_66203 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @topological_space.separable_space.{1} (normed_lattice_add_comm_group.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 topological_space.{1}) (normed_lattice_add_comm_group.{1} Type))  := sorry --non-trivial
lemma new_lemma_66204 (h0 : functor.add_const (function.extfun (Type 1) topological_space) (finset environment.implicit_infer_kind)) : @path_connected_space.{1} (comm_group.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) topological_space.{1}) (finset.{0} environment.implicit_infer_kind) h0) (comm_group.{1} Type))  := sorry --non-trivial
lemma new_lemma_66205 (h0 : list (has_bot (option empty))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_66206 (h0 : monoid (boolean_algebra.core (normed_comm_ring name))) : monoid.fg (boolean_algebra.core (normed_comm_ring name)) := sorry --non-trivial
lemma new_lemma_66207 (h0 : functor.add_const (topological_space (as_linear_order unsigned)) num) : @preirreducible_space.{0} (as_linear_order.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (as_linear_order.{0} unsigned)) num h0)  := sorry --non-trivial
lemma new_lemma_66208 (h1 : group (measurable_space (random_gen (random_gen (random_gen linarith.comp_source))))) : is_cyclic (measurable_space (random_gen (random_gen (random_gen linarith.comp_source)))) := sorry --non-trivial
lemma new_lemma_66209 (h0 : functor.add_const (finset (plift empty)) num) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_66210 (h0 : monoid (ordered_comm_monoid (has_Inf pos))) : monoid.fg (ordered_comm_monoid (has_Inf pos)) := sorry --non-trivial
lemma new_lemma_66211 (h0 : function.extfun Type topological_space) : @regular_space.{0} (boolean_algebra.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (boolean_algebra.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_66212 (h0 : topological_space (linear_ordered_cancel_comm_monoid empty)) : normal_space (linear_ordered_cancel_comm_monoid empty) := sorry --non-trivial
lemma new_lemma_66213 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : list.nodup (function.extfun_app (function.extfun_app h0 list) (denumerable to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_66214 (h0 : ring (div_inv_monoid (random_gen char))) : is_domain (div_inv_monoid (random_gen char)) := sorry --non-trivial
lemma new_lemma_66215 (h0 : group (measurable_space (has_norm unsigned))) : group.fg (measurable_space (has_norm unsigned)) := sorry --non-trivial
lemma new_lemma_66216 (h0 : filter (ring (normed_comm_ring (normed_comm_ring pos)))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_66217 (h0 : topological_space (add_cancel_monoid Type)) : normal_space (add_cancel_monoid Type) := sorry --non-trivial
lemma new_lemma_66218 (h0 : function.extfun Type topological_space) : @path_connected_space.{0} (random_gen.{0} string_imp) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (random_gen.{0} string_imp))  := sorry --non-trivial
lemma new_lemma_66219 (h0 : fin has_zero.zero) : @irreducible_space.{0} (ordered_comm_monoid.{0} real) (@matrix.vec_empty.{0} (topological_space.{0} (ordered_comm_monoid.{0} real)) h0)  := sorry --non-trivial
lemma new_lemma_66220 (h0 : functor.add_const (function.extfun Type uniform_space) (finset Type)) : @separated_space.{0} (comm_group.{0} pos) (@function.extfun_app.{2 1} Type uniform_space.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type uniform_space.{0}) (finset.{1} Type) h0) (comm_group.{0} pos))  := sorry --non-trivial
lemma new_lemma_66221 (h4 : set environment.projection_info) : set.nonempty h4 := sorry --non-trivial
lemma new_lemma_66222 (h0 : prod (linear_ordered_semiring (has_top (has_top unsigned))) (linear_ordered_semiring (has_top (has_top unsigned)))) : id_rel h0 := sorry --non-trivial
lemma new_lemma_66223 (h0 : list (has_one (semiring empty))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_66224 (h0 : function.extfun Type topological_space) : @preirreducible_space.{0} (has_neg.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_neg.{0} num))  := sorry --non-trivial
lemma new_lemma_66225 (h0 : not (ring (div_inv_monoid fun_info) -> false)) : @rank_condition.{0} (div_inv_monoid.{0} fun_info) (@classical.by_contradiction'.{1} (ring.{0} (div_inv_monoid.{0} fun_info)) h0)  := sorry --non-trivial
lemma new_lemma_66226 (h0 : functor.add_const (topological_space (has_nndist Type)) Type) : @sequential_space.{1} (has_nndist.{1} Type) (@functor.add_const.run.{1 1} (topological_space.{1} (has_nndist.{1} Type)) Type h0)  := sorry --non-trivial
lemma new_lemma_66227 (h0 : functor.add_const (ordered_comm_monoid linarith.comp) Type) : @has_exists_mul_of_le.{0} linarith.comp (@functor.add_const.run.{0 1} (ordered_comm_monoid.{0} linarith.comp) Type h0)  := sorry --non-trivial
lemma new_lemma_66228 (h0 : set (has_le linarith.ineq)) : set.finite h0 := sorry --non-trivial
lemma new_lemma_66229 (h0 : uniform_space (boolean_algebra (has_pos_part linarith.comp))) : complete_space (boolean_algebra (has_pos_part linarith.comp)) := sorry --non-trivial
lemma new_lemma_66230 (h0 : complete_lattice (has_inv (random_gen (random_gen fun_info)))) : complete_lattice.is_Sup_finite_compact (has_inv (random_gen (random_gen fun_info))) := sorry --non-trivial
lemma new_lemma_66231 (h0 : ordered_comm_monoid (canonically_ordered_comm_semiring (ring (ring Type)))) : has_exists_mul_of_le (canonically_ordered_comm_semiring (ring (ring Type))) := sorry --non-trivial
lemma new_lemma_66232 (h0 : topological_space (has_zero (ring (ring (finset name))))) : regular_space (has_zero (ring (ring (finset name)))) := sorry --non-trivial
lemma new_lemma_66233 (h0 : cancel_comm_monoid_with_zero (has_Inf name)) : unique_factorization_monoid (has_Inf name) := sorry --non-trivial
lemma new_lemma_66234 (h1 : add_group (add_cancel_comm_monoid linarith.comp_source)) : is_add_cyclic (add_cancel_comm_monoid linarith.comp_source) := sorry --non-trivial
lemma new_lemma_66235 (h0 : ordered_comm_monoid (has_neg (finset pos))) : has_exists_mul_of_le (has_neg (finset pos)) := sorry --non-trivial
lemma new_lemma_66236 (h2 : has_lt (mul_one_class ereal)) : no_max_order (mul_one_class ereal) := sorry --non-trivial
lemma new_lemma_66237 (h0 : functor.add_const (uniform_space (comm_monoid congr_arg_kind)) congr_arg_kind) : @complete_space.{0} (comm_monoid.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (uniform_space.{0} (comm_monoid.{0} congr_arg_kind)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_66238 (h1 : set (ereal -> add_comm_semigroup ereal)) : set.separates_points h1 := sorry --non-trivial
lemma new_lemma_66239 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @sequential_space.{0} (ordered_comm_monoid.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (ordered_comm_monoid.{0} pos))  := sorry --non-trivial
lemma new_lemma_66240 (h0 : functor.add_const (functor.add_const (complete_lattice Type) Type) name) : @is_atomistic.{1} Type (@functor.add_const.run.{1 1} (complete_lattice.{1} Type) Type (@functor.add_const.run.{1 0} (functor.add_const.{1 1} (complete_lattice.{1} Type) Type) name h0))  := sorry --non-trivial
lemma new_lemma_66241 (h0 : add_monoid (has_neg linarith.comp)) : add_monoid.fg (has_neg linarith.comp) := sorry --non-trivial
lemma new_lemma_66242 (h0 : function.extfun Type group) : @is_simple_group.{0} (left_cancel_monoid.{0} empty) (@function.extfun_app.{2 1} Type group.{0} h0 (left_cancel_monoid.{0} empty))  := sorry --non-trivial
lemma new_lemma_66243 (h0 : functor.add_const (ring (cancel_monoid Type)) ennreal) : @rank_condition.{1} (cancel_monoid.{1} Type) (@functor.add_const.run.{1 0} (ring.{1} (cancel_monoid.{1} Type)) ennreal h0)  := sorry --non-trivial
lemma new_lemma_66244 (h0 : not (function.extfun Type topological_space -> false)) : @locally_compact_space.{0} (has_top.{0} char) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (has_top.{0} char))  := sorry --non-trivial
lemma new_lemma_66245 (h0 : uniform_space (left_cancel_semigroup congr_arg_kind)) : complete_space (left_cancel_semigroup congr_arg_kind) := sorry --non-trivial
lemma new_lemma_66246 (h0 : filter (has_to_string (has_add (add_comm_monoid Type)))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_66247 (h0 : function.extfun Type complete_lattice) : @is_compactly_generated.{0} (has_inter.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (has_inter.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_66248 (h0 : function.extfun Type cancel_comm_monoid_with_zero) : @unique_factorization_monoid.{0} (add_cancel_monoid.{0} num) (@function.extfun_app.{2 1} Type cancel_comm_monoid_with_zero.{0} h0 (add_cancel_monoid.{0} num))  := sorry --non-trivial
lemma new_lemma_66249 (h0 : complete_lattice (has_inv linarith.comp_source)) : is_atomistic (has_inv linarith.comp_source) := sorry --non-trivial
lemma new_lemma_66250 (h0 : ordered_comm_monoid (canonically_ordered_monoid (has_neg (has_neg pos)))) : has_exists_mul_of_le (canonically_ordered_monoid (has_neg (has_neg pos))) := sorry --non-trivial
lemma new_lemma_66251 (h1 : preorder (mul_one_class ereal)) (h2 : set (mul_one_class ereal)) : set.is_pwo h2 := sorry --non-trivial
lemma new_lemma_66252 (h0 : topological_space (complete_distrib_lattice (has_Inf (sub_neg_monoid (sub_neg_monoid pos))))) : regular_space (complete_distrib_lattice (has_Inf (sub_neg_monoid (sub_neg_monoid pos)))) := sorry --non-trivial
lemma new_lemma_66253 (h0 : uniform_space (semigroup ennreal)) : separated_space (semigroup ennreal) := sorry --non-trivial
lemma new_lemma_66254 (h0 : topological_space (comm_monoid empty)) : totally_separated_space (comm_monoid empty) := sorry --non-trivial
lemma new_lemma_66255 (h0 : functor.add_const (function.extfun Type topological_space) pos) : @irreducible_space.{0} (generalized_boolean_algebra.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) pos h0) (generalized_boolean_algebra.{0} name))  := sorry --non-trivial
lemma new_lemma_66256 (h0 : complete_lattice (comm_group (option pos))) : is_compactly_generated (comm_group (option pos)) := sorry --non-trivial
lemma new_lemma_66257 (h1 : semiring (nondiscrete_normed_field char)) (h2 : ideal (nondiscrete_normed_field char)) : ideal.is_prime h2 := sorry --non-trivial
lemma new_lemma_66258 (h0 : function.extfun Type topological_space) : @preirreducible_space.{0} (ordered_comm_monoid.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (ordered_comm_monoid.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_66259 (h0 : has_norm (random_gen (random_gen linarith.ineq)) -> to_additive.value_type -> to_additive.value_type) : left_commutative h0 := sorry --non-trivial
lemma new_lemma_66260 (h0 : not (function.extfun Type topological_space -> false)) : @irreducible_space.{0} (random_gen.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (random_gen.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_66261 (h0 : functor.add_const (topological_space (comm_group Type)) Type) : @totally_disconnected_space.{1} (comm_group.{1} Type) (@functor.add_const.run.{1 1} (topological_space.{1} (comm_group.{1} Type)) Type h0)  := sorry --non-trivial
lemma new_lemma_66262 (h0 : uniform_space (has_to_string (option pos))) : complete_space (has_to_string (option pos)) := sorry --non-trivial
lemma new_lemma_66263 (h0 : uniform_space (denumerable (random_gen (random_gen char)))) : complete_space (denumerable (random_gen (random_gen char))) := sorry --non-trivial
lemma new_lemma_66264 (h0 : functor.add_const (group (has_edist empty)) empty) : @group.fg.{0} (has_edist.{0} empty) (@functor.add_const.run.{0 0} (group.{0} (has_edist.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_66265 (h0 : add_monoid (free_add_monoid num)) : add_monoid.fg (free_add_monoid num) := sorry --non-trivial
lemma new_lemma_66266 (h0 : functor.add_const (topological_space (finset name)) pos) : @loc_path_connected_space.{0} (finset.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (finset.{0} name)) pos h0)  := sorry --non-trivial
lemma new_lemma_66267 (h0 : complete_lattice (has_bot name)) : is_atomistic (has_bot name) := sorry --non-trivial
lemma new_lemma_66268 (h0 : function.extfun Type topological_space) : @preirreducible_space.{0} (group_with_zero.{0} ennreal) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (group_with_zero.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_66269 (h1 : function.extfun Type ring) : @is_domain.{0} (complete_semilattice_Sup.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type ring.{0} h1 (complete_semilattice_Sup.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_66270 (h0 : function.extfun Type topological_space) : @totally_separated_space.{0} (has_nndist.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_nndist.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_66271 (h0 : ring (has_norm unsigned)) : is_principal_ideal_ring (has_norm unsigned) := sorry --non-trivial
lemma new_lemma_66272 (h0 : complete_lattice (distrib (has_ssubset linarith.comp_source))) : complete_lattice.is_Sup_finite_compact (distrib (has_ssubset linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_66273 (h0 : list (finset (has_add (has_Inf (has_Inf (has_add linarith.comp)))))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_66274 (h0 : functor.add_const (function.extfun Type ring) pos) : @strong_rank_condition.{0} (finset.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type ring.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type ring.{0}) pos h0) (finset.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_66275 (h0 : prod (preorder (option unsigned)) (preorder (option unsigned))) : id_rel h0 := sorry --non-trivial
lemma new_lemma_66276 (h0 : has_mem.mem (id empty) has_emptyc.emptyc) : @normalizer_condition.{0} (@id.{2} Type empty) (@finset.pi.empty.{1 0} Type group.{0} (@id.{2} Type empty) h0)  := sorry --non-trivial
lemma new_lemma_66277 (h0 : ring (add_cancel_monoid char)) : strong_rank_condition (add_cancel_monoid char) := sorry --non-trivial
lemma new_lemma_66278 (h0 : set (prod (has_Inf Type) (has_Inf Type))) : symmetric_rel h0 := sorry --non-trivial
lemma new_lemma_66279 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @strong_rank_condition.{0} (ordered_comm_monoid.{0} pos) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (ordered_comm_monoid.{0} pos))  := sorry --non-trivial
lemma new_lemma_66280 (h0 : function.extfun (Type 1) topological_space) : @loc_path_connected_space.{1} (ring.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} h0 (ring.{1} Type))  := sorry --non-trivial
lemma new_lemma_66281 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @locally_compact_space.{0} (comm_monoid.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (comm_monoid.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_66282 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @totally_separated_space.{1} (has_zero.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 topological_space.{1}) (has_zero.{1} Type))  := sorry --non-trivial
lemma new_lemma_66283 (h0 : list (encodable (distrib_lattice to_additive.value_type))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_66284 (h0 : not (topological_space real.angle -> false)) : @t0_space.{0} real.angle (@classical.by_contradiction'.{1} (topological_space.{0} real.angle) h0)  := sorry --non-trivial
lemma new_lemma_66285 (h0 : add_group (measurable_space.dynkin_system (semiring unsigned))) : is_add_cyclic (measurable_space.dynkin_system (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_66286 (h0 : function.extfun Type topological_space) : totally_disconnected_space nnreal := sorry --non-trivial
lemma new_lemma_66287 (h0 : functor.add_const (function.extfun Type topological_space) Type) : @loc_path_connected_space.{0} (semigroup.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type topological_space.{0}) Type h0) (semigroup.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_66288 (h0 : topological_space (has_to_string (comm_group unsigned))) : sequential_space (has_to_string (comm_group unsigned)) := sorry --non-trivial
lemma new_lemma_66289 (h1 : (nondiscrete_normed_field enat -> enat) -> Prop) : set.separates_points (acc (fun (h0 : nondiscrete_normed_field enat -> enat), h1)) := sorry --non-trivial
lemma new_lemma_66290 (h2 : measurable_space (add_comm_semigroup ereal)) (h3 : has_sup (add_comm_semigroup ereal)) : has_measurable_sup₂ (add_comm_semigroup ereal) := sorry --non-trivial
lemma new_lemma_66291 (h0 : topological_space (ordered_comm_ring (has_add pos))) : t0_space (ordered_comm_ring (has_add pos)) := sorry --non-trivial
lemma new_lemma_66292 (h0 : topological_space (measurable_space.dynkin_system (semiring (semiring unsigned)))) : locally_compact_space (measurable_space.dynkin_system (semiring (semiring unsigned))) := sorry --non-trivial
lemma new_lemma_66293 (h0 : functor.add_const (monoid (ordered_cancel_add_comm_monoid num)) unsigned) : @monoid.fg.{0} (ordered_cancel_add_comm_monoid.{0} num) (@functor.add_const.run.{0 0} (monoid.{0} (ordered_cancel_add_comm_monoid.{0} num)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_66294 (h0 : functor.add_const (ordered_add_comm_monoid (semigroup empty)) (option unsigned)) : @archimedean.{0} (semigroup.{0} empty) (@functor.add_const.run.{0 0} (ordered_add_comm_monoid.{0} (semigroup.{0} empty)) (option.{0} unsigned) h0)  := sorry --non-trivial
lemma new_lemma_66295 (h0 : topological_space (semigroup (ring environment.implicit_infer_kind))) : t0_space (semigroup (ring environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_66296 (h0 : function.extfun Type group) : @normalizer_condition.{0} (sub_neg_monoid.{0} pos) (@function.extfun_app.{2 1} Type group.{0} h0 (sub_neg_monoid.{0} pos))  := sorry --non-trivial
lemma new_lemma_66297 (h0 : functor.add_const (topological_space (has_pos_part pos)) linarith.comp) : @t0_space.{0} (has_pos_part.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (has_pos_part.{0} pos)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_66298 (h0 : add_monoid (mul_zero_class (has_top (has_top unsigned)))) : add_monoid.fg (mul_zero_class (has_top (has_top unsigned))) := sorry --non-trivial
lemma new_lemma_66299 (h0 : function.extfun ((Type -> Type) -> Type 1) (function.extfun (Type -> Type))) : @totally_separated_space.{0} (has_emptyc.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) (@function.extfun_app.{3 2} ((Type → Type) → Type 1) (function.extfun.{2 2} (Type → Type)) h0 (function.extfun.{2 1} Type)) topological_space.{0}) (has_emptyc.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_66300 (h0 : topological_space (boolean_algebra (has_neg linarith.comp))) : preirreducible_space (boolean_algebra (has_neg linarith.comp)) := sorry --non-trivial
lemma new_lemma_66301 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @preconnected_space.{0} (has_nndist.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_nndist.{0} num))  := sorry --non-trivial
lemma new_lemma_66302 (h0 : function.extfun Type topological_space) : @totally_separated_space.{0} (has_inv.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_inv.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_66303 (h0 : functor.add_const (topological_space (finset unsigned)) unsigned) : @normal_space.{0} (finset.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (finset.{0} unsigned)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_66304 (h0 : topological_space (complete_distrib_lattice congr_arg_kind)) : normal_space (complete_distrib_lattice congr_arg_kind) := sorry --non-trivial
lemma new_lemma_66305 (h1 : ring (add_comm_semigroup environment.projection_info)) : rank_condition (add_comm_semigroup environment.projection_info) := sorry --non-trivial
lemma new_lemma_66306 (h0 : functor.add_const (function.extfun Type add_group) linarith.comp) : @is_add_cyclic.{0} (boolean_algebra.{0} linarith.comp) (@function.extfun_app.{2 1} Type add_group.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type add_group.{0}) linarith.comp h0) (boolean_algebra.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_66307 (h0 : functor.add_const (topological_space (partial_order congr_arg_kind)) empty) : @irreducible_space.{0} (partial_order.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (partial_order.{0} congr_arg_kind)) empty h0)  := sorry --non-trivial
lemma new_lemma_66308 (h0 : group (add_comm_monoid Type)) : normalizer_condition (add_comm_monoid Type) := sorry --non-trivial
lemma new_lemma_66309 (h0 : functor.add_const (topological_space (ordered_comm_ring pos)) (has_bot Type)) : @totally_separated_space.{0} (ordered_comm_ring.{0} pos) (@functor.add_const.run.{0 1} (topological_space.{0} (ordered_comm_ring.{0} pos)) (has_bot.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_66310 (h0 : function.extfun Type group) : @is_simple_group.{0} (group_with_zero.{0} pos) (@function.extfun_app.{2 1} Type group.{0} h0 (group_with_zero.{0} pos))  := sorry --non-trivial
lemma new_lemma_66311 (h0 : uniform_space (pseudo_metric_space (option (option (option (option (option (option unsigned)))))))) : separated_space (pseudo_metric_space (option (option (option (option (option (option unsigned))))))) := sorry --non-trivial
lemma new_lemma_66312 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_cyclic.{0} (has_union.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (has_union.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_66313 (h0 : uniform_space (has_Inf (finset linarith.comp))) : separated_space (has_Inf (finset linarith.comp)) := sorry --non-trivial
lemma new_lemma_66314 (h1 : complete_lattice (has_one (has_norm linarith.comp))) : complete_lattice.is_Sup_finite_compact (has_one (has_norm linarith.comp)) := sorry --non-trivial
lemma new_lemma_66315 (h0 : uniform_space (complete_semilattice_Sup (has_top fun_info))) : complete_space (complete_semilattice_Sup (has_top fun_info)) := sorry --non-trivial
lemma new_lemma_66316 (h0 : group (has_union num)) : is_cyclic (has_union num) := sorry --non-trivial
lemma new_lemma_66317 (h0 : filter (has_emptyc linarith.comp)) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_66318 (h0 : ring (boolean_algebra.core (has_add (has_add Type)))) : is_principal_ideal_ring (boolean_algebra.core (has_add (has_add Type))) := sorry --non-trivial
lemma new_lemma_66319 (h0 : functor.add_const (list (add_cancel_monoid name)) (has_add pos)) : palindrome (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_66320 (h1 h2 : multiset (nondiscrete_normed_field environment.projection_info)) : multiset.subset h1 h2 := sorry --non-trivial
lemma new_lemma_66321 (h0 : prod (mul_zero_class ennreal) (mul_zero_class ennreal)) : id_rel h0 := sorry --non-trivial
lemma new_lemma_66322 (h0 : uniform_space (measurable_space.dynkin_system num)) : separated_space (measurable_space.dynkin_system num) := sorry --non-trivial
lemma new_lemma_66323 (h0 : topological_space (has_Inf (has_Inf linarith.comp))) : normal_space (has_Inf (has_Inf linarith.comp)) := sorry --non-trivial
lemma new_lemma_66324 (h0 : functor.add_const (topological_space (has_neg unsigned)) pos) : @t1_space.{0} (has_neg.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (has_neg.{0} unsigned)) pos h0)  := sorry --non-trivial
lemma new_lemma_66325 (h2 : ring (has_compl to_additive.value_type)) : is_domain (has_compl to_additive.value_type) := sorry --non-trivial
lemma new_lemma_66326 (h0 : functor.add_const (ring (free_add_monoid congr_arg_kind)) unsigned) : @strong_rank_condition.{0} (free_add_monoid.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (ring.{0} (free_add_monoid.{0} congr_arg_kind)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_66327 (h0 : list (normed_group (has_top linarith.comp_source))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_66328 (h1 : add_group (has_ssubset enat)) : is_add_cyclic (has_ssubset enat) := sorry --non-trivial
lemma new_lemma_66329 (h0 : add_monoid (monoid_with_zero (option ennreal))) : add_monoid.fg (monoid_with_zero (option ennreal)) := sorry --non-trivial
lemma new_lemma_66330 (h0 : uniform_space (add_left_cancel_monoid (has_nnnorm (has_nnnorm fun_info)))) : complete_space (add_left_cancel_monoid (has_nnnorm (has_nnnorm fun_info))) := sorry --non-trivial
lemma new_lemma_66331 (h0 : add_group (metric_space (semiring unsigned))) : is_add_cyclic (metric_space (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_66332 (h0 : add_monoid (linear_ordered_comm_ring (semiring empty))) : add_monoid.fg (linear_ordered_comm_ring (semiring empty)) := sorry --non-trivial
lemma new_lemma_66333 (h0 : topological_space (ordered_comm_ring (ordered_comm_monoid (has_bot real)))) : totally_disconnected_space (ordered_comm_ring (ordered_comm_monoid (has_bot real))) := sorry --non-trivial
lemma new_lemma_66334 (h0 : not (function.extfun Type topological_space -> false)) : @path_connected_space.{0} fun_info (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) fun_info)  := sorry --non-trivial
lemma new_lemma_66335 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @normal_space.{0} (linear_ordered_field.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (linear_ordered_field.{0} empty))  := sorry --non-trivial
lemma new_lemma_66336 (h0 : set (distrib linarith.comp_source)) : set.finite h0 := sorry --non-trivial
lemma new_lemma_66337 (h0 : topological_space (ordered_comm_ring (has_add (has_add real)))) : t1_space (ordered_comm_ring (has_add (has_add real))) := sorry --non-trivial
lemma new_lemma_66338 (h0 : not (function.extfun Type monoid -> false)) : @monoid.fg.{0} (measure_theory.measure_space.{0} empty) (@function.extfun_app.{2 1} Type monoid.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type monoid.{0}) h0) (measure_theory.measure_space.{0} empty))  := sorry --non-trivial
lemma new_lemma_66339 (h0 : topological_space (semi_normed_comm_ring enat)) : path_connected_space (semi_normed_comm_ring enat) := sorry --non-trivial
lemma new_lemma_66340 (h0 : complete_lattice (boolean_algebra (has_add Type))) : is_compactly_generated (boolean_algebra (has_add Type)) := sorry --non-trivial
lemma new_lemma_66341 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @discrete_topology.{0} (has_bot.{0} real) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_bot.{0} real))  := sorry --non-trivial
lemma new_lemma_66342 (h0 : topological_space (linear_ordered_comm_group_with_zero string.iterator_imp)) (h1 : add_group (linear_ordered_comm_group_with_zero string.iterator_imp)) : topological_add_group (linear_ordered_comm_group_with_zero string.iterator_imp) := sorry --non-trivial
lemma new_lemma_66343 (h0 : functor.add_const (complete_lattice (semigroup linarith.comp)) pos) : @is_atomistic.{0} (semigroup.{0} linarith.comp) (@functor.add_const.run.{0 0} (complete_lattice.{0} (semigroup.{0} linarith.comp)) pos h0)  := sorry --non-trivial
lemma new_lemma_66344 (h0 : function.extfun Type (functor.add_const (topological_space (has_Inf linarith.comp)))) : @sequential_space.{0} (has_Inf.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (has_Inf.{0} linarith.comp)) (has_nndist.{0} linarith.comp) (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (topological_space.{0} (has_Inf.{0} linarith.comp))) h0 (has_nndist.{0} linarith.comp)))  := sorry --non-trivial
lemma new_lemma_66345 (h0 : topological_space (boolean_algebra (comm_group (has_to_string unsigned)))) : regular_space (boolean_algebra (comm_group (has_to_string unsigned))) := sorry --non-trivial
lemma new_lemma_66346 (h0 : functor.add_const (function.extfun Type group) (has_pos_part pos)) : @is_simple_group.{0} (ring.{0} pos) (@function.extfun_app.{2 1} Type group.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type group.{0}) (has_pos_part.{0} pos) h0) (ring.{0} pos))  := sorry --non-trivial
lemma new_lemma_66347 (h0 : complete_lattice (denumerable (comm_ring to_additive.value_type))) : complete_lattice.is_Sup_finite_compact (denumerable (comm_ring to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_66348 (h0 : list (distrib_lattice (comm_ring fun_info))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_66349 (h1 : topological_space (distrib_lattice (has_norm (has_norm to_additive.value_type)))) : irreducible_space (distrib_lattice (has_norm (has_norm to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_66350 (h0 : filter (with_zero (has_inv (random_gen fun_info)))) : filter.is_countably_generated h0 := sorry --non-trivial
lemma new_lemma_66351 (h0 : filter (has_dist (option ennreal))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_66352 (h0 : group (semigroup (has_add (boolean_algebra.core (has_add unsigned))))) : group.fg (semigroup (has_add (boolean_algebra.core (has_add unsigned)))) := sorry --non-trivial
lemma new_lemma_66353 (h0 : functor.add_const (topological_space (bin_tree congr_arg_kind)) empty) : @topological_space.separable_space.{0} (bin_tree.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (bin_tree.{0} congr_arg_kind)) empty h0)  := sorry --non-trivial
lemma new_lemma_66354 (h0 : functor.add_const (add_group (as_linear_order unsigned)) empty) : @is_add_cyclic.{0} (as_linear_order.{0} unsigned) (@functor.add_const.run.{0 0} (add_group.{0} (as_linear_order.{0} unsigned)) empty h0)  := sorry --non-trivial
lemma new_lemma_66355 (h0 : functor.add_const (ring (left_cancel_semigroup empty)) congr_arg_kind) : @is_principal_ideal_ring.{0} (left_cancel_semigroup.{0} empty) (@functor.add_const.run.{0 0} (ring.{0} (left_cancel_semigroup.{0} empty)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_66356 (h0 : add_group (has_ssubset (has_nnnorm (has_nnnorm (has_nnnorm (has_nnnorm linarith.comp_source)))))) : is_add_cyclic (has_ssubset (has_nnnorm (has_nnnorm (has_nnnorm (has_nnnorm linarith.comp_source))))) := sorry --non-trivial
lemma new_lemma_66357 (h0 : not (function.extfun Type add_group -> false)) : @is_add_cyclic.{0} (linear_ordered_semiring.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type add_group.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type add_group.{0}) h0) (linear_ordered_semiring.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_66358 (h0 : function.extfun Type semiring) : @is_noetherian_ring.{0} (ordered_comm_ring.{0} pos) (@function.extfun_app.{2 1} Type semiring.{0} h0 (ordered_comm_ring.{0} pos))  := sorry --non-trivial
lemma new_lemma_66359 (h0 : function.extfun Type (functor.comp topological_space add_comm_monoid)) : @totally_separated_space.{0} (add_comm_monoid.{0} unsigned) (@functor.comp.run.{0 0 0} topological_space.{0} add_comm_monoid.{0} unsigned (@function.extfun_app.{2 1} Type (functor.comp.{0 0 0} topological_space.{0} add_comm_monoid.{0}) h0 unsigned))  := sorry --non-trivial
lemma new_lemma_66360 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @totally_disconnected_space.{0} (with_bot.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (with_bot.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_66361 (h0 : function.extfun Type (functor.add_const (add_group (linear_ordered_cancel_comm_monoid empty)))) : @is_add_cyclic.{0} (linear_ordered_cancel_comm_monoid.{0} empty) (@functor.add_const.run.{0 0} (add_group.{0} (linear_ordered_cancel_comm_monoid.{0} empty)) empty (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (add_group.{0} (linear_ordered_cancel_comm_monoid.{0} empty))) h0 empty))  := sorry --non-trivial
lemma new_lemma_66362 (h0 : topological_space (has_compl (random_gen fun_info))) : totally_disconnected_space (has_compl (random_gen fun_info)) := sorry --non-trivial
lemma new_lemma_66363 (h0 : ring (has_nndist num)) : rank_condition (has_nndist num) := sorry --non-trivial
lemma new_lemma_66364 (h0 : function.extfun Type ring) : @strong_rank_condition.{0} (canonically_ordered_comm_semiring.{0} ennreal) (@function.extfun_app.{2 1} Type ring.{0} h0 (canonically_ordered_comm_semiring.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_66365 (h0 : functor.add_const (topological_space (linear_order empty)) empty) : @t0_space.{0} (linear_order.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (linear_order.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_66366 (h0 : set fun_info) : set.subsingleton h0 := sorry --non-trivial
lemma new_lemma_66367 (h0 : functor.add_const (topological_space (add_comm_monoid name)) environment.implicit_infer_kind) : @preconnected_space.{0} (add_comm_monoid.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (add_comm_monoid.{0} name)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_66368 (h0 : group (ring num)) : normalizer_condition (ring num) := sorry --non-trivial
lemma new_lemma_66369 (h0 : not (complete_lattice (simple_graph string.iterator_imp) -> false)) : @is_compactly_generated.{0} (simple_graph.{0} string.iterator_imp) (@classical.by_contradiction'.{1} (complete_lattice.{0} (simple_graph.{0} string.iterator_imp)) h0)  := sorry --non-trivial
lemma new_lemma_66370 (h0 : function.extfun Type topological_space) : @locally_compact_space.{0} (has_nndist.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_nndist.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_66371 (h0 : ring (measurable_space (semiring empty))) : strong_rank_condition (measurable_space (semiring empty)) := sorry --non-trivial
lemma new_lemma_66372 (h0 : fin has_zero.zero) : @is_noetherian_ring.{1} (has_bot.{1} Type) (@matrix.vec_empty.{1} (semiring.{1} (has_bot.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_66373 (h1 : group (id (random_gen linarith.ineq))) : normalizer_condition (id (random_gen linarith.ineq)) := sorry --non-trivial
lemma new_lemma_66374 (h0 : ring (uniform_space enat)) : rank_condition (uniform_space enat) := sorry --non-trivial
lemma new_lemma_66375 (h0 : functor.add_const (topological_space (canonically_ordered_monoid pos)) (has_Inf (has_neg (has_neg Type)))) : @discrete_topology.{0} (canonically_ordered_monoid.{0} pos) (@functor.add_const.run.{0 1} (topological_space.{0} (canonically_ordered_monoid.{0} pos)) (has_Inf.{1} (has_neg.{1} (has_neg.{1} Type))) h0)  := sorry --non-trivial
lemma new_lemma_66376 (h1 : ring (normed_field string.iterator_imp)) : strong_rank_condition (normed_field string.iterator_imp) := sorry --non-trivial
lemma new_lemma_66377 (h0 : functor.add_const (ring (has_neg_part Type)) Type) : @strong_rank_condition.{1} (has_neg_part.{1} Type) (@functor.add_const.run.{1 1} (ring.{1} (has_neg_part.{1} Type)) Type h0)  := sorry --non-trivial
lemma new_lemma_66378 (h0 : topological_space (finset num)) : topological_space.separable_space (finset num) := sorry --non-trivial
lemma new_lemma_66379 (h0 : topological_space (ordered_comm_monoid (has_neg linarith.comp))) : discrete_topology (ordered_comm_monoid (has_neg linarith.comp)) := sorry --non-trivial
lemma new_lemma_66380 (h0 : topological_space (ordered_comm_ring (ordered_ring (ordered_ring pos)))) : irreducible_space (ordered_comm_ring (ordered_ring (ordered_ring pos))) := sorry --non-trivial
lemma new_lemma_66381 (h1 : not (complete_lattice (metric_space linarith.comp_source) -> false)) : @is_compactly_generated.{0} (metric_space.{0} linarith.comp_source) (@classical.by_contradiction'.{1} (complete_lattice.{0} (metric_space.{0} linarith.comp_source)) h1)  := sorry --non-trivial
lemma new_lemma_66382 (h0 : topological_space (has_zero environment.implicit_infer_kind)) : normal_space (has_zero environment.implicit_infer_kind) := sorry --non-trivial
lemma new_lemma_66383 (h1 : complete_lattice (fintype (distrib char))) : is_compactly_generated (fintype (distrib char)) := sorry --non-trivial
lemma new_lemma_66384 (h0 : topological_space (comm_semigroup (has_bot (ordered_comm_monoid (has_bot Type))))) : preirreducible_space (comm_semigroup (has_bot (ordered_comm_monoid (has_bot Type)))) := sorry --non-trivial
lemma new_lemma_66385 (h0 : ring (comm_ring (with_bot string_imp))) : is_domain (comm_ring (with_bot string_imp)) := sorry --non-trivial
lemma new_lemma_66386 (h0 : monoid (linear_ordered_field unsigned)) : monoid.fg (linear_ordered_field unsigned) := sorry --non-trivial
lemma new_lemma_66387 (h1 : ring (has_append char)) : is_domain (has_append char) := sorry --non-trivial
lemma new_lemma_66388 (h0 : functor.add_const (topological_space (add_right_cancel_monoid congr_arg_kind)) num) : @topological_space.separable_space.{0} (add_right_cancel_monoid.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (add_right_cancel_monoid.{0} congr_arg_kind)) num h0)  := sorry --non-trivial
lemma new_lemma_66389 (h0 : complete_lattice (non_unital_non_assoc_semiring char)) : complete_lattice.is_Sup_finite_compact (non_unital_non_assoc_semiring char) := sorry --non-trivial
lemma new_lemma_66390 (h0 : functor.comp ring has_neg_part name) : @is_principal_ideal_ring.{0} (has_neg_part.{0} name) (@functor.comp.run.{0 0 0} ring.{0} has_neg_part.{0} name (@functor.comp.run.{0 0 0} ring.{0} has_neg_part.{0} name h0))  := sorry --non-trivial
lemma new_lemma_66391 (h0 : functor.add_const (topological_space (has_neg environment.implicit_infer_kind)) name) : @topological_space.separable_space.{0} (has_neg.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (has_neg.{0} environment.implicit_infer_kind)) name h0)  := sorry --non-trivial
lemma new_lemma_66392 (h0 : has_mem.mem (with_bot linarith.comp_source) has_emptyc.emptyc) : @path_connected_space.{0} (with_bot.{0} linarith.comp_source) (@finset.pi.empty.{1 0} Type topological_space.{0} (with_bot.{0} linarith.comp_source) h0)  := sorry --non-trivial
lemma new_lemma_66393 (h0 : ring (add_cancel_monoid (has_add Type))) : strong_rank_condition (add_cancel_monoid (has_add Type)) := sorry --non-trivial
lemma new_lemma_66394 (h0 : ring (has_to_string (comm_group (comm_group (comm_group name))))) : strong_rank_condition (has_to_string (comm_group (comm_group (comm_group name)))) := sorry --non-trivial
lemma new_lemma_66395 (h0 : functor.add_const (topological_space (has_add environment.implicit_infer_kind)) environment.implicit_infer_kind) : @discrete_topology.{0} (has_add.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (has_add.{0} environment.implicit_infer_kind)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_66396 (h0 : ring (add_cancel_comm_monoid (has_nnnorm char))) : is_domain (add_cancel_comm_monoid (has_nnnorm char)) := sorry --non-trivial
lemma new_lemma_66397 (h0 : not (topological_space (has_lt to_additive.value_type) -> false)) : @t0_space.{0} (has_lt.{0} to_additive.value_type) (@classical.by_contradiction'.{1} (topological_space.{0} (has_lt.{0} to_additive.value_type)) h0)  := sorry --non-trivial
lemma new_lemma_66398 (h0 : has_mem.mem (normed_group empty) has_emptyc.emptyc) : @path_connected_space.{0} (normed_group.{0} empty) (@finset.pi.empty.{1 0} Type topological_space.{0} (normed_group.{0} empty) h0)  := sorry --non-trivial
lemma new_lemma_66399 (h0 : functor.add_const (ring (canonically_ordered_comm_semiring empty)) num) : @strong_rank_condition.{0} (canonically_ordered_comm_semiring.{0} empty) (@functor.add_const.run.{0 0} (ring.{0} (canonically_ordered_comm_semiring.{0} empty)) num h0)  := sorry --non-trivial
lemma new_lemma_66400 (h0 : topological_space (has_Inf (has_neg pos))) : regular_space (has_Inf (has_neg pos)) := sorry --non-trivial
lemma new_lemma_66401 (h0 : functor.add_const (topological_space (add_cancel_monoid environment.implicit_infer_kind)) (finset linarith.comp)) : @locally_compact_space.{0} (add_cancel_monoid.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (add_cancel_monoid.{0} environment.implicit_infer_kind)) (finset.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_66402 (h0 : ring (plift (semiring unsigned))) : is_principal_ideal_ring (plift (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_66403 (h0 : topological_space (complete_distrib_lattice (has_add linarith.comp))) : locally_compact_space (complete_distrib_lattice (has_add linarith.comp)) := sorry --non-trivial
lemma new_lemma_66404 (h0 : function.extfun Type topological_space) : @discrete_topology.{0} (with_one.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (with_one.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_66405 (h0 : topological_space (add_group (semiring empty))) : totally_separated_space (add_group (semiring empty)) := sorry --non-trivial
lemma new_lemma_66406 (h1 : add_group (random_gen (semiring linarith.comp))) : is_add_cyclic (random_gen (semiring linarith.comp)) := sorry --non-trivial
lemma new_lemma_66407 (h0 : not (complete_lattice (left_cancel_monoid num) -> false)) : @is_atomistic.{0} (left_cancel_monoid.{0} num) (@classical.by_contradiction'.{1} (complete_lattice.{0} (left_cancel_monoid.{0} num)) h0)  := sorry --non-trivial
lemma new_lemma_66408 (h0 : complete_lattice (with_bot (random_gen linarith.comp_source))) : is_compactly_generated (with_bot (random_gen linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_66409 (h0 : add_group (has_top linarith.comp_source)) : is_add_cyclic (has_top linarith.comp_source) := sorry --non-trivial
lemma new_lemma_66410 (h1 : ring (has_ssubset (add_comm_semigroup string.iterator_imp))) : is_domain (has_ssubset (add_comm_semigroup string.iterator_imp)) := sorry --non-trivial
lemma new_lemma_66411 (h0 : functor.add_const (topological_space (free_add_monoid num)) num) : @t1_space.{0} (free_add_monoid.{0} num) (@functor.add_const.run.{0 0} (topological_space.{0} (free_add_monoid.{0} num)) num h0)  := sorry --non-trivial
lemma new_lemma_66412 (h0 : topological_space (has_neg (finset environment.implicit_infer_kind))) : regular_space (has_neg (finset environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_66413 (h0 : functor.add_const (topological_space (add_comm_monoid linarith.comp)) pos) : @loc_path_connected_space.{0} (add_comm_monoid.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (add_comm_monoid.{0} linarith.comp)) pos h0)  := sorry --non-trivial
lemma new_lemma_66414 (h0 : topological_space (complete_semilattice_Sup (has_top linarith.comp_source))) : locally_compact_space (complete_semilattice_Sup (has_top linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_66415 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @archimedean.{0} (normed_comm_ring.{0} name) (@function.extfun_app.{2 1} Type ordered_add_comm_monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ordered_add_comm_monoid.{0}) (normed_comm_ring.{0} name))  := sorry --non-trivial
lemma new_lemma_66416 (h1 : set (semi_normed_comm_ring to_additive.value_type)) : set.subsingleton h1 := sorry --non-trivial
lemma new_lemma_66417 (h0 : topological_space (with_bot (has_top unsigned))) : sequential_space (with_bot (has_top unsigned)) := sorry --non-trivial
lemma new_lemma_66418 (h0 : complete_lattice (random_gen (mul_one_class char))) : is_compactly_generated (random_gen (mul_one_class char)) := sorry --non-trivial
lemma new_lemma_66419 (h0 : finset (has_to_string Type)) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_66420 (h1 : monoid (random_gen (random_gen string_imp))) : monoid.fg (random_gen (random_gen string_imp)) := sorry --non-trivial
lemma new_lemma_66421 (h0 : complete_lattice (random_gen (has_norm linarith.ineq))) : is_compactly_generated (random_gen (has_norm linarith.ineq)) := sorry --non-trivial
lemma new_lemma_66422 (h0 : not (topological_space (has_one linarith.comp) -> false)) : @totally_disconnected_space.{0} (has_one.{0} linarith.comp) (@classical.by_contradiction'.{1} (topological_space.{0} (has_one.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_66423 (h1 : ring std_gen) : is_domain std_gen := sorry --non-trivial
lemma new_lemma_66424 (h0 : ordered_add_comm_monoid (canonically_ordered_comm_semiring pos)) : archimedean (canonically_ordered_comm_semiring pos) := sorry --non-trivial
lemma new_lemma_66425 (h0 : complete_lattice (has_norm (has_nnnorm (has_ssubset fun_info)))) : complete_lattice.is_Sup_finite_compact (has_norm (has_nnnorm (has_ssubset fun_info))) := sorry --non-trivial
lemma new_lemma_66426 (h0 : topological_space (has_add (has_pos_part (has_pos_part (has_pos_part (has_pos_part linarith.comp)))))) : t1_space (has_add (has_pos_part (has_pos_part (has_pos_part (has_pos_part linarith.comp))))) := sorry --non-trivial
lemma new_lemma_66427 (h0 : not (add_group enat -> false)) : @is_add_cyclic.{0} enat (@classical.by_contradiction'.{1} (add_group.{0} enat) h0)  := sorry --non-trivial
lemma new_lemma_66428 (h0 : functor.add_const (topological_space (left_cancel_monoid congr_arg_kind)) empty) : @locally_compact_space.{0} (left_cancel_monoid.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (left_cancel_monoid.{0} congr_arg_kind)) empty h0)  := sorry --non-trivial
lemma new_lemma_66429 (h0 : ring (cancel_monoid (option (option pos)))) : strong_rank_condition (cancel_monoid (option (option pos))) := sorry --non-trivial
lemma new_lemma_66430 (h0 : set (prod pos pos)) (h1 : functor.add_const (prod pos pos) linarith.comp) : symmetrize_rel h0 (functor.add_const.run h1) := sorry --non-trivial
lemma new_lemma_66431 (h0 : ring (has_union (semiring empty))) : is_domain (has_union (semiring empty)) := sorry --non-trivial
lemma new_lemma_66432 (h1 : ring (has_div reducibility_hints)) : is_domain (has_div reducibility_hints) := sorry --non-trivial
lemma new_lemma_66433 (h0 : uniform_space (simple_graph congr_arg_kind)) : complete_space (simple_graph congr_arg_kind) := sorry --non-trivial
lemma new_lemma_66434 (h0 : semiring (add_left_cancel_semigroup empty)) : is_noetherian_ring (add_left_cancel_semigroup empty) := sorry --non-trivial
lemma new_lemma_66435 (h0 : topological_space (has_lt (normed_field (has_inf (mul_one_class linarith.ineq))))) : totally_disconnected_space (has_lt (normed_field (has_inf (mul_one_class linarith.ineq)))) := sorry --non-trivial
lemma new_lemma_66436 (h0 : complete_lattice (finset (boolean_algebra environment.implicit_infer_kind))) : is_atomistic (finset (boolean_algebra environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_66437 (h0 : function.extfun Type ring) : @is_domain.{0} (add_cancel_monoid.{0} name) (@function.extfun_app.{2 1} Type ring.{0} h0 (add_cancel_monoid.{0} name))  := sorry --non-trivial
lemma new_lemma_66438 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_noetherian_ring.{0} (ordered_cancel_add_comm_monoid.{0} unsigned) (@function.extfun_app.{2 1} Type semiring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 semiring.{0}) (ordered_cancel_add_comm_monoid.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_66439 (h0 : add_group (dlist to_additive.value_type)) : is_add_cyclic (dlist to_additive.value_type) := sorry --non-trivial
lemma new_lemma_66440 (h0 : not (function.extfun Type ring -> false)) : @rank_condition.{0} (has_union.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type ring.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type ring.{0}) h0) (has_union.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_66441 (h0 : complete_lattice (normed_lattice_add_comm_group (has_add pos))) : complete_lattice.is_Sup_finite_compact (normed_lattice_add_comm_group (has_add pos)) := sorry --non-trivial
lemma new_lemma_66442 (h0 : add_group (has_to_string num)) : is_add_cyclic (has_to_string num) := sorry --non-trivial
lemma new_lemma_66443 (h0 : topological_space (monoid congr_arg_kind)) : discrete_topology (monoid congr_arg_kind) := sorry --non-trivial
lemma new_lemma_66444 (h0 : monoid (has_star num)) : monoid.fg (has_star num) := sorry --non-trivial
lemma new_lemma_66445 (h0 : cancel_comm_monoid_with_zero (is_R_or_C congr_arg_kind)) : unique_factorization_monoid (is_R_or_C congr_arg_kind) := sorry --non-trivial
lemma new_lemma_66446 (h0 : not (complete_lattice (semi_normed_ring string_imp) -> false)) : @complete_lattice.is_Sup_finite_compact.{0} (semi_normed_ring.{0} string_imp) (@classical.by_contradiction'.{1} (complete_lattice.{0} (semi_normed_ring.{0} string_imp)) h0)  := sorry --non-trivial
lemma new_lemma_66447 (h0 : group (ordered_comm_monoid (has_neg pos))) : is_cyclic (ordered_comm_monoid (has_neg pos)) := sorry --non-trivial
lemma new_lemma_66448 (h0 : topological_space (add_monoid to_additive.value_type)) : t0_space (add_monoid to_additive.value_type) := sorry --non-trivial
lemma new_lemma_66449 (h0 : topological_space (add_cancel_comm_monoid to_additive.value_type)) : totally_disconnected_space (add_cancel_comm_monoid to_additive.value_type) := sorry --non-trivial
lemma new_lemma_66450 (h0 : ring (has_emptyc (has_top (has_top (has_top (has_top fun_info)))))) : rank_condition (has_emptyc (has_top (has_top (has_top (has_top fun_info))))) := sorry --non-trivial
lemma new_lemma_66451 (h1 : topological_space (random_gen to_additive.value_type)) : totally_separated_space (random_gen to_additive.value_type) := sorry --non-trivial
lemma new_lemma_66452 (h0 : functor.add_const (filter (add_cancel_monoid linarith.comp)) environment.implicit_infer_kind) : countable_Inter_filter (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_66453 (h0 : has_mem.mem (with_bot linarith.comp_source) has_emptyc.emptyc) : @complete_lattice.is_Sup_finite_compact.{0} (with_bot.{0} linarith.comp_source) (@finset.pi.empty.{1 0} Type complete_lattice.{0} (with_bot.{0} linarith.comp_source) h0)  := sorry --non-trivial
lemma new_lemma_66454 (h0 : group (complete_semilattice_Sup (random_gen (random_gen to_additive.value_type)))) : group.fg (complete_semilattice_Sup (random_gen (random_gen to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_66455 (h0 : list (finset (cancel_monoid Type))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_66456 (h0 : group (has_nndist (has_pos_part real))) : normalizer_condition (has_nndist (has_pos_part real)) := sorry --non-trivial
lemma new_lemma_66457 (h0 : uniform_space (has_Sup unsigned)) : complete_space (has_Sup unsigned) := sorry --non-trivial
lemma new_lemma_66458 (h0 : functor.add_const (group (has_to_string num)) num) : @group.fg.{0} (has_to_string.{0} num) (@functor.add_const.run.{0 0} (group.{0} (has_to_string.{0} num)) num h0)  := sorry --non-trivial
lemma new_lemma_66459 (h2 : topological_space (has_compl linarith.comp_source)) : path_connected_space (has_compl linarith.comp_source) := sorry --non-trivial
lemma new_lemma_66460 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : filter.ne_bot (function.extfun_app (function.extfun_app h0 filter) (has_add name)) := sorry --non-trivial
lemma new_lemma_66461 (h0 : group (linear_ordered_comm_ring (semiring (has_top congr_arg_kind)))) : group.fg (linear_ordered_comm_ring (semiring (has_top congr_arg_kind))) := sorry --non-trivial
lemma new_lemma_66462 (h0 : functor.add_const (uniform_space (free_add_monoid congr_arg_kind)) num) : @complete_space.{0} (free_add_monoid.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (uniform_space.{0} (free_add_monoid.{0} congr_arg_kind)) num h0)  := sorry --non-trivial
lemma new_lemma_66463 (h0 : list (has_neg (option unsigned))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_66464 (h0 : topological_space (ordered_cancel_add_comm_monoid (option empty))) : normal_space (ordered_cancel_add_comm_monoid (option empty)) := sorry --non-trivial
lemma new_lemma_66465 (h0 : functor.add_const (function.extfun Type uniform_space) empty) : @separated_space.{0} (linear_order.{0} empty) (@function.extfun_app.{2 1} Type uniform_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type uniform_space.{0}) empty h0) (linear_order.{0} empty))  := sorry --non-trivial
lemma new_lemma_66466 (h0 : add_group (id (semiring (semiring empty)))) : is_add_cyclic (id (semiring (semiring empty))) := sorry --non-trivial
lemma new_lemma_66467 (h0 : ring (boolean_algebra (has_add (add_comm_monoid unsigned)))) : strong_rank_condition (boolean_algebra (has_add (add_comm_monoid unsigned))) := sorry --non-trivial
lemma new_lemma_66468 (h0 : complete_lattice (generalized_boolean_algebra (has_bot real))) : is_compactly_generated (generalized_boolean_algebra (has_bot real)) := sorry --non-trivial
lemma new_lemma_66469 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @add_monoid.fg.{0} (add_semigroup.{0} unsigned) (@function.extfun_app.{2 1} Type add_monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 add_monoid.{0}) (add_semigroup.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_66470 (h0 : function.extfun Type ring) : @is_domain.{0} (omega_complete_partial_order.{0} unsigned) (@function.extfun_app.{2 1} Type ring.{0} h0 (omega_complete_partial_order.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_66471 (h0 : topological_space (has_to_string (has_add Type))) : discrete_topology (has_to_string (has_add Type)) := sorry --non-trivial
lemma new_lemma_66472 (h0 : cancel_comm_monoid_with_zero (has_bot empty)) : unique_factorization_monoid (has_bot empty) := sorry --non-trivial
lemma new_lemma_66473 (h0 : function.extfun Type topological_space) : @preirreducible_space.{0} (semigroup.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (semigroup.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_66474 (h0 : functor.add_const (topological_space (comm_group linarith.comp)) linarith.comp) : @totally_separated_space.{0} (comm_group.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (comm_group.{0} linarith.comp)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_66475 (h1 : monoid (linear_order (with_bot string_imp))) : monoid.fg (linear_order (with_bot string_imp)) := sorry --non-trivial
lemma new_lemma_66476 (h0 : not (topological_space (has_ssubset reducibility_hints) -> false)) : @totally_disconnected_space.{0} (has_ssubset.{0} reducibility_hints) (@classical.by_contradiction'.{1} (topological_space.{0} (has_ssubset.{0} reducibility_hints)) h0)  := sorry --non-trivial
lemma new_lemma_66477 (h0 : group (semiring (has_norm (has_norm fun_info)))) : normalizer_condition (semiring (has_norm (has_norm fun_info))) := sorry --non-trivial
lemma new_lemma_66478 (h1 : ring (has_nnnorm (comm_ring (has_nnnorm reducibility_hints)))) : is_domain (has_nnnorm (comm_ring (has_nnnorm reducibility_hints))) := sorry --non-trivial
lemma new_lemma_66479 (h0 : topological_space (left_cancel_semigroup (semiring congr_arg_kind))) : topological_space.separable_space (left_cancel_semigroup (semiring congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_66480 (h0 : function.extfun Type (functor.add_const (list nnreal))) : palindrome (functor.add_const.run (function.extfun_app h0 num)) := sorry --non-trivial
lemma new_lemma_66481 (h0 : filter (has_nndist (has_add environment.implicit_infer_kind))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_66482 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @normal_space.{0} (ordered_comm_monoid.{0} real) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (ordered_comm_monoid.{0} real))  := sorry --non-trivial
lemma new_lemma_66483 (h0 : topological_space (has_to_string (has_pos_part (has_pos_part (has_pos_part linarith.comp))))) : path_connected_space (has_to_string (has_pos_part (has_pos_part (has_pos_part linarith.comp)))) := sorry --non-trivial
lemma new_lemma_66484 (h0 : functor.add_const (filter (has_add pos)) (ring (has_add (has_add Type)))) : countable_Inter_filter (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_66485 (h0 : topological_space (boolean_algebra.core (ring pos))) : sequential_space (boolean_algebra.core (ring pos)) := sorry --non-trivial
lemma new_lemma_66486 (h0 : function.extfun (Type 1) finset) : finset.nonempty (function.extfun_app h0 (plift num)) := sorry --non-trivial
lemma new_lemma_66487 (h0 : function.extfun Type (functor.add_const Prop)) : functor.add_const.run (function.extfun_app h0 (ring name)) := sorry --non-trivial
lemma new_lemma_66488 (h0 : group (has_zero (finset Type))) : group.fg (has_zero (finset Type)) := sorry --non-trivial
lemma new_lemma_66489 (h0 : functor.add_const (uniform_space (has_zero pos)) (has_add Type)) : @separated_space.{0} (has_zero.{0} pos) (@functor.add_const.run.{0 1} (uniform_space.{0} (has_zero.{0} pos)) (has_add.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_66490 (h0 : not (function.extfun Type group -> false)) : @is_cyclic.{0} (linear_ordered_comm_ring.{0} empty) (@function.extfun_app.{2 1} Type group.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type group.{0}) h0) (linear_ordered_comm_ring.{0} empty))  := sorry --non-trivial
lemma new_lemma_66491 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @rank_condition.{0} (has_norm.{0} empty) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (has_norm.{0} empty))  := sorry --non-trivial
lemma new_lemma_66492 (h1 : topological_space empty) : totally_separated_space empty := sorry --non-trivial
lemma new_lemma_66493 (h0 : filter Prop) : @filter.Liminf.{0} Prop (@complete_lattice.to_conditionally_complete_lattice.{0} Prop Prop.complete_lattice) h0  := sorry --non-trivial
lemma new_lemma_66494 (h0 : functor.add_const (function.extfun (Type 1) topological_space) environment.implicit_infer_kind) : @t1_space.{1} (has_zero.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) topological_space.{1}) environment.implicit_infer_kind h0) (has_zero.{1} Type))  := sorry --non-trivial
lemma new_lemma_66495 (h1 : ring (with_zero string_imp)) : strong_rank_condition (with_zero string_imp) := sorry --non-trivial
lemma new_lemma_66496 (h0 : ordered_comm_monoid (has_Inf (ring name))) : has_exists_mul_of_le (has_Inf (ring name)) := sorry --non-trivial
lemma new_lemma_66497 (h0 : topological_space (linear_ordered_comm_group_with_zero string.iterator_imp)) : t0_space (linear_ordered_comm_group_with_zero string.iterator_imp) := sorry --non-trivial
lemma new_lemma_66498 (h0 : topological_space (boolean_algebra.core (has_neg name))) : irreducible_space (boolean_algebra.core (has_neg name)) := sorry --non-trivial
lemma new_lemma_66499 (h0 : function.extfun Type topological_space) : @sequential_space.{0} (semigroup.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (semigroup.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_66500 (h0 : complete_lattice (measurable_space (has_inv (has_inv to_additive.value_type)))) : is_atomistic (measurable_space (has_inv (has_inv to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_66501 (h0 : add_monoid (has_to_string (has_neg_part pos))) : add_monoid.fg (has_to_string (has_neg_part pos)) := sorry --non-trivial
lemma new_lemma_66502 (h0 : ring (encodable (random_gen to_additive.value_type))) : is_domain (encodable (random_gen to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_66503 (h0 : uniform_space (has_neg_part (has_neg_part pos))) : complete_space (has_neg_part (has_neg_part pos)) := sorry --non-trivial
lemma new_lemma_66504 (h1 : function.extfun Type group) : @normalizer_condition.{0} (complete_semilattice_Sup.{0} fun_info) (@function.extfun_app.{2 1} Type group.{0} h1 (complete_semilattice_Sup.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_66505 (h0 : function.extfun Type topological_space) : @locally_compact_space.{0} (has_zero.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_zero.{0} num))  := sorry --non-trivial
lemma new_lemma_66506 (h0 : ring (has_append (denumerable linarith.ineq))) : is_domain (has_append (denumerable linarith.ineq)) := sorry --non-trivial
lemma new_lemma_66507 (h0 : not (function.extfun Type ring -> false)) : @strong_rank_condition.{0} (measure_theory.measure_space.{0} unsigned) (@function.extfun_app.{2 1} Type ring.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type ring.{0}) h0) (measure_theory.measure_space.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_66508 (h0 : empty) : @archimedean.{0} (semilattice_inf.{0} empty) (@empty.elim.{1} (ordered_add_comm_monoid.{0} (semilattice_inf.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_66509 (h0 : uniform_space (has_add (has_to_string (has_to_string unsigned)))) : complete_space (has_add (has_to_string (has_to_string unsigned))) := sorry --non-trivial
lemma new_lemma_66510 (h0 : ring (canonically_ordered_comm_semiring (comm_group pos))) : strong_rank_condition (canonically_ordered_comm_semiring (comm_group pos)) := sorry --non-trivial
lemma new_lemma_66511 (h0 : functor.add_const (topological_space (ordered_comm_ring name)) Type) : @normal_space.{0} (ordered_comm_ring.{0} name) (@functor.add_const.run.{0 1} (topological_space.{0} (ordered_comm_ring.{0} name)) Type h0)  := sorry --non-trivial
lemma new_lemma_66512 (h0 : ring (has_add fun_info)) : rank_condition (has_add fun_info) := sorry --non-trivial
lemma new_lemma_66513 (h0 : function.extfun Type list) : palindrome (function.extfun_app h0 (left_cancel_monoid (option unsigned))) := sorry --non-trivial
lemma new_lemma_66514 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @filter.Limsup.{0} Prop (@complete_lattice.to_conditionally_complete_lattice.{0} Prop Prop.complete_lattice) (@function.extfun_app.{2 1} Type filter.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 filter.{0}) Prop)  := sorry --non-trivial
lemma new_lemma_66515 (h0 : functor.add_const (function.extfun Type add_monoid) environment.implicit_infer_kind) : @add_monoid.fg.{0} (finset.{0} pos) (@function.extfun_app.{2 1} Type add_monoid.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type add_monoid.{0}) environment.implicit_infer_kind h0) (finset.{0} pos))  := sorry --non-trivial
lemma new_lemma_66516 (h0 : group (add_cancel_monoid (has_neg_part name))) : group.fg (add_cancel_monoid (has_neg_part name)) := sorry --non-trivial
lemma new_lemma_66517 (h0 : functor.add_const (group (has_zero Type)) environment.implicit_infer_kind) : @is_cyclic.{1} (has_zero.{1} Type) (@functor.add_const.run.{1 0} (group.{1} (has_zero.{1} Type)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_66518 (h0 : function.extfun Type topological_space) : @t0_space.{0} (has_ssubset.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_ssubset.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_66519 (h0 : topological_space (complete_distrib_lattice (has_add name))) : preconnected_space (complete_distrib_lattice (has_add name)) := sorry --non-trivial
lemma new_lemma_66520 (h0 : topological_space (has_Inf (ring (has_add pos)))) : preirreducible_space (has_Inf (ring (has_add pos))) := sorry --non-trivial
lemma new_lemma_66521 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @complete_lattice.is_Sup_finite_compact.{0} (dlist.{0} fun_info) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (dlist.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_66522 (h0 : functor.add_const (complete_lattice (has_dist unsigned)) num) : @is_atomistic.{0} (has_dist.{0} unsigned) (@functor.add_const.run.{0 0} (complete_lattice.{0} (has_dist.{0} unsigned)) num h0)  := sorry --non-trivial
lemma new_lemma_66523 (h0 : not (function.extfun Type ring -> false)) : @is_domain.{0} (has_union.{0} unsigned) (@function.extfun_app.{2 1} Type ring.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type ring.{0}) h0) (has_union.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_66524 (h0 : functor.add_const (function.extfun Type group) congr_arg_kind) : @is_cyclic.{0} linarith.comp_source (@function.extfun_app.{2 1} Type group.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type group.{0}) congr_arg_kind h0) linarith.comp_source)  := sorry --non-trivial
lemma new_lemma_66525 (h0 : functor.add_const (topological_space (left_cancel_monoid num)) empty) : @t0_space.{0} (left_cancel_monoid.{0} num) (@functor.add_const.run.{0 0} (topological_space.{0} (left_cancel_monoid.{0} num)) empty h0)  := sorry --non-trivial
lemma new_lemma_66526 (h0 : functor.add_const (group (has_nndist unsigned)) environment.implicit_infer_kind) : @group.fg.{0} (has_nndist.{0} unsigned) (@functor.add_const.run.{0 0} (group.{0} (has_nndist.{0} unsigned)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_66527 (h0 : functor.add_const (list (add_cancel_monoid Type)) name) : list.nodup (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_66528 (h0 : uniform_space (comm_group (ring Type))) : separated_space (comm_group (ring Type)) := sorry --non-trivial
lemma new_lemma_66529 (h0 : ring (mul_zero_class (random_gen (random_gen fun_info)))) : rank_condition (mul_zero_class (random_gen (random_gen fun_info))) := sorry --non-trivial
lemma new_lemma_66530 (h0 : functor.add_const (group (measure_theory.measure_space empty)) num) : @normalizer_condition.{0} (measure_theory.measure_space.{0} empty) (@functor.add_const.run.{0 0} (group.{0} (measure_theory.measure_space.{0} empty)) num h0)  := sorry --non-trivial
lemma new_lemma_66531 (h0 : function.extfun Type topological_space) : @t1_space.{0} (boolean_algebra.{0} (finset.{0} name)) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (boolean_algebra.{0} (finset.{0} name)))  := sorry --non-trivial
lemma new_lemma_66532 (h0 : functor.add_const (add_monoid (add_comm_monoid environment.implicit_infer_kind)) Type) : @add_monoid.fg.{0} (add_comm_monoid.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 1} (add_monoid.{0} (add_comm_monoid.{0} environment.implicit_infer_kind)) Type h0)  := sorry --non-trivial
lemma new_lemma_66533 (h0 : group (has_norm to_additive.value_type)) : is_cyclic (has_norm to_additive.value_type) := sorry --non-trivial
lemma new_lemma_66534 (h0 : group (with_bot (random_gen to_additive.value_type))) : normalizer_condition (with_bot (random_gen to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_66535 (h0 : not (complete_lattice (mul_one_class linarith.comp_source) -> false)) : @complete_lattice.is_Sup_finite_compact.{0} (mul_one_class.{0} linarith.comp_source) (@classical.by_contradiction'.{1} (complete_lattice.{0} (mul_one_class.{0} linarith.comp_source)) h0)  := sorry --non-trivial
lemma new_lemma_66536 (h0 : group (boolean_algebra (has_add (ring (has_neg (has_add Type)))))) : is_simple_group (boolean_algebra (has_add (ring (has_neg (has_add Type))))) := sorry --non-trivial
lemma new_lemma_66537 (h0 : topological_space (measurable_space.dynkin_system (semiring (option unsigned)))) : totally_separated_space (measurable_space.dynkin_system (semiring (option unsigned))) := sorry --non-trivial
lemma new_lemma_66538 (h0 : functor.add_const (group (omega_complete_partial_order unsigned)) unsigned) : @group.fg.{0} (omega_complete_partial_order.{0} unsigned) (@functor.add_const.run.{0 0} (group.{0} (omega_complete_partial_order.{0} unsigned)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_66539 (h0 : group (has_norm (random_gen fun_info))) : is_cyclic (has_norm (random_gen fun_info)) := sorry --non-trivial
lemma new_lemma_66540 (h0 : cancel_comm_monoid_with_zero (semigroup (has_add unsigned))) : unique_factorization_monoid (semigroup (has_add unsigned)) := sorry --non-trivial
lemma new_lemma_66541 (h0 : ring (comm_ring (random_gen to_additive.value_type))) : rank_condition (comm_ring (random_gen to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_66542 (h0 : ring (add_cancel_monoid (has_pos_part linarith.comp))) : strong_rank_condition (add_cancel_monoid (has_pos_part linarith.comp)) := sorry --non-trivial
lemma new_lemma_66543 (h0 : topological_space (has_zero (has_neg Type))) : t0_space (has_zero (has_neg Type)) := sorry --non-trivial
lemma new_lemma_66544 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @rank_condition.{0} (ordered_cancel_add_comm_monoid.{0} empty) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (ordered_cancel_add_comm_monoid.{0} empty))  := sorry --non-trivial
lemma new_lemma_66545 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_atomistic.{0} (linear_ordered_comm_group.{0} empty) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (linear_ordered_comm_group.{0} empty))  := sorry --non-trivial
lemma new_lemma_66546 (h0 : ring (comm_monoid congr_arg_kind)) : is_principal_ideal_ring (comm_monoid congr_arg_kind) := sorry --non-trivial
lemma new_lemma_66547 (h0 : list (has_emptyc (has_top (has_top (has_top (has_top (has_top linarith.comp_source))))))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_66548 (h0 : functor.add_const (ordered_comm_monoid pos) (ring linarith.comp)) : @has_exists_mul_of_le.{0} pos (@functor.add_const.run.{0 0} (ordered_comm_monoid.{0} pos) (ring.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_66549 (h0 : topological_space (group_with_zero (option (group_with_zero ennreal)))) : t0_space (group_with_zero (option (group_with_zero ennreal))) := sorry --non-trivial
lemma new_lemma_66550 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @unique_factorization_monoid.{0} (comm_group.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type cancel_comm_monoid_with_zero.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 cancel_comm_monoid_with_zero.{0}) (comm_group.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_66551 (h0 : functor.add_const (function.extfun (Type 1) topological_space) pos) : @preconnected_space.{1} (ring.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) topological_space.{1}) pos h0) (ring.{1} Type))  := sorry --non-trivial
lemma new_lemma_66552 (h0 : not (uniform_space num -> false)) : @complete_space.{0} num (@classical.by_contradiction'.{1} (uniform_space.{0} num) h0)  := sorry --non-trivial
lemma new_lemma_66553 (h3 : ring char) : strong_rank_condition char := sorry --non-trivial
lemma new_lemma_66554 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_atomistic.{0} (comm_group.{0} pos) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (comm_group.{0} pos))  := sorry --non-trivial
lemma new_lemma_66555 (h0 : functor.add_const (list (has_to_string unsigned)) pos) : list.nodup (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_66556 (h0 : filter (comm_group (has_add Type))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_66557 (h0 : topological_space (has_nnnorm string_imp)) : locally_compact_space (has_nnnorm string_imp) := sorry --non-trivial
lemma new_lemma_66558 (h1 : topological_space (distrib (distrib (has_lt (linear_ordered_comm_ring (random_gen char)))))) : t0_space (distrib (distrib (has_lt (linear_ordered_comm_ring (random_gen char))))) := sorry --non-trivial
lemma new_lemma_66559 (h0 : functor.add_const (function.extfun (Type 1) semiring) Type) : @is_noetherian_ring.{1} Type (@function.extfun_app.{3 2} (Type 1) semiring.{1} (@functor.add_const.run.{2 1} (function.extfun.{3 2} (Type 1) semiring.{1}) Type h0) Type)  := sorry --non-trivial
lemma new_lemma_66560 (h0 : ring (random_gen (has_nnnorm (has_nnnorm linarith.ineq)))) : rank_condition (random_gen (has_nnnorm (has_nnnorm linarith.ineq))) := sorry --non-trivial
lemma new_lemma_66561 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @t0_space.{0} (cancel_monoid.{0} ennreal) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (cancel_monoid.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_66562 (h0 : bin_tree Prop) : list.head (bin_tree.to_list h0) := sorry --non-trivial
lemma new_lemma_66563 (h0 : topological_space (has_zero (has_add unsigned))) : topological_space.separable_space (has_zero (has_add unsigned)) := sorry --non-trivial
lemma new_lemma_66564 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @discrete_topology.{1} (add_cancel_monoid.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 topological_space.{1}) (add_cancel_monoid.{1} Type))  := sorry --non-trivial
lemma new_lemma_66565 (h0 : group (ring (finset (finset linarith.comp)))) : normalizer_condition (ring (finset (finset linarith.comp))) := sorry --non-trivial
lemma new_lemma_66566 (h0 : monoid (has_top (has_top (has_top fun_info)))) : monoid.fg (has_top (has_top (has_top fun_info))) := sorry --non-trivial
lemma new_lemma_66567 (h0 : functor.add_const (topological_space (ring name)) linarith.comp) : @preirreducible_space.{0} (ring.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (ring.{0} name)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_66568 (h0 : complete_lattice (random_gen (with_one unsigned))) : is_atomistic (random_gen (with_one unsigned)) := sorry --non-trivial
lemma new_lemma_66569 (h0 : uniform_space (comm_group (has_neg_part (mul_zero_class name)))) : separated_space (comm_group (has_neg_part (mul_zero_class name))) := sorry --non-trivial
lemma new_lemma_66570 (h0 : functor.add_const (uniform_space (has_neg linarith.comp)) Type) : @separated_space.{0} (has_neg.{0} linarith.comp) (@functor.add_const.run.{0 1} (uniform_space.{0} (has_neg.{0} linarith.comp)) Type h0)  := sorry --non-trivial
lemma new_lemma_66571 (h0 : functor.add_const (group (has_Inf Type)) linarith.comp) : @is_cyclic.{1} (has_Inf.{1} Type) (@functor.add_const.run.{1 0} (group.{1} (has_Inf.{1} Type)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_66572 (h0 : ring (has_nnnorm (has_nnnorm linarith.comp_source))) : rank_condition (has_nnnorm (has_nnnorm linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_66573 (h0 : not (filter (fintype char) -> false)) : filter.ne_bot (classical.by_contradiction' h0) := sorry --non-trivial
lemma new_lemma_66574 (h0 : functor.add_const (topological_space (normed_comm_ring rat)) pos) : @loc_path_connected_space.{0} (normed_comm_ring.{0} rat) (@functor.add_const.run.{0 0} (topological_space.{0} (normed_comm_ring.{0} rat)) pos h0)  := sorry --non-trivial
lemma new_lemma_66575 (h0 : complete_lattice (canonically_ordered_comm_semiring congr_arg_kind)) : is_atomistic (canonically_ordered_comm_semiring congr_arg_kind) := sorry --non-trivial
lemma new_lemma_66576 (h0 : ordered_add_comm_monoid (simple_graph empty)) : archimedean (simple_graph empty) := sorry --non-trivial
lemma new_lemma_66577 (h0 : topological_space (has_pos_part (has_add Type))) : t0_space (has_pos_part (has_add Type)) := sorry --non-trivial
lemma new_lemma_66578 (h0 : functor.add_const (complete_lattice (comm_group name)) environment.implicit_infer_kind) : @complete_lattice.is_Sup_finite_compact.{0} (comm_group.{0} name) (@functor.add_const.run.{0 0} (complete_lattice.{0} (comm_group.{0} name)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_66579 (h0 : add_group (id (semiring linarith.comp))) : is_add_cyclic (id (semiring linarith.comp)) := sorry --non-trivial
lemma new_lemma_66580 (h0 : filter (has_zero (finset (finset (finset pos))))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_66581 (h2 : add_group (has_top linarith.ineq)) : is_add_cyclic (has_top linarith.ineq) := sorry --non-trivial
lemma new_lemma_66582 (h0 : topological_space (random_gen (has_ssubset linarith.ineq))) : irreducible_space (random_gen (has_ssubset linarith.ineq)) := sorry --non-trivial
lemma new_lemma_66583 (h0 : uniform_space (is_R_or_C num)) : separated_space (is_R_or_C num) := sorry --non-trivial
lemma new_lemma_66584 (h0 : group (has_to_string (option (option ennreal)))) : normalizer_condition (has_to_string (option (option ennreal))) := sorry --non-trivial
lemma new_lemma_66585 (h0 : group (ring ennreal)) : is_simple_group (ring ennreal) := sorry --non-trivial
lemma new_lemma_66586 (h0 : uniform_space (plift num)) : complete_space (plift num) := sorry --non-trivial
lemma new_lemma_66587 (h0 : ring (add_cancel_monoid (comm_group (comm_group ennreal)))) : is_principal_ideal_ring (add_cancel_monoid (comm_group (comm_group ennreal))) := sorry --non-trivial
lemma new_lemma_66588 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @irreducible_space.{0} (has_neg.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_neg.{0} name))  := sorry --non-trivial
lemma new_lemma_66589 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : list.nodup (function.extfun_app (function.extfun_app h0 list) (has_ssubset linarith.ineq)) := sorry --non-trivial
lemma new_lemma_66590 (h0 : functor.comp group complete_distrib_lattice unsigned) : @normalizer_condition.{0} (complete_distrib_lattice.{0} unsigned) (@functor.comp.run.{0 0 0} group.{0} complete_distrib_lattice.{0} unsigned h0)  := sorry --non-trivial
lemma new_lemma_66591 (h0 : topological_space (add_cancel_monoid (has_mul name))) : preirreducible_space (add_cancel_monoid (has_mul name)) := sorry --non-trivial
lemma new_lemma_66592 (h0 : topological_space (monoid ennreal)) : preirreducible_space (monoid ennreal) := sorry --non-trivial
lemma new_lemma_66593 (h0 : functor.add_const (group (has_to_string linarith.comp)) (has_neg Type)) : @normalizer_condition.{0} (has_to_string.{0} linarith.comp) (@functor.add_const.run.{0 1} (group.{0} (has_to_string.{0} linarith.comp)) (has_neg.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_66594 (h0 : complete_lattice (random_gen (has_nnnorm linarith.comp_source))) : is_compactly_generated (random_gen (has_nnnorm linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_66595 (h0 : functor.add_const Prop (has_neg_part Type)) : functor.add_const.run h0 := sorry --non-trivial
lemma new_lemma_66596 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @irreducible_space.{0} (has_neg_part.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_neg_part.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_66597 (h0 : function.extfun Type filter) : countable_Inter_filter (function.extfun_app h0 (boolean_algebra.core num)) := sorry --non-trivial
lemma new_lemma_66598 (h0 : functor.add_const (ring (normed_comm_ring pos)) (ring pos)) : @is_domain.{0} (normed_comm_ring.{0} pos) (@functor.add_const.run.{0 0} (ring.{0} (normed_comm_ring.{0} pos)) (ring.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_66599 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_compactly_generated.{0} (linear_ordered_comm_group.{0} ennreal) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (linear_ordered_comm_group.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_66600 (h0 : ordered_add_comm_monoid (non_assoc_semiring (semiring empty))) : archimedean (non_assoc_semiring (semiring empty)) := sorry --non-trivial
lemma new_lemma_66601 (h0 : functor.add_const (finset (simple_graph Type)) Type) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_66602 (h0 : not (topological_space (non_assoc_semiring unsigned) -> false)) : @preirreducible_space.{0} (non_assoc_semiring.{0} unsigned) (@classical.by_contradiction'.{1} (topological_space.{0} (non_assoc_semiring.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_66603 (h0 : functor.add_const (function.extfun (Type 1) filter) Type) : countable_Inter_filter (function.extfun_app (functor.add_const.run h0) (has_Inf Type)) := sorry --non-trivial
lemma new_lemma_66604 (h2 : ring (comm_ring (metric_space to_additive.value_type))) : strong_rank_condition (comm_ring (metric_space to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_66605 (h0 : function.extfun Type uniform_space) : @separated_space.{0} (is_R_or_C.{0} unsigned) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (is_R_or_C.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_66606 (h0 : functor.add_const (uniform_space (normed_comm_ring linarith.comp)) Type) : @separated_space.{0} (normed_comm_ring.{0} linarith.comp) (@functor.add_const.run.{0 1} (uniform_space.{0} (normed_comm_ring.{0} linarith.comp)) Type h0)  := sorry --non-trivial
lemma new_lemma_66607 (h0 : finset (has_neg_part (has_nndist environment.implicit_infer_kind))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_66608 (h0 : functor.add_const (ring (boolean_algebra pos)) unsigned) : @is_principal_ideal_ring.{0} (boolean_algebra.{0} pos) (@functor.add_const.run.{0 0} (ring.{0} (boolean_algebra.{0} pos)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_66609 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @t0_space.{0} (has_nnnorm.{0} fun_info) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_nnnorm.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_66610 (h0 : function.extfun Type (functor.add_const (list (add_group empty)))) : palindrome (functor.add_const.run (function.extfun_app h0 empty)) := sorry --non-trivial
lemma new_lemma_66611 (h1 : add_group (distrib_lattice (has_nnnorm fun_info))) : is_add_cyclic (distrib_lattice (has_nnnorm fun_info)) := sorry --non-trivial
lemma new_lemma_66612 (h0 : functor.add_const (complete_lattice (semigroup empty)) (option (option unsigned))) : @is_compactly_generated.{0} (semigroup.{0} empty) (@functor.add_const.run.{0 0} (complete_lattice.{0} (semigroup.{0} empty)) (option.{0} (option.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_66613 (h0 : function.extfun Type topological_space) : @path_connected_space.{0} (@id.{2} Type (has_top.{0} (has_top.{0} (add_right_cancel_monoid.{0} (has_top.{0} fun_info))))) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (@id.{2} Type (has_top.{0} (has_top.{0} (add_right_cancel_monoid.{0} (has_top.{0} fun_info))))))  := sorry --non-trivial
lemma new_lemma_66614 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @normal_space.{0} (normed_lattice_add_comm_group.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (normed_lattice_add_comm_group.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_66615 (h0 : group (add_right_cancel_monoid (semiring (semiring (semiring empty))))) : is_cyclic (add_right_cancel_monoid (semiring (semiring (semiring empty)))) := sorry --non-trivial
lemma new_lemma_66616 (h0 : group (has_Inf (ring linarith.comp))) : is_simple_group (has_Inf (ring linarith.comp)) := sorry --non-trivial
lemma new_lemma_66617 (h0 : monoid (add_cancel_monoid (has_pos_part (has_add Type)))) : monoid.fg (add_cancel_monoid (has_pos_part (has_add Type))) := sorry --non-trivial
lemma new_lemma_66618 (h0 : function.extfun Type topological_space) : @irreducible_space.{0} (add_comm_monoid.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (add_comm_monoid.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_66619 (h0 : function.extfun Type topological_space) : @normal_space.{0} (group_with_zero.{0} (option.{0} ennreal)) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (group_with_zero.{0} (option.{0} ennreal)))  := sorry --non-trivial
lemma new_lemma_66620 (h0 : ring ordering) : strong_rank_condition ordering := sorry --non-trivial
lemma new_lemma_66621 (h0 : group (has_append reducibility_hints)) : is_cyclic (has_append reducibility_hints) := sorry --non-trivial
lemma new_lemma_66622 (h0 : functor.add_const (topological_space (has_neg_part environment.implicit_infer_kind)) pos) : @totally_disconnected_space.{0} (has_neg_part.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (has_neg_part.{0} environment.implicit_infer_kind)) pos h0)  := sorry --non-trivial
lemma new_lemma_66623 (h0 : complete_lattice (has_add (has_add (has_add real)))) : is_atomistic (has_add (has_add (has_add real))) := sorry --non-trivial
lemma new_lemma_66624 (h0 : list (semigroup environment.implicit_infer_kind)) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_66625 (h0 : uniform_space name) : complete_space name := sorry --non-trivial
lemma new_lemma_66626 (h0 : topological_space (complete_linear_order to_additive.value_type)) : path_connected_space (complete_linear_order to_additive.value_type) := sorry --non-trivial
lemma new_lemma_66627 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @is_simple_group.{1} (sub_neg_monoid.{1} Type) (@function.extfun_app.{3 2} (Type 1) group.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 group.{1}) (sub_neg_monoid.{1} Type))  := sorry --non-trivial
lemma new_lemma_66628 (h0 : functor.add_const (group (add_comm_monoid Type)) linarith.comp) : @is_cyclic.{1} (add_comm_monoid.{1} Type) (@functor.add_const.run.{1 0} (group.{1} (add_comm_monoid.{1} Type)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_66629 (h0 : group (bin_tree fun_info)) (h1 : ring (group_topology (bin_tree fun_info))) : strong_rank_condition (group_topology (bin_tree fun_info)) := sorry --non-trivial
lemma new_lemma_66630 (h0 : topological_space (finset (has_Inf (finset (finset pos))))) : locally_compact_space (finset (has_Inf (finset (finset pos)))) := sorry --non-trivial
lemma new_lemma_66631 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @rank_condition.{0} (linear_ordered_add_comm_group.{0} linarith.ineq) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (linear_ordered_add_comm_group.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_66632 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @monoid.fg.{1} (has_neg.{1} Type) (@function.extfun_app.{3 2} (Type 1) monoid.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 monoid.{1}) (has_neg.{1} Type))  := sorry --non-trivial
lemma new_lemma_66633 (h0 : topological_space (add_comm_monoid congr_arg_kind)) : normal_space (add_comm_monoid congr_arg_kind) := sorry --non-trivial
lemma new_lemma_66634 (h0 : function.extfun Type group) : @group.fg.{0} (@id.{2} Type num) (@function.extfun_app.{2 1} Type group.{0} h0 (@id.{2} Type num))  := sorry --non-trivial
lemma new_lemma_66635 (h1 : has_mul (dlist char)) (h2 : topological_space (con (dlist char))) : path_connected_space (con (dlist char)) := sorry --non-trivial
lemma new_lemma_66636 (h0 : function.extfun Type group) : @group.fg.{0} (complete_distrib_lattice.{0} name) (@function.extfun_app.{2 1} Type group.{0} h0 (complete_distrib_lattice.{0} name))  := sorry --non-trivial
lemma new_lemma_66637 (h0 : functor.add_const (topological_space (has_to_string name)) environment.implicit_infer_kind) : @totally_separated_space.{0} (has_to_string.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (has_to_string.{0} name)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_66638 (h0 : fin has_zero.zero) : @regular_space.{0} (ordered_comm_monoid.{0} linarith.comp) (@matrix.vec_empty.{0} (topological_space.{0} (ordered_comm_monoid.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_66639 (h0 : topological_space (has_nndist (has_Inf (has_add Type)))) : normal_space (has_nndist (has_Inf (has_add Type))) := sorry --non-trivial
lemma new_lemma_66640 (h0 : measurable_space (nondiscrete_normed_field linarith.comp_source)) (h1 : measure_theory.measure (nondiscrete_normed_field linarith.comp_source)) : measure_theory.is_finite_measure h1 := sorry --non-trivial
lemma new_lemma_66641 (h0 : group (has_zero (has_add name))) : is_cyclic (has_zero (has_add name)) := sorry --non-trivial
lemma new_lemma_66642 (h0 : ring (add_cancel_monoid (boolean_algebra.core (semigroup name)))) : is_principal_ideal_ring (add_cancel_monoid (boolean_algebra.core (semigroup name))) := sorry --non-trivial
lemma new_lemma_66643 (h0 : functor.add_const (ordered_comm_monoid (boolean_algebra.core pos)) name) : @has_exists_mul_of_le.{0} (boolean_algebra.core.{0} pos) (@functor.add_const.run.{0 0} (ordered_comm_monoid.{0} (boolean_algebra.core.{0} pos)) name h0)  := sorry --non-trivial
lemma new_lemma_66644 (h0 : topological_space (add_right_cancel_monoid (semiring congr_arg_kind))) : t0_space (add_right_cancel_monoid (semiring congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_66645 (h0 : finset (has_bot congr_arg_kind)) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_66646 (h0 : uniform_space (boolean_algebra.core (comm_group name))) : separated_space (boolean_algebra.core (comm_group name)) := sorry --non-trivial
lemma new_lemma_66647 (h0 : prod (measurable_space.dynkin_system unsigned) (measurable_space.dynkin_system unsigned)) : id_rel h0 := sorry --non-trivial
lemma new_lemma_66648 (h0 : functor.add_const (semiring (add_cancel_monoid unsigned)) num) : @is_noetherian_ring.{0} (add_cancel_monoid.{0} unsigned) (@functor.add_const.run.{0 0} (semiring.{0} (add_cancel_monoid.{0} unsigned)) num h0)  := sorry --non-trivial
lemma new_lemma_66649 (h0 : ring (normed_field (mul_one_class linarith.ineq))) : rank_condition (normed_field (mul_one_class linarith.ineq)) := sorry --non-trivial
lemma new_lemma_66650 (h0 : function.extfun Type (functor.add_const (topological_space Type))) : @preconnected_space.{1} Type (@functor.add_const.run.{1 0} (topological_space.{1} Type) linarith.comp (@function.extfun_app.{2 2} Type (functor.add_const.{1 0} (topological_space.{1} Type)) h0 linarith.comp))  := sorry --non-trivial
lemma new_lemma_66651 (h0 : complete_lattice (has_bot (has_bot empty))) : is_compactly_generated (has_bot (has_bot empty)) := sorry --non-trivial
lemma new_lemma_66652 (h0 : semiring (has_add (ring linarith.comp))) : is_noetherian_ring (has_add (ring linarith.comp)) := sorry --non-trivial
lemma new_lemma_66653 (h0 : complete_lattice (has_nnnorm (has_nnnorm linarith.comp_source))) : is_compactly_generated (has_nnnorm (has_nnnorm linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_66654 (h0 : topological_space (measurable_space.dynkin_system (add_group linarith.comp))) : preirreducible_space (measurable_space.dynkin_system (add_group linarith.comp)) := sorry --non-trivial
lemma new_lemma_66655 (h0 : fin has_zero.zero) : @normalizer_condition.{0} (comm_semigroup.{0} pos) (@matrix.vec_empty.{0} (group.{0} (comm_semigroup.{0} pos)) (@matrix.vec_empty.{0} (fin (@has_zero.zero.{0} nat nat.has_zero)) h0))  := sorry --non-trivial
lemma new_lemma_66656 (h0 : topological_space (id (has_norm empty))) : discrete_topology (id (has_norm empty)) := sorry --non-trivial
lemma new_lemma_66657 (h0 : topological_space (has_bot pos)) : path_connected_space (has_bot pos) := sorry --non-trivial
lemma new_lemma_66658 (h0 : functor.comp ring normed_comm_ring name) : @is_principal_ideal_ring.{0} (normed_comm_ring.{0} name) (@functor.comp.run.{0 0 0} ring.{0} normed_comm_ring.{0} name h0)  := sorry --non-trivial
lemma new_lemma_66659 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @t0_space.{0} (as_linear_order.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (as_linear_order.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_66660 (h0 : ordered_add_comm_monoid (semigroup (has_add (has_zero Type)))) : archimedean (semigroup (has_add (has_zero Type))) := sorry --non-trivial
lemma new_lemma_66661 (h0 : set (has_lt (mul_one_class enat))) : set.finite h0 := sorry --non-trivial
lemma new_lemma_66662 (h0 : ring (has_star (option unsigned))) : rank_condition (has_star (option unsigned)) := sorry --non-trivial
lemma new_lemma_66663 (h0 : add_group (finset (option (option (option (option (option pos))))))) : is_add_cyclic (finset (option (option (option (option (option pos)))))) := sorry --non-trivial
lemma new_lemma_66664 (h0 : group (as_linear_order num)) : is_cyclic (as_linear_order num) := sorry --non-trivial
lemma new_lemma_66665 (h0 : function.extfun Type ring) : @strong_rank_condition.{0} (has_norm.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type ring.{0} h0 (has_norm.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_66666 (h0 : cancel_comm_monoid_with_zero (has_nndist pos)) : unique_factorization_monoid (has_nndist pos) := sorry --non-trivial
lemma new_lemma_66667 (h0 : function.extfun (Type 1) add_group) : @is_add_cyclic.{1} (generalized_boolean_algebra.{1} Type) (@function.extfun_app.{3 2} (Type 1) add_group.{1} h0 (generalized_boolean_algebra.{1} Type))  := sorry --non-trivial
lemma new_lemma_66668 (h0 : add_group (has_Inf (has_add (has_add real)))) : is_add_cyclic (has_Inf (has_add (has_add real))) := sorry --non-trivial
lemma new_lemma_66669 (h0 : topological_space (normed_linear_ordered_group congr_arg_kind)) : loc_path_connected_space (normed_linear_ordered_group congr_arg_kind) := sorry --non-trivial
lemma new_lemma_66670 (h0 : topological_space (boolean_algebra (has_Inf linarith.comp))) : totally_separated_space (boolean_algebra (has_Inf linarith.comp)) := sorry --non-trivial
lemma new_lemma_66671 (h0 : fin has_zero.zero) : @locally_compact_space.{0} (ordered_comm_ring.{0} real) (@matrix.vec_empty.{0} (topological_space.{0} (ordered_comm_ring.{0} real)) (@matrix.vec_empty.{0} (fin (@has_zero.zero.{0} nat nat.has_zero)) h0))  := sorry --non-trivial
lemma new_lemma_66672 (h0 : topological_space (boolean_algebra.core (boolean_algebra name))) : regular_space (boolean_algebra.core (boolean_algebra name)) := sorry --non-trivial
lemma new_lemma_66673 (h0 : function.extfun Type filter) : filter.ne_bot (function.extfun_app h0 (omega_complete_partial_order unsigned)) := sorry --non-trivial
lemma new_lemma_66674 (h2 : ring (mul_one_class char)) : rank_condition (mul_one_class char) := sorry --non-trivial
lemma new_lemma_66675 (h0 : functor.add_const (topological_space (has_neg Type)) pos) : @normal_space.{1} (has_neg.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (has_neg.{1} Type)) pos h0)  := sorry --non-trivial
lemma new_lemma_66676 (h0 : filter (finset (finset pos))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_66677 (h0 : ring (add_monoid (random_gen char))) : strong_rank_condition (add_monoid (random_gen char)) := sorry --non-trivial
lemma new_lemma_66678 (h0 : functor.add_const (complete_lattice (add_cancel_monoid unsigned)) (has_add (has_add Type))) : @complete_lattice.is_Sup_finite_compact.{0} (add_cancel_monoid.{0} unsigned) (@functor.add_const.run.{0 1} (complete_lattice.{0} (add_cancel_monoid.{0} unsigned)) (has_add.{1} (has_add.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_66679 (h0 : topological_space (has_norm (random_gen (random_gen fun_info)))) : t0_space (has_norm (random_gen (random_gen fun_info))) := sorry --non-trivial
lemma new_lemma_66680 (h0 : fin has_zero.zero) : @has_exists_mul_of_le.{0} (ordered_comm_ring.{0} real) (@matrix.vec_empty.{0} (ordered_comm_monoid.{0} (ordered_comm_ring.{0} real)) (@matrix.vec_empty.{0} (fin (@has_zero.zero.{0} nat nat.has_zero)) h0))  := sorry --non-trivial
lemma new_lemma_66681 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @totally_separated_space.{0} unsigned (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) unsigned)  := sorry --non-trivial
lemma new_lemma_66682 (h0 : function.extfun Type (functor.add_const (topological_space (non_assoc_semiring unsigned)))) : @discrete_topology.{0} (non_assoc_semiring.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (non_assoc_semiring.{0} unsigned)) empty (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (topological_space.{0} (non_assoc_semiring.{0} unsigned))) h0 empty))  := sorry --non-trivial
lemma new_lemma_66683 (h0 : complete_lattice (has_neg (has_neg pos))) : complete_lattice.is_Sup_finite_compact (has_neg (has_neg pos)) := sorry --non-trivial
lemma new_lemma_66684 (h0 : function.extfun (Type 1) group) : @group.fg.{1} Type (@function.extfun_app.{3 2} (Type 1) group.{1} h0 Type)  := sorry --non-trivial
lemma new_lemma_66685 (h0 : functor.add_const (topological_space (has_to_string empty)) num) : @locally_compact_space.{0} (has_to_string.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (has_to_string.{0} empty)) num h0)  := sorry --non-trivial
lemma new_lemma_66686 (h0 : topological_space (has_nndist (has_nndist (finset Type)))) : path_connected_space (has_nndist (has_nndist (finset Type))) := sorry --non-trivial
lemma new_lemma_66687 (h0 : list (option congr_arg_kind)) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_66688 (h0 : ring (metric_space (metric_space reducibility_hints))) : rank_condition (metric_space (metric_space reducibility_hints)) := sorry --non-trivial
lemma new_lemma_66689 (h0 : function.extfun Type complete_lattice) : @complete_lattice.is_Sup_finite_compact.{0} (boolean_algebra.{0} (semigroup.{0} name)) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (boolean_algebra.{0} (semigroup.{0} name)))  := sorry --non-trivial
lemma new_lemma_66690 (h0 : has_mem.mem topological_space has_emptyc.emptyc) : @t0_space.{0} linarith.comp_source (@function.extfun_app.{2 1} Type topological_space.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) topological_space.{0} h0) linarith.comp_source)  := sorry --non-trivial
lemma new_lemma_66691 (h0 : ring (measurable_space complex)) : rank_condition (measurable_space complex) := sorry --non-trivial
lemma new_lemma_66692 (h0 : function.extfun Type ring) : @rank_condition.{0} (with_bot.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type ring.{0} h0 (with_bot.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_66693 (h0 : topological_space (add_right_cancel_monoid num)) : path_connected_space (add_right_cancel_monoid num) := sorry --non-trivial
lemma new_lemma_66694 (h0 : topological_space (nondiscrete_normed_field (add_comm_semigroup (add_comm_semigroup linarith.ineq)))) (h1 : set (nondiscrete_normed_field (add_comm_semigroup (add_comm_semigroup linarith.ineq)))) : is_path_connected h1 := sorry --non-trivial
lemma new_lemma_66695 (h0 : cancel_comm_monoid_with_zero (has_add congr_arg_kind)) : unique_factorization_monoid (has_add congr_arg_kind) := sorry --non-trivial
lemma new_lemma_66696 (h0 : functor.add_const (group (normed_comm_ring pos)) (has_neg_part pos)) : @group.fg.{0} (normed_comm_ring.{0} pos) (@functor.add_const.run.{0 0} (group.{0} (normed_comm_ring.{0} pos)) (has_neg_part.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_66697 (h0 : function.extfun Type topological_space) : @loc_path_connected_space.{0} (linear_ordered_cancel_comm_monoid.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (linear_ordered_cancel_comm_monoid.{0} empty))  := sorry --non-trivial
lemma new_lemma_66698 (h0 : filter (measurable_space.dynkin_system (semiring (semiring unsigned)))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_66699 (h0 : functor.add_const (function.extfun (Type 1) topological_space) (has_add linarith.comp)) : @regular_space.{1} (has_zero.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) topological_space.{1}) (has_add.{0} linarith.comp) h0) (has_zero.{1} Type))  := sorry --non-trivial
lemma new_lemma_66700 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @totally_disconnected_space.{0} (has_top.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_top.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_66701 (h1 : complete_lattice (normed_field char)) : is_compactly_generated (normed_field char) := sorry --non-trivial
lemma new_lemma_66702 (h0 : fin has_zero.zero) : @preirreducible_space.{0} (has_pos_part.{0} real) (@matrix.vec_empty.{0} (topological_space.{0} (has_pos_part.{0} real)) h0)  := sorry --non-trivial
lemma new_lemma_66703 (h0 : ordered_add_comm_monoid (left_cancel_monoid (option (option unsigned)))) : archimedean (left_cancel_monoid (option (option unsigned))) := sorry --non-trivial
lemma new_lemma_66704 (h0 : topological_space (mul_zero_class unsigned)) : t1_space (mul_zero_class unsigned) := sorry --non-trivial
lemma new_lemma_66705 (h0 : group (has_one (has_norm (semiring empty)))) : is_cyclic (has_one (has_norm (semiring empty))) := sorry --non-trivial
lemma new_lemma_66706 (h0 : uniform_space (nondiscrete_normed_field enat)) : complete_space (nondiscrete_normed_field enat) := sorry --non-trivial
lemma new_lemma_66707 (h0 : topological_space (has_zero (cancel_monoid pos))) : t1_space (has_zero (cancel_monoid pos)) := sorry --non-trivial
lemma new_lemma_66708 (h0 : function.extfun Type topological_space) : @totally_separated_space.{0} (add_left_cancel_semigroup.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (add_left_cancel_semigroup.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_66709 (h0 : ordered_comm_monoid (semigroup (finset linarith.comp))) : has_exists_mul_of_le (semigroup (finset linarith.comp)) := sorry --non-trivial
lemma new_lemma_66710 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @discrete_topology.{0} (ring.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (ring.{0} name))  := sorry --non-trivial
lemma new_lemma_66711 (h0 : ordered_add_comm_monoid (pseudo_metric_space empty)) : archimedean (pseudo_metric_space empty) := sorry --non-trivial
lemma new_lemma_66712 (h0 : functor.add_const (ordered_comm_monoid (has_Inf pos)) name) : @has_exists_mul_of_le.{0} (has_Inf.{0} pos) (@functor.add_const.run.{0 0} (ordered_comm_monoid.{0} (has_Inf.{0} pos)) name h0)  := sorry --non-trivial
lemma new_lemma_66713 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @t1_space.{0} (has_add.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_add.{0} num))  := sorry --non-trivial
lemma new_lemma_66714 (h0 : group (has_star (semiring (semiring congr_arg_kind)))) : normalizer_condition (has_star (semiring (semiring congr_arg_kind))) := sorry --non-trivial
lemma new_lemma_66715 (h1 h2 : multiset (add_comm_semigroup std_gen)) : multiset.disjoint h1 h2 := sorry --non-trivial
lemma new_lemma_66716 (h0 : functor.add_const (add_group (semigroup name)) (boolean_algebra.core pos)) : @is_add_cyclic.{0} (semigroup.{0} name) (@functor.add_const.run.{0 0} (add_group.{0} (semigroup.{0} name)) (boolean_algebra.core.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_66717 (h0 : functor.add_const (complete_lattice (has_to_string unsigned)) (option unsigned)) : @is_atomistic.{0} (has_to_string.{0} unsigned) (@functor.add_const.run.{0 0} (complete_lattice.{0} (has_to_string.{0} unsigned)) (option.{0} unsigned) h0)  := sorry --non-trivial
lemma new_lemma_66718 (h0 : functor.add_const (complete_lattice (add_cancel_comm_monoid empty)) empty) : @complete_lattice.is_Sup_finite_compact.{0} (add_cancel_comm_monoid.{0} empty) (@functor.add_const.run.{0 0} (complete_lattice.{0} (add_cancel_comm_monoid.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_66719 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_noetherian_ring.{0} (partial_order.{0} num) (@function.extfun_app.{2 1} Type semiring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 semiring.{0}) (partial_order.{0} num))  := sorry --non-trivial
lemma new_lemma_66720 (h0 : semiring (comm_semigroup (semiring (semiring congr_arg_kind)))) : is_noetherian_ring (comm_semigroup (semiring (semiring congr_arg_kind))) := sorry --non-trivial
lemma new_lemma_66721 (h0 : uniform_space (boolean_algebra.core (has_add Type))) : complete_space (boolean_algebra.core (has_add Type)) := sorry --non-trivial
lemma new_lemma_66722 (h0 : has_mem.mem (with_bot linarith.comp) has_emptyc.emptyc) : @is_compactly_generated.{0} (with_bot.{0} linarith.comp) (@finset.pi.empty.{1 0} Type complete_lattice.{0} (with_bot.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_66723 (h0 : functor.add_const (function.extfun Type complete_lattice) environment.implicit_infer_kind) : @is_atomistic.{0} (add_comm_monoid.{0} pos) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type complete_lattice.{0}) environment.implicit_infer_kind h0) (add_comm_monoid.{0} pos))  := sorry --non-trivial
lemma new_lemma_66724 (h0 : not (add_group (encodable to_additive.value_type) -> false)) : @is_add_cyclic.{0} (encodable.{0} to_additive.value_type) (@classical.by_contradiction'.{1} (add_group.{0} (encodable.{0} to_additive.value_type)) h0)  := sorry --non-trivial
lemma new_lemma_66725 (h0 : topological_space (measure_theory.measure_space (semiring (semiring unsigned)))) : discrete_topology (measure_theory.measure_space (semiring (semiring unsigned))) := sorry --non-trivial
lemma new_lemma_66726 (h0 : group (has_neg (has_Inf (has_add linarith.comp)))) : normalizer_condition (has_neg (has_Inf (has_add linarith.comp))) := sorry --non-trivial
lemma new_lemma_66727 (h0 : topological_space (random_gen (has_norm (has_norm linarith.comp)))) : discrete_topology (random_gen (has_norm (has_norm linarith.comp))) := sorry --non-trivial
lemma new_lemma_66728 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @monoid.fg.{0} (mul_zero_class.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 monoid.{0}) (mul_zero_class.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_66729 (h0 : ordered_add_comm_monoid (ring (option name))) : archimedean (ring (option name)) := sorry --non-trivial
lemma new_lemma_66730 (h0 : has_zero (ring pos) -> has_zero (ring pos) -> Prop) : is_symm (has_zero (ring pos)) h0 := sorry --non-trivial
lemma new_lemma_66731 (h0 : function.extfun (finset Type) (has_mem.mem (has_one empty))) : @totally_separated_space.{0} (has_one.{0} empty) (@finset.pi.empty.{1 0} Type topological_space.{0} (has_one.{0} empty) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (has_one.{0} empty)) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_66732 (h0 : topological_space (has_to_string (add_comm_monoid (semigroup ennreal)))) : totally_separated_space (has_to_string (add_comm_monoid (semigroup ennreal))) := sorry --non-trivial
lemma new_lemma_66733 (h0 : functor.add_const (topological_space (monoid empty)) unsigned) : @locally_compact_space.{0} (monoid.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (monoid.{0} empty)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_66734 (h0 : functor.add_const (ring (semigroup empty)) (semiring empty)) : @rank_condition.{0} (semigroup.{0} empty) (@functor.add_const.run.{0 0} (ring.{0} (semigroup.{0} empty)) (semiring.{0} empty) h0)  := sorry --non-trivial
lemma new_lemma_66735 (h0 : ring (canonically_linear_ordered_monoid (has_neg name))) : is_principal_ideal_ring (canonically_linear_ordered_monoid (has_neg name)) := sorry --non-trivial
lemma new_lemma_66736 (h0 : topological_space (complete_distrib_lattice (option empty))) : preirreducible_space (complete_distrib_lattice (option empty)) := sorry --non-trivial
lemma new_lemma_66737 (h0 : add_group (mul_one_class (mul_one_class linarith.comp_source))) : is_add_cyclic (mul_one_class (mul_one_class linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_66738 (h0 : function.extfun Type topological_space) : @irreducible_space.{0} (monoid.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (monoid.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_66739 (h0 : ring (normed_comm_ring (option empty))) : is_principal_ideal_ring (normed_comm_ring (option empty)) := sorry --non-trivial
lemma new_lemma_66740 (h0 : topological_space (add_comm_monoid Type)) : totally_separated_space (add_comm_monoid Type) := sorry --non-trivial
lemma new_lemma_66741 (h0 : functor.add_const (ring (semigroup num)) num) : @strong_rank_condition.{0} (semigroup.{0} num) (@functor.add_const.run.{0 0} (ring.{0} (semigroup.{0} num)) num h0)  := sorry --non-trivial
lemma new_lemma_66742 (h0 : functor.add_const (uniform_space (has_Inf real)) pos) : @complete_space.{0} (has_Inf.{0} real) (@functor.add_const.run.{0 0} (uniform_space.{0} (has_Inf.{0} real)) pos h0)  := sorry --non-trivial
lemma new_lemma_66743 (h0 : functor.add_const (function.extfun Type topological_space) (boolean_algebra (has_neg (ring linarith.comp)))) : @sequential_space.{0} (normed_comm_ring.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) (boolean_algebra.{0} (has_neg.{0} (ring.{0} linarith.comp))) h0) (normed_comm_ring.{0} pos))  := sorry --non-trivial
lemma new_lemma_66744 (h0 : function.extfun Type topological_space) : @normal_space.{0} (add_comm_monoid.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (add_comm_monoid.{0} name))  := sorry --non-trivial
lemma new_lemma_66745 (h0 : topological_space (sub_neg_monoid (has_add name))) : loc_path_connected_space (sub_neg_monoid (has_add name)) := sorry --non-trivial
lemma new_lemma_66746 (h0 : functor.add_const (topological_space (has_zero ennreal)) pos) : @locally_compact_space.{0} (has_zero.{0} ennreal) (@functor.add_const.run.{0 0} (topological_space.{0} (has_zero.{0} ennreal)) pos h0)  := sorry --non-trivial
lemma new_lemma_66747 (h0 : topological_space (add_comm_semigroup fun_info)) : totally_disconnected_space (add_comm_semigroup fun_info) := sorry --non-trivial
lemma new_lemma_66748 (h0 : topological_space (has_inv (random_gen (has_top (random_gen (random_gen to_additive.value_type)))))) : t0_space (has_inv (random_gen (has_top (random_gen (random_gen to_additive.value_type))))) := sorry --non-trivial
lemma new_lemma_66749 (h2 : complete_lattice (has_div char)) : complete_lattice.is_Sup_finite_compact (has_div char) := sorry --non-trivial
lemma new_lemma_66750 (h0 : function.extfun Type (functor.comp group cancel_monoid)) : @group.fg.{0} (cancel_monoid.{0} pos) (@functor.comp.run.{0 0 0} group.{0} cancel_monoid.{0} pos (@function.extfun_app.{2 1} Type (functor.comp.{0 0 0} group.{0} cancel_monoid.{0}) h0 pos))  := sorry --non-trivial
lemma new_lemma_66751 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_cyclic.{0} (distrib_lattice.{0} linarith.ineq) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (distrib_lattice.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_66752 (h0 : not (finset (left_cancel_semigroup unsigned) -> false)) : finset.nonempty (classical.by_contradiction' h0) := sorry --non-trivial
lemma new_lemma_66753 (h1 : not (topological_space (distrib string_imp) -> false)) : @t0_space.{0} (distrib.{0} string_imp) (@classical.by_contradiction'.{1} (topological_space.{0} (distrib.{0} string_imp)) h1)  := sorry --non-trivial
lemma new_lemma_66754 (h0 : filter (with_bot (has_norm (semiring empty)))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_66755 (h0 : has_mem.mem (with_one fun_info) has_emptyc.emptyc) : @discrete_topology.{0} (with_one.{0} fun_info) (@finset.pi.empty.{1 0} Type topological_space.{0} (with_one.{0} fun_info) h0)  := sorry --non-trivial
lemma new_lemma_66756 (h0 : functor.add_const (topological_space (has_star congr_arg_kind)) empty) : @t1_space.{0} (has_star.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (has_star.{0} congr_arg_kind)) empty h0)  := sorry --non-trivial
lemma new_lemma_66757 (h1 : topological_space (mul_one_class string.iterator_imp)) : path_connected_space (mul_one_class string.iterator_imp) := sorry --non-trivial
lemma new_lemma_66758 (h0 : functor.add_const (group (bin_tree empty)) num) : @group.fg.{0} (bin_tree.{0} empty) (@functor.add_const.run.{0 0} (group.{0} (bin_tree.{0} empty)) num h0)  := sorry --non-trivial
lemma new_lemma_66759 (h1 : filter (has_append char)) : filter.ne_bot h1 := sorry --non-trivial
lemma new_lemma_66760 (h0 : not (function.extfun Type topological_space -> false)) : @totally_disconnected_space.{0} (with_bot.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (with_bot.{0} empty))  := sorry --non-trivial
lemma new_lemma_66761 (h0 : functor.add_const (ring (add_cancel_monoid name)) Type) : @strong_rank_condition.{0} (add_cancel_monoid.{0} name) (@functor.add_const.run.{0 1} (ring.{0} (add_cancel_monoid.{0} name)) Type h0)  := sorry --non-trivial
lemma new_lemma_66762 (h0 : complete_lattice (finset (option empty))) : is_compactly_generated (finset (option empty)) := sorry --non-trivial
lemma new_lemma_66763 (h0 : function.extfun (finset Type) (has_mem.mem (linear_ordered_semiring num))) : @is_compactly_generated.{0} (linear_ordered_semiring.{0} num) (@finset.pi.empty.{1 0} Type complete_lattice.{0} (linear_ordered_semiring.{0} num) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (linear_ordered_semiring.{0} num)) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_66764 (h0 : complete_lattice (non_assoc_semiring unsigned)) : is_compactly_generated (non_assoc_semiring unsigned) := sorry --non-trivial
lemma new_lemma_66765 (h0 : add_monoid (ring (has_add Type))) : add_monoid.fg (ring (has_add Type)) := sorry --non-trivial
lemma new_lemma_66766 (h0 : function.extfun Type ring) : @strong_rank_condition.{0} (canonically_linear_ordered_monoid.{0} ennreal) (@function.extfun_app.{2 1} Type ring.{0} h0 (canonically_linear_ordered_monoid.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_66767 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @preirreducible_space.{1} (normed_comm_ring.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 topological_space.{1}) (normed_comm_ring.{1} Type))  := sorry --non-trivial
lemma new_lemma_66768 (h0 : topological_space (ring (ring name))) : preirreducible_space (ring (ring name)) := sorry --non-trivial
lemma new_lemma_66769 (h0 : function.extfun Type topological_space) : @preirreducible_space.{0} (partial_order.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (partial_order.{0} num))  := sorry --non-trivial
lemma new_lemma_66770 (h0 : complete_lattice (add_comm_semigroup ereal)) (h1 : option (complete_lattice (add_comm_semigroup ereal))) : complete_lattice.is_Sup_finite_compact (add_comm_semigroup ereal) := sorry --non-trivial
lemma new_lemma_66771 (h0 : topological_space (has_nndist (has_add (finset (finset pos))))) : locally_compact_space (has_nndist (has_add (finset (finset pos)))) := sorry --non-trivial
lemma new_lemma_66772 (h0 : topological_space (ordered_comm_ring (has_neg (has_neg name)))) : locally_compact_space (ordered_comm_ring (has_neg (has_neg name))) := sorry --non-trivial
lemma new_lemma_66773 (h0 : topological_space (left_cancel_monoid (option unsigned))) : totally_disconnected_space (left_cancel_monoid (option unsigned)) := sorry --non-trivial
lemma new_lemma_66774 (h0 : not (uniform_space (normed_group linarith.comp) -> false)) : @complete_space.{0} (normed_group.{0} linarith.comp) (@classical.by_contradiction'.{1} (uniform_space.{0} (normed_group.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_66775 (h0 : function.extfun (finset (Type -> Type)) (has_mem.mem topological_space)) : @path_connected_space.{0} (metric_space.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) topological_space.{0} (@function.extfun_app.{2 0} (finset.{1} (Type → Type)) (@has_mem.mem.{1 1} (Type → Type) (finset.{1} (Type → Type)) (@finset.has_mem.{1} (Type → Type)) topological_space.{0}) h0 (@has_emptyc.emptyc.{1} (finset.{1} (Type → Type)) (@finset.has_emptyc.{1} (Type → Type))))) (metric_space.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_66776 (h0 : complete_lattice (has_sub (has_top empty))) : is_atomistic (has_sub (has_top empty)) := sorry --non-trivial
lemma new_lemma_66777 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @normalizer_condition.{0} (finset.{0} pos) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (finset.{0} pos))  := sorry --non-trivial
lemma new_lemma_66778 (h0 : complete_lattice (has_neg_part (option name))) : is_atomistic (has_neg_part (option name)) := sorry --non-trivial
lemma new_lemma_66779 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @t0_space.{0} (has_zero.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_zero.{0} pos))  := sorry --non-trivial
lemma new_lemma_66780 (h0 : group (has_inner empty empty)) : group.fg (has_inner empty empty) := sorry --non-trivial
lemma new_lemma_66781 (h0 : complete_lattice (has_star (semiring (semiring num)))) : is_compactly_generated (has_star (semiring (semiring num))) := sorry --non-trivial
lemma new_lemma_66782 (h0 : complete_lattice (semilattice_inf unsigned)) : is_atomistic (semilattice_inf unsigned) := sorry --non-trivial
lemma new_lemma_66783 (h0 : topological_space (ordered_comm_ring (ring pos))) : topological_space.separable_space (ordered_comm_ring (ring pos)) := sorry --non-trivial
lemma new_lemma_66784 (h0 : functor.add_const (add_group (cancel_monoid linarith.comp)) (comm_group (comm_group name))) : @is_add_cyclic.{0} (cancel_monoid.{0} linarith.comp) (@functor.add_const.run.{0 0} (add_group.{0} (cancel_monoid.{0} linarith.comp)) (comm_group.{0} (comm_group.{0} name)) h0)  := sorry --non-trivial
lemma new_lemma_66785 (h0 : functor.add_const (finset (ordered_comm_ring linarith.comp)) (has_add pos)) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_66786 (h0 : functor.add_const (function.extfun Type add_group) (has_Inf (has_pos_part linarith.comp))) : @is_add_cyclic.{0} (add_comm_monoid.{0} linarith.comp) (@function.extfun_app.{2 1} Type add_group.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type add_group.{0}) (has_Inf.{0} (has_pos_part.{0} linarith.comp)) h0) (add_comm_monoid.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_66787 (h0 : topological_space (ordered_comm_monoid (has_add (has_add (has_Inf pos))))) : totally_separated_space (ordered_comm_monoid (has_add (has_add (has_Inf pos)))) := sorry --non-trivial
lemma new_lemma_66788 (h0 : topological_space (has_append (random_gen reducibility_hints))) : path_connected_space (has_append (random_gen reducibility_hints)) := sorry --non-trivial
lemma new_lemma_66789 (h0 : function.extfun Type ring) : @strong_rank_condition.{0} (random_gen.{0} unsigned) (@function.extfun_app.{2 1} Type ring.{0} h0 (random_gen.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_66790 (h0 : filter (finset (has_nndist ennreal))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_66791 (h0 : functor.add_const (ring (option congr_arg_kind)) unsigned) : @is_domain.{0} (option.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (ring.{0} (option.{0} congr_arg_kind)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_66792 (h0 : ring (ordered_comm_monoid (has_to_string Type))) : is_domain (ordered_comm_monoid (has_to_string Type)) := sorry --non-trivial
lemma new_lemma_66793 (h0 : function.extfun Type monoid) : @monoid.fg.{0} (normed_group.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type monoid.{0} h0 (normed_group.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_66794 (h0 : semiring (canonically_linear_ordered_monoid (has_pos_part real))) : is_noetherian_ring (canonically_linear_ordered_monoid (has_pos_part real)) := sorry --non-trivial
lemma new_lemma_66795 (h0 : ring (add_group (has_norm congr_arg_kind))) : rank_condition (add_group (has_norm congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_66796 (h0 : ring (plift congr_arg_kind)) : strong_rank_condition (plift congr_arg_kind) := sorry --non-trivial
lemma new_lemma_66797 (h0 : topological_space (finset (has_add (has_neg pos)))) : topological_space.separable_space (finset (has_add (has_neg pos))) := sorry --non-trivial
lemma new_lemma_66798 (h0 : function.extfun Type list) : list.nodup (function.extfun_app h0 (monoid pos)) := sorry --non-trivial
lemma new_lemma_66799 (h0 : function.extfun (finset Type) (has_mem.mem (linear_ordered_semiring to_additive.value_type))) : @separated_space.{0} (linear_ordered_semiring.{0} to_additive.value_type) (@finset.pi.empty.{1 0} Type uniform_space.{0} (linear_ordered_semiring.{0} to_additive.value_type) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (linear_ordered_semiring.{0} to_additive.value_type)) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_66800 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_domain.{0} (canonically_ordered_add_monoid.{0} (option.{0} empty)) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (canonically_ordered_add_monoid.{0} (option.{0} empty)))  := sorry --non-trivial
lemma new_lemma_66801 (h0 : simple_graph (complete_lattice empty)) (h1 : complete_lattice empty) : simple_graph.support h0 h1 := sorry --non-trivial
lemma new_lemma_66802 (h0 : topological_space (semigroup (boolean_algebra name))) : regular_space (semigroup (boolean_algebra name)) := sorry --non-trivial
lemma new_lemma_66803 (h0 : group (random_gen (random_gen (random_gen linarith.ineq)))) : normalizer_condition (random_gen (random_gen (random_gen linarith.ineq))) := sorry --non-trivial
lemma new_lemma_66804 (h0 : topological_space (has_top (has_ssubset (has_norm fun_info)))) : irreducible_space (has_top (has_ssubset (has_norm fun_info))) := sorry --non-trivial
lemma new_lemma_66805 (h0 : topological_space (semiring unsigned)) : locally_compact_space (semiring unsigned) := sorry --non-trivial
lemma new_lemma_66806 (h0 : not (function.extfun Type complete_lattice -> false)) : @is_atomistic.{0} (linear_ordered_semiring.{0} unsigned) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type complete_lattice.{0}) h0) (linear_ordered_semiring.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_66807 (h0 : complete_lattice congr_arg_kind) : complete_lattice.is_Sup_finite_compact congr_arg_kind := sorry --non-trivial
lemma new_lemma_66808 (h0 : topological_space (cancel_monoid (has_to_string congr_arg_kind))) : discrete_topology (cancel_monoid (has_to_string congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_66809 (h0 : functor.add_const (uniform_space (mul_one_class Type)) linarith.comp) : @separated_space.{1} (mul_one_class.{1} Type) (@functor.add_const.run.{1 0} (uniform_space.{1} (mul_one_class.{1} Type)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_66810 (h0 : functor.add_const (group (has_dist empty)) num) : @normalizer_condition.{0} (has_dist.{0} empty) (@functor.add_const.run.{0 0} (group.{0} (has_dist.{0} empty)) num h0)  := sorry --non-trivial
lemma new_lemma_66811 (h0 : uniform_space (normed_comm_ring (has_add (has_neg (finset linarith.comp))))) : separated_space (normed_comm_ring (has_add (has_neg (finset linarith.comp)))) := sorry --non-trivial
lemma new_lemma_66812 (h0 : monoid (has_Inf (has_Inf real))) : monoid.fg (has_Inf (has_Inf real)) := sorry --non-trivial
lemma new_lemma_66813 (h0 : functor.add_const (complete_lattice (has_nndist Type)) ennreal) : @is_atomistic.{1} (has_nndist.{1} Type) (@functor.add_const.run.{1 0} (complete_lattice.{1} (has_nndist.{1} Type)) ennreal h0)  := sorry --non-trivial
lemma new_lemma_66814 (h0 : topological_space (has_Inf (has_Inf (has_Inf (has_Inf linarith.comp))))) : t0_space (has_Inf (has_Inf (has_Inf (has_Inf linarith.comp)))) := sorry --non-trivial
lemma new_lemma_66815 (h0 : functor.comp complete_lattice normed_group linarith.ineq) : @complete_lattice.is_Sup_finite_compact.{0} (normed_group.{0} linarith.ineq) (@functor.comp.run.{0 0 0} complete_lattice.{0} normed_group.{0} linarith.ineq h0)  := sorry --non-trivial
lemma new_lemma_66816 (h0 : finset (has_zero Type)) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_66817 (h0 : topological_space (comm_group (has_add linarith.comp))) : topological_space.separable_space (comm_group (has_add linarith.comp)) := sorry --non-trivial
lemma new_lemma_66818 (h1 : uniform_space (mul_one_class (normed_field (normed_field reducibility_hints)))) : complete_space (mul_one_class (normed_field (normed_field reducibility_hints))) := sorry --non-trivial
lemma new_lemma_66819 (h0 : function.extfun Type (prod (linear_order unsigned))) : set.diagonal (linear_order unsigned) (function.extfun_app h0 (linear_order unsigned)) := sorry --non-trivial
lemma new_lemma_66820 (h0 : list (filter Prop)) (h1 : nat) : @Lim.{0} Prop sierpinski_space (@nonempty_of_inhabited.{1} Prop sort.inhabited.{0}) (@list.inth.{0} (filter.{0} Prop) (@filter.inhabited.{0} Prop) h0 h1)  := sorry --non-trivial
lemma new_lemma_66821 (h0 : measurable_space (has_add Type)) (h1 : filter (has_add (measure_theory.measure (has_add Type)))) : countable_Inter_filter h1 := sorry --non-trivial
lemma new_lemma_66822 (h0 : functor.add_const (functor.add_const Prop name) (has_neg (boolean_algebra (has_neg_part pos)))) : functor.add_const.run (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_66823 (h0 : functor.add_const (group (boolean_algebra pos)) Type) : @group.fg.{0} (boolean_algebra.{0} pos) (@functor.add_const.run.{0 1} (group.{0} (boolean_algebra.{0} pos)) Type h0)  := sorry --non-trivial
lemma new_lemma_66824 (h0 : function.extfun Type list) : palindrome (function.extfun_app h0 (has_inter ennreal)) := sorry --non-trivial
lemma new_lemma_66825 (h0 : functor.add_const (topological_space (ring name)) pos) : @normal_space.{0} (ring.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (ring.{0} name)) pos h0)  := sorry --non-trivial
lemma new_lemma_66826 (h0 : functor.add_const (uniform_space (has_to_string pos)) pos) : @complete_space.{0} (has_to_string.{0} pos) (@functor.add_const.run.{0 0} (uniform_space.{0} (has_to_string.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_66827 (h0 : complete_lattice (normed_field std_gen)) : is_compactly_generated (normed_field std_gen) := sorry --non-trivial
lemma new_lemma_66828 (h0 : not (topological_space (has_ssubset linarith.ineq) -> false)) : @t0_space.{0} (has_ssubset.{0} linarith.ineq) (@classical.by_contradiction'.{1} (topological_space.{0} (has_ssubset.{0} linarith.ineq)) h0)  := sorry --non-trivial
lemma new_lemma_66829 (h0 : semiring (has_nndist (has_to_string (comm_group (has_to_string pos))))) : is_noetherian_ring (has_nndist (has_to_string (comm_group (has_to_string pos)))) := sorry --non-trivial
lemma new_lemma_66830 (h0 : ring (free_add_monoid empty)) : strong_rank_condition (free_add_monoid empty) := sorry --non-trivial
lemma new_lemma_66831 (h0 : functor.comp topological_space semigroup pos) : @sequential_space.{0} (semigroup.{0} pos) (@functor.comp.run.{0 0 0} topological_space.{0} semigroup.{0} pos h0)  := sorry --non-trivial
lemma new_lemma_66832 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @totally_separated_space.{0} (has_union.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_union.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_66833 (h0 : topological_space (ordered_comm_monoid (has_add Type))) : regular_space (ordered_comm_monoid (has_add Type)) := sorry --non-trivial
lemma new_lemma_66834 (h0 : fin has_zero.zero) : @sequential_space.{0} (has_bot.{0} real) (@matrix.vec_empty.{0} (topological_space.{0} (has_bot.{0} real)) h0)  := sorry --non-trivial
lemma new_lemma_66835 (h0 : topological_space (simple_graph (semi_normed_comm_ring linarith.ineq))) : path_connected_space (simple_graph (semi_normed_comm_ring linarith.ineq)) := sorry --non-trivial
lemma new_lemma_66836 (h0 : finset (omega_complete_partial_order unsigned)) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_66837 (h0 : function.extfun Type ring) : @is_domain.{0} (normed_group.{0} empty) (@function.extfun_app.{2 1} Type ring.{0} h0 (normed_group.{0} empty))  := sorry --non-trivial
lemma new_lemma_66838 (h0 : functor.add_const (ordered_comm_monoid (normed_comm_ring name)) Type) : @has_exists_mul_of_le.{0} (normed_comm_ring.{0} name) (@functor.add_const.run.{0 1} (ordered_comm_monoid.{0} (normed_comm_ring.{0} name)) Type h0)  := sorry --non-trivial
lemma new_lemma_66839 (h1 : function.extfun (finset (Type -> Type)) (has_mem.mem complete_lattice)) : @is_atomistic.{0} (random_gen.{0} fun_info) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) complete_lattice.{0} (@function.extfun_app.{2 0} (finset.{1} (Type → Type)) (@has_mem.mem.{1 1} (Type → Type) (finset.{1} (Type → Type)) (@finset.has_mem.{1} (Type → Type)) complete_lattice.{0}) h1 (@has_emptyc.emptyc.{1} (finset.{1} (Type → Type)) (@finset.has_emptyc.{1} (Type → Type))))) (random_gen.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_66840 (h0 : complete_lattice (add_cancel_monoid empty)) : is_compactly_generated (add_cancel_monoid empty) := sorry --non-trivial
lemma new_lemma_66841 (h0 : list (linear_ordered_add_comm_group (has_inv fun_info))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_66842 (h0 : topological_space (add_cancel_comm_monoid char)) : path_connected_space (add_cancel_comm_monoid char) := sorry --non-trivial
lemma new_lemma_66843 (h0 : list (has_pos_part (complete_distrib_lattice real))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_66844 (h0 : topological_space (dlist (has_ssubset linarith.ineq))) : totally_disconnected_space (dlist (has_ssubset linarith.ineq)) := sorry --non-trivial
lemma new_lemma_66845 (h0 : ring (has_inv (fintype (random_gen linarith.comp_source)))) : is_domain (has_inv (fintype (random_gen linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_66846 (h0 : ring (non_assoc_semiring (semiring (has_norm (semiring empty))))) : strong_rank_condition (non_assoc_semiring (semiring (has_norm (semiring empty)))) := sorry --non-trivial
lemma new_lemma_66847 (h0 : functor.add_const (topological_space (has_nndist linarith.comp)) linarith.comp) : @discrete_topology.{0} (has_nndist.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (has_nndist.{0} linarith.comp)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_66848 (h0 : functor.add_const (ordered_comm_monoid (has_Inf linarith.comp)) pos) : @has_exists_mul_of_le.{0} (has_Inf.{0} linarith.comp) (@functor.add_const.run.{0 0} (ordered_comm_monoid.{0} (has_Inf.{0} linarith.comp)) pos h0)  := sorry --non-trivial
lemma new_lemma_66849 (h0 : semiring (has_Inf (finset pos))) : is_noetherian_ring (has_Inf (finset pos)) := sorry --non-trivial
lemma new_lemma_66850 (h0 : group (linear_ordered_add_comm_group (random_gen (has_nnnorm fun_info)))) : group.fg (linear_ordered_add_comm_group (random_gen (has_nnnorm fun_info))) := sorry --non-trivial
lemma new_lemma_66851 (h0 : functor.add_const (complete_lattice (complete_distrib_lattice unsigned)) name) : @complete_lattice.is_Sup_finite_compact.{0} (complete_distrib_lattice.{0} unsigned) (@functor.add_const.run.{0 0} (complete_lattice.{0} (complete_distrib_lattice.{0} unsigned)) name h0)  := sorry --non-trivial
lemma new_lemma_66852 (h0 : semiring (sub_neg_monoid (has_add linarith.comp))) : is_noetherian_ring (sub_neg_monoid (has_add linarith.comp)) := sorry --non-trivial
lemma new_lemma_66853 (h0 : topological_space (has_nnnorm (add_comm_semigroup fun_info))) (h1 : set (has_nnnorm (add_comm_semigroup fun_info))) : is_path_connected h1 := sorry --non-trivial
lemma new_lemma_66854 (h0 : topological_space (semigroup (finset pos))) : irreducible_space (semigroup (finset pos)) := sorry --non-trivial
lemma new_lemma_66855 (h0 : add_group (cancel_monoid (option (option (option (option ennreal)))))) : is_add_cyclic (cancel_monoid (option (option (option (option ennreal))))) := sorry --non-trivial
lemma new_lemma_66856 (h0 : ring (add_group unsigned)) : strong_rank_condition (add_group unsigned) := sorry --non-trivial
lemma new_lemma_66857 (h0 : set (normed_field (mul_one_class linarith.ineq))) : set.finite h0 := sorry --non-trivial
lemma new_lemma_66858 (h0 : topological_space (has_Inf (has_add linarith.comp))) : irreducible_space (has_Inf (has_add linarith.comp)) := sorry --non-trivial
lemma new_lemma_66859 (h0 : complete_lattice (linear_ordered_add_comm_group (has_nnnorm (has_nnnorm linarith.ineq)))) : is_compactly_generated (linear_ordered_add_comm_group (has_nnnorm (has_nnnorm linarith.ineq))) := sorry --non-trivial
lemma new_lemma_66860 (h0 : functor.add_const (finset (has_zero pos)) unsigned) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_66861 (h0 : functor.add_const (topological_space (has_Inf Type)) linarith.comp) : @preconnected_space.{1} (has_Inf.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (has_Inf.{1} Type)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_66862 (h0 : functor.add_const (function.extfun Type topological_space) Type) : @totally_separated_space.{0} (add_cancel_monoid.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type topological_space.{0}) Type h0) (add_cancel_monoid.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_66863 (h0 : monoid (canonically_ordered_add_monoid num)) : monoid.fg (canonically_ordered_add_monoid num) := sorry --non-trivial
lemma new_lemma_66864 (h0 : functor.add_const (monoid (semigroup unsigned)) congr_arg_kind) : @monoid.fg.{0} (semigroup.{0} unsigned) (@functor.add_const.run.{0 0} (monoid.{0} (semigroup.{0} unsigned)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_66865 (h0 : topological_space (add_comm_monoid pos)) : irreducible_space (add_comm_monoid pos) := sorry --non-trivial
lemma new_lemma_66866 (h2 : semiring string.iterator_imp) (h3 : ideal string.iterator_imp) : ideal.is_prime h3 := sorry --non-trivial
lemma new_lemma_66867 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @t1_space.{1} (has_neg.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 topological_space.{1}) (has_neg.{1} Type))  := sorry --non-trivial
lemma new_lemma_66868 (h0 : ring (has_neg (finset (finset linarith.comp)))) : is_domain (has_neg (finset (finset linarith.comp))) := sorry --non-trivial
lemma new_lemma_66869 (h0 : topological_space (has_nndist (has_to_string environment.implicit_infer_kind))) : t0_space (has_nndist (has_to_string environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_66870 (h0 : function.extfun Type uniform_space) : @separated_space.{0} (left_cancel_monoid.{0} unsigned) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (left_cancel_monoid.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_66871 (h0 : function.extfun Type topological_space) : @t0_space.{0} (has_edist.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_edist.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_66872 (h0 : topological_space (normed_comm_ring (has_neg_part Type))) : loc_path_connected_space (normed_comm_ring (has_neg_part Type)) := sorry --non-trivial
lemma new_lemma_66873 (h0 : ring (id fun_info)) : is_domain (id fun_info) := sorry --non-trivial
lemma new_lemma_66874 (h0 : function.extfun Type topological_space) : @irreducible_space.{0} (has_Inf.{0} real) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_Inf.{0} real))  := sorry --non-trivial
lemma new_lemma_66875 (h0 : topological_space (has_bot (has_Inf Type))) : t1_space (has_bot (has_Inf Type)) := sorry --non-trivial
lemma new_lemma_66876 (h0 : function.extfun Type topological_space) : @normal_space.{0} (option.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (option.{0} pos))  := sorry --non-trivial
lemma new_lemma_66877 (h0 : ring (random_gen (has_zero (semiring empty)))) : is_domain (random_gen (has_zero (semiring empty))) := sorry --non-trivial
lemma new_lemma_66878 (h0 : functor.add_const (topological_space (has_nndist pos)) Type) : @discrete_topology.{0} (has_nndist.{0} pos) (@functor.add_const.run.{0 1} (topological_space.{0} (has_nndist.{0} pos)) Type h0)  := sorry --non-trivial
lemma new_lemma_66879 (h0 : topological_space (normed_comm_ring (has_to_string (has_add (has_to_string Type))))) : preconnected_space (normed_comm_ring (has_to_string (has_add (has_to_string Type)))) := sorry --non-trivial
lemma new_lemma_66880 (h0 : complete_lattice (has_norm string_imp)) : is_atomistic (has_norm string_imp) := sorry --non-trivial
lemma new_lemma_66881 (h0 : functor.add_const (function.extfun Type complete_lattice) (has_pos_part linarith.comp)) : @complete_lattice.is_Sup_finite_compact.{0} (boolean_algebra.{0} pos) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type complete_lattice.{0}) (has_pos_part.{0} linarith.comp) h0) (boolean_algebra.{0} pos))  := sorry --non-trivial
lemma new_lemma_66882 (h0 : group (linear_ordered_comm_monoid_with_zero unsigned)) : is_cyclic (linear_ordered_comm_monoid_with_zero unsigned) := sorry --non-trivial
lemma new_lemma_66883 (h0 : function.extfun Type group) : @is_cyclic.{0} (semigroup.{0} unsigned) (@function.extfun_app.{2 1} Type group.{0} h0 (semigroup.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_66884 (h0 : group (ring (has_Inf pos))) : group.fg (ring (has_Inf pos)) := sorry --non-trivial
lemma new_lemma_66885 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @path_connected_space.{0} (has_pos_part.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_pos_part.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_66886 (h0 : functor.comp ring linear_ordered_field pos) : @is_principal_ideal_ring.{0} (linear_ordered_field.{0} pos) (@functor.comp.run.{0 0 0} ring.{0} linear_ordered_field.{0} pos h0)  := sorry --non-trivial
lemma new_lemma_66887 (h0 : complete_lattice (boolean_algebra (ring (has_nndist Type)))) : complete_lattice.is_Sup_finite_compact (boolean_algebra (ring (has_nndist Type))) := sorry --non-trivial
lemma new_lemma_66888 (h2 : function.extfun Type ring) : @is_domain.{0} (has_inv.{0} string_imp) (@function.extfun_app.{2 1} Type ring.{0} h2 (has_inv.{0} string_imp))  := sorry --non-trivial
lemma new_lemma_66889 (h0 : functor.add_const (function.extfun Type topological_space) linarith.comp) : @normal_space.{0} (has_zero.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) linarith.comp h0) (has_zero.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_66890 (h0 : uniform_space (normed_comm_ring (measurable_space (add_cancel_monoid (has_neg linarith.comp))))) : separated_space (normed_comm_ring (measurable_space (add_cancel_monoid (has_neg linarith.comp)))) := sorry --non-trivial
lemma new_lemma_66891 (h0 : function.extfun Type (functor.comp uniform_space boolean_algebra)) : @separated_space.{0} (boolean_algebra.{0} name) (@functor.comp.run.{0 0 0} uniform_space.{0} boolean_algebra.{0} name (@function.extfun_app.{2 1} Type (functor.comp.{0 0 0} uniform_space.{0} boolean_algebra.{0}) h0 name))  := sorry --non-trivial
lemma new_lemma_66892 (h0 : ring (canonically_ordered_monoid (sub_neg_monoid Type))) : strong_rank_condition (canonically_ordered_monoid (sub_neg_monoid Type)) := sorry --non-trivial
lemma new_lemma_66893 (h0 : group (boolean_algebra.core (finset name))) : normalizer_condition (boolean_algebra.core (finset name)) := sorry --non-trivial
lemma new_lemma_66894 (h1 : ring (has_add char)) : rank_condition (has_add char) := sorry --non-trivial
lemma new_lemma_66895 (h2 : has_mem.mem linarith.comp_source has_emptyc.emptyc) : @normalizer_condition.{0} linarith.comp_source (@finset.pi.empty.{1 0} Type group.{0} linarith.comp_source h2)  := sorry --non-trivial
lemma new_lemma_66896 (h0 : function.extfun Type topological_space) : @preirreducible_space.{0} (partial_order.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (partial_order.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_66897 (h0 : fin has_zero.zero) : @preirreducible_space.{0} (generalized_boolean_algebra.{0} real) (@matrix.vec_empty.{0} (topological_space.{0} (generalized_boolean_algebra.{0} real)) h0)  := sorry --non-trivial
lemma new_lemma_66898 (h0 : add_group (linear_ordered_comm_group (option empty))) : is_add_cyclic (linear_ordered_comm_group (option empty)) := sorry --non-trivial
lemma new_lemma_66899 (h0 : functor.add_const (ring (boolean_algebra Type)) (finset pos)) : @rank_condition.{1} (boolean_algebra.{1} Type) (@functor.add_const.run.{1 0} (ring.{1} (boolean_algebra.{1} Type)) (finset.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_66900 (h0 : complete_lattice (add_left_cancel_semigroup unsigned)) : is_compactly_generated (add_left_cancel_semigroup unsigned) := sorry --non-trivial
lemma new_lemma_66901 (h0 : complete_lattice (has_star (option (semiring unsigned)))) : complete_lattice.is_Sup_finite_compact (has_star (option (semiring unsigned))) := sorry --non-trivial
lemma new_lemma_66902 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @monoid.fg.{0} (random_gen.{0} string_imp) (@function.extfun_app.{2 1} Type monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 monoid.{0}) (random_gen.{0} string_imp))  := sorry --non-trivial
lemma new_lemma_66903 (h0 : functor.add_const (ordered_add_comm_monoid (boolean_algebra.core Type)) Type) : @archimedean.{1} (boolean_algebra.core.{1} Type) (@functor.add_const.run.{1 1} (ordered_add_comm_monoid.{1} (boolean_algebra.core.{1} Type)) Type h0)  := sorry --non-trivial
lemma new_lemma_66904 (h0 : has_mem.mem (has_one unsigned) has_emptyc.emptyc) : @monoid.fg.{0} (has_one.{0} unsigned) (@finset.pi.empty.{1 0} Type monoid.{0} (has_one.{0} unsigned) h0)  := sorry --non-trivial
lemma new_lemma_66905 (h0 : ring (random_gen (has_lt reducibility_hints))) : rank_condition (random_gen (has_lt reducibility_hints)) := sorry --non-trivial
lemma new_lemma_66906 (h0 : uniform_space (linear_ordered_semiring (semiring (semiring unsigned)))) : separated_space (linear_ordered_semiring (semiring (semiring unsigned))) := sorry --non-trivial
lemma new_lemma_66907 (h0 : ring (add_cancel_monoid (has_add (finset (finset pos))))) : strong_rank_condition (add_cancel_monoid (has_add (finset (finset pos)))) := sorry --non-trivial
lemma new_lemma_66908 (h0 : uniform_space (has_nnnorm (random_gen (has_nnnorm char)))) : complete_space (has_nnnorm (random_gen (has_nnnorm char))) := sorry --non-trivial
lemma new_lemma_66909 (h0 : function.extfun (Type 1) (functor.comp ring has_neg_part)) : @strong_rank_condition.{1} (has_neg_part.{1} Type) (@functor.comp.run.{1 1 1} ring.{1} has_neg_part.{1} Type (@function.extfun_app.{3 2} (Type 1) (functor.comp.{1 1 1} ring.{1} has_neg_part.{1}) h0 Type))  := sorry --non-trivial
lemma new_lemma_66910 (h0 : not (function.extfun Type uniform_space -> false)) : @separated_space.{0} (has_union.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type uniform_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type uniform_space.{0}) h0) (has_union.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_66911 (h0 : function.extfun Type topological_space) : @normal_space.{0} (add_comm_monoid.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (add_comm_monoid.{0} empty))  := sorry --non-trivial
lemma new_lemma_66912 (h0 : topological_space (add_cancel_monoid (option unsigned))) : irreducible_space (add_cancel_monoid (option unsigned)) := sorry --non-trivial
lemma new_lemma_66913 (h0 : topological_space (pseudo_metric_space name)) : normal_space (pseudo_metric_space name) := sorry --non-trivial
lemma new_lemma_66914 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @preirreducible_space.{0} (has_nndist.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_nndist.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_66915 (h0 : topological_space (has_bot (has_Inf real))) : totally_separated_space (has_bot (has_Inf real)) := sorry --non-trivial
lemma new_lemma_66916 (h0 : topological_space (has_to_string (finset unsigned))) : sequential_space (has_to_string (finset unsigned)) := sorry --non-trivial
lemma new_lemma_66917 (h0 : not (group (linear_ordered_semiring congr_arg_kind) -> false)) : @is_cyclic.{0} (linear_ordered_semiring.{0} congr_arg_kind) (@classical.by_contradiction'.{1} (group.{0} (linear_ordered_semiring.{0} congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_66918 (h1 : topological_space (uniform_space (mul_one_class string.iterator_imp))) (h2 : preorder (uniform_space (mul_one_class string.iterator_imp))) : order_topology (uniform_space (mul_one_class string.iterator_imp)) := sorry --non-trivial
lemma new_lemma_66919 (h0 : function.extfun Type add_group) : @is_add_cyclic.{0} (ordered_comm_monoid.{0} real) (@function.extfun_app.{2 1} Type add_group.{0} h0 (ordered_comm_monoid.{0} real))  := sorry --non-trivial
lemma new_lemma_66920 (h0 : function.extfun Type (functor.add_const (topological_space (has_Sup empty)))) : @t0_space.{0} (has_Sup.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (has_Sup.{0} empty)) empty (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (topological_space.{0} (has_Sup.{0} empty))) h0 empty))  := sorry --non-trivial
lemma new_lemma_66921 (h0 : group (has_neg_part (has_add (has_add (comm_group ennreal))))) : is_cyclic (has_neg_part (has_add (has_add (comm_group ennreal)))) := sorry --non-trivial
lemma new_lemma_66922 (h0 : monoid (add_cancel_monoid (option (has_bot unsigned)))) : monoid.fg (add_cancel_monoid (option (has_bot unsigned))) := sorry --non-trivial
lemma new_lemma_66923 (h0 : list (has_Inf (has_Inf (has_Inf (ordered_ring (has_Inf (has_neg linarith.comp))))))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_66924 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_atomistic.{0} (with_bot.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (with_bot.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_66925 (h0 : fin has_zero.zero) : @is_noetherian_ring.{0} (generalized_boolean_algebra.{0} real) (@matrix.vec_empty.{0} (semiring.{0} (generalized_boolean_algebra.{0} real)) h0)  := sorry --non-trivial
lemma new_lemma_66926 (h0 : function.extfun Type ring) : @is_principal_ideal_ring.{0} (left_cancel_monoid.{0} unsigned) (@function.extfun_app.{2 1} Type ring.{0} h0 (left_cancel_monoid.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_66927 (h0 : function.extfun Type topological_space) : @preirreducible_space.{0} (measurable_space.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (measurable_space.{0} empty))  := sorry --non-trivial
lemma new_lemma_66928 (h0 : function.extfun Type complete_lattice) : @is_compactly_generated.{0} (normed_comm_ring.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (normed_comm_ring.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_66929 (h0 : topological_space (metric_space (id (has_one empty)))) : path_connected_space (metric_space (id (has_one empty))) := sorry --non-trivial
lemma new_lemma_66930 (h0 : functor.add_const (ring (has_to_string Type)) (has_neg Type)) : @is_domain.{1} (has_to_string.{1} Type) (@functor.add_const.run.{1 1} (ring.{1} (has_to_string.{1} Type)) (has_neg.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_66931 (h0 : fin has_zero.zero) : @has_exists_mul_of_le.{0} (ordered_comm_monoid.{0} real) (@function.extfun_app.{2 1} Type ordered_comm_monoid.{0} (@matrix.vec_empty.{1} (function.extfun.{2 1} Type ordered_comm_monoid.{0}) h0) (ordered_comm_monoid.{0} real))  := sorry --non-trivial
lemma new_lemma_66932 (h0 : topological_space (add_cancel_monoid (option (option (option (option (option empty))))))) : discrete_topology (add_cancel_monoid (option (option (option (option (option empty)))))) := sorry --non-trivial
lemma new_lemma_66933 (h0 : topological_space (semigroup (option pos))) : normal_space (semigroup (option pos)) := sorry --non-trivial
lemma new_lemma_66934 (h0 : group (finset (ring (ring name)))) : is_simple_group (finset (ring (ring name))) := sorry --non-trivial
lemma new_lemma_66935 (h0 : topological_space (mul_zero_class (has_nndist pos))) : totally_disconnected_space (mul_zero_class (has_nndist pos)) := sorry --non-trivial
lemma new_lemma_66936 (h0 : topological_space (has_lt std_gen)) (h1 : add_group (has_lt std_gen)) : topological_add_group (has_lt std_gen) := sorry --non-trivial
lemma new_lemma_66937 (h0 : fin has_zero.zero) : @path_connected_space.{1} (ordered_comm_ring.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) (@matrix.vec_empty.{2} (function.extfun.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1))) h0) topological_space.{1}) (ordered_comm_ring.{1} Type))  := sorry --non-trivial
lemma new_lemma_66938 (h0 : uniform_space (has_ssubset (has_nnnorm (has_nnnorm linarith.ineq)))) : complete_space (has_ssubset (has_nnnorm (has_nnnorm linarith.ineq))) := sorry --non-trivial
lemma new_lemma_66939 (h0 : topological_space (comm_semigroup (has_Inf real))) : loc_path_connected_space (comm_semigroup (has_Inf real)) := sorry --non-trivial
lemma new_lemma_66940 (h0 : functor.add_const (complete_lattice (pseudo_metric_space ennreal)) ennreal) : @is_atomistic.{0} (pseudo_metric_space.{0} ennreal) (@functor.add_const.run.{0 0} (complete_lattice.{0} (pseudo_metric_space.{0} ennreal)) ennreal h0)  := sorry --non-trivial
lemma new_lemma_66941 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @t0_space.{0} (has_dist.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_dist.{0} empty))  := sorry --non-trivial
lemma new_lemma_66942 (h0 : complete_lattice (dlist linarith.comp_source) -> linarith.ineq) (h1 : coe_sort (set.range h0)) : @is_compactly_generated.{0} (dlist.{0} linarith.comp_source) (@set.range_splitting.{0 0} (complete_lattice.{0} (dlist.{0} linarith.comp_source)) linarith.ineq h0 h1)  := sorry --non-trivial
lemma new_lemma_66943 (h0 : function.extfun (Type 1) (functor.comp ring comm_group)) : @is_principal_ideal_ring.{1} (comm_group.{1} Type) (@functor.comp.run.{1 1 1} ring.{1} comm_group.{1} Type (@function.extfun_app.{3 2} (Type 1) (functor.comp.{1 1 1} ring.{1} comm_group.{1}) h0 Type))  := sorry --non-trivial
lemma new_lemma_66944 (h0 : topological_space (has_top (has_top congr_arg_kind))) : irreducible_space (has_top (has_top congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_66945 (h0 : add_monoid (ring (finset (finset linarith.comp)))) : add_monoid.fg (ring (finset (finset linarith.comp))) := sorry --non-trivial
lemma new_lemma_66946 (h0 : topological_space (normed_field (mul_one_class linarith.ineq))) : path_connected_space (normed_field (mul_one_class linarith.ineq)) := sorry --non-trivial
lemma new_lemma_66947 (h0 : complete_lattice (has_ssubset (comm_ring (has_nnnorm linarith.ineq)))) : complete_lattice.is_Sup_finite_compact (has_ssubset (comm_ring (has_nnnorm linarith.ineq))) := sorry --non-trivial
lemma new_lemma_66948 (h0 : functor.add_const (function.extfun Type topological_space) linarith.comp) : @irreducible_space.{0} (has_neg.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) linarith.comp h0) (has_neg.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_66949 (h0 : topological_space (canonically_linear_ordered_monoid (has_pos_part real))) : t1_space (canonically_linear_ordered_monoid (has_pos_part real)) := sorry --non-trivial
lemma new_lemma_66950 (h0 : functor.add_const (ordered_comm_monoid (has_add pos)) (has_neg name)) : @has_exists_mul_of_le.{0} (has_add.{0} pos) (@functor.add_const.run.{0 0} (ordered_comm_monoid.{0} (has_add.{0} pos)) (has_neg.{0} name) h0)  := sorry --non-trivial
lemma new_lemma_66951 (h0 : ring (random_gen (random_gen num))) : strong_rank_condition (random_gen (random_gen num)) := sorry --non-trivial
lemma new_lemma_66952 (h0 : topological_space (has_Inf (has_Inf (has_add (has_add Type))))) : t0_space (has_Inf (has_Inf (has_add (has_add Type)))) := sorry --non-trivial
lemma new_lemma_66953 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @path_connected_space.{0} (complete_semilattice_Sup.{0} (random_gen.{0} (has_top.{0} (random_gen.{0} linarith.ineq)))) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (complete_semilattice_Sup.{0} (random_gen.{0} (has_top.{0} (random_gen.{0} linarith.ineq)))))  := sorry --non-trivial
lemma new_lemma_66954 (h0 : function.extfun Type list) : palindrome (function.extfun_app h0 (has_bot unsigned)) := sorry --non-trivial
lemma new_lemma_66955 (h0 : complete_lattice (has_lt (mul_one_class string.iterator_imp))) : is_compactly_generated (has_lt (mul_one_class string.iterator_imp)) := sorry --non-trivial
lemma new_lemma_66956 (h0 : function.extfun Type filter) : countable_Inter_filter (function.extfun_app h0 (add_comm_monoid (option empty))) := sorry --non-trivial
lemma new_lemma_66957 (h0 : functor.add_const (filter (has_zero pos)) pos) : countable_Inter_filter (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_66958 (h0 : functor.add_const (topological_space (semigroup Type)) Type) : @sequential_space.{1} (semigroup.{1} Type) (@functor.add_const.run.{1 1} (topological_space.{1} (semigroup.{1} Type)) Type h0)  := sorry --non-trivial
lemma new_lemma_66959 (h0 : topological_space (uniform_space (non_unital_non_assoc_semiring (mul_one_class string.iterator_imp)))) : t0_space (uniform_space (non_unital_non_assoc_semiring (mul_one_class string.iterator_imp))) := sorry --non-trivial
lemma new_lemma_66960 (h0 : topological_space (distrib (mul_one_class char))) : path_connected_space (distrib (mul_one_class char)) := sorry --non-trivial
lemma new_lemma_66961 (h0 : function.extfun Type topological_space) : @locally_compact_space.{0} (simple_graph.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (simple_graph.{0} pos))  := sorry --non-trivial
lemma new_lemma_66962 (h0 : not (ring (add_monoid linarith.comp_source) -> false)) : @is_domain.{0} (add_monoid.{0} linarith.comp_source) (@classical.by_contradiction'.{1} (ring.{0} (add_monoid.{0} linarith.comp_source)) h0)  := sorry --non-trivial
lemma new_lemma_66963 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @t0_space.{0} (comm_monoid.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (comm_monoid.{0} empty))  := sorry --non-trivial
lemma new_lemma_66964 (h0 : uniform_space (id (has_top (has_norm linarith.comp)))) : complete_space (id (has_top (has_norm linarith.comp))) := sorry --non-trivial
lemma new_lemma_66965 (h0 : topological_space (has_neg (has_neg_part pos))) : irreducible_space (has_neg (has_neg_part pos)) := sorry --non-trivial
lemma new_lemma_66966 (h3 : topological_space (mul_one_class linarith.ineq)) (h4 : set (mul_one_class linarith.ineq)) : is_path_connected h4 := sorry --non-trivial
lemma new_lemma_66967 (h0 : topological_space (has_top (has_inv fun_info))) : totally_separated_space (has_top (has_inv fun_info)) := sorry --non-trivial
lemma new_lemma_66968 (h0 : functor.add_const (filter (add_cancel_monoid Type)) unsigned) : filter.ne_bot (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_66969 (h0 : topological_space (normed_lattice_add_comm_group pos)) : t1_space (normed_lattice_add_comm_group pos) := sorry --non-trivial
lemma new_lemma_66970 (h0 : functor.add_const (uniform_space (has_Sup empty)) empty) : @separated_space.{0} (has_Sup.{0} empty) (@functor.add_const.run.{0 0} (uniform_space.{0} (has_Sup.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_66971 (h0 : not (function.extfun Type group -> false)) : @group.fg.{0} (has_top.{0} char) (@function.extfun_app.{2 1} Type group.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type group.{0}) h0) (has_top.{0} char))  := sorry --non-trivial
lemma new_lemma_66972 (h0 : ring rat) : is_domain rat := sorry --non-trivial
lemma new_lemma_66973 (h0 : topological_space (ring (boolean_algebra name))) : preconnected_space (ring (boolean_algebra name)) := sorry --non-trivial
lemma new_lemma_66974 (h0 : topological_space (normed_comm_ring (option unsigned))) : topological_space.separable_space (normed_comm_ring (option unsigned)) := sorry --non-trivial
lemma new_lemma_66975 (h0 : function.extfun (Type 1) ring) : @strong_rank_condition.{1} (has_neg_part.{1} Type) (@function.extfun_app.{3 2} (Type 1) ring.{1} h0 (has_neg_part.{1} Type))  := sorry --non-trivial
lemma new_lemma_66976 (h0 : functor.add_const (topological_space (add_cancel_monoid name)) linarith.comp) : @discrete_topology.{0} (add_cancel_monoid.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (add_cancel_monoid.{0} name)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_66977 (h0 : topological_space (random_gen (random_gen (random_gen fun_info)))) : totally_separated_space (random_gen (random_gen (random_gen fun_info))) := sorry --non-trivial
lemma new_lemma_66978 (h2 : ring (non_unital_non_assoc_semiring string_imp)) : rank_condition (non_unital_non_assoc_semiring string_imp) := sorry --non-trivial
lemma new_lemma_66979 (h0 : topological_space (add_cancel_monoid (has_add name))) : path_connected_space (add_cancel_monoid (has_add name)) := sorry --non-trivial
lemma new_lemma_66980 (h0 : fin has_zero.zero) : matrix.vec_empty (id (id (id (matrix.vec_empty (id (id (id h0))))))) := sorry --non-trivial
lemma new_lemma_66981 (h0 : not (function.extfun (finset Type) (has_mem.mem to_additive.value_type) -> false)) : @normalizer_condition.{0} to_additive.value_type (@finset.pi.empty.{1 0} Type group.{0} to_additive.value_type (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) to_additive.value_type) (@classical.by_contradiction'.{0} (function.extfun.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) to_additive.value_type)) h0) (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_66982 (h0 : topological_space (has_bot (sub_neg_monoid (sub_neg_monoid pos)))) : path_connected_space (has_bot (sub_neg_monoid (sub_neg_monoid pos))) := sorry --non-trivial
lemma new_lemma_66983 (h0 : semiring (has_Sup num)) : is_noetherian_ring (has_Sup num) := sorry --non-trivial
lemma new_lemma_66984 (h0 : complete_lattice (dlist (random_gen (random_gen linarith.comp_source)))) : is_compactly_generated (dlist (random_gen (random_gen linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_66985 (h0 : group (add_cancel_monoid name)) : is_simple_group (add_cancel_monoid name) := sorry --non-trivial
lemma new_lemma_66986 (h2 h3 : multiset (nondiscrete_normed_field ereal)) : multiset.subset h2 h3 := sorry --non-trivial
lemma new_lemma_66987 (h0 : add_group (nondiscrete_normed_field (has_ssubset environment.projection_info))) : is_add_cyclic (nondiscrete_normed_field (has_ssubset environment.projection_info)) := sorry --non-trivial
lemma new_lemma_66988 (h0 : function.extfun Type group) : @is_cyclic.{0} (semiring.{0} (random_gen.{0} (random_gen.{0} (random_gen.{0} (random_gen.{0} num))))) (@function.extfun_app.{2 1} Type group.{0} h0 (semiring.{0} (random_gen.{0} (random_gen.{0} (random_gen.{0} (random_gen.{0} num))))))  := sorry --non-trivial
lemma new_lemma_66989 (h0 : topological_space (boolean_algebra.core (boolean_algebra.core (boolean_algebra.core linarith.comp)))) : regular_space (boolean_algebra.core (boolean_algebra.core (boolean_algebra.core linarith.comp))) := sorry --non-trivial
lemma new_lemma_66990 (h0 : topological_space (semiring unsigned)) : totally_separated_space (semiring unsigned) := sorry --non-trivial
lemma new_lemma_66991 (h0 : complete_lattice (semigroup (finset Type))) : is_compactly_generated (semigroup (finset Type)) := sorry --non-trivial
lemma new_lemma_66992 (h0 : functor.add_const (uniform_space (add_cancel_monoid Type)) (has_neg (has_add linarith.comp))) : @separated_space.{1} (add_cancel_monoid.{1} Type) (@functor.add_const.run.{1 0} (uniform_space.{1} (add_cancel_monoid.{1} Type)) (has_neg.{0} (has_add.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_66993 (h0 : group (has_repr ennreal)) : is_simple_group (has_repr ennreal) := sorry --non-trivial
lemma new_lemma_66994 (h0 : functor.add_const (function.extfun Type complete_lattice) (has_pos_part pos)) : @complete_lattice.is_Sup_finite_compact.{0} (has_pos_part.{0} pos) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type complete_lattice.{0}) (has_pos_part.{0} pos) h0) (has_pos_part.{0} pos))  := sorry --non-trivial
lemma new_lemma_66995 (h0 : topological_space (complete_linear_order num)) : path_connected_space (complete_linear_order num) := sorry --non-trivial
lemma new_lemma_66996 (h0 : functor.add_const (add_monoid (ordered_comm_ring Type)) pos) : @add_monoid.fg.{1} (ordered_comm_ring.{1} Type) (@functor.add_const.run.{1 0} (add_monoid.{1} (ordered_comm_ring.{1} Type)) pos h0)  := sorry --non-trivial
lemma new_lemma_66997 (h0 : functor.comp topological_space complete_distrib_lattice Type) : @regular_space.{1} (complete_distrib_lattice.{1} Type) (@functor.comp.run.{1 1 1} topological_space.{1} complete_distrib_lattice.{1} Type h0)  := sorry --non-trivial
lemma new_lemma_66998 (h0 : functor.add_const (group (has_Inf pos)) (has_neg Type)) : @group.fg.{0} (has_Inf.{0} pos) (@functor.add_const.run.{0 1} (group.{0} (has_Inf.{0} pos)) (has_neg.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_66999 (h0 : functor.add_const (function.extfun (Type 1) add_monoid) (ring pos)) : @add_monoid.fg.{1} (ordered_comm_monoid.{1} Type) (@function.extfun_app.{3 2} (Type 1) add_monoid.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) add_monoid.{1}) (ring.{0} pos) h0) (ordered_comm_monoid.{1} Type))  := sorry --non-trivial
lemma new_lemma_67000 (h0 : group (option (option ennreal))) : normalizer_condition (option (option ennreal)) := sorry --non-trivial
lemma new_lemma_67001 (h0 : group (comm_group (has_add pos))) : group.fg (comm_group (has_add pos)) := sorry --non-trivial
lemma new_lemma_67002 (h0 : functor.add_const (topological_space (omega_complete_partial_order empty)) (semiring empty)) : @totally_disconnected_space.{0} (omega_complete_partial_order.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (omega_complete_partial_order.{0} empty)) (semiring.{0} empty) h0)  := sorry --non-trivial
lemma new_lemma_67003 (h0 : functor.add_const (ring (has_Inf pos)) pos) : @rank_condition.{0} (has_Inf.{0} pos) (@functor.add_const.run.{0 0} (ring.{0} (has_Inf.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_67004 (h0 : complete_lattice (normed_comm_ring (option ennreal))) : complete_lattice.is_Sup_finite_compact (normed_comm_ring (option ennreal)) := sorry --non-trivial
lemma new_lemma_67005 (h0 : add_group (measurable_space (has_inv (has_top (has_top linarith.comp_source))))) : is_add_cyclic (measurable_space (has_inv (has_top (has_top linarith.comp_source)))) := sorry --non-trivial
lemma new_lemma_67006 (h0 : functor.add_const (topological_space (free_add_monoid unsigned)) congr_arg_kind) : @t0_space.{0} (free_add_monoid.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (free_add_monoid.{0} unsigned)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_67007 (h0 : finset (boolean_algebra (has_nndist (ring name)))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_67008 (h3 : not (topological_space reducibility_hints -> false)) : @t0_space.{0} reducibility_hints (@classical.by_contradiction'.{1} (topological_space.{0} reducibility_hints) h3)  := sorry --non-trivial
lemma new_lemma_67009 (h0 : ring (has_nnnorm (has_ssubset fun_info))) : is_domain (has_nnnorm (has_ssubset fun_info)) := sorry --non-trivial
lemma new_lemma_67010 (h0 : function.extfun Type topological_space) : @t0_space.{0} (with_zero.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (with_zero.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_67011 (h0 : topological_space (has_nndist (option pos))) : totally_separated_space (has_nndist (option pos)) := sorry --non-trivial
lemma new_lemma_67012 (h0 : measurable_space (has_div enat)) (h1 : filter (has_div enat)) : filter.is_measurably_generated h1 := sorry --non-trivial
lemma new_lemma_67013 (h0 : functor.add_const (add_monoid (has_neg_part name)) (finset unsigned)) : @add_monoid.fg.{0} (has_neg_part.{0} name) (@functor.add_const.run.{0 0} (add_monoid.{0} (has_neg_part.{0} name)) (finset.{0} unsigned) h0)  := sorry --non-trivial
lemma new_lemma_67014 (h0 : function.extfun Type topological_space) : @t0_space.{0} (ordered_comm_group.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (ordered_comm_group.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_67015 (h0 : topological_space (has_ssubset (has_lt (uniform_space linarith.comp_source)))) : totally_disconnected_space (has_ssubset (has_lt (uniform_space linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_67016 (h0 : function.extfun Type topological_space) : @preirreducible_space.{0} (ordered_cancel_add_comm_monoid.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (ordered_cancel_add_comm_monoid.{0} empty))  := sorry --non-trivial
lemma new_lemma_67017 (h0 : functor.add_const (functor.add_const (function.extfun Type ring) Type) (boolean_algebra (finset linarith.comp))) : @is_domain.{0} (has_inner.{0 0} name pos) (@function.extfun_app.{2 1} Type ring.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type ring.{0}) Type (@functor.add_const.run.{1 0} (functor.add_const.{1 1} (function.extfun.{2 1} Type ring.{0}) Type) (boolean_algebra.{0} (finset.{0} linarith.comp)) h0)) (has_inner.{0 0} name pos))  := sorry --non-trivial
lemma new_lemma_67018 (h0 : set (add_comm_semigroup (add_comm_semigroup ereal) -> ereal)) : set.separates_points h0 := sorry --non-trivial
lemma new_lemma_67019 (h0 : function.extfun Type topological_space) : @normal_space.{0} (@id.{2} Type empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (@id.{2} Type empty))  := sorry --non-trivial
lemma new_lemma_67020 (h0 : functor.add_const (topological_space (mul_zero_class empty)) empty) : @topological_space.separable_space.{0} (mul_zero_class.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (mul_zero_class.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_67021 (h1 : monoid (with_one linarith.ineq)) : monoid.fg (with_one linarith.ineq) := sorry --non-trivial
lemma new_lemma_67022 (h0 : monoid (filter congr_arg_kind)) : monoid.fg (filter congr_arg_kind) := sorry --non-trivial
lemma new_lemma_67023 (h0 : functor.add_const (group ennreal) ennreal) : @normalizer_condition.{0} ennreal (@functor.add_const.run.{0 0} (group.{0} ennreal) ennreal h0)  := sorry --non-trivial
lemma new_lemma_67024 (h0 : uniform_space (complete_distrib_lattice (has_Inf (normed_comm_ring name)))) : separated_space (complete_distrib_lattice (has_Inf (normed_comm_ring name))) := sorry --non-trivial
lemma new_lemma_67025 (h0 : functor.add_const (group (add_cancel_monoid pos)) (finset (finset (has_add pos)))) : @is_cyclic.{0} (add_cancel_monoid.{0} pos) (@functor.add_const.run.{0 0} (group.{0} (add_cancel_monoid.{0} pos)) (finset.{0} (finset.{0} (has_add.{0} pos))) h0)  := sorry --non-trivial
lemma new_lemma_67026 (h0 : functor.add_const (complete_lattice (boolean_algebra pos)) (has_to_string (has_neg (ring Type)))) : @is_compactly_generated.{0} (boolean_algebra.{0} pos) (@functor.add_const.run.{0 1} (complete_lattice.{0} (boolean_algebra.{0} pos)) (has_to_string.{1} (has_neg.{1} (ring.{1} Type))) h0)  := sorry --non-trivial
lemma new_lemma_67027 (h0 : ring (normed_comm_ring (add_comm_monoid (has_add name)))) : strong_rank_condition (normed_comm_ring (add_comm_monoid (has_add name))) := sorry --non-trivial
lemma new_lemma_67028 (h0 : not (function.extfun Type uniform_space -> false)) : @complete_space.{0} (normed_group.{0} num) (@function.extfun_app.{2 1} Type uniform_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type uniform_space.{0}) h0) (normed_group.{0} num))  := sorry --non-trivial
lemma new_lemma_67029 (h0 : function.extfun (finset Type) (has_mem.mem num)) : @path_connected_space.{0} num (@finset.pi.empty.{1 0} Type topological_space.{0} num (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) num) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_67030 (h0 : topological_space (linear_ordered_comm_group unsigned)) : t1_space (linear_ordered_comm_group unsigned) := sorry --non-trivial
lemma new_lemma_67031 (h0 : topological_space (has_norm (has_norm empty))) : preirreducible_space (has_norm (has_norm empty)) := sorry --non-trivial
lemma new_lemma_67032 (h0 : topological_space (has_add (has_pos_part (finset Type)))) : locally_compact_space (has_add (has_pos_part (finset Type))) := sorry --non-trivial
lemma new_lemma_67033 (h0 : functor.add_const (filter (has_to_string ennreal)) name) : countable_Inter_filter (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_67034 (h0 : topological_space (add_cancel_monoid (mul_one_class pos))) : sequential_space (add_cancel_monoid (mul_one_class pos)) := sorry --non-trivial
lemma new_lemma_67035 (h0 : topological_space (measurable_space (semiring unsigned))) : path_connected_space (measurable_space (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_67036 (h0 : add_group to_additive.value_type -> add_group to_additive.value_type -> Prop) (h1 : function.extfun (add_group to_additive.value_type -> add_group to_additive.value_type -> Prop) well_founded) (h2 : add_group to_additive.value_type) : is_add_cyclic to_additive.value_type := sorry --non-trivial
lemma new_lemma_67037 (h0 : topological_space (add_cancel_monoid (has_pos_part Type))) : totally_separated_space (add_cancel_monoid (has_pos_part Type)) := sorry --non-trivial
lemma new_lemma_67038 (h0 : complete_lattice (pseudo_metric_space (finset (has_nndist (finset pos))))) : is_atomistic (pseudo_metric_space (finset (has_nndist (finset pos)))) := sorry --non-trivial
lemma new_lemma_67039 (h0 : topological_space (add_right_cancel_monoid (semiring (semiring (semiring (semiring empty)))))) : normal_space (add_right_cancel_monoid (semiring (semiring (semiring (semiring empty))))) := sorry --non-trivial
lemma new_lemma_67040 (h0 : function.extfun Type (functor.add_const (topological_space ennreal))) : discrete_topology ennreal := sorry --non-trivial
lemma new_lemma_67041 (h0 : function.extfun Type complete_lattice) : @is_atomistic.{0} (add_cancel_comm_monoid.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (add_cancel_comm_monoid.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_67042 (h0 : semiring (normed_group unsigned)) : is_noetherian_ring (normed_group unsigned) := sorry --non-trivial
lemma new_lemma_67043 (h0 : function.extfun Type topological_space) : @locally_compact_space.{0} (add_group.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (add_group.{0} num))  := sorry --non-trivial
lemma new_lemma_67044 (h0 : functor.add_const (cancel_comm_monoid_with_zero (add_cancel_monoid ennreal)) ennreal) : @unique_factorization_monoid.{0} (add_cancel_monoid.{0} ennreal) (@functor.add_const.run.{0 0} (cancel_comm_monoid_with_zero.{0} (add_cancel_monoid.{0} ennreal)) ennreal h0)  := sorry --non-trivial
lemma new_lemma_67045 (h0 : topological_space (cancel_monoid (option ennreal))) : loc_path_connected_space (cancel_monoid (option ennreal)) := sorry --non-trivial
lemma new_lemma_67046 (h0 : add_group (linear_ordered_semiring (random_gen num))) : is_add_cyclic (linear_ordered_semiring (random_gen num)) := sorry --non-trivial
lemma new_lemma_67047 (h0 : topological_space (left_cancel_monoid (semiring num))) : totally_separated_space (left_cancel_monoid (semiring num)) := sorry --non-trivial
lemma new_lemma_67048 (h0 : not (function.extfun Type uniform_space -> false)) : @separated_space.{0} (with_bot.{0} empty) (@function.extfun_app.{2 1} Type uniform_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type uniform_space.{0}) h0) (with_bot.{0} empty))  := sorry --non-trivial
lemma new_lemma_67049 (h0 : function.extfun Type topological_space) : @preirreducible_space.{0} (has_Inf.{0} real) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_Inf.{0} real))  := sorry --non-trivial
lemma new_lemma_67050 (h0 : ring (has_div std_gen)) : is_domain (has_div std_gen) := sorry --non-trivial
lemma new_lemma_67051 (h0 : topological_space (preorder (option (option num)))) : path_connected_space (preorder (option (option num))) := sorry --non-trivial
lemma new_lemma_67052 (h0 : group (simple_graph (boolean_algebra.core (has_add (has_add pos))))) : normalizer_condition (simple_graph (boolean_algebra.core (has_add (has_add pos)))) := sorry --non-trivial
lemma new_lemma_67053 (h0 : group (has_inv (has_inv linarith.comp_source))) : is_cyclic (has_inv (has_inv linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_67054 (h0 : monoid (boolean_algebra (has_to_string (comm_group unsigned)))) : monoid.fg (boolean_algebra (has_to_string (comm_group unsigned))) := sorry --non-trivial
lemma new_lemma_67055 (h0 : finset (semigroup (semiring (semiring empty)))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_67056 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @normalizer_condition.{0} (comm_group.{0} pos) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (comm_group.{0} pos))  := sorry --non-trivial
lemma new_lemma_67057 (h0 : fin has_zero.zero) : @preirreducible_space.{0} (boolean_algebra.{0} real) (@matrix.vec_empty.{0} (topological_space.{0} (boolean_algebra.{0} real)) (@matrix.vec_empty.{0} (fin (@has_zero.zero.{0} nat nat.has_zero)) h0))  := sorry --non-trivial
lemma new_lemma_67058 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @monoid.fg.{0} (has_norm.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 monoid.{0}) (has_norm.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_67059 (h0 : has_lt (has_lt char)) : no_max_order (has_lt char) := sorry --non-trivial
lemma new_lemma_67060 (h0 : function.extfun Type topological_space) : @path_connected_space.{0} (normed_group.{0} fun_info) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (normed_group.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_67061 (h2 : topological_space (random_gen (denumerable fun_info))) : t0_space (random_gen (denumerable fun_info)) := sorry --non-trivial
lemma new_lemma_67062 (h0 : set string.iterator_imp) : set.finite h0 := sorry --non-trivial
lemma new_lemma_67063 (h1 : ring (topological_space (has_nnnorm (has_nnnorm (has_nnnorm char))))) : rank_condition (topological_space (has_nnnorm (has_nnnorm (has_nnnorm char)))) := sorry --non-trivial
lemma new_lemma_67064 (h0 : uniform_space (complete_distrib_lattice unsigned)) : separated_space (complete_distrib_lattice unsigned) := sorry --non-trivial
lemma new_lemma_67065 (h0 : functor.add_const (function.extfun Type topological_space) Type) : @path_connected_space.{0} (semigroup.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type topological_space.{0}) Type h0) (semigroup.{0} name))  := sorry --non-trivial
lemma new_lemma_67066 (h0 : topological_space (semi_normed_ring (has_nnnorm reducibility_hints))) : totally_disconnected_space (semi_normed_ring (has_nnnorm reducibility_hints)) := sorry --non-trivial
lemma new_lemma_67067 (h0 : functor.comp topological_space comm_group pos) : @path_connected_space.{0} (comm_group.{0} pos) (@functor.comp.run.{0 0 0} topological_space.{0} comm_group.{0} pos h0)  := sorry --non-trivial
lemma new_lemma_67068 (h0 : not (group (linear_ordered_comm_ring empty) -> false)) : @normalizer_condition.{0} (linear_ordered_comm_ring.{0} empty) (@classical.by_contradiction'.{1} (group.{0} (linear_ordered_comm_ring.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_67069 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_compactly_generated.{0} (left_cancel_semigroup.{0} empty) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (left_cancel_semigroup.{0} empty))  := sorry --non-trivial
lemma new_lemma_67070 (h0 : topological_space (comm_group (add_cancel_monoid linarith.comp))) : normal_space (comm_group (add_cancel_monoid linarith.comp)) := sorry --non-trivial
lemma new_lemma_67071 (h0 : add_comm_monoid (has_add congr_arg_kind) -> add_comm_monoid (has_add congr_arg_kind) -> Prop) : is_symm (add_comm_monoid (has_add congr_arg_kind)) h0 := sorry --non-trivial
lemma new_lemma_67072 (h0 : add_group char) : is_add_cyclic char := sorry --non-trivial
lemma new_lemma_67073 (h0 : has_lt (has_compl (semi_normed_comm_ring reducibility_hints))) : no_max_order (has_compl (semi_normed_comm_ring reducibility_hints)) := sorry --non-trivial
lemma new_lemma_67074 (h0 : topological_space (has_norm (random_gen (random_gen num)))) : path_connected_space (has_norm (random_gen (random_gen num))) := sorry --non-trivial
lemma new_lemma_67075 (h0 : not (group (random_gen char) -> false)) : @group.fg.{0} (random_gen.{0} char) (@classical.by_contradiction'.{1} (group.{0} (random_gen.{0} char)) h0)  := sorry --non-trivial
lemma new_lemma_67076 (h0 : functor.add_const (monoid (semigroup environment.implicit_infer_kind)) name) : @monoid.fg.{0} (semigroup.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (monoid.{0} (semigroup.{0} environment.implicit_infer_kind)) name h0)  := sorry --non-trivial
lemma new_lemma_67077 (h1 : topological_space (has_nnnorm to_additive.value_type)) (h2 : has_inf (has_nnnorm to_additive.value_type)) : has_continuous_inf (has_nnnorm to_additive.value_type) := sorry --non-trivial
lemma new_lemma_67078 (h0 : functor.add_const (uniform_space (add_comm_monoid name)) (normed_comm_ring pos)) : @complete_space.{0} (add_comm_monoid.{0} name) (@functor.add_const.run.{0 0} (uniform_space.{0} (add_comm_monoid.{0} name)) (normed_comm_ring.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_67079 (h0 : has_lt (linear_ordered_comm_group_with_zero (mul_one_class linarith.comp_source))) : no_max_order (linear_ordered_comm_group_with_zero (mul_one_class linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_67080 (h0 : not (has_mem.mem (complete_semilattice_Sup num) has_emptyc.emptyc -> false)) : @t0_space.{0} (complete_semilattice_Sup.{0} num) (@finset.pi.empty.{1 0} Type topological_space.{0} (complete_semilattice_Sup.{0} num) (@classical.by_contradiction'.{0} (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (complete_semilattice_Sup.{0} num) (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))) h0))  := sorry --non-trivial
lemma new_lemma_67081 (h0 : functor.add_const (topological_space (has_star empty)) empty) : @preirreducible_space.{0} (has_star.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (has_star.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_67082 (h0 : functor.add_const (uniform_space (partial_order unsigned)) congr_arg_kind) : @separated_space.{0} (partial_order.{0} unsigned) (@functor.add_const.run.{0 0} (uniform_space.{0} (partial_order.{0} unsigned)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_67083 (h0 : functor.add_const (fin has_zero.zero) linarith.comp) : @discrete_topology.{1} (ordered_comm_ring.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@matrix.vec_empty.{2} (function.extfun.{3 2} (Type 1) topological_space.{1}) (@functor.add_const.run.{0 0} (fin (@has_zero.zero.{0} nat nat.has_zero)) linarith.comp h0)) (ordered_comm_ring.{1} Type))  := sorry --non-trivial
lemma new_lemma_67084 (h0 : function.extfun Type topological_space) : @path_connected_space.{0} (has_nndist.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_nndist.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_67085 (h0 : topological_space (linear_ordered_comm_ring empty)) (h1 : option (topological_space (linear_ordered_comm_ring empty))) : t1_space (linear_ordered_comm_ring empty) := sorry --non-trivial
lemma new_lemma_67086 (h0 : uniform_space (has_subset (semiring congr_arg_kind))) : separated_space (has_subset (semiring congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_67087 (h0 : group (has_to_string environment.implicit_infer_kind)) : normalizer_condition (has_to_string environment.implicit_infer_kind) := sorry --non-trivial
lemma new_lemma_67088 (h1 : topological_space (nondiscrete_normed_field (mul_one_class ereal))) : totally_disconnected_space (nondiscrete_normed_field (mul_one_class ereal)) := sorry --non-trivial
lemma new_lemma_67089 (h0 : monoid (add_cancel_monoid Type)) : monoid.fg (add_cancel_monoid Type) := sorry --non-trivial
lemma new_lemma_67090 (h0 : comm_semiring (pseudo_metric_space empty)) (h1 : polynomial (pseudo_metric_space empty)) : polynomial.separable h1 := sorry --non-trivial
lemma new_lemma_67091 (h0 : ring (has_ssubset string.iterator_imp)) : is_domain (has_ssubset string.iterator_imp) := sorry --non-trivial
lemma new_lemma_67092 (h0 : function.extfun (Type 1) (functor.comp topological_space semigroup)) : @preconnected_space.{1} (semigroup.{1} Type) (@functor.comp.run.{1 1 1} topological_space.{1} semigroup.{1} Type (@function.extfun_app.{3 2} (Type 1) (functor.comp.{1 1 1} topological_space.{1} semigroup.{1}) h0 Type))  := sorry --non-trivial
lemma new_lemma_67093 (h0 : topological_space (has_le fun_info)) : t0_space (has_le fun_info) := sorry --non-trivial
lemma new_lemma_67094 (h0 : not (topological_space (has_norm linarith.comp) -> false)) : @totally_disconnected_space.{0} (has_norm.{0} linarith.comp) (@classical.by_contradiction'.{1} (topological_space.{0} (has_norm.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_67095 (h0 : functor.add_const (complete_lattice (ring linarith.comp)) (finset (finset (finset Type)))) : @is_compactly_generated.{0} (ring.{0} linarith.comp) (@functor.add_const.run.{0 1} (complete_lattice.{0} (ring.{0} linarith.comp)) (finset.{1} (finset.{1} (finset.{1} Type))) h0)  := sorry --non-trivial
lemma new_lemma_67096 (h0 : function.extfun Type topological_space) : @totally_disconnected_space.{0} (finset.{0} (option.{0} unsigned)) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (finset.{0} (option.{0} unsigned)))  := sorry --non-trivial
lemma new_lemma_67097 (h0 : functor.add_const (ordered_comm_monoid (boolean_algebra pos)) (comm_group name)) : @has_exists_mul_of_le.{0} (boolean_algebra.{0} pos) (@functor.add_const.run.{0 0} (ordered_comm_monoid.{0} (boolean_algebra.{0} pos)) (comm_group.{0} name) h0)  := sorry --non-trivial
lemma new_lemma_67098 (h1 : function.extfun Type monoid) : @monoid.fg.{0} (semiring.{0} linarith.ineq) (@function.extfun_app.{2 1} Type monoid.{0} h1 (semiring.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_67099 (h0 : semiring std_gen) (h1 : ordered_semiring std_gen) (h2 : uniform_space (absolute_value std_gen std_gen)) : complete_space (absolute_value std_gen std_gen) := sorry --non-trivial
lemma new_lemma_67100 (h0 : group (semigroup (ring (finset (ring pos))))) : is_simple_group (semigroup (ring (finset (ring pos)))) := sorry --non-trivial
lemma new_lemma_67101 (h0 : function.extfun (finset Type) (has_mem.mem (has_top linarith.comp))) : @strong_rank_condition.{0} (has_top.{0} linarith.comp) (@finset.pi.empty.{1 0} Type ring.{0} (has_top.{0} linarith.comp) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (has_top.{0} linarith.comp)) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_67102 (h0 : not (complete_lattice (measurable_space to_additive.value_type) -> false)) : complete_lattice.is_Sup_finite_compact (measurable_space to_additive.value_type) := sorry --non-trivial
lemma new_lemma_67103 (h0 : function.extfun nat fin) : @is_cyclic.{0} (ordered_comm_ring.{0} pos) (@function.extfun_app.{2 1} Type group.{0} (@matrix.vec_empty.{1} (function.extfun.{2 1} Type group.{0}) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero))) (ordered_comm_ring.{0} pos))  := sorry --non-trivial
lemma new_lemma_67104 (h0 : functor.add_const (finset (semiring congr_arg_kind)) congr_arg_kind) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_67105 (h1 h2 : ereal) : function.is_fixed_pt (fun (h0 : ereal), h1) h2 := sorry --non-trivial
lemma new_lemma_67106 (h0 : ring (dlist (comm_ring to_additive.value_type))) : is_domain (dlist (comm_ring to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_67107 (h0 : function.extfun Type list) : palindrome (function.extfun_app h0 (cancel_monoid name)) := sorry --non-trivial
lemma new_lemma_67108 (h0 : topological_space (with_one (semiring fun_info))) : path_connected_space (with_one (semiring fun_info)) := sorry --non-trivial
lemma new_lemma_67109 (h0 : functor.add_const (complete_lattice (canonically_linear_ordered_monoid pos)) pos) : @is_atomistic.{0} (canonically_linear_ordered_monoid.{0} pos) (@functor.add_const.run.{0 0} (complete_lattice.{0} (canonically_linear_ordered_monoid.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_67110 (h0 : filter (metric_space (has_norm linarith.comp))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_67111 (h0 : add_group (linear_ordered_add_comm_group (has_inv linarith.ineq))) : is_add_cyclic (linear_ordered_add_comm_group (has_inv linarith.ineq)) := sorry --non-trivial
lemma new_lemma_67112 (h0 : ring (ordered_cancel_add_comm_monoid congr_arg_kind)) : is_principal_ideal_ring (ordered_cancel_add_comm_monoid congr_arg_kind) := sorry --non-trivial
lemma new_lemma_67113 (h0 : functor.add_const (topological_space (ring environment.implicit_infer_kind)) name) : @discrete_topology.{0} (ring.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (ring.{0} environment.implicit_infer_kind)) name h0)  := sorry --non-trivial
lemma new_lemma_67114 (h0 : set (set (denumerable linarith.ineq))) : is_countably_spanning h0 := sorry --non-trivial
lemma new_lemma_67115 (h0 : function.extfun (finset Type) (has_mem.mem (normed_group fun_info))) : @complete_lattice.is_Sup_finite_compact.{0} (normed_group.{0} fun_info) (@finset.pi.empty.{1 0} Type complete_lattice.{0} (normed_group.{0} fun_info) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (normed_group.{0} fun_info)) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_67116 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @t1_space.{0} (monoid_with_zero.{0} ennreal) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (monoid_with_zero.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_67117 (h0 : ring (finset (finset (finset pos)))) : is_principal_ideal_ring (finset (finset (finset pos))) := sorry --non-trivial
lemma new_lemma_67118 (h0 : topological_space (random_gen (has_inv linarith.ineq))) : path_connected_space (random_gen (has_inv linarith.ineq)) := sorry --non-trivial
lemma new_lemma_67119 (h0 : complete_lattice (linear_ordered_comm_group_with_zero string.iterator_imp)) : complete_lattice.is_Sup_finite_compact (linear_ordered_comm_group_with_zero string.iterator_imp) := sorry --non-trivial
lemma new_lemma_67120 (h0 : add_group (sub_neg_monoid (option (option (option (option (option (option empty)))))))) : is_add_cyclic (sub_neg_monoid (option (option (option (option (option (option empty))))))) := sorry --non-trivial
lemma new_lemma_67121 (h0 : functor.add_const (group (has_zero name)) unsigned) : @is_cyclic.{0} (has_zero.{0} name) (@functor.add_const.run.{0 0} (group.{0} (has_zero.{0} name)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_67122 (h0 : complete_lattice (has_inner (comm_monoid empty) num)) : is_compactly_generated (has_inner (comm_monoid empty) num) := sorry --non-trivial
lemma new_lemma_67123 (h0 : functor.add_const (ring (has_to_string Type)) environment.implicit_infer_kind) : @is_principal_ideal_ring.{1} (has_to_string.{1} Type) (@functor.add_const.run.{1 0} (ring.{1} (has_to_string.{1} Type)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_67124 (h0 : functor.add_const (uniform_space (has_neg Type)) Type) : @complete_space.{1} (has_neg.{1} Type) (@functor.add_const.run.{1 1} (uniform_space.{1} (has_neg.{1} Type)) Type h0)  := sorry --non-trivial
lemma new_lemma_67125 (h0 : topological_space (has_norm (has_norm num))) : discrete_topology (has_norm (has_norm num)) := sorry --non-trivial
lemma new_lemma_67126 (h0 : not (topological_space (has_emptyc empty) -> false)) : @irreducible_space.{0} (has_emptyc.{0} empty) (@classical.by_contradiction'.{1} (topological_space.{0} (has_emptyc.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_67127 (h0 : not (complete_lattice nnreal -> false)) : @complete_lattice.is_Sup_finite_compact.{0} nnreal (@classical.by_contradiction'.{1} (complete_lattice.{0} nnreal) h0)  := sorry --non-trivial
lemma new_lemma_67128 (h0 : topological_space (canonically_ordered_comm_semiring (has_add (has_add (has_add Type))))) : preconnected_space (canonically_ordered_comm_semiring (has_add (has_add (has_add Type)))) := sorry --non-trivial
lemma new_lemma_67129 (h0 : topological_space (left_cancel_semigroup (semiring congr_arg_kind))) : irreducible_space (left_cancel_semigroup (semiring congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_67130 (h0 : not (function.extfun Type topological_space -> false)) : @discrete_topology.{0} (random_gen.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (random_gen.{0} num))  := sorry --non-trivial
lemma new_lemma_67131 (h0 : topological_space (has_edist (semiring (option empty)))) : t0_space (has_edist (semiring (option empty))) := sorry --non-trivial
lemma new_lemma_67132 (h0 : function.extfun Type ordered_comm_monoid) : @has_exists_mul_of_le.{0} (ordered_cancel_add_comm_monoid.{0} pos) (@function.extfun_app.{2 1} Type ordered_comm_monoid.{0} h0 (ordered_cancel_add_comm_monoid.{0} pos))  := sorry --non-trivial
lemma new_lemma_67133 (h0 : add_monoid (has_top linarith.comp_source)) (h1 : function.extfun Type has_top) : is_of_fin_add_order (function.extfun_app h1 linarith.comp_source) := sorry --non-trivial
lemma new_lemma_67134 (h0 : not (complete_lattice (complete_semilattice_Sup to_additive.value_type) -> false)) : @is_compactly_generated.{0} (complete_semilattice_Sup.{0} to_additive.value_type) (@classical.by_contradiction'.{1} (complete_lattice.{0} (complete_semilattice_Sup.{0} to_additive.value_type)) h0)  := sorry --non-trivial
lemma new_lemma_67135 (h0 : complete_lattice (id (has_norm linarith.comp))) : is_compactly_generated (id (has_norm linarith.comp)) := sorry --non-trivial
lemma new_lemma_67136 (h0 : group (finset (has_Inf linarith.comp))) : is_simple_group (finset (has_Inf linarith.comp)) := sorry --non-trivial
lemma new_lemma_67137 (h0 : functor.add_const (ring (normed_linear_ordered_group unsigned)) empty) : @is_domain.{0} (normed_linear_ordered_group.{0} unsigned) (@functor.add_const.run.{0 0} (ring.{0} (normed_linear_ordered_group.{0} unsigned)) empty h0)  := sorry --non-trivial
lemma new_lemma_67138 (h0 : has_mem.mem (with_one linarith.ineq) has_emptyc.emptyc) : @path_connected_space.{0} (with_one.{0} linarith.ineq) (@finset.pi.empty.{1 0} Type topological_space.{0} (with_one.{0} linarith.ineq) h0)  := sorry --non-trivial
lemma new_lemma_67139 (h0 : topological_space (complete_distrib_lattice name)) : totally_disconnected_space (complete_distrib_lattice name) := sorry --non-trivial
lemma new_lemma_67140 (h0 : pnat) (h1 : nat) (h2 : fin (nat.succ h1) -> pnat) (h3 : fin h1) : pnat.coprime (id h0) (matrix.vec_tail h2 h3) := sorry --non-trivial
lemma new_lemma_67141 (h0 : function.extfun Type ring) : @rank_condition.{0} (complete_distrib_lattice.{0} real) (@function.extfun_app.{2 1} Type ring.{0} h0 (complete_distrib_lattice.{0} real))  := sorry --non-trivial
lemma new_lemma_67142 (h0 : function.extfun Type filter) : countable_Inter_filter (function.extfun_app h0 (normed_comm_ring num)) := sorry --non-trivial
lemma new_lemma_67143 (h0 : filter (option (option (option (option unsigned))))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_67144 (h0 : uniform_space (has_union (semiring congr_arg_kind))) : separated_space (has_union (semiring congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_67145 (h0 : topological_space (bin_tree (semiring (semiring unsigned)))) : t1_space (bin_tree (semiring (semiring unsigned))) := sorry --non-trivial
lemma new_lemma_67146 (h1 : topological_space (has_inv linarith.ineq)) : totally_disconnected_space (has_inv linarith.ineq) := sorry --non-trivial
lemma new_lemma_67147 (h0 : functor.comp (prod (has_to_string Type)) has_to_string Type) : id_rel (functor.comp.run h0) := sorry --non-trivial
lemma new_lemma_67148 (h0 : topological_space (normed_group linarith.comp)) : preirreducible_space (normed_group linarith.comp) := sorry --non-trivial
lemma new_lemma_67149 (h0 : monoid (with_one (has_norm empty))) : monoid.fg (with_one (has_norm empty)) := sorry --non-trivial
lemma new_lemma_67150 (h0 : topological_space (finset (boolean_algebra.core pos))) : normal_space (finset (boolean_algebra.core pos)) := sorry --non-trivial
lemma new_lemma_67151 (h0 : functor.add_const (topological_space (measurable_space.dynkin_system num)) empty) : @irreducible_space.{0} (measurable_space.dynkin_system.{0} num) (@functor.add_const.run.{0 0} (topological_space.{0} (measurable_space.dynkin_system.{0} num)) empty h0)  := sorry --non-trivial
lemma new_lemma_67152 (h0 : semiring (has_star (semiring unsigned))) : is_noetherian_ring (has_star (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_67153 (h0 : functor.add_const (topological_space (finset name)) Type) : @locally_compact_space.{0} (finset.{0} name) (@functor.add_const.run.{0 1} (topological_space.{0} (finset.{0} name)) Type h0)  := sorry --non-trivial
lemma new_lemma_67154 (h0 : function.extfun Type topological_space) : @irreducible_space.{0} (canonically_ordered_comm_semiring.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (canonically_ordered_comm_semiring.{0} pos))  := sorry --non-trivial
lemma new_lemma_67155 (h0 : function.extfun Type topological_space) : @path_connected_space.{0} (has_bot.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_bot.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_67156 (h0 : not (list (linear_ordered_add_comm_group fun_info) -> false)) : list.nodup (classical.by_contradiction' h0) := sorry --non-trivial
lemma new_lemma_67157 (h0 : functor.add_const (topological_space (has_to_string pos)) (finset (finset environment.implicit_infer_kind))) : @totally_disconnected_space.{0} (has_to_string.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (has_to_string.{0} pos)) (finset.{0} (finset.{0} environment.implicit_infer_kind)) h0)  := sorry --non-trivial
lemma new_lemma_67158 (h0 : topological_space (has_top (semiring unsigned))) : t1_space (has_top (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_67159 (h0 : function.extfun Type (prod (preorder empty))) : id_rel (function.extfun_app h0 (preorder empty)) := sorry --non-trivial
lemma new_lemma_67160 (h0 : filter (has_neg num)) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_67161 (h0 : functor.add_const (cancel_comm_monoid_with_zero (has_zero Type)) linarith.comp) : @unique_factorization_monoid.{1} (has_zero.{1} Type) (@functor.add_const.run.{1 0} (cancel_comm_monoid_with_zero.{1} (has_zero.{1} Type)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_67162 (h0 : thunk (fin has_zero.zero)) (h1 : ulower pnat) : pnat.coprime (@matrix.vec_empty.{0} pnat (@trace_call_stack.{0} (fin (@has_zero.zero.{0} nat nat.has_zero)) h0)) (@id.{1} pnat (@ulower.up.{0} pnat encodable.pnat h1))  := sorry --non-trivial
lemma new_lemma_67163 (h0 : not (topological_space (add_group unsigned) -> false)) : @irreducible_space.{0} (add_group.{0} unsigned) (@classical.by_contradiction'.{1} (topological_space.{0} (add_group.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_67164 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @complete_lattice.is_Sup_finite_compact.{0} (has_union.{0} num) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (has_union.{0} num))  := sorry --non-trivial
lemma new_lemma_67165 (h0 : cancel_comm_monoid_with_zero (semigroup (has_add (has_nndist name)))) : unique_factorization_monoid (semigroup (has_add (has_nndist name))) := sorry --non-trivial
lemma new_lemma_67166 (h0 : functor.add_const (topological_space (has_Sup empty)) num) : @totally_separated_space.{0} (has_Sup.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (has_Sup.{0} empty)) num h0)  := sorry --non-trivial
lemma new_lemma_67167 (h0 : fin has_zero.zero) : @monoid.fg.{0} (normed_lattice_add_comm_group.{0} name) (@matrix.vec_empty.{0} (monoid.{0} (normed_lattice_add_comm_group.{0} name)) h0)  := sorry --non-trivial
lemma new_lemma_67168 (h0 : not (has_mem.mem linarith.comp_source has_emptyc.emptyc -> false)) : @complete_space.{0} linarith.comp_source (@finset.pi.empty.{1 0} Type uniform_space.{0} linarith.comp_source (@classical.by_contradiction'.{0} (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) linarith.comp_source (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))) h0))  := sorry --non-trivial
lemma new_lemma_67169 (h0 : topological_space (cancel_monoid (complete_distrib_lattice (finset pos)))) : totally_separated_space (cancel_monoid (complete_distrib_lattice (finset pos))) := sorry --non-trivial
lemma new_lemma_67170 (h0 : semiring (has_star (semiring (semiring num)))) : is_noetherian_ring (has_star (semiring (semiring num))) := sorry --non-trivial
lemma new_lemma_67171 (h0 : uniform_space (linear_ordered_semiring (random_gen num))) : complete_space (linear_ordered_semiring (random_gen num)) := sorry --non-trivial
lemma new_lemma_67172 (h0 : functor.add_const (monoid (boolean_algebra name)) (boolean_algebra (has_add pos))) : @monoid.fg.{0} (boolean_algebra.{0} name) (@functor.add_const.run.{0 0} (monoid.{0} (boolean_algebra.{0} name)) (boolean_algebra.{0} (has_add.{0} pos)) h0)  := sorry --non-trivial
lemma new_lemma_67173 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_cyclic.{0} (has_Inf.{0} real) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (has_Inf.{0} real))  := sorry --non-trivial
lemma new_lemma_67174 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_add_cyclic.{0} (add_right_cancel_monoid.{0} unsigned) (@function.extfun_app.{2 1} Type add_group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 add_group.{0}) (add_right_cancel_monoid.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_67175 (h0 : functor.add_const (topological_space (bin_tree unsigned)) unsigned) : @totally_separated_space.{0} (bin_tree.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (bin_tree.{0} unsigned)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_67176 (h0 : topological_space environment.projection_info) (h1 : preorder environment.projection_info) : order_topology environment.projection_info := sorry --non-trivial
lemma new_lemma_67177 (h0 : set (has_le (mul_one_class (mul_one_class linarith.comp_source)))) : set.subsingleton h0 := sorry --non-trivial
lemma new_lemma_67178 (h0 : function.extfun Type semiring) : @is_noetherian_ring.{0} linarith.comp (@function.extfun_app.{2 1} Type semiring.{0} h0 linarith.comp)  := sorry --non-trivial
lemma new_lemma_67179 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @strong_rank_condition.{0} pos (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) pos)  := sorry --non-trivial
lemma new_lemma_67180 (h0 : topological_space (has_div linarith.ineq)) : path_connected_space (has_div linarith.ineq) := sorry --non-trivial
lemma new_lemma_67181 (h0 : function.extfun Type group) : @normalizer_condition.{0} (has_neg.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type group.{0} h0 (has_neg.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_67182 (h0 : topological_space (bin_tree empty)) : locally_compact_space (bin_tree empty) := sorry --non-trivial
lemma new_lemma_67183 (h0 : ring (add_comm_monoid (has_add unsigned))) : strong_rank_condition (add_comm_monoid (has_add unsigned)) := sorry --non-trivial
lemma new_lemma_67184 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_simple_group.{0} (monoid.{0} ennreal) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (monoid.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_67185 (h0 : complete_lattice (has_add (has_to_string (has_to_string pos)))) : complete_lattice.is_Sup_finite_compact (has_add (has_to_string (has_to_string pos))) := sorry --non-trivial
lemma new_lemma_67186 (h1 : topological_space (comm_ring reducibility_hints)) : totally_disconnected_space (comm_ring reducibility_hints) := sorry --non-trivial
lemma new_lemma_67187 (h0 : ordered_add_comm_monoid (has_Inf (has_pos_part linarith.comp))) : archimedean (has_Inf (has_pos_part linarith.comp)) := sorry --non-trivial
lemma new_lemma_67188 (h0 : topological_space (add_left_cancel_semigroup (option (option (option (option unsigned)))))) : loc_path_connected_space (add_left_cancel_semigroup (option (option (option (option unsigned))))) := sorry --non-trivial
lemma new_lemma_67189 (h0 : uniform_space (has_emptyc to_additive.value_type)) : separated_space (has_emptyc to_additive.value_type) := sorry --non-trivial
lemma new_lemma_67190 (h0 : functor.add_const (complete_lattice (has_bot real)) (comm_semigroup real)) : @is_compactly_generated.{0} (has_bot.{0} real) (@functor.add_const.run.{0 0} (complete_lattice.{0} (has_bot.{0} real)) (comm_semigroup.{0} real) h0)  := sorry --non-trivial
lemma new_lemma_67191 (h0 : list (add_left_cancel_semigroup unsigned)) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_67192 (h0 : add_group (add_comm_monoid (has_add name))) : is_add_cyclic (add_comm_monoid (has_add name)) := sorry --non-trivial
lemma new_lemma_67193 (h0 : function.extfun Type topological_space) : @irreducible_space.{0} (add_comm_monoid.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (add_comm_monoid.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_67194 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @unique_factorization_monoid.{0} (measurable_space.dynkin_system.{0} unsigned) (@function.extfun_app.{2 1} Type cancel_comm_monoid_with_zero.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 cancel_comm_monoid_with_zero.{0}) (measurable_space.dynkin_system.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_67195 (h0 : complete_lattice (semiring (has_norm linarith.comp))) : is_atomistic (semiring (has_norm linarith.comp)) := sorry --non-trivial
lemma new_lemma_67196 (h0 : ring (finset (has_neg (ring linarith.comp)))) : rank_condition (finset (has_neg (ring linarith.comp))) := sorry --non-trivial
lemma new_lemma_67197 (h0 : topological_space (has_zero (has_zero linarith.comp))) : preirreducible_space (has_zero (has_zero linarith.comp)) := sorry --non-trivial
lemma new_lemma_67198 (h0 : topological_space (option (option unsigned))) : topological_space.separable_space (option (option unsigned)) := sorry --non-trivial
lemma new_lemma_67199 (h0 : function.extfun Type ring) : @is_domain.{0} (monoid.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type ring.{0} h0 (monoid.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_67200 (h0 : finset ennreal -> finset ennreal -> Prop) : is_symm (finset ennreal) h0 := sorry --non-trivial
lemma new_lemma_67201 (h0 : ring (generalized_boolean_algebra linarith.comp)) : is_domain (generalized_boolean_algebra linarith.comp) := sorry --non-trivial
lemma new_lemma_67202 (h0 : functor.add_const (ring (has_nndist ennreal)) Type) : @strong_rank_condition.{0} (has_nndist.{0} ennreal) (@functor.add_const.run.{0 1} (ring.{0} (has_nndist.{0} ennreal)) Type h0)  := sorry --non-trivial
lemma new_lemma_67203 (h0 : ring (add_comm_monoid (comm_group (add_comm_monoid name)))) : is_domain (add_comm_monoid (comm_group (add_comm_monoid name))) := sorry --non-trivial
lemma new_lemma_67204 (h1 : topological_space (comm_ring fun_info)) : totally_disconnected_space (comm_ring fun_info) := sorry --non-trivial
lemma new_lemma_67205 (h0 : group (with_one (semiring fun_info))) : group.fg (with_one (semiring fun_info)) := sorry --non-trivial
lemma new_lemma_67206 (h0 : topological_space (has_nndist (ring (ring environment.implicit_infer_kind)))) : loc_path_connected_space (has_nndist (ring (ring environment.implicit_infer_kind))) := sorry --non-trivial
lemma new_lemma_67207 (h0 : group (linear_ordered_comm_ring (semiring (semiring (semiring empty))))) : is_cyclic (linear_ordered_comm_ring (semiring (semiring (semiring empty)))) := sorry --non-trivial
lemma new_lemma_67208 (h0 : group (has_neg (has_neg environment.implicit_infer_kind))) : is_cyclic (has_neg (has_neg environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_67209 (h0 : functor.add_const (topological_space (bin_tree num)) congr_arg_kind) : @t0_space.{0} (bin_tree.{0} num) (@functor.add_const.run.{0 0} (topological_space.{0} (bin_tree.{0} num)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_67210 (h0 : functor.add_const (topological_space (ordered_comm_ring pos)) (has_neg Type)) : @sequential_space.{0} (ordered_comm_ring.{0} pos) (@functor.add_const.run.{0 1} (topological_space.{0} (ordered_comm_ring.{0} pos)) (has_neg.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_67211 (h0 : string_imp -> function.extfun (Type -> Type) (function.extfun Type)) (h1 : unit) (h2 : string_imp) : @irreducible_space.{0} (distrib_lattice.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) (@matrix.row.{1 0} string_imp (function.extfun.{2 2} (Type → Type) (function.extfun.{2 1} Type)) h0 h1 h2) topological_space.{0}) (distrib_lattice.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_67212 (h0 : functor.comp topological_space has_add Type) : @discrete_topology.{1} (has_add.{1} Type) (@functor.comp.run.{1 1 1} topological_space.{1} has_add.{1} Type h0)  := sorry --non-trivial
lemma new_lemma_67213 (h0 : has_mem.mem (random_gen congr_arg_kind) has_emptyc.emptyc) : @irreducible_space.{0} (random_gen.{0} congr_arg_kind) (@finset.pi.empty.{1 0} Type topological_space.{0} (random_gen.{0} congr_arg_kind) h0)  := sorry --non-trivial
lemma new_lemma_67214 (h0 : topological_space (simple_graph (has_pos_part linarith.comp))) : preirreducible_space (simple_graph (has_pos_part linarith.comp)) := sorry --non-trivial
lemma new_lemma_67215 (h0 : function.extfun Type topological_space) : @t1_space.{0} (has_Inf.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_Inf.{0} name))  := sorry --non-trivial
lemma new_lemma_67216 (h0 : list (measurable_space.dynkin_system empty)) : palindrome h0 := sorry --non-trivial
lemma new_lemma_67217 (h0 : ring (comm_ring fun_info)) : is_domain (comm_ring fun_info) := sorry --non-trivial
lemma new_lemma_67218 (h0 : function.extfun Type topological_space) : @totally_separated_space.{0} (linear_ordered_cancel_comm_monoid.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (linear_ordered_cancel_comm_monoid.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_67219 (h0 : functor.add_const (group (ordered_comm_monoid name)) real) : @is_cyclic.{0} (ordered_comm_monoid.{0} name) (@functor.add_const.run.{0 0} (group.{0} (ordered_comm_monoid.{0} name)) real h0)  := sorry --non-trivial
lemma new_lemma_67220 (h0 : group (has_nnnorm (has_nnnorm reducibility_hints))) : is_cyclic (has_nnnorm (has_nnnorm reducibility_hints)) := sorry --non-trivial
lemma new_lemma_67221 (h1 : function.extfun Type topological_space) : @totally_separated_space.{0} to_additive.value_type (@function.extfun_app.{2 1} Type topological_space.{0} h1 to_additive.value_type)  := sorry --non-trivial
lemma new_lemma_67222 (h0 : topological_space (mul_zero_class (finset ennreal))) : sequential_space (mul_zero_class (finset ennreal)) := sorry --non-trivial
lemma new_lemma_67223 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @locally_compact_space.{0} (denumerable.{0} fun_info) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (denumerable.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_67224 (h0 : group (with_one fun_info)) : group.fg (with_one fun_info) := sorry --non-trivial
lemma new_lemma_67225 (h0 : ordered_add_comm_monoid (add_comm_monoid real)) : archimedean (add_comm_monoid real) := sorry --non-trivial
lemma new_lemma_67226 (h0 : functor.add_const (topological_space (comm_group ordering)) Type) : @path_connected_space.{0} (comm_group.{0} ordering) (@functor.add_const.run.{0 1} (topological_space.{0} (comm_group.{0} ordering)) Type h0)  := sorry --non-trivial
lemma new_lemma_67227 (h0 : group (ordered_comm_ring name)) : normalizer_condition (ordered_comm_ring name) := sorry --non-trivial
lemma new_lemma_67228 (h0 : not (group (measurable_space linarith.comp) -> false)) : @group.fg.{0} (measurable_space.{0} linarith.comp) (@classical.by_contradiction'.{1} (group.{0} (measurable_space.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_67229 (h0 : topological_space (add_comm_monoid unsigned)) : t1_space (add_comm_monoid unsigned) := sorry --non-trivial
lemma new_lemma_67230 (h0 : topological_space (id (semiring (semiring congr_arg_kind)))) : irreducible_space (id (semiring (semiring congr_arg_kind))) := sorry --non-trivial
lemma new_lemma_67231 (h2 : function.extfun Type complete_lattice) : @is_compactly_generated.{0} (complete_semilattice_Sup.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type complete_lattice.{0} h2 (complete_semilattice_Sup.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_67232 (h1 : ring (add_comm_semigroup std_gen)) : strong_rank_condition (add_comm_semigroup std_gen) := sorry --non-trivial
lemma new_lemma_67233 (h0 : topological_space (ordered_comm_group (option (option empty)))) : locally_compact_space (ordered_comm_group (option (option empty))) := sorry --non-trivial
lemma new_lemma_67234 (h0 : topological_space (has_dist congr_arg_kind)) : preconnected_space (has_dist congr_arg_kind) := sorry --non-trivial
lemma new_lemma_67235 (h0 : topological_space (ordered_comm_monoid (has_add (has_add (has_Inf linarith.comp))))) : t1_space (ordered_comm_monoid (has_add (has_add (has_Inf linarith.comp)))) := sorry --non-trivial
lemma new_lemma_67236 (h0 : function.extfun (Type 1) ring) : @strong_rank_condition.{1} (normed_comm_ring.{1} Type) (@function.extfun_app.{3 2} (Type 1) ring.{1} h0 (normed_comm_ring.{1} Type))  := sorry --non-trivial
lemma new_lemma_67237 (h0 : semiring (has_sub (semiring (semiring (semiring (semiring (semiring unsigned))))))) : is_noetherian_ring (has_sub (semiring (semiring (semiring (semiring (semiring unsigned)))))) := sorry --non-trivial
lemma new_lemma_67238 (h0 : function.extfun Type ordered_comm_monoid) : @has_exists_mul_of_le.{0} (monoid.{0} unsigned) (@function.extfun_app.{2 1} Type ordered_comm_monoid.{0} h0 (monoid.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_67239 (h0 : topological_space (sub_neg_monoid (finset (has_add (finset (finset name)))))) : normal_space (sub_neg_monoid (finset (has_add (finset (finset name))))) := sorry --non-trivial
lemma new_lemma_67240 (h0 : group (complete_distrib_lattice ennreal)) : normalizer_condition (complete_distrib_lattice ennreal) := sorry --non-trivial
lemma new_lemma_67241 (h0 : topological_space (ordered_comm_ring (ring (ring (finset (has_neg (has_Inf Type))))))) : totally_separated_space (ordered_comm_ring (ring (ring (finset (has_neg (has_Inf Type)))))) := sorry --non-trivial
lemma new_lemma_67242 (h0 : list (monoid (option (option unsigned)))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_67243 (h0 : ordered_add_comm_monoid (add_comm_monoid (has_to_string (has_neg_part name)))) : archimedean (add_comm_monoid (has_to_string (has_neg_part name))) := sorry --non-trivial
lemma new_lemma_67244 (h0 : functor.add_const (group (has_add environment.implicit_infer_kind)) linarith.comp) : @normalizer_condition.{0} (has_add.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (group.{0} (has_add.{0} environment.implicit_infer_kind)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_67245 (h1 : complete_lattice (complete_semilattice_Sup string_imp)) : is_compactly_generated (complete_semilattice_Sup string_imp) := sorry --non-trivial
lemma new_lemma_67246 (h0 : topological_space (has_add (has_Inf (has_Inf Type)))) : loc_path_connected_space (has_add (has_Inf (has_Inf Type))) := sorry --non-trivial
lemma new_lemma_67247 (h0 : has_bot real -> has_Inf real -> has_Inf real) : left_commutative h0 := sorry --non-trivial
lemma new_lemma_67248 (h0 : functor.add_const (ring (normed_lattice_add_comm_group name)) pos) : @strong_rank_condition.{0} (normed_lattice_add_comm_group.{0} name) (@functor.add_const.run.{0 0} (ring.{0} (normed_lattice_add_comm_group.{0} name)) pos h0)  := sorry --non-trivial
lemma new_lemma_67249 (h0 : group (has_top (random_gen (semiring linarith.comp_source)))) : is_cyclic (has_top (random_gen (semiring linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_67250 (h0 : function.extfun Type (functor.add_const (ring (free_add_monoid congr_arg_kind)))) : @is_domain.{0} (free_add_monoid.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (ring.{0} (free_add_monoid.{0} congr_arg_kind)) unsigned (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (ring.{0} (free_add_monoid.{0} congr_arg_kind))) h0 unsigned))  := sorry --non-trivial
lemma new_lemma_67251 (h0 : ordered_add_comm_monoid (omega_complete_partial_order num)) : archimedean (omega_complete_partial_order num) := sorry --non-trivial
lemma new_lemma_67252 (h1 : topological_space (random_gen (comm_ring string_imp))) : t0_space (random_gen (comm_ring string_imp)) := sorry --non-trivial
lemma new_lemma_67253 (h0 : fin has_zero.zero) : @discrete_topology.{0} (boolean_algebra.{0} real) (@matrix.vec_empty.{0} (topological_space.{0} (boolean_algebra.{0} real)) h0)  := sorry --non-trivial
lemma new_lemma_67254 (h0 : function.extfun Type group) : @is_cyclic.{0} (has_inv.{0} fun_info) (@function.extfun_app.{2 1} Type group.{0} h0 (has_inv.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_67255 (h0 : filter (has_inter ennreal)) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_67256 (h0 : not (topological_space (normed_group to_additive.value_type) -> false)) : @totally_disconnected_space.{0} (normed_group.{0} to_additive.value_type) (@classical.by_contradiction'.{1} (topological_space.{0} (normed_group.{0} to_additive.value_type)) h0)  := sorry --non-trivial
lemma new_lemma_67257 (h0 : function.extfun Type uniform_space) : @complete_space.{0} (random_gen.{0} empty) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (random_gen.{0} empty))  := sorry --non-trivial
lemma new_lemma_67258 (h0 : not (function.extfun Type uniform_space -> false)) : @separated_space.{0} linarith.comp_source (@function.extfun_app.{2 1} Type uniform_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type uniform_space.{0}) h0) linarith.comp_source)  := sorry --non-trivial
lemma new_lemma_67259 (h0 : topological_space (canonically_linear_ordered_monoid (ordered_comm_monoid Type))) : totally_separated_space (canonically_linear_ordered_monoid (ordered_comm_monoid Type)) := sorry --non-trivial
lemma new_lemma_67260 (h0 : uniform_space (with_bot congr_arg_kind)) : separated_space (with_bot congr_arg_kind) := sorry --non-trivial
lemma new_lemma_67261 (h1 : add_group (distrib (random_gen (random_gen char)))) : is_add_cyclic (distrib (random_gen (random_gen char))) := sorry --non-trivial
lemma new_lemma_67262 (h0 : function.extfun Type topological_space) : @irreducible_space.{0} (canonically_linear_ordered_monoid.{0} (option.{0} ennreal)) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (canonically_linear_ordered_monoid.{0} (option.{0} ennreal)))  := sorry --non-trivial
lemma new_lemma_67263 (h0 : topological_space (non_unital_non_assoc_semiring std_gen)) : totally_disconnected_space (non_unital_non_assoc_semiring std_gen) := sorry --non-trivial
lemma new_lemma_67264 (h0 : filter (metric_space (has_top congr_arg_kind))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_67265 (h0 : functor.add_const (function.extfun Type topological_space) Type) : @sequential_space.{0} (has_pos_part.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type topological_space.{0}) Type h0) (has_pos_part.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_67266 (h12 : not (uniform_space (denumerable char) -> false)) : @complete_space.{0} (denumerable.{0} char) (@classical.by_contradiction'.{1} (uniform_space.{0} (denumerable.{0} char)) h12)  := sorry --non-trivial
lemma new_lemma_67267 (h0 : function.extfun Type group) : @normalizer_condition.{0} (complete_semilattice_Sup.{0} linarith.comp) (@function.extfun_app.{2 1} Type group.{0} h0 (complete_semilattice_Sup.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_67268 (h0 : topological_space (encodable (has_nnnorm linarith.comp_source))) : totally_disconnected_space (encodable (has_nnnorm linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_67269 (h0 : uniform_space (has_neg (has_add (boolean_algebra.core pos)))) : separated_space (has_neg (has_add (boolean_algebra.core pos))) := sorry --non-trivial
lemma new_lemma_67270 (h0 : functor.add_const (topological_space (comm_group pos)) name) : @sequential_space.{0} (comm_group.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (comm_group.{0} pos)) name h0)  := sorry --non-trivial
lemma new_lemma_67271 (h2 : add_group (has_emptyc num)) : is_add_cyclic (has_emptyc num) := sorry --non-trivial
lemma new_lemma_67272 (h0 : topological_space (dlist (random_gen (random_gen linarith.ineq)))) : irreducible_space (dlist (random_gen (random_gen linarith.ineq))) := sorry --non-trivial
lemma new_lemma_67273 (h1 : topological_space (measurable_space (ordered_comm_semiring string_imp))) : totally_separated_space (measurable_space (ordered_comm_semiring string_imp)) := sorry --non-trivial
lemma new_lemma_67274 (h0 : uniform_space (finset (option pos))) : separated_space (finset (option pos)) := sorry --non-trivial
lemma new_lemma_67275 (h0 : topological_space (boolean_algebra (semigroup unsigned))) : t0_space (boolean_algebra (semigroup unsigned)) := sorry --non-trivial
lemma new_lemma_67276 (h0 : group (canonically_ordered_comm_semiring (option ennreal))) : group.fg (canonically_ordered_comm_semiring (option ennreal)) := sorry --non-trivial
lemma new_lemma_67277 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @rank_condition.{0} (add_cancel_monoid.{0} linarith.comp) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (add_cancel_monoid.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_67278 (h0 : set (semi_normed_comm_ring char)) : set.subsingleton h0 := sorry --non-trivial
lemma new_lemma_67279 (h0 : topological_space (semigroup (has_add environment.implicit_infer_kind))) : t0_space (semigroup (has_add environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_67280 (h0 : function.extfun Type topological_space) : @locally_compact_space.{0} (linear_ordered_comm_monoid_with_zero.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (linear_ordered_comm_monoid_with_zero.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_67281 (h0 : add_group (complete_semilattice_Sup (random_gen (random_gen fun_info)))) : is_add_cyclic (complete_semilattice_Sup (random_gen (random_gen fun_info))) := sorry --non-trivial
lemma new_lemma_67282 (h0 : function.extfun Type topological_space) : @loc_path_connected_space.{0} (has_dist.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_dist.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_67283 (h0 : group (generalized_boolean_algebra (has_pos_part Type))) : is_simple_group (generalized_boolean_algebra (has_pos_part Type)) := sorry --non-trivial
lemma new_lemma_67284 (h0 : group (add_comm_monoid (comm_group linarith.comp))) : group.fg (add_comm_monoid (comm_group linarith.comp)) := sorry --non-trivial
lemma new_lemma_67285 (h0 : not (topological_space (measurable_space.dynkin_system num) -> false)) : @irreducible_space.{0} (measurable_space.dynkin_system.{0} num) (@classical.by_contradiction'.{1} (topological_space.{0} (measurable_space.dynkin_system.{0} num)) h0)  := sorry --non-trivial
lemma new_lemma_67286 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @t0_space.{0} (has_one.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_one.{0} empty))  := sorry --non-trivial
lemma new_lemma_67287 (h0 : topological_space (canonically_linear_ordered_monoid unsigned)) : discrete_topology (canonically_linear_ordered_monoid unsigned) := sorry --non-trivial
lemma new_lemma_67288 (h0 : add_group (add_cancel_comm_monoid linarith.comp_source)) : is_add_cyclic (add_cancel_comm_monoid linarith.comp_source) := sorry --non-trivial
lemma new_lemma_67289 (h0 : functor.add_const (function.extfun (Type 1) ring) environment.implicit_infer_kind) : @is_domain.{1} (finset.{1} Type) (@function.extfun_app.{3 2} (Type 1) ring.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) ring.{1}) environment.implicit_infer_kind h0) (finset.{1} Type))  := sorry --non-trivial
lemma new_lemma_67290 (h0 : filter (semigroup (has_add (has_add (has_neg (has_add linarith.comp)))))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_67291 (h0 : functor.add_const (add_group (complete_distrib_lattice Type)) Type) : @is_add_cyclic.{1} (complete_distrib_lattice.{1} Type) (@functor.add_const.run.{1 1} (add_group.{1} (complete_distrib_lattice.{1} Type)) Type h0)  := sorry --non-trivial
lemma new_lemma_67292 (h0 : functor.add_const (function.extfun Type list) linarith.comp) : list.nodup (function.extfun_app (functor.add_const.run h0) (has_nndist name)) := sorry --non-trivial
lemma new_lemma_67293 (h0 : functor.add_const (function.extfun Type ordered_comm_monoid) name) : @has_exists_mul_of_le.{0} (has_add.{0} name) (@function.extfun_app.{2 1} Type ordered_comm_monoid.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type ordered_comm_monoid.{0}) name h0) (has_add.{0} name))  := sorry --non-trivial
lemma new_lemma_67294 (h0 : function.extfun Type topological_space) : @loc_path_connected_space.{0} (has_neg.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_neg.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_67295 (h0 : pnat) (h1 : thunk (fin has_zero.zero)) : pnat.coprime h0 (@matrix.vec_empty.{0} pnat (@trace_call_stack.{0} (fin (@has_zero.zero.{0} nat nat.has_zero)) h1))  := sorry --non-trivial
lemma new_lemma_67296 (h0 : functor.comp topological_space boolean_algebra environment.implicit_infer_kind) : @irreducible_space.{0} (boolean_algebra.{0} environment.implicit_infer_kind) (@functor.comp.run.{0 0 0} topological_space.{0} boolean_algebra.{0} environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_67297 (h0 : functor.add_const Prop (canonically_ordered_comm_semiring linarith.comp)) : functor.add_const.run h0 := sorry --non-trivial
lemma new_lemma_67298 (h0 : topological_space (as_linear_order (option num))) : normal_space (as_linear_order (option num)) := sorry --non-trivial
lemma new_lemma_67299 (h0 : functor.add_const (function.extfun (Type 1) topological_space) Type) : @t1_space.{1} (has_to_string.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@functor.add_const.run.{2 1} (function.extfun.{3 2} (Type 1) topological_space.{1}) Type h0) (has_to_string.{1} Type))  := sorry --non-trivial
lemma new_lemma_67300 (h0 : cancel_comm_monoid_with_zero (pseudo_metric_space (option pos))) : unique_factorization_monoid (pseudo_metric_space (option pos)) := sorry --non-trivial
lemma new_lemma_67301 (h0 : function.extfun (finset Type) (has_mem.mem (has_emptyc linarith.ineq))) : @complete_lattice.is_Sup_finite_compact.{0} (has_emptyc.{0} linarith.ineq) (@finset.pi.empty.{1 0} Type complete_lattice.{0} (has_emptyc.{0} linarith.ineq) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (has_emptyc.{0} linarith.ineq)) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_67302 (h0 : group (sub_neg_monoid (has_Inf Type))) : is_cyclic (sub_neg_monoid (has_Inf Type)) := sorry --non-trivial
lemma new_lemma_67303 (h0 : functor.add_const (uniform_space (generalized_boolean_algebra name)) pos) : @complete_space.{0} (generalized_boolean_algebra.{0} name) (@functor.add_const.run.{0 0} (uniform_space.{0} (generalized_boolean_algebra.{0} name)) pos h0)  := sorry --non-trivial
lemma new_lemma_67304 (h0 : group (has_star (semiring (semiring num)))) : normalizer_condition (has_star (semiring (semiring num))) := sorry --non-trivial
lemma new_lemma_67305 (h0 : has_mem.mem (metric_space linarith.comp) has_emptyc.emptyc) : @totally_disconnected_space.{0} (metric_space.{0} linarith.comp) (@finset.pi.empty.{1 0} Type topological_space.{0} (metric_space.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_67306 (h0 : topological_space (boolean_algebra (has_Inf pos))) : totally_disconnected_space (boolean_algebra (has_Inf pos)) := sorry --non-trivial
lemma new_lemma_67307 (h0 : function.extfun Type filter) : filter.ne_bot (function.extfun_app h0 (semiring num)) := sorry --non-trivial
lemma new_lemma_67308 (h0 : functor.add_const (ring (comm_group unsigned)) name) : @is_domain.{0} (comm_group.{0} unsigned) (@functor.add_const.run.{0 0} (ring.{0} (comm_group.{0} unsigned)) name h0)  := sorry --non-trivial
lemma new_lemma_67309 (h0 : functor.add_const (ordered_add_comm_monoid (canonically_ordered_comm_semiring ennreal)) name) : @archimedean.{0} (canonically_ordered_comm_semiring.{0} ennreal) (@functor.add_const.run.{0 0} (ordered_add_comm_monoid.{0} (canonically_ordered_comm_semiring.{0} ennreal)) name h0)  := sorry --non-trivial
lemma new_lemma_67310 (h0 : functor.add_const (topological_space (has_to_string Type)) (ring Type)) : @t1_space.{1} (has_to_string.{1} Type) (@functor.add_const.run.{1 1} (topological_space.{1} (has_to_string.{1} Type)) (ring.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_67311 (h0 : not (topological_space (topological_space (has_append linarith.comp_source)) -> false)) : @t0_space.{0} (topological_space.{0} (has_append.{0} linarith.comp_source)) (@classical.by_contradiction'.{1} (topological_space.{0} (topological_space.{0} (has_append.{0} linarith.comp_source))) h0)  := sorry --non-trivial
lemma new_lemma_67312 (h0 : topological_space (option pos)) : locally_compact_space (option pos) := sorry --non-trivial
lemma new_lemma_67313 (h0 : topological_space (finset (has_Inf (has_to_string pos)))) : topological_space.separable_space (finset (has_Inf (has_to_string pos))) := sorry --non-trivial
lemma new_lemma_67314 (h0 : functor.add_const (functor.comp ring add_comm_monoid name) name) : @is_principal_ideal_ring.{0} (add_comm_monoid.{0} name) (@functor.comp.run.{0 0 0} ring.{0} add_comm_monoid.{0} name (@functor.comp.run.{0 0 0} ring.{0} add_comm_monoid.{0} name (@functor.comp.run.{0 0 0} ring.{0} add_comm_monoid.{0} name (@functor.comp.run.{0 0 0} ring.{0} add_comm_monoid.{0} name (@functor.comp.run.{0 0 0} ring.{0} add_comm_monoid.{0} name (@functor.comp.run.{0 0 0} ring.{0} add_comm_monoid.{0} name (@functor.comp.run.{0 0 0} ring.{0} add_comm_monoid.{0} name (@functor.add_const.run.{0 0} (functor.comp.{0 0 0} ring.{0} add_comm_monoid.{0} name) name h0))))))))  := sorry --non-trivial
lemma new_lemma_67315 (h0 : topological_space (finset (has_Inf (has_neg linarith.comp)))) : irreducible_space (finset (has_Inf (has_neg linarith.comp))) := sorry --non-trivial
lemma new_lemma_67316 (h0 : functor.add_const (list (linear_ordered_comm_monoid_with_zero unsigned)) unsigned) : palindrome (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_67317 (h0 : not (function.extfun Type ring -> false)) : @is_domain.{0} (semiring.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type ring.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type ring.{0}) h0) (semiring.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_67318 (h0 : complete_lattice (has_norm (random_gen fun_info))) : complete_lattice.is_Sup_finite_compact (has_norm (random_gen fun_info)) := sorry --non-trivial
lemma new_lemma_67319 (h0 : topological_space (semiring (has_emptyc to_additive.value_type))) : path_connected_space (semiring (has_emptyc to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_67320 (h0 : fin has_zero.zero) : @discrete_topology.{0} (has_bot.{0} real) (@matrix.vec_empty.{0} (topological_space.{0} (has_bot.{0} real)) h0)  := sorry --non-trivial
lemma new_lemma_67321 (h0 : add_monoid (add_comm_monoid (has_to_string linarith.comp))) : add_monoid.fg (add_comm_monoid (has_to_string linarith.comp)) := sorry --non-trivial
lemma new_lemma_67322 (h0 : complete_lattice (normed_comm_ring (has_neg_part name))) : is_atomistic (normed_comm_ring (has_neg_part name)) := sorry --non-trivial
lemma new_lemma_67323 (h0 : functor.add_const (topological_space (finset Type)) unsigned) : @preirreducible_space.{1} (finset.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (finset.{1} Type)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_67324 (h0 : not (topological_space (div_inv_monoid fun_info) -> false)) : @t0_space.{0} (div_inv_monoid.{0} fun_info) (@classical.by_contradiction'.{1} (topological_space.{0} (div_inv_monoid.{0} fun_info)) h0)  := sorry --non-trivial
lemma new_lemma_67325 (h0 : topological_space (complete_linear_order (semiring (has_top (semiring empty))))) : totally_disconnected_space (complete_linear_order (semiring (has_top (semiring empty)))) := sorry --non-trivial
lemma new_lemma_67326 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @t0_space.{0} (measurable_space.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (measurable_space.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_67327 (h0 : semiring (ordered_comm_monoid (ring (boolean_algebra.core Type)))) : is_noetherian_ring (ordered_comm_monoid (ring (boolean_algebra.core Type))) := sorry --non-trivial
lemma new_lemma_67328 (h0 : complete_lattice (has_top linarith.comp_source)) (h1 : function.extfun (Type -> Type) (function.extfun Type)) : is_atomistic (has_top linarith.comp_source) := sorry --non-trivial
lemma new_lemma_67329 (h0 : complete_lattice (has_inv (random_gen (random_gen string_imp)))) : is_compactly_generated (has_inv (random_gen (random_gen string_imp))) := sorry --non-trivial
lemma new_lemma_67330 (h0 : add_monoid (has_to_string (has_to_string environment.implicit_infer_kind))) : add_monoid.fg (has_to_string (has_to_string environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_67331 (h0 : functor.add_const (ring (semiring unsigned)) unsigned) : @strong_rank_condition.{0} (semiring.{0} unsigned) (@functor.add_const.run.{0 0} (ring.{0} (semiring.{0} unsigned)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_67332 (h0 : functor.add_const (ring (has_neg linarith.comp)) environment.implicit_infer_kind) : @rank_condition.{0} (has_neg.{0} linarith.comp) (@functor.add_const.run.{0 0} (ring.{0} (has_neg.{0} linarith.comp)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_67333 (h0 : functor.add_const (topological_space (canonically_ordered_monoid linarith.comp)) linarith.comp) : @preconnected_space.{0} (canonically_ordered_monoid.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (canonically_ordered_monoid.{0} linarith.comp)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_67334 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @t1_space.{0} (semigroup.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (semigroup.{0} pos))  := sorry --non-trivial
lemma new_lemma_67335 (h0 : cancel_comm_monoid_with_zero (boolean_algebra (comm_semigroup (comm_semigroup real)))) : unique_factorization_monoid (boolean_algebra (comm_semigroup (comm_semigroup real))) := sorry --non-trivial
lemma new_lemma_67336 (h1 : semiring (nondiscrete_normed_field (add_comm_semigroup enat))) (h2 : ideal (nondiscrete_normed_field (add_comm_semigroup enat))) : ideal.is_prime h2 := sorry --non-trivial
lemma new_lemma_67337 (h0 : functor.add_const (complete_lattice (has_pos_part linarith.comp)) pos) : @complete_lattice.is_Sup_finite_compact.{0} (has_pos_part.{0} linarith.comp) (@functor.add_const.run.{0 0} (complete_lattice.{0} (has_pos_part.{0} linarith.comp)) pos h0)  := sorry --non-trivial
lemma new_lemma_67338 (h0 : has_add Type -> real -> Prop) : relator.bi_total h0 := sorry --non-trivial
lemma new_lemma_67339 (h0 : functor.add_const (topological_space (generalized_boolean_algebra pos)) (ordered_ring name)) : @locally_compact_space.{0} (generalized_boolean_algebra.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (generalized_boolean_algebra.{0} pos)) (ordered_ring.{0} name) h0)  := sorry --non-trivial
lemma new_lemma_67340 (h0 : functor.add_const (topological_space (preorder congr_arg_kind)) num) : @discrete_topology.{0} (preorder.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (preorder.{0} congr_arg_kind)) num h0)  := sorry --non-trivial
lemma new_lemma_67341 (h0 : functor.add_const (topological_space (pseudo_metric_space pos)) name) : @preirreducible_space.{0} (pseudo_metric_space.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (pseudo_metric_space.{0} pos)) name h0)  := sorry --non-trivial
lemma new_lemma_67342 (h0 : function.extfun (finset (Type -> Type)) (has_mem.mem topological_space)) : @totally_disconnected_space.{0} (linear_ordered_semiring.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) topological_space.{0} (@function.extfun_app.{2 0} (finset.{1} (Type → Type)) (@has_mem.mem.{1 1} (Type → Type) (finset.{1} (Type → Type)) (@finset.has_mem.{1} (Type → Type)) topological_space.{0}) h0 (@has_emptyc.emptyc.{1} (finset.{1} (Type → Type)) (@finset.has_emptyc.{1} (Type → Type))))) (linear_ordered_semiring.{0} empty))  := sorry --non-trivial
lemma new_lemma_67343 (h0 : uniform_space (normed_comm_ring (has_add Type))) : separated_space (normed_comm_ring (has_add Type)) := sorry --non-trivial
lemma new_lemma_67344 (h0 : ring (has_Sup unsigned)) : is_principal_ideal_ring (has_Sup unsigned) := sorry --non-trivial
lemma new_lemma_67345 (h0 : has_mem.mem (function.extfun Type) has_emptyc.emptyc) : @complete_lattice.is_Sup_finite_compact.{0} (has_norm.{0} num) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) (@finset.pi.empty.{2 1} ((Type → Type) → Type 1) (function.extfun.{2 2} (Type → Type)) (function.extfun.{2 1} Type) h0) complete_lattice.{0}) (has_norm.{0} num))  := sorry --non-trivial
lemma new_lemma_67346 (h0 : topological_space (boolean_algebra (has_Inf linarith.comp))) : discrete_topology (boolean_algebra (has_Inf linarith.comp)) := sorry --non-trivial
lemma new_lemma_67347 (h0 : topological_space (with_bot to_additive.value_type)) : locally_compact_space (with_bot to_additive.value_type) := sorry --non-trivial
lemma new_lemma_67348 (h0 : function.extfun Type topological_space) : @loc_path_connected_space.{0} pos (@function.extfun_app.{2 1} Type topological_space.{0} h0 pos)  := sorry --non-trivial
lemma new_lemma_67349 (h0 : topological_space (measurable_space (semiring congr_arg_kind))) : locally_compact_space (measurable_space (semiring congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_67350 (h0 : topological_space (has_one congr_arg_kind)) : path_connected_space (has_one congr_arg_kind) := sorry --non-trivial
lemma new_lemma_67351 (h1 : add_group (linear_ordered_add_comm_group linarith.ineq)) : is_add_cyclic (linear_ordered_add_comm_group linarith.ineq) := sorry --non-trivial
lemma new_lemma_67352 (h0 : functor.add_const (topological_space (cancel_monoid linarith.comp)) linarith.comp) : @discrete_topology.{0} (cancel_monoid.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (cancel_monoid.{0} linarith.comp)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_67353 (h0 : filter (linear_ordered_field (option name))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_67354 (h0 : functor.add_const (ordered_add_comm_monoid (generalized_boolean_algebra name)) Type) : @archimedean.{0} (generalized_boolean_algebra.{0} name) (@functor.add_const.run.{0 1} (ordered_add_comm_monoid.{0} (generalized_boolean_algebra.{0} name)) Type h0)  := sorry --non-trivial
lemma new_lemma_67355 (h0 : functor.add_const (semiring (complete_distrib_lattice real)) (has_Inf real)) : @is_noetherian_ring.{0} (complete_distrib_lattice.{0} real) (@functor.add_const.run.{0 0} (semiring.{0} (complete_distrib_lattice.{0} real)) (has_Inf.{0} real) h0)  := sorry --non-trivial
lemma new_lemma_67356 (h0 : functor.add_const (topological_space (boolean_algebra linarith.comp)) Type) : @t1_space.{0} (boolean_algebra.{0} linarith.comp) (@functor.add_const.run.{0 1} (topological_space.{0} (boolean_algebra.{0} linarith.comp)) Type h0)  := sorry --non-trivial
lemma new_lemma_67357 (h0 : not (topological_space (option congr_arg_kind) -> false)) : @t1_space.{0} (option.{0} congr_arg_kind) (@classical.by_contradiction'.{1} (topological_space.{0} (option.{0} congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_67358 (h1 : set (std_gen -> metric_space (mul_one_class enat))) : set.separates_points h1 := sorry --non-trivial
lemma new_lemma_67359 (h0 : functor.add_const (ring (normed_comm_ring unsigned)) Type) : @strong_rank_condition.{0} (normed_comm_ring.{0} unsigned) (@functor.add_const.run.{0 1} (ring.{0} (normed_comm_ring.{0} unsigned)) Type h0)  := sorry --non-trivial
lemma new_lemma_67360 (h0 : functor.add_const (add_monoid (has_to_string pos)) (has_neg Type)) : @add_monoid.fg.{0} (has_to_string.{0} pos) (@functor.add_const.run.{0 1} (add_monoid.{0} (has_to_string.{0} pos)) (has_neg.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_67361 (h1 : has_neg (mul_one_class linarith.ineq)) (h2 : measurable_space (mul_one_class linarith.ineq)) : has_measurable_neg (mul_one_class linarith.ineq) := sorry --non-trivial
lemma new_lemma_67362 (h0 : group (complete_distrib_lattice (option unsigned))) : is_simple_group (complete_distrib_lattice (option unsigned)) := sorry --non-trivial
lemma new_lemma_67363 (h0 : functor.add_const (function.extfun (Type 1) group) name) : @normalizer_condition.{1} (ordered_comm_ring.{1} Type) (@function.extfun_app.{3 2} (Type 1) group.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) group.{1}) name h0) (ordered_comm_ring.{1} Type))  := sorry --non-trivial
lemma new_lemma_67364 (h0 : functor.add_const (group (ordered_ring empty)) num) : @normalizer_condition.{0} (ordered_ring.{0} empty) (@functor.add_const.run.{0 0} (group.{0} (ordered_ring.{0} empty)) num h0)  := sorry --non-trivial
lemma new_lemma_67365 (h0 : function.extfun Type group) : @normalizer_condition.{0} (random_gen.{0} (has_top.{0} linarith.comp_source)) (@function.extfun_app.{2 1} Type group.{0} h0 (random_gen.{0} (has_top.{0} linarith.comp_source)))  := sorry --non-trivial
lemma new_lemma_67366 (h0 : topological_space (has_div linarith.comp_source)) : totally_disconnected_space (has_div linarith.comp_source) := sorry --non-trivial
lemma new_lemma_67367 (h0 : function.extfun Type (functor.comp topological_space comm_group)) : @topological_space.separable_space.{0} (comm_group.{0} name) (@functor.comp.run.{0 0 0} topological_space.{0} comm_group.{0} name (@function.extfun_app.{2 1} Type (functor.comp.{0 0 0} topological_space.{0} comm_group.{0}) h0 name))  := sorry --non-trivial
lemma new_lemma_67368 (h0 : functor.add_const (topological_space (semigroup linarith.comp)) linarith.comp) : @totally_separated_space.{0} (semigroup.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (semigroup.{0} linarith.comp)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_67369 (h0 : functor.add_const (function.extfun Type uniform_space) (mul_zero_class pos)) : @complete_space.{0} (finset.{0} ennreal) (@function.extfun_app.{2 1} Type uniform_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type uniform_space.{0}) (mul_zero_class.{0} pos) h0) (finset.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_67370 (h0 : functor.add_const (list (has_Inf name)) pos) : list.nodup (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_67371 (h0 : complete_lattice (linear_ordered_comm_ring empty)) : is_compactly_generated (linear_ordered_comm_ring empty) := sorry --non-trivial
lemma new_lemma_67372 (h0 : linear_ordered_comm_group_with_zero string_imp) (h1 : list (linear_ordered_comm_group_with_zero string_imp)) : list.mem h0 h1 := sorry --non-trivial
lemma new_lemma_67373 (h0 : function.extfun Type filter) : filter.ne_bot (function.extfun_app h0 (has_dist num)) := sorry --non-trivial
lemma new_lemma_67374 (h0 : topological_space (semigroup (comm_group (comm_group Type)))) : preconnected_space (semigroup (comm_group (comm_group Type))) := sorry --non-trivial
lemma new_lemma_67375 (h0 : topological_space (generalized_boolean_algebra (ring name))) : topological_space.separable_space (generalized_boolean_algebra (ring name)) := sorry --non-trivial
lemma new_lemma_67376 (h0 : add_monoid (complete_distrib_lattice (option (option empty)))) : add_monoid.fg (complete_distrib_lattice (option (option empty))) := sorry --non-trivial
lemma new_lemma_67377 (h0 : uniform_space (has_to_string ennreal)) : separated_space (has_to_string ennreal) := sorry --non-trivial
lemma new_lemma_67378 (h0 : monoid (ordered_comm_ring (has_Inf (has_neg (has_Inf Type))))) : monoid.fg (ordered_comm_ring (has_Inf (has_neg (has_Inf Type)))) := sorry --non-trivial
lemma new_lemma_67379 (h0 : uniform_space (metric_space (semiring empty))) : complete_space (metric_space (semiring empty)) := sorry --non-trivial
lemma new_lemma_67380 (h0 : functor.add_const (topological_space (add_comm_monoid pos)) environment.implicit_infer_kind) : @irreducible_space.{0} (add_comm_monoid.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (add_comm_monoid.{0} pos)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_67381 (h0 : functor.add_const (function.extfun Type complete_lattice) (has_neg linarith.comp)) : @complete_lattice.is_Sup_finite_compact.{0} (add_comm_monoid.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type complete_lattice.{0}) (has_neg.{0} linarith.comp) h0) (add_comm_monoid.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_67382 (h0 : functor.add_const (topological_space (finset pos)) pos) : @discrete_topology.{0} (finset.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (finset.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_67383 (h0 : fun_info -> fun_info -> Prop) (h1 : fun_info) : acc h0 h1 := sorry --non-trivial
lemma new_lemma_67384 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @unique_factorization_monoid.{0} (ordered_comm_group.{0} unsigned) (@function.extfun_app.{2 1} Type cancel_comm_monoid_with_zero.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 cancel_comm_monoid_with_zero.{0}) (ordered_comm_group.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_67385 (h0 : topological_space (has_to_string (has_add (has_add (has_add name))))) : irreducible_space (has_to_string (has_add (has_add (has_add name)))) := sorry --non-trivial
lemma new_lemma_67386 (h1 : ring (has_emptyc num)) : rank_condition (has_emptyc num) := sorry --non-trivial
lemma new_lemma_67387 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @is_compactly_generated.{1} (canonically_ordered_monoid.{1} (has_Inf.{1} Type)) (@function.extfun_app.{3 2} (Type 1) complete_lattice.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 complete_lattice.{1}) (canonically_ordered_monoid.{1} (has_Inf.{1} Type)))  := sorry --non-trivial
lemma new_lemma_67388 (h0 : functor.add_const (uniform_space (has_neg_part environment.implicit_infer_kind)) Type) : @complete_space.{0} (has_neg_part.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 1} (uniform_space.{0} (has_neg_part.{0} environment.implicit_infer_kind)) Type h0)  := sorry --non-trivial
lemma new_lemma_67389 (h0 : complete_lattice (complete_distrib_lattice (has_add name))) : is_atomistic (complete_distrib_lattice (has_add name)) := sorry --non-trivial
lemma new_lemma_67390 (h0 : add_monoid (ordered_ring num)) : add_monoid.fg (ordered_ring num) := sorry --non-trivial
lemma new_lemma_67391 (h0 : uniform_space (add_comm_semigroup fun_info)) : separated_space (add_comm_semigroup fun_info) := sorry --non-trivial
lemma new_lemma_67392 (h0 : set (mul_one_class to_additive.value_type)) (h1 : mul_one_class to_additive.value_type) : set.compl h0 h1 := sorry --non-trivial
lemma new_lemma_67393 (h0 : ring (has_neg_part (has_add (finset pos)))) : strong_rank_condition (has_neg_part (has_add (finset pos))) := sorry --non-trivial
lemma new_lemma_67394 (h0 : topological_space (metric_space (has_top (has_norm congr_arg_kind)))) : preirreducible_space (metric_space (has_top (has_norm congr_arg_kind))) := sorry --non-trivial
lemma new_lemma_67395 (h0 : add_monoid (semigroup (add_comm_monoid environment.implicit_infer_kind))) : add_monoid.fg (semigroup (add_comm_monoid environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_67396 (h0 : ring (linear_ordered_field (option pos))) : is_principal_ideal_ring (linear_ordered_field (option pos)) := sorry --non-trivial
lemma new_lemma_67397 (h0 : ring (ordered_comm_monoid Type)) : strong_rank_condition (ordered_comm_monoid Type) := sorry --non-trivial
lemma new_lemma_67398 (h0 : functor.add_const (ordered_comm_monoid (comm_group environment.implicit_infer_kind)) ennreal) : @has_exists_mul_of_le.{0} (comm_group.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (ordered_comm_monoid.{0} (comm_group.{0} environment.implicit_infer_kind)) ennreal h0)  := sorry --non-trivial
lemma new_lemma_67399 (h0 : group (measure_theory.measure_space (has_top empty))) : normalizer_condition (measure_theory.measure_space (has_top empty)) := sorry --non-trivial
lemma new_lemma_67400 (h0 : functor.add_const (monoid (ordered_comm_monoid pos)) name) : @monoid.fg.{0} (ordered_comm_monoid.{0} pos) (@functor.add_const.run.{0 0} (monoid.{0} (ordered_comm_monoid.{0} pos)) name h0)  := sorry --non-trivial
lemma new_lemma_67401 (h0 : function.extfun Type ordered_add_comm_monoid) : @archimedean.{0} (measurable_space.dynkin_system.{0} unsigned) (@function.extfun_app.{2 1} Type ordered_add_comm_monoid.{0} h0 (measurable_space.dynkin_system.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_67402 (h0 : group (complete_semilattice_Sup (has_ssubset linarith.ineq))) : group.fg (complete_semilattice_Sup (has_ssubset linarith.ineq)) := sorry --non-trivial
lemma new_lemma_67403 (h0 : multiset (topological_space (semiring fun_info))) : @totally_disconnected_space.{0} (semiring.{0} fun_info) (@multiset.inf.{0} (topological_space.{0} (semiring.{0} fun_info)) (@lattice.to_semilattice_inf.{0} (topological_space.{0} (semiring.{0} fun_info)) (@conditionally_complete_lattice.to_lattice.{0} (topological_space.{0} (semiring.{0} fun_info)) (@complete_lattice.to_conditionally_complete_lattice.{0} (topological_space.{0} (semiring.{0} fun_info)) (@topological_space.complete_lattice.{0} (semiring.{0} fun_info))))) (@bounded_order.to_order_top.{0} (topological_space.{0} (semiring.{0} fun_info)) (@preorder.to_has_le.{0} (topological_space.{0} (semiring.{0} fun_info)) (@partial_order.to_preorder.{0} (topological_space.{0} (semiring.{0} fun_info)) (@semilattice_inf.to_partial_order.{0} (topological_space.{0} (semiring.{0} fun_info)) (@lattice.to_semilattice_inf.{0} (topological_space.{0} (semiring.{0} fun_info)) (@conditionally_complete_lattice.to_lattice.{0} (topological_space.{0} (semiring.{0} fun_info)) (@complete_lattice.to_conditionally_complete_lattice.{0} (topological_space.{0} (semiring.{0} fun_info)) (@topological_space.complete_lattice.{0} (semiring.{0} fun_info)))))))) (@complete_lattice.to_bounded_order.{0} (topological_space.{0} (semiring.{0} fun_info)) (@topological_space.complete_lattice.{0} (semiring.{0} fun_info)))) h0)  := sorry --non-trivial
lemma new_lemma_67404 (h0 : complete_lattice (has_add (has_add linarith.comp))) : is_atomistic (has_add (has_add linarith.comp)) := sorry --non-trivial
lemma new_lemma_67405 (h0 : functor.comp group has_nndist Type) : @is_simple_group.{1} (has_nndist.{1} Type) (@functor.comp.run.{1 1 1} group.{1} has_nndist.{1} Type h0)  := sorry --non-trivial
lemma new_lemma_67406 (h0 : complete_lattice (measurable_space (has_norm (has_norm linarith.comp)))) : is_compactly_generated (measurable_space (has_norm (has_norm linarith.comp))) := sorry --non-trivial
lemma new_lemma_67407 (h1 : filter (distrib char)) : filter.ne_bot h1 := sorry --non-trivial
lemma new_lemma_67408 (h0 : not (ring string_imp -> false)) : @strong_rank_condition.{0} string_imp (@classical.by_contradiction'.{1} (ring.{0} string_imp) h0)  := sorry --non-trivial
lemma new_lemma_67409 (h0 : ring (omega_complete_partial_order num)) : is_domain (omega_complete_partial_order num) := sorry --non-trivial
lemma new_lemma_67410 (h0 : topological_space (has_emptyc (has_top (has_top (has_top fun_info))))) : irreducible_space (has_emptyc (has_top (has_top (has_top fun_info)))) := sorry --non-trivial
lemma new_lemma_67411 (h0 : topological_space (has_Inf (has_pos_part linarith.comp))) : irreducible_space (has_Inf (has_pos_part linarith.comp)) := sorry --non-trivial
lemma new_lemma_67412 (h0 : topological_space (has_top (distrib_lattice (has_inv (has_norm to_additive.value_type))))) : path_connected_space (has_top (distrib_lattice (has_inv (has_norm to_additive.value_type)))) := sorry --non-trivial
lemma new_lemma_67413 (h0 : list (linear_ordered_add_comm_group congr_arg_kind)) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_67414 (h0 : functor.add_const (topological_space (has_to_string pos)) (has_to_string linarith.comp)) : @regular_space.{0} (has_to_string.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (has_to_string.{0} pos)) (has_to_string.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_67415 (h0 : has_lt (nondiscrete_normed_field (add_comm_semigroup fun_info))) : no_max_order (nondiscrete_normed_field (add_comm_semigroup fun_info)) := sorry --non-trivial
lemma new_lemma_67416 (h0 : group (has_norm (distrib_lattice char))) : is_cyclic (has_norm (distrib_lattice char)) := sorry --non-trivial
lemma new_lemma_67417 (h0 : functor.add_const (topological_space (free_add_monoid congr_arg_kind)) congr_arg_kind) : @t0_space.{0} (free_add_monoid.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (free_add_monoid.{0} congr_arg_kind)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_67418 (h0 : filter (is_R_or_C unsigned)) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_67419 (h0 : function.extfun Type (functor.comp filter mul_zero_class)) : countable_Inter_filter (functor.comp.run (function.extfun_app h0 name)) := sorry --non-trivial
lemma new_lemma_67420 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_domain.{0} (normed_group.{0} fun_info) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (normed_group.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_67421 (h0 : has_neg (complete_distrib_lattice name)) (h1 : measurable_space (complete_distrib_lattice name)) : has_measurable_neg (complete_distrib_lattice name) := sorry --non-trivial
lemma new_lemma_67422 (h0 : functor.add_const (filter (has_nndist Type)) name) : countable_Inter_filter (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_67423 (h0 : has_mem.mem group has_emptyc.emptyc) : @normalizer_condition.{0} (linear_ordered_semiring.{0} linarith.ineq) (@function.extfun_app.{2 1} Type group.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) group.{0} h0) (linear_ordered_semiring.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_67424 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @locally_compact_space.{0} auto.case_option (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) auto.case_option)  := sorry --non-trivial
lemma new_lemma_67425 (h0 : topological_space (simple_graph pos)) : topological_space.separable_space (simple_graph pos) := sorry --non-trivial
lemma new_lemma_67426 (h0 : functor.add_const (topological_space (non_assoc_semiring num)) empty) : @preirreducible_space.{0} (non_assoc_semiring.{0} num) (@functor.add_const.run.{0 0} (topological_space.{0} (non_assoc_semiring.{0} num)) empty h0)  := sorry --non-trivial
lemma new_lemma_67427 (h0 : topological_space (has_bot (sub_neg_monoid real))) : normal_space (has_bot (sub_neg_monoid real)) := sorry --non-trivial
lemma new_lemma_67428 (h0 : complete_lattice (cancel_monoid (option (option unsigned)))) : complete_lattice.is_Sup_finite_compact (cancel_monoid (option (option unsigned))) := sorry --non-trivial
lemma new_lemma_67429 (h0 : complete_lattice (has_compl string_imp)) : is_compactly_generated (has_compl string_imp) := sorry --non-trivial
lemma new_lemma_67430 (h0 : functor.add_const (semiring (add_comm_monoid pos)) environment.implicit_infer_kind) : @is_noetherian_ring.{0} (add_comm_monoid.{0} pos) (@functor.add_const.run.{0 0} (semiring.{0} (add_comm_monoid.{0} pos)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_67431 (h0 : function.extfun Type group) : @group.fg.{0} linarith.comp_source (@function.extfun_app.{2 1} Type group.{0} h0 linarith.comp_source)  := sorry --non-trivial
lemma new_lemma_67432 (h0 : functor.add_const (topological_space (has_add pos)) (ordered_ring linarith.comp)) : @sequential_space.{0} (has_add.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (has_add.{0} pos)) (ordered_ring.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_67433 (h0 : functor.add_const (list (non_assoc_semiring unsigned)) unsigned) : palindrome (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_67434 (h0 : functor.add_const (topological_space (bin_tree num)) empty) : @t0_space.{0} (bin_tree.{0} num) (@functor.add_const.run.{0 0} (topological_space.{0} (bin_tree.{0} num)) empty h0)  := sorry --non-trivial
lemma new_lemma_67435 (h0 : topological_space (cancel_monoid (boolean_algebra environment.implicit_infer_kind))) : locally_compact_space (cancel_monoid (boolean_algebra environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_67436 (h0 : topological_space (bin_tree (semiring empty))) : t0_space (bin_tree (semiring empty)) := sorry --non-trivial
lemma new_lemma_67437 (h0 : topological_space (id (has_top unsigned))) : t0_space (id (has_top unsigned)) := sorry --non-trivial
lemma new_lemma_67438 (h0 : list (ring (finset pos))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_67439 (h0 : topological_space (normed_field linarith.ineq)) (h1 : has_sub (normed_field linarith.ineq)) : has_continuous_sub (normed_field linarith.ineq) := sorry --non-trivial
lemma new_lemma_67440 (h0 : filter (cancel_monoid (normed_comm_ring (add_comm_monoid Type)))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_67441 (h0 : preorder (add_comm_semigroup char)) (h2 : Prop) : set.is_pwo (id (fun (h1 : add_comm_semigroup char), h2)) := sorry --non-trivial
lemma new_lemma_67442 (h0 : semiring (ordered_comm_ring (finset (finset (finset (finset linarith.comp)))))) : is_noetherian_ring (ordered_comm_ring (finset (finset (finset (finset linarith.comp))))) := sorry --non-trivial
lemma new_lemma_67443 (h0 : fin has_zero.zero) : @separated_space.{0} (canonically_ordered_monoid.{0} real) (@matrix.vec_empty.{0} (uniform_space.{0} (canonically_ordered_monoid.{0} real)) (@matrix.vec_empty.{0} (fin (@has_zero.zero.{0} nat nat.has_zero)) h0))  := sorry --non-trivial
lemma new_lemma_67444 (h0 : ring (simple_graph std_gen) -> ring (simple_graph std_gen)) (h1 : nat) (h2 : ring (simple_graph std_gen)) : rank_condition (simple_graph std_gen) := sorry --non-trivial
lemma new_lemma_67445 (h0 : complete_lattice (cancel_monoid congr_arg_kind)) : complete_lattice.is_Sup_finite_compact (cancel_monoid congr_arg_kind) := sorry --non-trivial
lemma new_lemma_67446 (h0 : function.extfun Type topological_space) : @path_connected_space.{0} (comm_semigroup.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (comm_semigroup.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_67447 (h0 : ring (has_union (has_norm (semiring empty)))) : rank_condition (has_union (has_norm (semiring empty))) := sorry --non-trivial
lemma new_lemma_67448 (h0 : functor.add_const (topological_space (semigroup unsigned)) name) : @loc_path_connected_space.{0} (semigroup.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (semigroup.{0} unsigned)) name h0)  := sorry --non-trivial
lemma new_lemma_67449 (h0 : finset Type -> finset Type -> Prop) : is_extensional (finset Type) h0 := sorry --non-trivial
lemma new_lemma_67450 (h1 : group (normed_field (has_nnnorm (comm_ring string_imp)))) : is_cyclic (normed_field (has_nnnorm (comm_ring string_imp))) := sorry --non-trivial
lemma new_lemma_67451 (h0 : list (has_pos_part (has_Inf (has_neg (finset Type))))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_67452 (h0 : not (topological_space (linear_ordered_add_comm_group linarith.comp_source) -> false)) : @path_connected_space.{0} (linear_ordered_add_comm_group.{0} linarith.comp_source) (@classical.by_contradiction'.{1} (topological_space.{0} (linear_ordered_add_comm_group.{0} linarith.comp_source)) h0)  := sorry --non-trivial
lemma new_lemma_67453 (h0 : ring (linear_ordered_comm_group_with_zero linarith.comp_source)) : strong_rank_condition (linear_ordered_comm_group_with_zero linarith.comp_source) := sorry --non-trivial
lemma new_lemma_67454 (h0 : not (complete_lattice (option unsigned) -> false)) : @is_compactly_generated.{0} (option.{0} unsigned) (@classical.by_contradiction'.{1} (complete_lattice.{0} (option.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_67455 (h1 : semiring char) (h2 : ideal char) : ideal.is_prime h2 := sorry --non-trivial
lemma new_lemma_67456 (h3 : not (topological_space (has_append linarith.comp_source) -> false)) : @path_connected_space.{0} (has_append.{0} linarith.comp_source) (@classical.by_contradiction'.{1} (topological_space.{0} (has_append.{0} linarith.comp_source)) h3)  := sorry --non-trivial
lemma new_lemma_67457 (h0 : function.extfun Type complete_lattice) : @is_compactly_generated.{0} (ordered_comm_ring.{0} name) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (ordered_comm_ring.{0} name))  := sorry --non-trivial
lemma new_lemma_67458 (h0 : add_group (nondiscrete_normed_field (add_comm_semigroup (add_comm_semigroup fun_info)))) : is_add_cyclic (nondiscrete_normed_field (add_comm_semigroup (add_comm_semigroup fun_info))) := sorry --non-trivial
lemma new_lemma_67459 (h0 : functor.add_const (function.extfun Type ring) pos) : @strong_rank_condition.{0} (has_add.{0} name) (@function.extfun_app.{2 1} Type ring.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type ring.{0}) pos h0) (has_add.{0} name))  := sorry --non-trivial
lemma new_lemma_67460 (h0 : functor.add_const (topological_space (semiring empty)) empty) : @loc_path_connected_space.{0} (semiring.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (semiring.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_67461 (h0 : functor.add_const (uniform_space (simple_graph linarith.comp)) name) : @complete_space.{0} (simple_graph.{0} linarith.comp) (@functor.add_const.run.{0 0} (uniform_space.{0} (simple_graph.{0} linarith.comp)) name h0)  := sorry --non-trivial
lemma new_lemma_67462 (h0 : function.extfun Type finset) : finset.nonempty (function.extfun_app h0 (omega_complete_partial_order unsigned)) := sorry --non-trivial
lemma new_lemma_67463 (h0 : filter (canonically_linear_ordered_monoid name)) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_67464 (h1 : complete_lattice (mul_one_class (mul_one_class std_gen))) : complete_lattice.is_Sup_finite_compact (mul_one_class (mul_one_class std_gen)) := sorry --non-trivial
lemma new_lemma_67465 (h1 : list (measurable_space (simple_graph string.iterator_imp))) (h2 : filter (simple_graph string.iterator_imp)) : @filter.is_measurably_generated.{0} (simple_graph.{0} string.iterator_imp) (@list.ilast.{0} (measurable_space.{0} (simple_graph.{0} string.iterator_imp)) (@measurable_space.inhabited.{0} (simple_graph.{0} string.iterator_imp)) h1) h2  := sorry --non-trivial
lemma new_lemma_67466 (h0 : ring (comm_group ennreal)) : rank_condition (comm_group ennreal) := sorry --non-trivial
lemma new_lemma_67467 (h0 : add_group (with_one (random_gen num))) : is_add_cyclic (with_one (random_gen num)) := sorry --non-trivial
lemma new_lemma_67468 (h0 : functor.comp topological_space has_add environment.implicit_infer_kind) : @discrete_topology.{0} (has_add.{0} environment.implicit_infer_kind) (@functor.comp.run.{0 0 0} topological_space.{0} has_add.{0} environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_67469 (h0 : topological_space (ring (has_neg (ring Type)))) : preirreducible_space (ring (has_neg (ring Type))) := sorry --non-trivial
lemma new_lemma_67470 (h0 : measurable_space (has_nnnorm (mul_one_class string.iterator_imp))) (h1 : filter (has_nnnorm (mul_one_class string.iterator_imp))) : filter.is_measurably_generated h1 := sorry --non-trivial
lemma new_lemma_67471 (h0 : topological_space (add_cancel_monoid (finset (has_add linarith.comp)))) : irreducible_space (add_cancel_monoid (finset (has_add linarith.comp))) := sorry --non-trivial
lemma new_lemma_67472 (h0 : topological_space (normed_comm_ring num)) : path_connected_space (normed_comm_ring num) := sorry --non-trivial
lemma new_lemma_67473 (h0 : finset (mul_zero_class unsigned)) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_67474 (h0 : group (comm_group (has_add pos))) : is_cyclic (comm_group (has_add pos)) := sorry --non-trivial
lemma new_lemma_67475 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @t0_space.{0} (has_ssubset.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_ssubset.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_67476 (h0 : topological_space (has_pos_part (finset Type))) : locally_compact_space (has_pos_part (finset Type)) := sorry --non-trivial
lemma new_lemma_67477 (h0 : functor.add_const (topological_space (ordered_comm_monoid pos)) pos) : @loc_path_connected_space.{0} (ordered_comm_monoid.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (ordered_comm_monoid.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_67478 (h0 : not (monoid (with_bot num) -> false)) : @monoid.fg.{0} (with_bot.{0} num) (@classical.by_contradiction'.{1} (monoid.{0} (with_bot.{0} num)) h0)  := sorry --non-trivial
lemma new_lemma_67479 (h1 : set (normed_field reducibility_hints)) : set.finite h1 := sorry --non-trivial
lemma new_lemma_67480 (h0 : function.extfun Type topological_space) : @locally_compact_space.{0} (with_one.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (with_one.{0} num))  := sorry --non-trivial
lemma new_lemma_67481 (h0 : functor.add_const (ring znum) (option empty)) : @is_principal_ideal_ring.{0} znum (@functor.add_const.run.{0 0} (ring.{0} znum) (option.{0} empty) h0)  := sorry --non-trivial
lemma new_lemma_67482 (h0 : functor.add_const (cancel_comm_monoid_with_zero (add_cancel_monoid pos)) (ring (has_neg pos))) : @unique_factorization_monoid.{0} (add_cancel_monoid.{0} pos) (@functor.add_const.run.{0 0} (cancel_comm_monoid_with_zero.{0} (add_cancel_monoid.{0} pos)) (ring.{0} (has_neg.{0} pos)) h0)  := sorry --non-trivial
lemma new_lemma_67483 (h0 : topological_space (partial_order (option unsigned))) : totally_separated_space (partial_order (option unsigned)) := sorry --non-trivial
lemma new_lemma_67484 (h0 : topological_space (add_cancel_comm_monoid empty)) : totally_disconnected_space (add_cancel_comm_monoid empty) := sorry --non-trivial
lemma new_lemma_67485 (h1 : topological_space (topological_space (random_gen (has_ssubset enat)))) : t0_space (topological_space (random_gen (has_ssubset enat))) := sorry --non-trivial
lemma new_lemma_67486 (h0 : topological_space (has_sub congr_arg_kind)) : path_connected_space (has_sub congr_arg_kind) := sorry --non-trivial
lemma new_lemma_67487 (h0 : topological_space (complete_semilattice_Sup string_imp)) : locally_compact_space (complete_semilattice_Sup string_imp) := sorry --non-trivial
lemma new_lemma_67488 (h0 : has_mem.mem (has_top (random_gen linarith.comp_source)) has_emptyc.emptyc) : @complete_lattice.is_Sup_finite_compact.{0} (has_top.{0} (random_gen.{0} linarith.comp_source)) (@finset.pi.empty.{1 0} Type complete_lattice.{0} (has_top.{0} (random_gen.{0} linarith.comp_source)) h0)  := sorry --non-trivial
lemma new_lemma_67489 (h0 : complete_lattice (complete_semilattice_Sup (has_nnnorm string_imp))) : is_compactly_generated (complete_semilattice_Sup (has_nnnorm string_imp)) := sorry --non-trivial
lemma new_lemma_67490 (h0 : not (function.extfun (Type -> Type) (function.extfun Type) -> false)) : @is_noetherian_ring.{0} linarith.comp (@function.extfun_app.{2 1} Type semiring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) (@classical.by_contradiction'.{2} (function.extfun.{2 2} (Type → Type) (function.extfun.{2 1} Type)) h0) semiring.{0}) linarith.comp)  := sorry --non-trivial
lemma new_lemma_67491 (h0 : function.extfun Type group) : @group.fg.{0} (normed_group.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type group.{0} h0 (normed_group.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_67492 (h0 : topological_space (cancel_monoid (option unsigned))) : locally_compact_space (cancel_monoid (option unsigned)) := sorry --non-trivial
lemma new_lemma_67493 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @preirreducible_space.{0} (finset.{0} ennreal) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (finset.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_67494 (h0 : topological_space (add_cancel_monoid (has_pos_part (has_Inf linarith.comp)))) : regular_space (add_cancel_monoid (has_pos_part (has_Inf linarith.comp))) := sorry --non-trivial
lemma new_lemma_67495 (h0 : function.extfun nat fin) : @rank_condition.{0} (ordered_comm_ring.{0} name) (@function.extfun_app.{2 1} Type ring.{0} (@matrix.vec_empty.{1} (function.extfun.{2 1} Type ring.{0}) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero))) (ordered_comm_ring.{0} name))  := sorry --non-trivial
lemma new_lemma_67496 (h0 : ring (add_cancel_comm_monoid (metric_space char))) : is_domain (add_cancel_comm_monoid (metric_space char)) := sorry --non-trivial
lemma new_lemma_67497 (h0 : functor.add_const (ring (boolean_algebra linarith.comp)) environment.implicit_infer_kind) : @is_domain.{0} (boolean_algebra.{0} linarith.comp) (@functor.add_const.run.{0 0} (ring.{0} (boolean_algebra.{0} linarith.comp)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_67498 (h0 : function.extfun Type topological_space) : @preconnected_space.{0} (linear_order.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (linear_order.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_67499 (h0 : uniform_space (linear_ordered_semiring (has_norm empty))) : complete_space (linear_ordered_semiring (has_norm empty)) := sorry --non-trivial
lemma new_lemma_67500 (h0 : function.extfun Type topological_space) : @t0_space.{0} (linear_ordered_semiring.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (linear_ordered_semiring.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_67501 (h0 : topological_space (add_comm_monoid (comm_group pos))) : discrete_topology (add_comm_monoid (comm_group pos)) := sorry --non-trivial
lemma new_lemma_67502 (h0 : filter (monoid (option unsigned))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_67503 (h0 : function.extfun Type topological_space) : @irreducible_space.{0} (boolean_algebra.core.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (boolean_algebra.core.{0} name))  := sorry --non-trivial
lemma new_lemma_67504 (h0 : complete_lattice (generalized_boolean_algebra (sub_neg_monoid (sub_neg_monoid linarith.comp)))) : is_compactly_generated (generalized_boolean_algebra (sub_neg_monoid (sub_neg_monoid linarith.comp))) := sorry --non-trivial
lemma new_lemma_67505 (h0 : monoid (has_top (random_gen to_additive.value_type))) : monoid.fg (has_top (random_gen to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_67506 (h0 : topological_space (ordered_comm_group (option (option empty)))) : path_connected_space (ordered_comm_group (option (option empty))) := sorry --non-trivial
lemma new_lemma_67507 (h0 : not (has_mem.mem (semiring linarith.comp_source) has_emptyc.emptyc -> false)) : @path_connected_space.{0} (semiring.{0} linarith.comp_source) (@finset.pi.empty.{1 0} Type topological_space.{0} (semiring.{0} linarith.comp_source) (@classical.by_contradiction'.{0} (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (semiring.{0} linarith.comp_source) (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))) h0))  := sorry --non-trivial
lemma new_lemma_67508 (h0 : ring (normed_group (random_gen num))) : strong_rank_condition (normed_group (random_gen num)) := sorry --non-trivial
lemma new_lemma_67509 (h0 : topological_space (normed_group (has_top (has_top to_additive.value_type)))) : path_connected_space (normed_group (has_top (has_top to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_67510 (h0 : topological_space (id empty)) : t0_space (id empty) := sorry --non-trivial
lemma new_lemma_67511 (h0 : filter (has_Inf (has_add (has_to_string environment.implicit_infer_kind)))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_67512 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @topological_space.separable_space.{0} (has_to_string.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_to_string.{0} pos))  := sorry --non-trivial
lemma new_lemma_67513 (h2 h3 : add_comm_semigroup std_gen) : function.is_fixed_pt (fun (h1 : add_comm_semigroup std_gen), h2) h3 := sorry --non-trivial
lemma new_lemma_67514 (h0 : topological_space (canonically_linear_ordered_monoid num)) : topological_space.separable_space (canonically_linear_ordered_monoid num) := sorry --non-trivial
lemma new_lemma_67515 (h0 : complete_lattice (comm_semigroup (has_Inf (comm_semigroup (has_add real))))) : is_compactly_generated (comm_semigroup (has_Inf (comm_semigroup (has_add real)))) := sorry --non-trivial
lemma new_lemma_67516 (h0 : list (has_zero (has_to_string (has_neg (has_add Type))))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_67517 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @path_connected_space.{0} (comm_semigroup.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (comm_semigroup.{0} name))  := sorry --non-trivial
lemma new_lemma_67518 (h0 : functor.comp ring has_neg Type) : @is_principal_ideal_ring.{1} (has_neg.{1} Type) (@functor.comp.run.{1 1 1} ring.{1} has_neg.{1} Type h0)  := sorry --non-trivial
lemma new_lemma_67519 (h0 : complete_lattice (normed_linear_ordered_group unsigned)) : is_atomistic (normed_linear_ordered_group unsigned) := sorry --non-trivial
lemma new_lemma_67520 (h0 : functor.add_const (topological_space (has_to_string num)) num) : @totally_disconnected_space.{0} (has_to_string.{0} num) (@functor.add_const.run.{0 0} (topological_space.{0} (has_to_string.{0} num)) num h0)  := sorry --non-trivial
lemma new_lemma_67521 (h0 : add_group (uniform_space (has_lt linarith.comp_source))) : is_add_cyclic (uniform_space (has_lt linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_67522 (h0 : complete_lattice (ring (ring (has_neg Type)))) : is_compactly_generated (ring (ring (has_neg Type))) := sorry --non-trivial
lemma new_lemma_67523 (h0 : function.extfun Type topological_space) : @totally_separated_space.{0} (normed_lattice_add_comm_group.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (normed_lattice_add_comm_group.{0} pos))  := sorry --non-trivial
lemma new_lemma_67524 (h0 : ring (normed_lattice_add_comm_group linarith.comp)) : strong_rank_condition (normed_lattice_add_comm_group linarith.comp) := sorry --non-trivial
lemma new_lemma_67525 (h0 : add_monoid (monoid_with_zero ennreal)) : add_monoid.fg (monoid_with_zero ennreal) := sorry --non-trivial
lemma new_lemma_67526 (h0 : topological_space (option (semiring (semiring num)))) : t0_space (option (semiring (semiring num))) := sorry --non-trivial
lemma new_lemma_67527 (h0 : ring (add_left_cancel_monoid (has_nnnorm linarith.ineq))) : rank_condition (add_left_cancel_monoid (has_nnnorm linarith.ineq)) := sorry --non-trivial
lemma new_lemma_67528 (h0 : topological_space (canonically_linear_ordered_add_monoid linarith.comp)) : sequential_space (canonically_linear_ordered_add_monoid linarith.comp) := sorry --non-trivial
lemma new_lemma_67529 (h0 : function.extfun Type monoid) : @monoid.fg.{0} (linear_ordered_semiring.{0} unsigned) (@function.extfun_app.{2 1} Type monoid.{0} h0 (linear_ordered_semiring.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_67530 (h0 : uniform_space (linear_ordered_comm_ring (semiring (semiring num)))) : separated_space (linear_ordered_comm_ring (semiring (semiring num))) := sorry --non-trivial
lemma new_lemma_67531 (h1 : function.extfun Type topological_space) : @totally_disconnected_space.{0} (distrib_lattice.{0} string_imp) (@function.extfun_app.{2 1} Type topological_space.{0} h1 (distrib_lattice.{0} string_imp))  := sorry --non-trivial
lemma new_lemma_67532 (h5 : add_group enat) : is_add_cyclic enat := sorry --non-trivial
lemma new_lemma_67533 (h0 : functor.add_const (ring (complete_distrib_lattice empty)) empty) : @strong_rank_condition.{0} (complete_distrib_lattice.{0} empty) (@functor.add_const.run.{0 0} (ring.{0} (complete_distrib_lattice.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_67534 (h0 : has_lt (has_lt string.iterator_imp)) : no_max_order (has_lt string.iterator_imp) := sorry --non-trivial
lemma new_lemma_67535 (h0 : group (distrib_lattice linarith.comp_source)) : normalizer_condition (distrib_lattice linarith.comp_source) := sorry --non-trivial
lemma new_lemma_67536 (h0 : topological_space (mul_zero_class name)) : locally_compact_space (mul_zero_class name) := sorry --non-trivial
lemma new_lemma_67537 (h0 : topological_space (complete_distrib_lattice unsigned)) : loc_path_connected_space (complete_distrib_lattice unsigned) := sorry --non-trivial
lemma new_lemma_67538 (h0 : functor.add_const (monoid (has_add linarith.comp)) environment.implicit_infer_kind) : @monoid.fg.{0} (has_add.{0} linarith.comp) (@functor.add_const.run.{0 0} (monoid.{0} (has_add.{0} linarith.comp)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_67539 (h0 : functor.add_const (functor.add_const (list Prop) (has_neg linarith.comp)) name) : list.head (functor.add_const.run (functor.add_const.run h0)) := sorry --non-trivial
lemma new_lemma_67540 (h0 : function.extfun (finset (Type -> Type)) (has_mem.mem topological_space)) : @irreducible_space.{0} (has_emptyc.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type topological_space.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) topological_space.{0} (@function.extfun_app.{2 0} (finset.{1} (Type → Type)) (@has_mem.mem.{1 1} (Type → Type) (finset.{1} (Type → Type)) (@finset.has_mem.{1} (Type → Type)) topological_space.{0}) h0 (@has_emptyc.emptyc.{1} (finset.{1} (Type → Type)) (@finset.has_emptyc.{1} (Type → Type))))) (has_emptyc.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_67541 (h0 : functor.add_const Prop (finset unsigned)) : functor.add_const.run h0 := sorry --non-trivial
lemma new_lemma_67542 (h0 : group (complete_distrib_lattice (has_Inf real))) : is_cyclic (complete_distrib_lattice (has_Inf real)) := sorry --non-trivial
lemma new_lemma_67543 (h0 : ring (comm_monoid empty)) : is_principal_ideal_ring (comm_monoid empty) := sorry --non-trivial
lemma new_lemma_67544 (h0 : functor.add_const (function.extfun (Type 1) topological_space) Type) : @preconnected_space.{1} (has_add.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@functor.add_const.run.{2 1} (function.extfun.{3 2} (Type 1) topological_space.{1}) Type h0) (has_add.{1} Type))  := sorry --non-trivial
lemma new_lemma_67545 (h1 : topological_space (with_one (random_gen string_imp))) : irreducible_space (with_one (random_gen string_imp)) := sorry --non-trivial
lemma new_lemma_67546 (h0 : group (normed_comm_ring (has_add (mul_one_class linarith.comp)))) : is_simple_group (normed_comm_ring (has_add (mul_one_class linarith.comp))) := sorry --non-trivial
lemma new_lemma_67547 (h0 : complete_lattice (linear_ordered_semiring (has_top (semiring congr_arg_kind)))) : complete_lattice.is_Sup_finite_compact (linear_ordered_semiring (has_top (semiring congr_arg_kind))) := sorry --non-trivial
lemma new_lemma_67548 (h0 : add_group (semiring (has_top num))) : is_add_cyclic (semiring (has_top num)) := sorry --non-trivial
lemma new_lemma_67549 (h0 : not (function.extfun Type monoid -> false)) : @monoid.fg.{0} (measurable_space.{0} fun_info) (@function.extfun_app.{2 1} Type monoid.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type monoid.{0}) h0) (measurable_space.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_67550 (h0 : functor.add_const (group (generalized_boolean_algebra pos)) pos) : @normalizer_condition.{0} (generalized_boolean_algebra.{0} pos) (@functor.add_const.run.{0 0} (group.{0} (generalized_boolean_algebra.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_67551 (h0 : topological_space (has_bot (has_add name))) : preirreducible_space (has_bot (has_add name)) := sorry --non-trivial
lemma new_lemma_67552 (h0 : functor.add_const (ordered_comm_monoid (canonically_ordered_comm_semiring unsigned)) name) : @has_exists_mul_of_le.{0} (canonically_ordered_comm_semiring.{0} unsigned) (@functor.add_const.run.{0 0} (ordered_comm_monoid.{0} (canonically_ordered_comm_semiring.{0} unsigned)) name h0)  := sorry --non-trivial
lemma new_lemma_67553 (h0 : ring (has_top (has_norm congr_arg_kind))) : is_domain (has_top (has_norm congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_67554 (h0 : functor.add_const (ordered_add_comm_monoid (cancel_monoid ennreal)) unsigned) : @archimedean.{0} (cancel_monoid.{0} ennreal) (@functor.add_const.run.{0 0} (ordered_add_comm_monoid.{0} (cancel_monoid.{0} ennreal)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_67555 (h0 : topological_space (simple_graph (option (option (option unsigned))))) : totally_separated_space (simple_graph (option (option (option unsigned)))) := sorry --non-trivial
lemma new_lemma_67556 (h0 : add_group (normed_group (random_gen (comm_ring to_additive.value_type)))) : is_add_cyclic (normed_group (random_gen (comm_ring to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_67557 (h0 : ordered_add_comm_monoid (comm_semigroup (has_Inf (has_Inf real)))) : archimedean (comm_semigroup (has_Inf (has_Inf real))) := sorry --non-trivial
lemma new_lemma_67558 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @irreducible_space.{1} (semigroup.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 topological_space.{1}) (semigroup.{1} Type))  := sorry --non-trivial
lemma new_lemma_67559 (h0 : functor.add_const (topological_space (boolean_algebra name)) linarith.comp) : @discrete_topology.{0} (boolean_algebra.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (boolean_algebra.{0} name)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_67560 (h0 : partial_order (fintype to_additive.value_type)) (h1 : order_bot (fintype to_additive.value_type)) : is_atomic (fintype to_additive.value_type) := sorry --non-trivial
lemma new_lemma_67561 (h0 : function.extfun Type topological_space) : @loc_path_connected_space.{0} (has_pos_part.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_pos_part.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_67562 (h0 : function.extfun Type monoid) : @monoid.fg.{0} linarith.comp_source (@function.extfun_app.{2 1} Type monoid.{0} h0 linarith.comp_source)  := sorry --non-trivial
lemma new_lemma_67563 (h1 : function.extfun Type topological_space) : @irreducible_space.{0} (complete_semilattice_Sup.{0} string_imp) (@function.extfun_app.{2 1} Type topological_space.{0} h1 (complete_semilattice_Sup.{0} string_imp))  := sorry --non-trivial
lemma new_lemma_67564 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @discrete_topology.{0} (has_union.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_union.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_67565 (h0 : functor.add_const (topological_space (ring name)) pos) : @preconnected_space.{0} (ring.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (ring.{0} name)) pos h0)  := sorry --non-trivial
lemma new_lemma_67566 (h0 : functor.add_const (function.extfun Type topological_space) linarith.comp) : @t1_space.{0} (add_cancel_monoid.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) linarith.comp h0) (add_cancel_monoid.{0} name))  := sorry --non-trivial
lemma new_lemma_67567 (h0 : functor.add_const (group (comm_group name)) (has_neg environment.implicit_infer_kind)) : @is_simple_group.{0} (comm_group.{0} name) (@functor.add_const.run.{0 0} (group.{0} (comm_group.{0} name)) (has_neg.{0} environment.implicit_infer_kind) h0)  := sorry --non-trivial
lemma new_lemma_67568 (h0 : list (has_Inf (has_Inf (has_Inf (has_Inf (has_Inf (has_Inf (has_Inf real)))))))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_67569 (h0 : functor.add_const (function.extfun Type ring) unsigned) : @rank_condition.{0} (partial_order.{0} unsigned) (@function.extfun_app.{2 1} Type ring.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type ring.{0}) unsigned h0) (partial_order.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_67570 (h0 : eq (has_ssubset (random_gen (add_left_cancel_semigroup to_additive.value_type))) Prop) (h1 : has_ssubset (random_gen (add_left_cancel_semigroup to_additive.value_type))) : eq.mp h0 h1 := sorry --non-trivial
lemma new_lemma_67571 (h0 : functor.add_const (topological_space (ring pos)) linarith.comp) : @preconnected_space.{0} (ring.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (ring.{0} pos)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_67572 (h0 : list (has_nndist (add_comm_monoid name))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_67573 (h0 : function.extfun Type topological_space) : @t1_space.{0} (has_neg.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_neg.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_67574 (h0 : complete_lattice (random_gen (random_gen linarith.comp_source))) : is_atomistic (random_gen (random_gen linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_67575 (h0 : topological_space (with_bot (has_norm (has_norm empty)))) : discrete_topology (with_bot (has_norm (has_norm empty))) := sorry --non-trivial
lemma new_lemma_67576 (h0 : group (boolean_algebra real)) : is_simple_group (boolean_algebra real) := sorry --non-trivial
lemma new_lemma_67577 (h0 : topological_space (canonically_ordered_monoid (has_Inf name))) : loc_path_connected_space (canonically_ordered_monoid (has_Inf name)) := sorry --non-trivial
lemma new_lemma_67578 (h0 : complete_lattice (as_linear_order (option (option (option empty))))) : is_atomistic (as_linear_order (option (option (option empty)))) := sorry --non-trivial
lemma new_lemma_67579 (h0 : not (function.extfun Type ring -> false)) : @strong_rank_condition.{0} (has_one.{0} num) (@function.extfun_app.{2 1} Type ring.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type ring.{0}) h0) (has_one.{0} num))  := sorry --non-trivial
lemma new_lemma_67580 (h0 : functor.add_const (topological_space (boolean_algebra name)) (finset Type)) : @preconnected_space.{0} (boolean_algebra.{0} name) (@functor.add_const.run.{0 1} (topological_space.{0} (boolean_algebra.{0} name)) (finset.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_67581 (h0 : filter (has_add (has_nnnorm linarith.ineq))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_67582 (h0 : functor.add_const (topological_space (has_zero environment.implicit_infer_kind)) linarith.comp) : @locally_compact_space.{0} (has_zero.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (has_zero.{0} environment.implicit_infer_kind)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_67583 (h0 : add_group (simple_graph (mul_one_class (cancel_monoid char)))) : is_add_cyclic (simple_graph (mul_one_class (cancel_monoid char))) := sorry --non-trivial
lemma new_lemma_67584 (h0 : topological_space (preorder (option empty))) : loc_path_connected_space (preorder (option empty)) := sorry --non-trivial
lemma new_lemma_67585 (h0 : topological_space (has_top (semiring (random_gen (has_norm num))))) : irreducible_space (has_top (semiring (random_gen (has_norm num)))) := sorry --non-trivial
lemma new_lemma_67586 (h0 : not (function.extfun Type complete_lattice -> false)) : @complete_lattice.is_Sup_finite_compact.{0} unsigned (@function.extfun_app.{2 1} Type complete_lattice.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type complete_lattice.{0}) h0) unsigned)  := sorry --non-trivial
lemma new_lemma_67587 (h1 : group (with_one to_additive.value_type)) : group.fg (with_one to_additive.value_type) := sorry --non-trivial
lemma new_lemma_67588 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @add_monoid.fg.{0} (canonically_ordered_comm_semiring.{0} empty) (@function.extfun_app.{2 1} Type add_monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 add_monoid.{0}) (canonically_ordered_comm_semiring.{0} empty))  := sorry --non-trivial
lemma new_lemma_67589 (h0 : uniform_space (ring (finset environment.implicit_infer_kind))) : separated_space (ring (finset environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_67590 (h0 : ordered_add_comm_monoid (cancel_monoid (comm_group name))) : archimedean (cancel_monoid (comm_group name)) := sorry --non-trivial
lemma new_lemma_67591 (h0 : topological_space (mul_one_class linarith.comp_source)) : t0_space (mul_one_class linarith.comp_source) := sorry --non-trivial
lemma new_lemma_67592 (h0 : function.extfun Type (functor.add_const (cancel_comm_monoid_with_zero (has_edist empty)))) : @unique_factorization_monoid.{0} (has_edist.{0} empty) (@functor.add_const.run.{0 0} (cancel_comm_monoid_with_zero.{0} (has_edist.{0} empty)) unsigned (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (cancel_comm_monoid_with_zero.{0} (has_edist.{0} empty))) h0 unsigned))  := sorry --non-trivial
lemma new_lemma_67593 (h0 : semiring (add_comm_semigroup linarith.ineq)) (h2 : ideal (add_comm_semigroup linarith.ineq)) : ideal.is_prime h2 := sorry --non-trivial
lemma new_lemma_67594 (h0 : topological_space (add_cancel_monoid (option (option empty)))) : totally_disconnected_space (add_cancel_monoid (option (option empty))) := sorry --non-trivial
lemma new_lemma_67595 (h0 : finset (complete_distrib_lattice linarith.comp)) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_67596 (h3 : monoid (has_top to_additive.value_type)) : monoid.fg (has_top to_additive.value_type) := sorry --non-trivial
lemma new_lemma_67597 (h0 : functor.add_const (group (add_left_cancel_semigroup empty)) (option empty)) : @normalizer_condition.{0} (add_left_cancel_semigroup.{0} empty) (@functor.add_const.run.{0 0} (group.{0} (add_left_cancel_semigroup.{0} empty)) (option.{0} empty) h0)  := sorry --non-trivial
lemma new_lemma_67598 (h0 : functor.add_const (topological_space (finset pos)) pos) : @preconnected_space.{0} (finset.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (finset.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_67599 (h0 : topological_space (partial_order num)) : irreducible_space (partial_order num) := sorry --non-trivial
lemma new_lemma_67600 (h0 : ordered_comm_monoid (has_neg_part (has_add (has_add Type)))) : has_exists_mul_of_le (has_neg_part (has_add (has_add Type))) := sorry --non-trivial
lemma new_lemma_67601 (h0 : topological_space (semiring (semiring (semiring congr_arg_kind)))) : path_connected_space (semiring (semiring (semiring congr_arg_kind))) := sorry --non-trivial
lemma new_lemma_67602 (h0 : not (topological_space (has_union linarith.comp) -> false)) : @path_connected_space.{0} (has_union.{0} linarith.comp) (@classical.by_contradiction'.{1} (topological_space.{0} (has_union.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_67603 (h0 : topological_space (comm_group unsigned)) : discrete_topology (comm_group unsigned) := sorry --non-trivial
lemma new_lemma_67604 (h0 : group (add_group (has_union linarith.comp))) : is_cyclic (add_group (has_union linarith.comp)) := sorry --non-trivial
lemma new_lemma_67605 (h0 : filter (canonically_linear_ordered_monoid (option (option num)))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_67606 (h0 : function.extfun Type semiring) : @is_noetherian_ring.{0} (has_neg.{0} unsigned) (@function.extfun_app.{2 1} Type semiring.{0} h0 (has_neg.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_67607 (h0 : topological_space (add_comm_monoid linarith.comp)) : totally_disconnected_space (add_comm_monoid linarith.comp) := sorry --non-trivial
lemma new_lemma_67608 (h0 : ordered_comm_monoid (has_Inf (has_nndist pos))) : has_exists_mul_of_le (has_Inf (has_nndist pos)) := sorry --non-trivial
lemma new_lemma_67609 (h0 : group (id (with_bot string_imp))) : is_cyclic (id (with_bot string_imp)) := sorry --non-trivial
lemma new_lemma_67610 (h0 : list (add_semigroup empty)) : palindrome h0 := sorry --non-trivial
lemma new_lemma_67611 (h0 : not (function.extfun Type complete_lattice -> false)) : @complete_lattice.is_Sup_finite_compact.{0} (semiring.{0} (measurable_space.{0} fun_info)) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type complete_lattice.{0}) h0) (semiring.{0} (measurable_space.{0} fun_info)))  := sorry --non-trivial
lemma new_lemma_67612 (h0 : add_group (has_Inf (has_neg name))) : is_add_cyclic (has_Inf (has_neg name)) := sorry --non-trivial
lemma new_lemma_67613 (h0 : function.extfun Type complete_lattice) : @is_compactly_generated.{0} (complete_distrib_lattice.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (complete_distrib_lattice.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_67614 (h0 : functor.add_const (complete_lattice (normed_comm_ring name)) name) : @is_compactly_generated.{0} (normed_comm_ring.{0} name) (@functor.add_const.run.{0 0} (complete_lattice.{0} (normed_comm_ring.{0} name)) name h0)  := sorry --non-trivial
lemma new_lemma_67615 (h0 : functor.add_const (ring (preorder congr_arg_kind)) (ordered_cancel_comm_monoid empty)) : @strong_rank_condition.{0} (preorder.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (ring.{0} (preorder.{0} congr_arg_kind)) (ordered_cancel_comm_monoid.{0} empty) h0)  := sorry --non-trivial
lemma new_lemma_67616 (h0 : functor.add_const (function.extfun (Type 1) complete_lattice) (ordered_ring Type)) : @complete_lattice.is_Sup_finite_compact.{1} Type (@function.extfun_app.{3 2} (Type 1) complete_lattice.{1} (@functor.add_const.run.{2 1} (function.extfun.{3 2} (Type 1) complete_lattice.{1}) (ordered_ring.{1} Type) h0) Type)  := sorry --non-trivial
lemma new_lemma_67617 (h0 : functor.add_const (topological_space (normed_comm_ring unsigned)) linarith.comp) : @regular_space.{0} (normed_comm_ring.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (normed_comm_ring.{0} unsigned)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_67618 (h0 : monoid (add_group (semiring (semiring (semiring unsigned))))) : monoid.fg (add_group (semiring (semiring (semiring unsigned)))) := sorry --non-trivial
lemma new_lemma_67619 (h0 : function.extfun (finset Type) (has_mem.mem (has_emptyc to_additive.value_type))) : @path_connected_space.{0} (has_emptyc.{0} to_additive.value_type) (@finset.pi.empty.{1 0} Type topological_space.{0} (has_emptyc.{0} to_additive.value_type) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (has_emptyc.{0} to_additive.value_type)) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_67620 (h0 : functor.add_const (function.extfun Type topological_space) environment.implicit_infer_kind) : @preconnected_space.{0} (boolean_algebra.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) environment.implicit_infer_kind h0) (boolean_algebra.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_67621 (h0 : not (semiring (complete_semilattice_Sup empty) -> false)) : @is_noetherian_ring.{0} (complete_semilattice_Sup.{0} empty) (@classical.by_contradiction'.{1} (semiring.{0} (complete_semilattice_Sup.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_67622 (h0 : filter (random_gen (has_top (has_top fun_info)))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_67623 (h0 : add_group (has_ssubset (mul_one_class fun_info))) : is_add_cyclic (has_ssubset (mul_one_class fun_info)) := sorry --non-trivial
lemma new_lemma_67624 (h0 : filter (measure_theory.measure_space (semiring empty))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_67625 (h1 : not (topological_space (has_ssubset char) -> false)) : @totally_disconnected_space.{0} (has_ssubset.{0} char) (@classical.by_contradiction'.{1} (topological_space.{0} (has_ssubset.{0} char)) h1)  := sorry --non-trivial
lemma new_lemma_67626 (h0 : functor.add_const (filter (mul_zero_class name)) unsigned) : countable_Inter_filter (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_67627 (h0 : add_comm_semigroup string.iterator_imp -> char) (h2 : add_comm_semigroup string.iterator_imp) : function.right_inverse h0 (fun (h1 : char), h2) := sorry --non-trivial
lemma new_lemma_67628 (h0 : uniform_space (linear_ordered_semiring (has_norm num))) : separated_space (linear_ordered_semiring (has_norm num)) := sorry --non-trivial
lemma new_lemma_67629 (h0 : functor.add_const (complete_lattice (add_cancel_monoid environment.implicit_infer_kind)) pos) : @complete_lattice.is_Sup_finite_compact.{0} (add_cancel_monoid.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (complete_lattice.{0} (add_cancel_monoid.{0} environment.implicit_infer_kind)) pos h0)  := sorry --non-trivial
lemma new_lemma_67630 (h0 : functor.add_const (function.extfun Type topological_space) environment.implicit_infer_kind) : @totally_disconnected_space.{0} (semigroup.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) environment.implicit_infer_kind h0) (semigroup.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_67631 (h0 : ring (add_right_cancel_monoid (semiring empty))) : rank_condition (add_right_cancel_monoid (semiring empty)) := sorry --non-trivial
lemma new_lemma_67632 (h0 : function.extfun Type topological_space) : @t0_space.{0} (canonically_linear_ordered_monoid.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (canonically_linear_ordered_monoid.{0} num))  := sorry --non-trivial
lemma new_lemma_67633 (h0 : filter (encodable (has_nnnorm (random_gen to_additive.value_type)))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_67634 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @is_noetherian_ring.{1} (ordered_comm_ring.{1} Type) (@function.extfun_app.{3 2} (Type 1) semiring.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 semiring.{1}) (ordered_comm_ring.{1} Type))  := sorry --non-trivial
lemma new_lemma_67635 (h0 : ring (has_top empty)) : strong_rank_condition (has_top empty) := sorry --non-trivial
lemma new_lemma_67636 (h1 : group (measurable_space linarith.comp)) : group.fg (measurable_space linarith.comp) := sorry --non-trivial
lemma new_lemma_67637 (h0 : topological_space (normed_group (has_top (has_top (has_top fun_info))))) : totally_separated_space (normed_group (has_top (has_top (has_top fun_info)))) := sorry --non-trivial
lemma new_lemma_67638 (h0 : topological_space (has_pos_part (ring Type))) : sequential_space (has_pos_part (ring Type)) := sorry --non-trivial
lemma new_lemma_67639 (h0 : functor.add_const (uniform_space (has_zero Type)) Type) : @complete_space.{1} (has_zero.{1} Type) (@functor.add_const.run.{1 1} (uniform_space.{1} (has_zero.{1} Type)) Type h0)  := sorry --non-trivial
lemma new_lemma_67640 (h0 : not (function.extfun Type group -> false)) : @normalizer_condition.{0} (with_one.{0} empty) (@function.extfun_app.{2 1} Type group.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type group.{0}) h0) (with_one.{0} empty))  := sorry --non-trivial
lemma new_lemma_67641 (h0 : topological_space (sub_neg_monoid (has_neg pos))) : t1_space (sub_neg_monoid (has_neg pos)) := sorry --non-trivial
lemma new_lemma_67642 (h0 : not (function.extfun Type topological_space -> false)) : @totally_disconnected_space.{0} (linear_ordered_add_comm_group.{0} fun_info) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (linear_ordered_add_comm_group.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_67643 (h0 : topological_space (has_Inf (sub_neg_monoid real))) : loc_path_connected_space (has_Inf (sub_neg_monoid real)) := sorry --non-trivial
lemma new_lemma_67644 (h0 : function.extfun Type ring) : @is_domain.{0} (random_gen.{0} num) (@function.extfun_app.{2 1} Type ring.{0} h0 (random_gen.{0} num))  := sorry --non-trivial
lemma new_lemma_67645 (h0 : function.extfun Type topological_space) : @path_connected_space.{0} (linear_ordered_comm_ring.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (linear_ordered_comm_ring.{0} empty))  := sorry --non-trivial
lemma new_lemma_67646 (h0 : topological_space (linear_ordered_field (cancel_monoid pos))) : totally_disconnected_space (linear_ordered_field (cancel_monoid pos)) := sorry --non-trivial
lemma new_lemma_67647 (h0 : functor.add_const (function.extfun (Type 1) finset) pos) : finset.nonempty (function.extfun_app (functor.add_const.run h0) Type) := sorry --non-trivial
lemma new_lemma_67648 (h0 : ring (ordered_comm_group congr_arg_kind)) : is_domain (ordered_comm_group congr_arg_kind) := sorry --non-trivial
lemma new_lemma_67649 (h0 : group (has_norm num)) : group.fg (has_norm num) := sorry --non-trivial
lemma new_lemma_67650 (h0 : functor.add_const (uniform_space (generalized_boolean_algebra linarith.comp)) (has_neg (has_neg Type))) : @separated_space.{0} (generalized_boolean_algebra.{0} linarith.comp) (@functor.add_const.run.{0 1} (uniform_space.{0} (generalized_boolean_algebra.{0} linarith.comp)) (has_neg.{1} (has_neg.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_67651 (h2 : uniform_space (linear_ordered_comm_group_with_zero to_additive.value_type)) : complete_space (linear_ordered_comm_group_with_zero to_additive.value_type) := sorry --non-trivial
lemma new_lemma_67652 (h0 : complete_lattice (add_right_cancel_monoid (has_top empty))) : is_compactly_generated (add_right_cancel_monoid (has_top empty)) := sorry --non-trivial
lemma new_lemma_67653 (h0 : topological_space (ordered_comm_ring (comm_semigroup (sub_neg_monoid real)))) : preconnected_space (ordered_comm_ring (comm_semigroup (sub_neg_monoid real))) := sorry --non-trivial
lemma new_lemma_67654 (h0 : topological_space (has_union fun_info)) : normal_space (has_union fun_info) := sorry --non-trivial
lemma new_lemma_67655 (h0 : functor.add_const (topological_space (comm_group ennreal)) ennreal) : @t0_space.{0} (comm_group.{0} ennreal) (@functor.add_const.run.{0 0} (topological_space.{0} (comm_group.{0} ennreal)) ennreal h0)  := sorry --non-trivial
lemma new_lemma_67656 (h0 : not (has_mem.mem complete_lattice has_emptyc.emptyc -> false)) : @is_atomistic.{0} (normed_group.{0} fun_info) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) complete_lattice.{0} (@classical.by_contradiction'.{0} (@has_mem.mem.{1 1} (Type → Type) (finset.{1} (Type → Type)) (@finset.has_mem.{1} (Type → Type)) complete_lattice.{0} (@has_emptyc.emptyc.{1} (finset.{1} (Type → Type)) (@finset.has_emptyc.{1} (Type → Type)))) h0)) (normed_group.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_67657 (h0 : filter (linear_ordered_add_comm_group (random_gen (has_norm (has_norm fun_info))))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_67658 (h0 : monoid (plift (semiring (semiring (semiring unsigned))))) : monoid.fg (plift (semiring (semiring (semiring unsigned)))) := sorry --non-trivial
lemma new_lemma_67659 (h0 : has_mem.mem topological_space has_emptyc.emptyc) : @irreducible_space.{0} (has_norm.{0} (has_top.{0} (has_top.{0} (has_top.{0} (has_top.{0} fun_info))))) (@function.extfun_app.{2 1} Type topological_space.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) topological_space.{0} h0) (has_norm.{0} (has_top.{0} (has_top.{0} (has_top.{0} (has_top.{0} fun_info))))))  := sorry --non-trivial
lemma new_lemma_67660 (h0 : function.extfun Type topological_space) : @preirreducible_space.{0} (finset.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (finset.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_67661 (h0 : function.extfun (random_gen linarith.ineq) (fun (x : random_gen linarith.ineq), Prop)) : @infi.{0 1} Prop (@conditionally_complete_lattice.to_has_Inf.{0} Prop (@complete_lattice.to_conditionally_complete_lattice.{0} Prop Prop.complete_lattice)) (random_gen.{0} linarith.ineq) (@function.extfun_app.{1 1} (random_gen.{0} linarith.ineq) (λ (x : random_gen.{0} linarith.ineq), Prop) h0)  := sorry --non-trivial
lemma new_lemma_67662 (h0 : ring (normed_group (semiring (semiring congr_arg_kind)))) : rank_condition (normed_group (semiring (semiring congr_arg_kind))) := sorry --non-trivial
lemma new_lemma_67663 (h0 : functor.add_const (semiring (canonically_ordered_comm_semiring pos)) linarith.comp) : @is_noetherian_ring.{0} (canonically_ordered_comm_semiring.{0} pos) (@functor.add_const.run.{0 0} (semiring.{0} (canonically_ordered_comm_semiring.{0} pos)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_67664 (h1 : not (topological_space (normed_field char) -> false)) : @path_connected_space.{0} (normed_field.{0} char) (@classical.by_contradiction'.{1} (topological_space.{0} (normed_field.{0} char)) h1)  := sorry --non-trivial
lemma new_lemma_67665 (h0 : fin has_zero.zero) : @is_atomistic.{1} (canonically_ordered_monoid.{1} Type) (@matrix.vec_empty.{1} (complete_lattice.{1} (canonically_ordered_monoid.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_67666 (h0 : functor.add_const (add_monoid (normed_comm_ring environment.implicit_infer_kind)) (ring pos)) : @add_monoid.fg.{0} (normed_comm_ring.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (add_monoid.{0} (normed_comm_ring.{0} environment.implicit_infer_kind)) (ring.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_67667 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @t0_space.{1} (ordered_comm_monoid.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 topological_space.{1}) (ordered_comm_monoid.{1} Type))  := sorry --non-trivial
lemma new_lemma_67668 (h0 : functor.add_const (topological_space (semigroup linarith.comp)) environment.implicit_infer_kind) : @regular_space.{0} (semigroup.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (semigroup.{0} linarith.comp)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_67669 (h0 : topological_space (has_add (option ennreal))) : topological_space.separable_space (has_add (option ennreal)) := sorry --non-trivial
lemma new_lemma_67670 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @loc_path_connected_space.{0} (has_star.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_star.{0} empty))  := sorry --non-trivial
lemma new_lemma_67671 (h0 : function.extfun Type topological_space) : @locally_compact_space.{0} (with_bot.{0} linarith.ineq) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (with_bot.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_67672 (h0 : filter (comm_group (has_add ennreal))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_67673 (h1 : complete_lattice (add_left_cancel_monoid fun_info)) : complete_lattice.is_Sup_finite_compact (add_left_cancel_monoid fun_info) := sorry --non-trivial
lemma new_lemma_67674 (h0 : functor.add_const (functor.add_const (cancel_comm_monoid_with_zero (comm_monoid empty)) empty) empty) : @unique_factorization_monoid.{0} (comm_monoid.{0} empty) (@functor.add_const.run.{0 0} (cancel_comm_monoid_with_zero.{0} (comm_monoid.{0} empty)) empty (@functor.add_const.run.{0 0} (functor.add_const.{0 0} (cancel_comm_monoid_with_zero.{0} (comm_monoid.{0} empty)) empty) empty h0))  := sorry --non-trivial
lemma new_lemma_67675 (h0 : functor.add_const (uniform_space (normed_comm_ring linarith.comp)) pos) : @complete_space.{0} (normed_comm_ring.{0} linarith.comp) (@functor.add_const.run.{0 0} (uniform_space.{0} (normed_comm_ring.{0} linarith.comp)) pos h0)  := sorry --non-trivial
lemma new_lemma_67676 (h0 : topological_space (measure_theory.measure_space (semiring (semiring unsigned)))) : t1_space (measure_theory.measure_space (semiring (semiring unsigned))) := sorry --non-trivial
lemma new_lemma_67677 (h2 : ring (denumerable fun_info)) : rank_condition (denumerable fun_info) := sorry --non-trivial
lemma new_lemma_67678 (h0 : topological_space (has_top (has_norm to_additive.value_type))) : discrete_topology (has_top (has_norm to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_67679 (h0 : function.extfun Type semiring) : @is_noetherian_ring.{0} (measurable_space.dynkin_system.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type semiring.{0} h0 (measurable_space.dynkin_system.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_67680 (h0 : functor.add_const (topological_space (has_neg linarith.comp)) (ring (ring Type))) : @preirreducible_space.{0} (has_neg.{0} linarith.comp) (@functor.add_const.run.{0 1} (topological_space.{0} (has_neg.{0} linarith.comp)) (ring.{1} (ring.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_67681 (h0 : group (free_add_monoid unsigned)) : is_cyclic (free_add_monoid unsigned) := sorry --non-trivial
lemma new_lemma_67682 (h0 : complete_lattice (ordered_cancel_add_comm_monoid congr_arg_kind)) : is_compactly_generated (ordered_cancel_add_comm_monoid congr_arg_kind) := sorry --non-trivial
lemma new_lemma_67683 (h0 : list (normed_comm_ring (option unsigned))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_67684 (h0 : topological_space (ring (has_to_string (has_add (has_add pos))))) : locally_compact_space (ring (has_to_string (has_add (has_add pos)))) := sorry --non-trivial
lemma new_lemma_67685 (h0 : not (add_group (has_norm unsigned) -> false)) : @is_add_cyclic.{0} (has_norm.{0} unsigned) (@classical.by_contradiction'.{1} (add_group.{0} (has_norm.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_67686 (h0 : functor.add_const (topological_space (add_cancel_monoid Type)) pos) : @preconnected_space.{1} (add_cancel_monoid.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (add_cancel_monoid.{1} Type)) pos h0)  := sorry --non-trivial
lemma new_lemma_67687 (h0 h1 : multiset (distrib std_gen)) : multiset.disjoint h0 h1 := sorry --non-trivial
lemma new_lemma_67688 (h0 : add_monoid (comm_group (has_to_string linarith.comp))) : add_monoid.fg (comm_group (has_to_string linarith.comp)) := sorry --non-trivial
lemma new_lemma_67689 (h1 : topological_space (distrib (denumerable char))) : totally_disconnected_space (distrib (denumerable char)) := sorry --non-trivial
lemma new_lemma_67690 (h0 : topological_space (has_sub congr_arg_kind)) : discrete_topology (has_sub congr_arg_kind) := sorry --non-trivial
lemma new_lemma_67691 (h0 : complete_lattice (has_to_string (has_Inf real))) : is_atomistic (has_to_string (has_Inf real)) := sorry --non-trivial
lemma new_lemma_67692 (h0 : add_group (finset (finset pos))) : is_add_cyclic (finset (finset pos)) := sorry --non-trivial
lemma new_lemma_67693 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @totally_separated_space.{0} (add_group.{0} (semiring.{0} congr_arg_kind)) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (add_group.{0} (semiring.{0} congr_arg_kind)))  := sorry --non-trivial
lemma new_lemma_67694 (h0 : functor.add_const (ordered_comm_monoid (has_neg_part name)) (has_add name)) : @has_exists_mul_of_le.{0} (has_neg_part.{0} name) (@functor.add_const.run.{0 0} (ordered_comm_monoid.{0} (has_neg_part.{0} name)) (has_add.{0} name) h0)  := sorry --non-trivial
lemma new_lemma_67695 (h0 : topological_space (has_pos_part linarith.comp)) : path_connected_space (has_pos_part linarith.comp) := sorry --non-trivial
lemma new_lemma_67696 (h0 : group (has_to_string (comm_group (has_add pos)))) : group.fg (has_to_string (comm_group (has_add pos))) := sorry --non-trivial
lemma new_lemma_67697 (h0 : topological_space (normed_field string_imp)) : path_connected_space (normed_field string_imp) := sorry --non-trivial
lemma new_lemma_67698 (h0 : topological_space (with_zero fun_info)) : path_connected_space (with_zero fun_info) := sorry --non-trivial
lemma new_lemma_67699 (h0 : topological_space (complete_distrib_lattice (has_pos_part Type))) : preirreducible_space (complete_distrib_lattice (has_pos_part Type)) := sorry --non-trivial
lemma new_lemma_67700 (h0 : group (ring (has_to_string (has_to_string (has_to_string pos))))) : group.fg (ring (has_to_string (has_to_string (has_to_string pos)))) := sorry --non-trivial
lemma new_lemma_67701 (h0 : has_le enat) : no_top_order enat := sorry --non-trivial
lemma new_lemma_67702 (h0 : function.extfun (finset Type) (has_mem.mem (has_one congr_arg_kind))) : @is_cyclic.{0} (has_one.{0} congr_arg_kind) (@finset.pi.empty.{1 0} Type group.{0} (has_one.{0} congr_arg_kind) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (has_one.{0} congr_arg_kind)) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_67703 (h0 : complete_lattice (normed_group (random_gen linarith.comp))) : complete_lattice.is_Sup_finite_compact (normed_group (random_gen linarith.comp)) := sorry --non-trivial
lemma new_lemma_67704 (h0 : functor.add_const (list (has_Inf name)) pos) : palindrome (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_67705 (h0 : function.extfun Type topological_space) : @totally_disconnected_space.{0} (has_add.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_add.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_67706 (h0 : topological_space (has_ssubset (mul_one_class ereal))) : path_connected_space (has_ssubset (mul_one_class ereal)) := sorry --non-trivial
lemma new_lemma_67707 (h0 : add_group (sub_neg_monoid (has_add Type))) : is_add_cyclic (sub_neg_monoid (has_add Type)) := sorry --non-trivial
lemma new_lemma_67708 (h0 : topological_space (has_add (has_Inf (has_Inf Type)))) : regular_space (has_add (has_Inf (has_Inf Type))) := sorry --non-trivial
lemma new_lemma_67709 (h0 : function.extfun Type cancel_comm_monoid_with_zero) : @unique_factorization_monoid.{0} (preorder.{0} num) (@function.extfun_app.{2 1} Type cancel_comm_monoid_with_zero.{0} h0 (preorder.{0} num))  := sorry --non-trivial
lemma new_lemma_67710 (h0 : function.extfun Type measurable_space) (h1 : has_sup (mul_zero_class empty)) : @has_measurable_sup.{0} (mul_zero_class.{0} empty) (@function.extfun_app.{2 1} Type measurable_space.{0} h0 (mul_zero_class.{0} empty)) h1  := sorry --non-trivial
lemma new_lemma_67711 (h0 : topological_space (finset (finset Type))) : t1_space (finset (finset Type)) := sorry --non-trivial
lemma new_lemma_67712 (h0 : function.extfun Type group) : @normalizer_condition.{0} (ordered_cancel_add_comm_monoid.{0} num) (@function.extfun_app.{2 1} Type group.{0} h0 (ordered_cancel_add_comm_monoid.{0} num))  := sorry --non-trivial
lemma new_lemma_67713 (h0 : topological_space (finset (has_add (has_Inf (ordered_comm_monoid real))))) : totally_separated_space (finset (has_add (has_Inf (ordered_comm_monoid real)))) := sorry --non-trivial
lemma new_lemma_67714 (h0 : functor.add_const (topological_space (has_neg Type)) (finset pos)) : @t1_space.{1} (has_neg.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (has_neg.{1} Type)) (finset.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_67715 (h0 : semiring (has_zero (has_neg_part (has_neg_part unsigned)))) : is_noetherian_ring (has_zero (has_neg_part (has_neg_part unsigned))) := sorry --non-trivial
lemma new_lemma_67716 (h0 : functor.add_const (topological_space (has_Inf linarith.comp)) pos) : @regular_space.{0} (has_Inf.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (has_Inf.{0} linarith.comp)) pos h0)  := sorry --non-trivial
lemma new_lemma_67717 (h0 : functor.add_const (list (left_cancel_monoid unsigned)) num) : list.nodup (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_67718 (h0 : functor.add_const (uniform_space (ordered_comm_ring pos)) linarith.comp) : @separated_space.{0} (ordered_comm_ring.{0} pos) (@functor.add_const.run.{0 0} (uniform_space.{0} (ordered_comm_ring.{0} pos)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_67719 (h0 : function.extfun Type ring) : @strong_rank_condition.{0} (metric_space.{0} congr_arg_kind) (@id.{1} (ring.{0} (metric_space.{0} congr_arg_kind)) (@function.extfun_app.{2 1} Type ring.{0} h0 (metric_space.{0} congr_arg_kind)))  := sorry --non-trivial
lemma new_lemma_67720 (h0 : function.extfun (Type 1) group) : @group.fg.{1} (has_neg_part.{1} Type) (@function.extfun_app.{3 2} (Type 1) group.{1} h0 (has_neg_part.{1} Type))  := sorry --non-trivial
lemma new_lemma_67721 (h0 : order_hom nat (topological_space (has_append string.iterator_imp))) : @t0_space.{0} (has_append.{0} string.iterator_imp) (@monotonic_sequence_limit.{0} (topological_space.{0} (has_append.{0} string.iterator_imp)) (@topological_space.partial_order.{0} (has_append.{0} string.iterator_imp)) h0)  := sorry --non-trivial
lemma new_lemma_67722 (h0 : function.extfun Type topological_space) : @preirreducible_space.{0} (simple_graph.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (simple_graph.{0} empty))  := sorry --non-trivial
lemma new_lemma_67723 (h0 : topological_space (generalized_boolean_algebra (has_Inf (has_pos_part (has_Inf (has_Inf real)))))) : preconnected_space (generalized_boolean_algebra (has_Inf (has_pos_part (has_Inf (has_Inf real))))) := sorry --non-trivial
lemma new_lemma_67724 (h0 : topological_space (semigroup (has_Inf linarith.comp))) : sequential_space (semigroup (has_Inf linarith.comp)) := sorry --non-trivial
lemma new_lemma_67725 (h0 : topological_space (topological_space reducibility_hints)) : totally_disconnected_space (topological_space reducibility_hints) := sorry --non-trivial
lemma new_lemma_67726 (h2 : measurable_space enat) (h3 : measure_theory.measure enat) : measure_theory.has_no_atoms h3 := sorry --non-trivial
lemma new_lemma_67727 (h0 : uniform_space (has_inter (option (option ennreal)))) : separated_space (has_inter (option (option ennreal))) := sorry --non-trivial
lemma new_lemma_67728 (h0 : group (has_ssubset (has_nnnorm fun_info))) : is_cyclic (has_ssubset (has_nnnorm fun_info)) := sorry --non-trivial
lemma new_lemma_67729 (h0 : not (uniform_space (has_compl reducibility_hints) -> false)) : @complete_space.{0} (has_compl.{0} reducibility_hints) (@classical.by_contradiction'.{1} (uniform_space.{0} (has_compl.{0} reducibility_hints)) h0)  := sorry --non-trivial
lemma new_lemma_67730 (h0 : function.extfun Type group) : @is_cyclic.{0} (has_pos_part.{0} pos) (@function.extfun_app.{2 1} Type group.{0} h0 (has_pos_part.{0} pos))  := sorry --non-trivial
lemma new_lemma_67731 (h0 : uniform_space (left_cancel_semigroup (semiring congr_arg_kind))) : separated_space (left_cancel_semigroup (semiring congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_67732 (h0 : not (list fun_info -> false)) : list.nodup (classical.by_contradiction' h0) := sorry --non-trivial
lemma new_lemma_67733 (h0 : group (boolean_algebra (comm_group (has_to_string (has_to_string unsigned))))) : group.fg (boolean_algebra (comm_group (has_to_string (has_to_string unsigned)))) := sorry --non-trivial
lemma new_lemma_67734 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @preconnected_space.{0} (cancel_monoid.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (cancel_monoid.{0} empty))  := sorry --non-trivial
lemma new_lemma_67735 (h0 : group (add_cancel_comm_monoid string.iterator_imp)) : is_cyclic (add_cancel_comm_monoid string.iterator_imp) := sorry --non-trivial
lemma new_lemma_67736 (h0 : function.extfun (nat -> Type) (function.extfun nat)) : @path_connected_space.{0} (has_pos_part.{0} pos) (@matrix.vec_empty.{0} (topological_space.{0} (has_pos_part.{0} pos)) (@function.extfun_app.{1 1} nat fin (@function.extfun_app.{2 1} (nat → Type) (function.extfun.{1 1} nat) h0 fin) (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_67737 (h0 : topological_space (simple_graph (has_add linarith.comp))) : sequential_space (simple_graph (has_add linarith.comp)) := sorry --non-trivial
lemma new_lemma_67738 (h0 : functor.comp topological_space boolean_algebra.core ennreal) : @sequential_space.{0} (boolean_algebra.core.{0} ennreal) (@functor.comp.run.{0 0 0} topological_space.{0} boolean_algebra.core.{0} ennreal h0)  := sorry --non-trivial
lemma new_lemma_67739 (h0 : topological_space (has_neg_part (has_add environment.implicit_infer_kind))) : totally_disconnected_space (has_neg_part (has_add environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_67740 (h0 : function.extfun Type (functor.add_const (ring (add_left_cancel_semigroup empty)))) : @rank_condition.{0} (add_left_cancel_semigroup.{0} empty) (@functor.add_const.run.{0 0} (ring.{0} (add_left_cancel_semigroup.{0} empty)) empty (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (ring.{0} (add_left_cancel_semigroup.{0} empty))) h0 empty))  := sorry --non-trivial
lemma new_lemma_67741 (h0 : functor.add_const (filter (comm_group Type)) Type) : countable_Inter_filter (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_67742 (h0 : functor.add_const (function.extfun Type topological_space) linarith.comp) : @totally_separated_space.{0} (has_neg.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) linarith.comp h0) (has_neg.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_67743 (h0 : topological_space (boolean_algebra (has_pos_part (finset pos)))) : discrete_topology (boolean_algebra (has_pos_part (finset pos))) := sorry --non-trivial
lemma new_lemma_67744 (h0 : add_group (add_comm_monoid (option num))) : is_add_cyclic (add_comm_monoid (option num)) := sorry --non-trivial
lemma new_lemma_67745 (h0 : function.extfun Type add_monoid) : @add_monoid.fg.{0} (canonically_ordered_monoid.{0} linarith.comp) (@function.extfun_app.{2 1} Type add_monoid.{0} h0 (canonically_ordered_monoid.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_67746 (h0 : uniform_space (has_add (add_left_cancel_monoid char))) : complete_space (has_add (add_left_cancel_monoid char)) := sorry --non-trivial
lemma new_lemma_67747 (h0 : topological_space (complete_distrib_lattice (ring (finset (ring linarith.comp))))) : normal_space (complete_distrib_lattice (ring (finset (ring linarith.comp)))) := sorry --non-trivial
lemma new_lemma_67748 (h0 : add_monoid (has_bot empty)) : add_monoid.fg (has_bot empty) := sorry --non-trivial
lemma new_lemma_67749 (h0 : functor.add_const (group (plift num)) empty) : @is_cyclic.{1} (plift.{1} num) (@functor.add_const.run.{1 0} (group.{1} (plift.{1} num)) empty h0)  := sorry --non-trivial
lemma new_lemma_67750 (h1 : ring (has_ssubset string_imp)) : is_domain (has_ssubset string_imp) := sorry --non-trivial
lemma new_lemma_67751 (h0 : not (add_group (add_monoid linarith.ineq) -> false)) : @is_add_cyclic.{0} (add_monoid.{0} linarith.ineq) (@classical.by_contradiction'.{1} (add_group.{0} (add_monoid.{0} linarith.ineq)) h0)  := sorry --non-trivial
lemma new_lemma_67752 (h0 : function.extfun Type filter) : countable_Inter_filter (function.extfun_app h0 (finset pos)) := sorry --non-trivial
lemma new_lemma_67753 (h0 : complete_lattice (has_inv to_additive.value_type)) : is_atomistic (has_inv to_additive.value_type) := sorry --non-trivial
lemma new_lemma_67754 (h0 : set (mul_one_class linarith.ineq -> fun_info)) : set.separates_points h0 := sorry --non-trivial
lemma new_lemma_67755 (h0 : functor.add_const (function.extfun (Type 1) add_monoid) pos) : @add_monoid.fg.{1} (generalized_boolean_algebra.{1} Type) (@function.extfun_app.{3 2} (Type 1) add_monoid.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) add_monoid.{1}) pos h0) (generalized_boolean_algebra.{1} Type))  := sorry --non-trivial
lemma new_lemma_67756 (h0 : topological_space (semi_normed_ring linarith.ineq)) : path_connected_space (semi_normed_ring linarith.ineq) := sorry --non-trivial
lemma new_lemma_67757 (h0 : prod (has_one (has_top num)) (has_one (has_top num))) : id_rel h0 := sorry --non-trivial
lemma new_lemma_67758 (h0 : list (has_add congr_arg_kind)) : palindrome h0 := sorry --non-trivial
lemma new_lemma_67759 (h0 : functor.add_const (function.extfun Type ring) Type) : @is_principal_ideal_ring.{0} (ordered_comm_monoid.{0} linarith.comp) (@function.extfun_app.{2 1} Type ring.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type ring.{0}) Type h0) (ordered_comm_monoid.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_67760 (h0 : semiring (boolean_algebra (comm_group Type))) : is_noetherian_ring (boolean_algebra (comm_group Type)) := sorry --non-trivial
lemma new_lemma_67761 (h0 : group (id (random_gen (random_gen (random_gen linarith.ineq))))) : normalizer_condition (id (random_gen (random_gen (random_gen linarith.ineq)))) := sorry --non-trivial
lemma new_lemma_67762 (h0 : finset (cancel_monoid (add_comm_monoid environment.implicit_infer_kind))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_67763 (h0 : function.extfun (Type 1) group) : @group.fg.{1} (normed_comm_ring.{1} Type) (@function.extfun_app.{3 2} (Type 1) group.{1} h0 (normed_comm_ring.{1} Type))  := sorry --non-trivial
lemma new_lemma_67764 (h0 : topological_space (boolean_algebra (normed_comm_ring pos))) : t1_space (boolean_algebra (normed_comm_ring pos)) := sorry --non-trivial
lemma new_lemma_67765 (h0 : group (has_top to_additive.value_type)) : group.fg (has_top to_additive.value_type) := sorry --non-trivial
lemma new_lemma_67766 (h0 : functor.add_const (ordered_comm_monoid (ordered_comm_monoid linarith.comp)) pos) : @has_exists_mul_of_le.{0} (ordered_comm_monoid.{0} linarith.comp) (@functor.add_const.run.{0 0} (ordered_comm_monoid.{0} (ordered_comm_monoid.{0} linarith.comp)) pos h0)  := sorry --non-trivial
lemma new_lemma_67767 (h0 : functor.add_const (monoid (comm_group linarith.comp)) pos) : @monoid.fg.{0} (comm_group.{0} linarith.comp) (@functor.add_const.run.{0 0} (monoid.{0} (comm_group.{0} linarith.comp)) pos h0)  := sorry --non-trivial
lemma new_lemma_67768 (h0 : function.extfun Type complete_lattice) : @is_atomistic.{0} (has_emptyc.{0} num) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (has_emptyc.{0} num))  := sorry --non-trivial
lemma new_lemma_67769 (h0 : uniform_space (has_div (has_ssubset linarith.ineq))) : complete_space (has_div (has_ssubset linarith.ineq)) := sorry --non-trivial
lemma new_lemma_67770 (h0 : functor.add_const (monoid (ring Type)) linarith.comp) : @monoid.fg.{1} (ring.{1} Type) (@functor.add_const.run.{1 0} (monoid.{1} (ring.{1} Type)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_67771 (h0 : add_monoid (pseudo_metric_space (option empty))) : add_monoid.fg (pseudo_metric_space (option empty)) := sorry --non-trivial
lemma new_lemma_67772 (h0 : not (function.extfun Type ring -> false)) : @rank_condition.{0} (complete_semilattice_Sup.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type ring.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type ring.{0}) h0) (complete_semilattice_Sup.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_67773 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : filter.ne_bot (function.extfun_app (function.extfun_app h0 filter) (with_bot string_imp)) := sorry --non-trivial
lemma new_lemma_67774 (h0 : topological_space (finset (has_neg_part pos))) : totally_separated_space (finset (has_neg_part pos)) := sorry --non-trivial
lemma new_lemma_67775 (h0 : functor.add_const (topological_space (comm_group environment.implicit_infer_kind)) name) : @discrete_topology.{0} (comm_group.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (comm_group.{0} environment.implicit_infer_kind)) name h0)  := sorry --non-trivial
lemma new_lemma_67776 (h0 : list (ring (has_neg linarith.comp))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_67777 (h0 : has_mem.mem (measurable_space linarith.comp) has_emptyc.emptyc) : @is_add_cyclic.{0} (measurable_space.{0} linarith.comp) (@finset.pi.empty.{1 0} Type add_group.{0} (measurable_space.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_67778 (h0 : functor.add_const (function.extfun Type group) Type) : @normalizer_condition.{0} (semigroup.{0} linarith.comp) (@function.extfun_app.{2 1} Type group.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type group.{0}) Type h0) (semigroup.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_67779 (h0 : complete_lattice (partial_order (semiring empty))) : is_atomistic (partial_order (semiring empty)) := sorry --non-trivial
lemma new_lemma_67780 (h0 : topological_space (add_comm_monoid (option (option (option (option (option unsigned))))))) : t1_space (add_comm_monoid (option (option (option (option (option unsigned)))))) := sorry --non-trivial
lemma new_lemma_67781 (h0 : function.extfun (Type 1) ring) : @strong_rank_condition.{1} (plift.{1} congr_arg_kind) (@function.extfun_app.{3 2} (Type 1) ring.{1} h0 (plift.{1} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_67782 (h0 : ordered_add_comm_monoid (has_pos_part (finset (has_Inf pos)))) : archimedean (has_pos_part (finset (has_Inf pos))) := sorry --non-trivial
lemma new_lemma_67783 (h0 : not (function.extfun Type ring -> false)) : @is_domain.{0} (with_one.{0} empty) (@function.extfun_app.{2 1} Type ring.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type ring.{0}) h0) (with_one.{0} empty))  := sorry --non-trivial
lemma new_lemma_67784 (h0 : group (has_zero (has_to_string (has_to_string name)))) : is_simple_group (has_zero (has_to_string (has_to_string name))) := sorry --non-trivial
lemma new_lemma_67785 (h0 : functor.add_const (topological_space (semigroup unsigned)) name) : @normal_space.{0} (semigroup.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (semigroup.{0} unsigned)) name h0)  := sorry --non-trivial
lemma new_lemma_67786 (h0 : function.extfun Type filter) : countable_Inter_filter (function.extfun_app h0 (ring pos)) := sorry --non-trivial
lemma new_lemma_67787 (h0 : fin has_zero.zero) : @preconnected_space.{0} (sub_neg_monoid.{0} linarith.comp) (@matrix.vec_empty.{0} (topological_space.{0} (sub_neg_monoid.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_67788 (h0 : functor.add_const (ring (ordered_ring empty)) (semiring (semiring empty))) : @rank_condition.{0} (ordered_ring.{0} empty) (@functor.add_const.run.{0 0} (ring.{0} (ordered_ring.{0} empty)) (semiring.{0} (semiring.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_67789 (h0 : list (has_Inf (has_pos_part linarith.comp))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_67790 (h0 : function.extfun nat fin) : @rank_condition.{0} (ordered_comm_monoid.{0} real) (@matrix.vec_empty.{0} (ring.{0} (ordered_comm_monoid.{0} real)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_67791 (h0 : functor.add_const (complete_lattice (comm_group pos)) (option (finset (has_add ennreal)))) : @is_atomistic.{0} (comm_group.{0} pos) (@functor.add_const.run.{0 0} (complete_lattice.{0} (comm_group.{0} pos)) (option.{0} (finset.{0} (has_add.{0} ennreal))) h0)  := sorry --non-trivial
lemma new_lemma_67792 (h0 : not (function.extfun Type group -> false)) : @normalizer_condition.{0} (linear_ordered_semiring.{0} empty) (@function.extfun_app.{2 1} Type group.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type group.{0}) h0) (linear_ordered_semiring.{0} empty))  := sorry --non-trivial
lemma new_lemma_67793 (h0 : functor.add_const (uniform_space (comm_group pos)) name) : @complete_space.{0} (comm_group.{0} pos) (@functor.add_const.run.{0 0} (uniform_space.{0} (comm_group.{0} pos)) name h0)  := sorry --non-trivial
lemma new_lemma_67794 (h0 : not (group (has_norm to_additive.value_type) -> false)) : @group.fg.{0} (has_norm.{0} to_additive.value_type) (@classical.by_contradiction'.{1} (group.{0} (has_norm.{0} to_additive.value_type)) h0)  := sorry --non-trivial
lemma new_lemma_67795 (h0 : function.extfun Type topological_space) : @irreducible_space.{0} (is_R_or_C.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (is_R_or_C.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_67796 (h0 : ring (finset (has_add pos))) : rank_condition (finset (has_add pos)) := sorry --non-trivial
lemma new_lemma_67797 (h0 : not (function.extfun Type add_monoid -> false)) : @add_monoid.fg.{0} (linear_ordered_semiring.{0} unsigned) (@function.extfun_app.{2 1} Type add_monoid.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type add_monoid.{0}) h0) (linear_ordered_semiring.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_67798 (h0 : topological_space (comm_group (add_cancel_monoid linarith.comp))) : preconnected_space (comm_group (add_cancel_monoid linarith.comp)) := sorry --non-trivial
lemma new_lemma_67799 (h0 : function.extfun nat fin) : @has_exists_mul_of_le.{1} (has_pos_part.{1} Type) (@matrix.vec_empty.{1} (ordered_comm_monoid.{1} (has_pos_part.{1} Type)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_67800 (h0 : ring (add_monoid to_additive.value_type)) : rank_condition (add_monoid to_additive.value_type) := sorry --non-trivial
lemma new_lemma_67801 (h0 : semiring (ring (has_neg name))) : is_noetherian_ring (ring (has_neg name)) := sorry --non-trivial
lemma new_lemma_67802 (h0 : add_monoid (boolean_algebra real)) : add_monoid.fg (boolean_algebra real) := sorry --non-trivial
lemma new_lemma_67803 (h0 : topological_space (normed_comm_ring (has_neg_part unsigned))) : sequential_space (normed_comm_ring (has_neg_part unsigned)) := sorry --non-trivial
lemma new_lemma_67804 (h1 : complete_lattice (has_top fun_info)) : is_compactly_generated (has_top fun_info) := sorry --non-trivial
lemma new_lemma_67805 (h0 : complete_lattice (ring (has_pos_part name))) : complete_lattice.is_Sup_finite_compact (ring (has_pos_part name)) := sorry --non-trivial
lemma new_lemma_67806 (h0 : function.extfun Type group) : @is_cyclic.{0} (denumerable.{0} string_imp) (@function.extfun_app.{2 1} Type group.{0} h0 (denumerable.{0} string_imp))  := sorry --non-trivial
lemma new_lemma_67807 (h0 : not (filter (metric_space congr_arg_kind) -> false)) : filter.ne_bot (classical.by_contradiction' h0) := sorry --non-trivial
lemma new_lemma_67808 (h0 : uniform_space (has_add (has_top (has_add (complete_semilattice_Sup string_imp))))) : complete_space (has_add (has_top (has_add (complete_semilattice_Sup string_imp)))) := sorry --non-trivial
lemma new_lemma_67809 (h0 : topological_space (has_compl fun_info)) (h1 : not (add_group (has_compl fun_info) -> false)) : @topological_add_group.{0} (has_compl.{0} fun_info) h0 (@classical.by_contradiction'.{1} (add_group.{0} (has_compl.{0} fun_info)) h1)  := sorry --non-trivial
lemma new_lemma_67810 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @complete_space.{0} (ordered_comm_monoid.{0} linarith.comp) (@function.extfun_app.{2 1} Type uniform_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 uniform_space.{0}) (ordered_comm_monoid.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_67811 (h0 : group (semiring (has_inv linarith.ineq))) : normalizer_condition (semiring (has_inv linarith.ineq)) := sorry --non-trivial
lemma new_lemma_67812 (h0 : function.extfun Type ring) : @is_domain.{0} (canonically_ordered_monoid.{0} real) (@function.extfun_app.{2 1} Type ring.{0} h0 (canonically_ordered_monoid.{0} real))  := sorry --non-trivial
lemma new_lemma_67813 (h1 : add_group (semi_normed_comm_ring reducibility_hints)) : is_add_cyclic (semi_normed_comm_ring reducibility_hints) := sorry --non-trivial
lemma new_lemma_67814 (h0 : complete_lattice (boolean_algebra.core Type)) : complete_lattice.is_Sup_finite_compact (boolean_algebra.core Type) := sorry --non-trivial
lemma new_lemma_67815 (h0 : function.extfun Type group) : @is_cyclic.{0} (complete_distrib_lattice.{0} ennreal) (@function.extfun_app.{2 1} Type group.{0} h0 (complete_distrib_lattice.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_67816 (h0 : topological_space (add_cancel_monoid (ring (has_neg (has_neg Type))))) : normal_space (add_cancel_monoid (ring (has_neg (has_neg Type)))) := sorry --non-trivial
lemma new_lemma_67817 (h0 : topological_space (linear_ordered_add_comm_group to_additive.value_type)) : irreducible_space (linear_ordered_add_comm_group to_additive.value_type) := sorry --non-trivial
lemma new_lemma_67818 (h0 : function.extfun Type topological_space) (h1 : set (boolean_algebra.core ennreal)) : @is_seq_compact.{0} (boolean_algebra.core.{0} ennreal) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (boolean_algebra.core.{0} ennreal)) h1  := sorry --non-trivial
lemma new_lemma_67819 (h0 : ring (denumerable (has_nnnorm (has_nnnorm fun_info)))) : rank_condition (denumerable (has_nnnorm (has_nnnorm fun_info))) := sorry --non-trivial
lemma new_lemma_67820 (h0 : group (comm_ring (mul_one_class fun_info))) : is_cyclic (comm_ring (mul_one_class fun_info)) := sorry --non-trivial
lemma new_lemma_67821 (h0 : topological_space (add_comm_monoid (has_add name))) : topological_space.separable_space (add_comm_monoid (has_add name)) := sorry --non-trivial
lemma new_lemma_67822 (h0 : add_monoid (finset empty)) : add_monoid.fg (finset empty) := sorry --non-trivial
lemma new_lemma_67823 (h0 : not (function.extfun (Type 1) filter -> false)) : filter.ne_bot (function.extfun_app (classical.by_contradiction' h0) (plift num)) := sorry --non-trivial
lemma new_lemma_67824 (h0 : cancel_comm_monoid_with_zero real) : unique_factorization_monoid real := sorry --non-trivial
lemma new_lemma_67825 (h0 : function.extfun (finset (Type -> Type)) (has_mem.mem complete_lattice)) : @complete_lattice.is_Sup_finite_compact.{0} (semiring.{0} fun_info) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) complete_lattice.{0} (@function.extfun_app.{2 0} (finset.{1} (Type → Type)) (@has_mem.mem.{1 1} (Type → Type) (finset.{1} (Type → Type)) (@finset.has_mem.{1} (Type → Type)) complete_lattice.{0}) h0 (@has_emptyc.emptyc.{1} (finset.{1} (Type → Type)) (@finset.has_emptyc.{1} (Type → Type))))) (semiring.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_67826 (h0 : topological_space (uniform_space (mul_one_class linarith.ineq))) : totally_disconnected_space (uniform_space (mul_one_class linarith.ineq)) := sorry --non-trivial
lemma new_lemma_67827 (h0 : functor.comp topological_space add_cancel_monoid (finset environment.implicit_infer_kind)) : @t1_space.{0} (add_cancel_monoid.{0} (finset.{0} environment.implicit_infer_kind)) (@functor.comp.run.{0 0 0} topological_space.{0} add_cancel_monoid.{0} (finset.{0} environment.implicit_infer_kind) h0)  := sorry --non-trivial
lemma new_lemma_67828 (h0 : functor.add_const (monoid (boolean_algebra.core unsigned)) unsigned) : @monoid.fg.{0} (boolean_algebra.core.{0} unsigned) (@functor.add_const.run.{0 0} (monoid.{0} (boolean_algebra.core.{0} unsigned)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_67829 (h1 : topological_space (measurable_space to_additive.value_type)) : locally_compact_space (measurable_space to_additive.value_type) := sorry --non-trivial
lemma new_lemma_67830 (h0 : topological_space (has_pos_part name)) : totally_separated_space (has_pos_part name) := sorry --non-trivial
lemma new_lemma_67831 (h0 : cancel_comm_monoid_with_zero (has_add (option (option (option (option (option congr_arg_kind))))))) : unique_factorization_monoid (has_add (option (option (option (option (option congr_arg_kind)))))) := sorry --non-trivial
lemma new_lemma_67832 (h0 : topological_space (normed_group (has_norm (has_norm linarith.comp_source)))) : irreducible_space (normed_group (has_norm (has_norm linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_67833 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @t1_space.{0} (ring.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (ring.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_67834 (h0 : functor.add_const (group (sub_neg_monoid name)) (has_neg name)) : @is_cyclic.{0} (sub_neg_monoid.{0} name) (@functor.add_const.run.{0 0} (group.{0} (sub_neg_monoid.{0} name)) (has_neg.{0} name) h0)  := sorry --non-trivial
lemma new_lemma_67835 (h0 : filter (has_neg_part (option (mul_zero_class (mul_zero_class name))))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_67836 (h0 : not (ring (has_nnnorm linarith.ineq) -> false)) : @is_domain.{0} (has_nnnorm.{0} linarith.ineq) (@classical.by_contradiction'.{1} (ring.{0} (has_nnnorm.{0} linarith.ineq)) h0)  := sorry --non-trivial
lemma new_lemma_67837 (h0 : topological_space (cancel_monoid (finset ennreal))) : path_connected_space (cancel_monoid (finset ennreal)) := sorry --non-trivial
lemma new_lemma_67838 (h0 : topological_space (generalized_boolean_algebra (has_pos_part real))) : path_connected_space (generalized_boolean_algebra (has_pos_part real)) := sorry --non-trivial
lemma new_lemma_67839 (h0 : functor.add_const (ring (ordered_ring unsigned)) empty) : @rank_condition.{0} (ordered_ring.{0} unsigned) (@functor.add_const.run.{0 0} (ring.{0} (ordered_ring.{0} unsigned)) empty h0)  := sorry --non-trivial
lemma new_lemma_67840 (h0 : functor.add_const (topological_space (has_neg name)) ennreal) : @normal_space.{0} (has_neg.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (has_neg.{0} name)) ennreal h0)  := sorry --non-trivial
lemma new_lemma_67841 (h1 : topological_space (distrib_lattice fun_info)) : totally_disconnected_space (distrib_lattice fun_info) := sorry --non-trivial
lemma new_lemma_67842 (h0 : fin has_zero.zero) : @totally_disconnected_space.{0} (comm_semigroup.{0} real) (@matrix.vec_empty.{0} (topological_space.{0} (comm_semigroup.{0} real)) h0)  := sorry --non-trivial
lemma new_lemma_67843 (h0 : functor.add_const (semiring (has_zero pos)) pos) : @is_noetherian_ring.{0} (has_zero.{0} pos) (@functor.add_const.run.{0 0} (semiring.{0} (has_zero.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_67844 (h0 : function.extfun Type (functor.add_const (topological_space (option empty)))) : @irreducible_space.{0} (option.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (option.{0} empty)) empty (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (topological_space.{0} (option.{0} empty))) h0 empty))  := sorry --non-trivial
lemma new_lemma_67845 (h0 : not (uniform_space (option unsigned) -> false)) : @separated_space.{0} (option.{0} unsigned) (@classical.by_contradiction'.{1} (uniform_space.{0} (option.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_67846 (h0 : complete_lattice (has_zero (boolean_algebra Type))) : is_atomistic (has_zero (boolean_algebra Type)) := sorry --non-trivial
lemma new_lemma_67847 (h0 : functor.add_const (monoid (add_comm_monoid unsigned)) pos) : @monoid.fg.{0} (add_comm_monoid.{0} unsigned) (@functor.add_const.run.{0 0} (monoid.{0} (add_comm_monoid.{0} unsigned)) pos h0)  := sorry --non-trivial
lemma new_lemma_67848 (h0 : function.extfun Type (functor.add_const (finset auto.case_option))) : finset.nonempty (functor.add_const.run (function.extfun_app h0 ennreal)) := sorry --non-trivial
lemma new_lemma_67849 (h0 : functor.add_const (complete_lattice (semigroup pos)) Type) : @complete_lattice.is_Sup_finite_compact.{0} (semigroup.{0} pos) (@functor.add_const.run.{0 1} (complete_lattice.{0} (semigroup.{0} pos)) Type h0)  := sorry --non-trivial
lemma new_lemma_67850 (h0 : fun_info -> fun_info -> Prop) : is_per fun_info h0 := sorry --non-trivial
lemma new_lemma_67851 (h0 : function.extfun Type uniform_space) : @complete_space.{0} (random_gen.{0} string_imp) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (random_gen.{0} string_imp))  := sorry --non-trivial
lemma new_lemma_67852 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @group.fg.{0} (has_nnnorm.{0} fun_info) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (has_nnnorm.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_67853 (h0 : add_monoid (ordered_comm_monoid (has_add Type))) : add_monoid.fg (ordered_comm_monoid (has_add Type)) := sorry --non-trivial
lemma new_lemma_67854 (h0 : ring (semiring (semiring unsigned))) : is_domain (semiring (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_67855 (h0 : functor.add_const (ordered_add_comm_monoid (finset Type)) (has_add Type)) : @archimedean.{1} (finset.{1} Type) (@functor.add_const.run.{1 1} (ordered_add_comm_monoid.{1} (finset.{1} Type)) (has_add.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_67856 (h0 : topological_space (has_zero (has_add ennreal))) : normal_space (has_zero (has_add ennreal)) := sorry --non-trivial
lemma new_lemma_67857 (h1 : complete_lattice (div_inv_monoid linarith.comp_source)) : complete_lattice.is_Sup_finite_compact (div_inv_monoid linarith.comp_source) := sorry --non-trivial
lemma new_lemma_67858 (h0 : add_monoid (partial_order (has_top (semiring empty)))) : add_monoid.fg (partial_order (has_top (semiring empty))) := sorry --non-trivial
lemma new_lemma_67859 (h0 : group (has_bot unsigned)) : is_cyclic (has_bot unsigned) := sorry --non-trivial
lemma new_lemma_67860 (h0 : monoid (ordered_ring (option (option (option unsigned))))) : monoid.fg (ordered_ring (option (option (option unsigned)))) := sorry --non-trivial
lemma new_lemma_67861 (h0 : group (has_nnnorm (has_nnnorm linarith.comp_source))) : group.fg (has_nnnorm (has_nnnorm linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_67862 (h0 : functor.comp list add_cancel_monoid Type) : palindrome (functor.comp.run h0) := sorry --non-trivial
lemma new_lemma_67863 (h0 : ring (is_R_or_C (option empty))) : is_domain (is_R_or_C (option empty)) := sorry --non-trivial
lemma new_lemma_67864 (h0 : topological_space (has_le linarith.ineq)) : t0_space (has_le linarith.ineq) := sorry --non-trivial
lemma new_lemma_67865 (h0 : function.extfun (Type 1) ring) : @is_principal_ideal_ring.{1} (generalized_boolean_algebra.{1} Type) (@function.extfun_app.{3 2} (Type 1) ring.{1} h0 (generalized_boolean_algebra.{1} Type))  := sorry --non-trivial
lemma new_lemma_67866 (h1 : function.extfun Type ring) : @is_domain.{0} (with_one.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type ring.{0} h1 (with_one.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_67867 (h0 : topological_space empty) : path_connected_space empty := sorry --non-trivial
lemma new_lemma_67868 (h0 : list (distrib_lattice (has_nnnorm (random_gen linarith.comp_source)))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_67869 (h0 : add_group (semiring (has_norm (has_top (has_top fun_info))))) : is_add_cyclic (semiring (has_norm (has_top (has_top fun_info)))) := sorry --non-trivial
lemma new_lemma_67870 (h0 : ring (has_pos_part real)) : is_domain (has_pos_part real) := sorry --non-trivial
lemma new_lemma_67871 (h1 : function.extfun Type complete_lattice) : @is_compactly_generated.{0} (random_gen.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type complete_lattice.{0} h1 (random_gen.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_67872 (h1 : complete_lattice (random_gen congr_arg_kind)) : is_compactly_generated (random_gen congr_arg_kind) := sorry --non-trivial
lemma new_lemma_67873 (h0 : topological_space (normed_comm_ring (has_nndist pos))) : locally_compact_space (normed_comm_ring (has_nndist pos)) := sorry --non-trivial
lemma new_lemma_67874 (h0 : functor.add_const (complete_lattice (add_comm_monoid pos)) pos) : @is_atomistic.{0} (add_comm_monoid.{0} pos) (@functor.add_const.run.{0 0} (complete_lattice.{0} (add_comm_monoid.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_67875 (h0 : complete_lattice (add_comm_semigroup (add_comm_semigroup fun_info))) : complete_lattice.is_Sup_finite_compact (add_comm_semigroup (add_comm_semigroup fun_info)) := sorry --non-trivial
lemma new_lemma_67876 (h0 : topological_space (has_neg_part name)) : regular_space (has_neg_part name) := sorry --non-trivial
lemma new_lemma_67877 (h0 : functor.add_const Prop (has_to_string unsigned)) : functor.add_const.run h0 := sorry --non-trivial
lemma new_lemma_67878 (h0 : topological_space (linear_ordered_comm_monoid_with_zero (option (option empty)))) : discrete_topology (linear_ordered_comm_monoid_with_zero (option (option empty))) := sorry --non-trivial
lemma new_lemma_67879 (h0 : measurable_space (has_pos_part ennreal)) (h1 : has_mul (has_pos_part ennreal)) (h2 : measure_theory.measure (has_pos_part ennreal)) : measure_theory.measure.is_mul_left_invariant h2 := sorry --non-trivial
lemma new_lemma_67880 (h0 : complete_lattice (has_compl reducibility_hints)) : is_compactly_generated (has_compl reducibility_hints) := sorry --non-trivial
lemma new_lemma_67881 (h0 : topological_space (ordered_cancel_add_comm_monoid (option ennreal))) : loc_path_connected_space (ordered_cancel_add_comm_monoid (option ennreal)) := sorry --non-trivial
lemma new_lemma_67882 (h0 : topological_space (as_linear_order (option unsigned))) : totally_disconnected_space (as_linear_order (option unsigned)) := sorry --non-trivial
lemma new_lemma_67883 (h0 : measurable_space (measure_theory.measure_space num)) (h1 : not (has_add (measure_theory.measure_space num) -> false)) : @has_measurable_add.{0} (measure_theory.measure_space.{0} num) h0 (@classical.by_contradiction'.{1} (has_add.{0} (measure_theory.measure_space.{0} num)) h1)  := sorry --non-trivial
lemma new_lemma_67884 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : countable_Inter_filter (function.extfun_app (function.extfun_app h0 filter) (has_neg pos)) := sorry --non-trivial
lemma new_lemma_67885 (h0 : functor.add_const (topological_space (normed_comm_ring ennreal)) name) : @irreducible_space.{0} (normed_comm_ring.{0} ennreal) (@functor.add_const.run.{0 0} (topological_space.{0} (normed_comm_ring.{0} ennreal)) name h0)  := sorry --non-trivial
lemma new_lemma_67886 (h0 : topological_space (has_add (has_neg (ring (has_add (has_add (finset Type))))))) : loc_path_connected_space (has_add (has_neg (ring (has_add (has_add (finset Type)))))) := sorry --non-trivial
lemma new_lemma_67887 (h0 : function.extfun Type filter) : countable_Inter_filter (function.extfun_app h0 (add_comm_monoid num)) := sorry --non-trivial
lemma new_lemma_67888 (h0 : ring (with_one num)) : strong_rank_condition (with_one num) := sorry --non-trivial
lemma new_lemma_67889 (h0 : functor.add_const (add_monoid (omega_complete_partial_order congr_arg_kind)) unsigned) : @add_monoid.fg.{0} (omega_complete_partial_order.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (add_monoid.{0} (omega_complete_partial_order.{0} congr_arg_kind)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_67890 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_atomistic.{0} (comm_group.{0} ennreal) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (comm_group.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_67891 (h0 : group (boolean_algebra.core (finset (has_add (has_add name))))) : normalizer_condition (boolean_algebra.core (finset (has_add (has_add name)))) := sorry --non-trivial
lemma new_lemma_67892 (h0 : topological_space (semigroup (has_neg pos))) : preirreducible_space (semigroup (has_neg pos)) := sorry --non-trivial
lemma new_lemma_67893 (h0 : ring (nondiscrete_normed_field environment.projection_info)) : is_domain (nondiscrete_normed_field environment.projection_info) := sorry --non-trivial
lemma new_lemma_67894 (h0 : topological_space (has_to_string (has_to_string (has_to_string pos)))) : normal_space (has_to_string (has_to_string (has_to_string pos))) := sorry --non-trivial
lemma new_lemma_67895 (h1 : topological_space (distrib reducibility_hints)) : path_connected_space (distrib reducibility_hints) := sorry --non-trivial
lemma new_lemma_67896 (h0 : group (plift empty)) : is_cyclic (plift empty) := sorry --non-trivial
lemma new_lemma_67897 (h0 : monoid (ordered_comm_ring (has_add (has_Inf linarith.comp)))) : monoid.fg (ordered_comm_ring (has_add (has_Inf linarith.comp))) := sorry --non-trivial
lemma new_lemma_67898 (h0 : add_group (sub_neg_monoid (has_Inf (has_add (has_Inf Type))))) : is_add_cyclic (sub_neg_monoid (has_Inf (has_add (has_Inf Type)))) := sorry --non-trivial
lemma new_lemma_67899 (h0 : topological_space (has_bot Type)) : path_connected_space (has_bot Type) := sorry --non-trivial
lemma new_lemma_67900 (h0 : topological_space (finset congr_arg_kind)) : discrete_topology (finset congr_arg_kind) := sorry --non-trivial
lemma new_lemma_67901 (h0 : filter (comm_group (option pos))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_67902 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @group.fg.{0} (linear_ordered_add_comm_group.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (linear_ordered_add_comm_group.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_67903 (h0 : add_group (finset (has_nndist Type))) : is_add_cyclic (finset (has_nndist Type)) := sorry --non-trivial
lemma new_lemma_67904 (h0 : functor.add_const (topological_space (option pos)) unsigned) : @topological_space.separable_space.{0} (option.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (option.{0} pos)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_67905 (h0 : topological_space (ordered_ring empty)) : topological_space.separable_space (ordered_ring empty) := sorry --non-trivial
lemma new_lemma_67906 (h1 : not (ring (linear_ordered_add_comm_group char) -> false)) : @is_domain.{0} (linear_ordered_add_comm_group.{0} char) (@classical.by_contradiction'.{1} (ring.{0} (linear_ordered_add_comm_group.{0} char)) h1)  := sorry --non-trivial
lemma new_lemma_67907 (h0 : functor.add_const (function.extfun Type topological_space) pos) : @topological_space.separable_space.{0} (has_to_string.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) pos h0) (has_to_string.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_67908 (h0 : topological_space (option congr_arg_kind)) : normal_space (option congr_arg_kind) := sorry --non-trivial
lemma new_lemma_67909 (h0 : topological_space (ordered_cancel_add_comm_monoid (option (option (option empty))))) : t0_space (ordered_cancel_add_comm_monoid (option (option (option empty)))) := sorry --non-trivial
lemma new_lemma_67910 (h1 : ring (has_top string_imp)) : is_domain (has_top string_imp) := sorry --non-trivial
lemma new_lemma_67911 (h0 : functor.add_const (ordered_add_comm_monoid (ring pos)) pos) : @archimedean.{0} (ring.{0} pos) (@functor.add_const.run.{0 0} (ordered_add_comm_monoid.{0} (ring.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_67912 (h0 : ring (with_one linarith.comp_source)) : is_domain (with_one linarith.comp_source) := sorry --non-trivial
lemma new_lemma_67913 (h0 : not (list (random_gen linarith.comp_source) -> false)) : list.nodup (classical.by_contradiction' h0) := sorry --non-trivial
lemma new_lemma_67914 (h0 : functor.add_const (function.extfun Type topological_space) real) : @path_connected_space.{0} (comm_semigroup.{0} real) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) real h0) (comm_semigroup.{0} real))  := sorry --non-trivial
lemma new_lemma_67915 (h0 : ring (has_norm linarith.comp_source)) : strong_rank_condition (has_norm linarith.comp_source) := sorry --non-trivial
lemma new_lemma_67916 (h0 : functor.add_const (topological_space (ordered_comm_ring name)) pos) : @locally_compact_space.{0} (ordered_comm_ring.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (ordered_comm_ring.{0} name)) pos h0)  := sorry --non-trivial
lemma new_lemma_67917 (h0 : topological_space (add_left_cancel_semigroup (semiring empty))) : loc_path_connected_space (add_left_cancel_semigroup (semiring empty)) := sorry --non-trivial
lemma new_lemma_67918 (h0 : topological_space (has_add (has_add pos))) : totally_disconnected_space (has_add (has_add pos)) := sorry --non-trivial
lemma new_lemma_67919 (h0 : filter (normed_group congr_arg_kind)) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_67920 (h0 : function.extfun Type ordered_comm_monoid) : @has_exists_mul_of_le.{0} (ordered_comm_monoid.{0} pos) (@function.extfun_app.{2 1} Type ordered_comm_monoid.{0} h0 (ordered_comm_monoid.{0} pos))  := sorry --non-trivial
lemma new_lemma_67921 (h0 : group (boolean_algebra (finset Type))) : is_simple_group (boolean_algebra (finset Type)) := sorry --non-trivial
lemma new_lemma_67922 (h0 : function.extfun Type (functor.comp topological_space complete_distrib_lattice)) : @discrete_topology.{0} (complete_distrib_lattice.{0} ennreal) (@functor.comp.run.{0 0 0} topological_space.{0} complete_distrib_lattice.{0} ennreal (@function.extfun_app.{2 1} Type (functor.comp.{0 0 0} topological_space.{0} complete_distrib_lattice.{0}) h0 ennreal))  := sorry --non-trivial
lemma new_lemma_67923 (h0 : topological_space (canonically_ordered_add_monoid (option (option (option (option empty)))))) : normal_space (canonically_ordered_add_monoid (option (option (option (option empty))))) := sorry --non-trivial
lemma new_lemma_67924 (h0 : function.extfun Type topological_space) : @locally_compact_space.{0} (comm_ring.{0} fun_info) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (comm_ring.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_67925 (h0 : ring (complete_distrib_lattice environment.implicit_infer_kind)) : strong_rank_condition (complete_distrib_lattice environment.implicit_infer_kind) := sorry --non-trivial
lemma new_lemma_67926 (h0 : complete_lattice (left_cancel_monoid (semiring num))) : is_compactly_generated (left_cancel_monoid (semiring num)) := sorry --non-trivial
lemma new_lemma_67927 (h0 : functor.add_const (finset (non_unital_non_assoc_ring unsigned)) empty) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_67928 (h0 : functor.add_const (ring (add_comm_monoid Type)) linarith.comp) : @is_principal_ideal_ring.{1} (add_comm_monoid.{1} Type) (@functor.add_const.run.{1 0} (ring.{1} (add_comm_monoid.{1} Type)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_67929 (h0 : functor.add_const (ring (boolean_algebra.core unsigned)) Type) : @strong_rank_condition.{0} (boolean_algebra.core.{0} unsigned) (@functor.add_const.run.{0 1} (ring.{0} (boolean_algebra.core.{0} unsigned)) Type h0)  := sorry --non-trivial
lemma new_lemma_67930 (h0 : monoid_with_zero (linear_ordered_field pos) -> monoid_with_zero (linear_ordered_field pos) -> Prop) : is_symm (monoid_with_zero (linear_ordered_field pos)) h0 := sorry --non-trivial
lemma new_lemma_67931 (h0 : semiring (has_top (semiring (semiring congr_arg_kind)))) : is_noetherian_ring (has_top (semiring (semiring congr_arg_kind))) := sorry --non-trivial
lemma new_lemma_67932 (h0 : functor.add_const (topological_space (boolean_algebra Type)) (has_to_string pos)) : @preconnected_space.{1} (boolean_algebra.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (boolean_algebra.{1} Type)) (has_to_string.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_67933 (h0 : ring (monoid_with_zero congr_arg_kind)) : strong_rank_condition (monoid_with_zero congr_arg_kind) := sorry --non-trivial
lemma new_lemma_67934 (h0 : complete_lattice (add_comm_monoid (option name))) : complete_lattice.is_Sup_finite_compact (add_comm_monoid (option name)) := sorry --non-trivial
lemma new_lemma_67935 (h0 : function.extfun Type ring) : @rank_condition.{0} (has_nndist.{0} name) (@function.extfun_app.{2 1} Type ring.{0} h0 (has_nndist.{0} name))  := sorry --non-trivial
lemma new_lemma_67936 (h0 : functor.add_const (monoid (complete_distrib_lattice Type)) (has_add Type)) : @monoid.fg.{1} (complete_distrib_lattice.{1} Type) (@functor.add_const.run.{1 1} (monoid.{1} (complete_distrib_lattice.{1} Type)) (has_add.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_67937 (h0 : topological_space (simple_graph Type)) : regular_space (simple_graph Type) := sorry --non-trivial
lemma new_lemma_67938 (h0 : functor.comp ordered_add_comm_monoid has_neg_part unsigned) : @archimedean.{0} (has_neg_part.{0} unsigned) (@functor.comp.run.{0 0 0} ordered_add_comm_monoid.{0} has_neg_part.{0} unsigned h0)  := sorry --non-trivial
lemma new_lemma_67939 (h0 : topological_space (distrib (mul_one_class (comm_ring fun_info)))) : t0_space (distrib (mul_one_class (comm_ring fun_info))) := sorry --non-trivial
lemma new_lemma_67940 (h0 : ring (monoid empty)) : strong_rank_condition (monoid empty) := sorry --non-trivial
lemma new_lemma_67941 (h0 : not (topological_space (plift empty) -> false)) : @preirreducible_space.{1} (plift.{1} empty) (@classical.by_contradiction'.{2} (topological_space.{1} (plift.{1} empty)) h0)  := sorry --non-trivial
lemma new_lemma_67942 (h1 : not (ring (has_nnnorm linarith.comp_source) -> false)) : @rank_condition.{0} (has_nnnorm.{0} linarith.comp_source) (@classical.by_contradiction'.{1} (ring.{0} (has_nnnorm.{0} linarith.comp_source)) h1)  := sorry --non-trivial
lemma new_lemma_67943 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_domain.{0} (linear_ordered_semiring.{0} unsigned) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (linear_ordered_semiring.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_67944 (h0 : functor.add_const (complete_lattice (has_add environment.implicit_infer_kind)) Type) : @is_compactly_generated.{0} (has_add.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 1} (complete_lattice.{0} (has_add.{0} environment.implicit_infer_kind)) Type h0)  := sorry --non-trivial
lemma new_lemma_67945 (h0 : fin has_zero.zero) : @preconnected_space.{1} (boolean_algebra.{1} Type) (@matrix.vec_empty.{1} (topological_space.{1} (boolean_algebra.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_67946 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : t0_space real := sorry --non-trivial
lemma new_lemma_67947 (h0 : function.extfun Type ring) : @rank_condition.{0} (complete_semilattice_Sup.{0} fun_info) (@function.extfun_app.{2 1} Type ring.{0} h0 (complete_semilattice_Sup.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_67948 (h0 : topological_space (has_nndist (mul_zero_class name))) : locally_compact_space (has_nndist (mul_zero_class name)) := sorry --non-trivial
lemma new_lemma_67949 (h1 h2 : multiset (add_comm_semigroup (normed_field (normed_field (normed_field std_gen))))) : multiset.subset h1 h2 := sorry --non-trivial
lemma new_lemma_67950 (h2 : num -> num -> Prop) : is_antisymm num h2 := sorry --non-trivial
lemma new_lemma_67951 (h0 : function.extfun Type monoid) : @monoid.fg.{0} (linear_ordered_comm_group.{0} empty) (@function.extfun_app.{2 1} Type monoid.{0} h0 (linear_ordered_comm_group.{0} empty))  := sorry --non-trivial
lemma new_lemma_67952 (h0 : topological_space (has_pos_part (ring Type))) : path_connected_space (has_pos_part (ring Type)) := sorry --non-trivial
lemma new_lemma_67953 (h0 : functor.add_const (topological_space (add_comm_monoid name)) pos) : @regular_space.{0} (add_comm_monoid.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (add_comm_monoid.{0} name)) pos h0)  := sorry --non-trivial
lemma new_lemma_67954 (h0 : group (comm_semigroup name)) : is_simple_group (comm_semigroup name) := sorry --non-trivial
lemma new_lemma_67955 (h0 : functor.add_const (finset (has_Inf pos)) (ring (ring linarith.comp))) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_67956 (h0 : ring (has_one (has_top (semiring unsigned)))) : strong_rank_condition (has_one (has_top (semiring unsigned))) := sorry --non-trivial
lemma new_lemma_67957 (h0 : topological_space (fintype (linear_ordered_add_comm_group char))) : totally_disconnected_space (fintype (linear_ordered_add_comm_group char)) := sorry --non-trivial
lemma new_lemma_67958 (h0 : function.extfun Type topological_space) : @totally_separated_space.{0} (has_Sup.{0} (option.{0} empty)) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_Sup.{0} (option.{0} empty)))  := sorry --non-trivial
lemma new_lemma_67959 (h0 : functor.add_const (function.extfun (Type 1) filter) Type) : countable_Inter_filter (function.extfun_app (functor.add_const.run h0) (boolean_algebra Type)) := sorry --non-trivial
lemma new_lemma_67960 (h0 : add_group (has_lt (mul_one_class enat))) : is_add_cyclic (has_lt (mul_one_class enat)) := sorry --non-trivial
lemma new_lemma_67961 (h0 : ring (with_zero (has_nnnorm linarith.comp_source))) : strong_rank_condition (with_zero (has_nnnorm linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_67962 (h3 : uniform_space fun_info) : complete_space fun_info := sorry --non-trivial
lemma new_lemma_67963 (h0 : functor.add_const (function.extfun Type semiring) Type) : @is_noetherian_ring.{0} (has_nndist.{0} pos) (@function.extfun_app.{2 1} Type semiring.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type semiring.{0}) Type h0) (has_nndist.{0} pos))  := sorry --non-trivial
lemma new_lemma_67964 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @monoid.fg.{0} (boolean_algebra.core.{0} linarith.comp) (@function.extfun_app.{2 1} Type monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 monoid.{0}) (boolean_algebra.core.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_67965 (h0 : function.extfun Type group) : @group.fg.{0} (has_norm.{0} string_imp) (@function.extfun_app.{2 1} Type group.{0} h0 (has_norm.{0} string_imp))  := sorry --non-trivial
lemma new_lemma_67966 (h0 : group (linear_ordered_add_comm_group (random_gen (random_gen (random_gen (random_gen char)))))) : group.fg (linear_ordered_add_comm_group (random_gen (random_gen (random_gen (random_gen char))))) := sorry --non-trivial
lemma new_lemma_67967 (h0 : uniform_space to_additive.value_type) : complete_space to_additive.value_type := sorry --non-trivial
lemma new_lemma_67968 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @add_monoid.fg.{0} (has_bot.{0} pos) (@function.extfun_app.{2 1} Type add_monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 add_monoid.{0}) (has_bot.{0} pos))  := sorry --non-trivial
lemma new_lemma_67969 (h0 : topological_space (add_comm_semigroup (add_comm_semigroup std_gen))) : totally_disconnected_space (add_comm_semigroup (add_comm_semigroup std_gen)) := sorry --non-trivial
lemma new_lemma_67970 (h1 : complete_lattice (topological_space string_imp)) : is_compactly_generated (topological_space string_imp) := sorry --non-trivial
lemma new_lemma_67971 (h0 : not (ring (encodable to_additive.value_type) -> false)) : @strong_rank_condition.{0} (encodable.{0} to_additive.value_type) (@classical.by_contradiction'.{1} (ring.{0} (encodable.{0} to_additive.value_type)) h0)  := sorry --non-trivial
lemma new_lemma_67972 (h0 : has_mem.mem (id congr_arg_kind) has_emptyc.emptyc) : @is_cyclic.{0} (@id.{2} Type congr_arg_kind) (@finset.pi.empty.{1 0} Type group.{0} (@id.{2} Type congr_arg_kind) h0)  := sorry --non-trivial
lemma new_lemma_67973 (h2 : ring (has_top fun_info)) : strong_rank_condition (has_top fun_info) := sorry --non-trivial
lemma new_lemma_67974 (h0 : topological_space (has_top (random_gen (random_gen (random_gen (random_gen linarith.comp_source)))))) : irreducible_space (has_top (random_gen (random_gen (random_gen (random_gen linarith.comp_source))))) := sorry --non-trivial
lemma new_lemma_67975 (h0 : functor.add_const (topological_space (semigroup linarith.comp)) (has_zero linarith.comp)) : @discrete_topology.{0} (semigroup.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (semigroup.{0} linarith.comp)) (has_zero.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_67976 (h0 : function.extfun ((Type -> Type) -> Type 1) (function.extfun (Type -> Type))) : @group.fg.{0} (has_norm.{0} string_imp) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) (@function.extfun_app.{3 2} ((Type → Type) → Type 1) (function.extfun.{2 2} (Type → Type)) h0 (function.extfun.{2 1} Type)) group.{0}) (has_norm.{0} string_imp))  := sorry --non-trivial
lemma new_lemma_67977 (h0 : functor.add_const (ordered_comm_monoid (has_neg linarith.comp)) pos) : @has_exists_mul_of_le.{0} (has_neg.{0} linarith.comp) (@functor.add_const.run.{0 0} (ordered_comm_monoid.{0} (has_neg.{0} linarith.comp)) pos h0)  := sorry --non-trivial
lemma new_lemma_67978 (h0 : topological_space (canonically_ordered_comm_semiring (boolean_algebra.core Type))) : t0_space (canonically_ordered_comm_semiring (boolean_algebra.core Type)) := sorry --non-trivial
lemma new_lemma_67979 (h0 : uniform_space (add_monoid linarith.ineq)) : complete_space (add_monoid linarith.ineq) := sorry --non-trivial
lemma new_lemma_67980 (h0 : function.extfun Type add_group) : @is_add_cyclic.{0} (linear_ordered_semiring.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type add_group.{0} h0 (linear_ordered_semiring.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_67981 (h0 : ring (metric_space (semiring (semiring (semiring congr_arg_kind))))) : is_principal_ideal_ring (metric_space (semiring (semiring (semiring congr_arg_kind)))) := sorry --non-trivial
lemma new_lemma_67982 (h0 : function.extfun Type topological_space) : @topological_space.separable_space.{0} (mul_zero_class.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (mul_zero_class.{0} name))  := sorry --non-trivial
lemma new_lemma_67983 (h0 : uniform_space (has_Inf (has_add (has_Inf pos)))) : separated_space (has_Inf (has_add (has_Inf pos))) := sorry --non-trivial
lemma new_lemma_67984 (h0 : function.extfun Type (functor.add_const (cancel_comm_monoid_with_zero (semigroup empty)))) : @unique_factorization_monoid.{0} (semigroup.{0} empty) (@functor.add_const.run.{0 0} (cancel_comm_monoid_with_zero.{0} (semigroup.{0} empty)) empty (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (cancel_comm_monoid_with_zero.{0} (semigroup.{0} empty))) h0 empty))  := sorry --non-trivial
lemma new_lemma_67985 (h0 : topological_space (has_add (finset Type))) : irreducible_space (has_add (finset Type)) := sorry --non-trivial
lemma new_lemma_67986 (h0 : function.extfun (finset Type) (has_mem.mem (measurable_space congr_arg_kind))) : complete_lattice.is_Sup_finite_compact (measurable_space congr_arg_kind) := sorry --non-trivial
lemma new_lemma_67987 (h2 : topological_space (semiring to_additive.value_type)) : locally_compact_space (semiring to_additive.value_type) := sorry --non-trivial
lemma new_lemma_67988 (h0 : functor.add_const (topological_space (canonically_ordered_comm_semiring pos)) name) : @preconnected_space.{0} (canonically_ordered_comm_semiring.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (canonically_ordered_comm_semiring.{0} pos)) name h0)  := sorry --non-trivial
lemma new_lemma_67989 (h0 : function.extfun Type monoid) : @monoid.fg.{0} (has_to_string.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type monoid.{0} h0 (has_to_string.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_67990 (h0 : add_group (has_emptyc linarith.ineq)) : is_add_cyclic (has_emptyc linarith.ineq) := sorry --non-trivial
lemma new_lemma_67991 (h0 : topological_space (monoid (option ennreal))) : preconnected_space (monoid (option ennreal)) := sorry --non-trivial
lemma new_lemma_67992 (h0 : prod (linear_ordered_semiring (semiring (has_top empty))) (linear_ordered_semiring (semiring (has_top empty)))) : id_rel h0 := sorry --non-trivial
lemma new_lemma_67993 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @normalizer_condition.{1} (generalized_boolean_algebra.{1} Type) (@function.extfun_app.{3 2} (Type 1) group.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 group.{1}) (generalized_boolean_algebra.{1} Type))  := sorry --non-trivial
lemma new_lemma_67994 (h0 : has_mem.mem (normed_group empty) has_emptyc.emptyc) : @is_atomistic.{0} (normed_group.{0} empty) (@finset.pi.empty.{1 0} Type complete_lattice.{0} (normed_group.{0} empty) h0)  := sorry --non-trivial
lemma new_lemma_67995 (h0 : topological_space (normed_group (has_norm fun_info))) : path_connected_space (normed_group (has_norm fun_info)) := sorry --non-trivial
lemma new_lemma_67996 (h0 : function.extfun Type group) : @is_simple_group.{0} (add_cancel_monoid.{0} name) (@function.extfun_app.{2 1} Type group.{0} h0 (add_cancel_monoid.{0} name))  := sorry --non-trivial
lemma new_lemma_67997 (h0 : topological_space (with_one (semiring empty))) : path_connected_space (with_one (semiring empty)) := sorry --non-trivial
lemma new_lemma_67998 (h0 : functor.add_const (finset (finset name)) unsigned) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_67999 (h0 : function.extfun Type group) : @group.fg.{0} (has_nndist.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type group.{0} h0 (has_nndist.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_68000 (h0 : fin has_zero.zero) : @is_cyclic.{0} (has_pos_part.{0} pos) (@matrix.vec_empty.{0} (group.{0} (has_pos_part.{0} pos)) h0)  := sorry --non-trivial
lemma new_lemma_68001 (h0 : cancel_comm_monoid_with_zero (has_neg congr_arg_kind)) : unique_factorization_monoid (has_neg congr_arg_kind) := sorry --non-trivial
lemma new_lemma_68002 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_compactly_generated.{0} (complete_linear_order.{0} num) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (complete_linear_order.{0} num))  := sorry --non-trivial
lemma new_lemma_68003 (h0 : topological_space (ordered_comm_monoid (has_Inf (boolean_algebra.core name)))) : preirreducible_space (ordered_comm_monoid (has_Inf (boolean_algebra.core name))) := sorry --non-trivial
lemma new_lemma_68004 (h0 : function.extfun Type ring) : @strong_rank_condition.{0} (pseudo_metric_space.{0} ennreal) (@function.extfun_app.{2 1} Type ring.{0} h0 (pseudo_metric_space.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_68005 (h0 : group (ring (option unsigned))) : normalizer_condition (ring (option unsigned)) := sorry --non-trivial
lemma new_lemma_68006 (h0 : uniform_space (measurable_space.dynkin_system (with_bot (with_bot unsigned)))) : complete_space (measurable_space.dynkin_system (with_bot (with_bot unsigned))) := sorry --non-trivial
lemma new_lemma_68007 (h0 : not (uniform_space (metric_space fun_info) -> false)) : @complete_space.{0} (metric_space.{0} fun_info) (@classical.by_contradiction'.{1} (uniform_space.{0} (metric_space.{0} fun_info)) h0)  := sorry --non-trivial
lemma new_lemma_68008 (h0 : functor.add_const (uniform_space pos) pos) : @separated_space.{0} pos (@functor.add_const.run.{0 0} (uniform_space.{0} pos) pos h0)  := sorry --non-trivial
lemma new_lemma_68009 (h0 : function.extfun (finset Type) (has_mem.mem (measurable_space num))) : @separated_space.{0} (measurable_space.{0} num) (@finset.pi.empty.{1 0} Type uniform_space.{0} (measurable_space.{0} num) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (measurable_space.{0} num)) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_68010 (h0 : ring (add_comm_monoid pos)) : rank_condition (add_comm_monoid pos) := sorry --non-trivial
lemma new_lemma_68011 (h0 : function.extfun Type topological_space) : @totally_separated_space.{0} (semiring.{0} fun_info) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (semiring.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_68012 (h0 : group (has_pos_part linarith.comp)) : is_simple_group (has_pos_part linarith.comp) := sorry --non-trivial
lemma new_lemma_68013 (h0 : topological_space (add_cancel_comm_monoid char)) : t0_space (add_cancel_comm_monoid char) := sorry --non-trivial
lemma new_lemma_68014 (h0 : topological_space (has_neg linarith.comp_source)) : path_connected_space (has_neg linarith.comp_source) := sorry --non-trivial
lemma new_lemma_68015 (h0 : functor.add_const (add_monoid (has_neg Type)) Type) : @add_monoid.fg.{1} (has_neg.{1} Type) (@functor.add_const.run.{1 1} (add_monoid.{1} (has_neg.{1} Type)) Type h0)  := sorry --non-trivial
lemma new_lemma_68016 (h2 : add_group (add_comm_semigroup (add_comm_semigroup (mul_one_class ereal)))) : is_add_cyclic (add_comm_semigroup (add_comm_semigroup (mul_one_class ereal))) := sorry --non-trivial
lemma new_lemma_68017 (h0 : complete_lattice (has_nndist (finset Type))) : complete_lattice.is_Sup_finite_compact (has_nndist (finset Type)) := sorry --non-trivial
lemma new_lemma_68018 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_cyclic.{0} (linear_ordered_comm_monoid_with_zero.{0} empty) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (linear_ordered_comm_monoid_with_zero.{0} empty))  := sorry --non-trivial
lemma new_lemma_68019 (h0 : has_mem.mem (random_gen (has_norm linarith.comp_source)) has_emptyc.emptyc) : @t0_space.{0} (random_gen.{0} (has_norm.{0} linarith.comp_source)) (@finset.pi.empty.{1 0} Type topological_space.{0} (random_gen.{0} (has_norm.{0} linarith.comp_source)) h0)  := sorry --non-trivial
lemma new_lemma_68020 (h0 : topological_space (has_Inf (finset (has_nndist (has_Inf (has_Inf Type)))))) : preconnected_space (has_Inf (finset (has_nndist (has_Inf (has_Inf Type))))) := sorry --non-trivial
lemma new_lemma_68021 (h0 : topological_space (canonically_linear_ordered_monoid (option (option ennreal)))) : t1_space (canonically_linear_ordered_monoid (option (option ennreal))) := sorry --non-trivial
lemma new_lemma_68022 (h0 : complete_lattice (has_nndist (has_add linarith.comp))) : is_compactly_generated (has_nndist (has_add linarith.comp)) := sorry --non-trivial
lemma new_lemma_68023 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @unique_factorization_monoid.{0} (complete_distrib_lattice.{0} unsigned) (@function.extfun_app.{2 1} Type cancel_comm_monoid_with_zero.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 cancel_comm_monoid_with_zero.{0}) (complete_distrib_lattice.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_68024 (h0 : functor.add_const (ordered_comm_monoid (sub_neg_monoid pos)) linarith.comp) : @has_exists_mul_of_le.{0} (sub_neg_monoid.{0} pos) (@functor.add_const.run.{0 0} (ordered_comm_monoid.{0} (sub_neg_monoid.{0} pos)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_68025 (h0 : topological_space (semiring (random_gen linarith.comp_source))) : irreducible_space (semiring (random_gen linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_68026 (h0 : topological_space (has_add congr_arg_kind)) : discrete_topology (has_add congr_arg_kind) := sorry --non-trivial
lemma new_lemma_68027 (h0 : filter (has_neg (finset (finset linarith.comp)))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_68028 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @sequential_space.{0} (boolean_algebra.{0} real) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (boolean_algebra.{0} real))  := sorry --non-trivial
lemma new_lemma_68029 (h0 : uniform_space (normed_linear_ordered_group (option (option (option (option empty)))))) : complete_space (normed_linear_ordered_group (option (option (option (option empty))))) := sorry --non-trivial
lemma new_lemma_68030 (h0 : ring (distrib (has_ssubset linarith.comp_source))) : rank_condition (distrib (has_ssubset linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_68031 (h0 : prod (semiring num) (semiring num)) : id_rel h0 := sorry --non-trivial
lemma new_lemma_68032 (h0 : functor.add_const (topological_space (add_cancel_monoid empty)) ennreal) : @t1_space.{0} (add_cancel_monoid.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (add_cancel_monoid.{0} empty)) ennreal h0)  := sorry --non-trivial
lemma new_lemma_68033 (h0 : ordered_comm_monoid (finset unsigned)) : has_exists_mul_of_le (finset unsigned) := sorry --non-trivial
lemma new_lemma_68034 (h0 : function.extfun Type finset) : finset.nonempty (function.extfun_app h0 (group_with_zero ennreal)) := sorry --non-trivial
lemma new_lemma_68035 (h0 : functor.add_const (functor.add_const (cancel_comm_monoid_with_zero Type) unsigned) Type) : @unique_factorization_monoid.{1} Type (@functor.add_const.run.{1 0} (cancel_comm_monoid_with_zero.{1} Type) unsigned (@functor.add_const.run.{1 1} (functor.add_const.{1 0} (cancel_comm_monoid_with_zero.{1} Type) unsigned) Type h0))  := sorry --non-trivial
lemma new_lemma_68036 (h0 : function.extfun Type complete_lattice) : @is_compactly_generated.{0} (with_one.{0} linarith.ineq) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (with_one.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_68037 (h0 : ring (div_inv_monoid char)) : rank_condition (div_inv_monoid char) := sorry --non-trivial
lemma new_lemma_68038 (h0 : ulower (fin has_zero.zero)) (h1 : thunk pnat) : pnat.coprime (@matrix.vec_empty.{0} pnat (@ulower.up.{0} (fin (@has_zero.zero.{0} nat nat.has_zero)) (encodable.fin (@has_zero.zero.{0} nat nat.has_zero)) h0)) (@id.{1} pnat (@trace_call_stack.{0} pnat h1))  := sorry --non-trivial
lemma new_lemma_68039 (h0 : topological_space (ordered_comm_ring (has_Inf linarith.comp))) : regular_space (ordered_comm_ring (has_Inf linarith.comp)) := sorry --non-trivial
lemma new_lemma_68040 (h0 : topological_space (has_neg linarith.comp)) : t1_space (has_neg linarith.comp) := sorry --non-trivial
lemma new_lemma_68041 (h0 : topological_space (cancel_monoid (has_add pos))) : loc_path_connected_space (cancel_monoid (has_add pos)) := sorry --non-trivial
lemma new_lemma_68042 (h0 : functor.add_const (ordered_comm_monoid (add_comm_monoid environment.implicit_infer_kind)) pos) : @has_exists_mul_of_le.{0} (add_comm_monoid.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (ordered_comm_monoid.{0} (add_comm_monoid.{0} environment.implicit_infer_kind)) pos h0)  := sorry --non-trivial
lemma new_lemma_68043 (h0 : not (uniform_space (has_ssubset char) -> false)) : @complete_space.{0} (has_ssubset.{0} char) (@classical.by_contradiction'.{1} (uniform_space.{0} (has_ssubset.{0} char)) h0)  := sorry --non-trivial
lemma new_lemma_68044 (h0 : topological_space (has_neg environment.implicit_infer_kind)) : topological_space.separable_space (has_neg environment.implicit_infer_kind) := sorry --non-trivial
lemma new_lemma_68045 (h0 : ring real) : is_domain real := sorry --non-trivial
lemma new_lemma_68046 (h0 : functor.add_const (group (option name)) unsigned) : @group.fg.{0} (option.{0} name) (@functor.add_const.run.{0 0} (group.{0} (option.{0} name)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_68047 (h0 h1 : multiset (has_compl (has_lt string.iterator_imp))) : multiset.disjoint h0 h1 := sorry --non-trivial
lemma new_lemma_68048 (h1 : not (ring (has_ssubset to_additive.value_type) -> false)) : @is_domain.{0} (has_ssubset.{0} to_additive.value_type) (@classical.by_contradiction'.{1} (ring.{0} (has_ssubset.{0} to_additive.value_type)) h1)  := sorry --non-trivial
lemma new_lemma_68049 (h0 : not (topological_space (measurable_space linarith.comp) -> false)) : @irreducible_space.{0} (measurable_space.{0} linarith.comp) (@classical.by_contradiction'.{1} (topological_space.{0} (measurable_space.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_68050 (h0 : topological_space (generalized_boolean_algebra (has_nndist (finset Type)))) : sequential_space (generalized_boolean_algebra (has_nndist (finset Type))) := sorry --non-trivial
lemma new_lemma_68051 (h0 : function.extfun (Type 1) topological_space) : @t0_space.{1} (finset.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} h0 (finset.{1} Type))  := sorry --non-trivial
lemma new_lemma_68052 (h0 : fin has_zero.zero) : @is_atomistic.{0} (sub_neg_monoid.{0} name) (@matrix.vec_empty.{0} (complete_lattice.{0} (sub_neg_monoid.{0} name)) h0)  := sorry --non-trivial
lemma new_lemma_68053 (h0 : topological_space (metric_space (has_norm congr_arg_kind))) : t0_space (metric_space (has_norm congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_68054 (h0 : not (ring (measurable_space.dynkin_system unsigned) -> false)) : @is_principal_ideal_ring.{0} (measurable_space.dynkin_system.{0} unsigned) (@classical.by_contradiction'.{1} (ring.{0} (measurable_space.dynkin_system.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_68055 (h0 : ring (distrib_lattice (random_gen (has_norm (random_gen fun_info))))) : rank_condition (distrib_lattice (random_gen (has_norm (random_gen fun_info)))) := sorry --non-trivial
lemma new_lemma_68056 (h0 : functor.add_const (add_monoid (has_to_string name)) name) : @add_monoid.fg.{0} (has_to_string.{0} name) (@functor.add_const.run.{0 0} (add_monoid.{0} (has_to_string.{0} name)) name h0)  := sorry --non-trivial
lemma new_lemma_68057 (h0 : group (has_Inf (has_add Type))) : is_cyclic (has_Inf (has_add Type)) := sorry --non-trivial
lemma new_lemma_68058 (h0 : list (has_Inf (finset (has_Inf linarith.comp)))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_68059 (h0 : topological_space (has_bot (has_Inf pos))) : regular_space (has_bot (has_Inf pos)) := sorry --non-trivial
lemma new_lemma_68060 (h0 : complete_lattice (add_cancel_monoid (option ennreal))) : is_compactly_generated (add_cancel_monoid (option ennreal)) := sorry --non-trivial
lemma new_lemma_68061 (h0 : group (finset (ring environment.implicit_infer_kind))) : is_cyclic (finset (ring environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_68062 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @locally_compact_space.{0} (complete_semilattice_Sup.{0} linarith.ineq) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (complete_semilattice_Sup.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_68063 (h0 : complete_lattice (complete_linear_order (semiring (semiring (semiring (semiring (semiring num))))))) : is_atomistic (complete_linear_order (semiring (semiring (semiring (semiring (semiring num)))))) := sorry --non-trivial
lemma new_lemma_68064 (h0 : list (has_top (with_bot string_imp))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_68065 (h0 : ring (distrib (has_nnnorm (random_gen (has_nnnorm reducibility_hints))))) : rank_condition (distrib (has_nnnorm (random_gen (has_nnnorm reducibility_hints)))) := sorry --non-trivial
lemma new_lemma_68066 (h0 : topological_space (has_nnnorm (add_cancel_comm_monoid to_additive.value_type))) : t0_space (has_nnnorm (add_cancel_comm_monoid to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_68067 (h0 : function.extfun Type (functor.add_const (topological_space znum))) : @discrete_topology.{0} znum (@functor.add_const.run.{0 0} (topological_space.{0} znum) num (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (topological_space.{0} znum)) h0 num))  := sorry --non-trivial
lemma new_lemma_68068 (h0 : function.extfun (Type 1) (functor.comp topological_space boolean_algebra.core)) : @loc_path_connected_space.{1} (boolean_algebra.core.{1} Type) (@functor.comp.run.{1 1 1} topological_space.{1} boolean_algebra.core.{1} Type (@function.extfun_app.{3 2} (Type 1) (functor.comp.{1 1 1} topological_space.{1} boolean_algebra.core.{1}) h0 Type))  := sorry --non-trivial
lemma new_lemma_68069 (h0 : functor.add_const (topological_space (complete_distrib_lattice pos)) name) : @preconnected_space.{0} (complete_distrib_lattice.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (complete_distrib_lattice.{0} pos)) name h0)  := sorry --non-trivial
lemma new_lemma_68070 (h0 : functor.add_const (group (has_edist empty)) (option unsigned)) : @normalizer_condition.{0} (has_edist.{0} empty) (@functor.add_const.run.{0 0} (group.{0} (has_edist.{0} empty)) (option.{0} unsigned) h0)  := sorry --non-trivial
lemma new_lemma_68071 (h0 : functor.add_const (topological_space (has_Inf Type)) pos) : @path_connected_space.{1} (has_Inf.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (has_Inf.{1} Type)) pos h0)  := sorry --non-trivial
lemma new_lemma_68072 (h0 : not (complete_lattice (denumerable string.iterator_imp) -> false)) : @complete_lattice.is_Sup_finite_compact.{0} (denumerable.{0} string.iterator_imp) (@classical.by_contradiction'.{1} (complete_lattice.{0} (denumerable.{0} string.iterator_imp)) h0)  := sorry --non-trivial
lemma new_lemma_68073 (h0 : uniform_space (semiring (semiring (semiring (semiring (semiring unsigned)))))) : complete_space (semiring (semiring (semiring (semiring (semiring unsigned))))) := sorry --non-trivial
lemma new_lemma_68074 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @locally_compact_space.{0} (has_inter.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_inter.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_68075 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_simple_group.{0} (monoid.{0} pos) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (monoid.{0} pos))  := sorry --non-trivial
lemma new_lemma_68076 (h0 : topological_space (normed_comm_ring (has_nndist environment.implicit_infer_kind))) : path_connected_space (normed_comm_ring (has_nndist environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_68077 (h0 : topological_space (boolean_algebra (has_neg real))) : locally_compact_space (boolean_algebra (has_neg real)) := sorry --non-trivial
lemma new_lemma_68078 (h0 : topological_space (semiring (has_top to_additive.value_type))) : locally_compact_space (semiring (has_top to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_68079 (h0 : functor.add_const (filter (has_add linarith.comp)) Type) : countable_Inter_filter (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_68080 (h0 : functor.add_const (topological_space (add_comm_monoid Type)) environment.implicit_infer_kind) : @topological_space.separable_space.{1} (add_comm_monoid.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (add_comm_monoid.{1} Type)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_68081 (h0 : functor.add_const (group (finset ennreal)) (boolean_algebra (boolean_algebra name))) : @normalizer_condition.{0} (finset.{0} ennreal) (@functor.add_const.run.{0 0} (group.{0} (finset.{0} ennreal)) (boolean_algebra.{0} (boolean_algebra.{0} name)) h0)  := sorry --non-trivial
lemma new_lemma_68082 (h0 : not (function.extfun Type uniform_space -> false)) : @separated_space.{0} (has_norm.{0} num) (@function.extfun_app.{2 1} Type uniform_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type uniform_space.{0}) h0) (has_norm.{0} num))  := sorry --non-trivial
lemma new_lemma_68083 (h0 : monoid (non_assoc_semiring (non_assoc_semiring congr_arg_kind))) : monoid.fg (non_assoc_semiring (non_assoc_semiring congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_68084 (h0 : topological_space (cancel_monoid name)) : t0_space (cancel_monoid name) := sorry --non-trivial
lemma new_lemma_68085 (h0 : uniform_space (has_ssubset (has_lt (has_lt linarith.ineq)))) : complete_space (has_ssubset (has_lt (has_lt linarith.ineq))) := sorry --non-trivial
lemma new_lemma_68086 (h0 : topological_space (has_to_string (ring (has_pos_part Type)))) : sequential_space (has_to_string (ring (has_pos_part Type))) := sorry --non-trivial
lemma new_lemma_68087 (h0 : ordered_add_comm_monoid (finset (add_cancel_monoid name))) : archimedean (finset (add_cancel_monoid name)) := sorry --non-trivial
lemma new_lemma_68088 (h0 : functor.add_const (filter (has_add Type)) (finset linarith.comp)) : filter.ne_bot (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_68089 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @archimedean.{0} (mul_zero_class.{0} name) (@function.extfun_app.{2 1} Type ordered_add_comm_monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ordered_add_comm_monoid.{0}) (mul_zero_class.{0} name))  := sorry --non-trivial
lemma new_lemma_68090 (h0 : functor.add_const (ring (normed_comm_ring unsigned)) linarith.comp) : @rank_condition.{0} (normed_comm_ring.{0} unsigned) (@functor.add_const.run.{0 0} (ring.{0} (normed_comm_ring.{0} unsigned)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_68091 (h1 : not (topological_space (random_gen linarith.ineq) -> false)) : @totally_disconnected_space.{0} (random_gen.{0} linarith.ineq) (@classical.by_contradiction'.{1} (topological_space.{0} (random_gen.{0} linarith.ineq)) h1)  := sorry --non-trivial
lemma new_lemma_68092 (h0 : group (has_Inf (has_ssubset pos))) : normalizer_condition (has_Inf (has_ssubset pos)) := sorry --non-trivial
lemma new_lemma_68093 (h0 : add_group (sub_neg_monoid pos)) : is_add_cyclic (sub_neg_monoid pos) := sorry --non-trivial
lemma new_lemma_68094 (h0 : monoid (id (has_top to_additive.value_type))) : monoid.fg (id (has_top to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_68095 (h0 : add_monoid (linear_ordered_comm_ring (semiring (semiring unsigned)))) : add_monoid.fg (linear_ordered_comm_ring (semiring (semiring unsigned))) := sorry --non-trivial
lemma new_lemma_68096 (h0 : functor.add_const (topological_space (ring linarith.comp)) environment.implicit_infer_kind) : @regular_space.{0} (ring.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (ring.{0} linarith.comp)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_68097 (h0 : not (complete_lattice (add_monoid fun_info) -> false)) : @complete_lattice.is_Sup_finite_compact.{0} (add_monoid.{0} fun_info) (@classical.by_contradiction'.{1} (complete_lattice.{0} (add_monoid.{0} fun_info)) h0)  := sorry --non-trivial
lemma new_lemma_68098 (h0 : finset (finset (boolean_algebra (has_neg_part pos)))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_68099 (h0 : ordered_add_comm_monoid (has_Inf (has_Inf pos))) : archimedean (has_Inf (has_Inf pos)) := sorry --non-trivial
lemma new_lemma_68100 (h0 : has_neg (complete_distrib_lattice ennreal) -> has_neg (complete_distrib_lattice ennreal) -> Prop) : is_symm (has_neg (complete_distrib_lattice ennreal)) h0 := sorry --non-trivial
lemma new_lemma_68101 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_simple_group.{0} (ordered_comm_ring.{0} pos) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (ordered_comm_ring.{0} pos))  := sorry --non-trivial
lemma new_lemma_68102 (h0 : function.extfun Type add_monoid) : @add_monoid.fg.{0} (non_assoc_semiring.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type add_monoid.{0} h0 (non_assoc_semiring.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_68103 (h0 : topological_space (comm_group num)) : preconnected_space (comm_group num) := sorry --non-trivial
lemma new_lemma_68104 (h0 : function.extfun Type complete_lattice) : is_compactly_generated (measurable_space string_imp) := sorry --non-trivial
lemma new_lemma_68105 (h0 : functor.add_const (uniform_space (partial_order environment.implicit_infer_kind)) num) : @separated_space.{0} (partial_order.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (uniform_space.{0} (partial_order.{0} environment.implicit_infer_kind)) num h0)  := sorry --non-trivial
lemma new_lemma_68106 (h0 : topological_space (has_inv (comm_ring (comm_ring (comm_ring fun_info))))) : path_connected_space (has_inv (comm_ring (comm_ring (comm_ring fun_info)))) := sorry --non-trivial
lemma new_lemma_68107 (h0 : topological_space (add_cancel_monoid (finset (finset linarith.comp)))) : totally_disconnected_space (add_cancel_monoid (finset (finset linarith.comp))) := sorry --non-trivial
lemma new_lemma_68108 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @irreducible_space.{0} (semiring.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (semiring.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_68109 (h1 : topological_space num) : path_connected_space num := sorry --non-trivial
lemma new_lemma_68110 (h0 : ulower pnat) (h1 : thunk (fin has_zero.zero)) : pnat.coprime (@id.{1} pnat (@ulower.up.{0} pnat encodable.pnat h0)) (@id.{1} pnat (@id.{1} pnat (@matrix.vec_empty.{0} pnat (@trace_call_stack.{0} (fin (@has_zero.zero.{0} nat nat.has_zero)) h1))))  := sorry --non-trivial
lemma new_lemma_68111 (h0 : topological_space (ring (ring (ring linarith.comp)))) : discrete_topology (ring (ring (ring linarith.comp))) := sorry --non-trivial
lemma new_lemma_68112 (h0 : has_mem.mem (linear_ordered_add_comm_group fun_info) has_emptyc.emptyc) : @is_atomistic.{0} (linear_ordered_add_comm_group.{0} fun_info) (@finset.pi.empty.{1 0} Type complete_lattice.{0} (linear_ordered_add_comm_group.{0} fun_info) h0)  := sorry --non-trivial
lemma new_lemma_68113 (h0 : functor.add_const (topological_space (has_neg name)) linarith.comp) : @regular_space.{0} (has_neg.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (has_neg.{0} name)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_68114 (h0 : topological_space (complete_distrib_lattice (has_add name))) : normal_space (complete_distrib_lattice (has_add name)) := sorry --non-trivial
lemma new_lemma_68115 (h1 : ring (semiring (random_gen to_additive.value_type))) : is_domain (semiring (random_gen to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_68116 (h0 : group (has_bot (has_add linarith.comp))) : is_cyclic (has_bot (has_add linarith.comp)) := sorry --non-trivial
lemma new_lemma_68117 (h0 : measurable_space (nondiscrete_normed_field (mul_one_class linarith.ineq))) (h1 : measure_theory.measure (nondiscrete_normed_field (mul_one_class linarith.ineq))) : measure_theory.has_no_atoms h1 := sorry --non-trivial
lemma new_lemma_68118 (h0 : functor.add_const (topological_space (has_neg linarith.comp)) Type) : @loc_path_connected_space.{0} (has_neg.{0} linarith.comp) (@functor.add_const.run.{0 1} (topological_space.{0} (has_neg.{0} linarith.comp)) Type h0)  := sorry --non-trivial
lemma new_lemma_68119 (h0 : semiring (finset (has_Inf (has_Inf (has_add (has_Inf (sub_neg_monoid Type))))))) : is_noetherian_ring (finset (has_Inf (has_Inf (has_add (has_Inf (sub_neg_monoid Type)))))) := sorry --non-trivial
lemma new_lemma_68120 (h0 : not (topological_space (topological_space linarith.ineq) -> false)) : @t0_space.{0} (topological_space.{0} linarith.ineq) (@classical.by_contradiction'.{1} (topological_space.{0} (topological_space.{0} linarith.ineq)) h0)  := sorry --non-trivial
lemma new_lemma_68121 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @t0_space.{0} (normed_lattice_add_comm_group.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (normed_lattice_add_comm_group.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_68122 (h0 : has_mem.mem topological_space has_emptyc.emptyc) : @discrete_topology.{0} (semiring.{0} linarith.ineq) (@function.extfun_app.{2 1} Type topological_space.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) topological_space.{0} h0) (semiring.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_68123 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : palindrome (function.extfun_app (function.extfun_app h0 list) (has_neg pos)) := sorry --non-trivial
lemma new_lemma_68124 (h0 : not (topological_space (has_nnnorm fun_info) -> false)) : @path_connected_space.{0} (has_nnnorm.{0} fun_info) (@classical.by_contradiction'.{1} (topological_space.{0} (has_nnnorm.{0} fun_info)) h0)  := sorry --non-trivial
lemma new_lemma_68125 (h0 : function.extfun Type topological_space) : @irreducible_space.{0} (has_neg_part.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_neg_part.{0} name))  := sorry --non-trivial
lemma new_lemma_68126 (h0 : topological_space (semiring (has_norm to_additive.value_type))) : totally_separated_space (semiring (has_norm to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_68127 (h0 : function.extfun ((finset Type -> Prop) -> Prop) (function.extfun (finset Type -> Prop))) : @is_atomistic.{0} congr_arg_kind (@finset.pi.empty.{1 0} Type complete_lattice.{0} congr_arg_kind (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) congr_arg_kind) (@function.extfun_app.{2 0} (finset.{1} Type → Prop) (function.extfun.{2 0} (finset.{1} Type)) (@function.extfun_app.{2 0} ((finset.{1} Type → Prop) → Prop) (function.extfun.{2 0} (finset.{1} Type → Prop)) h0 (function.extfun.{2 0} (finset.{1} Type))) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) congr_arg_kind)) (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_68128 (h0 : functor.add_const (ring (has_Inf linarith.comp)) linarith.comp) : @is_domain.{0} (has_Inf.{0} linarith.comp) (@functor.add_const.run.{0 0} (ring.{0} (has_Inf.{0} linarith.comp)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_68129 (h0 : filter (div_inv_monoid fun_info)) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_68130 (h0 : list (has_add (finset (has_pos_part (has_pos_part pos))))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_68131 (h0 : topological_space (has_one (has_top linarith.ineq))) : discrete_topology (has_one (has_top linarith.ineq)) := sorry --non-trivial
lemma new_lemma_68132 (h0 : ring (comm_semigroup (sub_neg_monoid real))) : is_principal_ideal_ring (comm_semigroup (sub_neg_monoid real)) := sorry --non-trivial
lemma new_lemma_68133 (h0 : topological_space (simple_graph (mul_one_class reducibility_hints))) : path_connected_space (simple_graph (mul_one_class reducibility_hints)) := sorry --non-trivial
lemma new_lemma_68134 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : list.nodup (function.extfun_app (function.extfun_app h0 list) (has_to_string Type)) := sorry --non-trivial
lemma new_lemma_68135 (h1 : nondiscrete_normed_field enat -> nondiscrete_normed_field enat -> Prop) (h2 : set (nondiscrete_normed_field enat)) : zorn.chain h1 h2 := sorry --non-trivial
lemma new_lemma_68136 (h0 : functor.add_const (ring (left_cancel_monoid unsigned)) congr_arg_kind) : @strong_rank_condition.{0} (left_cancel_monoid.{0} unsigned) (@functor.add_const.run.{0 0} (ring.{0} (left_cancel_monoid.{0} unsigned)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_68137 (h0 : set (has_ssubset string.iterator_imp)) : set.finite h0 := sorry --non-trivial
lemma new_lemma_68138 (h0 : function.extfun Type list) : list.nodup (function.extfun_app h0 (has_ssubset to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_68139 (h0 : ring (boolean_algebra Type)) : is_domain (boolean_algebra Type) := sorry --non-trivial
lemma new_lemma_68140 (h0 : prod (add_group empty) (add_group empty)) : id_rel h0 := sorry --non-trivial
lemma new_lemma_68141 (h0 : complete_lattice (normed_group (has_inv (has_inv to_additive.value_type)))) : is_compactly_generated (normed_group (has_inv (has_inv to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_68142 (h0 : functor.add_const (ring (finset Type)) (has_Inf (has_Inf linarith.comp))) : @rank_condition.{1} (finset.{1} Type) (@functor.add_const.run.{1 0} (ring.{1} (finset.{1} Type)) (has_Inf.{0} (has_Inf.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_68143 (h0 : list (has_bot unsigned)) : palindrome h0 := sorry --non-trivial
lemma new_lemma_68144 (h0 : add_group (topological_space (has_nnnorm (random_gen char)))) : is_add_cyclic (topological_space (has_nnnorm (random_gen char))) := sorry --non-trivial
lemma new_lemma_68145 (h0 : topological_space (normed_group (random_gen (has_norm num)))) : locally_compact_space (normed_group (random_gen (has_norm num))) := sorry --non-trivial
lemma new_lemma_68146 (h0 : functor.add_const (ring (add_cancel_monoid environment.implicit_infer_kind)) Type) : @rank_condition.{0} (add_cancel_monoid.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 1} (ring.{0} (add_cancel_monoid.{0} environment.implicit_infer_kind)) Type h0)  := sorry --non-trivial
lemma new_lemma_68147 (h2 : complete_lattice (distrib to_additive.value_type)) : complete_lattice.is_Sup_finite_compact (distrib to_additive.value_type) := sorry --non-trivial
lemma new_lemma_68148 (h1 : group (has_nnnorm linarith.ineq)) : group.fg (has_nnnorm linarith.ineq) := sorry --non-trivial
lemma new_lemma_68149 (h0 : functor.add_const (functor.add_const (ring name) num) num) : @rank_condition.{0} name (@functor.add_const.run.{0 0} (ring.{0} name) num (@functor.add_const.run.{0 0} (functor.add_const.{0 0} (ring.{0} name) num) num h0))  := sorry --non-trivial
lemma new_lemma_68150 (h0 : ring (has_to_string (has_add Type))) : is_principal_ideal_ring (has_to_string (has_add Type)) := sorry --non-trivial
lemma new_lemma_68151 (h0 : topological_space (ring (finset (has_nndist (has_Inf (has_neg Type)))))) : sequential_space (ring (finset (has_nndist (has_Inf (has_neg Type))))) := sorry --non-trivial
lemma new_lemma_68152 (h0 : topological_space (has_neg_part (comm_group name))) : path_connected_space (has_neg_part (comm_group name)) := sorry --non-trivial
lemma new_lemma_68153 (h0 : group (filter congr_arg_kind)) : is_cyclic (filter congr_arg_kind) := sorry --non-trivial
lemma new_lemma_68154 (h0 : topological_space (with_one (has_top (has_top (has_top (has_top linarith.comp_source)))))) : path_connected_space (with_one (has_top (has_top (has_top (has_top linarith.comp_source))))) := sorry --non-trivial
lemma new_lemma_68155 (h0 : not (topological_space (denumerable linarith.comp_source) -> false)) : @path_connected_space.{0} (denumerable.{0} linarith.comp_source) (@classical.by_contradiction'.{1} (topological_space.{0} (denumerable.{0} linarith.comp_source)) h0)  := sorry --non-trivial
lemma new_lemma_68156 (h0 : filter (add_left_cancel_monoid (denumerable char))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_68157 (h0 : ring (has_norm (semiring (semiring (semiring empty))))) : is_domain (has_norm (semiring (semiring (semiring empty)))) := sorry --non-trivial
lemma new_lemma_68158 (h0 : function.extfun Type topological_space) : @t0_space.{0} (has_neg.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_neg.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_68159 (h0 : functor.comp topological_space has_neg name) : @locally_compact_space.{0} (has_neg.{0} name) (@functor.comp.run.{0 0 0} topological_space.{0} has_neg.{0} name h0)  := sorry --non-trivial
lemma new_lemma_68160 (h0 : topological_space (finset congr_arg_kind)) : totally_disconnected_space (finset congr_arg_kind) := sorry --non-trivial
lemma new_lemma_68161 (h0 : function.extfun Type uniform_space) : @separated_space.{0} (omega_complete_partial_order.{0} (ordered_comm_group.{0} unsigned)) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (omega_complete_partial_order.{0} (ordered_comm_group.{0} unsigned)))  := sorry --non-trivial
lemma new_lemma_68162 (h0 : topological_space (finset (boolean_algebra.core unsigned))) : path_connected_space (finset (boolean_algebra.core unsigned)) := sorry --non-trivial
lemma new_lemma_68163 (h0 : topological_space (fintype (random_gen (random_gen (random_gen linarith.comp_source))))) : totally_disconnected_space (fintype (random_gen (random_gen (random_gen linarith.comp_source)))) := sorry --non-trivial
lemma new_lemma_68164 (h0 : topological_space (has_neg (ring pos))) : discrete_topology (has_neg (ring pos)) := sorry --non-trivial
lemma new_lemma_68165 (h0 : functor.add_const (topological_space (boolean_algebra Type)) environment.implicit_infer_kind) : @sequential_space.{1} (boolean_algebra.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (boolean_algebra.{1} Type)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_68166 (h0 : topological_space char) (h2 : has_sub char) : has_continuous_sub char := sorry --non-trivial
lemma new_lemma_68167 (h1 : function.extfun (Type -> Type) (function.extfun Type)) : @locally_compact_space.{0} (complete_semilattice_Sup.{0} fun_info) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h1 topological_space.{0}) (complete_semilattice_Sup.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_68168 (h0 : has_mem.mem string_imp has_emptyc.emptyc) : @is_domain.{0} string_imp (@finset.pi.empty.{1 0} Type ring.{0} string_imp h0)  := sorry --non-trivial
lemma new_lemma_68169 (h0 : ordered_comm_monoid (has_add (has_pos_part pos))) : has_exists_mul_of_le (has_add (has_pos_part pos)) := sorry --non-trivial
lemma new_lemma_68170 (h0 : function.extfun (Type 1) topological_space) : @totally_separated_space.{1} (generalized_boolean_algebra.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} h0 (generalized_boolean_algebra.{1} Type))  := sorry --non-trivial
lemma new_lemma_68171 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @is_compactly_generated.{1} (canonically_ordered_monoid.{1} Type) (@function.extfun_app.{3 2} (Type 1) complete_lattice.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 complete_lattice.{1}) (canonically_ordered_monoid.{1} Type))  := sorry --non-trivial
lemma new_lemma_68172 (h0 : complete_lattice (boolean_algebra.core (mul_zero_class Type))) : is_compactly_generated (boolean_algebra.core (mul_zero_class Type)) := sorry --non-trivial
lemma new_lemma_68173 (h0 : function.extfun Type complete_lattice) : @complete_lattice.is_Sup_finite_compact.{0} (finset.{0} unsigned) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (finset.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_68174 (h0 : group (cancel_monoid linarith.comp)) : is_cyclic (cancel_monoid linarith.comp) := sorry --non-trivial
lemma new_lemma_68175 (h0 : filter (comm_group (finset linarith.comp))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_68176 (h0 : not (topological_space (measurable_space linarith.comp_source) -> false)) : @totally_separated_space.{0} (measurable_space.{0} linarith.comp_source) (@classical.by_contradiction'.{1} (topological_space.{0} (measurable_space.{0} linarith.comp_source)) h0)  := sorry --non-trivial
lemma new_lemma_68177 (h1 : group (has_compl linarith.ineq)) : is_cyclic (has_compl linarith.ineq) := sorry --non-trivial
lemma new_lemma_68178 (h0 : monoid (semiring congr_arg_kind)) : monoid.fg (semiring congr_arg_kind) := sorry --non-trivial
lemma new_lemma_68179 (h0 : fin has_zero.zero) : @preirreducible_space.{0} (sub_neg_monoid.{0} pos) (@matrix.vec_empty.{0} (topological_space.{0} (sub_neg_monoid.{0} pos)) h0)  := sorry --non-trivial
lemma new_lemma_68180 (h0 : uniform_space (complete_semilattice_Sup (normed_group linarith.comp))) : separated_space (complete_semilattice_Sup (normed_group linarith.comp)) := sorry --non-trivial
lemma new_lemma_68181 (h0 : ordered_comm_monoid (cancel_monoid (has_nndist pos))) : has_exists_mul_of_le (cancel_monoid (has_nndist pos)) := sorry --non-trivial
lemma new_lemma_68182 (h0 : topological_space (finset (has_to_string (finset (finset (finset linarith.comp)))))) : irreducible_space (finset (has_to_string (finset (finset (finset linarith.comp))))) := sorry --non-trivial
lemma new_lemma_68183 (h1 : topological_space (topological_space (comm_ring reducibility_hints))) : totally_disconnected_space (topological_space (comm_ring reducibility_hints)) := sorry --non-trivial
lemma new_lemma_68184 (h0 : ordered_add_comm_monoid (has_neg_part (option unsigned))) : archimedean (has_neg_part (option unsigned)) := sorry --non-trivial
lemma new_lemma_68185 (h0 : function.extfun (finset (Type -> Type)) (has_mem.mem uniform_space)) : @complete_space.{0} linarith.comp_source (@function.extfun_app.{2 1} Type uniform_space.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) uniform_space.{0} (@function.extfun_app.{2 0} (finset.{1} (Type → Type)) (@has_mem.mem.{1 1} (Type → Type) (finset.{1} (Type → Type)) (@finset.has_mem.{1} (Type → Type)) uniform_space.{0}) h0 (@has_emptyc.emptyc.{1} (finset.{1} (Type → Type)) (@finset.has_emptyc.{1} (Type → Type))))) linarith.comp_source)  := sorry --non-trivial
lemma new_lemma_68186 (h2 : filter (random_gen char)) : filter.ne_bot h2 := sorry --non-trivial
lemma new_lemma_68187 (h0 : functor.add_const (topological_space (cancel_monoid pos)) name) : @path_connected_space.{0} (cancel_monoid.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (cancel_monoid.{0} pos)) name h0)  := sorry --non-trivial
lemma new_lemma_68188 (h0 : topological_space (complete_distrib_lattice (has_pos_part (has_add Type)))) : sequential_space (complete_distrib_lattice (has_pos_part (has_add Type))) := sorry --non-trivial
lemma new_lemma_68189 (h0 : function.extfun Type topological_space) : @topological_space.separable_space.{0} (comm_semigroup.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (comm_semigroup.{0} name))  := sorry --non-trivial
lemma new_lemma_68190 (h0 : functor.add_const (topological_space (finset linarith.comp)) pos) : @preirreducible_space.{0} (finset.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (finset.{0} linarith.comp)) pos h0)  := sorry --non-trivial
lemma new_lemma_68191 (h0 : topological_space (random_gen (mul_one_class (has_ssubset reducibility_hints)))) : totally_disconnected_space (random_gen (mul_one_class (has_ssubset reducibility_hints))) := sorry --non-trivial
lemma new_lemma_68192 (h0 : functor.add_const (filter (has_inter num)) empty) : countable_Inter_filter (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_68193 (h0 : fin has_zero.zero) : @t1_space.{1} (boolean_algebra.{1} Type) (@matrix.vec_empty.{1} (topological_space.{1} (boolean_algebra.{1} Type)) (@matrix.vec_empty.{0} (fin (@has_zero.zero.{0} nat nat.has_zero)) (@matrix.vec_empty.{0} (fin (@has_zero.zero.{0} nat nat.has_zero)) (@matrix.vec_empty.{0} (fin (@has_zero.zero.{0} nat nat.has_zero)) (@matrix.vec_empty.{0} (fin (@has_zero.zero.{0} nat nat.has_zero)) h0)))))  := sorry --non-trivial
lemma new_lemma_68194 (h0 : functor.add_const Prop (canonically_ordered_comm_semiring (generalized_boolean_algebra pos))) : functor.add_const.run h0 := sorry --non-trivial
lemma new_lemma_68195 (h3 : complete_lattice (has_compl linarith.comp_source)) : is_compactly_generated (has_compl linarith.comp_source) := sorry --non-trivial
lemma new_lemma_68196 (h0 : functor.add_const (ordered_comm_monoid (has_zero Type)) (has_nndist (has_neg pos))) : @has_exists_mul_of_le.{1} (has_zero.{1} Type) (@functor.add_const.run.{1 0} (ordered_comm_monoid.{1} (has_zero.{1} Type)) (has_nndist.{0} (has_neg.{0} pos)) h0)  := sorry --non-trivial
lemma new_lemma_68197 (h0 : Prop) (h1 : with_bot (decidable h0)) (h2 : ne h1 has_bot.bot) : @id.{1} Prop (@as_false h0 (@with_bot.unbot.{0} (decidable h0) h1 h2))  := sorry --non-trivial
lemma new_lemma_68198 (h0 : functor.add_const (topological_space (has_nndist pos)) name) : @regular_space.{0} (has_nndist.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (has_nndist.{0} pos)) name h0)  := sorry --non-trivial
lemma new_lemma_68199 (h0 : functor.add_const (topological_space (free_add_monoid empty)) num) : @loc_path_connected_space.{0} (free_add_monoid.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (free_add_monoid.{0} empty)) num h0)  := sorry --non-trivial
lemma new_lemma_68200 (h0 : semiring (has_to_string (has_add (has_add linarith.comp)))) : is_noetherian_ring (has_to_string (has_add (has_add linarith.comp))) := sorry --non-trivial
lemma new_lemma_68201 (h0 : function.extfun Type add_monoid) : @add_monoid.fg.{0} (add_semigroup.{0} unsigned) (@function.extfun_app.{2 1} Type add_monoid.{0} h0 (add_semigroup.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_68202 (h0 : group (has_emptyc (random_gen (has_top (random_gen linarith.ineq))))) : group.fg (has_emptyc (random_gen (has_top (random_gen linarith.ineq)))) := sorry --non-trivial
lemma new_lemma_68203 (h0 : complete_lattice (has_neg_part name)) : is_atomistic (has_neg_part name) := sorry --non-trivial
lemma new_lemma_68204 (h0 : filter (id (has_union empty))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_68205 (h0 : group (has_norm (has_top (has_top to_additive.value_type)))) : group.fg (has_norm (has_top (has_top to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_68206 (h0 : ring (has_bot (has_bot (has_add (has_add (has_bot real)))))) : is_principal_ideal_ring (has_bot (has_bot (has_add (has_add (has_bot real))))) := sorry --non-trivial
lemma new_lemma_68207 (h0 : functor.add_const (ring (has_nndist environment.implicit_infer_kind)) linarith.comp) : @rank_condition.{0} (has_nndist.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (ring.{0} (has_nndist.{0} environment.implicit_infer_kind)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_68208 (h0 : function.extfun Type finset) : finset.nonempty (function.extfun_app h0 (normed_linear_ordered_group congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_68209 (h0 : function.extfun Type uniform_space) : @complete_space.{0} (denumerable.{0} linarith.ineq) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (denumerable.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_68210 (h0 : function.extfun Type list) : list.nodup (function.extfun_app h0 (has_to_string ennreal)) := sorry --non-trivial
lemma new_lemma_68211 (h0 : fun_info -> linarith.ineq -> linarith.ineq) : left_commutative h0 := sorry --non-trivial
lemma new_lemma_68212 (h0 : function.extfun Type (functor.add_const (topological_space pos))) : @preconnected_space.{0} pos (@functor.add_const.run.{0 0} (topological_space.{0} pos) name (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (topological_space.{0} pos)) h0 name))  := sorry --non-trivial
lemma new_lemma_68213 (h0 : not (group (has_nnnorm linarith.comp_source) -> false)) : @group.fg.{0} (has_nnnorm.{0} linarith.comp_source) (@classical.by_contradiction'.{1} (group.{0} (has_nnnorm.{0} linarith.comp_source)) h0)  := sorry --non-trivial
lemma new_lemma_68214 (h1 : topological_space (normed_field (has_ssubset char))) : t0_space (normed_field (has_ssubset char)) := sorry --non-trivial
lemma new_lemma_68215 (h0 : group (has_Inf Type)) : group.fg (has_Inf Type) := sorry --non-trivial
lemma new_lemma_68216 (h0 : not (function.extfun Type topological_space -> false)) : @normal_space.{0} (add_group.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (add_group.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_68217 (h0 : add_group (has_bot (has_Inf real))) : is_add_cyclic (has_bot (has_Inf real)) := sorry --non-trivial
lemma new_lemma_68218 (h1 : topological_space (semiring (random_gen (random_gen (has_top to_additive.value_type))))) : irreducible_space (semiring (random_gen (random_gen (has_top to_additive.value_type)))) := sorry --non-trivial
lemma new_lemma_68219 (h0 : not (topological_space (dlist fun_info) -> false)) : @path_connected_space.{0} (dlist.{0} fun_info) (@classical.by_contradiction'.{1} (topological_space.{0} (dlist.{0} fun_info)) h0)  := sorry --non-trivial
lemma new_lemma_68220 (h0 : functor.add_const (complete_lattice (has_add linarith.comp)) (finset unsigned)) : @is_atomistic.{0} (has_add.{0} linarith.comp) (@functor.add_const.run.{0 0} (complete_lattice.{0} (has_add.{0} linarith.comp)) (finset.{0} unsigned) h0)  := sorry --non-trivial
lemma new_lemma_68221 (h0 : functor.comp uniform_space has_neg linarith.comp) : @complete_space.{0} (has_neg.{0} linarith.comp) (@functor.comp.run.{0 0 0} uniform_space.{0} has_neg.{0} linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_68222 (h0 : ordered_add_comm_monoid (add_cancel_monoid (add_comm_monoid pos))) : archimedean (add_cancel_monoid (add_comm_monoid pos)) := sorry --non-trivial
lemma new_lemma_68223 (h0 : set (semi_normed_ring char)) : set.subsingleton h0 := sorry --non-trivial
lemma new_lemma_68224 (h0 : function.extfun Type group) : @group.fg.{0} congr_arg_kind (@function.extfun_app.{2 1} Type group.{0} h0 congr_arg_kind)  := sorry --non-trivial
lemma new_lemma_68225 (h0 : topological_space (boolean_algebra.core (has_add name))) : irreducible_space (boolean_algebra.core (has_add name)) := sorry --non-trivial
lemma new_lemma_68226 (h0 : functor.add_const (group (omega_complete_partial_order empty)) empty) : @is_cyclic.{0} (omega_complete_partial_order.{0} empty) (@functor.add_const.run.{0 0} (group.{0} (omega_complete_partial_order.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_68227 (h0 : functor.add_const (topological_space (has_neg name)) pos) : @totally_disconnected_space.{0} (has_neg.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (has_neg.{0} name)) pos h0)  := sorry --non-trivial
lemma new_lemma_68228 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @preconnected_space.{0} (finset.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (finset.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_68229 (h0 : topological_space (has_neg_part ennreal)) : locally_compact_space (has_neg_part ennreal) := sorry --non-trivial
lemma new_lemma_68230 (h0 : topological_space (measurable_space (has_inv linarith.comp_source))) : locally_compact_space (measurable_space (has_inv linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_68231 (h0 : topological_space (complete_distrib_lattice num)) : preirreducible_space (complete_distrib_lattice num) := sorry --non-trivial
lemma new_lemma_68232 (h1 : ring (topological_space (random_gen (random_gen char)))) : rank_condition (topological_space (random_gen (random_gen char))) := sorry --non-trivial
lemma new_lemma_68233 (h0 : ring (has_add (has_Inf (has_Inf pos)))) : is_domain (has_add (has_Inf (has_Inf pos))) := sorry --non-trivial
lemma new_lemma_68234 (h0 : functor.add_const (topological_space (normed_comm_ring ennreal)) num) : @preirreducible_space.{0} (normed_comm_ring.{0} ennreal) (@functor.add_const.run.{0 0} (topological_space.{0} (normed_comm_ring.{0} ennreal)) num h0)  := sorry --non-trivial
lemma new_lemma_68235 (h0 : functor.add_const (topological_space (ordered_comm_monoid pos)) pos) : @irreducible_space.{0} (ordered_comm_monoid.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (ordered_comm_monoid.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_68236 (h0 : functor.add_const (list (pseudo_metric_space unsigned)) empty) : list.nodup (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_68237 (h0 : topological_space (random_gen fun_info)) : path_connected_space (random_gen fun_info) := sorry --non-trivial
lemma new_lemma_68238 (h0 : ring (measurable_space (has_ssubset (random_gen fun_info)))) : strong_rank_condition (measurable_space (has_ssubset (random_gen fun_info))) := sorry --non-trivial
lemma new_lemma_68239 (h0 : topological_space (encodable linarith.ineq)) : locally_compact_space (encodable linarith.ineq) := sorry --non-trivial
lemma new_lemma_68240 (h0 : functor.add_const (topological_space (boolean_algebra Type)) environment.implicit_infer_kind) : @normal_space.{1} (boolean_algebra.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (boolean_algebra.{1} Type)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_68241 (h0 : function.extfun Type topological_space) : @t0_space.{0} (semigroup.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (semigroup.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_68242 (h0 : ring (has_emptyc fun_info)) : rank_condition (has_emptyc fun_info) := sorry --non-trivial
lemma new_lemma_68243 (h0 : functor.add_const (monoid (normed_comm_ring Type)) ennreal) : @monoid.fg.{1} (normed_comm_ring.{1} Type) (@functor.add_const.run.{1 0} (monoid.{1} (normed_comm_ring.{1} Type)) ennreal h0)  := sorry --non-trivial
lemma new_lemma_68244 (h0 : not (function.extfun Type topological_space -> false)) : @preirreducible_space.{0} (metric_space.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (metric_space.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_68245 (h0 : monoid (complete_distrib_lattice (finset (finset (finset (finset linarith.comp)))))) : monoid.fg (complete_distrib_lattice (finset (finset (finset (finset linarith.comp))))) := sorry --non-trivial
lemma new_lemma_68246 (h0 : ordered_add_comm_monoid (canonically_ordered_monoid (has_add Type))) : archimedean (canonically_ordered_monoid (has_add Type)) := sorry --non-trivial
lemma new_lemma_68247 (h0 : uniform_space (add_comm_semigroup (add_comm_semigroup char))) : complete_space (add_comm_semigroup (add_comm_semigroup char)) := sorry --non-trivial
lemma new_lemma_68248 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @irreducible_space.{1} (normed_comm_ring.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 topological_space.{1}) (normed_comm_ring.{1} Type))  := sorry --non-trivial
lemma new_lemma_68249 (h0 : linarith.comp_source -> linarith.comp_source -> Prop) (h1 : filter linarith.comp_source) : filter.is_cobounded h0 h1 := sorry --non-trivial
lemma new_lemma_68250 (h0 : function.extfun Type topological_space) : @path_connected_space.{0} (has_to_string.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_to_string.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_68251 (h0 : list (has_add (ring name))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_68252 (h0 : ring (has_neg_part (ring (ring unsigned)))) : is_domain (has_neg_part (ring (ring unsigned))) := sorry --non-trivial
lemma new_lemma_68253 (h0 : complete_lattice (comm_semigroup pos)) : complete_lattice.is_Sup_finite_compact (comm_semigroup pos) := sorry --non-trivial
lemma new_lemma_68254 (h0 : group (complete_distrib_lattice (comm_group (comm_group (semigroup pos))))) : normalizer_condition (complete_distrib_lattice (comm_group (comm_group (semigroup pos)))) := sorry --non-trivial
lemma new_lemma_68255 (h0 : functor.comp topological_space option pos) : @topological_space.separable_space.{0} (option.{0} pos) (@functor.comp.run.{0 0 0} topological_space.{0} option.{0} pos h0)  := sorry --non-trivial
lemma new_lemma_68256 (h0 : functor.add_const (topological_space (measure_theory.measure_space congr_arg_kind)) empty) : @preirreducible_space.{0} (measure_theory.measure_space.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (measure_theory.measure_space.{0} congr_arg_kind)) empty h0)  := sorry --non-trivial
lemma new_lemma_68257 (h0 : function.extfun Type group) : @is_cyclic.{0} (with_one.{0} linarith.comp) (@function.extfun_app.{2 1} Type group.{0} h0 (with_one.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_68258 (h0 : topological_space (option (option (option ennreal)))) : preconnected_space (option (option (option ennreal))) := sorry --non-trivial
lemma new_lemma_68259 (h0 : ring (comm_ring (random_gen linarith.comp_source))) : is_domain (comm_ring (random_gen linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_68260 (h1 : uniform_space (add_comm_semigroup char)) : separated_space (add_comm_semigroup char) := sorry --non-trivial
lemma new_lemma_68261 (h0 : not (function.extfun (finset Type) (has_mem.mem (has_top empty)) -> false)) : @is_domain.{0} (has_top.{0} empty) (@finset.pi.empty.{1 0} Type ring.{0} (has_top.{0} empty) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (has_top.{0} empty)) (@classical.by_contradiction'.{0} (function.extfun.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (has_top.{0} empty))) h0) (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_68262 (h0 : functor.add_const (complete_lattice (add_cancel_monoid Type)) (add_cancel_monoid pos)) : @complete_lattice.is_Sup_finite_compact.{1} (add_cancel_monoid.{1} Type) (@functor.add_const.run.{1 0} (complete_lattice.{1} (add_cancel_monoid.{1} Type)) (add_cancel_monoid.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_68263 (h1 : complete_lattice (ordered_comm_ring char)) : complete_lattice.is_Sup_finite_compact (ordered_comm_ring char) := sorry --non-trivial
lemma new_lemma_68264 (h0 : ring (uniform_space (add_cancel_comm_monoid char))) : strong_rank_condition (uniform_space (add_cancel_comm_monoid char)) := sorry --non-trivial
lemma new_lemma_68265 (h0 : function.extfun Type topological_space) : @loc_path_connected_space.{0} (normed_comm_ring.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (normed_comm_ring.{0} empty))  := sorry --non-trivial
lemma new_lemma_68266 (h0 : function.extfun Type list) : list.nodup (function.extfun_app h0 (measurable_space.dynkin_system unsigned)) := sorry --non-trivial
lemma new_lemma_68267 (h0 : functor.add_const (function.extfun Type ring) name) : @strong_rank_condition.{0} (has_neg.{0} name) (@function.extfun_app.{2 1} Type ring.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type ring.{0}) name h0) (has_neg.{0} name))  := sorry --non-trivial
lemma new_lemma_68268 (h0 : topological_space (has_div ereal)) (h1 : preorder (has_div ereal)) : order_topology (has_div ereal) := sorry --non-trivial
lemma new_lemma_68269 (h0 : functor.add_const (group (finset name)) pos) : @is_cyclic.{0} (finset.{0} name) (@functor.add_const.run.{0 0} (group.{0} (finset.{0} name)) pos h0)  := sorry --non-trivial
lemma new_lemma_68270 (h0 : topological_space (ordered_cancel_add_comm_monoid (option (option ennreal)))) : normal_space (ordered_cancel_add_comm_monoid (option (option ennreal))) := sorry --non-trivial
lemma new_lemma_68271 (h0 : functor.add_const Prop (linear_ordered_field (option congr_arg_kind))) : functor.add_const.run h0 := sorry --non-trivial
lemma new_lemma_68272 (h0 : set (has_scalar char environment.projection_info)) : set.finite h0 := sorry --non-trivial
lemma new_lemma_68273 (h0 : not (has_mem.mem (has_top linarith.ineq) has_emptyc.emptyc -> false)) : @path_connected_space.{0} (has_top.{0} linarith.ineq) (@finset.pi.empty.{1 0} Type topological_space.{0} (has_top.{0} linarith.ineq) (@classical.by_contradiction'.{0} (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (has_top.{0} linarith.ineq) (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))) h0))  := sorry --non-trivial
lemma new_lemma_68274 (h0 : semiring (has_zero (cancel_monoid (has_add name)))) : is_noetherian_ring (has_zero (cancel_monoid (has_add name))) := sorry --non-trivial
lemma new_lemma_68275 (h0 : list (ordered_cancel_add_comm_monoid (option (option empty)))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_68276 (h0 : cancel_comm_monoid_with_zero (add_left_cancel_semigroup (option (option unsigned)))) : unique_factorization_monoid (add_left_cancel_semigroup (option (option unsigned))) := sorry --non-trivial
lemma new_lemma_68277 (h0 : group (has_add (finset (ring (ring linarith.comp))))) : normalizer_condition (has_add (finset (ring (ring linarith.comp)))) := sorry --non-trivial
lemma new_lemma_68278 (h0 : topological_space (denumerable (has_nnnorm linarith.ineq))) : t0_space (denumerable (has_nnnorm linarith.ineq)) := sorry --non-trivial
lemma new_lemma_68279 (h0 : topological_space name) : regular_space name := sorry --non-trivial
lemma new_lemma_68280 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_cyclic.{0} linarith.comp_source (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) linarith.comp_source)  := sorry --non-trivial
lemma new_lemma_68281 (h0 : topological_space (semigroup (ring (mul_one_class (finset Type))))) : sequential_space (semigroup (ring (mul_one_class (finset Type)))) := sorry --non-trivial
lemma new_lemma_68282 (h0 : ring (finset (ring (has_add (has_add Type))))) : is_domain (finset (ring (has_add (has_add Type)))) := sorry --non-trivial
lemma new_lemma_68283 (h0 : function.extfun Type uniform_space) : @complete_space.{0} (with_bot.{0} empty) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (with_bot.{0} empty))  := sorry --non-trivial
lemma new_lemma_68284 (h0 : topological_space (finset (boolean_algebra (boolean_algebra (has_neg Type))))) : discrete_topology (finset (boolean_algebra (boolean_algebra (has_neg Type)))) := sorry --non-trivial
lemma new_lemma_68285 (h0 : topological_space real.angle) : totally_separated_space real.angle := sorry --non-trivial
lemma new_lemma_68286 (h0 : functor.add_const (ordered_add_comm_monoid (has_neg linarith.comp)) (has_pos_part pos)) : @archimedean.{0} (has_neg.{0} linarith.comp) (@functor.add_const.run.{0 0} (ordered_add_comm_monoid.{0} (has_neg.{0} linarith.comp)) (has_pos_part.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_68287 (h0 : functor.add_const (cancel_comm_monoid_with_zero (simple_graph pos)) Type) : @unique_factorization_monoid.{0} (simple_graph.{0} pos) (@functor.add_const.run.{0 1} (cancel_comm_monoid_with_zero.{0} (simple_graph.{0} pos)) Type h0)  := sorry --non-trivial
lemma new_lemma_68288 (h0 : ring (has_norm (with_bot to_additive.value_type))) : rank_condition (has_norm (with_bot to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_68289 (h0 : function.extfun Type complete_lattice) : @is_compactly_generated.{0} (pseudo_metric_space.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (pseudo_metric_space.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_68290 (h0 : function.extfun nat fin) : @rank_condition.{0} (has_add.{0} linarith.comp) (@matrix.vec_empty.{0} (ring.{0} (has_add.{0} linarith.comp)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_68291 (h0 : filter (linear_ordered_field pos)) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_68292 (h0 : filter (metric_space (semiring congr_arg_kind))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_68293 (h0 : functor.add_const (add_group (has_Inf linarith.comp)) Type) : @is_add_cyclic.{0} (has_Inf.{0} linarith.comp) (@functor.add_const.run.{0 1} (add_group.{0} (has_Inf.{0} linarith.comp)) Type h0)  := sorry --non-trivial
lemma new_lemma_68294 (h0 : group (boolean_algebra (ring name))) : normalizer_condition (boolean_algebra (ring name)) := sorry --non-trivial
lemma new_lemma_68295 (h0 : topological_space (has_one (has_top unsigned))) : totally_separated_space (has_one (has_top unsigned)) := sorry --non-trivial
lemma new_lemma_68296 (h0 : add_group (has_zero (has_neg name))) : is_add_cyclic (has_zero (has_neg name)) := sorry --non-trivial
lemma new_lemma_68297 (h0 : ring (complete_distrib_lattice congr_arg_kind)) : is_principal_ideal_ring (complete_distrib_lattice congr_arg_kind) := sorry --non-trivial
lemma new_lemma_68298 (h0 : filter (comm_monoid (option (option unsigned)))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_68299 (h0 : topological_space (complete_distrib_lattice (has_add (ordered_comm_monoid linarith.comp)))) : path_connected_space (complete_distrib_lattice (has_add (ordered_comm_monoid linarith.comp))) := sorry --non-trivial
lemma new_lemma_68300 (h0 : function.extfun Type cancel_comm_monoid_with_zero) : @unique_factorization_monoid.{0} (free_add_monoid.{0} empty) (@function.extfun_app.{2 1} Type cancel_comm_monoid_with_zero.{0} h0 (free_add_monoid.{0} empty))  := sorry --non-trivial
lemma new_lemma_68301 (h0 : topological_space (mul_zero_class (add_comm_monoid Type))) : irreducible_space (mul_zero_class (add_comm_monoid Type)) := sorry --non-trivial
lemma new_lemma_68302 (h0 : function.extfun (finset Type) (has_mem.mem (measurable_space empty))) : complete_lattice.is_Sup_finite_compact (measurable_space empty) := sorry --non-trivial
lemma new_lemma_68303 (h0 : filter (add_left_cancel_monoid (comm_ring (random_gen char)))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_68304 (h0 : group (has_zero (finset environment.implicit_infer_kind))) : group.fg (has_zero (finset environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_68305 (h0 : group (ordered_cancel_add_comm_monoid unsigned)) : is_cyclic (ordered_cancel_add_comm_monoid unsigned) := sorry --non-trivial
lemma new_lemma_68306 (h0 : functor.add_const (ring (boolean_algebra name)) pos) : @strong_rank_condition.{0} (boolean_algebra.{0} name) (@functor.add_const.run.{0 0} (ring.{0} (boolean_algebra.{0} name)) pos h0)  := sorry --non-trivial
lemma new_lemma_68307 (h0 : filter (partial_order (semiring (semiring empty)))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_68308 (h0 : topological_space (normed_group congr_arg_kind)) : topological_space.separable_space (normed_group congr_arg_kind) := sorry --non-trivial
lemma new_lemma_68309 (h0 : functor.add_const (add_group (ordered_comm_ring Type)) (has_add (ring Type))) : @is_add_cyclic.{1} (ordered_comm_ring.{1} Type) (@functor.add_const.run.{1 1} (add_group.{1} (ordered_comm_ring.{1} Type)) (has_add.{1} (ring.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_68310 (h0 : complete_lattice (distrib_lattice linarith.comp_source)) : is_compactly_generated (distrib_lattice linarith.comp_source) := sorry --non-trivial
lemma new_lemma_68311 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @t0_space.{1} (plift.{1} empty) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 topological_space.{1}) (plift.{1} empty))  := sorry --non-trivial
lemma new_lemma_68312 (h0 : function.extfun Type group) : @group.fg.{0} (with_one.{0} (has_nnnorm.{0} linarith.ineq)) (@function.extfun_app.{2 1} Type group.{0} h0 (with_one.{0} (has_nnnorm.{0} linarith.ineq)))  := sorry --non-trivial
lemma new_lemma_68313 (h0 : functor.add_const (filter (has_pos_part pos)) pos) : filter.ne_bot (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_68314 (h0 : function.extfun Type semiring) : @is_noetherian_ring.{0} (normed_lattice_add_comm_group.{0} real) (@function.extfun_app.{2 1} Type semiring.{0} h0 (normed_lattice_add_comm_group.{0} real))  := sorry --non-trivial
lemma new_lemma_68315 (h0 : functor.add_const (topological_space (complete_distrib_lattice pos)) linarith.comp) : @preconnected_space.{0} (complete_distrib_lattice.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (complete_distrib_lattice.{0} pos)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_68316 (h1 : ring (has_top (random_gen string_imp))) : is_domain (has_top (random_gen string_imp)) := sorry --non-trivial
lemma new_lemma_68317 (h0 : topological_space (canonically_ordered_comm_semiring (has_add name))) : totally_separated_space (canonically_ordered_comm_semiring (has_add name)) := sorry --non-trivial
lemma new_lemma_68318 (h0 : function.extfun Type uniform_space) : @separated_space.{0} (canonically_ordered_comm_semiring.{0} empty) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (canonically_ordered_comm_semiring.{0} empty))  := sorry --non-trivial
lemma new_lemma_68319 (h0 : topological_space (random_gen num)) : preirreducible_space (random_gen num) := sorry --non-trivial
lemma new_lemma_68320 (h0 : topological_space (finset (finset Type))) : topological_space.separable_space (finset (finset Type)) := sorry --non-trivial
lemma new_lemma_68321 (h0 : monoid (semiring (measurable_space.dynkin_system unsigned))) : monoid.fg (semiring (measurable_space.dynkin_system unsigned)) := sorry --non-trivial
lemma new_lemma_68322 (h0 : topological_space (measurable_space (semiring (semiring fun_info)))) : irreducible_space (measurable_space (semiring (semiring fun_info))) := sorry --non-trivial
lemma new_lemma_68323 (h0 : function.extfun Type (functor.add_const (topological_space pos))) : @totally_separated_space.{0} pos (@functor.add_const.run.{0 0} (topological_space.{0} pos) unsigned (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (topological_space.{0} pos)) h0 unsigned))  := sorry --non-trivial
lemma new_lemma_68324 (h0 : group (has_compl reducibility_hints)) : is_cyclic (has_compl reducibility_hints) := sorry --non-trivial
lemma new_lemma_68325 (h0 : ordered_comm_monoid (has_nndist (has_add Type))) : has_exists_mul_of_le (has_nndist (has_add Type)) := sorry --non-trivial
lemma new_lemma_68326 (h0 : complete_lattice (has_star congr_arg_kind)) : is_compactly_generated (has_star congr_arg_kind) := sorry --non-trivial
lemma new_lemma_68327 (h0 : complete_lattice (has_add (with_zero to_additive.value_type))) : is_compactly_generated (has_add (with_zero to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_68328 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @locally_compact_space.{0} (has_neg_part.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_neg_part.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_68329 (h0 : functor.add_const (topological_space (has_to_string name)) (has_neg Type)) : @topological_space.separable_space.{0} (has_to_string.{0} name) (@functor.add_const.run.{0 1} (topological_space.{0} (has_to_string.{0} name)) (has_neg.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_68330 (h0 : fin has_zero.zero) : @separated_space.{0} (normed_lattice_add_comm_group.{0} name) (@function.extfun_app.{2 1} Type uniform_space.{0} (@matrix.vec_empty.{1} (function.extfun.{2 1} Type uniform_space.{0}) h0) (normed_lattice_add_comm_group.{0} name))  := sorry --non-trivial
lemma new_lemma_68331 (h0 : topological_space (has_nndist (has_add name))) : sequential_space (has_nndist (has_add name)) := sorry --non-trivial
lemma new_lemma_68332 (h0 : preorder (add_comm_semigroup std_gen)) (h1 : set (add_comm_semigroup std_gen)) : set.is_pwo h1 := sorry --non-trivial
lemma new_lemma_68333 (h0 : functor.add_const (ring (has_nndist unsigned)) linarith.comp) : @rank_condition.{0} (has_nndist.{0} unsigned) (@functor.add_const.run.{0 0} (ring.{0} (has_nndist.{0} unsigned)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_68334 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @totally_separated_space.{0} (ring.{0} ennreal) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (ring.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_68335 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_add_cyclic.{0} (boolean_algebra.core.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type add_group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 add_group.{0}) (boolean_algebra.core.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_68336 (h0 : functor.add_const (topological_space (semigroup unsigned)) (add_comm_monoid Type)) : @totally_disconnected_space.{0} (semigroup.{0} unsigned) (@functor.add_const.run.{0 1} (topological_space.{0} (semigroup.{0} unsigned)) (add_comm_monoid.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_68337 (h0 : not (monoid (has_union congr_arg_kind) -> false)) : @monoid.fg.{0} (has_union.{0} congr_arg_kind) (@classical.by_contradiction'.{1} (monoid.{0} (has_union.{0} congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_68338 (h0 : ring (add_monoid (linear_ordered_add_comm_group string_imp))) : strong_rank_condition (add_monoid (linear_ordered_add_comm_group string_imp)) := sorry --non-trivial
lemma new_lemma_68339 (h0 : functor.add_const (fin has_zero.zero) (has_Inf (has_add name))) : @preconnected_space.{1} (sub_neg_monoid.{1} Type) (@matrix.vec_empty.{1} (topological_space.{1} (sub_neg_monoid.{1} Type)) (@functor.add_const.run.{0 0} (fin (@has_zero.zero.{0} nat nat.has_zero)) (has_Inf.{0} (has_add.{0} name)) h0))  := sorry --non-trivial
lemma new_lemma_68340 (h0 : function.extfun Type topological_space) : @topological_space.separable_space.{0} (preorder.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (preorder.{0} empty))  := sorry --non-trivial
lemma new_lemma_68341 (h2 : add_group (mul_one_class (add_comm_semigroup fun_info))) : is_add_cyclic (mul_one_class (add_comm_semigroup fun_info)) := sorry --non-trivial
lemma new_lemma_68342 (h0 : topological_space (has_add (has_neg Type))) : loc_path_connected_space (has_add (has_neg Type)) := sorry --non-trivial
lemma new_lemma_68343 (h0 : fin has_zero.zero) (h1 : nat) (h2 : vector punit (nat.succ h1)) : category_theory.hom_of_element (matrix.vec_empty h0) (vector.head h2) := sorry --non-trivial
lemma new_lemma_68344 (h1 : ring (distrib_lattice (has_nnnorm (has_nnnorm (has_nnnorm char))))) : is_domain (distrib_lattice (has_nnnorm (has_nnnorm (has_nnnorm char)))) := sorry --non-trivial
lemma new_lemma_68345 (h0 : functor.add_const (group (semigroup empty)) unsigned) : @is_cyclic.{0} (semigroup.{0} empty) (@functor.add_const.run.{0 0} (group.{0} (semigroup.{0} empty)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_68346 (h0 : functor.add_const (prod (mul_zero_class num) (mul_zero_class num)) empty) : id_rel (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_68347 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @monoid.fg.{0} (canonically_linear_ordered_monoid.{0} ennreal) (@function.extfun_app.{2 1} Type monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 monoid.{0}) (canonically_linear_ordered_monoid.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_68348 (h0 : group (complete_distrib_lattice environment.implicit_infer_kind)) : normalizer_condition (complete_distrib_lattice environment.implicit_infer_kind) := sorry --non-trivial
lemma new_lemma_68349 (h0 : functor.add_const (complete_lattice (cancel_monoid pos)) (boolean_algebra name)) : @complete_lattice.is_Sup_finite_compact.{0} (cancel_monoid.{0} pos) (@functor.add_const.run.{0 0} (complete_lattice.{0} (cancel_monoid.{0} pos)) (boolean_algebra.{0} name) h0)  := sorry --non-trivial
lemma new_lemma_68350 (h0 : topological_space (has_neg ennreal)) : irreducible_space (has_neg ennreal) := sorry --non-trivial
lemma new_lemma_68351 (h0 : functor.add_const (uniform_space (semigroup pos)) Type) : @complete_space.{0} (semigroup.{0} pos) (@functor.add_const.run.{0 1} (uniform_space.{0} (semigroup.{0} pos)) Type h0)  := sorry --non-trivial
lemma new_lemma_68352 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @t0_space.{1} (canonically_ordered_monoid.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 topological_space.{1}) (canonically_ordered_monoid.{1} Type))  := sorry --non-trivial
lemma new_lemma_68353 (h0 : functor.add_const (complete_lattice (finset pos)) linarith.comp) : @complete_lattice.is_Sup_finite_compact.{0} (finset.{0} pos) (@functor.add_const.run.{0 0} (complete_lattice.{0} (finset.{0} pos)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_68354 (h0 : functor.add_const (topological_space (boolean_algebra.core Type)) name) : @totally_separated_space.{1} (boolean_algebra.core.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (boolean_algebra.core.{1} Type)) name h0)  := sorry --non-trivial
lemma new_lemma_68355 (h0 : ordered_comm_monoid (normed_comm_ring (boolean_algebra name))) : has_exists_mul_of_le (normed_comm_ring (boolean_algebra name)) := sorry --non-trivial
lemma new_lemma_68356 (h0 : functor.add_const (add_monoid (option empty)) num) : @add_monoid.fg.{0} (option.{0} empty) (@functor.add_const.run.{0 0} (add_monoid.{0} (option.{0} empty)) num h0)  := sorry --non-trivial
lemma new_lemma_68357 (h0 : topological_space (has_zero (has_zero Type))) : preconnected_space (has_zero (has_zero Type)) := sorry --non-trivial
lemma new_lemma_68358 (h0 : has_mem.mem (has_one empty) has_emptyc.emptyc) : @complete_space.{0} (has_one.{0} empty) (@finset.pi.empty.{1 0} Type uniform_space.{0} (has_one.{0} empty) h0)  := sorry --non-trivial
lemma new_lemma_68359 (h0 : topological_space (complete_distrib_lattice (comm_group (comm_group (comm_group (comm_group unsigned)))))) : t1_space (complete_distrib_lattice (comm_group (comm_group (comm_group (comm_group unsigned))))) := sorry --non-trivial
lemma new_lemma_68360 (h0 : uniform_space (normed_field (comm_ring char))) : complete_space (normed_field (comm_ring char)) := sorry --non-trivial
lemma new_lemma_68361 (h0 : functor.add_const (topological_space (has_Inf pos)) pos) : @regular_space.{0} (has_Inf.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (has_Inf.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_68362 (h0 : function.extfun Type ordered_add_comm_monoid) : @archimedean.{0} (canonically_linear_ordered_monoid.{0} ennreal) (@function.extfun_app.{2 1} Type ordered_add_comm_monoid.{0} h0 (canonically_linear_ordered_monoid.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_68363 (h0 : fin has_zero.zero) : @separated_space.{0} (finset.{0} pos) (@matrix.vec_empty.{0} (uniform_space.{0} (finset.{0} pos)) h0)  := sorry --non-trivial
lemma new_lemma_68364 (h0 : function.extfun Type ring) : @strong_rank_condition.{0} (finset.{0} empty) (@function.extfun_app.{2 1} Type ring.{0} h0 (finset.{0} empty))  := sorry --non-trivial
lemma new_lemma_68365 (h2 : topological_space (nondiscrete_normed_field enat)) (h3 : set (nondiscrete_normed_field enat)) : is_path_connected h3 := sorry --non-trivial
lemma new_lemma_68366 (h0 : function.extfun Type ring) : @is_domain.{0} (random_gen.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type ring.{0} h0 (random_gen.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_68367 (h0 : ring (with_zero linarith.ineq)) : rank_condition (with_zero linarith.ineq) := sorry --non-trivial
lemma new_lemma_68368 (h0 : uniform_space (with_bot (semiring unsigned))) : separated_space (with_bot (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_68369 (h0 : not (function.extfun (Type -> Type) (function.extfun Type) -> false)) : @path_connected_space.{0} (complete_linear_order.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) (@classical.by_contradiction'.{2} (function.extfun.{2 2} (Type → Type) (function.extfun.{2 1} Type)) h0) topological_space.{0}) (complete_linear_order.{0} empty))  := sorry --non-trivial
lemma new_lemma_68370 (h0 : not (function.extfun Type complete_lattice -> false)) : @is_atomistic.{0} unsigned (@function.extfun_app.{2 1} Type complete_lattice.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type complete_lattice.{0}) h0) unsigned)  := sorry --non-trivial
lemma new_lemma_68371 (h0 : function.extfun Type topological_space) : @loc_path_connected_space.{0} (comm_group.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (comm_group.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_68372 (h0 : topological_space (metric_space (has_norm unsigned))) : locally_compact_space (metric_space (has_norm unsigned)) := sorry --non-trivial
lemma new_lemma_68373 (h0 : group (generalized_boolean_algebra (has_neg pos))) : is_simple_group (generalized_boolean_algebra (has_neg pos)) := sorry --non-trivial
lemma new_lemma_68374 (h0 : ordered_add_comm_monoid (has_neg_part (boolean_algebra.core ennreal))) : archimedean (has_neg_part (boolean_algebra.core ennreal)) := sorry --non-trivial
lemma new_lemma_68375 (h0 : finset (canonically_ordered_add_monoid empty)) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_68376 (h0 : topological_space (linear_ordered_add_comm_group congr_arg_kind) -> Prop) (h1 : Exists (fun (x : topological_space (linear_ordered_add_comm_group congr_arg_kind)), h0 x)) : @irreducible_space.{0} (linear_ordered_add_comm_group.{0} congr_arg_kind) (@classical.some.{1} (topological_space.{0} (linear_ordered_add_comm_group.{0} congr_arg_kind)) h0 h1)  := sorry --non-trivial
lemma new_lemma_68377 (h0 : uniform_space (linear_ordered_comm_monoid_with_zero (option unsigned))) : separated_space (linear_ordered_comm_monoid_with_zero (option unsigned)) := sorry --non-trivial
lemma new_lemma_68378 (h0 : ring (has_Inf (has_Inf Type))) : rank_condition (has_Inf (has_Inf Type)) := sorry --non-trivial
lemma new_lemma_68379 (h0 : functor.add_const (group (ring linarith.comp)) (has_zero pos)) : @group.fg.{0} (ring.{0} linarith.comp) (@functor.add_const.run.{0 0} (group.{0} (ring.{0} linarith.comp)) (has_zero.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_68380 (h0 : uniform_space (comm_semigroup pos)) : separated_space (comm_semigroup pos) := sorry --non-trivial
lemma new_lemma_68381 (h0 : function.extfun Type complete_lattice) : @complete_lattice.is_Sup_finite_compact.{0} (has_to_string.{0} pos) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (has_to_string.{0} pos))  := sorry --non-trivial
lemma new_lemma_68382 (h0 : cancel_comm_monoid_with_zero (complete_linear_order (semiring congr_arg_kind))) : unique_factorization_monoid (complete_linear_order (semiring congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_68383 (h0 : functor.add_const (complete_lattice (cancel_monoid pos)) (has_add name)) : @is_compactly_generated.{0} (cancel_monoid.{0} pos) (@functor.add_const.run.{0 0} (complete_lattice.{0} (cancel_monoid.{0} pos)) (has_add.{0} name) h0)  := sorry --non-trivial
lemma new_lemma_68384 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_principal_ideal_ring.{0} (bin_tree.{0} unsigned) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (bin_tree.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_68385 (h0 : functor.add_const (topological_space (left_cancel_semigroup congr_arg_kind)) num) : @locally_compact_space.{0} (left_cancel_semigroup.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (left_cancel_semigroup.{0} congr_arg_kind)) num h0)  := sorry --non-trivial
lemma new_lemma_68386 (h1 : function.extfun Type multiset) : @multiset.inf.{0} Prop (@lattice.to_semilattice_inf.{0} Prop (@conditionally_complete_lattice.to_lattice.{0} Prop (@complete_lattice.to_conditionally_complete_lattice.{0} Prop Prop.complete_lattice))) (@bounded_order.to_order_top.{0} Prop (@preorder.to_has_le.{0} Prop (@partial_order.to_preorder.{0} Prop (@semilattice_inf.to_partial_order.{0} Prop (@lattice.to_semilattice_inf.{0} Prop (@conditionally_complete_lattice.to_lattice.{0} Prop (@complete_lattice.to_conditionally_complete_lattice.{0} Prop Prop.complete_lattice)))))) Prop.bounded_order) (@function.extfun_app.{2 1} Type multiset.{0} h1 Prop)  := sorry --non-trivial
lemma new_lemma_68387 (h0 : add_group (ordered_cancel_add_comm_monoid congr_arg_kind)) : is_add_cyclic (ordered_cancel_add_comm_monoid congr_arg_kind) := sorry --non-trivial
lemma new_lemma_68388 (h0 : functor.add_const (topological_space (add_semigroup empty)) empty) : @t0_space.{0} (add_semigroup.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (add_semigroup.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_68389 (h0 : function.extfun Type topological_space) : @loc_path_connected_space.{0} (canonically_ordered_add_monoid.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (canonically_ordered_add_monoid.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_68390 (h0 : functor.add_const (ring (has_neg pos)) pos) : @is_principal_ideal_ring.{0} (has_neg.{0} pos) (@functor.add_const.run.{0 0} (ring.{0} (has_neg.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_68391 (h1 : topological_space linarith.ineq) (h2 : complete_lattice (topological_space.compacts linarith.ineq)) : complete_lattice.is_Sup_finite_compact (topological_space.compacts linarith.ineq) := sorry --non-trivial
lemma new_lemma_68392 (h0 : topological_space (has_top (has_norm (semiring to_additive.value_type)))) : irreducible_space (has_top (has_norm (semiring to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_68393 (h0 : functor.add_const (function.extfun Type group) (boolean_algebra (comm_group unsigned))) : @group.fg.{0} (has_zero.{0} ennreal) (@function.extfun_app.{2 1} Type group.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type group.{0}) (boolean_algebra.{0} (comm_group.{0} unsigned)) h0) (has_zero.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_68394 (h0 : complete_lattice (has_ssubset linarith.comp_source)) : is_atomistic (has_ssubset linarith.comp_source) := sorry --non-trivial
lemma new_lemma_68395 (h0 : topological_space (measurable_space (random_gen linarith.comp_source))) : path_connected_space (measurable_space (random_gen linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_68396 (h0 : functor.add_const (functor.add_const (group Type) environment.implicit_infer_kind) Type) : @normalizer_condition.{1} Type (@functor.add_const.run.{1 0} (group.{1} Type) environment.implicit_infer_kind (@functor.add_const.run.{1 1} (functor.add_const.{1 0} (group.{1} Type) environment.implicit_infer_kind) Type h0))  := sorry --non-trivial
lemma new_lemma_68397 (h0 : functor.add_const (group (partial_order num)) empty) : @normalizer_condition.{0} (partial_order.{0} num) (@functor.add_const.run.{0 0} (group.{0} (partial_order.{0} num)) empty h0)  := sorry --non-trivial
lemma new_lemma_68398 (h0 : ring (left_cancel_monoid num)) : strong_rank_condition (left_cancel_monoid num) := sorry --non-trivial
lemma new_lemma_68399 (h0 : functor.add_const (filter (has_neg unsigned)) name) : countable_Inter_filter (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_68400 (h0 : functor.add_const (topological_space (ordered_ring empty)) empty) : @totally_separated_space.{0} (ordered_ring.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (ordered_ring.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_68401 (h0 : functor.add_const (group (complete_distrib_lattice pos)) environment.implicit_infer_kind) : @is_simple_group.{0} (complete_distrib_lattice.{0} pos) (@functor.add_const.run.{0 0} (group.{0} (complete_distrib_lattice.{0} pos)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_68402 (h0 : function.extfun nat fin) : @preconnected_space.{1} (generalized_boolean_algebra.{1} Type) (@matrix.vec_empty.{1} (topological_space.{1} (generalized_boolean_algebra.{1} Type)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_68403 (h0 : topological_space (has_one (semiring empty))) : locally_compact_space (has_one (semiring empty)) := sorry --non-trivial
lemma new_lemma_68404 (h0 : ring (linear_ordered_add_comm_monoid_with_top unsigned)) : is_domain (linear_ordered_add_comm_monoid_with_top unsigned) := sorry --non-trivial
lemma new_lemma_68405 (h0 : functor.add_const (topological_space (semigroup name)) linarith.comp) : @t1_space.{0} (semigroup.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (semigroup.{0} name)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_68406 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @locally_compact_space.{0} (has_ssubset.{0} linarith.ineq) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_ssubset.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_68407 (h0 : function.extfun Type (prod (partial_order unsigned))) : id_rel (function.extfun_app h0 (partial_order unsigned)) := sorry --non-trivial
lemma new_lemma_68408 (h0 : functor.add_const (function.extfun Type topological_space) Type) : @locally_compact_space.{0} (has_Inf.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type topological_space.{0}) Type h0) (has_Inf.{0} pos))  := sorry --non-trivial
lemma new_lemma_68409 (h0 : ring (semigroup (finset (finset linarith.comp)))) : rank_condition (semigroup (finset (finset linarith.comp))) := sorry --non-trivial
lemma new_lemma_68410 (h0 : functor.add_const (ring (boolean_algebra.core pos)) name) : @strong_rank_condition.{0} (boolean_algebra.core.{0} pos) (@functor.add_const.run.{0 0} (ring.{0} (boolean_algebra.core.{0} pos)) name h0)  := sorry --non-trivial
lemma new_lemma_68411 (h0 : not (add_group (has_sub unsigned) -> false)) : @is_add_cyclic.{0} (has_sub.{0} unsigned) (@classical.by_contradiction'.{1} (add_group.{0} (has_sub.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_68412 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @t0_space.{0} (measurable_space.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (measurable_space.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_68413 (h0 : function.extfun Type topological_space) : @totally_disconnected_space.{0} (has_pos_part.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_pos_part.{0} pos))  := sorry --non-trivial
lemma new_lemma_68414 (h0 : function.extfun Type topological_space) : @locally_compact_space.{0} (left_cancel_monoid.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (left_cancel_monoid.{0} empty))  := sorry --non-trivial
lemma new_lemma_68415 (h0 : functor.add_const (topological_space (boolean_algebra pos)) pos) : @regular_space.{0} (boolean_algebra.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (boolean_algebra.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_68416 (h0 : functor.add_const (topological_space (boolean_algebra linarith.comp)) Type) : @totally_disconnected_space.{0} (boolean_algebra.{0} linarith.comp) (@functor.add_const.run.{0 1} (topological_space.{0} (boolean_algebra.{0} linarith.comp)) Type h0)  := sorry --non-trivial
lemma new_lemma_68417 (h0 : function.extfun Type uniform_space) : @separated_space.{0} (cancel_monoid.{0} ennreal) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (cancel_monoid.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_68418 (h0 : group (complete_linear_order unsigned)) : normalizer_condition (complete_linear_order unsigned) := sorry --non-trivial
lemma new_lemma_68419 (h0 : fun_info -> Prop) : zzz_forall h0 := sorry --non-trivial
lemma new_lemma_68420 (h0 : function.extfun nat fin) : @preconnected_space.{0} (ordered_comm_monoid.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} (@matrix.vec_empty.{1} (function.extfun.{2 1} Type topological_space.{0}) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero))) (ordered_comm_monoid.{0} name))  := sorry --non-trivial
lemma new_lemma_68421 (h0 : functor.add_const (function.extfun Type topological_space) pos) : @locally_compact_space.{0} (has_to_string.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) pos h0) (has_to_string.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_68422 (h1 : uniform_space (comm_ring to_additive.value_type)) : complete_space (comm_ring to_additive.value_type) := sorry --non-trivial
lemma new_lemma_68423 (h0 : topological_space (plift (semiring num))) : totally_separated_space (plift (semiring num)) := sorry --non-trivial
lemma new_lemma_68424 (h0 : function.extfun Type semiring) : @is_noetherian_ring.{0} (sub_neg_monoid.{0} pos) (@function.extfun_app.{2 1} Type semiring.{0} h0 (sub_neg_monoid.{0} pos))  := sorry --non-trivial
lemma new_lemma_68425 (h0 : uniform_space (with_bot (has_top (has_norm (has_norm linarith.comp))))) : complete_space (with_bot (has_top (has_norm (has_norm linarith.comp)))) := sorry --non-trivial
lemma new_lemma_68426 (h1 : topological_space string.iterator_imp) : topological_space.first_countable_topology string.iterator_imp := sorry --non-trivial
lemma new_lemma_68427 (h0 : uniform_space (complete_distrib_lattice (boolean_algebra.core name))) : complete_space (complete_distrib_lattice (boolean_algebra.core name)) := sorry --non-trivial
lemma new_lemma_68428 (h0 : topological_space (fintype (random_gen char))) : path_connected_space (fintype (random_gen char)) := sorry --non-trivial
lemma new_lemma_68429 (h0 : topological_space (has_neg (has_add pos))) : topological_space.separable_space (has_neg (has_add pos)) := sorry --non-trivial
lemma new_lemma_68430 (h0 : topological_space (random_gen linarith.ineq)) : irreducible_space (random_gen linarith.ineq) := sorry --non-trivial
lemma new_lemma_68431 (h5 : uniform_space (div_inv_monoid fun_info)) : complete_space (div_inv_monoid fun_info) := sorry --non-trivial
lemma new_lemma_68432 (h0 : function.extfun Type ring) : @rank_condition.{0} (complete_distrib_lattice.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type ring.{0} h0 (complete_distrib_lattice.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_68433 (h0 : topological_space (add_comm_monoid (has_neg_part (comm_group (has_add Type))))) : preirreducible_space (add_comm_monoid (has_neg_part (comm_group (has_add Type)))) := sorry --non-trivial
lemma new_lemma_68434 (h0 : ring (option (semiring (semiring congr_arg_kind)))) : is_domain (option (semiring (semiring congr_arg_kind))) := sorry --non-trivial
lemma new_lemma_68435 (h0 : ring (linear_ordered_semiring (has_top empty))) : is_domain (linear_ordered_semiring (has_top empty)) := sorry --non-trivial
lemma new_lemma_68436 (h0 : function.extfun Type complete_lattice) : @is_atomistic.{0} (normed_group.{0} linarith.ineq) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (normed_group.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_68437 (h0 : not (ring (random_gen (random_gen reducibility_hints)) -> false)) : @rank_condition.{0} (random_gen.{0} (random_gen.{0} reducibility_hints)) (@classical.by_contradiction'.{1} (ring.{0} (random_gen.{0} (random_gen.{0} reducibility_hints))) h0)  := sorry --non-trivial
lemma new_lemma_68438 (h0 : not (filter (has_top congr_arg_kind) -> false)) : filter.ne_bot (classical.by_contradiction' h0) := sorry --non-trivial
lemma new_lemma_68439 (h0 : topological_space fun_info) (h1 : not (ring (connected_components fun_info) -> false)) : @is_domain.{0} (@connected_components.{0} fun_info h0) (@classical.by_contradiction'.{1} (ring.{0} (@connected_components.{0} fun_info h0)) h1)  := sorry --non-trivial
lemma new_lemma_68440 (h0 : not (topological_space (has_add num) -> false)) : @preirreducible_space.{0} (has_add.{0} num) (@classical.by_contradiction'.{1} (topological_space.{0} (has_add.{0} num)) h0)  := sorry --non-trivial
lemma new_lemma_68441 (h0 : group (has_add (option ennreal))) : is_cyclic (has_add (option ennreal)) := sorry --non-trivial
lemma new_lemma_68442 (h0 : fin has_zero.zero) : @is_principal_ideal_ring.{0} (has_nndist.{0} linarith.comp) (@matrix.vec_empty.{0} (ring.{0} (has_nndist.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_68443 (h0 : prod (partial_order empty) (partial_order empty)) : id_rel h0 := sorry --non-trivial
lemma new_lemma_68444 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @rank_condition.{0} (has_neg.{0} pos) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (has_neg.{0} pos))  := sorry --non-trivial
lemma new_lemma_68445 (h0 : filter (has_to_string (has_add Type))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_68446 (h0 : function.extfun Type uniform_space) : @separated_space.{0} (has_Sup.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (has_Sup.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_68447 (h0 : not (function.extfun Type topological_space -> false)) : @totally_disconnected_space.{0} (has_one.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (has_one.{0} empty))  := sorry --non-trivial
lemma new_lemma_68448 (h0 : group (semi_normed_ring (random_gen char))) : is_cyclic (semi_normed_ring (random_gen char)) := sorry --non-trivial
lemma new_lemma_68449 (h0 : topological_space (has_ssubset (has_subset fun_info))) : totally_disconnected_space (has_ssubset (has_subset fun_info)) := sorry --non-trivial
lemma new_lemma_68450 (h0 : group (normed_lattice_add_comm_group (has_add (has_add pos)))) : normalizer_condition (normed_lattice_add_comm_group (has_add (has_add pos))) := sorry --non-trivial
lemma new_lemma_68451 (h0 : topological_space (left_cancel_monoid (semiring congr_arg_kind))) : preirreducible_space (left_cancel_monoid (semiring congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_68452 (h0 : ring (boolean_algebra (has_add Type))) : rank_condition (boolean_algebra (has_add Type)) := sorry --non-trivial
lemma new_lemma_68453 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @topological_space.separable_space.{0} (simple_graph.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (simple_graph.{0} pos))  := sorry --non-trivial
lemma new_lemma_68454 (h0 : add_group (simple_graph (has_lt reducibility_hints))) : is_add_cyclic (simple_graph (has_lt reducibility_hints)) := sorry --non-trivial
lemma new_lemma_68455 (h0 : fin has_zero.zero) : @normal_space.{0} pos (@matrix.vec_empty.{0} (topological_space.{0} pos) (@matrix.vec_empty.{0} (fin (@has_zero.zero.{0} nat nat.has_zero)) h0))  := sorry --non-trivial
lemma new_lemma_68456 (h0 h1 : multiset (has_compl string_imp)) : multiset.disjoint h0 h1 := sorry --non-trivial
lemma new_lemma_68457 (h0 : ring (id (option empty))) : is_domain (id (option empty)) := sorry --non-trivial
lemma new_lemma_68458 (h0 : function.extfun Type complete_lattice) : @complete_lattice.is_Sup_finite_compact.{0} (ring.{0} empty) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (ring.{0} empty))  := sorry --non-trivial
lemma new_lemma_68459 (h0 : topological_space (has_sub (has_top empty))) : discrete_topology (has_sub (has_top empty)) := sorry --non-trivial
lemma new_lemma_68460 (h0 : functor.add_const (complete_lattice (complete_distrib_lattice ennreal)) ennreal) : @is_atomistic.{0} (complete_distrib_lattice.{0} ennreal) (@functor.add_const.run.{0 0} (complete_lattice.{0} (complete_distrib_lattice.{0} ennreal)) ennreal h0)  := sorry --non-trivial
lemma new_lemma_68461 (h0 : functor.add_const (topological_space (bin_tree empty)) num) : @totally_separated_space.{0} (bin_tree.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (bin_tree.{0} empty)) num h0)  := sorry --non-trivial
lemma new_lemma_68462 (h0 : semiring (normed_lattice_add_comm_group (option num))) : is_noetherian_ring (normed_lattice_add_comm_group (option num)) := sorry --non-trivial
lemma new_lemma_68463 (h0 : functor.add_const (finset (boolean_algebra Type)) environment.implicit_infer_kind) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_68464 (h0 : group (boolean_algebra (finset pos))) : is_cyclic (boolean_algebra (finset pos)) := sorry --non-trivial
lemma new_lemma_68465 (h0 : functor.add_const (complete_lattice (has_neg_part pos)) (option ennreal)) : @complete_lattice.is_Sup_finite_compact.{0} (has_neg_part.{0} pos) (@functor.add_const.run.{0 0} (complete_lattice.{0} (has_neg_part.{0} pos)) (option.{0} ennreal) h0)  := sorry --non-trivial
lemma new_lemma_68466 (h0 : ring (normed_group (random_gen (comm_ring string_imp)))) : is_domain (normed_group (random_gen (comm_ring string_imp))) := sorry --non-trivial
lemma new_lemma_68467 (h0 : group (has_inv (has_nnnorm (random_gen (random_gen (has_inv to_additive.value_type)))))) : is_cyclic (has_inv (has_nnnorm (random_gen (random_gen (has_inv to_additive.value_type))))) := sorry --non-trivial
lemma new_lemma_68468 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_cyclic.{0} (complete_semilattice_Sup.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (complete_semilattice_Sup.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_68469 (h0 : not (group (semiring empty) -> false)) : @normalizer_condition.{0} (semiring.{0} empty) (@classical.by_contradiction'.{1} (group.{0} (semiring.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_68470 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @locally_compact_space.{0} (canonically_ordered_comm_semiring.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (canonically_ordered_comm_semiring.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_68471 (h0 : functor.add_const (group (normed_comm_ring Type)) name) : @is_cyclic.{1} (normed_comm_ring.{1} Type) (@functor.add_const.run.{1 0} (group.{1} (normed_comm_ring.{1} Type)) name h0)  := sorry --non-trivial
lemma new_lemma_68472 (h0 : add_monoid (add_cancel_monoid (ring (finset linarith.comp)))) : add_monoid.fg (add_cancel_monoid (ring (finset linarith.comp))) := sorry --non-trivial
lemma new_lemma_68473 (h0 : function.extfun Type topological_space) : @irreducible_space.{0} (with_one.{0} string_imp) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (with_one.{0} string_imp))  := sorry --non-trivial
lemma new_lemma_68474 (h0 : ordered_comm_monoid (normed_lattice_add_comm_group (sub_neg_monoid (has_add real)))) : has_exists_mul_of_le (normed_lattice_add_comm_group (sub_neg_monoid (has_add real))) := sorry --non-trivial
lemma new_lemma_68475 (h0 : functor.add_const (semiring (boolean_algebra pos)) (ring (has_nndist pos))) : @is_noetherian_ring.{0} (boolean_algebra.{0} pos) (@functor.add_const.run.{0 0} (semiring.{0} (boolean_algebra.{0} pos)) (ring.{0} (has_nndist.{0} pos)) h0)  := sorry --non-trivial
lemma new_lemma_68476 (h2 : topological_space (denumerable (has_nnnorm (has_nnnorm (has_nnnorm (has_nnnorm (has_nnnorm char))))))) : t0_space (denumerable (has_nnnorm (has_nnnorm (has_nnnorm (has_nnnorm (has_nnnorm char)))))) := sorry --non-trivial
lemma new_lemma_68477 (h0 : topological_space (comm_ring (comm_ring (normed_field linarith.comp_source)))) : t0_space (comm_ring (comm_ring (normed_field linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_68478 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_domain.{0} (finset.{0} pos) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (finset.{0} pos))  := sorry --non-trivial
lemma new_lemma_68479 (h0 : uniform_space (has_emptyc string_imp)) : complete_space (has_emptyc string_imp) := sorry --non-trivial
lemma new_lemma_68480 (h0 : functor.add_const (add_group (filter unsigned)) unsigned) : @is_add_cyclic.{0} (filter.{0} unsigned) (@functor.add_const.run.{0 0} (add_group.{0} (filter.{0} unsigned)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_68481 (h0 : add_group (boolean_algebra (has_pos_part (has_add environment.implicit_infer_kind)))) : is_add_cyclic (boolean_algebra (has_pos_part (has_add environment.implicit_infer_kind))) := sorry --non-trivial
lemma new_lemma_68482 (h1 : ring (has_ssubset fun_info)) : rank_condition (has_ssubset fun_info) := sorry --non-trivial
lemma new_lemma_68483 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @totally_disconnected_space.{0} (has_sdiff.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_sdiff.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_68484 (h0 : list (measurable_space (has_norm to_additive.value_type))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_68485 (h0 : not (ring (semiring congr_arg_kind) -> false)) : @strong_rank_condition.{0} (semiring.{0} congr_arg_kind) (@classical.by_contradiction'.{1} (ring.{0} (semiring.{0} congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_68486 (h0 : topological_space (has_to_string (option ennreal))) : preconnected_space (has_to_string (option ennreal)) := sorry --non-trivial
lemma new_lemma_68487 (h0 : function.extfun Type topological_space) : @totally_disconnected_space.{0} (topological_space.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (topological_space.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_68488 (h0 : group (semiring to_additive.value_type)) : is_cyclic (semiring to_additive.value_type) := sorry --non-trivial
lemma new_lemma_68489 (h1 : topological_space (simple_graph (group reducibility_hints))) : totally_disconnected_space (simple_graph (group reducibility_hints)) := sorry --non-trivial
lemma new_lemma_68490 (h1 : topological_space (random_gen char)) : path_connected_space (random_gen char) := sorry --non-trivial
lemma new_lemma_68491 (h0 : not (ring (has_add fun_info) -> false)) : @is_domain.{0} (has_add.{0} fun_info) (@classical.by_contradiction'.{1} (ring.{0} (has_add.{0} fun_info)) h0)  := sorry --non-trivial
lemma new_lemma_68492 (h0 : functor.add_const (topological_space (linear_order empty)) congr_arg_kind) : @discrete_topology.{0} (linear_order.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (linear_order.{0} empty)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_68493 (h0 : add_group (has_norm (has_norm (has_norm (has_norm congr_arg_kind))))) : is_add_cyclic (has_norm (has_norm (has_norm (has_norm congr_arg_kind)))) := sorry --non-trivial
lemma new_lemma_68494 (h0 : functor.add_const (function.extfun Type add_group) (has_neg (has_neg environment.implicit_infer_kind))) : @is_add_cyclic.{0} (boolean_algebra.{0} linarith.comp) (@function.extfun_app.{2 1} Type add_group.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type add_group.{0}) (has_neg.{0} (has_neg.{0} environment.implicit_infer_kind)) h0) (boolean_algebra.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_68495 (h0 : ring (mul_zero_class (semiring unsigned))) : is_principal_ideal_ring (mul_zero_class (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_68496 (h0 : function.extfun nat fin) : @normalizer_condition.{1} (ordered_comm_monoid.{1} Type) (@matrix.vec_empty.{1} (group.{1} (ordered_comm_monoid.{1} Type)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_68497 (h0 : functor.comp topological_space has_zero pos) : @irreducible_space.{0} (has_zero.{0} pos) (@functor.comp.run.{0 0 0} topological_space.{0} has_zero.{0} pos h0)  := sorry --non-trivial
lemma new_lemma_68498 (h0 : topological_space (add_comm_monoid (comm_group name))) : normal_space (add_comm_monoid (comm_group name)) := sorry --non-trivial
lemma new_lemma_68499 (h0 : functor.add_const (ring (free_add_monoid num)) empty) : @rank_condition.{0} (free_add_monoid.{0} num) (@functor.add_const.run.{0 0} (ring.{0} (free_add_monoid.{0} num)) empty h0)  := sorry --non-trivial
lemma new_lemma_68500 (h0 : function.extfun Type (functor.comp topological_space ring)) : @locally_compact_space.{0} (ring.{0} pos) (@functor.comp.run.{0 0 0} topological_space.{0} ring.{0} pos (@function.extfun_app.{2 1} Type (functor.comp.{0 0 0} topological_space.{0} ring.{0}) h0 pos))  := sorry --non-trivial
lemma new_lemma_68501 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @unique_factorization_monoid.{0} (comm_semigroup.{0} real) (@function.extfun_app.{2 1} Type cancel_comm_monoid_with_zero.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 cancel_comm_monoid_with_zero.{0}) (comm_semigroup.{0} real))  := sorry --non-trivial
lemma new_lemma_68502 (h0 : functor.add_const (ordered_add_comm_monoid (simple_graph Type)) (has_neg pos)) : @archimedean.{1} (simple_graph.{1} Type) (@functor.add_const.run.{1 0} (ordered_add_comm_monoid.{1} (simple_graph.{1} Type)) (has_neg.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_68503 (h0 : functor.add_const (function.extfun Type topological_space) (ring (has_add linarith.comp))) : @regular_space.{0} (add_cancel_monoid.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) (ring.{0} (has_add.{0} linarith.comp)) h0) (add_cancel_monoid.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_68504 (h0 : functor.comp topological_space has_to_string environment.implicit_infer_kind) : @preirreducible_space.{0} (has_to_string.{0} environment.implicit_infer_kind) (@functor.comp.run.{0 0 0} topological_space.{0} has_to_string.{0} environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_68505 (h0 : add_monoid (finset (comm_group name))) : add_monoid.fg (finset (comm_group name)) := sorry --non-trivial
lemma new_lemma_68506 (h1 : ring (has_add (has_nnnorm char))) : rank_condition (has_add (has_nnnorm char)) := sorry --non-trivial
lemma new_lemma_68507 (h0 : function.extfun Type topological_space) : @totally_separated_space.{0} (semiring.{0} (semiring.{0} (semiring.{0} empty))) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (semiring.{0} (semiring.{0} (semiring.{0} empty))))  := sorry --non-trivial
lemma new_lemma_68508 (h0 : function.extfun Type topological_space) : @regular_space.{0} (has_neg_part.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_neg_part.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_68509 (h0 : fin has_zero.zero) : @is_principal_ideal_ring.{0} (boolean_algebra.{0} pos) (@matrix.vec_empty.{0} (ring.{0} (boolean_algebra.{0} pos)) h0)  := sorry --non-trivial
lemma new_lemma_68510 (h0 : ring (add_comm_monoid (finset name))) : rank_condition (add_comm_monoid (finset name)) := sorry --non-trivial
lemma new_lemma_68511 (h1 : topological_space (has_emptyc to_additive.value_type)) : totally_disconnected_space (has_emptyc to_additive.value_type) := sorry --non-trivial
lemma new_lemma_68512 (h0 : ring (normed_comm_ring pos)) : is_domain (normed_comm_ring pos) := sorry --non-trivial
lemma new_lemma_68513 (h0 : function.extfun Type ring) : @rank_condition.{0} (has_add.{0} (has_add.{0} linarith.comp)) (@function.extfun_app.{2 1} Type ring.{0} h0 (has_add.{0} (has_add.{0} linarith.comp)))  := sorry --non-trivial
lemma new_lemma_68514 (h0 : functor.add_const (topological_space (measurable_space.dynkin_system num)) num) : @t0_space.{0} (measurable_space.dynkin_system.{0} num) (@functor.add_const.run.{0 0} (topological_space.{0} (measurable_space.dynkin_system.{0} num)) num h0)  := sorry --non-trivial
lemma new_lemma_68515 (h0 : filter (has_add (has_add linarith.comp))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_68516 (h0 : uniform_space (preorder (option (option (option (option (option unsigned))))))) : complete_space (preorder (option (option (option (option (option unsigned)))))) := sorry --non-trivial
lemma new_lemma_68517 (h0 : group (generalized_boolean_algebra (ordered_comm_monoid (comm_semigroup pos)))) : is_cyclic (generalized_boolean_algebra (ordered_comm_monoid (comm_semigroup pos))) := sorry --non-trivial
lemma new_lemma_68518 (h0 : functor.add_const (topological_space (has_zero unsigned)) (option unsigned)) : @regular_space.{0} (has_zero.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (has_zero.{0} unsigned)) (option.{0} unsigned) h0)  := sorry --non-trivial
lemma new_lemma_68519 (h0 : functor.add_const (topological_space (has_dist unsigned)) congr_arg_kind) : @t0_space.{0} (has_dist.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (has_dist.{0} unsigned)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_68520 (h0 : functor.add_const (function.extfun Type semiring) pos) : @is_noetherian_ring.{0} (comm_group.{0} linarith.comp) (@function.extfun_app.{2 1} Type semiring.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type semiring.{0}) pos h0) (comm_group.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_68521 (h0 : function.extfun Type topological_space) : @totally_disconnected_space.{0} (complete_semilattice_Sup.{0} fun_info) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (complete_semilattice_Sup.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_68522 (h0 : function.extfun (nat -> Type) (function.extfun nat)) : @archimedean.{1} (has_bot.{1} Type) (@matrix.vec_empty.{1} (ordered_add_comm_monoid.{1} (has_bot.{1} Type)) (@function.extfun_app.{1 1} nat fin (@function.extfun_app.{2 1} (nat → Type) (function.extfun.{1 1} nat) h0 fin) (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_68523 (h0 : complete_lattice (mul_one_class linarith.ineq)) : complete_lattice.is_Sup_finite_compact (mul_one_class linarith.ineq) := sorry --non-trivial
lemma new_lemma_68524 (h0 : add_monoid (semigroup name)) : add_monoid.fg (semigroup name) := sorry --non-trivial
lemma new_lemma_68525 (h0 : functor.add_const (filter (complete_distrib_lattice unsigned)) linarith.comp) : filter.ne_bot (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_68526 (h0 : function.extfun Type filter) : countable_Inter_filter (function.extfun_app h0 (mul_zero_class name)) := sorry --non-trivial
lemma new_lemma_68527 (h0 : functor.add_const (function.extfun Type group) (has_add linarith.comp)) : @group.fg.{0} (has_pos_part.{0} linarith.comp) (@function.extfun_app.{2 1} Type group.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type group.{0}) (has_add.{0} linarith.comp) h0) (has_pos_part.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_68528 (h0 : has_mem.mem (with_one linarith.comp_source) has_emptyc.emptyc) : @monoid.fg.{0} (with_one.{0} linarith.comp_source) (@finset.pi.empty.{1 0} Type monoid.{0} (with_one.{0} linarith.comp_source) h0)  := sorry --non-trivial
lemma new_lemma_68529 (h0 : functor.add_const (topological_space (normed_comm_ring Type)) linarith.comp) : @normal_space.{1} (normed_comm_ring.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (normed_comm_ring.{1} Type)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_68530 (h0 : list (linear_ordered_add_comm_group (has_ssubset (has_ssubset fun_info)))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_68531 (h0 : not (ring (semi_normed_ring (mul_one_class string.iterator_imp)) -> false)) : @is_domain.{0} (semi_normed_ring.{0} (mul_one_class.{0} string.iterator_imp)) (@classical.by_contradiction'.{1} (ring.{0} (semi_normed_ring.{0} (mul_one_class.{0} string.iterator_imp))) h0)  := sorry --non-trivial
lemma new_lemma_68532 (h0 : functor.add_const (topological_space (add_cancel_monoid Type)) name) : @loc_path_connected_space.{1} (add_cancel_monoid.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (add_cancel_monoid.{1} Type)) name h0)  := sorry --non-trivial
lemma new_lemma_68533 (h0 : ring (left_cancel_monoid congr_arg_kind)) : is_principal_ideal_ring (left_cancel_monoid congr_arg_kind) := sorry --non-trivial
lemma new_lemma_68534 (h0 : ring (option ennreal)) : strong_rank_condition (option ennreal) := sorry --non-trivial
lemma new_lemma_68535 (h0 : not (has_mem.mem (measurable_space linarith.comp_source) has_emptyc.emptyc -> false)) : @totally_disconnected_space.{0} (measurable_space.{0} linarith.comp_source) (@finset.pi.empty.{1 0} Type topological_space.{0} (measurable_space.{0} linarith.comp_source) (@classical.by_contradiction'.{0} (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (measurable_space.{0} linarith.comp_source) (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))) h0))  := sorry --non-trivial
lemma new_lemma_68536 (h0 : add_group (comm_ring (random_gen to_additive.value_type))) : is_add_cyclic (comm_ring (random_gen to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_68537 (h0 : ordered_comm_monoid (has_pos_part (ring (has_Inf (has_Inf (has_Inf pos)))))) : has_exists_mul_of_le (has_pos_part (ring (has_Inf (has_Inf (has_Inf pos))))) := sorry --non-trivial
lemma new_lemma_68538 (h0 : functor.add_const (semiring (ring linarith.comp)) Type) : @is_noetherian_ring.{0} (ring.{0} linarith.comp) (@functor.add_const.run.{0 1} (semiring.{0} (ring.{0} linarith.comp)) Type h0)  := sorry --non-trivial
lemma new_lemma_68539 (h0 : functor.add_const (topological_space (boolean_algebra.core pos)) pos) : @path_connected_space.{0} (boolean_algebra.core.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (boolean_algebra.core.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_68540 (h0 : functor.add_const (topological_space (canonically_ordered_add_monoid empty)) empty) : @discrete_topology.{0} (canonically_ordered_add_monoid.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (canonically_ordered_add_monoid.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_68541 (h0 : not (function.extfun Type ring -> false)) : @is_domain.{0} (has_union.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type ring.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type ring.{0}) h0) (has_union.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_68542 (h0 : filter (semigroup (option pos))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_68543 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_domain.{0} (has_ssubset.{0} (has_ssubset.{0} linarith.ineq)) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (has_ssubset.{0} (has_ssubset.{0} linarith.ineq)))  := sorry --non-trivial
lemma new_lemma_68544 (h0 : function.extfun (Type 1) topological_space) : @totally_separated_space.{1} (add_cancel_monoid.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} h0 (add_cancel_monoid.{1} Type))  := sorry --non-trivial
lemma new_lemma_68545 (h0 : preorder (random_gen char)) (h1 : set (random_gen char)) : bdd_above h1 := sorry --non-trivial
lemma new_lemma_68546 (h0 : group (has_ssubset (has_ssubset linarith.ineq))) : group.fg (has_ssubset (has_ssubset linarith.ineq)) := sorry --non-trivial
lemma new_lemma_68547 (h0 : functor.add_const (topological_space (option empty)) empty) : @t0_space.{0} (option.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (option.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_68548 (h0 : function.extfun Type (functor.add_const (topological_space (ordered_ring unsigned)))) : @locally_compact_space.{0} (ordered_ring.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (ordered_ring.{0} unsigned)) empty (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (topological_space.{0} (ordered_ring.{0} unsigned))) h0 empty))  := sorry --non-trivial
lemma new_lemma_68549 (h0 : topological_space (has_star (semiring num))) : preirreducible_space (has_star (semiring num)) := sorry --non-trivial
lemma new_lemma_68550 (h0 : function.extfun Type topological_space) : @discrete_topology.{0} (add_comm_monoid.{0} real) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (add_comm_monoid.{0} real))  := sorry --non-trivial
lemma new_lemma_68551 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : list.nodup (function.extfun_app (function.extfun_app h0 list) (has_pos_part linarith.comp)) := sorry --non-trivial
lemma new_lemma_68552 (h0 : function.extfun (finset Type) (has_mem.mem congr_arg_kind)) : @path_connected_space.{0} congr_arg_kind (@finset.pi.empty.{1 0} Type topological_space.{0} congr_arg_kind (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) congr_arg_kind) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_68553 (h0 : list (has_to_string (option pos))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_68554 (h1 : ring (distrib_lattice char)) : strong_rank_condition (distrib_lattice char) := sorry --non-trivial
lemma new_lemma_68555 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_atomistic.{0} (has_bot.{0} real) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (has_bot.{0} real))  := sorry --non-trivial
lemma new_lemma_68556 (h0 : ring (random_gen (has_lt string_imp))) : is_domain (random_gen (has_lt string_imp)) := sorry --non-trivial
lemma new_lemma_68557 (h0 : ring (has_nndist (normed_comm_ring (finset (ring linarith.comp))))) : strong_rank_condition (has_nndist (normed_comm_ring (finset (ring linarith.comp)))) := sorry --non-trivial
lemma new_lemma_68558 (h0 : not (finset (has_inf unsigned) -> false)) : finset.nonempty (classical.by_contradiction' h0) := sorry --non-trivial
lemma new_lemma_68559 (h0 : topological_space (has_norm (with_bot (with_bot (with_bot linarith.comp_source))))) : path_connected_space (has_norm (with_bot (with_bot (with_bot linarith.comp_source)))) := sorry --non-trivial
lemma new_lemma_68560 (h3 : complete_lattice (semi_normed_ring (has_nnnorm char))) : complete_lattice.is_Sup_finite_compact (semi_normed_ring (has_nnnorm char)) := sorry --non-trivial
lemma new_lemma_68561 (h0 : monoid (finset linarith.comp)) : monoid.fg (finset linarith.comp) := sorry --non-trivial
lemma new_lemma_68562 (h0 : functor.add_const (function.extfun Type topological_space) (has_add (has_add pos))) : @path_connected_space.{0} (ordered_comm_ring.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) (has_add.{0} (has_add.{0} pos)) h0) (ordered_comm_ring.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_68563 (h0 : ordered_comm_monoid (normed_lattice_add_comm_group (has_add pos))) : has_exists_mul_of_le (normed_lattice_add_comm_group (has_add pos)) := sorry --non-trivial
lemma new_lemma_68564 (h0 : not (ring (simple_graph enat) -> false)) : @strong_rank_condition.{0} (simple_graph.{0} enat) (@classical.by_contradiction'.{1} (ring.{0} (simple_graph.{0} enat)) h0)  := sorry --non-trivial
lemma new_lemma_68565 (h0 : functor.add_const (topological_space (cancel_monoid linarith.comp)) name) : @irreducible_space.{0} (cancel_monoid.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (cancel_monoid.{0} linarith.comp)) name h0)  := sorry --non-trivial
lemma new_lemma_68566 (h0 : function.extfun Type (functor.add_const (function.extfun Type ordered_comm_monoid))) : @has_exists_mul_of_le.{0} (has_nndist.{0} linarith.comp) (@function.extfun_app.{2 1} Type ordered_comm_monoid.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type ordered_comm_monoid.{0}) pos (@function.extfun_app.{2 2} Type (functor.add_const.{1 0} (function.extfun.{2 1} Type ordered_comm_monoid.{0})) h0 pos)) (has_nndist.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_68567 (h0 : prod (cancel_monoid empty) (cancel_monoid empty)) : id_rel h0 := sorry --non-trivial
lemma new_lemma_68568 (h0 : not (uniform_space (add_monoid fun_info) -> false)) : @complete_space.{0} (add_monoid.{0} fun_info) (@classical.by_contradiction'.{1} (uniform_space.{0} (add_monoid.{0} fun_info)) h0)  := sorry --non-trivial
lemma new_lemma_68569 (h0 : ring (division_ring (random_gen num))) : is_domain (division_ring (random_gen num)) := sorry --non-trivial
lemma new_lemma_68570 (h0 : topological_space (boolean_algebra.core (has_neg linarith.comp))) : path_connected_space (boolean_algebra.core (has_neg linarith.comp)) := sorry --non-trivial
lemma new_lemma_68571 (h0 : finset Type) (h1 h2 : Pi (i : Type), has_lt i) (h3 : Pi (j : Type), decidable (has_mem.mem j h0)) : no_max_order (mul_one_class to_additive.value_type) := sorry --non-trivial
lemma new_lemma_68572 (h0 : topological_space (has_neg_part (has_neg_part (ring unsigned)))) : totally_separated_space (has_neg_part (has_neg_part (ring unsigned))) := sorry --non-trivial
lemma new_lemma_68573 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @add_monoid.fg.{0} (boolean_algebra.{0} pos) (@function.extfun_app.{2 1} Type add_monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 add_monoid.{0}) (boolean_algebra.{0} pos))  := sorry --non-trivial
lemma new_lemma_68574 (h0 : prod (add_monoid enat) (add_monoid enat)) : set.diagonal (add_monoid enat) h0 := sorry --non-trivial
lemma new_lemma_68575 (h0 : has_mem.mem (has_top num) has_emptyc.emptyc) : @is_compactly_generated.{0} (has_top.{0} num) (@finset.pi.empty.{1 0} Type complete_lattice.{0} (has_top.{0} num) h0)  := sorry --non-trivial
lemma new_lemma_68576 (h0 : not (group (distrib (has_nnnorm (has_nnnorm (has_nnnorm (has_nnnorm char))))) -> false)) : @is_cyclic.{0} (distrib.{0} (has_nnnorm.{0} (has_nnnorm.{0} (has_nnnorm.{0} (has_nnnorm.{0} char))))) (@classical.by_contradiction'.{1} (group.{0} (distrib.{0} (has_nnnorm.{0} (has_nnnorm.{0} (has_nnnorm.{0} (has_nnnorm.{0} char)))))) h0)  := sorry --non-trivial
lemma new_lemma_68577 (h0 : has_mem.mem (random_gen (has_top linarith.comp_source)) has_emptyc.emptyc) : @locally_compact_space.{0} (random_gen.{0} (has_top.{0} linarith.comp_source)) (@finset.pi.empty.{1 0} Type topological_space.{0} (random_gen.{0} (has_top.{0} linarith.comp_source)) h0)  := sorry --non-trivial
lemma new_lemma_68578 (h0 : ring (finset (has_pos_part linarith.comp))) : is_principal_ideal_ring (finset (has_pos_part linarith.comp)) := sorry --non-trivial
lemma new_lemma_68579 (h0 : functor.add_const (topological_space (has_add Type)) name) : @regular_space.{1} (has_add.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (has_add.{1} Type)) name h0)  := sorry --non-trivial
lemma new_lemma_68580 (h0 : topological_space (semigroup ennreal)) : t0_space (semigroup ennreal) := sorry --non-trivial
lemma new_lemma_68581 (h0 : functor.add_const (complete_lattice (non_assoc_semiring empty)) empty) : @complete_lattice.is_Sup_finite_compact.{0} (non_assoc_semiring.{0} empty) (@functor.add_const.run.{0 0} (complete_lattice.{0} (non_assoc_semiring.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_68582 (h0 : topological_space (linear_ordered_comm_group_with_zero enat)) : path_connected_space (linear_ordered_comm_group_with_zero enat) := sorry --non-trivial
lemma new_lemma_68583 (h0 : function.extfun Type topological_space) : @locally_compact_space.{0} (linear_order.{0} (option.{0} empty)) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (linear_order.{0} (option.{0} empty)))  := sorry --non-trivial
lemma new_lemma_68584 (h0 : functor.add_const (ring (normed_comm_ring pos)) linarith.comp) : @is_principal_ideal_ring.{0} (normed_comm_ring.{0} pos) (@functor.add_const.run.{0 0} (ring.{0} (normed_comm_ring.{0} pos)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_68585 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_atomistic.{0} (monoid.{0} ennreal) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (monoid.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_68586 (h1 : topological_space (has_inv to_additive.value_type)) : path_connected_space (has_inv to_additive.value_type) := sorry --non-trivial
lemma new_lemma_68587 (h0 : function.extfun (finset (Type -> Type)) (has_mem.mem topological_space)) : @path_connected_space.{0} (semiring.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) topological_space.{0} (@function.extfun_app.{2 0} (finset.{1} (Type → Type)) (@has_mem.mem.{1 1} (Type → Type) (finset.{1} (Type → Type)) (@finset.has_mem.{1} (Type → Type)) topological_space.{0}) h0 (@has_emptyc.emptyc.{1} (finset.{1} (Type → Type)) (@finset.has_emptyc.{1} (Type → Type))))) (semiring.{0} num))  := sorry --non-trivial
lemma new_lemma_68588 (h0 : heq (comm_semigroup (add_group unsigned)) (complete_linear_order empty)) (h1 : filter (comm_semigroup (add_group unsigned))) : filter.ne_bot (heq.elim h0 h1) := sorry --non-trivial
lemma new_lemma_68589 (h0 : function.extfun nat fin) : @is_cyclic.{0} (has_add.{0} real) (@matrix.vec_empty.{0} (group.{0} (has_add.{0} real)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_68590 (h0 : topological_space (normed_field (comm_ring string_imp))) : t0_space (normed_field (comm_ring string_imp)) := sorry --non-trivial
lemma new_lemma_68591 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @totally_disconnected_space.{0} (add_comm_monoid.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (add_comm_monoid.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_68592 (h0 : topological_space (add_semigroup (option (semiring (option empty))))) : totally_separated_space (add_semigroup (option (semiring (option empty)))) := sorry --non-trivial
lemma new_lemma_68593 (h0 : topological_space (preorder unsigned)) : irreducible_space (preorder unsigned) := sorry --non-trivial
lemma new_lemma_68594 (h0 : not (monoid empty -> false)) : @monoid.fg.{0} empty (@classical.by_contradiction'.{1} (monoid.{0} empty) h0)  := sorry --non-trivial
lemma new_lemma_68595 (h1 : set (has_lt (is_R_or_C linarith.comp_source))) : set.subsingleton h1 := sorry --non-trivial
lemma new_lemma_68596 (h0 : functor.add_const (topological_space (left_cancel_monoid empty)) num) : @t1_space.{0} (left_cancel_monoid.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (left_cancel_monoid.{0} empty)) num h0)  := sorry --non-trivial
lemma new_lemma_68597 (h0 : ring (has_to_string (has_add (cancel_monoid name)))) : strong_rank_condition (has_to_string (has_add (cancel_monoid name))) := sorry --non-trivial
lemma new_lemma_68598 (h0 : topological_space (normed_group (has_union empty))) : normal_space (normed_group (has_union empty)) := sorry --non-trivial
lemma new_lemma_68599 (h0 : has_mem.mem (semiring (has_norm linarith.comp)) has_emptyc.emptyc) : @locally_compact_space.{0} (semiring.{0} (has_norm.{0} linarith.comp)) (@finset.pi.empty.{1 0} Type topological_space.{0} (semiring.{0} (has_norm.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_68600 (h0 : uniform_space (ordered_comm_monoid (has_to_string Type))) : separated_space (ordered_comm_monoid (has_to_string Type)) := sorry --non-trivial
lemma new_lemma_68601 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @regular_space.{0} (generalized_boolean_algebra.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (generalized_boolean_algebra.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_68602 (h3 : complete_lattice (with_zero (has_nnnorm fun_info))) : is_compactly_generated (with_zero (has_nnnorm fun_info)) := sorry --non-trivial
lemma new_lemma_68603 (h0 : topological_space (has_to_string (has_add Type))) : t1_space (has_to_string (has_add Type)) := sorry --non-trivial
lemma new_lemma_68604 (h0 : function.extfun (finset (Type -> Type)) (has_mem.mem complete_lattice)) : @is_compactly_generated.{0} string_imp (@function.extfun_app.{2 1} Type complete_lattice.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) complete_lattice.{0} (@function.extfun_app.{2 0} (finset.{1} (Type → Type)) (@has_mem.mem.{1 1} (Type → Type) (finset.{1} (Type → Type)) (@finset.has_mem.{1} (Type → Type)) complete_lattice.{0}) h0 (@has_emptyc.emptyc.{1} (finset.{1} (Type → Type)) (@finset.has_emptyc.{1} (Type → Type))))) string_imp)  := sorry --non-trivial
lemma new_lemma_68605 (h0 : topological_space (canonically_ordered_monoid (has_neg pos))) : topological_space.separable_space (canonically_ordered_monoid (has_neg pos)) := sorry --non-trivial
lemma new_lemma_68606 (h0 : functor.add_const (add_monoid (add_cancel_monoid pos)) environment.implicit_infer_kind) : @add_monoid.fg.{0} (add_cancel_monoid.{0} pos) (@functor.add_const.run.{0 0} (add_monoid.{0} (add_cancel_monoid.{0} pos)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_68607 (h0 : topological_space (canonically_linear_ordered_monoid (finset Type))) : locally_compact_space (canonically_linear_ordered_monoid (finset Type)) := sorry --non-trivial
lemma new_lemma_68608 (h0 : functor.add_const (ordered_comm_monoid (has_add environment.implicit_infer_kind)) linarith.comp) : @has_exists_mul_of_le.{0} (has_add.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (ordered_comm_monoid.{0} (has_add.{0} environment.implicit_infer_kind)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_68609 (h0 : functor.add_const (group (boolean_algebra.core pos)) linarith.comp) : @group.fg.{0} (boolean_algebra.core.{0} pos) (@functor.add_const.run.{0 0} (group.{0} (boolean_algebra.core.{0} pos)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_68610 (h0 : functor.add_const (uniform_space (normed_comm_ring linarith.comp)) (has_Inf pos)) : @complete_space.{0} (normed_comm_ring.{0} linarith.comp) (@functor.add_const.run.{0 0} (uniform_space.{0} (normed_comm_ring.{0} linarith.comp)) (has_Inf.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_68611 (h0 : functor.add_const (cancel_comm_monoid_with_zero (boolean_algebra linarith.comp)) name) : @unique_factorization_monoid.{0} (boolean_algebra.{0} linarith.comp) (@functor.add_const.run.{0 0} (cancel_comm_monoid_with_zero.{0} (boolean_algebra.{0} linarith.comp)) name h0)  := sorry --non-trivial
lemma new_lemma_68612 (h0 : monoid (comm_group (add_comm_monoid linarith.comp))) : monoid.fg (comm_group (add_comm_monoid linarith.comp)) := sorry --non-trivial
lemma new_lemma_68613 (h0 : topological_space (has_Inf (has_neg (has_add name)))) : discrete_topology (has_Inf (has_neg (has_add name))) := sorry --non-trivial
lemma new_lemma_68614 (h0 : complete_lattice (linear_ordered_semiring empty)) : is_atomistic (linear_ordered_semiring empty) := sorry --non-trivial
lemma new_lemma_68615 (h0 : function.extfun Type topological_space) : @preconnected_space.{0} (comm_group.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (comm_group.{0} pos))  := sorry --non-trivial
lemma new_lemma_68616 (h0 : function.extfun Type topological_space) : @discrete_topology.{0} (has_Inf.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_Inf.{0} name))  := sorry --non-trivial
lemma new_lemma_68617 (h0 : topological_space (has_nndist (comm_group (comm_group (add_comm_monoid (add_comm_monoid Type)))))) : normal_space (has_nndist (comm_group (comm_group (add_comm_monoid (add_comm_monoid Type))))) := sorry --non-trivial
lemma new_lemma_68618 (h0 : function.extfun Type complete_lattice) : @complete_lattice.is_Sup_finite_compact.{0} (has_add.{0} unsigned) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (has_add.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_68619 (h0 : function.extfun Type (functor.comp add_monoid finset)) : @add_monoid.fg.{0} (finset.{0} pos) (@functor.add_const.run.{0 0} (add_monoid.{0} (finset.{0} pos)) pos (@functor.comp.run.{0 0 0} add_monoid.{0} finset.{0} pos (@function.extfun_app.{2 1} Type (functor.comp.{0 0 0} add_monoid.{0} finset.{0}) h0 pos)))  := sorry --non-trivial
lemma new_lemma_68620 (h0 : ring (semi_normed_comm_ring (random_gen (has_nnnorm to_additive.value_type)))) : rank_condition (semi_normed_comm_ring (random_gen (has_nnnorm to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_68621 (h0 : cancel_comm_monoid_with_zero (monoid unsigned)) : unique_factorization_monoid (monoid unsigned) := sorry --non-trivial
lemma new_lemma_68622 (h0 : cancel_comm_monoid_with_zero (has_add (has_neg_part unsigned))) : unique_factorization_monoid (has_add (has_neg_part unsigned)) := sorry --non-trivial
lemma new_lemma_68623 (h0 : functor.add_const (topological_space (ring unsigned)) Type) : @discrete_topology.{0} (ring.{0} unsigned) (@functor.add_const.run.{0 1} (topological_space.{0} (ring.{0} unsigned)) Type h0)  := sorry --non-trivial
lemma new_lemma_68624 (h1 : complete_lattice (with_bot fun_info)) : complete_lattice.is_Sup_finite_compact (with_bot fun_info) := sorry --non-trivial
lemma new_lemma_68625 (h0 : set (add_comm_semigroup (add_comm_semigroup string.iterator_imp) -> std_gen)) : set.separates_points h0 := sorry --non-trivial
lemma new_lemma_68626 (h0 : topological_space (has_one (semiring (semiring (has_top (semiring unsigned)))))) : totally_separated_space (has_one (semiring (semiring (has_top (semiring unsigned))))) := sorry --non-trivial
lemma new_lemma_68627 (h0 : functor.add_const (finset (normed_comm_ring pos)) ennreal) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_68628 (h0 : functor.add_const (ordered_comm_monoid (has_pos_part linarith.comp)) linarith.comp) : @has_exists_mul_of_le.{0} (has_pos_part.{0} linarith.comp) (@functor.add_const.run.{0 0} (ordered_comm_monoid.{0} (has_pos_part.{0} linarith.comp)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_68629 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : filter.ne_bot (function.extfun_app (function.extfun_app h0 filter) (semigroup linarith.comp)) := sorry --non-trivial
lemma new_lemma_68630 (h0 : group (with_one (random_gen fun_info))) : is_cyclic (with_one (random_gen fun_info)) := sorry --non-trivial
lemma new_lemma_68631 (h0 : topological_space (has_edist unsigned)) : totally_disconnected_space (has_edist unsigned) := sorry --non-trivial
lemma new_lemma_68632 (h0 : topological_space (has_zero Type)) : path_connected_space (has_zero Type) := sorry --non-trivial
lemma new_lemma_68633 (h0 : functor.add_const (filter (ordered_comm_monoid pos)) pos) : countable_Inter_filter (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_68634 (h0 : filter (has_top fun_info)) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_68635 (h0 : ordered_comm_monoid (boolean_algebra (has_add (has_add Type)))) : has_exists_mul_of_le (boolean_algebra (has_add (has_add Type))) := sorry --non-trivial
lemma new_lemma_68636 (h0 : add_group (add_comm_monoid (finset Type))) : is_add_cyclic (add_comm_monoid (finset Type)) := sorry --non-trivial
lemma new_lemma_68637 (h0 : list (monoid_with_zero (option ennreal))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_68638 (h0 : filter (has_star (semiring (semiring (has_top (semiring (semiring (semiring (semiring unsigned))))))))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_68639 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @t1_space.{0} (normed_comm_ring.{0} ennreal) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (normed_comm_ring.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_68640 (h0 : ring (add_comm_monoid (comm_group Type))) : is_principal_ideal_ring (add_comm_monoid (comm_group Type)) := sorry --non-trivial
lemma new_lemma_68641 (h0 : functor.add_const (topological_space (generalized_boolean_algebra pos)) real) : @discrete_topology.{0} (generalized_boolean_algebra.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (generalized_boolean_algebra.{0} pos)) real h0)  := sorry --non-trivial
lemma new_lemma_68642 (h0 : functor.comp list has_to_string name) : list.nodup (functor.comp.run h0) := sorry --non-trivial
lemma new_lemma_68643 (h0 : functor.add_const (complete_lattice (finset Type)) ennreal) : @is_compactly_generated.{1} (finset.{1} Type) (@functor.add_const.run.{1 0} (complete_lattice.{1} (finset.{1} Type)) ennreal h0)  := sorry --non-trivial
lemma new_lemma_68644 (h0 : functor.add_const (function.extfun (Type 1) topological_space) Type) : @totally_separated_space.{1} (has_Inf.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@functor.add_const.run.{2 1} (function.extfun.{3 2} (Type 1) topological_space.{1}) Type h0) (has_Inf.{1} Type))  := sorry --non-trivial
lemma new_lemma_68645 (h0 : topological_space (with_bot linarith.comp)) : preirreducible_space (with_bot linarith.comp) := sorry --non-trivial
lemma new_lemma_68646 (h0 : topological_space (has_sdiff environment.implicit_infer_kind)) : preirreducible_space (has_sdiff environment.implicit_infer_kind) := sorry --non-trivial
lemma new_lemma_68647 (h0 : not (topological_space (random_gen linarith.ineq) -> false)) : @path_connected_space.{0} (random_gen.{0} linarith.ineq) (@classical.by_contradiction'.{1} (topological_space.{0} (random_gen.{0} linarith.ineq)) h0)  := sorry --non-trivial
lemma new_lemma_68648 (h0 : group (has_to_string (finset (finset (finset linarith.comp))))) : normalizer_condition (has_to_string (finset (finset (finset linarith.comp)))) := sorry --non-trivial
lemma new_lemma_68649 (h1 : uniform_space string_imp) : complete_space string_imp := sorry --non-trivial
lemma new_lemma_68650 (h0 : complete_lattice (normed_lattice_add_comm_group (has_neg real))) : is_compactly_generated (normed_lattice_add_comm_group (has_neg real)) := sorry --non-trivial
lemma new_lemma_68651 (h0 : functor.add_const (function.extfun Type topological_space) environment.implicit_infer_kind) : @preirreducible_space.{0} (semigroup.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) environment.implicit_infer_kind h0) (semigroup.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_68652 (h0 : cancel_comm_monoid_with_zero (has_add (has_add (has_add Type)))) : unique_factorization_monoid (has_add (has_add (has_add Type))) := sorry --non-trivial
lemma new_lemma_68653 (h0 : functor.add_const (topological_space (preorder num)) congr_arg_kind) : @preirreducible_space.{0} (preorder.{0} num) (@functor.add_const.run.{0 0} (topological_space.{0} (preorder.{0} num)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_68654 (h0 : ring (ordered_cancel_add_comm_monoid (option pos))) : strong_rank_condition (ordered_cancel_add_comm_monoid (option pos)) := sorry --non-trivial
lemma new_lemma_68655 (h0 : ring (canonically_linear_ordered_monoid (has_neg (has_Inf real)))) : is_principal_ideal_ring (canonically_linear_ordered_monoid (has_neg (has_Inf real))) := sorry --non-trivial
lemma new_lemma_68656 (h0 : function.extfun Type topological_space) : @preconnected_space.{0} (has_add.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_add.{0} num))  := sorry --non-trivial
lemma new_lemma_68657 (h0 : list (add_cancel_monoid name)) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_68658 (h0 : topological_space (has_Inf (finset (has_add Type)))) : sequential_space (has_Inf (finset (has_add Type))) := sorry --non-trivial
lemma new_lemma_68659 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @complete_space.{0} (linear_ordered_semiring.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type uniform_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 uniform_space.{0}) (linear_ordered_semiring.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_68660 (h0 : functor.comp monoid finset linarith.comp) : @monoid.fg.{0} (finset.{0} linarith.comp) (@functor.comp.run.{0 0 0} monoid.{0} finset.{0} linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_68661 (h0 : filter (boolean_algebra Type)) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_68662 (h1 : group (random_gen to_additive.value_type)) : normalizer_condition (random_gen to_additive.value_type) := sorry --non-trivial
lemma new_lemma_68663 (h0 : uniform_space (normed_lattice_add_comm_group linarith.comp)) : separated_space (normed_lattice_add_comm_group linarith.comp) := sorry --non-trivial
lemma new_lemma_68664 (h0 : set (mul_one_class (normed_field (mul_one_class (mul_one_class std_gen))) -> add_comm_semigroup ereal)) : set.separates_points h0 := sorry --non-trivial
lemma new_lemma_68665 (h0 : ring (has_add (ring linarith.comp))) : is_domain (has_add (ring linarith.comp)) := sorry --non-trivial
lemma new_lemma_68666 (h0 : add_group (finset (finset (has_add pos)))) : is_add_cyclic (finset (finset (has_add pos))) := sorry --non-trivial
lemma new_lemma_68667 (h0 : functor.add_const (function.extfun (Type 1) group) linarith.comp) : @normalizer_condition.{1} Type (@function.extfun_app.{3 2} (Type 1) group.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) group.{1}) linarith.comp h0) Type)  := sorry --non-trivial
lemma new_lemma_68668 (h0 : functor.add_const (topological_space (semigroup empty)) empty) : @t0_space.{0} (semigroup.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (semigroup.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_68669 (h0 : functor.add_const (function.extfun Type topological_space) Type) : @normal_space.{0} linarith.comp (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type topological_space.{0}) Type h0) linarith.comp)  := sorry --non-trivial
lemma new_lemma_68670 (h0 : topological_space (distrib_lattice (random_gen (random_gen string_imp)))) : locally_compact_space (distrib_lattice (random_gen (random_gen string_imp))) := sorry --non-trivial
lemma new_lemma_68671 (h0 : function.extfun Type filter) : countable_Inter_filter (function.extfun_app h0 environment.implicit_infer_kind) := sorry --non-trivial
lemma new_lemma_68672 (h0 : prod (omega_complete_partial_order empty) (omega_complete_partial_order empty)) : id_rel h0 := sorry --non-trivial
lemma new_lemma_68673 (h0 : add_monoid (boolean_algebra.core (boolean_algebra.core (has_add pos)))) : add_monoid.fg (boolean_algebra.core (boolean_algebra.core (has_add pos))) := sorry --non-trivial
lemma new_lemma_68674 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @t0_space.{0} (mul_one_class.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (mul_one_class.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_68675 (h0 : function.extfun Type semiring) : @is_noetherian_ring.{0} (left_cancel_semigroup.{0} (option.{0} empty)) (@function.extfun_app.{2 1} Type semiring.{0} h0 (left_cancel_semigroup.{0} (option.{0} empty)))  := sorry --non-trivial
lemma new_lemma_68676 (h0 : functor.add_const (complete_lattice (has_nndist linarith.comp)) environment.implicit_infer_kind) : @is_compactly_generated.{0} (has_nndist.{0} linarith.comp) (@functor.add_const.run.{0 0} (complete_lattice.{0} (has_nndist.{0} linarith.comp)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_68677 (h0 : list (boolean_algebra.core (add_comm_monoid pos))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_68678 (h0 : complete_lattice (with_bot (has_top (semiring congr_arg_kind)))) : complete_lattice.is_Sup_finite_compact (with_bot (has_top (semiring congr_arg_kind))) := sorry --non-trivial
lemma new_lemma_68679 (h0 : add_group (is_R_or_C empty)) : is_add_cyclic (is_R_or_C empty) := sorry --non-trivial
lemma new_lemma_68680 (h0 : function.extfun Type cancel_comm_monoid_with_zero) : @unique_factorization_monoid.{0} (has_Sup.{0} unsigned) (@function.extfun_app.{2 1} Type cancel_comm_monoid_with_zero.{0} h0 (has_Sup.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_68681 (h0 : ring (semigroup (has_neg_part pos))) : is_principal_ideal_ring (semigroup (has_neg_part pos)) := sorry --non-trivial
lemma new_lemma_68682 (h0 : topological_space (has_neg_part (normed_comm_ring environment.implicit_infer_kind))) : regular_space (has_neg_part (normed_comm_ring environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_68683 (h0 : has_lt (semi_normed_comm_ring (mul_one_class enat))) : no_max_order (semi_normed_comm_ring (mul_one_class enat)) := sorry --non-trivial
lemma new_lemma_68684 (h0 : functor.add_const (add_group (add_cancel_monoid environment.implicit_infer_kind)) (has_zero (has_zero pos))) : @is_add_cyclic.{0} (add_cancel_monoid.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (add_group.{0} (add_cancel_monoid.{0} environment.implicit_infer_kind)) (has_zero.{0} (has_zero.{0} pos)) h0)  := sorry --non-trivial
lemma new_lemma_68685 (h0 : topological_space (has_div linarith.ineq)) : totally_disconnected_space (has_div linarith.ineq) := sorry --non-trivial
lemma new_lemma_68686 (h0 : topological_space (add_cancel_comm_monoid congr_arg_kind)) : topological_space.separable_space (add_cancel_comm_monoid congr_arg_kind) := sorry --non-trivial
lemma new_lemma_68687 (h0 : functor.add_const (function.extfun Type topological_space) name) : @preirreducible_space.{0} (has_to_string.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) name h0) (has_to_string.{0} name))  := sorry --non-trivial
lemma new_lemma_68688 (h0 : functor.add_const (complete_lattice (finset unsigned)) (option name)) : @is_atomistic.{0} (finset.{0} unsigned) (@functor.add_const.run.{0 0} (complete_lattice.{0} (finset.{0} unsigned)) (option.{0} name) h0)  := sorry --non-trivial
lemma new_lemma_68689 (h0 : add_group (option (semiring (option unsigned)))) : is_add_cyclic (option (semiring (option unsigned))) := sorry --non-trivial
lemma new_lemma_68690 (h0 : function.extfun (((Type -> Type) -> Type 1) -> Type 1) (function.extfun ((Type -> Type) -> Type 1))) : @path_connected_space.{0} (has_inv.{0} linarith.ineq) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) (@function.extfun_app.{3 2} ((Type → Type) → Type 1) (function.extfun.{2 2} (Type → Type)) (@function.extfun_app.{3 3} (((Type → Type) → Type 1) → Type 1) (function.extfun.{3 2} ((Type → Type) → Type 1)) h0 (function.extfun.{2 2} (Type → Type))) (function.extfun.{2 1} Type)) topological_space.{0}) (has_inv.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_68691 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_compactly_generated.{0} (has_one.{0} empty) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (has_one.{0} empty))  := sorry --non-trivial
lemma new_lemma_68692 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @regular_space.{0} (pseudo_metric_space.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (pseudo_metric_space.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_68693 (h0 : complete_lattice (has_norm (has_ssubset to_additive.value_type))) : is_compactly_generated (has_norm (has_ssubset to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_68694 (h1 : topological_space (add_comm_semigroup reducibility_hints)) (h2 : add_group (add_comm_semigroup reducibility_hints)) : topological_add_group (add_comm_semigroup reducibility_hints) := sorry --non-trivial
lemma new_lemma_68695 (h0 : function.extfun (finset (Type -> Type)) (has_mem.mem topological_space)) : @totally_disconnected_space.{0} (has_emptyc.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type topological_space.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) topological_space.{0} (@function.extfun_app.{2 0} (finset.{1} (Type → Type)) (@has_mem.mem.{1 1} (Type → Type) (finset.{1} (Type → Type)) (@finset.has_mem.{1} (Type → Type)) topological_space.{0}) h0 (@has_emptyc.emptyc.{1} (finset.{1} (Type → Type)) (@finset.has_emptyc.{1} (Type → Type))))) (has_emptyc.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_68696 (h0 : has_mem.mem (semiring (has_norm linarith.comp_source)) has_emptyc.emptyc) : @totally_disconnected_space.{0} (semiring.{0} (has_norm.{0} linarith.comp_source)) (@finset.pi.empty.{1 0} Type topological_space.{0} (semiring.{0} (has_norm.{0} linarith.comp_source)) h0)  := sorry --non-trivial
lemma new_lemma_68697 (h0 : complete_lattice (normed_lattice_add_comm_group Type)) : complete_lattice.is_Sup_finite_compact (normed_lattice_add_comm_group Type) := sorry --non-trivial
lemma new_lemma_68698 (h0 : topological_space (linear_ordered_semiring (random_gen (random_gen num)))) : totally_separated_space (linear_ordered_semiring (random_gen (random_gen num))) := sorry --non-trivial
lemma new_lemma_68699 (h0 : fin has_zero.zero) : @loc_path_connected_space.{1} (simple_graph.{1} Type) (@matrix.vec_empty.{1} (topological_space.{1} (simple_graph.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_68700 (h0 : list (semigroup (option empty))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_68701 (h0 : function.extfun Type ring) : @is_principal_ideal_ring.{0} ennreal (@function.extfun_app.{2 1} Type ring.{0} h0 ennreal)  := sorry --non-trivial
lemma new_lemma_68702 (h0 : ring (has_zero (ring Type))) : strong_rank_condition (has_zero (ring Type)) := sorry --non-trivial
lemma new_lemma_68703 (h0 : topological_space (canonically_ordered_comm_semiring (has_add Type))) : sequential_space (canonically_ordered_comm_semiring (has_add Type)) := sorry --non-trivial
lemma new_lemma_68704 (h0 : function.extfun Type ring) : @is_domain.{0} (@id.{2} Type string_imp) (@function.extfun_app.{2 1} Type ring.{0} h0 (@id.{2} Type string_imp))  := sorry --non-trivial
lemma new_lemma_68705 (h0 : functor.add_const (topological_space (ordered_comm_monoid linarith.comp)) name) : @preirreducible_space.{0} (ordered_comm_monoid.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (ordered_comm_monoid.{0} linarith.comp)) name h0)  := sorry --non-trivial
lemma new_lemma_68706 (h0 : complete_lattice (monoid unsigned)) : is_atomistic (monoid unsigned) := sorry --non-trivial
lemma new_lemma_68707 (h0 : function.extfun ((Type -> Type) -> Type 1) (function.extfun (Type -> Type))) : @totally_separated_space.{0} (linear_ordered_add_comm_group.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) (@function.extfun_app.{3 2} ((Type → Type) → Type 1) (function.extfun.{2 2} (Type → Type)) h0 (function.extfun.{2 1} Type)) topological_space.{0}) (linear_ordered_add_comm_group.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_68708 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @locally_compact_space.{0} (has_nndist.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_nndist.{0} pos))  := sorry --non-trivial
lemma new_lemma_68709 (h0 : ordered_comm_monoid (complete_distrib_lattice pos)) : has_exists_mul_of_le (complete_distrib_lattice pos) := sorry --non-trivial
lemma new_lemma_68710 (h2 : uniform_space (semi_normed_ring to_additive.value_type)) : complete_space (semi_normed_ring to_additive.value_type) := sorry --non-trivial
lemma new_lemma_68711 (h1 : topological_space (has_emptyc string_imp)) : irreducible_space (has_emptyc string_imp) := sorry --non-trivial
lemma new_lemma_68712 (h0 : ring (has_Inf (canonically_ordered_monoid name))) : is_principal_ideal_ring (has_Inf (canonically_ordered_monoid name)) := sorry --non-trivial
lemma new_lemma_68713 (h0 : function.extfun Type filter) : filter.ne_bot (function.extfun_app h0 (complete_distrib_lattice empty)) := sorry --non-trivial
lemma new_lemma_68714 (h0 : group (with_bot (has_top linarith.ineq))) : normalizer_condition (with_bot (has_top linarith.ineq)) := sorry --non-trivial
lemma new_lemma_68715 (h0 : topological_space (canonically_ordered_comm_semiring (boolean_algebra (boolean_algebra Type)))) : locally_compact_space (canonically_ordered_comm_semiring (boolean_algebra (boolean_algebra Type))) := sorry --non-trivial
lemma new_lemma_68716 (h0 : complete_lattice (has_to_string environment.implicit_infer_kind)) : is_atomistic (has_to_string environment.implicit_infer_kind) := sorry --non-trivial
lemma new_lemma_68717 (h0 : functor.add_const (finset (left_cancel_semigroup empty)) num) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_68718 (h0 : topological_space (boolean_algebra (finset pos))) : regular_space (boolean_algebra (finset pos)) := sorry --non-trivial
lemma new_lemma_68719 (h0 : set (mul_one_class (mul_one_class string.iterator_imp) -> std_gen)) : set.separates_points h0 := sorry --non-trivial
lemma new_lemma_68720 (h0 : topological_space (ring (option (option ennreal)))) : t1_space (ring (option (option ennreal))) := sorry --non-trivial
lemma new_lemma_68721 (h0 : filter (cancel_monoid Type)) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_68722 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_domain.{0} (normed_comm_ring.{0} ennreal) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (normed_comm_ring.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_68723 (h0 : ordered_add_comm_monoid (linear_ordered_comm_group num)) : archimedean (linear_ordered_comm_group num) := sorry --non-trivial
lemma new_lemma_68724 (h0 : group (encodable (has_nnnorm fun_info))) : is_cyclic (encodable (has_nnnorm fun_info)) := sorry --non-trivial
lemma new_lemma_68725 (h0 : function.extfun (finset Type) (has_mem.mem (with_bot linarith.comp))) : @complete_lattice.is_Sup_finite_compact.{0} (with_bot.{0} linarith.comp) (@finset.pi.empty.{1 0} Type complete_lattice.{0} (with_bot.{0} linarith.comp) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (with_bot.{0} linarith.comp)) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_68726 (h0 : function.extfun Type monoid) : @monoid.fg.{0} (monoid.{0} unsigned) (@function.extfun_app.{2 1} Type monoid.{0} h0 (monoid.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_68727 (h0 : complete_lattice (random_gen (semiring unsigned))) : complete_lattice.is_Sup_finite_compact (random_gen (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_68728 (h0 : functor.add_const (topological_space (measure_theory.measure_space congr_arg_kind)) num) : @t1_space.{0} (measure_theory.measure_space.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (measure_theory.measure_space.{0} congr_arg_kind)) num h0)  := sorry --non-trivial
lemma new_lemma_68729 (h0 : topological_space (add_semigroup empty)) : loc_path_connected_space (add_semigroup empty) := sorry --non-trivial
lemma new_lemma_68730 (h0 : uniform_space (has_sub (semiring num))) : separated_space (has_sub (semiring num)) := sorry --non-trivial
lemma new_lemma_68731 (h0 : function.extfun Type list) : list.nodup (function.extfun_app h0 (measurable_space to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_68732 (h0 : functor.add_const (semiring (ordered_cancel_add_comm_monoid num)) num) : @is_noetherian_ring.{0} (ordered_cancel_add_comm_monoid.{0} num) (@functor.add_const.run.{0 0} (semiring.{0} (ordered_cancel_add_comm_monoid.{0} num)) num h0)  := sorry --non-trivial
lemma new_lemma_68733 (h0 : complete_lattice (with_one (semiring linarith.comp))) : complete_lattice.is_Sup_finite_compact (with_one (semiring linarith.comp)) := sorry --non-trivial
lemma new_lemma_68734 (h0 : prod (with_one empty) (with_one empty)) : id_rel h0 := sorry --non-trivial
lemma new_lemma_68735 (h0 : function.extfun Type ring) : @is_principal_ideal_ring.{0} (has_Inf.{0} linarith.comp) (@function.extfun_app.{2 1} Type ring.{0} h0 (has_Inf.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_68736 (h0 : functor.add_const (finset (ordered_comm_monoid name)) pos) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_68737 (h0 : functor.add_const (topological_space (left_cancel_semigroup unsigned)) unsigned) : @locally_compact_space.{0} (left_cancel_semigroup.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (left_cancel_semigroup.{0} unsigned)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_68738 (h0 : uniform_space (semigroup (ring (has_add pos)))) : separated_space (semigroup (ring (has_add pos))) := sorry --non-trivial
lemma new_lemma_68739 (h0 : has_mem.mem topological_space has_emptyc.emptyc) : @totally_disconnected_space.{0} (random_gen.{0} fun_info) (@function.extfun_app.{2 1} Type topological_space.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) topological_space.{0} h0) (random_gen.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_68740 (h0 : function.extfun Type complete_lattice) : @is_compactly_generated.{0} (complete_linear_order.{0} num) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (complete_linear_order.{0} num))  := sorry --non-trivial
lemma new_lemma_68741 (h0 : set (add_comm_semigroup (add_comm_semigroup std_gen) -> enat)) : set.separates_points h0 := sorry --non-trivial
lemma new_lemma_68742 (h2 : not (uniform_space (topological_space char) -> false)) : @complete_space.{0} (topological_space.{0} char) (@classical.by_contradiction'.{1} (uniform_space.{0} (topological_space.{0} char)) h2)  := sorry --non-trivial
lemma new_lemma_68743 (h0 : topological_space (cancel_monoid (ring Type))) : discrete_topology (cancel_monoid (ring Type)) := sorry --non-trivial
lemma new_lemma_68744 (h0 : complete_lattice (has_neg (has_neg (has_neg Type)))) : complete_lattice.is_Sup_finite_compact (has_neg (has_neg (has_neg Type))) := sorry --non-trivial
lemma new_lemma_68745 (h0 : not (cancel_comm_monoid_with_zero (add_group congr_arg_kind) -> false)) : @unique_factorization_monoid.{0} (add_group.{0} congr_arg_kind) (@classical.by_contradiction'.{1} (cancel_comm_monoid_with_zero.{0} (add_group.{0} congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_68746 (h0 : ring (mul_zero_class (semiring (semiring (semiring (semiring empty)))))) : is_domain (mul_zero_class (semiring (semiring (semiring (semiring empty))))) := sorry --non-trivial
lemma new_lemma_68747 (h0 : topological_space (has_neg name)) : topological_space.separable_space (has_neg name) := sorry --non-trivial
lemma new_lemma_68748 (h0 : set (mul_one_class (add_comm_semigroup ereal) -> ereal)) : set.separates_points h0 := sorry --non-trivial
lemma new_lemma_68749 (h0 : topological_space (normed_group unsigned)) : t1_space (normed_group unsigned) := sorry --non-trivial
lemma new_lemma_68750 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @sequential_space.{0} (has_neg.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_neg.{0} pos))  := sorry --non-trivial
lemma new_lemma_68751 (h0 : topological_space (canonically_linear_ordered_monoid (has_Inf (has_Inf (has_Inf real))))) : irreducible_space (canonically_linear_ordered_monoid (has_Inf (has_Inf (has_Inf real)))) := sorry --non-trivial
lemma new_lemma_68752 (h0 : function.extfun Type topological_space) : @path_connected_space.{0} (add_cancel_monoid.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (add_cancel_monoid.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_68753 (h0 : group (ring linarith.comp)) : is_simple_group (ring linarith.comp) := sorry --non-trivial
lemma new_lemma_68754 (h0 : topological_space (normed_comm_ring (option (option unsigned)))) : t0_space (normed_comm_ring (option (option unsigned))) := sorry --non-trivial
lemma new_lemma_68755 (h0 : topological_space (linear_ordered_comm_ring (has_top (has_top empty)))) : totally_separated_space (linear_ordered_comm_ring (has_top (has_top empty))) := sorry --non-trivial
lemma new_lemma_68756 (h3 : ring (with_zero linarith.ineq)) : strong_rank_condition (with_zero linarith.ineq) := sorry --non-trivial
lemma new_lemma_68757 (h0 : filter (add_cancel_monoid (comm_group (comm_group (comm_group (comm_group Type)))))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_68758 (h0 : not (function.extfun Type topological_space -> false)) : @normal_space.{0} (linear_ordered_semiring.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (linear_ordered_semiring.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_68759 (h0 : complete_lattice (has_neg_part (cancel_monoid name))) : is_atomistic (has_neg_part (cancel_monoid name)) := sorry --non-trivial
lemma new_lemma_68760 (h0 : has_mem.mem linarith.comp_source has_emptyc.emptyc) : @complete_lattice.is_Sup_finite_compact.{0} linarith.comp_source (@finset.pi.empty.{1 0} Type complete_lattice.{0} linarith.comp_source h0)  := sorry --non-trivial
lemma new_lemma_68761 (h0 : uniform_space (with_one (semiring empty))) : separated_space (with_one (semiring empty)) := sorry --non-trivial
lemma new_lemma_68762 (h0 : topological_space (linear_ordered_semiring (semiring (semiring num)))) : irreducible_space (linear_ordered_semiring (semiring (semiring num))) := sorry --non-trivial
lemma new_lemma_68763 (h0 : monoid (random_gen (has_union (id (has_union empty))))) : monoid.fg (random_gen (has_union (id (has_union empty)))) := sorry --non-trivial
lemma new_lemma_68764 (h0 : not (complete_lattice (has_nnnorm fun_info) -> false)) : @complete_lattice.is_Sup_finite_compact.{0} (has_nnnorm.{0} fun_info) (@classical.by_contradiction'.{1} (complete_lattice.{0} (has_nnnorm.{0} fun_info)) h0)  := sorry --non-trivial
lemma new_lemma_68765 (h0 : ring (add_cancel_monoid (generalized_boolean_algebra pos))) : rank_condition (add_cancel_monoid (generalized_boolean_algebra pos)) := sorry --non-trivial
lemma new_lemma_68766 (h0 : complete_lattice znum) : is_atomistic znum := sorry --non-trivial
lemma new_lemma_68767 (h0 : complete_lattice (has_add (has_neg (has_Inf real)))) : complete_lattice.is_Sup_finite_compact (has_add (has_neg (has_Inf real))) := sorry --non-trivial
lemma new_lemma_68768 (h1 : topological_space (measurable_space linarith.comp)) : t0_space (measurable_space linarith.comp) := sorry --non-trivial
lemma new_lemma_68769 (h0 : topological_space (linear_ordered_add_comm_group (random_gen (comm_ring fun_info)))) : totally_disconnected_space (linear_ordered_add_comm_group (random_gen (comm_ring fun_info))) := sorry --non-trivial
lemma new_lemma_68770 (h0 : functor.add_const (ordered_add_comm_monoid (comm_group pos)) linarith.comp) : @archimedean.{0} (comm_group.{0} pos) (@functor.add_const.run.{0 0} (ordered_add_comm_monoid.{0} (comm_group.{0} pos)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_68771 (h0 : ring (with_one (random_gen (random_gen fun_info)))) : rank_condition (with_one (random_gen (random_gen fun_info))) := sorry --non-trivial
lemma new_lemma_68772 (h0 : group (mul_zero_class (semiring empty))) : normalizer_condition (mul_zero_class (semiring empty)) := sorry --non-trivial
lemma new_lemma_68773 (h0 : ring (has_union (semiring (semiring num)))) : rank_condition (has_union (semiring (semiring num))) := sorry --non-trivial
lemma new_lemma_68774 (h0 : uniform_space (has_nndist linarith.comp)) : separated_space (has_nndist linarith.comp) := sorry --non-trivial
lemma new_lemma_68775 (h0 : function.extfun Type list) : palindrome (function.extfun_app h0 (canonically_ordered_comm_semiring congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_68776 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @locally_compact_space.{0} (topological_space.{0} linarith.ineq) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (topological_space.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_68777 (h0 : topological_space (canonically_ordered_monoid (has_Inf (has_add linarith.comp)))) : totally_separated_space (canonically_ordered_monoid (has_Inf (has_add linarith.comp))) := sorry --non-trivial
lemma new_lemma_68778 (h1 : group (semi_normed_ring (comm_ring char))) : is_cyclic (semi_normed_ring (comm_ring char)) := sorry --non-trivial
lemma new_lemma_68779 (h0 : not (ring (has_compl linarith.ineq) -> false)) : @rank_condition.{0} (has_compl.{0} linarith.ineq) (@classical.by_contradiction'.{1} (ring.{0} (has_compl.{0} linarith.ineq)) h0)  := sorry --non-trivial
lemma new_lemma_68780 (h0 : topological_space (finset (has_to_string pos))) : preconnected_space (finset (has_to_string pos)) := sorry --non-trivial
lemma new_lemma_68781 (h0 : topological_space (complete_semilattice_Sup char)) : t0_space (complete_semilattice_Sup char) := sorry --non-trivial
lemma new_lemma_68782 (h0 : ordered_add_comm_monoid (normed_comm_ring (add_comm_monoid Type))) : archimedean (normed_comm_ring (add_comm_monoid Type)) := sorry --non-trivial
lemma new_lemma_68783 (h0 : measurable_space (has_compl (mul_one_class char))) (h1 : measure_theory.measure (has_compl (mul_one_class char))) : measure_theory.has_no_atoms h1 := sorry --non-trivial
lemma new_lemma_68784 (h0 : function.extfun Type group) : @is_cyclic.{0} (canonically_ordered_add_monoid.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type group.{0} h0 (canonically_ordered_add_monoid.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_68785 (h1 : semiring (has_sub linarith.comp)) : is_noetherian_ring (has_sub linarith.comp) := sorry --non-trivial
lemma new_lemma_68786 (h1 : monoid (with_bot (has_top linarith.comp_source))) : monoid.fg (with_bot (has_top linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_68787 (h0 : function.extfun Type cancel_comm_monoid_with_zero) : @unique_factorization_monoid.{0} (normed_lattice_add_comm_group.{0} empty) (@function.extfun_app.{2 1} Type cancel_comm_monoid_with_zero.{0} h0 (normed_lattice_add_comm_group.{0} empty))  := sorry --non-trivial
lemma new_lemma_68788 (h0 : function.extfun (nat -> Type) (function.extfun nat)) : @is_noetherian_ring.{0} (ordered_comm_ring.{0} (has_add.{0} pos)) (@matrix.vec_empty.{0} (semiring.{0} (ordered_comm_ring.{0} (has_add.{0} pos))) (@function.extfun_app.{1 1} nat fin (@function.extfun_app.{2 1} (nat → Type) (function.extfun.{1 1} nat) h0 fin) (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_68789 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_noetherian_ring.{0} (has_pos_part.{0} pos) (@function.extfun_app.{2 1} Type semiring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 semiring.{0}) (has_pos_part.{0} pos))  := sorry --non-trivial
lemma new_lemma_68790 (h0 : complete_lattice (has_pos_part (ring pos))) : is_compactly_generated (has_pos_part (ring pos)) := sorry --non-trivial
lemma new_lemma_68791 (h0 : topological_space (finset (finset (finset (finset linarith.comp))))) : t1_space (finset (finset (finset (finset linarith.comp)))) := sorry --non-trivial
lemma new_lemma_68792 (h0 : functor.add_const (topological_space (has_nndist unsigned)) Type) : @regular_space.{0} (has_nndist.{0} unsigned) (@functor.add_const.run.{0 1} (topological_space.{0} (has_nndist.{0} unsigned)) Type h0)  := sorry --non-trivial
lemma new_lemma_68793 (h0 : group (has_add (ordered_comm_monoid real))) : is_simple_group (has_add (ordered_comm_monoid real)) := sorry --non-trivial
lemma new_lemma_68794 (h0 : complete_lattice (with_one empty)) : is_compactly_generated (with_one empty) := sorry --non-trivial
lemma new_lemma_68795 (h0 : filter (canonically_linear_ordered_monoid (option ennreal))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_68796 (h0 : ring (complete_distrib_lattice (option (option pos)))) : is_principal_ideal_ring (complete_distrib_lattice (option (option pos))) := sorry --non-trivial
lemma new_lemma_68797 (h0 : filter (semiring linarith.comp)) (h1 : semiring linarith.comp -> topological_space linarith.comp) : @totally_disconnected_space.{0} linarith.comp (@filter.limsup.{0 0} (topological_space.{0} linarith.comp) (semiring.{0} linarith.comp) (@complete_lattice.to_conditionally_complete_lattice.{0} (topological_space.{0} linarith.comp) (@topological_space.complete_lattice.{0} linarith.comp)) h0 h1)  := sorry --non-trivial
lemma new_lemma_68798 (h0 : functor.add_const (semiring (finset linarith.comp)) (ring Type)) : @is_noetherian_ring.{0} (finset.{0} linarith.comp) (@functor.add_const.run.{0 1} (semiring.{0} (finset.{0} linarith.comp)) (ring.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_68799 (h0 : function.extfun Type cancel_comm_monoid_with_zero) : @unique_factorization_monoid.{0} (has_norm.{0} empty) (@function.extfun_app.{2 1} Type cancel_comm_monoid_with_zero.{0} h0 (has_norm.{0} empty))  := sorry --non-trivial
lemma new_lemma_68800 (h0 : functor.comp ring comm_group Type) : @strong_rank_condition.{1} (comm_group.{1} Type) (@functor.comp.run.{1 1 1} ring.{1} comm_group.{1} Type h0)  := sorry --non-trivial
lemma new_lemma_68801 (h0 : group (generalized_boolean_algebra (has_nndist (ring Type)))) : is_cyclic (generalized_boolean_algebra (has_nndist (ring Type))) := sorry --non-trivial
lemma new_lemma_68802 (h0 : functor.add_const (topological_space (has_pos_part Type)) pos) : @irreducible_space.{1} (has_pos_part.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (has_pos_part.{1} Type)) pos h0)  := sorry --non-trivial
lemma new_lemma_68803 (h0 : ring (comm_ring char)) : rank_condition (comm_ring char) := sorry --non-trivial
lemma new_lemma_68804 (h0 : filter (canonically_linear_ordered_monoid num)) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_68805 (h0 : function.extfun Type topological_space) : @normal_space.{0} (sub_neg_monoid.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (sub_neg_monoid.{0} pos))  := sorry --non-trivial
lemma new_lemma_68806 (h0 : complete_lattice (non_unital_non_assoc_semiring environment.projection_info)) : complete_lattice.is_Sup_finite_compact (non_unital_non_assoc_semiring environment.projection_info) := sorry --non-trivial
lemma new_lemma_68807 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @strong_rank_condition.{0} (metric_space.{0} num) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (metric_space.{0} num))  := sorry --non-trivial
lemma new_lemma_68808 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_noetherian_ring.{0} (ring.{0} name) (@function.extfun_app.{2 1} Type semiring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 semiring.{0}) (ring.{0} name))  := sorry --non-trivial
lemma new_lemma_68809 (h0 : topological_space (has_compl (uniform_space (mul_one_class string.iterator_imp)))) : path_connected_space (has_compl (uniform_space (mul_one_class string.iterator_imp))) := sorry --non-trivial
lemma new_lemma_68810 (h0 : semiring Type) (h1 : polynomial Type) : polynomial.is_root h1 std_gen := sorry --non-trivial
lemma new_lemma_68811 (h0 : cancel_comm_monoid_with_zero (left_cancel_monoid num)) : unique_factorization_monoid (left_cancel_monoid num) := sorry --non-trivial
lemma new_lemma_68812 (h0 : function.extfun Type topological_space) : @t0_space.{0} (complete_distrib_lattice.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (complete_distrib_lattice.{0} pos))  := sorry --non-trivial
lemma new_lemma_68813 (h0 : function.extfun Type finset) : finset.nonempty (function.extfun_app h0 (linear_ordered_comm_group ennreal)) := sorry --non-trivial
lemma new_lemma_68814 (h0 : filter (has_zero (has_neg linarith.comp))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_68815 (h0 : group (has_norm (semiring (has_norm num)))) : is_cyclic (has_norm (semiring (has_norm num))) := sorry --non-trivial
lemma new_lemma_68816 (h0 : topological_space (has_Inf (has_add linarith.comp))) : sequential_space (has_Inf (has_add linarith.comp)) := sorry --non-trivial
lemma new_lemma_68817 (h0 : ordered_add_comm_monoid (add_cancel_monoid (ring (has_neg (ring (has_to_string linarith.comp)))))) : archimedean (add_cancel_monoid (ring (has_neg (ring (has_to_string linarith.comp))))) := sorry --non-trivial
lemma new_lemma_68818 (h0 : functor.add_const (topological_space (canonically_ordered_comm_semiring ennreal)) name) : @sequential_space.{0} (canonically_ordered_comm_semiring.{0} ennreal) (@functor.add_const.run.{0 0} (topological_space.{0} (canonically_ordered_comm_semiring.{0} ennreal)) name h0)  := sorry --non-trivial
lemma new_lemma_68819 (h0 : not (function.extfun Type topological_space -> false)) : @normal_space.{0} (has_union.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (has_union.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_68820 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @loc_path_connected_space.{0} (has_neg_part.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_neg_part.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_68821 (h0 : topological_space (has_to_string (has_add (has_add (has_add (has_to_string pos)))))) : locally_compact_space (has_to_string (has_add (has_add (has_add (has_to_string pos))))) := sorry --non-trivial
lemma new_lemma_68822 (h0 : ring (has_append (has_nnnorm (has_nnnorm fun_info)))) : is_domain (has_append (has_nnnorm (has_nnnorm fun_info))) := sorry --non-trivial
lemma new_lemma_68823 (h0 : topological_space (normed_comm_ring congr_arg_kind)) : normal_space (normed_comm_ring congr_arg_kind) := sorry --non-trivial
lemma new_lemma_68824 (h0 : not (list (add_right_cancel_monoid num) -> false)) : list.nodup (classical.by_contradiction' h0) := sorry --non-trivial
lemma new_lemma_68825 (h0 : list (linear_ordered_comm_monoid_with_zero unsigned)) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_68826 (h0 : group (plift (semiring num))) : normalizer_condition (plift (semiring num)) := sorry --non-trivial
lemma new_lemma_68827 (h0 : functor.add_const (filter (normed_comm_ring empty)) unsigned) : filter.ne_bot (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_68828 (h0 : group (semigroup (has_add Type))) : group.fg (semigroup (has_add Type)) := sorry --non-trivial
lemma new_lemma_68829 (h0 : ring (has_top to_additive.value_type)) : rank_condition (has_top to_additive.value_type) := sorry --non-trivial
lemma new_lemma_68830 (h0 : uniform_space (distrib (has_ssubset (has_ssubset linarith.ineq)))) : complete_space (distrib (has_ssubset (has_ssubset linarith.ineq))) := sorry --non-trivial
lemma new_lemma_68831 (h0 : ring (add_left_cancel_monoid (random_gen (random_gen fun_info)))) : rank_condition (add_left_cancel_monoid (random_gen (random_gen fun_info))) := sorry --non-trivial
lemma new_lemma_68832 (h2 : group (normed_field (random_gen char))) : is_cyclic (normed_field (random_gen char)) := sorry --non-trivial
lemma new_lemma_68833 (h0 : not (ring (comm_ring string.iterator_imp) -> false)) : @rank_condition.{0} (comm_ring.{0} string.iterator_imp) (@classical.by_contradiction'.{1} (ring.{0} (comm_ring.{0} string.iterator_imp)) h0)  := sorry --non-trivial
lemma new_lemma_68834 (h0 : function.extfun nat fin) : @preconnected_space.{0} (ordered_comm_monoid.{0} pos) (@matrix.vec_empty.{0} (topological_space.{0} (ordered_comm_monoid.{0} pos)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_68835 (h0 : fin has_zero.zero) : @separated_space.{0} (has_Inf.{0} pos) (@function.extfun_app.{2 1} Type uniform_space.{0} (@matrix.vec_empty.{1} (function.extfun.{2 1} Type uniform_space.{0}) h0) (has_Inf.{0} pos))  := sorry --non-trivial
lemma new_lemma_68836 (h0 : ring (fintype (random_gen (random_gen char)))) : rank_condition (fintype (random_gen (random_gen char))) := sorry --non-trivial
lemma new_lemma_68837 (h0 : functor.add_const (ring linarith.comp) (normed_comm_ring linarith.comp)) : @is_domain.{0} linarith.comp (@functor.add_const.run.{0 0} (ring.{0} linarith.comp) (normed_comm_ring.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_68838 (h0 : add_monoid (pseudo_metric_space (measurable_space.dynkin_system unsigned))) : add_monoid.fg (pseudo_metric_space (measurable_space.dynkin_system unsigned)) := sorry --non-trivial
lemma new_lemma_68839 (h0 : functor.add_const (function.extfun Type group) (ring linarith.comp)) : @group.fg.{0} (add_cancel_monoid.{0} pos) (@function.extfun_app.{2 1} Type group.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type group.{0}) (ring.{0} linarith.comp) h0) (add_cancel_monoid.{0} pos))  := sorry --non-trivial
lemma new_lemma_68840 (h0 : group (denumerable (random_gen (comm_ring linarith.ineq)))) : is_cyclic (denumerable (random_gen (comm_ring linarith.ineq))) := sorry --non-trivial
lemma new_lemma_68841 (h0 : function.extfun Type topological_space) : @loc_path_connected_space.{0} (partial_order.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (partial_order.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_68842 (h0 : function.extfun (Type 1) group) : @normalizer_condition.{1} (comm_group.{1} Type) (@function.extfun_app.{3 2} (Type 1) group.{1} h0 (comm_group.{1} Type))  := sorry --non-trivial
lemma new_lemma_68843 (h0 : ring (complete_semilattice_Sup linarith.ineq)) : strong_rank_condition (complete_semilattice_Sup linarith.ineq) := sorry --non-trivial
lemma new_lemma_68844 (h0 : function.extfun Type cancel_comm_monoid_with_zero) : @unique_factorization_monoid.{0} (canonically_ordered_monoid.{0} (has_Inf.{0} linarith.comp)) (@function.extfun_app.{2 1} Type cancel_comm_monoid_with_zero.{0} h0 (canonically_ordered_monoid.{0} (has_Inf.{0} linarith.comp)))  := sorry --non-trivial
lemma new_lemma_68845 (h0 : group (has_emptyc (random_gen (random_gen num)))) : is_cyclic (has_emptyc (random_gen (random_gen num))) := sorry --non-trivial
lemma new_lemma_68846 (h0 : complete_lattice (pseudo_metric_space (comm_group pos))) : is_compactly_generated (pseudo_metric_space (comm_group pos)) := sorry --non-trivial
lemma new_lemma_68847 (h0 : complete_lattice (has_ssubset (random_gen linarith.comp_source))) : is_compactly_generated (has_ssubset (random_gen linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_68848 (h0 : ring (normed_field (has_nnnorm (has_nnnorm (has_nnnorm reducibility_hints))))) : strong_rank_condition (normed_field (has_nnnorm (has_nnnorm (has_nnnorm reducibility_hints)))) := sorry --non-trivial
lemma new_lemma_68849 (h0 : list (id (with_bot (with_bot linarith.comp_source)))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_68850 (h0 : topological_space (semiring (normed_group (semiring linarith.comp)))) : totally_disconnected_space (semiring (normed_group (semiring linarith.comp))) := sorry --non-trivial
lemma new_lemma_68851 (h0 : not (ring (linear_ordered_add_comm_group to_additive.value_type) -> false)) : @strong_rank_condition.{0} (linear_ordered_add_comm_group.{0} to_additive.value_type) (@classical.by_contradiction'.{1} (ring.{0} (linear_ordered_add_comm_group.{0} to_additive.value_type)) h0)  := sorry --non-trivial
lemma new_lemma_68852 (h0 : functor.add_const (topological_space (has_nndist environment.implicit_infer_kind)) pos) : @locally_compact_space.{0} (has_nndist.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (has_nndist.{0} environment.implicit_infer_kind)) pos h0)  := sorry --non-trivial
lemma new_lemma_68853 (h0 : topological_space (linear_ordered_field name)) : totally_disconnected_space (linear_ordered_field name) := sorry --non-trivial
lemma new_lemma_68854 (h0 : topological_space (add_comm_monoid (has_add (has_add name)))) : totally_disconnected_space (add_comm_monoid (has_add (has_add name))) := sorry --non-trivial
lemma new_lemma_68855 (h0 : functor.add_const (list (add_cancel_monoid Type)) Type) : palindrome (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_68856 (h0 : complete_lattice (has_top (has_inv fun_info))) : is_compactly_generated (has_top (has_inv fun_info)) := sorry --non-trivial
lemma new_lemma_68857 (h0 : add_monoid (add_comm_monoid (add_comm_monoid (add_comm_monoid name)))) : add_monoid.fg (add_comm_monoid (add_comm_monoid (add_comm_monoid name))) := sorry --non-trivial
lemma new_lemma_68858 (h0 : not (group (has_star num) -> false)) : @group.fg.{0} (has_star.{0} num) (@classical.by_contradiction'.{1} (group.{0} (has_star.{0} num)) h0)  := sorry --non-trivial
lemma new_lemma_68859 (h0 : functor.add_const (topological_space (canonically_ordered_add_monoid empty)) empty) : @irreducible_space.{0} (canonically_ordered_add_monoid.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (canonically_ordered_add_monoid.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_68860 (h0 : functor.add_const (topological_space (has_nndist pos)) Type) : @irreducible_space.{0} (has_nndist.{0} pos) (@functor.add_const.run.{0 1} (topological_space.{0} (has_nndist.{0} pos)) Type h0)  := sorry --non-trivial
lemma new_lemma_68861 (h0 : topological_space (free_add_monoid (option unsigned))) : loc_path_connected_space (free_add_monoid (option unsigned)) := sorry --non-trivial
lemma new_lemma_68862 (h0 : prod (measure_theory.measure_space (has_top empty)) (measure_theory.measure_space (has_top empty))) : id_rel h0 := sorry --non-trivial
lemma new_lemma_68863 (h0 : functor.add_const (function.extfun (Type 1) monoid) linarith.comp) : @monoid.fg.{1} (has_neg.{1} Type) (@function.extfun_app.{3 2} (Type 1) monoid.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) monoid.{1}) linarith.comp h0) (has_neg.{1} Type))  := sorry --non-trivial
lemma new_lemma_68864 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @complete_lattice.is_Sup_finite_compact.{0} (canonically_ordered_monoid.{0} real) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (canonically_ordered_monoid.{0} real))  := sorry --non-trivial
lemma new_lemma_68865 (h0 : functor.add_const (add_monoid (boolean_algebra Type)) (ring (ring Type))) : @add_monoid.fg.{1} (boolean_algebra.{1} Type) (@functor.add_const.run.{1 1} (add_monoid.{1} (boolean_algebra.{1} Type)) (ring.{1} (ring.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_68866 (h0 : distrib_lattice num -> semiring environment.implicit_infer_kind -> semiring environment.implicit_infer_kind) (h1 : semiring environment.implicit_infer_kind -> semiring environment.implicit_infer_kind -> Prop) : contravariant_class (distrib_lattice num) (semiring environment.implicit_infer_kind) h0 h1 := sorry --non-trivial
lemma new_lemma_68867 (h0 : group (complete_semilattice_Sup (has_top (has_norm linarith.ineq)))) : is_cyclic (complete_semilattice_Sup (has_top (has_norm linarith.ineq))) := sorry --non-trivial
lemma new_lemma_68868 (h0 : group (add_group num)) : is_cyclic (add_group num) := sorry --non-trivial
lemma new_lemma_68869 (h0 : topological_space (random_gen (with_bot to_additive.value_type))) : locally_compact_space (random_gen (with_bot to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_68870 (h0 : functor.add_const (uniform_space (non_assoc_semiring empty)) unsigned) : @complete_space.{0} (non_assoc_semiring.{0} empty) (@functor.add_const.run.{0 0} (uniform_space.{0} (non_assoc_semiring.{0} empty)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_68871 (h0 : ring (has_zero linarith.comp)) : strong_rank_condition (has_zero linarith.comp) := sorry --non-trivial
lemma new_lemma_68872 (h0 : functor.add_const (filter (add_cancel_monoid name)) pos) : filter.ne_bot (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_68873 (h0 : has_neg enat) (h2 : measurable_space enat) : has_measurable_neg enat := sorry --non-trivial
lemma new_lemma_68874 (h0 : complete_lattice (add_left_cancel_monoid fun_info)) : is_compactly_generated (add_left_cancel_monoid fun_info) := sorry --non-trivial
lemma new_lemma_68875 (h0 : functor.add_const (topological_space (ring Type)) (ordered_ring (has_Inf Type))) : @locally_compact_space.{1} (ring.{1} Type) (@functor.add_const.run.{1 1} (topological_space.{1} (ring.{1} Type)) (ordered_ring.{1} (has_Inf.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_68876 (h0 : cancel_comm_monoid_with_zero (bin_tree (option empty))) : unique_factorization_monoid (bin_tree (option empty)) := sorry --non-trivial
lemma new_lemma_68877 (h0 : ring (add_group (semiring empty))) : is_domain (add_group (semiring empty)) := sorry --non-trivial
lemma new_lemma_68878 (h0 : group (ordered_cancel_add_comm_monoid ennreal)) : is_simple_group (ordered_cancel_add_comm_monoid ennreal) := sorry --non-trivial
lemma new_lemma_68879 (h0 : functor.add_const (add_group (has_neg pos)) environment.implicit_infer_kind) : @is_add_cyclic.{0} (has_neg.{0} pos) (@functor.add_const.run.{0 0} (add_group.{0} (has_neg.{0} pos)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_68880 (h0 : ring (pseudo_metric_space unsigned) -> ring (pseudo_metric_space unsigned) -> Prop) : is_symm (ring (pseudo_metric_space unsigned)) h0 := sorry --non-trivial
lemma new_lemma_68881 (h0 : group (partial_order empty)) : is_cyclic (partial_order empty) := sorry --non-trivial
lemma new_lemma_68882 (h0 : functor.add_const (topological_space (finset environment.implicit_infer_kind)) linarith.comp) : @preconnected_space.{0} (finset.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (finset.{0} environment.implicit_infer_kind)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_68883 (h0 : function.extfun Type (functor.add_const (ring auto.case_option))) : @is_domain.{0} auto.case_option (@functor.add_const.run.{0 0} (ring.{0} auto.case_option) empty (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (ring.{0} auto.case_option)) h0 empty))  := sorry --non-trivial
lemma new_lemma_68884 (h0 : function.extfun Type topological_space) : @path_connected_space.{0} (left_cancel_monoid.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (left_cancel_monoid.{0} num))  := sorry --non-trivial
lemma new_lemma_68885 (h0 : functor.add_const (ring (has_zero Type)) linarith.comp) : @is_principal_ideal_ring.{1} (has_zero.{1} Type) (@functor.add_const.run.{1 0} (ring.{1} (has_zero.{1} Type)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_68886 (h0 : complete_lattice (non_unital_non_assoc_semiring (mul_one_class linarith.ineq))) : complete_lattice.is_Sup_finite_compact (non_unital_non_assoc_semiring (mul_one_class linarith.ineq)) := sorry --non-trivial
lemma new_lemma_68887 (h0 : not (topological_space (with_bot empty) -> false)) : @path_connected_space.{0} (with_bot.{0} empty) (@classical.by_contradiction'.{1} (topological_space.{0} (with_bot.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_68888 (h0 : ordered_comm_monoid (has_inner Type name)) : has_exists_mul_of_le (has_inner Type name) := sorry --non-trivial
lemma new_lemma_68889 (h0 : has_dist unsigned -> has_dist unsigned -> Prop) : well_founded h0 := sorry --non-trivial
lemma new_lemma_68890 (h0 : ring (semigroup (cancel_monoid ennreal))) : strong_rank_condition (semigroup (cancel_monoid ennreal)) := sorry --non-trivial
lemma new_lemma_68891 (h0 : topological_space (sub_neg_monoid real)) : normal_space (sub_neg_monoid real) := sorry --non-trivial
lemma new_lemma_68892 (h0 : ring (ordered_comm_monoid (has_neg name))) : is_principal_ideal_ring (ordered_comm_monoid (has_neg name)) := sorry --non-trivial
lemma new_lemma_68893 (h0 : complete_lattice (has_bot (has_bot (has_bot name)))) : is_compactly_generated (has_bot (has_bot (has_bot name))) := sorry --non-trivial
lemma new_lemma_68894 (h0 : ring (linear_ordered_semiring (semiring fun_info))) : strong_rank_condition (linear_ordered_semiring (semiring fun_info)) := sorry --non-trivial
lemma new_lemma_68895 (h0 : cancel_comm_monoid_with_zero (has_zero (has_neg name))) : unique_factorization_monoid (has_zero (has_neg name)) := sorry --non-trivial
lemma new_lemma_68896 (h0 : fin has_zero.zero) (h1 : pnat) : id (pnat.coprime (matrix.vec_empty h0) h1) := sorry --non-trivial
lemma new_lemma_68897 (h0 : not (function.extfun Type topological_space -> false)) : @discrete_topology.{0} (add_right_cancel_monoid.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (add_right_cancel_monoid.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_68898 (h0 : complete_lattice (random_gen (has_top linarith.comp))) : is_atomistic (random_gen (has_top linarith.comp)) := sorry --non-trivial
lemma new_lemma_68899 (h0 : function.extfun (finset (Type -> Type)) (has_mem.mem group)) : @normalizer_condition.{0} num (@function.extfun_app.{2 1} Type group.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) group.{0} (@function.extfun_app.{2 0} (finset.{1} (Type → Type)) (@has_mem.mem.{1 1} (Type → Type) (finset.{1} (Type → Type)) (@finset.has_mem.{1} (Type → Type)) group.{0}) h0 (@has_emptyc.emptyc.{1} (finset.{1} (Type → Type)) (@finset.has_emptyc.{1} (Type → Type))))) num)  := sorry --non-trivial
lemma new_lemma_68900 (h0 : function.extfun (Type 1) (functor.comp uniform_space ring)) : @separated_space.{1} (ring.{1} Type) (@functor.comp.run.{1 1 1} uniform_space.{1} ring.{1} Type (@function.extfun_app.{3 2} (Type 1) (functor.comp.{1 1 1} uniform_space.{1} ring.{1}) h0 Type))  := sorry --non-trivial
lemma new_lemma_68901 (h0 : filter (normed_linear_ordered_group (semiring unsigned))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_68902 (h0 : group (normed_field fun_info)) : is_cyclic (normed_field fun_info) := sorry --non-trivial
lemma new_lemma_68903 (h0 : functor.add_const (cancel_comm_monoid_with_zero (bin_tree empty)) empty) : @unique_factorization_monoid.{0} (bin_tree.{0} empty) (@functor.add_const.run.{0 0} (cancel_comm_monoid_with_zero.{0} (bin_tree.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_68904 (h0 : functor.add_const (topological_space (canonically_ordered_comm_semiring linarith.comp)) linarith.comp) : @irreducible_space.{0} (canonically_ordered_comm_semiring.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (canonically_ordered_comm_semiring.{0} linarith.comp)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_68905 (h0 : function.extfun Type list) : palindrome (function.extfun_app h0 (pseudo_emetric_space empty)) := sorry --non-trivial
lemma new_lemma_68906 (h0 : functor.add_const (monoid (comm_group linarith.comp)) linarith.comp) : @monoid.fg.{0} (comm_group.{0} linarith.comp) (@functor.add_const.run.{0 0} (monoid.{0} (comm_group.{0} linarith.comp)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_68907 (h0 h1 : not (multiset (linear_ordered_add_comm_monoid_with_top char) -> false)) : multiset.disjoint (classical.by_contradiction' h0) (classical.by_contradiction' h1) := sorry --non-trivial
lemma new_lemma_68908 (h0 : set (linear_ordered_comm_group_with_zero (mul_one_class (mul_one_class std_gen)))) : set.finite h0 := sorry --non-trivial
lemma new_lemma_68909 (h0 : complete_lattice (dlist to_additive.value_type)) : is_compactly_generated (dlist to_additive.value_type) := sorry --non-trivial
lemma new_lemma_68910 (h0 : topological_space (has_ssubset (has_nnnorm fun_info))) : locally_compact_space (has_ssubset (has_nnnorm fun_info)) := sorry --non-trivial
lemma new_lemma_68911 (h0 : topological_space (semigroup (has_to_string name))) : irreducible_space (semigroup (has_to_string name)) := sorry --non-trivial
lemma new_lemma_68912 (h0 : group (has_to_string (has_add Type))) : is_cyclic (has_to_string (has_add Type)) := sorry --non-trivial
lemma new_lemma_68913 (h0 : topological_space (ordered_comm_ring (has_Inf real))) : preirreducible_space (ordered_comm_ring (has_Inf real)) := sorry --non-trivial
lemma new_lemma_68914 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @complete_space.{0} (has_sub.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type uniform_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 uniform_space.{0}) (has_sub.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_68915 (h0 : functor.add_const (list (add_comm_monoid Type)) Type) : palindrome (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_68916 (h1 : uniform_space (complete_semilattice_Sup to_additive.value_type)) : complete_space (complete_semilattice_Sup to_additive.value_type) := sorry --non-trivial
lemma new_lemma_68917 (h0 : preorder linarith.ineq) (h1 : set linarith.ineq) : set.is_pwo h1 := sorry --non-trivial
lemma new_lemma_68918 (h1 : add_group (distrib_lattice (has_nnnorm linarith.ineq))) : is_add_cyclic (distrib_lattice (has_nnnorm linarith.ineq)) := sorry --non-trivial
lemma new_lemma_68919 (h0 : not (complete_lattice (measure_theory.measure_space unsigned) -> false)) : @complete_lattice.is_Sup_finite_compact.{0} (measure_theory.measure_space.{0} unsigned) (@classical.by_contradiction'.{1} (complete_lattice.{0} (measure_theory.measure_space.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_68920 (h0 : topological_space (generalized_boolean_algebra name)) : topological_space.separable_space (generalized_boolean_algebra name) := sorry --non-trivial
lemma new_lemma_68921 (h0 : function.extfun Type ring) : @is_domain.{0} (random_gen.{0} string_imp) (@function.extfun_app.{2 1} Type ring.{0} h0 (random_gen.{0} string_imp))  := sorry --non-trivial
lemma new_lemma_68922 (h0 : function.extfun Type topological_space) : @normal_space.{0} (left_cancel_monoid.{0} (semiring.{0} unsigned)) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (left_cancel_monoid.{0} (semiring.{0} unsigned)))  := sorry --non-trivial
lemma new_lemma_68923 (h0 : group (has_Inf (has_neg (has_Inf name)))) : normalizer_condition (has_Inf (has_neg (has_Inf name))) := sorry --non-trivial
lemma new_lemma_68924 (h0 : function.extfun Type topological_space) : @irreducible_space.{0} (has_inner.{0 0} empty congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_inner.{0 0} empty congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_68925 (h0 : topological_space (add_group_with_zero_nhd enat)) : path_connected_space (add_group_with_zero_nhd enat) := sorry --non-trivial
lemma new_lemma_68926 (h0 : not (group congr_arg_kind -> false)) : @normalizer_condition.{0} congr_arg_kind (@classical.by_contradiction'.{1} (group.{0} congr_arg_kind) h0)  := sorry --non-trivial
lemma new_lemma_68927 (h0 : has_mem.mem (with_bot fun_info) has_emptyc.emptyc) : filter.ne_bot (finset.pi.empty filter (with_bot fun_info) h0) := sorry --non-trivial
lemma new_lemma_68928 (h0 : functor.add_const (function.extfun Type topological_space) pos) : @loc_path_connected_space.{0} (has_zero.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) pos h0) (has_zero.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_68929 (h0 : functor.add_const (function.extfun Type topological_space) pos) : @locally_compact_space.{0} (add_comm_monoid.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) pos h0) (add_comm_monoid.{0} name))  := sorry --non-trivial
lemma new_lemma_68930 (h0 : complete_lattice (group_with_zero (option unsigned))) : complete_lattice.is_Sup_finite_compact (group_with_zero (option unsigned)) := sorry --non-trivial
lemma new_lemma_68931 (h0 : function.extfun Type (functor.add_const (topological_space (has_star empty)))) : @irreducible_space.{0} (has_star.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (has_star.{0} empty)) num (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (topological_space.{0} (has_star.{0} empty))) h0 num))  := sorry --non-trivial
lemma new_lemma_68932 (h0 : function.extfun Type monoid) : @monoid.fg.{0} (has_union.{0} linarith.comp) (@function.extfun_app.{2 1} Type monoid.{0} h0 (has_union.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_68933 (h0 : uniform_space (normed_comm_ring (ordered_cancel_comm_monoid (mul_zero_class name)))) : separated_space (normed_comm_ring (ordered_cancel_comm_monoid (mul_zero_class name))) := sorry --non-trivial
lemma new_lemma_68934 (h0 : group (measurable_space (random_gen (random_gen to_additive.value_type)))) : group.fg (measurable_space (random_gen (random_gen to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_68935 (h0 : functor.add_const (topological_space (has_nndist ennreal)) num) : @locally_compact_space.{0} (has_nndist.{0} ennreal) (@functor.add_const.run.{0 0} (topological_space.{0} (has_nndist.{0} ennreal)) num h0)  := sorry --non-trivial
lemma new_lemma_68936 (h0 : topological_space (has_scalar to_additive.value_type congr_arg_kind)) : irreducible_space (has_scalar to_additive.value_type congr_arg_kind) := sorry --non-trivial
lemma new_lemma_68937 (h0 : topological_space (has_neg_part (finset (comm_group (has_add ennreal))))) : path_connected_space (has_neg_part (finset (comm_group (has_add ennreal)))) := sorry --non-trivial
lemma new_lemma_68938 (h0 : function.extfun Type ring) : @strong_rank_condition.{0} (has_union.{0} empty) (@function.extfun_app.{2 1} Type ring.{0} h0 (has_union.{0} empty))  := sorry --non-trivial
lemma new_lemma_68939 (h0 : complete_lattice (ordered_comm_monoid (has_Inf (sub_neg_monoid Type)))) : complete_lattice.is_Sup_finite_compact (ordered_comm_monoid (has_Inf (sub_neg_monoid Type))) := sorry --non-trivial
lemma new_lemma_68940 (h0 : not (topological_space (semiring (random_gen num)) -> false)) : @irreducible_space.{0} (semiring.{0} (random_gen.{0} num)) (@classical.by_contradiction'.{1} (topological_space.{0} (semiring.{0} (random_gen.{0} num))) h0)  := sorry --non-trivial
lemma new_lemma_68941 (h0 : topological_space (has_union (semiring (semiring (semiring (semiring unsigned)))))) : normal_space (has_union (semiring (semiring (semiring (semiring unsigned))))) := sorry --non-trivial
lemma new_lemma_68942 (h0 : add_group (has_add (sub_neg_monoid (ordered_comm_monoid (has_Inf real))))) : is_add_cyclic (has_add (sub_neg_monoid (ordered_comm_monoid (has_Inf real)))) := sorry --non-trivial
lemma new_lemma_68943 (h0 : list (comm_ring (has_nnnorm linarith.ineq))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_68944 (h0 : function.extfun nat fin) : @is_simple_group.{0} (complete_distrib_lattice.{0} real) (@matrix.vec_empty.{0} (group.{0} (complete_distrib_lattice.{0} real)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_68945 (h0 : topological_space (comm_group environment.implicit_infer_kind)) : preirreducible_space (comm_group environment.implicit_infer_kind) := sorry --non-trivial
lemma new_lemma_68946 (h0 : function.extfun Type complete_lattice) : @is_compactly_generated.{0} (comm_group.{0} ennreal) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (comm_group.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_68947 (h0 : list (ordered_comm_group (option (complete_distrib_lattice empty)))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_68948 (h0 : topological_space (canonically_ordered_monoid (has_neg pos))) : preirreducible_space (canonically_ordered_monoid (has_neg pos)) := sorry --non-trivial
lemma new_lemma_68949 (h0 : add_group (distrib_lattice char)) : is_add_cyclic (distrib_lattice char) := sorry --non-trivial
lemma new_lemma_68950 (h0 : ring (has_neg (finset (has_add (has_add name))))) : is_principal_ideal_ring (has_neg (finset (has_add (has_add name)))) := sorry --non-trivial
lemma new_lemma_68951 (h0 : functor.add_const (uniform_space (simple_graph Type)) pos) : @separated_space.{1} (simple_graph.{1} Type) (@functor.add_const.run.{1 0} (uniform_space.{1} (simple_graph.{1} Type)) pos h0)  := sorry --non-trivial
lemma new_lemma_68952 (h0 : not (function.extfun Type topological_space -> false)) : @t1_space.{0} (left_cancel_semigroup.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (left_cancel_semigroup.{0} empty))  := sorry --non-trivial
lemma new_lemma_68953 (h0 : cancel_comm_monoid_with_zero (boolean_algebra (has_Inf (has_pos_part (has_Inf pos))))) : unique_factorization_monoid (boolean_algebra (has_Inf (has_pos_part (has_Inf pos)))) := sorry --non-trivial
lemma new_lemma_68954 (h0 : fin has_zero.zero) : @t1_space.{0} (boolean_algebra.{0} real) (@function.extfun_app.{2 1} Type topological_space.{0} (@matrix.vec_empty.{1} (function.extfun.{2 1} Type topological_space.{0}) h0) (boolean_algebra.{0} real))  := sorry --non-trivial
lemma new_lemma_68955 (h0 : topological_space (mul_zero_class (has_add ennreal))) : locally_compact_space (mul_zero_class (has_add ennreal)) := sorry --non-trivial
lemma new_lemma_68956 (h0 : topological_space (has_nnnorm ereal)) (h1 : preorder (has_nnnorm ereal)) : order_closed_topology (has_nnnorm ereal) := sorry --non-trivial
lemma new_lemma_68957 (h0 : fin has_zero.zero) : @has_exists_mul_of_le.{0} (finset.{0} pos) (@matrix.vec_empty.{0} (ordered_comm_monoid.{0} (finset.{0} pos)) (@matrix.vec_empty.{0} (fin (@has_zero.zero.{0} nat nat.has_zero)) h0))  := sorry --non-trivial
lemma new_lemma_68958 (h0 : ring (add_cancel_monoid (has_pos_part linarith.comp))) : is_domain (add_cancel_monoid (has_pos_part linarith.comp)) := sorry --non-trivial
lemma new_lemma_68959 (h0 : functor.add_const (topological_space (boolean_algebra.core Type)) environment.implicit_infer_kind) : @preconnected_space.{1} (boolean_algebra.core.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (boolean_algebra.core.{1} Type)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_68960 (h0 : not (topological_space (measurable_space empty) -> false)) : @locally_compact_space.{0} (measurable_space.{0} empty) (@classical.by_contradiction'.{1} (topological_space.{0} (measurable_space.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_68961 (h0 : functor.add_const (complete_lattice (comm_group linarith.comp)) Type) : @complete_lattice.is_Sup_finite_compact.{0} (comm_group.{0} linarith.comp) (@functor.add_const.run.{0 1} (complete_lattice.{0} (comm_group.{0} linarith.comp)) Type h0)  := sorry --non-trivial
lemma new_lemma_68962 (h0 : add_group (mul_one_class real.angle)) : is_add_cyclic (mul_one_class real.angle) := sorry --non-trivial
lemma new_lemma_68963 (h0 : function.extfun Type topological_space) : @t1_space.{0} (add_left_cancel_semigroup.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (add_left_cancel_semigroup.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_68964 (h0 : ring (with_zero char)) : is_domain (with_zero char) := sorry --non-trivial
lemma new_lemma_68965 (h0 : monoid (measurable_space (has_inv (random_gen (random_gen linarith.ineq))))) : monoid.fg (measurable_space (has_inv (random_gen (random_gen linarith.ineq)))) := sorry --non-trivial
lemma new_lemma_68966 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @totally_disconnected_space.{0} (simple_graph.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (simple_graph.{0} empty))  := sorry --non-trivial
lemma new_lemma_68967 (h0 : monoid (complete_semilattice_Sup (has_inv (has_inv (has_inv linarith.comp_source))))) : monoid.fg (complete_semilattice_Sup (has_inv (has_inv (has_inv linarith.comp_source)))) := sorry --non-trivial
lemma new_lemma_68968 (h0 : functor.add_const (function.extfun Type list) linarith.comp) : list.nodup (function.extfun_app (functor.add_const.run h0) (add_cancel_monoid linarith.comp)) := sorry --non-trivial
lemma new_lemma_68969 (h0 : not (ring (uniform_space reducibility_hints) -> false)) : @strong_rank_condition.{0} (uniform_space.{0} reducibility_hints) (@classical.by_contradiction'.{1} (ring.{0} (uniform_space.{0} reducibility_hints)) h0)  := sorry --non-trivial
lemma new_lemma_68970 (h0 : ring (has_nnnorm (random_gen (has_ssubset string_imp)))) : strong_rank_condition (has_nnnorm (random_gen (has_ssubset string_imp))) := sorry --non-trivial
lemma new_lemma_68971 (h0 : functor.add_const (complete_lattice (add_left_cancel_semigroup unsigned)) (option (option empty))) : @is_compactly_generated.{0} (add_left_cancel_semigroup.{0} unsigned) (@functor.add_const.run.{0 0} (complete_lattice.{0} (add_left_cancel_semigroup.{0} unsigned)) (option.{0} (option.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_68972 (h0 : has_mem.mem (measurable_space congr_arg_kind) has_emptyc.emptyc) : @is_domain.{0} (measurable_space.{0} congr_arg_kind) (@finset.pi.empty.{1 0} Type ring.{0} (measurable_space.{0} congr_arg_kind) h0)  := sorry --non-trivial
lemma new_lemma_68973 (h0 : topological_space (with_bot (random_gen linarith.comp_source))) : path_connected_space (with_bot (random_gen linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_68974 (h0 : not (function.extfun Type uniform_space -> false)) : @separated_space.{0} (has_one.{0} unsigned) (@function.extfun_app.{2 1} Type uniform_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type uniform_space.{0}) h0) (has_one.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_68975 (h0 : functor.comp group finset name) : @normalizer_condition.{0} (finset.{0} name) (@functor.comp.run.{0 0 0} group.{0} finset.{0} name h0)  := sorry --non-trivial
lemma new_lemma_68976 (h0 : topological_space (linear_ordered_comm_group_with_zero linarith.ineq)) (h1 : preorder (linear_ordered_comm_group_with_zero linarith.ineq)) : order_topology (linear_ordered_comm_group_with_zero linarith.ineq) := sorry --non-trivial
lemma new_lemma_68977 (h0 : topological_space (has_star (semiring (semiring num)))) : totally_separated_space (has_star (semiring (semiring num))) := sorry --non-trivial
lemma new_lemma_68978 (h0 : topological_space (boolean_algebra.core num)) : discrete_topology (boolean_algebra.core num) := sorry --non-trivial
lemma new_lemma_68979 (h1 : ring (topological_space (topological_space (denumerable (has_nnnorm (random_gen string_imp)))))) : is_domain (topological_space (topological_space (denumerable (has_nnnorm (random_gen string_imp))))) := sorry --non-trivial
lemma new_lemma_68980 (h0 : topological_space (semigroup environment.implicit_infer_kind)) : sequential_space (semigroup environment.implicit_infer_kind) := sorry --non-trivial
lemma new_lemma_68981 (h0 : list (has_nndist (finset (finset (finset ennreal))))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_68982 (h0 : ring (uniform_space (mul_one_class fun_info))) : rank_condition (uniform_space (mul_one_class fun_info)) := sorry --non-trivial
lemma new_lemma_68983 (h0 : functor.add_const (functor.add_const (ring name) unsigned) num) : @strong_rank_condition.{0} name (@functor.add_const.run.{0 0} (ring.{0} name) unsigned (@functor.add_const.run.{0 0} (functor.add_const.{0 0} (ring.{0} name) unsigned) num h0))  := sorry --non-trivial
lemma new_lemma_68984 (h0 : filter (add_cancel_comm_monoid unsigned)) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_68985 (h0 : semiring (has_neg_part (mul_zero_class pos))) : is_noetherian_ring (has_neg_part (mul_zero_class pos)) := sorry --non-trivial
lemma new_lemma_68986 (h0 : add_group (measurable_space (has_norm to_additive.value_type))) : is_add_cyclic (measurable_space (has_norm to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_68987 (h0 : complete_lattice (add_comm_monoid (comm_semigroup pos))) : is_compactly_generated (add_comm_monoid (comm_semigroup pos)) := sorry --non-trivial
lemma new_lemma_68988 (h0 : function.extfun (finset (Type -> Type)) (has_mem.mem topological_space)) : locally_compact_space empty := sorry --non-trivial
lemma new_lemma_68989 (h0 : list pnat) (h1 : ne h0 list.nil) (h2 : with_bot pnat) (h3 : ne h2 has_bot.bot) : pnat.coprime (list.last h0 h1) (with_bot.unbot h2 h3) := sorry --non-trivial
lemma new_lemma_68990 (h0 : functor.add_const (topological_space (canonically_linear_ordered_monoid real.angle)) pos) : @discrete_topology.{0} (canonically_linear_ordered_monoid.{0} real.angle) (@functor.add_const.run.{0 0} (topological_space.{0} (canonically_linear_ordered_monoid.{0} real.angle)) pos h0)  := sorry --non-trivial
lemma new_lemma_68991 (h1 : add_monoid (id num)) : add_monoid.fg (id num) := sorry --non-trivial
lemma new_lemma_68992 (h0 : fin has_zero.zero) : @totally_disconnected_space.{0} (ordered_comm_ring.{0} name) (@matrix.vec_empty.{0} (topological_space.{0} (ordered_comm_ring.{0} name)) h0)  := sorry --non-trivial
lemma new_lemma_68993 (h0 : function.extfun Type topological_space) : @t1_space.{0} (semiring.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (semiring.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_68994 (h0 : not (ring (measure_theory.measure_space congr_arg_kind) -> false)) : @is_principal_ideal_ring.{0} (measure_theory.measure_space.{0} congr_arg_kind) (@classical.by_contradiction'.{1} (ring.{0} (measure_theory.measure_space.{0} congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_68995 (h0 : ring (group_with_zero (option (option (option num))))) : rank_condition (group_with_zero (option (option (option num)))) := sorry --non-trivial
lemma new_lemma_68996 (h0 : has_coe (add_comm_semigroup char) Prop) (h1 : add_comm_semigroup char) : @coe_b.{1 1} (add_comm_semigroup.{0} char) Prop h0 h1  := sorry --non-trivial
lemma new_lemma_68997 (h1 : uniform_space (normed_field linarith.ineq)) : complete_space (normed_field linarith.ineq) := sorry --non-trivial
lemma new_lemma_68998 (h0 : finset (partial_order congr_arg_kind)) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_68999 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @loc_path_connected_space.{0} (ring.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (ring.{0} pos))  := sorry --non-trivial
lemma new_lemma_69000 (h0 : add_group (ordered_comm_ring linarith.ineq)) : is_add_cyclic (ordered_comm_ring linarith.ineq) := sorry --non-trivial
lemma new_lemma_69001 (h0 : filter (canonically_ordered_comm_semiring Type)) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_69002 (h0 : ring (has_nndist (finset environment.implicit_infer_kind))) : is_domain (has_nndist (finset environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_69003 (h0 : ring (linear_ordered_add_comm_group (has_nnnorm linarith.comp_source))) : rank_condition (linear_ordered_add_comm_group (has_nnnorm linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_69004 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @monoid.fg.{0} (dlist.{0} fun_info) (@function.extfun_app.{2 1} Type monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 monoid.{0}) (dlist.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_69005 (h0 : finset (has_pos_part (has_Inf (ordered_comm_monoid (has_pos_part Type))))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_69006 (h0 h1 : Prop) : xor h0 h1 := sorry --non-trivial
lemma new_lemma_69007 (h0 : add_monoid (add_cancel_monoid (comm_group (comm_group ennreal)))) : add_monoid.fg (add_cancel_monoid (comm_group (comm_group ennreal))) := sorry --non-trivial
lemma new_lemma_69008 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : filter.ne_bot (function.extfun_app (function.extfun_app h0 filter) (semigroup name)) := sorry --non-trivial
lemma new_lemma_69009 (h0 : functor.add_const (complete_lattice (semigroup Type)) Type) : @is_compactly_generated.{1} (semigroup.{1} Type) (@functor.add_const.run.{1 1} (complete_lattice.{1} (semigroup.{1} Type)) Type h0)  := sorry --non-trivial
lemma new_lemma_69010 (h0 : function.extfun Type add_group) : @is_add_cyclic.{0} (has_nndist.{0} pos) (@function.extfun_app.{2 1} Type add_group.{0} h0 (has_nndist.{0} pos))  := sorry --non-trivial
lemma new_lemma_69011 (h0 : ring (add_cancel_monoid num)) : strong_rank_condition (add_cancel_monoid num) := sorry --non-trivial
lemma new_lemma_69012 (h0 : semiring char) (h1 : char) : odd h1 := sorry --non-trivial
lemma new_lemma_69013 (h0 : function.extfun Type topological_space) : @loc_path_connected_space.{0} (boolean_algebra.core.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (boolean_algebra.core.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_69014 (h0 : topological_space (measurable_space to_additive.value_type)) : totally_disconnected_space (measurable_space to_additive.value_type) := sorry --non-trivial
lemma new_lemma_69015 (h0 : function.extfun Type ring) : @strong_rank_condition.{0} (comm_monoid.{0} pos) (@function.extfun_app.{2 1} Type ring.{0} h0 (comm_monoid.{0} pos))  := sorry --non-trivial
lemma new_lemma_69016 (h0 : ring (ring unsigned)) : is_principal_ideal_ring (ring unsigned) := sorry --non-trivial
lemma new_lemma_69017 (h0 : group (mul_zero_class (finset ennreal))) : group.fg (mul_zero_class (finset ennreal)) := sorry --non-trivial
lemma new_lemma_69018 (h0 : function.extfun Type (functor.add_const (topological_space linarith.comp))) : @regular_space.{0} linarith.comp (@functor.add_const.run.{0 0} (topological_space.{0} linarith.comp) (has_Inf.{0} linarith.comp) (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (topological_space.{0} linarith.comp)) h0 (has_Inf.{0} linarith.comp)))  := sorry --non-trivial
lemma new_lemma_69019 (h1 : not (topological_space (measurable_space congr_arg_kind) -> false)) : @t0_space.{0} (measurable_space.{0} congr_arg_kind) (@classical.by_contradiction'.{1} (topological_space.{0} (measurable_space.{0} congr_arg_kind)) h1)  := sorry --non-trivial
lemma new_lemma_69020 (h0 : filter (linear_ordered_add_comm_group (has_nnnorm linarith.ineq))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_69021 (h0 : function.extfun Type uniform_space) : @separated_space.{0} (mul_zero_class.{0} ennreal) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (mul_zero_class.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_69022 (h0 : monoid (add_group empty)) : monoid.fg (add_group empty) := sorry --non-trivial
lemma new_lemma_69023 (h0 : group (complete_distrib_lattice (comm_group (add_comm_monoid pos)))) : is_simple_group (complete_distrib_lattice (comm_group (add_comm_monoid pos))) := sorry --non-trivial
lemma new_lemma_69024 (h0 : function.extfun (Type 1) (functor.add_const Prop)) : functor.add_const.run (function.extfun_app h0 (has_to_string Type)) := sorry --non-trivial
lemma new_lemma_69025 (h0 : not (complete_lattice (id num) -> false)) : @is_atomistic.{0} (@id.{2} Type num) (@classical.by_contradiction'.{1} (complete_lattice.{0} (@id.{2} Type num)) h0)  := sorry --non-trivial
lemma new_lemma_69026 (h0 : topological_space (id (semiring congr_arg_kind))) : preirreducible_space (id (semiring congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_69027 (h0 : function.extfun Type topological_space) : @t0_space.{0} (omega_complete_partial_order.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (omega_complete_partial_order.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_69028 (h0 : function.extfun Type topological_space) : @t1_space.{0} (ring.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (ring.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_69029 (h0 : function.extfun (Type 1) list) : list.nodup (function.extfun_app h0 (simple_graph Type)) := sorry --non-trivial
lemma new_lemma_69030 (h1 : complete_lattice (with_zero string_imp)) : complete_lattice.is_Sup_finite_compact (with_zero string_imp) := sorry --non-trivial
lemma new_lemma_69031 (h0 : cancel_comm_monoid_with_zero (has_Inf linarith.comp)) : unique_factorization_monoid (has_Inf linarith.comp) := sorry --non-trivial
lemma new_lemma_69032 (h0 : topological_space (has_neg (add_comm_monoid Type))) : preconnected_space (has_neg (add_comm_monoid Type)) := sorry --non-trivial
lemma new_lemma_69033 (h0 : topological_space (boolean_algebra (normed_comm_ring name))) : regular_space (boolean_algebra (normed_comm_ring name)) := sorry --non-trivial
lemma new_lemma_69034 (h1 : ring (add_cancel_comm_monoid (metric_space reducibility_hints))) : is_domain (add_cancel_comm_monoid (metric_space reducibility_hints)) := sorry --non-trivial
lemma new_lemma_69035 (h0 : group (id (random_gen to_additive.value_type))) : is_cyclic (id (random_gen to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_69036 (h0 : complete_lattice (linear_ordered_add_comm_monoid_with_top empty)) : is_compactly_generated (linear_ordered_add_comm_monoid_with_top empty) := sorry --non-trivial
lemma new_lemma_69037 (h0 : uniform_space (add_cancel_monoid (has_zero (ring linarith.comp)))) : complete_space (add_cancel_monoid (has_zero (ring linarith.comp))) := sorry --non-trivial
lemma new_lemma_69038 (h0 : not (function.extfun (Type -> Type) (function.extfun Type) -> false)) : @normal_space.{0} (with_one.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) (@classical.by_contradiction'.{2} (function.extfun.{2 2} (Type → Type) (function.extfun.{2 1} Type)) h0) topological_space.{0}) (with_one.{0} num))  := sorry --non-trivial
lemma new_lemma_69039 (h0 : functor.add_const (functor.add_const (function.extfun Type ring) Type) linarith.comp) : @is_domain.{0} (add_comm_monoid.{0} name) (@function.extfun_app.{2 1} Type ring.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type ring.{0}) Type (@functor.add_const.run.{1 0} (functor.add_const.{1 1} (function.extfun.{2 1} Type ring.{0}) Type) linarith.comp h0)) (add_comm_monoid.{0} name))  := sorry --non-trivial
lemma new_lemma_69040 (h0 : functor.comp group has_neg linarith.comp) : @group.fg.{0} (has_neg.{0} linarith.comp) (@functor.comp.run.{0 0 0} group.{0} has_neg.{0} linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_69041 (h1 : not (function.extfun Type add_group -> false)) : @is_add_cyclic.{0} (complete_semilattice_Sup.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type add_group.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type add_group.{0}) h1) (complete_semilattice_Sup.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_69042 (h0 : group (has_neg (ring linarith.comp))) : normalizer_condition (has_neg (ring linarith.comp)) := sorry --non-trivial
lemma new_lemma_69043 (h0 : ring (division_ring (has_top linarith.comp_source))) : strong_rank_condition (division_ring (has_top linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_69044 (h0 : uniform_space (has_pos_part (has_Inf Type))) : complete_space (has_pos_part (has_Inf Type)) := sorry --non-trivial
lemma new_lemma_69045 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_domain.{0} (linear_ordered_comm_monoid_with_zero.{0} unsigned) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (linear_ordered_comm_monoid_with_zero.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_69046 (h0 : function.extfun Type add_monoid) : @add_monoid.fg.{0} (linear_ordered_comm_ring.{0} unsigned) (@function.extfun_app.{2 1} Type add_monoid.{0} h0 (linear_ordered_comm_ring.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_69047 (h0 : complete_lattice (has_to_string (boolean_algebra.core environment.implicit_infer_kind))) : is_atomistic (has_to_string (boolean_algebra.core environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_69048 (h0 : ring (has_div (mul_one_class (mul_one_class linarith.ineq)))) : is_domain (has_div (mul_one_class (mul_one_class linarith.ineq))) := sorry --non-trivial
lemma new_lemma_69049 (h0 : has_mem.mem (has_emptyc linarith.comp_source) has_emptyc.emptyc) : @is_compactly_generated.{0} (has_emptyc.{0} linarith.comp_source) (@finset.pi.empty.{1 0} Type complete_lattice.{0} (has_emptyc.{0} linarith.comp_source) h0)  := sorry --non-trivial
lemma new_lemma_69050 (h0 : semiring (has_to_string (option pos))) : is_noetherian_ring (has_to_string (option pos)) := sorry --non-trivial
lemma new_lemma_69051 (h0 : functor.add_const (topological_space (ring ennreal)) unsigned) : @normal_space.{0} (ring.{0} ennreal) (@functor.add_const.run.{0 0} (topological_space.{0} (ring.{0} ennreal)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_69052 (h0 : boolean_algebra.core (option (option (option pos))) -> boolean_algebra.core (option (option (option pos))) -> Prop) : is_symm (boolean_algebra.core (option (option (option pos)))) h0 := sorry --non-trivial
lemma new_lemma_69053 (h0 : functor.add_const (uniform_space (has_add pos)) pos) : @complete_space.{0} (has_add.{0} pos) (@functor.add_const.run.{0 0} (uniform_space.{0} (has_add.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_69054 (h0 : function.extfun (finset Type) (has_mem.mem (semiring num))) : @is_cyclic.{0} (semiring.{0} num) (@finset.pi.empty.{1 0} Type group.{0} (semiring.{0} num) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (semiring.{0} num)) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_69055 (h0 : not (function.extfun Type topological_space -> false)) : @t0_space.{0} (has_inv.{0} fun_info) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (has_inv.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_69056 (h0 : ordered_comm_monoid (normed_comm_ring unsigned)) : has_exists_mul_of_le (normed_comm_ring unsigned) := sorry --non-trivial
lemma new_lemma_69057 (h1 : filter (topological_space char)) : filter.ne_bot h1 := sorry --non-trivial
lemma new_lemma_69058 (h0 : topological_space (semigroup (cancel_monoid name))) : irreducible_space (semigroup (cancel_monoid name)) := sorry --non-trivial
lemma new_lemma_69059 (h0 : ring (boolean_algebra (has_to_string pos))) : is_domain (boolean_algebra (has_to_string pos)) := sorry --non-trivial
lemma new_lemma_69060 (h0 : functor.add_const (semiring (has_add Type)) environment.implicit_infer_kind) : @is_noetherian_ring.{1} (has_add.{1} Type) (@functor.add_const.run.{1 0} (semiring.{1} (has_add.{1} Type)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_69061 (h0 : set (add_comm_semigroup enat -> add_comm_semigroup fun_info)) : set.separates_points h0 := sorry --non-trivial
lemma new_lemma_69062 (h0 : function.extfun Type uniform_space) : @separated_space.{0} (has_add.{0} ennreal) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (has_add.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_69063 (h1 : not (uniform_space (simple_graph string_imp) -> false)) : @complete_space.{0} (simple_graph.{0} string_imp) (@classical.by_contradiction'.{1} (uniform_space.{0} (simple_graph.{0} string_imp)) h1)  := sorry --non-trivial
lemma new_lemma_69064 (h0 : ring (ordered_comm_ring (finset (finset Type)))) : strong_rank_condition (ordered_comm_ring (finset (finset Type))) := sorry --non-trivial
lemma new_lemma_69065 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @irreducible_space.{0} (complete_distrib_lattice.{0} real) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (complete_distrib_lattice.{0} real))  := sorry --non-trivial
lemma new_lemma_69066 (h0 : functor.add_const (filter (ring Type)) (has_add linarith.comp)) : filter.ne_bot (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_69067 (h0 : monoid (has_neg_part (finset linarith.comp))) : monoid.fg (has_neg_part (finset linarith.comp)) := sorry --non-trivial
lemma new_lemma_69068 (h0 : ring (comm_semigroup (has_Inf (has_pos_part (has_Inf real))))) : rank_condition (comm_semigroup (has_Inf (has_pos_part (has_Inf real)))) := sorry --non-trivial
lemma new_lemma_69069 (h0 : semiring (finset (finset (has_add pos)))) : is_noetherian_ring (finset (finset (has_add pos))) := sorry --non-trivial
lemma new_lemma_69070 (h0 : complete_lattice (complete_semilattice_Sup linarith.comp)) : is_atomistic (complete_semilattice_Sup linarith.comp) := sorry --non-trivial
lemma new_lemma_69071 (h0 : functor.add_const (add_group (ring ennreal)) unsigned) : @is_add_cyclic.{0} (ring.{0} ennreal) (@functor.add_const.run.{0 0} (add_group.{0} (ring.{0} ennreal)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_69072 (h0 : topological_space (denumerable (add_right_cancel_monoid (comm_semigroup string_imp)))) : path_connected_space (denumerable (add_right_cancel_monoid (comm_semigroup string_imp))) := sorry --non-trivial
lemma new_lemma_69073 (h0 : topological_space (has_compl std_gen)) : path_connected_space (has_compl std_gen) := sorry --non-trivial
lemma new_lemma_69074 (h0 : topological_space (is_R_or_C congr_arg_kind)) : discrete_topology (is_R_or_C congr_arg_kind) := sorry --non-trivial
lemma new_lemma_69075 (h0 : add_group (semi_normed_ring enat)) : is_add_cyclic (semi_normed_ring enat) := sorry --non-trivial
lemma new_lemma_69076 (h0 : functor.add_const (list (has_zero Type)) Type) : list.nodup (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_69077 (h0 : functor.add_const (uniform_space (normed_comm_ring name)) (ring environment.implicit_infer_kind)) : @separated_space.{0} (normed_comm_ring.{0} name) (@functor.add_const.run.{0 0} (uniform_space.{0} (normed_comm_ring.{0} name)) (ring.{0} environment.implicit_infer_kind) h0)  := sorry --non-trivial
lemma new_lemma_69078 (h0 : add_monoid (measurable_space.dynkin_system (semiring (semiring unsigned)))) : add_monoid.fg (measurable_space.dynkin_system (semiring (semiring unsigned))) := sorry --non-trivial
lemma new_lemma_69079 (h0 : topological_space (complete_distrib_lattice string_imp)) : path_connected_space (complete_distrib_lattice string_imp) := sorry --non-trivial
lemma new_lemma_69080 (h0 : functor.add_const (function.extfun (Type 1) group) linarith.comp) : @is_cyclic.{1} (add_cancel_monoid.{1} Type) (@function.extfun_app.{3 2} (Type 1) group.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) group.{1}) linarith.comp h0) (add_cancel_monoid.{1} Type))  := sorry --non-trivial
lemma new_lemma_69081 (h0 : set (has_div enat)) : set.subsingleton h0 := sorry --non-trivial
lemma new_lemma_69082 (h0 : topological_space (ordered_comm_ring (has_neg pos))) : loc_path_connected_space (ordered_comm_ring (has_neg pos)) := sorry --non-trivial
lemma new_lemma_69083 (h0 : uniform_space (random_gen string.iterator_imp)) : complete_space (random_gen string.iterator_imp) := sorry --non-trivial
lemma new_lemma_69084 (h0 : ring (finset (finset pos))) : is_domain (finset (finset pos)) := sorry --non-trivial
lemma new_lemma_69085 (h0 : topological_space (is_R_or_C (semiring empty))) : t0_space (is_R_or_C (semiring empty)) := sorry --non-trivial
lemma new_lemma_69086 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_principal_ideal_ring.{0} (has_zero.{0} unsigned) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (has_zero.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_69087 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @monoid.fg.{0} (has_norm.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 monoid.{0}) (has_norm.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_69088 (h0 : ring (with_one (random_gen linarith.comp_source))) : strong_rank_condition (with_one (random_gen linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_69089 (h2 : not (filter (random_gen linarith.ineq) -> false)) : filter.ne_bot (classical.by_contradiction' h2) := sorry --non-trivial
lemma new_lemma_69090 (h0 : functor.add_const (functor.add_const (ordered_add_comm_monoid Type) pos) name) : @archimedean.{1} Type (@functor.add_const.run.{1 0} (ordered_add_comm_monoid.{1} Type) pos (@functor.add_const.run.{1 0} (functor.add_const.{1 0} (ordered_add_comm_monoid.{1} Type) pos) name h0))  := sorry --non-trivial
lemma new_lemma_69091 (h0 : function.extfun (Type 1) complete_lattice) : @complete_lattice.is_Sup_finite_compact.{1} (ordered_comm_monoid.{1} Type) (@function.extfun_app.{3 2} (Type 1) complete_lattice.{1} h0 (ordered_comm_monoid.{1} Type))  := sorry --non-trivial
lemma new_lemma_69092 (h0 : topological_space (sub_neg_monoid linarith.comp)) : regular_space (sub_neg_monoid linarith.comp) := sorry --non-trivial
lemma new_lemma_69093 (h0 : topological_space (has_emptyc (random_gen num))) : totally_separated_space (has_emptyc (random_gen num)) := sorry --non-trivial
lemma new_lemma_69094 (h0 : function.extfun Type complete_lattice) : @is_atomistic.{0} (as_linear_order.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (as_linear_order.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_69095 (h0 : ring (nondiscrete_normed_field (add_comm_semigroup char))) : strong_rank_condition (nondiscrete_normed_field (add_comm_semigroup char)) := sorry --non-trivial
lemma new_lemma_69096 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_cyclic.{0} (has_pos_part.{0} pos) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (has_pos_part.{0} pos))  := sorry --non-trivial
lemma new_lemma_69097 (h0 : function.extfun Type topological_space) : @irreducible_space.{0} (has_neg.{0} (has_nndist.{0} name)) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_neg.{0} (has_nndist.{0} name)))  := sorry --non-trivial
lemma new_lemma_69098 (h0 : functor.add_const (topological_space (cancel_monoid Type)) (has_add (has_add ennreal))) : @preconnected_space.{1} (cancel_monoid.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (cancel_monoid.{1} Type)) (has_add.{0} (has_add.{0} ennreal)) h0)  := sorry --non-trivial
lemma new_lemma_69099 (h0 : list (add_cancel_monoid (has_Inf pos))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_69100 (h3 : set reducibility_hints) : set.finite h3 := sorry --non-trivial
lemma new_lemma_69101 (h0 : topological_space (has_bot (option empty))) : totally_disconnected_space (has_bot (option empty)) := sorry --non-trivial
lemma new_lemma_69102 (h0 : function.extfun (finset Type) (has_mem.mem (measurable_space num))) : @path_connected_space.{0} (measurable_space.{0} num) (@finset.pi.empty.{1 0} Type topological_space.{0} (measurable_space.{0} num) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (measurable_space.{0} num)) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_69103 (h0 : ordered_comm_monoid (has_to_string (has_to_string ennreal))) : has_exists_mul_of_le (has_to_string (has_to_string ennreal)) := sorry --non-trivial
lemma new_lemma_69104 (h0 : functor.add_const (topological_space (boolean_algebra.core pos)) name) : @t1_space.{0} (boolean_algebra.core.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (boolean_algebra.core.{0} pos)) name h0)  := sorry --non-trivial
lemma new_lemma_69105 (h0 : group (has_ssubset linarith.comp_source)) : group.fg (has_ssubset linarith.comp_source) := sorry --non-trivial
lemma new_lemma_69106 (h0 : uniform_space (denumerable (has_norm to_additive.value_type))) : complete_space (denumerable (has_norm to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_69107 (h0 : functor.add_const (ordered_comm_monoid (finset linarith.comp)) pos) : @has_exists_mul_of_le.{0} (finset.{0} linarith.comp) (@functor.add_const.run.{0 0} (ordered_comm_monoid.{0} (finset.{0} linarith.comp)) pos h0)  := sorry --non-trivial
lemma new_lemma_69108 (h0 : add_group (ordered_comm_ring (has_add (finset pos)))) : is_add_cyclic (ordered_comm_ring (has_add (finset pos))) := sorry --non-trivial
lemma new_lemma_69109 (h0 : function.extfun Type topological_space) : @totally_separated_space.{0} (has_emptyc.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_emptyc.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_69110 (h0 : function.extfun Type ring) : @is_domain.{0} (canonically_ordered_comm_semiring.{0} ennreal) (@function.extfun_app.{2 1} Type ring.{0} h0 (canonically_ordered_comm_semiring.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_69111 (h0 : functor.add_const (ring (add_comm_monoid linarith.comp)) pos) : @is_principal_ideal_ring.{0} (add_comm_monoid.{0} linarith.comp) (@functor.add_const.run.{0 0} (ring.{0} (add_comm_monoid.{0} linarith.comp)) pos h0)  := sorry --non-trivial
lemma new_lemma_69112 (h1 : not (ring (linear_ordered_add_comm_group char) -> false)) : @rank_condition.{0} (linear_ordered_add_comm_group.{0} char) (@classical.by_contradiction'.{1} (ring.{0} (linear_ordered_add_comm_group.{0} char)) h1)  := sorry --non-trivial
lemma new_lemma_69113 (h0 : has_mem.mem (has_emptyc empty) has_emptyc.emptyc) : @is_cyclic.{0} (has_emptyc.{0} empty) (@finset.pi.empty.{1 0} Type group.{0} (has_emptyc.{0} empty) h0)  := sorry --non-trivial
lemma new_lemma_69114 (h0 : functor.add_const (ring (generalized_boolean_algebra pos)) name) : @is_domain.{0} (generalized_boolean_algebra.{0} pos) (@functor.add_const.run.{0 0} (ring.{0} (generalized_boolean_algebra.{0} pos)) name h0)  := sorry --non-trivial
lemma new_lemma_69115 (h0 : set (add_comm_semigroup (add_comm_semigroup linarith.ineq) -> linarith.ineq)) : set.separates_points h0 := sorry --non-trivial
lemma new_lemma_69116 (h0 : fin has_zero.zero) : @topological_space.separable_space.{0} (normed_lattice_add_comm_group.{0} real) (@function.extfun_app.{2 1} Type topological_space.{0} (@matrix.vec_empty.{1} (function.extfun.{2 1} Type topological_space.{0}) h0) (normed_lattice_add_comm_group.{0} real))  := sorry --non-trivial
lemma new_lemma_69117 (h0 : functor.add_const (topological_space (boolean_algebra.core pos)) pos) : @topological_space.separable_space.{0} (boolean_algebra.core.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (boolean_algebra.core.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_69118 (h0 : has_mem.mem (has_norm to_additive.value_type) has_emptyc.emptyc) : @complete_lattice.is_Sup_finite_compact.{0} (has_norm.{0} to_additive.value_type) (@finset.pi.empty.{1 0} Type complete_lattice.{0} (has_norm.{0} to_additive.value_type) h0)  := sorry --non-trivial
lemma new_lemma_69119 (h0 : functor.add_const (topological_space (has_add environment.implicit_infer_kind)) pos) : @t1_space.{0} (has_add.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (has_add.{0} environment.implicit_infer_kind)) pos h0)  := sorry --non-trivial
lemma new_lemma_69120 (h0 : uniform_space (has_to_string (boolean_algebra pos))) : separated_space (has_to_string (boolean_algebra pos)) := sorry --non-trivial
lemma new_lemma_69121 (h0 : monoid (comm_monoid (semiring empty))) : monoid.fg (comm_monoid (semiring empty)) := sorry --non-trivial
lemma new_lemma_69122 (h0 : not (group (has_emptyc linarith.comp_source) -> false)) : @group.fg.{0} (has_emptyc.{0} linarith.comp_source) (@classical.by_contradiction'.{1} (group.{0} (has_emptyc.{0} linarith.comp_source)) h0)  := sorry --non-trivial
lemma new_lemma_69123 (h0 : function.extfun Type complete_lattice) : @is_atomistic.{0} (has_one.{0} (semiring.{0} congr_arg_kind)) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (has_one.{0} (semiring.{0} congr_arg_kind)))  := sorry --non-trivial
lemma new_lemma_69124 (h0 : ordered_comm_monoid (finset (ordered_ring pos))) : has_exists_mul_of_le (finset (ordered_ring pos)) := sorry --non-trivial
lemma new_lemma_69125 (h0 : topological_space (non_assoc_semiring (semiring congr_arg_kind))) : locally_compact_space (non_assoc_semiring (semiring congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_69126 (h0 : topological_space (finset (boolean_algebra name))) : discrete_topology (finset (boolean_algebra name)) := sorry --non-trivial
lemma new_lemma_69127 (h0 : uniform_space (measurable_space (random_gen congr_arg_kind))) : complete_space (measurable_space (random_gen congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_69128 (h0 : functor.add_const (semiring (boolean_algebra Type)) linarith.comp) : @is_noetherian_ring.{1} (boolean_algebra.{1} Type) (@functor.add_const.run.{1 0} (semiring.{1} (boolean_algebra.{1} Type)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_69129 (h0 : monoid (has_to_string (has_neg (has_pos_part (normed_comm_ring linarith.comp))))) : monoid.fg (has_to_string (has_neg (has_pos_part (normed_comm_ring linarith.comp)))) := sorry --non-trivial
lemma new_lemma_69130 (h0 : functor.add_const (ring (add_cancel_monoid pos)) name) : @rank_condition.{0} (add_cancel_monoid.{0} pos) (@functor.add_const.run.{0 0} (ring.{0} (add_cancel_monoid.{0} pos)) name h0)  := sorry --non-trivial
lemma new_lemma_69131 (h0 : not (complete_lattice (uniform_space (mul_one_class linarith.ineq)) -> false)) : complete_lattice.is_Sup_finite_compact (uniform_space (mul_one_class linarith.ineq)) := sorry --non-trivial
lemma new_lemma_69132 (h1 : group (has_inv string_imp)) : is_cyclic (has_inv string_imp) := sorry --non-trivial
lemma new_lemma_69133 (h0 : functor.add_const (ring (distrib reducibility_hints)) char) : @is_domain.{0} (distrib.{0} reducibility_hints) (@functor.add_const.run.{0 0} (ring.{0} (distrib.{0} reducibility_hints)) char h0)  := sorry --non-trivial
lemma new_lemma_69134 (h0 : topological_space (comm_monoid (option unsigned))) : totally_disconnected_space (comm_monoid (option unsigned)) := sorry --non-trivial
lemma new_lemma_69135 (h0 : complete_lattice (has_compl (random_gen (random_gen fun_info)))) : complete_lattice.is_Sup_finite_compact (has_compl (random_gen (random_gen fun_info))) := sorry --non-trivial
lemma new_lemma_69136 (h0 : cancel_comm_monoid_with_zero (has_to_string (has_add environment.implicit_infer_kind))) : unique_factorization_monoid (has_to_string (has_add environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_69137 (h0 : uniform_space (has_to_string (finset linarith.comp))) : separated_space (has_to_string (finset linarith.comp)) := sorry --non-trivial
lemma new_lemma_69138 (h0 : functor.add_const (function.extfun Type group) pos) : @group.fg.{0} (boolean_algebra.{0} linarith.comp) (@function.extfun_app.{2 1} Type group.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type group.{0}) pos h0) (boolean_algebra.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_69139 (h0 : functor.add_const (topological_space (ring environment.implicit_infer_kind)) real) : @irreducible_space.{0} (ring.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (ring.{0} environment.implicit_infer_kind)) real h0)  := sorry --non-trivial
lemma new_lemma_69140 (h1 : not (topological_space (has_lt string_imp) -> false)) : @totally_disconnected_space.{0} (has_lt.{0} string_imp) (@classical.by_contradiction'.{1} (topological_space.{0} (has_lt.{0} string_imp)) h1)  := sorry --non-trivial
lemma new_lemma_69141 (h0 : functor.add_const (ordered_add_comm_monoid (has_Inf name)) real) : @archimedean.{0} (has_Inf.{0} name) (@functor.add_const.run.{0 0} (ordered_add_comm_monoid.{0} (has_Inf.{0} name)) real h0)  := sorry --non-trivial
lemma new_lemma_69142 (h0 : functor.add_const (topological_space (ring linarith.comp)) (comm_group pos)) : @preconnected_space.{0} (ring.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (ring.{0} linarith.comp)) (comm_group.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_69143 (h0 : ring (semiring (has_norm (random_gen (random_gen linarith.comp_source))))) : rank_condition (semiring (has_norm (random_gen (random_gen linarith.comp_source)))) := sorry --non-trivial
lemma new_lemma_69144 (h0 : ring (has_neg ennreal)) : rank_condition (has_neg ennreal) := sorry --non-trivial
lemma new_lemma_69145 (h0 : topological_space (add_comm_semigroup std_gen)) : t0_space (add_comm_semigroup std_gen) := sorry --non-trivial
lemma new_lemma_69146 (h0 : functor.add_const (topological_space (bin_tree unsigned)) congr_arg_kind) : @normal_space.{0} (bin_tree.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (bin_tree.{0} unsigned)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_69147 (h0 : functor.add_const (group znum) num) : @is_cyclic.{0} znum (@functor.add_const.run.{0 0} (group.{0} znum) num h0)  := sorry --non-trivial
lemma new_lemma_69148 (h0 : ring (canonically_linear_ordered_monoid Type)) : is_domain (canonically_linear_ordered_monoid Type) := sorry --non-trivial
lemma new_lemma_69149 (h0 : group (normed_group (linear_ordered_semiring fun_info))) : group.fg (normed_group (linear_ordered_semiring fun_info)) := sorry --non-trivial
lemma new_lemma_69150 (h0 : ring (complete_distrib_lattice (has_nndist Type))) : strong_rank_condition (complete_distrib_lattice (has_nndist Type)) := sorry --non-trivial
lemma new_lemma_69151 (h0 : functor.add_const (function.extfun (Type 1) cancel_comm_monoid_with_zero) Type) : @unique_factorization_monoid.{1} (semigroup.{1} Type) (@function.extfun_app.{3 2} (Type 1) cancel_comm_monoid_with_zero.{1} (@functor.add_const.run.{2 1} (function.extfun.{3 2} (Type 1) cancel_comm_monoid_with_zero.{1}) Type h0) (semigroup.{1} Type))  := sorry --non-trivial
lemma new_lemma_69152 (h0 : cancel_comm_monoid_with_zero (has_Inf (ring (has_pos_part (has_add pos))))) : unique_factorization_monoid (has_Inf (ring (has_pos_part (has_add pos)))) := sorry --non-trivial
lemma new_lemma_69153 (h0 : uniform_space (non_unital_non_assoc_semiring (mul_one_class string.iterator_imp))) : complete_space (non_unital_non_assoc_semiring (mul_one_class string.iterator_imp)) := sorry --non-trivial
lemma new_lemma_69154 (h0 : group (has_inv (has_nnnorm (random_gen linarith.comp_source)))) : is_cyclic (has_inv (has_nnnorm (random_gen linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_69155 (h0 : group (denumerable fun_info)) : group.fg (denumerable fun_info) := sorry --non-trivial
lemma new_lemma_69156 (h0 : add_group (has_ssubset to_additive.value_type)) (h1 : uniform_space (uniform_space (add_subgroup (has_ssubset to_additive.value_type)))) : complete_space (uniform_space (add_subgroup (has_ssubset to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_69157 (h0 : topological_space (has_emptyc (has_top to_additive.value_type))) : path_connected_space (has_emptyc (has_top to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_69158 (h0 : list (add_comm_monoid (boolean_algebra.core unsigned))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_69159 (h0 : topological_space (has_neg (has_add name))) : sequential_space (has_neg (has_add name)) := sorry --non-trivial
lemma new_lemma_69160 (h0 : topological_space (linear_ordered_field name)) : regular_space (linear_ordered_field name) := sorry --non-trivial
lemma new_lemma_69161 (h0 : fin has_zero.zero) : @add_monoid.fg.{0} (comm_semigroup.{0} pos) (@function.extfun_app.{2 1} Type add_monoid.{0} (@matrix.vec_empty.{1} (function.extfun.{2 1} Type add_monoid.{0}) (@matrix.vec_empty.{0} (fin (@has_zero.zero.{0} nat nat.has_zero)) (@matrix.vec_empty.{0} (fin (@has_zero.zero.{0} nat nat.has_zero)) (@matrix.vec_empty.{0} (fin (@has_zero.zero.{0} nat nat.has_zero)) (@matrix.vec_empty.{0} (fin (@has_zero.zero.{0} nat nat.has_zero)) h0))))) (comm_semigroup.{0} pos))  := sorry --non-trivial
lemma new_lemma_69162 (h0 : function.extfun Type topological_space) : @topological_space.separable_space.{0} (partial_order.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (partial_order.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_69163 (h0 : group (distrib_lattice fun_info)) : is_cyclic (distrib_lattice fun_info) := sorry --non-trivial
lemma new_lemma_69164 (h0 : has_mem.mem (distrib linarith.ineq) has_emptyc.emptyc) : @rank_condition.{0} (distrib.{0} linarith.ineq) (@finset.pi.empty.{1 0} Type ring.{0} (distrib.{0} linarith.ineq) h0)  := sorry --non-trivial
lemma new_lemma_69165 (h0 : topological_space (filter (add_left_cancel_semigroup congr_arg_kind))) : irreducible_space (filter (add_left_cancel_semigroup congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_69166 (h0 : complete_lattice (generalized_boolean_algebra (ring (has_add pos)))) : complete_lattice.is_Sup_finite_compact (generalized_boolean_algebra (ring (has_add pos))) := sorry --non-trivial
lemma new_lemma_69167 (h0 : function.extfun (Type 1) ring) : @strong_rank_condition.{1} (add_comm_monoid.{1} Type) (@function.extfun_app.{3 2} (Type 1) ring.{1} h0 (add_comm_monoid.{1} Type))  := sorry --non-trivial
lemma new_lemma_69168 (h0 : topological_space (has_top (semiring (semiring linarith.comp)))) : normal_space (has_top (semiring (semiring linarith.comp))) := sorry --non-trivial
lemma new_lemma_69169 (h0 : ordered_comm_monoid (comm_group (finset (add_comm_monoid name)))) : has_exists_mul_of_le (comm_group (finset (add_comm_monoid name))) := sorry --non-trivial
lemma new_lemma_69170 (h0 : topological_space (comm_group Type)) : t1_space (comm_group Type) := sorry --non-trivial
lemma new_lemma_69171 (h0 : monoid (has_inv linarith.ineq)) : monoid.fg (has_inv linarith.ineq) := sorry --non-trivial
lemma new_lemma_69172 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : palindrome (function.extfun_app (function.extfun_app h0 list) (ring linarith.comp)) := sorry --non-trivial
lemma new_lemma_69173 (h0 : not (topological_space (measurable_space empty) -> false)) : @irreducible_space.{0} (measurable_space.{0} empty) (@classical.by_contradiction'.{1} (topological_space.{0} (measurable_space.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_69174 (h0 : topological_space (has_zero (has_add unsigned))) : locally_compact_space (has_zero (has_add unsigned)) := sorry --non-trivial
lemma new_lemma_69175 (h0 : topological_space (semiring unsigned)) : normal_space (semiring unsigned) := sorry --non-trivial
lemma new_lemma_69176 (h0 : ordered_add_comm_monoid (finset (comm_group Type))) : archimedean (finset (comm_group Type)) := sorry --non-trivial
lemma new_lemma_69177 (h0 : not (ring (id congr_arg_kind) -> false)) : @strong_rank_condition.{0} (@id.{2} Type congr_arg_kind) (@classical.by_contradiction'.{1} (ring.{0} (@id.{2} Type congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_69178 (h0 : fin has_zero.zero) : @normalizer_condition.{0} (boolean_algebra.core.{0} pos) (@matrix.vec_empty.{0} (group.{0} (boolean_algebra.core.{0} pos)) h0)  := sorry --non-trivial
lemma new_lemma_69179 (h0 : semiring (has_add (has_Inf (sub_neg_monoid (has_Inf (has_Inf real)))))) : is_noetherian_ring (has_add (has_Inf (sub_neg_monoid (has_Inf (has_Inf real))))) := sorry --non-trivial
lemma new_lemma_69180 (h0 : functor.add_const (list (add_right_cancel_monoid congr_arg_kind)) empty) : palindrome (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_69181 (h0 : ring (has_neg (has_pos_part linarith.comp))) : rank_condition (has_neg (has_pos_part linarith.comp)) := sorry --non-trivial
lemma new_lemma_69182 (h0 : topological_space (pseudo_metric_space congr_arg_kind)) : discrete_topology (pseudo_metric_space congr_arg_kind) := sorry --non-trivial
lemma new_lemma_69183 (h0 : topological_space (linear_order (option empty))) : irreducible_space (linear_order (option empty)) := sorry --non-trivial
lemma new_lemma_69184 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @t0_space.{0} (topological_space.{0} char) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (topological_space.{0} char))  := sorry --non-trivial
lemma new_lemma_69185 (h0 : topological_space (has_norm (comm_ring to_additive.value_type))) : t0_space (has_norm (comm_ring to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_69186 (h0 : functor.add_const (topological_space (add_cancel_monoid ennreal)) (option unsigned)) : @loc_path_connected_space.{0} (add_cancel_monoid.{0} ennreal) (@functor.add_const.run.{0 0} (topological_space.{0} (add_cancel_monoid.{0} ennreal)) (option.{0} unsigned) h0)  := sorry --non-trivial
lemma new_lemma_69187 (h0 : ring (canonically_ordered_comm_semiring (has_add Type))) : is_principal_ideal_ring (canonically_ordered_comm_semiring (has_add Type)) := sorry --non-trivial
lemma new_lemma_69188 (h0 : functor.add_const (complete_lattice (finset pos)) environment.implicit_infer_kind) : @complete_lattice.is_Sup_finite_compact.{0} (finset.{0} pos) (@functor.add_const.run.{0 0} (complete_lattice.{0} (finset.{0} pos)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_69189 (h0 : topological_space (measurable_space (semiring (random_gen congr_arg_kind)))) : t0_space (measurable_space (semiring (random_gen congr_arg_kind))) := sorry --non-trivial
lemma new_lemma_69190 (h0 : not (group (complete_linear_order congr_arg_kind) -> false)) : @normalizer_condition.{0} (complete_linear_order.{0} congr_arg_kind) (@classical.by_contradiction'.{1} (group.{0} (complete_linear_order.{0} congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_69191 (h0 : add_group (boolean_algebra.core (option unsigned))) : is_add_cyclic (boolean_algebra.core (option unsigned)) := sorry --non-trivial
lemma new_lemma_69192 (h0 : functor.add_const (ring (simple_graph linarith.comp)) name) : @rank_condition.{0} (simple_graph.{0} linarith.comp) (@functor.add_const.run.{0 0} (ring.{0} (simple_graph.{0} linarith.comp)) name h0)  := sorry --non-trivial
lemma new_lemma_69193 (h0 : function.extfun (Type 1) finset) : finset.nonempty (function.extfun_app h0 (has_pos_part Type)) := sorry --non-trivial
lemma new_lemma_69194 (h0 : functor.add_const (complete_lattice (boolean_algebra.core ennreal)) num) : @is_atomistic.{0} (boolean_algebra.core.{0} ennreal) (@functor.add_const.run.{0 0} (complete_lattice.{0} (boolean_algebra.core.{0} ennreal)) num h0)  := sorry --non-trivial
lemma new_lemma_69195 (h0 : functor.add_const Prop (simple_graph (option empty))) : functor.add_const.run h0 := sorry --non-trivial
lemma new_lemma_69196 (h0 : function.extfun (Type 1) (functor.comp ring has_add)) : @rank_condition.{1} (has_add.{1} Type) (@functor.comp.run.{1 1 1} ring.{1} has_add.{1} Type (@function.extfun_app.{3 2} (Type 1) (functor.comp.{1 1 1} ring.{1} has_add.{1}) h0 Type))  := sorry --non-trivial
lemma new_lemma_69197 (h0 : functor.add_const (ring (has_to_string name)) linarith.comp) : @rank_condition.{0} (has_to_string.{0} name) (@functor.add_const.run.{0 0} (ring.{0} (has_to_string.{0} name)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_69198 (h0 : functor.add_const (group (ordered_ring congr_arg_kind)) empty) : @normalizer_condition.{0} (ordered_ring.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (group.{0} (ordered_ring.{0} congr_arg_kind)) empty h0)  := sorry --non-trivial
lemma new_lemma_69199 (h0 : topological_space (has_inter congr_arg_kind)) : t0_space (has_inter congr_arg_kind) := sorry --non-trivial
lemma new_lemma_69200 (h0 : functor.add_const (topological_space (simple_graph pos)) Type) : @discrete_topology.{0} (simple_graph.{0} pos) (@functor.add_const.run.{0 1} (topological_space.{0} (simple_graph.{0} pos)) Type h0)  := sorry --non-trivial
lemma new_lemma_69201 (h0 : not (function.extfun Type add_group -> false)) : @is_add_cyclic.{0} (has_top.{0} unsigned) (@function.extfun_app.{2 1} Type add_group.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type add_group.{0}) h0) (has_top.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_69202 (h0 : topological_space (linear_ordered_add_comm_group (has_inv string_imp))) : path_connected_space (linear_ordered_add_comm_group (has_inv string_imp)) := sorry --non-trivial
lemma new_lemma_69203 (h0 : uniform_space (canonically_linear_ordered_monoid (option unsigned))) : complete_space (canonically_linear_ordered_monoid (option unsigned)) := sorry --non-trivial
lemma new_lemma_69204 (h0 : topological_space (add_group (has_top (has_top (semiring congr_arg_kind))))) : topological_space.separable_space (add_group (has_top (has_top (semiring congr_arg_kind)))) := sorry --non-trivial
lemma new_lemma_69205 (h0 : ordered_add_comm_monoid (add_comm_monoid ennreal)) : archimedean (add_comm_monoid ennreal) := sorry --non-trivial
lemma new_lemma_69206 (h0 : monoid (nondiscrete_normed_field environment.projection_info)) (h1 : ring (conj_classes (nondiscrete_normed_field environment.projection_info))) : rank_condition (conj_classes (nondiscrete_normed_field environment.projection_info)) := sorry --non-trivial
lemma new_lemma_69207 (h0 : functor.add_const (topological_space (has_Inf linarith.comp)) pos) : @t1_space.{0} (has_Inf.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (has_Inf.{0} linarith.comp)) pos h0)  := sorry --non-trivial
lemma new_lemma_69208 (h0 : fin has_zero.zero) : @unique_factorization_monoid.{1} (boolean_algebra.{1} Type) (@matrix.vec_empty.{1} (cancel_comm_monoid_with_zero.{1} (boolean_algebra.{1} Type)) (@matrix.vec_empty.{0} (fin (@has_zero.zero.{0} nat nat.has_zero)) h0))  := sorry --non-trivial
lemma new_lemma_69209 (h0 : functor.add_const (ordered_comm_monoid (boolean_algebra.core name)) (ordered_ring name)) : @has_exists_mul_of_le.{0} (boolean_algebra.core.{0} name) (@functor.add_const.run.{0 0} (ordered_comm_monoid.{0} (boolean_algebra.core.{0} name)) (ordered_ring.{0} name) h0)  := sorry --non-trivial
lemma new_lemma_69210 (h0 : has_dist (add_comm_monoid congr_arg_kind) -> has_dist (add_comm_monoid congr_arg_kind) -> Prop) : well_founded h0 := sorry --non-trivial
lemma new_lemma_69211 (h0 : topological_space (canonically_ordered_comm_semiring (normed_comm_ring pos))) : totally_disconnected_space (canonically_ordered_comm_semiring (normed_comm_ring pos)) := sorry --non-trivial
lemma new_lemma_69212 (h0 : functor.add_const (add_group (plift unsigned)) empty) : @is_add_cyclic.{1} (plift.{1} unsigned) (@functor.add_const.run.{1 0} (add_group.{1} (plift.{1} unsigned)) empty h0)  := sorry --non-trivial
lemma new_lemma_69213 (h0 : ring (has_inv to_additive.value_type)) : is_domain (has_inv to_additive.value_type) := sorry --non-trivial
lemma new_lemma_69214 (h0 : functor.add_const (complete_lattice (normed_comm_ring pos)) pos) : @is_compactly_generated.{0} (normed_comm_ring.{0} pos) (@functor.add_const.run.{0 0} (complete_lattice.{0} (normed_comm_ring.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_69215 (h0 : function.extfun Type filter) : countable_Inter_filter (function.extfun_app h0 (add_cancel_monoid pos)) := sorry --non-trivial
lemma new_lemma_69216 (h0 : topological_space (has_Inf linarith.comp)) : regular_space (has_Inf linarith.comp) := sorry --non-trivial
lemma new_lemma_69217 (h0 : functor.add_const (complete_lattice (simple_graph pos)) linarith.comp) : @complete_lattice.is_Sup_finite_compact.{0} (simple_graph.{0} pos) (@functor.add_const.run.{0 0} (complete_lattice.{0} (simple_graph.{0} pos)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_69218 (h0 : topological_space (ordered_ring (semiring empty))) : t1_space (ordered_ring (semiring empty)) := sorry --non-trivial
lemma new_lemma_69219 (h0 : functor.add_const (uniform_space (ordered_comm_monoid name)) pos) : @separated_space.{0} (ordered_comm_monoid.{0} name) (@functor.add_const.run.{0 0} (uniform_space.{0} (ordered_comm_monoid.{0} name)) pos h0)  := sorry --non-trivial
lemma new_lemma_69220 (h0 : functor.add_const (ring (boolean_algebra.core name)) (has_neg pos)) : @is_domain.{0} (boolean_algebra.core.{0} name) (@functor.add_const.run.{0 0} (ring.{0} (boolean_algebra.core.{0} name)) (has_neg.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_69221 (h0 : functor.add_const (topological_space (simple_graph pos)) pos) : @regular_space.{0} (simple_graph.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (simple_graph.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_69222 (h0 : functor.add_const (uniform_space (has_edist empty)) empty) : @separated_space.{0} (has_edist.{0} empty) (@functor.add_const.run.{0 0} (uniform_space.{0} (has_edist.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_69223 (h0 : complete_lattice (canonically_linear_ordered_monoid num)) : complete_lattice.is_Sup_finite_compact (canonically_linear_ordered_monoid num) := sorry --non-trivial
lemma new_lemma_69224 (h0 : ring (add_cancel_monoid (boolean_algebra (finset (has_neg Type))))) : strong_rank_condition (add_cancel_monoid (boolean_algebra (finset (has_neg Type)))) := sorry --non-trivial
lemma new_lemma_69225 (h0 : topological_space (linear_ordered_comm_group pos)) : normal_space (linear_ordered_comm_group pos) := sorry --non-trivial
lemma new_lemma_69226 (h0 : topological_space (normed_group (semiring (semiring unsigned)))) : path_connected_space (normed_group (semiring (semiring unsigned))) := sorry --non-trivial
lemma new_lemma_69227 (h0 : functor.add_const (topological_space (has_Inf Type)) pos) : @loc_path_connected_space.{1} (has_Inf.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (has_Inf.{1} Type)) pos h0)  := sorry --non-trivial
lemma new_lemma_69228 (h0 : topological_space (add_cancel_monoid (has_add (has_add Type)))) : regular_space (add_cancel_monoid (has_add (has_add Type))) := sorry --non-trivial
lemma new_lemma_69229 (h0 : not (uniform_space (has_top num) -> false)) : @complete_space.{0} (has_top.{0} num) (@classical.by_contradiction'.{1} (uniform_space.{0} (has_top.{0} num)) h0)  := sorry --non-trivial
lemma new_lemma_69230 (h0 : function.extfun nat fin) : @locally_compact_space.{0} (ordered_comm_monoid.{0} name) (@matrix.vec_empty.{0} (topological_space.{0} (ordered_comm_monoid.{0} name)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_69231 (h0 : uniform_space (has_emptyc (has_top (has_top (has_top (has_top (has_top (has_top num)))))))) : complete_space (has_emptyc (has_top (has_top (has_top (has_top (has_top (has_top num))))))) := sorry --non-trivial
lemma new_lemma_69232 (h0 : list (cancel_monoid (semigroup name))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_69233 (h0 : ring (has_bot name)) : rank_condition (has_bot name) := sorry --non-trivial
lemma new_lemma_69234 (h0 : monoid (boolean_algebra (semigroup unsigned))) : monoid.fg (boolean_algebra (semigroup unsigned)) := sorry --non-trivial
lemma new_lemma_69235 (h0 : topological_space (normed_linear_ordered_group (semiring unsigned))) : t1_space (normed_linear_ordered_group (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_69236 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @totally_separated_space.{0} (denumerable.{0} linarith.ineq) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (denumerable.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_69237 (h0 : topological_space (complete_linear_order empty)) : normal_space (complete_linear_order empty) := sorry --non-trivial
lemma new_lemma_69238 (h0 : topological_space (semigroup (finset (finset (finset (has_pos_part pos)))))) : loc_path_connected_space (semigroup (finset (finset (finset (has_pos_part pos))))) := sorry --non-trivial
lemma new_lemma_69239 (h0 : topological_space (ordered_comm_ring (has_add name))) : sequential_space (ordered_comm_ring (has_add name)) := sorry --non-trivial
lemma new_lemma_69240 (h0 : topological_space (add_cancel_monoid empty)) : discrete_topology (add_cancel_monoid empty) := sorry --non-trivial
lemma new_lemma_69241 (h0 : function.extfun Type group) : @group.fg.{0} (ordered_comm_group.{0} ennreal) (@function.extfun_app.{2 1} Type group.{0} h0 (ordered_comm_group.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_69242 (h0 : functor.add_const (ring (has_neg pos)) environment.implicit_infer_kind) : @is_principal_ideal_ring.{0} (has_neg.{0} pos) (@functor.add_const.run.{0 0} (ring.{0} (has_neg.{0} pos)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_69243 (h0 : functor.add_const (complete_lattice (has_neg environment.implicit_infer_kind)) linarith.comp) : @is_compactly_generated.{0} (has_neg.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (complete_lattice.{0} (has_neg.{0} environment.implicit_infer_kind)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_69244 (h5 : set (string.iterator_imp -> add_comm_semigroup (add_comm_semigroup char))) : set.separates_points h5 := sorry --non-trivial
lemma new_lemma_69245 (h0 : function.extfun Type multiset) : @multiset.sup.{0} Prop (@lattice.to_semilattice_sup.{0} Prop (@conditionally_complete_lattice.to_lattice.{0} Prop (@complete_lattice.to_conditionally_complete_lattice.{0} Prop Prop.complete_lattice))) (@generalized_boolean_algebra.to_order_bot.{0} Prop (@boolean_algebra.to_generalized_boolean_algebra.{0} Prop Prop.boolean_algebra)) (@function.extfun_app.{2 1} Type multiset.{0} h0 Prop)  := sorry --non-trivial
lemma new_lemma_69246 (h0 : functor.add_const (ring (has_neg environment.implicit_infer_kind)) pos) : @is_principal_ideal_ring.{0} (has_neg.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (ring.{0} (has_neg.{0} environment.implicit_infer_kind)) pos h0)  := sorry --non-trivial
lemma new_lemma_69247 (h1 : monoid (has_emptyc (has_norm fun_info))) : monoid.fg (has_emptyc (has_norm fun_info)) := sorry --non-trivial
lemma new_lemma_69248 (h0 : topological_space (comm_ring (linear_ordered_add_comm_group linarith.comp_source))) : totally_disconnected_space (comm_ring (linear_ordered_add_comm_group linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_69249 (h0 : complete_lattice (ordered_comm_ring (has_Inf real))) : is_atomistic (ordered_comm_ring (has_Inf real)) := sorry --non-trivial
lemma new_lemma_69250 (h1 : topological_space enat) : path_connected_space enat := sorry --non-trivial
lemma new_lemma_69251 (h0 : ring (ring (ring pos))) : is_principal_ideal_ring (ring (ring pos)) := sorry --non-trivial
lemma new_lemma_69252 (h0 : function.extfun Type (functor.comp complete_lattice add_cancel_monoid)) : @is_atomistic.{0} (add_cancel_monoid.{0} name) (@functor.comp.run.{0 0 0} complete_lattice.{0} add_cancel_monoid.{0} name (@function.extfun_app.{2 1} Type (functor.comp.{0 0 0} complete_lattice.{0} add_cancel_monoid.{0}) h0 name))  := sorry --non-trivial
lemma new_lemma_69253 (h0 : fin has_zero.zero) : @is_cyclic.{0} (has_Inf.{0} real) (@matrix.vec_empty.{0} (group.{0} (has_Inf.{0} real)) (@matrix.vec_empty.{0} (fin (@has_zero.zero.{0} nat nat.has_zero)) (@matrix.vec_empty.{0} (fin (@has_zero.zero.{0} nat nat.has_zero)) h0)))  := sorry --non-trivial
lemma new_lemma_69254 (h0 : functor.add_const (function.extfun Type topological_space) (ring (finset Type))) : @totally_separated_space.{0} (add_cancel_monoid.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type topological_space.{0}) (ring.{1} (finset.{1} Type)) h0) (add_cancel_monoid.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_69255 (h0 : topological_space (comm_semigroup (has_pos_part real))) : loc_path_connected_space (comm_semigroup (has_pos_part real)) := sorry --non-trivial
lemma new_lemma_69256 (h0 : topological_space (has_zero (has_Inf (has_pos_part (has_pos_part Type))))) : preconnected_space (has_zero (has_Inf (has_pos_part (has_pos_part Type)))) := sorry --non-trivial
lemma new_lemma_69257 (h0 : not (group (random_gen fun_info) -> false)) : @is_cyclic.{0} (random_gen.{0} fun_info) (@classical.by_contradiction'.{1} (group.{0} (random_gen.{0} fun_info)) h0)  := sorry --non-trivial
lemma new_lemma_69258 (h0 : topological_space (mul_zero_class (has_neg name))) : topological_space.separable_space (mul_zero_class (has_neg name)) := sorry --non-trivial
lemma new_lemma_69259 (h0 : not (ring (simple_graph char) -> false)) : @strong_rank_condition.{0} (simple_graph.{0} char) (@classical.by_contradiction'.{1} (ring.{0} (simple_graph.{0} char)) h0)  := sorry --non-trivial
lemma new_lemma_69260 (h0 : ring (has_norm (random_gen linarith.ineq))) : is_domain (has_norm (random_gen linarith.ineq)) := sorry --non-trivial
lemma new_lemma_69261 (h0 : functor.add_const (function.extfun (Type 1) ring) linarith.comp) : @strong_rank_condition.{1} (has_nndist.{1} Type) (@function.extfun_app.{3 2} (Type 1) ring.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) ring.{1}) linarith.comp h0) (has_nndist.{1} Type))  := sorry --non-trivial
lemma new_lemma_69262 (h0 : functor.add_const (topological_space (option num)) empty) : @t1_space.{0} (option.{0} num) (@functor.add_const.run.{0 0} (topological_space.{0} (option.{0} num)) empty h0)  := sorry --non-trivial
lemma new_lemma_69263 (h0 : topological_space (has_one (semiring (semiring congr_arg_kind)))) : totally_separated_space (has_one (semiring (semiring congr_arg_kind))) := sorry --non-trivial
lemma new_lemma_69264 (h0 : list (canonically_ordered_comm_semiring (has_add (has_nndist ennreal)))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_69265 (h10 : complete_lattice (semi_normed_ring linarith.ineq)) : is_compactly_generated (semi_normed_ring linarith.ineq) := sorry --non-trivial
lemma new_lemma_69266 (h0 : function.extfun nat fin) : @is_compactly_generated.{1} (generalized_boolean_algebra.{1} Type) (@matrix.vec_empty.{1} (complete_lattice.{1} (generalized_boolean_algebra.{1} Type)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_69267 (h0 : uniform_space (measurable_space.dynkin_system (has_norm (has_top (semiring (has_top empty)))))) : complete_space (measurable_space.dynkin_system (has_norm (has_top (semiring (has_top empty))))) := sorry --non-trivial
lemma new_lemma_69268 (h0 : topological_space (add_comm_monoid (option (option (option empty))))) : normal_space (add_comm_monoid (option (option (option empty)))) := sorry --non-trivial
lemma new_lemma_69269 (h0 : not (topological_space (has_append fun_info) -> false)) : @t0_space.{0} (has_append.{0} fun_info) (@classical.by_contradiction'.{1} (topological_space.{0} (has_append.{0} fun_info)) h0)  := sorry --non-trivial
lemma new_lemma_69270 (h1 : topological_space (non_unital_non_assoc_semiring to_additive.value_type)) : t0_space (non_unital_non_assoc_semiring to_additive.value_type) := sorry --non-trivial
lemma new_lemma_69271 (h0 : not (ring (has_add fun_info) -> false)) : @strong_rank_condition.{0} (has_add.{0} fun_info) (@classical.by_contradiction'.{1} (ring.{0} (has_add.{0} fun_info)) h0)  := sorry --non-trivial
lemma new_lemma_69272 (h0 : functor.add_const (group (has_add Type)) name) : @is_simple_group.{1} (has_add.{1} Type) (@functor.add_const.run.{1 0} (group.{1} (has_add.{1} Type)) name h0)  := sorry --non-trivial
lemma new_lemma_69273 (h0 : function.extfun Type topological_space) : @locally_compact_space.{0} (filter.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (filter.{0} num))  := sorry --non-trivial
lemma new_lemma_69274 (h0 : complete_lattice (add_group (semiring empty))) : is_compactly_generated (add_group (semiring empty)) := sorry --non-trivial
lemma new_lemma_69275 (h0 : ordered_comm_monoid (normed_comm_ring (has_neg Type))) : has_exists_mul_of_le (normed_comm_ring (has_neg Type)) := sorry --non-trivial
lemma new_lemma_69276 (h0 : functor.add_const (ring (finset pos)) Type) : @strong_rank_condition.{0} (finset.{0} pos) (@functor.add_const.run.{0 1} (ring.{0} (finset.{0} pos)) Type h0)  := sorry --non-trivial
lemma new_lemma_69277 (h0 : fin has_zero.zero) : @is_cyclic.{1} Type (@function.extfun_app.{3 2} (Type 1) group.{1} (@matrix.vec_empty.{2} (function.extfun.{3 2} (Type 1) group.{1}) h0) Type)  := sorry --non-trivial
lemma new_lemma_69278 (h0 : topological_space (complete_distrib_lattice (finset (has_Inf (ring (ring Type)))))) : sequential_space (complete_distrib_lattice (finset (has_Inf (ring (ring Type))))) := sorry --non-trivial
lemma new_lemma_69279 (h0 : add_group (simple_graph (has_pos_part (ring (has_to_string (has_pos_part Type)))))) : is_add_cyclic (simple_graph (has_pos_part (ring (has_to_string (has_pos_part Type))))) := sorry --non-trivial
lemma new_lemma_69280 (h0 : topological_space (semigroup (has_pos_part environment.implicit_infer_kind))) : preirreducible_space (semigroup (has_pos_part environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_69281 (h0 : function.extfun Type topological_space) : @t0_space.{0} (cancel_monoid.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (cancel_monoid.{0} name))  := sorry --non-trivial
lemma new_lemma_69282 (h0 : uniform_space (complete_distrib_lattice (has_add unsigned))) : complete_space (complete_distrib_lattice (has_add unsigned)) := sorry --non-trivial
lemma new_lemma_69283 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @complete_lattice.is_Sup_finite_compact.{0} (ordered_cancel_add_comm_monoid.{0} num) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (ordered_cancel_add_comm_monoid.{0} num))  := sorry --non-trivial
lemma new_lemma_69284 (h0 : functor.add_const (topological_space (has_to_string name)) Type) : @preirreducible_space.{0} (has_to_string.{0} name) (@functor.add_const.run.{0 1} (topological_space.{0} (has_to_string.{0} name)) Type h0)  := sorry --non-trivial
lemma new_lemma_69285 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_noetherian_ring.{0} (has_Inf.{0} pos) (@function.extfun_app.{2 1} Type semiring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 semiring.{0}) (has_Inf.{0} pos))  := sorry --non-trivial
lemma new_lemma_69286 (h0 : uniform_space (non_assoc_semiring (option unsigned))) : separated_space (non_assoc_semiring (option unsigned)) := sorry --non-trivial
lemma new_lemma_69287 (h0 : topological_space (semiring (has_norm congr_arg_kind))) : t0_space (semiring (has_norm congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_69288 (h0 : topological_space (has_ssubset (has_nnnorm fun_info))) : totally_disconnected_space (has_ssubset (has_nnnorm fun_info)) := sorry --non-trivial
lemma new_lemma_69289 (h0 : not (topological_space (has_emptyc fun_info) -> false)) : @t0_space.{0} (has_emptyc.{0} fun_info) (@classical.by_contradiction'.{1} (topological_space.{0} (has_emptyc.{0} fun_info)) h0)  := sorry --non-trivial
lemma new_lemma_69290 (h0 : topological_space (has_add (has_Inf real))) : path_connected_space (has_add (has_Inf real)) := sorry --non-trivial
lemma new_lemma_69291 (h0 : function.extfun Type ring) : @rank_condition.{0} linarith.ineq (@function.extfun_app.{2 1} Type ring.{0} h0 linarith.ineq)  := sorry --non-trivial
lemma new_lemma_69292 (h0 : topological_space (complete_distrib_lattice (has_Inf (has_Inf (has_pos_part pos))))) : t1_space (complete_distrib_lattice (has_Inf (has_Inf (has_pos_part pos)))) := sorry --non-trivial
lemma new_lemma_69293 (h0 : functor.add_const (function.extfun Type group) Type) : @is_simple_group.{0} (comm_group.{0} linarith.comp) (@function.extfun_app.{2 1} Type group.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type group.{0}) Type h0) (comm_group.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_69294 (h0 : function.extfun Type topological_space) : @regular_space.{0} (finset.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (finset.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_69295 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @loc_path_connected_space.{0} (ordered_comm_monoid.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (ordered_comm_monoid.{0} pos))  := sorry --non-trivial
lemma new_lemma_69296 (h0 : group (has_compl to_additive.value_type)) : group.fg (has_compl to_additive.value_type) := sorry --non-trivial
lemma new_lemma_69297 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @t0_space.{0} znum (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) znum)  := sorry --non-trivial
lemma new_lemma_69298 (h0 : functor.add_const (group (has_add pos)) name) : @is_simple_group.{0} (has_add.{0} pos) (@functor.add_const.run.{0 0} (group.{0} (has_add.{0} pos)) name h0)  := sorry --non-trivial
lemma new_lemma_69299 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @discrete_topology.{0} (has_dist.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_dist.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_69300 (h1 : complete_lattice (has_ssubset (has_nnnorm fun_info))) : is_compactly_generated (has_ssubset (has_nnnorm fun_info)) := sorry --non-trivial
lemma new_lemma_69301 (h0 : not (topological_space (partial_order num) -> false)) : @path_connected_space.{0} (partial_order.{0} num) (@classical.by_contradiction'.{1} (topological_space.{0} (partial_order.{0} num)) h0)  := sorry --non-trivial
lemma new_lemma_69302 (h0 : ring (non_assoc_semiring empty)) : rank_condition (non_assoc_semiring empty) := sorry --non-trivial
lemma new_lemma_69303 (h0 : ring (has_add char)) : is_domain (has_add char) := sorry --non-trivial
lemma new_lemma_69304 (h0 : function.extfun Type ordered_add_comm_monoid) : @archimedean.{0} (bin_tree.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type ordered_add_comm_monoid.{0} h0 (bin_tree.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_69305 (h0 : list (with_one (has_top linarith.comp_source))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_69306 (h0 : function.extfun Type add_monoid) : @add_monoid.fg.{0} (normed_lattice_add_comm_group.{0} pos) (@function.extfun_app.{2 1} Type add_monoid.{0} h0 (normed_lattice_add_comm_group.{0} pos))  := sorry --non-trivial
lemma new_lemma_69307 (h0 : not (uniform_space (distrib string.iterator_imp) -> false)) : @complete_space.{0} (distrib.{0} string.iterator_imp) (@classical.by_contradiction'.{1} (uniform_space.{0} (distrib.{0} string.iterator_imp)) h0)  := sorry --non-trivial
lemma new_lemma_69308 (h0 : functor.add_const (function.extfun Type cancel_comm_monoid_with_zero) pos) : @unique_factorization_monoid.{0} (has_neg.{0} ennreal) (@function.extfun_app.{2 1} Type cancel_comm_monoid_with_zero.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type cancel_comm_monoid_with_zero.{0}) pos h0) (has_neg.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_69309 (h0 : functor.add_const (topological_space (generalized_boolean_algebra Type)) pos) : @sequential_space.{1} (generalized_boolean_algebra.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (generalized_boolean_algebra.{1} Type)) pos h0)  := sorry --non-trivial
lemma new_lemma_69310 (h0 : functor.add_const (topological_space (ring environment.implicit_infer_kind)) Type) : @topological_space.separable_space.{0} (ring.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 1} (topological_space.{0} (ring.{0} environment.implicit_infer_kind)) Type h0)  := sorry --non-trivial
lemma new_lemma_69311 (h1 : add_group (has_nnnorm (has_nnnorm linarith.comp_source))) : is_add_cyclic (has_nnnorm (has_nnnorm linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_69312 (h0 : function.extfun Type topological_space) : @topological_space.separable_space.{0} (simple_graph.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (simple_graph.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_69313 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_cyclic.{0} (has_Inf.{0} pos) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (has_Inf.{0} pos))  := sorry --non-trivial
lemma new_lemma_69314 (h0 : functor.add_const (list (ring Type)) linarith.comp) : palindrome (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_69315 (h0 : ring (has_add (option ennreal))) : is_domain (has_add (option ennreal)) := sorry --non-trivial
lemma new_lemma_69316 (h0 : group (linear_ordered_semiring (random_gen (has_norm congr_arg_kind)))) : normalizer_condition (linear_ordered_semiring (random_gen (has_norm congr_arg_kind))) := sorry --non-trivial
lemma new_lemma_69317 (h0 : functor.add_const (topological_space (has_Inf linarith.comp)) linarith.comp) : @preconnected_space.{0} (has_Inf.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (has_Inf.{0} linarith.comp)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_69318 (h0 : functor.add_const (topological_space (has_to_string Type)) Type) : @topological_space.separable_space.{1} (has_to_string.{1} Type) (@functor.add_const.run.{1 1} (topological_space.{1} (has_to_string.{1} Type)) Type h0)  := sorry --non-trivial
lemma new_lemma_69319 (h0 : function.extfun Type complete_lattice) : @is_atomistic.{0} (with_one.{0} linarith.ineq) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (with_one.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_69320 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_principal_ideal_ring.{0} (boolean_algebra.{0} linarith.comp) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (boolean_algebra.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_69321 (h0 : group (topological_space (comm_ring linarith.ineq))) : is_cyclic (topological_space (comm_ring linarith.ineq)) := sorry --non-trivial
lemma new_lemma_69322 (h0 : add_group (comm_ring (comm_ring fun_info))) : is_add_cyclic (comm_ring (comm_ring fun_info)) := sorry --non-trivial
lemma new_lemma_69323 (h0 : functor.add_const (function.extfun Type uniform_space) linarith.comp) : @separated_space.{0} (has_add.{0} linarith.comp) (@function.extfun_app.{2 1} Type uniform_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type uniform_space.{0}) linarith.comp h0) (has_add.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_69324 (h0 : add_group (comm_semigroup (has_Inf (has_add real)))) : is_add_cyclic (comm_semigroup (has_Inf (has_add real))) := sorry --non-trivial
lemma new_lemma_69325 (h0 : complete_lattice (linear_ordered_semiring (semiring linarith.comp))) : complete_lattice.is_Sup_finite_compact (linear_ordered_semiring (semiring linarith.comp)) := sorry --non-trivial
lemma new_lemma_69326 (h0 : finset (add_comm_monoid (has_neg environment.implicit_infer_kind))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_69327 (h0 : not (topological_space (complete_semilattice_Sup linarith.comp) -> false)) : @t0_space.{0} (complete_semilattice_Sup.{0} linarith.comp) (@classical.by_contradiction'.{1} (topological_space.{0} (complete_semilattice_Sup.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_69328 (h0 : functor.add_const (finset (has_neg linarith.comp)) linarith.comp) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_69329 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : palindrome (function.extfun_app (function.extfun_app h0 list) (has_zero linarith.comp)) := sorry --non-trivial
lemma new_lemma_69330 (h0 : ring (semi_normed_comm_ring enat)) : is_domain (semi_normed_comm_ring enat) := sorry --non-trivial
lemma new_lemma_69331 (h0 : ring (uniform_space string_imp)) : strong_rank_condition (uniform_space string_imp) := sorry --non-trivial
lemma new_lemma_69332 (h1 : not (has_mem.mem (normed_group linarith.comp_source) has_emptyc.emptyc -> false)) : @strong_rank_condition.{0} (normed_group.{0} linarith.comp_source) (@finset.pi.empty.{1 0} Type ring.{0} (normed_group.{0} linarith.comp_source) (@classical.by_contradiction'.{0} (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (normed_group.{0} linarith.comp_source) (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))) h1))  := sorry --non-trivial
lemma new_lemma_69333 (h0 : function.extfun Type topological_space) : @totally_separated_space.{0} (has_star.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_star.{0} num))  := sorry --non-trivial
lemma new_lemma_69334 (h0 : add_monoid (measure_theory.measure_space (has_top (has_top (semiring (has_top num)))))) : add_monoid.fg (measure_theory.measure_space (has_top (has_top (semiring (has_top num))))) := sorry --non-trivial
lemma new_lemma_69335 (h0 : measurable_space (ordered_ring unsigned)) (h1 : measure_theory.measure (ordered_ring unsigned)) : measure_theory.measure.is_complete h1 := sorry --non-trivial
lemma new_lemma_69336 (h0 : functor.add_const (topological_space (comm_group pos)) linarith.comp) : @preconnected_space.{0} (comm_group.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (comm_group.{0} pos)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_69337 (h0 : list (with_bot (with_bot string_imp))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_69338 (h0 : ring (add_cancel_comm_monoid (semiring unsigned))) : strong_rank_condition (add_cancel_comm_monoid (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_69339 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @topological_space.separable_space.{1} (ordered_comm_ring.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 topological_space.{1}) (ordered_comm_ring.{1} Type))  := sorry --non-trivial
lemma new_lemma_69340 (h1 : set (has_compl std_gen)) : set.subsingleton h1 := sorry --non-trivial
lemma new_lemma_69341 (h0 : group (comm_monoid unsigned)) : is_cyclic (comm_monoid unsigned) := sorry --non-trivial
lemma new_lemma_69342 (h0 : group (has_lt linarith.comp_source)) : is_cyclic (has_lt linarith.comp_source) := sorry --non-trivial
lemma new_lemma_69343 (h0 : group (ordered_comm_ring (has_pos_part Type))) : group.fg (ordered_comm_ring (has_pos_part Type)) := sorry --non-trivial
lemma new_lemma_69344 (h0 : functor.add_const (function.extfun nat fin) pos) : @discrete_topology.{1} (normed_lattice_add_comm_group.{1} Type) (@matrix.vec_empty.{1} (topological_space.{1} (normed_lattice_add_comm_group.{1} Type)) (@function.extfun_app.{1 1} nat fin (@functor.add_const.run.{0 0} (function.extfun.{1 1} nat fin) pos h0) (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_69345 (h0 : has_mem.mem topological_space has_emptyc.emptyc) : @totally_separated_space.{0} string_imp (@function.extfun_app.{2 1} Type topological_space.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) topological_space.{0} h0) string_imp)  := sorry --non-trivial
lemma new_lemma_69346 (h0 : topological_space (comm_semigroup (has_Inf (sub_neg_monoid real)))) : loc_path_connected_space (comm_semigroup (has_Inf (sub_neg_monoid real))) := sorry --non-trivial
lemma new_lemma_69347 (h0 : has_mem.mem (has_norm congr_arg_kind) has_emptyc.emptyc) : @is_domain.{0} (has_norm.{0} congr_arg_kind) (@finset.pi.empty.{1 0} Type ring.{0} (has_norm.{0} congr_arg_kind) h0)  := sorry --non-trivial
lemma new_lemma_69348 (h0 : functor.add_const (prod (semigroup empty) (semigroup empty)) (semiring empty)) : id_rel (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_69349 (h0 : functor.add_const (ordered_add_comm_monoid (canonically_ordered_monoid unsigned)) unsigned) : @archimedean.{0} (canonically_ordered_monoid.{0} unsigned) (@functor.add_const.run.{0 0} (ordered_add_comm_monoid.{0} (canonically_ordered_monoid.{0} unsigned)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_69350 (h0 : topological_space (add_comm_semigroup (mul_one_class enat))) (h1 : set (add_comm_semigroup (mul_one_class enat))) : is_path_connected h1 := sorry --non-trivial
lemma new_lemma_69351 (h0 : function.extfun (Type 1) complete_lattice) : @complete_lattice.is_Sup_finite_compact.{1} (has_well_founded.{1} unsigned) (@function.extfun_app.{3 2} (Type 1) complete_lattice.{1} h0 (has_well_founded.{1} unsigned))  := sorry --non-trivial
lemma new_lemma_69352 (h0 : preorder char) (h1 : preorder linarith.ineq) (h2 : char -> linarith.ineq) : antitone h2 := sorry --non-trivial
lemma new_lemma_69353 (h0 : topological_space (canonically_linear_ordered_monoid (option (option (option pos))))) : preconnected_space (canonically_linear_ordered_monoid (option (option (option pos)))) := sorry --non-trivial
lemma new_lemma_69354 (h0 : topological_space (has_nndist name)) : preirreducible_space (has_nndist name) := sorry --non-trivial
lemma new_lemma_69355 (h0 : ring (has_le to_additive.value_type)) : is_domain (has_le to_additive.value_type) := sorry --non-trivial
lemma new_lemma_69356 (h0 : topological_space (uniform_space linarith.ineq)) : path_connected_space (uniform_space linarith.ineq) := sorry --non-trivial
lemma new_lemma_69357 (h0 : topological_space (mul_zero_class num)) : loc_path_connected_space (mul_zero_class num) := sorry --non-trivial
lemma new_lemma_69358 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : list.nodup (function.extfun_app (function.extfun_app h0 list) (has_neg unsigned)) := sorry --non-trivial
lemma new_lemma_69359 (h0 : function.extfun Type ring) : @is_domain.{0} (canonically_linear_ordered_monoid.{0} empty) (@function.extfun_app.{2 1} Type ring.{0} h0 (canonically_linear_ordered_monoid.{0} empty))  := sorry --non-trivial
lemma new_lemma_69360 (h0 : ring (boolean_algebra (has_to_string (has_to_string (has_add (has_neg_part Type)))))) : rank_condition (boolean_algebra (has_to_string (has_to_string (has_add (has_neg_part Type))))) := sorry --non-trivial
lemma new_lemma_69361 (h0 : filter (has_add (has_Inf name))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_69362 (h0 : topological_space (boolean_algebra Type)) : regular_space (boolean_algebra Type) := sorry --non-trivial
lemma new_lemma_69363 (h0 : topological_space (measurable_space (has_norm (has_inv to_additive.value_type)))) : path_connected_space (measurable_space (has_norm (has_inv to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_69364 (h0 : group (has_top (has_nnnorm to_additive.value_type))) : group.fg (has_top (has_nnnorm to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_69365 (h0 : fin has_zero.zero) : @totally_separated_space.{0} (ordered_comm_ring.{0} real) (@matrix.vec_empty.{0} (topological_space.{0} (ordered_comm_ring.{0} real)) h0)  := sorry --non-trivial
lemma new_lemma_69366 (h0 : ring (boolean_algebra.core (option (option (option unsigned))))) : rank_condition (boolean_algebra.core (option (option (option unsigned)))) := sorry --non-trivial
lemma new_lemma_69367 (h0 : fin has_zero.zero) : @complete_lattice.is_Sup_finite_compact.{1} (complete_distrib_lattice.{1} Type) (@matrix.vec_empty.{1} (complete_lattice.{1} (complete_distrib_lattice.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_69368 (h0 : functor.add_const (function.extfun Type topological_space) linarith.comp) : @preconnected_space.{0} (generalized_boolean_algebra.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) linarith.comp h0) (generalized_boolean_algebra.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_69369 (h0 : fin has_zero.zero) : @complete_lattice.is_Sup_finite_compact.{0} (@id.{2} Type (random_gen.{0} fun_info)) (@matrix.vec_empty.{0} (complete_lattice.{0} (@id.{2} Type (random_gen.{0} fun_info))) h0)  := sorry --non-trivial
lemma new_lemma_69370 (h0 : ring (has_bot linarith.comp)) : strong_rank_condition (has_bot linarith.comp) := sorry --non-trivial
lemma new_lemma_69371 (h0 : topological_space (has_add (random_gen (random_gen to_additive.value_type)))) : path_connected_space (has_add (random_gen (random_gen to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_69372 (h0 : functor.add_const (ring (filter empty)) empty) : @rank_condition.{0} (filter.{0} empty) (@functor.add_const.run.{0 0} (ring.{0} (filter.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_69373 (h0 : add_group (has_norm (semiring (has_norm (has_top empty))))) : is_add_cyclic (has_norm (semiring (has_norm (has_top empty)))) := sorry --non-trivial
lemma new_lemma_69374 (h0 : topological_space (finset (add_cancel_monoid Type))) : totally_disconnected_space (finset (add_cancel_monoid Type)) := sorry --non-trivial
lemma new_lemma_69375 (h1 : topological_space (linear_ordered_comm_group_with_zero string.iterator_imp)) (h2 : preorder (linear_ordered_comm_group_with_zero string.iterator_imp)) : order_closed_topology (linear_ordered_comm_group_with_zero string.iterator_imp) := sorry --non-trivial
lemma new_lemma_69376 (h0 : not (function.extfun Type complete_lattice -> false)) : @is_atomistic.{0} (add_group.{0} num) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type complete_lattice.{0}) h0) (add_group.{0} num))  := sorry --non-trivial
lemma new_lemma_69377 (h0 : functor.comp ring add_cancel_monoid pos) : @rank_condition.{0} (add_cancel_monoid.{0} pos) (@functor.comp.run.{0 0 0} ring.{0} add_cancel_monoid.{0} pos h0)  := sorry --non-trivial
lemma new_lemma_69378 (h0 : topological_space (simple_graph (has_pos_part pos))) : topological_space.separable_space (simple_graph (has_pos_part pos)) := sorry --non-trivial
lemma new_lemma_69379 (h0 : topological_space (has_pos_part (ordered_comm_monoid real))) : t0_space (has_pos_part (ordered_comm_monoid real)) := sorry --non-trivial
lemma new_lemma_69380 (h0 : function.extfun (finset Type) (has_mem.mem (has_top fun_info))) : @path_connected_space.{0} (has_top.{0} fun_info) (@finset.pi.empty.{1 0} Type topological_space.{0} (has_top.{0} fun_info) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (has_top.{0} fun_info)) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_69381 (h0 : ordered_comm_monoid (has_add pos)) : has_exists_mul_of_le (has_add pos) := sorry --non-trivial
lemma new_lemma_69382 (h0 : functor.add_const (topological_space (has_Inf pos)) (add_cancel_monoid name)) : @preconnected_space.{0} (has_Inf.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (has_Inf.{0} pos)) (add_cancel_monoid.{0} name) h0)  := sorry --non-trivial
lemma new_lemma_69383 (h0 : topological_space (nondiscrete_normed_field char)) (h1 : set (nondiscrete_normed_field char)) : is_preirreducible h1 := sorry --non-trivial
lemma new_lemma_69384 (h0 : group (has_norm (has_norm fun_info))) : is_cyclic (has_norm (has_norm fun_info)) := sorry --non-trivial
lemma new_lemma_69385 (h0 : topological_space (semigroup (has_to_string (has_to_string unsigned)))) : regular_space (semigroup (has_to_string (has_to_string unsigned))) := sorry --non-trivial
lemma new_lemma_69386 (h0 : function.extfun Type topological_space) : @t0_space.{0} (complete_semilattice_Sup.{0} string_imp) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (complete_semilattice_Sup.{0} string_imp))  := sorry --non-trivial
lemma new_lemma_69387 (h0 : ring (boolean_algebra (finset environment.implicit_infer_kind))) : is_domain (boolean_algebra (finset environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_69388 (h0 : functor.add_const (topological_space (has_inter empty)) unsigned) : @t1_space.{0} (has_inter.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (has_inter.{0} empty)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_69389 (h0 : functor.add_const (topological_space (add_cancel_monoid Type)) Type) : @preconnected_space.{1} (add_cancel_monoid.{1} Type) (@functor.add_const.run.{1 1} (topological_space.{1} (add_cancel_monoid.{1} Type)) Type h0)  := sorry --non-trivial
lemma new_lemma_69390 (h0 : ring (has_append linarith.ineq)) : rank_condition (has_append linarith.ineq) := sorry --non-trivial
lemma new_lemma_69391 (h0 : fin has_zero.zero) : @irreducible_space.{1} (simple_graph.{1} Type) (@matrix.vec_empty.{1} (topological_space.{1} (simple_graph.{1} Type)) (@function.extfun_app.{1 1} nat fin (@matrix.vec_empty.{0} (function.extfun.{1 1} nat fin) h0) (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_69392 (h2 : ring (has_append char)) : strong_rank_condition (has_append char) := sorry --non-trivial
lemma new_lemma_69393 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @preconnected_space.{0} (linear_ordered_comm_group.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (linear_ordered_comm_group.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_69394 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_compactly_generated.{0} (normed_linear_ordered_group.{0} empty) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (normed_linear_ordered_group.{0} empty))  := sorry --non-trivial
lemma new_lemma_69395 (h0 : not (complete_lattice (complete_semilattice_Sup congr_arg_kind) -> false)) : @is_atomistic.{0} (complete_semilattice_Sup.{0} congr_arg_kind) (@classical.by_contradiction'.{1} (complete_lattice.{0} (complete_semilattice_Sup.{0} congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_69396 (h0 : fin has_zero.zero) : @group.fg.{0} (has_pos_part.{0} linarith.comp) (@matrix.vec_empty.{0} (group.{0} (has_pos_part.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_69397 (h0 : topological_space (option (semiring empty))) : totally_disconnected_space (option (semiring empty)) := sorry --non-trivial
lemma new_lemma_69398 (h0 : group (id (random_gen (random_gen string_imp)))) : group.fg (id (random_gen (random_gen string_imp))) := sorry --non-trivial
lemma new_lemma_69399 (h0 : fin has_zero.zero) : @archimedean.{0} (comm_semigroup.{0} pos) (@matrix.vec_empty.{0} (ordered_add_comm_monoid.{0} (comm_semigroup.{0} pos)) (@matrix.vec_empty.{0} (fin (@has_zero.zero.{0} nat nat.has_zero)) h0))  := sorry --non-trivial
lemma new_lemma_69400 (h0 : ordered_add_comm_monoid (has_nndist (has_to_string linarith.comp))) : archimedean (has_nndist (has_to_string linarith.comp)) := sorry --non-trivial
lemma new_lemma_69401 (h0 : monoid (non_assoc_semiring empty)) : monoid.fg (non_assoc_semiring empty) := sorry --non-trivial
lemma new_lemma_69402 (h0 : topological_space (normed_comm_ring num)) : totally_separated_space (normed_comm_ring num) := sorry --non-trivial
lemma new_lemma_69403 (h0 : functor.add_const (topological_space (boolean_algebra pos)) name) : @locally_compact_space.{0} (boolean_algebra.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (boolean_algebra.{0} pos)) name h0)  := sorry --non-trivial
lemma new_lemma_69404 (h0 : topological_space (canonically_ordered_add_monoid congr_arg_kind)) : discrete_topology (canonically_ordered_add_monoid congr_arg_kind) := sorry --non-trivial
lemma new_lemma_69405 (h0 : functor.add_const (ring (add_cancel_monoid unsigned)) Type) : @is_principal_ideal_ring.{0} (add_cancel_monoid.{0} unsigned) (@functor.add_const.run.{0 1} (ring.{0} (add_cancel_monoid.{0} unsigned)) Type h0)  := sorry --non-trivial
lemma new_lemma_69406 (h0 : function.extfun Type list) : list.nodup (function.extfun_app h0 (topological_space to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_69407 (h0 : functor.add_const (topological_space (add_group num)) congr_arg_kind) : @irreducible_space.{0} (add_group.{0} num) (@functor.add_const.run.{0 0} (topological_space.{0} (add_group.{0} num)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_69408 (h0 : function.extfun Type (functor.comp cancel_comm_monoid_with_zero finset)) : @unique_factorization_monoid.{0} (finset.{0} pos) (@functor.comp.run.{0 0 0} cancel_comm_monoid_with_zero.{0} finset.{0} pos (@function.extfun_app.{2 1} Type (functor.comp.{0 0 0} cancel_comm_monoid_with_zero.{0} finset.{0}) h0 pos))  := sorry --non-trivial
lemma new_lemma_69409 (h0 : function.extfun Type topological_space) : @totally_disconnected_space.{0} (has_neg.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_neg.{0} empty))  := sorry --non-trivial
lemma new_lemma_69410 (h0 : not (group (id empty) -> false)) : @is_cyclic.{0} (@id.{2} Type empty) (@classical.by_contradiction'.{1} (group.{0} (@id.{2} Type empty)) h0)  := sorry --non-trivial
lemma new_lemma_69411 (h0 : functor.add_const (semiring (ordered_comm_monoid linarith.comp)) Type) : @is_noetherian_ring.{0} (ordered_comm_monoid.{0} linarith.comp) (@functor.add_const.run.{0 1} (semiring.{0} (ordered_comm_monoid.{0} linarith.comp)) Type h0)  := sorry --non-trivial
lemma new_lemma_69412 (h0 : ring (has_to_string (has_neg linarith.comp))) : is_domain (has_to_string (has_neg linarith.comp)) := sorry --non-trivial
lemma new_lemma_69413 (h0 : add_monoid (monoid_with_zero (option pos))) : add_monoid.fg (monoid_with_zero (option pos)) := sorry --non-trivial
lemma new_lemma_69414 (h0 : topological_space (boolean_algebra (has_neg_part pos))) : locally_compact_space (boolean_algebra (has_neg_part pos)) := sorry --non-trivial
lemma new_lemma_69415 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_domain.{0} (denumerable.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (denumerable.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_69416 (h0 : ring (div_inv_monoid (denumerable fun_info))) : strong_rank_condition (div_inv_monoid (denumerable fun_info)) := sorry --non-trivial
lemma new_lemma_69417 (h0 : function.extfun Type (functor.comp uniform_space cancel_monoid)) : @complete_space.{0} (cancel_monoid.{0} name) (@functor.comp.run.{0 0 0} uniform_space.{0} cancel_monoid.{0} name (@function.extfun_app.{2 1} Type (functor.comp.{0 0 0} uniform_space.{0} cancel_monoid.{0}) h0 name))  := sorry --non-trivial
lemma new_lemma_69418 (h0 : topological_space (ring (ring (complete_distrib_lattice name)))) : totally_separated_space (ring (ring (complete_distrib_lattice name))) := sorry --non-trivial
lemma new_lemma_69419 (h0 : functor.add_const (complete_lattice (semiring num)) empty) : @is_atomistic.{0} (semiring.{0} num) (@functor.add_const.run.{0 0} (complete_lattice.{0} (semiring.{0} num)) empty h0)  := sorry --non-trivial
lemma new_lemma_69420 (h0 : functor.add_const (functor.add_const (ordered_comm_monoid Type) linarith.comp) (has_pos_part linarith.comp)) : @has_exists_mul_of_le.{1} Type (@functor.add_const.run.{1 0} (ordered_comm_monoid.{1} Type) linarith.comp (@functor.add_const.run.{1 0} (functor.add_const.{1 0} (ordered_comm_monoid.{1} Type) linarith.comp) (has_pos_part.{0} linarith.comp) h0))  := sorry --non-trivial
lemma new_lemma_69421 (h0 : not (ring (has_nnnorm fun_info) -> false)) : @strong_rank_condition.{0} (has_nnnorm.{0} fun_info) (@classical.by_contradiction'.{1} (ring.{0} (has_nnnorm.{0} fun_info)) h0)  := sorry --non-trivial
lemma new_lemma_69422 (h0 : function.extfun Type (functor.add_const (topological_space (metric_space unsigned)))) : @locally_compact_space.{0} (metric_space.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (metric_space.{0} unsigned)) num (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (topological_space.{0} (metric_space.{0} unsigned))) h0 num))  := sorry --non-trivial
lemma new_lemma_69423 (h0 : filter (has_emptyc (semiring num))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_69424 (h0 : complete_lattice (has_neg (option ennreal))) : complete_lattice.is_Sup_finite_compact (has_neg (option ennreal)) := sorry --non-trivial
lemma new_lemma_69425 (h0 : set (prod ennreal ennreal)) (h1 : functor.add_const (prod ennreal ennreal) pos) : symmetrize_rel h0 (functor.add_const.run h1) := sorry --non-trivial
lemma new_lemma_69426 (h0 : functor.add_const (function.extfun Type ordered_add_comm_monoid) linarith.comp) : @archimedean.{0} (add_cancel_monoid.{0} linarith.comp) (@function.extfun_app.{2 1} Type ordered_add_comm_monoid.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type ordered_add_comm_monoid.{0}) linarith.comp h0) (add_cancel_monoid.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_69427 (h0 : functor.add_const (function.extfun Type complete_lattice) Type) : @complete_lattice.is_Sup_finite_compact.{0} (add_comm_monoid.{0} pos) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type complete_lattice.{0}) Type h0) (add_comm_monoid.{0} pos))  := sorry --non-trivial
lemma new_lemma_69428 (h3 : ring (random_gen string_imp)) : rank_condition (random_gen string_imp) := sorry --non-trivial
lemma new_lemma_69429 (h0 : functor.add_const (group (monoid empty)) unsigned) : @is_cyclic.{0} (monoid.{0} empty) (@functor.add_const.run.{0 0} (group.{0} (monoid.{0} empty)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_69430 (h0 : topological_space (distrib (mul_one_class linarith.ineq))) : path_connected_space (distrib (mul_one_class linarith.ineq)) := sorry --non-trivial
lemma new_lemma_69431 (h0 : not (function.extfun Type uniform_space -> false)) : @separated_space.{0} (measurable_space.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type uniform_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type uniform_space.{0}) h0) (measurable_space.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_69432 (h0 : topological_space (has_neg (has_pos_part (finset pos)))) : normal_space (has_neg (has_pos_part (finset pos))) := sorry --non-trivial
lemma new_lemma_69433 (h0 : ring (comm_group Type)) : is_domain (comm_group Type) := sorry --non-trivial
lemma new_lemma_69434 (h0 : has_mem.mem (has_inv linarith.comp_source) has_emptyc.emptyc) : @totally_disconnected_space.{0} (has_inv.{0} linarith.comp_source) (@finset.pi.empty.{1 0} Type topological_space.{0} (has_inv.{0} linarith.comp_source) h0)  := sorry --non-trivial
lemma new_lemma_69435 (h1 : ring (distrib (random_gen (random_gen (comm_ring fun_info))))) : rank_condition (distrib (random_gen (random_gen (comm_ring fun_info)))) := sorry --non-trivial
lemma new_lemma_69436 (h0 : topological_space (has_dist (option (option empty)))) : locally_compact_space (has_dist (option (option empty))) := sorry --non-trivial
lemma new_lemma_69437 (h0 : ordered_comm_monoid (add_comm_monoid (boolean_algebra name))) : has_exists_mul_of_le (add_comm_monoid (boolean_algebra name)) := sorry --non-trivial
lemma new_lemma_69438 (h0 : function.extfun Type (functor.add_const (group (omega_complete_partial_order unsigned)))) : @is_cyclic.{0} (omega_complete_partial_order.{0} unsigned) (@functor.add_const.run.{0 0} (group.{0} (omega_complete_partial_order.{0} unsigned)) unsigned (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (group.{0} (omega_complete_partial_order.{0} unsigned))) h0 unsigned))  := sorry --non-trivial
lemma new_lemma_69439 (h0 : complete_lattice (monoid (option pos))) : is_compactly_generated (monoid (option pos)) := sorry --non-trivial
lemma new_lemma_69440 (h0 : ring (has_top (has_top congr_arg_kind))) : strong_rank_condition (has_top (has_top congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_69441 (h0 : functor.add_const (semiring (option num)) empty) : @is_noetherian_ring.{0} (option.{0} num) (@functor.add_const.run.{0 0} (semiring.{0} (option.{0} num)) empty h0)  := sorry --non-trivial
lemma new_lemma_69442 (h0 : functor.add_const (add_group (boolean_algebra.core name)) name) : @is_add_cyclic.{0} (boolean_algebra.core.{0} name) (@functor.add_const.run.{0 0} (add_group.{0} (boolean_algebra.core.{0} name)) name h0)  := sorry --non-trivial
lemma new_lemma_69443 (h0 : topological_space (random_gen (has_nnnorm fun_info))) : locally_compact_space (random_gen (has_nnnorm fun_info)) := sorry --non-trivial
lemma new_lemma_69444 (h0 : functor.add_const (functor.comp topological_space canonically_ordered_comm_semiring name) pos) : @loc_path_connected_space.{0} (canonically_ordered_comm_semiring.{0} name) (@functor.comp.run.{0 0 0} topological_space.{0} canonically_ordered_comm_semiring.{0} name (@functor.add_const.run.{0 0} (functor.comp.{0 0 0} topological_space.{0} canonically_ordered_comm_semiring.{0} name) pos h0))  := sorry --non-trivial
lemma new_lemma_69445 (h2 : preorder (add_comm_semigroup string.iterator_imp)) (h3 : set (add_comm_semigroup string.iterator_imp)) : set.is_pwo h3 := sorry --non-trivial
lemma new_lemma_69446 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @separated_space.{0} (add_cancel_monoid.{0} linarith.comp) (@function.extfun_app.{2 1} Type uniform_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 uniform_space.{0}) (add_cancel_monoid.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_69447 (h0 : add_group (has_inv char)) : is_add_cyclic (has_inv char) := sorry --non-trivial
lemma new_lemma_69448 (h0 : topological_space (has_pos_part Type)) : preconnected_space (has_pos_part Type) := sorry --non-trivial
lemma new_lemma_69449 (h0 : topological_space (has_neg_part (has_add (finset (finset (finset (finset pos))))))) : totally_disconnected_space (has_neg_part (has_add (finset (finset (finset (finset pos)))))) := sorry --non-trivial
lemma new_lemma_69450 (h0 : topological_space (semiring (has_top (has_top congr_arg_kind)))) : totally_disconnected_space (semiring (has_top (has_top congr_arg_kind))) := sorry --non-trivial
lemma new_lemma_69451 (h0 : add_group (add_comm_monoid environment.implicit_infer_kind)) : is_add_cyclic (add_comm_monoid environment.implicit_infer_kind) := sorry --non-trivial
lemma new_lemma_69452 (h0 : function.extfun Type ring) : @is_principal_ideal_ring.{0} (has_top.{0} num) (@function.extfun_app.{2 1} Type ring.{0} h0 (has_top.{0} num))  := sorry --non-trivial
lemma new_lemma_69453 (h1 : ring (has_append linarith.comp_source)) : is_domain (has_append linarith.comp_source) := sorry --non-trivial
lemma new_lemma_69454 (h1 : ring (has_append (add_monoid (ordered_cancel_comm_monoid to_additive.value_type)))) : strong_rank_condition (has_append (add_monoid (ordered_cancel_comm_monoid to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_69455 (h0 : topological_space (has_one num)) : normal_space (has_one num) := sorry --non-trivial
lemma new_lemma_69456 (h1 : preorder string.iterator_imp) (h2 : has_lt (nondiscrete_normed_field (omega_complete_partial_order.chain string.iterator_imp))) : no_max_order (nondiscrete_normed_field (omega_complete_partial_order.chain string.iterator_imp)) := sorry --non-trivial
lemma new_lemma_69457 (h0 : ordered_add_comm_monoid (normed_lattice_add_comm_group (has_Inf Type))) : archimedean (normed_lattice_add_comm_group (has_Inf Type)) := sorry --non-trivial
lemma new_lemma_69458 (h3 : preorder char) (h4 : set char) : set.is_pwo h4 := sorry --non-trivial
lemma new_lemma_69459 (h0 : function.extfun Type semiring) : @is_noetherian_ring.{0} (has_to_string.{0} (option.{0} (option.{0} ennreal))) (@function.extfun_app.{2 1} Type semiring.{0} h0 (has_to_string.{0} (option.{0} (option.{0} ennreal))))  := sorry --non-trivial
lemma new_lemma_69460 (h0 : ring (ordered_comm_ring (ring Type))) : is_principal_ideal_ring (ordered_comm_ring (ring Type)) := sorry --non-trivial
lemma new_lemma_69461 (h0 : filter (has_add (option unsigned))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_69462 (h0 : topological_space (topological_space (has_inv linarith.ineq))) : totally_disconnected_space (topological_space (has_inv linarith.ineq)) := sorry --non-trivial
lemma new_lemma_69463 (h0 : topological_space (has_norm (has_inv (has_inv (has_inv (has_inv linarith.comp_source)))))) : irreducible_space (has_norm (has_inv (has_inv (has_inv (has_inv linarith.comp_source))))) := sorry --non-trivial
lemma new_lemma_69464 (h0 : topological_space (has_to_string unsigned)) : regular_space (has_to_string unsigned) := sorry --non-trivial
lemma new_lemma_69465 (h0 : group (semi_normed_comm_ring (random_gen char))) : group.fg (semi_normed_comm_ring (random_gen char)) := sorry --non-trivial
lemma new_lemma_69466 (h0 : list (non_assoc_semiring empty)) : palindrome h0 := sorry --non-trivial
lemma new_lemma_69467 (h0 : list (normed_comm_ring (option unsigned))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_69468 (h0 : linear_ordered_field (monoid pos) -> linear_ordered_field (monoid pos) -> Prop) : is_symm (linear_ordered_field (monoid pos)) h0 := sorry --non-trivial
lemma new_lemma_69469 (h0 : ring (comm_group (has_to_string (has_to_string (comm_group Type))))) : is_domain (comm_group (has_to_string (has_to_string (comm_group Type)))) := sorry --non-trivial
lemma new_lemma_69470 (h0 : ring (has_one (has_norm unsigned))) : rank_condition (has_one (has_norm unsigned)) := sorry --non-trivial
lemma new_lemma_69471 (h0 : topological_space (measurable_space (with_bot (with_bot to_additive.value_type)))) : t0_space (measurable_space (with_bot (with_bot to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_69472 (h0 : ring (has_add (sub_neg_monoid (finset real)))) : rank_condition (has_add (sub_neg_monoid (finset real))) := sorry --non-trivial
lemma new_lemma_69473 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_cyclic.{0} (random_gen.{0} char) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (random_gen.{0} char))  := sorry --non-trivial
lemma new_lemma_69474 (h0 : list (denumerable (with_one to_additive.value_type))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_69475 (h0 : functor.add_const (topological_space (complete_distrib_lattice unsigned)) empty) : @irreducible_space.{0} (complete_distrib_lattice.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (complete_distrib_lattice.{0} unsigned)) empty h0)  := sorry --non-trivial
lemma new_lemma_69476 (h1 : uniform_space (distrib (comm_ring (comm_ring char)))) : complete_space (distrib (comm_ring (comm_ring char))) := sorry --non-trivial
lemma new_lemma_69477 (h0 : functor.add_const (filter (semigroup name)) (has_to_string (ring linarith.comp))) : filter.ne_bot (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_69478 (h0 : filter (has_ssubset char)) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_69479 (h0 : functor.add_const (topological_space (semigroup unsigned)) pos) : @t1_space.{0} (semigroup.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (semigroup.{0} unsigned)) pos h0)  := sorry --non-trivial
lemma new_lemma_69480 (h0 : uniform_space (measurable_space (semiring (semiring empty)))) : complete_space (measurable_space (semiring (semiring empty))) := sorry --non-trivial
lemma new_lemma_69481 (h0 : ring (boolean_algebra (has_neg_part (comm_group unsigned)))) : strong_rank_condition (boolean_algebra (has_neg_part (comm_group unsigned))) := sorry --non-trivial
lemma new_lemma_69482 (h0 : functor.add_const (topological_space (has_add linarith.comp)) (has_zero Type)) : @t0_space.{0} (has_add.{0} linarith.comp) (@functor.add_const.run.{0 1} (topological_space.{0} (has_add.{0} linarith.comp)) (has_zero.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_69483 (h4 : uniform_space (semi_normed_ring string_imp)) : complete_space (semi_normed_ring string_imp) := sorry --non-trivial
lemma new_lemma_69484 (h0 : functor.add_const (topological_space (comm_group linarith.comp)) environment.implicit_infer_kind) : @sequential_space.{0} (comm_group.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (comm_group.{0} linarith.comp)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_69485 (h0 : uniform_space (sub_neg_monoid (sub_neg_monoid (has_Inf Type)))) : complete_space (sub_neg_monoid (sub_neg_monoid (has_Inf Type))) := sorry --non-trivial
lemma new_lemma_69486 (h0 : function.extfun nat fin) : @rank_condition.{1} (generalized_boolean_algebra.{1} Type) (@matrix.vec_empty.{1} (ring.{1} (generalized_boolean_algebra.{1} Type)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_69487 (h0 : function.extfun (Type 1) option) (h1 : topological_space (option.get_or_else (function.extfun_app h0 Type) ennreal)) : totally_separated_space (option.get_or_else (function.extfun_app h0 Type) ennreal) := sorry --non-trivial
lemma new_lemma_69488 (h0 : group (finset (finset ennreal))) : group.fg (finset (finset ennreal)) := sorry --non-trivial
lemma new_lemma_69489 (h0 : topological_space (ordered_ring num)) : totally_separated_space (ordered_ring num) := sorry --non-trivial
lemma new_lemma_69490 (h0 : topological_space (has_nndist (has_neg Type))) : t0_space (has_nndist (has_neg Type)) := sorry --non-trivial
lemma new_lemma_69491 (h0 : ring (linear_ordered_add_comm_group num)) : strong_rank_condition (linear_ordered_add_comm_group num) := sorry --non-trivial
lemma new_lemma_69492 (h0 : topological_space (add_cancel_monoid Type)) : discrete_topology (add_cancel_monoid Type) := sorry --non-trivial
lemma new_lemma_69493 (h0 : uniform_space (add_cancel_monoid (has_neg_part linarith.comp))) : separated_space (add_cancel_monoid (has_neg_part linarith.comp)) := sorry --non-trivial
lemma new_lemma_69494 (h0 : ring (denumerable (random_gen char))) : rank_condition (denumerable (random_gen char)) := sorry --non-trivial
lemma new_lemma_69495 (h0 : topological_space (has_to_string (ring pos))) : totally_separated_space (has_to_string (ring pos)) := sorry --non-trivial
lemma new_lemma_69496 (h0 : measurable_space (non_unital_non_assoc_semiring linarith.ineq)) (h1 : filter (non_unital_non_assoc_semiring linarith.ineq)) : filter.is_measurably_generated h1 := sorry --non-trivial
lemma new_lemma_69497 (h0 : topological_space (ordered_comm_ring (ring linarith.comp))) : totally_disconnected_space (ordered_comm_ring (ring linarith.comp)) := sorry --non-trivial
lemma new_lemma_69498 (h0 : list (partial_order unsigned)) (h1 : option (list (partial_order unsigned))) : list.nodup (option.lhoare h0 h1) := sorry --non-trivial
lemma new_lemma_69499 (h0 : ordered_add_comm_monoid (has_Inf (ring (ring linarith.comp)))) : archimedean (has_Inf (ring (ring linarith.comp))) := sorry --non-trivial
lemma new_lemma_69500 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_add_cyclic.{0} (linear_ordered_semiring.{0} num) (@function.extfun_app.{2 1} Type add_group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 add_group.{0}) (linear_ordered_semiring.{0} num))  := sorry --non-trivial
lemma new_lemma_69501 (h0 : functor.add_const (semiring (free_add_monoid unsigned)) congr_arg_kind) : @is_noetherian_ring.{0} (free_add_monoid.{0} unsigned) (@functor.add_const.run.{0 0} (semiring.{0} (free_add_monoid.{0} unsigned)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_69502 (h0 : functor.comp group boolean_algebra.core pos) : @is_cyclic.{0} (boolean_algebra.core.{0} pos) (@functor.comp.run.{0 0 0} group.{0} boolean_algebra.core.{0} pos h0)  := sorry --non-trivial
lemma new_lemma_69503 (h0 : functor.add_const (function.extfun Type ring) Type) : @is_principal_ideal_ring.{0} (has_to_string.{0} pos) (@function.extfun_app.{2 1} Type ring.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type ring.{0}) Type h0) (has_to_string.{0} pos))  := sorry --non-trivial
lemma new_lemma_69504 (h0 : function.extfun Type topological_space) : @topological_space.separable_space.{0} (normed_group.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (normed_group.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_69505 (h0 : group (has_compl (has_nnnorm to_additive.value_type))) : is_cyclic (has_compl (has_nnnorm to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_69506 (h0 : functor.add_const (ring (comm_group environment.implicit_infer_kind)) environment.implicit_infer_kind) : @strong_rank_condition.{0} (comm_group.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (ring.{0} (comm_group.{0} environment.implicit_infer_kind)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_69507 (h0 : topological_space (has_nndist ennreal)) : t1_space (has_nndist ennreal) := sorry --non-trivial
lemma new_lemma_69508 (h2 : group (with_zero to_additive.value_type)) : is_cyclic (with_zero to_additive.value_type) := sorry --non-trivial
lemma new_lemma_69509 (h0 : functor.add_const (group (ring pos)) pos) : @is_cyclic.{0} (ring.{0} pos) (@functor.add_const.run.{0 0} (group.{0} (ring.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_69510 (h0 : topological_space (boolean_algebra (has_to_string (has_to_string Type)))) : irreducible_space (boolean_algebra (has_to_string (has_to_string Type))) := sorry --non-trivial
lemma new_lemma_69511 (h0 : topological_space (has_neg (ring (finset (finset (finset linarith.comp)))))) : t1_space (has_neg (ring (finset (finset (finset linarith.comp))))) := sorry --non-trivial
lemma new_lemma_69512 (h0 : functor.add_const (function.extfun Type topological_space) Type) : @topological_space.separable_space.{0} (has_to_string.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type topological_space.{0}) Type h0) (has_to_string.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_69513 (h0 : topological_space (bin_tree congr_arg_kind)) : normal_space (bin_tree congr_arg_kind) := sorry --non-trivial
lemma new_lemma_69514 (h0 : function.extfun Type topological_space) : @totally_separated_space.{0} (add_semigroup.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (add_semigroup.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_69515 (h0 : functor.add_const (semiring (comm_group linarith.comp)) name) : @is_noetherian_ring.{0} (comm_group.{0} linarith.comp) (@functor.add_const.run.{0 0} (semiring.{0} (comm_group.{0} linarith.comp)) name h0)  := sorry --non-trivial
lemma new_lemma_69516 (h0 : function.extfun linarith.comp_source (fun (x : linarith.comp_source), Prop)) : @infi.{0 1} Prop (@conditionally_complete_lattice.to_has_Inf.{0} Prop (@complete_lattice.to_conditionally_complete_lattice.{0} Prop Prop.complete_lattice)) linarith.comp_source (@function.extfun_app.{1 1} linarith.comp_source (λ (x : linarith.comp_source), Prop) h0)  := sorry --non-trivial
lemma new_lemma_69517 (h0 : functor.add_const (filter (cancel_monoid ennreal)) num) : countable_Inter_filter (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_69518 (h0 : functor.add_const (monoid (semigroup unsigned)) empty) : @monoid.fg.{0} (semigroup.{0} unsigned) (@functor.add_const.run.{0 0} (monoid.{0} (semigroup.{0} unsigned)) empty h0)  := sorry --non-trivial
lemma new_lemma_69519 (h0 : not (ring reducibility_hints -> false)) : @is_domain.{0} reducibility_hints (@classical.by_contradiction'.{1} (ring.{0} reducibility_hints) h0)  := sorry --non-trivial
lemma new_lemma_69520 (h0 : function.extfun (finset Type) (has_mem.mem num)) : @totally_separated_space.{0} num (@finset.pi.empty.{1 0} Type topological_space.{0} num (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) num) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_69521 (h0 : functor.add_const (ring (boolean_algebra.core unsigned)) name) : @is_domain.{0} (boolean_algebra.core.{0} unsigned) (@functor.add_const.run.{0 0} (ring.{0} (boolean_algebra.core.{0} unsigned)) name h0)  := sorry --non-trivial
lemma new_lemma_69522 (h0 : topological_space enat) (h1 : enat -> enat -> Prop) : topological_space.is_topological_basis (set.bounded h1) := sorry --non-trivial
lemma new_lemma_69523 (h0 : function.extfun Type group) : @normalizer_condition.{0} (has_bot.{0} real) (@function.extfun_app.{2 1} Type group.{0} h0 (has_bot.{0} real))  := sorry --non-trivial
lemma new_lemma_69524 (h0 : topological_space (boolean_algebra.core (comm_group Type))) : irreducible_space (boolean_algebra.core (comm_group Type)) := sorry --non-trivial
lemma new_lemma_69525 (h0 : add_monoid (measurable_space (has_norm num))) : add_monoid.fg (measurable_space (has_norm num)) := sorry --non-trivial
lemma new_lemma_69526 (h0 : function.extfun nat fin) : @is_cyclic.{0} (has_norm.{0} num) (@matrix.vec_empty.{0} (group.{0} (has_norm.{0} num)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_69527 (h1 : topological_space (mul_one_class std_gen)) (h2 : set (mul_one_class std_gen)) : is_path_connected h2 := sorry --non-trivial
lemma new_lemma_69528 (h0 : function.extfun Type group) : @normalizer_condition.{0} (add_group.{0} empty) (@function.extfun_app.{2 1} Type group.{0} h0 (add_group.{0} empty))  := sorry --non-trivial
lemma new_lemma_69529 (h0 : functor.add_const (add_monoid (left_cancel_monoid num)) empty) : @add_monoid.fg.{0} (left_cancel_monoid.{0} num) (@functor.add_const.run.{0 0} (add_monoid.{0} (left_cancel_monoid.{0} num)) empty h0)  := sorry --non-trivial
lemma new_lemma_69530 (h0 : group (semigroup (finset (has_add (has_add unsigned))))) : is_simple_group (semigroup (finset (has_add (has_add unsigned)))) := sorry --non-trivial
lemma new_lemma_69531 (h0 : function.extfun Type topological_space) : @normal_space.{0} (monoid_with_zero.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (monoid_with_zero.{0} pos))  := sorry --non-trivial
lemma new_lemma_69532 (h0 : complete_lattice (has_union num)) : is_atomistic (has_union num) := sorry --non-trivial
lemma new_lemma_69533 (h0 : topological_space (has_nndist environment.implicit_infer_kind)) : normal_space (has_nndist environment.implicit_infer_kind) := sorry --non-trivial
lemma new_lemma_69534 (h0 : functor.add_const (topological_space (has_Sup unsigned)) empty) : @loc_path_connected_space.{0} (has_Sup.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (has_Sup.{0} unsigned)) empty h0)  := sorry --non-trivial
lemma new_lemma_69535 (h0 : group (measure_theory.measure_space (semiring (semiring (semiring (semiring congr_arg_kind)))))) : group.fg (measure_theory.measure_space (semiring (semiring (semiring (semiring congr_arg_kind))))) := sorry --non-trivial
lemma new_lemma_69536 (h0 : ring (comm_ring (comm_ring (comm_ring reducibility_hints)))) : rank_condition (comm_ring (comm_ring (comm_ring reducibility_hints))) := sorry --non-trivial
lemma new_lemma_69537 (h0 : topological_space (boolean_algebra.core (option (option congr_arg_kind)))) : t1_space (boolean_algebra.core (option (option congr_arg_kind))) := sorry --non-trivial
lemma new_lemma_69538 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @monoid.fg.{0} (linear_ordered_comm_group.{0} empty) (@function.extfun_app.{2 1} Type monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 monoid.{0}) (linear_ordered_comm_group.{0} empty))  := sorry --non-trivial
lemma new_lemma_69539 (h0 : monoid (with_one (linear_ordered_semiring linarith.comp))) : monoid.fg (with_one (linear_ordered_semiring linarith.comp)) := sorry --non-trivial
lemma new_lemma_69540 (h0 : uniform_space (has_norm (has_inv (random_gen fun_info)))) : complete_space (has_norm (has_inv (random_gen fun_info))) := sorry --non-trivial
lemma new_lemma_69541 (h0 : functor.add_const (ring (has_nndist environment.implicit_infer_kind)) pos) : @strong_rank_condition.{0} (has_nndist.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (ring.{0} (has_nndist.{0} environment.implicit_infer_kind)) pos h0)  := sorry --non-trivial
lemma new_lemma_69542 (h0 : finset (ordered_comm_ring (has_Inf (has_add Type)))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_69543 (h0 : functor.add_const (topological_space (ordered_comm_ring pos)) (finset Type)) : @discrete_topology.{0} (ordered_comm_ring.{0} pos) (@functor.add_const.run.{0 1} (topological_space.{0} (ordered_comm_ring.{0} pos)) (finset.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_69544 (h0 : topological_space (div_inv_monoid linarith.comp_source)) : path_connected_space (div_inv_monoid linarith.comp_source) := sorry --non-trivial
lemma new_lemma_69545 (h0 : ulower (ulower Prop)) : @ulower.up.{0} Prop encodable.Prop (@ulower.up.{0} (@ulower.{0} Prop encodable.Prop) (@ulower.encodable.{0} Prop encodable.Prop) (@id.{1} (@ulower.{0} (@ulower.{0} Prop encodable.Prop) (@ulower.encodable.{0} Prop encodable.Prop)) (@id.{1} (@ulower.{0} (@ulower.{0} Prop encodable.Prop) (@ulower.encodable.{0} Prop encodable.Prop)) h0)))  := sorry --non-trivial
lemma new_lemma_69546 (h0 : topological_space (has_top empty)) : t0_space (has_top empty) := sorry --non-trivial
lemma new_lemma_69547 (h0 : function.extfun Type topological_space) : loc_path_connected_space ennreal := sorry --non-trivial
lemma new_lemma_69548 (h0 : add_group (has_nnnorm to_additive.value_type)) : is_add_cyclic (has_nnnorm to_additive.value_type) := sorry --non-trivial
lemma new_lemma_69549 (h0 : functor.add_const (group (finset environment.implicit_infer_kind)) (finset Type)) : @is_simple_group.{0} (finset.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 1} (group.{0} (finset.{0} environment.implicit_infer_kind)) (finset.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_69550 (h0 : function.extfun Type topological_space) : @totally_separated_space.{0} (measure_theory.measure_space.{0} (option.{0} empty)) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (measure_theory.measure_space.{0} (option.{0} empty)))  := sorry --non-trivial
lemma new_lemma_69551 (h0 : add_group (canonically_ordered_add_monoid congr_arg_kind)) : is_add_cyclic (canonically_ordered_add_monoid congr_arg_kind) := sorry --non-trivial
lemma new_lemma_69552 (h0 : complete_lattice (has_top (finset linarith.comp_source))) : is_atomistic (has_top (finset linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_69553 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @strong_rank_condition.{0} (semigroup.{0} unsigned) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (semigroup.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_69554 (h0 : fin has_zero.zero) : is_principal_ideal_ring real := sorry --non-trivial
lemma new_lemma_69555 (h0 : functor.add_const (topological_space (finset environment.implicit_infer_kind)) Type) : @preirreducible_space.{0} (finset.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 1} (topological_space.{0} (finset.{0} environment.implicit_infer_kind)) Type h0)  := sorry --non-trivial
lemma new_lemma_69556 (h0 : functor.add_const (ring (finset environment.implicit_infer_kind)) name) : @rank_condition.{0} (finset.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (ring.{0} (finset.{0} environment.implicit_infer_kind)) name h0)  := sorry --non-trivial
lemma new_lemma_69557 (h0 : ring (measurable_space (has_norm empty))) : rank_condition (measurable_space (has_norm empty)) := sorry --non-trivial
lemma new_lemma_69558 (h0 : topological_space (linear_ordered_semiring congr_arg_kind) -> Prop) (h1 : Exists (fun (x : topological_space (linear_ordered_semiring congr_arg_kind)), h0 x)) : @path_connected_space.{0} (linear_ordered_semiring.{0} congr_arg_kind) (@classical.some.{1} (topological_space.{0} (linear_ordered_semiring.{0} congr_arg_kind)) h0 h1)  := sorry --non-trivial
lemma new_lemma_69559 (h0 : ring (monoid num)) : rank_condition (monoid num) := sorry --non-trivial
lemma new_lemma_69560 (h0 : fin has_zero.zero) : @preconnected_space.{1} (canonically_linear_ordered_monoid.{1} Type) (@matrix.vec_empty.{1} (topological_space.{1} (canonically_linear_ordered_monoid.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_69561 (h0 : functor.comp topological_space mul_zero_class ennreal) : @locally_compact_space.{0} (mul_zero_class.{0} ennreal) (@functor.comp.run.{0 0 0} topological_space.{0} mul_zero_class.{0} ennreal h0)  := sorry --non-trivial
lemma new_lemma_69562 (h0 : function.extfun (finset (Type -> Type)) (has_mem.mem ring)) : @is_domain.{0} (has_norm.{0} num) (@function.extfun_app.{2 1} Type ring.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) ring.{0} (@function.extfun_app.{2 0} (finset.{1} (Type → Type)) (@has_mem.mem.{1 1} (Type → Type) (finset.{1} (Type → Type)) (@finset.has_mem.{1} (Type → Type)) ring.{0}) h0 (@has_emptyc.emptyc.{1} (finset.{1} (Type → Type)) (@finset.has_emptyc.{1} (Type → Type))))) (has_norm.{0} num))  := sorry --non-trivial
lemma new_lemma_69563 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @monoid.fg.{0} (has_neg_part.{0} name) (@function.extfun_app.{2 1} Type monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 monoid.{0}) (has_neg_part.{0} name))  := sorry --non-trivial
lemma new_lemma_69564 (h0 : not (group (bin_tree empty) -> false)) : @normalizer_condition.{0} (bin_tree.{0} empty) (@classical.by_contradiction'.{1} (group.{0} (bin_tree.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_69565 (h0 : topological_space (complete_linear_order congr_arg_kind)) : loc_path_connected_space (complete_linear_order congr_arg_kind) := sorry --non-trivial
lemma new_lemma_69566 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @separated_space.{0} (canonically_ordered_comm_semiring.{0} pos) (@function.extfun_app.{2 1} Type uniform_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 uniform_space.{0}) (canonically_ordered_comm_semiring.{0} pos))  := sorry --non-trivial
lemma new_lemma_69567 (h0 : semiring (has_star (semiring empty))) : is_noetherian_ring (has_star (semiring empty)) := sorry --non-trivial
lemma new_lemma_69568 (h0 : functor.add_const (topological_space (boolean_algebra.core Type)) (normed_comm_ring Type)) : @preirreducible_space.{1} (boolean_algebra.core.{1} Type) (@functor.add_const.run.{1 1} (topological_space.{1} (boolean_algebra.core.{1} Type)) (normed_comm_ring.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_69569 (h0 : complete_lattice (id (semiring (semiring num)))) : complete_lattice.is_Sup_finite_compact (id (semiring (semiring num))) := sorry --non-trivial
lemma new_lemma_69570 (h0 : topological_space (boolean_algebra.core (has_add name))) : t0_space (boolean_algebra.core (has_add name)) := sorry --non-trivial
lemma new_lemma_69571 (h0 : Type) (h1 : eq Prop (mul_one_class h0)) (h2 : mul_one_class h0) : eq.mpr h1 h2 := sorry --non-trivial
lemma new_lemma_69572 (h0 : uniform_space (ordered_comm_monoid (has_neg (has_neg (has_neg linarith.comp))))) : separated_space (ordered_comm_monoid (has_neg (has_neg (has_neg linarith.comp)))) := sorry --non-trivial
lemma new_lemma_69573 (h0 : monoid (random_gen (has_inv linarith.ineq))) : monoid.fg (random_gen (has_inv linarith.ineq)) := sorry --non-trivial
lemma new_lemma_69574 (h0 : cancel_comm_monoid_with_zero (monoid num)) : unique_factorization_monoid (monoid num) := sorry --non-trivial
lemma new_lemma_69575 (h0 : functor.add_const (complete_lattice (plift unsigned)) congr_arg_kind) : @complete_lattice.is_Sup_finite_compact.{1} (plift.{1} unsigned) (@functor.add_const.run.{1 0} (complete_lattice.{1} (plift.{1} unsigned)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_69576 (h0 : functor.add_const (topological_space Type) (finset pos)) : @sequential_space.{1} Type (@functor.add_const.run.{1 0} (topological_space.{1} Type) (finset.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_69577 (h0 : functor.add_const (topological_space (comm_monoid unsigned)) empty) : @totally_separated_space.{0} (comm_monoid.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (comm_monoid.{0} unsigned)) empty h0)  := sorry --non-trivial
lemma new_lemma_69578 (h0 : ring (boolean_algebra.core name)) : is_domain (boolean_algebra.core name) := sorry --non-trivial
lemma new_lemma_69579 (h0 : add_monoid (has_sub (semiring empty))) : add_monoid.fg (has_sub (semiring empty)) := sorry --non-trivial
lemma new_lemma_69580 (h0 : ring (has_le char)) : rank_condition (has_le char) := sorry --non-trivial
lemma new_lemma_69581 (h0 : ring (normed_lattice_add_comm_group (has_Inf real))) : strong_rank_condition (normed_lattice_add_comm_group (has_Inf real)) := sorry --non-trivial
lemma new_lemma_69582 (h0 : topological_space (non_unital_non_assoc_semiring (mul_one_class linarith.comp_source))) : t0_space (non_unital_non_assoc_semiring (mul_one_class linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_69583 (h0 : topological_space (normed_comm_ring unsigned)) : normal_space (normed_comm_ring unsigned) := sorry --non-trivial
lemma new_lemma_69584 (h0 : functor.add_const (group (has_nndist ennreal)) name) : @group.fg.{0} (has_nndist.{0} ennreal) (@functor.add_const.run.{0 0} (group.{0} (has_nndist.{0} ennreal)) name h0)  := sorry --non-trivial
lemma new_lemma_69585 (h1 : complete_lattice (semi_normed_comm_ring reducibility_hints)) : is_compactly_generated (semi_normed_comm_ring reducibility_hints) := sorry --non-trivial
lemma new_lemma_69586 (h0 : ordered_comm_monoid (ordered_comm_ring (has_neg (has_nndist pos)))) : has_exists_mul_of_le (ordered_comm_ring (has_neg (has_nndist pos))) := sorry --non-trivial
lemma new_lemma_69587 (h0 : functor.add_const (topological_space (complete_distrib_lattice pos)) linarith.comp) : @sequential_space.{0} (complete_distrib_lattice.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (complete_distrib_lattice.{0} pos)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_69588 (h0 : group (complete_semilattice_Sup (has_nnnorm to_additive.value_type))) : is_cyclic (complete_semilattice_Sup (has_nnnorm to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_69589 (h0 : functor.add_const (ordered_add_comm_monoid (ordered_comm_ring Type)) pos) : @archimedean.{1} (ordered_comm_ring.{1} Type) (@functor.add_const.run.{1 0} (ordered_add_comm_monoid.{1} (ordered_comm_ring.{1} Type)) pos h0)  := sorry --non-trivial
lemma new_lemma_69590 (h0 : function.extfun Type add_group) : @is_add_cyclic.{0} (with_one.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type add_group.{0} h0 (with_one.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_69591 (h0 : topological_space (cancel_monoid pos)) : irreducible_space (cancel_monoid pos) := sorry --non-trivial
lemma new_lemma_69592 (h0 : filter (linear_ordered_semiring unsigned)) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_69593 (h0 : topological_space (ordered_comm_ring (has_Inf real))) : locally_compact_space (ordered_comm_ring (has_Inf real)) := sorry --non-trivial
lemma new_lemma_69594 (h0 : list (has_to_string (ordered_ring linarith.comp))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_69595 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @sequential_space.{0} (has_add.{0} real) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_add.{0} real))  := sorry --non-trivial
lemma new_lemma_69596 (h0 : has_lt (distrib environment.projection_info)) : no_max_order (distrib environment.projection_info) := sorry --non-trivial
lemma new_lemma_69597 (h0 : ring (boolean_algebra (has_Inf (has_Inf (has_Inf (finset pos)))))) : rank_condition (boolean_algebra (has_Inf (has_Inf (has_Inf (finset pos))))) := sorry --non-trivial
lemma new_lemma_69598 (h0 : uniform_space (has_emptyc (has_norm num))) : separated_space (has_emptyc (has_norm num)) := sorry --non-trivial
lemma new_lemma_69599 (h0 : functor.add_const (group (cancel_monoid Type)) (has_add pos)) : @normalizer_condition.{1} (cancel_monoid.{1} Type) (@functor.add_const.run.{1 0} (group.{1} (cancel_monoid.{1} Type)) (has_add.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_69600 (h0 : topological_space (normed_comm_ring (has_add pos))) : t0_space (normed_comm_ring (has_add pos)) := sorry --non-trivial
lemma new_lemma_69601 (h0 : functor.comp topological_space has_to_string pos) : @t1_space.{0} (has_to_string.{0} pos) (@functor.comp.run.{0 0 0} topological_space.{0} has_to_string.{0} pos h0)  := sorry --non-trivial
lemma new_lemma_69602 (h0 : functor.add_const (fin has_zero.zero) (has_Inf Type)) : @is_add_cyclic.{1} (comm_semigroup.{1} Type) (@matrix.vec_empty.{1} (add_group.{1} (comm_semigroup.{1} Type)) (@functor.add_const.run.{0 1} (fin (@has_zero.zero.{0} nat nat.has_zero)) (has_Inf.{1} Type) h0))  := sorry --non-trivial
lemma new_lemma_69603 (h0 : complete_lattice (measurable_space (has_inv (has_inv fun_info)))) : is_atomistic (measurable_space (has_inv (has_inv fun_info))) := sorry --non-trivial
lemma new_lemma_69604 (h0 : function.extfun Type topological_space) : @locally_compact_space.{0} (mul_zero_class.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (mul_zero_class.{0} num))  := sorry --non-trivial
lemma new_lemma_69605 (h0 : topological_space (has_ssubset (random_gen (has_norm string_imp)))) : t0_space (has_ssubset (random_gen (has_norm string_imp))) := sorry --non-trivial
lemma new_lemma_69606 (h0 : complete_lattice (option empty)) : complete_lattice.is_Sup_finite_compact (option empty) := sorry --non-trivial
lemma new_lemma_69607 (h0 : functor.add_const (function.extfun Type ring) Type) : @strong_rank_condition.{0} (has_neg_part.{0} pos) (@function.extfun_app.{2 1} Type ring.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type ring.{0}) Type h0) (has_neg_part.{0} pos))  := sorry --non-trivial
lemma new_lemma_69608 (h1 : not (topological_space (normed_field reducibility_hints) -> false)) : @t0_space.{0} (normed_field.{0} reducibility_hints) (@classical.by_contradiction'.{1} (topological_space.{0} (normed_field.{0} reducibility_hints)) h1)  := sorry --non-trivial
lemma new_lemma_69609 (h0 : topological_space (linear_ordered_semiring (canonically_linear_ordered_monoid congr_arg_kind))) : path_connected_space (linear_ordered_semiring (canonically_linear_ordered_monoid congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_69610 (h0 : topological_space (semiring (linear_ordered_semiring (semiring (semiring empty))))) : t0_space (semiring (linear_ordered_semiring (semiring (semiring empty)))) := sorry --non-trivial
lemma new_lemma_69611 (h0 : filter (distrib_lattice (has_inv linarith.comp_source))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_69612 (h0 : filter (has_ssubset empty)) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_69613 (h0 : ring (simple_graph (ring Type))) : is_domain (simple_graph (ring Type)) := sorry --non-trivial
lemma new_lemma_69614 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @loc_path_connected_space.{0} (canonically_ordered_monoid.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (canonically_ordered_monoid.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_69615 (h0 : list (cancel_monoid (comm_group name))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_69616 (h0 : topological_space (has_nndist (mul_one_class (semigroup Type)))) : t0_space (has_nndist (mul_one_class (semigroup Type))) := sorry --non-trivial
lemma new_lemma_69617 (h0 : complete_lattice (has_inter ennreal)) : is_compactly_generated (has_inter ennreal) := sorry --non-trivial
lemma new_lemma_69618 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_noetherian_ring.{0} (finset.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type semiring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 semiring.{0}) (finset.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_69619 (h0 : function.extfun Type topological_space) : @sequential_space.{0} (sub_neg_monoid.{0} real) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (sub_neg_monoid.{0} real))  := sorry --non-trivial
lemma new_lemma_69620 (h0 : group (has_add (random_gen (random_gen linarith.ineq)))) : is_cyclic (has_add (random_gen (random_gen linarith.ineq))) := sorry --non-trivial
lemma new_lemma_69621 (h0 : ring (has_zero (comm_group (comm_group Type)))) : strong_rank_condition (has_zero (comm_group (comm_group Type))) := sorry --non-trivial
lemma new_lemma_69622 (h0 : functor.add_const (complete_lattice (has_neg unsigned)) unsigned) : @is_compactly_generated.{0} (has_neg.{0} unsigned) (@functor.add_const.run.{0 0} (complete_lattice.{0} (has_neg.{0} unsigned)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_69623 (h0 : topological_space (add_left_cancel_monoid (random_gen string_imp))) : totally_disconnected_space (add_left_cancel_monoid (random_gen string_imp)) := sorry --non-trivial
lemma new_lemma_69624 (h0 : functor.add_const Prop (finset (finset (finset pos)))) : functor.add_const.run h0 := sorry --non-trivial
lemma new_lemma_69625 (h0 : not (function.extfun Type topological_space -> false)) : @irreducible_space.{0} (with_bot.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (with_bot.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_69626 (h0 : functor.add_const (topological_space (free_add_monoid empty)) num) : @totally_disconnected_space.{0} (free_add_monoid.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (free_add_monoid.{0} empty)) num h0)  := sorry --non-trivial
lemma new_lemma_69627 (h0 : topological_space (distrib_lattice to_additive.value_type)) : locally_compact_space (distrib_lattice to_additive.value_type) := sorry --non-trivial
lemma new_lemma_69628 (h0 : ring (comm_semigroup Type)) : strong_rank_condition (comm_semigroup Type) := sorry --non-trivial
lemma new_lemma_69629 (h0 : semiring (boolean_algebra pos)) : is_noetherian_ring (boolean_algebra pos) := sorry --non-trivial
lemma new_lemma_69630 (h0 : functor.add_const (topological_space (as_linear_order unsigned)) empty) : @irreducible_space.{0} (as_linear_order.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (as_linear_order.{0} unsigned)) empty h0)  := sorry --non-trivial
lemma new_lemma_69631 (h0 : not (function.extfun (Type -> Type) (function.extfun Type) -> false)) : complete_space empty := sorry --non-trivial
lemma new_lemma_69632 (h0 : topological_space (generalized_boolean_algebra linarith.comp)) : t1_space (generalized_boolean_algebra linarith.comp) := sorry --non-trivial
lemma new_lemma_69633 (h0 : functor.add_const (complete_lattice (left_cancel_monoid num)) num) : @complete_lattice.is_Sup_finite_compact.{0} (left_cancel_monoid.{0} num) (@functor.add_const.run.{0 0} (complete_lattice.{0} (left_cancel_monoid.{0} num)) num h0)  := sorry --non-trivial
lemma new_lemma_69634 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : filter.ne_bot (function.extfun_app (function.extfun_app h0 filter) (has_inv to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_69635 (h0 : functor.add_const (ordered_comm_monoid (comm_group environment.implicit_infer_kind)) name) : @has_exists_mul_of_le.{0} (comm_group.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (ordered_comm_monoid.{0} (comm_group.{0} environment.implicit_infer_kind)) name h0)  := sorry --non-trivial
lemma new_lemma_69636 (h0 : group (has_inv linarith.ineq)) : group.fg (has_inv linarith.ineq) := sorry --non-trivial
lemma new_lemma_69637 (h0 : function.extfun Type topological_space) : @totally_disconnected_space.{0} (canonically_ordered_comm_semiring.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (canonically_ordered_comm_semiring.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_69638 (h0 : topological_space (normed_comm_ring ennreal)) : normal_space (normed_comm_ring ennreal) := sorry --non-trivial
lemma new_lemma_69639 (h0 : functor.add_const (topological_space (canonically_ordered_comm_semiring Type)) name) : @preirreducible_space.{1} (canonically_ordered_comm_semiring.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (canonically_ordered_comm_semiring.{1} Type)) name h0)  := sorry --non-trivial
lemma new_lemma_69640 (h0 : int) (h1 : int -> fun_info) (h2 : coe_sort (set.range h1)) : int.lt h0 (set.range_splitting h1 h2) := sorry --non-trivial
lemma new_lemma_69641 (h0 : topological_space (generalized_boolean_algebra (has_neg (has_neg name)))) : totally_disconnected_space (generalized_boolean_algebra (has_neg (has_neg name))) := sorry --non-trivial
lemma new_lemma_69642 (h1 : uniform_space (mul_one_class (has_ssubset ereal))) : complete_space (mul_one_class (has_ssubset ereal)) := sorry --non-trivial
lemma new_lemma_69643 (h0 : topological_space (dlist (has_ssubset to_additive.value_type))) : t0_space (dlist (has_ssubset to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_69644 (h0 : functor.add_const (topological_space (normed_linear_ordered_group (option unsigned))) empty) : @loc_path_connected_space.{0} (normed_linear_ordered_group.{0} (option.{0} unsigned)) (@functor.add_const.run.{0 0} (topological_space.{0} (normed_linear_ordered_group.{0} (option.{0} unsigned))) empty h0)  := sorry --non-trivial
lemma new_lemma_69645 (h0 : functor.add_const (topological_space (has_neg unsigned)) name) : @preconnected_space.{0} (has_neg.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (has_neg.{0} unsigned)) name h0)  := sorry --non-trivial
lemma new_lemma_69646 (h0 : functor.add_const (cancel_comm_monoid_with_zero (add_cancel_monoid unsigned)) pos) : @unique_factorization_monoid.{0} (add_cancel_monoid.{0} unsigned) (@functor.add_const.run.{0 0} (cancel_comm_monoid_with_zero.{0} (add_cancel_monoid.{0} unsigned)) pos h0)  := sorry --non-trivial
lemma new_lemma_69647 (h0 : functor.add_const (topological_space (has_to_string name)) environment.implicit_infer_kind) : @normal_space.{0} (has_to_string.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (has_to_string.{0} name)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_69648 (h0 : complete_lattice (with_bot (random_gen to_additive.value_type))) : is_compactly_generated (with_bot (random_gen to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_69649 (h0 : function.extfun Type finset) : finset.nonempty (function.extfun_app h0 (mul_zero_class num)) := sorry --non-trivial
lemma new_lemma_69650 (h0 : not (group (semi_normed_comm_ring to_additive.value_type) -> false)) : @group.fg.{0} (semi_normed_comm_ring.{0} to_additive.value_type) (@classical.by_contradiction'.{1} (group.{0} (semi_normed_comm_ring.{0} to_additive.value_type)) h0)  := sorry --non-trivial
lemma new_lemma_69651 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @rank_condition.{1} (semigroup.{1} Type) (@function.extfun_app.{3 2} (Type 1) ring.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 ring.{1}) (semigroup.{1} Type))  := sorry --non-trivial
lemma new_lemma_69652 (h0 : functor.add_const (topological_space (has_neg ennreal)) ennreal) : @locally_compact_space.{0} (has_neg.{0} ennreal) (@functor.add_const.run.{0 0} (topological_space.{0} (has_neg.{0} ennreal)) ennreal h0)  := sorry --non-trivial
lemma new_lemma_69653 (h0 : ring (has_neg (has_add (has_add unsigned)))) : is_principal_ideal_ring (has_neg (has_add (has_add unsigned))) := sorry --non-trivial
lemma new_lemma_69654 (h0 : group (cancel_monoid (finset name))) : is_simple_group (cancel_monoid (finset name)) := sorry --non-trivial
lemma new_lemma_69655 (h0 : functor.add_const (functor.add_const (complete_lattice linarith.comp) pos) pos) : @complete_lattice.is_Sup_finite_compact.{0} linarith.comp (@functor.add_const.run.{0 0} (complete_lattice.{0} linarith.comp) pos (@functor.add_const.run.{0 0} (functor.add_const.{0 0} (complete_lattice.{0} linarith.comp) pos) pos h0))  := sorry --non-trivial
lemma new_lemma_69656 (h0 : list to_additive.value_type) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_69657 (h0 : topological_space (finset (finset linarith.comp))) : t0_space (finset (finset linarith.comp)) := sorry --non-trivial
lemma new_lemma_69658 (h0 : topological_space (has_add (boolean_algebra pos))) : irreducible_space (has_add (boolean_algebra pos)) := sorry --non-trivial
lemma new_lemma_69659 (h0 : topological_space rat) (h1 : add_group rat) : topological_add_group rat := sorry --non-trivial
lemma new_lemma_69660 (h0 : ring (has_compl (has_inner reducibility_hints reducibility_hints))) : strong_rank_condition (has_compl (has_inner reducibility_hints reducibility_hints)) := sorry --non-trivial
lemma new_lemma_69661 (h0 : function.extfun Type ordered_add_comm_monoid) : @archimedean.{0} (semiring.{0} empty) (@function.extfun_app.{2 1} Type ordered_add_comm_monoid.{0} h0 (semiring.{0} empty))  := sorry --non-trivial
lemma new_lemma_69662 (h0 : function.extfun Type ring) : @is_principal_ideal_ring.{0} (add_cancel_monoid.{0} linarith.comp) (@function.extfun_app.{2 1} Type ring.{0} h0 (add_cancel_monoid.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_69663 (h0 : fin has_zero.zero) : @is_simple_group.{0} (normed_lattice_add_comm_group.{0} linarith.comp) (@matrix.vec_empty.{0} (group.{0} (normed_lattice_add_comm_group.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_69664 (h0 : ring (plift (semiring (semiring num)))) : strong_rank_condition (plift (semiring (semiring num))) := sorry --non-trivial
lemma new_lemma_69665 (h0 : functor.add_const (topological_space (semigroup pos)) environment.implicit_infer_kind) : @irreducible_space.{0} (semigroup.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (semigroup.{0} pos)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_69666 (h0 : topological_space (linear_ordered_cancel_comm_monoid (semiring empty))) : totally_disconnected_space (linear_ordered_cancel_comm_monoid (semiring empty)) := sorry --non-trivial
lemma new_lemma_69667 (h0 : has_add (distrib linarith.comp_source)) (h1 : ring (semi_normed_ring (mul_one_class (add_con (distrib linarith.comp_source))))) : rank_condition (semi_normed_ring (mul_one_class (add_con (distrib linarith.comp_source)))) := sorry --non-trivial
lemma new_lemma_69668 (h0 : complete_lattice (measurable_space.dynkin_system (semiring (semiring num)))) : is_compactly_generated (measurable_space.dynkin_system (semiring (semiring num))) := sorry --non-trivial
lemma new_lemma_69669 (h0 : topological_space (semiring (random_gen (random_gen to_additive.value_type)))) : locally_compact_space (semiring (random_gen (random_gen to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_69670 (h0 : functor.add_const (ordered_add_comm_monoid (generalized_boolean_algebra linarith.comp)) pos) : @archimedean.{0} (generalized_boolean_algebra.{0} linarith.comp) (@functor.add_const.run.{0 0} (ordered_add_comm_monoid.{0} (generalized_boolean_algebra.{0} linarith.comp)) pos h0)  := sorry --non-trivial
lemma new_lemma_69671 (h0 : not (function.extfun Type monoid -> false)) : @monoid.fg.{0} (linear_ordered_semiring.{0} empty) (@function.extfun_app.{2 1} Type monoid.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type monoid.{0}) h0) (linear_ordered_semiring.{0} empty))  := sorry --non-trivial
lemma new_lemma_69672 (h1 : ring (distrib (random_gen (random_gen char)))) : strong_rank_condition (distrib (random_gen (random_gen char))) := sorry --non-trivial
lemma new_lemma_69673 (h0 : has_mem.mem monoid has_emptyc.emptyc) : @monoid.fg.{0} unsigned (@function.extfun_app.{2 1} Type monoid.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) monoid.{0} h0) unsigned)  := sorry --non-trivial
lemma new_lemma_69674 (h0 : add_group (linear_ordered_comm_monoid_with_zero congr_arg_kind)) : is_add_cyclic (linear_ordered_comm_monoid_with_zero congr_arg_kind) := sorry --non-trivial
lemma new_lemma_69675 (h0 : functor.add_const (function.extfun Type topological_space) pos) : @preirreducible_space.{0} (has_zero.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) pos h0) (has_zero.{0} pos))  := sorry --non-trivial
lemma new_lemma_69676 (h0 : functor.add_const (prod (semigroup empty) (semigroup empty)) empty) : id_rel (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_69677 (h0 : group (dlist (has_nnnorm linarith.ineq))) : group.fg (dlist (has_nnnorm linarith.ineq)) := sorry --non-trivial
lemma new_lemma_69678 (h0 : topological_space (is_R_or_C empty)) : path_connected_space (is_R_or_C empty) := sorry --non-trivial
lemma new_lemma_69679 (h0 : group (with_bot (has_top num))) : normalizer_condition (with_bot (has_top num)) := sorry --non-trivial
lemma new_lemma_69680 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @strong_rank_condition.{0} (has_nndist.{0} unsigned) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (has_nndist.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_69681 (h0 : ring (ordered_cancel_add_comm_monoid unsigned)) : is_principal_ideal_ring (ordered_cancel_add_comm_monoid unsigned) := sorry --non-trivial
lemma new_lemma_69682 (h0 : add_monoid (mul_zero_class (has_top empty))) : add_monoid.fg (mul_zero_class (has_top empty)) := sorry --non-trivial
lemma new_lemma_69683 (h0 : function.extfun Type group) : @group.fg.{0} (ordered_ring.{0} (semiring.{0} num)) (@function.extfun_app.{2 1} Type group.{0} h0 (ordered_ring.{0} (semiring.{0} num)))  := sorry --non-trivial
lemma new_lemma_69684 (h2 : not (ring (pseudo_emetric_space fun_info) -> false)) : @is_domain.{0} (pseudo_emetric_space.{0} fun_info) (@classical.by_contradiction'.{1} (ring.{0} (pseudo_emetric_space.{0} fun_info)) h2)  := sorry --non-trivial
lemma new_lemma_69685 (h0 : topological_space (has_inner unsigned congr_arg_kind)) : irreducible_space (has_inner unsigned congr_arg_kind) := sorry --non-trivial
lemma new_lemma_69686 (h0 : ordered_comm_monoid (has_pos_part (has_Inf (has_nndist Type)))) : has_exists_mul_of_le (has_pos_part (has_Inf (has_nndist Type))) := sorry --non-trivial
lemma new_lemma_69687 (h0 : functor.comp topological_space has_add environment.implicit_infer_kind) : @irreducible_space.{0} (has_add.{0} environment.implicit_infer_kind) (@functor.comp.run.{0 0 0} topological_space.{0} has_add.{0} environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_69688 (h0 : not (ring (semi_normed_comm_ring to_additive.value_type) -> false)) : @is_domain.{0} (semi_normed_comm_ring.{0} to_additive.value_type) (@classical.by_contradiction'.{1} (ring.{0} (semi_normed_comm_ring.{0} to_additive.value_type)) h0)  := sorry --non-trivial
lemma new_lemma_69689 (h0 : functor.add_const (add_monoid (has_add linarith.comp)) Type) : @add_monoid.fg.{0} (has_add.{0} linarith.comp) (@functor.add_const.run.{0 1} (add_monoid.{0} (has_add.{0} linarith.comp)) Type h0)  := sorry --non-trivial
lemma new_lemma_69690 (h0 : functor.comp topological_space complete_distrib_lattice Type) : @loc_path_connected_space.{1} (complete_distrib_lattice.{1} Type) (@functor.comp.run.{1 1 1} topological_space.{1} complete_distrib_lattice.{1} Type h0)  := sorry --non-trivial
lemma new_lemma_69691 (h0 : functor.add_const (topological_space (cancel_monoid unsigned)) name) : @locally_compact_space.{0} (cancel_monoid.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (cancel_monoid.{0} unsigned)) name h0)  := sorry --non-trivial
lemma new_lemma_69692 (h0 : function.extfun Type uniform_space) : @complete_space.{0} (has_to_string.{0} pos) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (has_to_string.{0} pos))  := sorry --non-trivial
lemma new_lemma_69693 (h0 : functor.add_const (topological_space (complete_linear_order num)) (semiring (semiring empty))) : @locally_compact_space.{0} (complete_linear_order.{0} num) (@functor.add_const.run.{0 0} (topological_space.{0} (complete_linear_order.{0} num)) (semiring.{0} (semiring.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_69694 (h0 : topological_space (metric_space (has_norm linarith.comp))) : totally_separated_space (metric_space (has_norm linarith.comp)) := sorry --non-trivial
lemma new_lemma_69695 (h0 : list (add_comm_monoid linarith.comp)) : palindrome h0 := sorry --non-trivial
lemma new_lemma_69696 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : filter.ne_bot (function.extfun_app (function.extfun_app h0 filter) linarith.comp_source) := sorry --non-trivial
lemma new_lemma_69697 (h0 : function.extfun Type ring) : @is_domain.{0} (linear_ordered_semiring.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type ring.{0} h0 (linear_ordered_semiring.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_69698 (h0 : function.extfun ((Type -> Type) -> Type 1) (function.extfun (Type -> Type))) : @group.fg.{0} (linear_ordered_add_comm_monoid_with_top.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) (@function.extfun_app.{3 2} ((Type → Type) → Type 1) (function.extfun.{2 2} (Type → Type)) h0 (function.extfun.{2 1} Type)) group.{0}) (linear_ordered_add_comm_monoid_with_top.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_69699 (h0 : topological_space (uniform_space.core (has_top (has_top (has_top fun_info))))) : path_connected_space (uniform_space.core (has_top (has_top (has_top fun_info)))) := sorry --non-trivial
lemma new_lemma_69700 (h0 : topological_space (has_Inf (has_neg name))) : topological_space.separable_space (has_Inf (has_neg name)) := sorry --non-trivial
lemma new_lemma_69701 (h0 : functor.add_const (complete_lattice (semigroup Type)) environment.implicit_infer_kind) : @is_compactly_generated.{1} (semigroup.{1} Type) (@functor.add_const.run.{1 0} (complete_lattice.{1} (semigroup.{1} Type)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_69702 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @irreducible_space.{0} (measurable_space.{0} fun_info) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (measurable_space.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_69703 (h0 : add_group (normed_lattice_add_comm_group (has_Inf pos))) : is_add_cyclic (normed_lattice_add_comm_group (has_Inf pos)) := sorry --non-trivial
lemma new_lemma_69704 (h0 : function.extfun Type group) : @normalizer_condition.{0} (linear_ordered_add_comm_group.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type group.{0} h0 (linear_ordered_add_comm_group.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_69705 (h0 : topological_space (normed_comm_ring (has_add linarith.comp))) : loc_path_connected_space (normed_comm_ring (has_add linarith.comp)) := sorry --non-trivial
lemma new_lemma_69706 (h0 : filter (add_cancel_monoid congr_arg_kind)) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_69707 (h0 : add_group (semi_normed_comm_ring (has_nnnorm (random_gen to_additive.value_type)))) : is_add_cyclic (semi_normed_comm_ring (has_nnnorm (random_gen to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_69708 (h0 : set (add_comm_semigroup (add_comm_semigroup linarith.ineq))) : set.finite h0 := sorry --non-trivial
lemma new_lemma_69709 (h0 : functor.add_const (list (semigroup pos)) (has_neg (has_neg (ordered_ring (has_neg (ordered_ring Type)))))) : list.nodup (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_69710 (h0 : set (has_div (mul_one_class (mul_one_class to_additive.value_type)))) : set.finite h0 := sorry --non-trivial
lemma new_lemma_69711 (h0 : functor.add_const (ring (boolean_algebra environment.implicit_infer_kind)) pos) : @strong_rank_condition.{0} (boolean_algebra.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (ring.{0} (boolean_algebra.{0} environment.implicit_infer_kind)) pos h0)  := sorry --non-trivial
lemma new_lemma_69712 (h3 : Prop -> fun_info) (h4 : coe_sort (set.range h3)) : set.range_splitting h3 h4 := sorry --non-trivial
lemma new_lemma_69713 (h0 : complete_lattice (normed_group (random_gen (random_gen linarith.ineq)))) : is_compactly_generated (normed_group (random_gen (random_gen linarith.ineq))) := sorry --non-trivial
lemma new_lemma_69714 (h0 : not (function.extfun Type topological_space -> false)) : @totally_disconnected_space.{0} (measurable_space.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (measurable_space.{0} num))  := sorry --non-trivial
lemma new_lemma_69715 (h0 : filter (topological_space (topological_space fun_info))) : @totally_disconnected_space.{0} (topological_space.{0} fun_info) (@filter.Limsup.{0} (topological_space.{0} (topological_space.{0} fun_info)) (@complete_lattice.to_conditionally_complete_lattice.{0} (topological_space.{0} (topological_space.{0} fun_info)) (@topological_space.complete_lattice.{0} (topological_space.{0} fun_info))) h0)  := sorry --non-trivial
lemma new_lemma_69716 (h0 : topological_space (has_zero pos)) : topological_space.separable_space (has_zero pos) := sorry --non-trivial
lemma new_lemma_69717 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @normalizer_condition.{0} (has_zero.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (has_zero.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_69718 (h4 : not (topological_space (has_ssubset to_additive.value_type) -> false)) : @path_connected_space.{0} (has_ssubset.{0} to_additive.value_type) (@classical.by_contradiction'.{1} (topological_space.{0} (has_ssubset.{0} to_additive.value_type)) h4)  := sorry --non-trivial
lemma new_lemma_69719 (h1 : has_lt (normed_field linarith.comp_source)) : no_max_order (normed_field linarith.comp_source) := sorry --non-trivial
lemma new_lemma_69720 (h0 : function.extfun Type complete_lattice) : @is_compactly_generated.{0} (distrib.{0} (fintype.{0} (denumerable.{0} linarith.comp_source))) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (distrib.{0} (fintype.{0} (denumerable.{0} linarith.comp_source))))  := sorry --non-trivial
lemma new_lemma_69721 (h0 : function.extfun Type add_group) : @is_add_cyclic.{0} (linear_ordered_field.{0} empty) (@function.extfun_app.{2 1} Type add_group.{0} h0 (linear_ordered_field.{0} empty))  := sorry --non-trivial
lemma new_lemma_69722 (h0 : topological_space (has_one (has_norm num))) : totally_separated_space (has_one (has_norm num)) := sorry --non-trivial
lemma new_lemma_69723 (h1 : topological_space ordering) : totally_disconnected_space ordering := sorry --non-trivial
lemma new_lemma_69724 (h0 : functor.add_const (complete_lattice (has_neg pos)) pos) : @is_compactly_generated.{0} (has_neg.{0} pos) (@functor.add_const.run.{0 0} (complete_lattice.{0} (has_neg.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_69725 (h0 : function.extfun Type group) : @is_simple_group.{0} (mul_zero_class.{0} ennreal) (@function.extfun_app.{2 1} Type group.{0} h0 (mul_zero_class.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_69726 (h0 : topological_space (simple_graph (ring (boolean_algebra.core Type)))) : t0_space (simple_graph (ring (boolean_algebra.core Type))) := sorry --non-trivial
lemma new_lemma_69727 (h0 : complete_lattice (comm_semigroup (comm_semigroup real))) : is_compactly_generated (comm_semigroup (comm_semigroup real)) := sorry --non-trivial
lemma new_lemma_69728 (h0 : filter (distrib_lattice (has_inv (has_norm (has_norm string_imp))))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_69729 (h0 : function.extfun Type semiring) : @is_noetherian_ring.{0} (canonically_linear_ordered_monoid.{0} ennreal) (@function.extfun_app.{2 1} Type semiring.{0} h0 (canonically_linear_ordered_monoid.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_69730 (h0 : functor.add_const (ring (cancel_monoid name)) (finset (normed_comm_ring name))) : @is_principal_ideal_ring.{0} (cancel_monoid.{0} name) (@functor.add_const.run.{0 0} (ring.{0} (cancel_monoid.{0} name)) (finset.{0} (normed_comm_ring.{0} name)) h0)  := sorry --non-trivial
lemma new_lemma_69731 (h0 : topological_space (mul_one_class enat)) : path_connected_space (mul_one_class enat) := sorry --non-trivial
lemma new_lemma_69732 (h0 : has_mem.mem (has_emptyc congr_arg_kind) has_emptyc.emptyc) : @complete_space.{0} (has_emptyc.{0} congr_arg_kind) (@finset.pi.empty.{1 0} Type uniform_space.{0} (has_emptyc.{0} congr_arg_kind) h0)  := sorry --non-trivial
lemma new_lemma_69733 (h0 : functor.add_const (finset (generalized_boolean_algebra pos)) linarith.comp) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_69734 (h0 : ring (with_one (comm_ring linarith.ineq))) : rank_condition (with_one (comm_ring linarith.ineq)) := sorry --non-trivial
lemma new_lemma_69735 (h0 : uniform_space (has_add (ring (ordered_comm_monoid (has_nndist (has_add pos)))))) : separated_space (has_add (ring (ordered_comm_monoid (has_nndist (has_add pos))))) := sorry --non-trivial
lemma new_lemma_69736 (h0 : topological_space (has_norm (random_gen (random_gen string_imp)))) : t0_space (has_norm (random_gen (random_gen string_imp))) := sorry --non-trivial
lemma new_lemma_69737 (h0 : topological_space (measure_theory.measure_space (semiring (semiring empty)))) : normal_space (measure_theory.measure_space (semiring (semiring empty))) := sorry --non-trivial
lemma new_lemma_69738 (h0 : functor.add_const (complete_lattice (has_zero Type)) environment.implicit_infer_kind) : @complete_lattice.is_Sup_finite_compact.{1} (has_zero.{1} Type) (@functor.add_const.run.{1 0} (complete_lattice.{1} (has_zero.{1} Type)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_69739 (h0 : topological_space (canonically_ordered_comm_semiring name)) : locally_compact_space (canonically_ordered_comm_semiring name) := sorry --non-trivial
lemma new_lemma_69740 (h0 : topological_space (nondiscrete_normed_field environment.projection_info)) : t0_space (nondiscrete_normed_field environment.projection_info) := sorry --non-trivial
lemma new_lemma_69741 (h0 : complete_lattice (denumerable (random_gen fun_info))) : is_compactly_generated (denumerable (random_gen fun_info)) := sorry --non-trivial
lemma new_lemma_69742 (h0 : add_group (measurable_space.dynkin_system (semiring congr_arg_kind))) : is_add_cyclic (measurable_space.dynkin_system (semiring congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_69743 (h0 : function.extfun Type complete_lattice) : @complete_lattice.is_Sup_finite_compact.{0} (option.{0} name) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (option.{0} name))  := sorry --non-trivial
lemma new_lemma_69744 (h0 : semiring (complete_semilattice_Sup (semiring unsigned))) : is_noetherian_ring (complete_semilattice_Sup (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_69745 (h0 : complete_lattice (semiring congr_arg_kind)) : complete_lattice.is_Sup_finite_compact (semiring congr_arg_kind) := sorry --non-trivial
lemma new_lemma_69746 (h0 : functor.add_const (filter (ordered_comm_group unsigned)) empty) : filter.ne_bot (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_69747 (h0 : topological_space (measurable_space (random_gen (has_norm linarith.comp_source)))) : irreducible_space (measurable_space (random_gen (has_norm linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_69748 (h0 : functor.add_const (ring (canonically_linear_ordered_monoid name)) ennreal) : @strong_rank_condition.{0} (canonically_linear_ordered_monoid.{0} name) (@functor.add_const.run.{0 0} (ring.{0} (canonically_linear_ordered_monoid.{0} name)) ennreal h0)  := sorry --non-trivial
lemma new_lemma_69749 (h0 : ring (with_bot (has_top (has_top congr_arg_kind)))) : rank_condition (with_bot (has_top (has_top congr_arg_kind))) := sorry --non-trivial
lemma new_lemma_69750 (h0 : functor.add_const Prop (has_neg (option congr_arg_kind))) : functor.add_const.run h0 := sorry --non-trivial
lemma new_lemma_69751 (h0 : function.extfun Type finset) : finset.nonempty (function.extfun_app h0 (has_nndist name)) := sorry --non-trivial
lemma new_lemma_69752 (h0 : function.extfun ((Type -> Type) -> Type 1) (function.extfun (Type -> Type))) : @monoid.fg.{0} (with_bot.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) (@function.extfun_app.{3 2} ((Type → Type) → Type 1) (function.extfun.{2 2} (Type → Type)) h0 (function.extfun.{2 1} Type)) monoid.{0}) (with_bot.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_69753 (h0 : std_gen -> std_gen) : function.involutive h0 := sorry --non-trivial
lemma new_lemma_69754 (h0 : complete_lattice (measurable_space.dynkin_system (semiring empty))) : complete_lattice.is_Sup_finite_compact (measurable_space.dynkin_system (semiring empty)) := sorry --non-trivial
lemma new_lemma_69755 (h0 : set (add_comm_semigroup ereal -> enat)) : set.separates_points h0 := sorry --non-trivial
lemma new_lemma_69756 (h0 : functor.add_const (add_group (generalized_boolean_algebra pos)) (has_neg pos)) : @is_add_cyclic.{0} (generalized_boolean_algebra.{0} pos) (@functor.add_const.run.{0 0} (add_group.{0} (generalized_boolean_algebra.{0} pos)) (has_neg.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_69757 (h1 : function.extfun (Type -> Type) (function.extfun Type)) : @monoid.fg.{0} congr_arg_kind (@function.extfun_app.{2 1} Type monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h1 monoid.{0}) congr_arg_kind)  := sorry --non-trivial
lemma new_lemma_69758 (h0 : topological_space (boolean_algebra (has_Inf linarith.comp))) : normal_space (boolean_algebra (has_Inf linarith.comp)) := sorry --non-trivial
lemma new_lemma_69759 (h0 : function.extfun Type topological_space) : @preirreducible_space.{0} (add_comm_monoid.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (add_comm_monoid.{0} empty))  := sorry --non-trivial
lemma new_lemma_69760 (h0 : functor.add_const (topological_space (canonically_ordered_comm_semiring linarith.comp)) pos) : @totally_separated_space.{0} (canonically_ordered_comm_semiring.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (canonically_ordered_comm_semiring.{0} linarith.comp)) pos h0)  := sorry --non-trivial
lemma new_lemma_69761 (h0 : add_group (semiring (semiring congr_arg_kind))) : is_add_cyclic (semiring (semiring congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_69762 (h0 : functor.add_const (list (has_pos_part pos)) linarith.comp) : list.nodup (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_69763 (h0 : ring (has_to_string (has_nndist environment.implicit_infer_kind))) : is_principal_ideal_ring (has_to_string (has_nndist environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_69764 (h0 : function.extfun Type topological_space) : @locally_compact_space.{0} unsigned (@function.extfun_app.{2 1} Type topological_space.{0} h0 unsigned)  := sorry --non-trivial
lemma new_lemma_69765 (h0 : filter (normed_comm_ring pos)) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_69766 (h0 : function.extfun Type add_group) : @is_add_cyclic.{0} (generalized_boolean_algebra.{0} real) (@function.extfun_app.{2 1} Type add_group.{0} h0 (generalized_boolean_algebra.{0} real))  := sorry --non-trivial
lemma new_lemma_69767 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @strong_rank_condition.{0} (mul_zero_class.{0} unsigned) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (mul_zero_class.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_69768 (h0 : group (with_one (has_norm empty))) : is_cyclic (with_one (has_norm empty)) := sorry --non-trivial
lemma new_lemma_69769 (h0 : topological_space (has_zero (option name))) : regular_space (has_zero (option name)) := sorry --non-trivial
lemma new_lemma_69770 (h0 : group (measurable_space.dynkin_system (semiring unsigned))) : group.fg (measurable_space.dynkin_system (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_69771 (h0 : has_add Type -> has_add Type -> Prop) : irreflexive h0 := sorry --non-trivial
lemma new_lemma_69772 (h0 : functor.add_const (function.extfun Type complete_lattice) linarith.comp) : @is_compactly_generated.{0} (has_add.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type complete_lattice.{0}) linarith.comp h0) (has_add.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_69773 (h0 : topological_space (finset (ring (has_to_string Type)))) : topological_space.separable_space (finset (ring (has_to_string Type))) := sorry --non-trivial
lemma new_lemma_69774 (h0 : functor.add_const (ring (add_comm_monoid name)) Type) : @rank_condition.{0} (add_comm_monoid.{0} name) (@functor.add_const.run.{0 1} (ring.{0} (add_comm_monoid.{0} name)) Type h0)  := sorry --non-trivial
lemma new_lemma_69775 (h0 : topological_space (ring (semigroup linarith.comp))) : totally_separated_space (ring (semigroup linarith.comp)) := sorry --non-trivial
lemma new_lemma_69776 (h0 : semiring (monoid (option pos))) : is_noetherian_ring (monoid (option pos)) := sorry --non-trivial
lemma new_lemma_69777 (h0 : function.extfun (Type 1) list) : palindrome (function.extfun_app h0 (plift empty)) := sorry --non-trivial
lemma new_lemma_69778 (h0 : add_monoid (complete_distrib_lattice linarith.comp)) : add_monoid.fg (complete_distrib_lattice linarith.comp) := sorry --non-trivial
lemma new_lemma_69779 (h0 : topological_space (complete_linear_order (has_norm empty))) : irreducible_space (complete_linear_order (has_norm empty)) := sorry --non-trivial
lemma new_lemma_69780 (h0 : functor.add_const (ring (linear_order unsigned)) unsigned) : @is_domain.{0} (linear_order.{0} unsigned) (@functor.add_const.run.{0 0} (ring.{0} (linear_order.{0} unsigned)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_69781 (h0 : filter (has_nndist (finset (finset name)))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_69782 (h0 : functor.add_const (complete_lattice (boolean_algebra.core name)) (has_add Type)) : @complete_lattice.is_Sup_finite_compact.{0} (boolean_algebra.core.{0} name) (@functor.add_const.run.{0 1} (complete_lattice.{0} (boolean_algebra.core.{0} name)) (has_add.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_69783 (h1 : set string.iterator) : set.finite h1 := sorry --non-trivial
lemma new_lemma_69784 (h0 : uniform_space (complete_distrib_lattice name)) : separated_space (complete_distrib_lattice name) := sorry --non-trivial
lemma new_lemma_69785 (h0 : fin has_zero.zero) : @unique_factorization_monoid.{0} (has_add.{0} name) (@matrix.vec_empty.{0} (cancel_comm_monoid_with_zero.{0} (has_add.{0} name)) h0)  := sorry --non-trivial
lemma new_lemma_69786 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @archimedean.{0} (boolean_algebra.core.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type ordered_add_comm_monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ordered_add_comm_monoid.{0}) (boolean_algebra.core.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_69787 (h0 : ring (semi_normed_ring (mul_one_class (mul_one_class linarith.ineq)))) : rank_condition (semi_normed_ring (mul_one_class (mul_one_class linarith.ineq))) := sorry --non-trivial
lemma new_lemma_69788 (h0 : group (has_add name)) : is_cyclic (has_add name) := sorry --non-trivial
lemma new_lemma_69789 (h0 : topological_space (has_add name)) : preirreducible_space (has_add name) := sorry --non-trivial
lemma new_lemma_69790 (h0 : list (has_ssubset (has_top (comm_ring linarith.ineq)))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_69791 (h0 : ring (with_one (semiring (semiring (semiring (semiring unsigned)))))) : strong_rank_condition (with_one (semiring (semiring (semiring (semiring unsigned))))) := sorry --non-trivial
lemma new_lemma_69792 (h2 : function.extfun Type topological_space) : @locally_compact_space.{0} (measurable_space.{0} linarith.ineq) (@function.extfun_app.{2 1} Type topological_space.{0} h2 (measurable_space.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_69793 (h0 : function.extfun Type group) : @is_cyclic.{0} (linear_ordered_add_comm_monoid_with_top.{0} num) (@function.extfun_app.{2 1} Type group.{0} h0 (linear_ordered_add_comm_monoid_with_top.{0} num))  := sorry --non-trivial
lemma new_lemma_69794 (h0 : functor.add_const (filter (add_cancel_monoid name)) (has_add Type)) : countable_Inter_filter (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_69795 (h0 : not (function.extfun Type topological_space -> false)) : @discrete_topology.{0} (has_top.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (has_top.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_69796 (h0 : topological_space (measurable_space.dynkin_system (semiring unsigned))) : normal_space (measurable_space.dynkin_system (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_69797 (h0 : monoid (has_to_string (has_neg pos))) : monoid.fg (has_to_string (has_neg pos)) := sorry --non-trivial
lemma new_lemma_69798 (h0 : add_group (has_norm (has_norm to_additive.value_type))) : is_add_cyclic (has_norm (has_norm to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_69799 (h0 : group (ordered_comm_ring (ordered_comm_monoid (has_neg real)))) : normalizer_condition (ordered_comm_ring (ordered_comm_monoid (has_neg real))) := sorry --non-trivial
lemma new_lemma_69800 (h0 : add_group (normed_comm_ring (finset linarith.comp))) : is_add_cyclic (normed_comm_ring (finset linarith.comp)) := sorry --non-trivial
lemma new_lemma_69801 (h0 h1 : multiset (add_comm_semigroup (mul_one_class environment.projection_info))) : multiset.subset h0 h1 := sorry --non-trivial
lemma new_lemma_69802 (h0 h1 : multiset (non_unital_non_assoc_semiring (mul_one_class (metric_space char)))) : multiset.disjoint h0 h1 := sorry --non-trivial
lemma new_lemma_69803 (h0 : complete_lattice (has_norm (random_gen (has_norm (has_norm congr_arg_kind))))) : is_compactly_generated (has_norm (random_gen (has_norm (has_norm congr_arg_kind)))) := sorry --non-trivial
lemma new_lemma_69804 (h0 : group (ordered_comm_monoid name)) : is_cyclic (ordered_comm_monoid name) := sorry --non-trivial
lemma new_lemma_69805 (h0 : topological_space (add_comm_semigroup (mul_one_class char))) : totally_disconnected_space (add_comm_semigroup (mul_one_class char)) := sorry --non-trivial
lemma new_lemma_69806 (h0 : functor.add_const (ring (semigroup pos)) Type) : @is_domain.{0} (semigroup.{0} pos) (@functor.add_const.run.{0 1} (ring.{0} (semigroup.{0} pos)) Type h0)  := sorry --non-trivial
lemma new_lemma_69807 (h0 : not (complete_lattice (with_bot empty) -> false)) : @complete_lattice.is_Sup_finite_compact.{0} (with_bot.{0} empty) (@classical.by_contradiction'.{1} (complete_lattice.{0} (with_bot.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_69808 (h0 : list (has_inv (normed_group string_imp))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_69809 (h0 : complete_lattice (comm_ring (random_gen (random_gen (random_gen char))))) : is_compactly_generated (comm_ring (random_gen (random_gen (random_gen char)))) := sorry --non-trivial
lemma new_lemma_69810 (h0 : cancel_comm_monoid_with_zero (has_pos_part (has_pos_part (ring (has_neg Type))))) : unique_factorization_monoid (has_pos_part (has_pos_part (ring (has_neg Type)))) := sorry --non-trivial
lemma new_lemma_69811 (h0 : semiring (comm_semigroup (comm_semigroup (has_pos_part real)))) : is_noetherian_ring (comm_semigroup (comm_semigroup (has_pos_part real))) := sorry --non-trivial
lemma new_lemma_69812 (h0 : ring (semigroup (has_to_string pos))) : is_principal_ideal_ring (semigroup (has_to_string pos)) := sorry --non-trivial
lemma new_lemma_69813 (h1 : ring (mul_one_class (normed_field environment.projection_info))) : is_domain (mul_one_class (normed_field environment.projection_info)) := sorry --non-trivial
lemma new_lemma_69814 (h0 : ring (normed_lattice_add_comm_group (has_neg pos))) : strong_rank_condition (normed_lattice_add_comm_group (has_neg pos)) := sorry --non-trivial
lemma new_lemma_69815 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_domain.{0} (distrib_lattice.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (distrib_lattice.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_69816 (h0 : has_lt (linear_ordered_comm_group_with_zero to_additive.value_type)) : no_max_order (linear_ordered_comm_group_with_zero to_additive.value_type) := sorry --non-trivial
lemma new_lemma_69817 (h0 : functor.add_const (uniform_space (add_cancel_monoid linarith.comp)) linarith.comp) : @complete_space.{0} (add_cancel_monoid.{0} linarith.comp) (@functor.add_const.run.{0 0} (uniform_space.{0} (add_cancel_monoid.{0} linarith.comp)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_69818 (h0 : group (ordered_comm_ring (sub_neg_monoid pos))) : is_simple_group (ordered_comm_ring (sub_neg_monoid pos)) := sorry --non-trivial
lemma new_lemma_69819 (h0 : functor.add_const (topological_space (linear_ordered_field name)) Type) : @loc_path_connected_space.{0} (linear_ordered_field.{0} name) (@functor.add_const.run.{0 1} (topological_space.{0} (linear_ordered_field.{0} name)) Type h0)  := sorry --non-trivial
lemma new_lemma_69820 (h0 : ring (boolean_algebra (has_to_string name))) : is_domain (boolean_algebra (has_to_string name)) := sorry --non-trivial
lemma new_lemma_69821 (h0 : functor.add_const (complete_lattice (measure_theory.measure_space num)) empty) : @is_atomistic.{0} (measure_theory.measure_space.{0} num) (@functor.add_const.run.{0 0} (complete_lattice.{0} (measure_theory.measure_space.{0} num)) empty h0)  := sorry --non-trivial
lemma new_lemma_69822 (h0 : cancel_comm_monoid_with_zero (partial_order (semiring (semiring empty)))) : unique_factorization_monoid (partial_order (semiring (semiring empty))) := sorry --non-trivial
lemma new_lemma_69823 (h0 : list (normed_linear_ordered_group unsigned)) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_69824 (h0 : functor.add_const (ring (boolean_algebra pos)) (boolean_algebra name)) : @rank_condition.{0} (boolean_algebra.{0} pos) (@functor.add_const.run.{0 0} (ring.{0} (boolean_algebra.{0} pos)) (boolean_algebra.{0} name) h0)  := sorry --non-trivial
lemma new_lemma_69825 (h0 : ring (complete_semilattice_Sup (semiring num))) : rank_condition (complete_semilattice_Sup (semiring num)) := sorry --non-trivial
lemma new_lemma_69826 (h0 : not (complete_lattice (has_ssubset fun_info) -> false)) : @is_compactly_generated.{0} (has_ssubset.{0} fun_info) (@classical.by_contradiction'.{1} (complete_lattice.{0} (has_ssubset.{0} fun_info)) h0)  := sorry --non-trivial
lemma new_lemma_69827 (h0 : functor.add_const (monoid (cancel_monoid congr_arg_kind)) empty) : @monoid.fg.{0} (cancel_monoid.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (monoid.{0} (cancel_monoid.{0} congr_arg_kind)) empty h0)  := sorry --non-trivial
lemma new_lemma_69828 (h0 : topological_space (has_nndist (finset (finset (finset pos))))) : irreducible_space (has_nndist (finset (finset (finset pos)))) := sorry --non-trivial
lemma new_lemma_69829 (h0 : semiring (has_nnnorm enat)) (h1 : ideal (has_nnnorm enat)) : ideal.is_prime h1 := sorry --non-trivial
lemma new_lemma_69830 (h0 : topological_space (generalized_boolean_algebra (has_Inf (has_Inf pos)))) : regular_space (generalized_boolean_algebra (has_Inf (has_Inf pos))) := sorry --non-trivial
lemma new_lemma_69831 (h0 : function.extfun (nat -> Type) (function.extfun nat)) : @is_compactly_generated.{1} (canonically_ordered_monoid.{1} Type) (@matrix.vec_empty.{1} (complete_lattice.{1} (canonically_ordered_monoid.{1} Type)) (@function.extfun_app.{1 1} nat fin (@function.extfun_app.{2 1} (nat → Type) (function.extfun.{1 1} nat) h0 fin) (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_69832 (h0 : ring (has_nndist (finset (has_zero linarith.comp)))) : is_domain (has_nndist (finset (has_zero linarith.comp))) := sorry --non-trivial
lemma new_lemma_69833 (h0 : functor.add_const (function.extfun (Type 1) topological_space) Type) : @totally_disconnected_space.{1} (ring.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@functor.add_const.run.{2 1} (function.extfun.{3 2} (Type 1) topological_space.{1}) Type h0) (ring.{1} Type))  := sorry --non-trivial
lemma new_lemma_69834 (h0 : functor.comp ring has_add ennreal) : @strong_rank_condition.{0} (has_add.{0} ennreal) (@functor.comp.run.{0 0 0} ring.{0} has_add.{0} ennreal h0)  := sorry --non-trivial
lemma new_lemma_69835 (h0 : functor.add_const (monoid (boolean_algebra.core linarith.comp)) pos) : @monoid.fg.{0} (boolean_algebra.core.{0} linarith.comp) (@functor.add_const.run.{0 0} (monoid.{0} (boolean_algebra.core.{0} linarith.comp)) pos h0)  := sorry --non-trivial
lemma new_lemma_69836 (h0 : functor.add_const (function.extfun (Type 1) uniform_space) (has_nndist linarith.comp)) : @complete_space.{1} (generalized_boolean_algebra.{1} Type) (@function.extfun_app.{3 2} (Type 1) uniform_space.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) uniform_space.{1}) (has_nndist.{0} linarith.comp) h0) (generalized_boolean_algebra.{1} Type))  := sorry --non-trivial
lemma new_lemma_69837 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @irreducible_space.{0} (linear_ordered_comm_group.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (linear_ordered_comm_group.{0} empty))  := sorry --non-trivial
lemma new_lemma_69838 (h0 : not (uniform_space (non_assoc_semiring unsigned) -> false)) : @complete_space.{0} (non_assoc_semiring.{0} unsigned) (@classical.by_contradiction'.{1} (uniform_space.{0} (non_assoc_semiring.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_69839 (h0 : not (topological_space (has_top to_additive.value_type) -> false)) : @path_connected_space.{0} (has_top.{0} to_additive.value_type) (@classical.by_contradiction'.{1} (topological_space.{0} (has_top.{0} to_additive.value_type)) h0)  := sorry --non-trivial
lemma new_lemma_69840 (h0 : functor.add_const (group (option ennreal)) (option (option (option ennreal)))) : @is_cyclic.{0} (option.{0} ennreal) (@functor.add_const.run.{0 0} (group.{0} (option.{0} ennreal)) (option.{0} (option.{0} (option.{0} ennreal))) h0)  := sorry --non-trivial
lemma new_lemma_69841 (h0 : ring (denumerable (has_nnnorm linarith.comp_source))) : rank_condition (denumerable (has_nnnorm linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_69842 (h0 : functor.add_const (topological_space (finset name)) (finset pos)) : @totally_separated_space.{0} (finset.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (finset.{0} name)) (finset.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_69843 (h0 : monoid (semigroup (has_add pos))) : monoid.fg (semigroup (has_add pos)) := sorry --non-trivial
lemma new_lemma_69844 (h0 : functor.add_const (ordered_comm_monoid (normed_comm_ring pos)) linarith.comp) : @has_exists_mul_of_le.{0} (normed_comm_ring.{0} pos) (@functor.add_const.run.{0 0} (ordered_comm_monoid.{0} (normed_comm_ring.{0} pos)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_69845 (h1 : function.extfun (Type -> Type) (function.extfun Type)) : @normalizer_condition.{0} linarith.comp_source (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h1 group.{0}) linarith.comp_source)  := sorry --non-trivial
lemma new_lemma_69846 (h0 : function.extfun Type topological_space) : @topological_space.separable_space.{0} (filter.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (filter.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_69847 (h0 : topological_space (has_nnnorm char)) : totally_disconnected_space (has_nnnorm char) := sorry --non-trivial
lemma new_lemma_69848 (h1 : has_le (has_lt linarith.comp_source)) (h2 : bounded_order (has_lt linarith.comp_source)) : is_simple_order (has_lt linarith.comp_source) := sorry --non-trivial
lemma new_lemma_69849 (h0 : topological_space (has_pos_part reducibility_hints)) : totally_disconnected_space (has_pos_part reducibility_hints) := sorry --non-trivial
lemma new_lemma_69850 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @strong_rank_condition.{0} (measurable_space.{0} unsigned) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (measurable_space.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_69851 (h0 : add_group (normed_field (random_gen (mul_one_class string.iterator_imp)))) : is_add_cyclic (normed_field (random_gen (mul_one_class string.iterator_imp))) := sorry --non-trivial
lemma new_lemma_69852 (h0 : functor.comp complete_lattice has_to_string Type) : @complete_lattice.is_Sup_finite_compact.{1} (has_to_string.{1} Type) (@functor.comp.run.{1 1 1} complete_lattice.{1} has_to_string.{1} Type h0)  := sorry --non-trivial
lemma new_lemma_69853 (h0 : ring (semigroup empty)) : rank_condition (semigroup empty) := sorry --non-trivial
lemma new_lemma_69854 (h0 : ring (as_linear_order empty)) : is_principal_ideal_ring (as_linear_order empty) := sorry --non-trivial
lemma new_lemma_69855 (h0 : not (topological_space (dlist linarith.ineq) -> false)) : @totally_disconnected_space.{0} (dlist.{0} linarith.ineq) (@classical.by_contradiction'.{1} (topological_space.{0} (dlist.{0} linarith.ineq)) h0)  := sorry --non-trivial
lemma new_lemma_69856 (h0 : function.extfun (finset (Type -> Type)) (has_mem.mem ring)) : @strong_rank_condition.{0} real.angle (@function.extfun_app.{2 1} Type ring.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) ring.{0} (@function.extfun_app.{2 0} (finset.{1} (Type → Type)) (@has_mem.mem.{1 1} (Type → Type) (finset.{1} (Type → Type)) (@finset.has_mem.{1} (Type → Type)) ring.{0}) h0 (@has_emptyc.emptyc.{1} (finset.{1} (Type → Type)) (@finset.has_emptyc.{1} (Type → Type))))) real.angle)  := sorry --non-trivial
lemma new_lemma_69857 (h0 : functor.add_const (function.extfun Type topological_space) pos) : @normal_space.{0} (finset.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) pos h0) (finset.{0} pos))  := sorry --non-trivial
lemma new_lemma_69858 (h0 : uniform_space (semiring (semiring (semiring empty)))) : complete_space (semiring (semiring (semiring empty))) := sorry --non-trivial
lemma new_lemma_69859 (h0 : function.extfun Type topological_space) : @path_connected_space.{0} pos (@function.extfun_app.{2 1} Type topological_space.{0} h0 pos)  := sorry --non-trivial
lemma new_lemma_69860 (h0 : filter (cancel_monoid (has_add (add_comm_monoid Type)))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_69861 (h0 : function.extfun (finset Type) (has_mem.mem (metric_space num))) : @strong_rank_condition.{0} (metric_space.{0} num) (@finset.pi.empty.{1 0} Type ring.{0} (metric_space.{0} num) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (metric_space.{0} num)) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_69862 (h0 : topological_space (ordered_comm_monoid (has_add name))) : preconnected_space (ordered_comm_monoid (has_add name)) := sorry --non-trivial
lemma new_lemma_69863 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @normal_space.{0} (simple_graph.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (simple_graph.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_69864 (h0 : functor.add_const (ring (has_pos_part Type)) linarith.comp) : @strong_rank_condition.{1} (has_pos_part.{1} Type) (@functor.add_const.run.{1 0} (ring.{1} (has_pos_part.{1} Type)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_69865 (h0 : functor.add_const (finset (complete_distrib_lattice name)) linarith.comp) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_69866 (h0 : add_monoid (ring (has_neg Type))) : add_monoid.fg (ring (has_neg Type)) := sorry --non-trivial
lemma new_lemma_69867 (h0 : add_group (finset (has_to_string Type))) : is_add_cyclic (finset (has_to_string Type)) := sorry --non-trivial
lemma new_lemma_69868 (h0 : functor.add_const (filter (has_zero pos)) (has_neg linarith.comp)) : countable_Inter_filter (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_69869 (h2 : topological_space (complete_semilattice_Sup congr_arg_kind)) : path_connected_space (complete_semilattice_Sup congr_arg_kind) := sorry --non-trivial
lemma new_lemma_69870 (h0 : functor.add_const (complete_lattice (finset name)) name) : @is_compactly_generated.{0} (finset.{0} name) (@functor.add_const.run.{0 0} (complete_lattice.{0} (finset.{0} name)) name h0)  := sorry --non-trivial
lemma new_lemma_69871 (h0 : functor.add_const (group (has_neg environment.implicit_infer_kind)) pos) : @group.fg.{0} (has_neg.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (group.{0} (has_neg.{0} environment.implicit_infer_kind)) pos h0)  := sorry --non-trivial
lemma new_lemma_69872 (h0 : topological_space (has_to_string (has_neg_part name))) : path_connected_space (has_to_string (has_neg_part name)) := sorry --non-trivial
lemma new_lemma_69873 (h0 : function.extfun Type uniform_space) : @complete_space.{0} (simple_graph.{0} empty) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (simple_graph.{0} empty))  := sorry --non-trivial
lemma new_lemma_69874 (h0 : functor.add_const (uniform_space Type) pos) : @complete_space.{1} Type (@functor.add_const.run.{1 0} (uniform_space.{1} Type) pos h0)  := sorry --non-trivial
lemma new_lemma_69875 (h0 : topological_space (boolean_algebra linarith.comp)) : preirreducible_space (boolean_algebra linarith.comp) := sorry --non-trivial
lemma new_lemma_69876 (h0 : complete_lattice (normed_comm_ring (has_neg_part environment.implicit_infer_kind))) : is_compactly_generated (normed_comm_ring (has_neg_part environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_69877 (h0 : ring (add_comm_monoid (has_to_string linarith.comp))) : rank_condition (add_comm_monoid (has_to_string linarith.comp)) := sorry --non-trivial
lemma new_lemma_69878 (h0 : topological_space (measurable_space.dynkin_system linarith.comp)) : preirreducible_space (measurable_space.dynkin_system linarith.comp) := sorry --non-trivial
lemma new_lemma_69879 (h0 : uniform_space (has_one (has_top linarith.comp))) : complete_space (has_one (has_top linarith.comp)) := sorry --non-trivial
lemma new_lemma_69880 (h0 : functor.add_const (topological_space (ring name)) Type) : @locally_compact_space.{0} (ring.{0} name) (@functor.add_const.run.{0 1} (topological_space.{0} (ring.{0} name)) Type h0)  := sorry --non-trivial
lemma new_lemma_69881 (h0 : topological_space (normed_group (random_gen (random_gen fun_info)))) : locally_compact_space (normed_group (random_gen (random_gen fun_info))) := sorry --non-trivial
lemma new_lemma_69882 (h0 : function.extfun Type uniform_space) : @complete_space.{0} (linear_ordered_comm_ring.{0} empty) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (linear_ordered_comm_ring.{0} empty))  := sorry --non-trivial
lemma new_lemma_69883 (h0 : function.extfun ((Type -> Type) -> Type 1) (function.extfun (Type -> Type))) : @topological_space.separable_space.{0} (has_zero.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) (@function.extfun_app.{3 2} ((Type → Type) → Type 1) (function.extfun.{2 2} (Type → Type)) h0 (function.extfun.{2 1} Type)) topological_space.{0}) (has_zero.{0} pos))  := sorry --non-trivial
lemma new_lemma_69884 (h0 : group (canonically_ordered_add_monoid (option (option empty)))) : normalizer_condition (canonically_ordered_add_monoid (option (option empty))) := sorry --non-trivial
lemma new_lemma_69885 (h0 : uniform_space (add_comm_monoid num)) : complete_space (add_comm_monoid num) := sorry --non-trivial
lemma new_lemma_69886 (h1 : not (topological_space (mul_one_class linarith.comp_source) -> false)) : @totally_disconnected_space.{0} (mul_one_class.{0} linarith.comp_source) (@classical.by_contradiction'.{1} (topological_space.{0} (mul_one_class.{0} linarith.comp_source)) h1)  := sorry --non-trivial
lemma new_lemma_69887 (h0 : ring (complete_distrib_lattice (ring linarith.comp))) : strong_rank_condition (complete_distrib_lattice (ring linarith.comp)) := sorry --non-trivial
lemma new_lemma_69888 (h0 : function.extfun Type group) : @is_cyclic.{0} (measurable_space.{0} linarith.comp) (@function.extfun_app.{2 1} Type group.{0} h0 (measurable_space.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_69889 (h0 : ordered_comm_monoid (complete_distrib_lattice (has_Inf (has_add Type)))) : has_exists_mul_of_le (complete_distrib_lattice (has_Inf (has_add Type))) := sorry --non-trivial
lemma new_lemma_69890 (h0 : not (function.extfun Type topological_space -> false)) : @totally_disconnected_space.{0} (has_one.{0} fun_info) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (has_one.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_69891 (h0 : topological_space (semigroup (ring linarith.comp))) : preirreducible_space (semigroup (ring linarith.comp)) := sorry --non-trivial
lemma new_lemma_69892 (h0 : function.extfun Type topological_space) : @locally_compact_space.{0} (has_top.{0} fun_info) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_top.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_69893 (h0 : function.extfun Type topological_space) : @normal_space.{0} (normed_comm_ring.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (normed_comm_ring.{0} empty))  := sorry --non-trivial
lemma new_lemma_69894 (h0 : finset (semigroup (has_neg environment.implicit_infer_kind))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_69895 (h0 : functor.add_const (monoid (finset pos)) environment.implicit_infer_kind) : @monoid.fg.{0} (finset.{0} pos) (@functor.add_const.run.{0 0} (monoid.{0} (finset.{0} pos)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_69896 (h0 : function.extfun Type cancel_comm_monoid_with_zero) : @unique_factorization_monoid.{0} (mul_zero_class.{0} ennreal) (@function.extfun_app.{2 1} Type cancel_comm_monoid_with_zero.{0} h0 (mul_zero_class.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_69897 (h0 : topological_space (omega_complete_partial_order empty)) : preirreducible_space (omega_complete_partial_order empty) := sorry --non-trivial
lemma new_lemma_69898 (h0 : topological_space (has_ssubset (random_gen fun_info))) : locally_compact_space (has_ssubset (random_gen fun_info)) := sorry --non-trivial
lemma new_lemma_69899 (h0 : finset (mul_zero_class (option (option (option (option unsigned)))))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_69900 (h0 : functor.add_const (topological_space (semigroup name)) name) : @t0_space.{0} (semigroup.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (semigroup.{0} name)) name h0)  := sorry --non-trivial
lemma new_lemma_69901 (h0 : ring (finset (has_add (has_Inf name)))) : is_principal_ideal_ring (finset (has_add (has_Inf name))) := sorry --non-trivial
lemma new_lemma_69902 (h0 : set (prod empty empty)) (h1 : prod empty empty) : symmetrize_rel h0 h1 := sorry --non-trivial
lemma new_lemma_69903 (h0 : measurable_space (has_nnnorm (mul_one_class to_additive.value_type))) (h1 : measure_theory.measure (has_nnnorm (mul_one_class to_additive.value_type))) : measure_theory.is_finite_measure h1 := sorry --non-trivial
lemma new_lemma_69904 (h0 : topological_space (generalized_boolean_algebra (sub_neg_monoid real))) : discrete_topology (generalized_boolean_algebra (sub_neg_monoid real)) := sorry --non-trivial
lemma new_lemma_69905 (h0 : group (complete_distrib_lattice (comm_group name))) : is_cyclic (complete_distrib_lattice (comm_group name)) := sorry --non-trivial
lemma new_lemma_69906 (h0 : topological_space (normed_lattice_add_comm_group (has_add (has_add pos)))) : normal_space (normed_lattice_add_comm_group (has_add (has_add pos))) := sorry --non-trivial
lemma new_lemma_69907 (h0 : functor.add_const (functor.add_const (filter environment.implicit_infer_kind) linarith.comp) pos) : countable_Inter_filter (functor.add_const.run (functor.add_const.run h0)) := sorry --non-trivial
lemma new_lemma_69908 (h0 : filter (id (semiring num))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_69909 (h0 : monoid (has_norm fun_info)) : monoid.fg (has_norm fun_info) := sorry --non-trivial
lemma new_lemma_69910 (h0 : monoid (semigroup environment.implicit_infer_kind)) : monoid.fg (semigroup environment.implicit_infer_kind) := sorry --non-trivial
lemma new_lemma_69911 (h0 : functor.add_const (monoid (boolean_algebra Type)) (has_Inf (has_Inf linarith.comp))) : @monoid.fg.{1} (boolean_algebra.{1} Type) (@functor.add_const.run.{1 0} (monoid.{1} (boolean_algebra.{1} Type)) (has_Inf.{0} (has_Inf.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_69912 (h0 h1 : Prop) : and h0 h1 := sorry --non-trivial
lemma new_lemma_69913 (h0 : uniform_space (has_nndist (has_add name))) : complete_space (has_nndist (has_add name)) := sorry --non-trivial
lemma new_lemma_69914 (h0 : topological_space (has_norm unsigned)) : normal_space (has_norm unsigned) := sorry --non-trivial
lemma new_lemma_69915 (h0 : functor.add_const (ring (has_pos_part linarith.comp)) linarith.comp) : @is_domain.{0} (has_pos_part.{0} linarith.comp) (@functor.add_const.run.{0 0} (ring.{0} (has_pos_part.{0} linarith.comp)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_69916 (h0 : group (cancel_monoid (comm_group pos))) : normalizer_condition (cancel_monoid (comm_group pos)) := sorry --non-trivial
lemma new_lemma_69917 (h0 : topological_space (generalized_boolean_algebra (has_neg (has_neg name)))) : topological_space.separable_space (generalized_boolean_algebra (has_neg (has_neg name))) := sorry --non-trivial
lemma new_lemma_69918 (h0 : functor.add_const (group (add_left_cancel_semigroup empty)) empty) : @group.fg.{0} (add_left_cancel_semigroup.{0} empty) (@functor.add_const.run.{0 0} (group.{0} (add_left_cancel_semigroup.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_69919 (h0 : ring (has_union (semiring (semiring congr_arg_kind)))) : rank_condition (has_union (semiring (semiring congr_arg_kind))) := sorry --non-trivial
lemma new_lemma_69920 (h0 : not (complete_lattice (has_nnnorm linarith.ineq) -> false)) : @complete_lattice.is_Sup_finite_compact.{0} (has_nnnorm.{0} linarith.ineq) (@classical.by_contradiction'.{1} (complete_lattice.{0} (has_nnnorm.{0} linarith.ineq)) h0)  := sorry --non-trivial
lemma new_lemma_69921 (h0 : functor.add_const (topological_space (finset pos)) (finset (has_neg pos))) : @locally_compact_space.{0} (finset.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (finset.{0} pos)) (finset.{0} (has_neg.{0} pos)) h0)  := sorry --non-trivial
lemma new_lemma_69922 (h2 : ring (denumerable to_additive.value_type)) : is_domain (denumerable to_additive.value_type) := sorry --non-trivial
lemma new_lemma_69923 (h0 : function.extfun Type ring) : @is_domain.{0} (has_sub.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type ring.{0} h0 (has_sub.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_69924 (h0 : list (add_comm_monoid (normed_comm_ring (boolean_algebra Type)))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_69925 (h0 : topological_space (option (option ennreal))) : normal_space (option (option ennreal)) := sorry --non-trivial
lemma new_lemma_69926 (h0 : function.extfun Type group) : @normalizer_condition.{0} (preorder.{0} unsigned) (@function.extfun_app.{2 1} Type group.{0} h0 (preorder.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_69927 (h0 : function.extfun Type list) : list.nodup (function.extfun_app h0 (distrib_lattice fun_info)) := sorry --non-trivial
lemma new_lemma_69928 (h0 : functor.add_const (ordered_add_comm_monoid (has_nndist Type)) environment.implicit_infer_kind) : @archimedean.{1} (has_nndist.{1} Type) (@functor.add_const.run.{1 0} (ordered_add_comm_monoid.{1} (has_nndist.{1} Type)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_69929 (h0 : topological_space (mul_zero_class (finset name))) : locally_compact_space (mul_zero_class (finset name)) := sorry --non-trivial
lemma new_lemma_69930 (h0 : not (function.extfun Type topological_space -> false)) : @totally_separated_space.{0} (random_gen.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (random_gen.{0} empty))  := sorry --non-trivial
lemma new_lemma_69931 (h0 : topological_space (linear_ordered_semiring (has_norm congr_arg_kind))) : t0_space (linear_ordered_semiring (has_norm congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_69932 (h0 : complete_lattice (has_top (semiring congr_arg_kind))) : complete_lattice.is_Sup_finite_compact (has_top (semiring congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_69933 (h0 : filter (normed_comm_ring (finset pos))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_69934 (h0 : functor.add_const (function.extfun Type topological_space) (finset pos)) : @preconnected_space.{0} (normed_comm_ring.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) (finset.{0} pos) h0) (normed_comm_ring.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_69935 (h0 : fin has_zero.zero) : @preirreducible_space.{0} (sub_neg_monoid.{0} real) (@matrix.vec_empty.{0} (topological_space.{0} (sub_neg_monoid.{0} real)) h0)  := sorry --non-trivial
lemma new_lemma_69936 (h0 : functor.add_const (list (has_nndist pos)) environment.implicit_infer_kind) : palindrome (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_69937 (h0 : functor.add_const (complete_lattice (has_neg_part pos)) ennreal) : @is_compactly_generated.{0} (has_neg_part.{0} pos) (@functor.add_const.run.{0 0} (complete_lattice.{0} (has_neg_part.{0} pos)) ennreal h0)  := sorry --non-trivial
lemma new_lemma_69938 (h0 : topological_space (linear_ordered_add_comm_group (random_gen linarith.ineq))) : t0_space (linear_ordered_add_comm_group (random_gen linarith.ineq)) := sorry --non-trivial
lemma new_lemma_69939 (h0 : not (uniform_space (id linarith.ineq) -> false)) : @complete_space.{0} (@id.{2} Type linarith.ineq) (@classical.by_contradiction'.{1} (uniform_space.{0} (@id.{2} Type linarith.ineq)) h0)  := sorry --non-trivial
lemma new_lemma_69940 (h0 : topological_space (ordered_comm_monoid (ring (has_add linarith.comp)))) : sequential_space (ordered_comm_monoid (ring (has_add linarith.comp))) := sorry --non-trivial
lemma new_lemma_69941 (h0 : not (has_mem.mem uniform_space has_emptyc.emptyc -> false)) : @separated_space.{0} (with_bot.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type uniform_space.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) uniform_space.{0} (@classical.by_contradiction'.{0} (@has_mem.mem.{1 1} (Type → Type) (finset.{1} (Type → Type)) (@finset.has_mem.{1} (Type → Type)) uniform_space.{0} (@has_emptyc.emptyc.{1} (finset.{1} (Type → Type)) (@finset.has_emptyc.{1} (Type → Type)))) h0)) (with_bot.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_69942 (h0 : functor.add_const (uniform_space (semigroup name)) environment.implicit_infer_kind) : @complete_space.{0} (semigroup.{0} name) (@functor.add_const.run.{0 0} (uniform_space.{0} (semigroup.{0} name)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_69943 (h0 : add_group (random_gen (random_gen (pseudo_emetric_space fun_info)))) : is_add_cyclic (random_gen (random_gen (pseudo_emetric_space fun_info))) := sorry --non-trivial
lemma new_lemma_69944 (h0 : functor.add_const (topological_space (ring pos)) Type) : @t1_space.{0} (ring.{0} pos) (@functor.add_const.run.{0 1} (topological_space.{0} (ring.{0} pos)) Type h0)  := sorry --non-trivial
lemma new_lemma_69945 (h0 : ring (has_compl (random_gen to_additive.value_type))) : strong_rank_condition (has_compl (random_gen to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_69946 (h0 : function.extfun nat fin) : @t1_space.{0} (normed_lattice_add_comm_group.{0} real) (@function.extfun_app.{2 1} Type topological_space.{0} (@matrix.vec_empty.{1} (function.extfun.{2 1} Type topological_space.{0}) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero))) (normed_lattice_add_comm_group.{0} real))  := sorry --non-trivial
lemma new_lemma_69947 (h0 : functor.add_const (uniform_space (mul_zero_class empty)) congr_arg_kind) : @separated_space.{0} (mul_zero_class.{0} empty) (@functor.add_const.run.{0 0} (uniform_space.{0} (mul_zero_class.{0} empty)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_69948 (h1 : topological_space (semi_normed_comm_ring char)) : t0_space (semi_normed_comm_ring char) := sorry --non-trivial
lemma new_lemma_69949 (h0 : ring (has_append (random_gen (random_gen char)))) : strong_rank_condition (has_append (random_gen (random_gen char))) := sorry --non-trivial
lemma new_lemma_69950 (h0 : functor.add_const (complete_lattice (semigroup unsigned)) empty) : @complete_lattice.is_Sup_finite_compact.{0} (semigroup.{0} unsigned) (@functor.add_const.run.{0 0} (complete_lattice.{0} (semigroup.{0} unsigned)) empty h0)  := sorry --non-trivial
lemma new_lemma_69951 (h0 : function.extfun Type (functor.add_const (topological_space pos))) : @discrete_topology.{0} pos (@functor.add_const.run.{0 0} (topological_space.{0} pos) pos (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (topological_space.{0} pos)) h0 pos))  := sorry --non-trivial
lemma new_lemma_69952 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @t1_space.{0} (finset.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (finset.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_69953 (h2 : has_mem.mem (complete_semilattice_Sup linarith.comp) has_emptyc.emptyc) : @complete_space.{0} (complete_semilattice_Sup.{0} linarith.comp) (@finset.pi.empty.{1 0} Type uniform_space.{0} (complete_semilattice_Sup.{0} linarith.comp) h2)  := sorry --non-trivial
lemma new_lemma_69954 (h0 : complete_lattice (with_bot (semiring (has_norm empty)))) : is_atomistic (with_bot (semiring (has_norm empty))) := sorry --non-trivial
lemma new_lemma_69955 (h0 : topological_space (ordered_comm_ring pos)) : irreducible_space (ordered_comm_ring pos) := sorry --non-trivial
lemma new_lemma_69956 (h0 : fin has_zero.zero) : @is_cyclic.{0} real (@functor.add_const.run.{0 0} (group.{0} real) real (@matrix.vec_empty.{0} (functor.add_const.{0 0} (group.{0} real) real) (@function.extfun_app.{1 1} nat fin (@matrix.vec_empty.{0} (function.extfun.{1 1} nat fin) h0) (@has_zero.zero.{0} nat nat.has_zero))))  := sorry --non-trivial
lemma new_lemma_69957 (h0 : finset (monoid num)) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_69958 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_compactly_generated.{0} (has_neg.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (has_neg.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_69959 (h0 : has_mem.mem (has_emptyc num) has_emptyc.emptyc) : @irreducible_space.{0} (has_emptyc.{0} num) (@finset.pi.empty.{1 0} Type topological_space.{0} (has_emptyc.{0} num) h0)  := sorry --non-trivial
lemma new_lemma_69960 (h6 : semiring string.iterator_imp) (h7 : ideal string.iterator_imp) : ideal.is_prime h7 := sorry --non-trivial
lemma new_lemma_69961 (h0 : topological_space (canonically_ordered_comm_semiring (has_add (comm_group unsigned)))) : t1_space (canonically_ordered_comm_semiring (has_add (comm_group unsigned))) := sorry --non-trivial
lemma new_lemma_69962 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @regular_space.{0} (add_comm_monoid.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (add_comm_monoid.{0} name))  := sorry --non-trivial
lemma new_lemma_69963 (h0 : std_gen -> Prop) (h1 : derive_fintype.finset_in h0 -> derive_fintype.finset_in h0 -> Prop) : is_total (derive_fintype.finset_in h0) h1 := sorry --non-trivial
lemma new_lemma_69964 (h0 : finset (cancel_monoid environment.implicit_infer_kind)) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_69965 (h0 : not (function.extfun Type complete_lattice -> false)) : @is_atomistic.{0} linarith.ineq (@function.extfun_app.{2 1} Type complete_lattice.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type complete_lattice.{0}) h0) linarith.ineq)  := sorry --non-trivial
lemma new_lemma_69966 (h0 : add_group (normed_group (random_gen (comm_ring fun_info)))) : is_add_cyclic (normed_group (random_gen (comm_ring fun_info))) := sorry --non-trivial
lemma new_lemma_69967 (h0 : has_mem.mem (has_norm num) has_emptyc.emptyc) : @group.fg.{0} (has_norm.{0} num) (@finset.pi.empty.{1 0} Type group.{0} (has_norm.{0} num) h0)  := sorry --non-trivial
lemma new_lemma_69968 (h0 : group (option (cancel_monoid (option (comm_group (option pos)))))) : is_cyclic (option (cancel_monoid (option (comm_group (option pos))))) := sorry --non-trivial
lemma new_lemma_69969 (h0 : has_mem.mem (normed_group linarith.comp_source) has_emptyc.emptyc) : @is_domain.{0} (normed_group.{0} linarith.comp_source) (@finset.pi.empty.{1 0} Type ring.{0} (normed_group.{0} linarith.comp_source) h0)  := sorry --non-trivial
lemma new_lemma_69970 (h0 : ring (ordered_comm_ring (has_neg (has_neg Type)))) : is_domain (ordered_comm_ring (has_neg (has_neg Type))) := sorry --non-trivial
lemma new_lemma_69971 (h0 : complete_lattice (finset (has_neg linarith.comp))) : is_compactly_generated (finset (has_neg linarith.comp)) := sorry --non-trivial
lemma new_lemma_69972 (h0 : topological_space (has_bot (has_pos_part real))) : regular_space (has_bot (has_pos_part real)) := sorry --non-trivial
lemma new_lemma_69973 (h0 : functor.add_const (topological_space (finset Type)) name) : @totally_separated_space.{1} (finset.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (finset.{1} Type)) name h0)  := sorry --non-trivial
lemma new_lemma_69974 (h0 : functor.add_const (functor.add_const Prop (complete_distrib_lattice pos)) linarith.comp) : functor.add_const.run (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_69975 (h0 : uniform_space (normed_lattice_add_comm_group (has_Inf (has_Inf real)))) : complete_space (normed_lattice_add_comm_group (has_Inf (has_Inf real))) := sorry --non-trivial
lemma new_lemma_69976 (h0 : list (boolean_algebra.core (cancel_monoid name))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_69977 (h0 : not (function.extfun Type topological_space -> false)) : @irreducible_space.{0} string_imp (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) string_imp)  := sorry --non-trivial
lemma new_lemma_69978 (h0 : topological_space (semiring unsigned)) : t0_space (semiring unsigned) := sorry --non-trivial
lemma new_lemma_69979 (h1 : set (nondiscrete_normed_field enat)) : set.finite h1 := sorry --non-trivial
lemma new_lemma_69980 (h0 : function.extfun Type (functor.add_const (ring (has_Sup num)))) : @is_principal_ideal_ring.{0} (has_Sup.{0} num) (@functor.add_const.run.{0 0} (ring.{0} (has_Sup.{0} num)) empty (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (ring.{0} (has_Sup.{0} num))) h0 empty))  := sorry --non-trivial
lemma new_lemma_69981 (h0 : uniform_space (has_norm linarith.comp)) : complete_space (has_norm linarith.comp) := sorry --non-trivial
lemma new_lemma_69982 (h0 : topological_space (has_nndist (has_add Type))) : t1_space (has_nndist (has_add Type)) := sorry --non-trivial
lemma new_lemma_69983 (h0 : functor.add_const (ring (complete_linear_order num)) (semiring num)) : @is_principal_ideal_ring.{0} (complete_linear_order.{0} num) (@functor.add_const.run.{0 0} (ring.{0} (complete_linear_order.{0} num)) (semiring.{0} num) h0)  := sorry --non-trivial
lemma new_lemma_69984 (h0 : complete_lattice (distrib reducibility_hints)) : is_compactly_generated (distrib reducibility_hints) := sorry --non-trivial
lemma new_lemma_69985 (h0 : ring (has_dist (option (option unsigned)))) : is_domain (has_dist (option (option unsigned))) := sorry --non-trivial
lemma new_lemma_69986 (h0 : add_group (simple_graph (ring (ring linarith.comp)))) : is_add_cyclic (simple_graph (ring (ring linarith.comp))) := sorry --non-trivial
lemma new_lemma_69987 (h0 : topological_space (has_Sup congr_arg_kind)) : totally_disconnected_space (has_Sup congr_arg_kind) := sorry --non-trivial
lemma new_lemma_69988 (h0 : monoid (has_zero (has_add (mul_one_class pos)))) : monoid.fg (has_zero (has_add (mul_one_class pos))) := sorry --non-trivial
lemma new_lemma_69989 (h0 : functor.add_const (topological_space (has_neg linarith.comp)) pos) : @sequential_space.{0} (has_neg.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (has_neg.{0} linarith.comp)) pos h0)  := sorry --non-trivial
lemma new_lemma_69990 (h0 : functor.add_const (topological_space (has_neg name)) environment.implicit_infer_kind) : @topological_space.separable_space.{0} (has_neg.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (has_neg.{0} name)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_69991 (h0 : function.extfun Type complete_lattice) : @is_compactly_generated.{0} (complete_distrib_lattice.{0} (option.{0} ennreal)) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (complete_distrib_lattice.{0} (option.{0} ennreal)))  := sorry --non-trivial
lemma new_lemma_69992 (h0 : topological_space (has_add (has_neg (sub_neg_monoid real)))) : loc_path_connected_space (has_add (has_neg (sub_neg_monoid real))) := sorry --non-trivial
lemma new_lemma_69993 (h0 : finset (normed_linear_ordered_group empty)) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_69994 (h0 : group (linear_ordered_add_comm_group num)) : is_cyclic (linear_ordered_add_comm_group num) := sorry --non-trivial
lemma new_lemma_69995 (h0 : uniform_space (has_append char)) : complete_space (has_append char) := sorry --non-trivial
lemma new_lemma_69996 (h0 : group (has_inter unsigned)) : is_cyclic (has_inter unsigned) := sorry --non-trivial
lemma new_lemma_69997 (h0 : has_mem.mem (with_bot (has_top unsigned)) has_emptyc.emptyc) : @totally_disconnected_space.{0} (with_bot.{0} (has_top.{0} unsigned)) (@finset.pi.empty.{1 0} Type topological_space.{0} (with_bot.{0} (has_top.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_69998 (h0 : not (uniform_space (id num) -> false)) : @separated_space.{0} (@id.{2} Type num) (@classical.by_contradiction'.{1} (uniform_space.{0} (@id.{2} Type num)) h0)  := sorry --non-trivial
lemma new_lemma_69999 (h0 : ring (comm_ring (random_gen fun_info))) : rank_condition (comm_ring (random_gen fun_info)) := sorry --non-trivial
lemma new_lemma_70000 (h0 : has_mem.mem multiset has_emptyc.emptyc) : @multiset.inf.{0} Prop (@lattice.to_semilattice_inf.{0} Prop (@conditionally_complete_lattice.to_lattice.{0} Prop (@complete_lattice.to_conditionally_complete_lattice.{0} Prop Prop.complete_lattice))) (@bounded_order.to_order_top.{0} Prop (@preorder.to_has_le.{0} Prop (@partial_order.to_preorder.{0} Prop (@semilattice_inf.to_partial_order.{0} Prop (@lattice.to_semilattice_inf.{0} Prop (@conditionally_complete_lattice.to_lattice.{0} Prop (@complete_lattice.to_conditionally_complete_lattice.{0} Prop Prop.complete_lattice)))))) Prop.bounded_order) (@function.extfun_app.{2 1} Type multiset.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) multiset.{0} h0) Prop)  := sorry --non-trivial
lemma new_lemma_70001 (h0 : topological_space (has_bot congr_arg_kind)) : t0_space (has_bot congr_arg_kind) := sorry --non-trivial
lemma new_lemma_70002 (h0 : topological_space (has_div fun_info)) (h1 : preorder (has_div fun_info)) : order_topology (has_div fun_info) := sorry --non-trivial
lemma new_lemma_70003 (h0 : function.extfun Type (functor.add_const (group znum))) : @normalizer_condition.{0} znum (@functor.add_const.run.{0 0} (group.{0} znum) num (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (group.{0} znum)) h0 num))  := sorry --non-trivial
lemma new_lemma_70004 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_cyclic.{0} (measurable_space.{0} empty) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (measurable_space.{0} empty))  := sorry --non-trivial
lemma new_lemma_70005 (h0 : complete_lattice (has_pos_part (sub_neg_monoid real))) : complete_lattice.is_Sup_finite_compact (has_pos_part (sub_neg_monoid real)) := sorry --non-trivial
lemma new_lemma_70006 (h0 : ring (ordered_comm_ring (ring linarith.comp))) : is_domain (ordered_comm_ring (ring linarith.comp)) := sorry --non-trivial
lemma new_lemma_70007 (h1 : not (ring (random_gen linarith.comp_source) -> false)) : @strong_rank_condition.{0} (random_gen.{0} linarith.comp_source) (@classical.by_contradiction'.{1} (ring.{0} (random_gen.{0} linarith.comp_source)) h1)  := sorry --non-trivial
lemma new_lemma_70008 (h0 : add_monoid (has_top (random_gen (has_one (has_one empty))))) : add_monoid.fg (has_top (random_gen (has_one (has_one empty)))) := sorry --non-trivial
lemma new_lemma_70009 (h0 : topological_space (complete_distrib_lattice pos)) : preirreducible_space (complete_distrib_lattice pos) := sorry --non-trivial
lemma new_lemma_70010 (h0 : function.extfun Type group) : @normalizer_condition.{0} (add_comm_monoid.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type group.{0} h0 (add_comm_monoid.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_70011 (h0 : ordered_comm_monoid (finset (finset (has_to_string pos)))) : has_exists_mul_of_le (finset (finset (has_to_string pos))) := sorry --non-trivial
lemma new_lemma_70012 (h0 : finset char) (h1 : char -> Prop) : @finset.sup.{0 0} Prop char (@lattice.to_semilattice_sup.{0} Prop (@conditionally_complete_lattice.to_lattice.{0} Prop (@complete_lattice.to_conditionally_complete_lattice.{0} Prop Prop.complete_lattice))) (@generalized_boolean_algebra.to_order_bot.{0} Prop (@boolean_algebra.to_generalized_boolean_algebra.{0} Prop Prop.boolean_algebra)) h0 (@www_fun.{1 1} char Prop h1)  := sorry --non-trivial
lemma new_lemma_70013 (h0 : topological_space (semiring to_additive.value_type)) : totally_separated_space (semiring to_additive.value_type) := sorry --non-trivial
lemma new_lemma_70014 (h0 : function.extfun Type topological_space) : @totally_disconnected_space.{0} (group_with_zero.{0} ennreal) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (group_with_zero.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_70015 (h0 : functor.add_const (topological_space (normed_comm_ring unsigned)) linarith.comp) : @loc_path_connected_space.{0} (normed_comm_ring.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (normed_comm_ring.{0} unsigned)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_70016 (h0 : ordered_comm_monoid (semigroup (boolean_algebra pos))) : has_exists_mul_of_le (semigroup (boolean_algebra pos)) := sorry --non-trivial
lemma new_lemma_70017 (h0 : ordered_add_comm_monoid (option (mul_zero_class pos))) : archimedean (option (mul_zero_class pos)) := sorry --non-trivial
lemma new_lemma_70018 (h0 : functor.add_const (finset (has_add unsigned)) name) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_70019 (h0 : fin has_zero.zero) : @add_monoid.fg.{0} (comm_semigroup.{0} real) (@matrix.vec_empty.{0} (add_monoid.{0} (comm_semigroup.{0} real)) (@matrix.vec_empty.{0} (fin (@has_zero.zero.{0} nat nat.has_zero)) h0))  := sorry --non-trivial
lemma new_lemma_70020 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_add_cyclic.{0} (ring.{0} linarith.comp) (@function.extfun_app.{2 1} Type add_group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 add_group.{0}) (ring.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_70021 (h0 : functor.add_const (complete_lattice (complete_distrib_lattice ennreal)) num) : @complete_lattice.is_Sup_finite_compact.{0} (complete_distrib_lattice.{0} ennreal) (@functor.add_const.run.{0 0} (complete_lattice.{0} (complete_distrib_lattice.{0} ennreal)) num h0)  := sorry --non-trivial
lemma new_lemma_70022 (h0 : topological_space (partial_order (add_right_cancel_monoid empty))) : totally_disconnected_space (partial_order (add_right_cancel_monoid empty)) := sorry --non-trivial
lemma new_lemma_70023 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @complete_space.{0} (preorder.{0} unsigned) (@function.extfun_app.{2 1} Type uniform_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 uniform_space.{0}) (preorder.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_70024 (h0 : filter (distrib_lattice (random_gen (comm_ring (random_gen linarith.ineq))))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_70025 (h0 : functor.add_const (group (has_pos_part linarith.comp)) (has_neg Type)) : @normalizer_condition.{0} (has_pos_part.{0} linarith.comp) (@functor.add_const.run.{0 1} (group.{0} (has_pos_part.{0} linarith.comp)) (has_neg.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_70026 (h0 : functor.add_const (topological_space (free_add_monoid congr_arg_kind)) num) : @preirreducible_space.{0} (free_add_monoid.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (free_add_monoid.{0} congr_arg_kind)) num h0)  := sorry --non-trivial
lemma new_lemma_70027 (h0 : function.extfun Type add_monoid) : @add_monoid.fg.{0} (has_union.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type add_monoid.{0} h0 (has_union.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_70028 (h0 : topological_space (pseudo_metric_space (option unsigned))) : totally_disconnected_space (pseudo_metric_space (option unsigned)) := sorry --non-trivial
lemma new_lemma_70029 (h0 : ring (uniform_space enat)) : strong_rank_condition (uniform_space enat) := sorry --non-trivial
lemma new_lemma_70030 (h0 : uniform_space (linear_ordered_add_comm_group (has_top (has_inv fun_info)))) : complete_space (linear_ordered_add_comm_group (has_top (has_inv fun_info))) := sorry --non-trivial
lemma new_lemma_70031 (h0 : topological_space (semiring (semiring num))) : irreducible_space (semiring (semiring num)) := sorry --non-trivial
lemma new_lemma_70032 (h0 : functor.add_const (filter (has_add pos)) (option (option unsigned))) : filter.ne_bot (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_70033 (h0 : topological_space (non_assoc_semiring (semiring (semiring unsigned)))) : normal_space (non_assoc_semiring (semiring (semiring unsigned))) := sorry --non-trivial
lemma new_lemma_70034 (h0 : fin has_zero.zero) : @is_cyclic.{0} (comm_semigroup.{0} name) (@matrix.vec_empty.{0} (group.{0} (comm_semigroup.{0} name)) (@matrix.vec_empty.{0} (fin (@has_zero.zero.{0} nat nat.has_zero)) h0))  := sorry --non-trivial
lemma new_lemma_70035 (h0 : ring (has_pos_part (has_Inf Type))) : strong_rank_condition (has_pos_part (has_Inf Type)) := sorry --non-trivial
lemma new_lemma_70036 (h0 : uniform_space (ordered_comm_ring (ring name))) : separated_space (ordered_comm_ring (ring name)) := sorry --non-trivial
lemma new_lemma_70037 (h0 : functor.add_const (topological_space (finset Type)) pos) : @discrete_topology.{1} (finset.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (finset.{1} Type)) pos h0)  := sorry --non-trivial
lemma new_lemma_70038 (h0 : add_group (random_gen (has_norm (has_norm (has_norm fun_info))))) : is_add_cyclic (random_gen (has_norm (has_norm (has_norm fun_info)))) := sorry --non-trivial
lemma new_lemma_70039 (h0 : functor.add_const (ordered_comm_monoid (has_Inf pos)) (has_Inf (has_add Type))) : @has_exists_mul_of_le.{0} (has_Inf.{0} pos) (@functor.add_const.run.{0 1} (ordered_comm_monoid.{0} (has_Inf.{0} pos)) (has_Inf.{1} (has_add.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_70040 (h0 : topological_space (normed_lattice_add_comm_group (has_bot Type))) : sequential_space (normed_lattice_add_comm_group (has_bot Type)) := sorry --non-trivial
lemma new_lemma_70041 (h0 : functor.add_const (topological_space (normed_comm_ring pos)) name) : @discrete_topology.{0} (normed_comm_ring.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (normed_comm_ring.{0} pos)) name h0)  := sorry --non-trivial
lemma new_lemma_70042 (h0 : function.extfun Type topological_space) : @sequential_space.{0} pos (@function.extfun_app.{2 1} Type topological_space.{0} h0 pos)  := sorry --non-trivial
lemma new_lemma_70043 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @preirreducible_space.{0} (complete_distrib_lattice.{0} real) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (complete_distrib_lattice.{0} real))  := sorry --non-trivial
lemma new_lemma_70044 (h0 : functor.add_const (topological_space (finset name)) unsigned) : @totally_disconnected_space.{0} (finset.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (finset.{0} name)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_70045 (h0 : function.extfun Type ring) : @is_principal_ideal_ring.{0} (has_Sup.{0} unsigned) (@function.extfun_app.{2 1} Type ring.{0} h0 (has_Sup.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_70046 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @normal_space.{1} (comm_group.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 topological_space.{1}) (comm_group.{1} Type))  := sorry --non-trivial
lemma new_lemma_70047 (h0 : not (topological_space (with_bot empty) -> false)) : @discrete_topology.{0} (with_bot.{0} empty) (@classical.by_contradiction'.{1} (topological_space.{0} (with_bot.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_70048 (h0 : complete_lattice (has_top (has_norm empty))) : is_atomistic (has_top (has_norm empty)) := sorry --non-trivial
lemma new_lemma_70049 (h0 : function.extfun Type finset) : finset.nonempty (function.extfun_app h0 unsigned) := sorry --non-trivial
lemma new_lemma_70050 (h0 : topological_space (has_union (has_top num))) : totally_disconnected_space (has_union (has_top num)) := sorry --non-trivial
lemma new_lemma_70051 (h0 : group (mul_zero_class (has_nndist ennreal))) : group.fg (mul_zero_class (has_nndist ennreal)) := sorry --non-trivial
lemma new_lemma_70052 (h0 : complete_lattice (non_unital_non_assoc_semiring linarith.ineq)) : complete_lattice.is_Sup_finite_compact (non_unital_non_assoc_semiring linarith.ineq) := sorry --non-trivial
lemma new_lemma_70053 (h0 : function.extfun (finset Type) (has_mem.mem (has_top linarith.comp_source))) : @monoid.fg.{0} (has_top.{0} linarith.comp_source) (@finset.pi.empty.{1 0} Type monoid.{0} (has_top.{0} linarith.comp_source) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (has_top.{0} linarith.comp_source)) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_70054 (h0 : functor.add_const (finset (boolean_algebra linarith.comp)) environment.implicit_infer_kind) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_70055 (h0 : topological_space (add_cancel_monoid (comm_group Type))) : discrete_topology (add_cancel_monoid (comm_group Type)) := sorry --non-trivial
lemma new_lemma_70056 (h0 : topological_space (has_norm (semiring (semiring (semiring congr_arg_kind))))) : discrete_topology (has_norm (semiring (semiring (semiring congr_arg_kind)))) := sorry --non-trivial
lemma new_lemma_70057 (h0 : function.extfun Type group) : @group.fg.{0} (linear_order.{0} num) (@function.extfun_app.{2 1} Type group.{0} h0 (linear_order.{0} num))  := sorry --non-trivial
lemma new_lemma_70058 (h0 : function.extfun Type (functor.comp filter comm_group)) : countable_Inter_filter (functor.comp.run (function.extfun_app h0 name)) := sorry --non-trivial
lemma new_lemma_70059 (h0 : topological_space (comm_monoid (comm_monoid unsigned))) : locally_compact_space (comm_monoid (comm_monoid unsigned)) := sorry --non-trivial
lemma new_lemma_70060 (h2 : topological_space (has_append to_additive.value_type)) : t0_space (has_append to_additive.value_type) := sorry --non-trivial
lemma new_lemma_70061 (h0 : topological_space num) : t1_space num := sorry --non-trivial
lemma new_lemma_70062 (h0 : functor.add_const (functor.add_const (function.extfun Type ring) environment.implicit_infer_kind) linarith.comp) : @strong_rank_condition.{0} (add_comm_monoid.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type ring.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type ring.{0}) environment.implicit_infer_kind (@functor.add_const.run.{1 0} (functor.add_const.{1 0} (function.extfun.{2 1} Type ring.{0}) environment.implicit_infer_kind) linarith.comp h0)) (add_comm_monoid.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_70063 (h0 : topological_space (has_top (random_gen (random_gen num)))) : totally_separated_space (has_top (random_gen (random_gen num))) := sorry --non-trivial
lemma new_lemma_70064 (h0 : functor.add_const (ring (plift congr_arg_kind)) unsigned) : @strong_rank_condition.{1} (plift.{1} congr_arg_kind) (@functor.add_const.run.{1 0} (ring.{1} (plift.{1} congr_arg_kind)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_70065 (h0 : topological_space (add_cancel_monoid (has_neg linarith.comp))) : regular_space (add_cancel_monoid (has_neg linarith.comp)) := sorry --non-trivial
lemma new_lemma_70066 (h0 : topological_space (ordered_comm_monoid (has_add (has_Inf Type)))) : t0_space (ordered_comm_monoid (has_add (has_Inf Type))) := sorry --non-trivial
lemma new_lemma_70067 (h0 : fin has_zero.zero) : @unique_factorization_monoid.{0} (comm_semigroup.{0} pos) (@matrix.vec_empty.{0} (cancel_comm_monoid_with_zero.{0} (comm_semigroup.{0} pos)) h0)  := sorry --non-trivial
lemma new_lemma_70068 (h0 : not (function.extfun Type topological_space -> false)) : @locally_compact_space.{0} (random_gen.{0} fun_info) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (random_gen.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_70069 (h0 : topological_space (has_nnnorm (has_top (has_nnnorm linarith.ineq)))) : t0_space (has_nnnorm (has_top (has_nnnorm linarith.ineq))) := sorry --non-trivial
lemma new_lemma_70070 (h0 : not (function.extfun Type topological_space -> false)) : @t0_space.{0} (has_emptyc.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (has_emptyc.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_70071 (h0 : add_group (has_append (metric_space reducibility_hints))) : is_add_cyclic (has_append (metric_space reducibility_hints)) := sorry --non-trivial
lemma new_lemma_70072 (h0 : functor.add_const Prop (linear_ordered_semiring (semiring (complete_semilattice_Sup empty)))) : functor.add_const.run h0 := sorry --non-trivial
lemma new_lemma_70073 (h0 : functor.add_const (group (ring Type)) (has_add linarith.comp)) : @normalizer_condition.{1} (ring.{1} Type) (@functor.add_const.run.{1 0} (group.{1} (ring.{1} Type)) (has_add.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_70074 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @preirreducible_space.{0} (add_group.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (add_group.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_70075 (h0 : topological_space (ring (option ennreal))) : discrete_topology (ring (option ennreal)) := sorry --non-trivial
lemma new_lemma_70076 (h0 : topological_space (canonically_ordered_comm_semiring (has_add environment.implicit_infer_kind))) : sequential_space (canonically_ordered_comm_semiring (has_add environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_70077 (h0 : complete_lattice (semi_normed_comm_ring (id linarith.ineq))) : is_compactly_generated (semi_normed_comm_ring (id linarith.ineq)) := sorry --non-trivial
lemma new_lemma_70078 (h0 : not (function.extfun Type uniform_space -> false)) : @complete_space.{0} congr_arg_kind (@function.extfun_app.{2 1} Type uniform_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type uniform_space.{0}) h0) congr_arg_kind)  := sorry --non-trivial
lemma new_lemma_70079 (h0 : functor.add_const (monoid (cancel_monoid ennreal)) Type) : @monoid.fg.{0} (cancel_monoid.{0} ennreal) (@functor.add_const.run.{0 1} (monoid.{0} (cancel_monoid.{0} ennreal)) Type h0)  := sorry --non-trivial
lemma new_lemma_70080 (h0 : group (finset (has_zero Type))) : is_simple_group (finset (has_zero Type)) := sorry --non-trivial
lemma new_lemma_70081 (h0 : topological_space (has_nndist (canonically_ordered_comm_semiring name))) : discrete_topology (has_nndist (canonically_ordered_comm_semiring name)) := sorry --non-trivial
lemma new_lemma_70082 (h0 : uniform_space (has_Inf (finset pos))) : complete_space (has_Inf (finset pos)) := sorry --non-trivial
lemma new_lemma_70083 (h0 : topological_space (ring (has_zero linarith.comp))) : totally_disconnected_space (ring (has_zero linarith.comp)) := sorry --non-trivial
lemma new_lemma_70084 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @totally_separated_space.{1} (boolean_algebra.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 topological_space.{1}) (boolean_algebra.{1} Type))  := sorry --non-trivial
lemma new_lemma_70085 (h0 : functor.add_const (topological_space (linear_ordered_field pos)) unsigned) : @loc_path_connected_space.{0} (linear_ordered_field.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (linear_ordered_field.{0} pos)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_70086 (h0 : set (non_unital_non_assoc_semiring string.iterator_imp)) : set.subsingleton h0 := sorry --non-trivial
lemma new_lemma_70087 (h0 : function.extfun Type group) : @is_cyclic.{0} (has_edist.{0} unsigned) (@function.extfun_app.{2 1} Type group.{0} h0 (has_edist.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_70088 (h0 : group (boolean_algebra (has_pos_part (finset linarith.comp)))) : is_cyclic (boolean_algebra (has_pos_part (finset linarith.comp))) := sorry --non-trivial
lemma new_lemma_70089 (h0 : function.extfun Type topological_space) : @path_connected_space.{0} (random_gen.{0} linarith.ineq) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (random_gen.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_70090 (h0 : functor.add_const (uniform_space (has_to_string pos)) pos) : @separated_space.{0} (has_to_string.{0} pos) (@functor.add_const.run.{0 0} (uniform_space.{0} (has_to_string.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_70091 (h0 : has_Sup (ordered_ring empty) -> has_Sup (ordered_ring empty) -> Prop) : is_antisymm (has_Sup (ordered_ring empty)) h0 := sorry --non-trivial
lemma new_lemma_70092 (h0 : function.extfun ((Type -> Type) -> Type 1) (function.extfun (Type -> Type))) : @monoid.fg.{0} (measurable_space.{0} string_imp) (@function.extfun_app.{2 1} Type monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) (@function.extfun_app.{3 2} ((Type → Type) → Type 1) (function.extfun.{2 2} (Type → Type)) h0 (function.extfun.{2 1} Type)) monoid.{0}) (measurable_space.{0} string_imp))  := sorry --non-trivial
lemma new_lemma_70093 (h1 : ring (div_inv_monoid string_imp)) : rank_condition (div_inv_monoid string_imp) := sorry --non-trivial
lemma new_lemma_70094 (h2 : ring (has_append (random_gen (comm_ring (comm_ring string_imp))))) : rank_condition (has_append (random_gen (comm_ring (comm_ring string_imp)))) := sorry --non-trivial
lemma new_lemma_70095 (h0 : ring (ordered_comm_ring (has_add (ring pos)))) : is_principal_ideal_ring (ordered_comm_ring (has_add (ring pos))) := sorry --non-trivial
lemma new_lemma_70096 (h0 : ring (add_right_cancel_monoid (semiring (semiring empty)))) : strong_rank_condition (add_right_cancel_monoid (semiring (semiring empty))) := sorry --non-trivial
lemma new_lemma_70097 (h0 : topological_space (cancel_monoid (option (option ennreal)))) : totally_separated_space (cancel_monoid (option (option ennreal))) := sorry --non-trivial
lemma new_lemma_70098 (h0 : not (function.extfun Type add_monoid -> false)) : @add_monoid.fg.{0} (has_norm.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type add_monoid.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type add_monoid.{0}) h0) (has_norm.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_70099 (h0 : topological_space (has_to_string (option (option (option unsigned))))) : path_connected_space (has_to_string (option (option (option unsigned)))) := sorry --non-trivial
lemma new_lemma_70100 (h0 : topological_space (with_bot (has_inv (distrib_lattice (comm_ring (comm_ring (has_top linarith.ineq))))))) : t0_space (with_bot (has_inv (distrib_lattice (comm_ring (comm_ring (has_top linarith.ineq)))))) := sorry --non-trivial
lemma new_lemma_70101 (h0 : functor.add_const (topological_space (semigroup name)) linarith.comp) : @totally_separated_space.{0} (semigroup.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (semigroup.{0} name)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_70102 (h0 : functor.add_const (ring (boolean_algebra.core Type)) name) : @rank_condition.{1} (boolean_algebra.core.{1} Type) (@functor.add_const.run.{1 0} (ring.{1} (boolean_algebra.core.{1} Type)) name h0)  := sorry --non-trivial
lemma new_lemma_70103 (h0 : topological_space (generalized_boolean_algebra (has_Inf pos))) : preirreducible_space (generalized_boolean_algebra (has_Inf pos)) := sorry --non-trivial
lemma new_lemma_70104 (h0 : topological_space (generalized_boolean_algebra (has_neg name))) : topological_space.separable_space (generalized_boolean_algebra (has_neg name)) := sorry --non-trivial
lemma new_lemma_70105 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_domain.{0} (has_add.{0} ennreal) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (has_add.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_70106 (h0 : add_group (with_one (random_gen fun_info))) : is_add_cyclic (with_one (random_gen fun_info)) := sorry --non-trivial
lemma new_lemma_70107 (h0 : function.extfun Type topological_space) : @totally_disconnected_space.{0} (has_neg.{0} ennreal) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_neg.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_70108 (h0 : finset (has_zero (has_add (has_add (finset pos))))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_70109 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @add_monoid.fg.{0} (finset.{0} ennreal) (@function.extfun_app.{2 1} Type add_monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 add_monoid.{0}) (finset.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_70110 (h0 : group (complete_linear_order (semiring (semiring (semiring (semiring empty)))))) : is_cyclic (complete_linear_order (semiring (semiring (semiring (semiring empty))))) := sorry --non-trivial
lemma new_lemma_70111 (h0 : function.extfun Type (prod (has_top empty))) : id_rel (function.extfun_app h0 (has_top empty)) := sorry --non-trivial
lemma new_lemma_70112 (h0 : topological_space (id (semiring (semiring congr_arg_kind)))) : normal_space (id (semiring (semiring congr_arg_kind))) := sorry --non-trivial
lemma new_lemma_70113 (h0 : function.extfun nat fin) : @normal_space.{1} (normed_lattice_add_comm_group.{1} Type) (@matrix.vec_empty.{1} (topological_space.{1} (normed_lattice_add_comm_group.{1} Type)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_70114 (h0 : list (canonically_ordered_add_monoid (option empty))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_70115 (h0 : functor.add_const (complete_lattice (ring linarith.comp)) Type) : @complete_lattice.is_Sup_finite_compact.{0} (ring.{0} linarith.comp) (@functor.add_const.run.{0 1} (complete_lattice.{0} (ring.{0} linarith.comp)) Type h0)  := sorry --non-trivial
lemma new_lemma_70116 (h0 : ring (simple_graph (option (option (option num))))) : is_principal_ideal_ring (simple_graph (option (option (option num)))) := sorry --non-trivial
lemma new_lemma_70117 (h0 : group (normed_group (has_inv (random_gen (random_gen linarith.comp_source))))) : normalizer_condition (normed_group (has_inv (random_gen (random_gen linarith.comp_source)))) := sorry --non-trivial
lemma new_lemma_70118 (h0 : ring (comm_monoid (semiring num))) : is_principal_ideal_ring (comm_monoid (semiring num)) := sorry --non-trivial
lemma new_lemma_70119 (h0 : functor.add_const (complete_lattice (has_to_string unsigned)) pos) : @is_atomistic.{0} (has_to_string.{0} unsigned) (@functor.add_const.run.{0 0} (complete_lattice.{0} (has_to_string.{0} unsigned)) pos h0)  := sorry --non-trivial
lemma new_lemma_70120 (h0 : functor.add_const (cancel_comm_monoid_with_zero (normed_comm_ring name)) (option (option name))) : @unique_factorization_monoid.{0} (normed_comm_ring.{0} name) (@functor.add_const.run.{0 0} (cancel_comm_monoid_with_zero.{0} (normed_comm_ring.{0} name)) (option.{0} (option.{0} name)) h0)  := sorry --non-trivial
lemma new_lemma_70121 (h2 : topological_space (nondiscrete_normed_field (add_comm_semigroup linarith.ineq))) (h3 : add_group (nondiscrete_normed_field (add_comm_semigroup linarith.ineq))) : topological_add_group (nondiscrete_normed_field (add_comm_semigroup linarith.ineq)) := sorry --non-trivial
lemma new_lemma_70122 (h0 : functor.add_const (function.extfun (Type 1) finset) Type) : finset.nonempty (function.extfun_app (functor.add_const.run h0) (has_sub Type)) := sorry --non-trivial
lemma new_lemma_70123 (h0 : function.extfun Type topological_space) : @path_connected_space.{0} (has_nnnorm.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_nnnorm.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_70124 (h0 : ring (comm_semigroup linarith.comp)) : is_domain (comm_semigroup linarith.comp) := sorry --non-trivial
lemma new_lemma_70125 (h0 : topological_space (nondiscrete_normed_field (add_comm_semigroup linarith.ineq))) : t0_space (nondiscrete_normed_field (add_comm_semigroup linarith.ineq)) := sorry --non-trivial
lemma new_lemma_70126 (h0 : ordered_add_comm_monoid (add_comm_monoid (boolean_algebra linarith.comp))) : archimedean (add_comm_monoid (boolean_algebra linarith.comp)) := sorry --non-trivial
lemma new_lemma_70127 (h0 : complete_lattice (measurable_space (has_emptyc congr_arg_kind))) : is_atomistic (measurable_space (has_emptyc congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_70128 (h0 : function.extfun Type ring) : @rank_condition.{0} (has_bot.{0} empty) (@function.extfun_app.{2 1} Type ring.{0} h0 (has_bot.{0} empty))  := sorry --non-trivial
lemma new_lemma_70129 (h0 : function.extfun Type list) : palindrome (function.extfun_app h0 (add_cancel_comm_monoid empty)) := sorry --non-trivial
lemma new_lemma_70130 (h0 : topological_space (add_cancel_monoid (has_Inf (has_neg linarith.comp)))) : t1_space (add_cancel_monoid (has_Inf (has_neg linarith.comp))) := sorry --non-trivial
lemma new_lemma_70131 (h1 : ring (add_monoid linarith.ineq)) : strong_rank_condition (add_monoid linarith.ineq) := sorry --non-trivial
lemma new_lemma_70132 (h0 : topological_space (linear_ordered_semiring (has_top (has_top (has_top fun_info))))) : totally_separated_space (linear_ordered_semiring (has_top (has_top (has_top fun_info)))) := sorry --non-trivial
lemma new_lemma_70133 (h0 : complete_lattice (uniform_space (mul_one_class string.iterator_imp))) : is_compactly_generated (uniform_space (mul_one_class string.iterator_imp)) := sorry --non-trivial
lemma new_lemma_70134 (h0 : topological_space (preorder (option (option (option (option (option empty))))))) : discrete_topology (preorder (option (option (option (option (option empty)))))) := sorry --non-trivial
lemma new_lemma_70135 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @preirreducible_space.{1} (boolean_algebra.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 topological_space.{1}) (boolean_algebra.{1} Type))  := sorry --non-trivial
lemma new_lemma_70136 (h0 : ring (linear_order (option empty))) : is_principal_ideal_ring (linear_order (option empty)) := sorry --non-trivial
lemma new_lemma_70137 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_principal_ideal_ring.{0} (mul_zero_class.{0} pos) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (mul_zero_class.{0} pos))  := sorry --non-trivial
lemma new_lemma_70138 (h3 : complete_lattice (semi_normed_ring char)) : complete_lattice.is_Sup_finite_compact (semi_normed_ring char) := sorry --non-trivial
lemma new_lemma_70139 (h0 : ring (normed_comm_ring (comm_group pos))) : rank_condition (normed_comm_ring (comm_group pos)) := sorry --non-trivial
lemma new_lemma_70140 (h0 : prod (partial_order (semiring num)) (partial_order (semiring num))) : id_rel h0 := sorry --non-trivial
lemma new_lemma_70141 (h0 : function.extfun Type add_group) : @is_add_cyclic.{0} (denumerable.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type add_group.{0} h0 (denumerable.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_70142 (h0 : ring (random_gen (random_gen reducibility_hints))) : rank_condition (random_gen (random_gen reducibility_hints)) := sorry --non-trivial
lemma new_lemma_70143 (h0 : complete_lattice (has_nndist (finset (add_comm_monoid (mul_zero_class ennreal))))) : is_compactly_generated (has_nndist (finset (add_comm_monoid (mul_zero_class ennreal)))) := sorry --non-trivial
lemma new_lemma_70144 (h0 : measurable_space (has_add (has_nnnorm fun_info))) (h1 : has_add (has_add (has_nnnorm fun_info))) : has_measurable_add₂ (has_add (has_nnnorm fun_info)) := sorry --non-trivial
lemma new_lemma_70145 (h0 : function.extfun Type complete_lattice) : complete_lattice.is_Sup_finite_compact (measurable_space linarith.comp) := sorry --non-trivial
lemma new_lemma_70146 (h0 : function.extfun Type uniform_space) : @separated_space.{0} (has_Inf.{0} pos) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (has_Inf.{0} pos))  := sorry --non-trivial
lemma new_lemma_70147 (h0 : function.extfun Type group) : @group.fg.{0} (measurable_space.{0} string_imp) (@function.extfun_app.{2 1} Type group.{0} h0 (measurable_space.{0} string_imp))  := sorry --non-trivial
lemma new_lemma_70148 (h0 : ring (add_left_cancel_monoid linarith.ineq)) : rank_condition (add_left_cancel_monoid linarith.ineq) := sorry --non-trivial
lemma new_lemma_70149 (h0 : function.extfun (finset (Type -> Type)) (has_mem.mem group)) : @is_cyclic.{0} (has_norm.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type group.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) group.{0} (@function.extfun_app.{2 0} (finset.{1} (Type → Type)) (@has_mem.mem.{1 1} (Type → Type) (finset.{1} (Type → Type)) (@finset.has_mem.{1} (Type → Type)) group.{0}) h0 (@has_emptyc.emptyc.{1} (finset.{1} (Type → Type)) (@finset.has_emptyc.{1} (Type → Type))))) (has_norm.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_70150 (h0 : group (option unsigned)) : is_cyclic (option unsigned) := sorry --non-trivial
lemma new_lemma_70151 (h0 : filter (comm_group (has_add (has_add Type)))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_70152 (h0 : topological_space (canonically_ordered_add_monoid (option unsigned))) : normal_space (canonically_ordered_add_monoid (option unsigned)) := sorry --non-trivial
lemma new_lemma_70153 (h0 : topological_space (complete_distrib_lattice (generalized_boolean_algebra linarith.comp))) : loc_path_connected_space (complete_distrib_lattice (generalized_boolean_algebra linarith.comp)) := sorry --non-trivial
lemma new_lemma_70154 (h0 : add_group (fintype (random_gen linarith.ineq))) : is_add_cyclic (fintype (random_gen linarith.ineq)) := sorry --non-trivial
lemma new_lemma_70155 (h0 : function.extfun Type group) : @normalizer_condition.{0} (has_bot.{0} name) (@function.extfun_app.{2 1} Type group.{0} h0 (has_bot.{0} name))  := sorry --non-trivial
lemma new_lemma_70156 (h0 : uniform_space (ordered_comm_ring (has_add real))) : separated_space (ordered_comm_ring (has_add real)) := sorry --non-trivial
lemma new_lemma_70157 (h0 : function.extfun Type topological_space) : @preirreducible_space.{0} (random_gen.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (random_gen.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_70158 (h0 : semiring (ordered_comm_ring real)) : is_noetherian_ring (ordered_comm_ring real) := sorry --non-trivial
lemma new_lemma_70159 (h0 : functor.add_const (topological_space (ordered_ring congr_arg_kind)) empty) : @totally_separated_space.{0} (ordered_ring.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (ordered_ring.{0} congr_arg_kind)) empty h0)  := sorry --non-trivial
lemma new_lemma_70160 (h0 : ordered_add_comm_monoid (ordered_comm_ring (has_add (has_add (has_add (has_add (has_add real))))))) : archimedean (ordered_comm_ring (has_add (has_add (has_add (has_add (has_add real)))))) := sorry --non-trivial
lemma new_lemma_70161 (h0 : functor.add_const (filter (has_zero linarith.comp)) Type) : filter.ne_bot (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_70162 (h0 : monoid (has_pos_part (has_add (finset (has_add (has_add linarith.comp)))))) : monoid.fg (has_pos_part (has_add (finset (has_add (has_add linarith.comp))))) := sorry --non-trivial
lemma new_lemma_70163 (h0 : list (normed_comm_ring (has_neg linarith.comp))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_70164 (h0 : functor.add_const (functor.add_const (uniform_space pos) Type) linarith.comp) : @complete_space.{0} pos (@functor.add_const.run.{0 1} (uniform_space.{0} pos) Type (@functor.add_const.run.{0 0} (functor.add_const.{0 1} (uniform_space.{0} pos) Type) linarith.comp h0))  := sorry --non-trivial
lemma new_lemma_70165 (h0 : ring (linear_ordered_add_comm_group (has_nnnorm linarith.ineq))) : strong_rank_condition (linear_ordered_add_comm_group (has_nnnorm linarith.ineq)) := sorry --non-trivial
lemma new_lemma_70166 (h0 : topological_space (bin_tree (semiring empty))) : discrete_topology (bin_tree (semiring empty)) := sorry --non-trivial
lemma new_lemma_70167 (h0 : not (ring (has_compl (comm_ring linarith.ineq)) -> false)) : @rank_condition.{0} (has_compl.{0} (comm_ring.{0} linarith.ineq)) (@classical.by_contradiction'.{1} (ring.{0} (has_compl.{0} (comm_ring.{0} linarith.ineq))) h0)  := sorry --non-trivial
lemma new_lemma_70168 (h0 : ring (has_to_string (has_add Type))) : strong_rank_condition (has_to_string (has_add Type)) := sorry --non-trivial
lemma new_lemma_70169 (h0 : topological_space (add_comm_monoid (has_to_string pos))) : t1_space (add_comm_monoid (has_to_string pos)) := sorry --non-trivial
lemma new_lemma_70170 (h0 : function.extfun Type uniform_space) : @separated_space.{0} (non_assoc_semiring.{0} unsigned) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (non_assoc_semiring.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_70171 (h0 : uniform_space (local_equiv ereal ereal)) : complete_space (local_equiv ereal ereal) := sorry --non-trivial
lemma new_lemma_70172 (h0 : topological_space (has_top (random_gen linarith.ineq))) : locally_compact_space (has_top (random_gen linarith.ineq)) := sorry --non-trivial
lemma new_lemma_70173 (h0 : functor.add_const (topological_space (has_zero ennreal)) Type) : @locally_compact_space.{0} (has_zero.{0} ennreal) (@functor.add_const.run.{0 1} (topological_space.{0} (has_zero.{0} ennreal)) Type h0)  := sorry --non-trivial
lemma new_lemma_70174 (h0 : functor.add_const (function.extfun (Type 1) complete_lattice) (has_add linarith.comp)) : @complete_lattice.is_Sup_finite_compact.{1} (has_Inf.{1} Type) (@function.extfun_app.{3 2} (Type 1) complete_lattice.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) complete_lattice.{1}) (has_add.{0} linarith.comp) h0) (has_Inf.{1} Type))  := sorry --non-trivial
lemma new_lemma_70175 (h0 : functor.add_const (complete_lattice (normed_linear_ordered_group unsigned)) unsigned) : @is_atomistic.{0} (normed_linear_ordered_group.{0} unsigned) (@functor.add_const.run.{0 0} (complete_lattice.{0} (normed_linear_ordered_group.{0} unsigned)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_70176 (h0 : ring (normed_comm_ring (boolean_algebra linarith.comp))) : is_principal_ideal_ring (normed_comm_ring (boolean_algebra linarith.comp)) := sorry --non-trivial
lemma new_lemma_70177 (h0 : add_monoid (with_one (semiring num))) : add_monoid.fg (with_one (semiring num)) := sorry --non-trivial
lemma new_lemma_70178 (h0 : functor.add_const (topological_space znum) (option unsigned)) : @t1_space.{0} znum (@functor.add_const.run.{0 0} (topological_space.{0} znum) (option.{0} unsigned) h0)  := sorry --non-trivial
lemma new_lemma_70179 (h0 : functor.add_const (topological_space (canonically_ordered_comm_semiring pos)) name) : @locally_compact_space.{0} (canonically_ordered_comm_semiring.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (canonically_ordered_comm_semiring.{0} pos)) name h0)  := sorry --non-trivial
lemma new_lemma_70180 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @rank_condition.{0} (has_neg.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (has_neg.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_70181 (h2 : complete_lattice (has_ssubset char)) : is_compactly_generated (has_ssubset char) := sorry --non-trivial
lemma new_lemma_70182 (h0 : group (ordered_comm_monoid (has_neg pos))) : normalizer_condition (ordered_comm_monoid (has_neg pos)) := sorry --non-trivial
lemma new_lemma_70183 (h0 : ordered_add_comm_monoid (has_bot pos)) : archimedean (has_bot pos) := sorry --non-trivial
lemma new_lemma_70184 (h1 : has_mem.mem (random_gen congr_arg_kind) has_emptyc.emptyc) : @is_domain.{0} (random_gen.{0} congr_arg_kind) (@finset.pi.empty.{1 0} Type ring.{0} (random_gen.{0} congr_arg_kind) h1)  := sorry --non-trivial
lemma new_lemma_70185 (h0 : functor.add_const (group (cancel_monoid ennreal)) unsigned) : @group.fg.{0} (cancel_monoid.{0} ennreal) (@functor.add_const.run.{0 0} (group.{0} (cancel_monoid.{0} ennreal)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_70186 (h0 : list (add_cancel_monoid ennreal)) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_70187 (h0 : topological_space (normed_comm_ring (finset pos))) : loc_path_connected_space (normed_comm_ring (finset pos)) := sorry --non-trivial
lemma new_lemma_70188 (h0 : function.extfun (finset Type) (has_mem.mem linarith.comp_source)) : @is_domain.{0} linarith.comp_source (@finset.pi.empty.{1 0} Type ring.{0} linarith.comp_source (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) linarith.comp_source) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_70189 (h0 : functor.add_const (topological_space (finset pos)) (has_to_string (has_to_string (has_to_string Type)))) : @locally_compact_space.{0} (finset.{0} pos) (@functor.add_const.run.{0 1} (topological_space.{0} (finset.{0} pos)) (has_to_string.{1} (has_to_string.{1} (has_to_string.{1} Type))) h0)  := sorry --non-trivial
lemma new_lemma_70190 (h0 : semiring (simple_graph (has_Inf (has_Inf Type)))) : is_noetherian_ring (simple_graph (has_Inf (has_Inf Type))) := sorry --non-trivial
lemma new_lemma_70191 (h0 : functor.add_const (ordered_comm_monoid (semigroup linarith.comp)) linarith.comp) : @has_exists_mul_of_le.{0} (semigroup.{0} linarith.comp) (@functor.add_const.run.{0 0} (ordered_comm_monoid.{0} (semigroup.{0} linarith.comp)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_70192 (h0 : ring (has_emptyc fun_info)) : strong_rank_condition (has_emptyc fun_info) := sorry --non-trivial
lemma new_lemma_70193 (h0 : finset (finset ennreal)) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_70194 (h0 : function.extfun Type group) : @group.fg.{0} (has_union.{0} linarith.comp) (@function.extfun_app.{2 1} Type group.{0} h0 (has_union.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_70195 (h0 : function.extfun Type add_monoid) : @add_monoid.fg.{0} (linear_ordered_semiring.{0} num) (@function.extfun_app.{2 1} Type add_monoid.{0} h0 (linear_ordered_semiring.{0} num))  := sorry --non-trivial
lemma new_lemma_70196 (h0 : set (has_nnnorm std_gen)) : set.finite h0 := sorry --non-trivial
lemma new_lemma_70197 (h0 : group (has_to_string (has_add (has_add (has_add (has_add Type)))))) : normalizer_condition (has_to_string (has_add (has_add (has_add (has_add Type))))) := sorry --non-trivial
lemma new_lemma_70198 (h0 : functor.add_const (topological_space (ordered_comm_ring linarith.comp)) (ring (ring linarith.comp))) : @preirreducible_space.{0} (ordered_comm_ring.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (ordered_comm_ring.{0} linarith.comp)) (ring.{0} (ring.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_70199 (h0 : function.extfun Type topological_space) : @preirreducible_space.{0} (has_union.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_union.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_70200 (h0 : has_mem.mem topological_space has_emptyc.emptyc) : @irreducible_space.{0} (has_emptyc.{0} fun_info) (@function.extfun_app.{2 1} Type topological_space.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) topological_space.{0} h0) (has_emptyc.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_70201 (h0 : function.extfun Type topological_space) : @path_connected_space.{0} (add_cancel_monoid.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (add_cancel_monoid.{0} num))  := sorry --non-trivial
lemma new_lemma_70202 (h0 : functor.add_const (list (cancel_monoid environment.implicit_infer_kind)) environment.implicit_infer_kind) : palindrome (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_70203 (h0 : uniform_space (normed_lattice_add_comm_group (finset (has_Inf pos)))) : separated_space (normed_lattice_add_comm_group (finset (has_Inf pos))) := sorry --non-trivial
lemma new_lemma_70204 (h0 : ring (linear_ordered_add_comm_group (complete_semilattice_Sup (with_bot fun_info)))) : is_domain (linear_ordered_add_comm_group (complete_semilattice_Sup (with_bot fun_info))) := sorry --non-trivial
lemma new_lemma_70205 (h0 : ring (generalized_boolean_algebra (finset linarith.comp))) : rank_condition (generalized_boolean_algebra (finset linarith.comp)) := sorry --non-trivial
lemma new_lemma_70206 (h0 : topological_space (boolean_algebra.core (has_add Type))) : t0_space (boolean_algebra.core (has_add Type)) := sorry --non-trivial
lemma new_lemma_70207 (h0 : function.extfun Type topological_space) : @t0_space.{0} (normed_group.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (normed_group.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_70208 (h0 : finset (complete_distrib_lattice (option (option (option (option pos)))))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_70209 (h0 : function.extfun Type ring) : @strong_rank_condition.{0} (complete_linear_order.{0} num) (@function.extfun_app.{2 1} Type ring.{0} h0 (complete_linear_order.{0} num))  := sorry --non-trivial
lemma new_lemma_70210 (h0 : add_group (boolean_algebra Type)) : is_add_cyclic (boolean_algebra Type) := sorry --non-trivial
lemma new_lemma_70211 (h0 : fin has_zero.zero) : @normal_space.{1} (comm_semigroup.{1} Type) (@matrix.vec_empty.{1} (topological_space.{1} (comm_semigroup.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_70212 (h0 : topological_space (with_zero (has_inv (has_nnnorm (has_nnnorm fun_info))))) : totally_disconnected_space (with_zero (has_inv (has_nnnorm (has_nnnorm fun_info)))) := sorry --non-trivial
lemma new_lemma_70213 (h0 : ring (has_top (add_group (metric_space (has_union linarith.comp))))) : strong_rank_condition (has_top (add_group (metric_space (has_union linarith.comp)))) := sorry --non-trivial
lemma new_lemma_70214 (h0 : finset (canonically_ordered_comm_semiring (boolean_algebra.core (boolean_algebra.core (has_Inf (finset Type)))))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_70215 (h0 : functor.add_const (cancel_comm_monoid_with_zero (option congr_arg_kind)) empty) : @unique_factorization_monoid.{0} (option.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (cancel_comm_monoid_with_zero.{0} (option.{0} congr_arg_kind)) empty h0)  := sorry --non-trivial
lemma new_lemma_70216 (h0 : complete_lattice (has_zero (option (option empty)))) : is_atomistic (has_zero (option (option empty))) := sorry --non-trivial
lemma new_lemma_70217 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @add_monoid.fg.{0} (canonically_ordered_monoid.{0} name) (@function.extfun_app.{2 1} Type add_monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 add_monoid.{0}) (canonically_ordered_monoid.{0} name))  := sorry --non-trivial
lemma new_lemma_70218 (h0 : functor.add_const (topological_space environment.implicit_infer_kind) Type) : @t0_space.{0} environment.implicit_infer_kind (@functor.add_const.run.{0 1} (topological_space.{0} environment.implicit_infer_kind) Type h0)  := sorry --non-trivial
lemma new_lemma_70219 (h0 : ring (add_comm_monoid congr_arg_kind)) : strong_rank_condition (add_comm_monoid congr_arg_kind) := sorry --non-trivial
lemma new_lemma_70220 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @t1_space.{0} (has_add.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_add.{0} name))  := sorry --non-trivial
lemma new_lemma_70221 (h2 : set (string.iterator_imp -> fun_info)) : set.separates_points h2 := sorry --non-trivial
lemma new_lemma_70222 (h0 : add_monoid (free_add_monoid (option unsigned))) : add_monoid.fg (free_add_monoid (option unsigned)) := sorry --non-trivial
lemma new_lemma_70223 (h0 : not (function.extfun Type topological_space -> false)) : @locally_compact_space.{0} (with_one.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (with_one.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_70224 (h0 : function.extfun Type filter) : countable_Inter_filter (function.extfun_app h0 (has_zero ennreal)) := sorry --non-trivial
lemma new_lemma_70225 (h0 : function.extfun Type complete_lattice) : @is_atomistic.{0} (has_norm.{0} fun_info) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (has_norm.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_70226 (h1 : topological_space (complete_semilattice_Sup fun_info)) : locally_compact_space (complete_semilattice_Sup fun_info) := sorry --non-trivial
lemma new_lemma_70227 (h0 : group (has_neg_part (mul_zero_class name))) : is_simple_group (has_neg_part (mul_zero_class name)) := sorry --non-trivial
lemma new_lemma_70228 (h0 : functor.add_const (topological_space (simple_graph Type)) Type) : @loc_path_connected_space.{1} (simple_graph.{1} Type) (@functor.add_const.run.{1 1} (topological_space.{1} (simple_graph.{1} Type)) Type h0)  := sorry --non-trivial
lemma new_lemma_70229 (h0 : topological_space (encodable (has_nnnorm char))) : path_connected_space (encodable (has_nnnorm char)) := sorry --non-trivial
lemma new_lemma_70230 (h0 : finset (left_cancel_monoid (semiring (semiring num)))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_70231 (h0 : complete_lattice (random_gen (has_nnnorm linarith.ineq))) : complete_lattice.is_Sup_finite_compact (random_gen (has_nnnorm linarith.ineq)) := sorry --non-trivial
lemma new_lemma_70232 (h0 : ring (canonically_linear_ordered_monoid (has_Inf name))) : is_principal_ideal_ring (canonically_linear_ordered_monoid (has_Inf name)) := sorry --non-trivial
lemma new_lemma_70233 (h0 : topological_space (with_one (random_gen fun_info))) : path_connected_space (with_one (random_gen fun_info)) := sorry --non-trivial
lemma new_lemma_70234 (h0 : add_group (boolean_algebra (has_pos_part Type))) : is_add_cyclic (boolean_algebra (has_pos_part Type)) := sorry --non-trivial
lemma new_lemma_70235 (h0 : functor.add_const (ordered_comm_monoid (comm_semigroup name)) pos) : @has_exists_mul_of_le.{0} (comm_semigroup.{0} name) (@functor.add_const.run.{0 0} (ordered_comm_monoid.{0} (comm_semigroup.{0} name)) pos h0)  := sorry --non-trivial
lemma new_lemma_70236 (h0 : functor.add_const (group (ring linarith.comp)) (ring linarith.comp)) : @normalizer_condition.{0} (ring.{0} linarith.comp) (@functor.add_const.run.{0 0} (group.{0} (ring.{0} linarith.comp)) (ring.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_70237 (h0 : complete_lattice (has_to_string (add_cancel_monoid Type))) : is_atomistic (has_to_string (add_cancel_monoid Type)) := sorry --non-trivial
lemma new_lemma_70238 (h0 : pnat) (h1 : ulower (fin has_zero.zero)) (h2 : list (ulower (fin has_zero.zero))) : pnat.coprime h0 (matrix.vec_empty (id (matrix.vec_empty (id (ulower.up (list.ilast' h1 h2)))))) := sorry --non-trivial
lemma new_lemma_70239 (h0 : has_mem.mem auto.case_option has_emptyc.emptyc) : @unique_factorization_monoid.{0} auto.case_option (@finset.pi.empty.{1 0} Type cancel_comm_monoid_with_zero.{0} auto.case_option h0)  := sorry --non-trivial
lemma new_lemma_70240 (h0 : function.extfun Type topological_space) : @normal_space.{0} (mul_zero_class.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (mul_zero_class.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_70241 (h0 : function.extfun pos (fun (x : pos), Prop)) : zzz_forall (function.extfun_app h0) := sorry --non-trivial
lemma new_lemma_70242 (h0 : functor.add_const (ring (has_add linarith.comp)) pos) : @strong_rank_condition.{0} (has_add.{0} linarith.comp) (@functor.add_const.run.{0 0} (ring.{0} (has_add.{0} linarith.comp)) pos h0)  := sorry --non-trivial
lemma new_lemma_70243 (h0 : function.extfun Type topological_space) : @irreducible_space.{0} (canonically_linear_ordered_monoid.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (canonically_linear_ordered_monoid.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_70244 (h0 : group (add_comm_monoid (finset environment.implicit_infer_kind))) : normalizer_condition (add_comm_monoid (finset environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_70245 (h0 : not (function.extfun Type complete_lattice -> false)) : @complete_lattice.is_Sup_finite_compact.{0} (has_one.{0} linarith.comp) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type complete_lattice.{0}) h0) (has_one.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_70246 (h0 : ring (has_top linarith.comp_source)) : is_domain (has_top linarith.comp_source) := sorry --non-trivial
lemma new_lemma_70247 (h0 : char -> has_inv num) (h1 : has_inv num -> char) : function.right_inverse h0 h1 := sorry --non-trivial
lemma new_lemma_70248 (h0 : topological_space (with_one (metric_space linarith.comp))) : preirreducible_space (with_one (metric_space linarith.comp)) := sorry --non-trivial
lemma new_lemma_70249 (h0 : fin has_zero.zero) : matrix.vec_empty (id (id (id (id h0)))) := sorry --non-trivial
lemma new_lemma_70250 (h0 : function.extfun Type uniform_space) : @complete_space.{0} (has_sub.{0} empty) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (has_sub.{0} empty))  := sorry --non-trivial
lemma new_lemma_70251 (h0 : not (ring (preorder empty) -> false)) : @is_principal_ideal_ring.{0} (preorder.{0} empty) (@classical.by_contradiction'.{1} (ring.{0} (preorder.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_70252 (h0 : ring (distrib (has_ssubset linarith.comp_source))) : is_domain (distrib (has_ssubset linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_70253 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @unique_factorization_monoid.{1} (has_add.{1} Type) (@function.extfun_app.{3 2} (Type 1) cancel_comm_monoid_with_zero.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 cancel_comm_monoid_with_zero.{1}) (has_add.{1} Type))  := sorry --non-trivial
lemma new_lemma_70254 (h0 : ring (ordered_comm_ring (boolean_algebra.core linarith.comp))) : rank_condition (ordered_comm_ring (boolean_algebra.core linarith.comp)) := sorry --non-trivial
lemma new_lemma_70255 (h0 : not (ring (normed_field char) -> false)) : @rank_condition.{0} (normed_field.{0} char) (@classical.by_contradiction'.{1} (ring.{0} (normed_field.{0} char)) h0)  := sorry --non-trivial
lemma new_lemma_70256 (h0 : ring (filter (semiring empty))) : is_domain (filter (semiring empty)) := sorry --non-trivial
lemma new_lemma_70257 (h0 : functor.add_const (function.extfun Type finset) unsigned) : finset.nonempty (function.extfun_app (functor.add_const.run h0) (has_zero unsigned)) := sorry --non-trivial
lemma new_lemma_70258 (h0 : list (boolean_algebra environment.implicit_infer_kind)) : palindrome h0 := sorry --non-trivial
lemma new_lemma_70259 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @rank_condition.{0} (is_R_or_C.{0} empty) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (is_R_or_C.{0} empty))  := sorry --non-trivial
lemma new_lemma_70260 (h0 : functor.add_const (topological_space (semigroup unsigned)) environment.implicit_infer_kind) : @t1_space.{0} (semigroup.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (semigroup.{0} unsigned)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_70261 (h0 : not (uniform_space (plift empty) -> false)) : @complete_space.{1} (plift.{1} empty) (@classical.by_contradiction'.{2} (uniform_space.{1} (plift.{1} empty)) h0)  := sorry --non-trivial
lemma new_lemma_70262 (h0 : complete_lattice (linear_ordered_field (option ennreal))) : complete_lattice.is_Sup_finite_compact (linear_ordered_field (option ennreal)) := sorry --non-trivial
lemma new_lemma_70263 (h0 : has_mem.mem (linear_ordered_semiring (semiring num)) has_emptyc.emptyc) : @complete_lattice.is_Sup_finite_compact.{0} (linear_ordered_semiring.{0} (semiring.{0} num)) (@finset.pi.empty.{1 0} Type complete_lattice.{0} (linear_ordered_semiring.{0} (semiring.{0} num)) h0)  := sorry --non-trivial
lemma new_lemma_70264 (h0 : filter environment.implicit_infer_kind) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_70265 (h0 : list (has_neg_part unsigned)) : palindrome h0 := sorry --non-trivial
lemma new_lemma_70266 (h0 : uniform_space (has_nndist (ring name))) : separated_space (has_nndist (ring name)) := sorry --non-trivial
lemma new_lemma_70267 (h0 : functor.add_const (group (linear_ordered_comm_monoid_with_zero congr_arg_kind)) (option empty)) : @is_cyclic.{0} (linear_ordered_comm_monoid_with_zero.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (group.{0} (linear_ordered_comm_monoid_with_zero.{0} congr_arg_kind)) (option.{0} empty) h0)  := sorry --non-trivial
lemma new_lemma_70268 (h0 : ring (canonically_ordered_add_monoid (option empty))) : strong_rank_condition (canonically_ordered_add_monoid (option empty)) := sorry --non-trivial
lemma new_lemma_70269 (h0 : ring (has_nnnorm (random_gen (comm_ring (random_gen (random_gen char)))))) : rank_condition (has_nnnorm (random_gen (comm_ring (random_gen (random_gen char))))) := sorry --non-trivial
lemma new_lemma_70270 (h0 : complete_lattice (uniform_space (semigroup (random_gen char)))) : is_compactly_generated (uniform_space (semigroup (random_gen char))) := sorry --non-trivial
lemma new_lemma_70271 (h0 : function.extfun Type group) : @group.fg.{0} (denumerable.{0} string_imp) (@function.extfun_app.{2 1} Type group.{0} h0 (denumerable.{0} string_imp))  := sorry --non-trivial
lemma new_lemma_70272 (h0 : function.extfun Type complete_lattice) : @is_atomistic.{0} (has_top.{0} empty) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (has_top.{0} empty))  := sorry --non-trivial
lemma new_lemma_70273 (h0 : ring (has_to_string (option (option (option unsigned))))) : is_domain (has_to_string (option (option (option unsigned)))) := sorry --non-trivial
lemma new_lemma_70274 (h0 : functor.add_const (complete_lattice (boolean_algebra.core name)) name) : @is_compactly_generated.{0} (boolean_algebra.core.{0} name) (@functor.add_const.run.{0 0} (complete_lattice.{0} (boolean_algebra.core.{0} name)) name h0)  := sorry --non-trivial
lemma new_lemma_70275 (h0 : topological_space (complete_distrib_lattice (has_add environment.implicit_infer_kind))) : locally_compact_space (complete_distrib_lattice (has_add environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_70276 (h0 : add_group (comm_ring (has_inv (has_inv (random_gen string_imp))))) : is_add_cyclic (comm_ring (has_inv (has_inv (random_gen string_imp)))) := sorry --non-trivial
lemma new_lemma_70277 (h0 : ring (sub_neg_monoid linarith.comp)) : strong_rank_condition (sub_neg_monoid linarith.comp) := sorry --non-trivial
lemma new_lemma_70278 (h0 : ring (has_emptyc num)) : rank_condition (has_emptyc num) := sorry --non-trivial
lemma new_lemma_70279 (h0 : topological_space (is_R_or_C (option (option (option unsigned))))) : topological_space.separable_space (is_R_or_C (option (option (option unsigned)))) := sorry --non-trivial
lemma new_lemma_70280 (h0 : topological_space (has_Inf (has_neg Type))) : regular_space (has_Inf (has_neg Type)) := sorry --non-trivial
lemma new_lemma_70281 (h0 : functor.add_const (function.extfun Type semiring) (ring Type)) : @is_noetherian_ring.{0} (add_comm_monoid.{0} pos) (@function.extfun_app.{2 1} Type semiring.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type semiring.{0}) (ring.{1} Type) h0) (add_comm_monoid.{0} pos))  := sorry --non-trivial
lemma new_lemma_70282 (h0 : topological_space (add_cancel_monoid (has_add Type))) : discrete_topology (add_cancel_monoid (has_add Type)) := sorry --non-trivial
lemma new_lemma_70283 (h2 : topological_space (mul_one_class (mul_one_class enat))) : path_connected_space (mul_one_class (mul_one_class enat)) := sorry --non-trivial
lemma new_lemma_70284 (h0 : group (canonically_linear_ordered_monoid linarith.comp)) : is_simple_group (canonically_linear_ordered_monoid linarith.comp) := sorry --non-trivial
lemma new_lemma_70285 (h0 : not (function.extfun Type semiring -> false)) : @is_noetherian_ring.{0} (has_top.{0} unsigned) (@function.extfun_app.{2 1} Type semiring.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type semiring.{0}) h0) (has_top.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_70286 (h0 : group (generalized_boolean_algebra (has_bot name))) : group.fg (generalized_boolean_algebra (has_bot name)) := sorry --non-trivial
lemma new_lemma_70287 (h0 : functor.add_const (complete_lattice (left_cancel_monoid empty)) (semiring empty)) : @complete_lattice.is_Sup_finite_compact.{0} (left_cancel_monoid.{0} empty) (@functor.add_const.run.{0 0} (complete_lattice.{0} (left_cancel_monoid.{0} empty)) (semiring.{0} empty) h0)  := sorry --non-trivial
lemma new_lemma_70288 (h0 : function.extfun Type monoid) : @monoid.fg.{0} (has_top.{0} linarith.ineq) (@function.extfun_app.{2 1} Type monoid.{0} h0 (has_top.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_70289 (h0 : functor.add_const (topological_space (free_add_monoid unsigned)) unsigned) : @preconnected_space.{0} (free_add_monoid.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (free_add_monoid.{0} unsigned)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_70290 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @path_connected_space.{0} (has_bot.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_bot.{0} pos))  := sorry --non-trivial
lemma new_lemma_70291 (h0 : functor.add_const (function.extfun (Type 1) ring) Type) : @is_domain.{1} (semigroup.{1} Type) (@function.extfun_app.{3 2} (Type 1) ring.{1} (@functor.add_const.run.{2 1} (function.extfun.{3 2} (Type 1) ring.{1}) Type h0) (semigroup.{1} Type))  := sorry --non-trivial
lemma new_lemma_70292 (h0 : not (function.extfun Type monoid -> false)) : @monoid.fg.{0} (complete_semilattice_Sup.{0} unsigned) (@function.extfun_app.{2 1} Type monoid.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type monoid.{0}) h0) (complete_semilattice_Sup.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_70293 (h0 : complete_lattice (has_to_string (ring (has_to_string Type)))) : complete_lattice.is_Sup_finite_compact (has_to_string (ring (has_to_string Type))) := sorry --non-trivial
lemma new_lemma_70294 (h1 : measurable_space char) (h2 : topological_space char) (h3 : measure_theory.measure char) : measure_theory.measure.outer_regular h3 := sorry --non-trivial
lemma new_lemma_70295 (h0 : complete_lattice (add_cancel_monoid empty)) : is_atomistic (add_cancel_monoid empty) := sorry --non-trivial
lemma new_lemma_70296 (h0 : group (has_compl (mul_one_class (mul_one_class fun_info)))) : is_cyclic (has_compl (mul_one_class (mul_one_class fun_info))) := sorry --non-trivial
lemma new_lemma_70297 (h0 : topological_space (canonically_ordered_comm_semiring (ring Type))) : loc_path_connected_space (canonically_ordered_comm_semiring (ring Type)) := sorry --non-trivial
lemma new_lemma_70298 (h0 : functor.add_const (finset (mul_zero_class num)) unsigned) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_70299 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : palindrome (function.extfun_app (function.extfun_app h0 list) (ordered_ring empty)) := sorry --non-trivial
lemma new_lemma_70300 (h0 : uniform_space (distrib linarith.comp_source)) : complete_space (distrib linarith.comp_source) := sorry --non-trivial
lemma new_lemma_70301 (h0 : filter Prop) (h1 : list (filter Prop)) : @Lim.{0} Prop sierpinski_space (@nonempty_of_inhabited.{1} Prop sort.inhabited.{0}) (@list.ilast'.{0} (filter.{0} Prop) h0 h1)  := sorry --non-trivial
lemma new_lemma_70302 (h0 : monoid (has_one (has_norm num))) : monoid.fg (has_one (has_norm num)) := sorry --non-trivial
lemma new_lemma_70303 (h1 : has_lt (nondiscrete_normed_field string.iterator_imp)) : no_max_order (nondiscrete_normed_field string.iterator_imp) := sorry --non-trivial
lemma new_lemma_70304 (h0 : functor.add_const (function.extfun (Type 1) list) linarith.comp) : palindrome (function.extfun_app (functor.add_const.run h0) (add_comm_monoid Type)) := sorry --non-trivial
lemma new_lemma_70305 (h0 : function.extfun nat fin) : @is_simple_group.{1} (ordered_comm_ring.{1} Type) (@matrix.vec_empty.{1} (group.{1} (ordered_comm_ring.{1} Type)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_70306 (h0 : ring (has_neg (finset Type))) : is_principal_ideal_ring (has_neg (finset Type)) := sorry --non-trivial
lemma new_lemma_70307 (h0 : function.extfun Type topological_space) : @t0_space.{0} (random_gen.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (random_gen.{0} empty))  := sorry --non-trivial
lemma new_lemma_70308 (h0 h1 : set (has_norm (add_left_cancel_semigroup linarith.comp_source))) : set.subset h0 h1 := sorry --non-trivial
lemma new_lemma_70309 (h0 : not (has_mem.mem (has_emptyc linarith.ineq) has_emptyc.emptyc -> false)) : @normalizer_condition.{0} (has_emptyc.{0} linarith.ineq) (@finset.pi.empty.{1 0} Type group.{0} (has_emptyc.{0} linarith.ineq) (@classical.by_contradiction'.{0} (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (has_emptyc.{0} linarith.ineq) (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))) h0))  := sorry --non-trivial
lemma new_lemma_70310 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @complete_lattice.is_Sup_finite_compact.{0} (partial_order.{0} empty) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (partial_order.{0} empty))  := sorry --non-trivial
lemma new_lemma_70311 (h0 : group (canonically_ordered_add_monoid unsigned)) : is_cyclic (canonically_ordered_add_monoid unsigned) := sorry --non-trivial
lemma new_lemma_70312 (h0 : topological_space (left_cancel_monoid (left_cancel_monoid (option empty)))) : path_connected_space (left_cancel_monoid (left_cancel_monoid (option empty))) := sorry --non-trivial
lemma new_lemma_70313 (h0 : functor.add_const (prod real.angle real.angle) (semiring congr_arg_kind)) : id_rel (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_70314 (h0 : function.extfun Type topological_space) : @normal_space.{0} (cancel_monoid.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (cancel_monoid.{0} pos))  := sorry --non-trivial
lemma new_lemma_70315 (h0 : functor.add_const (finset (ordered_comm_ring Type)) (has_add pos)) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_70316 (h0 : monoid (has_neg_part Type)) : monoid.fg (has_neg_part Type) := sorry --non-trivial
lemma new_lemma_70317 (h0 : function.extfun Type add_group) : @is_add_cyclic.{0} (linear_ordered_comm_group.{0} unsigned) (@function.extfun_app.{2 1} Type add_group.{0} h0 (linear_ordered_comm_group.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_70318 (h0 : topological_space (semigroup (has_add name))) : discrete_topology (semigroup (has_add name)) := sorry --non-trivial
lemma new_lemma_70319 (h0 : functor.add_const (topological_space (semigroup linarith.comp)) environment.implicit_infer_kind) : @loc_path_connected_space.{0} (semigroup.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (semigroup.{0} linarith.comp)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_70320 (h0 : ring (add_cancel_comm_monoid (has_nnnorm reducibility_hints))) : strong_rank_condition (add_cancel_comm_monoid (has_nnnorm reducibility_hints)) := sorry --non-trivial
lemma new_lemma_70321 (h0 : fin has_zero.zero) : @topological_space.separable_space.{0} (has_Inf.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@matrix.vec_empty.{1} (function.extfun.{2 1} Type topological_space.{0}) h0) (has_Inf.{0} pos))  := sorry --non-trivial
lemma new_lemma_70322 (h0 : fin has_zero.zero) : @is_principal_ideal_ring.{0} (boolean_algebra.{0} real) (@function.extfun_app.{2 1} Type ring.{0} (@matrix.vec_empty.{1} (function.extfun.{2 1} Type ring.{0}) h0) (boolean_algebra.{0} real))  := sorry --non-trivial
lemma new_lemma_70323 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @strong_rank_condition.{0} (ordered_ring.{0} empty) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (ordered_ring.{0} empty))  := sorry --non-trivial
lemma new_lemma_70324 (h0 : ring (option unsigned)) (h1 : topological_space (subring (option unsigned))) : normal_space (subring (option unsigned)) := sorry --non-trivial
lemma new_lemma_70325 (h1 : ring (div_inv_monoid to_additive.value_type)) : is_domain (div_inv_monoid to_additive.value_type) := sorry --non-trivial
lemma new_lemma_70326 (h1 : complete_lattice (topological_space char)) : complete_lattice.is_Sup_finite_compact (topological_space char) := sorry --non-trivial
lemma new_lemma_70327 (h0 : topological_space (normed_comm_ring (comm_group unsigned))) : loc_path_connected_space (normed_comm_ring (comm_group unsigned)) := sorry --non-trivial
lemma new_lemma_70328 (h0 : topological_space (boolean_algebra (has_to_string (has_to_string (has_to_string pos))))) : totally_disconnected_space (boolean_algebra (has_to_string (has_to_string (has_to_string pos)))) := sorry --non-trivial
lemma new_lemma_70329 (h0 : complete_lattice (add_comm_monoid (normed_comm_ring name))) : is_compactly_generated (add_comm_monoid (normed_comm_ring name)) := sorry --non-trivial
lemma new_lemma_70330 (h0 : functor.add_const (topological_space (complete_distrib_lattice name)) linarith.comp) : @t0_space.{0} (complete_distrib_lattice.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (complete_distrib_lattice.{0} name)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_70331 (h0 : functor.add_const (complete_lattice (semigroup name)) (has_add (ring linarith.comp))) : @is_compactly_generated.{0} (semigroup.{0} name) (@functor.add_const.run.{0 0} (complete_lattice.{0} (semigroup.{0} name)) (has_add.{0} (ring.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_70332 (h3 : linarith.comp -> has_norm linarith.comp -> Prop) : relator.right_unique h3 := sorry --non-trivial
lemma new_lemma_70333 (h0 : topological_space (has_ssubset to_additive.value_type)) : locally_compact_space (has_ssubset to_additive.value_type) := sorry --non-trivial
lemma new_lemma_70334 (h0 : cancel_comm_monoid_with_zero (has_zero Type)) : unique_factorization_monoid (has_zero Type) := sorry --non-trivial
lemma new_lemma_70335 (h0 : group (has_nndist (finset (has_add ennreal)))) : group.fg (has_nndist (finset (has_add ennreal))) := sorry --non-trivial
lemma new_lemma_70336 (h0 : topological_space (normed_comm_ring (has_to_string linarith.comp))) : preirreducible_space (normed_comm_ring (has_to_string linarith.comp)) := sorry --non-trivial
lemma new_lemma_70337 (h0 : add_group (non_unital_non_assoc_semiring std_gen)) : is_add_cyclic (non_unital_non_assoc_semiring std_gen) := sorry --non-trivial
lemma new_lemma_70338 (h0 : topological_space (comm_semigroup (has_add real))) : path_connected_space (comm_semigroup (has_add real)) := sorry --non-trivial
lemma new_lemma_70339 (h0 : function.extfun Type group) : @group.fg.{0} (linear_ordered_cancel_comm_monoid.{0} empty) (@function.extfun_app.{2 1} Type group.{0} h0 (linear_ordered_cancel_comm_monoid.{0} empty))  := sorry --non-trivial
lemma new_lemma_70340 (h0 : topological_space (id (semiring num))) : path_connected_space (id (semiring num)) := sorry --non-trivial
lemma new_lemma_70341 (h0 : function.extfun Type topological_space) : @regular_space.{0} (ordered_comm_monoid.{0} real) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (ordered_comm_monoid.{0} real))  := sorry --non-trivial
lemma new_lemma_70342 (h0 : fin has_zero.zero) : @strong_rank_condition.{0} (ring.{0} pos) (@matrix.vec_empty.{0} (ring.{0} (ring.{0} pos)) h0)  := sorry --non-trivial
lemma new_lemma_70343 (h0 : group (has_norm (has_top (has_nnnorm linarith.comp_source)))) : group.fg (has_norm (has_top (has_nnnorm linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_70344 (h0 : char -> nnreal -> Prop) : relator.bi_unique h0 := sorry --non-trivial
lemma new_lemma_70345 (h0 h1 : multiset (mul_one_class (add_comm_semigroup fun_info))) : multiset.disjoint h0 h1 := sorry --non-trivial
lemma new_lemma_70346 (h0 : topological_space (ring (has_neg pos))) : regular_space (ring (has_neg pos)) := sorry --non-trivial
lemma new_lemma_70347 (h0 : topological_space (has_bot unsigned)) : t0_space (has_bot unsigned) := sorry --non-trivial
lemma new_lemma_70348 (h0 : group (bin_tree (semiring (semiring unsigned)))) : normalizer_condition (bin_tree (semiring (semiring unsigned))) := sorry --non-trivial
lemma new_lemma_70349 (h0 : functor.add_const (complete_lattice (comm_group linarith.comp)) linarith.comp) : @is_compactly_generated.{0} (comm_group.{0} linarith.comp) (@functor.add_const.run.{0 0} (complete_lattice.{0} (comm_group.{0} linarith.comp)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_70350 (h0 : functor.add_const (uniform_space (left_cancel_semigroup unsigned)) empty) : @separated_space.{0} (left_cancel_semigroup.{0} unsigned) (@functor.add_const.run.{0 0} (uniform_space.{0} (left_cancel_semigroup.{0} unsigned)) empty h0)  := sorry --non-trivial
lemma new_lemma_70351 (h0 : has_mem.mem (has_emptyc (random_gen linarith.comp_source)) has_emptyc.emptyc) : @complete_space.{0} (has_emptyc.{0} (random_gen.{0} linarith.comp_source)) (@finset.pi.empty.{1 0} Type uniform_space.{0} (has_emptyc.{0} (random_gen.{0} linarith.comp_source)) h0)  := sorry --non-trivial
lemma new_lemma_70352 (h0 : functor.add_const (group (add_comm_monoid linarith.comp)) Type) : @group.fg.{0} (add_comm_monoid.{0} linarith.comp) (@functor.add_const.run.{0 1} (group.{0} (add_comm_monoid.{0} linarith.comp)) Type h0)  := sorry --non-trivial
lemma new_lemma_70353 (h0 : list (ordered_ring (option empty))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_70354 (h0 : ring (has_emptyc (has_top linarith.ineq))) : is_domain (has_emptyc (has_top linarith.ineq)) := sorry --non-trivial
lemma new_lemma_70355 (h0 : function.extfun Type topological_space) : @discrete_topology.{0} (monoid.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (monoid.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_70356 (h0 : functor.add_const (complete_lattice (has_Inf linarith.comp)) linarith.comp) : @complete_lattice.is_Sup_finite_compact.{0} (has_Inf.{0} linarith.comp) (@functor.add_const.run.{0 0} (complete_lattice.{0} (has_Inf.{0} linarith.comp)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_70357 (h0 : has_nnnorm (random_gen string_imp) -> has_nnnorm (random_gen string_imp) -> Prop) (h1 : has_nnnorm (random_gen string_imp)) (h2 : function.extfun (Type -> Type) (function.extfun Type)) : eqv_gen h0 h1 (function.extfun_app (function.extfun_app h2 has_nnnorm) (random_gen string_imp)) := sorry --non-trivial
lemma new_lemma_70358 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_cyclic.{0} (has_union.{0} unsigned) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (has_union.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_70359 (h0 : functor.add_const (topological_space (boolean_algebra linarith.comp)) name) : @totally_separated_space.{0} (boolean_algebra.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (boolean_algebra.{0} linarith.comp)) name h0)  := sorry --non-trivial
lemma new_lemma_70360 (h0 : functor.add_const (ring Type) (has_Inf pos)) : @is_principal_ideal_ring.{1} Type (@functor.add_const.run.{1 0} (ring.{1} Type) (has_Inf.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_70361 (h0 : functor.add_const (ring (has_Inf pos)) (has_neg (has_nndist (ring name)))) : @is_principal_ideal_ring.{0} (has_Inf.{0} pos) (@functor.add_const.run.{0 0} (ring.{0} (has_Inf.{0} pos)) (has_neg.{0} (has_nndist.{0} (ring.{0} name))) h0)  := sorry --non-trivial
lemma new_lemma_70362 (h0 : topological_space (has_nnnorm (has_nnnorm (has_nnnorm (mul_one_class char))))) : totally_disconnected_space (has_nnnorm (has_nnnorm (has_nnnorm (mul_one_class char)))) := sorry --non-trivial
lemma new_lemma_70363 (h0 : functor.add_const (monoid (normed_comm_ring environment.implicit_infer_kind)) pos) : @monoid.fg.{0} (normed_comm_ring.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (monoid.{0} (normed_comm_ring.{0} environment.implicit_infer_kind)) pos h0)  := sorry --non-trivial
lemma new_lemma_70364 (h0 : nat -> Prop) (h1 : nat) : @disjointed.{0} Prop (@boolean_algebra.to_generalized_boolean_algebra.{0} Prop Prop.boolean_algebra) h0 h1  := sorry --non-trivial
lemma new_lemma_70365 (h0 : function.extfun Type group) : @is_cyclic.{0} (semi_normed_comm_ring.{0} (random_gen.{0} linarith.comp_source)) (@function.extfun_app.{2 1} Type group.{0} h0 (semi_normed_comm_ring.{0} (random_gen.{0} linarith.comp_source)))  := sorry --non-trivial
lemma new_lemma_70366 (h0 : uniform_space (linear_ordered_cancel_comm_monoid empty)) : separated_space (linear_ordered_cancel_comm_monoid empty) := sorry --non-trivial
lemma new_lemma_70367 (h0 : topological_space (non_assoc_semiring (semiring (semiring (semiring (semiring empty)))))) : normal_space (non_assoc_semiring (semiring (semiring (semiring (semiring empty))))) := sorry --non-trivial
lemma new_lemma_70368 (h0 : topological_space (cancel_monoid (finset Type))) : t0_space (cancel_monoid (finset Type)) := sorry --non-trivial
lemma new_lemma_70369 (h1 : not (group (fintype string_imp) -> false)) : @is_cyclic.{0} (fintype.{0} string_imp) (@classical.by_contradiction'.{1} (group.{0} (fintype.{0} string_imp)) h1)  := sorry --non-trivial
lemma new_lemma_70370 (h0 : add_group (option (option (option (option unsigned))))) : is_add_cyclic (option (option (option (option unsigned)))) := sorry --non-trivial
lemma new_lemma_70371 (h0 : fin has_zero.zero) : @regular_space.{1} (has_add.{1} Type) (@matrix.vec_empty.{1} (topological_space.{1} (has_add.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_70372 (h0 : ordered_comm_monoid (boolean_algebra (boolean_algebra name))) : has_exists_mul_of_le (boolean_algebra (boolean_algebra name)) := sorry --non-trivial
lemma new_lemma_70373 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_atomistic.{0} (pseudo_metric_space.{0} (has_zero.{0} ennreal)) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (pseudo_metric_space.{0} (has_zero.{0} ennreal)))  := sorry --non-trivial
lemma new_lemma_70374 (h1 : not (topological_space (linear_ordered_add_comm_monoid_with_top linarith.comp_source) -> false)) : @path_connected_space.{0} (linear_ordered_add_comm_monoid_with_top.{0} linarith.comp_source) (@classical.by_contradiction'.{1} (topological_space.{0} (linear_ordered_add_comm_monoid_with_top.{0} linarith.comp_source)) h1)  := sorry --non-trivial
lemma new_lemma_70375 (h0 : topological_space (mul_one_class (normed_field ereal))) : totally_disconnected_space (mul_one_class (normed_field ereal)) := sorry --non-trivial
lemma new_lemma_70376 (h0 : topological_space (simple_graph (has_Inf name))) : t1_space (simple_graph (has_Inf name)) := sorry --non-trivial
lemma new_lemma_70377 (h0 : group (normed_lattice_add_comm_group (sub_neg_monoid real))) : group.fg (normed_lattice_add_comm_group (sub_neg_monoid real)) := sorry --non-trivial
lemma new_lemma_70378 (h0 : function.extfun Type topological_space) : @irreducible_space.{0} (has_zero.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_zero.{0} pos))  := sorry --non-trivial
lemma new_lemma_70379 (h0 : set (uniform_space linarith.ineq)) : set.subsingleton h0 := sorry --non-trivial
lemma new_lemma_70380 (h0 : not (uniform_space (fintype linarith.ineq) -> false)) : @complete_space.{0} (fintype.{0} linarith.ineq) (@classical.by_contradiction'.{1} (uniform_space.{0} (fintype.{0} linarith.ineq)) h0)  := sorry --non-trivial
lemma new_lemma_70381 (h0 : function.extfun Type ring) : @is_principal_ideal_ring.{0} (add_cancel_monoid.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type ring.{0} h0 (add_cancel_monoid.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_70382 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @has_exists_mul_of_le.{0} (canonically_linear_ordered_monoid.{0} linarith.comp) (@function.extfun_app.{2 1} Type ordered_comm_monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ordered_comm_monoid.{0}) (canonically_linear_ordered_monoid.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_70383 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @topological_space.separable_space.{0} (generalized_boolean_algebra.{0} real) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (generalized_boolean_algebra.{0} real))  := sorry --non-trivial
lemma new_lemma_70384 (h0 : list (metric_space (semiring (semiring unsigned)))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_70385 (h1 : function.extfun (multiset Type) (has_mem.mem linarith.ineq)) : @t0_space.{0} linarith.ineq (@multiset.pi.empty.{1 0} Type topological_space.{0} linarith.ineq (@function.extfun_app.{2 0} (multiset.{1} Type) (@has_mem.mem.{1 1} Type (multiset.{1} Type) (@multiset.has_mem.{1} Type) linarith.ineq) h1 (@has_zero.zero.{1} (multiset.{1} Type) (@multiset.has_zero.{1} Type))))  := sorry --non-trivial
lemma new_lemma_70386 (h0 : topological_space (canonically_ordered_comm_semiring environment.implicit_infer_kind)) : path_connected_space (canonically_ordered_comm_semiring environment.implicit_infer_kind) := sorry --non-trivial
lemma new_lemma_70387 (h0 : functor.add_const (function.extfun Type ring) Type) : @is_principal_ideal_ring.{0} (add_comm_monoid.{0} name) (@function.extfun_app.{2 1} Type ring.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type ring.{0}) Type h0) (add_comm_monoid.{0} name))  := sorry --non-trivial
lemma new_lemma_70388 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @totally_separated_space.{0} (has_emptyc.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_emptyc.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_70389 (h0 : function.extfun Type group) : @group.fg.{0} (has_norm.{0} linarith.ineq) (@function.extfun_app.{2 1} Type group.{0} h0 (has_norm.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_70390 (h0 : topological_space (boolean_algebra (add_comm_monoid unsigned))) : preirreducible_space (boolean_algebra (add_comm_monoid unsigned)) := sorry --non-trivial
lemma new_lemma_70391 (h0 : complete_lattice (has_zero (comm_group (comm_group (comm_group (comm_group pos)))))) : is_atomistic (has_zero (comm_group (comm_group (comm_group (comm_group pos))))) := sorry --non-trivial
lemma new_lemma_70392 (h0 : functor.add_const (function.extfun (Type 1) add_monoid) linarith.comp) : @add_monoid.fg.{1} (generalized_boolean_algebra.{1} Type) (@function.extfun_app.{3 2} (Type 1) add_monoid.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) add_monoid.{1}) linarith.comp h0) (generalized_boolean_algebra.{1} Type))  := sorry --non-trivial
lemma new_lemma_70393 (h0 : not (topological_space (with_one (semiring fun_info)) -> false)) : @path_connected_space.{0} (with_one.{0} (semiring.{0} fun_info)) (@classical.by_contradiction'.{1} (topological_space.{0} (with_one.{0} (semiring.{0} fun_info))) h0)  := sorry --non-trivial
lemma new_lemma_70394 (h0 : ring (has_edist (option unsigned))) : rank_condition (has_edist (option unsigned)) := sorry --non-trivial
lemma new_lemma_70395 (h0 : list (has_nndist (finset name))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_70396 (h0 : fin has_zero.zero) : @rank_condition.{0} (has_bot.{0} pos) (@matrix.vec_empty.{0} (ring.{0} (has_bot.{0} pos)) (@matrix.vec_empty.{0} (fin (@has_zero.zero.{0} nat nat.has_zero)) h0))  := sorry --non-trivial
lemma new_lemma_70397 (h2 : topological_space linarith.comp_source) (h3 : preorder linarith.comp_source) : order_closed_topology linarith.comp_source := sorry --non-trivial
lemma new_lemma_70398 (h0 : functor.add_const (complete_lattice (has_neg ennreal)) Type) : @complete_lattice.is_Sup_finite_compact.{0} (has_neg.{0} ennreal) (@functor.add_const.run.{0 1} (complete_lattice.{0} (has_neg.{0} ennreal)) Type h0)  := sorry --non-trivial
lemma new_lemma_70399 (h0 : function.extfun ((Type -> Type) -> Type 1) (function.extfun (Type -> Type))) : @totally_disconnected_space.{0} (has_top.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) (@function.extfun_app.{3 2} ((Type → Type) → Type 1) (function.extfun.{2 2} (Type → Type)) h0 (function.extfun.{2 1} Type)) topological_space.{0}) (has_top.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_70400 (h1 : function.extfun Type topological_space) : @locally_compact_space.{0} num (@function.extfun_app.{2 1} Type topological_space.{0} h1 num)  := sorry --non-trivial
lemma new_lemma_70401 (h0 : function.extfun Type list) : list.nodup (function.extfun_app h0 (add_right_cancel_monoid unsigned)) := sorry --non-trivial
lemma new_lemma_70402 (h0 : monoid (linear_ordered_add_comm_group (has_inv (comm_ring linarith.ineq)))) : monoid.fg (linear_ordered_add_comm_group (has_inv (comm_ring linarith.ineq))) := sorry --non-trivial
lemma new_lemma_70403 (h0 : topological_space (ring (has_neg Type))) : t0_space (ring (has_neg Type)) := sorry --non-trivial
lemma new_lemma_70404 (h0 : functor.add_const (topological_space (boolean_algebra unsigned)) name) : @t0_space.{0} (boolean_algebra.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (boolean_algebra.{0} unsigned)) name h0)  := sorry --non-trivial
lemma new_lemma_70405 (h1 : function.extfun (Type -> Type) (function.extfun Type)) : list.nodup (function.extfun_app (function.extfun_app h1 list) linarith.comp_source) := sorry --non-trivial
lemma new_lemma_70406 (h0 : function.extfun (Type 1) ring) : @strong_rank_condition.{1} (plift.{1} num) (@function.extfun_app.{3 2} (Type 1) ring.{1} h0 (plift.{1} num))  := sorry --non-trivial
lemma new_lemma_70407 (h0 : not (ring (mul_zero_class unsigned) -> false)) : @strong_rank_condition.{0} (mul_zero_class.{0} unsigned) (@classical.by_contradiction'.{1} (ring.{0} (mul_zero_class.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_70408 (h0 : list (finset (has_neg (has_neg name)))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_70409 (h0 : topological_space (option (option empty))) : path_connected_space (option (option empty)) := sorry --non-trivial
lemma new_lemma_70410 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : palindrome (list.ret (function.extfun_app (function.extfun_app h0 ring) ennreal)) := sorry --non-trivial
lemma new_lemma_70411 (h0 : uniform_space (with_bot linarith.comp_source)) : complete_space (with_bot linarith.comp_source) := sorry --non-trivial
lemma new_lemma_70412 (h0 : preorder (denumerable linarith.comp_source)) (h1 : set (denumerable linarith.comp_source)) : bdd_above h1 := sorry --non-trivial
lemma new_lemma_70413 (h0 : group (ring (has_add (has_add (has_add Type))))) : is_simple_group (ring (has_add (has_add (has_add Type)))) := sorry --non-trivial
lemma new_lemma_70414 (h0 : functor.add_const (function.extfun Type uniform_space) (mul_zero_class name)) : @complete_space.{0} (normed_comm_ring.{0} ennreal) (@function.extfun_app.{2 1} Type uniform_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type uniform_space.{0}) (mul_zero_class.{0} name) h0) (normed_comm_ring.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_70415 (h0 : uniform_space (has_neg (boolean_algebra pos))) : separated_space (has_neg (boolean_algebra pos)) := sorry --non-trivial
lemma new_lemma_70416 (h0 : finset (semigroup (has_add (has_add name)))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_70417 (h0 : function.extfun Type ring) : @rank_condition.{0} (has_ssubset.{0} fun_info) (@function.extfun_app.{2 1} Type ring.{0} h0 (has_ssubset.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_70418 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @irreducible_space.{0} (partial_order.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (partial_order.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_70419 (h0 : group (has_neg (has_nndist Type))) : group.fg (has_neg (has_nndist Type)) := sorry --non-trivial
lemma new_lemma_70420 (h0 : filter (has_inter congr_arg_kind)) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_70421 (h0 : monoid (complete_semilattice_Sup (random_gen fun_info))) : monoid.fg (complete_semilattice_Sup (random_gen fun_info)) := sorry --non-trivial
lemma new_lemma_70422 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @irreducible_space.{0} (filter.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (filter.{0} num))  := sorry --non-trivial
lemma new_lemma_70423 (h0 : uniform_space (div_inv_monoid linarith.comp_source)) : complete_space (div_inv_monoid linarith.comp_source) := sorry --non-trivial
lemma new_lemma_70424 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @rank_condition.{0} (has_add.{0} pos) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (has_add.{0} pos))  := sorry --non-trivial
lemma new_lemma_70425 (h0 : group (has_nndist (option empty))) : normalizer_condition (has_nndist (option empty)) := sorry --non-trivial
lemma new_lemma_70426 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @loc_path_connected_space.{0} (monoid.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (monoid.{0} num))  := sorry --non-trivial
lemma new_lemma_70427 (h0 : ordered_comm_monoid (ring (has_pos_part linarith.comp))) : has_exists_mul_of_le (ring (has_pos_part linarith.comp)) := sorry --non-trivial
lemma new_lemma_70428 (h0 : ring (canonically_ordered_add_monoid (option (option empty)))) : strong_rank_condition (canonically_ordered_add_monoid (option (option empty))) := sorry --non-trivial
lemma new_lemma_70429 (h0 : topological_space (has_compl linarith.ineq)) (h1 : preorder (has_compl linarith.ineq)) : order_closed_topology (has_compl linarith.ineq) := sorry --non-trivial
lemma new_lemma_70430 (h0 : fin has_zero.zero) : @t0_space.{0} (ordered_comm_ring.{0} real) (@function.extfun_app.{2 1} Type topological_space.{0} (@matrix.vec_empty.{1} (function.extfun.{2 1} Type topological_space.{0}) (@matrix.vec_empty.{0} (fin (@has_zero.zero.{0} nat nat.has_zero)) h0)) (ordered_comm_ring.{0} real))  := sorry --non-trivial
lemma new_lemma_70431 (h0 : functor.add_const (topological_space (boolean_algebra name)) (ring Type)) : @discrete_topology.{0} (boolean_algebra.{0} name) (@functor.add_const.run.{0 1} (topological_space.{0} (boolean_algebra.{0} name)) (ring.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_70432 (h0 : topological_space (has_edist unsigned)) : locally_compact_space (has_edist unsigned) := sorry --non-trivial
lemma new_lemma_70433 (h0 : group (ring (has_neg linarith.comp))) : group.fg (ring (has_neg linarith.comp)) := sorry --non-trivial
lemma new_lemma_70434 (h0 : topological_space (add_right_cancel_monoid unsigned)) : normal_space (add_right_cancel_monoid unsigned) := sorry --non-trivial
lemma new_lemma_70435 (h0 : group (canonically_ordered_comm_semiring (has_add name))) : is_simple_group (canonically_ordered_comm_semiring (has_add name)) := sorry --non-trivial
lemma new_lemma_70436 (h0 : topological_space (random_gen char)) : path_connected_space (random_gen char) := sorry --non-trivial
lemma new_lemma_70437 (h0 : functor.add_const (group (ordered_comm_group empty)) unsigned) : @is_cyclic.{0} (ordered_comm_group.{0} empty) (@functor.add_const.run.{0 0} (group.{0} (ordered_comm_group.{0} empty)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_70438 (h0 : fin has_zero.zero) : @is_noetherian_ring.{1} (has_pos_part.{1} Type) (@matrix.vec_empty.{1} (semiring.{1} (has_pos_part.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_70439 (h0 : function.extfun Type (prod (finset ennreal))) : id_rel (function.extfun_app h0 (finset ennreal)) := sorry --non-trivial
lemma new_lemma_70440 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_atomistic.{0} (monoid_with_zero.{0} ennreal) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (monoid_with_zero.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_70441 (h0 : topological_space (dlist (random_gen linarith.ineq))) : totally_disconnected_space (dlist (random_gen linarith.ineq)) := sorry --non-trivial
lemma new_lemma_70442 (h0 : topological_space (linear_ordered_comm_group_with_zero char)) (h1 : has_div (linear_ordered_comm_group_with_zero char)) : has_continuous_div (linear_ordered_comm_group_with_zero char) := sorry --non-trivial
lemma new_lemma_70443 (h0 : function.extfun nat fin) : @normal_space.{0} (normed_lattice_add_comm_group.{0} pos) (@matrix.vec_empty.{0} (topological_space.{0} (normed_lattice_add_comm_group.{0} pos)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_70444 (h0 : topological_space (finset (has_pos_part (complete_semilattice_Sup pos)))) : t1_space (finset (has_pos_part (complete_semilattice_Sup pos))) := sorry --non-trivial
lemma new_lemma_70445 (h0 : filter (finset (finset (finset Type)))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_70446 (h0 : functor.add_const (complete_lattice (comm_group unsigned)) linarith.comp) : @complete_lattice.is_Sup_finite_compact.{0} (comm_group.{0} unsigned) (@functor.add_const.run.{0 0} (complete_lattice.{0} (comm_group.{0} unsigned)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_70447 (h0 : functor.add_const (filter (add_cancel_monoid Type)) (comm_group (has_add (has_neg_part (has_add Type))))) : filter.ne_bot (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_70448 (h0 : functor.add_const (function.extfun Type add_group) (mul_zero_class name)) : @is_add_cyclic.{0} (canonically_ordered_comm_semiring.{0} pos) (@function.extfun_app.{2 1} Type add_group.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type add_group.{0}) (mul_zero_class.{0} name) h0) (canonically_ordered_comm_semiring.{0} pos))  := sorry --non-trivial
lemma new_lemma_70449 (h0 : function.extfun Type topological_space) : @irreducible_space.{0} (has_pos_part.{0} real) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_pos_part.{0} real))  := sorry --non-trivial
lemma new_lemma_70450 (h0 : topological_space (has_to_string (finset (semigroup name)))) : irreducible_space (has_to_string (finset (semigroup name))) := sorry --non-trivial
lemma new_lemma_70451 (h0 : topological_space (has_zero (finset (finset linarith.comp)))) : preirreducible_space (has_zero (finset (finset linarith.comp))) := sorry --non-trivial
lemma new_lemma_70452 (h0 : function.extfun Type (functor.add_const (ring unsigned))) : @is_domain.{0} unsigned (@functor.add_const.run.{0 0} (ring.{0} unsigned) empty (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (ring.{0} unsigned)) h0 empty))  := sorry --non-trivial
lemma new_lemma_70453 (h0 : ring (add_left_cancel_monoid (has_nnnorm (semi_normed_ring char)))) : strong_rank_condition (add_left_cancel_monoid (has_nnnorm (semi_normed_ring char))) := sorry --non-trivial
lemma new_lemma_70454 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @locally_compact_space.{0} (add_cancel_monoid.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (add_cancel_monoid.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_70455 (h0 : ring (normed_group (has_nnnorm (random_gen (denumerable fun_info))))) : strong_rank_condition (normed_group (has_nnnorm (random_gen (denumerable fun_info)))) := sorry --non-trivial
lemma new_lemma_70456 (h0 : function.extfun Type topological_space) : normal_space ennreal := sorry --non-trivial
lemma new_lemma_70457 (h0 : function.extfun nat fin) : @is_cyclic.{0} (sub_neg_monoid.{0} real) (@matrix.vec_empty.{0} (group.{0} (sub_neg_monoid.{0} real)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_70458 (h0 : monoid (has_neg (add_comm_monoid Type))) : monoid.fg (has_neg (add_comm_monoid Type)) := sorry --non-trivial
lemma new_lemma_70459 (h0 : functor.add_const (topological_space (plift num)) num) : @discrete_topology.{1} (plift.{1} num) (@functor.add_const.run.{1 0} (topological_space.{1} (plift.{1} num)) num h0)  := sorry --non-trivial
lemma new_lemma_70460 (h0 : topological_space (has_add (has_neg (semigroup pos)))) : t0_space (has_add (has_neg (semigroup pos))) := sorry --non-trivial
lemma new_lemma_70461 (h0 : topological_space (has_add (boolean_algebra.core Type))) : t0_space (has_add (boolean_algebra.core Type)) := sorry --non-trivial
lemma new_lemma_70462 (h0 : group (comm_group (has_zero pos))) : normalizer_condition (comm_group (has_zero pos)) := sorry --non-trivial
lemma new_lemma_70463 (h0 : functor.add_const (ring (add_cancel_monoid unsigned)) empty) : @strong_rank_condition.{0} (add_cancel_monoid.{0} unsigned) (@functor.add_const.run.{0 0} (ring.{0} (add_cancel_monoid.{0} unsigned)) empty h0)  := sorry --non-trivial
lemma new_lemma_70464 (h0 : complete_lattice (has_compl (mul_one_class reducibility_hints))) : complete_lattice.is_Sup_finite_compact (has_compl (mul_one_class reducibility_hints)) := sorry --non-trivial
lemma new_lemma_70465 (h0 : topological_space (has_to_string (has_to_string environment.implicit_infer_kind))) : regular_space (has_to_string (has_to_string environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_70466 (h0 : topological_space (normed_comm_ring (has_add (has_add Type)))) : sequential_space (normed_comm_ring (has_add (has_add Type))) := sorry --non-trivial
lemma new_lemma_70467 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_principal_ideal_ring.{0} (group_with_zero.{0} empty) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (group_with_zero.{0} empty))  := sorry --non-trivial
lemma new_lemma_70468 (h0 : functor.add_const (group (linear_ordered_comm_monoid_with_zero unsigned)) num) : @normalizer_condition.{0} (linear_ordered_comm_monoid_with_zero.{0} unsigned) (@functor.add_const.run.{0 0} (group.{0} (linear_ordered_comm_monoid_with_zero.{0} unsigned)) num h0)  := sorry --non-trivial
lemma new_lemma_70469 (h0 : topological_space (add_semigroup congr_arg_kind)) : preirreducible_space (add_semigroup congr_arg_kind) := sorry --non-trivial
lemma new_lemma_70470 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_cyclic.{0} (monoid.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (monoid.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_70471 (h0 : semiring (has_one (semiring unsigned))) : is_noetherian_ring (has_one (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_70472 (h0 : has_mem.mem (linear_ordered_semiring congr_arg_kind) has_emptyc.emptyc) : @discrete_topology.{0} (linear_ordered_semiring.{0} congr_arg_kind) (@finset.pi.empty.{1 0} Type topological_space.{0} (linear_ordered_semiring.{0} congr_arg_kind) h0)  := sorry --non-trivial
lemma new_lemma_70473 (h0 : not (complete_lattice (has_sub congr_arg_kind) -> false)) : @is_atomistic.{0} (has_sub.{0} congr_arg_kind) (@classical.by_contradiction'.{1} (complete_lattice.{0} (has_sub.{0} congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_70474 (h0 : preorder (semi_normed_comm_ring (mul_one_class linarith.ineq))) (h1 : set (semi_normed_comm_ring (mul_one_class linarith.ineq))) : set.ord_connected h1 := sorry --non-trivial
lemma new_lemma_70475 (h0 : not (topological_space (add_group unsigned) -> false)) : @t0_space.{0} (add_group.{0} unsigned) (@classical.by_contradiction'.{1} (topological_space.{0} (add_group.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_70476 (h0 : finset (bin_tree (semiring unsigned))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_70477 (h0 : function.extfun Type (functor.add_const Prop)) : functor.add_const.run (function.extfun_app h0 (add_comm_monoid congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_70478 (h3 : preorder enat) (h4 : set enat) : set.is_pwo h4 := sorry --non-trivial
lemma new_lemma_70479 (h0 : prod (has_to_string unsigned) (has_to_string unsigned)) : id_rel h0 := sorry --non-trivial
lemma new_lemma_70480 (h0 : semiring (comm_group (boolean_algebra pos))) : is_noetherian_ring (comm_group (boolean_algebra pos)) := sorry --non-trivial
lemma new_lemma_70481 (h0 : list (normed_group (has_norm to_additive.value_type))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_70482 (h0 : not (monoid (measurable_space num) -> false)) : @monoid.fg.{0} (measurable_space.{0} num) (@classical.by_contradiction'.{1} (monoid.{0} (measurable_space.{0} num)) h0)  := sorry --non-trivial
lemma new_lemma_70483 (h0 : has_mem.mem topological_space has_emptyc.emptyc) : @path_connected_space.{0} (has_top.{0} (has_top.{0} linarith.comp_source)) (@function.extfun_app.{2 1} Type topological_space.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) topological_space.{0} h0) (has_top.{0} (has_top.{0} linarith.comp_source)))  := sorry --non-trivial
lemma new_lemma_70484 (h0 : ordered_add_comm_monoid (finset (comm_group ennreal))) : archimedean (finset (comm_group ennreal)) := sorry --non-trivial
lemma new_lemma_70485 (h0 : functor.add_const (function.extfun (Type 1) monoid) Type) : @monoid.fg.{1} (has_neg.{1} Type) (@function.extfun_app.{3 2} (Type 1) monoid.{1} (@functor.add_const.run.{2 1} (function.extfun.{3 2} (Type 1) monoid.{1}) Type h0) (has_neg.{1} Type))  := sorry --non-trivial
lemma new_lemma_70486 (h0 : ring (has_ssubset (add_comm_semigroup linarith.ineq))) : is_domain (has_ssubset (add_comm_semigroup linarith.ineq)) := sorry --non-trivial
lemma new_lemma_70487 (h0 : not (group (add_group congr_arg_kind) -> false)) : @is_cyclic.{0} (add_group.{0} congr_arg_kind) (@classical.by_contradiction'.{1} (group.{0} (add_group.{0} congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_70488 (h0 : functor.add_const (topological_space (boolean_algebra.core name)) linarith.comp) : @totally_disconnected_space.{0} (boolean_algebra.core.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (boolean_algebra.core.{0} name)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_70489 (h2 : ring (dlist fun_info)) : rank_condition (dlist fun_info) := sorry --non-trivial
lemma new_lemma_70490 (h0 : topological_space (has_zero (option ennreal))) : preconnected_space (has_zero (option ennreal)) := sorry --non-trivial
lemma new_lemma_70491 (h0 : group (has_norm (random_gen (has_inv (has_inv (random_gen fun_info)))))) : is_cyclic (has_norm (random_gen (has_inv (has_inv (random_gen fun_info))))) := sorry --non-trivial
lemma new_lemma_70492 (h0 : add_monoid (canonically_ordered_comm_semiring (add_comm_monoid (add_comm_monoid (has_add name))))) : add_monoid.fg (canonically_ordered_comm_semiring (add_comm_monoid (add_comm_monoid (has_add name)))) := sorry --non-trivial
lemma new_lemma_70493 (h0 : uniform_space (boolean_algebra.core environment.implicit_infer_kind)) : separated_space (boolean_algebra.core environment.implicit_infer_kind) := sorry --non-trivial
lemma new_lemma_70494 (h0 : topological_space (has_pos_part (has_add (has_Inf (has_add pos))))) : preirreducible_space (has_pos_part (has_add (has_Inf (has_add pos)))) := sorry --non-trivial
lemma new_lemma_70495 (h0 : has_mem.mem (add_comm_monoid fun_info) has_emptyc.emptyc) : @totally_disconnected_space.{0} (add_comm_monoid.{0} fun_info) (@finset.pi.empty.{1 0} Type topological_space.{0} (add_comm_monoid.{0} fun_info) h0)  := sorry --non-trivial
lemma new_lemma_70496 (h0 : not (complete_lattice (distrib (semi_normed_ring (comm_ring char))) -> false)) : @is_compactly_generated.{0} (distrib.{0} (semi_normed_ring.{0} (comm_ring.{0} char))) (@classical.by_contradiction'.{1} (complete_lattice.{0} (distrib.{0} (semi_normed_ring.{0} (comm_ring.{0} char)))) h0)  := sorry --non-trivial
lemma new_lemma_70497 (h1 : list (with_one linarith.ineq)) : list.nodup h1 := sorry --non-trivial
lemma new_lemma_70498 (h0 : topological_space (has_zero (finset (has_pos_part (generalized_boolean_algebra Type))))) : locally_compact_space (has_zero (finset (has_pos_part (generalized_boolean_algebra Type)))) := sorry --non-trivial
lemma new_lemma_70499 (h0 : semiring (has_add (has_Inf (has_neg name)))) : is_noetherian_ring (has_add (has_Inf (has_neg name))) := sorry --non-trivial
lemma new_lemma_70500 (h0 : functor.add_const (topological_space (measure_theory.measure_space num)) num) : @topological_space.separable_space.{0} (measure_theory.measure_space.{0} num) (@functor.add_const.run.{0 0} (topological_space.{0} (measure_theory.measure_space.{0} num)) num h0)  := sorry --non-trivial
lemma new_lemma_70501 (h0 : has_mem.mem (has_top to_additive.value_type) has_emptyc.emptyc) : @complete_space.{0} (has_top.{0} to_additive.value_type) (@finset.pi.empty.{1 0} Type uniform_space.{0} (has_top.{0} to_additive.value_type) h0)  := sorry --non-trivial
lemma new_lemma_70502 (h0 : not (topological_space (plift unsigned) -> false)) : @topological_space.separable_space.{1} (plift.{1} unsigned) (@classical.by_contradiction'.{2} (topological_space.{1} (plift.{1} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_70503 (h0 : function.extfun Type topological_space) : @path_connected_space.{0} (ordered_ring.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (ordered_ring.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_70504 (h0 : add_group (mul_one_class string.iterator_imp)) : is_add_cyclic (mul_one_class string.iterator_imp) := sorry --non-trivial
lemma new_lemma_70505 (h0 : add_cancel_monoid num -> add_cancel_monoid num -> Prop) : reflexive h0 := sorry --non-trivial
lemma new_lemma_70506 (h0 : complete_lattice (linear_order empty)) : is_compactly_generated (linear_order empty) := sorry --non-trivial
lemma new_lemma_70507 (h0 : functor.add_const (topological_space (has_add ennreal)) num) : @irreducible_space.{0} (has_add.{0} ennreal) (@functor.add_const.run.{0 0} (topological_space.{0} (has_add.{0} ennreal)) num h0)  := sorry --non-trivial
lemma new_lemma_70508 (h0 : group (boolean_algebra.core (comm_group Type))) : group.fg (boolean_algebra.core (comm_group Type)) := sorry --non-trivial
lemma new_lemma_70509 (h0 : functor.add_const (ring (has_zero pos)) environment.implicit_infer_kind) : @strong_rank_condition.{0} (has_zero.{0} pos) (@functor.add_const.run.{0 0} (ring.{0} (has_zero.{0} pos)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_70510 (h0 : not (function.extfun Type topological_space -> false)) : @path_connected_space.{0} (add_right_cancel_monoid.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (add_right_cancel_monoid.{0} num))  := sorry --non-trivial
lemma new_lemma_70511 (h0 : function.extfun Type (functor.add_const Prop)) : functor.add_const.run (function.extfun_app h0 (cancel_monoid pos)) := sorry --non-trivial
lemma new_lemma_70512 (h0 : add_group (comm_group (has_neg_part (finset linarith.comp)))) : is_add_cyclic (comm_group (has_neg_part (finset linarith.comp))) := sorry --non-trivial
lemma new_lemma_70513 (h0 : not (function.extfun Type group -> false)) : @group.fg.{0} (complete_semilattice_Sup.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type group.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type group.{0}) h0) (complete_semilattice_Sup.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_70514 (h0 : uniform_space (canonically_ordered_comm_semiring num)) : separated_space (canonically_ordered_comm_semiring num) := sorry --non-trivial
lemma new_lemma_70515 (h0 : set (nondiscrete_normed_field (nondiscrete_normed_field enat) -> mul_one_class enat)) : set.separates_points h0 := sorry --non-trivial
lemma new_lemma_70516 (h0 : ring (metric_space empty)) : strong_rank_condition (metric_space empty) := sorry --non-trivial
lemma new_lemma_70517 (h0 : functor.add_const (ring (boolean_algebra.core environment.implicit_infer_kind)) linarith.comp) : @rank_condition.{0} (boolean_algebra.core.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (ring.{0} (boolean_algebra.core.{0} environment.implicit_infer_kind)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_70518 (h0 : uniform_space (topological_space (has_nnnorm (random_gen (random_gen char))))) : complete_space (topological_space (has_nnnorm (random_gen (random_gen char)))) := sorry --non-trivial
lemma new_lemma_70519 (h0 : topological_space (measure_theory.measure_space (semiring congr_arg_kind))) : t0_space (measure_theory.measure_space (semiring congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_70520 (h0 : group (canonically_linear_ordered_monoid unsigned)) : group.fg (canonically_linear_ordered_monoid unsigned) := sorry --non-trivial
lemma new_lemma_70521 (h0 : list (ring ennreal)) : palindrome h0 := sorry --non-trivial
lemma new_lemma_70522 (h0 : finset (has_add (has_Inf linarith.comp))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_70523 (h0 : topological_space (with_one (random_gen (random_gen linarith.ineq)))) : locally_compact_space (with_one (random_gen (random_gen linarith.ineq))) := sorry --non-trivial
lemma new_lemma_70524 (h0 : group (has_neg (has_neg (ring (ring pos))))) : normalizer_condition (has_neg (has_neg (ring (ring pos)))) := sorry --non-trivial
lemma new_lemma_70525 (h2 : measurable_space fun_info) (h3 : filter fun_info) : filter.is_measurably_generated h3 := sorry --non-trivial
lemma new_lemma_70526 (h0 : not (topological_space (plift num) -> false)) : @normal_space.{1} (plift.{1} num) (@classical.by_contradiction'.{2} (topological_space.{1} (plift.{1} num)) h0)  := sorry --non-trivial
lemma new_lemma_70527 (h0 : group (has_zero pos)) : is_simple_group (has_zero pos) := sorry --non-trivial
lemma new_lemma_70528 (h0 : not (ring fun_info -> false)) : @is_domain.{0} fun_info (@classical.by_contradiction'.{1} (ring.{0} fun_info) h0)  := sorry --non-trivial
lemma new_lemma_70529 (h0 : has_mul (has_add environment.implicit_infer_kind)) (h1 : functor.add_const (has_add environment.implicit_infer_kind) pos) : is_right_regular (functor.add_const.run h1) := sorry --non-trivial
lemma new_lemma_70530 (h0 : function.extfun Type topological_space) : @t0_space.{0} (has_add.{0} (option.{0} (option.{0} pos))) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_add.{0} (option.{0} (option.{0} pos))))  := sorry --non-trivial
lemma new_lemma_70531 (h0 : filter (normed_comm_ring (boolean_algebra (has_add pos)))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_70532 (h0 : uniform_space (ring (has_to_string (has_to_string linarith.comp)))) : separated_space (ring (has_to_string (has_to_string linarith.comp))) := sorry --non-trivial
lemma new_lemma_70533 (h0 : topological_space (boolean_algebra linarith.comp)) : normal_space (boolean_algebra linarith.comp) := sorry --non-trivial
lemma new_lemma_70534 (h0 : functor.add_const (topological_space (mul_zero_class empty)) unsigned) : @totally_disconnected_space.{0} (mul_zero_class.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (mul_zero_class.{0} empty)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_70535 (h0 : functor.add_const (function.extfun Type list) Type) : list.nodup (function.extfun_app (functor.add_const.run h0) (has_neg linarith.comp)) := sorry --non-trivial
lemma new_lemma_70536 (h0 : functor.add_const (ring (has_add environment.implicit_infer_kind)) linarith.comp) : @strong_rank_condition.{0} (has_add.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (ring.{0} (has_add.{0} environment.implicit_infer_kind)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_70537 (h0 : uniform_space (has_add (has_neg (ordered_comm_monoid real)))) : complete_space (has_add (has_neg (ordered_comm_monoid real))) := sorry --non-trivial
lemma new_lemma_70538 (h0 : topological_space (canonically_ordered_comm_semiring (ring Type))) : t0_space (canonically_ordered_comm_semiring (ring Type)) := sorry --non-trivial
lemma new_lemma_70539 (h0 : function.extfun (finset Type) (has_mem.mem (has_one empty))) : @is_atomistic.{0} (has_one.{0} empty) (@finset.pi.empty.{1 0} Type complete_lattice.{0} (has_one.{0} empty) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (has_one.{0} empty)) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_70540 (h0 : uniform_space (has_neg (finset linarith.comp))) : complete_space (has_neg (finset linarith.comp)) := sorry --non-trivial
lemma new_lemma_70541 (h0 : not (topological_space (encodable linarith.comp_source) -> false)) : @path_connected_space.{0} (encodable.{0} linarith.comp_source) (@classical.by_contradiction'.{1} (topological_space.{0} (encodable.{0} linarith.comp_source)) h0)  := sorry --non-trivial
lemma new_lemma_70542 (h0 : not (add_group (simple_graph (metric_space to_additive.value_type)) -> false)) : @is_add_cyclic.{0} (simple_graph.{0} (metric_space.{0} to_additive.value_type)) (@classical.by_contradiction'.{1} (add_group.{0} (simple_graph.{0} (metric_space.{0} to_additive.value_type))) h0)  := sorry --non-trivial
lemma new_lemma_70543 (h0 : group (semiring (random_gen linarith.ineq))) : normalizer_condition (semiring (random_gen linarith.ineq)) := sorry --non-trivial
lemma new_lemma_70544 (h0 : cancel_comm_monoid_with_zero (has_one (semiring (semiring (semiring empty))))) : unique_factorization_monoid (has_one (semiring (semiring (semiring empty)))) := sorry --non-trivial
lemma new_lemma_70545 (h0 : monoid (normed_comm_ring (has_neg pos))) : monoid.fg (normed_comm_ring (has_neg pos)) := sorry --non-trivial
lemma new_lemma_70546 (h0 : functor.add_const (topological_space (has_neg linarith.comp)) (boolean_algebra environment.implicit_infer_kind)) : @preconnected_space.{0} (has_neg.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (has_neg.{0} linarith.comp)) (boolean_algebra.{0} environment.implicit_infer_kind) h0)  := sorry --non-trivial
lemma new_lemma_70547 (h0 : filter (complete_distrib_lattice (option ennreal))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_70548 : infinite ennreal := sorry --non-trivial
lemma new_lemma_70549 (h0 : ordered_comm_monoid (has_Inf (has_Inf (ring (boolean_algebra Type))))) : has_exists_mul_of_le (has_Inf (has_Inf (ring (boolean_algebra Type)))) := sorry --non-trivial
lemma new_lemma_70550 (h1 : set (reducibility_hints -> linarith.ineq)) : set.separates_points h1 := sorry --non-trivial
lemma new_lemma_70551 (h0 : topological_space (has_pos_part (has_add (has_add (has_add (has_Inf (has_Inf Type))))))) : sequential_space (has_pos_part (has_add (has_add (has_add (has_Inf (has_Inf Type)))))) := sorry --non-trivial
lemma new_lemma_70552 (h0 : fin has_zero.zero) : is_atomistic (uniform_space empty) := sorry --non-trivial
lemma new_lemma_70553 (h0 : functor.add_const (topological_space (add_cancel_monoid unsigned)) pos) : @sequential_space.{0} (add_cancel_monoid.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (add_cancel_monoid.{0} unsigned)) pos h0)  := sorry --non-trivial
lemma new_lemma_70554 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @is_principal_ideal_ring.{1} (complete_distrib_lattice.{1} Type) (@function.extfun_app.{3 2} (Type 1) ring.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 ring.{1}) (complete_distrib_lattice.{1} Type))  := sorry --non-trivial
lemma new_lemma_70555 (h0 : filter (linear_ordered_field (has_to_string ennreal))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_70556 (h0 : topological_space (ordered_comm_ring (has_Inf (has_add Type)))) : totally_separated_space (ordered_comm_ring (has_Inf (has_add Type))) := sorry --non-trivial
lemma new_lemma_70557 (h0 : not (group (measurable_space linarith.comp) -> false)) : @normalizer_condition.{0} (measurable_space.{0} linarith.comp) (@classical.by_contradiction'.{1} (group.{0} (measurable_space.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_70558 (h0 : function.extfun Type topological_space) : @loc_path_connected_space.{0} (has_Inf.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_Inf.{0} pos))  := sorry --non-trivial
lemma new_lemma_70559 (h0 : add_group (has_le (normed_field to_additive.value_type))) : is_add_cyclic (has_le (normed_field to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_70560 (h0 : function.extfun Type list) : list.nodup (function.extfun_app h0 (group_with_zero empty)) := sorry --non-trivial
lemma new_lemma_70561 (h0 : topological_space (has_neg unsigned)) : topological_space.separable_space (has_neg unsigned) := sorry --non-trivial
lemma new_lemma_70562 (h0 : filter (option (semiring (semiring empty)))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_70563 (h0 : has_neg (has_div linarith.comp_source)) (h1 : measurable_space (has_div linarith.comp_source)) : has_measurable_neg (has_div linarith.comp_source) := sorry --non-trivial
lemma new_lemma_70564 (h0 : add_monoid (ordered_cancel_comm_monoid empty)) (h1 : has_one (ordered_cancel_comm_monoid empty)) : char_zero (ordered_cancel_comm_monoid empty) := sorry --non-trivial
lemma new_lemma_70565 (h0 : topological_space (add_comm_monoid (boolean_algebra pos))) : regular_space (add_comm_monoid (boolean_algebra pos)) := sorry --non-trivial
lemma new_lemma_70566 (h0 : cancel_comm_monoid_with_zero (option (option (option pos)))) : unique_factorization_monoid (option (option (option pos))) := sorry --non-trivial
lemma new_lemma_70567 (h0 : functor.add_const (topological_space (add_cancel_monoid pos)) environment.implicit_infer_kind) : @loc_path_connected_space.{0} (add_cancel_monoid.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (add_cancel_monoid.{0} pos)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_70568 (h0 : topological_space (has_neg (has_neg name))) : sequential_space (has_neg (has_neg name)) := sorry --non-trivial
lemma new_lemma_70569 (h0 : functor.comp topological_space has_to_string pos) : @loc_path_connected_space.{0} (has_to_string.{0} pos) (@functor.comp.run.{0 0 0} topological_space.{0} has_to_string.{0} pos h0)  := sorry --non-trivial
lemma new_lemma_70570 (h0 : has_zero num -> has_zero num -> Prop) : reflexive h0 := sorry --non-trivial
lemma new_lemma_70571 (h0 : not (function.extfun Type group -> false)) : @normalizer_condition.{0} (measure_theory.measure_space.{0} unsigned) (@function.extfun_app.{2 1} Type group.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type group.{0}) h0) (measure_theory.measure_space.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_70572 (h1 : complete_lattice (add_monoid fun_info)) : complete_lattice.is_Sup_finite_compact (add_monoid fun_info) := sorry --non-trivial
lemma new_lemma_70573 (h1 : complete_lattice (normed_group (random_gen (random_gen (random_gen (random_gen string_imp)))))) : is_compactly_generated (normed_group (random_gen (random_gen (random_gen (random_gen string_imp))))) := sorry --non-trivial
lemma new_lemma_70574 (h0 : topological_space (mul_zero_class (finset (finset pos)))) : totally_separated_space (mul_zero_class (finset (finset pos))) := sorry --non-trivial
lemma new_lemma_70575 (h0 : function.extfun Type filter) : filter.ne_bot (function.extfun_app h0 (add_left_cancel_monoid linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_70576 (h0 : metric_space ereal) (h1 : set ereal) : euclidean_geometry.cospherical h1 := sorry --non-trivial
lemma new_lemma_70577 (h0 : ring (has_zero (has_zero pos))) : is_principal_ideal_ring (has_zero (has_zero pos)) := sorry --non-trivial
lemma new_lemma_70578 (h0 : functor.add_const (ring (finset num)) unsigned) : @strong_rank_condition.{0} (finset.{0} num) (@functor.add_const.run.{0 0} (ring.{0} (finset.{0} num)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_70579 (h0 : functor.add_const (function.extfun Type uniform_space) name) : @complete_space.{0} (ring.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type uniform_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type uniform_space.{0}) name h0) (ring.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_70580 (h0 : topological_space (add_cancel_monoid (add_comm_monoid (normed_comm_ring name)))) : preirreducible_space (add_cancel_monoid (add_comm_monoid (normed_comm_ring name))) := sorry --non-trivial
lemma new_lemma_70581 (h0 : topological_space (mul_one_class fun_info)) (h1 : add_group (mul_one_class fun_info)) : topological_add_group (mul_one_class fun_info) := sorry --non-trivial
lemma new_lemma_70582 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @complete_lattice.is_Sup_finite_compact.{0} (has_dist.{0} empty) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (has_dist.{0} empty))  := sorry --non-trivial
lemma new_lemma_70583 (h0 : topological_space (add_comm_monoid (has_add (add_comm_monoid name)))) : loc_path_connected_space (add_comm_monoid (has_add (add_comm_monoid name))) := sorry --non-trivial
lemma new_lemma_70584 (h0 : semiring pos) : is_noetherian_ring pos := sorry --non-trivial
lemma new_lemma_70585 (h0 : ring (add_left_cancel_monoid (has_inv linarith.ineq))) : is_domain (add_left_cancel_monoid (has_inv linarith.ineq)) := sorry --non-trivial
lemma new_lemma_70586 (h0 : semiring (normed_comm_ring unsigned)) : is_noetherian_ring (normed_comm_ring unsigned) := sorry --non-trivial
lemma new_lemma_70587 (h0 : functor.add_const (topological_space (has_zero linarith.comp)) (has_Inf linarith.comp)) : @regular_space.{0} (has_zero.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (has_zero.{0} linarith.comp)) (has_Inf.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_70588 (h0 : complete_lattice (normed_group (has_nnnorm to_additive.value_type))) : complete_lattice.is_Sup_finite_compact (normed_group (has_nnnorm to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_70589 (h0 : function.extfun Type topological_space) : @discrete_topology.{0} (complete_linear_order.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (complete_linear_order.{0} empty))  := sorry --non-trivial
lemma new_lemma_70590 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @preirreducible_space.{0} (ordered_comm_monoid.{0} real) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (ordered_comm_monoid.{0} real))  := sorry --non-trivial
lemma new_lemma_70591 (h0 : not (uniform_space (has_emptyc fun_info) -> false)) : @separated_space.{0} (has_emptyc.{0} fun_info) (@classical.by_contradiction'.{1} (uniform_space.{0} (has_emptyc.{0} fun_info)) h0)  := sorry --non-trivial
lemma new_lemma_70592 (h0 : has_mem.mem (has_norm linarith.comp) has_emptyc.emptyc) : @path_connected_space.{0} (has_norm.{0} linarith.comp) (@finset.pi.empty.{1 0} Type topological_space.{0} (has_norm.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_70593 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_add_cyclic.{0} (measurable_space.{0} fun_info) (@function.extfun_app.{2 1} Type add_group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 add_group.{0}) (measurable_space.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_70594 (h0 : functor.add_const (function.extfun (Type 1) topological_space) (finset pos)) : @irreducible_space.{1} (semigroup.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) topological_space.{1}) (finset.{0} pos) h0) (semigroup.{1} Type))  := sorry --non-trivial
lemma new_lemma_70595 (h0 : functor.add_const (topological_space (boolean_algebra.core name)) (has_add (boolean_algebra Type))) : @preconnected_space.{0} (boolean_algebra.core.{0} name) (@functor.add_const.run.{0 1} (topological_space.{0} (boolean_algebra.core.{0} name)) (has_add.{1} (boolean_algebra.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_70596 (h0 : monoid (add_right_cancel_monoid num)) : monoid.fg (add_right_cancel_monoid num) := sorry --non-trivial
lemma new_lemma_70597 (h0 : complete_lattice (has_zero (option (option pos)))) : is_compactly_generated (has_zero (option (option pos))) := sorry --non-trivial
lemma new_lemma_70598 (h0 : complete_lattice (semiring num)) : is_atomistic (semiring num) := sorry --non-trivial
lemma new_lemma_70599 (h0 : topological_space (cancel_monoid (has_add (has_add pos)))) : regular_space (cancel_monoid (has_add (has_add pos))) := sorry --non-trivial
lemma new_lemma_70600 (h0 : ring (has_pos_part (has_add real))) : is_domain (has_pos_part (has_add real)) := sorry --non-trivial
lemma new_lemma_70601 (h0 : group (has_zero (ring (ring (has_neg (ring Type)))))) : is_cyclic (has_zero (ring (ring (has_neg (ring Type))))) := sorry --non-trivial
lemma new_lemma_70602 (h2 : ring (has_compl char)) : is_domain (has_compl char) := sorry --non-trivial
lemma new_lemma_70603 (h0 : topological_space (has_zero (has_neg_part ennreal))) : t1_space (has_zero (has_neg_part ennreal)) := sorry --non-trivial
lemma new_lemma_70604 (h0 : function.extfun Type ring) : @is_domain.{0} (linear_ordered_comm_group.{0} (option.{0} (option.{0} ennreal))) (@function.extfun_app.{2 1} Type ring.{0} h0 (linear_ordered_comm_group.{0} (option.{0} (option.{0} ennreal))))  := sorry --non-trivial
lemma new_lemma_70605 (h0 : topological_space (measurable_space (semiring linarith.comp_source))) : irreducible_space (measurable_space (semiring linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_70606 (h1 : function.extfun Type ring) : @strong_rank_condition.{0} (semi_normed_ring.{0} string_imp) (@function.extfun_app.{2 1} Type ring.{0} h1 (semi_normed_ring.{0} string_imp))  := sorry --non-trivial
lemma new_lemma_70607 (h0 : functor.comp topological_space mul_zero_class name) : @totally_disconnected_space.{0} (mul_zero_class.{0} name) (@functor.comp.run.{0 0 0} topological_space.{0} mul_zero_class.{0} name h0)  := sorry --non-trivial
lemma new_lemma_70608 (h0 : semiring (linear_ordered_field (option (option (option pos))))) : is_noetherian_ring (linear_ordered_field (option (option (option pos)))) := sorry --non-trivial
lemma new_lemma_70609 (h0 : function.extfun Type topological_space) : @sequential_space.{0} (comm_group.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (comm_group.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_70610 (h0 : group (finset (option pos))) : is_cyclic (finset (option pos)) := sorry --non-trivial
lemma new_lemma_70611 (h0 : functor.add_const Prop (has_add congr_arg_kind)) : functor.add_const.run h0 := sorry --non-trivial
lemma new_lemma_70612 (h0 : uniform_space (semi_normed_comm_ring (has_ssubset char))) : complete_space (semi_normed_comm_ring (has_ssubset char)) := sorry --non-trivial
lemma new_lemma_70613 (h0 : list (add_group (semiring unsigned))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_70614 (h0 : function.extfun Type complete_lattice) : @complete_lattice.is_Sup_finite_compact.{0} (ring.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (ring.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_70615 (h0 : function.extfun Type list) : list.nodup (function.extfun_app h0 (semigroup congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_70616 (h0 : filter (with_zero (random_gen (has_nnnorm linarith.comp_source)))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_70617 (h0 : functor.add_const (semiring (add_cancel_monoid linarith.comp)) (has_to_string (comm_group unsigned))) : @is_noetherian_ring.{0} (add_cancel_monoid.{0} linarith.comp) (@functor.add_const.run.{0 0} (semiring.{0} (add_cancel_monoid.{0} linarith.comp)) (has_to_string.{0} (comm_group.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_70618 (h0 : topological_space (mul_zero_class ennreal)) : regular_space (mul_zero_class ennreal) := sorry --non-trivial
lemma new_lemma_70619 (h0 : topological_space (has_div linarith.ineq)) (h1 : set (has_div linarith.ineq)) : is_preirreducible h1 := sorry --non-trivial
lemma new_lemma_70620 (h0 : not (has_mem.mem (complete_semilattice_Sup linarith.comp_source) has_emptyc.emptyc -> false)) : @rank_condition.{0} (complete_semilattice_Sup.{0} linarith.comp_source) (@finset.pi.empty.{1 0} Type ring.{0} (complete_semilattice_Sup.{0} linarith.comp_source) (@classical.by_contradiction'.{0} (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (complete_semilattice_Sup.{0} linarith.comp_source) (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))) h0))  := sorry --non-trivial
lemma new_lemma_70621 (h0 : not (function.extfun Type topological_space -> false)) : @topological_space.second_countable_topology.{0} (has_emptyc.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (has_emptyc.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_70622 (h0 : group (ordered_comm_monoid (finset linarith.comp))) : normalizer_condition (ordered_comm_monoid (finset linarith.comp)) := sorry --non-trivial
lemma new_lemma_70623 (h0 : function.extfun nat fin) : @is_atomistic.{0} (ordered_comm_ring.{0} real) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@matrix.vec_empty.{1} (function.extfun.{2 1} Type complete_lattice.{0}) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero))) (ordered_comm_ring.{0} real))  := sorry --non-trivial
lemma new_lemma_70624 (h0 : functor.add_const (function.extfun (Type 1) topological_space) pos) : @sequential_space.{1} (has_nndist.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) topological_space.{1}) pos h0) (has_nndist.{1} Type))  := sorry --non-trivial
lemma new_lemma_70625 (h0 : ring (random_gen (has_nnnorm (has_lt (has_nnnorm fun_info))))) : rank_condition (random_gen (has_nnnorm (has_lt (has_nnnorm fun_info)))) := sorry --non-trivial
lemma new_lemma_70626 (h0 : complete_lattice (has_ssubset char)) : is_compactly_generated (has_ssubset char) := sorry --non-trivial
lemma new_lemma_70627 (h0 : list (has_pos_part (ring (ring Type)))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_70628 (h0 : list (has_zero (normed_comm_ring name))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_70629 (h1 : not (function.extfun Type add_group -> false)) : @is_add_cyclic.{0} fun_info (@function.extfun_app.{2 1} Type add_group.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type add_group.{0}) h1) fun_info)  := sorry --non-trivial
lemma new_lemma_70630 (h0 : topological_space (has_add (has_neg linarith.comp))) : topological_space.separable_space (has_add (has_neg linarith.comp)) := sorry --non-trivial
lemma new_lemma_70631 (h0 : set (linear_ordered_comm_group_with_zero (mul_one_class string.iterator_imp))) : set.finite h0 := sorry --non-trivial
lemma new_lemma_70632 (h0 : ring (has_ssubset (mul_one_class char))) : rank_condition (has_ssubset (mul_one_class char)) := sorry --non-trivial
lemma new_lemma_70633 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @totally_disconnected_space.{0} (finset.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (finset.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_70634 (h0 : group (measurable_space.dynkin_system (semiring (semiring (semiring (semiring empty)))))) : is_cyclic (measurable_space.dynkin_system (semiring (semiring (semiring (semiring empty))))) := sorry --non-trivial
lemma new_lemma_70635 (h0 : group (add_cancel_monoid (ring (has_add Type)))) : is_cyclic (add_cancel_monoid (ring (has_add Type))) := sorry --non-trivial
lemma new_lemma_70636 (h0 : complete_lattice (has_one (linear_ordered_semiring unsigned))) : complete_lattice.is_Sup_finite_compact (has_one (linear_ordered_semiring unsigned)) := sorry --non-trivial
lemma new_lemma_70637 (h0 : uniform_space (finset congr_arg_kind)) : separated_space (finset congr_arg_kind) := sorry --non-trivial
lemma new_lemma_70638 (h0 : ring (has_to_string (finset environment.implicit_infer_kind))) : rank_condition (has_to_string (finset environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_70639 (h0 : topological_space (has_neg (finset (finset (finset pos))))) : topological_space.separable_space (has_neg (finset (finset (finset pos)))) := sorry --non-trivial
lemma new_lemma_70640 (h0 : functor.add_const (complete_lattice (add_right_cancel_monoid empty)) empty) : @complete_lattice.is_Sup_finite_compact.{0} (add_right_cancel_monoid.{0} empty) (@functor.add_const.run.{0 0} (complete_lattice.{0} (add_right_cancel_monoid.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_70641 (h0 : ring (semi_normed_ring (mul_one_class linarith.ineq))) : is_domain (semi_normed_ring (mul_one_class linarith.ineq)) := sorry --non-trivial
lemma new_lemma_70642 (h0 : functor.add_const (list Type) Type) : list.nodup (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_70643 (h0 : ring (add_group (semiring (semiring congr_arg_kind)))) : is_domain (add_group (semiring (semiring congr_arg_kind))) := sorry --non-trivial
lemma new_lemma_70644 (h0 : topological_space (boolean_algebra.core (has_pos_part linarith.comp))) : regular_space (boolean_algebra.core (has_pos_part linarith.comp)) := sorry --non-trivial
lemma new_lemma_70645 (h0 : functor.add_const (semiring (comm_group pos)) name) : @is_noetherian_ring.{0} (comm_group.{0} pos) (@functor.add_const.run.{0 0} (semiring.{0} (comm_group.{0} pos)) name h0)  := sorry --non-trivial
lemma new_lemma_70646 (h0 : has_mul (mul_one_class string_imp)) (h1 : ring (con (mul_one_class string_imp))) : is_domain (con (mul_one_class string_imp)) := sorry --non-trivial
lemma new_lemma_70647 (h0 : functor.add_const (topological_space (complete_linear_order num)) (semiring num)) : @normal_space.{0} (complete_linear_order.{0} num) (@functor.add_const.run.{0 0} (topological_space.{0} (complete_linear_order.{0} num)) (semiring.{0} num) h0)  := sorry --non-trivial
lemma new_lemma_70648 (h0 : function.extfun Type topological_space) : @t0_space.{0} (denumerable.{0} string_imp) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (denumerable.{0} string_imp))  := sorry --non-trivial
lemma new_lemma_70649 (h0 : function.extfun nat fin) : @monoid.fg.{0} (comm_semigroup.{0} pos) (@matrix.vec_empty.{0} (monoid.{0} (comm_semigroup.{0} pos)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_70650 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_compactly_generated.{0} (has_to_string.{0} pos) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (has_to_string.{0} pos))  := sorry --non-trivial
lemma new_lemma_70651 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @normalizer_condition.{0} (has_Inf.{0} linarith.comp) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (has_Inf.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_70652 (h0 : uniform_space (linear_ordered_add_comm_group (random_gen linarith.ineq))) : complete_space (linear_ordered_add_comm_group (random_gen linarith.ineq)) := sorry --non-trivial
lemma new_lemma_70653 (h0 : topological_space (finset (has_nndist name))) : totally_disconnected_space (finset (has_nndist name)) := sorry --non-trivial
lemma new_lemma_70654 (h0 : function.extfun Type topological_space) : @t0_space.{0} (add_right_cancel_monoid.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (add_right_cancel_monoid.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_70655 (h0 : add_group (linear_ordered_comm_group_with_zero (mul_one_class to_additive.value_type))) : is_add_cyclic (linear_ordered_comm_group_with_zero (mul_one_class to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_70656 (h0 : function.extfun Type topological_space) : @discrete_topology.{0} (with_bot.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (with_bot.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_70657 (h0 : function.extfun (nat -> Type) (function.extfun nat)) : @topological_space.separable_space.{1} (boolean_algebra.{1} Type) (@matrix.vec_empty.{1} (topological_space.{1} (boolean_algebra.{1} Type)) (@matrix.vec_empty.{0} (fin (@has_zero.zero.{0} nat nat.has_zero)) (@function.extfun_app.{1 1} nat fin (@function.extfun_app.{2 1} (nat → Type) (function.extfun.{1 1} nat) h0 fin) (@has_zero.zero.{0} nat nat.has_zero))))  := sorry --non-trivial
lemma new_lemma_70658 (h0 : filter (ring (option name))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_70659 (h0 : function.extfun (finset (Type -> Type)) (has_mem.mem topological_space)) : @totally_separated_space.{0} (normed_group.{0} fun_info) (@function.extfun_app.{2 1} Type topological_space.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) topological_space.{0} (@function.extfun_app.{2 0} (finset.{1} (Type → Type)) (@has_mem.mem.{1 1} (Type → Type) (finset.{1} (Type → Type)) (@finset.has_mem.{1} (Type → Type)) topological_space.{0}) h0 (@has_emptyc.emptyc.{1} (finset.{1} (Type → Type)) (@finset.has_emptyc.{1} (Type → Type))))) (normed_group.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_70660 (h0 : ordered_add_comm_monoid (add_cancel_monoid (ring (has_to_string linarith.comp)))) : archimedean (add_cancel_monoid (ring (has_to_string linarith.comp))) := sorry --non-trivial
lemma new_lemma_70661 (h4 : topological_space (nondiscrete_normed_field (add_comm_semigroup char))) (h5 : add_group (nondiscrete_normed_field (add_comm_semigroup char))) : topological_add_group (nondiscrete_normed_field (add_comm_semigroup char)) := sorry --non-trivial
lemma new_lemma_70662 (h0 : list (topological_space char)) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_70663 (h0 : function.extfun Type group) : @normalizer_condition.{0} (measurable_space.{0} fun_info) (@function.extfun_app.{2 1} Type group.{0} h0 (measurable_space.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_70664 (h0 : not (function.extfun (Type -> Type) (function.extfun Type) -> false)) : @group.fg.{0} (has_inv.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) (@classical.by_contradiction'.{2} (function.extfun.{2 2} (Type → Type) (function.extfun.{2 1} Type)) h0) group.{0}) (has_inv.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_70665 (h0 : topological_space (has_neg_part (option unsigned))) : topological_space.separable_space (has_neg_part (option unsigned)) := sorry --non-trivial
lemma new_lemma_70666 (h0 : group (has_Inf (has_add Type))) : is_simple_group (has_Inf (has_add Type)) := sorry --non-trivial
lemma new_lemma_70667 (h0 : ring (ordered_comm_ring (has_Inf real))) : strong_rank_condition (ordered_comm_ring (has_Inf real)) := sorry --non-trivial
lemma new_lemma_70668 (h0 : topological_space (has_dist unsigned)) : t0_space (has_dist unsigned) := sorry --non-trivial
lemma new_lemma_70669 (h0 : set (has_nnnorm string.iterator_imp)) : set.subsingleton h0 := sorry --non-trivial
lemma new_lemma_70670 (h0 : functor.add_const (topological_space (has_neg_part pos)) pos) : @irreducible_space.{0} (has_neg_part.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (has_neg_part.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_70671 (h0 : add_group (mul_zero_class environment.implicit_infer_kind)) : is_add_cyclic (mul_zero_class environment.implicit_infer_kind) := sorry --non-trivial
lemma new_lemma_70672 (h0 : functor.add_const (complete_lattice (option ennreal)) ennreal) : @complete_lattice.is_Sup_finite_compact.{0} (option.{0} ennreal) (@functor.add_const.run.{0 0} (complete_lattice.{0} (option.{0} ennreal)) ennreal h0)  := sorry --non-trivial
lemma new_lemma_70673 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @add_monoid.fg.{0} (ordered_comm_group.{0} empty) (@function.extfun_app.{2 1} Type add_monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 add_monoid.{0}) (ordered_comm_group.{0} empty))  := sorry --non-trivial
lemma new_lemma_70674 (h0 : functor.add_const (complete_lattice (add_cancel_monoid Type)) Type) : @complete_lattice.is_Sup_finite_compact.{1} (add_cancel_monoid.{1} Type) (@functor.add_const.run.{1 1} (complete_lattice.{1} (add_cancel_monoid.{1} Type)) Type h0)  := sorry --non-trivial
lemma new_lemma_70675 (h0 : functor.add_const (topological_space (has_neg unsigned)) pos) : @regular_space.{0} (has_neg.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (has_neg.{0} unsigned)) pos h0)  := sorry --non-trivial
lemma new_lemma_70676 (h0 : topological_space (has_neg ennreal)) : path_connected_space (has_neg ennreal) := sorry --non-trivial
lemma new_lemma_70677 (h0 : ring (boolean_algebra (has_to_string Type))) : rank_condition (boolean_algebra (has_to_string Type)) := sorry --non-trivial
lemma new_lemma_70678 (h0 : function.extfun (Type 1) complete_lattice) : @is_atomistic.{1} (finset.{1} Type) (@function.extfun_app.{3 2} (Type 1) complete_lattice.{1} h0 (finset.{1} Type))  := sorry --non-trivial
lemma new_lemma_70679 (h0 : functor.add_const (function.extfun Type uniform_space) Type) : @complete_space.{0} (has_Inf.{0} linarith.comp) (@function.extfun_app.{2 1} Type uniform_space.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type uniform_space.{0}) Type h0) (has_Inf.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_70680 (h0 : topological_space (with_bot (comm_ring linarith.comp_source))) : path_connected_space (with_bot (comm_ring linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_70681 (h0 : functor.add_const (group (bin_tree num)) num) : @group.fg.{0} (bin_tree.{0} num) (@functor.add_const.run.{0 0} (group.{0} (bin_tree.{0} num)) num h0)  := sorry --non-trivial
lemma new_lemma_70682 (h0 : list (ring (mul_one_class linarith.comp))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_70683 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_cyclic.{0} (monoid.{0} num) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (monoid.{0} num))  := sorry --non-trivial
lemma new_lemma_70684 (h0 : topological_space (plift congr_arg_kind)) : totally_separated_space (plift congr_arg_kind) := sorry --non-trivial
lemma new_lemma_70685 (h0 : has_lt std_gen) : no_max_order std_gen := sorry --non-trivial
lemma new_lemma_70686 (h0 : functor.add_const (ordered_add_comm_monoid (has_Sup empty)) (semiring (semiring (semiring (ordered_ring num))))) : @archimedean.{0} (has_Sup.{0} empty) (@functor.add_const.run.{0 0} (ordered_add_comm_monoid.{0} (has_Sup.{0} empty)) (semiring.{0} (semiring.{0} (semiring.{0} (ordered_ring.{0} num)))) h0)  := sorry --non-trivial
lemma new_lemma_70687 (h0 : complete_lattice (distrib to_additive.value_type)) : is_compactly_generated (distrib to_additive.value_type) := sorry --non-trivial
lemma new_lemma_70688 (h1 : topological_space (denumerable (denumerable char))) : t0_space (denumerable (denumerable char)) := sorry --non-trivial
lemma new_lemma_70689 (h0 : add_group (normed_field string_imp)) : is_add_cyclic (normed_field string_imp) := sorry --non-trivial
lemma new_lemma_70690 (h0 : functor.add_const Prop (complete_semilattice_Sup congr_arg_kind)) : functor.add_const.run h0 := sorry --non-trivial
lemma new_lemma_70691 (h0 : list (comm_monoid congr_arg_kind)) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_70692 (h0 : fin has_zero.zero) : @topological_space.separable_space.{0} (canonically_ordered_monoid.{0} real) (@matrix.vec_empty.{0} (topological_space.{0} (canonically_ordered_monoid.{0} real)) h0)  := sorry --non-trivial
lemma new_lemma_70693 (h0 : topological_space (ring (has_to_string (finset (has_zero Type))))) : topological_space.separable_space (ring (has_to_string (finset (has_zero Type)))) := sorry --non-trivial
lemma new_lemma_70694 (h0 : functor.add_const (topological_space (pseudo_metric_space unsigned)) unsigned) : @preconnected_space.{0} (pseudo_metric_space.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (pseudo_metric_space.{0} unsigned)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_70695 (h0 : random_gen (random_gen string_imp) -> random_gen (random_gen string_imp) -> bool) : is_dec_refl h0 := sorry --non-trivial
lemma new_lemma_70696 (h0 : topological_space (has_neg (finset environment.implicit_infer_kind))) : t1_space (has_neg (finset environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_70697 (h0 : group (normed_comm_ring (has_neg (has_neg (finset linarith.comp))))) : is_simple_group (normed_comm_ring (has_neg (has_neg (finset linarith.comp)))) := sorry --non-trivial
lemma new_lemma_70698 (h0 : functor.add_const (function.extfun Type list) pos) : palindrome (function.extfun_app (functor.add_const.run h0) (ring unsigned)) := sorry --non-trivial
lemma new_lemma_70699 (h0 : has_neg (has_lt environment.projection_info)) (h1 : measurable_space (has_lt environment.projection_info)) : has_measurable_neg (has_lt environment.projection_info) := sorry --non-trivial
lemma new_lemma_70700 (h0 : function.extfun Type ring) : @strong_rank_condition.{0} (linear_ordered_comm_group.{0} unsigned) (@function.extfun_app.{2 1} Type ring.{0} h0 (linear_ordered_comm_group.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_70701 (h0 : function.extfun Type group) : @is_cyclic.{0} (with_one.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type group.{0} h0 (with_one.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_70702 (h0 : monoid std_gen) (h1 : set (nondiscrete_normed_field (boolean_algebra.core (conj_classes std_gen)))) : set.finite h1 := sorry --non-trivial
lemma new_lemma_70703 (h0 : topological_space (linear_ordered_add_comm_group (random_gen (random_gen fun_info)))) : path_connected_space (linear_ordered_add_comm_group (random_gen (random_gen fun_info))) := sorry --non-trivial
lemma new_lemma_70704 (h0 : topological_space (semiring (has_norm linarith.comp_source))) : t0_space (semiring (has_norm linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_70705 (h1 : complete_lattice (has_norm (random_gen linarith.comp))) : is_compactly_generated (has_norm (random_gen linarith.comp)) := sorry --non-trivial
lemma new_lemma_70706 (h0 : function.extfun Type ring) : @is_domain.{0} (with_bot.{0} string_imp) (@function.extfun_app.{2 1} Type ring.{0} h0 (with_bot.{0} string_imp))  := sorry --non-trivial
lemma new_lemma_70707 (h0 : functor.comp complete_lattice has_dist Type) : @is_compactly_generated.{1} (has_dist.{1} Type) (@functor.comp.run.{1 1 1} complete_lattice.{1} has_dist.{1} Type h0)  := sorry --non-trivial
lemma new_lemma_70708 (h0 : topological_space (comm_monoid unsigned)) : path_connected_space (comm_monoid unsigned) := sorry --non-trivial
lemma new_lemma_70709 (h1 : ring (linear_ordered_add_comm_group char) -> char) (h2 : coe_sort (set.range h1)) : @is_domain.{0} (linear_ordered_add_comm_group.{0} char) (@set.range_splitting.{0 0} (ring.{0} (linear_ordered_add_comm_group.{0} char)) char h1 h2)  := sorry --non-trivial
lemma new_lemma_70710 (h0 : not (ring (denumerable (has_nnnorm linarith.ineq)) -> false)) : @is_domain.{0} (denumerable.{0} (has_nnnorm.{0} linarith.ineq)) (@classical.by_contradiction'.{1} (ring.{0} (denumerable.{0} (has_nnnorm.{0} linarith.ineq))) h0)  := sorry --non-trivial
lemma new_lemma_70711 (h0 : monoid (with_bot (comm_ring to_additive.value_type))) : monoid.fg (with_bot (comm_ring to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_70712 (h0 : topological_space (add_cancel_monoid (add_cancel_monoid Type))) : regular_space (add_cancel_monoid (add_cancel_monoid Type)) := sorry --non-trivial
lemma new_lemma_70713 (h0 : not (topological_space (has_bot char) -> false)) : @t0_space.{0} (has_bot.{0} char) (@classical.by_contradiction'.{1} (topological_space.{0} (has_bot.{0} char)) h0)  := sorry --non-trivial
lemma new_lemma_70714 (h0 : topological_space (has_emptyc (random_gen congr_arg_kind))) : path_connected_space (has_emptyc (random_gen congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_70715 (h0 : topological_space (mul_zero_class (mul_zero_class ennreal))) : preirreducible_space (mul_zero_class (mul_zero_class ennreal)) := sorry --non-trivial
lemma new_lemma_70716 (h0 : functor.add_const (monoid (boolean_algebra Type)) (has_add name)) : @monoid.fg.{1} (boolean_algebra.{1} Type) (@functor.add_const.run.{1 0} (monoid.{1} (boolean_algebra.{1} Type)) (has_add.{0} name) h0)  := sorry --non-trivial
lemma new_lemma_70717 (h0 : add_group (simple_graph (finset linarith.comp))) : is_add_cyclic (simple_graph (finset linarith.comp)) := sorry --non-trivial
lemma new_lemma_70718 (h0 : group (semigroup (has_nndist (finset (finset ennreal))))) : is_simple_group (semigroup (has_nndist (finset (finset ennreal)))) := sorry --non-trivial
lemma new_lemma_70719 (h0 : add_group (distrib_lattice fun_info)) : is_add_cyclic (distrib_lattice fun_info) := sorry --non-trivial
lemma new_lemma_70720 (h0 : functor.comp ring canonically_ordered_comm_semiring unsigned) : @is_domain.{0} (canonically_ordered_comm_semiring.{0} unsigned) (@functor.comp.run.{0 0 0} ring.{0} canonically_ordered_comm_semiring.{0} unsigned h0)  := sorry --non-trivial
lemma new_lemma_70721 (h0 : not (ring (measurable_space fun_info) -> false)) : @is_domain.{0} (measurable_space.{0} fun_info) (@classical.by_contradiction'.{1} (ring.{0} (measurable_space.{0} fun_info)) h0)  := sorry --non-trivial
lemma new_lemma_70722 (h0 : uniform_space (has_to_string (comm_group name))) : complete_space (has_to_string (comm_group name)) := sorry --non-trivial
lemma new_lemma_70723 (h0 : function.extfun Type filter) : countable_Inter_filter (function.extfun_app h0 (normed_comm_ring pos)) := sorry --non-trivial
lemma new_lemma_70724 (h0 : function.extfun (finset Type) (has_mem.mem (has_emptyc fun_info))) : @is_atomistic.{0} (has_emptyc.{0} fun_info) (@finset.pi.empty.{1 0} Type complete_lattice.{0} (has_emptyc.{0} fun_info) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (has_emptyc.{0} fun_info)) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_70725 (h0 : ring (mul_one_class linarith.ineq)) : rank_condition (mul_one_class linarith.ineq) := sorry --non-trivial
lemma new_lemma_70726 (h0 : add_group (ordered_ring congr_arg_kind)) : is_add_cyclic (ordered_ring congr_arg_kind) := sorry --non-trivial
lemma new_lemma_70727 (h0 : function.extfun Type ring) : @strong_rank_condition.{0} (ordered_comm_ring.{0} name) (@function.extfun_app.{2 1} Type ring.{0} h0 (ordered_comm_ring.{0} name))  := sorry --non-trivial
lemma new_lemma_70728 (h0 : function.extfun Type list) : list.nodup (function.extfun_app h0 (omega_complete_partial_order congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_70729 (h0 : prod (partial_order (semiring empty)) (partial_order (semiring empty))) : id_rel h0 := sorry --non-trivial
lemma new_lemma_70730 (h0 : ring (has_to_string (finset (has_add environment.implicit_infer_kind)))) : strong_rank_condition (has_to_string (finset (has_add environment.implicit_infer_kind))) := sorry --non-trivial
lemma new_lemma_70731 (h0 : filter (ordered_cancel_add_comm_monoid (option (option ennreal)))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_70732 (h0 : function.extfun Type topological_space) : @topological_space.separable_space.{0} (non_assoc_semiring.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (non_assoc_semiring.{0} empty))  := sorry --non-trivial
lemma new_lemma_70733 (h0 : topological_space (semiring (has_top (has_top linarith.comp)))) : totally_separated_space (semiring (has_top (has_top linarith.comp))) := sorry --non-trivial
lemma new_lemma_70734 (h0 : set (mul_one_class (mul_one_class (add_comm_semigroup string.iterator_imp)) -> mul_one_class fun_info)) : set.separates_points h0 := sorry --non-trivial
lemma new_lemma_70735 (h0 : filter (metric_space (has_top (semiring (semiring (has_norm (has_norm (has_norm congr_arg_kind)))))))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_70736 (h0 : has_mem.mem uniform_space has_emptyc.emptyc) : @complete_space.{0} (with_bot.{0} empty) (@function.extfun_app.{2 1} Type uniform_space.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) uniform_space.{0} h0) (with_bot.{0} empty))  := sorry --non-trivial
lemma new_lemma_70737 (h0 : complete_lattice (normed_comm_ring empty)) : is_atomistic (normed_comm_ring empty) := sorry --non-trivial
lemma new_lemma_70738 (h0 : monoid (plift (semiring (semiring unsigned)))) : monoid.fg (plift (semiring (semiring unsigned))) := sorry --non-trivial
lemma new_lemma_70739 (h0 : functor.add_const (topological_space (has_zero pos)) linarith.comp) : @totally_separated_space.{0} (has_zero.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (has_zero.{0} pos)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_70740 (h0 : topological_space (add_cancel_monoid (finset unsigned))) : path_connected_space (add_cancel_monoid (finset unsigned)) := sorry --non-trivial
lemma new_lemma_70741 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @normal_space.{1} Type (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 topological_space.{1}) Type)  := sorry --non-trivial
lemma new_lemma_70742 (h0 : functor.add_const (ring (add_cancel_monoid unsigned)) ennreal) : @strong_rank_condition.{0} (add_cancel_monoid.{0} unsigned) (@functor.add_const.run.{0 0} (ring.{0} (add_cancel_monoid.{0} unsigned)) ennreal h0)  := sorry --non-trivial
lemma new_lemma_70743 (h1 : complete_lattice (simple_graph std_gen)) : is_compactly_generated (simple_graph std_gen) := sorry --non-trivial
lemma new_lemma_70744 (h0 : functor.add_const Prop (has_neg (add_comm_monoid (normed_comm_ring environment.implicit_infer_kind)))) : functor.add_const.run h0 := sorry --non-trivial
lemma new_lemma_70745 (h0 : functor.add_const (topological_space (comm_group Type)) pos) : @discrete_topology.{1} (comm_group.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (comm_group.{1} Type)) pos h0)  := sorry --non-trivial
lemma new_lemma_70746 (h0 : topological_space (semigroup (semigroup linarith.comp))) : sequential_space (semigroup (semigroup linarith.comp)) := sorry --non-trivial
lemma new_lemma_70747 (h0 : topological_space (normed_comm_ring (has_add pos))) : preconnected_space (normed_comm_ring (has_add pos)) := sorry --non-trivial
lemma new_lemma_70748 (h0 : list (complete_distrib_lattice (sub_neg_monoid real))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_70749 (h0 : functor.add_const (topological_space (has_neg Type)) linarith.comp) : @preirreducible_space.{1} (has_neg.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (has_neg.{1} Type)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_70750 (h0 : function.extfun Type monoid) : monoid.fg nnreal := sorry --non-trivial
lemma new_lemma_70751 (h0 : function.extfun Type topological_space) : @t0_space.{0} (cancel_monoid.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (cancel_monoid.{0} pos))  := sorry --non-trivial
lemma new_lemma_70752 (h0 : function.extfun Type (functor.comp topological_space add_cancel_monoid)) : @topological_space.separable_space.{0} (add_cancel_monoid.{0} pos) (@functor.comp.run.{0 0 0} topological_space.{0} add_cancel_monoid.{0} pos (@function.extfun_app.{2 1} Type (functor.comp.{0 0 0} topological_space.{0} add_cancel_monoid.{0}) h0 pos))  := sorry --non-trivial
lemma new_lemma_70753 (h0 : set (has_le std_gen)) : set.subsingleton h0 := sorry --non-trivial
lemma new_lemma_70754 (h0 : not (ring (non_unital_non_assoc_semiring char) -> false)) : @rank_condition.{0} (non_unital_non_assoc_semiring.{0} char) (@classical.by_contradiction'.{1} (ring.{0} (non_unital_non_assoc_semiring.{0} char)) h0)  := sorry --non-trivial
lemma new_lemma_70755 (h0 : function.extfun (finset (Type -> Type)) (has_mem.mem topological_space)) : @locally_compact_space.{0} (random_gen.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) topological_space.{0} (@function.extfun_app.{2 0} (finset.{1} (Type → Type)) (@has_mem.mem.{1 1} (Type → Type) (finset.{1} (Type → Type)) (@finset.has_mem.{1} (Type → Type)) topological_space.{0}) h0 (@has_emptyc.emptyc.{1} (finset.{1} (Type → Type)) (@finset.has_emptyc.{1} (Type → Type))))) (random_gen.{0} num))  := sorry --non-trivial
lemma new_lemma_70756 (h0 : fin has_zero.zero) : @discrete_topology.{1} (normed_lattice_add_comm_group.{1} Type) (@matrix.vec_empty.{1} (topological_space.{1} (normed_lattice_add_comm_group.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_70757 (h0 : functor.add_const Prop (generalized_boolean_algebra Type)) : functor.add_const.run h0 := sorry --non-trivial
lemma new_lemma_70758 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_add_cyclic.{0} (metric_space.{0} empty) (@function.extfun_app.{2 1} Type add_group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 add_group.{0}) (metric_space.{0} empty))  := sorry --non-trivial
lemma new_lemma_70759 (h0 : complete_lattice (has_append (has_nnnorm (denumerable char)))) : complete_lattice.is_Sup_finite_compact (has_append (has_nnnorm (denumerable char))) := sorry --non-trivial
lemma new_lemma_70760 (h0 : topological_space (ordered_comm_ring (ring pos))) : path_connected_space (ordered_comm_ring (ring pos)) := sorry --non-trivial
lemma new_lemma_70761 (h0 : not (function.extfun Type topological_space -> false)) : @totally_separated_space.{0} (has_top.{0} (random_gen.{0} (random_gen.{0} (random_gen.{0} (random_gen.{0} num))))) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (has_top.{0} (random_gen.{0} (random_gen.{0} (random_gen.{0} (random_gen.{0} num))))))  := sorry --non-trivial
lemma new_lemma_70762 (h0 : complete_lattice (with_bot num)) : is_compactly_generated (with_bot num) := sorry --non-trivial
lemma new_lemma_70763 (h0 : topological_space (boolean_algebra (has_Inf real))) : sequential_space (boolean_algebra (has_Inf real)) := sorry --non-trivial
lemma new_lemma_70764 (h0 : function.extfun Type add_group) : @is_add_cyclic.{0} (add_comm_monoid.{0} name) (@function.extfun_app.{2 1} Type add_group.{0} h0 (add_comm_monoid.{0} name))  := sorry --non-trivial
lemma new_lemma_70765 (h0 : semiring (add_cancel_monoid (finset pos))) : is_noetherian_ring (add_cancel_monoid (finset pos)) := sorry --non-trivial
lemma new_lemma_70766 (h0 : has_mem.mem (measurable_space pos) has_emptyc.emptyc) : @complete_space.{0} (measurable_space.{0} pos) (@finset.pi.empty.{1 0} Type uniform_space.{0} (measurable_space.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_70767 (h0 : not (function.extfun Type group -> false)) : @normalizer_condition.{0} (has_top.{0} linarith.ineq) (@function.extfun_app.{2 1} Type group.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type group.{0}) h0) (has_top.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_70768 (h0 : ring (mul_one_class char)) : rank_condition (mul_one_class char) := sorry --non-trivial
lemma new_lemma_70769 (h0 : topological_space (linear_ordered_field empty)) : loc_path_connected_space (linear_ordered_field empty) := sorry --non-trivial
lemma new_lemma_70770 (h0 : group (has_star (semiring (semiring (semiring (semiring num)))))) : is_cyclic (has_star (semiring (semiring (semiring (semiring num))))) := sorry --non-trivial
lemma new_lemma_70771 (h0 : not (topological_space (encodable (comm_ring fun_info)) -> false)) : @t0_space.{0} (encodable.{0} (comm_ring.{0} fun_info)) (@classical.by_contradiction'.{1} (topological_space.{0} (encodable.{0} (comm_ring.{0} fun_info))) h0)  := sorry --non-trivial
lemma new_lemma_70772 (h0 : topological_space (with_bot empty)) : irreducible_space (with_bot empty) := sorry --non-trivial
lemma new_lemma_70773 (h0 : semiring (id num)) : is_noetherian_ring (id num) := sorry --non-trivial
lemma new_lemma_70774 (h0 : add_monoid (comm_group (cancel_monoid (has_add pos)))) : add_monoid.fg (comm_group (cancel_monoid (has_add pos))) := sorry --non-trivial
lemma new_lemma_70775 (h0 : functor.add_const (group (has_dist empty)) empty) : @group.fg.{0} (has_dist.{0} empty) (@functor.add_const.run.{0 0} (group.{0} (has_dist.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_70776 (h0 : function.extfun nat fin) : @t0_space.{1} (ordered_comm_monoid.{1} Type) (@matrix.vec_empty.{1} (topological_space.{1} (ordered_comm_monoid.{1} Type)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_70777 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @add_monoid.fg.{0} (linear_ordered_field.{0} pos) (@function.extfun_app.{2 1} Type add_monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 add_monoid.{0}) (linear_ordered_field.{0} pos))  := sorry --non-trivial
lemma new_lemma_70778 (h2 : topological_space (topological_space (denumerable char))) : totally_disconnected_space (topological_space (denumerable char)) := sorry --non-trivial
lemma new_lemma_70779 (h0 : filter (dlist char)) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_70780 (h0 : linarith.comp -> linarith.comp -> Prop) : is_antisymm linarith.comp h0 := sorry --non-trivial
lemma new_lemma_70781 (h0 : functor.add_const (list (non_assoc_semiring empty)) empty) : palindrome (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_70782 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @normal_space.{0} (has_top.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_top.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_70783 (h0 : uniform_space (has_norm (semiring congr_arg_kind))) : separated_space (has_norm (semiring congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_70784 (h0 : functor.add_const (ordered_add_comm_monoid (omega_complete_partial_order empty)) empty) : @archimedean.{0} (omega_complete_partial_order.{0} empty) (@functor.add_const.run.{0 0} (ordered_add_comm_monoid.{0} (omega_complete_partial_order.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_70785 (h1 : set (normed_field (normed_field enat))) : set.finite h1 := sorry --non-trivial
lemma new_lemma_70786 (h0 : functor.add_const (function.extfun Type topological_space) linarith.comp) : @t0_space.{0} (complete_distrib_lattice.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) linarith.comp h0) (complete_distrib_lattice.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_70787 (h0 : complete_lattice (simple_graph (option unsigned))) : complete_lattice.is_Sup_finite_compact (simple_graph (option unsigned)) := sorry --non-trivial
lemma new_lemma_70788 (h0 : topological_space (has_neg (finset (ring pos)))) : path_connected_space (has_neg (finset (ring pos))) := sorry --non-trivial
lemma new_lemma_70789 (h0 : not (function.extfun Type topological_space -> false)) : @irreducible_space.{0} (has_norm.{0} linarith.ineq) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (has_norm.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_70790 (h0 : topological_space (has_nndist (has_add pos))) : t1_space (has_nndist (has_add pos)) := sorry --non-trivial
lemma new_lemma_70791 (h0 : has_neg (simple_graph char)) (h1 : measurable_space (simple_graph char)) : has_measurable_neg (simple_graph char) := sorry --non-trivial
lemma new_lemma_70792 (h0 : functor.add_const (finset (option num)) num) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_70793 (h0 : functor.add_const (topological_space (as_linear_order empty)) (option (option empty))) : @locally_compact_space.{0} (as_linear_order.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (as_linear_order.{0} empty)) (option.{0} (option.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_70794 (h0 : topological_space (has_to_string Type)) : irreducible_space (has_to_string Type) := sorry --non-trivial
lemma new_lemma_70795 (h0 : topological_space (pseudo_metric_space environment.implicit_infer_kind)) : irreducible_space (pseudo_metric_space environment.implicit_infer_kind) := sorry --non-trivial
lemma new_lemma_70796 (h0 : function.extfun Type topological_space) : @discrete_topology.{0} (has_add.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_add.{0} num))  := sorry --non-trivial
lemma new_lemma_70797 (h0 : ring (add_comm_monoid linarith.comp)) : strong_rank_condition (add_comm_monoid linarith.comp) := sorry --non-trivial
lemma new_lemma_70798 (h1 : complete_lattice (has_append linarith.comp_source)) : complete_lattice.is_Sup_finite_compact (has_append linarith.comp_source) := sorry --non-trivial
lemma new_lemma_70799 (h0 : fin has_zero.zero) : @totally_disconnected_space.{0} (has_pos_part.{0} pos) (@matrix.vec_empty.{0} (topological_space.{0} (has_pos_part.{0} pos)) h0)  := sorry --non-trivial
lemma new_lemma_70800 (h0 : ring (mul_one_class (normed_field ereal))) : strong_rank_condition (mul_one_class (normed_field ereal)) := sorry --non-trivial
lemma new_lemma_70801 (h0 : function.extfun Type add_group) : @is_add_cyclic.{0} (with_one.{0} string_imp) (@function.extfun_app.{2 1} Type add_group.{0} h0 (with_one.{0} string_imp))  := sorry --non-trivial
lemma new_lemma_70802 (h0 : ring (ordered_comm_ring (ordered_comm_monoid Type))) : rank_condition (ordered_comm_ring (ordered_comm_monoid Type)) := sorry --non-trivial
lemma new_lemma_70803 (h0 : uniform_space (add_cancel_monoid (ring linarith.comp))) : separated_space (add_cancel_monoid (ring linarith.comp)) := sorry --non-trivial
lemma new_lemma_70804 (h0 : ring (complete_semilattice_Sup (distrib_lattice to_additive.value_type))) : is_domain (complete_semilattice_Sup (distrib_lattice to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_70805 (h0 : functor.add_const (functor.add_const (topological_space pos) Type) (finset pos)) : @preconnected_space.{0} pos (@functor.add_const.run.{0 1} (topological_space.{0} pos) Type (@functor.add_const.run.{0 0} (functor.add_const.{0 1} (topological_space.{0} pos) Type) (finset.{0} pos) h0))  := sorry --non-trivial
lemma new_lemma_70806 (h0 : topological_space (canonically_linear_ordered_monoid name)) : totally_disconnected_space (canonically_linear_ordered_monoid name) := sorry --non-trivial
lemma new_lemma_70807 (h0 : ring (has_edist (option (option (option nnreal))))) : is_principal_ideal_ring (has_edist (option (option (option nnreal)))) := sorry --non-trivial
lemma new_lemma_70808 (h0 : complete_lattice (dlist (has_nnnorm fun_info))) : is_compactly_generated (dlist (has_nnnorm fun_info)) := sorry --non-trivial
lemma new_lemma_70809 (h0 : functor.add_const (topological_space (left_cancel_monoid num)) (semiring empty)) : @topological_space.separable_space.{0} (left_cancel_monoid.{0} num) (@functor.add_const.run.{0 0} (topological_space.{0} (left_cancel_monoid.{0} num)) (semiring.{0} empty) h0)  := sorry --non-trivial
lemma new_lemma_70810 (h0 : ring (simple_graph (option (option (option (option unsigned)))))) : rank_condition (simple_graph (option (option (option (option unsigned))))) := sorry --non-trivial
lemma new_lemma_70811 (h1 : ring (dlist fun_info)) : rank_condition (dlist fun_info) := sorry --non-trivial
lemma new_lemma_70812 (h0 : ring (metric_space (comm_ring linarith.comp_source))) : rank_condition (metric_space (comm_ring linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_70813 (h0 : topological_space (has_to_string (semigroup (semigroup Type)))) : discrete_topology (has_to_string (semigroup (semigroup Type))) := sorry --non-trivial
lemma new_lemma_70814 (h0 : list (has_add (has_add (has_add linarith.comp)))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_70815 (h0 : fin has_zero.zero) : @strong_rank_condition.{0} (generalized_boolean_algebra.{0} pos) (@matrix.vec_empty.{0} (ring.{0} (generalized_boolean_algebra.{0} pos)) h0)  := sorry --non-trivial
lemma new_lemma_70816 (h0 : complete_lattice (option (semiring num))) : is_atomistic (option (semiring num)) := sorry --non-trivial
lemma new_lemma_70817 (h0 : topological_space (add_group (ordered_comm_monoid (has_add (has_neg real))))) : t1_space (add_group (ordered_comm_monoid (has_add (has_neg real)))) := sorry --non-trivial
lemma new_lemma_70818 (h0 : filter (normed_comm_ring (comm_group name))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_70819 (h0 : add_monoid (measure_theory.measure_space (has_top num))) : add_monoid.fg (measure_theory.measure_space (has_top num)) := sorry --non-trivial
lemma new_lemma_70820 (h0 : not (has_mem.mem (semiring fun_info) has_emptyc.emptyc -> false)) : @is_domain.{0} (semiring.{0} fun_info) (@finset.pi.empty.{1 0} Type ring.{0} (semiring.{0} fun_info) (@classical.by_contradiction'.{0} (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (semiring.{0} fun_info) (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))) h0))  := sorry --non-trivial
lemma new_lemma_70821 (h0 : cancel_comm_monoid_with_zero (add_cancel_monoid (option unsigned))) : unique_factorization_monoid (add_cancel_monoid (option unsigned)) := sorry --non-trivial
lemma new_lemma_70822 (h0 : function.extfun (finset Type) (has_mem.mem (with_bot linarith.comp))) : @complete_space.{0} (with_bot.{0} linarith.comp) (@finset.pi.empty.{1 0} Type uniform_space.{0} (with_bot.{0} linarith.comp) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (with_bot.{0} linarith.comp)) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_70823 (h0 : functor.add_const (uniform_space (cancel_monoid linarith.comp)) name) : @complete_space.{0} (cancel_monoid.{0} linarith.comp) (@functor.add_const.run.{0 0} (uniform_space.{0} (cancel_monoid.{0} linarith.comp)) name h0)  := sorry --non-trivial
lemma new_lemma_70824 (h0 : filter (linear_ordered_add_comm_group (with_bot (random_gen linarith.ineq)))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_70825 (h0 : topological_space (has_emptyc linarith.ineq)) : irreducible_space (has_emptyc linarith.ineq) := sorry --non-trivial
lemma new_lemma_70826 (h0 : functor.add_const (monoid (preorder empty)) empty) : @monoid.fg.{0} (preorder.{0} empty) (@functor.add_const.run.{0 0} (monoid.{0} (preorder.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_70827 (h0 : topological_space (add_comm_monoid (comm_group (boolean_algebra name)))) : discrete_topology (add_comm_monoid (comm_group (boolean_algebra name))) := sorry --non-trivial
lemma new_lemma_70828 (h0 : group (boolean_algebra (has_Inf Type))) : is_cyclic (boolean_algebra (has_Inf Type)) := sorry --non-trivial
lemma new_lemma_70829 (h0 : functor.add_const (topological_space (semigroup environment.implicit_infer_kind)) pos) : @preconnected_space.{0} (semigroup.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (semigroup.{0} environment.implicit_infer_kind)) pos h0)  := sorry --non-trivial
lemma new_lemma_70830 (h0 : semiring (has_add (comm_group (finset environment.implicit_infer_kind)))) : is_noetherian_ring (has_add (comm_group (finset environment.implicit_infer_kind))) := sorry --non-trivial
lemma new_lemma_70831 (h0 : function.extfun Type uniform_space) : @complete_space.{0} (has_bot.{0} empty) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (has_bot.{0} empty))  := sorry --non-trivial
lemma new_lemma_70832 (h0 : complete_lattice (has_pos_part real)) : complete_lattice.is_Sup_finite_compact (has_pos_part real) := sorry --non-trivial
lemma new_lemma_70833 (h0 : functor.add_const (group (has_pos_part pos)) name) : @group.fg.{0} (has_pos_part.{0} pos) (@functor.add_const.run.{0 0} (group.{0} (has_pos_part.{0} pos)) name h0)  := sorry --non-trivial
lemma new_lemma_70834 (h0 : monoid (has_norm (semiring (semiring empty)))) : monoid.fg (has_norm (semiring (semiring empty))) := sorry --non-trivial
lemma new_lemma_70835 (h0 : Type -> Type -> Prop) : is_total_preorder Type h0 := sorry --non-trivial
lemma new_lemma_70836 (h0 : topological_space (finset (has_add Type))) : normal_space (finset (has_add Type)) := sorry --non-trivial
lemma new_lemma_70837 (h0 : list (has_neg num)) : palindrome h0 := sorry --non-trivial
lemma new_lemma_70838 (h0 : add_group (uniform_space reducibility_hints)) : is_add_cyclic (uniform_space reducibility_hints) := sorry --non-trivial
lemma new_lemma_70839 (h0 : not (ring (with_zero linarith.ineq) -> false)) : @rank_condition.{0} (with_zero.{0} linarith.ineq) (@classical.by_contradiction'.{1} (ring.{0} (with_zero.{0} linarith.ineq)) h0)  := sorry --non-trivial
lemma new_lemma_70840 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_compactly_generated.{0} (denumerable.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (denumerable.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_70841 (h0 : not (topological_space (has_top (semiring (semiring (semiring (semiring unsigned))))) -> false)) : @totally_disconnected_space.{0} (has_top.{0} (semiring.{0} (semiring.{0} (semiring.{0} (semiring.{0} unsigned))))) (@classical.by_contradiction'.{1} (topological_space.{0} (has_top.{0} (semiring.{0} (semiring.{0} (semiring.{0} (semiring.{0} unsigned)))))) h0)  := sorry --non-trivial
lemma new_lemma_70842 (h0 : semiring (simple_graph (finset (has_add (boolean_algebra pos))))) : is_noetherian_ring (simple_graph (finset (has_add (boolean_algebra pos)))) := sorry --non-trivial
lemma new_lemma_70843 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @archimedean.{0} (normed_comm_ring.{0} pos) (@function.extfun_app.{2 1} Type ordered_add_comm_monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ordered_add_comm_monoid.{0}) (normed_comm_ring.{0} pos))  := sorry --non-trivial
lemma new_lemma_70844 (h0 : not (function.extfun Type filter -> false)) : filter.ne_bot (function.extfun_app (classical.by_contradiction' h0) (has_top empty)) := sorry --non-trivial
lemma new_lemma_70845 (h1 : complete_lattice (comm_ring (random_gen (random_gen string_imp)))) : is_compactly_generated (comm_ring (random_gen (random_gen string_imp))) := sorry --non-trivial
lemma new_lemma_70846 (h0 : functor.add_const (complete_lattice (has_inner unsigned unsigned)) unsigned) : @is_compactly_generated.{0} (has_inner.{0 0} unsigned unsigned) (@functor.add_const.run.{0 0} (complete_lattice.{0} (has_inner.{0 0} unsigned unsigned)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_70847 (h0 : function.extfun Type monoid) : @monoid.fg.{0} (linear_ordered_field.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type monoid.{0} h0 (linear_ordered_field.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_70848 (h0 : topological_space (finset (add_cancel_monoid Type))) : irreducible_space (finset (add_cancel_monoid Type)) := sorry --non-trivial
lemma new_lemma_70849 (h0 : has_mem.mem num has_emptyc.emptyc) : @discrete_topology.{0} num (@finset.pi.empty.{1 0} Type topological_space.{0} num h0)  := sorry --non-trivial
lemma new_lemma_70850 (h0 : topological_space (comm_group (has_to_string Type))) : irreducible_space (comm_group (has_to_string Type)) := sorry --non-trivial
lemma new_lemma_70851 (h0 : function.extfun (finset Type) (has_mem.mem (with_bot congr_arg_kind))) : @totally_separated_space.{0} (with_bot.{0} congr_arg_kind) (@finset.pi.empty.{1 0} Type topological_space.{0} (with_bot.{0} congr_arg_kind) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (with_bot.{0} congr_arg_kind)) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_70852 (h0 : function.extfun Type list) : palindrome (function.extfun_app h0 (has_neg empty)) := sorry --non-trivial
lemma new_lemma_70853 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @totally_disconnected_space.{0} (has_neg.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_neg.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_70854 (h0 : functor.add_const (add_group (ring pos)) (has_neg Type)) : @is_add_cyclic.{0} (ring.{0} pos) (@functor.add_const.run.{0 1} (add_group.{0} (ring.{0} pos)) (has_neg.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_70855 (h1 : topological_space (nondiscrete_normed_field enat)) (h2 : preorder (nondiscrete_normed_field enat)) : order_topology (nondiscrete_normed_field enat) := sorry --non-trivial
lemma new_lemma_70856 (h0 : fin has_zero.zero) : @Lim.{0} Prop sierpinski_space (@nonempty_of_inhabited.{1} Prop sort.inhabited.{0}) (@matrix.vec_empty.{0} (filter.{0} Prop) (@id.{1} (fin (@has_zero.zero.{0} nat nat.has_zero)) (@id.{1} (fin (@has_zero.zero.{0} nat nat.has_zero)) h0)))  := sorry --non-trivial
lemma new_lemma_70857 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_domain.{0} (linear_ordered_field.{0} unsigned) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (linear_ordered_field.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_70858 (h0 : ordered_comm_monoid (canonically_ordered_comm_semiring name)) : has_exists_mul_of_le (canonically_ordered_comm_semiring name) := sorry --non-trivial
lemma new_lemma_70859 (h0 : group (has_union empty)) : group.fg (has_union empty) := sorry --non-trivial
lemma new_lemma_70860 (h0 : uniform_space (has_add (has_Inf Type))) : complete_space (has_add (has_Inf Type)) := sorry --non-trivial
lemma new_lemma_70861 (h0 : functor.add_const (uniform_space (semigroup pos)) (option pos)) : @complete_space.{0} (semigroup.{0} pos) (@functor.add_const.run.{0 0} (uniform_space.{0} (semigroup.{0} pos)) (option.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_70862 (h0 : topological_space (linear_ordered_comm_group unsigned)) : irreducible_space (linear_ordered_comm_group unsigned) := sorry --non-trivial
lemma new_lemma_70863 (h0 : has_lt enat) : no_max_order enat := sorry --non-trivial
lemma new_lemma_70864 (h0 : list (random_gen to_additive.value_type)) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_70865 (h0 : topological_space (has_Inf (has_neg (has_neg (ring linarith.comp))))) : locally_compact_space (has_Inf (has_neg (has_neg (ring linarith.comp)))) := sorry --non-trivial
lemma new_lemma_70866 (h2 : add_group (with_zero fun_info)) : is_add_cyclic (with_zero fun_info) := sorry --non-trivial
lemma new_lemma_70867 (h0 : functor.add_const (topological_space (has_to_string pos)) name) : @t1_space.{0} (has_to_string.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (has_to_string.{0} pos)) name h0)  := sorry --non-trivial
lemma new_lemma_70868 (h1 : uniform_space (simple_graph linarith.comp_source)) : complete_space (simple_graph linarith.comp_source) := sorry --non-trivial
lemma new_lemma_70869 (h0 : complete_lattice (has_bot (has_add (has_Inf Type)))) : is_compactly_generated (has_bot (has_add (has_Inf Type))) := sorry --non-trivial
lemma new_lemma_70870 (h0 : complete_lattice (sub_neg_monoid (sub_neg_monoid (has_neg (has_Inf Type))))) : is_atomistic (sub_neg_monoid (sub_neg_monoid (has_neg (has_Inf Type)))) := sorry --non-trivial
lemma new_lemma_70871 (h0 : uniform_space (simple_graph (mul_one_class char))) : complete_space (simple_graph (mul_one_class char)) := sorry --non-trivial
lemma new_lemma_70872 (h1 : complete_lattice (div_inv_monoid (has_ssubset char))) : is_compactly_generated (div_inv_monoid (has_ssubset char)) := sorry --non-trivial
lemma new_lemma_70873 (h0 : functor.add_const (topological_space (has_nndist ennreal)) pos) : @path_connected_space.{0} (has_nndist.{0} ennreal) (@functor.add_const.run.{0 0} (topological_space.{0} (has_nndist.{0} ennreal)) pos h0)  := sorry --non-trivial
lemma new_lemma_70874 (h5 : topological_space (mul_one_class (mul_one_class std_gen))) : path_connected_space (mul_one_class (mul_one_class std_gen)) := sorry --non-trivial
lemma new_lemma_70875 (h0 : ring (linear_ordered_comm_ring num)) : is_principal_ideal_ring (linear_ordered_comm_ring num) := sorry --non-trivial
lemma new_lemma_70876 (h0 : prod (complete_semilattice_Sup empty) (complete_semilattice_Sup empty)) : id_rel h0 := sorry --non-trivial
lemma new_lemma_70877 (h0 : topological_space (ordered_ring num)) : irreducible_space (ordered_ring num) := sorry --non-trivial
lemma new_lemma_70878 (h0 : group (left_cancel_semigroup unsigned)) : is_cyclic (left_cancel_semigroup unsigned) := sorry --non-trivial
lemma new_lemma_70879 (h0 : function.extfun Type semiring) : @is_noetherian_ring.{0} (finset.{0} pos) (@function.extfun_app.{2 1} Type semiring.{0} h0 (finset.{0} pos))  := sorry --non-trivial
lemma new_lemma_70880 (h0 : function.extfun Type list) : list.nodup (function.extfun_app h0 (has_dist unsigned)) := sorry --non-trivial
lemma new_lemma_70881 (h0 : functor.comp filter comm_group Type) : filter.ne_bot (functor.comp.run h0) := sorry --non-trivial
lemma new_lemma_70882 (h0 : functor.add_const (function.extfun Type uniform_space) name) : @separated_space.{0} linarith.comp (@function.extfun_app.{2 1} Type uniform_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type uniform_space.{0}) name h0) linarith.comp)  := sorry --non-trivial
lemma new_lemma_70883 (h0 : topological_space (has_add (has_add (has_neg linarith.comp)))) : regular_space (has_add (has_add (has_neg linarith.comp))) := sorry --non-trivial
lemma new_lemma_70884 (h0 : uniform_space (measurable_space.dynkin_system (semiring (semiring congr_arg_kind)))) : complete_space (measurable_space.dynkin_system (semiring (semiring congr_arg_kind))) := sorry --non-trivial
lemma new_lemma_70885 (h0 : topological_space (finset (has_add linarith.comp))) : topological_space.separable_space (finset (has_add linarith.comp)) := sorry --non-trivial
lemma new_lemma_70886 (h0 : topological_space (preorder unsigned)) : topological_space.separable_space (preorder unsigned) := sorry --non-trivial
lemma new_lemma_70887 (h0 : ring (encodable (random_gen (comm_ring fun_info)))) : is_domain (encodable (random_gen (comm_ring fun_info))) := sorry --non-trivial
lemma new_lemma_70888 (h0 : ring (linear_ordered_add_comm_group (div_inv_monoid linarith.comp_source))) : strong_rank_condition (linear_ordered_add_comm_group (div_inv_monoid linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_70889 (h0 : group (has_neg_part (boolean_algebra.core pos))) : normalizer_condition (has_neg_part (boolean_algebra.core pos)) := sorry --non-trivial
lemma new_lemma_70890 (h0 : complete_lattice (random_gen (denumerable (has_nnnorm (comm_ring (comm_ring fun_info)))))) : is_compactly_generated (random_gen (denumerable (has_nnnorm (comm_ring (comm_ring fun_info))))) := sorry --non-trivial
lemma new_lemma_70891 (h0 : function.extfun (finset Type) (has_mem.mem znum)) : @is_compactly_generated.{0} znum (@finset.pi.empty.{1 0} Type complete_lattice.{0} znum (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) znum) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_70892 (h0 : list (cancel_monoid ennreal)) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_70893 (h0 : complete_lattice (id (has_norm (has_norm (has_top empty))))) : is_compactly_generated (id (has_norm (has_norm (has_top empty)))) := sorry --non-trivial
lemma new_lemma_70894 (h1 : ring (has_norm string_imp)) : rank_condition (has_norm string_imp) := sorry --non-trivial
lemma new_lemma_70895 (h0 : topological_space (is_R_or_C (option (option (option (option unsigned)))))) : totally_disconnected_space (is_R_or_C (option (option (option (option unsigned))))) := sorry --non-trivial
lemma new_lemma_70896 (h0 : function.extfun (finset (Type -> Type)) (has_mem.mem uniform_space)) : @complete_space.{0} (semiring.{0} fun_info) (@function.extfun_app.{2 1} Type uniform_space.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) uniform_space.{0} (@function.extfun_app.{2 0} (finset.{1} (Type → Type)) (@has_mem.mem.{1 1} (Type → Type) (finset.{1} (Type → Type)) (@finset.has_mem.{1} (Type → Type)) uniform_space.{0}) h0 (@has_emptyc.emptyc.{1} (finset.{1} (Type → Type)) (@finset.has_emptyc.{1} (Type → Type))))) (semiring.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_70897 (h0 : ordered_comm_monoid (complete_distrib_lattice (has_neg_part (comm_group ennreal)))) : has_exists_mul_of_le (complete_distrib_lattice (has_neg_part (comm_group ennreal))) := sorry --non-trivial
lemma new_lemma_70898 (h0 : topological_space (add_group (semiring (semiring unsigned)))) : discrete_topology (add_group (semiring (semiring unsigned))) := sorry --non-trivial
lemma new_lemma_70899 (h0 : uniform_space (monoid_with_zero (option pos))) : separated_space (monoid_with_zero (option pos)) := sorry --non-trivial
lemma new_lemma_70900 (h0 : group (add_cancel_monoid (option ennreal))) : is_simple_group (add_cancel_monoid (option ennreal)) := sorry --non-trivial
lemma new_lemma_70901 (h0 : topological_space (ordered_comm_monoid (has_pos_part linarith.comp))) : irreducible_space (ordered_comm_monoid (has_pos_part linarith.comp)) := sorry --non-trivial
lemma new_lemma_70902 (h0 h1 : multiset (simple_graph linarith.comp_source)) : multiset.subset h0 h1 := sorry --non-trivial
lemma new_lemma_70903 (h0 : function.extfun (finset Type) (has_mem.mem (random_gen linarith.ineq))) : @is_compactly_generated.{0} (random_gen.{0} linarith.ineq) (@finset.pi.empty.{1 0} Type complete_lattice.{0} (random_gen.{0} linarith.ineq) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (random_gen.{0} linarith.ineq)) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_70904 (h0 : linarith.comp_source -> ring (uniform_space reducibility_hints)) (h1 : ordinal) (h2 : has_lt.lt h1 (ordinal.type well_ordering_rel)) : @is_domain.{0} (uniform_space.{0} reducibility_hints) (@ordinal.bfamily_of_family.{0 0} (ring.{0} (uniform_space.{0} reducibility_hints)) linarith.comp_source h0 h1 h2)  := sorry --non-trivial
lemma new_lemma_70905 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @locally_compact_space.{0} (mul_zero_class.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (mul_zero_class.{0} name))  := sorry --non-trivial
lemma new_lemma_70906 (h0 : functor.add_const (topological_space (has_to_string Type)) pos) : @topological_space.separable_space.{1} (has_to_string.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (has_to_string.{1} Type)) pos h0)  := sorry --non-trivial
lemma new_lemma_70907 (h0 : topological_space (option (semiring empty))) : totally_separated_space (option (semiring empty)) := sorry --non-trivial
lemma new_lemma_70908 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @path_connected_space.{0} (linear_ordered_semiring.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (linear_ordered_semiring.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_70909 (h0 : topological_space (add_right_cancel_monoid congr_arg_kind)) : path_connected_space (add_right_cancel_monoid congr_arg_kind) := sorry --non-trivial
lemma new_lemma_70910 (h0 : function.extfun Type uniform_space) : @separated_space.{0} (measurable_space.{0} fun_info) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (measurable_space.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_70911 (h0 : function.extfun (nat -> Type) (function.extfun nat)) : @loc_path_connected_space.{0} (has_bot.{0} pos) (@matrix.vec_empty.{0} (topological_space.{0} (has_bot.{0} pos)) (@function.extfun_app.{1 1} nat fin (@function.extfun_app.{2 1} (nat → Type) (function.extfun.{1 1} nat) h0 fin) (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_70912 (h0 : complete_lattice pos) : is_atomistic pos := sorry --non-trivial
lemma new_lemma_70913 (h0 : function.extfun Type complete_lattice) : @is_compactly_generated.{0} (cancel_monoid.{0} name) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (cancel_monoid.{0} name))  := sorry --non-trivial
lemma new_lemma_70914 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @loc_path_connected_space.{1} (has_Inf.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 topological_space.{1}) (has_Inf.{1} Type))  := sorry --non-trivial
lemma new_lemma_70915 (h0 : functor.add_const (topological_space (ordered_comm_ring name)) linarith.comp) : @preconnected_space.{0} (ordered_comm_ring.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (ordered_comm_ring.{0} name)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_70916 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_add_cyclic.{0} (group_with_zero.{0} num) (@function.extfun_app.{2 1} Type add_group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 add_group.{0}) (group_with_zero.{0} num))  := sorry --non-trivial
lemma new_lemma_70917 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @path_connected_space.{0} (add_comm_monoid.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (add_comm_monoid.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_70918 (h0 : topological_space (normed_group (random_gen (random_gen (has_ssubset (has_ssubset fun_info)))))) : t0_space (normed_group (random_gen (random_gen (has_ssubset (has_ssubset fun_info))))) := sorry --non-trivial
lemma new_lemma_70919 (h0 : functor.add_const (topological_space (bin_tree congr_arg_kind)) congr_arg_kind) : @topological_space.separable_space.{0} (bin_tree.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (bin_tree.{0} congr_arg_kind)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_70920 (h0 : functor.add_const (function.extfun (Type 1) topological_space) pos) : @totally_disconnected_space.{1} Type (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) topological_space.{1}) pos h0) Type)  := sorry --non-trivial
lemma new_lemma_70921 (h0 : functor.add_const (topological_space (normed_linear_ordered_group num)) num) : @irreducible_space.{0} (normed_linear_ordered_group.{0} num) (@functor.add_const.run.{0 0} (topological_space.{0} (normed_linear_ordered_group.{0} num)) num h0)  := sorry --non-trivial
lemma new_lemma_70922 (h0 : topological_space (boolean_algebra (boolean_algebra pos))) : topological_space.separable_space (boolean_algebra (boolean_algebra pos)) := sorry --non-trivial
lemma new_lemma_70923 (h0 : function.extfun Type topological_space) : @preirreducible_space.{0} (has_neg.{0} ennreal) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_neg.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_70924 (h0 : uniform_space (normed_field ereal)) : complete_space (normed_field ereal) := sorry --non-trivial
lemma new_lemma_70925 (h0 : ring (boolean_algebra.core empty)) : is_domain (boolean_algebra.core empty) := sorry --non-trivial
lemma new_lemma_70926 (h0 : topological_space (has_neg (option unsigned))) : sequential_space (has_neg (option unsigned)) := sorry --non-trivial
lemma new_lemma_70927 (h0 : function.extfun Type complete_lattice) : @is_atomistic.{0} unsigned (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 unsigned)  := sorry --non-trivial
lemma new_lemma_70928 (h0 : list (comm_ring (random_gen (random_gen string_imp)))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_70929 (h2 : uniform_space (with_zero (has_nnnorm linarith.ineq))) : complete_space (with_zero (has_nnnorm linarith.ineq)) := sorry --non-trivial
lemma new_lemma_70930 (h0 : functor.add_const (function.extfun Type topological_space) linarith.comp) : @totally_separated_space.{0} (generalized_boolean_algebra.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) linarith.comp h0) (generalized_boolean_algebra.{0} pos))  := sorry --non-trivial
lemma new_lemma_70931 (h0 : functor.add_const (topological_space (has_add linarith.comp)) linarith.comp) : @totally_disconnected_space.{0} (has_add.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (has_add.{0} linarith.comp)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_70932 (h0 : not (function.extfun (Type -> Type) (function.extfun Type) -> false)) : @group.fg.{0} (semiring.{0} linarith.comp) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) (@classical.by_contradiction'.{2} (function.extfun.{2 2} (Type → Type) (function.extfun.{2 1} Type)) h0) group.{0}) (semiring.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_70933 (h0 : add_monoid (has_neg_part (has_nndist (finset ennreal)))) : add_monoid.fg (has_neg_part (has_nndist (finset ennreal))) := sorry --non-trivial
lemma new_lemma_70934 (h0 : group (semigroup (add_comm_monoid congr_arg_kind))) : is_simple_group (semigroup (add_comm_monoid congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_70935 (h0 : functor.add_const (finset (preorder unsigned)) unsigned) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_70936 (h0 : not (ring (simple_graph char) -> false)) : @is_domain.{0} (simple_graph.{0} char) (@classical.by_contradiction'.{1} (ring.{0} (simple_graph.{0} char)) h0)  := sorry --non-trivial
lemma new_lemma_70937 (h0 : functor.add_const (add_group (generalized_boolean_algebra pos)) name) : @is_add_cyclic.{0} (generalized_boolean_algebra.{0} pos) (@functor.add_const.run.{0 0} (add_group.{0} (generalized_boolean_algebra.{0} pos)) name h0)  := sorry --non-trivial
lemma new_lemma_70938 (h0 : add_group (has_ssubset (has_nnnorm (random_gen linarith.comp_source)))) : is_add_cyclic (has_ssubset (has_nnnorm (random_gen linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_70939 (h0 : function.extfun Type (functor.add_const (topological_space (left_cancel_monoid unsigned)))) : @totally_disconnected_space.{0} (left_cancel_monoid.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (left_cancel_monoid.{0} unsigned)) empty (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (topological_space.{0} (left_cancel_monoid.{0} unsigned))) h0 empty))  := sorry --non-trivial
lemma new_lemma_70940 (h0 : topological_space (has_inner unsigned congr_arg_kind)) : t1_space (has_inner unsigned congr_arg_kind) := sorry --non-trivial
lemma new_lemma_70941 (h0 : functor.add_const (list (monoid empty)) empty) : list.nodup (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_70942 (h0 : functor.add_const (function.extfun Type filter) pos) : filter.ne_bot (function.extfun_app (functor.add_const.run h0) (semigroup linarith.comp)) := sorry --non-trivial
lemma new_lemma_70943 (h0 : functor.add_const (topological_space (boolean_algebra Type)) (has_pos_part (has_Inf (has_pos_part pos)))) : @totally_disconnected_space.{1} (boolean_algebra.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (boolean_algebra.{1} Type)) (has_pos_part.{0} (has_Inf.{0} (has_pos_part.{0} pos))) h0)  := sorry --non-trivial
lemma new_lemma_70944 (h0 : not (ring (partial_order num) -> false)) : @is_domain.{0} (partial_order.{0} num) (@classical.by_contradiction'.{1} (ring.{0} (partial_order.{0} num)) h0)  := sorry --non-trivial
lemma new_lemma_70945 (h0 : has_mem.mem (random_gen linarith.ineq) has_emptyc.emptyc) : @is_compactly_generated.{0} (random_gen.{0} linarith.ineq) (@finset.pi.empty.{1 0} Type complete_lattice.{0} (random_gen.{0} linarith.ineq) h0)  := sorry --non-trivial
lemma new_lemma_70946 (h0 : topological_space (has_compl (random_gen linarith.comp_source))) : path_connected_space (has_compl (random_gen linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_70947 (h0 : ring (complete_linear_order (semiring (semiring (semiring empty))))) : rank_condition (complete_linear_order (semiring (semiring (semiring empty)))) := sorry --non-trivial
lemma new_lemma_70948 (h0 : ordered_comm_monoid (has_pos_part (ring name))) : has_exists_mul_of_le (has_pos_part (ring name)) := sorry --non-trivial
lemma new_lemma_70949 (h0 : function.extfun Type topological_space) : @preirreducible_space.{0} (has_star.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_star.{0} empty))  := sorry --non-trivial
lemma new_lemma_70950 (h0 : function.extfun Type group) : @normalizer_condition.{0} (add_cancel_comm_monoid.{0} unsigned) (@function.extfun_app.{2 1} Type group.{0} h0 (add_cancel_comm_monoid.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_70951 (h0 : ordered_add_comm_monoid (canonically_ordered_comm_semiring (option (option (option unsigned))))) : archimedean (canonically_ordered_comm_semiring (option (option (option unsigned)))) := sorry --non-trivial
lemma new_lemma_70952 (h0 : monoid (topological_space (has_nnnorm fun_info))) (h1 : uniform_space (conj_classes (topological_space (has_nnnorm fun_info)))) : complete_space (conj_classes (topological_space (has_nnnorm fun_info))) := sorry --non-trivial
lemma new_lemma_70953 (h0 : functor.add_const (ring (cancel_monoid name)) name) : @rank_condition.{0} (cancel_monoid.{0} name) (@functor.add_const.run.{0 0} (ring.{0} (cancel_monoid.{0} name)) name h0)  := sorry --non-trivial
lemma new_lemma_70954 (h0 : not (topological_space (normed_group fun_info) -> false)) : @totally_disconnected_space.{0} (normed_group.{0} fun_info) (@classical.by_contradiction'.{1} (topological_space.{0} (normed_group.{0} fun_info)) h0)  := sorry --non-trivial
lemma new_lemma_70955 (h0 : functor.add_const (ordered_add_comm_monoid (has_add linarith.comp)) Type) : @archimedean.{0} (has_add.{0} linarith.comp) (@functor.add_const.run.{0 1} (ordered_add_comm_monoid.{0} (has_add.{0} linarith.comp)) Type h0)  := sorry --non-trivial
lemma new_lemma_70956 (h0 : uniform_space (semiring unsigned)) : separated_space (semiring unsigned) := sorry --non-trivial
lemma new_lemma_70957 (h0 : add_group (has_to_string (has_add (has_add name)))) : is_add_cyclic (has_to_string (has_add (has_add name))) := sorry --non-trivial
lemma new_lemma_70958 (h0 : functor.add_const (topological_space (has_zero pos)) name) : @sequential_space.{0} (has_zero.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (has_zero.{0} pos)) name h0)  := sorry --non-trivial
lemma new_lemma_70959 (h0 : ring (dlist (comm_ring char))) : strong_rank_condition (dlist (comm_ring char)) := sorry --non-trivial
lemma new_lemma_70960 (h0 : topological_space (comm_group linarith.comp)) : totally_disconnected_space (comm_group linarith.comp) := sorry --non-trivial
lemma new_lemma_70961 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @discrete_topology.{0} (has_pos_part.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_pos_part.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_70962 (h0 : topological_space (semigroup (option empty))) : preirreducible_space (semigroup (option empty)) := sorry --non-trivial
lemma new_lemma_70963 (h1 : topological_space (denumerable (comm_ring (comm_ring char)))) : t0_space (denumerable (comm_ring (comm_ring char))) := sorry --non-trivial
lemma new_lemma_70964 (h0 : topological_space (cancel_monoid (option (option unsigned)))) : locally_compact_space (cancel_monoid (option (option unsigned))) := sorry --non-trivial
lemma new_lemma_70965 (h0 : add_group (nondiscrete_normed_field (mul_one_class (mul_one_class (mul_one_class char))))) : is_add_cyclic (nondiscrete_normed_field (mul_one_class (mul_one_class (mul_one_class char)))) := sorry --non-trivial
lemma new_lemma_70966 (h0 : function.extfun Type topological_space) : @loc_path_connected_space.{0} (boolean_algebra.core.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (boolean_algebra.core.{0} pos))  := sorry --non-trivial
lemma new_lemma_70967 (h0 : functor.comp cancel_comm_monoid_with_zero mul_zero_class pos) : @unique_factorization_monoid.{0} (mul_zero_class.{0} pos) (@functor.comp.run.{0 0 0} cancel_comm_monoid_with_zero.{0} mul_zero_class.{0} pos h0)  := sorry --non-trivial
lemma new_lemma_70968 (h0 : topological_space (normed_comm_ring congr_arg_kind)) : t1_space (normed_comm_ring congr_arg_kind) := sorry --non-trivial
lemma new_lemma_70969 (h2 : not (topological_space (random_gen fun_info) -> false)) : @path_connected_space.{0} (random_gen.{0} fun_info) (@classical.by_contradiction'.{1} (topological_space.{0} (random_gen.{0} fun_info)) h2)  := sorry --non-trivial
lemma new_lemma_70970 (h0 : std_gen -> nat) (h1 h2 : std_gen) : measure h0 h1 h2 := sorry --non-trivial
lemma new_lemma_70971 (h0 : functor.add_const (topological_space (semigroup environment.implicit_infer_kind)) name) : @discrete_topology.{0} (semigroup.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (semigroup.{0} environment.implicit_infer_kind)) name h0)  := sorry --non-trivial
lemma new_lemma_70972 (h0 : functor.add_const (topological_space (has_to_string ennreal)) num) : @t1_space.{0} (has_to_string.{0} ennreal) (@functor.add_const.run.{0 0} (topological_space.{0} (has_to_string.{0} ennreal)) num h0)  := sorry --non-trivial
lemma new_lemma_70973 (h0 : complete_lattice (ordered_comm_ring (finset (ring Type)))) : is_compactly_generated (ordered_comm_ring (finset (ring Type))) := sorry --non-trivial
lemma new_lemma_70974 (h0 : functor.add_const (topological_space (linear_ordered_field empty)) congr_arg_kind) : @t0_space.{0} (linear_ordered_field.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (linear_ordered_field.{0} empty)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_70975 (h5 : ring (simple_graph std_gen)) : is_domain (simple_graph std_gen) := sorry --non-trivial
lemma new_lemma_70976 (h0 : function.extfun Type topological_space) : @locally_compact_space.{0} (left_cancel_semigroup.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (left_cancel_semigroup.{0} num))  := sorry --non-trivial
lemma new_lemma_70977 (h0 : has_le ereal) (h1 : ereal) : is_bot h1 := sorry --non-trivial
lemma new_lemma_70978 (h0 : topological_space (boolean_algebra (has_pos_part (has_Inf (finset Type))))) : discrete_topology (boolean_algebra (has_pos_part (has_Inf (finset Type)))) := sorry --non-trivial
lemma new_lemma_70979 (h3 : complete_lattice ereal) : complete_lattice.is_Sup_finite_compact ereal := sorry --non-trivial
lemma new_lemma_70980 (h0 : group (has_neg (option pos))) : is_cyclic (has_neg (option pos)) := sorry --non-trivial
lemma new_lemma_70981 (h0 : znum -> znum -> Prop) : total h0 := sorry --non-trivial
lemma new_lemma_70982 (h0 : group (comm_group environment.implicit_infer_kind)) : group.fg (comm_group environment.implicit_infer_kind) := sorry --non-trivial
lemma new_lemma_70983 (h0 : functor.comp topological_space canonically_ordered_comm_semiring ennreal) : @totally_disconnected_space.{0} (canonically_ordered_comm_semiring.{0} ennreal) (@functor.comp.run.{0 0 0} topological_space.{0} canonically_ordered_comm_semiring.{0} ennreal h0)  := sorry --non-trivial
lemma new_lemma_70984 (h0 : fin has_zero.zero) : @unique_factorization_monoid.{0} (comm_semigroup.{0} pos) (@matrix.vec_empty.{0} (cancel_comm_monoid_with_zero.{0} (comm_semigroup.{0} pos)) (@matrix.vec_empty.{0} (fin (@has_zero.zero.{0} nat nat.has_zero)) h0))  := sorry --non-trivial
lemma new_lemma_70985 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @normal_space.{0} (comm_group.{0} ennreal) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (comm_group.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_70986 (h0 : monoid (semigroup (semiring empty))) : monoid.fg (semigroup (semiring empty)) := sorry --non-trivial
lemma new_lemma_70987 (h0 : complete_lattice (boolean_algebra.core pos)) : is_compactly_generated (boolean_algebra.core pos) := sorry --non-trivial
lemma new_lemma_70988 (h0 : topological_space (has_Sup unsigned)) : totally_separated_space (has_Sup unsigned) := sorry --non-trivial
lemma new_lemma_70989 (h0 : complete_lattice (ordered_comm_monoid (sub_neg_monoid Type))) : is_atomistic (ordered_comm_monoid (sub_neg_monoid Type)) := sorry --non-trivial
lemma new_lemma_70990 (h0 : functor.add_const (topological_space (boolean_algebra name)) name) : @path_connected_space.{0} (boolean_algebra.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (boolean_algebra.{0} name)) name h0)  := sorry --non-trivial
lemma new_lemma_70991 (h0 : topological_space (free_add_monoid empty)) : locally_compact_space (free_add_monoid empty) := sorry --non-trivial
lemma new_lemma_70992 (h0 : function.extfun Type topological_space) : @t0_space.{0} (partial_order.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (partial_order.{0} num))  := sorry --non-trivial
lemma new_lemma_70993 (h0 : functor.add_const (complete_lattice (has_neg_part unsigned)) pos) : @is_compactly_generated.{0} (has_neg_part.{0} unsigned) (@functor.add_const.run.{0 0} (complete_lattice.{0} (has_neg_part.{0} unsigned)) pos h0)  := sorry --non-trivial
lemma new_lemma_70994 (h0 : ring (finset (option (option unsigned)))) : is_principal_ideal_ring (finset (option (option unsigned))) := sorry --non-trivial
lemma new_lemma_70995 (h0 : functor.add_const (function.extfun Type topological_space) pos) : @loc_path_connected_space.{0} (ring.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) pos h0) (ring.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_70996 (h1 : normed_group char) (h2 : star_add_monoid char) (h3 : set (ereal -> normed_star_monoid char)) : set.separates_points h3 := sorry --non-trivial
lemma new_lemma_70997 (h0 : ring (add_cancel_monoid (has_pos_part pos))) : rank_condition (add_cancel_monoid (has_pos_part pos)) := sorry --non-trivial
lemma new_lemma_70998 (h0 : function.extfun Type group) : @normalizer_condition.{0} (random_gen.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type group.{0} h0 (random_gen.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_70999 (h0 : finset (normed_comm_ring num)) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_71000 (h0 : function.extfun (finset Type) (has_mem.mem (has_top linarith.ineq))) : @is_atomistic.{0} (has_top.{0} linarith.ineq) (@finset.pi.empty.{1 0} Type complete_lattice.{0} (has_top.{0} linarith.ineq) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (has_top.{0} linarith.ineq)) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_71001 (h0 : add_group (normed_field (mul_one_class (mul_one_class (mul_one_class string.iterator_imp))))) : is_add_cyclic (normed_field (mul_one_class (mul_one_class (mul_one_class string.iterator_imp)))) := sorry --non-trivial
lemma new_lemma_71002 (h0 : topological_space (has_star (has_top (has_top (has_top (has_top empty)))))) : totally_disconnected_space (has_star (has_top (has_top (has_top (has_top empty))))) := sorry --non-trivial
lemma new_lemma_71003 (h0 : topological_space (has_pos_part (ordered_comm_monoid (has_Inf pos)))) : preirreducible_space (has_pos_part (ordered_comm_monoid (has_Inf pos))) := sorry --non-trivial
lemma new_lemma_71004 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_compactly_generated.{0} (finset.{0} empty) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (finset.{0} empty))  := sorry --non-trivial
lemma new_lemma_71005 (h0 : add_monoid (complete_distrib_lattice (option (option (option (option empty)))))) : add_monoid.fg (complete_distrib_lattice (option (option (option (option empty))))) := sorry --non-trivial
lemma new_lemma_71006 (h0 : list real) : palindrome h0 := sorry --non-trivial
lemma new_lemma_71007 (h0 : preorder (nondiscrete_normed_field string.iterator_imp)) (h1 : set (nondiscrete_normed_field string.iterator_imp)) : set.is_pwo h1 := sorry --non-trivial
lemma new_lemma_71008 (h0 : topological_space (mul_zero_class (mul_zero_class num))) : t0_space (mul_zero_class (mul_zero_class num)) := sorry --non-trivial
lemma new_lemma_71009 (h0 : group (has_add (sub_neg_monoid Type))) : is_cyclic (has_add (sub_neg_monoid Type)) := sorry --non-trivial
lemma new_lemma_71010 (h0 : ring (random_gen linarith.comp_source)) : strong_rank_condition (random_gen linarith.comp_source) := sorry --non-trivial
lemma new_lemma_71011 (h0 : ring (add_cancel_comm_monoid linarith.comp_source)) : rank_condition (add_cancel_comm_monoid linarith.comp_source) := sorry --non-trivial
lemma new_lemma_71012 (h0 : functor.add_const (filter (cancel_monoid name)) name) : countable_Inter_filter (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_71013 (h0 : functor.add_const (group (comm_monoid empty)) (semiring (semiring empty))) : @is_cyclic.{0} (comm_monoid.{0} empty) (@functor.add_const.run.{0 0} (group.{0} (comm_monoid.{0} empty)) (semiring.{0} (semiring.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_71014 (h0 : functor.add_const (topological_space (boolean_algebra pos)) (has_add name)) : @t0_space.{0} (boolean_algebra.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (boolean_algebra.{0} pos)) (has_add.{0} name) h0)  := sorry --non-trivial
lemma new_lemma_71015 (h0 : uniform_space (linear_ordered_add_comm_group_with_top ennreal)) : separated_space (linear_ordered_add_comm_group_with_top ennreal) := sorry --non-trivial
lemma new_lemma_71016 (h0 : functor.add_const (topological_space (option num)) congr_arg_kind) : @normal_space.{0} (option.{0} num) (@functor.add_const.run.{0 0} (topological_space.{0} (option.{0} num)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_71017 (h0 : topological_space (has_to_string Type)) : regular_space (has_to_string Type) := sorry --non-trivial
lemma new_lemma_71018 (h0 : function.extfun Type topological_space) : @preirreducible_space.{0} (left_cancel_monoid.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (left_cancel_monoid.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_71019 (h0 : group (comm_group (has_nndist environment.implicit_infer_kind))) : is_simple_group (comm_group (has_nndist environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_71020 (h0 : functor.add_const (ordered_add_comm_monoid (has_add linarith.comp)) pos) : @archimedean.{0} (has_add.{0} linarith.comp) (@functor.add_const.run.{0 0} (ordered_add_comm_monoid.{0} (has_add.{0} linarith.comp)) pos h0)  := sorry --non-trivial
lemma new_lemma_71021 (h0 : topological_space (has_top (has_top linarith.ineq))) : totally_separated_space (has_top (has_top linarith.ineq)) := sorry --non-trivial
lemma new_lemma_71022 (h0 : function.extfun (finset Type) (has_mem.mem (id empty))) : @is_add_cyclic.{0} (@id.{2} Type empty) (@finset.pi.empty.{1 0} Type add_group.{0} (@id.{2} Type empty) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (@id.{2} Type empty)) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_71023 (h0 : has_mem.mem topological_space has_emptyc.emptyc) : @irreducible_space.{0} (fintype.{0} linarith.ineq) (@function.extfun_app.{2 1} Type topological_space.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) topological_space.{0} h0) (fintype.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_71024 (h0 : cancel_comm_monoid_with_zero (has_neg_part (ring (cancel_monoid Type)))) : unique_factorization_monoid (has_neg_part (ring (cancel_monoid Type))) := sorry --non-trivial
lemma new_lemma_71025 (h0 : functor.add_const (topological_space (has_neg_part name)) unsigned) : @sequential_space.{0} (has_neg_part.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (has_neg_part.{0} name)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_71026 (h0 : function.extfun Type topological_space) : @totally_separated_space.{0} (boolean_algebra.core.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (boolean_algebra.core.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_71027 (h0 : not (topological_space (has_one reducibility_hints) -> false)) : @totally_disconnected_space.{0} (has_one.{0} reducibility_hints) (@classical.by_contradiction'.{1} (topological_space.{0} (has_one.{0} reducibility_hints)) h0)  := sorry --non-trivial
lemma new_lemma_71028 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @complete_space.{0} (finset.{0} pos) (@function.extfun_app.{2 1} Type uniform_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 uniform_space.{0}) (finset.{0} pos))  := sorry --non-trivial
lemma new_lemma_71029 (h0 : group (has_norm (has_norm (semiring empty)))) : normalizer_condition (has_norm (has_norm (semiring empty))) := sorry --non-trivial
lemma new_lemma_71030 (h0 : not (ring (linear_ordered_semiring num) -> false)) : @is_principal_ideal_ring.{0} (linear_ordered_semiring.{0} num) (@classical.by_contradiction'.{1} (ring.{0} (linear_ordered_semiring.{0} num)) h0)  := sorry --non-trivial
lemma new_lemma_71031 (h0 : topological_space (add_comm_monoid (option (option empty)))) : path_connected_space (add_comm_monoid (option (option empty))) := sorry --non-trivial
lemma new_lemma_71032 (h0 : functor.add_const (prod (has_Sup empty) (has_Sup empty)) empty) : id_rel (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_71033 (h0 : functor.add_const (finset (comm_group pos)) unsigned) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_71034 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_cyclic.{0} ennreal (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) ennreal)  := sorry --non-trivial
lemma new_lemma_71035 (h0 : group (has_bot linarith.comp)) : group.fg (has_bot linarith.comp) := sorry --non-trivial
lemma new_lemma_71036 (h0 : functor.add_const (group (normed_comm_ring name)) Type) : @is_cyclic.{0} (normed_comm_ring.{0} name) (@functor.add_const.run.{0 1} (group.{0} (normed_comm_ring.{0} name)) Type h0)  := sorry --non-trivial
lemma new_lemma_71037 (h0 : ring (with_bot (random_gen (random_gen string_imp)))) : is_domain (with_bot (random_gen (random_gen string_imp))) := sorry --non-trivial
lemma new_lemma_71038 (h0 : ring (has_neg (semigroup unsigned))) : is_principal_ideal_ring (has_neg (semigroup unsigned)) := sorry --non-trivial
lemma new_lemma_71039 (h0 : topological_space (boolean_algebra (has_add (has_add Type)))) : t1_space (boolean_algebra (has_add (has_add Type))) := sorry --non-trivial
lemma new_lemma_71040 (h0 : topological_space (generalized_boolean_algebra (has_neg Type))) : preirreducible_space (generalized_boolean_algebra (has_neg Type)) := sorry --non-trivial
lemma new_lemma_71041 (h0 : add_group (normed_comm_ring (has_add pos))) : is_add_cyclic (normed_comm_ring (has_add pos)) := sorry --non-trivial
lemma new_lemma_71042 (h0 : functor.comp topological_space cancel_monoid name) : @totally_separated_space.{0} (cancel_monoid.{0} name) (@functor.comp.run.{0 0 0} topological_space.{0} cancel_monoid.{0} name h0)  := sorry --non-trivial
lemma new_lemma_71043 (h0 : topological_space (ordered_comm_monoid (has_neg (ordered_comm_monoid (sub_neg_monoid real))))) : loc_path_connected_space (ordered_comm_monoid (has_neg (ordered_comm_monoid (sub_neg_monoid real)))) := sorry --non-trivial
lemma new_lemma_71044 (h0 : set (environment.projection_info -> fun_info)) : set.separates_points h0 := sorry --non-trivial
lemma new_lemma_71045 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @complete_space.{1} (has_Inf.{1} Type) (@function.extfun_app.{3 2} (Type 1) uniform_space.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 uniform_space.{1}) (has_Inf.{1} Type))  := sorry --non-trivial
lemma new_lemma_71046 (h0 : functor.add_const (function.extfun Type ring) pos) : @is_principal_ideal_ring.{0} (add_comm_monoid.{0} unsigned) (@function.extfun_app.{2 1} Type ring.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type ring.{0}) pos h0) (add_comm_monoid.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_71047 (h1 : topological_space (random_gen empty)) : discrete_topology (random_gen empty) := sorry --non-trivial
lemma new_lemma_71048 (h1 : uniform_space (non_unital_non_assoc_semiring to_additive.value_type)) : complete_space (non_unital_non_assoc_semiring to_additive.value_type) := sorry --non-trivial
lemma new_lemma_71049 (h0 : not (function.extfun Type complete_lattice -> false)) : @is_atomistic.{0} (has_emptyc.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type complete_lattice.{0}) h0) (has_emptyc.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_71050 (h0 : list (simple_graph (boolean_algebra.core pos))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_71051 (h0 : functor.add_const (uniform_space (finset pos)) (ring (has_to_string (has_neg (ring (ring Type)))))) : @complete_space.{0} (finset.{0} pos) (@functor.add_const.run.{0 1} (uniform_space.{0} (finset.{0} pos)) (ring.{1} (has_to_string.{1} (has_neg.{1} (ring.{1} (ring.{1} Type))))) h0)  := sorry --non-trivial
lemma new_lemma_71052 (h0 : functor.add_const (function.extfun Type group) pos) : @is_simple_group.{0} (boolean_algebra.{0} pos) (@function.extfun_app.{2 1} Type group.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type group.{0}) pos h0) (boolean_algebra.{0} pos))  := sorry --non-trivial
lemma new_lemma_71053 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @locally_compact_space.{0} (metric_space.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (metric_space.{0} num))  := sorry --non-trivial
lemma new_lemma_71054 (h0 : function.extfun Type (prod (add_cancel_monoid (option ennreal)))) : id_rel (function.extfun_app h0 (add_cancel_monoid (option ennreal))) := sorry --non-trivial
lemma new_lemma_71055 (h0 : function.extfun (finset (Type -> Type)) (has_mem.mem topological_space)) : @t0_space.{0} (semiring.{0} fun_info) (@function.extfun_app.{2 1} Type topological_space.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) topological_space.{0} (@function.extfun_app.{2 0} (finset.{1} (Type → Type)) (@has_mem.mem.{1 1} (Type → Type) (finset.{1} (Type → Type)) (@finset.has_mem.{1} (Type → Type)) topological_space.{0}) h0 (@has_emptyc.emptyc.{1} (finset.{1} (Type → Type)) (@finset.has_emptyc.{1} (Type → Type))))) (semiring.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_71056 (h0 : topological_space (has_bot (has_neg (has_Inf (has_neg (has_neg pos)))))) : sequential_space (has_bot (has_neg (has_Inf (has_neg (has_neg pos))))) := sorry --non-trivial
lemma new_lemma_71057 (h1 : semiring (add_comm_semigroup char)) (h2 : add_comm_semigroup char) : even h2 := sorry --non-trivial
lemma new_lemma_71058 (h0 : topological_space (encodable to_additive.value_type)) : irreducible_space (encodable to_additive.value_type) := sorry --non-trivial
lemma new_lemma_71059 (h0 : functor.add_const (complete_lattice (normed_linear_ordered_group empty)) congr_arg_kind) : @complete_lattice.is_Sup_finite_compact.{0} (normed_linear_ordered_group.{0} empty) (@functor.add_const.run.{0 0} (complete_lattice.{0} (normed_linear_ordered_group.{0} empty)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_71060 (h0 : group (ordered_comm_ring (finset (finset pos)))) : group.fg (ordered_comm_ring (finset (finset pos))) := sorry --non-trivial
lemma new_lemma_71061 (h0 : topological_space (has_neg (has_add (finset environment.implicit_infer_kind)))) : irreducible_space (has_neg (has_add (finset environment.implicit_infer_kind))) := sorry --non-trivial
lemma new_lemma_71062 (h0 : functor.add_const (function.extfun Type cancel_comm_monoid_with_zero) Type) : @unique_factorization_monoid.{0} (has_Inf.{0} pos) (@function.extfun_app.{2 1} Type cancel_comm_monoid_with_zero.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type cancel_comm_monoid_with_zero.{0}) Type h0) (has_Inf.{0} pos))  := sorry --non-trivial
lemma new_lemma_71063 (h0 : add_group (comm_ring linarith.comp_source)) : is_add_cyclic (comm_ring linarith.comp_source) := sorry --non-trivial
lemma new_lemma_71064 (h0 : functor.add_const (topological_space (add_right_cancel_monoid empty)) num) : @totally_disconnected_space.{0} (add_right_cancel_monoid.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (add_right_cancel_monoid.{0} empty)) num h0)  := sorry --non-trivial
lemma new_lemma_71065 (h0 : functor.add_const (topological_space (has_add pos)) pos) : @preconnected_space.{0} (has_add.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (has_add.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_71066 (h0 : not (prod (add_right_cancel_monoid empty) (add_right_cancel_monoid empty) -> false)) : id_rel (classical.by_contradiction' h0) := sorry --non-trivial
lemma new_lemma_71067 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_principal_ideal_ring.{0} (complete_distrib_lattice.{0} unsigned) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (complete_distrib_lattice.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_71068 (h0 : topological_space (pseudo_metric_space (option (option (option unsigned))))) : path_connected_space (pseudo_metric_space (option (option (option unsigned)))) := sorry --non-trivial
lemma new_lemma_71069 (h0 : complete_lattice (has_ssubset (mul_one_class char))) : is_compactly_generated (has_ssubset (mul_one_class char)) := sorry --non-trivial
lemma new_lemma_71070 (h0 : topological_space (normed_comm_ring (has_to_string Type))) : sequential_space (normed_comm_ring (has_to_string Type)) := sorry --non-trivial
lemma new_lemma_71071 (h0 : ring (id (has_top (semiring congr_arg_kind)))) : rank_condition (id (has_top (semiring congr_arg_kind))) := sorry --non-trivial
lemma new_lemma_71072 (h0 : topological_space (complete_distrib_lattice (has_neg environment.implicit_infer_kind))) : preconnected_space (complete_distrib_lattice (has_neg environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_71073 (h0 : functor.add_const (uniform_space (sub_neg_monoid linarith.comp)) (has_Inf name)) : @separated_space.{0} (sub_neg_monoid.{0} linarith.comp) (@functor.add_const.run.{0 0} (uniform_space.{0} (sub_neg_monoid.{0} linarith.comp)) (has_Inf.{0} name) h0)  := sorry --non-trivial
lemma new_lemma_71074 (h0 : cancel_comm_monoid_with_zero ereal) : unique_factorization_monoid ereal := sorry --non-trivial
lemma new_lemma_71075 (h0 : ring (ring (finset pos))) : strong_rank_condition (ring (finset pos)) := sorry --non-trivial
lemma new_lemma_71076 (h0 : function.extfun Type monoid) : @monoid.fg.{0} (has_emptyc.{0} fun_info) (@function.extfun_app.{2 1} Type monoid.{0} h0 (has_emptyc.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_71077 (h0 : function.extfun Type complete_lattice) : @complete_lattice.is_Sup_finite_compact.{0} (mul_zero_class.{0} name) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (mul_zero_class.{0} name))  := sorry --non-trivial
lemma new_lemma_71078 (h4 : ring (non_unital_non_assoc_semiring string_imp)) : rank_condition (non_unital_non_assoc_semiring string_imp) := sorry --non-trivial
lemma new_lemma_71079 (h0 : topological_space (boolean_algebra (linear_ordered_comm_group pos))) : regular_space (boolean_algebra (linear_ordered_comm_group pos)) := sorry --non-trivial
lemma new_lemma_71080 (h1 : semiring environment.projection_info) (h2 : ideal environment.projection_info) : ideal.is_prime h2 := sorry --non-trivial
lemma new_lemma_71081 (h0 : group (has_neg (has_neg_part (comm_group Type)))) : is_cyclic (has_neg (has_neg_part (comm_group Type))) := sorry --non-trivial
lemma new_lemma_71082 (h0 : topological_space (encodable to_additive.value_type)) : path_connected_space (encodable to_additive.value_type) := sorry --non-trivial
lemma new_lemma_71083 (h3 : add_group environment.projection_info) : is_add_cyclic environment.projection_info := sorry --non-trivial
lemma new_lemma_71084 (h0 : ring (omega_complete_partial_order (option (semiring unsigned)))) : is_domain (omega_complete_partial_order (option (semiring unsigned))) := sorry --non-trivial
lemma new_lemma_71085 (h0 : set (add_comm_semigroup ereal -> add_comm_semigroup char)) : set.separates_points h0 := sorry --non-trivial
lemma new_lemma_71086 (h0 : functor.add_const (topological_space (add_cancel_monoid Type)) name) : @locally_compact_space.{1} (add_cancel_monoid.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (add_cancel_monoid.{1} Type)) name h0)  := sorry --non-trivial
lemma new_lemma_71087 (h0 : complete_lattice (has_compl (add_zero_class fun_info))) : complete_lattice.is_Sup_finite_compact (has_compl (add_zero_class fun_info)) := sorry --non-trivial
lemma new_lemma_71088 (h0 : fin has_zero.zero) : @is_principal_ideal_ring.{0} (sub_neg_monoid.{0} linarith.comp) (@matrix.vec_empty.{0} (ring.{0} (sub_neg_monoid.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_71089 (h0 : topological_space (with_one (random_gen linarith.ineq))) : path_connected_space (with_one (random_gen linarith.ineq)) := sorry --non-trivial
lemma new_lemma_71090 (h0 : topological_space (pseudo_metric_space (option (option congr_arg_kind)))) : totally_separated_space (pseudo_metric_space (option (option congr_arg_kind))) := sorry --non-trivial
lemma new_lemma_71091 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_noetherian_ring.{0} (cancel_monoid.{0} pos) (@function.extfun_app.{2 1} Type semiring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 semiring.{0}) (cancel_monoid.{0} pos))  := sorry --non-trivial
lemma new_lemma_71092 (h0 : ordered_add_comm_monoid (has_neg (has_Inf (has_Inf (has_add pos))))) : archimedean (has_neg (has_Inf (has_Inf (has_add pos)))) := sorry --non-trivial
lemma new_lemma_71093 (h0 : topological_space (add_cancel_monoid num)) : path_connected_space (add_cancel_monoid num) := sorry --non-trivial
lemma new_lemma_71094 (h0 : topological_space (boolean_algebra.core (has_neg name))) : preconnected_space (boolean_algebra.core (has_neg name)) := sorry --non-trivial
lemma new_lemma_71095 (h0 : topological_space (has_nnnorm string.iterator_imp)) : path_connected_space (has_nnnorm string.iterator_imp) := sorry --non-trivial
lemma new_lemma_71096 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_compactly_generated.{0} (complete_semilattice_Sup.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (complete_semilattice_Sup.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_71097 (h2 : ring (mul_one_class ereal)) : rank_condition (mul_one_class ereal) := sorry --non-trivial
lemma new_lemma_71098 (h0 : complete_lattice (has_add (has_neg Type))) : complete_lattice.is_Sup_finite_compact (has_add (has_neg Type)) := sorry --non-trivial
lemma new_lemma_71099 (h0 : group (monoid unsigned)) : normalizer_condition (monoid unsigned) := sorry --non-trivial
lemma new_lemma_71100 (h0 : not (semiring (with_bot empty) -> false)) : @is_noetherian_ring.{0} (with_bot.{0} empty) (@classical.by_contradiction'.{1} (semiring.{0} (with_bot.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_71101 (h0 : function.extfun Type complete_lattice) : @is_compactly_generated.{0} (has_top.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (has_top.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_71102 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @regular_space.{0} (normed_comm_ring.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (normed_comm_ring.{0} pos))  := sorry --non-trivial
lemma new_lemma_71103 (h0 : topological_space (boolean_algebra (has_pos_part linarith.comp))) : preconnected_space (boolean_algebra (has_pos_part linarith.comp)) := sorry --non-trivial
lemma new_lemma_71104 (h0 : functor.add_const (function.extfun Type ring) pos) : @strong_rank_condition.{0} (has_to_string.{0} pos) (@function.extfun_app.{2 1} Type ring.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type ring.{0}) pos h0) (has_to_string.{0} pos))  := sorry --non-trivial
lemma new_lemma_71105 (h0 : functor.add_const (topological_space (has_dist empty)) unsigned) : @totally_disconnected_space.{0} (has_dist.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (has_dist.{0} empty)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_71106 (h0 : ordered_add_comm_monoid (has_pos_part (has_add pos))) : archimedean (has_pos_part (has_add pos)) := sorry --non-trivial
lemma new_lemma_71107 (h0 : ring (semigroup name)) : is_principal_ideal_ring (semigroup name) := sorry --non-trivial
lemma new_lemma_71108 (h0 : ring (sub_neg_monoid real)) : is_principal_ideal_ring (sub_neg_monoid real) := sorry --non-trivial
lemma new_lemma_71109 (h0 : function.extfun Type topological_space) : @loc_path_connected_space.{0} (group_with_zero.{0} ennreal) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (group_with_zero.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_71110 (h0 : complete_lattice (has_top (has_inv linarith.comp_source))) : is_atomistic (has_top (has_inv linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_71111 (h0 : function.extfun Type uniform_space) : @separated_space.{0} (has_Sup.{0} empty) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (has_Sup.{0} empty))  := sorry --non-trivial
lemma new_lemma_71112 (h0 : functor.add_const (function.extfun Type uniform_space) (has_pos_part pos)) : @separated_space.{0} (has_nndist.{0} pos) (@function.extfun_app.{2 1} Type uniform_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type uniform_space.{0}) (has_pos_part.{0} pos) h0) (has_nndist.{0} pos))  := sorry --non-trivial
lemma new_lemma_71113 (h0 : function.extfun Type topological_space) : @t0_space.{0} (comm_semigroup.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (comm_semigroup.{0} pos))  := sorry --non-trivial
lemma new_lemma_71114 (h0 : not (ring (has_ssubset (mul_one_class (mul_one_class (mul_one_class (mul_one_class enat))))) -> false)) : @rank_condition.{0} (has_ssubset.{0} (mul_one_class.{0} (mul_one_class.{0} (mul_one_class.{0} (mul_one_class.{0} enat))))) (@classical.by_contradiction'.{1} (ring.{0} (has_ssubset.{0} (mul_one_class.{0} (mul_one_class.{0} (mul_one_class.{0} (mul_one_class.{0} enat)))))) h0)  := sorry --non-trivial
lemma new_lemma_71115 (h0 : function.extfun Type finset) : finset.nonempty (function.extfun_app h0 (has_dist congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_71116 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @preconnected_space.{0} (has_nndist.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_nndist.{0} name))  := sorry --non-trivial
lemma new_lemma_71117 (h0 : add_monoid (comm_group (option unsigned))) : add_monoid.fg (comm_group (option unsigned)) := sorry --non-trivial
lemma new_lemma_71118 (h0 : functor.add_const (complete_lattice (has_neg pos)) linarith.comp) : @is_atomistic.{0} (has_neg.{0} pos) (@functor.add_const.run.{0 0} (complete_lattice.{0} (has_neg.{0} pos)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_71119 (h0 : function.extfun (finset Type) (has_mem.mem (has_emptyc fun_info))) : @strong_rank_condition.{0} (has_emptyc.{0} fun_info) (@finset.pi.empty.{1 0} Type ring.{0} (has_emptyc.{0} fun_info) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (has_emptyc.{0} fun_info)) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_71120 (h0 : ring (add_comm_monoid (ring (has_neg Type)))) : is_principal_ideal_ring (add_comm_monoid (ring (has_neg Type))) := sorry --non-trivial
lemma new_lemma_71121 (h0 : function.extfun Type list) : palindrome (function.extfun_app h0 (ring linarith.comp)) := sorry --non-trivial
lemma new_lemma_71122 (h0 : uniform_space (has_nndist (has_pos_part linarith.comp))) : complete_space (has_nndist (has_pos_part linarith.comp)) := sorry --non-trivial
lemma new_lemma_71123 (h0 : ring (normed_lattice_add_comm_group (has_Inf name))) : strong_rank_condition (normed_lattice_add_comm_group (has_Inf name)) := sorry --non-trivial
lemma new_lemma_71124 (h0 : functor.add_const (topological_space (has_zero environment.implicit_infer_kind)) name) : @locally_compact_space.{0} (has_zero.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (has_zero.{0} environment.implicit_infer_kind)) name h0)  := sorry --non-trivial
lemma new_lemma_71125 (h0 : functor.add_const (complete_lattice (boolean_algebra unsigned)) environment.implicit_infer_kind) : @is_atomistic.{0} (boolean_algebra.{0} unsigned) (@functor.add_const.run.{0 0} (complete_lattice.{0} (boolean_algebra.{0} unsigned)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_71126 (h0 : topological_space (ordered_comm_monoid (has_add (has_add (has_add Type))))) : regular_space (ordered_comm_monoid (has_add (has_add (has_add Type)))) := sorry --non-trivial
lemma new_lemma_71127 (h0 : topological_space (normed_group (has_norm empty))) : locally_compact_space (normed_group (has_norm empty)) := sorry --non-trivial
lemma new_lemma_71128 (h0 : list (mul_zero_class (has_neg pos))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_71129 (h0 : not (topological_space (has_ssubset linarith.comp_source) -> false)) : @t0_space.{0} (has_ssubset.{0} linarith.comp_source) (@classical.by_contradiction'.{1} (topological_space.{0} (has_ssubset.{0} linarith.comp_source)) h0)  := sorry --non-trivial
lemma new_lemma_71130 (h0 : functor.add_const (complete_lattice (semigroup unsigned)) (option unsigned)) : @is_compactly_generated.{0} (semigroup.{0} unsigned) (@functor.add_const.run.{0 0} (complete_lattice.{0} (semigroup.{0} unsigned)) (option.{0} unsigned) h0)  := sorry --non-trivial
lemma new_lemma_71131 (h0 : fin has_zero.zero) : @complete_space.{0} (canonically_linear_ordered_monoid.{0} linarith.comp) (@matrix.vec_empty.{0} (uniform_space.{0} (canonically_linear_ordered_monoid.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_71132 (h0 : cancel_comm_monoid_with_zero std_gen) (h1 h2 : multiset (gcd_monoid std_gen)) : multiset.subset h1 h2 := sorry --non-trivial
lemma new_lemma_71133 (h0 : fin has_zero.zero) : @locally_compact_space.{1} (has_bot.{1} Type) (@matrix.vec_empty.{1} (topological_space.{1} (has_bot.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_71134 (h0 : has_mem.mem topological_space has_emptyc.emptyc) : @totally_disconnected_space.{0} (@id.{2} Type congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) topological_space.{0} h0) (@id.{2} Type congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_71135 (h0 : uniform_space (has_nndist (has_to_string (boolean_algebra environment.implicit_infer_kind)))) : complete_space (has_nndist (has_to_string (boolean_algebra environment.implicit_infer_kind))) := sorry --non-trivial
lemma new_lemma_71136 (h0 : functor.add_const (ring (has_add Type)) Type) : @is_domain.{1} (has_add.{1} Type) (@functor.add_const.run.{1 1} (ring.{1} (has_add.{1} Type)) Type h0)  := sorry --non-trivial
lemma new_lemma_71137 (h0 : group (has_div reducibility_hints)) : is_cyclic (has_div reducibility_hints) := sorry --non-trivial
lemma new_lemma_71138 (h1 : function.extfun (Type -> Type) (function.extfun Type)) : @complete_lattice.is_Sup_finite_compact.{0} (distrib_lattice.{0} linarith.ineq) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h1 complete_lattice.{0}) (distrib_lattice.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_71139 (h0 : functor.add_const (group (cancel_monoid ennreal)) unsigned) : @is_simple_group.{0} (cancel_monoid.{0} ennreal) (@functor.add_const.run.{0 0} (group.{0} (cancel_monoid.{0} ennreal)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_71140 (h2 : measurable_space (nondiscrete_normed_field string.iterator_imp)) (h3 : linarith.ineq -> measure_theory.measure (nondiscrete_normed_field string.iterator_imp)) : measure_theory.is_finite_measure (measure_theory.measure.sum h3) := sorry --non-trivial
lemma new_lemma_71141 (h0 : group (preorder (semiring unsigned))) : is_cyclic (preorder (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_71142 (h1 : topological_space (denumerable char)) : t0_space (denumerable char) := sorry --non-trivial
lemma new_lemma_71143 (h0 : not (topological_space (distrib to_additive.value_type) -> false)) : @t0_space.{0} (distrib.{0} to_additive.value_type) (@classical.by_contradiction'.{1} (topological_space.{0} (distrib.{0} to_additive.value_type)) h0)  := sorry --non-trivial
lemma new_lemma_71144 (h0 : functor.add_const (functor.add_const (ring Type) pos) Type) : @rank_condition.{1} Type (@functor.add_const.run.{1 0} (ring.{1} Type) pos (@functor.add_const.run.{1 1} (functor.add_const.{1 0} (ring.{1} Type) pos) Type h0))  := sorry --non-trivial
lemma new_lemma_71145 (h0 : functor.add_const (monoid (has_dist empty)) empty) : @monoid.fg.{0} (has_dist.{0} empty) (@functor.add_const.run.{0 0} (monoid.{0} (has_dist.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_71146 (h0 : complete_lattice (has_nnnorm (random_gen (random_gen to_additive.value_type)))) : is_compactly_generated (has_nnnorm (random_gen (random_gen to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_71147 (h0 : fin has_zero.zero) : @is_domain.{1} (simple_graph.{1} Type) (@matrix.vec_empty.{1} (ring.{1} (simple_graph.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_71148 (h0 : topological_space (has_pos_part (finset linarith.comp))) : totally_separated_space (has_pos_part (finset linarith.comp)) := sorry --non-trivial
lemma new_lemma_71149 (h2 : complete_lattice empty) : complete_lattice.is_Sup_finite_compact empty := sorry --non-trivial
lemma new_lemma_71150 (h0 : functor.add_const (ring (ring linarith.comp)) (has_neg Type)) : @is_domain.{0} (ring.{0} linarith.comp) (@functor.add_const.run.{0 1} (ring.{0} (ring.{0} linarith.comp)) (has_neg.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_71151 (h0 : functor.add_const (topological_space (has_neg environment.implicit_infer_kind)) linarith.comp) : @path_connected_space.{0} (has_neg.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (has_neg.{0} environment.implicit_infer_kind)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_71152 (h0 : group (linear_ordered_field (option (option (option (option (option (option ennreal)))))))) : group.fg (linear_ordered_field (option (option (option (option (option (option ennreal))))))) := sorry --non-trivial
lemma new_lemma_71153 (h0 : topological_space (has_zero (boolean_algebra Type))) : locally_compact_space (has_zero (boolean_algebra Type)) := sorry --non-trivial
lemma new_lemma_71154 (h0 : functor.add_const (list (add_cancel_monoid linarith.comp)) (has_neg pos)) : list.nodup (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_71155 (h0 : functor.const Prop char) : functor.const.run h0 := sorry --non-trivial
lemma new_lemma_71156 (h2 : topological_space (has_ssubset (denumerable (denumerable to_additive.value_type)))) : t0_space (has_ssubset (denumerable (denumerable to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_71157 (h0 : complete_lattice (dlist (random_gen linarith.comp_source))) : complete_lattice.is_Sup_finite_compact (dlist (random_gen linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_71158 (h1 : topological_space (topological_space (random_gen char))) : t0_space (topological_space (random_gen char)) := sorry --non-trivial
lemma new_lemma_71159 (h0 : topological_space (normed_field (random_gen reducibility_hints))) : totally_disconnected_space (normed_field (random_gen reducibility_hints)) := sorry --non-trivial
lemma new_lemma_71160 (h0 : functor.add_const (ring (ring pos)) (finset (has_add linarith.comp))) : @is_domain.{0} (ring.{0} pos) (@functor.add_const.run.{0 0} (ring.{0} (ring.{0} pos)) (finset.{0} (has_add.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_71161 (h0 : filter (linear_ordered_add_comm_group string_imp)) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_71162 (h0 : has_lt (has_div to_additive.value_type)) : no_max_order (has_div to_additive.value_type) := sorry --non-trivial
lemma new_lemma_71163 (h0 : functor.add_const (cancel_comm_monoid_with_zero (canonically_ordered_comm_semiring linarith.comp)) linarith.comp) : @unique_factorization_monoid.{0} (canonically_ordered_comm_semiring.{0} linarith.comp) (@functor.add_const.run.{0 0} (cancel_comm_monoid_with_zero.{0} (canonically_ordered_comm_semiring.{0} linarith.comp)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_71164 (h0 : functor.add_const (topological_space (boolean_algebra linarith.comp)) environment.implicit_infer_kind) : @loc_path_connected_space.{0} (boolean_algebra.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (boolean_algebra.{0} linarith.comp)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_71165 (h0 : functor.add_const (function.extfun Type topological_space) name) : @locally_compact_space.{0} (canonically_ordered_comm_semiring.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) name h0) (canonically_ordered_comm_semiring.{0} pos))  := sorry --non-trivial
lemma new_lemma_71166 (h0 : topological_space (ordered_comm_monoid (has_add linarith.comp))) : totally_disconnected_space (ordered_comm_monoid (has_add linarith.comp)) := sorry --non-trivial
lemma new_lemma_71167 (h0 : set (mul_one_class char -> ereal)) : set.separates_points h0 := sorry --non-trivial
lemma new_lemma_71168 (h0 : group (has_pos_part (has_Inf (ring (ring Type))))) : group.fg (has_pos_part (has_Inf (ring (ring Type)))) := sorry --non-trivial
lemma new_lemma_71169 (h0 : function.extfun Type add_monoid) : @add_monoid.fg.{0} (cancel_monoid.{0} name) (@function.extfun_app.{2 1} Type add_monoid.{0} h0 (cancel_monoid.{0} name))  := sorry --non-trivial
lemma new_lemma_71170 (h0 : topological_space (uniform_space (mul_one_class (mul_one_class to_additive.value_type)))) : t0_space (uniform_space (mul_one_class (mul_one_class to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_71171 (h0 : functor.add_const (filter (has_nndist name)) linarith.comp) : countable_Inter_filter (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_71172 (h0 : topological_space (id (has_norm num))) : locally_compact_space (id (has_norm num)) := sorry --non-trivial
lemma new_lemma_71173 (h1 : topological_space (comm_ring char)) : t0_space (comm_ring char) := sorry --non-trivial
lemma new_lemma_71174 (h1 : monoid (normed_group (random_gen (random_gen (random_gen string_imp))))) : monoid.fg (normed_group (random_gen (random_gen (random_gen string_imp)))) := sorry --non-trivial
lemma new_lemma_71175 (h0 : topological_space (filter (option (option unsigned)))) : totally_separated_space (filter (option (option unsigned))) := sorry --non-trivial
lemma new_lemma_71176 (h0 : topological_space (has_inv (has_inv (has_ssubset (has_inv (random_gen linarith.ineq)))))) : totally_disconnected_space (has_inv (has_inv (has_ssubset (has_inv (random_gen linarith.ineq))))) := sorry --non-trivial
lemma new_lemma_71177 (h0 : function.extfun Type ring) : @is_principal_ideal_ring.{0} (has_edist.{0} (option.{0} unsigned)) (@function.extfun_app.{2 1} Type ring.{0} h0 (has_edist.{0} (option.{0} unsigned)))  := sorry --non-trivial
lemma new_lemma_71178 (h0 : filter (has_sub (semiring linarith.comp))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_71179 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @preirreducible_space.{0} (ordered_comm_ring.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (ordered_comm_ring.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_71180 (h0 : add_group (has_compl (denumerable to_additive.value_type))) : is_add_cyclic (has_compl (denumerable to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_71181 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @monoid.fg.{0} (generalized_boolean_algebra.{0} pos) (@function.extfun_app.{2 1} Type monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 monoid.{0}) (generalized_boolean_algebra.{0} pos))  := sorry --non-trivial
lemma new_lemma_71182 (h0 : topological_space (has_top (semiring empty))) : irreducible_space (has_top (semiring empty)) := sorry --non-trivial
lemma new_lemma_71183 (h0 : function.extfun (Type 1) add_group) : @is_add_cyclic.{1} (plift.{1} num) (@function.extfun_app.{3 2} (Type 1) add_group.{1} h0 (plift.{1} num))  := sorry --non-trivial
lemma new_lemma_71184 (h0 : topological_space (monoid_with_zero (option unsigned))) : t0_space (monoid_with_zero (option unsigned)) := sorry --non-trivial
lemma new_lemma_71185 (h0 : group (random_gen (semiring num))) : group.fg (random_gen (semiring num)) := sorry --non-trivial
lemma new_lemma_71186 (h0 : ring (nondiscrete_normed_field (add_comm_semigroup environment.projection_info))) : is_domain (nondiscrete_normed_field (add_comm_semigroup environment.projection_info)) := sorry --non-trivial
lemma new_lemma_71187 (h0 : functor.add_const (topological_space (semigroup pos)) environment.implicit_infer_kind) : @totally_disconnected_space.{0} (semigroup.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (semigroup.{0} pos)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_71188 (h2 : ring (denumerable char)) : rank_condition (denumerable char) := sorry --non-trivial
lemma new_lemma_71189 (h0 : functor.add_const (topological_space (has_pos_part pos)) pos) : @preconnected_space.{0} (has_pos_part.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (has_pos_part.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_71190 (h0 : complete_lattice (normed_group (has_top to_additive.value_type))) : is_compactly_generated (normed_group (has_top to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_71191 (h0 : functor.add_const (uniform_space (cancel_monoid pos)) linarith.comp) : @complete_space.{0} (cancel_monoid.{0} pos) (@functor.add_const.run.{0 0} (uniform_space.{0} (cancel_monoid.{0} pos)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_71192 (h0 : group (has_nndist environment.implicit_infer_kind)) : group.fg (has_nndist environment.implicit_infer_kind) := sorry --non-trivial
lemma new_lemma_71193 (h0 : functor.add_const (ring (linear_order empty)) unsigned) : @is_principal_ideal_ring.{0} (linear_order.{0} empty) (@functor.add_const.run.{0 0} (ring.{0} (linear_order.{0} empty)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_71194 (h0 : function.extfun Type topological_space) : @locally_compact_space.{0} (has_inter.{0} ennreal) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_inter.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_71195 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @path_connected_space.{0} (ordered_comm_ring.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (ordered_comm_ring.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_71196 (h0 : function.extfun nat fin) : @discrete_topology.{0} (boolean_algebra.{0} pos) (@matrix.vec_empty.{0} (topological_space.{0} (boolean_algebra.{0} pos)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_71197 (h0 : function.extfun Type add_group) : @is_add_cyclic.{0} (cancel_monoid.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type add_group.{0} h0 (cancel_monoid.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_71198 (h0 : function.extfun Type topological_space) : @locally_compact_space.{0} (has_top.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_top.{0} empty))  := sorry --non-trivial
lemma new_lemma_71199 (h0 : complete_lattice (has_top (random_gen (semiring (semiring unsigned))))) : complete_lattice.is_Sup_finite_compact (has_top (random_gen (semiring (semiring unsigned)))) := sorry --non-trivial
lemma new_lemma_71200 (h0 : fin has_zero.zero) : @strong_rank_condition.{1} (canonically_ordered_monoid.{1} Type) (@matrix.vec_empty.{1} (ring.{1} (canonically_ordered_monoid.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_71201 (h0 : filter (option pos)) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_71202 (h0 : complete_lattice (dlist string_imp)) : is_compactly_generated (dlist string_imp) := sorry --non-trivial
lemma new_lemma_71203 (h0 : functor.add_const (topological_space (ring unsigned)) Type) : @path_connected_space.{0} (ring.{0} unsigned) (@functor.add_const.run.{0 1} (topological_space.{0} (ring.{0} unsigned)) Type h0)  := sorry --non-trivial
lemma new_lemma_71204 (h0 : fin has_zero.zero) : @discrete_topology.{1} (complete_distrib_lattice.{1} Type) (@matrix.vec_empty.{1} (topological_space.{1} (complete_distrib_lattice.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_71205 (h0 : ring (has_bot (has_bot (comm_semigroup real)))) : rank_condition (has_bot (has_bot (comm_semigroup real))) := sorry --non-trivial
lemma new_lemma_71206 (h0 : function.extfun Type topological_space) : @totally_separated_space.{0} (has_inter.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_inter.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_71207 (h0 : functor.add_const (topological_space (cancel_monoid ennreal)) ennreal) : @preconnected_space.{0} (cancel_monoid.{0} ennreal) (@functor.add_const.run.{0 0} (topological_space.{0} (cancel_monoid.{0} ennreal)) ennreal h0)  := sorry --non-trivial
lemma new_lemma_71208 (h0 : fin has_zero.zero) : @path_connected_space.{0} (sub_neg_monoid.{0} pos) (@matrix.vec_empty.{0} (topological_space.{0} (sub_neg_monoid.{0} pos)) h0)  := sorry --non-trivial
lemma new_lemma_71209 (h0 : function.extfun (Type 1) topological_space) : @t0_space.{1} (ordered_comm_ring.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} h0 (ordered_comm_ring.{1} Type))  := sorry --non-trivial
lemma new_lemma_71210 (h0 : topological_space (distrib_lattice (random_gen fun_info))) : totally_disconnected_space (distrib_lattice (random_gen fun_info)) := sorry --non-trivial
lemma new_lemma_71211 (h0 : filter (add_comm_monoid Type)) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_71212 (h0 : fin has_zero.zero) : @is_compactly_generated.{0} (has_nnnorm.{0} linarith.ineq) (@matrix.vec_empty.{0} (complete_lattice.{0} (has_nnnorm.{0} linarith.ineq)) h0)  := sorry --non-trivial
lemma new_lemma_71213 (h0 : monoid (boolean_algebra (has_add (has_add name)))) : monoid.fg (boolean_algebra (has_add (has_add name))) := sorry --non-trivial
lemma new_lemma_71214 (h1 : function.extfun Type complete_lattice) : @is_atomistic.{0} (has_emptyc.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type complete_lattice.{0} h1 (has_emptyc.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_71215 (h0 : not (function.extfun Type topological_space -> false)) : @preirreducible_space.{0} linarith.comp (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) linarith.comp)  := sorry --non-trivial
lemma new_lemma_71216 (h0 : monoid (measurable_space (id (add_group empty)))) : monoid.fg (measurable_space (id (add_group empty))) := sorry --non-trivial
lemma new_lemma_71217 (h0 h1 : not (multiset (has_compl char) -> false)) : multiset.disjoint (classical.by_contradiction' h0) (classical.by_contradiction' h1) := sorry --non-trivial
lemma new_lemma_71218 (h0 : functor.add_const Prop (has_add (has_add name))) : functor.add_const.run h0 := sorry --non-trivial
lemma new_lemma_71219 (h0 : topological_space (boolean_algebra (has_Inf (has_add (has_Inf Type))))) : loc_path_connected_space (boolean_algebra (has_Inf (has_add (has_Inf Type)))) := sorry --non-trivial
lemma new_lemma_71220 (h0 : complete_lattice (random_gen (has_nnnorm (random_gen linarith.ineq)))) : is_compactly_generated (random_gen (has_nnnorm (random_gen linarith.ineq))) := sorry --non-trivial
lemma new_lemma_71221 (h0 : function.extfun Type topological_space) : @preirreducible_space.{0} (has_nndist.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_nndist.{0} empty))  := sorry --non-trivial
lemma new_lemma_71222 (h0 : complete_lattice (mul_zero_class num)) : is_atomistic (mul_zero_class num) := sorry --non-trivial
lemma new_lemma_71223 (h0 : topological_space (semigroup (has_nndist environment.implicit_infer_kind))) : preconnected_space (semigroup (has_nndist environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_71224 (h0 : not (ring (distrib linarith.comp_source) -> false)) : @is_domain.{0} (distrib.{0} linarith.comp_source) (@classical.by_contradiction'.{1} (ring.{0} (distrib.{0} linarith.comp_source)) h0)  := sorry --non-trivial
lemma new_lemma_71225 (h0 : ring (canonically_ordered_monoid (sub_neg_monoid real))) : is_domain (canonically_ordered_monoid (sub_neg_monoid real)) := sorry --non-trivial
lemma new_lemma_71226 (h0 : functor.add_const (filter (has_neg name)) name) : countable_Inter_filter (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_71227 (h0 : topological_space (comm_semigroup (sub_neg_monoid linarith.comp))) : regular_space (comm_semigroup (sub_neg_monoid linarith.comp)) := sorry --non-trivial
lemma new_lemma_71228 (h0 h1 : multiset (has_div (mul_one_class (mul_one_class linarith.ineq)))) : multiset.disjoint h0 h1 := sorry --non-trivial
lemma new_lemma_71229 (h1 : complete_lattice (add_left_cancel_monoid to_additive.value_type)) : is_compactly_generated (add_left_cancel_monoid to_additive.value_type) := sorry --non-trivial
lemma new_lemma_71230 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @preconnected_space.{0} (linear_ordered_field.{0} ennreal) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (linear_ordered_field.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_71231 (h1 : not (group (metric_space linarith.comp) -> false)) : @is_cyclic.{0} (metric_space.{0} linarith.comp) (@classical.by_contradiction'.{1} (group.{0} (metric_space.{0} linarith.comp)) h1)  := sorry --non-trivial
lemma new_lemma_71232 (h1 : topological_space (nondiscrete_normed_field char)) : topological_space.first_countable_topology (nondiscrete_normed_field char) := sorry --non-trivial
lemma new_lemma_71233 (h0 : functor.add_const (add_group (add_left_cancel_semigroup unsigned)) empty) : @is_add_cyclic.{0} (add_left_cancel_semigroup.{0} unsigned) (@functor.add_const.run.{0 0} (add_group.{0} (add_left_cancel_semigroup.{0} unsigned)) empty h0)  := sorry --non-trivial
lemma new_lemma_71234 (h0 : function.extfun Type add_group) : @is_add_cyclic.{0} (has_Sup.{0} unsigned) (@function.extfun_app.{2 1} Type add_group.{0} h0 (has_Sup.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_71235 (h0 : monoid (boolean_algebra pos)) : monoid.fg (boolean_algebra pos) := sorry --non-trivial
lemma new_lemma_71236 (h0 : functor.add_const (function.extfun Type topological_space) Type) : @preconnected_space.{0} (finset.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type topological_space.{0}) Type h0) (finset.{0} name))  := sorry --non-trivial
lemma new_lemma_71237 (h0 : has_Inf (has_Inf (has_Inf real)) -> has_Inf (has_Inf (has_Inf real)) -> Prop) : well_founded h0 := sorry --non-trivial
lemma new_lemma_71238 (h0 : functor.add_const (function.extfun Type topological_space) linarith.comp) : @preirreducible_space.{0} (has_to_string.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) linarith.comp h0) (has_to_string.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_71239 (h0 : not (has_mem.mem (id congr_arg_kind) has_emptyc.emptyc -> false)) : @locally_compact_space.{0} (@id.{2} Type congr_arg_kind) (@finset.pi.empty.{1 0} Type topological_space.{0} (@id.{2} Type congr_arg_kind) (@classical.by_contradiction'.{0} (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (@id.{2} Type congr_arg_kind) (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))) h0))  := sorry --non-trivial
lemma new_lemma_71240 (h0 : not (cancel_comm_monoid_with_zero (semiring unsigned) -> false)) : @unique_factorization_monoid.{0} (semiring.{0} unsigned) (@classical.by_contradiction'.{1} (cancel_comm_monoid_with_zero.{0} (semiring.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_71241 (h0 : topological_space (with_one (with_bot string_imp))) : irreducible_space (with_one (with_bot string_imp)) := sorry --non-trivial
lemma new_lemma_71242 (h0 : ring (linear_ordered_field (option (option unsigned)))) : is_principal_ideal_ring (linear_ordered_field (option (option unsigned))) := sorry --non-trivial
lemma new_lemma_71243 (h0 : topological_space (has_bot (has_Inf real))) : normal_space (has_bot (has_Inf real)) := sorry --non-trivial
lemma new_lemma_71244 (h0 : ring (metric_space unsigned)) : is_principal_ideal_ring (metric_space unsigned) := sorry --non-trivial
lemma new_lemma_71245 (h0 : function.extfun Type topological_space) : @path_connected_space.{0} (has_dist.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_dist.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_71246 (h0 : uniform_space (measurable_space.dynkin_system (option unsigned))) : separated_space (measurable_space.dynkin_system (option unsigned)) := sorry --non-trivial
lemma new_lemma_71247 (h0 : function.extfun (finset (Type -> Type)) (has_mem.mem add_group)) : @is_add_cyclic.{0} (normed_group.{0} fun_info) (@function.extfun_app.{2 1} Type add_group.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) add_group.{0} (@function.extfun_app.{2 0} (finset.{1} (Type → Type)) (@has_mem.mem.{1 1} (Type → Type) (finset.{1} (Type → Type)) (@finset.has_mem.{1} (Type → Type)) add_group.{0}) h0 (@has_emptyc.emptyc.{1} (finset.{1} (Type → Type)) (@finset.has_emptyc.{1} (Type → Type))))) (normed_group.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_71248 (h0 : complete_lattice (nondiscrete_normed_field (normed_field char))) : complete_lattice.is_Sup_finite_compact (nondiscrete_normed_field (normed_field char)) := sorry --non-trivial
lemma new_lemma_71249 (h0 : cancel_monoid name -> cancel_monoid name -> Prop) : is_symm (cancel_monoid name) h0 := sorry --non-trivial
lemma new_lemma_71250 (h0 : functor.add_const (add_group (has_add unsigned)) Type) : @is_add_cyclic.{0} (has_add.{0} unsigned) (@functor.add_const.run.{0 1} (add_group.{0} (has_add.{0} unsigned)) Type h0)  := sorry --non-trivial
lemma new_lemma_71251 (h0 : topological_space (normed_lattice_add_comm_group (has_neg name))) : topological_space.separable_space (normed_lattice_add_comm_group (has_neg name)) := sorry --non-trivial
lemma new_lemma_71252 (h0 : filter (add_cancel_monoid (comm_group (has_add Type)))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_71253 (h0 : list (add_cancel_monoid (option empty))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_71254 (h0 : not (topological_space (comm_ring linarith.ineq) -> false)) : @locally_compact_space.{0} (comm_ring.{0} linarith.ineq) (@classical.by_contradiction'.{1} (topological_space.{0} (comm_ring.{0} linarith.ineq)) h0)  := sorry --non-trivial
lemma new_lemma_71255 (h0 : uniform_space (add_cancel_monoid (option (option (option num))))) : complete_space (add_cancel_monoid (option (option (option num)))) := sorry --non-trivial
lemma new_lemma_71256 (h0 : set unsigned) : set.infinite h0 := sorry --non-trivial
lemma new_lemma_71257 (h0 : uniform_space (has_ssubset enat)) : complete_space (has_ssubset enat) := sorry --non-trivial
lemma new_lemma_71258 (h0 : complete_lattice (linear_ordered_semiring (has_norm (has_norm (semiring (has_norm congr_arg_kind)))))) : is_atomistic (linear_ordered_semiring (has_norm (has_norm (semiring (has_norm congr_arg_kind))))) := sorry --non-trivial
lemma new_lemma_71259 (h0 : topological_space (metric_space (has_norm linarith.comp))) : t0_space (metric_space (has_norm linarith.comp)) := sorry --non-trivial
lemma new_lemma_71260 (h0 : topological_space (has_neg (option pos))) : topological_space.separable_space (has_neg (option pos)) := sorry --non-trivial
lemma new_lemma_71261 (h0 : function.extfun ((Type -> Type) -> Type 1) (function.extfun (Type -> Type))) : @totally_separated_space.{0} (random_gen.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) (@function.extfun_app.{3 2} ((Type → Type) → Type 1) (function.extfun.{2 2} (Type → Type)) h0 (function.extfun.{2 1} Type)) topological_space.{0}) (random_gen.{0} empty))  := sorry --non-trivial
lemma new_lemma_71262 (h0 : list (mul_zero_class (semiring (semiring unsigned)))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_71263 (h0 : topological_space (cancel_monoid (ring (comm_group (ring Type))))) : sequential_space (cancel_monoid (ring (comm_group (ring Type)))) := sorry --non-trivial
lemma new_lemma_71264 (h0 : topological_space (linear_ordered_comm_monoid_with_zero unsigned)) : discrete_topology (linear_ordered_comm_monoid_with_zero unsigned) := sorry --non-trivial
lemma new_lemma_71265 (h0 : function.extfun Type filter) : countable_Inter_filter (function.extfun_app h0 (preorder num)) := sorry --non-trivial
lemma new_lemma_71266 (h0 : function.extfun Type ring) : @is_principal_ideal_ring.{0} (mul_zero_class.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type ring.{0} h0 (mul_zero_class.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_71267 (h0 : function.extfun Type ring) : @rank_condition.{0} (group_with_zero.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type ring.{0} h0 (group_with_zero.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_71268 (h0 : ring (has_nndist (finset name))) : rank_condition (has_nndist (finset name)) := sorry --non-trivial
lemma new_lemma_71269 (h0 : ring (boolean_algebra.core name)) : rank_condition (boolean_algebra.core name) := sorry --non-trivial
lemma new_lemma_71270 (h0 : functor.add_const (filter (boolean_algebra.core pos)) Type) : countable_Inter_filter (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_71271 (h0 : not (topological_space (with_bot unsigned) -> false)) : @topological_space.separable_space.{0} (with_bot.{0} unsigned) (@classical.by_contradiction'.{1} (topological_space.{0} (with_bot.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_71272 (h0 : ring (semi_normed_comm_ring environment.projection_info)) : rank_condition (semi_normed_comm_ring environment.projection_info) := sorry --non-trivial
lemma new_lemma_71273 (h0 : function.extfun Type finset) : finset.nonempty (function.extfun_app h0 (ring linarith.comp)) := sorry --non-trivial
lemma new_lemma_71274 (h0 : add_monoid (filter unsigned)) : add_monoid.fg (filter unsigned) := sorry --non-trivial
lemma new_lemma_71275 (h0 : topological_space (ring (finset (finset environment.implicit_infer_kind)))) : locally_compact_space (ring (finset (finset environment.implicit_infer_kind))) := sorry --non-trivial
lemma new_lemma_71276 (h0 : topological_space (has_nndist (has_neg (has_neg (has_neg (has_neg name)))))) : preconnected_space (has_nndist (has_neg (has_neg (has_neg (has_neg name))))) := sorry --non-trivial
lemma new_lemma_71277 (h0 : function.extfun (Type 1) (functor.comp topological_space has_to_string)) : @irreducible_space.{1} (has_to_string.{1} Type) (@functor.comp.run.{1 1 1} topological_space.{1} has_to_string.{1} Type (@function.extfun_app.{3 2} (Type 1) (functor.comp.{1 1 1} topological_space.{1} has_to_string.{1}) h0 Type))  := sorry --non-trivial
lemma new_lemma_71278 (h0 : topological_space (uniform_space (has_lt reducibility_hints))) : totally_disconnected_space (uniform_space (has_lt reducibility_hints)) := sorry --non-trivial
lemma new_lemma_71279 (h0 : fin has_zero.zero) : @discrete_topology.{1} (comm_semigroup.{1} Type) (@matrix.vec_empty.{1} (topological_space.{1} (comm_semigroup.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_71280 (h0 : topological_space (canonically_ordered_monoid real)) : preconnected_space (canonically_ordered_monoid real) := sorry --non-trivial
lemma new_lemma_71281 (h0 : group (is_R_or_C congr_arg_kind)) : normalizer_condition (is_R_or_C congr_arg_kind) := sorry --non-trivial
lemma new_lemma_71282 (h0 : complete_lattice (has_bot real)) : is_atomistic (has_bot real) := sorry --non-trivial
lemma new_lemma_71283 (h0 : function.extfun Type topological_space) : @irreducible_space.{0} (has_inter.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_inter.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_71284 (h0 : list (with_one (with_bot (has_inv (has_top fun_info))))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_71285 (h0 : monoid (has_emptyc (has_top fun_info))) : monoid.fg (has_emptyc (has_top fun_info)) := sorry --non-trivial
lemma new_lemma_71286 (h0 : topological_space (ring (finset linarith.comp))) : preirreducible_space (ring (finset linarith.comp)) := sorry --non-trivial
lemma new_lemma_71287 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @discrete_topology.{0} (semigroup.{0} ennreal) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (semigroup.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_71288 (h0 : ring (has_nndist Type)) : is_principal_ideal_ring (has_nndist Type) := sorry --non-trivial
lemma new_lemma_71289 (h0 : topological_space (has_zero (cancel_monoid pos))) : preirreducible_space (has_zero (cancel_monoid pos)) := sorry --non-trivial
lemma new_lemma_71290 (h0 : topological_space (ordered_comm_monoid (ring (ordered_comm_ring Type)))) : loc_path_connected_space (ordered_comm_monoid (ring (ordered_comm_ring Type))) := sorry --non-trivial
lemma new_lemma_71291 (h0 : topological_space (has_add (has_pos_part pos))) : discrete_topology (has_add (has_pos_part pos)) := sorry --non-trivial
lemma new_lemma_71292 (h0 : ring (add_comm_semigroup (add_comm_semigroup ereal))) : strong_rank_condition (add_comm_semigroup (add_comm_semigroup ereal)) := sorry --non-trivial
lemma new_lemma_71293 (h0 : topological_space (has_norm (random_gen (random_gen linarith.ineq)))) : discrete_topology (has_norm (random_gen (random_gen linarith.ineq))) := sorry --non-trivial
lemma new_lemma_71294 (h0 : group (dlist (has_top to_additive.value_type))) : is_cyclic (dlist (has_top to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_71295 (h0 : not (ring (add_cancel_comm_monoid linarith.comp_source) -> false)) : @is_domain.{0} (add_cancel_comm_monoid.{0} linarith.comp_source) (@classical.by_contradiction'.{1} (ring.{0} (add_cancel_comm_monoid.{0} linarith.comp_source)) h0)  := sorry --non-trivial
lemma new_lemma_71296 (h1 : add_group (random_gen (has_nnnorm char))) : is_add_cyclic (random_gen (has_nnnorm char)) := sorry --non-trivial
lemma new_lemma_71297 (h0 : ring (linear_ordered_comm_ring (semiring congr_arg_kind))) : is_domain (linear_ordered_comm_ring (semiring congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_71298 (h0 : list (normed_comm_ring (has_to_string Type))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_71299 (h0 : list (comm_group (boolean_algebra.core name))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_71300 (h0 : uniform_space (add_comm_monoid (measurable_space Type))) : complete_space (add_comm_monoid (measurable_space Type)) := sorry --non-trivial
lemma new_lemma_71301 (h0 : function.extfun Type topological_space) : @t1_space.{0} (has_pos_part.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_pos_part.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_71302 (h0 : functor.add_const (complete_lattice (has_nndist Type)) pos) : @is_atomistic.{1} (has_nndist.{1} Type) (@functor.add_const.run.{1 0} (complete_lattice.{1} (has_nndist.{1} Type)) pos h0)  := sorry --non-trivial
lemma new_lemma_71303 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @monoid.fg.{0} (@id.{2} Type linarith.ineq) (@function.extfun_app.{2 1} Type monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 monoid.{0}) (@id.{2} Type linarith.ineq))  := sorry --non-trivial
lemma new_lemma_71304 (h0 : topological_space (has_Inf (has_add name))) : preconnected_space (has_Inf (has_add name)) := sorry --non-trivial
lemma new_lemma_71305 (h0 : complete_lattice (measurable_space (has_norm linarith.comp))) : is_compactly_generated (measurable_space (has_norm linarith.comp)) := sorry --non-trivial
lemma new_lemma_71306 (h0 : uniform_space (boolean_algebra (boolean_algebra name))) : complete_space (boolean_algebra (boolean_algebra name)) := sorry --non-trivial
lemma new_lemma_71307 (h0 : topological_space (non_assoc_semiring congr_arg_kind)) : path_connected_space (non_assoc_semiring congr_arg_kind) := sorry --non-trivial
lemma new_lemma_71308 (h0 : fin has_zero.zero) : @preconnected_space.{1} (has_pos_part.{1} Type) (@matrix.vec_empty.{1} (topological_space.{1} (has_pos_part.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_71309 (h0 : topological_space (has_Inf (ring pos))) : locally_compact_space (has_Inf (ring pos)) := sorry --non-trivial
lemma new_lemma_71310 (h0 : ring (has_nndist (finset (ring (ring Type))))) : strong_rank_condition (has_nndist (finset (ring (ring Type)))) := sorry --non-trivial
lemma new_lemma_71311 (h0 : functor.add_const (complete_lattice (ring pos)) pos) : @complete_lattice.is_Sup_finite_compact.{0} (ring.{0} pos) (@functor.add_const.run.{0 0} (complete_lattice.{0} (ring.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_71312 (h0 : topological_space (has_neg (semigroup (semigroup (boolean_algebra.core Type))))) : preconnected_space (has_neg (semigroup (semigroup (boolean_algebra.core Type)))) := sorry --non-trivial
lemma new_lemma_71313 (h0 : function.extfun Type (functor.add_const Prop)) : functor.add_const.run (function.extfun_app h0 (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_71314 (h0 : topological_space (has_add (option (option (option unsigned))))) : preirreducible_space (has_add (option (option (option unsigned)))) := sorry --non-trivial
lemma new_lemma_71315 (h0 : not (topological_space (has_norm unsigned) -> false)) : @t0_space.{0} (has_norm.{0} unsigned) (@classical.by_contradiction'.{1} (topological_space.{0} (has_norm.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_71316 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @irreducible_space.{0} (linear_ordered_add_comm_group.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (linear_ordered_add_comm_group.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_71317 (h0 : finset (ordered_comm_monoid (has_Inf (has_Inf (has_Inf (has_Inf (has_add (has_Inf pos)))))))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_71318 (h0 : functor.add_const (topological_space (finset unsigned)) Type) : @totally_disconnected_space.{0} (finset.{0} unsigned) (@functor.add_const.run.{0 1} (topological_space.{0} (finset.{0} unsigned)) Type h0)  := sorry --non-trivial
lemma new_lemma_71319 (h2 : topological_space environment.projection_info) : path_connected_space environment.projection_info := sorry --non-trivial
lemma new_lemma_71320 (h0 : ordered_add_comm_monoid (has_pos_part (ring linarith.comp))) : archimedean (has_pos_part (ring linarith.comp)) := sorry --non-trivial
lemma new_lemma_71321 (h0 : group (normed_lattice_add_comm_group Type)) : is_cyclic (normed_lattice_add_comm_group Type) := sorry --non-trivial
lemma new_lemma_71322 (h0 : not (group (left_cancel_monoid (has_nnnorm (has_nnnorm fun_info))) -> false)) : @is_cyclic.{0} (left_cancel_monoid.{0} (has_nnnorm.{0} (has_nnnorm.{0} fun_info))) (@classical.by_contradiction'.{1} (group.{0} (left_cancel_monoid.{0} (has_nnnorm.{0} (has_nnnorm.{0} fun_info)))) h0)  := sorry --non-trivial
lemma new_lemma_71323 (h0 : function.extfun Type ordered_add_comm_monoid) : @archimedean.{0} (has_zero.{0} name) (@function.extfun_app.{2 1} Type ordered_add_comm_monoid.{0} h0 (has_zero.{0} name))  := sorry --non-trivial
lemma new_lemma_71324 (h0 : functor.add_const (function.extfun Type topological_space) pos) : @t0_space.{0} (semigroup.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) pos h0) (semigroup.{0} pos))  := sorry --non-trivial
lemma new_lemma_71325 (h1 : semiring (mul_one_class string.iterator_imp)) (h2 : ideal (mul_one_class string.iterator_imp)) : ideal.is_prime h2 := sorry --non-trivial
lemma new_lemma_71326 (h0 : functor.add_const (topological_space (finset unsigned)) pos) : @sequential_space.{0} (finset.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (finset.{0} unsigned)) pos h0)  := sorry --non-trivial
lemma new_lemma_71327 (h2 : not (add_group (topological_space (has_nnnorm (has_lt (has_nnnorm (has_nnnorm char))))) -> false)) : @is_add_cyclic.{0} (topological_space.{0} (has_nnnorm.{0} (has_lt.{0} (has_nnnorm.{0} (has_nnnorm.{0} char))))) (@classical.by_contradiction'.{1} (add_group.{0} (topological_space.{0} (has_nnnorm.{0} (has_lt.{0} (has_nnnorm.{0} (has_nnnorm.{0} char)))))) h2)  := sorry --non-trivial
lemma new_lemma_71328 (h0 : functor.add_const (topological_space (normed_comm_ring linarith.comp)) pos) : @preirreducible_space.{0} (normed_comm_ring.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (normed_comm_ring.{0} linarith.comp)) pos h0)  := sorry --non-trivial
lemma new_lemma_71329 (h0 : has_mem.mem (has_emptyc num) has_emptyc.emptyc) : @rank_condition.{0} (has_emptyc.{0} num) (@finset.pi.empty.{1 0} Type ring.{0} (has_emptyc.{0} num) h0)  := sorry --non-trivial
lemma new_lemma_71330 (h0 : filter (add_cancel_monoid (has_add (has_add (has_neg_part unsigned))))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_71331 (h0 : finset (has_nndist (boolean_algebra environment.implicit_infer_kind))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_71332 (h0 : cancel_comm_monoid_with_zero (left_cancel_monoid (option unsigned))) : unique_factorization_monoid (left_cancel_monoid (option unsigned)) := sorry --non-trivial
lemma new_lemma_71333 (h0 : function.extfun (nat -> Type) (function.extfun nat)) : @is_domain.{1} (ordered_comm_monoid.{1} Type) (@matrix.vec_empty.{1} (ring.{1} (ordered_comm_monoid.{1} Type)) (@function.extfun_app.{1 1} nat fin (@function.extfun_app.{2 1} (nat → Type) (function.extfun.{1 1} nat) h0 fin) (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_71334 (h0 : not (cancel_comm_monoid_with_zero (has_union empty) -> false)) : @unique_factorization_monoid.{0} (has_union.{0} empty) (@classical.by_contradiction'.{1} (cancel_comm_monoid_with_zero.{0} (has_union.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_71335 (h0 : function.extfun Type group) : @is_simple_group.{0} (mul_zero_class.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type group.{0} h0 (mul_zero_class.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_71336 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @unique_factorization_monoid.{1} (boolean_algebra.core.{1} Type) (@function.extfun_app.{3 2} (Type 1) cancel_comm_monoid_with_zero.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 cancel_comm_monoid_with_zero.{1}) (boolean_algebra.core.{1} Type))  := sorry --non-trivial
lemma new_lemma_71337 (h0 : not (function.extfun Type topological_space -> false)) : @normal_space.{0} (linear_ordered_semiring.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (linear_ordered_semiring.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_71338 (h0 : functor.comp topological_space normed_comm_ring Type) : @preconnected_space.{1} (normed_comm_ring.{1} Type) (@functor.comp.run.{1 1 1} topological_space.{1} normed_comm_ring.{1} Type h0)  := sorry --non-trivial
lemma new_lemma_71339 (h0 : add_group (has_div (has_ssubset linarith.ineq))) : is_add_cyclic (has_div (has_ssubset linarith.ineq)) := sorry --non-trivial
lemma new_lemma_71340 (h0 : functor.add_const (complete_lattice (left_cancel_monoid congr_arg_kind)) unsigned) : @complete_lattice.is_Sup_finite_compact.{0} (left_cancel_monoid.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (complete_lattice.{0} (left_cancel_monoid.{0} congr_arg_kind)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_71341 (h0 : topological_space (generalized_boolean_algebra (comm_semigroup (has_Inf pos)))) : preirreducible_space (generalized_boolean_algebra (comm_semigroup (has_Inf pos))) := sorry --non-trivial
lemma new_lemma_71342 (h0 : topological_space (has_nndist (semigroup unsigned))) : sequential_space (has_nndist (semigroup unsigned)) := sorry --non-trivial
lemma new_lemma_71343 (h0 : functor.add_const (topological_space (boolean_algebra unsigned)) pos) : @preconnected_space.{0} (boolean_algebra.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (boolean_algebra.{0} unsigned)) pos h0)  := sorry --non-trivial
lemma new_lemma_71344 (h0 : functor.add_const (filter (semigroup Type)) name) : countable_Inter_filter (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_71345 (h1 : complete_lattice (has_append char)) : complete_lattice.is_Sup_finite_compact (has_append char) := sorry --non-trivial
lemma new_lemma_71346 (h0 : function.extfun Type (functor.add_const (uniform_space (simple_graph linarith.comp)))) : @complete_space.{0} (simple_graph.{0} linarith.comp) (@functor.add_const.run.{0 0} (uniform_space.{0} (simple_graph.{0} linarith.comp)) name (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (uniform_space.{0} (simple_graph.{0} linarith.comp))) h0 name))  := sorry --non-trivial
lemma new_lemma_71347 (h0 : function.extfun (finset Type) (has_mem.mem empty)) : @is_add_cyclic.{0} empty (@finset.pi.empty.{1 0} Type add_group.{0} empty (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) empty) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_71348 (h0 : topological_space (measurable_space.dynkin_system (semiring (semiring (semiring unsigned))))) : discrete_topology (measurable_space.dynkin_system (semiring (semiring (semiring unsigned)))) := sorry --non-trivial
lemma new_lemma_71349 (h0 : function.extfun Type topological_space) : @loc_path_connected_space.{0} (linear_ordered_field.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (linear_ordered_field.{0} name))  := sorry --non-trivial
lemma new_lemma_71350 (h0 : topological_space (partial_order (semiring (semiring empty)))) : discrete_topology (partial_order (semiring (semiring empty))) := sorry --non-trivial
lemma new_lemma_71351 (h0 : group (has_Sup empty)) : normalizer_condition (has_Sup empty) := sorry --non-trivial
lemma new_lemma_71352 (h0 : topological_space (with_bot (semiring (semiring (semiring (semiring (semiring unsigned))))))) : discrete_topology (with_bot (semiring (semiring (semiring (semiring (semiring unsigned)))))) := sorry --non-trivial
lemma new_lemma_71353 (h0 : functor.add_const (uniform_space (finset Type)) pos) : @complete_space.{1} (finset.{1} Type) (@functor.add_const.run.{1 0} (uniform_space.{1} (finset.{1} Type)) pos h0)  := sorry --non-trivial
lemma new_lemma_71354 (h0 : fin has_zero.zero) : @is_add_cyclic.{1} (has_bot.{1} Type) (@matrix.vec_empty.{1} (add_group.{1} (has_bot.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_71355 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @complete_space.{0} (normed_comm_ring.{0} linarith.comp) (@function.extfun_app.{2 1} Type uniform_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 uniform_space.{0}) (normed_comm_ring.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_71356 (h0 : ordered_comm_monoid (has_neg (finset (ring (ring Type))))) : has_exists_mul_of_le (has_neg (finset (ring (ring Type)))) := sorry --non-trivial
lemma new_lemma_71357 (h0 : uniform_space (boolean_algebra.core (ring linarith.comp))) : complete_space (boolean_algebra.core (ring linarith.comp)) := sorry --non-trivial
lemma new_lemma_71358 (h0 : topological_space (measurable_space (has_norm num))) : discrete_topology (measurable_space (has_norm num)) := sorry --non-trivial
lemma new_lemma_71359 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @loc_path_connected_space.{0} (canonically_ordered_monoid.{0} real) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (canonically_ordered_monoid.{0} real))  := sorry --non-trivial
lemma new_lemma_71360 (h0 : functor.add_const (list (has_zero Type)) unsigned) : palindrome (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_71361 (h0 : topological_space (random_gen congr_arg_kind)) : discrete_topology (random_gen congr_arg_kind) := sorry --non-trivial
lemma new_lemma_71362 (h0 : group (denumerable (random_gen linarith.ineq))) : is_cyclic (denumerable (random_gen linarith.ineq)) := sorry --non-trivial
lemma new_lemma_71363 (h0 : group (has_pos_part real)) : group.fg (has_pos_part real) := sorry --non-trivial
lemma new_lemma_71364 (h0 : functor.comp ordered_comm_monoid has_to_string linarith.comp) : @has_exists_mul_of_le.{0} (has_to_string.{0} linarith.comp) (@functor.comp.run.{0 0 0} ordered_comm_monoid.{0} has_to_string.{0} linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_71365 (h0 : functor.add_const (ordered_add_comm_monoid (group_with_zero unsigned)) (option (option (option ennreal)))) : @archimedean.{0} (group_with_zero.{0} unsigned) (@functor.add_const.run.{0 0} (ordered_add_comm_monoid.{0} (group_with_zero.{0} unsigned)) (option.{0} (option.{0} (option.{0} ennreal))) h0)  := sorry --non-trivial
lemma new_lemma_71366 (h0 : functor.add_const (topological_space (complete_distrib_lattice unsigned)) congr_arg_kind) : @preirreducible_space.{0} (complete_distrib_lattice.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (complete_distrib_lattice.{0} unsigned)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_71367 (h0 : functor.add_const (list (semigroup linarith.comp)) (semigroup linarith.comp)) : list.nodup (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_71368 (h0 : functor.add_const (ordered_add_comm_monoid (boolean_algebra.core environment.implicit_infer_kind)) linarith.comp) : @archimedean.{0} (boolean_algebra.core.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (ordered_add_comm_monoid.{0} (boolean_algebra.core.{0} environment.implicit_infer_kind)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_71369 (h0 : complete_lattice (has_pos_part (has_Inf Type))) : complete_lattice.is_Sup_finite_compact (has_pos_part (has_Inf Type)) := sorry --non-trivial
lemma new_lemma_71370 (h0 : ring (add_cancel_comm_monoid char)) : rank_condition (add_cancel_comm_monoid char) := sorry --non-trivial
lemma new_lemma_71371 (h0 : ring (has_pos_part (has_neg (has_neg name)))) : strong_rank_condition (has_pos_part (has_neg (has_neg name))) := sorry --non-trivial
lemma new_lemma_71372 (h0 : add_group (canonically_linear_ordered_monoid (has_add (has_add linarith.comp)))) : is_add_cyclic (canonically_linear_ordered_monoid (has_add (has_add linarith.comp))) := sorry --non-trivial
lemma new_lemma_71373 (h0 : functor.add_const (ring (ordered_comm_ring name)) (has_Inf (has_add linarith.comp))) : @rank_condition.{0} (ordered_comm_ring.{0} name) (@functor.add_const.run.{0 0} (ring.{0} (ordered_comm_ring.{0} name)) (has_Inf.{0} (has_add.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_71374 (h0 : topological_space (boolean_algebra.core (has_add (has_add (has_add name))))) : irreducible_space (boolean_algebra.core (has_add (has_add (has_add name)))) := sorry --non-trivial
lemma new_lemma_71375 (h0 : topological_space (add_cancel_monoid environment.implicit_infer_kind)) : totally_separated_space (add_cancel_monoid environment.implicit_infer_kind) := sorry --non-trivial
lemma new_lemma_71376 (h0 : finset (ordered_comm_monoid (ring pos))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_71377 (h1 h2 : multiset (linear_ordered_comm_group_with_zero linarith.ineq)) : multiset.subset h1 h2 := sorry --non-trivial
lemma new_lemma_71378 (h0 : topological_space (ordered_comm_monoid (ring linarith.comp))) : locally_compact_space (ordered_comm_monoid (ring linarith.comp)) := sorry --non-trivial
lemma new_lemma_71379 (h0 : functor.add_const (topological_space (comm_group unsigned)) num) : @topological_space.separable_space.{0} (comm_group.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (comm_group.{0} unsigned)) num h0)  := sorry --non-trivial
lemma new_lemma_71380 (h0 : topological_space (canonically_linear_ordered_monoid (canonically_linear_ordered_monoid name))) : locally_compact_space (canonically_linear_ordered_monoid (canonically_linear_ordered_monoid name)) := sorry --non-trivial
lemma new_lemma_71381 (h0 : functor.add_const (function.extfun Type complete_lattice) environment.implicit_infer_kind) : @complete_lattice.is_Sup_finite_compact.{0} (boolean_algebra.core.{0} ennreal) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type complete_lattice.{0}) environment.implicit_infer_kind h0) (boolean_algebra.core.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_71382 (h0 : topological_space (complete_distrib_lattice (has_add (cancel_monoid pos)))) : t1_space (complete_distrib_lattice (has_add (cancel_monoid pos))) := sorry --non-trivial
lemma new_lemma_71383 (h0 : functor.add_const (monoid (ordered_cancel_add_comm_monoid ennreal)) ennreal) : @monoid.fg.{0} (ordered_cancel_add_comm_monoid.{0} ennreal) (@functor.add_const.run.{0 0} (monoid.{0} (ordered_cancel_add_comm_monoid.{0} ennreal)) ennreal h0)  := sorry --non-trivial
lemma new_lemma_71384 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @complete_space.{0} (has_add.{0} pos) (@function.extfun_app.{2 1} Type uniform_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 uniform_space.{0}) (has_add.{0} pos))  := sorry --non-trivial
lemma new_lemma_71385 (h0 : topological_space (has_add unsigned)) : totally_disconnected_space (has_add unsigned) := sorry --non-trivial
lemma new_lemma_71386 (h1 : add_group (mul_zero_class linarith.comp_source)) : is_add_cyclic (mul_zero_class linarith.comp_source) := sorry --non-trivial
lemma new_lemma_71387 (h1 : uniform_space (uniform_space (uniform_space (mul_one_class reducibility_hints)))) : complete_space (uniform_space (uniform_space (mul_one_class reducibility_hints))) := sorry --non-trivial
lemma new_lemma_71388 (h0 : topological_space (comm_group (has_to_string unsigned))) : totally_separated_space (comm_group (has_to_string unsigned)) := sorry --non-trivial
lemma new_lemma_71389 (h0 : functor.add_const (ring (has_edist empty)) empty) : @is_domain.{0} (has_edist.{0} empty) (@functor.add_const.run.{0 0} (ring.{0} (has_edist.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_71390 (h0 : topological_space (id (has_inv (has_inv linarith.comp_source)))) : locally_compact_space (id (has_inv (has_inv linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_71391 (h0 : functor.add_const (uniform_space (canonically_ordered_comm_semiring name)) name) : @separated_space.{0} (canonically_ordered_comm_semiring.{0} name) (@functor.add_const.run.{0 0} (uniform_space.{0} (canonically_ordered_comm_semiring.{0} name)) name h0)  := sorry --non-trivial
lemma new_lemma_71392 (h0 : topological_space (boolean_algebra (has_pos_part pos))) : path_connected_space (boolean_algebra (has_pos_part pos)) := sorry --non-trivial
lemma new_lemma_71393 (h0 : list (normed_comm_ring (finset (has_add pos)))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_71394 (h0 : functor.add_const (add_monoid (has_add pos)) Type) : @add_monoid.fg.{0} (has_add.{0} pos) (@functor.add_const.run.{0 1} (add_monoid.{0} (has_add.{0} pos)) Type h0)  := sorry --non-trivial
lemma new_lemma_71395 (h0 : finset (canonically_linear_ordered_monoid (has_add (has_add (has_add (has_add pos)))))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_71396 (h0 : functor.add_const (complete_lattice (boolean_algebra Type)) (has_add (has_add (has_neg_part Type)))) : @is_compactly_generated.{1} (boolean_algebra.{1} Type) (@functor.add_const.run.{1 1} (complete_lattice.{1} (boolean_algebra.{1} Type)) (has_add.{1} (has_add.{1} (has_neg_part.{1} Type))) h0)  := sorry --non-trivial
lemma new_lemma_71397 (h0 : functor.add_const (topological_space (sub_neg_monoid pos)) Type) : @irreducible_space.{0} (sub_neg_monoid.{0} pos) (@functor.add_const.run.{0 1} (topological_space.{0} (sub_neg_monoid.{0} pos)) Type h0)  := sorry --non-trivial
lemma new_lemma_71398 (h0 : functor.add_const (topological_space (cancel_monoid name)) name) : @irreducible_space.{0} (cancel_monoid.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (cancel_monoid.{0} name)) name h0)  := sorry --non-trivial
lemma new_lemma_71399 (h0 : topological_space (has_to_string (semigroup environment.implicit_infer_kind))) : locally_compact_space (has_to_string (semigroup environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_71400 (h0 : monoid (has_bot (has_Inf (has_add (has_Inf (has_pos_part (has_Inf linarith.comp))))))) : monoid.fg (has_bot (has_Inf (has_add (has_Inf (has_pos_part (has_Inf linarith.comp)))))) := sorry --non-trivial
lemma new_lemma_71401 (h0 : functor.comp complete_lattice has_to_string Type) : @is_atomistic.{1} (has_to_string.{1} Type) (@functor.comp.run.{1 1 1} complete_lattice.{1} has_to_string.{1} Type h0)  := sorry --non-trivial
lemma new_lemma_71402 (h0 : finset Type) (h1 h2 : Pi (i : Type), complete_lattice i) (h3 : Pi (j : Type), decidable (has_mem.mem j h0)) : complete_lattice.is_Sup_finite_compact (normed_field environment.projection_info) := sorry --non-trivial
lemma new_lemma_71403 (h0 : topological_space (has_to_string (semigroup Type))) : topological_space.separable_space (has_to_string (semigroup Type)) := sorry --non-trivial
lemma new_lemma_71404 (h0 : complete_lattice (boolean_algebra (boolean_algebra.core (has_add name)))) : is_compactly_generated (boolean_algebra (boolean_algebra.core (has_add name))) := sorry --non-trivial
lemma new_lemma_71405 (h0 : ring (cancel_monoid num)) : strong_rank_condition (cancel_monoid num) := sorry --non-trivial
lemma new_lemma_71406 (h0 : ring (canonically_linear_ordered_monoid (ordered_comm_monoid real))) : is_domain (canonically_linear_ordered_monoid (ordered_comm_monoid real)) := sorry --non-trivial
lemma new_lemma_71407 (h0 : functor.add_const (topological_space (mul_zero_class num)) num) : @totally_separated_space.{0} (mul_zero_class.{0} num) (@functor.add_const.run.{0 0} (topological_space.{0} (mul_zero_class.{0} num)) num h0)  := sorry --non-trivial
lemma new_lemma_71408 (h1 : add_group (nondiscrete_normed_field environment.projection_info)) : is_add_cyclic (nondiscrete_normed_field environment.projection_info) := sorry --non-trivial
lemma new_lemma_71409 (h0 : functor.add_const (functor.add_const (topological_space linarith.comp) Type) linarith.comp) : @irreducible_space.{0} linarith.comp (@functor.add_const.run.{0 1} (topological_space.{0} linarith.comp) Type (@functor.add_const.run.{0 0} (functor.add_const.{0 1} (topological_space.{0} linarith.comp) Type) linarith.comp h0))  := sorry --non-trivial
lemma new_lemma_71410 (h0 : functor.add_const (topological_space (linear_order empty)) unsigned) : @locally_compact_space.{0} (linear_order.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (linear_order.{0} empty)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_71411 (h0 : functor.add_const (group znum) unsigned) : @is_simple_group.{0} znum (@functor.add_const.run.{0 0} (group.{0} znum) unsigned h0)  := sorry --non-trivial
lemma new_lemma_71412 (h0 : functor.add_const (topological_space (has_nndist pos)) (boolean_algebra.core Type)) : @sequential_space.{0} (has_nndist.{0} pos) (@functor.add_const.run.{0 1} (topological_space.{0} (has_nndist.{0} pos)) (boolean_algebra.core.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_71413 (h0 : functor.add_const (functor.add_const (list linarith.comp) Type) linarith.comp) : palindrome (functor.add_const.run (functor.add_const.run h0)) := sorry --non-trivial
lemma new_lemma_71414 (h0 : functor.add_const (list (boolean_algebra name)) unsigned) : list.nodup (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_71415 (h0 : functor.add_const (ring (canonically_ordered_comm_semiring linarith.comp)) linarith.comp) : @is_principal_ideal_ring.{0} (canonically_ordered_comm_semiring.{0} linarith.comp) (@functor.add_const.run.{0 0} (ring.{0} (canonically_ordered_comm_semiring.{0} linarith.comp)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_71416 (h0 : topological_space (canonically_linear_ordered_monoid real)) : irreducible_space (canonically_linear_ordered_monoid real) := sorry --non-trivial
lemma new_lemma_71417 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : palindrome (function.extfun_app (function.extfun_app h0 list) (has_add pos)) := sorry --non-trivial
lemma new_lemma_71418 (h0 : topological_space (with_zero (complete_semilattice_Sup string_imp))) : t0_space (with_zero (complete_semilattice_Sup string_imp)) := sorry --non-trivial
lemma new_lemma_71419 (h0 : not (ring real.angle -> false)) : @strong_rank_condition.{0} real.angle (@classical.by_contradiction'.{1} (ring.{0} real.angle) h0)  := sorry --non-trivial
lemma new_lemma_71420 (h0 : filter (id congr_arg_kind)) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_71421 (h0 : functor.add_const (semiring (has_nndist congr_arg_kind)) congr_arg_kind) : @is_noetherian_ring.{0} (has_nndist.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (semiring.{0} (has_nndist.{0} congr_arg_kind)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_71422 (h0 : function.extfun nat fin) : @strong_rank_condition.{0} (ordered_comm_ring.{0} pos) (@function.extfun_app.{2 1} Type ring.{0} (@matrix.vec_empty.{1} (function.extfun.{2 1} Type ring.{0}) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero))) (ordered_comm_ring.{0} pos))  := sorry --non-trivial
lemma new_lemma_71423 (h1 h2 : multiset linarith.comp_source) : multiset.subset h1 h2 := sorry --non-trivial
lemma new_lemma_71424 (h0 : function.extfun (Type 1) ordered_add_comm_monoid) : @archimedean.{1} (simple_graph.{1} Type) (@function.extfun_app.{3 2} (Type 1) ordered_add_comm_monoid.{1} h0 (simple_graph.{1} Type))  := sorry --non-trivial
lemma new_lemma_71425 (h0 : has_one (has_norm unsigned) -> has_one (has_norm unsigned) -> Prop) : is_trans (has_one (has_norm unsigned)) h0 := sorry --non-trivial
lemma new_lemma_71426 (h0 : ring (boolean_algebra (has_to_string Type))) : is_principal_ideal_ring (boolean_algebra (has_to_string Type)) := sorry --non-trivial
lemma new_lemma_71427 (h0 : function.extfun Type add_group) : @is_add_cyclic.{0} (has_norm.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type add_group.{0} h0 (has_norm.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_71428 (h0 : add_group (semi_normed_comm_ring reducibility_hints)) : is_add_cyclic (semi_normed_comm_ring reducibility_hints) := sorry --non-trivial
lemma new_lemma_71429 (h0 : function.extfun Type semiring) : @is_noetherian_ring.{0} (measurable_space.{0} fun_info) (@function.extfun_app.{2 1} Type semiring.{0} h0 (measurable_space.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_71430 (h1 : not (ring (linear_ordered_add_comm_group char) -> false)) : @strong_rank_condition.{0} (linear_ordered_add_comm_group.{0} char) (@classical.by_contradiction'.{1} (ring.{0} (linear_ordered_add_comm_group.{0} char)) h1)  := sorry --non-trivial
lemma new_lemma_71431 (h0 : topological_space (comm_monoid (option num))) (h1 : set (comm_monoid (option num))) : is_open h1 := sorry --non-trivial
lemma new_lemma_71432 (h0 : ring (cancel_monoid (option pos))) : rank_condition (cancel_monoid (option pos)) := sorry --non-trivial
lemma new_lemma_71433 (h0 : uniform_space (sub_neg_monoid pos)) : complete_space (sub_neg_monoid pos) := sorry --non-trivial
lemma new_lemma_71434 (h0 : not (topological_space (normed_group linarith.comp) -> false)) : @t0_space.{0} (normed_group.{0} linarith.comp) (@classical.by_contradiction'.{1} (topological_space.{0} (normed_group.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_71435 (h0 : topological_space (add_comm_monoid (has_neg linarith.comp))) : preconnected_space (add_comm_monoid (has_neg linarith.comp)) := sorry --non-trivial
lemma new_lemma_71436 (h0 : finset (linear_ordered_comm_monoid_with_zero (option (option unsigned)))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_71437 (h0 : functor.add_const (topological_space (option congr_arg_kind)) congr_arg_kind) : @topological_space.separable_space.{0} (option.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (option.{0} congr_arg_kind)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_71438 (h0 : function.extfun Type topological_space) : @totally_disconnected_space.{0} (distrib_lattice.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (distrib_lattice.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_71439 (h0 : filter (linear_ordered_semiring (semiring (semiring (semiring (has_norm empty)))))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_71440 (h0 : uniform_space (has_union (semiring (semiring (semiring empty))))) : complete_space (has_union (semiring (semiring (semiring empty)))) := sorry --non-trivial
lemma new_lemma_71441 (h0 : functor.comp group add_cancel_monoid ennreal) : @is_cyclic.{0} (add_cancel_monoid.{0} ennreal) (@functor.comp.run.{0 0 0} group.{0} add_cancel_monoid.{0} ennreal h0)  := sorry --non-trivial
lemma new_lemma_71442 (h0 : ring (pseudo_metric_space (has_nndist Type))) : is_principal_ideal_ring (pseudo_metric_space (has_nndist Type)) := sorry --non-trivial
lemma new_lemma_71443 (h0 : monoid (normed_comm_ring (has_add environment.implicit_infer_kind))) : monoid.fg (normed_comm_ring (has_add environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_71444 (h0 : functor.add_const (topological_space (has_add ennreal)) ennreal) : @path_connected_space.{0} (has_add.{0} ennreal) (@functor.add_const.run.{0 0} (topological_space.{0} (has_add.{0} ennreal)) ennreal h0)  := sorry --non-trivial
lemma new_lemma_71445 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : countable_Inter_filter (function.extfun_app (function.extfun_app h0 filter) (has_Inf Type)) := sorry --non-trivial
lemma new_lemma_71446 (h0 : functor.add_const (ring (canonically_ordered_monoid linarith.comp)) (has_add pos)) : @is_principal_ideal_ring.{0} (canonically_ordered_monoid.{0} linarith.comp) (@functor.add_const.run.{0 0} (ring.{0} (canonically_ordered_monoid.{0} linarith.comp)) (has_add.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_71447 (h2 : function.extfun Type topological_space) : @t0_space.{0} (has_emptyc.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h2 (has_emptyc.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_71448 (h0 : set (mul_one_class (mul_one_class enat) -> mul_one_class enat)) : set.separates_points h0 := sorry --non-trivial
lemma new_lemma_71449 (h0 : has_lt (mul_one_class (mul_one_class std_gen))) : no_max_order (mul_one_class (mul_one_class std_gen)) := sorry --non-trivial
lemma new_lemma_71450 (h0 : functor.add_const (topological_space (complete_distrib_lattice linarith.comp)) linarith.comp) : @topological_space.separable_space.{0} (complete_distrib_lattice.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (complete_distrib_lattice.{0} linarith.comp)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_71451 (h0 : not (topological_space (complete_linear_order num) -> false)) : @irreducible_space.{0} (complete_linear_order.{0} num) (@classical.by_contradiction'.{1} (topological_space.{0} (complete_linear_order.{0} num)) h0)  := sorry --non-trivial
lemma new_lemma_71452 (h0 : function.extfun Type complete_lattice) : @is_compactly_generated.{0} (ordered_ring.{0} unsigned) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (ordered_ring.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_71453 (h0 : functor.add_const (list (comm_group Type)) Type) : palindrome (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_71454 (h0 : functor.add_const (complete_lattice (has_edist empty)) (option empty)) : @is_atomistic.{0} (has_edist.{0} empty) (@functor.add_const.run.{0 0} (complete_lattice.{0} (has_edist.{0} empty)) (option.{0} empty) h0)  := sorry --non-trivial
lemma new_lemma_71455 (h0 : not (function.extfun Type filter -> false)) : filter.ne_bot (function.extfun_app (classical.by_contradiction' h0) (has_norm linarith.comp)) := sorry --non-trivial
lemma new_lemma_71456 (h0 : functor.add_const (group (preorder empty)) empty) : @normalizer_condition.{0} (preorder.{0} empty) (@functor.add_const.run.{0 0} (group.{0} (preorder.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_71457 (h0 : topological_space (with_one linarith.ineq)) : totally_disconnected_space (with_one linarith.ineq) := sorry --non-trivial
lemma new_lemma_71458 (h0 : functor.add_const (ordered_comm_monoid (add_cancel_monoid pos)) pos) : @has_exists_mul_of_le.{0} (add_cancel_monoid.{0} pos) (@functor.add_const.run.{0 0} (ordered_comm_monoid.{0} (add_cancel_monoid.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_71459 (h0 : uniform_space (has_emptyc (random_gen (add_right_cancel_monoid fun_info)))) : complete_space (has_emptyc (random_gen (add_right_cancel_monoid fun_info))) := sorry --non-trivial
lemma new_lemma_71460 (h0 : add_monoid (ordered_comm_monoid (has_nndist linarith.comp))) : add_monoid.fg (ordered_comm_monoid (has_nndist linarith.comp)) := sorry --non-trivial
lemma new_lemma_71461 (h1 : topological_space (uniform_space string.iterator_imp)) : totally_disconnected_space (uniform_space string.iterator_imp) := sorry --non-trivial
lemma new_lemma_71462 (h0 : function.extfun Type (functor.add_const (cancel_comm_monoid_with_zero (has_Sup empty)))) : @unique_factorization_monoid.{0} (has_Sup.{0} empty) (@functor.add_const.run.{0 0} (cancel_comm_monoid_with_zero.{0} (has_Sup.{0} empty)) unsigned (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (cancel_comm_monoid_with_zero.{0} (has_Sup.{0} empty))) h0 unsigned))  := sorry --non-trivial
lemma new_lemma_71463 (h0 : functor.add_const (topological_space (linear_ordered_field empty)) unsigned) : @normal_space.{0} (linear_ordered_field.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (linear_ordered_field.{0} empty)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_71464 (h0 : filter (ordered_cancel_add_comm_monoid (option num))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_71465 (h0 : function.extfun Type (functor.add_const (function.extfun Type cancel_comm_monoid_with_zero))) : @unique_factorization_monoid.{0} (boolean_algebra.core.{0} pos) (@function.extfun_app.{2 1} Type cancel_comm_monoid_with_zero.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type cancel_comm_monoid_with_zero.{0}) pos (@function.extfun_app.{2 2} Type (functor.add_const.{1 0} (function.extfun.{2 1} Type cancel_comm_monoid_with_zero.{0})) h0 pos)) (boolean_algebra.core.{0} pos))  := sorry --non-trivial
lemma new_lemma_71466 (h0 : functor.add_const (topological_space (ordered_comm_monoid pos)) real) : @t1_space.{0} (ordered_comm_monoid.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (ordered_comm_monoid.{0} pos)) real h0)  := sorry --non-trivial
lemma new_lemma_71467 (h0 : functor.add_const (topological_space (linear_ordered_add_comm_group_with_top name)) pos) : @totally_separated_space.{0} (linear_ordered_add_comm_group_with_top.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (linear_ordered_add_comm_group_with_top.{0} name)) pos h0)  := sorry --non-trivial
lemma new_lemma_71468 (h0 : topological_space (add_comm_monoid (ordered_comm_monoid (has_Inf pos)))) : preirreducible_space (add_comm_monoid (ordered_comm_monoid (has_Inf pos))) := sorry --non-trivial
lemma new_lemma_71469 (h0 : not (group (has_star num) -> false)) : @normalizer_condition.{0} (has_star.{0} num) (@classical.by_contradiction'.{1} (group.{0} (has_star.{0} num)) h0)  := sorry --non-trivial
lemma new_lemma_71470 (h0 : not (complete_lattice (normed_field string_imp) -> false)) : @is_compactly_generated.{0} (normed_field.{0} string_imp) (@classical.by_contradiction'.{1} (complete_lattice.{0} (normed_field.{0} string_imp)) h0)  := sorry --non-trivial
lemma new_lemma_71471 (h0 : topological_space (mul_zero_class (semiring (semiring num)))) : t1_space (mul_zero_class (semiring (semiring num))) := sorry --non-trivial
lemma new_lemma_71472 (h0 : add_group (has_append (has_nnnorm fun_info))) : is_add_cyclic (has_append (has_nnnorm fun_info)) := sorry --non-trivial
lemma new_lemma_71473 (h0 : ring (linear_ordered_add_comm_group (random_gen string_imp))) : is_domain (linear_ordered_add_comm_group (random_gen string_imp)) := sorry --non-trivial
lemma new_lemma_71474 (h0 : ring (has_ssubset (random_gen string_imp))) : strong_rank_condition (has_ssubset (random_gen string_imp)) := sorry --non-trivial
lemma new_lemma_71475 (h0 : complete_lattice (has_zero (semigroup linarith.comp))) : complete_lattice.is_Sup_finite_compact (has_zero (semigroup linarith.comp)) := sorry --non-trivial
lemma new_lemma_71476 (h0 : function.extfun Type ring) : @strong_rank_condition.{0} fun_info (@function.extfun_app.{2 1} Type ring.{0} h0 fun_info)  := sorry --non-trivial
lemma new_lemma_71477 (h0 : topological_space (has_neg ennreal)) : preconnected_space (has_neg ennreal) := sorry --non-trivial
lemma new_lemma_71478 (h0 : ordered_comm_monoid (has_add Type)) : has_exists_mul_of_le (has_add Type) := sorry --non-trivial
lemma new_lemma_71479 (h0 : cancel_comm_monoid_with_zero (ordered_comm_monoid (ordered_comm_monoid Type))) : unique_factorization_monoid (ordered_comm_monoid (ordered_comm_monoid Type)) := sorry --non-trivial
lemma new_lemma_71480 (h0 : ring (add_left_cancel_monoid (has_nnnorm linarith.ineq))) : is_domain (add_left_cancel_monoid (has_nnnorm linarith.ineq)) := sorry --non-trivial
lemma new_lemma_71481 (h0 : function.extfun (finset Type) (has_mem.mem (measurable_space congr_arg_kind))) : @complete_space.{0} (measurable_space.{0} congr_arg_kind) (@finset.pi.empty.{1 0} Type uniform_space.{0} (measurable_space.{0} congr_arg_kind) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (measurable_space.{0} congr_arg_kind)) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_71482 (h0 : functor.add_const (topological_space (has_nndist linarith.comp)) name) : @path_connected_space.{0} (has_nndist.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (has_nndist.{0} linarith.comp)) name h0)  := sorry --non-trivial
lemma new_lemma_71483 (h0 : functor.add_const (uniform_space (semigroup pos)) (mul_zero_class pos)) : @complete_space.{0} (semigroup.{0} pos) (@functor.add_const.run.{0 0} (uniform_space.{0} (semigroup.{0} pos)) (mul_zero_class.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_71484 (h0 : not (function.extfun (Type -> Type) (function.extfun Type) -> false)) : @is_noetherian_ring.{0} (complete_semilattice_Sup.{0} num) (@function.extfun_app.{2 1} Type semiring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) (@classical.by_contradiction'.{2} (function.extfun.{2 2} (Type → Type) (function.extfun.{2 1} Type)) h0) semiring.{0}) (complete_semilattice_Sup.{0} num))  := sorry --non-trivial
lemma new_lemma_71485 (h0 : ring (normed_field (mul_one_class reducibility_hints))) : is_domain (normed_field (mul_one_class reducibility_hints)) := sorry --non-trivial
lemma new_lemma_71486 (h0 : topological_space linarith.comp) : preconnected_space linarith.comp := sorry --non-trivial
lemma new_lemma_71487 (h1 : not (topological_space (random_gen string_imp) -> false)) : @totally_disconnected_space.{0} (random_gen.{0} string_imp) (@classical.by_contradiction'.{1} (topological_space.{0} (random_gen.{0} string_imp)) h1)  := sorry --non-trivial
lemma new_lemma_71488 (h0 : ring (has_ssubset to_additive.value_type)) : rank_condition (has_ssubset to_additive.value_type) := sorry --non-trivial
lemma new_lemma_71489 (h0 : cancel_comm_monoid_with_zero (generalized_boolean_algebra (has_neg real))) : unique_factorization_monoid (generalized_boolean_algebra (has_neg real)) := sorry --non-trivial
lemma new_lemma_71490 (h0 : function.extfun Type ring) : @rank_condition.{0} (has_emptyc.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type ring.{0} h0 (has_emptyc.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_71491 (h1 : topological_space (semi_normed_comm_ring (has_ssubset char))) : path_connected_space (semi_normed_comm_ring (has_ssubset char)) := sorry --non-trivial
lemma new_lemma_71492 (h0 : topological_space (normed_linear_ordered_group empty)) : discrete_topology (normed_linear_ordered_group empty) := sorry --non-trivial
lemma new_lemma_71493 (h0 : has_mem.mem complete_lattice has_emptyc.emptyc) : @complete_lattice.is_Sup_finite_compact.{0} (normed_group.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) complete_lattice.{0} h0) (normed_group.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_71494 (h0 : measurable_space (has_div environment.projection_info)) (h1 : filter (has_div environment.projection_info)) : filter.is_measurably_generated h1 := sorry --non-trivial
lemma new_lemma_71495 (h0 : function.extfun Type uniform_space) : @complete_space.{0} (normed_lattice_add_comm_group.{0} linarith.comp) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (normed_lattice_add_comm_group.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_71496 (h0 : topological_space (linear_ordered_cancel_comm_monoid (semiring (semiring empty)))) : t0_space (linear_ordered_cancel_comm_monoid (semiring (semiring empty))) := sorry --non-trivial
lemma new_lemma_71497 (h0 : functor.add_const (complete_lattice empty) unsigned) : @is_compactly_generated.{0} empty (@functor.add_const.run.{0 0} (complete_lattice.{0} empty) unsigned h0)  := sorry --non-trivial
lemma new_lemma_71498 (h0 : complete_lattice (has_norm (has_top (random_gen (has_top unsigned))))) : is_atomistic (has_norm (has_top (random_gen (has_top unsigned)))) := sorry --non-trivial
lemma new_lemma_71499 (h0 : function.extfun Type complete_lattice) : @is_compactly_generated.{0} (boolean_algebra.{0} pos) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (boolean_algebra.{0} pos))  := sorry --non-trivial
lemma new_lemma_71500 (h0 : topological_space (has_compl (mul_one_class (mul_one_class linarith.comp_source)))) : t0_space (has_compl (mul_one_class (mul_one_class linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_71501 (h0 : topological_space (has_add (has_add pos))) : locally_compact_space (has_add (has_add pos)) := sorry --non-trivial
lemma new_lemma_71502 (h0 : set (has_le char)) : set.finite h0 := sorry --non-trivial
lemma new_lemma_71503 (h0 : complete_lattice (ordered_comm_ring (has_Inf (sub_neg_monoid linarith.comp)))) : is_compactly_generated (ordered_comm_ring (has_Inf (sub_neg_monoid linarith.comp))) := sorry --non-trivial
lemma new_lemma_71504 (h0 : functor.add_const (topological_space (boolean_algebra Type)) Type) : @path_connected_space.{1} (boolean_algebra.{1} Type) (@functor.add_const.run.{1 1} (topological_space.{1} (boolean_algebra.{1} Type)) Type h0)  := sorry --non-trivial
lemma new_lemma_71505 (h0 : topological_space (add_group (has_union linarith.comp))) : discrete_topology (add_group (has_union linarith.comp)) := sorry --non-trivial
lemma new_lemma_71506 (h0 : topological_space (comm_group (finset (finset linarith.comp)))) : t1_space (comm_group (finset (finset linarith.comp))) := sorry --non-trivial
lemma new_lemma_71507 (h0 : topological_space (has_le (mul_one_class (mul_one_class (mul_one_class char))))) : path_connected_space (has_le (mul_one_class (mul_one_class (mul_one_class char)))) := sorry --non-trivial
lemma new_lemma_71508 (h0 : functor.add_const (ordered_comm_monoid (has_nndist pos)) Type) : @has_exists_mul_of_le.{0} (has_nndist.{0} pos) (@functor.add_const.run.{0 1} (ordered_comm_monoid.{0} (has_nndist.{0} pos)) Type h0)  := sorry --non-trivial
lemma new_lemma_71509 (h0 : finset (has_top (semiring (semiring num)))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_71510 (h0 : group (pseudo_metric_space unsigned)) : is_simple_group (pseudo_metric_space unsigned) := sorry --non-trivial
lemma new_lemma_71511 (h1 : ordered_semiring (mul_one_class char)) (h2 : ordered_add_comm_monoid char) (h3 : smul_with_zero (mul_one_class char) char) : ordered_smul (mul_one_class char) char := sorry --non-trivial
lemma new_lemma_71512 (h0 : group (denumerable to_additive.value_type)) : group.fg (denumerable to_additive.value_type) := sorry --non-trivial
lemma new_lemma_71513 (h0 : complete_lattice (has_top (with_bot num))) : is_compactly_generated (has_top (with_bot num)) := sorry --non-trivial
lemma new_lemma_71514 (h0 : functor.add_const (complete_lattice (finset Type)) name) : @is_atomistic.{1} (finset.{1} Type) (@functor.add_const.run.{1 0} (complete_lattice.{1} (finset.{1} Type)) name h0)  := sorry --non-trivial
lemma new_lemma_71515 (h0 : add_monoid (ring name)) : add_monoid.fg (ring name) := sorry --non-trivial
lemma new_lemma_71516 (h0 : function.extfun (nat -> Type) (function.extfun nat)) : @normal_space.{0} (has_pos_part.{0} pos) (@matrix.vec_empty.{0} (topological_space.{0} (has_pos_part.{0} pos)) (@function.extfun_app.{1 1} nat fin (@function.extfun_app.{2 1} (nat → Type) (function.extfun.{1 1} nat) h0 fin) (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_71517 (h0 : functor.comp topological_space has_to_string linarith.comp) : @t1_space.{0} (has_to_string.{0} linarith.comp) (@functor.comp.run.{0 0 0} topological_space.{0} has_to_string.{0} linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_71518 (h0 : functor.add_const (function.extfun (Type 1) complete_lattice) pos) : @is_compactly_generated.{1} (semigroup.{1} Type) (@function.extfun_app.{3 2} (Type 1) complete_lattice.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) complete_lattice.{1}) pos h0) (semigroup.{1} Type))  := sorry --non-trivial
lemma new_lemma_71519 (h0 : complete_lattice (non_unital_non_assoc_semiring linarith.comp_source)) : is_compactly_generated (non_unital_non_assoc_semiring linarith.comp_source) := sorry --non-trivial
lemma new_lemma_71520 (h0 : functor.add_const (topological_space (option empty)) empty) : @t1_space.{0} (option.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (option.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_71521 (h0 : finset (has_pos_part (has_add (finset (has_add linarith.comp))))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_71522 (h0 : function.extfun Type (functor.add_const Prop)) : functor.add_const.run (function.extfun_app h0 congr_arg_kind) := sorry --non-trivial
lemma new_lemma_71523 (h0 : not (function.extfun Type group -> false)) : @group.fg.{0} (complete_semilattice_Sup.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type group.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type group.{0}) h0) (complete_semilattice_Sup.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_71524 (h0 : function.extfun Type (functor.add_const (topological_space (canonically_ordered_monoid name)))) : @irreducible_space.{0} (canonically_ordered_monoid.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (canonically_ordered_monoid.{0} name)) linarith.comp (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (topological_space.{0} (canonically_ordered_monoid.{0} name))) h0 linarith.comp))  := sorry --non-trivial
lemma new_lemma_71525 (h0 : group (has_nndist (has_add unsigned))) : normalizer_condition (has_nndist (has_add unsigned)) := sorry --non-trivial
lemma new_lemma_71526 (h0 : function.extfun Type list) : list.nodup (function.extfun_app h0 (has_Sup empty)) := sorry --non-trivial
lemma new_lemma_71527 (h0 : complete_lattice (measurable_space.dynkin_system (add_group linarith.comp))) : is_atomistic (measurable_space.dynkin_system (add_group linarith.comp)) := sorry --non-trivial
lemma new_lemma_71528 (h0 : function.extfun (Type 1) (functor.add_const (group pos))) : @group.fg.{0} pos (@functor.add_const.run.{0 1} (group.{0} pos) Type (@function.extfun_app.{3 1} (Type 1) (functor.add_const.{0 1} (group.{0} pos)) h0 Type))  := sorry --non-trivial
lemma new_lemma_71529 (h0 : ring (has_star (semiring (semiring (semiring (semiring (semiring num))))))) : strong_rank_condition (has_star (semiring (semiring (semiring (semiring (semiring num)))))) := sorry --non-trivial
lemma new_lemma_71530 (h0 : functor.add_const (function.extfun Type finset) pos) : finset.nonempty (function.extfun_app (functor.add_const.run h0) (ring linarith.comp)) := sorry --non-trivial
lemma new_lemma_71531 (h0 : uniform_space (has_top (random_gen num))) : complete_space (has_top (random_gen num)) := sorry --non-trivial
lemma new_lemma_71532 (h0 : ring (random_gen congr_arg_kind)) : rank_condition (random_gen congr_arg_kind) := sorry --non-trivial
lemma new_lemma_71533 (h0 : function.extfun Type ring) : @is_domain.{0} (canonically_ordered_monoid.{0} (finset.{0} (has_Inf.{0} linarith.comp))) (@function.extfun_app.{2 1} Type ring.{0} h0 (canonically_ordered_monoid.{0} (finset.{0} (has_Inf.{0} linarith.comp))))  := sorry --non-trivial
lemma new_lemma_71534 (h0 : function.extfun (Type 1) topological_space) : @loc_path_connected_space.{1} (add_cancel_monoid.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} h0 (add_cancel_monoid.{1} Type))  := sorry --non-trivial
lemma new_lemma_71535 (h0 : finset (has_add congr_arg_kind)) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_71536 (h0 : function.extfun Type list) : list.nodup (function.extfun_app h0 linarith.comp) := sorry --non-trivial
lemma new_lemma_71537 (h0 : complete_lattice (metric_space (has_top (has_top empty)))) : complete_lattice.is_Sup_finite_compact (metric_space (has_top (has_top empty))) := sorry --non-trivial
lemma new_lemma_71538 (h0 : group (add_cancel_comm_monoid (semi_normed_ring (random_gen (random_gen char))))) : is_cyclic (add_cancel_comm_monoid (semi_normed_ring (random_gen (random_gen char)))) := sorry --non-trivial
lemma new_lemma_71539 (h0 : ring (left_cancel_semigroup unsigned)) : rank_condition (left_cancel_semigroup unsigned) := sorry --non-trivial
lemma new_lemma_71540 (h0 : function.extfun Type complete_lattice) : @is_atomistic.{0} (simple_graph.{0} num) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (simple_graph.{0} num))  := sorry --non-trivial
lemma new_lemma_71541 (h0 : filter (linear_ordered_comm_group unsigned)) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_71542 (h0 : ring (distrib linarith.ineq)) : strong_rank_condition (distrib linarith.ineq) := sorry --non-trivial
lemma new_lemma_71543 (h0 : topological_space (ordered_comm_monoid (has_Inf (has_Inf Type)))) : discrete_topology (ordered_comm_monoid (has_Inf (has_Inf Type))) := sorry --non-trivial
lemma new_lemma_71544 (h0 : function.extfun Type list) : list.nodup (function.extfun_app h0 (boolean_algebra unsigned)) := sorry --non-trivial
lemma new_lemma_71545 (h0 : fin has_zero.zero) : archimedean real := sorry --non-trivial
lemma new_lemma_71546 (h0 : cancel_comm_monoid_with_zero (semigroup Type)) : unique_factorization_monoid (semigroup Type) := sorry --non-trivial
lemma new_lemma_71547 (h0 : filter (boolean_algebra (has_add linarith.comp))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_71548 (h1 : add_group (with_one (with_bot linarith.comp_source))) : is_add_cyclic (with_one (with_bot linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_71549 (h0 : not (complete_lattice (dlist linarith.comp_source) -> false)) : @complete_lattice.is_Sup_finite_compact.{0} (dlist.{0} linarith.comp_source) (@classical.by_contradiction'.{1} (complete_lattice.{0} (dlist.{0} linarith.comp_source)) h0)  := sorry --non-trivial
lemma new_lemma_71550 (h1 : complete_lattice (distrib_lattice (random_gen (random_gen char)))) : is_compactly_generated (distrib_lattice (random_gen (random_gen char))) := sorry --non-trivial
lemma new_lemma_71551 (h0 : group (normed_lattice_add_comm_group linarith.comp)) : group.fg (normed_lattice_add_comm_group linarith.comp) := sorry --non-trivial
lemma new_lemma_71552 (h0 : ring (plift (option (option (option (option empty)))))) : is_domain (plift (option (option (option (option empty))))) := sorry --non-trivial
lemma new_lemma_71553 (h0 : functor.add_const (uniform_space (has_zero name)) name) : @separated_space.{0} (has_zero.{0} name) (@functor.add_const.run.{0 0} (uniform_space.{0} (has_zero.{0} name)) name h0)  := sorry --non-trivial
lemma new_lemma_71554 (h0 : topological_space (has_nnnorm (has_ssubset (dlist (random_gen (has_top linarith.ineq)))))) : locally_compact_space (has_nnnorm (has_ssubset (dlist (random_gen (has_top linarith.ineq))))) := sorry --non-trivial
lemma new_lemma_71555 (h0 : topological_space (comm_group ennreal)) : totally_disconnected_space (comm_group ennreal) := sorry --non-trivial
lemma new_lemma_71556 (h0 : topological_space (has_zero (mul_zero_class (mul_zero_class name)))) : sequential_space (has_zero (mul_zero_class (mul_zero_class name))) := sorry --non-trivial
lemma new_lemma_71557 (h0 : functor.add_const (group (has_add unsigned)) Type) : @is_simple_group.{0} (has_add.{0} unsigned) (@functor.add_const.run.{0 1} (group.{0} (has_add.{0} unsigned)) Type h0)  := sorry --non-trivial
lemma new_lemma_71558 (h0 : function.extfun (Type 1) complete_lattice) : @complete_lattice.is_Sup_finite_compact.{1} (has_Inf.{1} Type) (@function.extfun_app.{3 2} (Type 1) complete_lattice.{1} h0 (has_Inf.{1} Type))  := sorry --non-trivial
lemma new_lemma_71559 (h0 : filter (has_union num)) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_71560 (h0 : function.extfun Type complete_lattice) : @is_compactly_generated.{0} (ring.{0} empty) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (ring.{0} empty))  := sorry --non-trivial
lemma new_lemma_71561 (h0 : functor.add_const (function.extfun Type topological_space) environment.implicit_infer_kind) : @sequential_space.{0} (semigroup.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) environment.implicit_infer_kind h0) (semigroup.{0} pos))  := sorry --non-trivial
lemma new_lemma_71562 (h2 : topological_space (has_le linarith.ineq)) : t0_space (has_le linarith.ineq) := sorry --non-trivial
lemma new_lemma_71563 (h0 : topological_space (omega_complete_partial_order unsigned)) : totally_separated_space (omega_complete_partial_order unsigned) := sorry --non-trivial
lemma new_lemma_71564 (h0 : topological_space (has_Inf (has_Inf name))) : preconnected_space (has_Inf (has_Inf name)) := sorry --non-trivial
lemma new_lemma_71565 (h0 : group (has_top (has_norm num))) : group.fg (has_top (has_norm num)) := sorry --non-trivial
lemma new_lemma_71566 (h1 : uniform_space (random_gen (comm_ring char))) : complete_space (random_gen (comm_ring char)) := sorry --non-trivial
lemma new_lemma_71567 (h1 : has_lt (preorder ereal)) : no_max_order (preorder ereal) := sorry --non-trivial
lemma new_lemma_71568 (h0 : complete_lattice (canonically_ordered_comm_semiring (boolean_algebra.core name))) : is_atomistic (canonically_ordered_comm_semiring (boolean_algebra.core name)) := sorry --non-trivial
lemma new_lemma_71569 (h0 : functor.add_const (filter (has_nndist environment.implicit_infer_kind)) pos) : filter.ne_bot (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_71570 (h0 : not (ring (has_ssubset linarith.ineq) -> false)) : @rank_condition.{0} (has_ssubset.{0} linarith.ineq) (@classical.by_contradiction'.{1} (ring.{0} (has_ssubset.{0} linarith.ineq)) h0)  := sorry --non-trivial
lemma new_lemma_71571 (h0 : functor.add_const (add_monoid (has_Inf name)) pos) : @add_monoid.fg.{0} (has_Inf.{0} name) (@functor.add_const.run.{0 0} (add_monoid.{0} (has_Inf.{0} name)) pos h0)  := sorry --non-trivial
lemma new_lemma_71572 (h0 : complete_lattice (has_add linarith.comp_source)) : is_compactly_generated (has_add linarith.comp_source) := sorry --non-trivial
lemma new_lemma_71573 (h0 : function.extfun Type ordered_add_comm_monoid) : @archimedean.{0} (normed_lattice_add_comm_group.{0} unsigned) (@function.extfun_app.{2 1} Type ordered_add_comm_monoid.{0} h0 (normed_lattice_add_comm_group.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_71574 (h0 : uniform_space (has_nndist (finset name))) : complete_space (has_nndist (finset name)) := sorry --non-trivial
lemma new_lemma_71575 (h1 : complete_lattice (with_zero to_additive.value_type)) : is_compactly_generated (with_zero to_additive.value_type) := sorry --non-trivial
lemma new_lemma_71576 (h0 : topological_space (with_bot (has_norm (semiring unsigned)))) : path_connected_space (with_bot (has_norm (semiring unsigned))) := sorry --non-trivial
lemma new_lemma_71577 (h0 : not (add_group (has_norm to_additive.value_type) -> false)) : @is_add_cyclic.{0} (has_norm.{0} to_additive.value_type) (@classical.by_contradiction'.{1} (add_group.{0} (has_norm.{0} to_additive.value_type)) h0)  := sorry --non-trivial
lemma new_lemma_71578 (h0 : topological_space (has_bot (ordered_comm_monoid name))) : t1_space (has_bot (ordered_comm_monoid name)) := sorry --non-trivial
lemma new_lemma_71579 (h0 : not (topological_space (measurable_space.dynkin_system num) -> false)) : @totally_disconnected_space.{0} (measurable_space.dynkin_system.{0} num) (@classical.by_contradiction'.{1} (topological_space.{0} (measurable_space.dynkin_system.{0} num)) h0)  := sorry --non-trivial
lemma new_lemma_71580 (h0 : topological_space (ring (has_neg Type))) : loc_path_connected_space (ring (has_neg Type)) := sorry --non-trivial
lemma new_lemma_71581 (h0 : topological_space (linear_ordered_comm_group_with_zero reducibility_hints)) : path_connected_space (linear_ordered_comm_group_with_zero reducibility_hints) := sorry --non-trivial
lemma new_lemma_71582 (h0 : monoid (semiring (has_norm linarith.ineq))) : monoid.fg (semiring (has_norm linarith.ineq)) := sorry --non-trivial
lemma new_lemma_71583 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @normal_space.{0} (finset.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (finset.{0} empty))  := sorry --non-trivial
lemma new_lemma_71584 (h0 : topological_space (add_comm_monoid (comm_group unsigned))) : sequential_space (add_comm_monoid (comm_group unsigned)) := sorry --non-trivial
lemma new_lemma_71585 (h0 : group (sub_neg_monoid (sub_neg_monoid pos))) : is_simple_group (sub_neg_monoid (sub_neg_monoid pos)) := sorry --non-trivial
lemma new_lemma_71586 (h1 : group (random_gen num)) : group.fg (random_gen num) := sorry --non-trivial
lemma new_lemma_71587 (h0 : topological_space (has_nndist (cancel_monoid environment.implicit_infer_kind))) : normal_space (has_nndist (cancel_monoid environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_71588 (h1 : ring (distrib reducibility_hints)) : is_domain (distrib reducibility_hints) := sorry --non-trivial
lemma new_lemma_71589 (h0 : ring (random_gen (has_nnnorm (has_nnnorm reducibility_hints)))) : is_domain (random_gen (has_nnnorm (has_nnnorm reducibility_hints))) := sorry --non-trivial
lemma new_lemma_71590 (h0 : function.extfun Type topological_space) : @t1_space.{0} (linear_ordered_comm_group.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (linear_ordered_comm_group.{0} num))  := sorry --non-trivial
lemma new_lemma_71591 (h0 : group (finset ennreal)) : is_cyclic (finset ennreal) := sorry --non-trivial
lemma new_lemma_71592 (h0 : fin has_zero.zero) : @is_principal_ideal_ring.{0} (complete_distrib_lattice.{0} pos) (@function.extfun_app.{2 1} Type ring.{0} (@matrix.vec_empty.{1} (function.extfun.{2 1} Type ring.{0}) h0) (complete_distrib_lattice.{0} pos))  := sorry --non-trivial
lemma new_lemma_71593 (h0 : functor.add_const (function.extfun Type cancel_comm_monoid_with_zero) pos) : @unique_factorization_monoid.{0} (has_zero.{0} name) (@function.extfun_app.{2 1} Type cancel_comm_monoid_with_zero.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type cancel_comm_monoid_with_zero.{0}) pos h0) (has_zero.{0} name))  := sorry --non-trivial
lemma new_lemma_71594 (h0 : cancel_comm_monoid_with_zero (has_neg_part (boolean_algebra.core (has_add name)))) : unique_factorization_monoid (has_neg_part (boolean_algebra.core (has_add name))) := sorry --non-trivial
lemma new_lemma_71595 (h0 : function.extfun (finset (Type -> Type)) (has_mem.mem topological_space)) : @irreducible_space.{0} (@id.{2} Type fun_info) (@function.extfun_app.{2 1} Type topological_space.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) topological_space.{0} (@function.extfun_app.{2 0} (finset.{1} (Type → Type)) (@has_mem.mem.{1 1} (Type → Type) (finset.{1} (Type → Type)) (@finset.has_mem.{1} (Type → Type)) topological_space.{0}) h0 (@has_emptyc.emptyc.{1} (finset.{1} (Type → Type)) (@finset.has_emptyc.{1} (Type → Type))))) (@id.{2} Type fun_info))  := sorry --non-trivial
lemma new_lemma_71596 (h0 : complete_lattice (linear_ordered_field (option name))) : is_compactly_generated (linear_ordered_field (option name)) := sorry --non-trivial
lemma new_lemma_71597 (h0 : functor.add_const (function.extfun Type uniform_space) linarith.comp) : @separated_space.{0} (has_pos_part.{0} linarith.comp) (@function.extfun_app.{2 1} Type uniform_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type uniform_space.{0}) linarith.comp h0) (has_pos_part.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_71598 (h0 : group (has_pos_part (ring pos))) : is_simple_group (has_pos_part (ring pos)) := sorry --non-trivial
lemma new_lemma_71599 (h0 : topological_space (has_zero (normed_comm_ring Type))) : sequential_space (has_zero (normed_comm_ring Type)) := sorry --non-trivial
lemma new_lemma_71600 (h1 : ring (has_nnnorm linarith.ineq)) : rank_condition (has_nnnorm linarith.ineq) := sorry --non-trivial
lemma new_lemma_71601 (h0 : not (has_mem.mem (linear_ordered_add_comm_group linarith.comp_source) has_emptyc.emptyc -> false)) : @totally_separated_space.{0} (linear_ordered_add_comm_group.{0} linarith.comp_source) (@finset.pi.empty.{1 0} Type topological_space.{0} (linear_ordered_add_comm_group.{0} linarith.comp_source) (@classical.by_contradiction'.{0} (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (linear_ordered_add_comm_group.{0} linarith.comp_source) (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))) h0))  := sorry --non-trivial
lemma new_lemma_71602 (h0 : not (ring (has_one linarith.comp) -> false)) : @strong_rank_condition.{0} (has_one.{0} linarith.comp) (@classical.by_contradiction'.{1} (ring.{0} (has_one.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_71603 (h0 : function.extfun Type group) : @normalizer_condition.{0} (linear_ordered_add_comm_group.{0} fun_info) (@function.extfun_app.{2 1} Type group.{0} h0 (linear_ordered_add_comm_group.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_71604 (h0 : functor.comp group has_add name) : @is_simple_group.{0} (has_add.{0} name) (@functor.comp.run.{0 0 0} group.{0} has_add.{0} name h0)  := sorry --non-trivial
lemma new_lemma_71605 (h0 : topological_space (with_bot (has_to_string (has_Inf pos)))) : t0_space (with_bot (has_to_string (has_Inf pos))) := sorry --non-trivial
lemma new_lemma_71606 (h0 : fin has_zero.zero) : @has_exists_mul_of_le.{0} (ordered_comm_ring.{0} real) (@matrix.vec_empty.{0} (ordered_comm_monoid.{0} (ordered_comm_ring.{0} real)) (@matrix.vec_empty.{0} (fin (@has_zero.zero.{0} nat nat.has_zero)) (@matrix.vec_empty.{0} (fin (@has_zero.zero.{0} nat nat.has_zero)) (@matrix.vec_empty.{0} (fin (@has_zero.zero.{0} nat nat.has_zero)) (@matrix.vec_empty.{0} (fin (@has_zero.zero.{0} nat nat.has_zero)) (@matrix.vec_empty.{0} (fin (@has_zero.zero.{0} nat nat.has_zero)) h0))))))  := sorry --non-trivial
lemma new_lemma_71607 (h0 : topological_space (generalized_boolean_algebra (has_bot real))) : totally_disconnected_space (generalized_boolean_algebra (has_bot real)) := sorry --non-trivial
lemma new_lemma_71608 (h0 : function.extfun Type filter) : filter.ne_bot (function.extfun_app h0 (filter congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_71609 (h0 : topological_space (boolean_algebra (has_add linarith.comp))) : loc_path_connected_space (boolean_algebra (has_add linarith.comp)) := sorry --non-trivial
lemma new_lemma_71610 (h0 : fin has_zero.zero) : @rank_condition.{1} (ordered_comm_ring.{1} Type) (@matrix.vec_empty.{1} (ring.{1} (ordered_comm_ring.{1} Type)) (@matrix.vec_empty.{0} (fin (@has_zero.zero.{0} nat nat.has_zero)) (@matrix.vec_empty.{0} (fin (@has_zero.zero.{0} nat nat.has_zero)) h0)))  := sorry --non-trivial
lemma new_lemma_71611 (h0 : functor.add_const (topological_space (has_neg_part ennreal)) unsigned) : @preirreducible_space.{0} (has_neg_part.{0} ennreal) (@functor.add_const.run.{0 0} (topological_space.{0} (has_neg_part.{0} ennreal)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_71612 (h0 : function.extfun Type topological_space) : @t0_space.{0} (has_inter.{0} ennreal) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_inter.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_71613 (h0 : topological_space (has_add real)) : sequential_space (has_add real) := sorry --non-trivial
lemma new_lemma_71614 (h0 : functor.add_const (function.extfun (Type 1) uniform_space) Type) : @separated_space.{1} (generalized_boolean_algebra.{1} Type) (@function.extfun_app.{3 2} (Type 1) uniform_space.{1} (@functor.add_const.run.{2 1} (function.extfun.{3 2} (Type 1) uniform_space.{1}) Type h0) (generalized_boolean_algebra.{1} Type))  := sorry --non-trivial
lemma new_lemma_71615 (h0 : functor.add_const (filter (ring Type)) Type) : countable_Inter_filter (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_71616 (h0 : topological_space (has_to_string (boolean_algebra.core unsigned))) : t1_space (has_to_string (boolean_algebra.core unsigned)) := sorry --non-trivial
lemma new_lemma_71617 (h0 : ordered_add_comm_monoid (generalized_boolean_algebra (has_Inf (has_neg Type)))) : archimedean (generalized_boolean_algebra (has_Inf (has_neg Type))) := sorry --non-trivial
lemma new_lemma_71618 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @strong_rank_condition.{0} (mul_zero_class.{0} (finset.{0} ennreal)) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (mul_zero_class.{0} (finset.{0} ennreal)))  := sorry --non-trivial
lemma new_lemma_71619 (h0 : topological_space (linear_ordered_field pos)) : t0_space (linear_ordered_field pos) := sorry --non-trivial
lemma new_lemma_71620 (h0 : functor.add_const (group (has_nndist Type)) (has_nndist pos)) : @group.fg.{1} (has_nndist.{1} Type) (@functor.add_const.run.{1 0} (group.{1} (has_nndist.{1} Type)) (has_nndist.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_71621 (h0 : complete_lattice (ordered_ring (semiring unsigned))) : is_compactly_generated (ordered_ring (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_71622 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_add_cyclic.{0} (add_comm_monoid.{0} unsigned) (@function.extfun_app.{2 1} Type add_group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 add_group.{0}) (add_comm_monoid.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_71623 (h0 : topological_space (comm_group (comm_group name))) : topological_space.separable_space (comm_group (comm_group name)) := sorry --non-trivial
lemma new_lemma_71624 (h0 : ordered_comm_monoid (ordered_comm_ring (sub_neg_monoid pos))) : has_exists_mul_of_le (ordered_comm_ring (sub_neg_monoid pos)) := sorry --non-trivial
lemma new_lemma_71625 (h0 : not (ring (semi_normed_comm_ring string.iterator_imp) -> false)) : @rank_condition.{0} (semi_normed_comm_ring.{0} string.iterator_imp) (@classical.by_contradiction'.{1} (ring.{0} (semi_normed_comm_ring.{0} string.iterator_imp)) h0)  := sorry --non-trivial
lemma new_lemma_71626 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @is_add_cyclic.{1} (add_cancel_monoid.{1} Type) (@function.extfun_app.{3 2} (Type 1) add_group.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 add_group.{1}) (add_cancel_monoid.{1} Type))  := sorry --non-trivial
lemma new_lemma_71627 (h0 : complete_lattice (canonically_ordered_monoid (has_Inf (has_Inf Type)))) : is_compactly_generated (canonically_ordered_monoid (has_Inf (has_Inf Type))) := sorry --non-trivial
lemma new_lemma_71628 (h0 : function.extfun Type finset) : finset.nonempty (function.extfun_app h0 (free_add_monoid congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_71629 (h0 : functor.add_const (functor.add_const (ring linarith.comp) pos) pos) : @strong_rank_condition.{0} linarith.comp (@functor.add_const.run.{0 0} (ring.{0} linarith.comp) pos (@functor.add_const.run.{0 0} (functor.add_const.{0 0} (ring.{0} linarith.comp) pos) pos h0))  := sorry --non-trivial
lemma new_lemma_71630 (h0 : ring (has_add (has_to_string ennreal))) : is_principal_ideal_ring (has_add (has_to_string ennreal)) := sorry --non-trivial
lemma new_lemma_71631 (h0 : function.extfun Type topological_space) : @normal_space.{0} unsigned (@function.extfun_app.{2 1} Type topological_space.{0} h0 unsigned)  := sorry --non-trivial
lemma new_lemma_71632 (h0 : functor.add_const (topological_space (has_neg_part unsigned)) Type) : @loc_path_connected_space.{0} (has_neg_part.{0} unsigned) (@functor.add_const.run.{0 1} (topological_space.{0} (has_neg_part.{0} unsigned)) Type h0)  := sorry --non-trivial
lemma new_lemma_71633 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_domain.{0} (comm_semigroup.{0} name) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (comm_semigroup.{0} name))  := sorry --non-trivial
lemma new_lemma_71634 (h0 : functor.add_const (topological_space (has_nndist environment.implicit_infer_kind)) name) : @totally_disconnected_space.{0} (has_nndist.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (has_nndist.{0} environment.implicit_infer_kind)) name h0)  := sorry --non-trivial
lemma new_lemma_71635 (h0 : function.extfun Type ring) : @rank_condition.{0} (ordered_ring.{0} unsigned) (@function.extfun_app.{2 1} Type ring.{0} h0 (ordered_ring.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_71636 (h0 : topological_space (ring num)) : preconnected_space (ring num) := sorry --non-trivial
lemma new_lemma_71637 (h0 : topological_space (semi_normed_comm_ring (has_ssubset (has_ssubset linarith.ineq)))) : path_connected_space (semi_normed_comm_ring (has_ssubset (has_ssubset linarith.ineq))) := sorry --non-trivial
lemma new_lemma_71638 (h0 : functor.add_const (filter (comm_group pos)) pos) : filter.ne_bot (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_71639 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @strong_rank_condition.{1} (complete_distrib_lattice.{1} Type) (@function.extfun_app.{3 2} (Type 1) ring.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 ring.{1}) (complete_distrib_lattice.{1} Type))  := sorry --non-trivial
lemma new_lemma_71640 (h0 : uniform_space (boolean_algebra.core (boolean_algebra.core Type))) : separated_space (boolean_algebra.core (boolean_algebra.core Type)) := sorry --non-trivial
lemma new_lemma_71641 (h0 : topological_space (ring (has_add (boolean_algebra.core Type)))) : t1_space (ring (has_add (boolean_algebra.core Type))) := sorry --non-trivial
lemma new_lemma_71642 (h0 : functor.add_const (topological_space (complete_distrib_lattice environment.implicit_infer_kind)) name) : @t0_space.{0} (complete_distrib_lattice.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (complete_distrib_lattice.{0} environment.implicit_infer_kind)) name h0)  := sorry --non-trivial
lemma new_lemma_71643 (h0 : prod (comm_monoid (semiring empty)) (comm_monoid (semiring empty))) : id_rel h0 := sorry --non-trivial
lemma new_lemma_71644 (h0 : uniform_space (normed_group (semiring empty))) : complete_space (normed_group (semiring empty)) := sorry --non-trivial
lemma new_lemma_71645 (h0 : group (boolean_algebra (has_pos_part linarith.comp))) : group.fg (boolean_algebra (has_pos_part linarith.comp)) := sorry --non-trivial
lemma new_lemma_71646 (h0 : semiring (with_one (semiring num))) : is_noetherian_ring (with_one (semiring num)) := sorry --non-trivial
lemma new_lemma_71647 (h0 : topological_space (semigroup (comm_group (comm_group (comm_group pos))))) : normal_space (semigroup (comm_group (comm_group (comm_group pos)))) := sorry --non-trivial
lemma new_lemma_71648 (h0 : not (topological_space (add_cancel_comm_monoid linarith.comp_source) -> false)) : @path_connected_space.{0} (add_cancel_comm_monoid.{0} linarith.comp_source) (@classical.by_contradiction'.{1} (topological_space.{0} (add_cancel_comm_monoid.{0} linarith.comp_source)) h0)  := sorry --non-trivial
lemma new_lemma_71649 (h0 : functor.add_const (uniform_space (left_cancel_monoid unsigned)) (semiring empty)) : @separated_space.{0} (left_cancel_monoid.{0} unsigned) (@functor.add_const.run.{0 0} (uniform_space.{0} (left_cancel_monoid.{0} unsigned)) (semiring.{0} empty) h0)  := sorry --non-trivial
lemma new_lemma_71650 (h2 : topological_space (add_comm_semigroup enat)) : totally_disconnected_space (add_comm_semigroup enat) := sorry --non-trivial
lemma new_lemma_71651 (h0 : topological_space (has_nndist (has_neg linarith.comp))) : discrete_topology (has_nndist (has_neg linarith.comp)) := sorry --non-trivial
lemma new_lemma_71652 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @monoid.fg.{0} (has_Sup.{0} empty) (@function.extfun_app.{2 1} Type monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 monoid.{0}) (has_Sup.{0} empty))  := sorry --non-trivial
lemma new_lemma_71653 (h0 : ring (has_zero (has_neg_part pos))) : strong_rank_condition (has_zero (has_neg_part pos)) := sorry --non-trivial
lemma new_lemma_71654 (h0 : complete_lattice (complete_distrib_lattice (has_add pos))) : is_compactly_generated (complete_distrib_lattice (has_add pos)) := sorry --non-trivial
lemma new_lemma_71655 (h0 : functor.add_const (ordered_comm_monoid (has_add name)) name) : @has_exists_mul_of_le.{0} (has_add.{0} name) (@functor.add_const.run.{0 0} (ordered_comm_monoid.{0} (has_add.{0} name)) name h0)  := sorry --non-trivial
lemma new_lemma_71656 (h0 : topological_space (measure_theory.measure_space (semiring num))) : locally_compact_space (measure_theory.measure_space (semiring num)) := sorry --non-trivial
lemma new_lemma_71657 (h0 : list (comm_group (option pos))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_71658 (h0 : functor.add_const (list (boolean_algebra linarith.comp)) (has_zero Type)) : list.nodup (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_71659 (h0 : function.extfun Type (functor.add_const (filter znum))) : filter.ne_bot (functor.add_const.run (function.extfun_app h0 unsigned)) := sorry --non-trivial
lemma new_lemma_71660 (h0 : complete_lattice (has_emptyc (has_top congr_arg_kind))) : complete_lattice.is_Sup_finite_compact (has_emptyc (has_top congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_71661 (h0 : functor.add_const (finset (cancel_monoid empty)) (semiring (semiring (semiring num)))) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_71662 (h0 : function.extfun Type (functor.add_const (ring ennreal))) : @is_domain.{0} ennreal (@functor.add_const.run.{0 0} (ring.{0} ennreal) empty (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (ring.{0} ennreal)) h0 empty))  := sorry --non-trivial
lemma new_lemma_71663 (h0 : functor.add_const (topological_space (normed_linear_ordered_group empty)) empty) : @t1_space.{0} (normed_linear_ordered_group.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (normed_linear_ordered_group.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_71664 (h0 : functor.add_const (ring (has_to_string environment.implicit_infer_kind)) (has_add pos)) : @rank_condition.{0} (has_to_string.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (ring.{0} (has_to_string.{0} environment.implicit_infer_kind)) (has_add.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_71665 (h0 : monoid (ring linarith.comp)) : monoid.fg (ring linarith.comp) := sorry --non-trivial
lemma new_lemma_71666 (h0 : topological_space (random_gen string_imp)) : irreducible_space (random_gen string_imp) := sorry --non-trivial
lemma new_lemma_71667 (h0 : ring (normed_group (semiring num))) : strong_rank_condition (normed_group (semiring num)) := sorry --non-trivial
lemma new_lemma_71668 (h0 : ring (has_top (random_gen linarith.ineq))) : rank_condition (has_top (random_gen linarith.ineq)) := sorry --non-trivial
lemma new_lemma_71669 (h0 : not (group (has_star num) -> false)) : @is_cyclic.{0} (has_star.{0} num) (@classical.by_contradiction'.{1} (group.{0} (has_star.{0} num)) h0)  := sorry --non-trivial
lemma new_lemma_71670 (h1 : ring (has_compl (has_nnnorm char))) : rank_condition (has_compl (has_nnnorm char)) := sorry --non-trivial
lemma new_lemma_71671 (h1 : ring (random_gen (add_zero_class (distrib_lattice (random_gen char))))) : rank_condition (random_gen (add_zero_class (distrib_lattice (random_gen char)))) := sorry --non-trivial
lemma new_lemma_71672 (h0 : complete_lattice (finset (has_pos_part (has_Inf pos)))) : complete_lattice.is_Sup_finite_compact (finset (has_pos_part (has_Inf pos))) := sorry --non-trivial
lemma new_lemma_71673 (h0 : not (function.extfun Type topological_space -> false)) : @irreducible_space.{0} (has_norm.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (has_norm.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_71674 (h0 : not (has_mem.mem uniform_space has_emptyc.emptyc -> false)) : @complete_space.{0} (measurable_space.{0} fun_info) (@function.extfun_app.{2 1} Type uniform_space.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) uniform_space.{0} (@classical.by_contradiction'.{0} (@has_mem.mem.{1 1} (Type → Type) (finset.{1} (Type → Type)) (@finset.has_mem.{1} (Type → Type)) uniform_space.{0} (@has_emptyc.emptyc.{1} (finset.{1} (Type → Type)) (@finset.has_emptyc.{1} (Type → Type)))) h0)) (measurable_space.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_71675 (h0 : functor.add_const (ordered_comm_monoid (ring environment.implicit_infer_kind)) (ring pos)) : @has_exists_mul_of_le.{0} (ring.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (ordered_comm_monoid.{0} (ring.{0} environment.implicit_infer_kind)) (ring.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_71676 (h0 : ring (linear_ordered_field name)) : strong_rank_condition (linear_ordered_field name) := sorry --non-trivial
lemma new_lemma_71677 (h0 : cancel_comm_monoid_with_zero (has_dist congr_arg_kind)) : unique_factorization_monoid (has_dist congr_arg_kind) := sorry --non-trivial
lemma new_lemma_71678 (h0 : add_monoid (non_assoc_semiring (option empty))) : add_monoid.fg (non_assoc_semiring (option empty)) := sorry --non-trivial
lemma new_lemma_71679 (h0 : complete_lattice (complete_distrib_lattice (has_to_string name))) : is_compactly_generated (complete_distrib_lattice (has_to_string name)) := sorry --non-trivial
lemma new_lemma_71680 (h0 : functor.add_const (topological_space (boolean_algebra.core Type)) ennreal) : @preconnected_space.{1} (boolean_algebra.core.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (boolean_algebra.core.{1} Type)) ennreal h0)  := sorry --non-trivial
lemma new_lemma_71681 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @totally_disconnected_space.{0} (has_nndist.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_nndist.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_71682 (h0 : topological_space (ring name)) : discrete_topology (ring name) := sorry --non-trivial
lemma new_lemma_71683 (h0 : topological_space (add_left_cancel_monoid (has_inv fun_info))) : totally_disconnected_space (add_left_cancel_monoid (has_inv fun_info)) := sorry --non-trivial
lemma new_lemma_71684 (h0 : topological_space (finset (normed_comm_ring (has_add name)))) : preconnected_space (finset (normed_comm_ring (has_add name))) := sorry --non-trivial
lemma new_lemma_71685 (h0 : functor.add_const (topological_space (add_cancel_monoid Type)) Type) : @preirreducible_space.{1} (add_cancel_monoid.{1} Type) (@functor.add_const.run.{1 1} (topological_space.{1} (add_cancel_monoid.{1} Type)) Type h0)  := sorry --non-trivial
lemma new_lemma_71686 (h0 : functor.add_const (topological_space (mul_zero_class name)) unsigned) : @t0_space.{0} (mul_zero_class.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (mul_zero_class.{0} name)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_71687 (h1 : function.extfun Type topological_space) : @t0_space.{0} (with_bot.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h1 (with_bot.{0} empty))  := sorry --non-trivial
lemma new_lemma_71688 (h0 : has_Inf (has_pos_part Type) -> has_Inf (has_pos_part Type) -> Prop) : transitive h0 := sorry --non-trivial
lemma new_lemma_71689 (h0 : cancel_comm_monoid_with_zero (add_semigroup (linear_ordered_field (option unsigned)))) : unique_factorization_monoid (add_semigroup (linear_ordered_field (option unsigned))) := sorry --non-trivial
lemma new_lemma_71690 (h0 : topological_space (encodable linarith.comp_source)) : totally_disconnected_space (encodable linarith.comp_source) := sorry --non-trivial
lemma new_lemma_71691 (h0 : topological_space (group_with_zero (option (option (option (option empty)))))) : totally_separated_space (group_with_zero (option (option (option (option empty))))) := sorry --non-trivial
lemma new_lemma_71692 (h0 : functor.add_const (topological_space (boolean_algebra.core Type)) linarith.comp) : @discrete_topology.{1} (boolean_algebra.core.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (boolean_algebra.core.{1} Type)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_71693 (h0 : function.extfun Type topological_space) : @loc_path_connected_space.{0} (add_cancel_monoid.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (add_cancel_monoid.{0} name))  := sorry --non-trivial
lemma new_lemma_71694 (h0 : ring (has_inner linarith.ineq (random_gen to_additive.value_type))) : rank_condition (has_inner linarith.ineq (random_gen to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_71695 (h0 : ring (non_unital_non_assoc_semiring (has_compl char))) : strong_rank_condition (non_unital_non_assoc_semiring (has_compl char)) := sorry --non-trivial
lemma new_lemma_71696 (h0 : topological_space (canonically_linear_ordered_monoid (ordered_comm_monoid (has_pos_part Type)))) : irreducible_space (canonically_linear_ordered_monoid (ordered_comm_monoid (has_pos_part Type))) := sorry --non-trivial
lemma new_lemma_71697 (h1 : function.extfun Type topological_space) : @discrete_topology.{0} (random_gen.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h1 (random_gen.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_71698 (h0 : mul_one_class string_imp -> mul_one_class string_imp -> Prop) (h1 : mul_one_class string_imp) (h2 : not (mul_one_class string_imp -> false)) : relation.refl_gen h0 h1 (classical.by_contradiction' h2) := sorry --non-trivial
lemma new_lemma_71699 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @archimedean.{0} (has_zero.{0} unsigned) (@function.extfun_app.{2 1} Type ordered_add_comm_monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ordered_add_comm_monoid.{0}) (has_zero.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_71700 (h0 : functor.add_const (function.extfun (Type 1) ring) Type) : @strong_rank_condition.{1} (ordered_comm_ring.{1} Type) (@function.extfun_app.{3 2} (Type 1) ring.{1} (@functor.add_const.run.{2 1} (function.extfun.{3 2} (Type 1) ring.{1}) Type h0) (ordered_comm_ring.{1} Type))  := sorry --non-trivial
lemma new_lemma_71701 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @preconnected_space.{0} (cancel_monoid.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (cancel_monoid.{0} num))  := sorry --non-trivial
lemma new_lemma_71702 (h0 : group (distrib_lattice (random_gen (random_gen string_imp)))) : normalizer_condition (distrib_lattice (random_gen (random_gen string_imp))) := sorry --non-trivial
lemma new_lemma_71703 (h0 : functor.add_const (function.extfun (Type 1) list) Type) : palindrome (function.extfun_app (functor.add_const.run h0) (has_to_string Type)) := sorry --non-trivial
lemma new_lemma_71704 (h0 : functor.add_const (topological_space (boolean_algebra Type)) (boolean_algebra name)) : @loc_path_connected_space.{1} (boolean_algebra.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (boolean_algebra.{1} Type)) (boolean_algebra.{0} name) h0)  := sorry --non-trivial
lemma new_lemma_71705 (h0 : monoid (complete_semilattice_Sup linarith.ineq)) : monoid.fg (complete_semilattice_Sup linarith.ineq) := sorry --non-trivial
lemma new_lemma_71706 (h0 : function.extfun Type topological_space) : @totally_separated_space.{0} (boolean_algebra.core.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (boolean_algebra.core.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_71707 (h0 : filter (has_neg_part (option (option (option unsigned))))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_71708 (h0 : cancel_comm_monoid_with_zero (has_dist (has_dist (option unsigned)))) : unique_factorization_monoid (has_dist (has_dist (option unsigned))) := sorry --non-trivial
lemma new_lemma_71709 (h0 : functor.add_const (complete_lattice (semigroup pos)) environment.implicit_infer_kind) : @is_atomistic.{0} (semigroup.{0} pos) (@functor.add_const.run.{0 0} (complete_lattice.{0} (semigroup.{0} pos)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_71710 (h0 : functor.add_const (group (has_zero name)) environment.implicit_infer_kind) : @normalizer_condition.{0} (has_zero.{0} name) (@functor.add_const.run.{0 0} (group.{0} (has_zero.{0} name)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_71711 (h0 : functor.add_const (finset (ordered_ring num)) num) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_71712 (h0 : not (function.extfun Type ring -> false)) : @rank_condition.{0} (has_one.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type ring.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type ring.{0}) h0) (has_one.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_71713 (h0 : group (finset (option (option pos)))) : group.fg (finset (option (option pos))) := sorry --non-trivial
lemma new_lemma_71714 (h0 : functor.add_const (complete_lattice (add_cancel_monoid Type)) name) : @complete_lattice.is_Sup_finite_compact.{1} (add_cancel_monoid.{1} Type) (@functor.add_const.run.{1 0} (complete_lattice.{1} (add_cancel_monoid.{1} Type)) name h0)  := sorry --non-trivial
lemma new_lemma_71715 (h0 : functor.add_const (complete_lattice (has_add pos)) linarith.comp) : @complete_lattice.is_Sup_finite_compact.{0} (has_add.{0} pos) (@functor.add_const.run.{0 0} (complete_lattice.{0} (has_add.{0} pos)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_71716 (h0 : cancel_comm_monoid_with_zero (free_add_monoid (option (semiring unsigned)))) : unique_factorization_monoid (free_add_monoid (option (semiring unsigned))) := sorry --non-trivial
lemma new_lemma_71717 (h0 : ring (linear_ordered_semiring (has_norm linarith.comp))) : is_domain (linear_ordered_semiring (has_norm linarith.comp)) := sorry --non-trivial
lemma new_lemma_71718 (h0 : complete_lattice (partial_order (has_top (has_top (semiring (has_top empty)))))) : is_compactly_generated (partial_order (has_top (has_top (semiring (has_top empty))))) := sorry --non-trivial
lemma new_lemma_71719 (h0 : group (has_edist empty)) : is_cyclic (has_edist empty) := sorry --non-trivial
lemma new_lemma_71720 (h0 : not (topological_space (normed_field (mul_one_class char)) -> false)) : @t0_space.{0} (normed_field.{0} (mul_one_class.{0} char)) (@classical.by_contradiction'.{1} (topological_space.{0} (normed_field.{0} (mul_one_class.{0} char))) h0)  := sorry --non-trivial
lemma new_lemma_71721 (h0 : function.extfun (finset Type) (has_mem.mem (has_one unsigned))) : @path_connected_space.{0} (has_one.{0} unsigned) (@finset.pi.empty.{1 0} Type topological_space.{0} (has_one.{0} unsigned) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (has_one.{0} unsigned)) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_71722 (h2 : topological_space (mul_one_class linarith.ineq)) (h3 : set (mul_one_class linarith.ineq)) : is_path_connected h3 := sorry --non-trivial
lemma new_lemma_71723 (h0 : ring char) : is_domain char := sorry --non-trivial
lemma new_lemma_71724 (h0 : functor.add_const (filter (has_nndist unsigned)) pos) : filter.ne_bot (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_71725 (h0 : function.extfun Type topological_space) : @preirreducible_space.{0} (canonically_ordered_comm_semiring.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (canonically_ordered_comm_semiring.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_71726 (h0 : topological_space (id (random_gen linarith.comp_source))) : locally_compact_space (id (random_gen linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_71727 (h0 : functor.add_const (ordered_comm_monoid (has_nndist environment.implicit_infer_kind)) (has_add (has_add pos))) : @has_exists_mul_of_le.{0} (has_nndist.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (ordered_comm_monoid.{0} (has_nndist.{0} environment.implicit_infer_kind)) (has_add.{0} (has_add.{0} pos)) h0)  := sorry --non-trivial
lemma new_lemma_71728 (h0 : functor.add_const (topological_space (add_cancel_monoid pos)) pos) : @normal_space.{0} (add_cancel_monoid.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (add_cancel_monoid.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_71729 (h0 : functor.add_const (ring (has_neg environment.implicit_infer_kind)) name) : @rank_condition.{0} (has_neg.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (ring.{0} (has_neg.{0} environment.implicit_infer_kind)) name h0)  := sorry --non-trivial
lemma new_lemma_71730 (h0 : complete_lattice (add_cancel_monoid (option (option empty)))) : is_atomistic (add_cancel_monoid (option (option empty))) := sorry --non-trivial
lemma new_lemma_71731 (h0 : topological_space (ordered_comm_ring linarith.comp)) : t0_space (ordered_comm_ring linarith.comp) := sorry --non-trivial
lemma new_lemma_71732 (h0 : functor.add_const (uniform_space (cancel_monoid Type)) linarith.comp) : @complete_space.{1} (cancel_monoid.{1} Type) (@functor.add_const.run.{1 0} (uniform_space.{1} (cancel_monoid.{1} Type)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_71733 (h0 : functor.add_const (fin has_zero.zero) real) : @is_atomistic.{0} (has_bot.{0} real) (@matrix.vec_empty.{0} (complete_lattice.{0} (has_bot.{0} real)) (@functor.add_const.run.{0 0} (fin (@has_zero.zero.{0} nat nat.has_zero)) real h0))  := sorry --non-trivial
lemma new_lemma_71734 (h0 : complete_lattice (monoid (option empty))) : complete_lattice.is_Sup_finite_compact (monoid (option empty)) := sorry --non-trivial
lemma new_lemma_71735 (h0 : function.extfun Type (prod auto.case_option)) : id_rel (function.extfun_app h0 auto.case_option) := sorry --non-trivial
lemma new_lemma_71736 (h0 h1 : ereal -> ereal) : function.commute h0 h1 := sorry --non-trivial
lemma new_lemma_71737 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @normalizer_condition.{0} (random_gen.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (random_gen.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_71738 (h0 : ordered_add_comm_monoid (canonically_ordered_comm_semiring Type)) : archimedean (canonically_ordered_comm_semiring Type) := sorry --non-trivial
lemma new_lemma_71739 (h0 : filter (semiring num)) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_71740 (h0 : function.extfun Type add_monoid) : @add_monoid.fg.{0} (has_neg_part.{0} pos) (@function.extfun_app.{2 1} Type add_monoid.{0} h0 (has_neg_part.{0} pos))  := sorry --non-trivial
lemma new_lemma_71741 (h0 : function.extfun nat fin) : @is_cyclic.{0} (sub_neg_monoid.{0} real) (@function.extfun_app.{2 1} Type group.{0} (@matrix.vec_empty.{1} (function.extfun.{2 1} Type group.{0}) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero))) (sub_neg_monoid.{0} real))  := sorry --non-trivial
lemma new_lemma_71742 (h0 : topological_space (has_bot (has_Inf (has_Inf Type)))) : loc_path_connected_space (has_bot (has_Inf (has_Inf Type))) := sorry --non-trivial
lemma new_lemma_71743 (h0 : has_lt (has_one linarith.ineq)) : no_max_order (has_one linarith.ineq) := sorry --non-trivial
lemma new_lemma_71744 (h0 : functor.add_const (topological_space (mul_zero_class unsigned)) empty) : @totally_disconnected_space.{0} (mul_zero_class.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (mul_zero_class.{0} unsigned)) empty h0)  := sorry --non-trivial
lemma new_lemma_71745 (h0 : function.extfun (Type 1) topological_space) : @sequential_space.{1} (mul_zero_class.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} h0 (mul_zero_class.{1} Type))  := sorry --non-trivial
lemma new_lemma_71746 (h0 : not (complete_lattice fun_info -> false)) : @complete_lattice.is_Sup_finite_compact.{0} fun_info (@classical.by_contradiction'.{1} (complete_lattice.{0} fun_info) h0)  := sorry --non-trivial
lemma new_lemma_71747 (h0 : has_neg (add_comm_semigroup enat)) (h1 : measurable_space (add_comm_semigroup enat)) : has_measurable_neg (add_comm_semigroup enat) := sorry --non-trivial
lemma new_lemma_71748 (h0 : function.extfun Type group) : @group.fg.{0} (add_comm_monoid.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type group.{0} h0 (add_comm_monoid.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_71749 (h0 : function.extfun Type topological_space) : @irreducible_space.{0} (comm_semigroup.{0} real) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (comm_semigroup.{0} real))  := sorry --non-trivial
lemma new_lemma_71750 (h0 : topological_space (has_top (random_gen linarith.comp_source))) : locally_compact_space (has_top (random_gen linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_71751 (h0 : complete_lattice (has_add (has_add (finset (has_add pos))))) : is_compactly_generated (has_add (has_add (finset (has_add pos)))) := sorry --non-trivial
lemma new_lemma_71752 (h0 : functor.add_const (ordered_comm_monoid (normed_comm_ring linarith.comp)) name) : @has_exists_mul_of_le.{0} (normed_comm_ring.{0} linarith.comp) (@functor.add_const.run.{0 0} (ordered_comm_monoid.{0} (normed_comm_ring.{0} linarith.comp)) name h0)  := sorry --non-trivial
lemma new_lemma_71753 (h0 : function.extfun Type add_monoid) : @add_monoid.fg.{0} (preorder.{0} empty) (@function.extfun_app.{2 1} Type add_monoid.{0} h0 (preorder.{0} empty))  := sorry --non-trivial
lemma new_lemma_71754 (h0 : not (group (linear_ordered_comm_ring empty) -> false)) : @is_simple_group.{0} (linear_ordered_comm_ring.{0} empty) (@classical.by_contradiction'.{1} (group.{0} (linear_ordered_comm_ring.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_71755 (h1 : preorder (add_comm_semigroup (mul_one_class fun_info))) (h2 : set (add_comm_semigroup (mul_one_class fun_info))) : set.is_pwo h2 := sorry --non-trivial
lemma new_lemma_71756 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : finset.nonempty (function.extfun_app (function.extfun_app h0 finset) (has_neg linarith.comp)) := sorry --non-trivial
lemma new_lemma_71757 (h1 : uniform_space (add_comm_semigroup (add_comm_semigroup (add_comm_semigroup linarith.ineq)))) : complete_space (add_comm_semigroup (add_comm_semigroup (add_comm_semigroup linarith.ineq))) := sorry --non-trivial
lemma new_lemma_71758 (h0 : complete_lattice (comm_monoid (semiring (semiring unsigned)))) : complete_lattice.is_Sup_finite_compact (comm_monoid (semiring (semiring unsigned))) := sorry --non-trivial
lemma new_lemma_71759 (h0 : not (topological_space (complete_linear_order num) -> false)) : @discrete_topology.{0} (complete_linear_order.{0} num) (@classical.by_contradiction'.{1} (topological_space.{0} (complete_linear_order.{0} num)) h0)  := sorry --non-trivial
lemma new_lemma_71760 (h0 : topological_space (comm_ring (random_gen (random_gen char)))) : t0_space (comm_ring (random_gen (random_gen char))) := sorry --non-trivial
lemma new_lemma_71761 (h0 : semiring (ordered_comm_ring (sub_neg_monoid real))) : is_noetherian_ring (ordered_comm_ring (sub_neg_monoid real)) := sorry --non-trivial
lemma new_lemma_71762 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : countable_Inter_filter (function.extfun_app (function.extfun_app h0 filter) (semigroup name)) := sorry --non-trivial
lemma new_lemma_71763 (h1 : topological_space environment.projection_info) : t0_space environment.projection_info := sorry --non-trivial
lemma new_lemma_71764 (h0 : topological_space (finset (has_nndist (cancel_monoid Type)))) : preconnected_space (finset (has_nndist (cancel_monoid Type))) := sorry --non-trivial
lemma new_lemma_71765 (h1 : uniform_space (with_one (has_inv to_additive.value_type))) : complete_space (with_one (has_inv to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_71766 (h0 : functor.add_const (topological_space (has_neg_part name)) Type) : @preirreducible_space.{0} (has_neg_part.{0} name) (@functor.add_const.run.{0 1} (topological_space.{0} (has_neg_part.{0} name)) Type h0)  := sorry --non-trivial
lemma new_lemma_71767 (h0 : ring (ordered_comm_ring (ring (has_to_string Type)))) : rank_condition (ordered_comm_ring (ring (has_to_string Type))) := sorry --non-trivial
lemma new_lemma_71768 (h0 : function.extfun (Type 1) uniform_space) : @complete_space.{1} (boolean_algebra.core.{1} Type) (@function.extfun_app.{3 2} (Type 1) uniform_space.{1} h0 (boolean_algebra.core.{1} Type))  := sorry --non-trivial
lemma new_lemma_71769 (h0 : functor.add_const (group (has_Inf linarith.comp)) (has_neg (has_neg (has_neg Type)))) : @group.fg.{0} (has_Inf.{0} linarith.comp) (@functor.add_const.run.{0 1} (group.{0} (has_Inf.{0} linarith.comp)) (has_neg.{1} (has_neg.{1} (has_neg.{1} Type))) h0)  := sorry --non-trivial
lemma new_lemma_71770 (h0 : setoid string.iterator_imp) (h1 : complete_lattice (quotient h0)) : is_compactly_generated (quotient h0) := sorry --non-trivial
lemma new_lemma_71771 (h0 : functor.add_const (topological_space (cancel_monoid linarith.comp)) linarith.comp) : @totally_separated_space.{0} (cancel_monoid.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (cancel_monoid.{0} linarith.comp)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_71772 (h0 : group (has_top num)) : is_cyclic (has_top num) := sorry --non-trivial
lemma new_lemma_71773 (h0 : functor.add_const (ring (has_pos_part pos)) name) : @strong_rank_condition.{0} (has_pos_part.{0} pos) (@functor.add_const.run.{0 0} (ring.{0} (has_pos_part.{0} pos)) name h0)  := sorry --non-trivial
lemma new_lemma_71774 (h0 : ordered_comm_monoid (has_nndist linarith.comp)) : has_exists_mul_of_le (has_nndist linarith.comp) := sorry --non-trivial
lemma new_lemma_71775 (h1 : function.extfun (Type -> Type) (function.extfun Type)) : @is_add_cyclic.{0} (denumerable.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type add_group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h1 add_group.{0}) (denumerable.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_71776 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : finset.nonempty (function.extfun_app (function.extfun_app h0 finset) (pseudo_metric_space ennreal)) := sorry --non-trivial
lemma new_lemma_71777 (h0 : not (topological_space (has_compl (has_ssubset to_additive.value_type)) -> false)) : @t0_space.{0} (has_compl.{0} (has_ssubset.{0} to_additive.value_type)) (@classical.by_contradiction'.{1} (topological_space.{0} (has_compl.{0} (has_ssubset.{0} to_additive.value_type))) h0)  := sorry --non-trivial
lemma new_lemma_71778 (h0 : functor.add_const (add_group (semigroup name)) (has_neg name)) : @is_add_cyclic.{0} (semigroup.{0} name) (@functor.add_const.run.{0 0} (add_group.{0} (semigroup.{0} name)) (has_neg.{0} name) h0)  := sorry --non-trivial
lemma new_lemma_71779 (h0 : function.extfun Type topological_space) : @t0_space.{0} (normed_group.{0} (comm_ring.{0} to_additive.value_type)) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (normed_group.{0} (comm_ring.{0} to_additive.value_type)))  := sorry --non-trivial
lemma new_lemma_71780 (h0 : functor.add_const (topological_space (mul_zero_class name)) pos) : @discrete_topology.{0} (mul_zero_class.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (mul_zero_class.{0} name)) pos h0)  := sorry --non-trivial
lemma new_lemma_71781 (h0 : has_mem.mem (has_top empty) has_emptyc.emptyc) : @is_compactly_generated.{0} (has_top.{0} empty) (@finset.pi.empty.{1 0} Type complete_lattice.{0} (has_top.{0} empty) h0)  := sorry --non-trivial
lemma new_lemma_71782 (h0 : functor.add_const (topological_space (boolean_algebra name)) name) : @irreducible_space.{0} (boolean_algebra.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (boolean_algebra.{0} name)) name h0)  := sorry --non-trivial
lemma new_lemma_71783 (h0 : topological_space (comm_group (boolean_algebra unsigned))) : t1_space (comm_group (boolean_algebra unsigned)) := sorry --non-trivial
lemma new_lemma_71784 (h0 : finset (has_edist unsigned)) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_71785 (h0 : topological_space (ordered_comm_monoid (has_pos_part linarith.comp))) : topological_space.separable_space (ordered_comm_monoid (has_pos_part linarith.comp)) := sorry --non-trivial
lemma new_lemma_71786 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @locally_compact_space.{0} (has_pos_part.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_pos_part.{0} pos))  := sorry --non-trivial
lemma new_lemma_71787 (h0 : topological_space (boolean_algebra (finset (ring linarith.comp)))) : loc_path_connected_space (boolean_algebra (finset (ring linarith.comp))) := sorry --non-trivial
lemma new_lemma_71788 (h0 : topological_space (simple_graph (has_neg linarith.comp))) : totally_disconnected_space (simple_graph (has_neg linarith.comp)) := sorry --non-trivial
lemma new_lemma_71789 (h0 : cancel_comm_monoid_with_zero (cancel_monoid (option ennreal))) : unique_factorization_monoid (cancel_monoid (option ennreal)) := sorry --non-trivial
lemma new_lemma_71790 (h0 : add_monoid (ring (has_neg (has_neg linarith.comp)))) : add_monoid.fg (ring (has_neg (has_neg linarith.comp))) := sorry --non-trivial
lemma new_lemma_71791 (h0 : function.extfun Type group) : @group.fg.{0} (semi_normed_comm_ring.{0} char) (@function.extfun_app.{2 1} Type group.{0} h0 (semi_normed_comm_ring.{0} char))  := sorry --non-trivial
lemma new_lemma_71792 (h0 : group (complete_semilattice_Sup (has_top linarith.comp_source))) : group.fg (complete_semilattice_Sup (has_top linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_71793 (h0 : has_mem.mem uniform_space has_emptyc.emptyc) : @complete_space.{0} (semiring.{0} fun_info) (@function.extfun_app.{2 1} Type uniform_space.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) uniform_space.{0} h0) (semiring.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_71794 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @totally_separated_space.{1} (has_neg.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 topological_space.{1}) (has_neg.{1} Type))  := sorry --non-trivial
lemma new_lemma_71795 (h0 : functor.add_const (topological_space (free_add_monoid unsigned)) unsigned) : @path_connected_space.{0} (free_add_monoid.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (free_add_monoid.{0} unsigned)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_71796 (h0 : functor.comp topological_space add_comm_monoid pos) : @topological_space.separable_space.{0} (add_comm_monoid.{0} pos) (@functor.comp.run.{0 0 0} topological_space.{0} add_comm_monoid.{0} pos (@functor.comp.run.{0 0 0} topological_space.{0} add_comm_monoid.{0} pos (@functor.comp.run.{0 0 0} topological_space.{0} add_comm_monoid.{0} pos (@functor.comp.run.{0 0 0} topological_space.{0} add_comm_monoid.{0} pos (@functor.comp.run.{0 0 0} topological_space.{0} add_comm_monoid.{0} pos h0)))))  := sorry --non-trivial
lemma new_lemma_71797 (h0 : topological_space (ring (boolean_algebra Type))) : sequential_space (ring (boolean_algebra Type)) := sorry --non-trivial
lemma new_lemma_71798 (h0 : not (function.extfun Type topological_space -> false)) : @normal_space.{0} (with_one.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (with_one.{0} empty))  := sorry --non-trivial
lemma new_lemma_71799 (h0 : topological_space (add_comm_monoid (finset (finset name)))) : t0_space (add_comm_monoid (finset (finset name))) := sorry --non-trivial
lemma new_lemma_71800 (h0 : filter (ring (has_add Type))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_71801 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @is_noetherian_ring.{1} (boolean_algebra.core.{1} Type) (@function.extfun_app.{3 2} (Type 1) semiring.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 semiring.{1}) (boolean_algebra.core.{1} Type))  := sorry --non-trivial
lemma new_lemma_71802 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @complete_lattice.is_Sup_finite_compact.{0} (option.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (option.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_71803 (h0 : topological_space (generalized_boolean_algebra (has_Inf (ordered_comm_ring (has_add linarith.comp))))) : t0_space (generalized_boolean_algebra (has_Inf (ordered_comm_ring (has_add linarith.comp)))) := sorry --non-trivial
lemma new_lemma_71804 (h0 : functor.add_const (finset (finset linarith.comp)) (has_Inf (has_Inf (has_Inf name)))) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_71805 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @complete_lattice.is_Sup_finite_compact.{0} (with_one.{0} num) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (with_one.{0} num))  := sorry --non-trivial
lemma new_lemma_71806 (h0 : functor.add_const (ordered_add_comm_monoid (add_cancel_monoid pos)) environment.implicit_infer_kind) : @archimedean.{0} (add_cancel_monoid.{0} pos) (@functor.add_const.run.{0 0} (ordered_add_comm_monoid.{0} (add_cancel_monoid.{0} pos)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_71807 (h0 : ring (simple_graph congr_arg_kind)) : is_principal_ideal_ring (simple_graph congr_arg_kind) := sorry --non-trivial
lemma new_lemma_71808 (h0 : topological_space (has_union linarith.comp)) : t0_space (has_union linarith.comp) := sorry --non-trivial
lemma new_lemma_71809 (h0 : topological_space (has_Inf (ring linarith.comp))) : locally_compact_space (has_Inf (ring linarith.comp)) := sorry --non-trivial
lemma new_lemma_71810 (h0 : group (ordered_comm_ring real)) : is_simple_group (ordered_comm_ring real) := sorry --non-trivial
lemma new_lemma_71811 (h0 : filter (has_one (has_top unsigned))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_71812 (h0 : functor.add_const (topological_space (semigroup Type)) pos) : @path_connected_space.{1} (semigroup.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (semigroup.{1} Type)) pos h0)  := sorry --non-trivial
lemma new_lemma_71813 (h0 : not (ring (linear_ordered_semiring num) -> false)) : @rank_condition.{0} (linear_ordered_semiring.{0} num) (@classical.by_contradiction'.{1} (ring.{0} (linear_ordered_semiring.{0} num)) h0)  := sorry --non-trivial
lemma new_lemma_71814 (h0 : functor.add_const (topological_space (ordered_comm_ring real)) (sub_neg_monoid real)) : @t0_space.{0} (ordered_comm_ring.{0} real) (@functor.add_const.run.{0 0} (topological_space.{0} (ordered_comm_ring.{0} real)) (sub_neg_monoid.{0} real) h0)  := sorry --non-trivial
lemma new_lemma_71815 (h0 : filter (boolean_algebra pos)) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_71816 (h0 : cancel_comm_monoid_with_zero (has_neg (has_neg_part (comm_group unsigned)))) : unique_factorization_monoid (has_neg (has_neg_part (comm_group unsigned))) := sorry --non-trivial
lemma new_lemma_71817 (h0 : functor.add_const (group (boolean_algebra linarith.comp)) Type) : @is_simple_group.{0} (boolean_algebra.{0} linarith.comp) (@functor.add_const.run.{0 1} (group.{0} (boolean_algebra.{0} linarith.comp)) Type h0)  := sorry --non-trivial
lemma new_lemma_71818 (h0 : functor.add_const (topological_space (boolean_algebra name)) Type) : @discrete_topology.{0} (boolean_algebra.{0} name) (@functor.add_const.run.{0 1} (topological_space.{0} (boolean_algebra.{0} name)) Type h0)  := sorry --non-trivial
lemma new_lemma_71819 (h0 : finset (pseudo_metric_space (option ennreal))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_71820 (h0 : has_mem.mem group has_emptyc.emptyc) : @is_cyclic.{0} linarith.ineq (@function.extfun_app.{2 1} Type group.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) group.{0} h0) linarith.ineq)  := sorry --non-trivial
lemma new_lemma_71821 (h0 : complete_lattice (ordered_comm_ring (sub_neg_monoid pos))) : is_compactly_generated (ordered_comm_ring (sub_neg_monoid pos)) := sorry --non-trivial
lemma new_lemma_71822 (h0 : topological_space (as_linear_order (semiring (semiring unsigned)))) : totally_disconnected_space (as_linear_order (semiring (semiring unsigned))) := sorry --non-trivial
lemma new_lemma_71823 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_principal_ideal_ring.{0} (ring.{0} linarith.comp) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (ring.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_71824 (h0 : ordered_add_comm_monoid (has_pos_part (canonically_linear_ordered_monoid real))) : archimedean (has_pos_part (canonically_linear_ordered_monoid real)) := sorry --non-trivial
lemma new_lemma_71825 (h0 : not (topological_space (add_group empty) -> false)) : @discrete_topology.{0} (add_group.{0} empty) (@classical.by_contradiction'.{1} (topological_space.{0} (add_group.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_71826 (h0 : topological_space (cancel_monoid (option pos))) : topological_space.separable_space (cancel_monoid (option pos)) := sorry --non-trivial
lemma new_lemma_71827 (h0 : topological_space (has_star (has_norm empty))) : topological_space.separable_space (has_star (has_norm empty)) := sorry --non-trivial
lemma new_lemma_71828 (h0 : ring (ordered_ring (option unsigned))) : rank_condition (ordered_ring (option unsigned)) := sorry --non-trivial
lemma new_lemma_71829 (h0 : functor.add_const (add_monoid (has_nndist name)) name) : @add_monoid.fg.{0} (has_nndist.{0} name) (@functor.add_const.run.{0 0} (add_monoid.{0} (has_nndist.{0} name)) name h0)  := sorry --non-trivial
lemma new_lemma_71830 (h0 : not (ring (semi_normed_comm_ring to_additive.value_type) -> false)) : @rank_condition.{0} (semi_normed_comm_ring.{0} to_additive.value_type) (@classical.by_contradiction'.{1} (ring.{0} (semi_normed_comm_ring.{0} to_additive.value_type)) h0)  := sorry --non-trivial
lemma new_lemma_71831 (h0 : topological_space (canonically_linear_ordered_monoid (has_Inf pos))) : sequential_space (canonically_linear_ordered_monoid (has_Inf pos)) := sorry --non-trivial
lemma new_lemma_71832 (h0 : functor.add_const (topological_space (add_cancel_monoid unsigned)) environment.implicit_infer_kind) : @totally_separated_space.{0} (add_cancel_monoid.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (add_cancel_monoid.{0} unsigned)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_71833 (h0 : finset (has_neg (finset (has_to_string (has_nndist pos))))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_71834 (h1 : topological_space (has_ssubset (has_nnnorm linarith.ineq))) : totally_disconnected_space (has_ssubset (has_nnnorm linarith.ineq)) := sorry --non-trivial
lemma new_lemma_71835 (h1 : measurable_space (normed_field (normed_field char))) (h2 : measure_theory.measure (normed_field (normed_field char))) : measure_theory.is_finite_measure h2 := sorry --non-trivial
lemma new_lemma_71836 (h1 : not (group char -> false)) : @is_cyclic.{0} char (@classical.by_contradiction'.{1} (group.{0} char) h1)  := sorry --non-trivial
lemma new_lemma_71837 (h0 : topological_space (has_bot unsigned)) : irreducible_space (has_bot unsigned) := sorry --non-trivial
lemma new_lemma_71838 (h0 : functor.add_const (topological_space (normed_comm_ring Type)) pos) : @t1_space.{1} (normed_comm_ring.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (normed_comm_ring.{1} Type)) pos h0)  := sorry --non-trivial
lemma new_lemma_71839 (h0 : uniform_space (has_ssubset (denumerable (denumerable char)))) : complete_space (has_ssubset (denumerable (denumerable char))) := sorry --non-trivial
lemma new_lemma_71840 (h0 : functor.add_const (ring (comm_group Type)) environment.implicit_infer_kind) : @is_principal_ideal_ring.{1} (comm_group.{1} Type) (@functor.add_const.run.{1 0} (ring.{1} (comm_group.{1} Type)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_71841 (h0 : group (add_cancel_monoid (finset (finset linarith.comp)))) : normalizer_condition (add_cancel_monoid (finset (finset linarith.comp))) := sorry --non-trivial
lemma new_lemma_71842 (h0 : function.extfun Type topological_space) : @irreducible_space.{0} (ordered_comm_group.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (ordered_comm_group.{0} empty))  := sorry --non-trivial
lemma new_lemma_71843 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @preconnected_space.{0} (pseudo_metric_space.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (pseudo_metric_space.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_71844 (h0 : not (topological_space (mul_one_class linarith.ineq) -> false)) : @path_connected_space.{0} (mul_one_class.{0} linarith.ineq) (@classical.by_contradiction'.{1} (topological_space.{0} (mul_one_class.{0} linarith.ineq)) h0)  := sorry --non-trivial
lemma new_lemma_71845 (h0 : functor.add_const (complete_lattice (has_bot name)) real) : @is_atomistic.{0} (has_bot.{0} name) (@functor.add_const.run.{0 0} (complete_lattice.{0} (has_bot.{0} name)) real h0)  := sorry --non-trivial
lemma new_lemma_71846 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @t0_space.{0} (has_union.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_union.{0} num))  := sorry --non-trivial
lemma new_lemma_71847 (h0 : functor.add_const (topological_space bool) name) : discrete_topology bool := sorry --non-trivial
lemma new_lemma_71848 (h0 : ring (semigroup (has_to_string Type))) : strong_rank_condition (semigroup (has_to_string Type)) := sorry --non-trivial
lemma new_lemma_71849 (h0 : not (complete_lattice (has_compl linarith.ineq) -> false)) : @is_compactly_generated.{0} (has_compl.{0} linarith.ineq) (@classical.by_contradiction'.{1} (complete_lattice.{0} (has_compl.{0} linarith.ineq)) h0)  := sorry --non-trivial
lemma new_lemma_71850 (h0 : functor.add_const (function.extfun Type add_group) pos) : @is_add_cyclic.{0} (boolean_algebra.core.{0} pos) (@function.extfun_app.{2 1} Type add_group.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type add_group.{0}) pos h0) (boolean_algebra.core.{0} pos))  := sorry --non-trivial
lemma new_lemma_71851 (h0 : topological_space (has_bot congr_arg_kind)) : locally_compact_space (has_bot congr_arg_kind) := sorry --non-trivial
lemma new_lemma_71852 (h0 : not (function.extfun Type uniform_space -> false)) : @complete_space.{0} (with_bot.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type uniform_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type uniform_space.{0}) h0) (with_bot.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_71853 (h2 : ring (has_ssubset (metric_space to_additive.value_type))) : rank_condition (has_ssubset (metric_space to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_71854 (h0 : functor.add_const (complete_lattice (has_zero Type)) unsigned) : @is_compactly_generated.{1} (has_zero.{1} Type) (@functor.add_const.run.{1 0} (complete_lattice.{1} (has_zero.{1} Type)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_71855 (h0 : topological_space (normed_lattice_add_comm_group (has_add Type))) : regular_space (normed_lattice_add_comm_group (has_add Type)) := sorry --non-trivial
lemma new_lemma_71856 (h0 : not (function.extfun Type add_group -> false)) : @is_add_cyclic.{0} (linear_ordered_comm_ring.{0} num) (@function.extfun_app.{2 1} Type add_group.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type add_group.{0}) h0) (linear_ordered_comm_ring.{0} num))  := sorry --non-trivial
lemma new_lemma_71857 (h1 : ring (has_append (comm_ring reducibility_hints))) : strong_rank_condition (has_append (comm_ring reducibility_hints)) := sorry --non-trivial
lemma new_lemma_71858 (h0 : topological_space (has_norm (has_top num))) : irreducible_space (has_norm (has_top num)) := sorry --non-trivial
lemma new_lemma_71859 (h0 : topological_space (has_nndist (finset name))) : totally_separated_space (has_nndist (finset name)) := sorry --non-trivial
lemma new_lemma_71860 (h0 : functor.add_const (topological_space (has_nndist environment.implicit_infer_kind)) pos) : @regular_space.{0} (has_nndist.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (has_nndist.{0} environment.implicit_infer_kind)) pos h0)  := sorry --non-trivial
lemma new_lemma_71861 (h0 : semiring (add_comm_semigroup linarith.ineq)) (h3 : add_comm_semigroup linarith.ineq) : even h3 := sorry --non-trivial
lemma new_lemma_71862 (h0 : monoid znum) : monoid.fg znum := sorry --non-trivial
lemma new_lemma_71863 (h0 : list (has_norm (random_gen (comm_ring (has_norm fun_info))))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_71864 (h0 : not (function.extfun Type ring -> false)) : @is_domain.{0} (has_top.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type ring.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type ring.{0}) h0) (has_top.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_71865 (h0 : topological_space (has_sub unsigned)) : totally_separated_space (has_sub unsigned) := sorry --non-trivial
lemma new_lemma_71866 (h0 : topological_space (normed_linear_ordered_group (option (option (option unsigned))))) : preirreducible_space (normed_linear_ordered_group (option (option (option unsigned)))) := sorry --non-trivial
lemma new_lemma_71867 (h0 : ring (add_comm_monoid (normed_comm_ring environment.implicit_infer_kind))) : rank_condition (add_comm_monoid (normed_comm_ring environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_71868 (h1 : complete_lattice (normed_field (has_nnnorm char))) : is_compactly_generated (normed_field (has_nnnorm char)) := sorry --non-trivial
lemma new_lemma_71869 (h0 : functor.add_const (topological_space (boolean_algebra Type)) (finset linarith.comp)) : @discrete_topology.{1} (boolean_algebra.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (boolean_algebra.{1} Type)) (finset.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_71870 (h3 : topological_space (add_comm_semigroup char)) : t0_space (add_comm_semigroup char) := sorry --non-trivial
lemma new_lemma_71871 (h0 : not (ring (option empty) -> false)) : @is_domain.{0} (option.{0} empty) (@classical.by_contradiction'.{1} (ring.{0} (option.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_71872 (h0 : topological_space (monoid (option (option empty)))) : preconnected_space (monoid (option (option empty))) := sorry --non-trivial
lemma new_lemma_71873 (h0 : topological_space (distrib linarith.comp_source)) : t0_space (distrib linarith.comp_source) := sorry --non-trivial
lemma new_lemma_71874 (h1 : group (add_left_cancel_monoid to_additive.value_type)) : is_cyclic (add_left_cancel_monoid to_additive.value_type) := sorry --non-trivial
lemma new_lemma_71875 (h0 : has_mem.mem group has_emptyc.emptyc) : @group.fg.{0} num (@function.extfun_app.{2 1} Type group.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) group.{0} h0) num)  := sorry --non-trivial
lemma new_lemma_71876 (h0 : functor.add_const (group (canonically_ordered_comm_semiring Type)) Type) : @normalizer_condition.{1} (canonically_ordered_comm_semiring.{1} Type) (@functor.add_const.run.{1 1} (group.{1} (canonically_ordered_comm_semiring.{1} Type)) Type h0)  := sorry --non-trivial
lemma new_lemma_71877 (h0 : function.extfun Type topological_space) : @path_connected_space.{0} (@id.{2} Type num) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (@id.{2} Type num))  := sorry --non-trivial
lemma new_lemma_71878 (h0 : functor.add_const (ordered_comm_monoid (has_pos_part linarith.comp)) name) : @has_exists_mul_of_le.{0} (has_pos_part.{0} linarith.comp) (@functor.add_const.run.{0 0} (ordered_comm_monoid.{0} (has_pos_part.{0} linarith.comp)) name h0)  := sorry --non-trivial
lemma new_lemma_71879 (h0 : topological_space (linear_order (has_add (has_add (has_add environment.implicit_infer_kind))))) : normal_space (linear_order (has_add (has_add (has_add environment.implicit_infer_kind)))) := sorry --non-trivial
lemma new_lemma_71880 (h0 : topological_space (ordered_comm_monoid (has_nndist Type))) : locally_compact_space (ordered_comm_monoid (has_nndist Type)) := sorry --non-trivial
lemma new_lemma_71881 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @group.fg.{0} (mul_zero_class.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (mul_zero_class.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_71882 (h0 : functor.add_const (function.extfun (Type 1) topological_space) (has_neg Type)) : @t0_space.{1} Type (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@functor.add_const.run.{2 1} (function.extfun.{3 2} (Type 1) topological_space.{1}) (has_neg.{1} Type) h0) Type)  := sorry --non-trivial
lemma new_lemma_71883 (h1 : complete_lattice empty) : is_atomistic empty := sorry --non-trivial
lemma new_lemma_71884 (h0 : function.extfun Type group) : @is_cyclic.{0} (group_with_zero.{0} ennreal) (@function.extfun_app.{2 1} Type group.{0} h0 (group_with_zero.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_71885 (h1 : complete_lattice (has_append (has_ssubset char))) : complete_lattice.is_Sup_finite_compact (has_append (has_ssubset char)) := sorry --non-trivial
lemma new_lemma_71886 (h0 : cancel_comm_monoid_with_zero (add_comm_monoid (semigroup environment.implicit_infer_kind))) : unique_factorization_monoid (add_comm_monoid (semigroup environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_71887 (h0 : not (function.extfun Type group -> false)) : @group.fg.{0} (has_emptyc.{0} empty) (@function.extfun_app.{2 1} Type group.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type group.{0}) h0) (has_emptyc.{0} empty))  := sorry --non-trivial
lemma new_lemma_71888 (h0 : functor.add_const (group (option ennreal)) unsigned) : @normalizer_condition.{0} (option.{0} ennreal) (@functor.add_const.run.{0 0} (group.{0} (option.{0} ennreal)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_71889 (h0 : functor.add_const (topological_space (boolean_algebra pos)) name) : @normal_space.{0} (boolean_algebra.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (boolean_algebra.{0} pos)) name h0)  := sorry --non-trivial
lemma new_lemma_71890 (h0 : uniform_space (semigroup (finset pos))) : separated_space (semigroup (finset pos)) := sorry --non-trivial
lemma new_lemma_71891 (h0 : ring (generalized_boolean_algebra (ordered_comm_ring (has_Inf linarith.comp)))) : is_domain (generalized_boolean_algebra (ordered_comm_ring (has_Inf linarith.comp))) := sorry --non-trivial
lemma new_lemma_71892 (h0 : function.extfun Type ring) : @strong_rank_condition.{0} (is_R_or_C.{0} (option.{0} (option.{0} (option.{0} unsigned)))) (@function.extfun_app.{2 1} Type ring.{0} h0 (is_R_or_C.{0} (option.{0} (option.{0} (option.{0} unsigned)))))  := sorry --non-trivial
lemma new_lemma_71893 (h0 : list (has_neg_part (mul_zero_class Type))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_71894 (h1 : set (non_unital_non_assoc_semiring ereal)) : set.subsingleton h1 := sorry --non-trivial
lemma new_lemma_71895 (h0 : not (function.extfun Type add_monoid -> false)) : @add_monoid.fg.{0} (semiring.{0} num) (@function.extfun_app.{2 1} Type add_monoid.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type add_monoid.{0}) h0) (semiring.{0} num))  := sorry --non-trivial
lemma new_lemma_71896 (h0 : list (random_gen linarith.ineq)) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_71897 (h0 : ring (has_bot (sub_neg_monoid Type))) : strong_rank_condition (has_bot (sub_neg_monoid Type)) := sorry --non-trivial
lemma new_lemma_71898 (h0 : has_mem.mem unsigned has_emptyc.emptyc) : @t0_space.{0} unsigned (@finset.pi.empty.{1 0} Type topological_space.{0} unsigned h0)  := sorry --non-trivial
lemma new_lemma_71899 (h0 : list (id linarith.comp_source)) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_71900 (h0 : ring (add_left_cancel_monoid string_imp)) : rank_condition (add_left_cancel_monoid string_imp) := sorry --non-trivial
lemma new_lemma_71901 (h0 : functor.add_const (finset (has_nndist ennreal)) (mul_zero_class (option (mul_zero_class (mul_zero_class name))))) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_71902 (h1 : function.extfun Type uniform_space) : @complete_space.{0} (with_bot.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type uniform_space.{0} h1 (with_bot.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_71903 (h0 : list (has_ssubset char)) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_71904 (h0 : functor.add_const (ring (cancel_monoid name)) linarith.comp) : @is_domain.{0} (cancel_monoid.{0} name) (@functor.add_const.run.{0 0} (ring.{0} (cancel_monoid.{0} name)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_71905 (h1 : has_mem.mem (complete_semilattice_Sup num) has_emptyc.emptyc) : @t0_space.{0} (complete_semilattice_Sup.{0} num) (@finset.pi.empty.{1 0} Type topological_space.{0} (complete_semilattice_Sup.{0} num) h1)  := sorry --non-trivial
lemma new_lemma_71906 (h0 : function.extfun Type filter) : countable_Inter_filter (function.extfun_app h0 (has_to_string name)) := sorry --non-trivial
lemma new_lemma_71907 (h0 : functor.add_const (topological_space (ring linarith.comp)) pos) : @normal_space.{0} (ring.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (ring.{0} linarith.comp)) pos h0)  := sorry --non-trivial
lemma new_lemma_71908 (h0 : function.extfun Type topological_space) : @totally_disconnected_space.{0} (normed_group.{0} fun_info) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (normed_group.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_71909 (h1 : set (std_gen -> std_gen)) : set.separates_points h1 := sorry --non-trivial
lemma new_lemma_71910 (h0 : functor.add_const (function.extfun Type topological_space) Type) : @preconnected_space.{0} (has_to_string.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type topological_space.{0}) Type h0) (has_to_string.{0} pos))  := sorry --non-trivial
lemma new_lemma_71911 (h0 : topological_space (has_div (add_comm_semigroup enat))) (h1 : preorder (has_div (add_comm_semigroup enat))) : order_topology (has_div (add_comm_semigroup enat)) := sorry --non-trivial
lemma new_lemma_71912 (h0 : functor.add_const (topological_space (canonically_ordered_comm_semiring pos)) pos) : @discrete_topology.{0} (canonically_ordered_comm_semiring.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (canonically_ordered_comm_semiring.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_71913 (h0 : functor.add_const (ring (add_group unsigned)) congr_arg_kind) : @is_domain.{0} (add_group.{0} unsigned) (@functor.add_const.run.{0 0} (ring.{0} (add_group.{0} unsigned)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_71914 (h0 : function.extfun (Type 1) semiring) : @is_noetherian_ring.{1} (plift.{1} unsigned) (@function.extfun_app.{3 2} (Type 1) semiring.{1} h0 (plift.{1} unsigned))  := sorry --non-trivial
lemma new_lemma_71915 (h0 : ring (has_add (option name))) : is_principal_ideal_ring (has_add (option name)) := sorry --non-trivial
lemma new_lemma_71916 (h0 : not (topological_space (with_bot num) -> false)) : @path_connected_space.{0} (with_bot.{0} num) (@classical.by_contradiction'.{1} (topological_space.{0} (with_bot.{0} num)) h0)  := sorry --non-trivial
lemma new_lemma_71917 (h0 : topological_space (measurable_space (has_norm num))) : irreducible_space (measurable_space (has_norm num)) := sorry --non-trivial
lemma new_lemma_71918 (h0 : function.extfun Type group) : @is_cyclic.{0} (@id.{2} Type fun_info) (@function.extfun_app.{2 1} Type group.{0} h0 (@id.{2} Type fun_info))  := sorry --non-trivial
lemma new_lemma_71919 (h0 : ring (normed_group fun_info)) : strong_rank_condition (normed_group fun_info) := sorry --non-trivial
lemma new_lemma_71920 (h0 : ordered_add_comm_monoid (pseudo_metric_space (option (option (option empty))))) : archimedean (pseudo_metric_space (option (option (option empty)))) := sorry --non-trivial
lemma new_lemma_71921 (h0 : topological_space (normed_comm_ring (has_add (has_add pos)))) : totally_disconnected_space (normed_comm_ring (has_add (has_add pos))) := sorry --non-trivial
lemma new_lemma_71922 (h0 : filter (has_nndist (comm_group (comm_group (comm_group pos))))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_71923 (h0 : has_mem.mem topological_space has_emptyc.emptyc) : @t0_space.{0} (has_inter.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) topological_space.{0} h0) (has_inter.{0} empty))  := sorry --non-trivial
lemma new_lemma_71924 (h0 : not (topological_space (normed_group linarith.ineq) -> false)) : @path_connected_space.{0} (normed_group.{0} linarith.ineq) (@classical.by_contradiction'.{1} (topological_space.{0} (normed_group.{0} linarith.ineq)) h0)  := sorry --non-trivial
lemma new_lemma_71925 (h0 : finset (has_nndist num)) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_71926 (h0 : functor.add_const (finset (generalized_boolean_algebra pos)) (has_pos_part pos)) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_71927 (h0 : complete_lattice (semigroup (has_to_string (add_comm_monoid name)))) : complete_lattice.is_Sup_finite_compact (semigroup (has_to_string (add_comm_monoid name))) := sorry --non-trivial
lemma new_lemma_71928 (h0 : list (monoid (option ennreal))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_71929 (h0 : function.extfun Type topological_space) : @loc_path_connected_space.{0} (has_add.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_add.{0} pos))  := sorry --non-trivial
lemma new_lemma_71930 (h2 : set (string.iterator_imp -> char)) : set.separates_points h2 := sorry --non-trivial
lemma new_lemma_71931 (h0 : function.extfun Type complete_lattice) : @complete_lattice.is_Sup_finite_compact.{0} (complete_linear_order.{0} unsigned) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (complete_linear_order.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_71932 (h0 : complete_lattice (boolean_algebra.core (has_add Type))) : complete_lattice.is_Sup_finite_compact (boolean_algebra.core (has_add Type)) := sorry --non-trivial
lemma new_lemma_71933 (h0 : ordered_comm_monoid (has_neg (option name))) : has_exists_mul_of_le (has_neg (option name)) := sorry --non-trivial
lemma new_lemma_71934 (h0 : group (has_star (has_sub empty))) : group.fg (has_star (has_sub empty)) := sorry --non-trivial
lemma new_lemma_71935 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_domain.{0} (has_one.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (has_one.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_71936 (h0 : function.extfun Type ring) : @is_domain.{0} (linear_ordered_field.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type ring.{0} h0 (linear_ordered_field.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_71937 (h0 : not (function.extfun Type ring -> false)) : @rank_condition.{0} (with_bot.{0} linarith.comp) (@function.extfun_app.{2 1} Type ring.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type ring.{0}) h0) (with_bot.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_71938 (h1 : function.extfun (Type -> Type) (function.extfun Type)) : @complete_space.{0} linarith.comp_source (@function.extfun_app.{2 1} Type uniform_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h1 uniform_space.{0}) linarith.comp_source)  := sorry --non-trivial
lemma new_lemma_71939 (h0 : function.extfun Type ring) : @is_principal_ideal_ring.{0} (cancel_monoid.{0} name) (@function.extfun_app.{2 1} Type ring.{0} h0 (cancel_monoid.{0} name))  := sorry --non-trivial
lemma new_lemma_71940 (h0 : functor.add_const (ring (ordered_ring congr_arg_kind)) num) : @strong_rank_condition.{0} (ordered_ring.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (ring.{0} (ordered_ring.{0} congr_arg_kind)) num h0)  := sorry --non-trivial
lemma new_lemma_71941 (h0 : topological_space (mul_one_class to_additive.value_type)) (h1 : preorder (mul_one_class to_additive.value_type)) : order_closed_topology (mul_one_class to_additive.value_type) := sorry --non-trivial
lemma new_lemma_71942 (h0 : semiring (linear_ordered_comm_ring (semiring num))) : is_noetherian_ring (linear_ordered_comm_ring (semiring num)) := sorry --non-trivial
lemma new_lemma_71943 (h0 : cancel_comm_monoid_with_zero (comm_group unsigned)) : unique_factorization_monoid (comm_group unsigned) := sorry --non-trivial
lemma new_lemma_71944 (h0 : functor.add_const (topological_space (comm_group environment.implicit_infer_kind)) pos) : @path_connected_space.{0} (comm_group.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (comm_group.{0} environment.implicit_infer_kind)) pos h0)  := sorry --non-trivial
lemma new_lemma_71945 (h0 : topological_space (boolean_algebra.core (comm_group name))) : preconnected_space (boolean_algebra.core (comm_group name)) := sorry --non-trivial
lemma new_lemma_71946 (h0 : topological_space (generalized_boolean_algebra linarith.comp)) : irreducible_space (generalized_boolean_algebra linarith.comp) := sorry --non-trivial
lemma new_lemma_71947 (h0 : function.extfun Type ordered_comm_monoid) : @has_exists_mul_of_le.{0} (boolean_algebra.{0} real) (@function.extfun_app.{2 1} Type ordered_comm_monoid.{0} h0 (boolean_algebra.{0} real))  := sorry --non-trivial
lemma new_lemma_71948 (h0 : function.extfun Type add_monoid) : @add_monoid.fg.{0} (canonically_linear_ordered_monoid.{0} ennreal) (@function.extfun_app.{2 1} Type add_monoid.{0} h0 (canonically_linear_ordered_monoid.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_71949 (h0 : topological_space (semi_normed_comm_ring fun_info)) : t0_space (semi_normed_comm_ring fun_info) := sorry --non-trivial
lemma new_lemma_71950 (h0 : functor.add_const (ring (ordered_comm_ring pos)) (has_add linarith.comp)) : @is_principal_ideal_ring.{0} (ordered_comm_ring.{0} pos) (@functor.add_const.run.{0 0} (ring.{0} (ordered_comm_ring.{0} pos)) (has_add.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_71951 (h0 : topological_space (canonically_linear_ordered_monoid ennreal)) : discrete_topology (canonically_linear_ordered_monoid ennreal) := sorry --non-trivial
lemma new_lemma_71952 (h0 : group (semiring (semiring empty))) : is_cyclic (semiring (semiring empty)) := sorry --non-trivial
lemma new_lemma_71953 (h0 : fin has_zero.zero) : @complete_space.{1} (canonically_ordered_comm_semiring.{1} Type) (@matrix.vec_empty.{1} (uniform_space.{1} (canonically_ordered_comm_semiring.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_71954 (h0 : functor.add_const (topological_space (add_group empty)) empty) : @totally_separated_space.{0} (add_group.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (add_group.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_71955 (h0 : functor.add_const (topological_space (finset environment.implicit_infer_kind)) name) : @irreducible_space.{0} (finset.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (finset.{0} environment.implicit_infer_kind)) name h0)  := sorry --non-trivial
lemma new_lemma_71956 (h0 : not (complete_lattice (mul_zero_class unsigned) -> false)) : @complete_lattice.is_Sup_finite_compact.{0} (mul_zero_class.{0} unsigned) (@classical.by_contradiction'.{1} (complete_lattice.{0} (mul_zero_class.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_71957 (h0 : topological_space (nondiscrete_normed_field ereal)) : totally_disconnected_space (nondiscrete_normed_field ereal) := sorry --non-trivial
lemma new_lemma_71958 (h2 : uniform_space (has_div linarith.comp_source)) : complete_space (has_div linarith.comp_source) := sorry --non-trivial
lemma new_lemma_71959 (h0 : functor.add_const (topological_space (has_neg Type)) pos) : @path_connected_space.{1} (has_neg.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (has_neg.{1} Type)) pos h0)  := sorry --non-trivial
lemma new_lemma_71960 (h0 : add_monoid (measurable_space.dynkin_system congr_arg_kind)) : add_monoid.fg (measurable_space.dynkin_system congr_arg_kind) := sorry --non-trivial
lemma new_lemma_71961 (h0 : ring (has_zero (add_cancel_monoid linarith.comp))) : is_principal_ideal_ring (has_zero (add_cancel_monoid linarith.comp)) := sorry --non-trivial
lemma new_lemma_71962 (h0 : semigroup (semigroup Type) -> semigroup (semigroup Type) -> Prop) : is_antisymm (semigroup (semigroup Type)) h0 := sorry --non-trivial
lemma new_lemma_71963 (h0 : topological_space (linear_ordered_semiring (has_norm (has_top empty)))) : discrete_topology (linear_ordered_semiring (has_norm (has_top empty))) := sorry --non-trivial
lemma new_lemma_71964 (h0 : monoid (has_bot (comm_semigroup pos))) : monoid.fg (has_bot (comm_semigroup pos)) := sorry --non-trivial
lemma new_lemma_71965 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @totally_separated_space.{0} (has_Sup.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_Sup.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_71966 (h1 : topological_space (mul_one_class (mul_one_class string.iterator_imp))) : path_connected_space (mul_one_class (mul_one_class string.iterator_imp)) := sorry --non-trivial
lemma new_lemma_71967 (h1 : filter (topological_space linarith.ineq)) : filter.ne_bot h1 := sorry --non-trivial
lemma new_lemma_71968 (h0 : topological_space (boolean_algebra.core (has_add pos))) : sequential_space (boolean_algebra.core (has_add pos)) := sorry --non-trivial
lemma new_lemma_71969 (h0 : has_mem.mem topological_space has_emptyc.emptyc) : @preirreducible_space.{0} (has_one.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) topological_space.{0} h0) (has_one.{0} empty))  := sorry --non-trivial
lemma new_lemma_71970 (h0 : functor.add_const (topological_space (ring pos)) linarith.comp) : @normal_space.{0} (ring.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (ring.{0} pos)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_71971 (h0 : ring (ordered_comm_group (option (option (option empty))))) : strong_rank_condition (ordered_comm_group (option (option (option empty)))) := sorry --non-trivial
lemma new_lemma_71972 (h0 : monoid (mul_zero_class unsigned)) : monoid.fg (mul_zero_class unsigned) := sorry --non-trivial
lemma new_lemma_71973 (h0 : add_monoid (has_top (with_bot linarith.comp))) : add_monoid.fg (has_top (with_bot linarith.comp)) := sorry --non-trivial
lemma new_lemma_71974 (h0 : fin has_zero.zero) : @preconnected_space.{0} (ordered_comm_monoid.{0} name) (@matrix.vec_empty.{0} (topological_space.{0} (ordered_comm_monoid.{0} name)) h0)  := sorry --non-trivial
lemma new_lemma_71975 (h0 : ring (add_cancel_monoid num)) : is_domain (add_cancel_monoid num) := sorry --non-trivial
lemma new_lemma_71976 (h0 : filter (mul_zero_class (option (semiring num)))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_71977 (h1 : topological_space std_gen) (h2 : preorder std_gen) : order_closed_topology std_gen := sorry --non-trivial
lemma new_lemma_71978 (h0 : topological_space (generalized_boolean_algebra (has_bot name))) : topological_space.separable_space (generalized_boolean_algebra (has_bot name)) := sorry --non-trivial
lemma new_lemma_71979 (h0 : functor.add_const (function.extfun Type uniform_space) pos) : @separated_space.{0} (has_add.{0} pos) (@function.extfun_app.{2 1} Type uniform_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type uniform_space.{0}) pos h0) (has_add.{0} pos))  := sorry --non-trivial
lemma new_lemma_71980 (h0 : group (has_zero (option pos))) : group.fg (has_zero (option pos)) := sorry --non-trivial
lemma new_lemma_71981 (h0 : functor.add_const (list (has_dist empty)) (option empty)) : palindrome (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_71982 (h0 : not (function.extfun Type ring -> false)) : @rank_condition.{0} (has_star.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type ring.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type ring.{0}) h0) (has_star.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_71983 (h0 : function.extfun Type add_monoid) : @add_monoid.fg.{0} (has_bot.{0} num) (@function.extfun_app.{2 1} Type add_monoid.{0} h0 (has_bot.{0} num))  := sorry --non-trivial
lemma new_lemma_71984 (h1 : ring (add_cancel_comm_monoid (random_gen char))) : is_domain (add_cancel_comm_monoid (random_gen char)) := sorry --non-trivial
lemma new_lemma_71985 (h0 : functor.comp group has_zero ennreal) : @normalizer_condition.{0} (has_zero.{0} ennreal) (@functor.comp.run.{0 0 0} group.{0} has_zero.{0} ennreal h0)  := sorry --non-trivial
lemma new_lemma_71986 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @locally_compact_space.{0} (has_emptyc.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_emptyc.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_71987 (h0 : monoid (boolean_algebra (has_add linarith.comp))) : monoid.fg (boolean_algebra (has_add linarith.comp)) := sorry --non-trivial
lemma new_lemma_71988 (h0 : functor.add_const (topological_space (ring unsigned)) Type) : @locally_compact_space.{0} (ring.{0} unsigned) (@functor.add_const.run.{0 1} (topological_space.{0} (ring.{0} unsigned)) Type h0)  := sorry --non-trivial
lemma new_lemma_71989 (h0 : monoid (has_dist (option ennreal))) : monoid.fg (has_dist (option ennreal)) := sorry --non-trivial
lemma new_lemma_71990 (h0 : function.extfun Type complete_lattice) : @is_atomistic.{0} (with_bot.{0} unsigned) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (with_bot.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_71991 (h0 : functor.add_const (filter (has_pos_part pos)) name) : countable_Inter_filter (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_71992 (h0 : filter (distrib fun_info)) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_71993 (h0 : functor.add_const (topological_space (has_zero environment.implicit_infer_kind)) name) : @discrete_topology.{0} (has_zero.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (has_zero.{0} environment.implicit_infer_kind)) name h0)  := sorry --non-trivial
lemma new_lemma_71994 (h0 : topological_space (normed_group (has_top (has_top num)))) : path_connected_space (normed_group (has_top (has_top num))) := sorry --non-trivial
lemma new_lemma_71995 (h0 : semiring (has_nndist (normed_comm_ring linarith.comp))) : is_noetherian_ring (has_nndist (normed_comm_ring linarith.comp)) := sorry --non-trivial
lemma new_lemma_71996 (h0 : filter (topological_space (div_inv_monoid fun_info))) : @t0_space.{0} (div_inv_monoid.{0} fun_info) (@filter.Limsup.{0} (topological_space.{0} (div_inv_monoid.{0} fun_info)) (@complete_lattice.to_conditionally_complete_lattice.{0} (topological_space.{0} (div_inv_monoid.{0} fun_info)) (@topological_space.complete_lattice.{0} (div_inv_monoid.{0} fun_info))) h0)  := sorry --non-trivial
lemma new_lemma_71997 (h1 : complete_lattice (semi_normed_ring string_imp)) : is_compactly_generated (semi_normed_ring string_imp) := sorry --non-trivial
lemma new_lemma_71998 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @normal_space.{0} (boolean_algebra.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (boolean_algebra.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_71999 (h0 : not (uniform_space (with_one (semiring num)) -> false)) : @separated_space.{0} (with_one.{0} (semiring.{0} num)) (@classical.by_contradiction'.{1} (uniform_space.{0} (with_one.{0} (semiring.{0} num))) h0)  := sorry --non-trivial
