import imports
lemma new_lemma_128000 (h0 : topological_space (canonically_ordered_add_monoid congr_arg_kind)) : t1_space (canonically_ordered_add_monoid congr_arg_kind) := sorry --non-trivial
lemma new_lemma_128001 (h0 : not (topological_space (mul_zero_class empty) -> false)) : @irreducible_space.{0} (mul_zero_class.{0} empty) (@classical.by_contradiction'.{1} (topological_space.{0} (mul_zero_class.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_128002 (h0 : not (complete_lattice (has_compl to_additive.value_type) -> false)) : @complete_lattice.is_Sup_finite_compact.{0} (has_compl.{0} to_additive.value_type) (@classical.by_contradiction'.{1} (complete_lattice.{0} (has_compl.{0} to_additive.value_type)) h0)  := sorry --non-trivial
lemma new_lemma_128003 (h0 : not (topological_space (option unsigned) -> false)) : @totally_disconnected_space.{0} (option.{0} unsigned) (@classical.by_contradiction'.{1} (topological_space.{0} (option.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_128004 (h0 : not (function.extfun (Type -> Type) (function.extfun Type) -> false)) : @is_atomistic.{0} (with_bot.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) (@classical.by_contradiction'.{2} (function.extfun.{2 2} (Type → Type) (function.extfun.{2 1} Type)) h0) complete_lattice.{0}) (with_bot.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_128005 (h0 : topological_space (has_Inf (has_Inf (has_Inf linarith.comp)))) : t0_space (has_Inf (has_Inf (has_Inf linarith.comp))) := sorry --non-trivial
lemma new_lemma_128006 (h0 : finset (generalized_boolean_algebra (has_add Type))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_128007 (h0 : complete_lattice (preorder (ordered_cancel_comm_monoid empty))) : is_compactly_generated (preorder (ordered_cancel_comm_monoid empty)) := sorry --non-trivial
lemma new_lemma_128008 (h0 : function.extfun Type topological_space) : @discrete_topology.{0} (random_gen.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (random_gen.{0} empty))  := sorry --non-trivial
lemma new_lemma_128009 (h0 : function.extfun Type add_group) : @is_add_cyclic.{0} (canonically_linear_ordered_monoid.{0} real) (@function.extfun_app.{2 1} Type add_group.{0} h0 (canonically_linear_ordered_monoid.{0} real))  := sorry --non-trivial
lemma new_lemma_128010 (h0 : function.extfun Type list) : list.nodup (function.extfun_app h0 (canonically_ordered_comm_semiring congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_128011 (h1 : topological_space (has_zero linarith.ineq)) : path_connected_space (has_zero linarith.ineq) := sorry --non-trivial
lemma new_lemma_128012 (h0 : topological_space (has_pos_part real)) : normal_space (has_pos_part real) := sorry --non-trivial
lemma new_lemma_128013 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @complete_space.{1} (finset.{1} Type) (@function.extfun_app.{3 2} (Type 1) uniform_space.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 uniform_space.{1}) (finset.{1} Type))  := sorry --non-trivial
lemma new_lemma_128014 (h0 : functor.add_const (topological_space (measure_theory.measure_space congr_arg_kind)) unsigned) : @totally_disconnected_space.{0} (measure_theory.measure_space.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (measure_theory.measure_space.{0} congr_arg_kind)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_128015 (h0 : topological_space (with_bot (random_gen (random_gen to_additive.value_type)))) : irreducible_space (with_bot (random_gen (random_gen to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_128016 (h0 : not (group (semiring to_additive.value_type) -> false)) : @normalizer_condition.{0} (semiring.{0} to_additive.value_type) (@classical.by_contradiction'.{1} (group.{0} (semiring.{0} to_additive.value_type)) h0)  := sorry --non-trivial
lemma new_lemma_128017 (h0 : complete_lattice (complete_linear_order (semiring unsigned))) : is_atomistic (complete_linear_order (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_128018 (h0 : functor.add_const (topological_space (semigroup Type)) name) : @irreducible_space.{1} (semigroup.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (semigroup.{1} Type)) name h0)  := sorry --non-trivial
lemma new_lemma_128019 (h0 : not (ring (add_left_cancel_monoid (random_gen (has_nnnorm linarith.comp_source))) -> false)) : @strong_rank_condition.{0} (add_left_cancel_monoid.{0} (random_gen.{0} (has_nnnorm.{0} linarith.comp_source))) (@classical.by_contradiction'.{1} (ring.{0} (add_left_cancel_monoid.{0} (random_gen.{0} (has_nnnorm.{0} linarith.comp_source)))) h0)  := sorry --non-trivial
lemma new_lemma_128020 (h0 : prod (linear_order (semiring empty)) (linear_order (semiring empty))) : id_rel h0 := sorry --non-trivial
lemma new_lemma_128021 (h0 : empty) : @rank_condition.{0} (linear_ordered_add_comm_group.{0} string_imp) (@empty.elim.{1} (ring.{0} (linear_ordered_add_comm_group.{0} string_imp)) h0)  := sorry --non-trivial
lemma new_lemma_128022 (h0 : topological_space (has_ssubset fun_info)) : totally_disconnected_space (has_ssubset fun_info) := sorry --non-trivial
lemma new_lemma_128023 (h0 : not (group (add_right_cancel_monoid empty) -> false)) : @normalizer_condition.{0} (add_right_cancel_monoid.{0} empty) (@classical.by_contradiction'.{1} (group.{0} (add_right_cancel_monoid.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_128024 (h0 : filter (cancel_monoid (has_nndist (has_nndist pos)))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_128025 (h0 : ring (has_top (has_top to_additive.value_type))) : strong_rank_condition (has_top (has_top to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_128026 (h0 : not (function.extfun (finset Type) (has_mem.mem empty) -> false)) : irreducible_space empty := sorry --non-trivial
lemma new_lemma_128027 (h0 : filter (boolean_algebra (has_add environment.implicit_infer_kind))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_128028 (h0 : finset (normed_comm_ring (has_zero linarith.comp))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_128029 (h0 : group (boolean_algebra.core (option unsigned))) : normalizer_condition (boolean_algebra.core (option unsigned)) := sorry --non-trivial
lemma new_lemma_128030 (h0 : filter (with_one (has_norm (has_norm fun_info)))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_128031 (h0 : group (distrib_lattice (has_nnnorm linarith.comp_source))) : group.fg (distrib_lattice (has_nnnorm linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_128032 (h1 : not (add_group (normed_field fun_info) -> false)) : @is_add_cyclic.{0} (normed_field.{0} fun_info) (@classical.by_contradiction'.{1} (add_group.{0} (normed_field.{0} fun_info)) h1)  := sorry --non-trivial
lemma new_lemma_128033 (h0 : functor.add_const (topological_space (add_comm_monoid Type)) (finset pos)) : @regular_space.{1} (add_comm_monoid.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (add_comm_monoid.{1} Type)) (finset.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_128034 (h0 : functor.add_const (group (normed_comm_ring Type)) environment.implicit_infer_kind) : @is_cyclic.{1} (normed_comm_ring.{1} Type) (@functor.add_const.run.{1 0} (group.{1} (normed_comm_ring.{1} Type)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_128035 (h0 : monoid (ring (option empty))) : monoid.fg (ring (option empty)) := sorry --non-trivial
lemma new_lemma_128036 (h0 : ring (has_neg_part (normed_comm_ring unsigned))) : is_principal_ideal_ring (has_neg_part (normed_comm_ring unsigned)) := sorry --non-trivial
lemma new_lemma_128037 (h0 : finset (ring name)) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_128038 (h0 : ulower (fin has_zero.zero)) : @Lim.{0} Prop sierpinski_space (@nonempty_of_inhabited.{1} Prop sort.inhabited.{0}) (@matrix.vec_empty.{0} (filter.{0} Prop) (@id.{1} (fin (@has_zero.zero.{0} nat nat.has_zero)) (@ulower.up.{0} (fin (@has_zero.zero.{0} nat nat.has_zero)) (encodable.fin (@has_zero.zero.{0} nat nat.has_zero)) h0)))  := sorry --non-trivial
lemma new_lemma_128039 (h0 : finset (ordered_ring (option unsigned))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_128040 (h0 : not (group (linear_ordered_add_comm_group char) -> false)) : @is_cyclic.{0} (linear_ordered_add_comm_group.{0} char) (@classical.by_contradiction'.{1} (group.{0} (linear_ordered_add_comm_group.{0} char)) h0)  := sorry --non-trivial
lemma new_lemma_128041 (h0 : functor.add_const (function.extfun Type topological_space) name) : @t1_space.{0} (generalized_boolean_algebra.{0} real) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) name h0) (generalized_boolean_algebra.{0} real))  := sorry --non-trivial
lemma new_lemma_128042 (h0 : not (ring (has_append (has_lt linarith.ineq)) -> false)) : @is_domain.{0} (has_append.{0} (has_lt.{0} linarith.ineq)) (@classical.by_contradiction'.{1} (ring.{0} (has_append.{0} (has_lt.{0} linarith.ineq))) h0)  := sorry --non-trivial
lemma new_lemma_128043 (h0 : uniform_space (ordered_comm_monoid (finset (boolean_algebra (has_neg (has_neg name)))))) : complete_space (ordered_comm_monoid (finset (boolean_algebra (has_neg (has_neg name))))) := sorry --non-trivial
lemma new_lemma_128044 (h0 : function.extfun Type group) : @is_cyclic.{0} (has_nndist.{0} empty) (@function.extfun_app.{2 1} Type group.{0} h0 (has_nndist.{0} empty))  := sorry --non-trivial
lemma new_lemma_128045 (h0 : topological_space (has_ssubset (has_ssubset fun_info))) : path_connected_space (has_ssubset (has_ssubset fun_info)) := sorry --non-trivial
lemma new_lemma_128046 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @has_exists_mul_of_le.{0} (sub_neg_monoid.{0} name) (@function.extfun_app.{2 1} Type ordered_comm_monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ordered_comm_monoid.{0}) (sub_neg_monoid.{0} name))  := sorry --non-trivial
lemma new_lemma_128047 (h0 : uniform_space (finset (has_add (has_add pos)))) : complete_space (finset (has_add (has_add pos))) := sorry --non-trivial
lemma new_lemma_128048 (h0 : function.extfun nat fin) : @sequential_space.{0} (ordered_comm_ring.{0} real) (@matrix.vec_empty.{0} (topological_space.{0} (ordered_comm_ring.{0} real)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_128049 (h0 : functor.add_const (function.extfun Type topological_space) name) : @normal_space.{0} (semigroup.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) name h0) (semigroup.{0} name))  := sorry --non-trivial
lemma new_lemma_128050 (h0 : topological_space (option (option unsigned))) : irreducible_space (option (option unsigned)) := sorry --non-trivial
lemma new_lemma_128051 (h0 : not (function.extfun Type topological_space -> false)) : @irreducible_space.{0} (with_bot.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (with_bot.{0} num))  := sorry --non-trivial
lemma new_lemma_128052 (h0 : add_monoid (add_comm_monoid (mul_zero_class pos))) : add_monoid.fg (add_comm_monoid (mul_zero_class pos)) := sorry --non-trivial
lemma new_lemma_128053 (h0 : topological_space (boolean_algebra (finset pos))) : path_connected_space (boolean_algebra (finset pos)) := sorry --non-trivial
lemma new_lemma_128054 (h0 : has_mem.mem (with_one linarith.comp) has_emptyc.emptyc) : @strong_rank_condition.{0} (with_one.{0} linarith.comp) (@finset.pi.empty.{1 0} Type ring.{0} (with_one.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_128055 (h0 : topological_space (has_add linarith.comp)) : regular_space (has_add linarith.comp) := sorry --non-trivial
lemma new_lemma_128056 (h1 : filter (fintype char)) : filter.ne_bot h1 := sorry --non-trivial
lemma new_lemma_128057 (h0 : uniform_space (linear_ordered_semiring congr_arg_kind)) : complete_space (linear_ordered_semiring congr_arg_kind) := sorry --non-trivial
lemma new_lemma_128058 (h0 : function.extfun Type topological_space) : @preirreducible_space.{0} (comm_group.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (comm_group.{0} name))  := sorry --non-trivial
lemma new_lemma_128059 (h0 : functor.comp add_group pseudo_metric_space name) : @is_add_cyclic.{0} (pseudo_metric_space.{0} name) (@functor.comp.run.{0 0 0} add_group.{0} pseudo_metric_space.{0} name h0)  := sorry --non-trivial
lemma new_lemma_128060 (h1 : preorder ereal) (h2 h3 : set ereal) : set.is_pwo (set.inter h2 h3) := sorry --non-trivial
lemma new_lemma_128061 (h0 : add_monoid (semigroup (ring Type))) : add_monoid.fg (semigroup (ring Type)) := sorry --non-trivial
lemma new_lemma_128062 (h0 : functor.add_const (topological_space (complete_distrib_lattice pos)) (has_neg_part Type)) : @irreducible_space.{0} (complete_distrib_lattice.{0} pos) (@functor.add_const.run.{0 1} (topological_space.{0} (complete_distrib_lattice.{0} pos)) (has_neg_part.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_128063 (h1 : add_group (distrib fun_info)) : is_add_cyclic (distrib fun_info) := sorry --non-trivial
lemma new_lemma_128064 (h0 : topological_space (comm_group (cancel_monoid (option num)))) : totally_separated_space (comm_group (cancel_monoid (option num))) := sorry --non-trivial
lemma new_lemma_128065 (h0 : ring (semigroup (comm_group unsigned))) : is_principal_ideal_ring (semigroup (comm_group unsigned)) := sorry --non-trivial
lemma new_lemma_128066 (h0 : functor.add_const (complete_lattice (ring ennreal)) unsigned) : @is_compactly_generated.{0} (ring.{0} ennreal) (@functor.add_const.run.{0 0} (complete_lattice.{0} (ring.{0} ennreal)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_128067 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : finset.nonempty (function.extfun_app (function.extfun_app h0 finset) (has_zero linarith.comp)) := sorry --non-trivial
lemma new_lemma_128068 (h0 : function.extfun Type (functor.add_const (list (bin_tree empty)))) : list.nodup (functor.add_const.run (function.extfun_app h0 empty)) := sorry --non-trivial
lemma new_lemma_128069 (h0 : complete_lattice (has_neg name)) : is_atomistic (has_neg name) := sorry --non-trivial
lemma new_lemma_128070 (h0 : functor.add_const (topological_space (ordered_comm_monoid pos)) pos) : @normal_space.{0} (ordered_comm_monoid.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (ordered_comm_monoid.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_128071 (h0 : char -> ereal -> Prop) : relator.right_total h0 := sorry --non-trivial
lemma new_lemma_128072 (h0 : pnat) (h1 : nat) (h2 : vector pnat (nat.succ h1)) : pnat.coprime h0 (vector.head h2) := sorry --non-trivial
lemma new_lemma_128073 (h0 : ring (has_neg (has_Inf Type))) : rank_condition (has_neg (has_Inf Type)) := sorry --non-trivial
lemma new_lemma_128074 (h0 : topological_space (has_lt fun_info)) : t0_space (has_lt fun_info) := sorry --non-trivial
lemma new_lemma_128075 (h0 : functor.add_const (add_group (has_nndist name)) (has_nndist Type)) : @is_add_cyclic.{0} (has_nndist.{0} name) (@functor.add_const.run.{0 1} (add_group.{0} (has_nndist.{0} name)) (has_nndist.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_128076 (h0 : function.extfun (Type 1) topological_space) : @totally_separated_space.{1} (boolean_algebra.core.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} h0 (boolean_algebra.core.{1} Type))  := sorry --non-trivial
lemma new_lemma_128077 (h0 : ring (has_compl std_gen)) : rank_condition (has_compl std_gen) := sorry --non-trivial
lemma new_lemma_128078 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_domain.{0} (has_ssubset.{0} linarith.ineq) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (has_ssubset.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_128079 (h0 : has_mem.mem complete_lattice has_emptyc.emptyc) : @is_atomistic.{0} unsigned (@function.extfun_app.{2 1} Type complete_lattice.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) complete_lattice.{0} h0) unsigned)  := sorry --non-trivial
lemma new_lemma_128080 (h0 : functor.add_const (ordered_add_comm_monoid (has_Inf name)) pos) : @archimedean.{0} (has_Inf.{0} name) (@functor.add_const.run.{0 0} (ordered_add_comm_monoid.{0} (has_Inf.{0} name)) pos h0)  := sorry --non-trivial
lemma new_lemma_128081 (h0 : topological_space (canonically_ordered_add_monoid (option (option (option (option empty)))))) : path_connected_space (canonically_ordered_add_monoid (option (option (option (option empty))))) := sorry --non-trivial
lemma new_lemma_128082 (h0 : cancel_comm_monoid_with_zero (canonically_ordered_comm_semiring (has_add ennreal))) : unique_factorization_monoid (canonically_ordered_comm_semiring (has_add ennreal)) := sorry --non-trivial
lemma new_lemma_128083 (h0 : group (metric_space (has_norm empty))) : is_cyclic (metric_space (has_norm empty)) := sorry --non-trivial
lemma new_lemma_128084 (h0 : list (has_bot empty)) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_128085 (h0 : functor.add_const (uniform_space (partial_order num)) (semiring unsigned)) : @separated_space.{0} (partial_order.{0} num) (@functor.add_const.run.{0 0} (uniform_space.{0} (partial_order.{0} num)) (semiring.{0} unsigned) h0)  := sorry --non-trivial
lemma new_lemma_128086 (h0 : add_group (generalized_boolean_algebra (sub_neg_monoid Type))) : is_add_cyclic (generalized_boolean_algebra (sub_neg_monoid Type)) := sorry --non-trivial
lemma new_lemma_128087 (h0 : functor.add_const (ring (add_comm_monoid unsigned)) environment.implicit_infer_kind) : @rank_condition.{0} (add_comm_monoid.{0} unsigned) (@functor.add_const.run.{0 0} (ring.{0} (add_comm_monoid.{0} unsigned)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_128088 (h1 : topological_space char) (h2 : preorder char) : order_topology char := sorry --non-trivial
lemma new_lemma_128089 (h0 : not (complete_lattice (complete_linear_order congr_arg_kind) -> false)) : @is_compactly_generated.{0} (complete_linear_order.{0} congr_arg_kind) (@classical.by_contradiction'.{1} (complete_lattice.{0} (complete_linear_order.{0} congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_128090 (h0 : function.extfun Type topological_space) : @regular_space.{0} (has_neg_part.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_neg_part.{0} name))  := sorry --non-trivial
lemma new_lemma_128091 (h0 : topological_space unsigned) : preirreducible_space unsigned := sorry --non-trivial
lemma new_lemma_128092 (h1 : not (functor.comp complete_lattice normed_field string_imp -> false)) : @is_compactly_generated.{0} (normed_field.{0} string_imp) (@functor.comp.run.{0 0 0} complete_lattice.{0} normed_field.{0} string_imp (@classical.by_contradiction'.{1} (functor.comp.{0 0 0} complete_lattice.{0} normed_field.{0} string_imp) h1))  := sorry --non-trivial
lemma new_lemma_128093 (h0 : topological_space (finset (has_to_string (finset pos)))) : topological_space.separable_space (finset (has_to_string (finset pos))) := sorry --non-trivial
lemma new_lemma_128094 (h0 : ordered_add_comm_monoid (canonically_ordered_monoid (sub_neg_monoid Type))) : archimedean (canonically_ordered_monoid (sub_neg_monoid Type)) := sorry --non-trivial
lemma new_lemma_128095 (h0 : functor.add_const (topological_space (free_add_monoid unsigned)) num) : @locally_compact_space.{0} (free_add_monoid.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (free_add_monoid.{0} unsigned)) num h0)  := sorry --non-trivial
lemma new_lemma_128096 (h0 : cancel_comm_monoid_with_zero (finset pos)) : unique_factorization_monoid (finset pos) := sorry --non-trivial
lemma new_lemma_128097 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @t0_space.{0} (canonically_ordered_comm_semiring.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (canonically_ordered_comm_semiring.{0} name))  := sorry --non-trivial
lemma new_lemma_128098 (h0 : prod (cancel_monoid environment.implicit_infer_kind) (cancel_monoid environment.implicit_infer_kind)) : id_rel h0 := sorry --non-trivial
lemma new_lemma_128099 (h0 : functor.add_const (group (normed_comm_ring linarith.comp)) (has_to_string Type)) : @group.fg.{0} (normed_comm_ring.{0} linarith.comp) (@functor.add_const.run.{0 1} (group.{0} (normed_comm_ring.{0} linarith.comp)) (has_to_string.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_128100 (h0 : topological_space (add_comm_monoid num)) : discrete_topology (add_comm_monoid num) := sorry --non-trivial
lemma new_lemma_128101 (h0 : topological_space (canonically_ordered_comm_semiring pos)) : regular_space (canonically_ordered_comm_semiring pos) := sorry --non-trivial
lemma new_lemma_128102 (h0 : topological_space (with_one (random_gen (has_norm (with_one to_additive.value_type))))) : t0_space (with_one (random_gen (has_norm (with_one to_additive.value_type)))) := sorry --non-trivial
lemma new_lemma_128103 (h0 : topological_space (finset ennreal)) : locally_compact_space (finset ennreal) := sorry --non-trivial
lemma new_lemma_128104 (h0 : functor.add_const (topological_space (finset name)) name) : @sequential_space.{0} (finset.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (finset.{0} name)) name h0)  := sorry --non-trivial
lemma new_lemma_128105 (h0 : filter (complete_semilattice_Sup string_imp)) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_128106 (h0 : topological_space (has_to_string (boolean_algebra (boolean_algebra name)))) : totally_disconnected_space (has_to_string (boolean_algebra (boolean_algebra name))) := sorry --non-trivial
lemma new_lemma_128107 (h0 : function.extfun Type topological_space) : @preirreducible_space.{0} (canonically_ordered_comm_semiring.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (canonically_ordered_comm_semiring.{0} pos))  := sorry --non-trivial
lemma new_lemma_128108 (h0 : functor.add_const (cancel_comm_monoid_with_zero (boolean_algebra.core unsigned)) unsigned) : @unique_factorization_monoid.{0} (boolean_algebra.core.{0} unsigned) (@functor.add_const.run.{0 0} (cancel_comm_monoid_with_zero.{0} (boolean_algebra.core.{0} unsigned)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_128109 (h0 : topological_space (semigroup (option pos))) : discrete_topology (semigroup (option pos)) := sorry --non-trivial
lemma new_lemma_128110 (h0 : functor.comp topological_space semigroup name) : @sequential_space.{0} (semigroup.{0} name) (@functor.comp.run.{0 0 0} topological_space.{0} semigroup.{0} name (@functor.comp.run.{0 0 0} topological_space.{0} semigroup.{0} name (@functor.comp.run.{0 0 0} topological_space.{0} semigroup.{0} name (@functor.comp.run.{0 0 0} topological_space.{0} semigroup.{0} name (@functor.comp.run.{0 0 0} topological_space.{0} semigroup.{0} name (@functor.comp.run.{0 0 0} topological_space.{0} semigroup.{0} name (@functor.comp.run.{0 0 0} topological_space.{0} semigroup.{0} name h0)))))))  := sorry --non-trivial
lemma new_lemma_128111 (h1 : group (dlist (random_gen fun_info))) : is_cyclic (dlist (random_gen fun_info)) := sorry --non-trivial
lemma new_lemma_128112 (h0 : topological_space (with_bot (semiring empty))) : path_connected_space (with_bot (semiring empty)) := sorry --non-trivial
lemma new_lemma_128113 (h0 : functor.add_const (topological_space (option unsigned)) congr_arg_kind) : @discrete_topology.{0} (option.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (option.{0} unsigned)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_128114 (h0 : topological_space (has_bot (has_add pos))) : discrete_topology (has_bot (has_add pos)) := sorry --non-trivial
lemma new_lemma_128115 (h0 : add_zero_class (random_gen reducibility_hints)) (h1 : ring (random_gen (add_submonoid (random_gen reducibility_hints)))) : rank_condition (random_gen (add_submonoid (random_gen reducibility_hints))) := sorry --non-trivial
lemma new_lemma_128116 (h0 : topological_space (semigroup (has_to_string Type))) : sequential_space (semigroup (has_to_string Type)) := sorry --non-trivial
lemma new_lemma_128117 (h0 : topological_space (has_nndist (has_to_string Type))) : t1_space (has_nndist (has_to_string Type)) := sorry --non-trivial
lemma new_lemma_128118 (h0 : uniform_space (has_top (has_norm to_additive.value_type))) : separated_space (has_top (has_norm to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_128119 (h0 : topological_space (simple_graph (has_add (ring Type)))) : preirreducible_space (simple_graph (has_add (ring Type))) := sorry --non-trivial
lemma new_lemma_128120 (h0 : ordered_add_comm_monoid (mul_zero_class pos)) : archimedean (mul_zero_class pos) := sorry --non-trivial
lemma new_lemma_128121 (h0 : function.extfun (((Type -> Type) -> Type 1) -> Type 1) (function.extfun ((Type -> Type) -> Type 1))) : @monoid.fg.{0} (has_top.{0} fun_info) (@function.extfun_app.{2 1} Type monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) (@function.extfun_app.{3 2} ((Type → Type) → Type 1) (function.extfun.{2 2} (Type → Type)) (@function.extfun_app.{3 3} (((Type → Type) → Type 1) → Type 1) (function.extfun.{3 2} ((Type → Type) → Type 1)) h0 (function.extfun.{2 2} (Type → Type))) (function.extfun.{2 1} Type)) monoid.{0}) (has_top.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_128122 (h0 : functor.add_const (ordered_comm_monoid (ring environment.implicit_infer_kind)) (has_neg_part pos)) : @has_exists_mul_of_le.{0} (ring.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (ordered_comm_monoid.{0} (ring.{0} environment.implicit_infer_kind)) (has_neg_part.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_128123 (h0 : group (semigroup (ring linarith.comp))) : normalizer_condition (semigroup (ring linarith.comp)) := sorry --non-trivial
lemma new_lemma_128124 (h0 : functor.add_const (ordered_comm_monoid (ring (boolean_algebra name))) environment.implicit_infer_kind) : @has_exists_mul_of_le.{0} (ring.{0} (boolean_algebra.{0} name)) (@functor.add_const.run.{0 0} (ordered_comm_monoid.{0} (ring.{0} (boolean_algebra.{0} name))) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_128125 (h0 : topological_space (metric_space (has_norm (has_norm linarith.comp)))) : discrete_topology (metric_space (has_norm (has_norm linarith.comp))) := sorry --non-trivial
lemma new_lemma_128126 (h0 : functor.add_const (finset (has_to_string ennreal)) pos) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_128127 (h0 : topological_space (cancel_monoid (normed_comm_ring (normed_comm_ring name)))) : normal_space (cancel_monoid (normed_comm_ring (normed_comm_ring name))) := sorry --non-trivial
lemma new_lemma_128128 (h0 : ring (denumerable (topological_space char))) : is_domain (denumerable (topological_space char)) := sorry --non-trivial
lemma new_lemma_128129 (h0 : topological_space (denumerable (mul_one_class (has_nnnorm char)))) : t0_space (denumerable (mul_one_class (has_nnnorm char))) := sorry --non-trivial
lemma new_lemma_128130 (h0 : functor.add_const (add_monoid (has_nndist unsigned)) Type) : @add_monoid.fg.{0} (has_nndist.{0} unsigned) (@functor.add_const.run.{0 1} (add_monoid.{0} (has_nndist.{0} unsigned)) Type h0)  := sorry --non-trivial
lemma new_lemma_128131 (h0 : add_monoid (complete_distrib_lattice (complete_distrib_lattice real))) : add_monoid.fg (complete_distrib_lattice (complete_distrib_lattice real)) := sorry --non-trivial
lemma new_lemma_128132 (h0 : filter (has_bot (option (option (semiring empty))))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_128133 (h0 : topological_space (has_top (semiring unsigned))) : preirreducible_space (has_top (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_128134 (h0 : function.extfun Type filter) : filter.ne_bot (function.extfun_app h0 (linear_ordered_comm_monoid_with_zero empty)) := sorry --non-trivial
lemma new_lemma_128135 (h0 : complete_lattice (has_union num)) : is_compactly_generated (has_union num) := sorry --non-trivial
lemma new_lemma_128136 (h0 : topological_space (has_top congr_arg_kind)) : topological_space.separable_space (has_top congr_arg_kind) := sorry --non-trivial
lemma new_lemma_128137 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @path_connected_space.{0} (has_union.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_union.{0} empty))  := sorry --non-trivial
lemma new_lemma_128138 (h2 : complete_lattice (has_top to_additive.value_type)) : complete_lattice.is_Sup_finite_compact (has_top to_additive.value_type) := sorry --non-trivial
lemma new_lemma_128139 (h0 : function.extfun Type topological_space) : @normal_space.{0} (normed_group.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (normed_group.{0} num))  := sorry --non-trivial
lemma new_lemma_128140 (h0 : uniform_space (ordered_comm_monoid real)) : separated_space (ordered_comm_monoid real) := sorry --non-trivial
lemma new_lemma_128141 (h0 : function.extfun Type uniform_space) : @complete_space.{0} (semiring.{0} linarith.ineq) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (semiring.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_128142 (h0 : ring (measurable_space (has_norm (has_norm num)))) : is_domain (measurable_space (has_norm (has_norm num))) := sorry --non-trivial
lemma new_lemma_128143 (h0 : topological_space (generalized_boolean_algebra (ring (ring name)))) : t1_space (generalized_boolean_algebra (ring (ring name))) := sorry --non-trivial
lemma new_lemma_128144 (h0 : ulower Prop) : @ulower.up.{0} Prop encodable.Prop (@id.{1} (@ulower.{0} Prop encodable.Prop) h0)  := sorry --non-trivial
lemma new_lemma_128145 (h0 : list (ordered_cancel_add_comm_monoid (has_to_string congr_arg_kind))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_128146 (h0 : ring (has_top (semiring (random_gen linarith.comp_source)))) : rank_condition (has_top (semiring (random_gen linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_128147 (h0 : set linarith.ineq) : set.infinite h0 := sorry --non-trivial
lemma new_lemma_128148 (h1 : topological_space (semiring num)) : t0_space (semiring num) := sorry --non-trivial
lemma new_lemma_128149 (h0 : prod (measure_theory.measure_space num) (measure_theory.measure_space num)) : id_rel h0 := sorry --non-trivial
lemma new_lemma_128150 (h0 : functor.comp ordered_add_comm_monoid boolean_algebra name) : @archimedean.{0} (boolean_algebra.{0} name) (@functor.comp.run.{0 0 0} ordered_add_comm_monoid.{0} boolean_algebra.{0} name h0)  := sorry --non-trivial
lemma new_lemma_128151 (h0 : add_group (nondiscrete_normed_field reducibility_hints)) : is_add_cyclic (nondiscrete_normed_field reducibility_hints) := sorry --non-trivial
lemma new_lemma_128152 (h0 : has_top empty -> linarith.comp -> linarith.comp) (h1 : linarith.comp -> linarith.comp -> Prop) : contravariant_class (has_top empty) linarith.comp h0 h1 := sorry --non-trivial
lemma new_lemma_128153 (h0 : topological_space (with_one (random_gen (has_inv (random_gen string_imp))))) : totally_separated_space (with_one (random_gen (has_inv (random_gen string_imp)))) := sorry --non-trivial
lemma new_lemma_128154 (h2 : topological_space (comm_ring (random_gen (random_gen (random_gen char))))) : totally_disconnected_space (comm_ring (random_gen (random_gen (random_gen char)))) := sorry --non-trivial
lemma new_lemma_128155 (h0 : functor.add_const Prop (has_neg (has_add (finset Type)))) : functor.add_const.run h0 := sorry --non-trivial
lemma new_lemma_128156 (h0 : ring (cancel_monoid (has_add environment.implicit_infer_kind))) : rank_condition (cancel_monoid (has_add environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_128157 (h0 : filter (semi_normed_comm_ring (has_nnnorm linarith.ineq))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_128158 (h0 : functor.add_const (group (ordered_comm_ring pos)) pos) : @is_cyclic.{0} (ordered_comm_ring.{0} pos) (@functor.add_const.run.{0 0} (group.{0} (ordered_comm_ring.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_128159 (h1 : add_group (add_comm_semigroup (mul_one_class linarith.ineq))) : is_add_cyclic (add_comm_semigroup (mul_one_class linarith.ineq)) := sorry --non-trivial
lemma new_lemma_128160 (h0 : has_zero pos -> has_zero pos -> Prop) : is_antisymm (has_zero pos) h0 := sorry --non-trivial
lemma new_lemma_128161 (h0 : functor.add_const (topological_space (ring Type)) (has_pos_part pos)) : @irreducible_space.{1} (ring.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (ring.{1} Type)) (has_pos_part.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_128162 (h0 : add_group (normed_group char)) : is_add_cyclic (normed_group char) := sorry --non-trivial
lemma new_lemma_128163 (h0 : function.extfun Type uniform_space) : @complete_space.{0} (measurable_space.dynkin_system.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (measurable_space.dynkin_system.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_128164 (h0 : ordered_comm_monoid (has_neg (has_to_string unsigned))) : has_exists_mul_of_le (has_neg (has_to_string unsigned)) := sorry --non-trivial
lemma new_lemma_128165 (h0 : has_mem.mem (has_one empty) has_emptyc.emptyc) : @totally_separated_space.{0} (has_one.{0} empty) (@finset.pi.empty.{1 0} Type topological_space.{0} (has_one.{0} empty) h0)  := sorry --non-trivial
lemma new_lemma_128166 (h0 : functor.add_const (filter (has_neg pos)) pos) : filter.ne_bot (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_128167 (h1 : ring (has_ssubset std_gen)) : is_domain (has_ssubset std_gen) := sorry --non-trivial
lemma new_lemma_128168 (h0 : ordered_comm_monoid (add_comm_monoid (comm_group name))) : has_exists_mul_of_le (add_comm_monoid (comm_group name)) := sorry --non-trivial
lemma new_lemma_128169 (h0 : function.extfun Type ring) : @is_domain.{0} (has_pos_part.{0} linarith.comp) (@function.extfun_app.{2 1} Type ring.{0} h0 (has_pos_part.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_128170 (h0 : ring (semigroup (option (option (option unsigned))))) : rank_condition (semigroup (option (option (option unsigned)))) := sorry --non-trivial
lemma new_lemma_128171 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : list.nodup (function.extfun_app (function.extfun_app h0 list) (has_norm fun_info)) := sorry --non-trivial
lemma new_lemma_128172 (h0 : fin has_zero.zero) : @monoid.fg.{0} (ring.{0} pos) (@matrix.vec_empty.{0} (monoid.{0} (ring.{0} pos)) h0)  := sorry --non-trivial
lemma new_lemma_128173 (h0 : add_group (linear_order congr_arg_kind)) : is_add_cyclic (linear_order congr_arg_kind) := sorry --non-trivial
lemma new_lemma_128174 (h0 : function.extfun Type (functor.add_const (complete_lattice (left_cancel_semigroup unsigned)))) : @is_compactly_generated.{0} (left_cancel_semigroup.{0} unsigned) (@functor.add_const.run.{0 0} (complete_lattice.{0} (left_cancel_semigroup.{0} unsigned)) (semiring.{0} unsigned) (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (complete_lattice.{0} (left_cancel_semigroup.{0} unsigned))) h0 (semiring.{0} unsigned)))  := sorry --non-trivial
lemma new_lemma_128175 (h0 : functor.add_const (complete_lattice (finset unsigned)) pos) : @is_compactly_generated.{0} (finset.{0} unsigned) (@functor.add_const.run.{0 0} (complete_lattice.{0} (finset.{0} unsigned)) pos h0)  := sorry --non-trivial
lemma new_lemma_128176 (h2 : measurable_space environment.projection_info) (h3 : filter environment.projection_info) : filter.is_measurably_generated h3 := sorry --non-trivial
lemma new_lemma_128177 (h0 : functor.add_const (topological_space (omega_complete_partial_order unsigned)) unsigned) : @loc_path_connected_space.{0} (omega_complete_partial_order.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (omega_complete_partial_order.{0} unsigned)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_128178 (h1 : fun_info -> Prop) : Exists h1 := sorry --non-trivial
lemma new_lemma_128179 (h0 : ordered_comm_monoid (semigroup (option name))) : has_exists_mul_of_le (semigroup (option name)) := sorry --non-trivial
lemma new_lemma_128180 (h0 : ring (measurable_space linarith.comp)) : rank_condition (measurable_space linarith.comp) := sorry --non-trivial
lemma new_lemma_128181 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @unique_factorization_monoid.{1} (ordered_comm_monoid.{1} Type) (@function.extfun_app.{3 2} (Type 1) cancel_comm_monoid_with_zero.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 cancel_comm_monoid_with_zero.{1}) (ordered_comm_monoid.{1} Type))  := sorry --non-trivial
lemma new_lemma_128182 (h1 : group (with_bot (random_gen linarith.ineq))) : normalizer_condition (with_bot (random_gen linarith.ineq)) := sorry --non-trivial
lemma new_lemma_128183 (h0 : functor.add_const (topological_space (add_comm_monoid environment.implicit_infer_kind)) pos) : @discrete_topology.{0} (add_comm_monoid.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (add_comm_monoid.{0} environment.implicit_infer_kind)) pos h0)  := sorry --non-trivial
lemma new_lemma_128184 (h0 : uniform_space (boolean_algebra (has_add pos))) : separated_space (boolean_algebra (has_add pos)) := sorry --non-trivial
lemma new_lemma_128185 (h0 : topological_space (complete_semilattice_Sup (has_top unsigned))) : normal_space (complete_semilattice_Sup (has_top unsigned)) := sorry --non-trivial
lemma new_lemma_128186 (h1 : topological_space (add_cancel_comm_monoid (random_gen char))) : t0_space (add_cancel_comm_monoid (random_gen char)) := sorry --non-trivial
lemma new_lemma_128187 (h0 : topological_space (boolean_algebra.core (mul_zero_class name))) : t1_space (boolean_algebra.core (mul_zero_class name)) := sorry --non-trivial
lemma new_lemma_128188 (h0 : topological_space (has_add (has_Inf (boolean_algebra.core linarith.comp)))) : regular_space (has_add (has_Inf (boolean_algebra.core linarith.comp))) := sorry --non-trivial
lemma new_lemma_128189 (h0 : ring (ordered_comm_group empty) -> Prop) (h1 : function.extfun (ring (ordered_comm_group empty) -> Prop) Exists) : @strong_rank_condition.{0} (ordered_comm_group.{0} empty) (@classical.some.{1} (ring.{0} (ordered_comm_group.{0} empty)) h0 (@function.extfun_app.{1 0} (ring.{0} (ordered_comm_group.{0} empty) → Prop) (@Exists.{1} (ring.{0} (ordered_comm_group.{0} empty))) h1 (λ (x : ring.{0} (ordered_comm_group.{0} empty)), h0 x)))  := sorry --non-trivial
lemma new_lemma_128190 (h0 : topological_space (ordered_comm_monoid (has_Inf Type))) : topological_space.separable_space (ordered_comm_monoid (has_Inf Type)) := sorry --non-trivial
lemma new_lemma_128191 (h0 : topological_space (has_neg (add_comm_monoid name))) : normal_space (has_neg (add_comm_monoid name)) := sorry --non-trivial
lemma new_lemma_128192 (h0 : semiring (has_nndist (ring (has_neg Type)))) : is_noetherian_ring (has_nndist (ring (has_neg Type))) := sorry --non-trivial
lemma new_lemma_128193 (h0 : has_mem.mem (has_norm num) has_emptyc.emptyc) : @is_add_cyclic.{0} (has_norm.{0} num) (@finset.pi.empty.{1 0} Type add_group.{0} (has_norm.{0} num) h0)  := sorry --non-trivial
lemma new_lemma_128194 (h0 : function.extfun Type topological_space) : @totally_disconnected_space.{0} (with_bot.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (with_bot.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_128195 (h0 : add_group (has_norm num)) (h1 : function.extfun (finset (add_group (has_norm num))) (has_mem.mem h0)) : @add_subgroup.characteristic.{0} (has_norm.{0} num) h0 (@finset.pi.empty.{0 0} (add_group.{0} (has_norm.{0} num)) (@add_subgroup.{0} (has_norm.{0} num)) h0 (@function.extfun_app.{1 0} (finset.{0} (add_group.{0} (has_norm.{0} num))) (@has_mem.mem.{0 0} (add_group.{0} (has_norm.{0} num)) (finset.{0} (add_group.{0} (has_norm.{0} num))) (@finset.has_mem.{0} (add_group.{0} (has_norm.{0} num))) h0) h1 (@has_emptyc.emptyc.{0} (finset.{0} (add_group.{0} (has_norm.{0} num))) (@finset.has_emptyc.{0} (add_group.{0} (has_norm.{0} num))))))  := sorry --non-trivial
lemma new_lemma_128196 (h0 : topological_space (ordered_cancel_add_comm_monoid (option (option (option (option empty)))))) : path_connected_space (ordered_cancel_add_comm_monoid (option (option (option (option empty))))) := sorry --non-trivial
lemma new_lemma_128197 (h0 : topological_space (has_top linarith.comp)) : totally_separated_space (has_top linarith.comp) := sorry --non-trivial
lemma new_lemma_128198 (h0 : group (has_to_string (has_add (finset pos)))) : is_cyclic (has_to_string (has_add (finset pos))) := sorry --non-trivial
lemma new_lemma_128199 (h0 : functor.add_const (topological_space (boolean_algebra unsigned)) pos) : @totally_disconnected_space.{0} (boolean_algebra.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (boolean_algebra.{0} unsigned)) pos h0)  := sorry --non-trivial
lemma new_lemma_128200 (h1 : complete_lattice (has_add linarith.ineq)) : complete_lattice.is_Sup_finite_compact (has_add linarith.ineq) := sorry --non-trivial
lemma new_lemma_128201 (h0 : uniform_space (encodable fun_info)) : complete_space (encodable fun_info) := sorry --non-trivial
lemma new_lemma_128202 (h0 : functor.add_const (ordered_comm_monoid (cancel_monoid name)) name) : @has_exists_mul_of_le.{0} (cancel_monoid.{0} name) (@functor.add_const.run.{0 0} (ordered_comm_monoid.{0} (cancel_monoid.{0} name)) name h0)  := sorry --non-trivial
lemma new_lemma_128203 (h0 : filter (has_neg_part (option pos))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_128204 (h0 : functor.add_const (function.extfun Type cancel_comm_monoid_with_zero) empty) : @unique_factorization_monoid.{0} (has_bot.{0} empty) (@function.extfun_app.{2 1} Type cancel_comm_monoid_with_zero.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type cancel_comm_monoid_with_zero.{0}) empty h0) (has_bot.{0} empty))  := sorry --non-trivial
lemma new_lemma_128205 (h0 : topological_space (ring (option (option pos)))) : t1_space (ring (option (option pos))) := sorry --non-trivial
lemma new_lemma_128206 (h0 : function.extfun Type topological_space) : @discrete_topology.{0} (filter.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (filter.{0} empty))  := sorry --non-trivial
lemma new_lemma_128207 (h0 : uniform_space (option num)) : separated_space (option num) := sorry --non-trivial
lemma new_lemma_128208 (h0 : function.extfun (Type 1) add_group) : @is_add_cyclic.{1} (canonically_ordered_monoid.{1} Type) (@function.extfun_app.{3 2} (Type 1) add_group.{1} h0 (canonically_ordered_monoid.{1} Type))  := sorry --non-trivial
lemma new_lemma_128209 (h0 : functor.add_const (topological_space (left_cancel_monoid unsigned)) (option (option empty))) : @totally_disconnected_space.{0} (left_cancel_monoid.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (left_cancel_monoid.{0} unsigned)) (option.{0} (option.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_128210 (h0 : functor.add_const (topological_space (boolean_algebra unsigned)) linarith.comp) : @sequential_space.{0} (boolean_algebra.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (boolean_algebra.{0} unsigned)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_128211 (h0 : add_group (normed_field (has_nnnorm fun_info))) : is_add_cyclic (normed_field (has_nnnorm fun_info)) := sorry --non-trivial
lemma new_lemma_128212 (h2 : set (ereal -> environment.projection_info)) : set.separates_points h2 := sorry --non-trivial
lemma new_lemma_128213 (h0 : functor.add_const (topological_space (comm_group pos)) name) : @preconnected_space.{0} (comm_group.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (comm_group.{0} pos)) name h0)  := sorry --non-trivial
lemma new_lemma_128214 (h0 : function.extfun Type ring) : @is_principal_ideal_ring.{0} (simple_graph.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type ring.{0} h0 (simple_graph.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_128215 (h0 : topological_space (sub_neg_monoid pos)) : loc_path_connected_space (sub_neg_monoid pos) := sorry --non-trivial
lemma new_lemma_128216 (h0 : functor.add_const (list nnreal) unsigned) : list.nodup (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_128217 (h1 : ring (distrib (rel to_additive.value_type linarith.comp_source))) : rank_condition (distrib (rel to_additive.value_type linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_128218 (h0 : topological_space (add_group (semiring empty))) : t1_space (add_group (semiring empty)) := sorry --non-trivial
lemma new_lemma_128219 (h0 : functor.add_const (topological_space (normed_comm_ring unsigned)) Type) : @regular_space.{0} (normed_comm_ring.{0} unsigned) (@functor.add_const.run.{0 1} (topological_space.{0} (normed_comm_ring.{0} unsigned)) Type h0)  := sorry --non-trivial
lemma new_lemma_128220 (h0 : function.extfun Type topological_space) : totally_disconnected_space real := sorry --non-trivial
lemma new_lemma_128221 (h0 : group auto.case_option) : group.fg auto.case_option := sorry --non-trivial
lemma new_lemma_128222 (h0 : topological_space (has_norm (comm_ring (comm_ring fun_info)))) : irreducible_space (has_norm (comm_ring (comm_ring fun_info))) := sorry --non-trivial
lemma new_lemma_128223 (h0 : ordered_comm_monoid (generalized_boolean_algebra (has_add linarith.comp))) : has_exists_mul_of_le (generalized_boolean_algebra (has_add linarith.comp)) := sorry --non-trivial
lemma new_lemma_128224 (h0 : functor.add_const (list (semigroup pos)) unsigned) : palindrome (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_128225 (h0 : uniform_space (with_bot (random_gen string_imp))) : complete_space (with_bot (random_gen string_imp)) := sorry --non-trivial
lemma new_lemma_128226 (h0 : functor.add_const (list (boolean_algebra environment.implicit_infer_kind)) Type) : list.nodup (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_128227 (h0 : not (function.extfun Type topological_space -> false)) : @normal_space.{0} (add_group.{0} fun_info) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (add_group.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_128228 (h0 : function.extfun Type (functor.add_const (topological_space (add_left_cancel_semigroup empty)))) : @discrete_topology.{0} (add_left_cancel_semigroup.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (add_left_cancel_semigroup.{0} empty)) empty (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (topological_space.{0} (add_left_cancel_semigroup.{0} empty))) h0 empty))  := sorry --non-trivial
lemma new_lemma_128229 (h0 : ring (ring (has_pos_part (has_add pos)))) : rank_condition (ring (has_pos_part (has_add pos))) := sorry --non-trivial
lemma new_lemma_128230 (h0 : complete_lattice (plift (left_cancel_semigroup empty))) : is_atomistic (plift (left_cancel_semigroup empty)) := sorry --non-trivial
lemma new_lemma_128231 (h0 : functor.add_const (topological_space (has_neg_part unsigned)) Type) : @t1_space.{0} (has_neg_part.{0} unsigned) (@functor.add_const.run.{0 1} (topological_space.{0} (has_neg_part.{0} unsigned)) Type h0)  := sorry --non-trivial
lemma new_lemma_128232 (h0 : functor.add_const (complete_lattice (monoid empty)) empty) : @complete_lattice.is_Sup_finite_compact.{0} (monoid.{0} empty) (@functor.add_const.run.{0 0} (complete_lattice.{0} (monoid.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_128233 (h0 : uniform_space (pseudo_metric_space pos)) : separated_space (pseudo_metric_space pos) := sorry --non-trivial
lemma new_lemma_128234 (h0 : function.extfun Type topological_space) : @irreducible_space.{0} (has_top.{0} linarith.ineq) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_top.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_128235 (h0 : group (canonically_ordered_monoid (has_Inf (has_Inf (has_add (finset real)))))) : is_cyclic (canonically_ordered_monoid (has_Inf (has_Inf (has_add (finset real))))) := sorry --non-trivial
lemma new_lemma_128236 (h0 : monoid (group_with_zero num)) : monoid.fg (group_with_zero num) := sorry --non-trivial
lemma new_lemma_128237 (h0 : topological_space (add_cancel_monoid (has_add (finset pos)))) : preconnected_space (add_cancel_monoid (has_add (finset pos))) := sorry --non-trivial
lemma new_lemma_128238 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_principal_ideal_ring.{0} (comm_monoid.{0} empty) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (comm_monoid.{0} empty))  := sorry --non-trivial
lemma new_lemma_128239 (h0 : functor.comp list canonically_ordered_comm_semiring name) : list.nodup (functor.comp.run h0) := sorry --non-trivial
lemma new_lemma_128240 (h0 : topological_space (boolean_algebra (finset (has_pos_part linarith.comp)))) : loc_path_connected_space (boolean_algebra (finset (has_pos_part linarith.comp))) := sorry --non-trivial
lemma new_lemma_128241 (h0 : function.extfun (finset (Type -> Type)) (has_mem.mem topological_space)) : @totally_separated_space.{0} (has_norm.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) topological_space.{0} (@function.extfun_app.{2 0} (finset.{1} (Type → Type)) (@has_mem.mem.{1 1} (Type → Type) (finset.{1} (Type → Type)) (@finset.has_mem.{1} (Type → Type)) topological_space.{0}) h0 (@has_emptyc.emptyc.{1} (finset.{1} (Type → Type)) (@finset.has_emptyc.{1} (Type → Type))))) (has_norm.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_128242 (h0 : function.extfun (finset Type) (has_mem.mem (has_top empty))) : @normalizer_condition.{0} (has_top.{0} empty) (@finset.pi.empty.{1 0} Type group.{0} (has_top.{0} empty) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (has_top.{0} empty)) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_128243 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @totally_disconnected_space.{0} (finset.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (finset.{0} empty))  := sorry --non-trivial
lemma new_lemma_128244 (h0 : add_group (has_bot (has_Inf name))) : is_add_cyclic (has_bot (has_Inf name)) := sorry --non-trivial
lemma new_lemma_128245 (h0 : topological_space (free_add_monoid num)) : locally_compact_space (free_add_monoid num) := sorry --non-trivial
lemma new_lemma_128246 (h0 : function.extfun Type finset) : finset.nonempty (function.extfun_app h0 (add_group num)) := sorry --non-trivial
lemma new_lemma_128247 (h0 : uniform_space (encodable (has_nnnorm (has_nnnorm fun_info)))) : complete_space (encodable (has_nnnorm (has_nnnorm fun_info))) := sorry --non-trivial
lemma new_lemma_128248 (h0 : topological_space (mul_zero_class environment.implicit_infer_kind)) : preconnected_space (mul_zero_class environment.implicit_infer_kind) := sorry --non-trivial
lemma new_lemma_128249 (h0 : functor.add_const (function.extfun Type list) (has_add pos)) : list.nodup (function.extfun_app (functor.add_const.run h0) (has_neg name)) := sorry --non-trivial
lemma new_lemma_128250 (h0 : functor.add_const (finset (boolean_algebra.core name)) linarith.comp) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_128251 (h0 : function.extfun Type group) : @group.fg.{0} (has_ssubset.{0} fun_info) (@function.extfun_app.{2 1} Type group.{0} h0 (has_ssubset.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_128252 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @totally_disconnected_space.{0} (filter.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (filter.{0} num))  := sorry --non-trivial
lemma new_lemma_128253 (h0 : functor.add_const (topological_space (add_group empty)) congr_arg_kind) : @discrete_topology.{0} (add_group.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (add_group.{0} empty)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_128254 (h0 : function.extfun Type uniform_space) : @complete_space.{0} real.angle (@function.extfun_app.{2 1} Type uniform_space.{0} h0 real.angle)  := sorry --non-trivial
lemma new_lemma_128255 (h0 : not (topological_space (complete_linear_order congr_arg_kind) -> false)) : @topological_space.separable_space.{0} (complete_linear_order.{0} congr_arg_kind) (@classical.by_contradiction'.{1} (topological_space.{0} (complete_linear_order.{0} congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_128256 (h0 : function.extfun (Type 1) (functor.comp topological_space cancel_monoid)) : @topological_space.separable_space.{1} (cancel_monoid.{1} Type) (@functor.comp.run.{1 1 1} topological_space.{1} cancel_monoid.{1} Type (@function.extfun_app.{3 2} (Type 1) (functor.comp.{1 1 1} topological_space.{1} cancel_monoid.{1}) h0 Type))  := sorry --non-trivial
lemma new_lemma_128257 (h0 : topological_space (has_zero (has_to_string linarith.comp))) : sequential_space (has_zero (has_to_string linarith.comp)) := sorry --non-trivial
lemma new_lemma_128258 (h0 : function.extfun nat fin) : @totally_separated_space.{1} (ordered_comm_ring.{1} Type) (@matrix.vec_empty.{1} (topological_space.{1} (ordered_comm_ring.{1} Type)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_128259 (h0 : function.extfun Type (functor.add_const Prop)) : functor.add_const.run (function.extfun_app h0 (ring ennreal)) := sorry --non-trivial
lemma new_lemma_128260 (h0 : functor.add_const (topological_space (has_neg_part name)) Type) : @totally_disconnected_space.{0} (has_neg_part.{0} name) (@functor.add_const.run.{0 1} (topological_space.{0} (has_neg_part.{0} name)) Type h0)  := sorry --non-trivial
lemma new_lemma_128261 (h0 : ring (canonically_ordered_monoid (sub_neg_monoid (sub_neg_monoid Type)))) : rank_condition (canonically_ordered_monoid (sub_neg_monoid (sub_neg_monoid Type))) := sorry --non-trivial
lemma new_lemma_128262 (h0 : functor.add_const (topological_space (ordered_ring empty)) num) : @discrete_topology.{0} (ordered_ring.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (ordered_ring.{0} empty)) num h0)  := sorry --non-trivial
lemma new_lemma_128263 (h0 : functor.add_const (uniform_space (ordered_comm_ring pos)) Type) : @separated_space.{0} (ordered_comm_ring.{0} pos) (@functor.add_const.run.{0 1} (uniform_space.{0} (ordered_comm_ring.{0} pos)) Type h0)  := sorry --non-trivial
lemma new_lemma_128264 (h0 : add_group (has_ssubset environment.projection_info)) : is_add_cyclic (has_ssubset environment.projection_info) := sorry --non-trivial
lemma new_lemma_128265 (h0 : functor.add_const (ring (canonically_ordered_comm_semiring unsigned)) linarith.comp) : @rank_condition.{0} (canonically_ordered_comm_semiring.{0} unsigned) (@functor.add_const.run.{0 0} (ring.{0} (canonically_ordered_comm_semiring.{0} unsigned)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_128266 (h0 : cancel_comm_monoid_with_zero (has_zero (finset linarith.comp))) : unique_factorization_monoid (has_zero (finset linarith.comp)) := sorry --non-trivial
lemma new_lemma_128267 (h0 : prod (option (option (option (option empty)))) (option (option (option (option empty))))) : id_rel h0 := sorry --non-trivial
lemma new_lemma_128268 (h0 : topological_space (measurable_space (semiring (semiring (semiring (semiring unsigned)))))) : preirreducible_space (measurable_space (semiring (semiring (semiring (semiring unsigned))))) := sorry --non-trivial
lemma new_lemma_128269 (h0 : topological_space (has_top linarith.comp_source)) : totally_disconnected_space (has_top linarith.comp_source) := sorry --non-trivial
lemma new_lemma_128270 (h0 : order_hom nat (topological_space (has_lt char))) : @path_connected_space.{0} (has_lt.{0} char) (@monotonic_sequence_limit.{0} (topological_space.{0} (has_lt.{0} char)) (@topological_space.partial_order.{0} (has_lt.{0} char)) h0)  := sorry --non-trivial
lemma new_lemma_128271 (h2 : group (add_left_cancel_monoid linarith.comp_source)) : is_cyclic (add_left_cancel_monoid linarith.comp_source) := sorry --non-trivial
lemma new_lemma_128272 (h0 : topological_space (has_zero (finset ennreal))) : sequential_space (has_zero (finset ennreal)) := sorry --non-trivial
lemma new_lemma_128273 (h0 : not (ring (distrib linarith.ineq) -> false)) : @rank_condition.{0} (distrib.{0} linarith.ineq) (@classical.by_contradiction'.{1} (ring.{0} (distrib.{0} linarith.ineq)) h0)  := sorry --non-trivial
lemma new_lemma_128274 (h0 : topological_space (has_bot (sub_neg_monoid pos))) : path_connected_space (has_bot (sub_neg_monoid pos)) := sorry --non-trivial
lemma new_lemma_128275 (h0 : not (topological_space unsigned -> false)) : @totally_disconnected_space.{0} unsigned (@classical.by_contradiction'.{1} (topological_space.{0} unsigned) h0)  := sorry --non-trivial
lemma new_lemma_128276 (h0 : ordered_add_comm_monoid (complete_distrib_lattice (ring Type))) : archimedean (complete_distrib_lattice (ring Type)) := sorry --non-trivial
lemma new_lemma_128277 (h0 : has_le char) (h1 : char) : is_max h1 := sorry --non-trivial
lemma new_lemma_128278 (h0 : functor.add_const (ordered_add_comm_monoid (has_neg Type)) (has_add pos)) : @archimedean.{1} (has_neg.{1} Type) (@functor.add_const.run.{1 0} (ordered_add_comm_monoid.{1} (has_neg.{1} Type)) (has_add.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_128279 (h0 : cancel_comm_monoid_with_zero (canonically_linear_ordered_monoid (option name))) : unique_factorization_monoid (canonically_linear_ordered_monoid (option name)) := sorry --non-trivial
lemma new_lemma_128280 (h0 : functor.add_const (topological_space (bin_tree num)) (semiring num)) : @discrete_topology.{0} (bin_tree.{0} num) (@functor.add_const.run.{0 0} (topological_space.{0} (bin_tree.{0} num)) (semiring.{0} num) h0)  := sorry --non-trivial
lemma new_lemma_128281 (h0 : functor.add_const (uniform_space (add_comm_monoid Type)) unsigned) : @separated_space.{1} (add_comm_monoid.{1} Type) (@functor.add_const.run.{1 0} (uniform_space.{1} (add_comm_monoid.{1} Type)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_128282 (h0 : function.extfun Type ordered_comm_monoid) : @has_exists_mul_of_le.{0} (finset.{0} ennreal) (@function.extfun_app.{2 1} Type ordered_comm_monoid.{0} h0 (finset.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_128283 (h0 : ring (group_with_zero congr_arg_kind)) : strong_rank_condition (group_with_zero congr_arg_kind) := sorry --non-trivial
lemma new_lemma_128284 (h0 : filter (semiring (semiring (semiring empty)))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_128285 (h0 : function.extfun Type group) : @group.fg.{0} (finset.{0} pos) (@function.extfun_app.{2 1} Type group.{0} h0 (finset.{0} pos))  := sorry --non-trivial
lemma new_lemma_128286 (h0 : congr_arg_kind -> congr_arg_kind -> congr_arg_kind) : is_right_cancel congr_arg_kind h0 := sorry --non-trivial
lemma new_lemma_128287 (h0 : has_mem.mem complete_lattice has_emptyc.emptyc) : @is_compactly_generated.{0} (random_gen.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) complete_lattice.{0} h0) (random_gen.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_128288 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @complete_space.{0} (normed_lattice_add_comm_group.{0} real) (@function.extfun_app.{2 1} Type uniform_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 uniform_space.{0}) (normed_lattice_add_comm_group.{0} real))  := sorry --non-trivial
lemma new_lemma_128289 (h0 : function.extfun Type ring) : @is_principal_ideal_ring.{0} (has_star.{0} empty) (@function.extfun_app.{2 1} Type ring.{0} h0 (has_star.{0} empty))  := sorry --non-trivial
lemma new_lemma_128290 (h0 : topological_space (linear_ordered_comm_ring (has_top empty))) : discrete_topology (linear_ordered_comm_ring (has_top empty)) := sorry --non-trivial
lemma new_lemma_128291 (h0 : group (random_gen (has_inv to_additive.value_type))) : group.fg (random_gen (has_inv to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_128292 (h0 : set (linarith.ineq -> nondiscrete_normed_field (measurable_space char))) : set.separates_points h0 := sorry --non-trivial
lemma new_lemma_128293 (h0 h1 : multiset (simple_graph ereal)) : multiset.disjoint h0 h1 := sorry --non-trivial
lemma new_lemma_128294 (h0 : functor.add_const (uniform_space (normed_linear_ordered_group empty)) (option empty)) : @complete_space.{0} (normed_linear_ordered_group.{0} empty) (@functor.add_const.run.{0 0} (uniform_space.{0} (normed_linear_ordered_group.{0} empty)) (option.{0} empty) h0)  := sorry --non-trivial
lemma new_lemma_128295 (h0 : not (function.extfun Type topological_space -> false)) : @discrete_topology.{0} (measurable_space.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (measurable_space.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_128296 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @discrete_topology.{0} (@id.{2} Type congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (@id.{2} Type congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_128297 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_domain.{0} (has_one.{0} unsigned) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (has_one.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_128298 (h0 : function.extfun Type ring) : @rank_condition.{0} (comm_monoid.{0} unsigned) (@function.extfun_app.{2 1} Type ring.{0} h0 (comm_monoid.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_128299 (h0 : group (complete_semilattice_Sup (has_nnnorm (random_gen linarith.comp_source)))) : group.fg (complete_semilattice_Sup (has_nnnorm (random_gen linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_128300 (h0 : function.extfun ((Type -> Type) -> Type 1) (function.extfun (Type -> Type))) : @normalizer_condition.{0} ennreal (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) (@function.extfun_app.{3 2} ((Type → Type) → Type 1) (function.extfun.{2 2} (Type → Type)) h0 (function.extfun.{2 1} Type)) group.{0}) ennreal)  := sorry --non-trivial
lemma new_lemma_128301 (h0 h1 : multiset (mul_one_class enat)) : multiset.disjoint h0 h1 := sorry --non-trivial
lemma new_lemma_128302 (h1 : add_group (nondiscrete_normed_field (mul_one_class environment.projection_info))) : is_add_cyclic (nondiscrete_normed_field (mul_one_class environment.projection_info)) := sorry --non-trivial
lemma new_lemma_128303 (h0 : function.extfun Type topological_space) : @t0_space.{0} (has_dist.{0} (option.{0} (option.{0} ennreal))) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_dist.{0} (option.{0} (option.{0} ennreal))))  := sorry --non-trivial
lemma new_lemma_128304 (h0 : fin has_zero.zero) : @loc_path_connected_space.{0} (has_bot.{0} linarith.comp) (@matrix.vec_empty.{0} (topological_space.{0} (has_bot.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_128305 (h0 : topological_space (add_cancel_monoid (finset (is_R_or_C (has_Inf (finset linarith.comp)))))) : irreducible_space (add_cancel_monoid (finset (is_R_or_C (has_Inf (finset linarith.comp))))) := sorry --non-trivial
lemma new_lemma_128306 (h0 : finset (add_cancel_monoid (finset pos))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_128307 (h0 : topological_space (has_pos_part (has_Inf real))) : loc_path_connected_space (has_pos_part (has_Inf real)) := sorry --non-trivial
lemma new_lemma_128308 (h2 : topological_space (add_comm_semigroup fun_info)) : totally_disconnected_space (add_comm_semigroup fun_info) := sorry --non-trivial
lemma new_lemma_128309 (h0 : has_mem.mem complete_lattice has_emptyc.emptyc) : @is_atomistic.{0} (@id.{2} Type to_additive.value_type) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) complete_lattice.{0} h0) (@id.{2} Type to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_128310 (h0 : set (has_div (semi_normed_ring fun_info))) : set.finite h0 := sorry --non-trivial
lemma new_lemma_128311 (h0 : functor.add_const (topological_space (has_neg_part name)) pos) : @path_connected_space.{0} (has_neg_part.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (has_neg_part.{0} name)) pos h0)  := sorry --non-trivial
lemma new_lemma_128312 (h0 : function.extfun (Type -> Type) (function.extfun Type)) (h1 : not (function.extfun Type group -> false)) : @uniform_group.{0} (has_norm.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type uniform_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 uniform_space.{0}) (has_norm.{0} linarith.comp_source)) (@function.extfun_app.{2 1} Type group.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type group.{0}) h1) (has_norm.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_128313 (h0 : add_monoid (add_cancel_monoid linarith.comp)) : add_monoid.fg (add_cancel_monoid linarith.comp) := sorry --non-trivial
lemma new_lemma_128314 (h0 : not (topological_space (has_union num) -> false)) : @totally_disconnected_space.{0} (has_union.{0} num) (@classical.by_contradiction'.{1} (topological_space.{0} (has_union.{0} num)) h0)  := sorry --non-trivial
lemma new_lemma_128315 (h0 : topological_space (has_nnnorm (mul_one_class enat))) (h1 : preorder (has_nnnorm (mul_one_class enat))) : order_topology (has_nnnorm (mul_one_class enat)) := sorry --non-trivial
lemma new_lemma_128316 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @group.fg.{0} (has_norm.{0} num) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (has_norm.{0} num))  := sorry --non-trivial
lemma new_lemma_128317 (h0 : add_monoid (normed_linear_ordered_group congr_arg_kind)) : add_monoid.fg (normed_linear_ordered_group congr_arg_kind) := sorry --non-trivial
lemma new_lemma_128318 (h0 : functor.add_const (filter (canonically_ordered_comm_semiring pos)) pos) : filter.ne_bot (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_128319 (h0 : functor.add_const (ordered_add_comm_monoid (non_assoc_semiring ennreal)) ennreal) : @archimedean.{0} (non_assoc_semiring.{0} ennreal) (@functor.add_const.run.{0 0} (ordered_add_comm_monoid.{0} (non_assoc_semiring.{0} ennreal)) ennreal h0)  := sorry --non-trivial
lemma new_lemma_128320 (h0 : list (has_top (random_gen (random_gen fun_info)))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_128321 (h0 : functor.add_const (list (add_cancel_monoid name)) linarith.comp) : palindrome (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_128322 (h0 : filter (comm_group (option (option name)))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_128323 (h0 : functor.add_const (list (ordered_comm_monoid name)) pos) : list.nodup (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_128324 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_domain.{0} (random_gen.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (random_gen.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_128325 (h0 : functor.add_const (add_group (boolean_algebra name)) linarith.comp) : @is_add_cyclic.{0} (boolean_algebra.{0} name) (@functor.add_const.run.{0 0} (add_group.{0} (boolean_algebra.{0} name)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_128326 (h0 : not (function.extfun Type filter -> false)) : filter.ne_bot (function.extfun_app (classical.by_contradiction' h0) (random_gen congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_128327 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @locally_compact_space.{0} (has_to_string.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_to_string.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_128328 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_noetherian_ring.{0} (filter.{0} empty) (@function.extfun_app.{2 1} Type semiring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 semiring.{0}) (filter.{0} empty))  := sorry --non-trivial
lemma new_lemma_128329 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @totally_separated_space.{0} (with_one.{0} linarith.ineq) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (with_one.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_128330 (h0 : function.extfun Type group) : @is_simple_group.{0} (generalized_boolean_algebra.{0} linarith.comp) (@function.extfun_app.{2 1} Type group.{0} h0 (generalized_boolean_algebra.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_128331 (h0 : topological_space (has_add (has_Inf real))) : normal_space (has_add (has_Inf real)) := sorry --non-trivial
lemma new_lemma_128332 (h0 : topological_space (complete_distrib_lattice (has_Inf (sub_neg_monoid real)))) : regular_space (complete_distrib_lattice (has_Inf (sub_neg_monoid real))) := sorry --non-trivial
lemma new_lemma_128333 (h0 : list (comm_group environment.implicit_infer_kind)) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_128334 (h0 : function.extfun Type topological_space) : @preirreducible_space.{0} (bin_tree.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (bin_tree.{0} empty))  := sorry --non-trivial
lemma new_lemma_128335 (h0 : function.extfun Type cancel_comm_monoid_with_zero) : @unique_factorization_monoid.{0} (linear_ordered_semiring.{0} empty) (@function.extfun_app.{2 1} Type cancel_comm_monoid_with_zero.{0} h0 (linear_ordered_semiring.{0} empty))  := sorry --non-trivial
lemma new_lemma_128336 (h0 : char -> Prop -> Prop) (h1 : Prop) (h2 : list char) : list.foldr h0 h1 h2 := sorry --non-trivial
lemma new_lemma_128337 (h0 : add_group (mul_one_class (mul_one_class (mul_one_class std_gen)))) : is_add_cyclic (mul_one_class (mul_one_class (mul_one_class std_gen))) := sorry --non-trivial
lemma new_lemma_128338 (h0 : finset (ring (has_add pos))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_128339 (h0 : not (ring (non_assoc_semiring empty) -> false)) : @rank_condition.{0} (non_assoc_semiring.{0} empty) (@classical.by_contradiction'.{1} (ring.{0} (non_assoc_semiring.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_128340 (h0 : functor.add_const Prop (semiring empty)) : functor.add_const.run h0 := sorry --non-trivial
lemma new_lemma_128341 (h0 : cancel_comm_monoid_with_zero (has_nndist (has_add pos))) : unique_factorization_monoid (has_nndist (has_add pos)) := sorry --non-trivial
lemma new_lemma_128342 (h0 : topological_space (normed_lattice_add_comm_group (has_Inf Type))) : locally_compact_space (normed_lattice_add_comm_group (has_Inf Type)) := sorry --non-trivial
lemma new_lemma_128343 (h0 : ring (has_to_string (comm_group (comm_group pos)))) : is_principal_ideal_ring (has_to_string (comm_group (comm_group pos))) := sorry --non-trivial
lemma new_lemma_128344 (h0 : filter (id (has_norm linarith.comp))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_128345 (h0 : filter (add_cancel_monoid (finset (finset (finset (finset (has_zero pos))))))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_128346 (h0 : functor.add_const (ordered_comm_monoid (has_add name)) (ring (has_pos_part linarith.comp))) : @has_exists_mul_of_le.{0} (has_add.{0} name) (@functor.add_const.run.{0 0} (ordered_comm_monoid.{0} (has_add.{0} name)) (ring.{0} (has_pos_part.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_128347 (h0 : fin has_zero.zero) : @has_exists_mul_of_le.{0} (sub_neg_monoid.{0} real) (@function.extfun_app.{2 1} Type ordered_comm_monoid.{0} (@matrix.vec_empty.{1} (function.extfun.{2 1} Type ordered_comm_monoid.{0}) h0) (sub_neg_monoid.{0} real))  := sorry --non-trivial
lemma new_lemma_128348 (h0 : topological_space (complete_semilattice_Sup (has_nnnorm (has_nnnorm fun_info)))) : path_connected_space (complete_semilattice_Sup (has_nnnorm (has_nnnorm fun_info))) := sorry --non-trivial
lemma new_lemma_128349 (h0 : topological_space (ring empty)) : preconnected_space (ring empty) := sorry --non-trivial
lemma new_lemma_128350 (h0 : add_group (has_ssubset (has_top linarith.ineq))) : is_add_cyclic (has_ssubset (has_top linarith.ineq)) := sorry --non-trivial
lemma new_lemma_128351 (h0 : functor.add_const (ordered_comm_monoid (semigroup linarith.comp)) (finset environment.implicit_infer_kind)) : @has_exists_mul_of_le.{0} (semigroup.{0} linarith.comp) (@functor.add_const.run.{0 0} (ordered_comm_monoid.{0} (semigroup.{0} linarith.comp)) (finset.{0} environment.implicit_infer_kind) h0)  := sorry --non-trivial
lemma new_lemma_128352 (h0 : topological_space (comm_ring (has_ssubset reducibility_hints))) : t0_space (comm_ring (has_ssubset reducibility_hints)) := sorry --non-trivial
lemma new_lemma_128353 (h0 : cancel_comm_monoid_with_zero (comm_group (complete_distrib_lattice environment.implicit_infer_kind))) : unique_factorization_monoid (comm_group (complete_distrib_lattice environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_128354 (h1 : group (id string_imp)) : group.fg (id string_imp) := sorry --non-trivial
lemma new_lemma_128355 (h0 : functor.add_const (cancel_comm_monoid_with_zero (mul_zero_class empty)) num) : @unique_factorization_monoid.{0} (mul_zero_class.{0} empty) (@functor.add_const.run.{0 0} (cancel_comm_monoid_with_zero.{0} (mul_zero_class.{0} empty)) num h0)  := sorry --non-trivial
lemma new_lemma_128356 (h0 : topological_space (has_inv (has_inv (has_norm fun_info)))) : locally_compact_space (has_inv (has_inv (has_norm fun_info))) := sorry --non-trivial
lemma new_lemma_128357 (h0 : functor.add_const (topological_space (has_Inf Type)) (has_neg linarith.comp)) : @totally_separated_space.{1} (has_Inf.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (has_Inf.{1} Type)) (has_neg.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_128358 (h0 : functor.add_const (topological_space (mul_zero_class ennreal)) name) : @loc_path_connected_space.{0} (mul_zero_class.{0} ennreal) (@functor.add_const.run.{0 0} (topological_space.{0} (mul_zero_class.{0} ennreal)) name h0)  := sorry --non-trivial
lemma new_lemma_128359 (h0 : functor.add_const (ring (has_Inf pos)) (has_add linarith.comp)) : @is_domain.{0} (has_Inf.{0} pos) (@functor.add_const.run.{0 0} (ring.{0} (has_Inf.{0} pos)) (has_add.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_128360 (h0 : topological_space (has_pos_part (has_Inf linarith.comp))) : totally_disconnected_space (has_pos_part (has_Inf linarith.comp)) := sorry --non-trivial
lemma new_lemma_128361 (h0 : complete_lattice (cancel_monoid (has_add name))) : complete_lattice.is_Sup_finite_compact (cancel_monoid (has_add name)) := sorry --non-trivial
lemma new_lemma_128362 (h0 : topological_space (normed_group (random_gen linarith.ineq))) : totally_disconnected_space (normed_group (random_gen linarith.ineq)) := sorry --non-trivial
lemma new_lemma_128363 (h0 : topological_space (boolean_algebra (has_neg_part Type))) : totally_separated_space (boolean_algebra (has_neg_part Type)) := sorry --non-trivial
lemma new_lemma_128364 (h0 : functor.add_const (topological_space (finset ennreal)) pos) : @t0_space.{0} (finset.{0} ennreal) (@functor.add_const.run.{0 0} (topological_space.{0} (finset.{0} ennreal)) pos h0)  := sorry --non-trivial
lemma new_lemma_128365 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @preconnected_space.{0} (finset.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (finset.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_128366 (h0 : topological_space (plift (semiring unsigned))) : totally_separated_space (plift (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_128367 (h0 : ring (complete_distrib_lattice (ordered_ring name))) : strong_rank_condition (complete_distrib_lattice (ordered_ring name)) := sorry --non-trivial
lemma new_lemma_128368 (h2 : complete_lattice (distrib_lattice linarith.ineq)) : is_compactly_generated (distrib_lattice linarith.ineq) := sorry --non-trivial
lemma new_lemma_128369 (h0 : not (monoid (measurable_space unsigned) -> false)) : @monoid.fg.{0} (measurable_space.{0} unsigned) (@classical.by_contradiction'.{1} (monoid.{0} (measurable_space.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_128370 (h0 : ring (denumerable linarith.comp_source)) : is_domain (denumerable linarith.comp_source) := sorry --non-trivial
lemma new_lemma_128371 (h0 : functor.add_const (group (semigroup unsigned)) pos) : @group.fg.{0} (semigroup.{0} unsigned) (@functor.add_const.run.{0 0} (group.{0} (semigroup.{0} unsigned)) pos h0)  := sorry --non-trivial
lemma new_lemma_128372 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @locally_compact_space.{0} (normed_group.{0} linarith.ineq) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (normed_group.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_128373 (h0 : function.extfun Type (functor.add_const (topological_space (is_R_or_C empty)))) : @t1_space.{0} (is_R_or_C.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (is_R_or_C.{0} empty)) empty (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (topological_space.{0} (is_R_or_C.{0} empty))) h0 empty))  := sorry --non-trivial
lemma new_lemma_128374 (h0 : functor.add_const (function.extfun Type complete_lattice) name) : @is_compactly_generated.{0} (mul_zero_class.{0} ennreal) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type complete_lattice.{0}) name h0) (mul_zero_class.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_128375 (h1 : Prop) : not h1 := sorry --non-trivial
lemma new_lemma_128376 (h1 : function.extfun Type complete_lattice) : @complete_lattice.is_Sup_finite_compact.{0} (denumerable.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type complete_lattice.{0} h1 (denumerable.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_128377 (h0 : function.extfun Type topological_space) : @normal_space.{0} (linear_ordered_comm_ring.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (linear_ordered_comm_ring.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_128378 (h2 : filter (denumerable (has_nnnorm (has_nnnorm to_additive.value_type)))) : filter.ne_bot h2 := sorry --non-trivial
lemma new_lemma_128379 (h0 : function.extfun Type ring) : @is_domain.{0} (pseudo_metric_space.{0} pos) (@function.extfun_app.{2 1} Type ring.{0} h0 (pseudo_metric_space.{0} pos))  := sorry --non-trivial
lemma new_lemma_128380 (h0 : list (has_to_string (finset (has_nndist ennreal)))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_128381 (h0 : ring (with_zero fun_info)) : rank_condition (with_zero fun_info) := sorry --non-trivial
lemma new_lemma_128382 (h0 : not (cancel_comm_monoid_with_zero empty -> false)) : @unique_factorization_monoid.{0} empty (@classical.by_contradiction'.{1} (cancel_comm_monoid_with_zero.{0} empty) h0)  := sorry --non-trivial
lemma new_lemma_128383 (h0 : list (dlist (has_ssubset (has_ssubset (random_gen (has_ssubset fun_info)))))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_128384 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @irreducible_space.{0} (has_neg.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_neg.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_128385 (h0 : function.extfun Type add_group) : @is_add_cyclic.{0} (has_add.{0} unsigned) (@function.extfun_app.{2 1} Type add_group.{0} h0 (has_add.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_128386 (h0 : functor.add_const (uniform_space (has_nndist linarith.comp)) (has_neg (finset pos))) : @complete_space.{0} (has_nndist.{0} linarith.comp) (@functor.add_const.run.{0 0} (uniform_space.{0} (has_nndist.{0} linarith.comp)) (has_neg.{0} (finset.{0} pos)) h0)  := sorry --non-trivial
lemma new_lemma_128387 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : palindrome (function.extfun_app (function.extfun_app h0 list) (comm_group name)) := sorry --non-trivial
lemma new_lemma_128388 (h0 : functor.add_const (topological_space (boolean_algebra.core linarith.comp)) Type) : @preirreducible_space.{0} (boolean_algebra.core.{0} linarith.comp) (@functor.add_const.run.{0 1} (topological_space.{0} (boolean_algebra.core.{0} linarith.comp)) Type h0)  := sorry --non-trivial
lemma new_lemma_128389 (h0 : ring (boolean_algebra.core (normed_comm_ring name))) : is_principal_ideal_ring (boolean_algebra.core (normed_comm_ring name)) := sorry --non-trivial
lemma new_lemma_128390 (h0 : ring (ordered_comm_monoid linarith.comp)) : is_principal_ideal_ring (ordered_comm_monoid linarith.comp) := sorry --non-trivial
lemma new_lemma_128391 (h0 : function.extfun Type topological_space) : @totally_separated_space.{0} subsingleton_info (@function.extfun_app.{2 1} Type topological_space.{0} h0 subsingleton_info)  := sorry --non-trivial
lemma new_lemma_128392 (h0 : complete_lattice (has_nndist (mul_zero_class ennreal))) : complete_lattice.is_Sup_finite_compact (has_nndist (mul_zero_class ennreal)) := sorry --non-trivial
lemma new_lemma_128393 (h0 : ring (linear_ordered_semiring fun_info)) : rank_condition (linear_ordered_semiring fun_info) := sorry --non-trivial
lemma new_lemma_128394 (h0 : semiring enat) (h8 : enat) : even h8 := sorry --non-trivial
lemma new_lemma_128395 (h0 : ordered_add_comm_monoid (has_add (has_nndist Type))) : archimedean (has_add (has_nndist Type)) := sorry --non-trivial
lemma new_lemma_128396 (h0 : complete_lattice (linear_ordered_semiring (has_top num))) : is_compactly_generated (linear_ordered_semiring (has_top num)) := sorry --non-trivial
lemma new_lemma_128397 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @add_monoid.fg.{0} (preorder.{0} empty) (@function.extfun_app.{2 1} Type add_monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 add_monoid.{0}) (preorder.{0} empty))  := sorry --non-trivial
lemma new_lemma_128398 (h0 : function.extfun Type topological_space) : @locally_compact_space.{0} (linear_ordered_field.{0} (option.{0} ennreal)) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (linear_ordered_field.{0} (option.{0} ennreal)))  := sorry --non-trivial
lemma new_lemma_128399 (h0 : functor.add_const (function.extfun Type group) pos) : @is_cyclic.{0} (finset.{0} linarith.comp) (@function.extfun_app.{2 1} Type group.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type group.{0}) pos h0) (finset.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_128400 (h0 : functor.add_const (topological_space (semigroup name)) name) : @t1_space.{0} (semigroup.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (semigroup.{0} name)) name h0)  := sorry --non-trivial
lemma new_lemma_128401 (h0 : topological_space (has_norm (has_inv fun_info))) : totally_separated_space (has_norm (has_inv fun_info)) := sorry --non-trivial
lemma new_lemma_128402 (h0 : ring (uniform_space (random_gen (comm_ring (metric_space string_imp))))) : rank_condition (uniform_space (random_gen (comm_ring (metric_space string_imp)))) := sorry --non-trivial
lemma new_lemma_128403 (h0 : topological_space (comm_group pos)) : topological_space.separable_space (comm_group pos) := sorry --non-trivial
lemma new_lemma_128404 (h0 : functor.add_const (topological_space (canonically_ordered_comm_semiring Type)) name) : @totally_separated_space.{1} (canonically_ordered_comm_semiring.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (canonically_ordered_comm_semiring.{1} Type)) name h0)  := sorry --non-trivial
lemma new_lemma_128405 (h0 : cancel_comm_monoid_with_zero (has_zero (has_to_string (has_neg_part (has_neg_part pos))))) : unique_factorization_monoid (has_zero (has_to_string (has_neg_part (has_neg_part pos)))) := sorry --non-trivial
lemma new_lemma_128406 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_domain.{0} (measure_theory.measure_space.{0} empty) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (measure_theory.measure_space.{0} empty))  := sorry --non-trivial
lemma new_lemma_128407 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @discrete_topology.{0} (has_neg.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_neg.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_128408 (h0 : functor.add_const (cancel_comm_monoid_with_zero (simple_graph linarith.comp)) name) : @unique_factorization_monoid.{0} (simple_graph.{0} linarith.comp) (@functor.add_const.run.{0 0} (cancel_comm_monoid_with_zero.{0} (simple_graph.{0} linarith.comp)) name h0)  := sorry --non-trivial
lemma new_lemma_128409 (h0 : topological_space (has_pos_part (finset pos))) : sequential_space (has_pos_part (finset pos)) := sorry --non-trivial
lemma new_lemma_128410 (h0 : group (is_R_or_C (semiring empty))) : group.fg (is_R_or_C (semiring empty)) := sorry --non-trivial
lemma new_lemma_128411 (h0 : function.extfun Type group) : @group.fg.{0} (distrib_lattice.{0} (has_nnnorm.{0} fun_info)) (@function.extfun_app.{2 1} Type group.{0} h0 (distrib_lattice.{0} (has_nnnorm.{0} fun_info)))  := sorry --non-trivial
lemma new_lemma_128412 (h0 : topological_space (complete_distrib_lattice linarith.comp)) : totally_disconnected_space (complete_distrib_lattice linarith.comp) := sorry --non-trivial
lemma new_lemma_128413 (h0 : set (prod congr_arg_kind congr_arg_kind)) : symmetric_rel h0 := sorry --non-trivial
lemma new_lemma_128414 (h0 : group (boolean_algebra pos)) : is_simple_group (boolean_algebra pos) := sorry --non-trivial
lemma new_lemma_128415 (h0 : function.extfun Type group) : @group.fg.{0} (has_add.{0} real) (@function.extfun_app.{2 1} Type group.{0} h0 (has_add.{0} real))  := sorry --non-trivial
lemma new_lemma_128416 (h0 : group (has_nnnorm to_additive.value_type)) : is_cyclic (has_nnnorm to_additive.value_type) := sorry --non-trivial
lemma new_lemma_128417 (h0 : topological_space (canonically_linear_ordered_monoid pos)) : path_connected_space (canonically_linear_ordered_monoid pos) := sorry --non-trivial
lemma new_lemma_128418 (h0 : ring (omega_complete_partial_order (option (option empty)))) : rank_condition (omega_complete_partial_order (option (option empty))) := sorry --non-trivial
lemma new_lemma_128419 (h0 : function.extfun Type uniform_space) : @separated_space.{0} (measure_theory.measure_space.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (measure_theory.measure_space.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_128420 (h0 : fin has_zero.zero) : @loc_path_connected_space.{1} (has_nndist.{1} Type) (@matrix.vec_empty.{1} (topological_space.{1} (has_nndist.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_128421 (h0 : topological_space (ring (has_add name))) : discrete_topology (ring (has_add name)) := sorry --non-trivial
lemma new_lemma_128422 (h0 : function.extfun (Type 1) semiring) : @is_noetherian_ring.{1} (plift.{1} (semiring.{0} (semiring.{0} (semiring.{0} (semiring.{0} congr_arg_kind))))) (@function.extfun_app.{3 2} (Type 1) semiring.{1} h0 (plift.{1} (semiring.{0} (semiring.{0} (semiring.{0} (semiring.{0} congr_arg_kind))))))  := sorry --non-trivial
lemma new_lemma_128423 (h0 : functor.add_const (topological_space (ordered_comm_group empty)) empty) : @normal_space.{0} (ordered_comm_group.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (ordered_comm_group.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_128424 (h0 : group (with_bot (random_gen (random_gen (random_gen (random_gen fun_info)))))) : normalizer_condition (with_bot (random_gen (random_gen (random_gen (random_gen fun_info))))) := sorry --non-trivial
lemma new_lemma_128425 (h0 : functor.add_const (topological_space (finset environment.implicit_infer_kind)) name) : @preconnected_space.{0} (finset.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (finset.{0} environment.implicit_infer_kind)) name h0)  := sorry --non-trivial
lemma new_lemma_128426 (h1 : function.extfun Type complete_lattice) : @complete_lattice.is_Sup_finite_compact.{0} (complete_semilattice_Sup.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type complete_lattice.{0} h1 (complete_semilattice_Sup.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_128427 (h0 : topological_space (normed_comm_ring (add_cancel_monoid pos))) : loc_path_connected_space (normed_comm_ring (add_cancel_monoid pos)) := sorry --non-trivial
lemma new_lemma_128428 (h0 : functor.add_const (functor.add_const (uniform_space Type) Type) Type) : @separated_space.{1} Type (@functor.add_const.run.{1 1} (uniform_space.{1} Type) Type (@functor.add_const.run.{1 1} (functor.add_const.{1 1} (uniform_space.{1} Type) Type) Type h0))  := sorry --non-trivial
lemma new_lemma_128429 (h0 : not (topological_space (left_cancel_semigroup congr_arg_kind) -> false)) : @locally_compact_space.{0} (left_cancel_semigroup.{0} congr_arg_kind) (@classical.by_contradiction'.{1} (topological_space.{0} (left_cancel_semigroup.{0} congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_128430 (h0 : cancel_comm_monoid_with_zero (linear_ordered_comm_group empty)) : unique_factorization_monoid (linear_ordered_comm_group empty) := sorry --non-trivial
lemma new_lemma_128431 (h0 : monoid (dlist (has_inv (has_inv linarith.comp_source)))) : monoid.fg (dlist (has_inv (has_inv linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_128432 (h0 : ring (has_norm (random_gen (random_gen (random_gen linarith.comp_source))))) : rank_condition (has_norm (random_gen (random_gen (random_gen linarith.comp_source)))) := sorry --non-trivial
lemma new_lemma_128433 (h0 : topological_space (linear_ordered_add_comm_group (random_gen char))) : path_connected_space (linear_ordered_add_comm_group (random_gen char)) := sorry --non-trivial
lemma new_lemma_128434 (h0 : complete_lattice (ordered_cancel_comm_monoid to_additive.value_type)) : complete_lattice.is_Sup_finite_compact (ordered_cancel_comm_monoid to_additive.value_type) := sorry --non-trivial
lemma new_lemma_128435 (h0 : function.extfun Type add_monoid) : @add_monoid.fg.{0} (sub_neg_monoid.{0} pos) (@function.extfun_app.{2 1} Type add_monoid.{0} h0 (sub_neg_monoid.{0} pos))  := sorry --non-trivial
lemma new_lemma_128436 (h0 : function.extfun Type complete_lattice) : @is_atomistic.{0} (has_zero.{0} ennreal) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (has_zero.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_128437 (h0 : topological_space (with_one (has_norm (with_bot congr_arg_kind)))) : t0_space (with_one (has_norm (with_bot congr_arg_kind))) := sorry --non-trivial
lemma new_lemma_128438 (h0 : function.extfun Type group) : @is_cyclic.{0} (has_ssubset.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type group.{0} h0 (has_ssubset.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_128439 (h0 : char -> char -> Prop) (h1 : list Prop) : list.ilast' (is_trans char h0) h1 := sorry --non-trivial
lemma new_lemma_128440 (h0 : topological_space (comm_group (comm_group (comm_group (comm_group unsigned))))) : discrete_topology (comm_group (comm_group (comm_group (comm_group unsigned)))) := sorry --non-trivial
lemma new_lemma_128441 (h0 : functor.add_const (add_monoid (has_neg linarith.comp)) (finset (has_Inf linarith.comp))) : @add_monoid.fg.{0} (has_neg.{0} linarith.comp) (@functor.add_const.run.{0 0} (add_monoid.{0} (has_neg.{0} linarith.comp)) (finset.{0} (has_Inf.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_128442 (h0 : functor.add_const (function.extfun Type ordered_comm_monoid) pos) : @has_exists_mul_of_le.{0} linarith.comp (@function.extfun_app.{2 1} Type ordered_comm_monoid.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type ordered_comm_monoid.{0}) pos h0) linarith.comp)  := sorry --non-trivial
lemma new_lemma_128443 (h0 : topological_space (has_nndist (finset Type))) : irreducible_space (has_nndist (finset Type)) := sorry --non-trivial
lemma new_lemma_128444 (h0 : not (function.extfun Type monoid -> false)) : @monoid.fg.{0} (random_gen.{0} linarith.comp) (@function.extfun_app.{2 1} Type monoid.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type monoid.{0}) h0) (random_gen.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_128445 (h4 : topological_space (normed_field to_additive.value_type)) : t0_space (normed_field to_additive.value_type) := sorry --non-trivial
lemma new_lemma_128446 (h0 : functor.add_const (functor.add_const (finset unsigned) environment.implicit_infer_kind) linarith.comp) : finset.nonempty (functor.add_const.run (functor.add_const.run h0)) := sorry --non-trivial
lemma new_lemma_128447 (h0 : topological_space (has_pos_part (finset linarith.comp))) : preirreducible_space (has_pos_part (finset linarith.comp)) := sorry --non-trivial
lemma new_lemma_128448 (h0 : list (ordered_ring unsigned)) : palindrome h0 := sorry --non-trivial
lemma new_lemma_128449 (h0 : function.extfun nat fin) : @monoid.fg.{0} (ordered_comm_monoid.{0} pos) (@matrix.vec_empty.{0} (monoid.{0} (ordered_comm_monoid.{0} pos)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_128450 (h0 : function.extfun Type (prod (option empty))) : id_rel (function.extfun_app h0 (option empty)) := sorry --non-trivial
lemma new_lemma_128451 (h2 : topological_space (complete_semilattice_Sup congr_arg_kind)) : locally_compact_space (complete_semilattice_Sup congr_arg_kind) := sorry --non-trivial
lemma new_lemma_128452 (h0 : ordered_comm_monoid (has_add (has_neg linarith.comp))) : has_exists_mul_of_le (has_add (has_neg linarith.comp)) := sorry --non-trivial
lemma new_lemma_128453 (h0 : not (topological_space (measurable_space linarith.comp) -> false)) : @locally_compact_space.{0} (measurable_space.{0} linarith.comp) (@classical.by_contradiction'.{1} (topological_space.{0} (measurable_space.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_128454 (h0 : ring (complete_distrib_lattice (semiring (semiring empty)))) : is_principal_ideal_ring (complete_distrib_lattice (semiring (semiring empty))) := sorry --non-trivial
lemma new_lemma_128455 (h0 : functor.add_const (topological_space (non_assoc_semiring empty)) empty) : @totally_separated_space.{0} (non_assoc_semiring.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (non_assoc_semiring.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_128456 (h0 : function.extfun Type topological_space) : @path_connected_space.{0} (has_top.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_top.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_128457 (h0 : functor.add_const (complete_lattice (has_add Type)) environment.implicit_infer_kind) : @complete_lattice.is_Sup_finite_compact.{1} (has_add.{1} Type) (@functor.add_const.run.{1 0} (complete_lattice.{1} (has_add.{1} Type)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_128458 (h0 : functor.comp topological_space boolean_algebra.core name) : @irreducible_space.{0} (boolean_algebra.core.{0} name) (@functor.comp.run.{0 0 0} topological_space.{0} boolean_algebra.core.{0} name h0)  := sorry --non-trivial
lemma new_lemma_128459 (h0 : topological_space (nondiscrete_normed_field ereal)) (h1 : preorder (nondiscrete_normed_field ereal)) : order_closed_topology (nondiscrete_normed_field ereal) := sorry --non-trivial
lemma new_lemma_128460 (h0 : functor.add_const (topological_space (normed_comm_ring linarith.comp)) Type) : @t0_space.{0} (normed_comm_ring.{0} linarith.comp) (@functor.add_const.run.{0 1} (topological_space.{0} (normed_comm_ring.{0} linarith.comp)) Type h0)  := sorry --non-trivial
lemma new_lemma_128461 (h0 : functor.add_const (filter (add_cancel_monoid linarith.comp)) (complete_distrib_lattice name)) : countable_Inter_filter (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_128462 (h0 : function.extfun nat fin) : @topological_space.separable_space.{0} (canonically_linear_ordered_monoid.{0} real) (@function.extfun_app.{2 1} Type topological_space.{0} (@matrix.vec_empty.{1} (function.extfun.{2 1} Type topological_space.{0}) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero))) (canonically_linear_ordered_monoid.{0} real))  := sorry --non-trivial
lemma new_lemma_128463 (h0 : functor.add_const (topological_space (semiring num)) num) : @t0_space.{0} (semiring.{0} num) (@functor.add_const.run.{0 0} (topological_space.{0} (semiring.{0} num)) num h0)  := sorry --non-trivial
lemma new_lemma_128464 (h0 : topological_space (complete_distrib_lattice (semigroup Type))) : preconnected_space (complete_distrib_lattice (semigroup Type)) := sorry --non-trivial
lemma new_lemma_128465 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @sequential_space.{0} (pseudo_metric_space.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (pseudo_metric_space.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_128466 (h0 : fin has_zero.zero) : @is_add_cyclic.{1} (normed_lattice_add_comm_group.{1} Type) (@matrix.vec_empty.{1} (add_group.{1} (normed_lattice_add_comm_group.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_128467 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @archimedean.{0} (canonically_ordered_comm_semiring.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type ordered_add_comm_monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ordered_add_comm_monoid.{0}) (canonically_ordered_comm_semiring.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_128468 (h0 : ring (has_inv char)) : is_domain (has_inv char) := sorry --non-trivial
lemma new_lemma_128469 (h0 : group (ordered_comm_monoid (has_Inf (has_pos_part pos)))) : is_cyclic (ordered_comm_monoid (has_Inf (has_pos_part pos))) := sorry --non-trivial
lemma new_lemma_128470 (h0 : not (ring (random_gen (metric_space char)) -> false)) : @strong_rank_condition.{0} (random_gen.{0} (metric_space.{0} char)) (@classical.by_contradiction'.{1} (ring.{0} (random_gen.{0} (metric_space.{0} char))) h0)  := sorry --non-trivial
lemma new_lemma_128471 (h0 : topological_space (complete_semilattice_Sup (semiring empty))) : totally_separated_space (complete_semilattice_Sup (semiring empty)) := sorry --non-trivial
lemma new_lemma_128472 (h0 : function.extfun (finset Type) (has_mem.mem congr_arg_kind)) : @normalizer_condition.{0} congr_arg_kind (@finset.pi.empty.{1 0} Type group.{0} congr_arg_kind (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) congr_arg_kind) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_128473 (h0 : topological_space (dlist (random_gen char))) : totally_disconnected_space (dlist (random_gen char)) := sorry --non-trivial
lemma new_lemma_128474 (h0 : ordered_comm_monoid (has_add (has_Inf Type))) : has_exists_mul_of_le (has_add (has_Inf Type)) := sorry --non-trivial
lemma new_lemma_128475 (h0 : monoid (lex (option (option (option ennreal))))) : monoid.fg (lex (option (option (option ennreal)))) := sorry --non-trivial
lemma new_lemma_128476 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @strong_rank_condition.{0} (normed_group.{0} linarith.comp) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (normed_group.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_128477 (h0 : topological_space (has_compl (random_gen reducibility_hints)) -> Prop) (h1 : Exists (fun (x : topological_space (has_compl (random_gen reducibility_hints))), h0 x)) : @totally_disconnected_space.{0} (has_compl.{0} (random_gen.{0} reducibility_hints)) (@classical.some.{1} (topological_space.{0} (has_compl.{0} (random_gen.{0} reducibility_hints))) h0 h1)  := sorry --non-trivial
lemma new_lemma_128478 (h0 : complete_lattice (semigroup (has_neg linarith.comp))) : complete_lattice.is_Sup_finite_compact (semigroup (has_neg linarith.comp)) := sorry --non-trivial
lemma new_lemma_128479 (h0 : not (group (with_one to_additive.value_type) -> false)) : @normalizer_condition.{0} (with_one.{0} to_additive.value_type) (@classical.by_contradiction'.{1} (group.{0} (with_one.{0} to_additive.value_type)) h0)  := sorry --non-trivial
lemma new_lemma_128480 (h0 : function.extfun Type semiring) : @is_noetherian_ring.{0} (has_add.{0} ennreal) (@function.extfun_app.{2 1} Type semiring.{0} h0 (has_add.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_128481 (h1 : set (has_nnnorm std_gen)) : set.subsingleton h1 := sorry --non-trivial
lemma new_lemma_128482 (h0 : ring (semigroup (has_to_string (comm_group unsigned)))) : is_principal_ideal_ring (semigroup (has_to_string (comm_group unsigned))) := sorry --non-trivial
lemma new_lemma_128483 (h1 : function.extfun Type ring) : @is_domain.{0} (@id.{2} Type linarith.ineq) (@function.extfun_app.{2 1} Type ring.{0} h1 (@id.{2} Type linarith.ineq))  := sorry --non-trivial
lemma new_lemma_128484 (h0 : functor.add_const (function.extfun Type topological_space) Type) : @t1_space.{0} (finset.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type topological_space.{0}) Type h0) (finset.{0} pos))  := sorry --non-trivial
lemma new_lemma_128485 (h0 : finset (group_with_zero ennreal)) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_128486 (h0 : functor.add_const (topological_space (group_with_zero unsigned)) unsigned) : @loc_path_connected_space.{0} (group_with_zero.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (group_with_zero.{0} unsigned)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_128487 (h0 : complete_lattice (div_inv_monoid to_additive.value_type)) : is_compactly_generated (div_inv_monoid to_additive.value_type) := sorry --non-trivial
lemma new_lemma_128488 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @rank_condition.{0} (add_left_cancel_semigroup.{0} unsigned) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (add_left_cancel_semigroup.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_128489 (h0 : function.extfun Type topological_space) : @locally_compact_space.{0} (complete_semilattice_Sup.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (complete_semilattice_Sup.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_128490 (h0 : function.extfun Type topological_space) : @t0_space.{0} (normed_group.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (normed_group.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_128491 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @irreducible_space.{1} (has_add.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 topological_space.{1}) (has_add.{1} Type))  := sorry --non-trivial
lemma new_lemma_128492 (h0 : topological_space (has_le (mul_one_class (nondiscrete_normed_field enat)))) : path_connected_space (has_le (mul_one_class (nondiscrete_normed_field enat))) := sorry --non-trivial
lemma new_lemma_128493 (h0 : topological_space (has_pos_part (has_add linarith.comp))) : topological_space.separable_space (has_pos_part (has_add linarith.comp)) := sorry --non-trivial
lemma new_lemma_128494 (h0 : not (function.extfun Type topological_space -> false)) : @discrete_topology.{0} (metric_space.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (metric_space.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_128495 (h0 : group (monoid_with_zero unsigned)) : normalizer_condition (monoid_with_zero unsigned) := sorry --non-trivial
lemma new_lemma_128496 (h0 : not (topological_space (has_div enat) -> false)) : @totally_disconnected_space.{0} (has_div.{0} enat) (@classical.by_contradiction'.{1} (topological_space.{0} (has_div.{0} enat)) h0)  := sorry --non-trivial
lemma new_lemma_128497 (h0 : topological_space (topological_space linarith.ineq)) : locally_compact_space (topological_space linarith.ineq) := sorry --non-trivial
lemma new_lemma_128498 (h0 : topological_space (nondiscrete_normed_field char)) (h1 : set (nondiscrete_normed_field char)) : is_path_connected h1 := sorry --non-trivial
lemma new_lemma_128499 (h0 : topological_space (boolean_algebra (comm_group (has_add Type)))) : t1_space (boolean_algebra (comm_group (has_add Type))) := sorry --non-trivial
lemma new_lemma_128500 (h0 : semiring (linear_order congr_arg_kind)) : is_noetherian_ring (linear_order congr_arg_kind) := sorry --non-trivial
lemma new_lemma_128501 (h0 : functor.add_const (function.extfun Type ring) Type) : @is_domain.{0} (has_pos_part.{0} pos) (@function.extfun_app.{2 1} Type ring.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type ring.{0}) Type h0) (has_pos_part.{0} pos))  := sorry --non-trivial
lemma new_lemma_128502 (h1 : complete_lattice (with_bot (with_bot linarith.ineq))) : complete_lattice.is_Sup_finite_compact (with_bot (with_bot linarith.ineq)) := sorry --non-trivial
lemma new_lemma_128503 (h0 : function.extfun Type (functor.comp cancel_comm_monoid_with_zero has_nndist)) : @unique_factorization_monoid.{0} (has_nndist.{0} name) (@functor.comp.run.{0 0 0} cancel_comm_monoid_with_zero.{0} has_nndist.{0} name (@function.extfun_app.{2 1} Type (functor.comp.{0 0 0} cancel_comm_monoid_with_zero.{0} has_nndist.{0}) h0 name))  := sorry --non-trivial
lemma new_lemma_128504 (h0 : topological_space (complete_distrib_lattice (option pos))) : irreducible_space (complete_distrib_lattice (option pos)) := sorry --non-trivial
lemma new_lemma_128505 (h0 : function.extfun (finset (Type -> Type)) (has_mem.mem complete_lattice)) : @complete_lattice.is_Sup_finite_compact.{0} fun_info (@function.extfun_app.{2 1} Type complete_lattice.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) complete_lattice.{0} (@function.extfun_app.{2 0} (finset.{1} (Type → Type)) (@has_mem.mem.{1 1} (Type → Type) (finset.{1} (Type → Type)) (@finset.has_mem.{1} (Type → Type)) complete_lattice.{0}) h0 (@has_emptyc.emptyc.{1} (finset.{1} (Type → Type)) (@finset.has_emptyc.{1} (Type → Type))))) fun_info)  := sorry --non-trivial
lemma new_lemma_128506 (h0 : ring (linear_ordered_semiring (random_gen num))) : rank_condition (linear_ordered_semiring (random_gen num)) := sorry --non-trivial
lemma new_lemma_128507 (h0 : functor.add_const (function.extfun Type group) (has_neg linarith.comp)) : @is_simple_group.{0} (ring.{0} linarith.comp) (@function.extfun_app.{2 1} Type group.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type group.{0}) (has_neg.{0} linarith.comp) h0) (ring.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_128508 (h0 : functor.add_const (group (comm_group Type)) (has_neg (has_neg linarith.comp))) : @is_simple_group.{1} (comm_group.{1} Type) (@functor.add_const.run.{1 0} (group.{1} (comm_group.{1} Type)) (has_neg.{0} (has_neg.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_128509 (h0 : not (topological_space (semi_normed_ring linarith.ineq) -> false)) : @totally_disconnected_space.{0} (semi_normed_ring.{0} linarith.ineq) (@classical.by_contradiction'.{1} (topological_space.{0} (semi_normed_ring.{0} linarith.ineq)) h0)  := sorry --non-trivial
lemma new_lemma_128510 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : finset.nonempty (function.extfun_app (function.extfun_app h0 finset) (mul_zero_class Type)) := sorry --non-trivial
lemma new_lemma_128511 (h0 : topological_space (ordered_comm_monoid (has_add linarith.comp))) : t0_space (ordered_comm_monoid (has_add linarith.comp)) := sorry --non-trivial
lemma new_lemma_128512 (h0 : functor.add_const (function.extfun Type ordered_comm_monoid) linarith.comp) : @has_exists_mul_of_le.{0} (has_Inf.{0} linarith.comp) (@function.extfun_app.{2 1} Type ordered_comm_monoid.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type ordered_comm_monoid.{0}) linarith.comp h0) (has_Inf.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_128513 (h0 : function.extfun nat fin) : @complete_space.{0} (canonically_ordered_comm_semiring.{0} name) (@matrix.vec_empty.{0} (uniform_space.{0} (canonically_ordered_comm_semiring.{0} name)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_128514 (h0 : functor.add_const (filter (finset pos)) pos) : filter.ne_bot (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_128515 (h0 : functor.add_const (topological_space (option num)) num) : @totally_separated_space.{0} (option.{0} num) (@functor.add_const.run.{0 0} (topological_space.{0} (option.{0} num)) num h0)  := sorry --non-trivial
lemma new_lemma_128516 (h0 : topological_space (complete_distrib_lattice (finset linarith.comp))) : regular_space (complete_distrib_lattice (finset linarith.comp)) := sorry --non-trivial
lemma new_lemma_128517 (h0 : functor.add_const (function.extfun (Type 1) cancel_comm_monoid_with_zero) (has_add linarith.comp)) : @unique_factorization_monoid.{1} (has_Inf.{1} Type) (@function.extfun_app.{3 2} (Type 1) cancel_comm_monoid_with_zero.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) cancel_comm_monoid_with_zero.{1}) (has_add.{0} linarith.comp) h0) (has_Inf.{1} Type))  := sorry --non-trivial
lemma new_lemma_128518 (h0 : fin has_zero.zero) : @is_principal_ideal_ring.{0} (has_pos_part.{0} linarith.comp) (@matrix.vec_empty.{0} (ring.{0} (has_pos_part.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_128519 (h0 : functor.add_const (topological_space (ordered_comm_monoid Type)) (ring name)) : @preirreducible_space.{1} (ordered_comm_monoid.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (ordered_comm_monoid.{1} Type)) (ring.{0} name) h0)  := sorry --non-trivial
lemma new_lemma_128520 (h0 : uniform_space (has_append to_additive.value_type)) : complete_space (has_append to_additive.value_type) := sorry --non-trivial
lemma new_lemma_128521 (h0 : functor.add_const (ring (semigroup environment.implicit_infer_kind)) linarith.comp) : @rank_condition.{0} (semigroup.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (ring.{0} (semigroup.{0} environment.implicit_infer_kind)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_128522 (h0 : topological_space (semiring (has_top (has_norm linarith.comp_source)))) : irreducible_space (semiring (has_top (has_norm linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_128523 (h0 : ring (distrib_lattice (random_gen (has_ssubset char)))) : strong_rank_condition (distrib_lattice (random_gen (has_ssubset char))) := sorry --non-trivial
lemma new_lemma_128524 (h0 : ring (bin_tree (semiring num))) : strong_rank_condition (bin_tree (semiring num)) := sorry --non-trivial
lemma new_lemma_128525 (h0 : group (semi_normed_comm_ring linarith.ineq)) : group.fg (semi_normed_comm_ring linarith.ineq) := sorry --non-trivial
lemma new_lemma_128526 (h0 : topological_space (add_cancel_monoid (has_neg Type))) : t0_space (add_cancel_monoid (has_neg Type)) := sorry --non-trivial
lemma new_lemma_128527 (h0 : measurable_space (nondiscrete_normed_field enat)) (h1 : filter (nondiscrete_normed_field enat)) : filter.is_measurably_generated h1 := sorry --non-trivial
lemma new_lemma_128528 (h0 : filter (add_cancel_monoid (comm_group unsigned))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_128529 (h0 : functor.add_const (complete_lattice (has_Sup unsigned)) num) : @is_compactly_generated.{0} (has_Sup.{0} unsigned) (@functor.add_const.run.{0 0} (complete_lattice.{0} (has_Sup.{0} unsigned)) num h0)  := sorry --non-trivial
lemma new_lemma_128530 (h0 : prod (boolean_algebra Type) (boolean_algebra Type)) : id_rel h0 := sorry --non-trivial
lemma new_lemma_128531 (h0 : topological_space (ordered_comm_ring (has_neg linarith.comp))) : totally_separated_space (ordered_comm_ring (has_neg linarith.comp)) := sorry --non-trivial
lemma new_lemma_128532 (h0 : functor.add_const (complete_lattice (partial_order empty)) empty) : @is_atomistic.{0} (partial_order.{0} empty) (@functor.add_const.run.{0 0} (complete_lattice.{0} (partial_order.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_128533 (h1 : complete_lattice (random_gen string_imp)) : is_atomistic (random_gen string_imp) := sorry --non-trivial
lemma new_lemma_128534 (h0 : topological_space (cancel_monoid (option (option (option empty))))) : path_connected_space (cancel_monoid (option (option (option empty)))) := sorry --non-trivial
lemma new_lemma_128535 (h0 : ring (partial_order char)) : rank_condition (partial_order char) := sorry --non-trivial
lemma new_lemma_128536 (h0 : has_neg (linear_ordered_comm_group_with_zero std_gen)) (h1 : measurable_space (linear_ordered_comm_group_with_zero std_gen)) : has_measurable_neg (linear_ordered_comm_group_with_zero std_gen) := sorry --non-trivial
lemma new_lemma_128537 (h0 : function.extfun nat fin) : @loc_path_connected_space.{0} (sub_neg_monoid.{0} name) (@matrix.vec_empty.{0} (topological_space.{0} (sub_neg_monoid.{0} name)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_128538 (h0 : functor.add_const (add_monoid Type) (finset linarith.comp)) : @add_monoid.fg.{1} Type (@functor.add_const.run.{1 0} (add_monoid.{1} Type) (finset.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_128539 (h0 : functor.add_const (function.extfun (Type 1) list) pos) : palindrome (function.extfun_app (functor.add_const.run h0) (has_neg Type)) := sorry --non-trivial
lemma new_lemma_128540 (h1 : has_le (add_comm_semigroup (mul_one_class char))) (h2 : add_comm_semigroup (mul_one_class char)) : is_bot h2 := sorry --non-trivial
lemma new_lemma_128541 (h0 : functor.add_const (function.extfun Type complete_lattice) linarith.comp) : @is_compactly_generated.{0} (ring.{0} linarith.comp) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type complete_lattice.{0}) linarith.comp h0) (ring.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_128542 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : filter.ne_bot (function.extfun_app (function.extfun_app h0 filter) (linear_ordered_semiring empty)) := sorry --non-trivial
lemma new_lemma_128543 (h0 : topological_space (add_cancel_comm_monoid char)) (h1 : preorder (add_cancel_comm_monoid char)) : order_topology (add_cancel_comm_monoid char) := sorry --non-trivial
lemma new_lemma_128544 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @has_exists_mul_of_le.{0} (ordered_cancel_add_comm_monoid.{0} (option.{0} pos)) (@function.extfun_app.{2 1} Type ordered_comm_monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ordered_comm_monoid.{0}) (ordered_cancel_add_comm_monoid.{0} (option.{0} pos)))  := sorry --non-trivial
lemma new_lemma_128545 (h0 : functor.add_const (ring (normed_group unsigned)) (option empty)) : @is_principal_ideal_ring.{0} (normed_group.{0} unsigned) (@functor.add_const.run.{0 0} (ring.{0} (normed_group.{0} unsigned)) (option.{0} empty) h0)  := sorry --non-trivial
lemma new_lemma_128546 (h0 : group (complete_semilattice_Sup empty)) : group.fg (complete_semilattice_Sup empty) := sorry --non-trivial
lemma new_lemma_128547 (h0 : functor.add_const (list (add_cancel_monoid linarith.comp)) linarith.comp) : list.nodup (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_128548 (h0 : function.extfun Type topological_space) (h1 : functor.add_const (has_mul (ordered_ring unsigned)) num) : @has_continuous_mul.{0} (ordered_ring.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (ordered_ring.{0} unsigned)) (@functor.add_const.run.{0 0} (has_mul.{0} (ordered_ring.{0} unsigned)) num h1)  := sorry --non-trivial
lemma new_lemma_128549 (h0 : functor.comp topological_space has_neg_part Type) : @irreducible_space.{1} (has_neg_part.{1} Type) (@functor.comp.run.{1 1 1} topological_space.{1} has_neg_part.{1} Type h0)  := sorry --non-trivial
lemma new_lemma_128550 (h0 : add_group (has_ssubset string.iterator_imp)) : is_add_cyclic (has_ssubset string.iterator_imp) := sorry --non-trivial
lemma new_lemma_128551 (h0 : functor.add_const (topological_space (partial_order congr_arg_kind)) unsigned) : @t1_space.{0} (partial_order.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (partial_order.{0} congr_arg_kind)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_128552 (h0 : functor.add_const (topological_space (finset name)) environment.implicit_infer_kind) : @loc_path_connected_space.{0} (finset.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (finset.{0} name)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_128553 (h0 : option Type) (h1 : topological_space (option.get_or_else h0 unsigned)) (h2 : measurable_space (option.get_or_else h0 unsigned)) : opens_measurable_space (option.get_or_else h0 unsigned) := sorry --non-trivial
lemma new_lemma_128554 (h0 : semiring (has_neg (normed_comm_ring Type))) : is_noetherian_ring (has_neg (normed_comm_ring Type)) := sorry --non-trivial
lemma new_lemma_128555 (h0 : topological_space (complete_semilattice_Sup (random_gen string_imp))) : locally_compact_space (complete_semilattice_Sup (random_gen string_imp)) := sorry --non-trivial
lemma new_lemma_128556 (h0 : topological_space (random_gen string_imp)) : totally_disconnected_space (random_gen string_imp) := sorry --non-trivial
lemma new_lemma_128557 (h0 : group (cancel_monoid pos)) : normalizer_condition (cancel_monoid pos) := sorry --non-trivial
lemma new_lemma_128558 (h0 : ring (has_sub (semiring (semiring unsigned)))) : rank_condition (has_sub (semiring (semiring unsigned))) := sorry --non-trivial
lemma new_lemma_128559 (h0 : functor.comp filter pseudo_metric_space unsigned) : filter.ne_bot (functor.comp.run h0) := sorry --non-trivial
lemma new_lemma_128560 (h0 : complete_lattice (add_group num)) : is_atomistic (add_group num) := sorry --non-trivial
lemma new_lemma_128561 (h0 : topological_space (has_nndist (has_well_founded name))) : normal_space (has_nndist (has_well_founded name)) := sorry --non-trivial
lemma new_lemma_128562 (h0 : topological_space (cancel_monoid ennreal)) : regular_space (cancel_monoid ennreal) := sorry --non-trivial
lemma new_lemma_128563 (h0 : ring (distrib_lattice (has_ssubset fun_info))) : rank_condition (distrib_lattice (has_ssubset fun_info)) := sorry --non-trivial
lemma new_lemma_128564 (h0 : group (finset (option ennreal))) : is_simple_group (finset (option ennreal)) := sorry --non-trivial
lemma new_lemma_128565 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @discrete_topology.{0} (sub_neg_monoid.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (sub_neg_monoid.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_128566 (h0 : functor.add_const (complete_lattice (preorder num)) congr_arg_kind) : @complete_lattice.is_Sup_finite_compact.{0} (preorder.{0} num) (@functor.add_const.run.{0 0} (complete_lattice.{0} (preorder.{0} num)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_128567 (h0 : ring (complete_linear_order (semiring congr_arg_kind))) : rank_condition (complete_linear_order (semiring congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_128568 (h0 : topological_space (has_emptyc (has_top (has_top fun_info)))) : t0_space (has_emptyc (has_top (has_top fun_info))) := sorry --non-trivial
lemma new_lemma_128569 (h0 : function.extfun Type complete_lattice) : @is_compactly_generated.{0} (canonically_ordered_comm_semiring.{0} name) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (canonically_ordered_comm_semiring.{0} name))  := sorry --non-trivial
lemma new_lemma_128570 (h0 : function.extfun Type topological_space) : @loc_path_connected_space.{0} (ordered_comm_ring.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (ordered_comm_ring.{0} name))  := sorry --non-trivial
lemma new_lemma_128571 (h0 : filter (distrib_lattice (has_ssubset fun_info))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_128572 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @path_connected_space.{0} (has_top.{0} linarith.ineq) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_top.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_128573 (h0 : functor.add_const (uniform_space (bin_tree congr_arg_kind)) empty) : @separated_space.{0} (bin_tree.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (uniform_space.{0} (bin_tree.{0} congr_arg_kind)) empty h0)  := sorry --non-trivial
lemma new_lemma_128574 (h0 : functor.add_const Prop (has_Inf (ring Type))) : functor.add_const.run h0 := sorry --non-trivial
lemma new_lemma_128575 (h0 : topological_space (nondiscrete_normed_field std_gen)) (h1 : preorder (nondiscrete_normed_field std_gen)) : order_topology (nondiscrete_normed_field std_gen) := sorry --non-trivial
lemma new_lemma_128576 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @rank_condition.{0} (normed_comm_ring.{0} linarith.comp) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (normed_comm_ring.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_128577 (h0 : add_group (distrib (has_nnnorm linarith.comp_source))) : is_add_cyclic (distrib (has_nnnorm linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_128578 (h0 : add_group (add_cancel_monoid (has_neg pos))) : is_add_cyclic (add_cancel_monoid (has_neg pos)) := sorry --non-trivial
lemma new_lemma_128579 (h0 : functor.add_const (topological_space empty) unsigned) : totally_separated_space empty := sorry --non-trivial
lemma new_lemma_128580 (h0 : functor.add_const (ring (semigroup empty)) num) : @rank_condition.{0} (semigroup.{0} empty) (@functor.add_const.run.{0 0} (ring.{0} (semigroup.{0} empty)) num h0)  := sorry --non-trivial
lemma new_lemma_128581 (h0 : uniform_space (has_nndist linarith.comp)) : complete_space (has_nndist linarith.comp) := sorry --non-trivial
lemma new_lemma_128582 (h0 : functor.add_const (functor.add_const (complete_lattice (cancel_monoid linarith.comp)) linarith.comp) Type) : @complete_lattice.is_Sup_finite_compact.{0} (cancel_monoid.{0} linarith.comp) (@functor.add_const.run.{0 0} (complete_lattice.{0} (cancel_monoid.{0} linarith.comp)) linarith.comp (@functor.add_const.run.{0 1} (functor.add_const.{0 0} (complete_lattice.{0} (cancel_monoid.{0} linarith.comp)) linarith.comp) Type h0))  := sorry --non-trivial
lemma new_lemma_128583 (h0 : functor.add_const (uniform_space (has_zero linarith.comp)) linarith.comp) : @separated_space.{0} (has_zero.{0} linarith.comp) (@functor.add_const.run.{0 0} (uniform_space.{0} (has_zero.{0} linarith.comp)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_128584 (h0 : topological_space (has_top (random_gen (random_gen fun_info)))) : totally_disconnected_space (has_top (random_gen (random_gen fun_info))) := sorry --non-trivial
lemma new_lemma_128585 (h0 : function.extfun Type list) : list.nodup (function.extfun_app h0 (non_assoc_semiring unsigned)) := sorry --non-trivial
lemma new_lemma_128586 (h0 : not (topological_space (random_gen congr_arg_kind) -> false)) : @discrete_topology.{0} (random_gen.{0} congr_arg_kind) (@classical.by_contradiction'.{1} (topological_space.{0} (random_gen.{0} congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_128587 (h0 : filter (canonically_linear_ordered_monoid num)) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_128588 (h0 : topological_space (semigroup (comm_group Type))) : loc_path_connected_space (semigroup (comm_group Type)) := sorry --non-trivial
lemma new_lemma_128589 (h0 : uniform_space (add_comm_monoid (option unsigned))) : separated_space (add_comm_monoid (option unsigned)) := sorry --non-trivial
lemma new_lemma_128590 (h0 : ring (boolean_algebra (ring (has_add linarith.comp)))) : strong_rank_condition (boolean_algebra (ring (has_add linarith.comp))) := sorry --non-trivial
lemma new_lemma_128591 (h0 : topological_space (with_bot (has_norm (has_norm num)))) : totally_separated_space (with_bot (has_norm (has_norm num))) := sorry --non-trivial
lemma new_lemma_128592 (h0 : uniform_space (has_nndist (boolean_algebra.core ennreal))) : complete_space (has_nndist (boolean_algebra.core ennreal)) := sorry --non-trivial
lemma new_lemma_128593 (h0 : function.extfun Type topological_space) : @regular_space.{0} (has_bot.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_bot.{0} pos))  := sorry --non-trivial
lemma new_lemma_128594 (h0 : function.extfun Type (functor.add_const (monoid (has_Sup empty)))) : @monoid.fg.{0} (has_Sup.{0} empty) (@functor.add_const.run.{0 0} (monoid.{0} (has_Sup.{0} empty)) empty (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (monoid.{0} (has_Sup.{0} empty))) h0 empty))  := sorry --non-trivial
lemma new_lemma_128595 (h0 : topological_space (nondiscrete_normed_field environment.projection_info)) : totally_disconnected_space (nondiscrete_normed_field environment.projection_info) := sorry --non-trivial
lemma new_lemma_128596 (h0 : functor.add_const (group (boolean_algebra unsigned)) pos) : @group.fg.{0} (boolean_algebra.{0} unsigned) (@functor.add_const.run.{0 0} (group.{0} (boolean_algebra.{0} unsigned)) pos h0)  := sorry --non-trivial
lemma new_lemma_128597 (h0 : function.extfun (finset Type) (has_mem.mem (measurable_space fun_info))) : @rank_condition.{0} (measurable_space.{0} fun_info) (@finset.pi.empty.{1 0} Type ring.{0} (measurable_space.{0} fun_info) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (measurable_space.{0} fun_info)) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_128598 (h0 : ring (semiring (semiring empty))) : is_principal_ideal_ring (semiring (semiring empty)) := sorry --non-trivial
lemma new_lemma_128599 (h0 : ring (normed_group linarith.ineq)) : is_domain (normed_group linarith.ineq) := sorry --non-trivial
lemma new_lemma_128600 (h0 : functor.add_const (semiring (simple_graph linarith.comp)) (has_pos_part (has_add Type))) : @is_noetherian_ring.{0} (simple_graph.{0} linarith.comp) (@functor.add_const.run.{0 1} (semiring.{0} (simple_graph.{0} linarith.comp)) (has_pos_part.{1} (has_add.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_128601 (h0 : ring (monoid (option ennreal))) : rank_condition (monoid (option ennreal)) := sorry --non-trivial
lemma new_lemma_128602 (h0 : function.extfun Type complete_lattice) : @complete_lattice.is_Sup_finite_compact.{0} (ordered_comm_ring.{0} linarith.comp) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (ordered_comm_ring.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_128603 (h1 : function.extfun (Type -> Type) (function.extfun Type)) : @is_add_cyclic.{0} congr_arg_kind (@function.extfun_app.{2 1} Type add_group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h1 add_group.{0}) congr_arg_kind)  := sorry --non-trivial
lemma new_lemma_128604 (h0 : uniform_space (plift (plift unsigned))) : separated_space (plift (plift unsigned)) := sorry --non-trivial
lemma new_lemma_128605 (h0 : functor.add_const (topological_space (monoid ennreal)) ennreal) : @preconnected_space.{0} (monoid.{0} ennreal) (@functor.add_const.run.{0 0} (topological_space.{0} (monoid.{0} ennreal)) ennreal h0)  := sorry --non-trivial
lemma new_lemma_128606 (h0 : function.extfun Type topological_space) : @topological_space.separable_space.{0} (semigroup.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (semigroup.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_128607 (h0 : ring (has_neg (has_to_string congr_arg_kind))) : is_domain (has_neg (has_to_string congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_128608 (h0 : topological_space (ring (comm_group name))) : discrete_topology (ring (comm_group name)) := sorry --non-trivial
lemma new_lemma_128609 (h0 : functor.add_const (topological_space (has_neg_part name)) (option unsigned)) : @t1_space.{0} (has_neg_part.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (has_neg_part.{0} name)) (option.{0} unsigned) h0)  := sorry --non-trivial
lemma new_lemma_128610 (h0 : cancel_comm_monoid_with_zero (pseudo_metric_space unsigned)) : unique_factorization_monoid (pseudo_metric_space unsigned) := sorry --non-trivial
lemma new_lemma_128611 (h0 : functor.add_const (topological_space (generalized_boolean_algebra Type)) name) : @preirreducible_space.{1} (generalized_boolean_algebra.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (generalized_boolean_algebra.{1} Type)) name h0)  := sorry --non-trivial
lemma new_lemma_128612 (h0 : functor.add_const (topological_space (cancel_monoid linarith.comp)) name) : @normal_space.{0} (cancel_monoid.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (cancel_monoid.{0} linarith.comp)) name h0)  := sorry --non-trivial
lemma new_lemma_128613 (h0 : ring (semigroup Type)) : strong_rank_condition (semigroup Type) := sorry --non-trivial
lemma new_lemma_128614 (h0 : ring (omega_complete_partial_order (option empty))) : rank_condition (omega_complete_partial_order (option empty)) := sorry --non-trivial
lemma new_lemma_128615 (h0 : functor.add_const (ordered_comm_monoid (ring environment.implicit_infer_kind)) environment.implicit_infer_kind) : @has_exists_mul_of_le.{0} (ring.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (ordered_comm_monoid.{0} (ring.{0} environment.implicit_infer_kind)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_128616 (h0 : ring (has_sub (random_gen to_additive.value_type))) : is_domain (has_sub (random_gen to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_128617 (h0 : list (pseudo_metric_space (finset (finset name)))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_128618 (h0 : ordered_comm_monoid (canonically_ordered_monoid (has_pos_part name))) : has_exists_mul_of_le (canonically_ordered_monoid (has_pos_part name)) := sorry --non-trivial
lemma new_lemma_128619 (h0 : ring (has_pos_part (has_add real))) : strong_rank_condition (has_pos_part (has_add real)) := sorry --non-trivial
lemma new_lemma_128620 (h0 : add_group (has_one (semiring num))) : is_add_cyclic (has_one (semiring num)) := sorry --non-trivial
lemma new_lemma_128621 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @loc_path_connected_space.{0} (has_dist.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_dist.{0} num))  := sorry --non-trivial
lemma new_lemma_128622 (h0 : not (group (has_compl linarith.comp_source) -> false)) : @is_cyclic.{0} (has_compl.{0} linarith.comp_source) (@classical.by_contradiction'.{1} (group.{0} (has_compl.{0} linarith.comp_source)) h0)  := sorry --non-trivial
lemma new_lemma_128623 (h0 : topological_space (with_bot (has_inv linarith.ineq))) : irreducible_space (with_bot (has_inv linarith.ineq)) := sorry --non-trivial
lemma new_lemma_128624 (h0 : function.extfun Type ring) : @is_domain.{0} (has_neg_part.{0} pos) (@function.extfun_app.{2 1} Type ring.{0} h0 (has_neg_part.{0} pos))  := sorry --non-trivial
lemma new_lemma_128625 (h0 : ring (boolean_algebra.core pos)) : rank_condition (boolean_algebra.core pos) := sorry --non-trivial
lemma new_lemma_128626 (h0 : complete_lattice (has_to_string (has_to_string (has_pos_part (has_add name))))) : is_compactly_generated (has_to_string (has_to_string (has_pos_part (has_add name)))) := sorry --non-trivial
lemma new_lemma_128627 (h1 : list (has_emptyc (random_gen (with_bot linarith.ineq)))) : list.nodup h1 := sorry --non-trivial
lemma new_lemma_128628 (h0 : function.extfun Type add_monoid) : @add_monoid.fg.{0} (ordered_comm_group.{0} unsigned) (@function.extfun_app.{2 1} Type add_monoid.{0} h0 (ordered_comm_group.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_128629 (h0 : function.extfun Type list) : list.nodup (function.extfun_app h0 (has_top (random_gen (random_gen (random_gen fun_info))))) := sorry --non-trivial
lemma new_lemma_128630 (h0 : functor.comp uniform_space semigroup name) : @separated_space.{0} (semigroup.{0} name) (@functor.comp.run.{0 0 0} uniform_space.{0} semigroup.{0} name h0)  := sorry --non-trivial
lemma new_lemma_128631 (h0 : functor.comp complete_lattice cancel_monoid environment.implicit_infer_kind) : @is_compactly_generated.{0} (cancel_monoid.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (complete_lattice.{0} (cancel_monoid.{0} environment.implicit_infer_kind)) pos (@functor.comp.run.{0 0 0} complete_lattice.{0} cancel_monoid.{0} environment.implicit_infer_kind h0))  := sorry --non-trivial
lemma new_lemma_128632 (h0 : ring (canonically_linear_ordered_monoid (has_Inf (has_Inf real)))) : is_domain (canonically_linear_ordered_monoid (has_Inf (has_Inf real))) := sorry --non-trivial
lemma new_lemma_128633 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_compactly_generated.{0} (ordered_ring.{0} (semiring.{0} unsigned)) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (ordered_ring.{0} (semiring.{0} unsigned)))  := sorry --non-trivial
lemma new_lemma_128634 (h0 : functor.add_const (ring (finset environment.implicit_infer_kind)) unsigned) : @is_principal_ideal_ring.{0} (finset.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (ring.{0} (finset.{0} environment.implicit_infer_kind)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_128635 (h0 : group (boolean_algebra.core (has_Inf (has_Inf pos)))) : group.fg (boolean_algebra.core (has_Inf (has_Inf pos))) := sorry --non-trivial
lemma new_lemma_128636 (h0 : not (function.extfun Type topological_space -> false)) : discrete_topology empty := sorry --non-trivial
lemma new_lemma_128637 (h0 : functor.add_const (semiring (semigroup linarith.comp)) (has_nndist environment.implicit_infer_kind)) : @is_noetherian_ring.{0} (semigroup.{0} linarith.comp) (@functor.add_const.run.{0 0} (semiring.{0} (semigroup.{0} linarith.comp)) (has_nndist.{0} environment.implicit_infer_kind) h0)  := sorry --non-trivial
lemma new_lemma_128638 (h0 : topological_space (has_nndist (ring (has_add linarith.comp)))) : loc_path_connected_space (has_nndist (ring (has_add linarith.comp))) := sorry --non-trivial
lemma new_lemma_128639 (h0 : not (add_monoid (has_union linarith.comp) -> false)) : @add_monoid.fg.{0} (has_union.{0} linarith.comp) (@classical.by_contradiction'.{1} (add_monoid.{0} (has_union.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_128640 (h0 : function.extfun Type ordered_add_comm_monoid) : @archimedean.{0} (normed_comm_ring.{0} ennreal) (@function.extfun_app.{2 1} Type ordered_add_comm_monoid.{0} h0 (normed_comm_ring.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_128641 (h0 : functor.add_const (ring (has_to_string unsigned)) (has_neg_part Type)) : @is_domain.{0} (has_to_string.{0} unsigned) (@functor.add_const.run.{0 1} (ring.{0} (has_to_string.{0} unsigned)) (has_neg_part.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_128642 (h0 : ordered_add_comm_monoid (canonically_ordered_comm_semiring num)) : archimedean (canonically_ordered_comm_semiring num) := sorry --non-trivial
lemma new_lemma_128643 (h0 : topological_space (has_zero (option name))) : locally_compact_space (has_zero (option name)) := sorry --non-trivial
lemma new_lemma_128644 (h0 : uniform_space (id (has_norm (has_top congr_arg_kind)))) : complete_space (id (has_norm (has_top congr_arg_kind))) := sorry --non-trivial
lemma new_lemma_128645 (h0 : complete_lattice (simple_graph linarith.ineq)) : is_compactly_generated (simple_graph linarith.ineq) := sorry --non-trivial
lemma new_lemma_128646 (h0 : not (function.extfun Type group -> false)) : @normalizer_condition.{0} (has_star.{0} unsigned) (@function.extfun_app.{2 1} Type group.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type group.{0}) h0) (has_star.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_128647 (h0 : topological_space (has_zero ennreal)) : t1_space (has_zero ennreal) := sorry --non-trivial
lemma new_lemma_128648 (h0 : preorder environment.projection_info) (h1 : set environment.projection_info) : set.is_pwo h1 := sorry --non-trivial
lemma new_lemma_128649 (h0 : filter (denumerable (has_nnnorm linarith.ineq))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_128650 (h0 : group (measurable_space (random_gen (random_gen string_imp)))) : normalizer_condition (measurable_space (random_gen (random_gen string_imp))) := sorry --non-trivial
lemma new_lemma_128651 (h0 : list (has_top (has_ssubset (has_ssubset to_additive.value_type)))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_128652 (h0 : add_comm_monoid (add_comm_monoid pos) -> add_comm_monoid (add_comm_monoid pos) -> Prop) : is_symm (add_comm_monoid (add_comm_monoid pos)) h0 := sorry --non-trivial
lemma new_lemma_128653 (h1 : group linarith.comp) : group.fg linarith.comp := sorry --non-trivial
lemma new_lemma_128654 (h0 : uniform_space (ordered_comm_ring (finset (finset (ring linarith.comp))))) : complete_space (ordered_comm_ring (finset (finset (ring linarith.comp)))) := sorry --non-trivial
lemma new_lemma_128655 (h1 : not (topological_space reducibility_hints -> false)) : @path_connected_space.{0} reducibility_hints (@classical.by_contradiction'.{1} (topological_space.{0} reducibility_hints) h1)  := sorry --non-trivial
lemma new_lemma_128656 (h0 : functor.add_const (monoid (linear_ordered_cancel_comm_monoid unsigned)) unsigned) : @monoid.fg.{0} (linear_ordered_cancel_comm_monoid.{0} unsigned) (@functor.add_const.run.{0 0} (monoid.{0} (linear_ordered_cancel_comm_monoid.{0} unsigned)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_128657 : infinite name := sorry --non-trivial
lemma new_lemma_128658 (h0 : uniform_space (normed_comm_ring empty)) : complete_space (normed_comm_ring empty) := sorry --non-trivial
lemma new_lemma_128659 (h0 : topological_space (linear_ordered_comm_group empty)) : t0_space (linear_ordered_comm_group empty) := sorry --non-trivial
lemma new_lemma_128660 (h0 : functor.add_const (function.extfun Type ordered_add_comm_monoid) pos) : @archimedean.{0} (has_add.{0} pos) (@function.extfun_app.{2 1} Type ordered_add_comm_monoid.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type ordered_add_comm_monoid.{0}) pos h0) (has_add.{0} pos))  := sorry --non-trivial
lemma new_lemma_128661 (h0 : ring (has_neg_part (finset environment.implicit_infer_kind))) : is_principal_ideal_ring (has_neg_part (finset environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_128662 (h0 : function.extfun Type ring) : @strong_rank_condition.{0} (has_neg_part.{0} empty) (@function.extfun_app.{2 1} Type ring.{0} h0 (has_neg_part.{0} empty))  := sorry --non-trivial
lemma new_lemma_128663 (h1 : not (topological_space (add_monoid char) -> false)) : @totally_disconnected_space.{0} (add_monoid.{0} char) (@classical.by_contradiction'.{1} (topological_space.{0} (add_monoid.{0} char)) h1)  := sorry --non-trivial
lemma new_lemma_128664 (h0 : functor.comp ring has_neg Type) : @rank_condition.{1} (has_neg.{1} Type) (@functor.comp.run.{1 1 1} ring.{1} has_neg.{1} Type h0)  := sorry --non-trivial
lemma new_lemma_128665 (h0 : ring (has_inter ennreal)) : is_domain (has_inter ennreal) := sorry --non-trivial
lemma new_lemma_128666 (h0 : functor.add_const (ordered_add_comm_monoid (finset pos)) (boolean_algebra linarith.comp)) : @archimedean.{0} (finset.{0} pos) (@functor.add_const.run.{0 0} (ordered_add_comm_monoid.{0} (finset.{0} pos)) (boolean_algebra.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_128667 (h0 : topological_space (ring (has_add (has_add (has_add (has_add Type)))))) : t1_space (ring (has_add (has_add (has_add (has_add Type))))) := sorry --non-trivial
lemma new_lemma_128668 (h0 : uniform_space (metric_space (semiring congr_arg_kind))) : separated_space (metric_space (semiring congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_128669 (h0 : functor.add_const (complete_lattice (canonically_ordered_comm_semiring Type)) Type) : @is_atomistic.{1} (canonically_ordered_comm_semiring.{1} Type) (@functor.add_const.run.{1 1} (complete_lattice.{1} (canonically_ordered_comm_semiring.{1} Type)) Type h0)  := sorry --non-trivial
lemma new_lemma_128670 (h0 : topological_space (left_cancel_monoid congr_arg_kind)) : locally_compact_space (left_cancel_monoid congr_arg_kind) := sorry --non-trivial
lemma new_lemma_128671 (h0 : complete_lattice (mul_zero_class (finset name))) : is_atomistic (mul_zero_class (finset name)) := sorry --non-trivial
lemma new_lemma_128672 (h0 : uniform_space (linear_ordered_add_comm_group (random_gen (random_gen linarith.ineq)))) : complete_space (linear_ordered_add_comm_group (random_gen (random_gen linarith.ineq))) := sorry --non-trivial
lemma new_lemma_128673 (h0 : function.extfun Type group) : @is_cyclic.{0} (distrib_lattice.{0} linarith.ineq) (@function.extfun_app.{2 1} Type group.{0} h0 (distrib_lattice.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_128674 (h0 : group (has_zero (has_add (ring Type)))) : is_simple_group (has_zero (has_add (ring Type))) := sorry --non-trivial
lemma new_lemma_128675 (h0 : not (ring (mul_zero_class num) -> false)) : @strong_rank_condition.{0} (mul_zero_class.{0} num) (@classical.by_contradiction'.{1} (ring.{0} (mul_zero_class.{0} num)) h0)  := sorry --non-trivial
lemma new_lemma_128676 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @sequential_space.{0} (has_neg.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_neg.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_128677 (h0 : add_group (boolean_algebra (comm_group Type))) : is_add_cyclic (boolean_algebra (comm_group Type)) := sorry --non-trivial
lemma new_lemma_128678 (h0 : monoid (has_top (has_top (semiring (semiring unsigned))))) : monoid.fg (has_top (has_top (semiring (semiring unsigned)))) := sorry --non-trivial
lemma new_lemma_128679 (h0 : functor.add_const (topological_space (mul_zero_class pos)) Type) : @totally_disconnected_space.{0} (mul_zero_class.{0} pos) (@functor.add_const.run.{0 1} (topological_space.{0} (mul_zero_class.{0} pos)) Type h0)  := sorry --non-trivial
lemma new_lemma_128680 (h0 : function.extfun Type ring) : @rank_condition.{0} (omega_complete_partial_order.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type ring.{0} h0 (omega_complete_partial_order.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_128681 (h0 : functor.add_const (semiring (semigroup pos)) environment.implicit_infer_kind) : @is_noetherian_ring.{0} (semigroup.{0} pos) (@functor.add_const.run.{0 0} (semiring.{0} (semigroup.{0} pos)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_128682 (h0 : topological_space (ring Type)) : preirreducible_space (ring Type) := sorry --non-trivial
lemma new_lemma_128683 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @strong_rank_condition.{0} (complete_semilattice_Sup.{0} fun_info) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (complete_semilattice_Sup.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_128684 (h0 : group (boolean_algebra (has_to_string (ring name)))) : group.fg (boolean_algebra (has_to_string (ring name))) := sorry --non-trivial
lemma new_lemma_128685 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @normal_space.{1} (cancel_monoid.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 topological_space.{1}) (cancel_monoid.{1} Type))  := sorry --non-trivial
lemma new_lemma_128686 (h0 : ordered_add_comm_monoid (has_neg_part (has_nndist pos))) : archimedean (has_neg_part (has_nndist pos)) := sorry --non-trivial
lemma new_lemma_128687 (h0 : function.extfun Type topological_space) : @preirreducible_space.{0} (ordered_comm_monoid.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (ordered_comm_monoid.{0} name))  := sorry --non-trivial
lemma new_lemma_128688 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @rank_condition.{1} (has_zero.{1} Type) (@function.extfun_app.{3 2} (Type 1) ring.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 ring.{1}) (has_zero.{1} Type))  := sorry --non-trivial
lemma new_lemma_128689 (h0 : function.extfun Type complete_lattice) : @complete_lattice.is_Sup_finite_compact.{0} (has_union.{0} (has_norm.{0} num)) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (has_union.{0} (has_norm.{0} num)))  := sorry --non-trivial
lemma new_lemma_128690 (h0 : function.extfun Type topological_space) : @preirreducible_space.{0} (monoid.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (monoid.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_128691 (h0 : not (topological_space (topological_space reducibility_hints) -> false)) : @path_connected_space.{0} (topological_space.{0} reducibility_hints) (@classical.by_contradiction'.{1} (topological_space.{0} (topological_space.{0} reducibility_hints)) h0)  := sorry --non-trivial
lemma new_lemma_128692 (h0 : not (function.extfun (Type -> Type) (function.extfun Type) -> false)) : @totally_separated_space.{0} (complete_semilattice_Sup.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) (@classical.by_contradiction'.{2} (function.extfun.{2 2} (Type → Type) (function.extfun.{2 1} Type)) h0) topological_space.{0}) (complete_semilattice_Sup.{0} empty))  := sorry --non-trivial
lemma new_lemma_128693 (h0 : add_group (has_compl (mul_one_class fun_info))) : is_add_cyclic (has_compl (mul_one_class fun_info)) := sorry --non-trivial
lemma new_lemma_128694 (h0 : monoid (with_one (semiring empty))) : monoid.fg (with_one (semiring empty)) := sorry --non-trivial
lemma new_lemma_128695 (h0 : cancel_comm_monoid_with_zero (left_cancel_semigroup (semiring empty))) : unique_factorization_monoid (left_cancel_semigroup (semiring empty)) := sorry --non-trivial
lemma new_lemma_128696 (h0 : function.extfun Type complete_lattice) : complete_lattice.is_Sup_finite_compact (filter unsigned) := sorry --non-trivial
lemma new_lemma_128697 (h0 : functor.add_const (functor.add_const (complete_lattice (comm_group linarith.comp)) (finset pos)) name) : @complete_lattice.is_Sup_finite_compact.{0} (comm_group.{0} linarith.comp) (@functor.add_const.run.{0 0} (complete_lattice.{0} (comm_group.{0} linarith.comp)) (finset.{0} pos) (@functor.add_const.run.{0 0} (functor.add_const.{0 0} (complete_lattice.{0} (comm_group.{0} linarith.comp)) (finset.{0} pos)) name h0))  := sorry --non-trivial
lemma new_lemma_128698 (h0 : functor.add_const (topological_space (canonically_ordered_monoid linarith.comp)) name) : @regular_space.{0} (canonically_ordered_monoid.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (canonically_ordered_monoid.{0} linarith.comp)) name h0)  := sorry --non-trivial
lemma new_lemma_128699 (h0 : function.extfun Type group) : @is_cyclic.{0} (canonically_ordered_monoid.{0} pos) (@function.extfun_app.{2 1} Type group.{0} h0 (canonically_ordered_monoid.{0} pos))  := sorry --non-trivial
lemma new_lemma_128700 (h0 : not (topological_space (random_gen fun_info) -> false)) : @t0_space.{0} (random_gen.{0} fun_info) (@classical.by_contradiction'.{1} (topological_space.{0} (random_gen.{0} fun_info)) h0)  := sorry --non-trivial
lemma new_lemma_128701 (h1 : group (has_ssubset string_imp)) : is_cyclic (has_ssubset string_imp) := sorry --non-trivial
lemma new_lemma_128702 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_compactly_generated.{0} (mul_zero_class.{0} ennreal) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (mul_zero_class.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_128703 (h0 : group (comm_group (add_cancel_monoid (has_neg name)))) : normalizer_condition (comm_group (add_cancel_monoid (has_neg name))) := sorry --non-trivial
lemma new_lemma_128704 (h0 : add_group (semi_normed_comm_ring (has_nnnorm int))) : is_add_cyclic (semi_normed_comm_ring (has_nnnorm int)) := sorry --non-trivial
lemma new_lemma_128705 (h0 : not (ring (bin_tree unsigned) -> false)) : @strong_rank_condition.{0} (bin_tree.{0} unsigned) (@classical.by_contradiction'.{1} (ring.{0} (bin_tree.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_128706 (h0 : not (function.extfun (Type -> Type) (function.extfun Type) -> false)) : @normal_space.{0} (complete_semilattice_Sup.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) (@classical.by_contradiction'.{2} (function.extfun.{2 2} (Type → Type) (function.extfun.{2 1} Type)) h0) topological_space.{0}) (complete_semilattice_Sup.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_128707 (h0 : has_mem.mem (complete_semilattice_Sup num) has_emptyc.emptyc) : @group.fg.{0} (complete_semilattice_Sup.{0} num) (@finset.pi.empty.{1 0} Type group.{0} (complete_semilattice_Sup.{0} num) h0)  := sorry --non-trivial
lemma new_lemma_128708 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @separated_space.{0} (with_bot.{0} unsigned) (@function.extfun_app.{2 1} Type uniform_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 uniform_space.{0}) (with_bot.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_128709 (h0 : linear_ordered_field (option pos) -> linear_ordered_field (option pos) -> Prop) : is_symm (linear_ordered_field (option pos)) h0 := sorry --non-trivial
lemma new_lemma_128710 (h1 : complete_lattice (normed_field (normed_field (normed_field linarith.ineq)))) : complete_lattice.is_Sup_finite_compact (normed_field (normed_field (normed_field linarith.ineq))) := sorry --non-trivial
lemma new_lemma_128711 (h0 : topological_space (distrib_lattice (has_ssubset to_additive.value_type))) : t0_space (distrib_lattice (has_ssubset to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_128712 (h0 : functor.add_const (topological_space (boolean_algebra.core pos)) unsigned) : @t0_space.{0} (boolean_algebra.core.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (boolean_algebra.core.{0} pos)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_128713 (h0 : functor.add_const (add_monoid (bin_tree empty)) num) : @add_monoid.fg.{0} (bin_tree.{0} empty) (@functor.add_const.run.{0 0} (add_monoid.{0} (bin_tree.{0} empty)) num h0)  := sorry --non-trivial
lemma new_lemma_128714 (h0 : ring (add_cancel_monoid name)) : is_domain (add_cancel_monoid name) := sorry --non-trivial
lemma new_lemma_128715 (h0 : uniform_space (plift (semiring (semiring (semiring (semiring (semiring empty))))))) : complete_space (plift (semiring (semiring (semiring (semiring (semiring empty)))))) := sorry --non-trivial
lemma new_lemma_128716 (h0 : function.extfun Type uniform_space) : @complete_space.{0} (canonically_ordered_comm_semiring.{0} ennreal) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (canonically_ordered_comm_semiring.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_128717 (h0 : not (group (complete_semilattice_Sup linarith.comp_source) -> false)) : @is_cyclic.{0} (complete_semilattice_Sup.{0} linarith.comp_source) (@classical.by_contradiction'.{1} (group.{0} (complete_semilattice_Sup.{0} linarith.comp_source)) h0)  := sorry --non-trivial
lemma new_lemma_128718 (h0 : group (id (with_bot linarith.ineq))) : group.fg (id (with_bot linarith.ineq)) := sorry --non-trivial
lemma new_lemma_128719 (h0 : topological_space (with_one (has_norm unsigned))) : path_connected_space (with_one (has_norm unsigned)) := sorry --non-trivial
lemma new_lemma_128720 (h1 : ring (has_emptyc fun_info)) : is_domain (has_emptyc fun_info) := sorry --non-trivial
lemma new_lemma_128721 (h0 : function.extfun Type filter) : filter.ne_bot (function.extfun_app h0 linarith.comp) := sorry --non-trivial
lemma new_lemma_128722 (h0 : filter (add_cancel_monoid ennreal)) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_128723 (h0 : list (has_inter empty)) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_128724 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_domain.{0} (ring.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (ring.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_128725 (h0 : complete_lattice (boolean_algebra (has_add Type))) : complete_lattice.is_Sup_finite_compact (boolean_algebra (has_add Type)) := sorry --non-trivial
lemma new_lemma_128726 (h0 : function.extfun (Type 1) semiring) : @is_noetherian_ring.{1} (has_to_string.{1} Type) (@function.extfun_app.{3 2} (Type 1) semiring.{1} h0 (has_to_string.{1} Type))  := sorry --non-trivial
lemma new_lemma_128727 (h0 : function.extfun Type topological_space) : @irreducible_space.{0} (linear_ordered_field.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (linear_ordered_field.{0} pos))  := sorry --non-trivial
lemma new_lemma_128728 (h0 : functor.add_const (ring (ring pos)) linarith.comp) : @is_principal_ideal_ring.{0} (ring.{0} pos) (@functor.add_const.run.{0 0} (ring.{0} (ring.{0} pos)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_128729 (h0 : add_monoid (bin_tree unsigned)) : add_monoid.fg (bin_tree unsigned) := sorry --non-trivial
lemma new_lemma_128730 (h0 : topological_space (has_to_string (has_add (has_add (has_add Type))))) : topological_space.separable_space (has_to_string (has_add (has_add (has_add Type)))) := sorry --non-trivial
lemma new_lemma_128731 (h0 : not (topological_space (add_right_cancel_monoid num) -> false)) : @irreducible_space.{0} (add_right_cancel_monoid.{0} num) (@classical.by_contradiction'.{1} (topological_space.{0} (add_right_cancel_monoid.{0} num)) h0)  := sorry --non-trivial
lemma new_lemma_128732 (h0 : functor.add_const (finset (add_cancel_monoid name)) unsigned) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_128733 (h0 : function.extfun Type add_monoid) : @add_monoid.fg.{0} (has_to_string.{0} num) (@function.extfun_app.{2 1} Type add_monoid.{0} h0 (has_to_string.{0} num))  := sorry --non-trivial
lemma new_lemma_128734 (h0 : functor.add_const (ordered_comm_monoid (boolean_algebra unsigned)) (add_left_cancel_semigroup Type)) : @has_exists_mul_of_le.{0} (boolean_algebra.{0} unsigned) (@functor.add_const.run.{0 1} (ordered_comm_monoid.{0} (boolean_algebra.{0} unsigned)) (add_left_cancel_semigroup.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_128735 (h0 : add_monoid (ring (comm_group environment.implicit_infer_kind))) : add_monoid.fg (ring (comm_group environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_128736 (h0 : function.extfun Type (functor.add_const (topological_space (add_cancel_comm_monoid empty)))) : @path_connected_space.{0} (add_cancel_comm_monoid.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (add_cancel_comm_monoid.{0} empty)) empty (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (topological_space.{0} (add_cancel_comm_monoid.{0} empty))) h0 empty))  := sorry --non-trivial
lemma new_lemma_128737 (h0 : list (mul_zero_class Type)) : palindrome h0 := sorry --non-trivial
lemma new_lemma_128738 (h0 : not (ring (semiring unsigned) -> false)) : @rank_condition.{0} (semiring.{0} unsigned) (@classical.by_contradiction'.{1} (ring.{0} (semiring.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_128739 (h0 : complete_lattice (add_cancel_comm_monoid to_additive.value_type)) : complete_lattice.is_Sup_finite_compact (add_cancel_comm_monoid to_additive.value_type) := sorry --non-trivial
lemma new_lemma_128740 (h0 : prod (ring name) (ring name)) : id_rel h0 := sorry --non-trivial
lemma new_lemma_128741 (h0 : not (add_group (add_left_cancel_monoid fun_info) -> false)) : @is_add_cyclic.{0} (add_left_cancel_monoid.{0} fun_info) (@classical.by_contradiction'.{1} (add_group.{0} (add_left_cancel_monoid.{0} fun_info)) h0)  := sorry --non-trivial
lemma new_lemma_128742 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_domain.{0} (boolean_algebra.core.{0} pos) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (boolean_algebra.core.{0} pos))  := sorry --non-trivial
lemma new_lemma_128743 (h0 : topological_space (cancel_monoid (has_add pos))) : preconnected_space (cancel_monoid (has_add pos)) := sorry --non-trivial
lemma new_lemma_128744 (h0 : group (has_lt to_additive.value_type)) (h1 : subgroup (has_lt to_additive.value_type)) : subgroup.fg h1 := sorry --non-trivial
lemma new_lemma_128745 (h0 : not (complete_lattice linarith.ineq -> false)) : @is_compactly_generated.{0} linarith.ineq (@classical.by_contradiction'.{1} (complete_lattice.{0} linarith.ineq) h0)  := sorry --non-trivial
lemma new_lemma_128746 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : palindrome (function.extfun_app (function.extfun_app h0 list) (ordered_comm_ring linarith.comp)) := sorry --non-trivial
lemma new_lemma_128747 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_cyclic.{0} (has_emptyc.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (has_emptyc.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_128748 (h0 : not (ring (has_nnnorm enat) -> false)) : @strong_rank_condition.{0} (has_nnnorm.{0} enat) (@classical.by_contradiction'.{1} (ring.{0} (has_nnnorm.{0} enat)) h0)  := sorry --non-trivial
lemma new_lemma_128749 (h0 : functor.add_const (ring (has_star unsigned)) unsigned) : @is_principal_ideal_ring.{0} (has_star.{0} unsigned) (@functor.add_const.run.{0 0} (ring.{0} (has_star.{0} unsigned)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_128750 (h0 : group (has_zero (has_neg Type))) : normalizer_condition (has_zero (has_neg Type)) := sorry --non-trivial
lemma new_lemma_128751 (h0 : not (add_group (normed_group num) -> false)) : @is_add_cyclic.{0} (normed_group.{0} num) (@classical.by_contradiction'.{1} (add_group.{0} (normed_group.{0} num)) h0)  := sorry --non-trivial
lemma new_lemma_128752 (h0 : topological_space (boolean_algebra (finset (ring linarith.comp)))) : t1_space (boolean_algebra (finset (ring linarith.comp))) := sorry --non-trivial
lemma new_lemma_128753 (h3 : ring linarith.ineq) : is_domain linarith.ineq := sorry --non-trivial
lemma new_lemma_128754 (h0 : functor.add_const (group (has_neg_part name)) unsigned) : @is_cyclic.{0} (has_neg_part.{0} name) (@functor.add_const.run.{0 0} (group.{0} (has_neg_part.{0} name)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_128755 (h0 : list (finset (mul_one_class linarith.comp))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_128756 (h0 : measurable_space (non_unital_non_assoc_semiring string.iterator_imp)) (h1 : measure_theory.measure (non_unital_non_assoc_semiring string.iterator_imp)) : measure_theory.is_finite_measure h1 := sorry --non-trivial
lemma new_lemma_128757 (h0 : functor.add_const (function.extfun Type topological_space) (finset Type)) : @t0_space.{0} (finset.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type topological_space.{0}) (finset.{1} Type) h0) (finset.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_128758 (h0 : finset (add_cancel_monoid num)) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_128759 (h0 : ring (has_pos_part (has_Inf (has_add (has_pos_part (has_Inf (has_Inf Type))))))) : is_principal_ideal_ring (has_pos_part (has_Inf (has_add (has_pos_part (has_Inf (has_Inf Type)))))) := sorry --non-trivial
lemma new_lemma_128760 (h0 : function.extfun (Type 1) topological_space) : @loc_path_connected_space.{1} (generalized_boolean_algebra.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} h0 (generalized_boolean_algebra.{1} Type))  := sorry --non-trivial
lemma new_lemma_128761 (h0 : prod (ordered_ring (semiring (semiring empty))) (ordered_ring (semiring (semiring empty)))) : id_rel h0 := sorry --non-trivial
lemma new_lemma_128762 (h1 : set (linarith.ineq -> linarith.ineq)) : set.separates_points h1 := sorry --non-trivial
lemma new_lemma_128763 (h0 : functor.add_const (function.extfun Type topological_space) name) : @preirreducible_space.{0} (add_cancel_monoid.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) name h0) (add_cancel_monoid.{0} name))  := sorry --non-trivial
lemma new_lemma_128764 (h0 : topological_space (has_zero (option pos))) : locally_compact_space (has_zero (option pos)) := sorry --non-trivial
lemma new_lemma_128765 (h0 : functor.add_const (uniform_space (has_zero environment.implicit_infer_kind)) linarith.comp) : @complete_space.{0} (has_zero.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (uniform_space.{0} (has_zero.{0} environment.implicit_infer_kind)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_128766 (h0 : add_monoid (preorder (semiring (semiring (semiring num))))) : add_monoid.fg (preorder (semiring (semiring (semiring num)))) := sorry --non-trivial
lemma new_lemma_128767 (h0 : complete_lattice (linear_ordered_field ennreal)) : is_compactly_generated (linear_ordered_field ennreal) := sorry --non-trivial
lemma new_lemma_128768 (h0 : ring (linear_order unsigned)) : is_principal_ideal_ring (linear_order unsigned) := sorry --non-trivial
lemma new_lemma_128769 (h0 : prod (bin_tree unsigned) (bin_tree unsigned)) : id_rel h0 := sorry --non-trivial
lemma new_lemma_128770 (h0 : functor.add_const (uniform_space (normed_comm_ring Type)) linarith.comp) : @complete_space.{1} (normed_comm_ring.{1} Type) (@functor.add_const.run.{1 0} (uniform_space.{1} (normed_comm_ring.{1} Type)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_128771 (h0 : functor.add_const (add_group (add_comm_monoid pos)) Type) : @is_add_cyclic.{0} (add_comm_monoid.{0} pos) (@functor.add_const.run.{0 1} (add_group.{0} (add_comm_monoid.{0} pos)) Type h0)  := sorry --non-trivial
lemma new_lemma_128772 (h0 : set (add_comm_semigroup fun_info -> add_comm_semigroup fun_info)) : set.separates_points h0 := sorry --non-trivial
lemma new_lemma_128773 (h0 : not (topological_space (add_monoid (has_nnnorm char)) -> false)) : @path_connected_space.{0} (add_monoid.{0} (has_nnnorm.{0} char)) (@classical.by_contradiction'.{1} (topological_space.{0} (add_monoid.{0} (has_nnnorm.{0} char))) h0)  := sorry --non-trivial
lemma new_lemma_128774 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @rank_condition.{0} (preorder.{0} empty) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (preorder.{0} empty))  := sorry --non-trivial
lemma new_lemma_128775 (h0 : not (group (has_nnnorm linarith.comp_source) -> false)) : @is_cyclic.{0} (has_nnnorm.{0} linarith.comp_source) (@classical.by_contradiction'.{1} (group.{0} (has_nnnorm.{0} linarith.comp_source)) h0)  := sorry --non-trivial
lemma new_lemma_128776 (h0 : topological_space (dlist (random_gen fun_info))) : path_connected_space (dlist (random_gen fun_info)) := sorry --non-trivial
lemma new_lemma_128777 (h0 : functor.add_const (ring (linear_order empty)) empty) : @is_principal_ideal_ring.{0} (linear_order.{0} empty) (@functor.add_const.run.{0 0} (ring.{0} (linear_order.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_128778 (h0 : ring (left_cancel_monoid unsigned)) : rank_condition (left_cancel_monoid unsigned) := sorry --non-trivial
lemma new_lemma_128779 (h0 : function.extfun Type topological_space) : @preirreducible_space.{0} (linear_ordered_comm_group.{0} ennreal) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (linear_ordered_comm_group.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_128780 (h0 : list (finset (comm_group name))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_128781 (h0 : add_group (has_append (mul_one_class to_additive.value_type))) : is_add_cyclic (has_append (mul_one_class to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_128782 (h0 : complete_lattice (comm_semigroup real)) : complete_lattice.is_Sup_finite_compact (comm_semigroup real) := sorry --non-trivial
lemma new_lemma_128783 (h0 : topological_space (has_pos_part (finset (boolean_algebra (has_add pos))))) : preconnected_space (has_pos_part (finset (boolean_algebra (has_add pos)))) := sorry --non-trivial
lemma new_lemma_128784 (h0 : topological_space (sub_neg_monoid linarith.comp)) : totally_separated_space (sub_neg_monoid linarith.comp) := sorry --non-trivial
lemma new_lemma_128785 (h0 : has_ssubset (denumerable linarith.ineq) -> has_ssubset (denumerable linarith.ineq) -> bool) : is_dec_refl h0 := sorry --non-trivial
lemma new_lemma_128786 (h0 : topological_space (distrib_lattice (has_inv fun_info))) : path_connected_space (distrib_lattice (has_inv fun_info)) := sorry --non-trivial
lemma new_lemma_128787 (h0 : complete_lattice (comm_semigroup (has_Inf (has_bot (has_bot real))))) : is_compactly_generated (comm_semigroup (has_Inf (has_bot (has_bot real)))) := sorry --non-trivial
lemma new_lemma_128788 (h0 : function.extfun Type ordered_add_comm_monoid) : @archimedean.{0} (canonically_ordered_comm_semiring.{0} empty) (@function.extfun_app.{2 1} Type ordered_add_comm_monoid.{0} h0 (canonically_ordered_comm_semiring.{0} empty))  := sorry --non-trivial
lemma new_lemma_128789 (h0 : ereal) (h2 : sym2 ereal) : sym2.mem h0 h2 := sorry --non-trivial
lemma new_lemma_128790 (h0 : topological_space (has_nndist congr_arg_kind)) : normal_space (has_nndist congr_arg_kind) := sorry --non-trivial
lemma new_lemma_128791 (h0 : has_mem.mem (linear_ordered_add_comm_group fun_info) has_emptyc.emptyc) : @totally_separated_space.{0} (linear_ordered_add_comm_group.{0} fun_info) (@finset.pi.empty.{1 0} Type topological_space.{0} (linear_ordered_add_comm_group.{0} fun_info) h0)  := sorry --non-trivial
lemma new_lemma_128792 (h0 : uniform_space (has_norm (random_gen (random_gen fun_info)))) : complete_space (has_norm (random_gen (random_gen fun_info))) := sorry --non-trivial
lemma new_lemma_128793 (h0 : functor.add_const (add_group (linear_ordered_add_comm_group (has_nnnorm linarith.comp_source))) string_imp) : @is_add_cyclic.{0} (linear_ordered_add_comm_group.{0} (has_nnnorm.{0} linarith.comp_source)) (@functor.add_const.run.{0 0} (add_group.{0} (linear_ordered_add_comm_group.{0} (has_nnnorm.{0} linarith.comp_source))) string_imp h0)  := sorry --non-trivial
lemma new_lemma_128794 (h0 : filter (add_group num)) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_128795 (h0 : function.extfun Type topological_space) : @regular_space.{0} (complete_distrib_lattice.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (complete_distrib_lattice.{0} pos))  := sorry --non-trivial
lemma new_lemma_128796 (h0 : functor.add_const (topological_space (has_add pos)) linarith.comp) : @sequential_space.{0} (has_add.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (has_add.{0} pos)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_128797 (h0 : topological_space (has_ssubset (random_gen string.iterator_imp))) : t0_space (has_ssubset (random_gen string.iterator_imp)) := sorry --non-trivial
lemma new_lemma_128798 (h0 : fin has_zero.zero) : @archimedean.{0} (canonically_ordered_monoid.{0} real) (@function.extfun_app.{2 1} Type ordered_add_comm_monoid.{0} (@matrix.vec_empty.{1} (function.extfun.{2 1} Type ordered_add_comm_monoid.{0}) h0) (canonically_ordered_monoid.{0} real))  := sorry --non-trivial
lemma new_lemma_128799 (h0 : functor.add_const (topological_space (left_cancel_semigroup num)) unsigned) : @t1_space.{0} (left_cancel_semigroup.{0} num) (@functor.add_const.run.{0 0} (topological_space.{0} (left_cancel_semigroup.{0} num)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_128800 (h0 : uniform_space (semiring (semiring (semiring linarith.comp)))) : complete_space (semiring (semiring (semiring linarith.comp))) := sorry --non-trivial
lemma new_lemma_128801 (h0 : function.extfun Type ring) : @strong_rank_condition.{0} (has_add.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type ring.{0} h0 (has_add.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_128802 (h0 : add_group (has_norm empty)) : is_add_cyclic (has_norm empty) := sorry --non-trivial
lemma new_lemma_128803 (h0 : semiring (monoid_with_zero (option unsigned))) : is_noetherian_ring (monoid_with_zero (option unsigned)) := sorry --non-trivial
lemma new_lemma_128804 (h1 : add_group (has_compl (has_ssubset (add_left_cancel_monoid (has_inv string_imp))))) : is_add_cyclic (has_compl (has_ssubset (add_left_cancel_monoid (has_inv string_imp)))) := sorry --non-trivial
lemma new_lemma_128805 (h0 : monoid (has_star (option unsigned))) : monoid.fg (has_star (option unsigned)) := sorry --non-trivial
lemma new_lemma_128806 (h0 : topological_space (semi_normed_comm_ring (semi_normed_ring reducibility_hints))) : totally_disconnected_space (semi_normed_comm_ring (semi_normed_ring reducibility_hints)) := sorry --non-trivial
lemma new_lemma_128807 (h0 : topological_space (has_add (has_nnnorm (has_inv fun_info)))) : path_connected_space (has_add (has_nnnorm (has_inv fun_info))) := sorry --non-trivial
lemma new_lemma_128808 (h0 : group (boolean_algebra (has_to_string (has_to_string pos)))) : normalizer_condition (boolean_algebra (has_to_string (has_to_string pos))) := sorry --non-trivial
lemma new_lemma_128809 (h0 : topological_space (has_neg_part (semigroup Type))) : loc_path_connected_space (has_neg_part (semigroup Type)) := sorry --non-trivial
lemma new_lemma_128810 (h0 : topological_space (has_dist (option (option (option empty))))) : preirreducible_space (has_dist (option (option (option empty)))) := sorry --non-trivial
lemma new_lemma_128811 (h0 : measurable_space (has_nndist (add_comm_monoid Type))) (h1 : set (has_nndist (add_comm_monoid Type))) : measurable_set h1 := sorry --non-trivial
lemma new_lemma_128812 (h0 : complete_lattice (cancel_monoid (option ennreal))) : is_atomistic (cancel_monoid (option ennreal)) := sorry --non-trivial
lemma new_lemma_128813 (h0 : functor.add_const (ring (ordered_ring empty)) empty) : @strong_rank_condition.{0} (ordered_ring.{0} empty) (@functor.add_const.run.{0 0} (ring.{0} (ordered_ring.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_128814 (h0 : functor.add_const (function.extfun Type finset) Type) : finset.nonempty (function.extfun_app (functor.add_const.run h0) (has_to_string unsigned)) := sorry --non-trivial
lemma new_lemma_128815 (h0 : ordered_add_comm_monoid (canonically_ordered_comm_semiring linarith.comp)) : archimedean (canonically_ordered_comm_semiring linarith.comp) := sorry --non-trivial
lemma new_lemma_128816 (h0 : functor.add_const (complete_lattice (canonically_ordered_add_monoid empty)) (semiring (semiring (semiring empty)))) : @complete_lattice.is_Sup_finite_compact.{0} (canonically_ordered_add_monoid.{0} empty) (@functor.add_const.run.{0 0} (complete_lattice.{0} (canonically_ordered_add_monoid.{0} empty)) (semiring.{0} (semiring.{0} (semiring.{0} empty))) h0)  := sorry --non-trivial
lemma new_lemma_128817 (h0 : functor.add_const (topological_space (normed_linear_ordered_group unsigned)) empty) : @path_connected_space.{0} (normed_linear_ordered_group.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (normed_linear_ordered_group.{0} unsigned)) empty h0)  := sorry --non-trivial
lemma new_lemma_128818 (h0 : monoid (ring (has_add (rel (add_cancel_monoid pos) name)))) : monoid.fg (ring (has_add (rel (add_cancel_monoid pos) name))) := sorry --non-trivial
lemma new_lemma_128819 (h0 : group (linear_ordered_semiring (has_top empty))) : group.fg (linear_ordered_semiring (has_top empty)) := sorry --non-trivial
lemma new_lemma_128820 (h0 : not (function.extfun Type uniform_space -> false)) : @separated_space.{0} (has_norm.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type uniform_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type uniform_space.{0}) h0) (has_norm.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_128821 (h0 : function.extfun Type topological_space) : @irreducible_space.{0} (with_one.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (with_one.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_128822 (h0 : function.extfun Type topological_space) : @locally_compact_space.{0} (boolean_algebra.core.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (boolean_algebra.core.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_128823 (h0 : functor.add_const (topological_space (has_neg_part unsigned)) pos) : @regular_space.{0} (has_neg_part.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (has_neg_part.{0} unsigned)) pos h0)  := sorry --non-trivial
lemma new_lemma_128824 (h0 : function.extfun Type topological_space) : @locally_compact_space.{0} linarith.comp (@function.extfun_app.{2 1} Type topological_space.{0} h0 linarith.comp)  := sorry --non-trivial
lemma new_lemma_128825 (h0 : function.extfun Type topological_space) : @t1_space.{0} (ordered_cancel_add_comm_monoid.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (ordered_cancel_add_comm_monoid.{0} empty))  := sorry --non-trivial
lemma new_lemma_128826 (h0 : topological_space (linear_ordered_comm_monoid_with_zero (option empty))) : t1_space (linear_ordered_comm_monoid_with_zero (option empty)) := sorry --non-trivial
lemma new_lemma_128827 (h0 : functor.add_const (group (finset linarith.comp)) linarith.comp) : @is_simple_group.{0} (finset.{0} linarith.comp) (@functor.add_const.run.{0 0} (group.{0} (finset.{0} linarith.comp)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_128828 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @normalizer_condition.{0} (has_norm.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (has_norm.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_128829 (h2 : not (topological_space reducibility_hints -> false)) : @totally_disconnected_space.{0} reducibility_hints (@classical.by_contradiction'.{1} (topological_space.{0} reducibility_hints) h2)  := sorry --non-trivial
lemma new_lemma_128830 (h0 : ordered_add_comm_monoid (ordered_comm_ring (has_neg pos))) : archimedean (ordered_comm_ring (has_neg pos)) := sorry --non-trivial
lemma new_lemma_128831 (h0 : functor.add_const (group (partial_order empty)) num) : @group.fg.{0} (partial_order.{0} empty) (@functor.add_const.run.{0 0} (group.{0} (partial_order.{0} empty)) num h0)  := sorry --non-trivial
lemma new_lemma_128832 (h0 : filter (comm_group (cancel_monoid (option (option ennreal))))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_128833 (h3 : add_group (distrib char)) : is_add_cyclic (distrib char) := sorry --non-trivial
lemma new_lemma_128834 (h0 : topological_space (ordered_cancel_add_comm_monoid unsigned)) : totally_disconnected_space (ordered_cancel_add_comm_monoid unsigned) := sorry --non-trivial
lemma new_lemma_128835 (h0 : topological_space (non_unital_non_assoc_semiring reducibility_hints)) : t0_space (non_unital_non_assoc_semiring reducibility_hints) := sorry --non-trivial
lemma new_lemma_128836 (h1 : add_group (has_pos_part char)) : is_add_cyclic (has_pos_part char) := sorry --non-trivial
lemma new_lemma_128837 (h0 : ring (boolean_algebra.core (option empty))) : is_domain (boolean_algebra.core (option empty)) := sorry --non-trivial
lemma new_lemma_128838 (h0 : list (linear_ordered_field (comm_monoid (complete_distrib_lattice unsigned)))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_128839 (h0 : has_mem.mem (with_one (has_norm congr_arg_kind)) has_emptyc.emptyc) : @discrete_topology.{0} (with_one.{0} (has_norm.{0} congr_arg_kind)) (@finset.pi.empty.{1 0} Type topological_space.{0} (with_one.{0} (has_norm.{0} congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_128840 (h0 : uniform_space (simple_graph (finset pos))) : separated_space (simple_graph (finset pos)) := sorry --non-trivial
lemma new_lemma_128841 (h0 : function.extfun (Type 1) semiring) : @is_noetherian_ring.{1} (boolean_algebra.core.{1} Type) (@function.extfun_app.{3 2} (Type 1) semiring.{1} h0 (boolean_algebra.core.{1} Type))  := sorry --non-trivial
lemma new_lemma_128842 (h0 : not (cancel_comm_monoid_with_zero (has_nndist empty) -> false)) : @unique_factorization_monoid.{0} (has_nndist.{0} empty) (@classical.by_contradiction'.{1} (cancel_comm_monoid_with_zero.{0} (has_nndist.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_128843 (h0 : list (left_cancel_semigroup congr_arg_kind)) : palindrome h0 := sorry --non-trivial
lemma new_lemma_128844 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : list.nodup (function.extfun_app (function.extfun_app h0 list) (denumerable linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_128845 (h0 : topological_space (monoid (option congr_arg_kind))) : discrete_topology (monoid (option congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_128846 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @monoid.fg.{0} (finset.{0} num) (@function.extfun_app.{2 1} Type monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 monoid.{0}) (finset.{0} num))  := sorry --non-trivial
lemma new_lemma_128847 (h0 : semiring (boolean_algebra (finset (finset linarith.comp)))) : is_noetherian_ring (boolean_algebra (finset (finset linarith.comp))) := sorry --non-trivial
lemma new_lemma_128848 (h0 : not (group (measure_theory.measure_space empty) -> false)) : @is_cyclic.{0} (measure_theory.measure_space.{0} empty) (@classical.by_contradiction'.{1} (group.{0} (measure_theory.measure_space.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_128849 (h0 : finset (generalized_boolean_algebra (has_add (has_pos_part (ring (ring linarith.comp)))))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_128850 (h0 : uniform_space (simple_graph congr_arg_kind)) : separated_space (simple_graph congr_arg_kind) := sorry --non-trivial
lemma new_lemma_128851 (h0 : filter (boolean_algebra.core (option ennreal))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_128852 (h0 : topological_space (has_edist (semiring (semiring unsigned)))) : normal_space (has_edist (semiring (semiring unsigned))) := sorry --non-trivial
lemma new_lemma_128853 (h0 : function.extfun Type topological_space) : @t0_space.{0} (canonically_ordered_comm_semiring.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (canonically_ordered_comm_semiring.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_128854 (h0 : function.extfun (finset (Type -> Type)) (has_mem.mem group)) : @normalizer_condition.{0} (semiring.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type group.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) group.{0} (@function.extfun_app.{2 0} (finset.{1} (Type → Type)) (@has_mem.mem.{1 1} (Type → Type) (finset.{1} (Type → Type)) (@finset.has_mem.{1} (Type → Type)) group.{0}) h0 (@has_emptyc.emptyc.{1} (finset.{1} (Type → Type)) (@finset.has_emptyc.{1} (Type → Type))))) (semiring.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_128855 (h0 : group (ordered_comm_ring Type)) : group.fg (ordered_comm_ring Type) := sorry --non-trivial
lemma new_lemma_128856 (h0 : not (function.extfun Type topological_space -> false)) : @locally_compact_space.{0} (has_nnnorm.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (has_nnnorm.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_128857 (h0 : function.extfun Type (prod (linear_ordered_comm_group unsigned))) : id_rel (function.extfun_app h0 (linear_ordered_comm_group unsigned)) := sorry --non-trivial
lemma new_lemma_128858 (h0 : filter (boolean_algebra (has_add (has_add (has_add pos))))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_128859 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_noetherian_ring.{0} pos (@function.extfun_app.{2 1} Type semiring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 semiring.{0}) pos)  := sorry --non-trivial
lemma new_lemma_128860 (h0 : topological_space (mul_zero_class ennreal)) : totally_disconnected_space (mul_zero_class ennreal) := sorry --non-trivial
lemma new_lemma_128861 (h0 : has_mem.mem (metric_space num) has_emptyc.emptyc) : @complete_space.{0} (metric_space.{0} num) (@finset.pi.empty.{1 0} Type uniform_space.{0} (metric_space.{0} num) h0)  := sorry --non-trivial
lemma new_lemma_128862 (h0 : functor.add_const (topological_space (has_Sup unsigned)) (option empty)) : @locally_compact_space.{0} (has_Sup.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (has_Sup.{0} unsigned)) (option.{0} empty) h0)  := sorry --non-trivial
lemma new_lemma_128863 (h0 : topological_space (has_add (has_add Type))) : preconnected_space (has_add (has_add Type)) := sorry --non-trivial
lemma new_lemma_128864 (h0 : semiring (has_pos_part (has_add (has_add real)))) : is_noetherian_ring (has_pos_part (has_add (has_add real))) := sorry --non-trivial
lemma new_lemma_128865 (h0 : functor.add_const (topological_space (has_star num)) empty) : @t0_space.{0} (has_star.{0} num) (@functor.add_const.run.{0 0} (topological_space.{0} (has_star.{0} num)) empty h0)  := sorry --non-trivial
lemma new_lemma_128866 (h0 : not (group (has_neg_part unsigned) -> false)) : @normalizer_condition.{0} (has_neg_part.{0} unsigned) (@classical.by_contradiction'.{1} (group.{0} (has_neg_part.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_128867 (h0 : functor.add_const (function.extfun Type add_group) Type) : @is_add_cyclic.{0} (boolean_algebra.{0} linarith.comp) (@function.extfun_app.{2 1} Type add_group.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type add_group.{0}) Type h0) (boolean_algebra.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_128868 (h0 : topological_space (complete_distrib_lattice (has_add (has_Inf real)))) : topological_space.separable_space (complete_distrib_lattice (has_add (has_Inf real))) := sorry --non-trivial
lemma new_lemma_128869 (h0 : group (has_compl (random_gen (random_gen enat)))) : group.fg (has_compl (random_gen (random_gen enat))) := sorry --non-trivial
lemma new_lemma_128870 (h0 : ring (has_sdiff unsigned)) : is_domain (has_sdiff unsigned) := sorry --non-trivial
lemma new_lemma_128871 (h0 : finset (comm_monoid congr_arg_kind)) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_128872 (h0 : ring (random_gen (has_norm empty))) : strong_rank_condition (random_gen (has_norm empty)) := sorry --non-trivial
lemma new_lemma_128873 (h0 : add_group (semiring (has_dist linarith.ineq))) : is_add_cyclic (semiring (has_dist linarith.ineq)) := sorry --non-trivial
lemma new_lemma_128874 (h0 : topological_space (complete_semilattice_Sup (has_norm num))) : t0_space (complete_semilattice_Sup (has_norm num)) := sorry --non-trivial
lemma new_lemma_128875 (h0 : uniform_space (add_comm_semigroup (add_comm_semigroup (add_comm_semigroup char)))) : complete_space (add_comm_semigroup (add_comm_semigroup (add_comm_semigroup char))) := sorry --non-trivial
lemma new_lemma_128876 (h0 : function.extfun Type group) : @is_cyclic.{0} (normed_group.{0} (has_top.{0} (has_top.{0} (has_top.{0} (has_top.{0} linarith.comp_source))))) (@function.extfun_app.{2 1} Type group.{0} h0 (normed_group.{0} (has_top.{0} (has_top.{0} (has_top.{0} (has_top.{0} linarith.comp_source))))))  := sorry --non-trivial
lemma new_lemma_128877 (h0 : functor.add_const (function.extfun Type filter) (ring environment.implicit_infer_kind)) : countable_Inter_filter (function.extfun_app (functor.add_const.run h0) (ring linarith.comp)) := sorry --non-trivial
lemma new_lemma_128878 (h0 : ulower (list Prop)) : @list.head.{0} Prop sort.inhabited.{0} (@id.{1} (list.{0} Prop) (@ulower.up.{0} (list.{0} Prop) (@encodable.list.{0} Prop encodable.Prop) h0))  := sorry --non-trivial
lemma new_lemma_128879 (h1 : ring (has_inv linarith.ineq)) : strong_rank_condition (has_inv linarith.ineq) := sorry --non-trivial
lemma new_lemma_128880 (h0 : function.extfun linarith.comp_source (fun (x : linarith.comp_source), Prop)) (h1 : Prop) (h2 : Pi (a : linarith.comp_source), function.extfun_app h0 a -> Prop) : classical.exists_cases h1 h2 := sorry --non-trivial
lemma new_lemma_128881 (h0 : topological_space (has_bot real)) : sequential_space (has_bot real) := sorry --non-trivial
lemma new_lemma_128882 (h0 : set (has_ssubset (has_ssubset reducibility_hints))) : set.finite h0 := sorry --non-trivial
lemma new_lemma_128883 (h0 : function.extfun Type (prod (linear_order (semiring empty)))) : id_rel (function.extfun_app h0 (linear_order (semiring empty))) := sorry --non-trivial
lemma new_lemma_128884 (h1 : topological_space (has_append char)) : path_connected_space (has_append char) := sorry --non-trivial
lemma new_lemma_128885 (h0 : filter (canonically_linear_ordered_monoid (has_nndist pos))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_128886 (h0 : function.extfun Type group) : @is_cyclic.{0} (generalized_boolean_algebra.{0} real) (@function.extfun_app.{2 1} Type group.{0} h0 (generalized_boolean_algebra.{0} real))  := sorry --non-trivial
lemma new_lemma_128887 (h0 : semiring (add_comm_semigroup (add_comm_semigroup (add_comm_semigroup ereal)))) (h1 : add_comm_semigroup (add_comm_semigroup (add_comm_semigroup ereal))) : even h1 := sorry --non-trivial
lemma new_lemma_128888 (h0 : functor.add_const (topological_space (has_to_string linarith.comp)) environment.implicit_infer_kind) : @t0_space.{0} (has_to_string.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (has_to_string.{0} linarith.comp)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_128889 (h0 : topological_space (finset (has_pos_part linarith.comp))) : t0_space (finset (has_pos_part linarith.comp)) := sorry --non-trivial
lemma new_lemma_128890 (h0 : group (has_neg (has_add Type))) : normalizer_condition (has_neg (has_add Type)) := sorry --non-trivial
lemma new_lemma_128891 (h0 : ring (complete_distrib_lattice (has_Inf linarith.comp))) : is_principal_ideal_ring (complete_distrib_lattice (has_Inf linarith.comp)) := sorry --non-trivial
lemma new_lemma_128892 (h0 : not (topological_space linarith.ineq -> false)) : @totally_disconnected_space.{0} linarith.ineq (@classical.by_contradiction'.{1} (topological_space.{0} linarith.ineq) h0)  := sorry --non-trivial
lemma new_lemma_128893 (h0 : functor.add_const (complete_lattice (left_cancel_semigroup unsigned)) unsigned) : @is_compactly_generated.{0} (left_cancel_semigroup.{0} unsigned) (@functor.add_const.run.{0 0} (complete_lattice.{0} (left_cancel_semigroup.{0} unsigned)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_128894 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @rank_condition.{0} (denumerable.{0} string_imp) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (denumerable.{0} string_imp))  := sorry --non-trivial
lemma new_lemma_128895 (h0 : fin has_zero.zero) : @discrete_topology.{1} (canonically_linear_ordered_monoid.{1} Type) (@matrix.vec_empty.{1} (topological_space.{1} (canonically_linear_ordered_monoid.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_128896 (h0 : complete_lattice (ring (has_Inf pos))) : is_compactly_generated (ring (has_Inf pos)) := sorry --non-trivial
lemma new_lemma_128897 (h0 : list (comm_monoid_with_zero (has_neg (has_neg linarith.comp)))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_128898 (h0 : not (cancel_comm_monoid_with_zero (add_group empty) -> false)) : @unique_factorization_monoid.{0} (add_group.{0} empty) (@classical.by_contradiction'.{1} (cancel_comm_monoid_with_zero.{0} (add_group.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_128899 (h0 : function.extfun Type uniform_space) : @complete_space.{0} (mul_zero_class.{0} unsigned) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (mul_zero_class.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_128900 (h0 : option (add_group (with_bot (has_inv linarith.ineq)))) (h1 : function.extfun bool coe_sort) : @is_add_cyclic.{0} (with_bot.{0} (has_inv.{0} linarith.ineq)) (@option.get.{0} (add_group.{0} (with_bot.{0} (has_inv.{0} linarith.ineq))) h0 (@function.extfun_app.{1 0} bool (@coe_sort.{1 1} bool Prop coe_sort_bool) h1 (@option.is_some.{0} (add_group.{0} (with_bot.{0} (has_inv.{0} linarith.ineq))) h0)))  := sorry --non-trivial
lemma new_lemma_128901 (h0 : functor.add_const (monoid (has_neg linarith.comp)) environment.implicit_infer_kind) : @monoid.fg.{0} (has_neg.{0} linarith.comp) (@functor.add_const.run.{0 0} (monoid.{0} (has_neg.{0} linarith.comp)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_128902 (h0 : function.extfun Type topological_space) : @locally_compact_space.{0} (add_cancel_monoid.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (add_cancel_monoid.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_128903 (h0 : empty) : empty.elim h0 := sorry --non-trivial
lemma new_lemma_128904 (h0 : functor.add_const (topological_space (filter empty)) empty) : @t0_space.{0} (filter.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (filter.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_128905 (h0 : not (function.extfun (Type -> Type) (function.extfun Type) -> false)) : @irreducible_space.{0} (semiring.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) (@classical.by_contradiction'.{2} (function.extfun.{2 2} (Type → Type) (function.extfun.{2 1} Type)) h0) topological_space.{0}) (semiring.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_128906 (h0 : function.extfun Type uniform_space) : @separated_space.{0} (partial_order.{0} num) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (partial_order.{0} num))  := sorry --non-trivial
lemma new_lemma_128907 (h0 : fin has_zero.zero) : @is_cyclic.{0} (comm_semigroup.{0} linarith.comp) (@matrix.vec_empty.{0} (group.{0} (comm_semigroup.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_128908 (h1 : topological_space (add_left_cancel_monoid (has_nnnorm (has_ssubset (has_nnnorm char))))) : t0_space (add_left_cancel_monoid (has_nnnorm (has_ssubset (has_nnnorm char)))) := sorry --non-trivial
lemma new_lemma_128909 (h0 : complete_lattice (normed_group (has_norm linarith.comp))) : is_atomistic (normed_group (has_norm linarith.comp)) := sorry --non-trivial
lemma new_lemma_128910 (h1 : complete_lattice (normed_group (random_gen string_imp))) : complete_lattice.is_Sup_finite_compact (normed_group (random_gen string_imp)) := sorry --non-trivial
lemma new_lemma_128911 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @monoid.fg.{1} (add_cancel_monoid.{1} Type) (@function.extfun_app.{3 2} (Type 1) monoid.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 monoid.{1}) (add_cancel_monoid.{1} Type))  := sorry --non-trivial
lemma new_lemma_128912 (h0 : functor.add_const (function.extfun Type ring) Type) : @is_domain.{0} (comm_group.{0} pos) (@function.extfun_app.{2 1} Type ring.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type ring.{0}) Type h0) (comm_group.{0} pos))  := sorry --non-trivial
lemma new_lemma_128913 (h0 : topological_space (mul_zero_class (finset (finset (has_add name))))) : t0_space (mul_zero_class (finset (finset (has_add name)))) := sorry --non-trivial
lemma new_lemma_128914 (h0 : complete_lattice (normed_group (random_gen (random_gen fun_info)))) : is_atomistic (normed_group (random_gen (random_gen fun_info))) := sorry --non-trivial
lemma new_lemma_128915 (h0 : has_mem.mem (normed_group (has_top linarith.comp_source)) has_emptyc.emptyc) : @path_connected_space.{0} (normed_group.{0} (has_top.{0} linarith.comp_source)) (@finset.pi.empty.{1 0} Type topological_space.{0} (normed_group.{0} (has_top.{0} linarith.comp_source)) h0)  := sorry --non-trivial
lemma new_lemma_128916 (h0 : topological_space (normed_group (has_norm empty))) : t0_space (normed_group (has_norm empty)) := sorry --non-trivial
lemma new_lemma_128917 (h0 : complete_lattice (has_neg num)) : is_compactly_generated (has_neg num) := sorry --non-trivial
lemma new_lemma_128918 (h0 : function.extfun Type group) : @normalizer_condition.{0} (add_right_cancel_monoid.{0} unsigned) (@function.extfun_app.{2 1} Type group.{0} h0 (add_right_cancel_monoid.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_128919 (h0 : cancel_comm_monoid_with_zero (ordered_comm_ring (ring linarith.comp))) : unique_factorization_monoid (ordered_comm_ring (ring linarith.comp)) := sorry --non-trivial
lemma new_lemma_128920 (h0 : topological_space (add_comm_monoid (has_neg_part unsigned))) : t1_space (add_comm_monoid (has_neg_part unsigned)) := sorry --non-trivial
lemma new_lemma_128921 (h0 : topological_space (has_top empty)) : normal_space (has_top empty) := sorry --non-trivial
lemma new_lemma_128922 (h0 : topological_space (with_bot (semiring empty))) : discrete_topology (with_bot (semiring empty)) := sorry --non-trivial
lemma new_lemma_128923 (h0 : ring (canonically_ordered_comm_semiring empty)) : strong_rank_condition (canonically_ordered_comm_semiring empty) := sorry --non-trivial
lemma new_lemma_128924 (h0 : function.extfun Type (functor.add_const Prop)) : functor.add_const.run (function.extfun_app h0 linarith.comp) := sorry --non-trivial
lemma new_lemma_128925 (h0 : functor.add_const (topological_space (generalized_boolean_algebra linarith.comp)) Type) : @locally_compact_space.{0} (generalized_boolean_algebra.{0} linarith.comp) (@functor.add_const.run.{0 1} (topological_space.{0} (generalized_boolean_algebra.{0} linarith.comp)) Type h0)  := sorry --non-trivial
lemma new_lemma_128926 (h0 : add_group (semiring (semiring (semiring (semiring (semiring (semiring num))))))) : is_add_cyclic (semiring (semiring (semiring (semiring (semiring (semiring num)))))) := sorry --non-trivial
lemma new_lemma_128927 (h0 : group (has_bot (canonically_linear_ordered_monoid real))) : is_cyclic (has_bot (canonically_linear_ordered_monoid real)) := sorry --non-trivial
lemma new_lemma_128928 (h0 : functor.add_const (function.extfun Type monoid) Type) : @monoid.fg.{0} (normed_comm_ring.{0} linarith.comp) (@function.extfun_app.{2 1} Type monoid.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type monoid.{0}) Type h0) (normed_comm_ring.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_128929 (h0 : functor.add_const (filter (semigroup linarith.comp)) Type) : filter.ne_bot (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_128930 (h0 : monoid (has_inv linarith.comp_source)) : monoid.fg (has_inv linarith.comp_source) := sorry --non-trivial
lemma new_lemma_128931 (h0 : topological_space (cancel_monoid name)) : regular_space (cancel_monoid name) := sorry --non-trivial
lemma new_lemma_128932 (h0 : functor.add_const (filter Type) (finset Type)) : countable_Inter_filter (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_128933 (h0 : topological_space (has_pos_part (finset Type))) : regular_space (has_pos_part (finset Type)) := sorry --non-trivial
lemma new_lemma_128934 (h0 : functor.add_const (ring (measurable_space.dynkin_system num)) num) : @is_domain.{0} (measurable_space.dynkin_system.{0} num) (@functor.add_const.run.{0 0} (ring.{0} (measurable_space.dynkin_system.{0} num)) num h0)  := sorry --non-trivial
lemma new_lemma_128935 (h0 : topological_space (finset real)) : t0_space (finset real) := sorry --non-trivial
lemma new_lemma_128936 (h0 : functor.add_const (topological_space (semigroup name)) linarith.comp) : @regular_space.{0} (semigroup.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (semigroup.{0} name)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_128937 (h0 : group (comm_monoid empty)) : is_cyclic (comm_monoid empty) := sorry --non-trivial
lemma new_lemma_128938 (h0 : function.extfun (finset (Type -> Type)) (has_mem.mem ring)) : @rank_condition.{0} linarith.comp_source (@function.extfun_app.{2 1} Type ring.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) ring.{0} (@function.extfun_app.{2 0} (finset.{1} (Type → Type)) (@has_mem.mem.{1 1} (Type → Type) (finset.{1} (Type → Type)) (@finset.has_mem.{1} (Type → Type)) ring.{0}) h0 (@has_emptyc.emptyc.{1} (finset.{1} (Type → Type)) (@finset.has_emptyc.{1} (Type → Type))))) linarith.comp_source)  := sorry --non-trivial
lemma new_lemma_128939 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @preirreducible_space.{0} (add_cancel_monoid.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (add_cancel_monoid.{0} num))  := sorry --non-trivial
lemma new_lemma_128940 (h0 : function.extfun (finset (Type -> Type)) (has_mem.mem topological_space)) : @totally_disconnected_space.{0} (with_bot.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) topological_space.{0} (@function.extfun_app.{2 0} (finset.{1} (Type → Type)) (@has_mem.mem.{1 1} (Type → Type) (finset.{1} (Type → Type)) (@finset.has_mem.{1} (Type → Type)) topological_space.{0}) h0 (@has_emptyc.emptyc.{1} (finset.{1} (Type → Type)) (@finset.has_emptyc.{1} (Type → Type))))) (with_bot.{0} num))  := sorry --non-trivial
lemma new_lemma_128941 (h0 : ring (random_gen (comm_ring fun_info))) : rank_condition (random_gen (comm_ring fun_info)) := sorry --non-trivial
lemma new_lemma_128942 (h0 : functor.add_const (list (has_to_string name)) Type) : palindrome (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_128943 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @strong_rank_condition.{0} (has_sub.{0} unsigned) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (has_sub.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_128944 (h0 : list (left_cancel_monoid empty)) : palindrome h0 := sorry --non-trivial
lemma new_lemma_128945 (h0 : function.extfun nat fin) : @complete_lattice.is_Sup_finite_compact.{0} (simple_graph.{0} name) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@matrix.vec_empty.{1} (function.extfun.{2 1} Type complete_lattice.{0}) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero))) (simple_graph.{0} name))  := sorry --non-trivial
lemma new_lemma_128946 (h0 : group (with_one (has_norm (has_norm empty)))) : normalizer_condition (with_one (has_norm (has_norm empty))) := sorry --non-trivial
lemma new_lemma_128947 (h0 : monoid (measure_theory.measure_space unsigned)) : monoid.fg (measure_theory.measure_space unsigned) := sorry --non-trivial
lemma new_lemma_128948 (h0 : group (with_bot (has_inv linarith.comp_source))) : group.fg (with_bot (has_inv linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_128949 (h0 : functor.add_const (topological_space (has_Inf Type)) (has_neg Type)) : @discrete_topology.{1} (has_Inf.{1} Type) (@functor.add_const.run.{1 1} (topological_space.{1} (has_Inf.{1} Type)) (has_neg.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_128950 (h0 : functor.add_const (topological_space (has_neg_part name)) Type) : @loc_path_connected_space.{0} (has_neg_part.{0} name) (@functor.add_const.run.{0 1} (topological_space.{0} (has_neg_part.{0} name)) Type h0)  := sorry --non-trivial
lemma new_lemma_128951 (h0 : not (function.extfun Type topological_space -> false)) : @irreducible_space.{0} fun_info (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) fun_info)  := sorry --non-trivial
lemma new_lemma_128952 (h0 : function.extfun Type topological_space) : @irreducible_space.{0} (measurable_space.{0} fun_info) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (measurable_space.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_128953 (h0 : ordered_add_comm_monoid (add_comm_monoid (option pos))) : archimedean (add_comm_monoid (option pos)) := sorry --non-trivial
lemma new_lemma_128954 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @strong_rank_condition.{0} fun_info (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) fun_info)  := sorry --non-trivial
lemma new_lemma_128955 (h0 : topological_space (with_one (has_inv (has_norm (has_top (has_top fun_info)))))) : totally_separated_space (with_one (has_inv (has_norm (has_top (has_top fun_info))))) := sorry --non-trivial
lemma new_lemma_128956 (h0 : ring (has_sub congr_arg_kind)) : strong_rank_condition (has_sub congr_arg_kind) := sorry --non-trivial
lemma new_lemma_128957 (h0 : topological_space (linear_ordered_comm_monoid_with_zero (add_comm_monoid (option (option empty))))) : t0_space (linear_ordered_comm_monoid_with_zero (add_comm_monoid (option (option empty)))) := sorry --non-trivial
lemma new_lemma_128958 (h0 : has_nndist (option (option (option ennreal))) -> has_nndist (option (option (option ennreal))) -> Prop) : is_symm (has_nndist (option (option (option ennreal)))) h0 := sorry --non-trivial
lemma new_lemma_128959 (h0 : linarith.ineq -> linarith.ineq -> Prop) (h1 : filter linarith.ineq) : filter.is_bounded h0 h1 := sorry --non-trivial
lemma new_lemma_128960 (h0 : semiring (has_neg num)) : is_noetherian_ring (has_neg num) := sorry --non-trivial
lemma new_lemma_128961 (h0 : ordered_add_comm_monoid (add_comm_monoid (option (option num)))) : archimedean (add_comm_monoid (option (option num))) := sorry --non-trivial
lemma new_lemma_128962 (h0 : functor.add_const (ring (has_zero environment.implicit_infer_kind)) environment.implicit_infer_kind) : @strong_rank_condition.{0} (has_zero.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (ring.{0} (has_zero.{0} environment.implicit_infer_kind)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_128963 (h0 : has_coe (mul_one_class string.iterator_imp) Prop) (h1 : mul_one_class string.iterator_imp) : @coe_b.{1 1} (mul_one_class.{0} string.iterator_imp) Prop h0 h1  := sorry --non-trivial
lemma new_lemma_128964 (h0 : ring (comm_group (has_to_string (option ennreal)))) : strong_rank_condition (comm_group (has_to_string (option ennreal))) := sorry --non-trivial
lemma new_lemma_128965 (h0 : function.extfun ((Type -> Type) -> Type 1) (function.extfun (Type -> Type))) : @is_add_cyclic.{0} (add_cancel_monoid.{0} empty) (@function.extfun_app.{2 1} Type add_group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) (@function.extfun_app.{3 2} ((Type → Type) → Type 1) (function.extfun.{2 2} (Type → Type)) h0 (function.extfun.{2 1} Type)) add_group.{0}) (add_cancel_monoid.{0} empty))  := sorry --non-trivial
lemma new_lemma_128966 (h0 : topological_space (comm_monoid empty)) : preirreducible_space (comm_monoid empty) := sorry --non-trivial
lemma new_lemma_128967 (h1 : complete_lattice (has_norm (has_norm (has_norm fun_info)))) : is_compactly_generated (has_norm (has_norm (has_norm fun_info))) := sorry --non-trivial
lemma new_lemma_128968 (h0 : topological_space (has_inner unsigned unsigned)) : t0_space (has_inner unsigned unsigned) := sorry --non-trivial
lemma new_lemma_128969 (h0 : measurable_space fun_info) (h1 : measure_theory.measure fun_info) : measure_theory.is_finite_measure h1 := sorry --non-trivial
lemma new_lemma_128970 (h1 : complete_lattice (add_left_cancel_monoid char)) : is_compactly_generated (add_left_cancel_monoid char) := sorry --non-trivial
lemma new_lemma_128971 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @t0_space.{0} (mul_zero_class.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (mul_zero_class.{0} empty))  := sorry --non-trivial
lemma new_lemma_128972 (h0 : function.extfun Type uniform_space) : @complete_space.{0} (has_norm.{0} unsigned) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (has_norm.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_128973 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @totally_disconnected_space.{0} (add_cancel_monoid.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (add_cancel_monoid.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_128974 (h0 : functor.add_const (ring (add_cancel_monoid pos)) pos) : @strong_rank_condition.{0} (add_cancel_monoid.{0} pos) (@functor.add_const.run.{0 0} (ring.{0} (add_cancel_monoid.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_128975 (h1 : filter (has_top string_imp)) : filter.ne_bot h1 := sorry --non-trivial
lemma new_lemma_128976 (h0 : functor.add_const (ring (has_nndist linarith.comp)) pos) : @rank_condition.{0} (has_nndist.{0} linarith.comp) (@functor.add_const.run.{0 0} (ring.{0} (has_nndist.{0} linarith.comp)) pos h0)  := sorry --non-trivial
lemma new_lemma_128977 (h0 : function.extfun (finset (Type -> Type)) (has_mem.mem complete_lattice)) : @is_atomistic.{0} znum (@function.extfun_app.{2 1} Type complete_lattice.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) complete_lattice.{0} (@function.extfun_app.{2 0} (finset.{1} (Type → Type)) (@has_mem.mem.{1 1} (Type → Type) (finset.{1} (Type → Type)) (@finset.has_mem.{1} (Type → Type)) complete_lattice.{0}) h0 (@has_emptyc.emptyc.{1} (finset.{1} (Type → Type)) (@finset.has_emptyc.{1} (Type → Type))))) znum)  := sorry --non-trivial
lemma new_lemma_128978 (h0 : topological_space (pseudo_metric_space congr_arg_kind)) : loc_path_connected_space (pseudo_metric_space congr_arg_kind) := sorry --non-trivial
lemma new_lemma_128979 (h1 : complete_lattice (has_top (random_gen to_additive.value_type))) : complete_lattice.is_Sup_finite_compact (has_top (random_gen to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_128980 (h0 : function.extfun Type topological_space) : @discrete_topology.{0} (ordered_comm_monoid.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (ordered_comm_monoid.{0} pos))  := sorry --non-trivial
lemma new_lemma_128981 (h0 : topological_space (random_gen to_additive.value_type)) : totally_separated_space (random_gen to_additive.value_type) := sorry --non-trivial
lemma new_lemma_128982 (h0 : functor.add_const (topological_space (canonically_linear_ordered_monoid ennreal)) unsigned) : @normal_space.{0} (canonically_linear_ordered_monoid.{0} ennreal) (@functor.add_const.run.{0 0} (topological_space.{0} (canonically_linear_ordered_monoid.{0} ennreal)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_128983 (h0 : function.extfun Type topological_space) : @irreducible_space.{0} (linear_order.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (linear_order.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_128984 (h0 : list (has_norm (has_nnnorm (has_nnnorm linarith.ineq)))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_128985 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_simple_group.{0} (generalized_boolean_algebra.{0} real) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (generalized_boolean_algebra.{0} real))  := sorry --non-trivial
lemma new_lemma_128986 (h0 : pfun char fun_info) (h1 : prod char fun_info) : pfun.graph h0 h1 := sorry --non-trivial
lemma new_lemma_128987 (h0 : not (has_mem.mem linarith.comp_source has_emptyc.emptyc -> false)) : @t0_space.{0} linarith.comp_source (@finset.pi.empty.{1 0} Type topological_space.{0} linarith.comp_source (@classical.by_contradiction'.{0} (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) linarith.comp_source (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))) h0))  := sorry --non-trivial
lemma new_lemma_128988 (h0 : ring (has_pos_part (has_add (has_add (has_add pos))))) : rank_condition (has_pos_part (has_add (has_add (has_add pos)))) := sorry --non-trivial
lemma new_lemma_128989 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : filter.ne_bot (function.extfun_app (function.extfun_app h0 filter) (add_cancel_monoid pos)) := sorry --non-trivial
lemma new_lemma_128990 (h0 h1 : list (add_comm_semigroup std_gen)) : list.is_rotated h0 h1 := sorry --non-trivial
lemma new_lemma_128991 (h0 h1 : multiset subsingleton_info) : multiset.subset h0 h1 := sorry --non-trivial
lemma new_lemma_128992 (h0 : function.extfun (Type 1) ring) : @rank_condition.{1} (simple_graph.{1} Type) (@function.extfun_app.{3 2} (Type 1) ring.{1} h0 (simple_graph.{1} Type))  := sorry --non-trivial
lemma new_lemma_128993 (h0 : function.extfun Type list) : palindrome (function.extfun_app h0 (has_neg name)) := sorry --non-trivial
lemma new_lemma_128994 (h0 : topological_space (has_to_string (finset linarith.comp))) : irreducible_space (has_to_string (finset linarith.comp)) := sorry --non-trivial
lemma new_lemma_128995 (h2 : function.extfun (Type -> Type) (function.extfun Type)) : @is_add_cyclic.{0} linarith.ineq (@function.extfun_app.{2 1} Type add_group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h2 add_group.{0}) linarith.ineq)  := sorry --non-trivial
lemma new_lemma_128996 (h0 : function.extfun Type uniform_space) : @separated_space.{0} (has_dist.{0} ennreal) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (has_dist.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_128997 (h0 : has_neg (normed_field enat)) (h1 : measurable_space (normed_field enat)) : has_measurable_neg (normed_field enat) := sorry --non-trivial
lemma new_lemma_128998 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @unique_factorization_monoid.{0} linarith.comp (@function.extfun_app.{2 1} Type cancel_comm_monoid_with_zero.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 cancel_comm_monoid_with_zero.{0}) linarith.comp)  := sorry --non-trivial
lemma new_lemma_128999 (h0 : complete_lattice (add_group (semiring unsigned))) : complete_lattice.is_Sup_finite_compact (add_group (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_129000 (h0 : functor.add_const (group (preorder unsigned)) empty) : @group.fg.{0} (preorder.{0} unsigned) (@functor.add_const.run.{0 0} (group.{0} (preorder.{0} unsigned)) empty h0)  := sorry --non-trivial
lemma new_lemma_129001 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_add_cyclic.{0} (normed_group.{0} string_imp) (@function.extfun_app.{2 1} Type add_group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 add_group.{0}) (normed_group.{0} string_imp))  := sorry --non-trivial
lemma new_lemma_129002 (h0 : not (uniform_space (id linarith.comp) -> false)) : @complete_space.{0} (@id.{2} Type linarith.comp) (@classical.by_contradiction'.{1} (uniform_space.{0} (@id.{2} Type linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_129003 (h0 : ring (topological_space string.iterator_imp)) : strong_rank_condition (topological_space string.iterator_imp) := sorry --non-trivial
lemma new_lemma_129004 (h0 : ring (has_inv linarith.ineq)) : strong_rank_condition (has_inv linarith.ineq) := sorry --non-trivial
lemma new_lemma_129005 (h0 : fin has_zero.zero) : @is_noetherian_ring.{0} (comm_semigroup.{0} name) (@matrix.vec_empty.{0} (semiring.{0} (comm_semigroup.{0} name)) (@matrix.vec_empty.{0} (fin (@has_zero.zero.{0} nat nat.has_zero)) h0))  := sorry --non-trivial
lemma new_lemma_129006 (h0 : functor.add_const (topological_space (boolean_algebra.core pos)) Type) : @irreducible_space.{0} (boolean_algebra.core.{0} pos) (@functor.add_const.run.{0 1} (topological_space.{0} (boolean_algebra.core.{0} pos)) Type h0)  := sorry --non-trivial
lemma new_lemma_129007 (h0 : uniform_space (semigroup empty)) : separated_space (semigroup empty) := sorry --non-trivial
lemma new_lemma_129008 (h0 : topological_space (has_star (semiring congr_arg_kind))) : preirreducible_space (has_star (semiring congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_129009 (h0 : not (group (has_norm num) -> false)) : @group.fg.{0} (has_norm.{0} num) (@classical.by_contradiction'.{1} (group.{0} (has_norm.{0} num)) h0)  := sorry --non-trivial
lemma new_lemma_129010 (h0 : add_group (id (has_top fun_info))) : is_add_cyclic (id (has_top fun_info)) := sorry --non-trivial
lemma new_lemma_129011 (h0 : functor.add_const (uniform_space (left_cancel_monoid unsigned)) unsigned) : @complete_space.{0} (left_cancel_monoid.{0} unsigned) (@functor.add_const.run.{0 0} (uniform_space.{0} (left_cancel_monoid.{0} unsigned)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_129012 (h0 : function.extfun Type topological_space) : @t0_space.{0} (has_ssubset.{0} (random_gen.{0} to_additive.value_type)) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_ssubset.{0} (random_gen.{0} to_additive.value_type)))  := sorry --non-trivial
lemma new_lemma_129013 (h0 : semiring (generalized_boolean_algebra (has_neg pos))) : is_noetherian_ring (generalized_boolean_algebra (has_neg pos)) := sorry --non-trivial
lemma new_lemma_129014 (h0 : topological_space (linear_ordered_comm_group_with_zero (has_emptyc char))) : totally_disconnected_space (linear_ordered_comm_group_with_zero (has_emptyc char)) := sorry --non-trivial
lemma new_lemma_129015 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @strong_rank_condition.{0} (has_to_string.{0} empty) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (has_to_string.{0} empty))  := sorry --non-trivial
lemma new_lemma_129016 (h0 : complete_lattice (has_bot real)) : is_compactly_generated (has_bot real) := sorry --non-trivial
lemma new_lemma_129017 (h0 : add_group (has_add (has_neg_part (has_neg_part (comm_group (has_neg_part Type)))))) : is_add_cyclic (has_add (has_neg_part (has_neg_part (comm_group (has_neg_part Type))))) := sorry --non-trivial
lemma new_lemma_129018 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @complete_lattice.is_Sup_finite_compact.{0} (normed_group.{0} unsigned) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (normed_group.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_129019 (h0 : ordered_comm_monoid (ring (has_zero name))) : has_exists_mul_of_le (ring (has_zero name)) := sorry --non-trivial
lemma new_lemma_129020 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @preirreducible_space.{0} (add_comm_monoid.{0} ennreal) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (add_comm_monoid.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_129021 (h0 : complete_lattice (complete_semilattice_Sup unsigned)) : is_atomistic (complete_semilattice_Sup unsigned) := sorry --non-trivial
lemma new_lemma_129022 (h0 : topological_space (has_lt std_gen)) : totally_disconnected_space (has_lt std_gen) := sorry --non-trivial
lemma new_lemma_129023 (h0 : functor.add_const (ordered_comm_monoid Type) pos) : @has_exists_mul_of_le.{1} Type (@functor.add_const.run.{1 0} (ordered_comm_monoid.{1} Type) pos h0)  := sorry --non-trivial
lemma new_lemma_129024 (h0 : ring (left_cancel_semigroup (ordered_cancel_comm_monoid (semiring num)))) : is_domain (left_cancel_semigroup (ordered_cancel_comm_monoid (semiring num))) := sorry --non-trivial
lemma new_lemma_129025 (h0 : ring (add_left_cancel_monoid linarith.comp_source)) : strong_rank_condition (add_left_cancel_monoid linarith.comp_source) := sorry --non-trivial
lemma new_lemma_129026 (h0 : functor.add_const (ordered_add_comm_monoid (has_to_string pos)) pos) : @archimedean.{0} (has_to_string.{0} pos) (@functor.add_const.run.{0 0} (ordered_add_comm_monoid.{0} (has_to_string.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_129027 (h0 : monoid (has_bot (has_Inf Type))) : monoid.fg (has_bot (has_Inf Type)) := sorry --non-trivial
lemma new_lemma_129028 (h0 : ordered_add_comm_monoid (has_add (normed_comm_ring Type))) : archimedean (has_add (normed_comm_ring Type)) := sorry --non-trivial
lemma new_lemma_129029 (h0 : uniform_space (linear_ordered_field (option (option unsigned)))) : separated_space (linear_ordered_field (option (option unsigned))) := sorry --non-trivial
lemma new_lemma_129030 (h0 : topological_space (has_add (sub_neg_monoid (sub_neg_monoid real)))) : preconnected_space (has_add (sub_neg_monoid (sub_neg_monoid real))) := sorry --non-trivial
lemma new_lemma_129031 (h0 : functor.add_const (ring (has_neg name)) name) : @is_domain.{0} (has_neg.{0} name) (@functor.add_const.run.{0 0} (ring.{0} (has_neg.{0} name)) name h0)  := sorry --non-trivial
lemma new_lemma_129032 (h0 : function.extfun Type topological_space) : @totally_separated_space.{0} (has_bot.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_bot.{0} pos))  := sorry --non-trivial
lemma new_lemma_129033 (h3 : measurable_space environment.projection_info) (h4 : measure_theory.measure environment.projection_info) : measure_theory.is_finite_measure h4 := sorry --non-trivial
lemma new_lemma_129034 (h0 : topological_space (comm_group (option unsigned))) : totally_separated_space (comm_group (option unsigned)) := sorry --non-trivial
lemma new_lemma_129035 (h0 : reducibility_hints -> reducibility_hints -> Prop) : is_trans reducibility_hints h0 := sorry --non-trivial
lemma new_lemma_129036 (h0 : monoid (with_bot (random_gen fun_info))) : monoid.fg (with_bot (random_gen fun_info)) := sorry --non-trivial
lemma new_lemma_129037 (h0 : topological_space (has_inv (random_gen (has_norm linarith.ineq)))) : locally_compact_space (has_inv (random_gen (has_norm linarith.ineq))) := sorry --non-trivial
lemma new_lemma_129038 (h0 : topological_space (non_assoc_semiring congr_arg_kind)) : preirreducible_space (non_assoc_semiring congr_arg_kind) := sorry --non-trivial
lemma new_lemma_129039 (h0 : topological_space (has_top linarith.comp)) : totally_disconnected_space (has_top linarith.comp) := sorry --non-trivial
lemma new_lemma_129040 (h0 : fin has_zero.zero) : @normalizer_condition.{0} (comm_semigroup.{0} pos) (@matrix.vec_empty.{0} (group.{0} (comm_semigroup.{0} pos)) h0)  := sorry --non-trivial
lemma new_lemma_129041 (h0 : fin has_zero.zero) : @is_domain.{0} (has_Inf.{0} real) (@matrix.vec_empty.{0} (ring.{0} (has_Inf.{0} real)) h0)  := sorry --non-trivial
lemma new_lemma_129042 (h0 : uniform_space (has_inv string_imp)) : complete_space (has_inv string_imp) := sorry --non-trivial
lemma new_lemma_129043 (h0 : topological_space (cancel_monoid (has_add Type))) : preirreducible_space (cancel_monoid (has_add Type)) := sorry --non-trivial
lemma new_lemma_129044 (h1 : filter (distrib_lattice (has_top to_additive.value_type))) : filter.ne_bot h1 := sorry --non-trivial
lemma new_lemma_129045 (h0 : functor.add_const (topological_space (boolean_algebra environment.implicit_infer_kind)) pos) : @regular_space.{0} (boolean_algebra.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (boolean_algebra.{0} environment.implicit_infer_kind)) pos h0)  := sorry --non-trivial
lemma new_lemma_129046 (h0 : topological_space (has_emptyc (semiring num))) : irreducible_space (has_emptyc (semiring num)) := sorry --non-trivial
lemma new_lemma_129047 (h0 : functor.add_const (function.extfun Type add_group) pos) : @is_add_cyclic.{0} (ring.{0} pos) (@function.extfun_app.{2 1} Type add_group.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type add_group.{0}) pos h0) (ring.{0} pos))  := sorry --non-trivial
lemma new_lemma_129048 (h0 : ring (id (has_top empty))) : strong_rank_condition (id (has_top empty)) := sorry --non-trivial
lemma new_lemma_129049 (h0 : ring (has_add (has_nnnorm linarith.ineq))) : strong_rank_condition (has_add (has_nnnorm linarith.ineq)) := sorry --non-trivial
lemma new_lemma_129050 (h1 : topological_space (add_comm_semigroup (normed_field (normed_field enat)))) (h2 : add_group (add_comm_semigroup (normed_field (normed_field enat)))) : topological_add_group (add_comm_semigroup (normed_field (normed_field enat))) := sorry --non-trivial
lemma new_lemma_129051 (h0 : functor.add_const (semiring (has_nndist Type)) (has_add (has_add (has_add name)))) : @is_noetherian_ring.{1} (has_nndist.{1} Type) (@functor.add_const.run.{1 0} (semiring.{1} (has_nndist.{1} Type)) (has_add.{0} (has_add.{0} (has_add.{0} name))) h0)  := sorry --non-trivial
lemma new_lemma_129052 (h0 : uniform_space (has_nndist (has_neg_part pos))) : complete_space (has_nndist (has_neg_part pos)) := sorry --non-trivial
lemma new_lemma_129053 (h0 : function.extfun (Type 1) (functor.comp topological_space finset)) : @loc_path_connected_space.{1} (finset.{1} Type) (@functor.comp.run.{1 1 1} topological_space.{1} finset.{1} Type (@function.extfun_app.{3 2} (Type 1) (functor.comp.{1 1 1} topological_space.{1} finset.{1}) h0 Type))  := sorry --non-trivial
lemma new_lemma_129054 (h0 : group (plift congr_arg_kind)) : is_cyclic (plift congr_arg_kind) := sorry --non-trivial
lemma new_lemma_129055 (h0 : function.extfun Type group) : @group.fg.{0} (has_bot.{0} linarith.comp) (@function.extfun_app.{2 1} Type group.{0} h0 (has_bot.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_129056 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @archimedean.{0} (has_to_string.{0} name) (@function.extfun_app.{2 1} Type ordered_add_comm_monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ordered_add_comm_monoid.{0}) (has_to_string.{0} name))  := sorry --non-trivial
lemma new_lemma_129057 (h0 : topological_space (normed_lattice_add_comm_group (finset pos))) : t0_space (normed_lattice_add_comm_group (finset pos)) := sorry --non-trivial
lemma new_lemma_129058 (h0 : fin has_zero.zero) : @totally_separated_space.{0} (has_bot.{0} linarith.comp) (@matrix.vec_empty.{0} (topological_space.{0} (has_bot.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_129059 (h1 : topological_space (has_emptyc (has_norm linarith.comp_source))) : t0_space (has_emptyc (has_norm linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_129060 (h0 : topological_space (cancel_monoid (has_nndist pos))) : sequential_space (cancel_monoid (has_nndist pos)) := sorry --non-trivial
lemma new_lemma_129061 (h0 : function.extfun Type topological_space) : @preconnected_space.{0} (option.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (option.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_129062 (h0 : functor.add_const (ring (normed_linear_ordered_group unsigned)) unsigned) : @is_domain.{0} (normed_linear_ordered_group.{0} unsigned) (@functor.add_const.run.{0 0} (ring.{0} (normed_linear_ordered_group.{0} unsigned)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_129063 (h0 : topological_space (semigroup (cancel_monoid Type))) : topological_space.separable_space (semigroup (cancel_monoid Type)) := sorry --non-trivial
lemma new_lemma_129064 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @totally_disconnected_space.{0} (has_inv.{0} fun_info) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_inv.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_129065 (h0 : uniform_space (random_gen (has_nnnorm reducibility_hints))) : complete_space (random_gen (has_nnnorm reducibility_hints)) := sorry --non-trivial
lemma new_lemma_129066 (h0 : not (group (with_bot unsigned) -> false)) : @is_cyclic.{0} (with_bot.{0} unsigned) (@classical.by_contradiction'.{1} (group.{0} (with_bot.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_129067 (h0 : functor.add_const (topological_space (has_neg Type)) linarith.comp) : @loc_path_connected_space.{1} (has_neg.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (has_neg.{1} Type)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_129068 (h2 : set (enat -> enat)) : set.separates_points h2 := sorry --non-trivial
lemma new_lemma_129069 (h0 : functor.add_const (group (has_Inf Type)) Type) : @group.fg.{1} (has_Inf.{1} Type) (@functor.add_const.run.{1 1} (group.{1} (has_Inf.{1} Type)) Type h0)  := sorry --non-trivial
lemma new_lemma_129070 (h0 : unsigned -> Prop) (h1 : Prop) : xor (exists_unique h0) h1 := sorry --non-trivial
lemma new_lemma_129071 (h0 : not (function.extfun Type topological_space -> false)) : @locally_compact_space.{0} fun_info (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) fun_info)  := sorry --non-trivial
lemma new_lemma_129072 (h0 : functor.add_const (topological_space (normed_comm_ring Type)) linarith.comp) : @irreducible_space.{1} (normed_comm_ring.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (normed_comm_ring.{1} Type)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_129073 (h0 : function.extfun Type add_group) : @is_add_cyclic.{0} (has_top.{0} unsigned) (@function.extfun_app.{2 1} Type add_group.{0} h0 (has_top.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_129074 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @path_connected_space.{0} (@id.{2} Type linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (@id.{2} Type linarith.comp))  := sorry --non-trivial
lemma new_lemma_129075 (h0 : finset (has_Inf (generalized_boolean_algebra pos))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_129076 (h0 : function.extfun Type topological_space) : @totally_disconnected_space.{0} (add_semigroup.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (add_semigroup.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_129077 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_add_cyclic.{0} (has_union.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type add_group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 add_group.{0}) (has_union.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_129078 (h0 : topological_space (has_add congr_arg_kind)) : t0_space (has_add congr_arg_kind) := sorry --non-trivial
lemma new_lemma_129079 (h0 : topological_space (encodable string_imp)) : totally_disconnected_space (encodable string_imp) := sorry --non-trivial
lemma new_lemma_129080 (h0 : group (normed_group (has_inv linarith.ineq))) : is_cyclic (normed_group (has_inv linarith.ineq)) := sorry --non-trivial
lemma new_lemma_129081 (h0 : function.extfun Type (functor.add_const (finset (linear_ordered_comm_monoid_with_zero empty)))) : finset.nonempty (functor.add_const.run (function.extfun_app h0 empty)) := sorry --non-trivial
lemma new_lemma_129082 (h0 : function.extfun Type list) : list.nodup (function.extfun_app h0 (comm_ring linarith.ineq)) := sorry --non-trivial
lemma new_lemma_129083 (h0 : not (ring (complete_semilattice_Sup unsigned) -> false)) : @rank_condition.{0} (complete_semilattice_Sup.{0} unsigned) (@classical.by_contradiction'.{1} (ring.{0} (complete_semilattice_Sup.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_129084 (h0 : functor.add_const (ring (boolean_algebra.core Type)) (finset pos)) : @strong_rank_condition.{1} (boolean_algebra.core.{1} Type) (@functor.add_const.run.{1 0} (ring.{1} (boolean_algebra.core.{1} Type)) (finset.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_129085 (h0 : topological_space (add_cancel_monoid (comm_group Type))) : preconnected_space (add_cancel_monoid (comm_group Type)) := sorry --non-trivial
lemma new_lemma_129086 (h0 : topological_space (add_cancel_monoid (has_to_string Type))) : irreducible_space (add_cancel_monoid (has_to_string Type)) := sorry --non-trivial
lemma new_lemma_129087 (h0 : function.extfun Type ring) : @strong_rank_condition.{0} (pseudo_metric_space.{0} unsigned) (@function.extfun_app.{2 1} Type ring.{0} h0 (pseudo_metric_space.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_129088 (h0 : finset (comm_monoid (semiring empty))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_129089 (h0 : functor.add_const (topological_space (has_add Type)) (has_zero pos)) : @totally_disconnected_space.{1} (has_add.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (has_add.{1} Type)) (has_zero.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_129090 (h0 : function.extfun Type complete_lattice) : @complete_lattice.is_Sup_finite_compact.{0} (ordered_cancel_add_comm_monoid.{0} ennreal) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (ordered_cancel_add_comm_monoid.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_129091 (h0 : functor.add_const (ring (add_comm_monoid linarith.comp)) Type) : @is_domain.{0} (add_comm_monoid.{0} linarith.comp) (@functor.add_const.run.{0 1} (ring.{0} (add_comm_monoid.{0} linarith.comp)) Type h0)  := sorry --non-trivial
lemma new_lemma_129092 (h0 : group (semi_normed_ring (mul_one_class linarith.ineq))) : is_cyclic (semi_normed_ring (mul_one_class linarith.ineq)) := sorry --non-trivial
lemma new_lemma_129093 (h0 : group (has_Inf (ordered_comm_monoid real))) : normalizer_condition (has_Inf (ordered_comm_monoid real)) := sorry --non-trivial
lemma new_lemma_129094 (h0 : complete_lattice (distrib (has_nnnorm to_additive.value_type))) : complete_lattice.is_Sup_finite_compact (distrib (has_nnnorm to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_129095 (h0 : add_group (has_bot (has_add (has_Inf Type)))) : is_add_cyclic (has_bot (has_add (has_Inf Type))) := sorry --non-trivial
lemma new_lemma_129096 (h0 : topological_space (has_Inf (sub_neg_monoid linarith.comp))) : path_connected_space (has_Inf (sub_neg_monoid linarith.comp)) := sorry --non-trivial
lemma new_lemma_129097 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @rank_condition.{0} (has_to_string.{0} empty) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (has_to_string.{0} empty))  := sorry --non-trivial
lemma new_lemma_129098 (h0 : topological_space (monoid_with_zero (has_to_string num))) : t1_space (monoid_with_zero (has_to_string num)) := sorry --non-trivial
lemma new_lemma_129099 (h0 : ring (has_dist (option (option (option (option num)))))) : is_domain (has_dist (option (option (option (option num))))) := sorry --non-trivial
lemma new_lemma_129100 (h0 : function.extfun nat fin) : @is_simple_group.{1} (generalized_boolean_algebra.{1} Type) (@matrix.vec_empty.{1} (group.{1} (generalized_boolean_algebra.{1} Type)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_129101 (h0 : uniform_space (complete_semilattice_Sup (has_top (has_top congr_arg_kind)))) : complete_space (complete_semilattice_Sup (has_top (has_top congr_arg_kind))) := sorry --non-trivial
lemma new_lemma_129102 (h0 : group (boolean_algebra.core (has_neg Type))) : is_cyclic (boolean_algebra.core (has_neg Type)) := sorry --non-trivial
lemma new_lemma_129103 (h0 : group (linear_ordered_comm_group (option unsigned))) : is_simple_group (linear_ordered_comm_group (option unsigned)) := sorry --non-trivial
lemma new_lemma_129104 (h0 : uniform_space (semiring (has_norm (semiring linarith.comp)))) : complete_space (semiring (has_norm (semiring linarith.comp))) := sorry --non-trivial
lemma new_lemma_129105 (h0 : uniform_space (linear_ordered_comm_ring num)) : separated_space (linear_ordered_comm_ring num) := sorry --non-trivial
lemma new_lemma_129106 (h0 : functor.add_const (topological_space (complete_distrib_lattice name)) name) : @normal_space.{0} (complete_distrib_lattice.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (complete_distrib_lattice.{0} name)) name h0)  := sorry --non-trivial
lemma new_lemma_129107 (h0 : set (normed_field (mul_one_class linarith.comp_source))) : set.finite h0 := sorry --non-trivial
lemma new_lemma_129108 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @discrete_topology.{0} (add_semigroup.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (add_semigroup.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_129109 (h0 : topological_space (comm_semigroup (has_bot real))) : irreducible_space (comm_semigroup (has_bot real)) := sorry --non-trivial
lemma new_lemma_129110 (h0 : ring (has_Inf (has_pos_part Type))) : strong_rank_condition (has_Inf (has_pos_part Type)) := sorry --non-trivial
lemma new_lemma_129111 (h1 : ring (metric_space string_imp)) : strong_rank_condition (metric_space string_imp) := sorry --non-trivial
lemma new_lemma_129112 (h0 : filter (add_cancel_monoid congr_arg_kind)) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_129113 (h0 : functor.add_const (topological_space (canonically_linear_ordered_monoid pos)) pos) : @irreducible_space.{0} (canonically_linear_ordered_monoid.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (canonically_linear_ordered_monoid.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_129114 (h0 : has_mem.mem (linear_ordered_semiring fun_info) has_emptyc.emptyc) : @totally_separated_space.{0} (linear_ordered_semiring.{0} fun_info) (@finset.pi.empty.{1 0} Type topological_space.{0} (linear_ordered_semiring.{0} fun_info) h0)  := sorry --non-trivial
lemma new_lemma_129115 (h0 : topological_space (boolean_algebra (has_to_string environment.implicit_infer_kind))) : irreducible_space (boolean_algebra (has_to_string environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_129116 (h1 : set (string.iterator_imp -> char)) : set.separates_points h1 := sorry --non-trivial
lemma new_lemma_129117 (h0 : group (topological_space (topological_space char))) : is_cyclic (topological_space (topological_space char)) := sorry --non-trivial
lemma new_lemma_129118 (h0 : functor.add_const (topological_space (cancel_monoid Type)) Type) : @discrete_topology.{1} (cancel_monoid.{1} Type) (@functor.add_const.run.{1 1} (topological_space.{1} (cancel_monoid.{1} Type)) Type h0)  := sorry --non-trivial
lemma new_lemma_129119 (h0 : finset (has_zero (normed_comm_ring Type))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_129120 (h0 : add_group (measure_theory.measure_space empty) -> add_group (measure_theory.measure_space empty) -> Prop) : is_equiv (add_group (measure_theory.measure_space empty)) h0 := sorry --non-trivial
lemma new_lemma_129121 (h0 : function.extfun Type (functor.add_const Prop)) : functor.add_const.run (function.extfun_app h0 (canonically_ordered_comm_semiring unsigned)) := sorry --non-trivial
lemma new_lemma_129122 (h1 : ring (distrib_lattice (random_gen (has_compl (random_gen (has_nnnorm fun_info)))))) : rank_condition (distrib_lattice (random_gen (has_compl (random_gen (has_nnnorm fun_info))))) := sorry --non-trivial
lemma new_lemma_129123 (h0 : pos_num) (h1 : tree (ulower (ulower Prop))) (h2 : ulower (ulower Prop)) : @ulower.up.{0} Prop encodable.Prop (@ulower.up.{0} (@ulower.{0} Prop encodable.Prop) (@ulower.encodable.{0} Prop encodable.Prop) (@tree.get_or_else.{0} (@ulower.{0} (@ulower.{0} Prop encodable.Prop) (@ulower.encodable.{0} Prop encodable.Prop)) (@id.{1} pos_num h0) h1 h2))  := sorry --non-trivial
lemma new_lemma_129124 (h1 : add_group (normed_group string_imp)) : is_add_cyclic (normed_group string_imp) := sorry --non-trivial
lemma new_lemma_129125 (h0 : topological_space (boolean_algebra (has_Inf Type))) : discrete_topology (boolean_algebra (has_Inf Type)) := sorry --non-trivial
lemma new_lemma_129126 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @normalizer_condition.{0} (add_group.{0} linarith.comp) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (add_group.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_129127 (h0 : functor.add_const (filter (boolean_algebra environment.implicit_infer_kind)) environment.implicit_infer_kind) : countable_Inter_filter (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_129128 (h0 : topological_space (cancel_monoid (finset pos))) : normal_space (cancel_monoid (finset pos)) := sorry --non-trivial
lemma new_lemma_129129 (h0 : function.extfun (finset (Type -> Type)) (has_mem.mem complete_lattice)) : @is_compactly_generated.{0} (linear_ordered_semiring.{0} empty) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) complete_lattice.{0} (@function.extfun_app.{2 0} (finset.{1} (Type → Type)) (@has_mem.mem.{1 1} (Type → Type) (finset.{1} (Type → Type)) (@finset.has_mem.{1} (Type → Type)) complete_lattice.{0}) h0 (@has_emptyc.emptyc.{1} (finset.{1} (Type → Type)) (@finset.has_emptyc.{1} (Type → Type))))) (linear_ordered_semiring.{0} empty))  := sorry --non-trivial
lemma new_lemma_129130 (h0 : topological_space (has_add linarith.comp)) : topological_space.separable_space (has_add linarith.comp) := sorry --non-trivial
lemma new_lemma_129131 (h0 : functor.add_const (ordered_add_comm_monoid (add_left_cancel_semigroup empty)) empty) : @archimedean.{0} (add_left_cancel_semigroup.{0} empty) (@functor.add_const.run.{0 0} (ordered_add_comm_monoid.{0} (add_left_cancel_semigroup.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_129132 (h0 : ordered_comm_monoid (has_pos_part (has_neg name))) : has_exists_mul_of_le (has_pos_part (has_neg name)) := sorry --non-trivial
lemma new_lemma_129133 (h0 : uniform_space (comm_group (finset Type))) : separated_space (comm_group (finset Type)) := sorry --non-trivial
lemma new_lemma_129134 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @irreducible_space.{0} (has_add.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_add.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_129135 (h0 : function.extfun (finset Type) (has_mem.mem (has_star linarith.comp_source))) : @rank_condition.{0} (has_star.{0} linarith.comp_source) (@finset.pi.empty.{1 0} Type ring.{0} (has_star.{0} linarith.comp_source) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (has_star.{0} linarith.comp_source)) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_129136 (h0 : ordered_add_comm_monoid (has_add (has_neg (has_neg (has_neg (has_neg (has_neg linarith.comp))))))) : archimedean (has_add (has_neg (has_neg (has_neg (has_neg (has_neg linarith.comp)))))) := sorry --non-trivial
lemma new_lemma_129137 (h0 : topological_space (normed_group (semiring num))) : discrete_topology (normed_group (semiring num)) := sorry --non-trivial
lemma new_lemma_129138 (h0 : functor.add_const (ring (add_cancel_monoid linarith.comp)) (finset pos)) : @is_principal_ideal_ring.{0} (add_cancel_monoid.{0} linarith.comp) (@functor.add_const.run.{0 0} (ring.{0} (add_cancel_monoid.{0} linarith.comp)) (finset.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_129139 (h0 : function.extfun Type uniform_space) : @complete_space.{0} (generalized_boolean_algebra.{0} name) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (generalized_boolean_algebra.{0} name))  := sorry --non-trivial
lemma new_lemma_129140 (h0 : ring (add_cancel_comm_monoid string_imp)) : rank_condition (add_cancel_comm_monoid string_imp) := sorry --non-trivial
lemma new_lemma_129141 (h0 : functor.add_const (topological_space (boolean_algebra name)) environment.implicit_infer_kind) : @t0_space.{0} (boolean_algebra.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (boolean_algebra.{0} name)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_129142 (h0 : topological_space (has_compl (random_gen (random_gen string_imp)))) : totally_disconnected_space (has_compl (random_gen (random_gen string_imp))) := sorry --non-trivial
lemma new_lemma_129143 (h0 : fin has_zero.zero) : @is_atomistic.{0} (complete_distrib_lattice.{0} pos) (@matrix.vec_empty.{0} (complete_lattice.{0} (complete_distrib_lattice.{0} pos)) h0)  := sorry --non-trivial
lemma new_lemma_129144 (h0 : not (function.extfun Type group -> false)) : @normalizer_condition.{0} congr_arg_kind (@function.extfun_app.{2 1} Type group.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type group.{0}) h0) congr_arg_kind)  := sorry --non-trivial
lemma new_lemma_129145 (h0 : functor.add_const (monoid (has_neg pos)) linarith.comp) : @monoid.fg.{0} (has_neg.{0} pos) (@functor.add_const.run.{0 0} (monoid.{0} (has_neg.{0} pos)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_129146 (h0 : topological_space (add_group unsigned)) : locally_compact_space (add_group unsigned) := sorry --non-trivial
lemma new_lemma_129147 (h0 : function.extfun Type (functor.add_const (topological_space (semigroup empty)))) : @loc_path_connected_space.{0} (semigroup.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (semigroup.{0} empty)) empty (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (topological_space.{0} (semigroup.{0} empty))) h0 empty))  := sorry --non-trivial
lemma new_lemma_129148 (h0 : topological_space (semigroup name)) : locally_compact_space (semigroup name) := sorry --non-trivial
lemma new_lemma_129149 (h0 : ring (add_cancel_monoid (has_pos_part Type))) : strong_rank_condition (add_cancel_monoid (has_pos_part Type)) := sorry --non-trivial
lemma new_lemma_129150 (h0 : not (function.extfun (Type 1) topological_space -> false)) : @totally_disconnected_space.{1} (plift.{1} empty) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@classical.by_contradiction'.{3} (function.extfun.{3 2} (Type 1) topological_space.{1}) h0) (plift.{1} empty))  := sorry --non-trivial
lemma new_lemma_129151 (h0 : function.extfun Type cancel_comm_monoid_with_zero) : @unique_factorization_monoid.{0} (sub_neg_monoid.{0} pos) (@function.extfun_app.{2 1} Type cancel_comm_monoid_with_zero.{0} h0 (sub_neg_monoid.{0} pos))  := sorry --non-trivial
lemma new_lemma_129152 (h0 : functor.add_const (cancel_comm_monoid_with_zero (has_neg unsigned)) environment.implicit_infer_kind) : @unique_factorization_monoid.{0} (has_neg.{0} unsigned) (@functor.add_const.run.{0 0} (cancel_comm_monoid_with_zero.{0} (has_neg.{0} unsigned)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_129153 (h0 : topological_space (normed_field (mul_one_class (mul_one_class environment.projection_info)))) : path_connected_space (normed_field (mul_one_class (mul_one_class environment.projection_info))) := sorry --non-trivial
lemma new_lemma_129154 (h0 : not (function.extfun Type ring -> false)) : @strong_rank_condition.{0} (normed_group.{0} unsigned) (@function.extfun_app.{2 1} Type ring.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type ring.{0}) h0) (normed_group.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_129155 (h0 : function.extfun (Type 1) topological_space) : @path_connected_space.{1} (generalized_boolean_algebra.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} h0 (generalized_boolean_algebra.{1} Type))  := sorry --non-trivial
lemma new_lemma_129156 (h0 : functor.add_const (add_group (ordered_comm_ring name)) (ring pos)) : @is_add_cyclic.{0} (ordered_comm_ring.{0} name) (@functor.add_const.run.{0 0} (add_group.{0} (ordered_comm_ring.{0} name)) (ring.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_129157 (h0 : functor.add_const (ring (has_to_string name)) environment.implicit_infer_kind) : @is_domain.{0} (has_to_string.{0} name) (@functor.add_const.run.{0 0} (ring.{0} (has_to_string.{0} name)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_129158 (h0 : functor.add_const (ring (finset linarith.comp)) (has_neg pos)) : @is_domain.{0} (finset.{0} linarith.comp) (@functor.add_const.run.{0 0} (ring.{0} (finset.{0} linarith.comp)) (has_neg.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_129159 (h0 : not (topological_space (plift congr_arg_kind) -> false)) : @locally_compact_space.{1} (plift.{1} congr_arg_kind) (@classical.by_contradiction'.{2} (topological_space.{1} (plift.{1} congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_129160 (h0 : topological_space (with_bot (semiring empty))) : t0_space (with_bot (semiring empty)) := sorry --non-trivial
lemma new_lemma_129161 (h0 : ring (linear_ordered_semiring (random_gen fun_info))) : strong_rank_condition (linear_ordered_semiring (random_gen fun_info)) := sorry --non-trivial
lemma new_lemma_129162 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @separated_space.{0} (monoid.{0} unsigned) (@function.extfun_app.{2 1} Type uniform_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 uniform_space.{0}) (monoid.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_129163 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @strong_rank_condition.{0} (boolean_algebra.core.{0} pos) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (boolean_algebra.core.{0} pos))  := sorry --non-trivial
lemma new_lemma_129164 (h0 : add_group (normed_comm_ring pos)) : is_add_cyclic (normed_comm_ring pos) := sorry --non-trivial
lemma new_lemma_129165 (h0 : function.extfun Type complete_lattice) : @is_atomistic.{0} (has_inv.{0} fun_info) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (has_inv.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_129166 (h2 : complete_lattice (with_bot (random_gen to_additive.value_type))) : is_compactly_generated (with_bot (random_gen to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_129167 (h0 : ereal -> ereal -> Prop) : is_symm ereal h0 := sorry --non-trivial
lemma new_lemma_129168 (h0 : has_scalar empty (has_star congr_arg_kind)) : has_faithful_scalar empty (has_star congr_arg_kind) := sorry --non-trivial
lemma new_lemma_129169 (h0 : functor.add_const (ring (semigroup congr_arg_kind)) congr_arg_kind) : @is_domain.{0} (semigroup.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (ring.{0} (semigroup.{0} congr_arg_kind)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_129170 (h0 : not (topological_space (random_gen congr_arg_kind) -> false)) : @totally_separated_space.{0} (random_gen.{0} congr_arg_kind) (@classical.by_contradiction'.{1} (topological_space.{0} (random_gen.{0} congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_129171 (h0 : group (boolean_algebra (semigroup (add_cancel_monoid (has_add name))))) : is_cyclic (boolean_algebra (semigroup (add_cancel_monoid (has_add name)))) := sorry --non-trivial
lemma new_lemma_129172 (h0 : topological_space (ordered_comm_ring linarith.comp)) : regular_space (ordered_comm_ring linarith.comp) := sorry --non-trivial
lemma new_lemma_129173 (h0 : function.extfun (finset Type) (has_mem.mem (has_emptyc num))) : @complete_lattice.is_Sup_finite_compact.{0} (has_emptyc.{0} num) (@finset.pi.empty.{1 0} Type complete_lattice.{0} (has_emptyc.{0} num) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (has_emptyc.{0} num)) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_129174 (h0 : topological_space (finset (has_add name))) : sequential_space (finset (has_add name)) := sorry --non-trivial
lemma new_lemma_129175 (h0 : function.extfun Type ordered_add_comm_monoid) : @archimedean.{0} (cancel_monoid.{0} ennreal) (@function.extfun_app.{2 1} Type ordered_add_comm_monoid.{0} h0 (cancel_monoid.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_129176 (h0 : fin has_zero.zero) : @normalizer_condition.{1} (has_bot.{1} Type) (@matrix.vec_empty.{1} (group.{1} (has_bot.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_129177 (h0 : topological_space (has_zero (ring ennreal))) : preconnected_space (has_zero (ring ennreal)) := sorry --non-trivial
lemma new_lemma_129178 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : list.head (function.extfun_app (function.extfun_app h0 list) Prop) := sorry --non-trivial
lemma new_lemma_129179 (h0 : topological_space (finset (has_neg name))) : preirreducible_space (finset (has_neg name)) := sorry --non-trivial
lemma new_lemma_129180 (h0 : ring (has_neg_part (cancel_monoid (cancel_monoid ennreal)))) : strong_rank_condition (has_neg_part (cancel_monoid (cancel_monoid ennreal))) := sorry --non-trivial
lemma new_lemma_129181 (h0 : topological_space (ordered_comm_ring (has_add (has_add real)))) : topological_space.separable_space (ordered_comm_ring (has_add (has_add real))) := sorry --non-trivial
lemma new_lemma_129182 (h0 : function.extfun Type semiring) : @is_noetherian_ring.{0} (linear_ordered_comm_ring.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type semiring.{0} h0 (linear_ordered_comm_ring.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_129183 (h0 : functor.add_const (ring (has_neg_part name)) linarith.comp) : @strong_rank_condition.{0} (has_neg_part.{0} name) (@functor.add_const.run.{0 0} (ring.{0} (has_neg_part.{0} name)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_129184 (h0 : functor.add_const (ordered_comm_monoid (semigroup pos)) linarith.comp) : @has_exists_mul_of_le.{0} (semigroup.{0} pos) (@functor.add_const.run.{0 0} (ordered_comm_monoid.{0} (semigroup.{0} pos)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_129185 (h0 : function.extfun Type monoid) : @monoid.fg.{0} (topological_space.{0} linarith.ineq) (@function.extfun_app.{2 1} Type monoid.{0} h0 (topological_space.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_129186 (h1 : group (with_zero linarith.ineq)) : is_cyclic (with_zero linarith.ineq) := sorry --non-trivial
lemma new_lemma_129187 (h0 : functor.add_const (ordered_add_comm_monoid (has_add linarith.comp)) (finset pos)) : @archimedean.{0} (has_add.{0} linarith.comp) (@functor.add_const.run.{0 0} (ordered_add_comm_monoid.{0} (has_add.{0} linarith.comp)) (finset.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_129188 (h0 : topological_space (omega_complete_partial_order empty)) : t1_space (omega_complete_partial_order empty) := sorry --non-trivial
lemma new_lemma_129189 (h0 : functor.add_const (finset (has_neg Type)) (add_cancel_monoid (has_neg name))) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_129190 (h0 : topological_space (omega_complete_partial_order (option empty))) : locally_compact_space (omega_complete_partial_order (option empty)) := sorry --non-trivial
lemma new_lemma_129191 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_principal_ideal_ring.{0} (canonically_ordered_monoid.{0} name) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (canonically_ordered_monoid.{0} name))  := sorry --non-trivial
lemma new_lemma_129192 (h0 : functor.add_const (topological_space (canonically_ordered_comm_semiring Type)) Type) : @totally_separated_space.{1} (canonically_ordered_comm_semiring.{1} Type) (@functor.add_const.run.{1 1} (topological_space.{1} (canonically_ordered_comm_semiring.{1} Type)) Type h0)  := sorry --non-trivial
lemma new_lemma_129193 (h0 : has_Inf (canonically_linear_ordered_monoid name) -> has_Inf (canonically_linear_ordered_monoid name) -> Prop) : is_antisymm (has_Inf (canonically_linear_ordered_monoid name)) h0 := sorry --non-trivial
lemma new_lemma_129194 (h0 : function.extfun Type topological_space) : @totally_disconnected_space.{0} (with_one.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (with_one.{0} num))  := sorry --non-trivial
lemma new_lemma_129195 (h1 : topological_space (comm_ring reducibility_hints)) : path_connected_space (comm_ring reducibility_hints) := sorry --non-trivial
lemma new_lemma_129196 (h0 : group (add_group unsigned)) : normalizer_condition (add_group unsigned) := sorry --non-trivial
lemma new_lemma_129197 (h0 : group (simple_graph (boolean_algebra.core pos))) : normalizer_condition (simple_graph (boolean_algebra.core pos)) := sorry --non-trivial
lemma new_lemma_129198 (h0 : function.extfun Type topological_space) : @topological_space.separable_space.{0} (comm_group.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (comm_group.{0} pos))  := sorry --non-trivial
lemma new_lemma_129199 (h0 : uniform_space (ordered_comm_monoid real)) : complete_space (ordered_comm_monoid real) := sorry --non-trivial
lemma new_lemma_129200 (h1 : uniform_space (normed_field (denumerable char))) : complete_space (normed_field (denumerable char)) := sorry --non-trivial
lemma new_lemma_129201 (h0 : semiring (add_cancel_monoid num)) : is_noetherian_ring (add_cancel_monoid num) := sorry --non-trivial
lemma new_lemma_129202 (h0 : ring (ring (finset Type))) : rank_condition (ring (finset Type)) := sorry --non-trivial
lemma new_lemma_129203 (h0 : function.extfun Type list) : list.nodup (function.extfun_app h0 (ordered_ring empty)) := sorry --non-trivial
lemma new_lemma_129204 (h0 : function.extfun Type topological_space) : @topological_space.separable_space.{0} (has_one.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_one.{0} empty))  := sorry --non-trivial
lemma new_lemma_129205 (h0 : ring (semigroup (has_neg Type))) : rank_condition (semigroup (has_neg Type)) := sorry --non-trivial
lemma new_lemma_129206 (h0 : function.extfun Type ring) : @strong_rank_condition.{0} (add_group.{0} linarith.comp) (@function.extfun_app.{2 1} Type ring.{0} h0 (add_group.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_129207 (h0 : functor.add_const (list (cancel_monoid environment.implicit_infer_kind)) pos) : list.nodup (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_129208 (h0 : functor.add_const (topological_space (has_neg linarith.comp)) name) : @loc_path_connected_space.{0} (has_neg.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (has_neg.{0} linarith.comp)) name h0)  := sorry --non-trivial
lemma new_lemma_129209 (h0 : group (measurable_space (complete_semilattice_Sup num))) : group.fg (measurable_space (complete_semilattice_Sup num)) := sorry --non-trivial
lemma new_lemma_129210 (h0 : function.extfun nat fin) : @is_principal_ideal_ring.{0} (ordered_comm_ring.{0} pos) (@matrix.vec_empty.{0} (ring.{0} (ordered_comm_ring.{0} pos)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_129211 (h0 : functor.add_const (filter (semigroup linarith.comp)) (ring Type)) : filter.ne_bot (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_129212 (h0 : function.extfun (nat -> Type) (function.extfun nat)) : @add_monoid.fg.{0} (sub_neg_monoid.{0} linarith.comp) (@matrix.vec_empty.{0} (add_monoid.{0} (sub_neg_monoid.{0} linarith.comp)) (@function.extfun_app.{1 1} nat fin (@function.extfun_app.{2 1} (nat → Type) (function.extfun.{1 1} nat) h0 fin) (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_129213 (h0 : fun_info -> fun_info -> Prop) (h1 : not (filter fun_info -> false)) : filter.is_cobounded h0 (classical.by_contradiction' h1) := sorry --non-trivial
lemma new_lemma_129214 (h0 h1 : set (canonically_linear_ordered_monoid empty)) : set.subset h0 h1 := sorry --non-trivial
lemma new_lemma_129215 (h0 : functor.comp topological_space ring environment.implicit_infer_kind) : @locally_compact_space.{0} (ring.{0} environment.implicit_infer_kind) (@functor.comp.run.{0 0 0} topological_space.{0} ring.{0} environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_129216 (h0 : topological_space (has_edist unsigned)) : path_connected_space (has_edist unsigned) := sorry --non-trivial
lemma new_lemma_129217 (h0 : functor.add_const (group (has_zero pos)) pos) : @is_cyclic.{0} (has_zero.{0} pos) (@functor.add_const.run.{0 0} (group.{0} (has_zero.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_129218 (h2 : topological_space (dlist to_additive.value_type)) : t0_space (dlist to_additive.value_type) := sorry --non-trivial
lemma new_lemma_129219 (h0 : ring (has_le (semi_normed_ring to_additive.value_type))) : is_domain (has_le (semi_normed_ring to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_129220 (h1 : topological_space string.iterator) : totally_disconnected_space string.iterator := sorry --non-trivial
lemma new_lemma_129221 (h0 : ring (semi_normed_comm_ring (has_nnnorm reducibility_hints))) : rank_condition (semi_normed_comm_ring (has_nnnorm reducibility_hints)) := sorry --non-trivial
lemma new_lemma_129222 (h0 : not (topological_space (has_norm linarith.ineq) -> false)) : @totally_disconnected_space.{0} (has_norm.{0} linarith.ineq) (@classical.by_contradiction'.{1} (topological_space.{0} (has_norm.{0} linarith.ineq)) h0)  := sorry --non-trivial
lemma new_lemma_129223 (h0 : function.extfun Type complete_lattice) : @complete_lattice.is_Sup_finite_compact.{0} (complete_distrib_lattice.{0} name) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (complete_distrib_lattice.{0} name))  := sorry --non-trivial
lemma new_lemma_129224 (h0 : group (comm_group (has_add (has_add pos)))) : normalizer_condition (comm_group (has_add (has_add pos))) := sorry --non-trivial
lemma new_lemma_129225 (h0 : uniform_space (sub_neg_monoid (has_add Type))) : complete_space (sub_neg_monoid (has_add Type)) := sorry --non-trivial
lemma new_lemma_129226 (h0 : semiring (finset (has_neg linarith.comp))) : is_noetherian_ring (finset (has_neg linarith.comp)) := sorry --non-trivial
lemma new_lemma_129227 (h0 : ring (has_compl (simple_graph linarith.comp_source))) : strong_rank_condition (has_compl (simple_graph linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_129228 (h0 : function.extfun Type topological_space) : @t0_space.{0} (semigroup.{0} (semiring.{0} empty)) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (semigroup.{0} (semiring.{0} empty)))  := sorry --non-trivial
lemma new_lemma_129229 (h0 : functor.add_const (topological_space (has_zero ennreal)) name) : @t0_space.{0} (has_zero.{0} ennreal) (@functor.add_const.run.{0 0} (topological_space.{0} (has_zero.{0} ennreal)) name h0)  := sorry --non-trivial
lemma new_lemma_129230 (h0 : topological_space (id linarith.comp)) : path_connected_space (id linarith.comp) := sorry --non-trivial
lemma new_lemma_129231 (h0 : ring (has_to_string (has_Inf linarith.comp))) : strong_rank_condition (has_to_string (has_Inf linarith.comp)) := sorry --non-trivial
lemma new_lemma_129232 (h0 : function.extfun Type cancel_comm_monoid_with_zero) : @unique_factorization_monoid.{0} (canonically_ordered_monoid.{0} (has_nndist.{0} pos)) (@function.extfun_app.{2 1} Type cancel_comm_monoid_with_zero.{0} h0 (canonically_ordered_monoid.{0} (has_nndist.{0} pos)))  := sorry --non-trivial
lemma new_lemma_129233 (h0 : topological_space (boolean_algebra Type)) : totally_separated_space (boolean_algebra Type) := sorry --non-trivial
lemma new_lemma_129234 (h0 : complete_lattice (has_inv string_imp)) : complete_lattice.is_Sup_finite_compact (has_inv string_imp) := sorry --non-trivial
lemma new_lemma_129235 (h0 : functor.add_const (uniform_space (has_pos_part name)) Type) : @separated_space.{0} (has_pos_part.{0} name) (@functor.add_const.run.{0 1} (uniform_space.{0} (has_pos_part.{0} name)) Type h0)  := sorry --non-trivial
lemma new_lemma_129236 (h0 : functor.add_const (ordered_comm_monoid (finset pos)) Type) : @has_exists_mul_of_le.{0} (finset.{0} pos) (@functor.add_const.run.{0 1} (ordered_comm_monoid.{0} (finset.{0} pos)) Type h0)  := sorry --non-trivial
lemma new_lemma_129237 (h0 : ring (metric_space (semiring num))) : is_domain (metric_space (semiring num)) := sorry --non-trivial
lemma new_lemma_129238 (h0 : complete_lattice (dlist char)) : is_compactly_generated (dlist char) := sorry --non-trivial
lemma new_lemma_129239 (h0 : functor.add_const (group (boolean_algebra linarith.comp)) Type) : @is_cyclic.{0} (boolean_algebra.{0} linarith.comp) (@functor.add_const.run.{0 1} (group.{0} (boolean_algebra.{0} linarith.comp)) Type h0)  := sorry --non-trivial
lemma new_lemma_129240 (h0 : functor.add_const (topological_space (option num)) (semiring congr_arg_kind)) : @discrete_topology.{0} (option.{0} num) (@functor.add_const.run.{0 0} (topological_space.{0} (option.{0} num)) (semiring.{0} congr_arg_kind) h0)  := sorry --non-trivial
lemma new_lemma_129241 (h0 : complete_lattice (normed_comm_ring (finset (finset environment.implicit_infer_kind)))) : is_compactly_generated (normed_comm_ring (finset (finset environment.implicit_infer_kind))) := sorry --non-trivial
lemma new_lemma_129242 (h0 : add_monoid (has_to_string (has_add (has_to_string (has_to_string unsigned))))) : add_monoid.fg (has_to_string (has_add (has_to_string (has_to_string unsigned)))) := sorry --non-trivial
lemma new_lemma_129243 (h0 : functor.add_const (ordered_comm_monoid (has_nndist unsigned)) Type) : @has_exists_mul_of_le.{0} (has_nndist.{0} unsigned) (@functor.add_const.run.{0 1} (ordered_comm_monoid.{0} (has_nndist.{0} unsigned)) Type h0)  := sorry --non-trivial
lemma new_lemma_129244 (h0 : not (complete_lattice (with_one fun_info) -> false)) : @is_compactly_generated.{0} (with_one.{0} fun_info) (@classical.by_contradiction'.{1} (complete_lattice.{0} (with_one.{0} fun_info)) h0)  := sorry --non-trivial
lemma new_lemma_129245 (h0 : topological_space (has_pos_part name)) : sequential_space (has_pos_part name) := sorry --non-trivial
lemma new_lemma_129246 (h1 : has_coe ereal Prop) (h2 : ereal) : @coe_b.{1 1} ereal Prop h1 h2  := sorry --non-trivial
lemma new_lemma_129247 (h0 : functor.add_const (function.extfun Type group) Type) : @is_simple_group.{0} (has_add.{0} linarith.comp) (@function.extfun_app.{2 1} Type group.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type group.{0}) Type h0) (has_add.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_129248 (h0 : topological_space (complete_distrib_lattice Type)) : t1_space (complete_distrib_lattice Type) := sorry --non-trivial
lemma new_lemma_129249 (h0 : topological_space (add_cancel_monoid environment.implicit_infer_kind)) : preirreducible_space (add_cancel_monoid environment.implicit_infer_kind) := sorry --non-trivial
lemma new_lemma_129250 (h0 : topological_space (has_inter num)) : locally_compact_space (has_inter num) := sorry --non-trivial
lemma new_lemma_129251 (h0 : ring (measure_theory.measure_space (semiring num))) : is_principal_ideal_ring (measure_theory.measure_space (semiring num)) := sorry --non-trivial
lemma new_lemma_129252 (h0 : measurable_space (nondiscrete_normed_field (normed_field char))) (h1 : filter (nondiscrete_normed_field (normed_field char))) : filter.is_measurably_generated h1 := sorry --non-trivial
lemma new_lemma_129253 (h0 : topological_space (add_comm_monoid (has_add (has_neg name)))) : normal_space (add_comm_monoid (has_add (has_neg name))) := sorry --non-trivial
lemma new_lemma_129254 (h0 : function.extfun Type topological_space) : @path_connected_space.{0} (omega_complete_partial_order.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (omega_complete_partial_order.{0} empty))  := sorry --non-trivial
lemma new_lemma_129255 (h0 : semiring (has_neg (option ennreal))) : is_noetherian_ring (has_neg (option ennreal)) := sorry --non-trivial
lemma new_lemma_129256 (h0 : monoid (canonically_linear_ordered_monoid (sub_neg_monoid (has_neg (has_neg (has_neg pos)))))) : monoid.fg (canonically_linear_ordered_monoid (sub_neg_monoid (has_neg (has_neg (has_neg pos))))) := sorry --non-trivial
lemma new_lemma_129257 (h0 : functor.add_const (filter (has_neg Type)) name) : filter.ne_bot (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_129258 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @preirreducible_space.{1} (canonically_ordered_comm_semiring.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 topological_space.{1}) (canonically_ordered_comm_semiring.{1} Type))  := sorry --non-trivial
lemma new_lemma_129259 (h0 : complete_lattice (semiring (has_top linarith.comp))) : complete_lattice.is_Sup_finite_compact (semiring (has_top linarith.comp)) := sorry --non-trivial
lemma new_lemma_129260 (h0 : topological_space (has_add (finset (has_neg Type)))) : preirreducible_space (has_add (finset (has_neg Type))) := sorry --non-trivial
lemma new_lemma_129261 (h0 : functor.add_const (monoid (has_to_string Type)) (has_to_string pos)) : @monoid.fg.{1} (has_to_string.{1} Type) (@functor.add_const.run.{1 0} (monoid.{1} (has_to_string.{1} Type)) (has_to_string.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_129262 (h1 : not (topological_space (metric_space num) -> false)) : @totally_disconnected_space.{0} (metric_space.{0} num) (@classical.by_contradiction'.{1} (topological_space.{0} (metric_space.{0} num)) h1)  := sorry --non-trivial
lemma new_lemma_129263 (h0 : complete_lattice (has_compl (mul_one_class linarith.ineq))) : complete_lattice.is_Sup_finite_compact (has_compl (mul_one_class linarith.ineq)) := sorry --non-trivial
lemma new_lemma_129264 (h0 : topological_space (has_bot linarith.comp)) : discrete_topology (has_bot linarith.comp) := sorry --non-trivial
lemma new_lemma_129265 (h0 : topological_space (free_add_monoid (semiring empty))) : topological_space.separable_space (free_add_monoid (semiring empty)) := sorry --non-trivial
lemma new_lemma_129266 (h0 : uniform_space (boolean_algebra (right_cancel_semigroup Type))) : separated_space (boolean_algebra (right_cancel_semigroup Type)) := sorry --non-trivial
lemma new_lemma_129267 (h0 : topological_space (has_inner empty empty)) : totally_separated_space (has_inner empty empty) := sorry --non-trivial
lemma new_lemma_129268 (h0 : functor.add_const (semiring (canonically_ordered_comm_semiring name)) name) : @is_noetherian_ring.{0} (canonically_ordered_comm_semiring.{0} name) (@functor.add_const.run.{0 0} (semiring.{0} (canonically_ordered_comm_semiring.{0} name)) name h0)  := sorry --non-trivial
lemma new_lemma_129269 (h0 : functor.add_const (add_group (has_Sup num)) empty) : @is_add_cyclic.{0} (has_Sup.{0} num) (@functor.add_const.run.{0 0} (add_group.{0} (has_Sup.{0} num)) empty h0)  := sorry --non-trivial
lemma new_lemma_129270 (h0 : function.extfun nat fin) : @irreducible_space.{0} (has_pos_part.{0} pos) (@matrix.vec_empty.{0} (topological_space.{0} (has_pos_part.{0} pos)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_129271 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_atomistic.{0} (linear_ordered_semiring.{0} unsigned) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (linear_ordered_semiring.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_129272 (h0 : monoid (has_norm (random_gen (has_top num)))) : monoid.fg (has_norm (random_gen (has_top num))) := sorry --non-trivial
lemma new_lemma_129273 (h0 : complete_lattice (topological_space (random_gen (random_gen to_additive.value_type)))) : is_compactly_generated (topological_space (random_gen (random_gen to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_129274 (h0 : cancel_comm_monoid_with_zero (boolean_algebra (ordered_comm_monoid (has_add (has_bot pos))))) : unique_factorization_monoid (boolean_algebra (ordered_comm_monoid (has_add (has_bot pos)))) := sorry --non-trivial
lemma new_lemma_129275 (h0 : topological_space (normed_lattice_add_comm_group (boolean_algebra name))) : irreducible_space (normed_lattice_add_comm_group (boolean_algebra name)) := sorry --non-trivial
lemma new_lemma_129276 (h0 : topological_space (has_add environment.implicit_infer_kind)) : t1_space (has_add environment.implicit_infer_kind) := sorry --non-trivial
lemma new_lemma_129277 (h0 : not (function.extfun Type topological_space -> false)) : @locally_compact_space.{0} (has_inv.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (has_inv.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_129278 (h0 : not (filter (has_add linarith.ineq) -> false)) : filter.ne_bot (classical.by_contradiction' h0) := sorry --non-trivial
lemma new_lemma_129279 (h0 : not (monoid (measure_theory.measure_space congr_arg_kind) -> false)) : @monoid.exponent_exists.{0} (measure_theory.measure_space.{0} congr_arg_kind) (@classical.by_contradiction'.{1} (monoid.{0} (measure_theory.measure_space.{0} congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_129280 (h0 : topological_space (complete_distrib_lattice (has_Inf Type))) : regular_space (complete_distrib_lattice (has_Inf Type)) := sorry --non-trivial
lemma new_lemma_129281 (h0 : not (function.extfun Type topological_space -> false)) : @path_connected_space.{0} (normed_group.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (normed_group.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_129282 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_add_cyclic.{0} (comm_semigroup.{0} real) (@function.extfun_app.{2 1} Type add_group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 add_group.{0}) (comm_semigroup.{0} real))  := sorry --non-trivial
lemma new_lemma_129283 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @preirreducible_space.{0} (has_to_string.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_to_string.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_129284 (h0 : topological_space (add_cancel_monoid (has_add (has_add Type)))) : totally_separated_space (add_cancel_monoid (has_add (has_add Type))) := sorry --non-trivial
lemma new_lemma_129285 (h0 : complete_lattice (has_add (finset (has_neg pos)))) : is_compactly_generated (has_add (finset (has_neg pos))) := sorry --non-trivial
lemma new_lemma_129286 (h0 : fin has_zero.zero) : @topological_space.separable_space.{0} (sub_neg_monoid.{0} pos) (@matrix.vec_empty.{0} (topological_space.{0} (sub_neg_monoid.{0} pos)) h0)  := sorry --non-trivial
lemma new_lemma_129287 (h0 : functor.add_const (topological_space (canonically_ordered_comm_semiring linarith.comp)) pos) : @topological_space.separable_space.{0} (canonically_ordered_comm_semiring.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (canonically_ordered_comm_semiring.{0} linarith.comp)) pos h0)  := sorry --non-trivial
lemma new_lemma_129288 (h0 : functor.add_const Prop (ordered_comm_ring pos)) : functor.add_const.run h0 := sorry --non-trivial
lemma new_lemma_129289 (h0 : uniform_space (with_zero fun_info)) : complete_space (with_zero fun_info) := sorry --non-trivial
lemma new_lemma_129290 (h0 : functor.add_const (semiring (semigroup linarith.comp)) pos) : @is_noetherian_ring.{0} (semigroup.{0} linarith.comp) (@functor.add_const.run.{0 0} (semiring.{0} (semigroup.{0} linarith.comp)) pos h0)  := sorry --non-trivial
lemma new_lemma_129291 (h0 : finset (canonically_ordered_comm_semiring (option (option empty)))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_129292 (h0 : functor.comp topological_space finset name) : @regular_space.{0} (finset.{0} name) (@functor.comp.run.{0 0 0} topological_space.{0} finset.{0} name h0)  := sorry --non-trivial
lemma new_lemma_129293 (h0 : add_group (semiring (random_gen (random_gen (random_gen linarith.comp_source))))) : is_add_cyclic (semiring (random_gen (random_gen (random_gen linarith.comp_source)))) := sorry --non-trivial
lemma new_lemma_129294 (h0 : topological_space (add_cancel_monoid Type)) : irreducible_space (add_cancel_monoid Type) := sorry --non-trivial
lemma new_lemma_129295 (h0 : add_monoid (boolean_algebra (comm_group unsigned))) : add_monoid.fg (boolean_algebra (comm_group unsigned)) := sorry --non-trivial
lemma new_lemma_129296 (h0 : group (has_union (has_norm num))) : is_cyclic (has_union (has_norm num)) := sorry --non-trivial
lemma new_lemma_129297 (h0 : complete_lattice (boolean_algebra.core (option ennreal))) : complete_lattice.is_Sup_finite_compact (boolean_algebra.core (option ennreal)) := sorry --non-trivial
lemma new_lemma_129298 (h0 : complete_lattice (has_sub (semiring (has_top empty)))) : is_atomistic (has_sub (semiring (has_top empty))) := sorry --non-trivial
lemma new_lemma_129299 (h0 : function.extfun Type topological_space) : @totally_separated_space.{0} (comm_semigroup.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (comm_semigroup.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_129300 (h0 : topological_space (denumerable (has_inv (has_nnnorm fun_info)))) : t0_space (denumerable (has_inv (has_nnnorm fun_info))) := sorry --non-trivial
lemma new_lemma_129301 (h0 : prod (normed_comm_ring (finset name)) (normed_comm_ring (finset name))) : id_rel h0 := sorry --non-trivial
lemma new_lemma_129302 (h2 : not (ring (random_gen fun_info) -> false)) : @is_domain.{0} (random_gen.{0} fun_info) (@classical.by_contradiction'.{1} (ring.{0} (random_gen.{0} fun_info)) h2)  := sorry --non-trivial
lemma new_lemma_129303 (h0 : complete_lattice (has_pos_part Type)) : is_atomistic (has_pos_part Type) := sorry --non-trivial
lemma new_lemma_129304 (h0 : filter (normed_group linarith.comp)) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_129305 (h0 : topological_space (linear_ordered_add_comm_monoid_with_top num)) : topological_space.separable_space (linear_ordered_add_comm_monoid_with_top num) := sorry --non-trivial
lemma new_lemma_129306 (h2 : topological_space (distrib_lattice name)) : t0_space (distrib_lattice name) := sorry --non-trivial
lemma new_lemma_129307 (h0 : filter (cancel_monoid (comm_group Type))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_129308 (h0 : functor.comp topological_space add_comm_monoid unsigned) : @totally_separated_space.{0} (add_comm_monoid.{0} unsigned) (@functor.comp.run.{0 0 0} topological_space.{0} add_comm_monoid.{0} unsigned h0)  := sorry --non-trivial
lemma new_lemma_129309 (h0 : topological_space (has_zero (finset (ring Type)))) : regular_space (has_zero (finset (ring Type))) := sorry --non-trivial
lemma new_lemma_129310 (h0 : topological_space (has_to_string (has_to_string unsigned))) : regular_space (has_to_string (has_to_string unsigned)) := sorry --non-trivial
lemma new_lemma_129311 (h0 : functor.add_const (complete_lattice (cancel_monoid unsigned)) name) : @is_compactly_generated.{0} (cancel_monoid.{0} unsigned) (@functor.add_const.run.{0 0} (complete_lattice.{0} (cancel_monoid.{0} unsigned)) name h0)  := sorry --non-trivial
lemma new_lemma_129312 (h0 : functor.add_const (cancel_comm_monoid_with_zero (has_add Type)) (has_zero Type)) : @unique_factorization_monoid.{1} (has_add.{1} Type) (@functor.add_const.run.{1 1} (cancel_comm_monoid_with_zero.{1} (has_add.{1} Type)) (has_zero.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_129313 (h0 : add_monoid (preorder congr_arg_kind)) : add_monoid.fg (preorder congr_arg_kind) := sorry --non-trivial
lemma new_lemma_129314 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @preirreducible_space.{1} (comm_group.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 topological_space.{1}) (comm_group.{1} Type))  := sorry --non-trivial
lemma new_lemma_129315 (h1 : ring (has_top (has_top (has_top congr_arg_kind)))) : strong_rank_condition (has_top (has_top (has_top congr_arg_kind))) := sorry --non-trivial
lemma new_lemma_129316 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @discrete_topology.{0} (non_assoc_semiring.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (non_assoc_semiring.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_129317 (h0 : topological_space (normed_field to_additive.value_type)) (h1 : add_group (normed_field to_additive.value_type)) : topological_add_group (normed_field to_additive.value_type) := sorry --non-trivial
lemma new_lemma_129318 (h0 : ring (has_bot (has_Inf (has_add real)))) : is_domain (has_bot (has_Inf (has_add real))) := sorry --non-trivial
lemma new_lemma_129319 (h0 : list (cancel_monoid (option unsigned))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_129320 (h0 : topological_space (linear_ordered_field (option (option (option (option (option empty))))))) : path_connected_space (linear_ordered_field (option (option (option (option (option empty)))))) := sorry --non-trivial
lemma new_lemma_129321 (h0 : filter (add_comm_monoid (option ennreal))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_129322 (h0 : not (list (has_ssubset fun_info) -> false)) : list.nodup (classical.by_contradiction' h0) := sorry --non-trivial
lemma new_lemma_129323 (h0 : topological_space (cancel_monoid empty)) : irreducible_space (cancel_monoid empty) := sorry --non-trivial
lemma new_lemma_129324 (h0 : ring (measurable_space.dynkin_system (semiring (semiring congr_arg_kind)))) : is_domain (measurable_space.dynkin_system (semiring (semiring congr_arg_kind))) := sorry --non-trivial
lemma new_lemma_129325 (h0 : functor.add_const (ring (finset name)) name) : @strong_rank_condition.{0} (finset.{0} name) (@functor.add_const.run.{0 0} (ring.{0} (finset.{0} name)) name h0)  := sorry --non-trivial
lemma new_lemma_129326 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_cyclic.{0} (has_norm.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (has_norm.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_129327 (h0 : function.extfun nat fin) : @totally_disconnected_space.{0} (boolean_algebra.{0} pos) (@matrix.vec_empty.{0} (topological_space.{0} (boolean_algebra.{0} pos)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_129328 (h0 : functor.add_const (function.extfun Type list) name) : list.nodup (function.extfun_app (functor.add_const.run h0) (finset name)) := sorry --non-trivial
lemma new_lemma_129329 (h0 : prod (semigroup (semiring num)) (semigroup (semiring num))) : id_rel h0 := sorry --non-trivial
lemma new_lemma_129330 (h0 : topological_space (distrib fun_info)) (h1 : add_group (distrib fun_info)) : topological_add_group (distrib fun_info) := sorry --non-trivial
lemma new_lemma_129331 (h0 : topological_space (has_neg (has_neg linarith.comp))) : regular_space (has_neg (has_neg linarith.comp)) := sorry --non-trivial
lemma new_lemma_129332 (h0 : complete_lattice (linear_ordered_field (option empty))) : is_atomistic (linear_ordered_field (option empty)) := sorry --non-trivial
lemma new_lemma_129333 (h0 : topological_space (has_norm fun_info)) : irreducible_space (has_norm fun_info) := sorry --non-trivial
lemma new_lemma_129334 (h0 : has_mem.mem (measurable_space empty) has_emptyc.emptyc) : @separated_space.{0} (measurable_space.{0} empty) (@finset.pi.empty.{1 0} Type uniform_space.{0} (measurable_space.{0} empty) h0)  := sorry --non-trivial
lemma new_lemma_129335 (h0 : not (complete_lattice reducibility_hints -> false)) : @complete_lattice.is_Sup_finite_compact.{0} reducibility_hints (@classical.by_contradiction'.{1} (complete_lattice.{0} reducibility_hints) h0)  := sorry --non-trivial
lemma new_lemma_129336 (h0 : function.extfun Type ring) : @strong_rank_condition.{0} (complete_distrib_lattice.{0} pos) (@function.extfun_app.{2 1} Type ring.{0} h0 (complete_distrib_lattice.{0} pos))  := sorry --non-trivial
lemma new_lemma_129337 (h0 : functor.add_const (topological_space (ring environment.implicit_infer_kind)) environment.implicit_infer_kind) : @normal_space.{0} (ring.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (ring.{0} environment.implicit_infer_kind)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_129338 (h0 : functor.add_const (topological_space (has_neg linarith.comp)) (ring linarith.comp)) : @t1_space.{0} (has_neg.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (has_neg.{0} linarith.comp)) (ring.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_129339 (h0 : list (has_top (with_bot (with_bot (with_bot (with_bot string_imp)))))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_129340 (h0 : not (function.extfun Type ring -> false)) : @is_domain.{0} real.angle (@function.extfun_app.{2 1} Type ring.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type ring.{0}) h0) real.angle)  := sorry --non-trivial
lemma new_lemma_129341 (h0 : function.extfun Type (functor.comp finset has_neg)) : finset.nonempty (functor.comp.run (function.extfun_app h0 pos)) := sorry --non-trivial
lemma new_lemma_129342 (h0 : function.extfun Type ring) : @rank_condition.{0} (simple_graph.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type ring.{0} h0 (simple_graph.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_129343 (h0 : ordered_comm_monoid (has_nndist (has_nndist environment.implicit_infer_kind))) : has_exists_mul_of_le (has_nndist (has_nndist environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_129344 (h2 : group (comm_ring (metric_space (denumerable to_additive.value_type)))) : is_cyclic (comm_ring (metric_space (denumerable to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_129345 (h0 : ring (has_pos_part pos)) : rank_condition (has_pos_part pos) := sorry --non-trivial
lemma new_lemma_129346 (h0 : pnat) (h1 : thunk pnat) (h2 : ulower empty) : pnat.coprime (pnat.mod h0 (@trace_call_stack.{0} pnat h1)) (@empty.elim.{1} pnat (@ulower.up.{0} empty encodable.empty h2))  := sorry --non-trivial
lemma new_lemma_129347 (h0 : functor.add_const (function.extfun (Type 1) add_monoid) Type) : @add_monoid.fg.{1} (has_nndist.{1} Type) (@function.extfun_app.{3 2} (Type 1) add_monoid.{1} (@functor.add_const.run.{2 1} (function.extfun.{3 2} (Type 1) add_monoid.{1}) Type h0) (has_nndist.{1} Type))  := sorry --non-trivial
lemma new_lemma_129348 (h1 : uniform_space (topological_space string_imp)) : complete_space (topological_space string_imp) := sorry --non-trivial
lemma new_lemma_129349 (h2 : ring reducibility_hints) : strong_rank_condition reducibility_hints := sorry --non-trivial
lemma new_lemma_129350 (h0 : complete_lattice (complete_distrib_lattice (has_add pos))) : is_atomistic (complete_distrib_lattice (has_add pos)) := sorry --non-trivial
lemma new_lemma_129351 (h0 : uniform_space (add_group (semiring linarith.comp))) : separated_space (add_group (semiring linarith.comp)) := sorry --non-trivial
lemma new_lemma_129352 (h0 : group (canonically_ordered_monoid linarith.comp)) : group.fg (canonically_ordered_monoid linarith.comp) := sorry --non-trivial
lemma new_lemma_129353 (h0 : set (has_lt (mul_one_class (mul_one_class (mul_one_class fun_info))))) : set.finite h0 := sorry --non-trivial
lemma new_lemma_129354 (h0 : function.extfun Type topological_space) : @locally_compact_space.{0} (metric_space.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (metric_space.{0} num))  := sorry --non-trivial
lemma new_lemma_129355 (h0 : set (canonically_ordered_comm_semiring to_additive.value_type)) : set.subsingleton h0 := sorry --non-trivial
lemma new_lemma_129356 (h1 : topological_space (random_gen reducibility_hints)) : totally_disconnected_space (random_gen reducibility_hints) := sorry --non-trivial
lemma new_lemma_129357 (h1 : has_mem.mem (function.extfun Type) has_emptyc.emptyc) : @is_cyclic.{0} (has_emptyc.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) (@finset.pi.empty.{2 1} ((Type → Type) → Type 1) (function.extfun.{2 2} (Type → Type)) (function.extfun.{2 1} Type) h1) group.{0}) (has_emptyc.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_129358 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @has_exists_mul_of_le.{0} (normed_lattice_add_comm_group.{0} real) (@function.extfun_app.{2 1} Type ordered_comm_monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ordered_comm_monoid.{0}) (normed_lattice_add_comm_group.{0} real))  := sorry --non-trivial
lemma new_lemma_129359 (h0 : function.extfun Type uniform_space) : @complete_space.{0} (has_star.{0} num) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (has_star.{0} num))  := sorry --non-trivial
lemma new_lemma_129360 (h0 : functor.add_const (topological_space (boolean_algebra pos)) linarith.comp) : @discrete_topology.{0} (boolean_algebra.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (boolean_algebra.{0} pos)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_129361 (h0 : topological_space (nondiscrete_normed_field (add_comm_semigroup (add_comm_semigroup enat)))) : t0_space (nondiscrete_normed_field (add_comm_semigroup (add_comm_semigroup enat))) := sorry --non-trivial
lemma new_lemma_129362 (h0 : has_mem.mem (has_union linarith.comp) has_emptyc.emptyc) : @rank_condition.{0} (has_union.{0} linarith.comp) (@finset.pi.empty.{1 0} Type ring.{0} (has_union.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_129363 (h0 : topological_space (add_cancel_monoid (has_add Type))) : path_connected_space (add_cancel_monoid (has_add Type)) := sorry --non-trivial
lemma new_lemma_129364 (h0 : topological_space (comm_ring (has_top fun_info))) : t0_space (comm_ring (has_top fun_info)) := sorry --non-trivial
lemma new_lemma_129365 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @strong_rank_condition.{0} (complete_distrib_lattice.{0} unsigned) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (complete_distrib_lattice.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_129366 (h0 : function.extfun Type uniform_space) : @separated_space.{0} (add_left_cancel_semigroup.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (add_left_cancel_semigroup.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_129367 (h0 : ring (has_append (has_lt linarith.ineq))) : strong_rank_condition (has_append (has_lt linarith.ineq)) := sorry --non-trivial
lemma new_lemma_129368 (h0 : ordered_add_comm_monoid (plift (free_add_monoid (option (option unsigned))))) : archimedean (plift (free_add_monoid (option (option unsigned)))) := sorry --non-trivial
lemma new_lemma_129369 (h3 : ring (uniform_space (mul_one_class string.iterator_imp))) : strong_rank_condition (uniform_space (mul_one_class string.iterator_imp)) := sorry --non-trivial
lemma new_lemma_129370 (h0 : not (group (has_inv char) -> false)) : @group.fg.{0} (has_inv.{0} char) (@classical.by_contradiction'.{1} (group.{0} (has_inv.{0} char)) h0)  := sorry --non-trivial
lemma new_lemma_129371 (h0 : preorder (mul_one_class ereal)) (h1 : set (mul_one_class ereal)) : set.is_pwo h1 := sorry --non-trivial
lemma new_lemma_129372 (h0 : topological_space (finset empty)) : topological_space.separable_space (finset empty) := sorry --non-trivial
lemma new_lemma_129373 (h0 : functor.add_const (topological_space (comm_group unsigned)) name) : @preconnected_space.{0} (comm_group.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (comm_group.{0} unsigned)) name h0)  := sorry --non-trivial
lemma new_lemma_129374 (h0 : complete_lattice (uniform_space linarith.ineq)) : is_compactly_generated (uniform_space linarith.ineq) := sorry --non-trivial
lemma new_lemma_129375 (h0 : group (has_top (has_norm (distrib_lattice (has_norm to_additive.value_type))))) : is_cyclic (has_top (has_norm (distrib_lattice (has_norm to_additive.value_type)))) := sorry --non-trivial
lemma new_lemma_129376 (h1 : filter (add_left_cancel_monoid string_imp)) : filter.ne_bot h1 := sorry --non-trivial
lemma new_lemma_129377 (h0 : ring (measurable_space.dynkin_system num)) : is_principal_ideal_ring (measurable_space.dynkin_system num) := sorry --non-trivial
lemma new_lemma_129378 (h0 : ring (has_nndist (add_comm_monoid Type))) : is_domain (has_nndist (add_comm_monoid Type)) := sorry --non-trivial
lemma new_lemma_129379 (h0 : cancel_comm_monoid_with_zero (boolean_algebra environment.implicit_infer_kind)) : unique_factorization_monoid (boolean_algebra environment.implicit_infer_kind) := sorry --non-trivial
lemma new_lemma_129380 (h0 : uniform_space (boolean_algebra.core (ring Type))) : complete_space (boolean_algebra.core (ring Type)) := sorry --non-trivial
lemma new_lemma_129381 (h0 : topological_space (normed_comm_ring (has_add unsigned))) : irreducible_space (normed_comm_ring (has_add unsigned)) := sorry --non-trivial
lemma new_lemma_129382 (h0 : functor.add_const (topological_space (add_comm_monoid pos)) pos) : @t1_space.{0} (add_comm_monoid.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (add_comm_monoid.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_129383 (h1 : complete_lattice (has_compl string_imp)) : complete_lattice.is_Sup_finite_compact (has_compl string_imp) := sorry --non-trivial
lemma new_lemma_129384 (h0 : group (linear_ordered_comm_ring empty)) : is_cyclic (linear_ordered_comm_ring empty) := sorry --non-trivial
lemma new_lemma_129385 (h0 : ring (mul_zero_class (semiring empty))) : strong_rank_condition (mul_zero_class (semiring empty)) := sorry --non-trivial
lemma new_lemma_129386 (h0 : monoid (free_add_monoid unsigned)) : monoid.fg (free_add_monoid unsigned) := sorry --non-trivial
lemma new_lemma_129387 (h0 : ring (has_neg (has_add pos))) : is_domain (has_neg (has_add pos)) := sorry --non-trivial
lemma new_lemma_129388 (h0 : group (topological_space to_additive.value_type)) : group.fg (topological_space to_additive.value_type) := sorry --non-trivial
lemma new_lemma_129389 (h0 : functor.add_const (list (has_pos_part linarith.comp)) linarith.comp) : palindrome (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_129390 (h0 : topological_space (finset (has_nndist environment.implicit_infer_kind))) : preirreducible_space (finset (has_nndist environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_129391 (h0 : functor.add_const (measurable_space Type) Type) (h1 : functor.add_const (has_div Type) name) : @has_measurable_div₂.{1} Type (@functor.add_const.run.{1 1} (measurable_space.{1} Type) Type h0) (@functor.add_const.run.{1 0} (has_div.{1} Type) name h1)  := sorry --non-trivial
lemma new_lemma_129392 (h0 : monoid (normed_comm_ring (add_comm_monoid unsigned))) : monoid.fg (normed_comm_ring (add_comm_monoid unsigned)) := sorry --non-trivial
lemma new_lemma_129393 (h0 : uniform_space (plift (semiring (complete_linear_order num)))) : separated_space (plift (semiring (complete_linear_order num))) := sorry --non-trivial
lemma new_lemma_129394 (h0 : topological_space (has_norm (random_gen (random_gen (has_top string_imp))))) : t0_space (has_norm (random_gen (random_gen (has_top string_imp)))) := sorry --non-trivial
lemma new_lemma_129395 (h0 : topological_space (has_pos_part (has_Inf linarith.comp))) : path_connected_space (has_pos_part (has_Inf linarith.comp)) := sorry --non-trivial
lemma new_lemma_129396 (h0 : monoid (semigroup (has_pos_part (finset linarith.comp)))) : monoid.fg (semigroup (has_pos_part (finset linarith.comp))) := sorry --non-trivial
lemma new_lemma_129397 (h0 : topological_space (add_right_cancel_monoid (semiring empty))) : totally_separated_space (add_right_cancel_monoid (semiring empty)) := sorry --non-trivial
lemma new_lemma_129398 (h0 : topological_space (ordered_cancel_add_comm_monoid unsigned)) : totally_separated_space (ordered_cancel_add_comm_monoid unsigned) := sorry --non-trivial
lemma new_lemma_129399 (h0 : topological_space (add_cancel_monoid (finset (finset pos)))) : path_connected_space (add_cancel_monoid (finset (finset pos))) := sorry --non-trivial
lemma new_lemma_129400 (h0 : topological_space (non_assoc_semiring (semiring (semiring (semiring congr_arg_kind))))) : totally_separated_space (non_assoc_semiring (semiring (semiring (semiring congr_arg_kind)))) := sorry --non-trivial
lemma new_lemma_129401 (h0 : uniform_space (plift (has_top (semiring (has_top empty))))) : separated_space (plift (has_top (semiring (has_top empty)))) := sorry --non-trivial
lemma new_lemma_129402 (h0 : complete_lattice (ordered_comm_monoid (has_add pos))) : complete_lattice.is_Sup_finite_compact (ordered_comm_monoid (has_add pos)) := sorry --non-trivial
lemma new_lemma_129403 (h0 : filter (complete_semilattice_Sup (has_inv (has_nnnorm (has_nnnorm (has_inv linarith.ineq)))))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_129404 (h0 : not (add_monoid (has_norm empty) -> false)) : @add_monoid.fg.{0} (has_norm.{0} empty) (@classical.by_contradiction'.{1} (add_monoid.{0} (has_norm.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_129405 (h0 : not (prod empty empty -> false)) : id_rel (classical.by_contradiction' h0) := sorry --non-trivial
lemma new_lemma_129406 (h0 : setoid (semi_normed_ring char)) (h1 : semi_normed_ring char) : set.finite (setoid.rel h0 h1) := sorry --non-trivial
lemma new_lemma_129407 (h0 : topological_space (monoid (option (option unsigned)))) : t0_space (monoid (option (option unsigned))) := sorry --non-trivial
lemma new_lemma_129408 (h0 : function.extfun Type topological_space) : @sequential_space.{0} (has_pos_part.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_pos_part.{0} pos))  := sorry --non-trivial
lemma new_lemma_129409 (h0 : group (has_ssubset (has_ssubset (comm_ring string_imp)))) : is_cyclic (has_ssubset (has_ssubset (comm_ring string_imp))) := sorry --non-trivial
lemma new_lemma_129410 (h0 : list (pseudo_metric_space (has_nndist (ring (has_add (has_add name)))))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_129411 (h0 : function.extfun (finset Type) (has_mem.mem (random_gen linarith.comp))) : @group.fg.{0} (random_gen.{0} linarith.comp) (@finset.pi.empty.{1 0} Type group.{0} (random_gen.{0} linarith.comp) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (random_gen.{0} linarith.comp)) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_129412 (h0 : not (complete_lattice (denumerable linarith.ineq) -> false)) : @complete_lattice.is_Sup_finite_compact.{0} (denumerable.{0} linarith.ineq) (@classical.by_contradiction'.{1} (complete_lattice.{0} (denumerable.{0} linarith.ineq)) h0)  := sorry --non-trivial
lemma new_lemma_129413 (h0 : monoid (linear_ordered_cancel_comm_monoid congr_arg_kind)) : monoid.fg (linear_ordered_cancel_comm_monoid congr_arg_kind) := sorry --non-trivial
lemma new_lemma_129414 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : list.nodup (function.extfun_app (function.extfun_app h0 list) (has_inv linarith.ineq)) := sorry --non-trivial
lemma new_lemma_129415 (h0 : function.extfun Type complete_lattice) : @is_atomistic.{0} (has_zero.{0} unsigned) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (has_zero.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_129416 (h0 : set (set fun_info)) (h1 : set fun_info) : topological_space.generate_open h0 h1 := sorry --non-trivial
lemma new_lemma_129417 (h0 : functor.add_const (complete_lattice (semigroup Type)) (has_nndist pos)) : @complete_lattice.is_Sup_finite_compact.{1} (semigroup.{1} Type) (@functor.add_const.run.{1 0} (complete_lattice.{1} (semigroup.{1} Type)) (has_nndist.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_129418 (h0 : topological_space (has_zero (option name))) : sequential_space (has_zero (option name)) := sorry --non-trivial
lemma new_lemma_129419 (h0 : ring (measure_theory.measure_space (semiring empty))) : rank_condition (measure_theory.measure_space (semiring empty)) := sorry --non-trivial
lemma new_lemma_129420 (h0 : functor.add_const (topological_space (has_neg_part pos)) (option pos)) : @irreducible_space.{0} (has_neg_part.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (has_neg_part.{0} pos)) (option.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_129421 (h0 : topological_space (has_bot (option unsigned))) : path_connected_space (has_bot (option unsigned)) := sorry --non-trivial
lemma new_lemma_129422 (h0 : functor.add_const (topological_space (sub_neg_monoid pos)) (has_add name)) : @preirreducible_space.{0} (sub_neg_monoid.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (sub_neg_monoid.{0} pos)) (has_add.{0} name) h0)  := sorry --non-trivial
lemma new_lemma_129423 (h0 : not (semiring (measurable_space.dynkin_system congr_arg_kind) -> false)) : @is_noetherian_ring.{0} (measurable_space.dynkin_system.{0} congr_arg_kind) (@classical.by_contradiction'.{1} (semiring.{0} (measurable_space.dynkin_system.{0} congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_129424 (h0 h1 : multiset Prop) : @multiset.inf.{0} Prop (@lattice.to_semilattice_inf.{0} Prop (@conditionally_complete_lattice.to_lattice.{0} Prop (@complete_lattice.to_conditionally_complete_lattice.{0} Prop Prop.complete_lattice))) (@bounded_order.to_order_top.{0} Prop (@preorder.to_has_le.{0} Prop (@partial_order.to_preorder.{0} Prop (@semilattice_inf.to_partial_order.{0} Prop (@lattice.to_semilattice_inf.{0} Prop (@conditionally_complete_lattice.to_lattice.{0} Prop (@complete_lattice.to_conditionally_complete_lattice.{0} Prop Prop.complete_lattice)))))) Prop.bounded_order) (@multiset.inter.{0} Prop (λ (a b : Prop), @eq.decidable.{0} Prop Prop.linear_order a b) h0 h1)  := sorry --non-trivial
lemma new_lemma_129425 (h2 h3 : multiset (random_gen to_additive.value_type)) : multiset.disjoint h2 h3 := sorry --non-trivial
lemma new_lemma_129426 (h0 : complete_lattice (canonically_ordered_comm_semiring (has_zero (semigroup linarith.comp)))) : is_atomistic (canonically_ordered_comm_semiring (has_zero (semigroup linarith.comp))) := sorry --non-trivial
lemma new_lemma_129427 (h0 : topological_space (linear_ordered_comm_group empty)) : topological_space.separable_space (linear_ordered_comm_group empty) := sorry --non-trivial
lemma new_lemma_129428 (h0 : has_mem.mem (with_one congr_arg_kind) has_emptyc.emptyc) : @normalizer_condition.{0} (with_one.{0} congr_arg_kind) (@finset.pi.empty.{1 0} Type group.{0} (with_one.{0} congr_arg_kind) h0)  := sorry --non-trivial
lemma new_lemma_129429 (h0 : not (function.extfun (Type -> Type) (function.extfun Type) -> false)) : @add_monoid.fg.{0} (has_one.{0} empty) (@function.extfun_app.{2 1} Type add_monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) (@classical.by_contradiction'.{2} (function.extfun.{2 2} (Type → Type) (function.extfun.{2 1} Type)) h0) add_monoid.{0}) (has_one.{0} empty))  := sorry --non-trivial
lemma new_lemma_129430 (h0 : group (linear_ordered_comm_monoid_with_zero (has_edist unsigned))) : group.fg (linear_ordered_comm_monoid_with_zero (has_edist unsigned)) := sorry --non-trivial
lemma new_lemma_129431 (h0 : group (left_cancel_monoid (partial_order unsigned))) : normalizer_condition (left_cancel_monoid (partial_order unsigned)) := sorry --non-trivial
lemma new_lemma_129432 (h0 : topological_space (canonically_ordered_monoid (sub_neg_monoid Type))) : totally_disconnected_space (canonically_ordered_monoid (sub_neg_monoid Type)) := sorry --non-trivial
lemma new_lemma_129433 (h0 : topological_space (has_bot linarith.comp)) : loc_path_connected_space (has_bot linarith.comp) := sorry --non-trivial
lemma new_lemma_129434 (h0 : topological_space (generalized_boolean_algebra (ordered_comm_monoid (sub_neg_monoid real)))) : path_connected_space (generalized_boolean_algebra (ordered_comm_monoid (sub_neg_monoid real))) := sorry --non-trivial
lemma new_lemma_129435 (h0 : functor.add_const (topological_space (simple_graph empty)) num) : @t0_space.{0} (simple_graph.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (simple_graph.{0} empty)) num h0)  := sorry --non-trivial
lemma new_lemma_129436 (h0 : functor.add_const (function.extfun Type uniform_space) pos) : @separated_space.{0} (has_Inf.{0} pos) (@function.extfun_app.{2 1} Type uniform_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type uniform_space.{0}) pos h0) (has_Inf.{0} pos))  := sorry --non-trivial
lemma new_lemma_129437 (h1 : set (add_comm_semigroup linarith.ineq -> add_comm_semigroup fun_info)) : set.separates_points h1 := sorry --non-trivial
lemma new_lemma_129438 (h0 : finset (add_left_cancel_semigroup empty)) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_129439 (h0 : uniform_space (add_cancel_monoid (has_add (boolean_algebra.core pos)))) : complete_space (add_cancel_monoid (has_add (boolean_algebra.core pos))) := sorry --non-trivial
lemma new_lemma_129440 (h0 : semiring (with_bot (semiring (semiring (semiring (semiring congr_arg_kind)))))) : is_noetherian_ring (with_bot (semiring (semiring (semiring (semiring congr_arg_kind))))) := sorry --non-trivial
lemma new_lemma_129441 (h0 : topological_space (ordered_ring (semiring num))) : preirreducible_space (ordered_ring (semiring num)) := sorry --non-trivial
lemma new_lemma_129442 (h0 : uniform_space (complete_linear_order (semiring (ordered_cancel_comm_monoid unsigned)))) : complete_space (complete_linear_order (semiring (ordered_cancel_comm_monoid unsigned))) := sorry --non-trivial
lemma new_lemma_129443 (h0 : topological_space (plift (semiring (semiring num)))) : totally_separated_space (plift (semiring (semiring num))) := sorry --non-trivial
lemma new_lemma_129444 (h0 : semiring (linear_ordered_semiring (with_bot (has_top unsigned)))) : is_noetherian_ring (linear_ordered_semiring (with_bot (has_top unsigned))) := sorry --non-trivial
lemma new_lemma_129445 (h0 : functor.add_const (topological_space (has_to_string Type)) name) : @preirreducible_space.{1} (has_to_string.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (has_to_string.{1} Type)) name h0)  := sorry --non-trivial
lemma new_lemma_129446 (h0 : not (function.extfun Type complete_lattice -> false)) : is_atomistic (measurable_space linarith.comp) := sorry --non-trivial
lemma new_lemma_129447 (h0 : topological_space (has_to_string ennreal)) : t0_space (has_to_string ennreal) := sorry --non-trivial
lemma new_lemma_129448 (h0 : functor.add_const (topological_space (mul_zero_class num)) congr_arg_kind) : @path_connected_space.{0} (mul_zero_class.{0} num) (@functor.add_const.run.{0 0} (topological_space.{0} (mul_zero_class.{0} num)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_129449 (h0 : ring (canonically_ordered_comm_semiring pos)) : rank_condition (canonically_ordered_comm_semiring pos) := sorry --non-trivial
lemma new_lemma_129450 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @loc_path_connected_space.{0} (has_neg.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_neg.{0} name))  := sorry --non-trivial
lemma new_lemma_129451 (h0 : complete_lattice (mul_zero_class (has_add (has_add name)))) : is_compactly_generated (mul_zero_class (has_add (has_add name))) := sorry --non-trivial
lemma new_lemma_129452 (h0 : functor.add_const (function.extfun (Type 1) complete_lattice) Type) : @is_atomistic.{1} (has_nndist.{1} Type) (@function.extfun_app.{3 2} (Type 1) complete_lattice.{1} (@functor.add_const.run.{2 1} (function.extfun.{3 2} (Type 1) complete_lattice.{1}) Type h0) (has_nndist.{1} Type))  := sorry --non-trivial
lemma new_lemma_129453 (h0 : ring (generalized_boolean_algebra real)) : strong_rank_condition (generalized_boolean_algebra real) := sorry --non-trivial
lemma new_lemma_129454 (h0 : filter (has_zero (has_to_string pos))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_129455 (h0 : function.extfun Type group) : @normalizer_condition.{0} unsigned (@function.extfun_app.{2 1} Type group.{0} h0 unsigned)  := sorry --non-trivial
lemma new_lemma_129456 (h0 : fin has_zero.zero) : @t0_space.{1} (semigroup.{1} Type) (@matrix.vec_empty.{1} (topological_space.{1} (semigroup.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_129457 (h0 : group (has_add (has_add (has_add (finset (has_add (has_add name))))))) : is_simple_group (has_add (has_add (has_add (finset (has_add (has_add name)))))) := sorry --non-trivial
lemma new_lemma_129458 (h0 : topological_space (has_emptyc (has_norm (has_norm linarith.comp_source)))) : irreducible_space (has_emptyc (has_norm (has_norm linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_129459 (h0 : ring (has_nnnorm (mul_one_class fun_info))) : strong_rank_condition (has_nnnorm (mul_one_class fun_info)) := sorry --non-trivial
lemma new_lemma_129460 (h0 : group (boolean_algebra.core (has_add pos))) : normalizer_condition (boolean_algebra.core (has_add pos)) := sorry --non-trivial
lemma new_lemma_129461 (h0 : topological_space (has_top (random_gen linarith.comp_source))) : t0_space (has_top (random_gen linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_129462 (h0 : function.extfun Type topological_space) : @preirreducible_space.{0} (has_edist.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_edist.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_129463 (h1 : not (complete_lattice (normed_field string.iterator_imp) -> false)) : @is_compactly_generated.{0} (normed_field.{0} string.iterator_imp) (@classical.by_contradiction'.{1} (complete_lattice.{0} (normed_field.{0} string.iterator_imp)) h1)  := sorry --non-trivial
lemma new_lemma_129464 (h0 : topological_space (mul_zero_class (has_add pos))) : regular_space (mul_zero_class (has_add pos)) := sorry --non-trivial
lemma new_lemma_129465 (h0 : add_group (boolean_algebra (has_neg_part (has_neg_part Type)))) : is_add_cyclic (boolean_algebra (has_neg_part (has_neg_part Type))) := sorry --non-trivial
lemma new_lemma_129466 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @t0_space.{0} (ordered_comm_ring.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (ordered_comm_ring.{0} name))  := sorry --non-trivial
lemma new_lemma_129467 (h0 : group (topological_space (random_gen (random_gen linarith.ineq)))) : is_cyclic (topological_space (random_gen (random_gen linarith.ineq))) := sorry --non-trivial
lemma new_lemma_129468 (h0 : functor.add_const (uniform_space (add_left_cancel_semigroup empty)) empty) : @complete_space.{0} (add_left_cancel_semigroup.{0} empty) (@functor.add_const.run.{0 0} (uniform_space.{0} (add_left_cancel_semigroup.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_129469 (h0 : ring (has_neg (finset (finset (has_add pos))))) : is_domain (has_neg (finset (finset (has_add pos)))) := sorry --non-trivial
lemma new_lemma_129470 (h0 : function.extfun Type cancel_comm_monoid_with_zero) : @unique_factorization_monoid.{0} (has_add.{0} real) (@function.extfun_app.{2 1} Type cancel_comm_monoid_with_zero.{0} h0 (has_add.{0} real))  := sorry --non-trivial
lemma new_lemma_129471 (h0 : functor.add_const (ordered_add_comm_monoid nnreal) (option (option empty))) : archimedean nnreal := sorry --non-trivial
lemma new_lemma_129472 (h0 : topological_space (dlist (random_gen linarith.ineq))) : irreducible_space (dlist (random_gen linarith.ineq)) := sorry --non-trivial
lemma new_lemma_129473 (h0 : functor.add_const (topological_space (ring Type)) pos) : @t0_space.{1} (ring.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (ring.{1} Type)) pos h0)  := sorry --non-trivial
lemma new_lemma_129474 (h1 : topological_space (distrib reducibility_hints)) : t0_space (distrib reducibility_hints) := sorry --non-trivial
lemma new_lemma_129475 (h0 : functor.add_const (group (cancel_monoid name)) name) : @is_cyclic.{0} (cancel_monoid.{0} name) (@functor.add_const.run.{0 0} (group.{0} (cancel_monoid.{0} name)) name h0)  := sorry --non-trivial
lemma new_lemma_129476 (h0 : functor.add_const (complete_lattice (comm_group pos)) pos) : @is_compactly_generated.{0} (comm_group.{0} pos) (@functor.add_const.run.{0 0} (complete_lattice.{0} (comm_group.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_129477 (h0 : topological_space (add_cancel_monoid (finset environment.implicit_infer_kind))) : irreducible_space (add_cancel_monoid (finset environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_129478 (h0 : group environment.implicit_infer_kind) : normalizer_condition environment.implicit_infer_kind := sorry --non-trivial
lemma new_lemma_129479 (h0 : function.extfun Type topological_space) : @t0_space.{0} (has_nndist.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_nndist.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_129480 (h1 : has_mem.mem (has_norm num) has_emptyc.emptyc) : @strong_rank_condition.{0} (has_norm.{0} num) (@finset.pi.empty.{1 0} Type ring.{0} (has_norm.{0} num) h1)  := sorry --non-trivial
lemma new_lemma_129481 (h0 : functor.add_const (ring (add_cancel_monoid linarith.comp)) Type) : @is_domain.{0} (add_cancel_monoid.{0} linarith.comp) (@functor.add_const.run.{0 1} (ring.{0} (add_cancel_monoid.{0} linarith.comp)) Type h0)  := sorry --non-trivial
lemma new_lemma_129482 (h0 : preorder (add_comm_semigroup enat)) (h2 : Prop) : set.is_pwo (id (fun (h1 : add_comm_semigroup enat), h2)) := sorry --non-trivial
lemma new_lemma_129483 (h0 : not (group (with_bot congr_arg_kind) -> false)) : @group.fg.{0} (with_bot.{0} congr_arg_kind) (@classical.by_contradiction'.{1} (group.{0} (with_bot.{0} congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_129484 (h0 : function.extfun Type (functor.add_const (list (semigroup unsigned)))) : list.nodup (functor.add_const.run (function.extfun_app h0 unsigned)) := sorry --non-trivial
lemma new_lemma_129485 (h0 : ring (mul_zero_class (semiring (semiring (semiring num))))) : is_domain (mul_zero_class (semiring (semiring (semiring num)))) := sorry --non-trivial
lemma new_lemma_129486 (h0 : topological_space (has_add (has_neg name))) : totally_disconnected_space (has_add (has_neg name)) := sorry --non-trivial
lemma new_lemma_129487 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_noetherian_ring.{0} (has_inter.{0} unsigned) (@function.extfun_app.{2 1} Type semiring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 semiring.{0}) (has_inter.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_129488 (h0 : functor.add_const (group (normed_comm_ring name)) name) : @group.fg.{0} (normed_comm_ring.{0} name) (@functor.add_const.run.{0 0} (group.{0} (normed_comm_ring.{0} name)) name h0)  := sorry --non-trivial
lemma new_lemma_129489 (h0 : functor.add_const (ring (add_comm_monoid Type)) linarith.comp) : @rank_condition.{1} (add_comm_monoid.{1} Type) (@functor.add_const.run.{1 0} (ring.{1} (add_comm_monoid.{1} Type)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_129490 (h0 : ring (add_group (linear_ordered_semiring unsigned))) : rank_condition (add_group (linear_ordered_semiring unsigned)) := sorry --non-trivial
lemma new_lemma_129491 (h0 : not (ring (has_lt fun_info) -> false)) : @rank_condition.{0} (has_lt.{0} fun_info) (@classical.by_contradiction'.{1} (ring.{0} (has_lt.{0} fun_info)) h0)  := sorry --non-trivial
lemma new_lemma_129492 (h0 : not (function.extfun (Type -> Type) (function.extfun Type) -> false)) : @path_connected_space.{0} (complete_semilattice_Sup.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) (@classical.by_contradiction'.{2} (function.extfun.{2 2} (Type → Type) (function.extfun.{2 1} Type)) h0) topological_space.{0}) (complete_semilattice_Sup.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_129493 (h0 : group (has_Inf (add_cancel_monoid Type))) : normalizer_condition (has_Inf (add_cancel_monoid Type)) := sorry --non-trivial
lemma new_lemma_129494 (h0 : topological_space (linear_ordered_add_comm_group linarith.comp_source)) : path_connected_space (linear_ordered_add_comm_group linarith.comp_source) := sorry --non-trivial
lemma new_lemma_129495 (h0 : functor.add_const (group (boolean_algebra Type)) environment.implicit_infer_kind) : @normalizer_condition.{1} (boolean_algebra.{1} Type) (@functor.add_const.run.{1 0} (group.{1} (boolean_algebra.{1} Type)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_129496 (h0 h1 h2 : Prop) (h3 : decidable h2) : ite h2 h0 h1 := sorry --non-trivial
lemma new_lemma_129497 (h1 : topological_space (has_ssubset linarith.comp_source)) : locally_compact_space (has_ssubset linarith.comp_source) := sorry --non-trivial
lemma new_lemma_129498 (h0 : topological_space (option (option num))) : irreducible_space (option (option num)) := sorry --non-trivial
lemma new_lemma_129499 (h0 : ring (ring Type)) : is_domain (ring Type) := sorry --non-trivial
lemma new_lemma_129500 (h0 : functor.add_const (group (generalized_boolean_algebra linarith.comp)) linarith.comp) : @normalizer_condition.{0} (generalized_boolean_algebra.{0} linarith.comp) (@functor.add_const.run.{0 0} (group.{0} (generalized_boolean_algebra.{0} linarith.comp)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_129501 (h0 : filter (semigroup (finset name))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_129502 (h0 : function.extfun (topological_space (semiring fun_info)) (fun (x : topological_space (semiring fun_info)), Prop)) : @totally_disconnected_space.{0} (semiring.{0} fun_info) (@classical.epsilon.{1} (topological_space.{0} (semiring.{0} fun_info)) (@nonempty_of_inhabited.{1} (topological_space.{0} (semiring.{0} fun_info)) (@inhabited_topological_space.{0} (semiring.{0} fun_info))) (@function.extfun_app.{1 1} (topological_space.{0} (semiring.{0} fun_info)) (λ (x : topological_space.{0} (semiring.{0} fun_info)), Prop) h0))  := sorry --non-trivial
lemma new_lemma_129503 (h0 : fin has_zero.zero) : @normal_space.{0} (boolean_algebra.{0} pos) (@matrix.vec_empty.{0} (topological_space.{0} (boolean_algebra.{0} pos)) h0)  := sorry --non-trivial
lemma new_lemma_129504 (h0 : functor.add_const (topological_space (has_Sup empty)) empty) : @t0_space.{0} (has_Sup.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (has_Sup.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_129505 (h0 : topological_space (metric_space (semiring num))) : t0_space (metric_space (semiring num)) := sorry --non-trivial
lemma new_lemma_129506 (h0 : topological_space (comm_group (has_nndist Type))) : loc_path_connected_space (comm_group (has_nndist Type)) := sorry --non-trivial
lemma new_lemma_129507 (h0 : monoid (complete_semilattice_Sup unsigned)) : monoid.fg (complete_semilattice_Sup unsigned) := sorry --non-trivial
lemma new_lemma_129508 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @regular_space.{0} (has_add.{0} real) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_add.{0} real))  := sorry --non-trivial
lemma new_lemma_129509 (h0 : functor.add_const (ring (free_add_monoid unsigned)) (semiring (semiring (semiring (semiring unsigned))))) : @is_domain.{0} (free_add_monoid.{0} unsigned) (@functor.add_const.run.{0 0} (ring.{0} (free_add_monoid.{0} unsigned)) (semiring.{0} (semiring.{0} (semiring.{0} (semiring.{0} unsigned)))) h0)  := sorry --non-trivial
lemma new_lemma_129510 (h1 : set (mul_one_class linarith.comp_source)) : set.finite h1 := sorry --non-trivial
lemma new_lemma_129511 (h0 : filter (simple_graph congr_arg_kind)) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_129512 (h0 : function.extfun Type topological_space) : @t0_space.{0} (has_add.{0} ennreal) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_add.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_129513 (h0 : topological_space (add_monoid linarith.ineq)) : t0_space (add_monoid linarith.ineq) := sorry --non-trivial
lemma new_lemma_129514 (h0 : functor.add_const (complete_lattice (boolean_algebra unsigned)) Type) : @complete_lattice.is_Sup_finite_compact.{0} (boolean_algebra.{0} unsigned) (@functor.add_const.run.{0 1} (complete_lattice.{0} (boolean_algebra.{0} unsigned)) Type h0)  := sorry --non-trivial
lemma new_lemma_129515 (h0 : not (ring (semi_normed_ring (mul_one_class to_additive.value_type)) -> false)) : @is_domain.{0} (semi_normed_ring.{0} (mul_one_class.{0} to_additive.value_type)) (@classical.by_contradiction'.{1} (ring.{0} (semi_normed_ring.{0} (mul_one_class.{0} to_additive.value_type))) h0)  := sorry --non-trivial
lemma new_lemma_129516 (h0 : functor.add_const (monoid (has_zero Type)) Type) : @monoid.fg.{1} (has_zero.{1} Type) (@functor.add_const.run.{1 1} (monoid.{1} (has_zero.{1} Type)) Type h0)  := sorry --non-trivial
lemma new_lemma_129517 (h0 : add_group (uniform_space fun_info)) : is_add_cyclic (uniform_space fun_info) := sorry --non-trivial
lemma new_lemma_129518 (h0 : functor.add_const (ring (has_to_string linarith.comp)) linarith.comp) : @is_domain.{0} (has_to_string.{0} linarith.comp) (@functor.add_const.run.{0 0} (ring.{0} (has_to_string.{0} linarith.comp)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_129519 (h0 : fin has_zero.zero) : @complete_space.{1} (ordered_comm_monoid.{1} Type) (@matrix.vec_empty.{1} (uniform_space.{1} (ordered_comm_monoid.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_129520 (h0 : uniform_space (pseudo_metric_space (option (option (option (option pos)))))) : separated_space (pseudo_metric_space (option (option (option (option pos))))) := sorry --non-trivial
lemma new_lemma_129521 (h0 : function.extfun Type (functor.comp filter ring)) : countable_Inter_filter (functor.comp.run (function.extfun_app h0 name)) := sorry --non-trivial
lemma new_lemma_129522 (h2 : complete_lattice (denumerable char)) : complete_lattice.is_Sup_finite_compact (denumerable char) := sorry --non-trivial
lemma new_lemma_129523 (h0 : complete_lattice (add_semigroup unsigned)) : is_compactly_generated (add_semigroup unsigned) := sorry --non-trivial
lemma new_lemma_129524 (h0 : list (has_zero unsigned)) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_129525 (h0 : topological_space (simple_graph (boolean_algebra.core linarith.comp))) : discrete_topology (simple_graph (boolean_algebra.core linarith.comp)) := sorry --non-trivial
lemma new_lemma_129526 (h0 : ring (has_inter (option (option (option ennreal))))) : strong_rank_condition (has_inter (option (option (option ennreal)))) := sorry --non-trivial
lemma new_lemma_129527 (h0 : functor.add_const (function.extfun Type uniform_space) Type) : @separated_space.{0} (ring.{0} unsigned) (@function.extfun_app.{2 1} Type uniform_space.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type uniform_space.{0}) Type h0) (ring.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_129528 (h0 : function.extfun Type cancel_comm_monoid_with_zero) : @unique_factorization_monoid.{0} (finset.{0} unsigned) (@function.extfun_app.{2 1} Type cancel_comm_monoid_with_zero.{0} h0 (finset.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_129529 (h0 : uniform_space (has_neg (comm_group (has_to_string (boolean_algebra Type))))) : complete_space (has_neg (comm_group (has_to_string (boolean_algebra Type)))) := sorry --non-trivial
lemma new_lemma_129530 (h1 : complete_lattice (simple_graph std_gen)) : complete_lattice.is_Sup_finite_compact (simple_graph std_gen) := sorry --non-trivial
lemma new_lemma_129531 (h0 : topological_space (simple_graph Type)) : t1_space (simple_graph Type) := sorry --non-trivial
lemma new_lemma_129532 (h0 : complete_lattice (encodable (has_norm (comm_ring (has_ssubset linarith.ineq))))) : is_compactly_generated (encodable (has_norm (comm_ring (has_ssubset linarith.ineq)))) := sorry --non-trivial
lemma new_lemma_129533 (h0 : complete_lattice (has_top (semiring (semiring (semiring linarith.comp))))) : is_atomistic (has_top (semiring (semiring (semiring linarith.comp)))) := sorry --non-trivial
lemma new_lemma_129534 (h0 : fin has_zero.zero) : @irreducible_space.{0} (canonically_ordered_monoid.{0} real) (@function.extfun_app.{2 1} Type topological_space.{0} (@matrix.vec_empty.{1} (function.extfun.{2 1} Type topological_space.{0}) h0) (canonically_ordered_monoid.{0} real))  := sorry --non-trivial
lemma new_lemma_129535 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_noetherian_ring.{0} (canonically_ordered_comm_semiring.{0} linarith.comp) (@function.extfun_app.{2 1} Type semiring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 semiring.{0}) (canonically_ordered_comm_semiring.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_129536 (h0 : not (ring (linear_ordered_comm_group_with_zero char) -> false)) : @rank_condition.{0} (linear_ordered_comm_group_with_zero.{0} char) (@classical.by_contradiction'.{1} (ring.{0} (linear_ordered_comm_group_with_zero.{0} char)) h0)  := sorry --non-trivial
lemma new_lemma_129537 (h2 : ring (dlist fun_info)) : strong_rank_condition (dlist fun_info) := sorry --non-trivial
lemma new_lemma_129538 (h0 : uniform_space (has_top (semiring (semiring ennreal)))) : separated_space (has_top (semiring (semiring ennreal))) := sorry --non-trivial
lemma new_lemma_129539 (h0 : topological_space (option num)) : path_connected_space (option num) := sorry --non-trivial
lemma new_lemma_129540 (h0 : ring (complete_distrib_lattice ennreal)) : rank_condition (complete_distrib_lattice ennreal) := sorry --non-trivial
lemma new_lemma_129541 (h0 : filter (is_R_or_C congr_arg_kind)) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_129542 (h0 : topological_space (canonically_ordered_monoid (has_Inf (has_Inf (has_Inf Type))))) : t1_space (canonically_ordered_monoid (has_Inf (has_Inf (has_Inf Type)))) := sorry --non-trivial
lemma new_lemma_129543 (h0 : function.extfun Type uniform_space) : @separated_space.{0} (add_left_cancel_semigroup.{0} empty) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (add_left_cancel_semigroup.{0} empty))  := sorry --non-trivial
lemma new_lemma_129544 (h0 : ring (has_neg_part (has_neg_part Type))) : rank_condition (has_neg_part (has_neg_part Type)) := sorry --non-trivial
lemma new_lemma_129545 (h0 : functor.add_const (topological_space (comm_semigroup pos)) real) : @regular_space.{0} (comm_semigroup.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (comm_semigroup.{0} pos)) real h0)  := sorry --non-trivial
lemma new_lemma_129546 (h0 : topological_space (option ennreal)) : t0_space (option ennreal) := sorry --non-trivial
lemma new_lemma_129547 (h0 : functor.add_const (topological_space (semigroup Type)) name) : @topological_space.separable_space.{1} (semigroup.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (semigroup.{1} Type)) name h0)  := sorry --non-trivial
lemma new_lemma_129548 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @totally_separated_space.{0} (sub_neg_monoid.{0} real) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (sub_neg_monoid.{0} real))  := sorry --non-trivial
lemma new_lemma_129549 (h0 : group (ring (finset environment.implicit_infer_kind))) : group.fg (ring (finset environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_129550 (h0 : topological_space (has_to_string congr_arg_kind)) : loc_path_connected_space (has_to_string congr_arg_kind) := sorry --non-trivial
lemma new_lemma_129551 (h0 : ordered_add_comm_monoid (normed_comm_ring (option empty))) : archimedean (normed_comm_ring (option empty)) := sorry --non-trivial
lemma new_lemma_129552 (h1 : not (uniform_space num -> false)) : @complete_space.{0} num (@classical.by_contradiction'.{1} (uniform_space.{0} num) h1)  := sorry --non-trivial
lemma new_lemma_129553 (h0 : complete_lattice (measurable_space (random_gen fun_info))) : complete_lattice.is_Sup_finite_compact (measurable_space (random_gen fun_info)) := sorry --non-trivial
lemma new_lemma_129554 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @t0_space.{0} (ring.{0} ennreal) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (ring.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_129555 (h0 : function.extfun Type ring) : @rank_condition.{0} (has_nndist.{0} pos) (@function.extfun_app.{2 1} Type ring.{0} h0 (has_nndist.{0} pos))  := sorry --non-trivial
lemma new_lemma_129556 (h0 : topological_space (has_add Type)) : t0_space (has_add Type) := sorry --non-trivial
lemma new_lemma_129557 (h0 : semiring (with_bot (semiring empty))) : is_noetherian_ring (with_bot (semiring empty)) := sorry --non-trivial
lemma new_lemma_129558 (h0 : functor.add_const (function.extfun Type topological_space) pos) : @preconnected_space.{0} (comm_group.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) pos h0) (comm_group.{0} pos))  := sorry --non-trivial
lemma new_lemma_129559 (h0 : functor.add_const (topological_space (finset name)) pos) : @sequential_space.{0} (finset.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (finset.{0} name)) pos h0)  := sorry --non-trivial
lemma new_lemma_129560 (h0 : has_mem.mem (semiring (has_norm (semiring num))) has_emptyc.emptyc) : @is_compactly_generated.{0} (semiring.{0} (has_norm.{0} (semiring.{0} num))) (@finset.pi.empty.{1 0} Type complete_lattice.{0} (semiring.{0} (has_norm.{0} (semiring.{0} num))) h0)  := sorry --non-trivial
lemma new_lemma_129561 (h1 : measurable_space (normed_field char)) (h2 : filter (normed_field char)) : filter.is_measurably_generated h2 := sorry --non-trivial
lemma new_lemma_129562 (h0 : add_monoid (has_add (normed_linear_ordered_group Type))) : add_monoid.fg (has_add (normed_linear_ordered_group Type)) := sorry --non-trivial
lemma new_lemma_129563 (h0 : function.extfun Type cancel_comm_monoid_with_zero) : @unique_factorization_monoid.{0} (normed_lattice_add_comm_group.{0} real) (@function.extfun_app.{2 1} Type cancel_comm_monoid_with_zero.{0} h0 (normed_lattice_add_comm_group.{0} real))  := sorry --non-trivial
lemma new_lemma_129564 (h0 : function.extfun Type add_group) : @is_add_cyclic.{0} (has_norm.{0} linarith.comp) (@function.extfun_app.{2 1} Type add_group.{0} h0 (has_norm.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_129565 (h0 : add_monoid (add_cancel_monoid (has_add (has_add linarith.comp)))) : add_monoid.fg (add_cancel_monoid (has_add (has_add linarith.comp))) := sorry --non-trivial
lemma new_lemma_129566 (h0 : topological_space (semigroup congr_arg_kind)) : totally_separated_space (semigroup congr_arg_kind) := sorry --non-trivial
lemma new_lemma_129567 (h0 : has_mem.mem real.angle has_emptyc.emptyc) : @locally_compact_space.{0} real.angle (@finset.pi.empty.{1 0} Type topological_space.{0} real.angle h0)  := sorry --non-trivial
lemma new_lemma_129568 (h0 : topological_space (finset (has_to_string (has_to_string name)))) : totally_disconnected_space (finset (has_to_string (has_to_string name))) := sorry --non-trivial
lemma new_lemma_129569 (h1 : group (topological_space char)) : is_cyclic (topological_space char) := sorry --non-trivial
lemma new_lemma_129570 (h0 : topological_space (boolean_algebra (semigroup name))) : normal_space (boolean_algebra (semigroup name)) := sorry --non-trivial
lemma new_lemma_129571 (h0 : uniform_space (with_one linarith.comp)) : complete_space (with_one linarith.comp) := sorry --non-trivial
lemma new_lemma_129572 (h0 : monoid (with_one (random_gen linarith.ineq))) : monoid.fg (with_one (random_gen linarith.ineq)) := sorry --non-trivial
lemma new_lemma_129573 (h0 : list (cancel_monoid (has_add Type))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_129574 (h0 : topological_space (has_norm (semiring (semiring linarith.comp)))) : irreducible_space (has_norm (semiring (semiring linarith.comp))) := sorry --non-trivial
lemma new_lemma_129575 (h0 : group (with_one (random_gen (has_inv linarith.comp_source)))) : normalizer_condition (with_one (random_gen (has_inv linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_129576 (h0 : ring (left_cancel_semigroup (semiring empty))) : is_principal_ideal_ring (left_cancel_semigroup (semiring empty)) := sorry --non-trivial
lemma new_lemma_129577 (h0 : functor.add_const (function.extfun Type finset) Type) : finset.nonempty (function.extfun_app (functor.add_const.run h0) (has_to_string linarith.comp)) := sorry --non-trivial
lemma new_lemma_129578 (h0 : complete_lattice (semigroup (option (option (option name))))) : is_compactly_generated (semigroup (option (option (option name)))) := sorry --non-trivial
lemma new_lemma_129579 (h0 : functor.add_const (topological_space (ordered_ring num)) num) : @preirreducible_space.{0} (ordered_ring.{0} num) (@functor.add_const.run.{0 0} (topological_space.{0} (ordered_ring.{0} num)) num h0)  := sorry --non-trivial
lemma new_lemma_129580 (h0 : functor.add_const (group (finset pos)) linarith.comp) : @is_cyclic.{0} (finset.{0} pos) (@functor.add_const.run.{0 0} (group.{0} (finset.{0} pos)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_129581 (h0 : ring (random_gen (with_one to_additive.value_type))) : is_domain (random_gen (with_one to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_129582 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @monoid.fg.{0} (has_union.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 monoid.{0}) (has_union.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_129583 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @t0_space.{0} (group_with_zero.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (group_with_zero.{0} empty))  := sorry --non-trivial
lemma new_lemma_129584 (h0 : topological_space (has_top (has_nnnorm to_additive.value_type))) : t0_space (has_top (has_nnnorm to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_129585 (h0 : functor.add_const (ring (comm_monoid empty)) (option empty)) : @is_principal_ideal_ring.{0} (comm_monoid.{0} empty) (@functor.add_const.run.{0 0} (ring.{0} (comm_monoid.{0} empty)) (option.{0} empty) h0)  := sorry --non-trivial
lemma new_lemma_129586 (h0 : function.extfun (finset Type) (has_mem.mem (with_bot congr_arg_kind))) : @locally_compact_space.{0} (with_bot.{0} congr_arg_kind) (@finset.pi.empty.{1 0} Type topological_space.{0} (with_bot.{0} congr_arg_kind) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (with_bot.{0} congr_arg_kind)) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_129587 (h0 : functor.add_const (complete_lattice (has_neg_part unsigned)) (option (option (option unsigned)))) : @complete_lattice.is_Sup_finite_compact.{0} (has_neg_part.{0} unsigned) (@functor.add_const.run.{0 0} (complete_lattice.{0} (has_neg_part.{0} unsigned)) (option.{0} (option.{0} (option.{0} unsigned))) h0)  := sorry --non-trivial
lemma new_lemma_129588 (h0 : topological_space (canonically_linear_ordered_monoid (finset (has_add linarith.comp)))) : locally_compact_space (canonically_linear_ordered_monoid (finset (has_add linarith.comp))) := sorry --non-trivial
lemma new_lemma_129589 (h0 : uniform_space (has_union (semiring (semiring (semiring unsigned))))) : complete_space (has_union (semiring (semiring (semiring unsigned)))) := sorry --non-trivial
lemma new_lemma_129590 (h0 : functor.add_const (ring (normed_comm_ring name)) name) : @is_principal_ideal_ring.{0} (normed_comm_ring.{0} name) (@functor.add_const.run.{0 0} (ring.{0} (normed_comm_ring.{0} name)) name h0)  := sorry --non-trivial
lemma new_lemma_129591 (h0 : has_mem.mem complete_lattice has_emptyc.emptyc) : @complete_lattice.is_Sup_finite_compact.{0} (has_emptyc.{0} num) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) complete_lattice.{0} h0) (has_emptyc.{0} num))  := sorry --non-trivial
lemma new_lemma_129592 (h0 : function.extfun nat fin) : @discrete_topology.{0} (canonically_linear_ordered_monoid.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@matrix.vec_empty.{1} (function.extfun.{2 1} Type topological_space.{0}) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero))) (canonically_linear_ordered_monoid.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_129593 (h0 : group (has_nnnorm (normed_field (comm_ring linarith.comp_source)))) : is_cyclic (has_nnnorm (normed_field (comm_ring linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_129594 (h0 : topological_space (generalized_boolean_algebra (has_add (ring name)))) : locally_compact_space (generalized_boolean_algebra (has_add (ring name))) := sorry --non-trivial
lemma new_lemma_129595 (h0 : functor.add_const (topological_space (ring pos)) pos) : @regular_space.{0} (ring.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (ring.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_129596 (h0 : semiring (has_to_string (has_pos_part pos))) : is_noetherian_ring (has_to_string (has_pos_part pos)) := sorry --non-trivial
lemma new_lemma_129597 (h0 : functor.add_const Prop (has_to_string (option ennreal))) : functor.add_const.run h0 := sorry --non-trivial
lemma new_lemma_129598 (h0 : functor.comp filter add_cancel_monoid (option ennreal)) : countable_Inter_filter (functor.comp.run h0) := sorry --non-trivial
lemma new_lemma_129599 (h0 : ordered_add_comm_monoid (has_neg_part (option name))) : archimedean (has_neg_part (option name)) := sorry --non-trivial
lemma new_lemma_129600 (h0 : functor.add_const (functor.add_const (ring (comm_group pos)) name) environment.implicit_infer_kind) : @rank_condition.{0} (comm_group.{0} pos) (@functor.add_const.run.{0 0} (ring.{0} (comm_group.{0} pos)) name (@functor.add_const.run.{0 0} (functor.add_const.{0 0} (ring.{0} (comm_group.{0} pos)) name) environment.implicit_infer_kind h0))  := sorry --non-trivial
lemma new_lemma_129601 (h0 : functor.add_const (add_monoid (has_zero Type)) (ring linarith.comp)) : @add_monoid.fg.{1} (has_zero.{1} Type) (@functor.add_const.run.{1 0} (add_monoid.{1} (has_zero.{1} Type)) (ring.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_129602 (h0 : ordered_add_comm_monoid (finset (option empty))) : archimedean (finset (option empty)) := sorry --non-trivial
lemma new_lemma_129603 (h0 : function.extfun Type finset) : finset.nonempty (function.extfun_app h0 (preorder unsigned)) := sorry --non-trivial
lemma new_lemma_129604 (h0 : semiring (has_bot (has_add linarith.comp))) : is_noetherian_ring (has_bot (has_add linarith.comp)) := sorry --non-trivial
lemma new_lemma_129605 (h0 : function.extfun nat fin) : @irreducible_space.{1} (has_add.{1} Type) (@matrix.vec_empty.{1} (topological_space.{1} (has_add.{1} Type)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_129606 (h0 : functor.add_const (function.extfun Type topological_space) name) : @locally_compact_space.{0} (canonically_ordered_comm_semiring.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) name h0) (canonically_ordered_comm_semiring.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_129607 (h0 : topological_space (measurable_space (has_top (has_top to_additive.value_type)))) : totally_separated_space (measurable_space (has_top (has_top to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_129608 (h0 : functor.add_const (topological_space (option empty)) (semiring empty)) : @normal_space.{0} (option.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (option.{0} empty)) (semiring.{0} empty) h0)  := sorry --non-trivial
lemma new_lemma_129609 (h0 : cancel_comm_monoid_with_zero (has_add (has_add (sub_neg_monoid real)))) : unique_factorization_monoid (has_add (has_add (sub_neg_monoid real))) := sorry --non-trivial
lemma new_lemma_129610 (h0 : complete_lattice (plift num)) : is_atomistic (plift num) := sorry --non-trivial
lemma new_lemma_129611 (h0 : num -> Prop) (h1 : not (filter num -> false)) : filter.eventually h0 (classical.by_contradiction' h1) := sorry --non-trivial
lemma new_lemma_129612 (h0 : function.extfun Type ordered_add_comm_monoid) : @archimedean.{0} (has_neg_part.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type ordered_add_comm_monoid.{0} h0 (has_neg_part.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_129613 (h0 : fin has_zero.zero) : @is_cyclic.{0} (normed_lattice_add_comm_group.{0} pos) (@matrix.vec_empty.{0} (group.{0} (normed_lattice_add_comm_group.{0} pos)) h0)  := sorry --non-trivial
lemma new_lemma_129614 (h0 : functor.add_const (topological_space pos) Type) : @totally_separated_space.{0} pos (@functor.add_const.run.{0 1} (topological_space.{0} pos) Type h0)  := sorry --non-trivial
lemma new_lemma_129615 (h0 : add_monoid (ordered_comm_ring (has_add linarith.comp))) : add_monoid.fg (ordered_comm_ring (has_add linarith.comp)) := sorry --non-trivial
lemma new_lemma_129616 (h0 : group (normed_comm_ring (has_add name))) : group.fg (normed_comm_ring (has_add name)) := sorry --non-trivial
lemma new_lemma_129617 (h0 : functor.add_const (functor.add_const (topological_space pos) linarith.comp) linarith.comp) : @t0_space.{0} pos (@functor.add_const.run.{0 0} (topological_space.{0} pos) linarith.comp (@functor.add_const.run.{0 0} (functor.add_const.{0 0} (topological_space.{0} pos) linarith.comp) linarith.comp h0))  := sorry --non-trivial
lemma new_lemma_129618 (h0 : not (topological_space (topological_space reducibility_hints) -> false)) : @t0_space.{0} (topological_space.{0} reducibility_hints) (@classical.by_contradiction'.{1} (topological_space.{0} (topological_space.{0} reducibility_hints)) h0)  := sorry --non-trivial
lemma new_lemma_129619 (h3 : topological_space (semi_normed_comm_ring (has_nnnorm (has_nnnorm (has_nnnorm char))))) : path_connected_space (semi_normed_comm_ring (has_nnnorm (has_nnnorm (has_nnnorm char)))) := sorry --non-trivial
lemma new_lemma_129620 (h0 : list (ordered_comm_ring (finset (finset Type)))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_129621 (h0 : functor.add_const (function.extfun Type ring) pos) : @rank_condition.{0} (has_to_string.{0} pos) (@function.extfun_app.{2 1} Type ring.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type ring.{0}) pos h0) (has_to_string.{0} pos))  := sorry --non-trivial
lemma new_lemma_129622 (h0 : group (has_nndist (finset pos))) : is_simple_group (has_nndist (finset pos)) := sorry --non-trivial
lemma new_lemma_129623 (h0 : has_mem.mem string_imp has_emptyc.emptyc) : @locally_compact_space.{0} string_imp (@finset.pi.empty.{1 0} Type topological_space.{0} string_imp h0)  := sorry --non-trivial
lemma new_lemma_129624 (h0 : function.extfun Type complete_lattice) : @complete_lattice.is_Sup_finite_compact.{0} (has_norm.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (has_norm.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_129625 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_noetherian_ring.{0} unsigned (@function.extfun_app.{2 1} Type semiring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 semiring.{0}) unsigned)  := sorry --non-trivial
lemma new_lemma_129626 (h0 : complete_lattice (free_add_monoid num)) : is_atomistic (free_add_monoid num) := sorry --non-trivial
lemma new_lemma_129627 (h0 : complete_lattice (has_norm (has_norm (has_norm (has_norm linarith.comp))))) : is_atomistic (has_norm (has_norm (has_norm (has_norm linarith.comp)))) := sorry --non-trivial
lemma new_lemma_129628 (h0 : ring (measurable_space congr_arg_kind)) : rank_condition (measurable_space congr_arg_kind) := sorry --non-trivial
lemma new_lemma_129629 (h0 : functor.add_const (function.extfun Type complete_lattice) (mul_zero_class (has_add pos))) : @complete_lattice.is_Sup_finite_compact.{0} (canonically_ordered_comm_semiring.{0} ennreal) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type complete_lattice.{0}) (mul_zero_class.{0} (has_add.{0} pos)) h0) (canonically_ordered_comm_semiring.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_129630 (h0 : functor.add_const (ring (has_to_string linarith.comp)) Type) : @is_domain.{0} (has_to_string.{0} linarith.comp) (@functor.add_const.run.{0 1} (ring.{0} (has_to_string.{0} linarith.comp)) Type h0)  := sorry --non-trivial
lemma new_lemma_129631 (h0 : complete_lattice (canonically_ordered_comm_semiring (option unsigned))) : is_compactly_generated (canonically_ordered_comm_semiring (option unsigned)) := sorry --non-trivial
lemma new_lemma_129632 (h0 : function.extfun Type complete_lattice) : @complete_lattice.is_Sup_finite_compact.{0} (add_left_cancel_semigroup.{0} empty) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (add_left_cancel_semigroup.{0} empty))  := sorry --non-trivial
lemma new_lemma_129633 (h0 : group (canonically_linear_ordered_monoid (has_add (has_Inf (has_add linarith.comp))))) : is_simple_group (canonically_linear_ordered_monoid (has_add (has_Inf (has_add linarith.comp)))) := sorry --non-trivial
lemma new_lemma_129634 (h0 : uniform_space (non_unital_non_assoc_semiring (mul_one_class reducibility_hints))) : complete_space (non_unital_non_assoc_semiring (mul_one_class reducibility_hints)) := sorry --non-trivial
lemma new_lemma_129635 (h0 : group (add_cancel_monoid (add_comm_monoid name))) : group.fg (add_cancel_monoid (add_comm_monoid name)) := sorry --non-trivial
lemma new_lemma_129636 (h0 : topological_space (topological_space (random_gen char))) : t0_space (topological_space (random_gen char)) := sorry --non-trivial
lemma new_lemma_129637 (h0 : topological_space (finset num)) : normal_space (finset num) := sorry --non-trivial
lemma new_lemma_129638 (h0 : function.extfun Type topological_space) : @preirreducible_space.{0} (finset.{0} ennreal) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (finset.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_129639 (h0 : fin has_zero.zero) : @is_simple_group.{1} (boolean_algebra.core.{1} Type) (@matrix.vec_empty.{1} (group.{1} (boolean_algebra.core.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_129640 (h0 : topological_space (comm_semigroup (sub_neg_monoid (sub_neg_monoid Type)))) : normal_space (comm_semigroup (sub_neg_monoid (sub_neg_monoid Type))) := sorry --non-trivial
lemma new_lemma_129641 (h0 : functor.add_const (topological_space (boolean_algebra (has_pos_part pos))) Type) : @discrete_topology.{0} (boolean_algebra.{0} (has_pos_part.{0} pos)) (@functor.add_const.run.{0 1} (topological_space.{0} (boolean_algebra.{0} (has_pos_part.{0} pos))) Type h0)  := sorry --non-trivial
lemma new_lemma_129642 (h0 : topological_space (finset (ring (ring (has_Inf Type))))) : sequential_space (finset (ring (ring (has_Inf Type)))) := sorry --non-trivial
lemma new_lemma_129643 (h0 : function.extfun Type topological_space) : @locally_compact_space.{0} (filter.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (filter.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_129644 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_domain.{0} (metric_space.{0} linarith.comp) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (metric_space.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_129645 (h1 : function.extfun Type complete_lattice) : @is_atomistic.{0} (semiring.{0} fun_info) (@function.extfun_app.{2 1} Type complete_lattice.{0} h1 (semiring.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_129646 (h0 : ring (semigroup environment.implicit_infer_kind)) : is_principal_ideal_ring (semigroup environment.implicit_infer_kind) := sorry --non-trivial
lemma new_lemma_129647 (h0 : group (has_ssubset (random_gen (random_gen (random_gen linarith.ineq))))) : group.fg (has_ssubset (random_gen (random_gen (random_gen linarith.ineq)))) := sorry --non-trivial
lemma new_lemma_129648 (h0 : complete_lattice (random_gen (random_gen (comm_ring string.iterator_imp)))) : is_compactly_generated (random_gen (random_gen (comm_ring string.iterator_imp))) := sorry --non-trivial
lemma new_lemma_129649 (h0 : group (topological_space (has_nnnorm char))) : is_cyclic (topological_space (has_nnnorm char)) := sorry --non-trivial
lemma new_lemma_129650 (h0 : add_group (with_bot (random_gen (random_gen to_additive.value_type)))) : is_add_cyclic (with_bot (random_gen (random_gen to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_129651 (h0 : topological_space (has_pos_part empty)) : t0_space (has_pos_part empty) := sorry --non-trivial
lemma new_lemma_129652 (h0 : function.extfun Type (functor.comp list has_add)) : @list.nodup.{0} (has_add.{0} pos) (@functor.add_const.run.{0 0} (list.{0} (has_add.{0} pos)) pos (@functor.comp.run.{0 0 0} list.{0} has_add.{0} pos (@function.extfun_app.{2 1} Type (functor.comp.{0 0 0} list.{0} has_add.{0}) h0 pos)))  := sorry --non-trivial
lemma new_lemma_129653 (h0 : functor.add_const (function.extfun Type ring) name) : @strong_rank_condition.{0} (complete_distrib_lattice.{0} pos) (@function.extfun_app.{2 1} Type ring.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type ring.{0}) name h0) (complete_distrib_lattice.{0} pos))  := sorry --non-trivial
lemma new_lemma_129654 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @add_monoid.fg.{0} (as_linear_order.{0} empty) (@function.extfun_app.{2 1} Type add_monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 add_monoid.{0}) (as_linear_order.{0} empty))  := sorry --non-trivial
lemma new_lemma_129655 (h0 : function.extfun Type ring) : @strong_rank_condition.{0} (monoid_with_zero.{0} ennreal) (@function.extfun_app.{2 1} Type ring.{0} h0 (monoid_with_zero.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_129656 (h0 : functor.add_const (semiring (has_Sup empty)) (semiring (semiring (semiring empty)))) : @is_noetherian_ring.{0} (has_Sup.{0} empty) (@functor.add_const.run.{0 0} (semiring.{0} (has_Sup.{0} empty)) (semiring.{0} (semiring.{0} (semiring.{0} empty))) h0)  := sorry --non-trivial
lemma new_lemma_129657 (h0 : complete_lattice (has_inter (option (option empty)))) : is_compactly_generated (has_inter (option (option empty))) := sorry --non-trivial
lemma new_lemma_129658 (h0 : function.extfun Type topological_space) : @totally_disconnected_space.{0} (group_with_zero.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (group_with_zero.{0} empty))  := sorry --non-trivial
lemma new_lemma_129659 (h0 : uniform_space (has_compl (mul_one_class reducibility_hints))) : complete_space (has_compl (mul_one_class reducibility_hints)) := sorry --non-trivial
lemma new_lemma_129660 (h0 : functor.add_const (topological_space (has_dist unsigned)) empty) : @loc_path_connected_space.{0} (has_dist.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (has_dist.{0} unsigned)) empty h0)  := sorry --non-trivial
lemma new_lemma_129661 (h0 : complete_lattice (pseudo_metric_space (option (option ennreal)))) : is_compactly_generated (pseudo_metric_space (option (option ennreal))) := sorry --non-trivial
lemma new_lemma_129662 (h0 : functor.add_const (topological_space (normed_comm_ring environment.implicit_infer_kind)) Type) : @preconnected_space.{0} (normed_comm_ring.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 1} (topological_space.{0} (normed_comm_ring.{0} environment.implicit_infer_kind)) Type h0)  := sorry --non-trivial
lemma new_lemma_129663 (h0 : has_le (mul_one_class ereal)) (h1 : mul_one_class ereal) : is_max h1 := sorry --non-trivial
lemma new_lemma_129664 (h0 : ring (add_cancel_comm_monoid linarith.ineq)) : strong_rank_condition (add_cancel_comm_monoid linarith.ineq) := sorry --non-trivial
lemma new_lemma_129665 (h0 : uniform_space (ordered_cancel_add_comm_monoid (option pos))) : complete_space (ordered_cancel_add_comm_monoid (option pos)) := sorry --non-trivial
lemma new_lemma_129666 (h0 : functor.add_const (topological_space (add_cancel_monoid Type)) pos) : @loc_path_connected_space.{1} (add_cancel_monoid.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (add_cancel_monoid.{1} Type)) pos h0)  := sorry --non-trivial
lemma new_lemma_129667 (h0 : ring (with_one (has_norm (has_norm linarith.comp_source)))) : is_domain (with_one (has_norm (has_norm linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_129668 (h2 : ring std_gen) : strong_rank_condition std_gen := sorry --non-trivial
lemma new_lemma_129669 (h0 : not (add_group (non_unital_non_assoc_semiring linarith.comp_source) -> false)) : @is_add_cyclic.{0} (non_unital_non_assoc_semiring.{0} linarith.comp_source) (@classical.by_contradiction'.{1} (add_group.{0} (non_unital_non_assoc_semiring.{0} linarith.comp_source)) h0)  := sorry --non-trivial
lemma new_lemma_129670 (h0 : ring (random_gen char)) : strong_rank_condition (random_gen char) := sorry --non-trivial
lemma new_lemma_129671 (h0 : function.extfun Type topological_space) : @preirreducible_space.{0} (semiring.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (semiring.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_129672 (h0 : not (topological_space (has_compl to_additive.value_type) -> false)) : @totally_disconnected_space.{0} (has_compl.{0} to_additive.value_type) (@classical.by_contradiction'.{1} (topological_space.{0} (has_compl.{0} to_additive.value_type)) h0)  := sorry --non-trivial
lemma new_lemma_129673 (h0 : add_monoid (finset (has_add (ring linarith.comp)))) : add_monoid.fg (finset (has_add (ring linarith.comp))) := sorry --non-trivial
lemma new_lemma_129674 (h0 : functor.add_const (cancel_comm_monoid_with_zero (normed_comm_ring name)) name) : @unique_factorization_monoid.{0} (normed_comm_ring.{0} name) (@functor.add_const.run.{0 0} (cancel_comm_monoid_with_zero.{0} (normed_comm_ring.{0} name)) name h0)  := sorry --non-trivial
lemma new_lemma_129675 (h0 : function.extfun Type group) : @normalizer_condition.{0} (add_semigroup.{0} empty) (@function.extfun_app.{2 1} Type group.{0} h0 (add_semigroup.{0} empty))  := sorry --non-trivial
lemma new_lemma_129676 (h0 : topological_space (partial_order (semiring num))) : totally_separated_space (partial_order (semiring num)) := sorry --non-trivial
lemma new_lemma_129677 (h0 : topological_space (has_pos_part (has_add pos))) : normal_space (has_pos_part (has_add pos)) := sorry --non-trivial
lemma new_lemma_129678 (h0 : functor.add_const (function.extfun Type topological_space) pos) : @totally_disconnected_space.{0} (semigroup.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) pos h0) (semigroup.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_129679 (h0 : complete_lattice (ordered_cancel_add_comm_monoid num)) : complete_lattice.is_Sup_finite_compact (ordered_cancel_add_comm_monoid num) := sorry --non-trivial
lemma new_lemma_129680 (h0 : filter (linear_ordered_add_comm_group (has_nnnorm fun_info))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_129681 (h1 : topological_space (has_nnnorm (dlist (has_nnnorm linarith.ineq)))) : locally_compact_space (has_nnnorm (dlist (has_nnnorm linarith.ineq))) := sorry --non-trivial
lemma new_lemma_129682 (h0 : functor.add_const (topological_space (generalized_boolean_algebra Type)) (boolean_algebra linarith.comp)) : @totally_separated_space.{1} (generalized_boolean_algebra.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (generalized_boolean_algebra.{1} Type)) (boolean_algebra.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_129683 (h0 : list (has_neg (has_neg name))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_129684 (h0 : functor.add_const (ring (sub_neg_monoid linarith.comp)) pos) : @is_principal_ideal_ring.{0} (sub_neg_monoid.{0} linarith.comp) (@functor.add_const.run.{0 0} (ring.{0} (sub_neg_monoid.{0} linarith.comp)) pos h0)  := sorry --non-trivial
lemma new_lemma_129685 (h0 : semiring (semigroup (finset (has_neg (has_pos_part (has_pos_part Type)))))) : is_noetherian_ring (semigroup (finset (has_neg (has_pos_part (has_pos_part Type))))) := sorry --non-trivial
lemma new_lemma_129686 (h0 : functor.add_const (function.extfun Type topological_space) Type) : @sequential_space.{0} (semigroup.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type topological_space.{0}) Type h0) (semigroup.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_129687 (h0 : not (function.extfun Type filter -> false)) : filter.ne_bot (function.extfun_app (classical.by_contradiction' h0) to_additive.value_type) := sorry --non-trivial
lemma new_lemma_129688 (h0 : ordered_add_comm_monoid (simple_graph (option (option (option (option (option (option empty)))))))) : archimedean (simple_graph (option (option (option (option (option (option empty))))))) := sorry --non-trivial
lemma new_lemma_129689 (h0 : topological_space (with_zero (random_gen (random_gen (has_ssubset to_additive.value_type))))) : locally_compact_space (with_zero (random_gen (random_gen (has_ssubset to_additive.value_type)))) := sorry --non-trivial
lemma new_lemma_129690 (h0 : topological_space (complete_semilattice_Sup (random_gen num))) : discrete_topology (complete_semilattice_Sup (random_gen num)) := sorry --non-trivial
lemma new_lemma_129691 (h0 : group (has_neg_part (has_nndist pos))) : group.fg (has_neg_part (has_nndist pos)) := sorry --non-trivial
lemma new_lemma_129692 (h0 : set (simple_graph (mul_one_class fun_info))) : set.subsingleton h0 := sorry --non-trivial
lemma new_lemma_129693 (h0 : functor.add_const (topological_space (add_cancel_monoid name)) name) : @discrete_topology.{0} (add_cancel_monoid.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (add_cancel_monoid.{0} name)) name h0)  := sorry --non-trivial
lemma new_lemma_129694 (h0 : prod (comm_ring (random_gen linarith.ineq)) (comm_ring (random_gen linarith.ineq))) : set.diagonal (comm_ring (random_gen linarith.ineq)) h0 := sorry --non-trivial
lemma new_lemma_129695 (h0 : uniform_space (has_lt (mul_one_class enat))) : complete_space (has_lt (mul_one_class enat)) := sorry --non-trivial
lemma new_lemma_129696 (h0 : semiring (left_cancel_monoid (option congr_arg_kind))) : is_noetherian_ring (left_cancel_monoid (option congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_129697 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : filter.ne_bot (function.extfun_app (function.extfun_app h0 filter) (normed_group empty)) := sorry --non-trivial
lemma new_lemma_129698 (h0 : functor.add_const (uniform_space (boolean_algebra.core Type)) Type) : @complete_space.{1} (boolean_algebra.core.{1} Type) (@functor.add_const.run.{1 1} (uniform_space.{1} (boolean_algebra.core.{1} Type)) Type h0)  := sorry --non-trivial
lemma new_lemma_129699 (h0 : group (has_neg_part (has_add pos))) : is_cyclic (has_neg_part (has_add pos)) := sorry --non-trivial
lemma new_lemma_129700 (h0 : topological_space (has_add (finset environment.implicit_infer_kind))) : loc_path_connected_space (has_add (finset environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_129701 (h0 : functor.add_const (function.extfun Type topological_space) real) : @path_connected_space.{0} (add_comm_monoid.{0} real) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) real h0) (add_comm_monoid.{0} real))  := sorry --non-trivial
lemma new_lemma_129702 (h0 : topological_space (has_neg_part (has_add environment.implicit_infer_kind))) : loc_path_connected_space (has_neg_part (has_add environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_129703 (h0 : topological_space (linear_ordered_cancel_comm_monoid (has_bot empty))) : t1_space (linear_ordered_cancel_comm_monoid (has_bot empty)) := sorry --non-trivial
lemma new_lemma_129704 (h0 : functor.add_const (semiring (plift unsigned)) unsigned) : @is_noetherian_ring.{1} (plift.{1} unsigned) (@functor.add_const.run.{1 0} (semiring.{1} (plift.{1} unsigned)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_129705 (h0 : functor.add_const (function.extfun Type filter) pos) : countable_Inter_filter (function.extfun_app (functor.add_const.run h0) (has_Inf pos)) := sorry --non-trivial
lemma new_lemma_129706 (h0 : group (has_ssubset (with_one linarith.ineq))) : group.fg (has_ssubset (with_one linarith.ineq)) := sorry --non-trivial
lemma new_lemma_129707 (h0 : ring (semigroup (finset (has_add pos)))) : strong_rank_condition (semigroup (finset (has_add pos))) := sorry --non-trivial
lemma new_lemma_129708 (h0 : group (has_norm num)) : normalizer_condition (has_norm num) := sorry --non-trivial
lemma new_lemma_129709 (h1 : ring (monoid to_additive.value_type)) : strong_rank_condition (monoid to_additive.value_type) := sorry --non-trivial
lemma new_lemma_129710 (h0 : group (normed_field (has_nnnorm (random_gen (random_gen reducibility_hints))))) : is_cyclic (normed_field (has_nnnorm (random_gen (random_gen reducibility_hints)))) := sorry --non-trivial
lemma new_lemma_129711 (h0 : finset (pseudo_metric_space num)) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_129712 (h0 : functor.add_const (function.extfun Type uniform_space) Type) : @separated_space.{0} (cancel_monoid.{0} ennreal) (@function.extfun_app.{2 1} Type uniform_space.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type uniform_space.{0}) Type h0) (cancel_monoid.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_129713 (h0 : topological_space (canonically_ordered_comm_semiring Type)) : totally_disconnected_space (canonically_ordered_comm_semiring Type) := sorry --non-trivial
lemma new_lemma_129714 (h0 : functor.add_const (semiring (canonically_linear_ordered_monoid name)) name) : @is_noetherian_ring.{0} (canonically_linear_ordered_monoid.{0} name) (@functor.add_const.run.{0 0} (semiring.{0} (canonically_linear_ordered_monoid.{0} name)) name h0)  := sorry --non-trivial
lemma new_lemma_129715 (h1 : set (mul_one_class reducibility_hints)) : set.finite h1 := sorry --non-trivial
lemma new_lemma_129716 (h0 : complete_lattice (has_norm (random_gen (random_gen linarith.ineq)))) : is_compactly_generated (has_norm (random_gen (random_gen linarith.ineq))) := sorry --non-trivial
lemma new_lemma_129717 (h0 : uniform_space (has_one (semiring linarith.comp))) : complete_space (has_one (semiring linarith.comp)) := sorry --non-trivial
lemma new_lemma_129718 (h0 : set (set string_imp)) : is_countably_spanning h0 := sorry --non-trivial
lemma new_lemma_129719 (h0 : complete_lattice (distrib fun_info)) : complete_lattice.is_Sup_finite_compact (distrib fun_info) := sorry --non-trivial
lemma new_lemma_129720 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @preirreducible_space.{0} (ring.{0} ennreal) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (ring.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_129721 (h0 : topological_space (add_comm_monoid (has_add (has_neg_part Type)))) : totally_disconnected_space (add_comm_monoid (has_add (has_neg_part Type))) := sorry --non-trivial
lemma new_lemma_129722 (h0 : ring (topological_space linarith.ineq)) : rank_condition (topological_space linarith.ineq) := sorry --non-trivial
lemma new_lemma_129723 (h0 : ring (has_append (has_ssubset linarith.comp_source))) : strong_rank_condition (has_append (has_ssubset linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_129724 (h0 : functor.add_const (ring (semigroup pos)) name) : @rank_condition.{0} (semigroup.{0} pos) (@functor.add_const.run.{0 0} (ring.{0} (semigroup.{0} pos)) name h0)  := sorry --non-trivial
lemma new_lemma_129725 (h0 : group (filter empty)) : normalizer_condition (filter empty) := sorry --non-trivial
lemma new_lemma_129726 (h0 : functor.add_const (topological_space (add_left_cancel_semigroup unsigned)) unsigned) : @totally_separated_space.{0} (add_left_cancel_semigroup.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (add_left_cancel_semigroup.{0} unsigned)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_129727 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @archimedean.{1} (simple_graph.{1} Type) (@function.extfun_app.{3 2} (Type 1) ordered_add_comm_monoid.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 ordered_add_comm_monoid.{1}) (simple_graph.{1} Type))  := sorry --non-trivial
lemma new_lemma_129728 (h1 : topological_space (random_gen string_imp)) : totally_disconnected_space (random_gen string_imp) := sorry --non-trivial
lemma new_lemma_129729 (h0 : topological_space (has_neg congr_arg_kind)) : t1_space (has_neg congr_arg_kind) := sorry --non-trivial
lemma new_lemma_129730 (h0 : filter (add_comm_monoid (has_add (has_to_string name)))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_129731 (h0 : cancel_comm_monoid_with_zero (ordered_comm_group (option empty))) : unique_factorization_monoid (ordered_comm_group (option empty)) := sorry --non-trivial
lemma new_lemma_129732 (h0 : topological_space (add_semigroup (option (option empty)))) : irreducible_space (add_semigroup (option (option empty))) := sorry --non-trivial
lemma new_lemma_129733 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @normal_space.{0} (@id.{2} Type num) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (@id.{2} Type num))  := sorry --non-trivial
lemma new_lemma_129734 (h0 : functor.add_const (group (omega_complete_partial_order empty)) empty) : @group.fg.{0} (omega_complete_partial_order.{0} empty) (@functor.add_const.run.{0 0} (group.{0} (omega_complete_partial_order.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_129735 (h0 : list (canonically_linear_ordered_monoid (has_neg name))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_129736 (h0 : functor.add_const (topological_space (complete_distrib_lattice pos)) pos) : @t0_space.{0} (complete_distrib_lattice.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (complete_distrib_lattice.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_129737 (h0 : functor.add_const (filter (finset name)) Type) : countable_Inter_filter (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_129738 (h2 : topological_space (normed_field (comm_ring (random_gen fun_info)))) : path_connected_space (normed_field (comm_ring (random_gen fun_info))) := sorry --non-trivial
lemma new_lemma_129739 (h0 : functor.add_const (semiring (semigroup Type)) (ring (mul_one_class Type))) : @is_noetherian_ring.{1} (semigroup.{1} Type) (@functor.add_const.run.{1 1} (semiring.{1} (semigroup.{1} Type)) (ring.{1} (mul_one_class.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_129740 (h0 : topological_space (has_one (has_norm linarith.comp))) : totally_separated_space (has_one (has_norm linarith.comp)) := sorry --non-trivial
lemma new_lemma_129741 (h0 : function.extfun Type group) : @normalizer_condition.{0} (random_gen.{0} linarith.comp) (@function.extfun_app.{2 1} Type group.{0} h0 (random_gen.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_129742 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @locally_compact_space.{1} (comm_group.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 topological_space.{1}) (comm_group.{1} Type))  := sorry --non-trivial
lemma new_lemma_129743 (h0 : function.extfun Type ordered_add_comm_monoid) : @archimedean.{0} (normed_comm_ring.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type ordered_add_comm_monoid.{0} h0 (normed_comm_ring.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_129744 (h0 : functor.add_const (add_group (left_cancel_monoid unsigned)) congr_arg_kind) : @is_add_cyclic.{0} (left_cancel_monoid.{0} unsigned) (@functor.add_const.run.{0 0} (add_group.{0} (left_cancel_monoid.{0} unsigned)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_129745 (h0 : function.extfun Type topological_space) : @loc_path_connected_space.{0} (comm_monoid.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (comm_monoid.{0} empty))  := sorry --non-trivial
lemma new_lemma_129746 (h1 : ring fun_info) : rank_condition fun_info := sorry --non-trivial
lemma new_lemma_129747 (h0 : functor.add_const (list (comm_group unsigned)) name) : palindrome (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_129748 (h0 : filter (normed_group (has_top empty))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_129749 (h0 : complex) (h1 : has_mem.mem complex.abs has_emptyc.emptyc) (h2 : topological_space (cau_seq complex complex.abs)) (h3 : set (cau_seq complex complex.abs)) : joined_in h3 (complex.exp' h0) (finset.pi.empty (cau_seq complex) complex.abs h1) := sorry --non-trivial
lemma new_lemma_129750 (h0 : functor.add_const (ring (boolean_algebra linarith.comp)) (has_neg Type)) : @strong_rank_condition.{0} (boolean_algebra.{0} linarith.comp) (@functor.add_const.run.{0 1} (ring.{0} (boolean_algebra.{0} linarith.comp)) (has_neg.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_129751 (h0 : function.extfun Type complete_lattice) : @complete_lattice.is_Sup_finite_compact.{0} (random_gen.{0} string_imp) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (random_gen.{0} string_imp))  := sorry --non-trivial
lemma new_lemma_129752 (h0 : topological_space (normed_group (random_gen string_imp))) : locally_compact_space (normed_group (random_gen string_imp)) := sorry --non-trivial
lemma new_lemma_129753 (h0 : complete_lattice (has_neg_part (option name))) : complete_lattice.is_Sup_finite_compact (has_neg_part (option name)) := sorry --non-trivial
lemma new_lemma_129754 (h0 : functor.add_const (topological_space (left_cancel_semigroup num)) empty) : @topological_space.separable_space.{0} (left_cancel_semigroup.{0} num) (@functor.add_const.run.{0 0} (topological_space.{0} (left_cancel_semigroup.{0} num)) empty h0)  := sorry --non-trivial
lemma new_lemma_129755 (h0 : functor.add_const (function.extfun Type topological_space) pos) : @path_connected_space.{0} (has_Inf.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) pos h0) (has_Inf.{0} pos))  := sorry --non-trivial
lemma new_lemma_129756 (h0 : function.extfun Type semiring) : @is_noetherian_ring.{0} (has_nndist.{0} pos) (@function.extfun_app.{2 1} Type semiring.{0} h0 (has_nndist.{0} pos))  := sorry --non-trivial
lemma new_lemma_129757 (h0 : function.extfun Type topological_space) : @preirreducible_space.{0} (canonically_linear_ordered_monoid.{0} ennreal) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (canonically_linear_ordered_monoid.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_129758 (h5 : not (uniform_space (non_unital_non_assoc_semiring string_imp) -> false)) : @complete_space.{0} (non_unital_non_assoc_semiring.{0} string_imp) (@classical.by_contradiction'.{1} (uniform_space.{0} (non_unital_non_assoc_semiring.{0} string_imp)) h5)  := sorry --non-trivial
lemma new_lemma_129759 (h0 : group (with_bot (random_gen (has_top fun_info)))) : normalizer_condition (with_bot (random_gen (has_top fun_info))) := sorry --non-trivial
lemma new_lemma_129760 (h0 : functor.add_const (topological_space (mul_zero_class name)) num) : @t0_space.{0} (mul_zero_class.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (mul_zero_class.{0} name)) num h0)  := sorry --non-trivial
lemma new_lemma_129761 (h0 : not (uniform_space (non_unital_non_assoc_semiring (metric_space string.iterator_imp)) -> false)) : @complete_space.{0} (non_unital_non_assoc_semiring.{0} (metric_space.{0} string.iterator_imp)) (@classical.by_contradiction'.{1} (uniform_space.{0} (non_unital_non_assoc_semiring.{0} (metric_space.{0} string.iterator_imp))) h0)  := sorry --non-trivial
lemma new_lemma_129762 (h0 : function.extfun Type list) : list.nodup (function.extfun_app h0 (has_compl char)) := sorry --non-trivial
lemma new_lemma_129763 (h0 : ring (ring (ordered_ring pos))) : is_principal_ideal_ring (ring (ordered_ring pos)) := sorry --non-trivial
lemma new_lemma_129764 (h0 : function.extfun Type topological_space) : @discrete_topology.{0} (@id.{2} Type fun_info) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (@id.{2} Type fun_info))  := sorry --non-trivial
lemma new_lemma_129765 (h0 h1 h2 : pnat) : pnat.coprime (pnat.gcd h0 h1) h2 := sorry --non-trivial
lemma new_lemma_129766 (h0 : complete_lattice (finset (finset pos))) : is_atomistic (finset (finset pos)) := sorry --non-trivial
lemma new_lemma_129767 (h0 : not (semiring real.angle -> false)) : @is_noetherian_ring.{0} real.angle (@classical.by_contradiction'.{1} (semiring.{0} real.angle) h0)  := sorry --non-trivial
lemma new_lemma_129768 (h0 : function.extfun (Type 1) topological_space) : @path_connected_space.{1} (has_neg_part.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} h0 (has_neg_part.{1} Type))  := sorry --non-trivial
lemma new_lemma_129769 (h0 : list (add_cancel_monoid (finset (has_nndist (finset (has_pos_part (finset Type))))))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_129770 (h0 : group (semigroup name)) : group.fg (semigroup name) := sorry --non-trivial
lemma new_lemma_129771 (h0 : ring (canonically_ordered_monoid (has_Inf real))) : rank_condition (canonically_ordered_monoid (has_Inf real)) := sorry --non-trivial
lemma new_lemma_129772 (h2 : complete_lattice environment.projection_info) : complete_lattice.is_Sup_finite_compact environment.projection_info := sorry --non-trivial
lemma new_lemma_129773 (h0 : uniform_space (measurable_space.dynkin_system num)) : complete_space (measurable_space.dynkin_system num) := sorry --non-trivial
lemma new_lemma_129774 (h0 : functor.add_const (uniform_space (ring linarith.comp)) Type) : @complete_space.{0} (ring.{0} linarith.comp) (@functor.add_const.run.{0 1} (uniform_space.{0} (ring.{0} linarith.comp)) Type h0)  := sorry --non-trivial
lemma new_lemma_129775 (h0 : topological_space (cancel_monoid (has_add (has_add Type)))) : discrete_topology (cancel_monoid (has_add (has_add Type))) := sorry --non-trivial
lemma new_lemma_129776 (h0 : has_mem.mem (normed_group fun_info) has_emptyc.emptyc) : filter.ne_bot (finset.pi.empty filter (normed_group fun_info) h0) := sorry --non-trivial
lemma new_lemma_129777 (h0 : topological_space (mul_one_class linarith.ineq)) (h1 : preorder (mul_one_class linarith.ineq)) : order_closed_topology (mul_one_class linarith.ineq) := sorry --non-trivial
lemma new_lemma_129778 (h0 : fin has_zero.zero) : @normal_space.{1} (has_pos_part.{1} Type) (@matrix.vec_empty.{1} (topological_space.{1} (has_pos_part.{1} Type)) (@matrix.vec_empty.{0} (fin (@has_zero.zero.{0} nat nat.has_zero)) h0))  := sorry --non-trivial
lemma new_lemma_129779 (h0 : Type) (h1 : eq Prop h0) (h2 : h0) : eq.mpr h1 h2 := sorry --non-trivial
lemma new_lemma_129780 (h0 : not (function.extfun (Type -> Type) (function.extfun Type) -> false)) : @complete_space.{0} (has_sub.{0} unsigned) (@function.extfun_app.{2 1} Type uniform_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) (@classical.by_contradiction'.{2} (function.extfun.{2 2} (Type → Type) (function.extfun.{2 1} Type)) h0) uniform_space.{0}) (has_sub.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_129781 (h0 : functor.add_const (group (canonically_ordered_comm_semiring pos)) Type) : @normalizer_condition.{0} (canonically_ordered_comm_semiring.{0} pos) (@functor.add_const.run.{0 1} (group.{0} (canonically_ordered_comm_semiring.{0} pos)) Type h0)  := sorry --non-trivial
lemma new_lemma_129782 (h0 : function.extfun (finset Type) (has_mem.mem (complete_semilattice_Sup fun_info))) : @complete_lattice.is_Sup_finite_compact.{0} (complete_semilattice_Sup.{0} fun_info) (@finset.pi.empty.{1 0} Type complete_lattice.{0} (complete_semilattice_Sup.{0} fun_info) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (complete_semilattice_Sup.{0} fun_info)) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_129783 (h1 : function.extfun (finset Type) (has_mem.mem (metric_space linarith.comp))) : @normalizer_condition.{0} (metric_space.{0} linarith.comp) (@finset.pi.empty.{1 0} Type group.{0} (metric_space.{0} linarith.comp) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (metric_space.{0} linarith.comp)) h1 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_129784 (h0 : functor.add_const (ordered_comm_monoid (has_to_string linarith.comp)) (boolean_algebra linarith.comp)) : @has_exists_mul_of_le.{0} (has_to_string.{0} linarith.comp) (@functor.add_const.run.{0 0} (ordered_comm_monoid.{0} (has_to_string.{0} linarith.comp)) (boolean_algebra.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_129785 (h0 : topological_space (has_to_string (normed_linear_ordered_group environment.implicit_infer_kind))) : irreducible_space (has_to_string (normed_linear_ordered_group environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_129786 (h0 : complete_lattice (linear_ordered_semiring (right_cancel_semigroup num))) : complete_lattice.is_Sup_finite_compact (linear_ordered_semiring (right_cancel_semigroup num)) := sorry --non-trivial
lemma new_lemma_129787 (h0 : filter (normed_lattice_add_comm_group (has_add pos))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_129788 (h0 : topological_space (ordered_comm_ring (has_neg (has_add (has_add (has_nndist name)))))) : irreducible_space (ordered_comm_ring (has_neg (has_add (has_add (has_nndist name))))) := sorry --non-trivial
lemma new_lemma_129789 (h0 : ring (complete_distrib_lattice empty)) : rank_condition (complete_distrib_lattice empty) := sorry --non-trivial
lemma new_lemma_129790 (h0 : ring (add_comm_monoid environment.implicit_infer_kind)) : is_domain (add_comm_monoid environment.implicit_infer_kind) := sorry --non-trivial
lemma new_lemma_129791 (h0 : ordered_comm_monoid (has_pos_part (has_add (has_Inf (has_add pos))))) : has_exists_mul_of_le (has_pos_part (has_add (has_Inf (has_add pos)))) := sorry --non-trivial
lemma new_lemma_129792 (h0 : not (topological_space (plift congr_arg_kind) -> false)) : @t0_space.{1} (plift.{1} congr_arg_kind) (@classical.by_contradiction'.{2} (topological_space.{1} (plift.{1} congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_129793 (h0 : not (group (has_inv fun_info) -> false)) : @group.fg.{0} (has_inv.{0} fun_info) (@classical.by_contradiction'.{1} (group.{0} (has_inv.{0} fun_info)) h0)  := sorry --non-trivial
lemma new_lemma_129794 (h0 : topological_space (has_bot environment.implicit_infer_kind)) : loc_path_connected_space (has_bot environment.implicit_infer_kind) := sorry --non-trivial
lemma new_lemma_129795 (h0 : complete_lattice (has_to_string (option unsigned))) : complete_lattice.is_Sup_finite_compact (has_to_string (option unsigned)) := sorry --non-trivial
lemma new_lemma_129796 (h1 : has_mem.mem (measurable_space to_additive.value_type) has_emptyc.emptyc) : @is_cyclic.{0} (measurable_space.{0} to_additive.value_type) (@finset.pi.empty.{1 0} Type group.{0} (measurable_space.{0} to_additive.value_type) h1)  := sorry --non-trivial
lemma new_lemma_129797 (h0 : functor.add_const (function.extfun (Type 1) group) environment.implicit_infer_kind) : @is_cyclic.{1} Type (@function.extfun_app.{3 2} (Type 1) group.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) group.{1}) environment.implicit_infer_kind h0) Type)  := sorry --non-trivial
lemma new_lemma_129798 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @t0_space.{0} (linear_ordered_add_comm_group.{0} fun_info) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (linear_ordered_add_comm_group.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_129799 (h0 : monoid (normed_comm_ring (has_add (has_add (has_add name))))) : monoid.fg (normed_comm_ring (has_add (has_add (has_add name)))) := sorry --non-trivial
lemma new_lemma_129800 (h0 : not (complete_lattice (has_compl linarith.comp_source) -> false)) : @is_compactly_generated.{0} (has_compl.{0} linarith.comp_source) (@classical.by_contradiction'.{1} (complete_lattice.{0} (has_compl.{0} linarith.comp_source)) h0)  := sorry --non-trivial
lemma new_lemma_129801 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_domain.{0} (has_ssubset.{0} fun_info) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (has_ssubset.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_129802 (h0 : ring (random_gen (semiring congr_arg_kind))) : rank_condition (random_gen (semiring congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_129803 (h0 : fin has_zero.zero) : list.nodup (function.extfun_app (matrix.vec_empty h0) (boolean_algebra.core Type)) := sorry --non-trivial
lemma new_lemma_129804 (h0 : functor.add_const (group (left_cancel_monoid empty)) unsigned) : @group.fg.{0} (left_cancel_monoid.{0} empty) (@functor.add_const.run.{0 0} (group.{0} (left_cancel_monoid.{0} empty)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_129805 (h0 : functor.add_const (finset (finset name)) linarith.comp) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_129806 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @archimedean.{0} (has_neg_part.{0} unsigned) (@function.extfun_app.{2 1} Type ordered_add_comm_monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ordered_add_comm_monoid.{0}) (has_neg_part.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_129807 (h0 : ring (has_to_string (option pos))) : is_principal_ideal_ring (has_to_string (option pos)) := sorry --non-trivial
lemma new_lemma_129808 (h0 : semiring (measurable_space.dynkin_system (semiring linarith.comp))) : is_noetherian_ring (measurable_space.dynkin_system (semiring linarith.comp)) := sorry --non-trivial
lemma new_lemma_129809 (h0 : group (semiring unsigned)) : normalizer_condition (semiring unsigned) := sorry --non-trivial
lemma new_lemma_129810 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_add_cyclic.{0} (canonically_ordered_comm_semiring.{0} (has_to_string.{0} pos)) (@function.extfun_app.{2 1} Type add_group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 add_group.{0}) (canonically_ordered_comm_semiring.{0} (has_to_string.{0} pos)))  := sorry --non-trivial
lemma new_lemma_129811 (h0 : function.extfun Type topological_space) : @totally_disconnected_space.{0} (add_semigroup.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (add_semigroup.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_129812 (h0 : ring (encodable (has_inv to_additive.value_type))) : rank_condition (encodable (has_inv to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_129813 (h0 : topological_space (normed_comm_ring (add_comm_monoid Type))) : preconnected_space (normed_comm_ring (add_comm_monoid Type)) := sorry --non-trivial
lemma new_lemma_129814 (h0 : function.extfun Type complete_lattice) : @is_atomistic.{0} (with_bot.{0} (random_gen.{0} linarith.comp_source)) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (with_bot.{0} (random_gen.{0} linarith.comp_source)))  := sorry --non-trivial
lemma new_lemma_129815 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : list.nodup (function.extfun_app (function.extfun_app h0 list) (pseudo_metric_space congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_129816 (h0 : functor.add_const (topological_space (has_Inf Type)) linarith.comp) : @irreducible_space.{1} (has_Inf.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (has_Inf.{1} Type)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_129817 (h0 : has_mem.mem (semiring num) has_emptyc.emptyc) : @is_cyclic.{0} (semiring.{0} num) (@finset.pi.empty.{1 0} Type group.{0} (semiring.{0} num) h0)  := sorry --non-trivial
lemma new_lemma_129818 (h0 : functor.add_const (ring (has_nndist unsigned)) pos) : @is_domain.{0} (has_nndist.{0} unsigned) (@functor.add_const.run.{0 0} (ring.{0} (has_nndist.{0} unsigned)) pos h0)  := sorry --non-trivial
lemma new_lemma_129819 (h0 : complete_lattice (normed_lattice_add_comm_group (has_add (has_Inf real)))) : is_atomistic (normed_lattice_add_comm_group (has_add (has_Inf real))) := sorry --non-trivial
lemma new_lemma_129820 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : finset.nonempty (function.extfun_app (function.extfun_app h0 finset) (ordered_comm_ring Type)) := sorry --non-trivial
lemma new_lemma_129821 (h0 : semiring (id (has_norm num))) : is_noetherian_ring (id (has_norm num)) := sorry --non-trivial
lemma new_lemma_129822 (h0 : functor.add_const (ordered_add_comm_monoid nnreal) empty) : archimedean nnreal := sorry --non-trivial
lemma new_lemma_129823 (h0 : uniform_space (has_pos_part (has_Inf (has_add (has_Inf pos))))) : complete_space (has_pos_part (has_Inf (has_add (has_Inf pos)))) := sorry --non-trivial
lemma new_lemma_129824 (h0 : not (complete_lattice (comm_ring fun_info) -> false)) : @complete_lattice.is_Sup_finite_compact.{0} (comm_ring.{0} fun_info) (@classical.by_contradiction'.{1} (complete_lattice.{0} (comm_ring.{0} fun_info)) h0)  := sorry --non-trivial
lemma new_lemma_129825 (h0 : topological_space (semi_normed_comm_ring (has_lt char))) : path_connected_space (semi_normed_comm_ring (has_lt char)) := sorry --non-trivial
lemma new_lemma_129826 (h0 : functor.add_const (topological_space (has_neg_part unsigned)) name) : @totally_disconnected_space.{0} (has_neg_part.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (has_neg_part.{0} unsigned)) name h0)  := sorry --non-trivial
lemma new_lemma_129827 (h0 : functor.add_const (complete_lattice (has_zero pos)) linarith.comp) : @is_atomistic.{0} (has_zero.{0} pos) (@functor.add_const.run.{0 0} (complete_lattice.{0} (has_zero.{0} pos)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_129828 (h0 : functor.add_const (function.extfun Type ring) environment.implicit_infer_kind) : @rank_condition.{0} (finset.{0} linarith.comp) (@function.extfun_app.{2 1} Type ring.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type ring.{0}) environment.implicit_infer_kind h0) (finset.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_129829 (h1 : ring (with_bot congr_arg_kind)) : strong_rank_condition (with_bot congr_arg_kind) := sorry --non-trivial
lemma new_lemma_129830 (h0 : not (uniform_space (with_bot unsigned) -> false)) : @complete_space.{0} (with_bot.{0} unsigned) (@classical.by_contradiction'.{1} (uniform_space.{0} (with_bot.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_129831 (h0 : list (semi_normed_comm_ring string_imp)) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_129832 (h0 : ring (mul_zero_class (finset pos))) : is_principal_ideal_ring (mul_zero_class (finset pos)) := sorry --non-trivial
lemma new_lemma_129833 (h0 : fin has_zero.zero) : @monoid.fg.{1} (boolean_algebra.core.{1} (has_add.{1} Type)) (@matrix.vec_empty.{1} (monoid.{1} (boolean_algebra.core.{1} (has_add.{1} Type))) h0)  := sorry --non-trivial
lemma new_lemma_129834 (h0 : has_lt ereal) : no_max_order ereal := sorry --non-trivial
lemma new_lemma_129835 (h0 : not (add_group (metric_space string_imp) -> false)) : @is_add_cyclic.{0} (metric_space.{0} string_imp) (@classical.by_contradiction'.{1} (add_group.{0} (metric_space.{0} string_imp)) h0)  := sorry --non-trivial
lemma new_lemma_129836 (h0 : function.extfun Type add_group) : @is_add_cyclic.{0} (option.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type add_group.{0} h0 (option.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_129837 (h0 : function.extfun Type filter) : filter.ne_bot (function.extfun_app h0 (add_cancel_monoid linarith.comp)) := sorry --non-trivial
lemma new_lemma_129838 (h0 : not (ring (has_div enat) -> false)) : @strong_rank_condition.{0} (has_div.{0} enat) (@classical.by_contradiction'.{1} (ring.{0} (has_div.{0} enat)) h0)  := sorry --non-trivial
lemma new_lemma_129839 (h0 : function.extfun Type (functor.comp topological_space canonically_ordered_comm_semiring)) : @irreducible_space.{0} (canonically_ordered_comm_semiring.{0} name) (@functor.comp.run.{0 0 0} topological_space.{0} canonically_ordered_comm_semiring.{0} name (@function.extfun_app.{2 1} Type (functor.comp.{0 0 0} topological_space.{0} canonically_ordered_comm_semiring.{0}) h0 name))  := sorry --non-trivial
lemma new_lemma_129840 (h0 : ring (semiring (has_norm to_additive.value_type))) : strong_rank_condition (semiring (has_norm to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_129841 (h0 : finset (finset environment.implicit_infer_kind)) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_129842 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : finset.nonempty (function.extfun_app (function.extfun_app h0 finset) (boolean_algebra.core Type)) := sorry --non-trivial
lemma new_lemma_129843 (h0 : not (function.extfun Type complete_lattice -> false)) : @is_compactly_generated.{0} (has_compl.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type complete_lattice.{0}) h0) (has_compl.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_129844 (h0 : group (has_nndist (has_zero linarith.comp))) : is_simple_group (has_nndist (has_zero linarith.comp)) := sorry --non-trivial
lemma new_lemma_129845 (h0 : ring (comm_ring (has_nnnorm (has_nnnorm (has_nnnorm fun_info))))) : rank_condition (comm_ring (has_nnnorm (has_nnnorm (has_nnnorm fun_info)))) := sorry --non-trivial
lemma new_lemma_129846 (h0 : ring (normed_group (has_union linarith.comp))) : is_domain (normed_group (has_union linarith.comp)) := sorry --non-trivial
lemma new_lemma_129847 (h0 : group (has_star (semiring (semiring (semiring (has_top empty)))))) : group.fg (has_star (semiring (semiring (semiring (has_top empty))))) := sorry --non-trivial
lemma new_lemma_129848 (h0 : topological_space (has_norm (semiring unsigned))) : locally_compact_space (has_norm (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_129849 (h0 : ring (measurable_space (has_norm (has_norm (has_norm to_additive.value_type))))) : is_domain (measurable_space (has_norm (has_norm (has_norm to_additive.value_type)))) := sorry --non-trivial
lemma new_lemma_129850 (h1 : topological_space (random_gen congr_arg_kind)) : totally_separated_space (random_gen congr_arg_kind) := sorry --non-trivial
lemma new_lemma_129851 (h0 : ordered_comm_monoid (has_Inf (has_pos_part (has_bot real)))) : has_exists_mul_of_le (has_Inf (has_pos_part (has_bot real))) := sorry --non-trivial
lemma new_lemma_129852 (h0 : functor.add_const (topological_space (complete_linear_order num)) congr_arg_kind) : @totally_disconnected_space.{0} (complete_linear_order.{0} num) (@functor.add_const.run.{0 0} (topological_space.{0} (complete_linear_order.{0} num)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_129853 (h0 : with_bot (group (linear_ordered_add_comm_group linarith.comp_source))) (h1 : ne h0 has_bot.bot) : @normalizer_condition.{0} (linear_ordered_add_comm_group.{0} linarith.comp_source) (@with_bot.unbot.{0} (group.{0} (linear_ordered_add_comm_group.{0} linarith.comp_source)) h0 h1)  := sorry --non-trivial
lemma new_lemma_129854 (h0 : function.extfun Type topological_space) : @preconnected_space.{0} (ordered_comm_ring.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (ordered_comm_ring.{0} name))  := sorry --non-trivial
lemma new_lemma_129855 (h0 : topological_space (boolean_algebra (has_add linarith.comp))) : preconnected_space (boolean_algebra (has_add linarith.comp)) := sorry --non-trivial
lemma new_lemma_129856 (h0 : uniform_space (add_right_cancel_monoid (semiring num))) : separated_space (add_right_cancel_monoid (semiring num)) := sorry --non-trivial
lemma new_lemma_129857 (h0 : monoid (measure_theory.measure_space (semiring (semiring (semiring num))))) : monoid.fg (measure_theory.measure_space (semiring (semiring (semiring num)))) := sorry --non-trivial
lemma new_lemma_129858 (h1 : preorder linarith.ineq) (h2 : set linarith.ineq) : set.is_pwo h2 := sorry --non-trivial
lemma new_lemma_129859 (h0 : functor.comp filter complete_distrib_lattice pos) : countable_Inter_filter (functor.comp.run h0) := sorry --non-trivial
lemma new_lemma_129860 (h0 : topological_space (semigroup Type)) : preconnected_space (semigroup Type) := sorry --non-trivial
lemma new_lemma_129861 (h0 : function.extfun Type uniform_space) : @separated_space.{0} (has_add.{0} real) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (has_add.{0} real))  := sorry --non-trivial
lemma new_lemma_129862 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @t0_space.{0} (has_to_string.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_to_string.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_129863 (h0 : functor.add_const (ring (ring Type)) pos) : @strong_rank_condition.{1} (ring.{1} Type) (@functor.add_const.run.{1 0} (ring.{1} (ring.{1} Type)) pos h0)  := sorry --non-trivial
lemma new_lemma_129864 (h0 : functor.add_const (function.extfun Type topological_space) (ring pos)) : @regular_space.{0} (simple_graph.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) (ring.{0} pos) h0) (simple_graph.{0} pos))  := sorry --non-trivial
lemma new_lemma_129865 (h0 : ring (has_ssubset (comm_ring reducibility_hints))) : rank_condition (has_ssubset (comm_ring reducibility_hints)) := sorry --non-trivial
lemma new_lemma_129866 (h1 : complete_lattice (has_append fun_info)) : complete_lattice.is_Sup_finite_compact (has_append fun_info) := sorry --non-trivial
lemma new_lemma_129867 (h0 : function.extfun Type group) : @is_simple_group.{0} (finset.{0} ennreal) (@function.extfun_app.{2 1} Type group.{0} h0 (finset.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_129868 (h0 : topological_space (linear_ordered_comm_ring num)) : irreducible_space (linear_ordered_comm_ring num) := sorry --non-trivial
lemma new_lemma_129869 (h0 : add_group (option (option unsigned))) : is_add_cyclic (option (option unsigned)) := sorry --non-trivial
lemma new_lemma_129870 (h0 : topological_space (ordered_comm_group num)) : locally_compact_space (ordered_comm_group num) := sorry --non-trivial
lemma new_lemma_129871 (h0 : topological_space (has_Inf (has_neg (has_neg name)))) : locally_compact_space (has_Inf (has_neg (has_neg name))) := sorry --non-trivial
lemma new_lemma_129872 (h0 : functor.add_const (function.extfun Type topological_space) linarith.comp) : @loc_path_connected_space.{0} (has_add.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) linarith.comp h0) (has_add.{0} pos))  := sorry --non-trivial
lemma new_lemma_129873 (h0 : functor.add_const (topological_space (has_zero name)) Type) : @locally_compact_space.{0} (has_zero.{0} name) (@functor.add_const.run.{0 1} (topological_space.{0} (has_zero.{0} name)) Type h0)  := sorry --non-trivial
lemma new_lemma_129874 (h2 : topological_space (topological_space (comm_ring reducibility_hints))) : t0_space (topological_space (comm_ring reducibility_hints)) := sorry --non-trivial
lemma new_lemma_129875 (h0 : functor.add_const (function.extfun Type ordered_comm_monoid) (finset pos)) : @has_exists_mul_of_le.{0} (has_add.{0} pos) (@function.extfun_app.{2 1} Type ordered_comm_monoid.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type ordered_comm_monoid.{0}) (finset.{0} pos) h0) (has_add.{0} pos))  := sorry --non-trivial
lemma new_lemma_129876 (h0 : functor.add_const (topological_space (ring name)) linarith.comp) : @totally_disconnected_space.{0} (ring.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (ring.{0} name)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_129877 (h0 : functor.add_const (uniform_space (measurable_space.dynkin_system unsigned)) unsigned) : @complete_space.{0} (measurable_space.dynkin_system.{0} unsigned) (@functor.add_const.run.{0 0} (uniform_space.{0} (measurable_space.dynkin_system.{0} unsigned)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_129878 (h0 : function.extfun (Type 1) complete_lattice) : @is_atomistic.{1} (cancel_monoid.{1} Type) (@function.extfun_app.{3 2} (Type 1) complete_lattice.{1} h0 (cancel_monoid.{1} Type))  := sorry --non-trivial
lemma new_lemma_129879 (h1 : not (add_group (encodable char) -> false)) : @is_add_cyclic.{0} (encodable.{0} char) (@classical.by_contradiction'.{1} (add_group.{0} (encodable.{0} char)) h1)  := sorry --non-trivial
lemma new_lemma_129880 (h1 : has_lt (mul_one_class reducibility_hints)) : no_max_order (mul_one_class reducibility_hints) := sorry --non-trivial
lemma new_lemma_129881 (h0 : topological_space (has_neg_part (comm_group ennreal))) : regular_space (has_neg_part (comm_group ennreal)) := sorry --non-trivial
lemma new_lemma_129882 (h0 : uniform_space (metric_space (has_norm (has_norm empty)))) : complete_space (metric_space (has_norm (has_norm empty))) := sorry --non-trivial
lemma new_lemma_129883 (h0 : list (id (has_top (has_top (has_top linarith.ineq))))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_129884 (h0 : functor.add_const (topological_space (finset pos)) (finset linarith.comp)) : @totally_disconnected_space.{0} (finset.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (finset.{0} pos)) (finset.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_129885 (h0 : not (ring (normed_group to_additive.value_type) -> false)) : @strong_rank_condition.{0} (normed_group.{0} to_additive.value_type) (@classical.by_contradiction'.{1} (ring.{0} (normed_group.{0} to_additive.value_type)) h0)  := sorry --non-trivial
lemma new_lemma_129886 (h0 : function.extfun Type filter) : filter.ne_bot (function.extfun_app h0 (semi_normed_comm_ring to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_129887 (h0 : functor.add_const (topological_space (boolean_algebra linarith.comp)) linarith.comp) : @loc_path_connected_space.{0} (boolean_algebra.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (boolean_algebra.{0} linarith.comp)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_129888 (h0 : function.extfun Type topological_space) : @loc_path_connected_space.{0} (canonically_ordered_add_monoid.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (canonically_ordered_add_monoid.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_129889 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @path_connected_space.{0} (ordered_cancel_add_comm_monoid.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (ordered_cancel_add_comm_monoid.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_129890 (h0 : function.extfun Type topological_space) : @totally_disconnected_space.{0} (normed_group.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (normed_group.{0} num))  := sorry --non-trivial
lemma new_lemma_129891 (h0 : topological_space (comm_group (has_add pos))) : irreducible_space (comm_group (has_add pos)) := sorry --non-trivial
lemma new_lemma_129892 (h0 : topological_space (add_comm_monoid empty)) : t1_space (add_comm_monoid empty) := sorry --non-trivial
lemma new_lemma_129893 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @add_monoid.fg.{0} (has_to_string.{0} real) (@function.extfun_app.{2 1} Type add_monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 add_monoid.{0}) (has_to_string.{0} real))  := sorry --non-trivial
lemma new_lemma_129894 (h0 : uniform_space (has_union empty)) : separated_space (has_union empty) := sorry --non-trivial
lemma new_lemma_129895 (h0 : topological_space (has_add real)) : irreducible_space (has_add real) := sorry --non-trivial
lemma new_lemma_129896 (h0 : function.extfun Type topological_space) : @loc_path_connected_space.{0} (monoid.{0} ennreal) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (monoid.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_129897 (h0 : function.extfun Type group) : @group.fg.{0} (semiring.{0} linarith.comp) (@function.extfun_app.{2 1} Type group.{0} h0 (semiring.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_129898 (h0 : topological_space (has_pos_part (sub_neg_monoid real))) : path_connected_space (has_pos_part (sub_neg_monoid real)) := sorry --non-trivial
lemma new_lemma_129899 (h0 : function.extfun Type topological_space) : @preconnected_space.{0} (has_neg.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_neg.{0} name))  := sorry --non-trivial
lemma new_lemma_129900 (h0 : topological_space (has_union num)) : irreducible_space (has_union num) := sorry --non-trivial
lemma new_lemma_129901 (h0 : functor.add_const (topological_space (left_cancel_monoid congr_arg_kind)) empty) : @irreducible_space.{0} (left_cancel_monoid.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (left_cancel_monoid.{0} congr_arg_kind)) empty h0)  := sorry --non-trivial
lemma new_lemma_129902 (h0 : functor.add_const (topological_space (has_zero name)) name) : @topological_space.separable_space.{0} (has_zero.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (has_zero.{0} name)) name h0)  := sorry --non-trivial
lemma new_lemma_129903 (h0 : not (ring (has_nnnorm ennreal) -> false)) : @strong_rank_condition.{0} (has_nnnorm.{0} ennreal) (@classical.by_contradiction'.{1} (ring.{0} (has_nnnorm.{0} ennreal)) h0)  := sorry --non-trivial
lemma new_lemma_129904 (h0 : has_mem.mem ring has_emptyc.emptyc) : @is_domain.{0} (random_gen.{0} num) (@function.extfun_app.{2 1} Type ring.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) ring.{0} h0) (random_gen.{0} num))  := sorry --non-trivial
lemma new_lemma_129905 (h0 : topological_space (semigroup Type)) : regular_space (semigroup Type) := sorry --non-trivial
lemma new_lemma_129906 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @t0_space.{0} (has_inv.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_inv.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_129907 (h0 : topological_space (complete_distrib_lattice (boolean_algebra Type))) : preconnected_space (complete_distrib_lattice (boolean_algebra Type)) := sorry --non-trivial
lemma new_lemma_129908 (h0 : not (function.extfun Type complete_lattice -> false)) : @is_atomistic.{0} real.angle (@function.extfun_app.{2 1} Type complete_lattice.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type complete_lattice.{0}) h0) real.angle)  := sorry --non-trivial
lemma new_lemma_129909 (h0 : semiring (linear_ordered_comm_ring (semiring empty))) : is_noetherian_ring (linear_ordered_comm_ring (semiring empty)) := sorry --non-trivial
lemma new_lemma_129910 (h0 : complete_lattice (has_norm (random_gen num))) : complete_lattice.is_Sup_finite_compact (has_norm (random_gen num)) := sorry --non-trivial
lemma new_lemma_129911 (h0 : group (ring (option empty))) : group.fg (ring (option empty)) := sorry --non-trivial
lemma new_lemma_129912 (h0 : list (distrib_lattice (random_gen (random_gen string_imp)))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_129913 (h0 : topological_space (partial_order empty)) : discrete_topology (partial_order empty) := sorry --non-trivial
lemma new_lemma_129914 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_simple_group.{0} (has_nndist.{0} pos) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (has_nndist.{0} pos))  := sorry --non-trivial
lemma new_lemma_129915 (h0 : topological_space (generalized_boolean_algebra (has_Inf (has_bot real)))) : sequential_space (generalized_boolean_algebra (has_Inf (has_bot real))) := sorry --non-trivial
lemma new_lemma_129916 (h0 : topological_space (comm_group (comm_group Type))) : totally_disconnected_space (comm_group (comm_group Type)) := sorry --non-trivial
lemma new_lemma_129917 (h0 : group (comm_semigroup pos)) : is_cyclic (comm_semigroup pos) := sorry --non-trivial
lemma new_lemma_129918 (h0 : add_group (add_monoid (has_nnnorm (has_nnnorm fun_info)))) : is_add_cyclic (add_monoid (has_nnnorm (has_nnnorm fun_info))) := sorry --non-trivial
lemma new_lemma_129919 (h1 : group (has_nnnorm (has_nnnorm (denumerable linarith.ineq)))) : is_cyclic (has_nnnorm (has_nnnorm (denumerable linarith.ineq))) := sorry --non-trivial
lemma new_lemma_129920 (h0 : not (function.extfun Type group -> false)) : @normalizer_condition.{0} (with_bot.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type group.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type group.{0}) h0) (with_bot.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_129921 (h0 : ordered_add_comm_monoid (has_to_string (finset pos))) : archimedean (has_to_string (finset pos)) := sorry --non-trivial
lemma new_lemma_129922 (h0 : complete_lattice (ordered_cancel_add_comm_monoid (option num))) : is_atomistic (ordered_cancel_add_comm_monoid (option num)) := sorry --non-trivial
lemma new_lemma_129923 (h0 : complete_lattice (normed_group (random_gen fun_info))) : is_atomistic (normed_group (random_gen fun_info)) := sorry --non-trivial
lemma new_lemma_129924 (h0 : monoid (add_comm_monoid (has_add environment.implicit_infer_kind))) : monoid.fg (add_comm_monoid (has_add environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_129925 (h0 : group (has_inter ennreal)) : is_cyclic (has_inter ennreal) := sorry --non-trivial
lemma new_lemma_129926 (h0 : not (order_hom nat (topological_space (distrib (comm_ring (comm_ring (comm_ring char))))) -> false)) : @totally_disconnected_space.{0} (distrib.{0} (comm_ring.{0} (comm_ring.{0} (comm_ring.{0} char)))) (@monotonic_sequence_limit.{0} (topological_space.{0} (distrib.{0} (comm_ring.{0} (comm_ring.{0} (comm_ring.{0} char))))) (@topological_space.partial_order.{0} (distrib.{0} (comm_ring.{0} (comm_ring.{0} (comm_ring.{0} char))))) (@classical.by_contradiction'.{1} (@order_hom.{0 0} nat (topological_space.{0} (distrib.{0} (comm_ring.{0} (comm_ring.{0} (comm_ring.{0} char))))) (@partial_order.to_preorder.{0} nat (@ordered_cancel_add_comm_monoid.to_partial_order.{0} nat (@ordered_semiring.to_ordered_cancel_add_comm_monoid.{0} nat nat.ordered_semiring))) (@partial_order.to_preorder.{0} (topological_space.{0} (distrib.{0} (comm_ring.{0} (comm_ring.{0} (comm_ring.{0} char))))) (@topological_space.partial_order.{0} (distrib.{0} (comm_ring.{0} (comm_ring.{0} (comm_ring.{0} char))))))) h0))  := sorry --non-trivial
lemma new_lemma_129927 (h0 : functor.add_const (function.extfun Type uniform_space) linarith.comp) : @separated_space.{0} (has_neg.{0} name) (@function.extfun_app.{2 1} Type uniform_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type uniform_space.{0}) linarith.comp h0) (has_neg.{0} name))  := sorry --non-trivial
lemma new_lemma_129928 (h1 : set (has_ssubset environment.projection_info)) : set.finite h1 := sorry --non-trivial
lemma new_lemma_129929 (h0 : functor.add_const (ring (has_zero pos)) (boolean_algebra Type)) : @is_principal_ideal_ring.{0} (has_zero.{0} pos) (@functor.add_const.run.{0 1} (ring.{0} (has_zero.{0} pos)) (boolean_algebra.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_129930 (h0 : functor.add_const (ring (add_comm_monoid Type)) Type) : @rank_condition.{1} (add_comm_monoid.{1} Type) (@functor.add_const.run.{1 1} (ring.{1} (add_comm_monoid.{1} Type)) Type h0)  := sorry --non-trivial
lemma new_lemma_129931 (h0 : function.extfun Type complete_lattice) : @is_compactly_generated.{0} (linear_ordered_semiring.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (linear_ordered_semiring.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_129932 (h0 : function.extfun Type filter) : filter.ne_bot (function.extfun_app h0 (canonically_ordered_add_monoid unsigned)) := sorry --non-trivial
lemma new_lemma_129933 (h0 : functor.add_const (function.extfun (Type 1) group) linarith.comp) : @is_cyclic.{1} (has_neg.{1} Type) (@function.extfun_app.{3 2} (Type 1) group.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) group.{1}) linarith.comp h0) (has_neg.{1} Type))  := sorry --non-trivial
lemma new_lemma_129934 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @is_compactly_generated.{1} (has_add.{1} Type) (@function.extfun_app.{3 2} (Type 1) complete_lattice.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 complete_lattice.{1}) (has_add.{1} Type))  := sorry --non-trivial
lemma new_lemma_129935 (h0 : function.extfun Type add_group) : @is_add_cyclic.{0} (normed_comm_ring.{0} num) (@function.extfun_app.{2 1} Type add_group.{0} h0 (normed_comm_ring.{0} num))  := sorry --non-trivial
lemma new_lemma_129936 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @path_connected_space.{0} (normed_group.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (normed_group.{0} num))  := sorry --non-trivial
lemma new_lemma_129937 (h0 : ring (comm_ring (with_zero string_imp))) : is_domain (comm_ring (with_zero string_imp)) := sorry --non-trivial
lemma new_lemma_129938 (h1 : function.extfun Type topological_space) : @totally_disconnected_space.{0} (with_one.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h1 (with_one.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_129939 (h3 : ring (fintype fun_info)) : is_domain (fintype fun_info) := sorry --non-trivial
lemma new_lemma_129940 (h0 : has_mem.mem real.angle has_emptyc.emptyc) : @path_connected_space.{0} real.angle (@finset.pi.empty.{1 0} Type topological_space.{0} real.angle h0)  := sorry --non-trivial
lemma new_lemma_129941 (h0 : complete_lattice (canonically_linear_ordered_monoid (option name))) : complete_lattice.is_Sup_finite_compact (canonically_linear_ordered_monoid (option name)) := sorry --non-trivial
lemma new_lemma_129942 (h0 : topological_space (normed_comm_ring (has_to_string (has_to_string congr_arg_kind)))) : discrete_topology (normed_comm_ring (has_to_string (has_to_string congr_arg_kind))) := sorry --non-trivial
lemma new_lemma_129943 (h0 : function.extfun (Type 1) semiring) : @is_noetherian_ring.{1} (has_pos_part.{1} Type) (@function.extfun_app.{3 2} (Type 1) semiring.{1} h0 (has_pos_part.{1} Type))  := sorry --non-trivial
lemma new_lemma_129944 (h0 : uniform_space (metric_space (has_top unsigned))) : complete_space (metric_space (has_top unsigned)) := sorry --non-trivial
lemma new_lemma_129945 (h0 : topological_space (has_Sup (has_neg environment.implicit_infer_kind))) : path_connected_space (has_Sup (has_neg environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_129946 (h0 : topological_space (left_cancel_monoid (semiring (semiring congr_arg_kind)))) : totally_disconnected_space (left_cancel_monoid (semiring (semiring congr_arg_kind))) := sorry --non-trivial
lemma new_lemma_129947 (h0 : topological_space (finset (finset linarith.comp))) : irreducible_space (finset (finset linarith.comp)) := sorry --non-trivial
lemma new_lemma_129948 (h0 : monoid (has_inter (option (option (option num))))) : monoid.fg (has_inter (option (option (option num)))) := sorry --non-trivial
lemma new_lemma_129949 (h0 : complete_lattice (has_div (semi_normed_ring fun_info))) : is_compactly_generated (has_div (semi_normed_ring fun_info)) := sorry --non-trivial
lemma new_lemma_129950 (h0 : topological_space (add_comm_monoid (has_add Type))) : path_connected_space (add_comm_monoid (has_add Type)) := sorry --non-trivial
lemma new_lemma_129951 (h0 : list (encodable (has_nnnorm (has_nnnorm fun_info)))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_129952 (h0 : list (normed_lattice_add_comm_group congr_arg_kind)) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_129953 (h0 : group (has_neg (has_add (ring pos)))) : normalizer_condition (has_neg (has_add (ring pos))) := sorry --non-trivial
lemma new_lemma_129954 (h0 : topological_space (has_add (ring Type))) : totally_disconnected_space (has_add (ring Type)) := sorry --non-trivial
lemma new_lemma_129955 (h0 : functor.add_const (ring (has_nndist name)) name) : @strong_rank_condition.{0} (has_nndist.{0} name) (@functor.add_const.run.{0 0} (ring.{0} (has_nndist.{0} name)) name h0)  := sorry --non-trivial
lemma new_lemma_129956 (h0 : unsigned -> unsigned -> Prop) : is_symm unsigned h0 := sorry --non-trivial
lemma new_lemma_129957 (h1 : set (has_inv to_additive.value_type)) : set.finite h1 := sorry --non-trivial
lemma new_lemma_129958 (h0 : function.extfun Type topological_space) : @irreducible_space.{0} (canonically_ordered_add_monoid.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (canonically_ordered_add_monoid.{0} empty))  := sorry --non-trivial
lemma new_lemma_129959 (h0 : topological_space fun_info) (h3 : preorder fun_info) : order_closed_topology fun_info := sorry --non-trivial
lemma new_lemma_129960 (h0 : complete_lattice (comm_ring (has_nnnorm fun_info))) : complete_lattice.is_Sup_finite_compact (comm_ring (has_nnnorm fun_info)) := sorry --non-trivial
lemma new_lemma_129961 (h0 : functor.add_const (topological_space (cancel_monoid name)) (boolean_algebra environment.implicit_infer_kind)) : @regular_space.{0} (cancel_monoid.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (cancel_monoid.{0} name)) (boolean_algebra.{0} environment.implicit_infer_kind) h0)  := sorry --non-trivial
lemma new_lemma_129962 (h0 : complete_lattice (has_top (semiring (semiring unsigned)))) : is_atomistic (has_top (semiring (semiring unsigned))) := sorry --non-trivial
lemma new_lemma_129963 (h0 : topological_space (add_comm_monoid (has_neg pos))) : loc_path_connected_space (add_comm_monoid (has_neg pos)) := sorry --non-trivial
lemma new_lemma_129964 (h0 : topological_space (boolean_algebra.core linarith.comp)) : totally_separated_space (boolean_algebra.core linarith.comp) := sorry --non-trivial
lemma new_lemma_129965 (h0 : set (semi_normed_comm_ring environment.projection_info)) : set.finite h0 := sorry --non-trivial
lemma new_lemma_129966 (h0 : functor.add_const (finset (plift empty)) (semiring (semiring empty))) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_129967 (h0 : topological_space (has_nnnorm (mul_one_class linarith.ineq))) (h1 : preorder (has_nnnorm (mul_one_class linarith.ineq))) : order_closed_topology (has_nnnorm (mul_one_class linarith.ineq)) := sorry --non-trivial
lemma new_lemma_129968 (h0 : functor.comp complete_lattice complete_distrib_lattice (boolean_algebra.core ennreal)) : @is_atomistic.{0} (complete_distrib_lattice.{0} (boolean_algebra.core.{0} ennreal)) (@functor.comp.run.{0 0 0} complete_lattice.{0} complete_distrib_lattice.{0} (boolean_algebra.core.{0} ennreal) h0)  := sorry --non-trivial
lemma new_lemma_129969 (h0 : ordered_comm_monoid (has_to_string (has_to_string name))) : has_exists_mul_of_le (has_to_string (has_to_string name)) := sorry --non-trivial
lemma new_lemma_129970 (h0 : function.extfun Type ring) : @is_principal_ideal_ring.{0} (has_nndist.{0} empty) (@function.extfun_app.{2 1} Type ring.{0} h0 (has_nndist.{0} empty))  := sorry --non-trivial
lemma new_lemma_129971 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : finset.nonempty (function.extfun_app (function.extfun_app h0 finset) (mul_zero_class num)) := sorry --non-trivial
lemma new_lemma_129972 (h0 : functor.add_const (semiring (left_cancel_monoid unsigned)) unsigned) : @is_noetherian_ring.{0} (left_cancel_monoid.{0} unsigned) (@functor.add_const.run.{0 0} (semiring.{0} (left_cancel_monoid.{0} unsigned)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_129973 (h0 : functor.add_const (group (has_add environment.implicit_infer_kind)) name) : @is_simple_group.{0} (has_add.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (group.{0} (has_add.{0} environment.implicit_infer_kind)) name h0)  := sorry --non-trivial
lemma new_lemma_129974 (h0 : topological_space (has_nndist (has_neg (ring name)))) : locally_compact_space (has_nndist (has_neg (ring name))) := sorry --non-trivial
lemma new_lemma_129975 (h0 : functor.add_const (topological_space (canonically_ordered_comm_semiring name)) name) : @t1_space.{0} (canonically_ordered_comm_semiring.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (canonically_ordered_comm_semiring.{0} name)) name h0)  := sorry --non-trivial
lemma new_lemma_129976 (h2 : add_group (has_lt linarith.ineq)) : is_add_cyclic (has_lt linarith.ineq) := sorry --non-trivial
lemma new_lemma_129977 (h0 : functor.add_const (ring (add_cancel_monoid pos)) linarith.comp) : @is_principal_ideal_ring.{0} (add_cancel_monoid.{0} pos) (@functor.add_const.run.{0 0} (ring.{0} (add_cancel_monoid.{0} pos)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_129978 (h0 : functor.add_const (add_monoid (ring linarith.comp)) name) : @add_monoid.fg.{0} (ring.{0} linarith.comp) (@functor.add_const.run.{0 0} (add_monoid.{0} (ring.{0} linarith.comp)) name h0)  := sorry --non-trivial
lemma new_lemma_129979 (h0 : group (measurable_space (has_norm (random_gen (random_gen num))))) : group.fg (measurable_space (has_norm (random_gen (random_gen num)))) := sorry --non-trivial
lemma new_lemma_129980 (h0 : functor.add_const (topological_space (complete_distrib_lattice Type)) linarith.comp) : @normal_space.{1} (complete_distrib_lattice.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (complete_distrib_lattice.{1} Type)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_129981 (h0 : group (id num)) : normalizer_condition (id num) := sorry --non-trivial
lemma new_lemma_129982 (h0 : functor.add_const (topological_space (finset pos)) pos) : @regular_space.{0} (finset.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (finset.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_129983 (h0 : topological_space (linear_ordered_cancel_comm_monoid (semiring (semiring empty)))) : topological_space.separable_space (linear_ordered_cancel_comm_monoid (semiring (semiring empty))) := sorry --non-trivial
lemma new_lemma_129984 (h0 : ordered_comm_monoid (boolean_algebra (has_pos_part pos))) : has_exists_mul_of_le (boolean_algebra (has_pos_part pos)) := sorry --non-trivial
lemma new_lemma_129985 (h0 : topological_space (has_nndist unsigned)) : path_connected_space (has_nndist unsigned) := sorry --non-trivial
lemma new_lemma_129986 (h0 : topological_space (has_neg_part (comm_group (comm_group ennreal)))) : t0_space (has_neg_part (comm_group (comm_group ennreal))) := sorry --non-trivial
lemma new_lemma_129987 (h1 : add_monoid (has_nnnorm to_additive.value_type)) (h2 : has_one (has_nnnorm to_additive.value_type)) : char_zero (has_nnnorm to_additive.value_type) := sorry --non-trivial
lemma new_lemma_129988 (h0 : function.extfun (Type 1) (functor.add_const (topological_space (boolean_algebra.core name)))) : @t0_space.{0} (boolean_algebra.core.{0} name) (@functor.add_const.run.{0 1} (topological_space.{0} (boolean_algebra.core.{0} name)) Type (@function.extfun_app.{3 1} (Type 1) (functor.add_const.{0 1} (topological_space.{0} (boolean_algebra.core.{0} name))) h0 Type))  := sorry --non-trivial
lemma new_lemma_129989 (h0 : group (has_pos_part (has_Inf real))) : normalizer_condition (has_pos_part (has_Inf real)) := sorry --non-trivial
lemma new_lemma_129990 (h0 : ring (has_to_string unsigned)) : rank_condition (has_to_string unsigned) := sorry --non-trivial
lemma new_lemma_129991 (h0 : ring (ring (has_add linarith.comp))) : is_principal_ideal_ring (ring (has_add linarith.comp)) := sorry --non-trivial
lemma new_lemma_129992 (h0 : set (has_lt reducibility_hints)) : set.subsingleton h0 := sorry --non-trivial
lemma new_lemma_129993 (h0 : function.extfun (finset Type) (has_mem.mem (random_gen empty))) : @discrete_topology.{0} (random_gen.{0} empty) (@finset.pi.empty.{1 0} Type topological_space.{0} (random_gen.{0} empty) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (random_gen.{0} empty)) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_129994 (h0 : functor.add_const (topological_space (has_pos_part pos)) name) : @discrete_topology.{0} (has_pos_part.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (has_pos_part.{0} pos)) name h0)  := sorry --non-trivial
lemma new_lemma_129995 (h0 : has_le (has_lt string.iterator_imp)) (h1 : bounded_order (has_lt string.iterator_imp)) : is_simple_order (has_lt string.iterator_imp) := sorry --non-trivial
lemma new_lemma_129996 (h0 : functor.add_const (filter (has_zero name)) unsigned) : countable_Inter_filter (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_129997 (h0 : topological_space (with_one (has_nnnorm fun_info))) : totally_disconnected_space (with_one (has_nnnorm fun_info)) := sorry --non-trivial
lemma new_lemma_129998 (h0 : topological_space (has_bot (has_Inf (has_bot real)))) : locally_compact_space (has_bot (has_Inf (has_bot real))) := sorry --non-trivial
lemma new_lemma_129999 (h0 : function.extfun Type (functor.add_const (topological_space (ordered_comm_group empty)))) : @preirreducible_space.{0} (ordered_comm_group.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (ordered_comm_group.{0} empty)) empty (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (topological_space.{0} (ordered_comm_group.{0} empty))) h0 empty))  := sorry --non-trivial
lemma new_lemma_130000 (h0 : not (ring (linear_ordered_semiring unsigned) -> false)) : @is_principal_ideal_ring.{0} (linear_ordered_semiring.{0} unsigned) (@classical.by_contradiction'.{1} (ring.{0} (linear_ordered_semiring.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_130001 (h0 : function.extfun Type topological_space) : @path_connected_space.{0} (fintype.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (fintype.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_130002 (h0 : functor.add_const (filter (simple_graph linarith.comp)) (ring Type)) : countable_Inter_filter (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_130003 (h0 : not (topological_space (non_unital_non_assoc_semiring string_imp) -> false)) : @t0_space.{0} (non_unital_non_assoc_semiring.{0} string_imp) (@classical.by_contradiction'.{1} (topological_space.{0} (non_unital_non_assoc_semiring.{0} string_imp)) h0)  := sorry --non-trivial
lemma new_lemma_130004 (h0 : uniform_space (has_div (mul_one_class char))) : complete_space (has_div (mul_one_class char)) := sorry --non-trivial
lemma new_lemma_130005 (h0 : topological_space (canonically_ordered_comm_semiring (option empty))) : preirreducible_space (canonically_ordered_comm_semiring (option empty)) := sorry --non-trivial
lemma new_lemma_130006 (h1 : set (normed_field (mul_one_class (mul_one_class (mul_one_class std_gen))))) : set.finite h1 := sorry --non-trivial
lemma new_lemma_130007 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @totally_disconnected_space.{0} (ring.{0} ennreal) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (ring.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_130008 (h0 : functor.add_const (function.extfun Type finset) Type) : finset.nonempty (function.extfun_app (functor.add_const.run h0) (has_neg name)) := sorry --non-trivial
lemma new_lemma_130009 (h1 : uniform_space (add_comm_semigroup char)) : complete_space (add_comm_semigroup char) := sorry --non-trivial
lemma new_lemma_130010 (h0 : functor.add_const (cancel_comm_monoid_with_zero (has_neg linarith.comp)) pos) : @unique_factorization_monoid.{0} (has_neg.{0} linarith.comp) (@functor.add_const.run.{0 0} (cancel_comm_monoid_with_zero.{0} (has_neg.{0} linarith.comp)) pos h0)  := sorry --non-trivial
lemma new_lemma_130011 (h0 : functor.add_const (list (has_to_string linarith.comp)) pos) : palindrome (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_130012 (h0 : ring (has_pos_part (has_add name))) : rank_condition (has_pos_part (has_add name)) := sorry --non-trivial
lemma new_lemma_130013 (h0 : functor.add_const (functor.add_const (ring Type) pos) Type) : @is_principal_ideal_ring.{1} Type (@functor.add_const.run.{1 0} (ring.{1} Type) pos (@functor.add_const.run.{1 1} (functor.add_const.{1 0} (ring.{1} Type) pos) Type h0))  := sorry --non-trivial
lemma new_lemma_130014 (h0 : topological_space (has_top linarith.comp)) : normal_space (has_top linarith.comp) := sorry --non-trivial
lemma new_lemma_130015 (h0 : topological_space (ring (option (option empty)))) : path_connected_space (ring (option (option empty))) := sorry --non-trivial
lemma new_lemma_130016 (h0 : ring (semi_normed_comm_ring (denumerable reducibility_hints))) : is_domain (semi_normed_comm_ring (denumerable reducibility_hints)) := sorry --non-trivial
lemma new_lemma_130017 (h0 : functor.add_const (list (left_cancel_monoid unsigned)) congr_arg_kind) : list.nodup (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_130018 (h0 : group (dlist (random_gen (random_gen (random_gen linarith.ineq))))) : is_cyclic (dlist (random_gen (random_gen (random_gen linarith.ineq)))) := sorry --non-trivial
lemma new_lemma_130019 (h0 : group (complete_semilattice_Sup (has_top linarith.ineq))) : group.fg (complete_semilattice_Sup (has_top linarith.ineq)) := sorry --non-trivial
lemma new_lemma_130020 (h0 : add_group (fintype num)) : is_add_cyclic (fintype num) := sorry --non-trivial
lemma new_lemma_130021 (h0 : function.extfun Type group) : @group.fg.{0} (cancel_monoid.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type group.{0} h0 (cancel_monoid.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_130022 (h0 : functor.add_const (semiring (has_zero Type)) Type) : @is_noetherian_ring.{1} (has_zero.{1} Type) (@functor.add_const.run.{1 1} (semiring.{1} (has_zero.{1} Type)) Type h0)  := sorry --non-trivial
lemma new_lemma_130023 (h0 : topological_space (with_bot (random_gen (random_gen linarith.ineq)))) : locally_compact_space (with_bot (random_gen (random_gen linarith.ineq))) := sorry --non-trivial
lemma new_lemma_130024 (h0 : group (uniform_space char)) : is_cyclic (uniform_space char) := sorry --non-trivial
lemma new_lemma_130025 (h0 : ring (add_comm_monoid (has_add (has_add unsigned)))) : rank_condition (add_comm_monoid (has_add (has_add unsigned))) := sorry --non-trivial
lemma new_lemma_130026 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @archimedean.{0} (pseudo_metric_space.{0} pos) (@function.extfun_app.{2 1} Type ordered_add_comm_monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ordered_add_comm_monoid.{0}) (pseudo_metric_space.{0} pos))  := sorry --non-trivial
lemma new_lemma_130027 (h0 : ordered_add_comm_monoid (has_add (comm_group (measurable_space linarith.comp)))) : archimedean (has_add (comm_group (measurable_space linarith.comp))) := sorry --non-trivial
lemma new_lemma_130028 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @normalizer_condition.{0} (omega_complete_partial_order.{0} empty) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (omega_complete_partial_order.{0} empty))  := sorry --non-trivial
lemma new_lemma_130029 (h0 : function.extfun Type topological_space) : @normal_space.{0} (linear_ordered_field.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (linear_ordered_field.{0} pos))  := sorry --non-trivial
lemma new_lemma_130030 (h0 : functor.add_const (function.extfun Type ring) pos) : @strong_rank_condition.{0} (ring.{0} pos) (@function.extfun_app.{2 1} Type ring.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type ring.{0}) pos h0) (ring.{0} pos))  := sorry --non-trivial
lemma new_lemma_130031 (h0 : topological_space (comm_ring (has_top to_additive.value_type))) : t0_space (comm_ring (has_top to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_130032 (h0 : prod (add_group (semiring empty)) (add_group (semiring empty))) : id_rel h0 := sorry --non-trivial
lemma new_lemma_130033 (h0 : topological_space (has_neg (finset Type))) : normal_space (has_neg (finset Type)) := sorry --non-trivial
lemma new_lemma_130034 (h0 : function.extfun Type (functor.add_const (ring (has_star unsigned)))) : @is_principal_ideal_ring.{0} (has_star.{0} unsigned) (@functor.add_const.run.{0 0} (ring.{0} (has_star.{0} unsigned)) empty (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (ring.{0} (has_star.{0} unsigned))) h0 empty))  := sorry --non-trivial
lemma new_lemma_130035 (h0 : topological_space (simple_graph (ring (ring pos)))) : sequential_space (simple_graph (ring (ring pos))) := sorry --non-trivial
lemma new_lemma_130036 (h0 : group (linear_ordered_field congr_arg_kind)) : is_cyclic (linear_ordered_field congr_arg_kind) := sorry --non-trivial
lemma new_lemma_130037 (h0 : functor.add_const (filter (has_zero pos)) Type) : countable_Inter_filter (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_130038 (h0 : functor.add_const (function.extfun Type uniform_space) linarith.comp) : @separated_space.{0} (complete_distrib_lattice.{0} pos) (@function.extfun_app.{2 1} Type uniform_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type uniform_space.{0}) linarith.comp h0) (complete_distrib_lattice.{0} pos))  := sorry --non-trivial
lemma new_lemma_130039 (h0 : not (function.extfun Type complete_lattice -> false)) : @complete_lattice.is_Sup_finite_compact.{0} (has_norm.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type complete_lattice.{0}) h0) (has_norm.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_130040 (h0 : functor.add_const (finset (ring environment.implicit_infer_kind)) (semigroup (has_add (has_add Type)))) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_130041 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_noetherian_ring.{0} (has_add.{0} pos) (@function.extfun_app.{2 1} Type semiring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 semiring.{0}) (has_add.{0} pos))  := sorry --non-trivial
lemma new_lemma_130042 (h0 : complete_lattice (id (with_bot (with_bot string_imp)))) : is_atomistic (id (with_bot (with_bot string_imp))) := sorry --non-trivial
lemma new_lemma_130043 (h0 : list (canonically_ordered_comm_semiring name)) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_130044 (h0 : topological_space (has_inv fun_info)) : t0_space (has_inv fun_info) := sorry --non-trivial
lemma new_lemma_130045 (h0 : not (has_mem.mem linarith.ineq has_emptyc.emptyc -> false)) : @totally_separated_space.{0} linarith.ineq (@finset.pi.empty.{1 0} Type topological_space.{0} linarith.ineq (@classical.by_contradiction'.{0} (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) linarith.ineq (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))) h0))  := sorry --non-trivial
lemma new_lemma_130046 (h0 : add_group (boolean_algebra.core (has_add linarith.comp))) : is_add_cyclic (boolean_algebra.core (has_add linarith.comp)) := sorry --non-trivial
lemma new_lemma_130047 (h0 : uniform_space (ordered_cancel_add_comm_monoid num)) : separated_space (ordered_cancel_add_comm_monoid num) := sorry --non-trivial
lemma new_lemma_130048 (h0 : function.extfun (finset Type) (has_mem.mem (has_top linarith.comp_source))) : @is_add_cyclic.{0} (has_top.{0} linarith.comp_source) (@finset.pi.empty.{1 0} Type add_group.{0} (has_top.{0} linarith.comp_source) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (has_top.{0} linarith.comp_source)) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_130049 (h0 : topological_space (ordered_comm_monoid (has_neg name))) : preconnected_space (ordered_comm_monoid (has_neg name)) := sorry --non-trivial
lemma new_lemma_130050 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_simple_group.{0} (boolean_algebra.core.{0} name) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (boolean_algebra.core.{0} name))  := sorry --non-trivial
lemma new_lemma_130051 (h0 : not (topological_space (plift congr_arg_kind) -> false)) : @discrete_topology.{1} (plift.{1} congr_arg_kind) (@classical.by_contradiction'.{2} (topological_space.{1} (plift.{1} congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_130052 (h0 : topological_space (canonically_linear_ordered_monoid (has_Inf (has_neg real)))) : locally_compact_space (canonically_linear_ordered_monoid (has_Inf (has_neg real))) := sorry --non-trivial
lemma new_lemma_130053 (h0 : functor.add_const (functor.add_const (list (boolean_algebra pos)) linarith.comp) name) : palindrome (functor.add_const.run (functor.add_const.run h0)) := sorry --non-trivial
lemma new_lemma_130054 (h0 : group (with_one (has_top (has_top fun_info)))) : normalizer_condition (with_one (has_top (has_top fun_info))) := sorry --non-trivial
lemma new_lemma_130055 (h0 : topological_space (has_norm (has_top (with_bot fun_info)))) : path_connected_space (has_norm (has_top (with_bot fun_info))) := sorry --non-trivial
lemma new_lemma_130056 (h0 : functor.add_const (group (has_to_string name)) (has_neg (has_neg linarith.comp))) : @normalizer_condition.{0} (has_to_string.{0} name) (@functor.add_const.run.{0 0} (group.{0} (has_to_string.{0} name)) (has_neg.{0} (has_neg.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_130057 (h0 : measurable_space string.iterator_imp) (h1 : measure_theory.measure string.iterator_imp) : measure_theory.measure.is_complete h1 := sorry --non-trivial
lemma new_lemma_130058 (h0 : functor.add_const (topological_space (linear_order empty)) num) : @t0_space.{0} (linear_order.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (linear_order.{0} empty)) num h0)  := sorry --non-trivial
lemma new_lemma_130059 (h0 : ring (random_gen (comm_ring linarith.comp_source))) : is_domain (random_gen (comm_ring linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_130060 (h2 : topological_space (denumerable reducibility_hints)) : t0_space (denumerable reducibility_hints) := sorry --non-trivial
lemma new_lemma_130061 (h0 : ordered_comm_monoid (canonically_ordered_monoid Type)) : has_exists_mul_of_le (canonically_ordered_monoid Type) := sorry --non-trivial
lemma new_lemma_130062 (h0 : functor.add_const (complete_lattice (has_repr empty)) unsigned) : @is_compactly_generated.{0} (has_repr.{0} empty) (@functor.add_const.run.{0 0} (complete_lattice.{0} (has_repr.{0} empty)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_130063 (h0 : function.extfun Type finset) : finset.nonempty (function.extfun_app h0 (sub_neg_monoid ennreal)) := sorry --non-trivial
lemma new_lemma_130064 (h0 : uniform_space (normed_lattice_add_comm_group name)) : complete_space (normed_lattice_add_comm_group name) := sorry --non-trivial
lemma new_lemma_130065 (h1 : add_group (nondiscrete_normed_field (plift (mul_one_class linarith.ineq)))) : is_add_cyclic (nondiscrete_normed_field (plift (mul_one_class linarith.ineq))) := sorry --non-trivial
lemma new_lemma_130066 (h0 : functor.add_const (uniform_space (ordered_cancel_comm_monoid num)) unsigned) : @complete_space.{0} (ordered_cancel_comm_monoid.{0} num) (@functor.add_const.run.{0 0} (uniform_space.{0} (ordered_cancel_comm_monoid.{0} num)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_130067 (h1 : topological_space (add_zero_class (random_gen char))) : t0_space (add_zero_class (random_gen char)) := sorry --non-trivial
lemma new_lemma_130068 (h0 : filter (has_dist (option empty))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_130069 (h0 : set (distrib (non_unital_non_assoc_semiring linarith.ineq))) : set.finite h0 := sorry --non-trivial
lemma new_lemma_130070 (h0 : list (cancel_monoid (normed_comm_ring environment.implicit_infer_kind))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_130071 (h0 : monoid (has_nndist (option ennreal))) : monoid.fg (has_nndist (option ennreal)) := sorry --non-trivial
lemma new_lemma_130072 (h0 : functor.add_const (complete_lattice (has_neg Type)) linarith.comp) : @complete_lattice.is_Sup_finite_compact.{1} (has_neg.{1} Type) (@functor.add_const.run.{1 0} (complete_lattice.{1} (has_neg.{1} Type)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_130073 (h0 : functor.add_const (uniform_space (add_cancel_monoid linarith.comp)) linarith.comp) : @separated_space.{0} (add_cancel_monoid.{0} linarith.comp) (@functor.add_const.run.{0 0} (uniform_space.{0} (add_cancel_monoid.{0} linarith.comp)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_130074 (h0 : functor.add_const (list (ordered_comm_ring Type)) pos) : list.nodup (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_130075 (h0 : function.extfun Type group) : @group.fg.{0} (random_gen.{0} (has_top.{0} fun_info)) (@function.extfun_app.{2 1} Type group.{0} h0 (random_gen.{0} (has_top.{0} fun_info)))  := sorry --non-trivial
lemma new_lemma_130076 (h0 : topological_space (monoid (option num))) : loc_path_connected_space (monoid (option num)) := sorry --non-trivial
lemma new_lemma_130077 (h0 : fin has_zero.zero) : @strong_rank_condition.{0} (has_pos_part.{0} name) (@matrix.vec_empty.{0} (ring.{0} (has_pos_part.{0} name)) h0)  := sorry --non-trivial
lemma new_lemma_130078 (h0 : functor.add_const (ordered_add_comm_monoid (has_Inf linarith.comp)) (ring pos)) : @archimedean.{0} (has_Inf.{0} linarith.comp) (@functor.add_const.run.{0 0} (ordered_add_comm_monoid.{0} (has_Inf.{0} linarith.comp)) (ring.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_130079 (h0 : function.extfun Type topological_space) : @normal_space.{0} (has_union.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_union.{0} empty))  := sorry --non-trivial
lemma new_lemma_130080 (h0 : has_mem.mem to_additive.value_type has_emptyc.emptyc) : @normalizer_condition.{0} to_additive.value_type (@finset.pi.empty.{1 0} Type group.{0} to_additive.value_type h0)  := sorry --non-trivial
lemma new_lemma_130081 (h0 : function.extfun Type monoid) : @monoid.fg.{0} (boolean_algebra.{0} pos) (@function.extfun_app.{2 1} Type monoid.{0} h0 (boolean_algebra.{0} pos))  := sorry --non-trivial
lemma new_lemma_130082 (h0 : function.extfun Type add_group) : @is_add_cyclic.{0} (metric_space.{0} num) (@function.extfun_app.{2 1} Type add_group.{0} h0 (metric_space.{0} num))  := sorry --non-trivial
lemma new_lemma_130083 (h0 : list (normed_comm_ring num)) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_130084 (h0 : functor.add_const (topological_space (boolean_algebra.core environment.implicit_infer_kind)) (has_neg name)) : @totally_disconnected_space.{0} (boolean_algebra.core.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (boolean_algebra.core.{0} environment.implicit_infer_kind)) (has_neg.{0} name) h0)  := sorry --non-trivial
lemma new_lemma_130085 (h0 : complete_lattice (uniform_space (has_neg enat))) : complete_lattice.is_Sup_finite_compact (uniform_space (has_neg enat)) := sorry --non-trivial
lemma new_lemma_130086 (h0 : ring (has_add fun_info)) : is_domain (has_add fun_info) := sorry --non-trivial
lemma new_lemma_130087 (h0 : function.extfun Type list) : palindrome (function.extfun_app h0 (ring empty)) := sorry --non-trivial
lemma new_lemma_130088 (h0 : fin has_zero.zero) : @group.fg.{0} (has_add.{0} linarith.comp) (@matrix.vec_empty.{0} (group.{0} (has_add.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_130089 (h0 : complete_lattice (has_add (semigroup linarith.comp))) : complete_lattice.is_Sup_finite_compact (has_add (semigroup linarith.comp)) := sorry --non-trivial
lemma new_lemma_130090 (h0 : not (function.extfun Type topological_space -> false)) : @path_connected_space.{0} (random_gen.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (random_gen.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_130091 (h0 : has_mem.mem (id num) has_emptyc.emptyc) : @path_connected_space.{0} (@id.{2} Type num) (@finset.pi.empty.{1 0} Type topological_space.{0} (@id.{2} Type num) h0)  := sorry --non-trivial
lemma new_lemma_130092 (h0 : add_group (boolean_algebra.core empty)) : is_add_cyclic (boolean_algebra.core empty) := sorry --non-trivial
lemma new_lemma_130093 (h0 : semiring (has_zero environment.implicit_infer_kind)) : is_noetherian_ring (has_zero environment.implicit_infer_kind) := sorry --non-trivial
lemma new_lemma_130094 (h0 : has_mem.mem (has_norm congr_arg_kind) has_emptyc.emptyc) : @normalizer_condition.{0} (has_norm.{0} congr_arg_kind) (@finset.pi.empty.{1 0} Type group.{0} (has_norm.{0} congr_arg_kind) h0)  := sorry --non-trivial
lemma new_lemma_130095 (h0 : uniform_space enat) : complete_space enat := sorry --non-trivial
lemma new_lemma_130096 (h0 : function.extfun Type filter) : countable_Inter_filter (function.extfun_app h0 (option pos)) := sorry --non-trivial
lemma new_lemma_130097 (h0 : ring (denumerable (random_gen (has_nnnorm (has_nnnorm fun_info))))) : rank_condition (denumerable (random_gen (has_nnnorm (has_nnnorm fun_info)))) := sorry --non-trivial
lemma new_lemma_130098 (h0 : topological_space (has_neg_part (has_add (cancel_monoid name)))) : sequential_space (has_neg_part (has_add (cancel_monoid name))) := sorry --non-trivial
lemma new_lemma_130099 (h0 : group (canonically_ordered_monoid (has_bot real))) : is_cyclic (canonically_ordered_monoid (has_bot real)) := sorry --non-trivial
lemma new_lemma_130100 (h0 : group (is_R_or_C (option empty))) : is_cyclic (is_R_or_C (option empty)) := sorry --non-trivial
lemma new_lemma_130101 (h0 : group (has_nndist (has_nndist (ring pos)))) : normalizer_condition (has_nndist (has_nndist (ring pos))) := sorry --non-trivial
lemma new_lemma_130102 (h0 : function.extfun Type topological_space) : @t0_space.{0} (has_add.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_add.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_130103 (h0 : add_group (non_assoc_semiring (option (semiring empty)))) : is_add_cyclic (non_assoc_semiring (option (semiring empty))) := sorry --non-trivial
lemma new_lemma_130104 (h0 : functor.add_const (add_group (finset linarith.comp)) name) : @is_add_cyclic.{0} (finset.{0} linarith.comp) (@functor.add_const.run.{0 0} (add_group.{0} (finset.{0} linarith.comp)) name h0)  := sorry --non-trivial
lemma new_lemma_130105 (h0 : topological_space (add_comm_monoid (has_to_string congr_arg_kind))) : discrete_topology (add_comm_monoid (has_to_string congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_130106 (h0 : topological_space (left_cancel_semigroup num)) : topological_space.separable_space (left_cancel_semigroup num) := sorry --non-trivial
lemma new_lemma_130107 (h0 : function.extfun Type (functor.add_const (topological_space (ring linarith.comp)))) : @t1_space.{0} (ring.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (ring.{0} linarith.comp)) pos (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (topological_space.{0} (ring.{0} linarith.comp))) h0 pos))  := sorry --non-trivial
lemma new_lemma_130108 (h0 : cancel_comm_monoid_with_zero (has_Inf (has_pos_part pos))) : unique_factorization_monoid (has_Inf (has_pos_part pos)) := sorry --non-trivial
lemma new_lemma_130109 (h0 : finset (has_neg (has_neg linarith.comp))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_130110 (h0 : add_group (denumerable (denumerable reducibility_hints))) : is_add_cyclic (denumerable (denumerable reducibility_hints)) := sorry --non-trivial
lemma new_lemma_130111 (h0 : complete_lattice (has_union (has_norm (semiring unsigned)))) : complete_lattice.is_Sup_finite_compact (has_union (has_norm (semiring unsigned))) := sorry --non-trivial
lemma new_lemma_130112 (h0 : functor.add_const (filter znum) unsigned) : filter.ne_bot (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_130113 (h0 : has_mem.mem (measurable_space num) has_emptyc.emptyc) : @totally_disconnected_space.{0} (measurable_space.{0} num) (@finset.pi.empty.{1 0} Type topological_space.{0} (measurable_space.{0} num) h0)  := sorry --non-trivial
lemma new_lemma_130114 (h0 : topological_space (with_one (semiring linarith.comp))) : normal_space (with_one (semiring linarith.comp)) := sorry --non-trivial
lemma new_lemma_130115 (h0 : function.extfun Type topological_space) : @t0_space.{0} (measurable_space.{0} fun_info) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (measurable_space.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_130116 (h0 : functor.add_const (topological_space (has_nndist name)) pos) : @locally_compact_space.{0} (has_nndist.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (has_nndist.{0} name)) pos h0)  := sorry --non-trivial
lemma new_lemma_130117 (h0 : topological_space (ring name)) : totally_separated_space (ring name) := sorry --non-trivial
lemma new_lemma_130118 (h0 : functor.add_const (complete_lattice (has_zero pos)) linarith.comp) : @is_compactly_generated.{0} (has_zero.{0} pos) (@functor.add_const.run.{0 0} (complete_lattice.{0} (has_zero.{0} pos)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_130119 (h0 : complete_lattice (has_lt (mul_one_class (linear_order (has_lt char))))) : is_compactly_generated (has_lt (mul_one_class (linear_order (has_lt char)))) := sorry --non-trivial
lemma new_lemma_130120 (h0 : function.extfun Type complete_lattice) : @is_compactly_generated.{0} (add_cancel_monoid.{0} linarith.comp) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (add_cancel_monoid.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_130121 (h0 : functor.add_const (topological_space (canonically_ordered_comm_semiring Type)) Type) : @regular_space.{1} (canonically_ordered_comm_semiring.{1} Type) (@functor.add_const.run.{1 1} (topological_space.{1} (canonically_ordered_comm_semiring.{1} Type)) Type h0)  := sorry --non-trivial
lemma new_lemma_130122 (h0 : functor.add_const (monoid (has_Inf Type)) Type) : @monoid.fg.{1} (has_Inf.{1} Type) (@functor.add_const.run.{1 1} (monoid.{1} (has_Inf.{1} Type)) Type h0)  := sorry --non-trivial
lemma new_lemma_130123 (h0 : function.extfun Type topological_space) : @irreducible_space.{0} (monoid_with_zero.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (monoid_with_zero.{0} pos))  := sorry --non-trivial
lemma new_lemma_130124 (h0 : ring (distrib (has_ssubset linarith.comp_source))) : strong_rank_condition (distrib (has_ssubset linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_130125 (h0 : measurable_space (has_neg std_gen)) (h1 : filter (has_neg std_gen)) : filter.is_measurably_generated h1 := sorry --non-trivial
lemma new_lemma_130126 (h1 : ring (has_compl (metric_space string_imp))) : rank_condition (has_compl (metric_space string_imp)) := sorry --non-trivial
lemma new_lemma_130127 (h0 : topological_space (has_zero (add_comm_monoid unsigned))) : preirreducible_space (has_zero (add_comm_monoid unsigned)) := sorry --non-trivial
lemma new_lemma_130128 (h0 : functor.add_const (group (has_neg Type)) linarith.comp) : @is_cyclic.{1} (has_neg.{1} Type) (@functor.add_const.run.{1 0} (group.{1} (has_neg.{1} Type)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_130129 (h0 : complete_lattice (dlist (random_gen to_additive.value_type))) : complete_lattice.is_Sup_finite_compact (dlist (random_gen to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_130130 (h0 : topological_space (comm_group (has_nndist pos))) : locally_compact_space (comm_group (has_nndist pos)) := sorry --non-trivial
lemma new_lemma_130131 (h0 : topological_space (generalized_boolean_algebra (has_neg linarith.comp))) : regular_space (generalized_boolean_algebra (has_neg linarith.comp)) := sorry --non-trivial
lemma new_lemma_130132 (h0 : topological_space (has_inv (random_gen (has_inv (random_gen (random_gen linarith.ineq)))))) : totally_disconnected_space (has_inv (random_gen (has_inv (random_gen (random_gen linarith.ineq))))) := sorry --non-trivial
lemma new_lemma_130133 (h0 : topological_space (pseudo_metric_space name)) : locally_compact_space (pseudo_metric_space name) := sorry --non-trivial
lemma new_lemma_130134 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @discrete_topology.{1} (normed_comm_ring.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 topological_space.{1}) (normed_comm_ring.{1} Type))  := sorry --non-trivial
lemma new_lemma_130135 (h1 : topological_space (with_bot (random_gen string_imp))) : locally_compact_space (with_bot (random_gen string_imp)) := sorry --non-trivial
lemma new_lemma_130136 (h0 : function.extfun Type topological_space) : @totally_separated_space.{0} (add_group.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (add_group.{0} num))  := sorry --non-trivial
lemma new_lemma_130137 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @discrete_topology.{0} (finset.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (finset.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_130138 (h0 : semiring (ordered_comm_ring (has_add (has_pos_part Type)))) : is_noetherian_ring (ordered_comm_ring (has_add (has_pos_part Type))) := sorry --non-trivial
lemma new_lemma_130139 (h0 : group (has_top (random_gen (has_top (has_top (has_top (has_top (has_top (has_top fun_info))))))))) : group.fg (has_top (random_gen (has_top (has_top (has_top (has_top (has_top (has_top fun_info)))))))) := sorry --non-trivial
lemma new_lemma_130140 (h0 : functor.add_const (topological_space (boolean_algebra Type)) pos) : @preirreducible_space.{1} (boolean_algebra.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (boolean_algebra.{1} Type)) pos h0)  := sorry --non-trivial
lemma new_lemma_130141 (h0 : functor.add_const (topological_space (free_add_monoid congr_arg_kind)) num) : @normal_space.{0} (free_add_monoid.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (free_add_monoid.{0} congr_arg_kind)) num h0)  := sorry --non-trivial
lemma new_lemma_130142 (h0 : topological_space (linear_ordered_comm_ring (has_top empty))) : preirreducible_space (linear_ordered_comm_ring (has_top empty)) := sorry --non-trivial
lemma new_lemma_130143 (h0 : function.extfun Type ring) : @rank_condition.{0} (has_emptyc.{0} empty) (@function.extfun_app.{2 1} Type ring.{0} h0 (has_emptyc.{0} empty))  := sorry --non-trivial
lemma new_lemma_130144 (h0 : group (with_one (has_top to_additive.value_type))) : normalizer_condition (with_one (has_top to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_130145 (h0 : function.extfun Type monoid) : @monoid.fg.{0} (partial_order.{0} (semiring.{0} (semiring.{0} (semiring.{0} (semiring.{0} (semiring.{0} congr_arg_kind)))))) (@function.extfun_app.{2 1} Type monoid.{0} h0 (partial_order.{0} (semiring.{0} (semiring.{0} (semiring.{0} (semiring.{0} (semiring.{0} congr_arg_kind)))))))  := sorry --non-trivial
lemma new_lemma_130146 (h0 : ring (canonically_ordered_monoid (has_bot Type))) : strong_rank_condition (canonically_ordered_monoid (has_bot Type)) := sorry --non-trivial
lemma new_lemma_130147 (h0 : topological_space (simple_graph (boolean_algebra Type))) : t0_space (simple_graph (boolean_algebra Type)) := sorry --non-trivial
lemma new_lemma_130148 (h0 : ring (has_zero (ring environment.implicit_infer_kind))) : is_principal_ideal_ring (has_zero (ring environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_130149 (h0 : topological_space (has_add (comm_ring fun_info))) : path_connected_space (has_add (comm_ring fun_info)) := sorry --non-trivial
lemma new_lemma_130150 (h0 : functor.add_const (function.extfun (Type 1) topological_space) linarith.comp) : @totally_separated_space.{1} (has_pos_part.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) topological_space.{1}) linarith.comp h0) (has_pos_part.{1} Type))  := sorry --non-trivial
lemma new_lemma_130151 (h0 : functor.add_const (function.extfun (Type 1) uniform_space) pos) : @separated_space.{1} (add_cancel_monoid.{1} Type) (@function.extfun_app.{3 2} (Type 1) uniform_space.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) uniform_space.{1}) pos h0) (add_cancel_monoid.{1} Type))  := sorry --non-trivial
lemma new_lemma_130152 (h0 : function.extfun Type topological_space) : @t1_space.{0} (monoid.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (monoid.{0} num))  := sorry --non-trivial
lemma new_lemma_130153 (h0 : function.extfun Type complete_lattice) : @is_atomistic.{0} (has_top.{0} num) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (has_top.{0} num))  := sorry --non-trivial
lemma new_lemma_130154 (h0 : group (semigroup (ring linarith.comp))) : is_simple_group (semigroup (ring linarith.comp)) := sorry --non-trivial
lemma new_lemma_130155 (h0 : complete_lattice (id fun_info)) : is_atomistic (id fun_info) := sorry --non-trivial
lemma new_lemma_130156 (h0 : functor.add_const (semiring (add_comm_monoid Type)) pos) : @is_noetherian_ring.{1} (add_comm_monoid.{1} Type) (@functor.add_const.run.{1 0} (semiring.{1} (add_comm_monoid.{1} Type)) pos h0)  := sorry --non-trivial
lemma new_lemma_130157 (h0 : ring (has_neg (comm_group pos))) : is_domain (has_neg (comm_group pos)) := sorry --non-trivial
lemma new_lemma_130158 (h0 : ring (canonically_ordered_comm_semiring (option pos))) : rank_condition (canonically_ordered_comm_semiring (option pos)) := sorry --non-trivial
lemma new_lemma_130159 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @totally_disconnected_space.{0} (finset.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (finset.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_130160 (h0 : topological_space (normed_comm_ring (has_to_string pos))) : topological_space.separable_space (normed_comm_ring (has_to_string pos)) := sorry --non-trivial
lemma new_lemma_130161 (h0 : topological_space (has_zero (normed_comm_ring Type))) : locally_compact_space (has_zero (normed_comm_ring Type)) := sorry --non-trivial
lemma new_lemma_130162 (h0 : monoid (random_gen (semiring unsigned))) : monoid.fg (random_gen (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_130163 (h0 : not (function.extfun Type complete_lattice -> false)) : @is_atomistic.{0} (has_emptyc.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type complete_lattice.{0}) h0) (has_emptyc.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_130164 (h0 : has_mem.mem uniform_space has_emptyc.emptyc) : @complete_space.{0} (measurable_space.{0} empty) (@function.extfun_app.{2 1} Type uniform_space.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) uniform_space.{0} h0) (measurable_space.{0} empty))  := sorry --non-trivial
lemma new_lemma_130165 (h0 : topological_space (semi_normed_comm_ring std_gen)) (h1 : preorder (semi_normed_comm_ring std_gen)) : order_closed_topology (semi_normed_comm_ring std_gen) := sorry --non-trivial
lemma new_lemma_130166 (h0 : topological_space (measure_theory.measure_space (semiring unsigned))) : preirreducible_space (measure_theory.measure_space (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_130167 (h0 : filter (dlist (random_gen (random_gen linarith.ineq)))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_130168 (h0 : functor.add_const (ordered_add_comm_monoid (has_nndist linarith.comp)) (has_to_string unsigned)) : @archimedean.{0} (has_nndist.{0} linarith.comp) (@functor.add_const.run.{0 0} (ordered_add_comm_monoid.{0} (has_nndist.{0} linarith.comp)) (has_to_string.{0} unsigned) h0)  := sorry --non-trivial
lemma new_lemma_130169 (h0 : list (monoid_with_zero (has_neg pos))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_130170 (h0 : cancel_comm_monoid_with_zero (add_group (option num))) : unique_factorization_monoid (add_group (option num)) := sorry --non-trivial
lemma new_lemma_130171 (h0 : group (comm_group (has_to_string Type))) : group.fg (comm_group (has_to_string Type)) := sorry --non-trivial
lemma new_lemma_130172 (h0 : functor.add_const (topological_space (plift num)) (semiring (semiring congr_arg_kind))) : @irreducible_space.{1} (plift.{1} num) (@functor.add_const.run.{1 0} (topological_space.{1} (plift.{1} num)) (semiring.{0} (semiring.{0} congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_130173 (h0 : list (add_comm_monoid unsigned)) : palindrome h0 := sorry --non-trivial
lemma new_lemma_130174 (h0 : topological_space (has_nndist (has_add environment.implicit_infer_kind))) : t0_space (has_nndist (has_add environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_130175 (h0 : functor.add_const (add_monoid (preorder unsigned)) num) : @add_monoid.fg.{0} (preorder.{0} unsigned) (@functor.add_const.run.{0 0} (add_monoid.{0} (preorder.{0} unsigned)) num h0)  := sorry --non-trivial
lemma new_lemma_130176 (h0 : topological_space (add_left_cancel_semigroup (option (option empty)))) : loc_path_connected_space (add_left_cancel_semigroup (option (option empty))) := sorry --non-trivial
lemma new_lemma_130177 (h0 : topological_space (nondiscrete_normed_field linarith.ineq)) (h1 : preorder (nondiscrete_normed_field linarith.ineq)) : order_topology (nondiscrete_normed_field linarith.ineq) := sorry --non-trivial
lemma new_lemma_130178 (h0 : topological_space (measurable_space (random_gen (has_inv linarith.comp_source)))) : totally_separated_space (measurable_space (random_gen (has_inv linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_130179 (h0 : not (add_monoid (complete_semilattice_Sup empty) -> false)) : @add_monoid.fg.{0} (complete_semilattice_Sup.{0} empty) (@classical.by_contradiction'.{1} (add_monoid.{0} (complete_semilattice_Sup.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_130180 (h0 : functor.add_const (monoid (ring name)) (has_to_string pos)) : @monoid.fg.{0} (ring.{0} name) (@functor.add_const.run.{0 0} (monoid.{0} (ring.{0} name)) (has_to_string.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_130181 (h0 : topological_space (boolean_algebra (has_Inf pos))) : sequential_space (boolean_algebra (has_Inf pos)) := sorry --non-trivial
lemma new_lemma_130182 (h0 : function.extfun (finset (Type -> Type)) (has_mem.mem group)) : @normalizer_condition.{0} congr_arg_kind (@function.extfun_app.{2 1} Type group.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) group.{0} (@function.extfun_app.{2 0} (finset.{1} (Type → Type)) (@has_mem.mem.{1 1} (Type → Type) (finset.{1} (Type → Type)) (@finset.has_mem.{1} (Type → Type)) group.{0}) h0 (@has_emptyc.emptyc.{1} (finset.{1} (Type → Type)) (@finset.has_emptyc.{1} (Type → Type))))) congr_arg_kind)  := sorry --non-trivial
lemma new_lemma_130183 (h1 : topological_space (distrib (has_nnnorm char))) : path_connected_space (distrib (has_nnnorm char)) := sorry --non-trivial
lemma new_lemma_130184 (h0 : monoid (complete_semilattice_Sup (has_top to_additive.value_type))) : monoid.fg (complete_semilattice_Sup (has_top to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_130185 (h1 : ring (mul_one_class (mul_one_class fun_info))) : strong_rank_condition (mul_one_class (mul_one_class fun_info)) := sorry --non-trivial
lemma new_lemma_130186 (h0 : function.extfun Type complete_lattice) : @complete_lattice.is_Sup_finite_compact.{0} (random_gen.{0} linarith.comp) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (random_gen.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_130187 (h0 : topological_space (has_one (has_norm linarith.comp))) : t0_space (has_one (has_norm linarith.comp)) := sorry --non-trivial
lemma new_lemma_130188 (h0 : topological_space (normed_comm_ring (option (option empty)))) : t1_space (normed_comm_ring (option (option empty))) := sorry --non-trivial
lemma new_lemma_130189 (h0 : functor.add_const (function.extfun (Type 1) ring) Type) : @is_domain.{1} (has_to_string.{1} Type) (@function.extfun_app.{3 2} (Type 1) ring.{1} (@functor.add_const.run.{2 1} (function.extfun.{3 2} (Type 1) ring.{1}) Type h0) (has_to_string.{1} Type))  := sorry --non-trivial
lemma new_lemma_130190 (h0 : filter (semigroup (comm_group (has_neg_part (has_neg_part Type))))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_130191 (h0 : functor.add_const (group (has_zero pos)) (has_to_string Type)) : @is_cyclic.{0} (has_zero.{0} pos) (@functor.add_const.run.{0 1} (group.{0} (has_zero.{0} pos)) (has_to_string.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_130192 (h0 : topological_space (cancel_monoid (has_add pos))) : totally_separated_space (cancel_monoid (has_add pos)) := sorry --non-trivial
lemma new_lemma_130193 (h0 : topological_space (has_edist char)) : t0_space (has_edist char) := sorry --non-trivial
lemma new_lemma_130194 (h0 : filter (distrib_lattice (random_gen (random_gen (has_top linarith.comp_source))))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_130195 (h0 : monoid (complete_semilattice_Sup (random_gen (has_top (has_inv linarith.comp_source))))) : monoid.fg (complete_semilattice_Sup (random_gen (has_top (has_inv linarith.comp_source)))) := sorry --non-trivial
lemma new_lemma_130196 (h0 : function.extfun Type ring) : @is_domain.{0} (has_nndist.{0} linarith.comp) (@function.extfun_app.{2 1} Type ring.{0} h0 (has_nndist.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_130197 (h0 : function.extfun Type add_monoid) : @add_monoid.fg.{0} (normed_lattice_add_comm_group.{0} unsigned) (@function.extfun_app.{2 1} Type add_monoid.{0} h0 (normed_lattice_add_comm_group.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_130198 (h0 : topological_space (has_scalar (has_add (has_add (has_add real))) (sub_neg_monoid real))) : t1_space (has_scalar (has_add (has_add (has_add real))) (sub_neg_monoid real)) := sorry --non-trivial
lemma new_lemma_130199 (h0 : ordered_comm_monoid (add_comm_monoid (ring linarith.comp))) : has_exists_mul_of_le (add_comm_monoid (ring linarith.comp)) := sorry --non-trivial
lemma new_lemma_130200 (h0 : fin has_zero.zero) : @is_atomistic.{0} (has_to_string.{0} real) (@matrix.vec_empty.{0} (complete_lattice.{0} (has_to_string.{0} real)) h0)  := sorry --non-trivial
lemma new_lemma_130201 (h1 : function.extfun Type complete_lattice) : @is_atomistic.{0} (random_gen.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type complete_lattice.{0} h1 (random_gen.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_130202 (h0 : functor.add_const (list (pseudo_metric_space name)) (option unsigned)) : palindrome (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_130203 (h0 : function.extfun Type list) : list.nodup (function.extfun_app h0 (dlist to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_130204 (h0 : functor.add_const (finset (boolean_algebra pos)) pos) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_130205 (h0 : topological_space (has_nndist (normed_comm_ring pos))) : totally_separated_space (has_nndist (normed_comm_ring pos)) := sorry --non-trivial
lemma new_lemma_130206 (h0 : not (ring (linear_ordered_add_comm_group char) -> false)) : @strong_rank_condition.{0} (linear_ordered_add_comm_group.{0} char) (@classical.by_contradiction'.{1} (ring.{0} (linear_ordered_add_comm_group.{0} char)) h0)  := sorry --non-trivial
lemma new_lemma_130207 (h0 : add_group (measurable_space unsigned)) : is_add_cyclic (measurable_space unsigned) := sorry --non-trivial
lemma new_lemma_130208 (h0 : function.extfun Type topological_space) : @totally_separated_space.{0} (finset.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (finset.{0} num))  := sorry --non-trivial
lemma new_lemma_130209 (h0 : semiring (has_zero (normed_comm_ring unsigned))) : is_noetherian_ring (has_zero (normed_comm_ring unsigned)) := sorry --non-trivial
lemma new_lemma_130210 (h0 : function.extfun Type list) : list.nodup (function.extfun_app h0 (add_cancel_comm_monoid unsigned)) := sorry --non-trivial
lemma new_lemma_130211 (h0 : function.extfun (finset Type -> Prop) (function.extfun (finset Type))) : @is_atomistic.{0} (has_one.{0} empty) (@finset.pi.empty.{1 0} Type complete_lattice.{0} (has_one.{0} empty) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (has_one.{0} empty)) (@function.extfun_app.{2 0} (finset.{1} Type → Prop) (function.extfun.{2 0} (finset.{1} Type)) h0 (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (has_one.{0} empty))) (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_130212 (h0 : topological_space linarith.ineq) (h1 : set (set linarith.ineq)) : topological_space.is_topological_basis h1 := sorry --non-trivial
lemma new_lemma_130213 (h0 : group (simple_graph linarith.comp)) : normalizer_condition (simple_graph linarith.comp) := sorry --non-trivial
lemma new_lemma_130214 (h0 : functor.add_const (topological_space (preorder num)) empty) : @totally_separated_space.{0} (preorder.{0} num) (@functor.add_const.run.{0 0} (topological_space.{0} (preorder.{0} num)) empty h0)  := sorry --non-trivial
lemma new_lemma_130215 (h0 : group (with_bot (random_gen (random_gen linarith.comp_source)))) : normalizer_condition (with_bot (random_gen (random_gen linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_130216 (h0 : topological_space (ordered_ring (semiring num))) : loc_path_connected_space (ordered_ring (semiring num)) := sorry --non-trivial
lemma new_lemma_130217 (h0 : add_group (has_top (random_gen (random_gen to_additive.value_type)))) : is_add_cyclic (has_top (random_gen (random_gen to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_130218 (h0 : monoid (metric_space string_imp)) (h1 : ring (star_monoid (metric_space string_imp))) : strong_rank_condition (star_monoid (metric_space string_imp)) := sorry --non-trivial
lemma new_lemma_130219 (h0 : filter (semiring (semiring (has_norm empty)))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_130220 (h0 : functor.add_const (topological_space (add_comm_monoid linarith.comp)) name) : @normal_space.{0} (add_comm_monoid.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (add_comm_monoid.{0} linarith.comp)) name h0)  := sorry --non-trivial
lemma new_lemma_130221 (h0 : function.extfun Type monoid) : @monoid.fg.{0} (as_linear_order.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type monoid.{0} h0 (as_linear_order.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_130222 (h0 : functor.add_const (complete_lattice (semigroup name)) (comm_group (has_neg_part (comm_group Type)))) : @is_atomistic.{0} (semigroup.{0} name) (@functor.add_const.run.{0 1} (complete_lattice.{0} (semigroup.{0} name)) (comm_group.{1} (has_neg_part.{1} (comm_group.{1} Type))) h0)  := sorry --non-trivial
lemma new_lemma_130223 (h0 : functor.add_const (topological_space nnreal) empty) : totally_separated_space nnreal := sorry --non-trivial
lemma new_lemma_130224 (h0 : functor.add_const (uniform_space (add_comm_monoid name)) Type) : @separated_space.{0} (add_comm_monoid.{0} name) (@functor.add_const.run.{0 1} (uniform_space.{0} (add_comm_monoid.{0} name)) Type h0)  := sorry --non-trivial
lemma new_lemma_130225 (h0 : functor.add_const (add_group (add_comm_monoid linarith.comp)) Type) : @is_add_cyclic.{0} (add_comm_monoid.{0} linarith.comp) (@functor.add_const.run.{0 1} (add_group.{0} (add_comm_monoid.{0} linarith.comp)) Type h0)  := sorry --non-trivial
lemma new_lemma_130226 (h0 : topological_space (nondiscrete_normed_field enat)) (h3 : add_group (nondiscrete_normed_field enat)) : topological_add_group (nondiscrete_normed_field enat) := sorry --non-trivial
lemma new_lemma_130227 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @group.fg.{0} (semigroup.{0} name) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (semigroup.{0} name))  := sorry --non-trivial
lemma new_lemma_130228 (h0 : measurable_space (has_to_string (has_add (has_add name)))) (h1 : has_add (has_to_string (has_add (has_add name)))) : has_measurable_add (has_to_string (has_add (has_add name))) := sorry --non-trivial
lemma new_lemma_130229 (h0 : topological_space (metric_space (metric_space to_additive.value_type))) : totally_disconnected_space (metric_space (metric_space to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_130230 (h0 : has_mem.mem (has_emptyc to_additive.value_type) has_emptyc.emptyc) : @rank_condition.{0} (has_emptyc.{0} to_additive.value_type) (@finset.pi.empty.{1 0} Type ring.{0} (has_emptyc.{0} to_additive.value_type) h0)  := sorry --non-trivial
lemma new_lemma_130231 (h0 : functor.add_const (ring (has_to_string pos)) linarith.comp) : @is_principal_ideal_ring.{0} (has_to_string.{0} pos) (@functor.add_const.run.{0 0} (ring.{0} (has_to_string.{0} pos)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_130232 (h0 : function.extfun (Type 1) ordered_add_comm_monoid) : @archimedean.{1} (finset.{1} Type) (@function.extfun_app.{3 2} (Type 1) ordered_add_comm_monoid.{1} h0 (finset.{1} Type))  := sorry --non-trivial
lemma new_lemma_130233 (h0 : functor.add_const (function.extfun Type ring) linarith.comp) : @is_domain.{0} (simple_graph.{0} pos) (@function.extfun_app.{2 1} Type ring.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type ring.{0}) linarith.comp h0) (simple_graph.{0} pos))  := sorry --non-trivial
lemma new_lemma_130234 (h0 : topological_space (ring (ring linarith.comp))) : normal_space (ring (ring linarith.comp)) := sorry --non-trivial
lemma new_lemma_130235 (h0 : topological_space (with_one (random_gen linarith.ineq))) : t0_space (with_one (random_gen linarith.ineq)) := sorry --non-trivial
lemma new_lemma_130236 (h0 : topological_space (has_neg (finset linarith.comp))) : t1_space (has_neg (finset linarith.comp)) := sorry --non-trivial
lemma new_lemma_130237 (h0 : function.extfun Type topological_space) : @totally_separated_space.{0} to_additive.value_type (@function.extfun_app.{2 1} Type topological_space.{0} h0 to_additive.value_type)  := sorry --non-trivial
lemma new_lemma_130238 (h0 : function.extfun Type ordered_add_comm_monoid) : @archimedean.{0} (mul_zero_class.{0} unsigned) (@function.extfun_app.{2 1} Type ordered_add_comm_monoid.{0} h0 (mul_zero_class.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_130239 (h0 : fin has_zero.zero) : @preirreducible_space.{0} (metric_space.{0} (metric_space.{0} empty)) (@matrix.vec_empty.{0} (topological_space.{0} (metric_space.{0} (metric_space.{0} empty))) h0)  := sorry --non-trivial
lemma new_lemma_130240 (h1 : ring environment.projection_info) : is_domain environment.projection_info := sorry --non-trivial
lemma new_lemma_130241 (h0 : complete_lattice (metric_space (metric_space to_additive.value_type))) : complete_lattice.is_Sup_finite_compact (metric_space (metric_space to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_130242 (h0 : monoid (partial_order empty)) : monoid.fg (partial_order empty) := sorry --non-trivial
lemma new_lemma_130243 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @totally_disconnected_space.{0} (random_gen.{0} linarith.ineq) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (random_gen.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_130244 (h0 : ring (has_sub (semiring (semiring num)))) : is_domain (has_sub (semiring (semiring num))) := sorry --non-trivial
lemma new_lemma_130245 (h0 : filter (has_pos_part (has_nndist pos))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_130246 (h0 : functor.add_const (function.extfun (Type 1) topological_space) linarith.comp) : @loc_path_connected_space.{1} (finset.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) topological_space.{1}) linarith.comp h0) (finset.{1} Type))  := sorry --non-trivial
lemma new_lemma_130247 (h0 : function.extfun Type ring) : @is_domain.{0} (boolean_algebra.core.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type ring.{0} h0 (boolean_algebra.core.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_130248 (h0 : function.extfun (finset Type) (has_mem.mem (has_union num))) : @preirreducible_space.{0} (has_union.{0} num) (@finset.pi.empty.{1 0} Type topological_space.{0} (has_union.{0} num) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (has_union.{0} num)) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_130249 (h0 : function.extfun Type ring) : @strong_rank_condition.{0} (has_union.{0} unsigned) (@function.extfun_app.{2 1} Type ring.{0} h0 (has_union.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_130250 (h0 : function.extfun Type complete_lattice) : complete_lattice.is_Sup_finite_compact ennreal := sorry --non-trivial
lemma new_lemma_130251 (h0 : topological_space (generalized_boolean_algebra (ring (ring Type)))) : preirreducible_space (generalized_boolean_algebra (ring (ring Type))) := sorry --non-trivial
lemma new_lemma_130252 (h0 : group (random_gen string_imp)) : group.fg (random_gen string_imp) := sorry --non-trivial
lemma new_lemma_130253 (h0 : topological_space (ring (has_zero (boolean_algebra Type)))) : totally_disconnected_space (ring (has_zero (boolean_algebra Type))) := sorry --non-trivial
lemma new_lemma_130254 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : palindrome (function.extfun_app (function.extfun_app h0 list) (semigroup empty)) := sorry --non-trivial
lemma new_lemma_130255 (h0 : complete_lattice (ordered_cancel_add_comm_monoid unsigned)) : complete_lattice.is_Sup_finite_compact (ordered_cancel_add_comm_monoid unsigned) := sorry --non-trivial
lemma new_lemma_130256 (h0 : functor.add_const (topological_space (comm_group name)) name) : @locally_compact_space.{0} (comm_group.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (comm_group.{0} name)) name h0)  := sorry --non-trivial
lemma new_lemma_130257 (h0 : function.extfun Type add_monoid) : @add_monoid.fg.{0} (comm_group.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type add_monoid.{0} h0 (comm_group.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_130258 (h0 : function.extfun Type topological_space) : @discrete_topology.{0} (partial_order.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (partial_order.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_130259 (h0 : group (mul_zero_class (ring name))) : group.fg (mul_zero_class (ring name)) := sorry --non-trivial
lemma new_lemma_130260 (h0 : functor.add_const (function.extfun (Type 1) finset) environment.implicit_infer_kind) : finset.nonempty (function.extfun_app (functor.add_const.run h0) (has_zero Type)) := sorry --non-trivial
lemma new_lemma_130261 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : list.nodup (function.extfun_app (function.extfun_app h0 list) (has_add unsigned)) := sorry --non-trivial
lemma new_lemma_130262 (h0 : not (topological_space (has_union congr_arg_kind) -> false)) : @totally_disconnected_space.{0} (has_union.{0} congr_arg_kind) (@classical.by_contradiction'.{1} (topological_space.{0} (has_union.{0} congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_130263 (h0 : cancel_comm_monoid_with_zero (has_edist (option (option empty)))) : unique_factorization_monoid (has_edist (option (option empty))) := sorry --non-trivial
lemma new_lemma_130264 (h0 : ordered_comm_monoid (semigroup (has_add (has_pos_part (has_pos_part linarith.comp))))) : has_exists_mul_of_le (semigroup (has_add (has_pos_part (has_pos_part linarith.comp)))) := sorry --non-trivial
lemma new_lemma_130265 (h0 : not (ring (add_cancel_comm_monoid reducibility_hints) -> false)) : @rank_condition.{0} (add_cancel_comm_monoid.{0} reducibility_hints) (@classical.by_contradiction'.{1} (ring.{0} (add_cancel_comm_monoid.{0} reducibility_hints)) h0)  := sorry --non-trivial
lemma new_lemma_130266 (h0 : group (has_to_string (has_add (has_to_string pos)))) : normalizer_condition (has_to_string (has_add (has_to_string pos))) := sorry --non-trivial
lemma new_lemma_130267 (h0 : ring (has_zero (boolean_algebra pos))) : rank_condition (has_zero (boolean_algebra pos)) := sorry --non-trivial
lemma new_lemma_130268 (h0 : topological_space (ring (has_add pos))) : totally_disconnected_space (ring (has_add pos)) := sorry --non-trivial
lemma new_lemma_130269 (h0 : ring (has_union (semiring linarith.comp))) : is_domain (has_union (semiring linarith.comp)) := sorry --non-trivial
lemma new_lemma_130270 (h0 : functor.add_const (add_group (semigroup pos)) Type) : @is_add_cyclic.{0} (semigroup.{0} pos) (@functor.add_const.run.{0 1} (add_group.{0} (semigroup.{0} pos)) Type h0)  := sorry --non-trivial
lemma new_lemma_130271 (h0 : function.extfun Type filter) : filter.ne_bot (function.extfun_app h0 (simple_graph unsigned)) := sorry --non-trivial
lemma new_lemma_130272 (h0 : monoid auto.case_option) : monoid.fg auto.case_option := sorry --non-trivial
lemma new_lemma_130273 (h0 : topological_space (normed_comm_ring (has_to_string (ring (has_to_string (has_to_string pos)))))) : normal_space (normed_comm_ring (has_to_string (ring (has_to_string (has_to_string pos))))) := sorry --non-trivial
lemma new_lemma_130274 (h0 : functor.add_const (function.extfun Type topological_space) name) : @preconnected_space.{0} (add_cancel_monoid.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) name h0) (add_cancel_monoid.{0} pos))  := sorry --non-trivial
lemma new_lemma_130275 (h0 : group (has_emptyc (random_gen (has_inv linarith.comp_source)))) : is_cyclic (has_emptyc (random_gen (has_inv linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_130276 (h0 : functor.add_const (function.extfun (Type 1) group) linarith.comp) : @normalizer_condition.{1} (has_Inf.{1} Type) (@function.extfun_app.{3 2} (Type 1) group.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) group.{1}) linarith.comp h0) (has_Inf.{1} Type))  := sorry --non-trivial
lemma new_lemma_130277 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @regular_space.{0} (simple_graph.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (simple_graph.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_130278 (h0 : functor.add_const (function.extfun (Type 1) topological_space) (has_add (has_add name))) : @discrete_topology.{1} (add_cancel_monoid.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) topological_space.{1}) (has_add.{0} (has_add.{0} name)) h0) (add_cancel_monoid.{1} Type))  := sorry --non-trivial
lemma new_lemma_130279 (h0 : functor.add_const (topological_space (ordered_comm_monoid linarith.comp)) pos) : @irreducible_space.{0} (ordered_comm_monoid.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (ordered_comm_monoid.{0} linarith.comp)) pos h0)  := sorry --non-trivial
lemma new_lemma_130280 (h0 : complete_lattice (cancel_monoid empty)) : is_compactly_generated (cancel_monoid empty) := sorry --non-trivial
lemma new_lemma_130281 (h0 : group (has_inv (has_inv (has_inv fun_info)))) : normalizer_condition (has_inv (has_inv (has_inv fun_info))) := sorry --non-trivial
lemma new_lemma_130282 (h0 : group (add_cancel_monoid (has_pos_part pos))) : is_cyclic (add_cancel_monoid (has_pos_part pos)) := sorry --non-trivial
lemma new_lemma_130283 (h2 : topological_space congr_arg_kind) : t0_space congr_arg_kind := sorry --non-trivial
lemma new_lemma_130284 (h0 : not (group (has_norm empty) -> false)) : @normalizer_condition.{0} (has_norm.{0} empty) (@classical.by_contradiction'.{1} (group.{0} (has_norm.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_130285 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @unique_factorization_monoid.{0} (finset.{0} real) (@function.extfun_app.{2 1} Type cancel_comm_monoid_with_zero.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 cancel_comm_monoid_with_zero.{0}) (finset.{0} real))  := sorry --non-trivial
lemma new_lemma_130286 (h0 : cancel_comm_monoid_with_zero (has_nndist (comm_group (has_neg_part Type)))) : unique_factorization_monoid (has_nndist (comm_group (has_neg_part Type))) := sorry --non-trivial
lemma new_lemma_130287 (h0 : functor.add_const (topological_space (complete_linear_order empty)) congr_arg_kind) : @discrete_topology.{0} (complete_linear_order.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (complete_linear_order.{0} empty)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_130288 (h0 : ordered_comm_monoid (comm_group (cancel_monoid Type))) : has_exists_mul_of_le (comm_group (cancel_monoid Type)) := sorry --non-trivial
lemma new_lemma_130289 (h0 : not (monoid (has_emptyc unsigned) -> false)) : @monoid.fg.{0} (has_emptyc.{0} unsigned) (@classical.by_contradiction'.{1} (monoid.{0} (has_emptyc.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_130290 (h0 : function.extfun Type add_group) : @is_add_cyclic.{0} (has_emptyc.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type add_group.{0} h0 (has_emptyc.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_130291 (h0 : ordered_add_comm_monoid (as_linear_order (option empty))) : archimedean (as_linear_order (option empty)) := sorry --non-trivial
lemma new_lemma_130292 (h0 : topological_space (linear_order empty)) : totally_separated_space (linear_order empty) := sorry --non-trivial
lemma new_lemma_130293 (h0 : topological_space (has_emptyc (random_gen linarith.comp_source))) : locally_compact_space (has_emptyc (random_gen linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_130294 (h0 : ordered_add_comm_monoid (has_inter num)) : archimedean (has_inter num) := sorry --non-trivial
lemma new_lemma_130295 (h0 : ordered_comm_monoid (option (option pos))) : has_exists_mul_of_le (option (option pos)) := sorry --non-trivial
lemma new_lemma_130296 (h0 : functor.add_const (function.extfun Type list) (mul_one_class linarith.comp)) : palindrome (function.extfun_app (functor.add_const.run h0) (boolean_algebra linarith.comp)) := sorry --non-trivial
lemma new_lemma_130297 (h0 : function.extfun Type ring) : @is_principal_ideal_ring.{0} (monoid.{0} empty) (@function.extfun_app.{2 1} Type ring.{0} h0 (monoid.{0} empty))  := sorry --non-trivial
lemma new_lemma_130298 (h0 : functor.add_const (finset (ring linarith.comp)) (has_to_string pos)) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_130299 (h0 : fin has_zero.zero) : @t1_space.{0} (canonically_ordered_monoid.{0} real) (@matrix.vec_empty.{0} (topological_space.{0} (canonically_ordered_monoid.{0} real)) h0)  := sorry --non-trivial
lemma new_lemma_130300 (h0 : topological_space (has_to_string (option (option (option (option (option empty))))))) : normal_space (has_to_string (option (option (option (option (option empty)))))) := sorry --non-trivial
lemma new_lemma_130301 (h0 : add_monoid (add_comm_monoid (has_add pos))) : add_monoid.fg (add_comm_monoid (has_add pos)) := sorry --non-trivial
lemma new_lemma_130302 (h0 : sub_neg_monoid environment.implicit_infer_kind -> pseudo_metric_space Type -> pseudo_metric_space Type) (h1 : pseudo_metric_space Type -> pseudo_metric_space Type -> Prop) : covariant (sub_neg_monoid environment.implicit_infer_kind) (pseudo_metric_space Type) h0 h1 := sorry --non-trivial
lemma new_lemma_130303 (h0 : uniform_space (boolean_algebra.core (ring unsigned))) : complete_space (boolean_algebra.core (ring unsigned)) := sorry --non-trivial
lemma new_lemma_130304 (h0 : group (has_add (finset (ring (has_neg (ring Type)))))) : is_simple_group (has_add (finset (ring (has_neg (ring Type))))) := sorry --non-trivial
lemma new_lemma_130305 (h0 : semiring (simple_graph (has_add (has_add Type)))) : is_noetherian_ring (simple_graph (has_add (has_add Type))) := sorry --non-trivial
lemma new_lemma_130306 (h0 : uniform_space (mul_one_class (mul_one_class linarith.comp_source))) : complete_space (mul_one_class (mul_one_class linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_130307 (h0 : complete_lattice (finset (has_add pos))) : is_atomistic (finset (has_add pos)) := sorry --non-trivial
lemma new_lemma_130308 (h0 : functor.add_const (cancel_comm_monoid_with_zero (comm_group name)) (semigroup name)) : @unique_factorization_monoid.{0} (comm_group.{0} name) (@functor.add_const.run.{0 0} (cancel_comm_monoid_with_zero.{0} (comm_group.{0} name)) (semigroup.{0} name) h0)  := sorry --non-trivial
lemma new_lemma_130309 (h0 : ring (complete_semilattice_Sup string_imp)) : rank_condition (complete_semilattice_Sup string_imp) := sorry --non-trivial
lemma new_lemma_130310 (h0 : functor.add_const (functor.add_const (group (boolean_algebra linarith.comp)) Type) Type) : @group.fg.{0} (boolean_algebra.{0} linarith.comp) (@functor.add_const.run.{0 1} (group.{0} (boolean_algebra.{0} linarith.comp)) Type (@functor.add_const.run.{0 1} (functor.add_const.{0 1} (group.{0} (boolean_algebra.{0} linarith.comp)) Type) Type h0))  := sorry --non-trivial
lemma new_lemma_130311 (h0 : add_group (with_bot (has_top linarith.ineq))) : is_add_cyclic (with_bot (has_top linarith.ineq)) := sorry --non-trivial
lemma new_lemma_130312 (h0 : functor.add_const (complete_lattice (has_Inf linarith.comp)) (has_Inf (has_neg linarith.comp))) : @complete_lattice.is_Sup_finite_compact.{0} (has_Inf.{0} linarith.comp) (@functor.add_const.run.{0 0} (complete_lattice.{0} (has_Inf.{0} linarith.comp)) (has_Inf.{0} (has_neg.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_130313 (h0 : functor.add_const (function.extfun Type semiring) (has_neg name)) : @is_noetherian_ring.{0} (has_add.{0} linarith.comp) (@function.extfun_app.{2 1} Type semiring.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type semiring.{0}) (has_neg.{0} name) h0) (has_add.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_130314 (h0 : uniform_space (has_union (has_norm (has_top num)))) : complete_space (has_union (has_norm (has_top num))) := sorry --non-trivial
lemma new_lemma_130315 (h0 : topological_space (has_inter (add_comm_semigroup ereal))) : path_connected_space (has_inter (add_comm_semigroup ereal)) := sorry --non-trivial
lemma new_lemma_130316 (h1 : set (non_unital_non_assoc_semiring std_gen)) : set.subsingleton h1 := sorry --non-trivial
lemma new_lemma_130317 (h0 : ring (is_R_or_C string.iterator_imp)) : is_domain (is_R_or_C string.iterator_imp) := sorry --non-trivial
lemma new_lemma_130318 (h0 : topological_space (has_emptyc congr_arg_kind)) : totally_separated_space (has_emptyc congr_arg_kind) := sorry --non-trivial
lemma new_lemma_130319 (h0 : topological_space (ordered_comm_ring (ring linarith.comp))) : topological_space.separable_space (ordered_comm_ring (ring linarith.comp)) := sorry --non-trivial
lemma new_lemma_130320 (h0 : filter (add_cancel_monoid (finset linarith.comp))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_130321 (h3 : measurable_space string.iterator_imp) (h4 : filter string.iterator_imp) : filter.is_measurably_generated h4 := sorry --non-trivial
lemma new_lemma_130322 (h0 : topological_space (normed_comm_ring (finset (has_nndist (finset linarith.comp))))) : totally_disconnected_space (normed_comm_ring (finset (has_nndist (finset linarith.comp)))) := sorry --non-trivial
lemma new_lemma_130323 (h0 : function.extfun Type topological_space) : @totally_separated_space.{0} (linear_ordered_semiring.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (linear_ordered_semiring.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_130324 (h0 : functor.add_const (cancel_comm_monoid_with_zero (complete_distrib_lattice Type)) name) : @unique_factorization_monoid.{1} (complete_distrib_lattice.{1} Type) (@functor.add_const.run.{1 0} (cancel_comm_monoid_with_zero.{1} (complete_distrib_lattice.{1} Type)) name h0)  := sorry --non-trivial
lemma new_lemma_130325 (h0 : list (cancel_monoid (comm_group (normed_comm_ring name)))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_130326 (h0 : add_comm_semigroup std_gen) : set.subsingleton (is_distinct (add_comm_semigroup std_gen) h0) := sorry --non-trivial
lemma new_lemma_130327 (h1 : ring (topological_space (random_gen char))) : strong_rank_condition (topological_space (random_gen char)) := sorry --non-trivial
lemma new_lemma_130328 (h1 : function.extfun (finset Type) (has_mem.mem (normed_group congr_arg_kind))) : @path_connected_space.{0} (normed_group.{0} congr_arg_kind) (@finset.pi.empty.{1 0} Type topological_space.{0} (normed_group.{0} congr_arg_kind) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (normed_group.{0} congr_arg_kind)) h1 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_130329 (h0 : functor.add_const (list (has_neg linarith.comp)) (has_Inf (has_pos_part linarith.comp))) : palindrome (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_130330 (h0 : function.extfun Type semiring) : @is_noetherian_ring.{0} (add_group.{0} unsigned) (@function.extfun_app.{2 1} Type semiring.{0} h0 (add_group.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_130331 (h0 : not (complete_lattice (left_cancel_semigroup unsigned) -> false)) : @is_compactly_generated.{0} (left_cancel_semigroup.{0} unsigned) (@classical.by_contradiction'.{1} (complete_lattice.{0} (left_cancel_semigroup.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_130332 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @path_connected_space.{0} (has_norm.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_norm.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_130333 (h1 : add_group (add_cancel_comm_monoid string_imp)) : is_add_cyclic (add_cancel_comm_monoid string_imp) := sorry --non-trivial
lemma new_lemma_130334 (h0 : group (boolean_algebra.core unsigned)) : group.fg (boolean_algebra.core unsigned) := sorry --non-trivial
lemma new_lemma_130335 (h0 : Prop) (h1 : h0) (h2 : not h0) : absurd h1 h2 := sorry --trivial
lemma new_lemma_130336 (h0 : functor.add_const (semiring (comm_group Type)) environment.implicit_infer_kind) : @is_noetherian_ring.{1} (comm_group.{1} Type) (@functor.add_const.run.{1 0} (semiring.{1} (comm_group.{1} Type)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_130337 (h0 : function.extfun Type complete_lattice) : @complete_lattice.is_Sup_finite_compact.{0} (has_one.{0} empty) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (has_one.{0} empty))  := sorry --non-trivial
lemma new_lemma_130338 (h0 : ring (plift empty)) : is_domain (plift empty) := sorry --non-trivial
lemma new_lemma_130339 (h0 : function.extfun Type topological_space) : @topological_space.separable_space.{0} (canonically_linear_ordered_monoid.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (canonically_linear_ordered_monoid.{0} name))  := sorry --non-trivial
lemma new_lemma_130340 (h0 : topological_space (has_zero (has_pos_part (has_pos_part (has_Inf linarith.comp))))) : preconnected_space (has_zero (has_pos_part (has_pos_part (has_Inf linarith.comp)))) := sorry --non-trivial
lemma new_lemma_130341 (h0 : group (canonically_linear_ordered_monoid (option num))) : group.fg (canonically_linear_ordered_monoid (option num)) := sorry --non-trivial
lemma new_lemma_130342 (h0 : group (has_norm (has_norm linarith.comp_source))) : group.fg (has_norm (has_norm linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_130343 (h0 : filter (ring (has_add pos))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_130344 (h0 : ring (ring (option (option (option (option (option (option (option empty))))))))) : strong_rank_condition (ring (option (option (option (option (option (option (option empty)))))))) := sorry --non-trivial
lemma new_lemma_130345 (h0 : function.extfun ((finset Type -> Prop) -> Prop) (function.extfun (finset Type -> Prop))) : @irreducible_space.{0} (has_top.{0} (has_inv.{0} linarith.ineq)) (@finset.pi.empty.{1 0} Type topological_space.{0} (has_top.{0} (has_inv.{0} linarith.ineq)) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (has_top.{0} (has_inv.{0} linarith.ineq))) (@function.extfun_app.{2 0} (finset.{1} Type → Prop) (function.extfun.{2 0} (finset.{1} Type)) (@function.extfun_app.{2 0} ((finset.{1} Type → Prop) → Prop) (function.extfun.{2 0} (finset.{1} Type → Prop)) h0 (function.extfun.{2 0} (finset.{1} Type))) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (has_top.{0} (has_inv.{0} linarith.ineq)))) (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_130346 (h0 : topological_space (semigroup (ring (has_pos_part (finset (has_add Type)))))) : discrete_topology (semigroup (ring (has_pos_part (finset (has_add Type))))) := sorry --non-trivial
lemma new_lemma_130347 (h0 : ordered_add_comm_monoid (normed_lattice_add_comm_group real)) : archimedean (normed_lattice_add_comm_group real) := sorry --non-trivial
lemma new_lemma_130348 (h0 : finset (boolean_algebra (has_pos_part Type))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_130349 (h0 : functor.add_const (function.extfun Type list) pos) : list.nodup (function.extfun_app (functor.add_const.run h0) (has_add pos)) := sorry --non-trivial
lemma new_lemma_130350 (h0 : functor.add_const (function.extfun Type topological_space) linarith.comp) : @preconnected_space.{0} (add_cancel_monoid.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) linarith.comp h0) (add_cancel_monoid.{0} name))  := sorry --non-trivial
lemma new_lemma_130351 (h0 : functor.add_const (function.extfun Type uniform_space) name) : @separated_space.{0} (normed_comm_ring.{0} name) (@function.extfun_app.{2 1} Type uniform_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type uniform_space.{0}) name h0) (normed_comm_ring.{0} name))  := sorry --non-trivial
lemma new_lemma_130352 (h0 : not (function.extfun Type add_group -> false)) : @is_add_cyclic.{0} (has_emptyc.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type add_group.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type add_group.{0}) h0) (has_emptyc.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_130353 (h0 : topological_space (cancel_monoid num)) : discrete_topology (cancel_monoid num) := sorry --non-trivial
lemma new_lemma_130354 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_cyclic.{0} (ordered_comm_monoid.{0} linarith.comp) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (ordered_comm_monoid.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_130355 (h0 : function.extfun nat fin) : @complete_lattice.is_Sup_finite_compact.{0} (has_add.{0} real) (@matrix.vec_empty.{0} (complete_lattice.{0} (has_add.{0} real)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_130356 (h0 : functor.add_const (topological_space (ring name)) pos) : @irreducible_space.{0} (ring.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (ring.{0} name)) pos h0)  := sorry --non-trivial
lemma new_lemma_130357 (h0 : add_group (comm_ring reducibility_hints)) : is_add_cyclic (comm_ring reducibility_hints) := sorry --non-trivial
lemma new_lemma_130358 (h0 : topological_space (comm_group (finset pos))) : sequential_space (comm_group (finset pos)) := sorry --non-trivial
lemma new_lemma_130359 (h0 : not (group (comm_ring (has_nnnorm (random_gen (random_gen (random_gen reducibility_hints))))) -> false)) : @is_cyclic.{0} (comm_ring.{0} (has_nnnorm.{0} (random_gen.{0} (random_gen.{0} (random_gen.{0} reducibility_hints))))) (@classical.by_contradiction'.{1} (group.{0} (comm_ring.{0} (has_nnnorm.{0} (random_gen.{0} (random_gen.{0} (random_gen.{0} reducibility_hints)))))) h0)  := sorry --non-trivial
lemma new_lemma_130360 (h0 : not (function.extfun Type group -> false)) : @normalizer_condition.{0} (normed_group.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type group.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type group.{0}) h0) (normed_group.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_130361 (h0 : functor.add_const (group (complete_distrib_lattice name)) name) : @is_simple_group.{0} (complete_distrib_lattice.{0} name) (@functor.add_const.run.{0 0} (group.{0} (complete_distrib_lattice.{0} name)) name h0)  := sorry --non-trivial
lemma new_lemma_130362 (h0 : functor.const (group (denumerable to_additive.value_type)) to_additive.value_type) : @normalizer_condition.{0} (denumerable.{0} to_additive.value_type) (@functor.const.run.{0 0} (group.{0} (denumerable.{0} to_additive.value_type)) to_additive.value_type h0)  := sorry --non-trivial
lemma new_lemma_130363 (h2 : has_lt linarith.ineq) : no_max_order linarith.ineq := sorry --non-trivial
lemma new_lemma_130364 (h0 : functor.add_const (topological_space (comm_semigroup pos)) real) : @locally_compact_space.{0} (comm_semigroup.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (comm_semigroup.{0} pos)) real h0)  := sorry --non-trivial
lemma new_lemma_130365 (h0 : group (cancel_monoid (option (option (option empty))))) : is_cyclic (cancel_monoid (option (option (option empty)))) := sorry --non-trivial
lemma new_lemma_130366 (h0 : ring (boolean_algebra (has_to_string (comm_group (comm_group Type))))) : rank_condition (boolean_algebra (has_to_string (comm_group (comm_group Type)))) := sorry --non-trivial
lemma new_lemma_130367 (h0 : complete_lattice (id (has_norm empty))) : is_atomistic (id (has_norm empty)) := sorry --non-trivial
lemma new_lemma_130368 (h0 : functor.add_const (topological_space (has_add linarith.comp)) pos) : @normal_space.{0} (has_add.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (has_add.{0} linarith.comp)) pos h0)  := sorry --non-trivial
lemma new_lemma_130369 (h1 : topological_space (dlist linarith.ineq)) : totally_disconnected_space (dlist linarith.ineq) := sorry --non-trivial
lemma new_lemma_130370 (h0 : functor.comp complete_lattice canonically_ordered_comm_semiring name) : @is_compactly_generated.{0} (canonically_ordered_comm_semiring.{0} name) (@functor.comp.run.{0 0 0} complete_lattice.{0} canonically_ordered_comm_semiring.{0} name h0)  := sorry --non-trivial
lemma new_lemma_130371 (h0 : topological_space (ordered_comm_monoid (has_neg pos))) : regular_space (ordered_comm_monoid (has_neg pos)) := sorry --non-trivial
lemma new_lemma_130372 (h0 : add_group (normed_comm_ring (has_neg_part Type))) : is_add_cyclic (normed_comm_ring (has_neg_part Type)) := sorry --non-trivial
lemma new_lemma_130373 (h0 : list (has_dist empty)) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_130374 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @group.fg.{0} (linear_ordered_add_comm_group.{0} linarith.ineq) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (linear_ordered_add_comm_group.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_130375 (h1 : topological_space (measurable_space congr_arg_kind)) : discrete_topology (measurable_space congr_arg_kind) := sorry --non-trivial
lemma new_lemma_130376 (h0 : topological_space (canonically_ordered_monoid (has_Inf (has_neg Type)))) : loc_path_connected_space (canonically_ordered_monoid (has_Inf (has_neg Type))) := sorry --non-trivial
lemma new_lemma_130377 (h0 : topological_space (comm_group environment.implicit_infer_kind)) : t0_space (comm_group environment.implicit_infer_kind) := sorry --non-trivial
lemma new_lemma_130378 (h0 : functor.add_const (topological_space (has_neg environment.implicit_infer_kind)) linarith.comp) : @preirreducible_space.{0} (has_neg.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (has_neg.{0} environment.implicit_infer_kind)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_130379 (h0 : function.extfun nat fin) : @has_exists_mul_of_le.{1} (complete_distrib_lattice.{1} Type) (@matrix.vec_empty.{1} (ordered_comm_monoid.{1} (complete_distrib_lattice.{1} Type)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_130380 (h0 : function.extfun nat fin) : @is_add_cyclic.{0} (canonically_ordered_monoid.{0} linarith.comp) (@matrix.vec_empty.{0} (add_group.{0} (canonically_ordered_monoid.{0} linarith.comp)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_130381 (h0 : topological_space (has_sub congr_arg_kind)) : topological_space.separable_space (has_sub congr_arg_kind) := sorry --non-trivial
lemma new_lemma_130382 (h0 : topological_space (finset (finset (finset (finset (finset (finset pos))))))) : preconnected_space (finset (finset (finset (finset (finset (finset pos)))))) := sorry --non-trivial
lemma new_lemma_130383 (h0 : ring (uniform_space (has_ssubset (uniform_space char)))) : rank_condition (uniform_space (has_ssubset (uniform_space char))) := sorry --non-trivial
lemma new_lemma_130384 (h0 : functor.add_const (filter (normed_comm_ring name)) linarith.comp) : countable_Inter_filter (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_130385 (h0 : function.extfun (Type 1) semiring) : @is_noetherian_ring.{1} (ordered_comm_ring.{1} Type) (@function.extfun_app.{3 2} (Type 1) semiring.{1} h0 (ordered_comm_ring.{1} Type))  := sorry --non-trivial
lemma new_lemma_130386 (h1 : ring (distrib (has_nnnorm to_additive.value_type))) : rank_condition (distrib (has_nnnorm to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_130387 (h0 : list (ordered_comm_monoid (has_Inf linarith.comp))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_130388 (h0 : topological_space (add_comm_monoid (has_add Type))) : discrete_topology (add_comm_monoid (has_add Type)) := sorry --non-trivial
lemma new_lemma_130389 (h0 : topological_space (add_group (semiring congr_arg_kind))) : locally_compact_space (add_group (semiring congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_130390 (h0 : functor.add_const (complete_lattice (comm_group pos)) pos) : @complete_lattice.is_Sup_finite_compact.{0} (comm_group.{0} pos) (@functor.add_const.run.{0 0} (complete_lattice.{0} (comm_group.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_130391 (h0 : group (encodable (random_gen linarith.comp_source))) : group.fg (encodable (random_gen linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_130392 (h0 : measurable_space (has_lt std_gen)) (h1 : filter (has_lt std_gen)) : filter.is_measurably_generated h1 := sorry --non-trivial
lemma new_lemma_130393 (h0 : ring (distrib_lattice (semi_normed_ring string_imp))) : is_domain (distrib_lattice (semi_normed_ring string_imp)) := sorry --non-trivial
lemma new_lemma_130394 (h0 : topological_space (id (semiring (semiring (semiring (semiring (semiring empty))))))) : preirreducible_space (id (semiring (semiring (semiring (semiring (semiring empty)))))) := sorry --non-trivial
lemma new_lemma_130395 (h0 : functor.add_const (topological_space (boolean_algebra Type)) name) : @path_connected_space.{1} (boolean_algebra.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (boolean_algebra.{1} Type)) name h0)  := sorry --non-trivial
lemma new_lemma_130396 (h1 : set (normed_field environment.projection_info)) : set.finite h1 := sorry --non-trivial
lemma new_lemma_130397 (h0 : function.extfun Type finset) : finset.nonempty (function.extfun_app h0 (canonically_ordered_comm_semiring num)) := sorry --non-trivial
lemma new_lemma_130398 (h0 : functor.add_const (topological_space (normed_comm_ring unsigned)) Type) : @preconnected_space.{0} (normed_comm_ring.{0} unsigned) (@functor.add_const.run.{0 1} (topological_space.{0} (normed_comm_ring.{0} unsigned)) Type h0)  := sorry --non-trivial
lemma new_lemma_130399 (h0 : function.extfun Type (functor.comp complete_lattice add_cancel_monoid)) : @complete_lattice.is_Sup_finite_compact.{0} (add_cancel_monoid.{0} name) (@functor.comp.run.{0 0 0} complete_lattice.{0} add_cancel_monoid.{0} name (@function.extfun_app.{2 1} Type (functor.comp.{0 0 0} complete_lattice.{0} add_cancel_monoid.{0}) h0 name))  := sorry --non-trivial
lemma new_lemma_130400 (h0 : functor.add_const (topological_space (complete_distrib_lattice linarith.comp)) linarith.comp) : @regular_space.{0} (complete_distrib_lattice.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (complete_distrib_lattice.{0} linarith.comp)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_130401 (h1 : has_mem.mem (complete_semilattice_Sup linarith.comp) has_emptyc.emptyc) : @irreducible_space.{0} (complete_semilattice_Sup.{0} linarith.comp) (@finset.pi.empty.{1 0} Type topological_space.{0} (complete_semilattice_Sup.{0} linarith.comp) h1)  := sorry --non-trivial
lemma new_lemma_130402 (h0 : topological_space (has_nndist (has_neg pos))) : topological_space.separable_space (has_nndist (has_neg pos)) := sorry --non-trivial
lemma new_lemma_130403 (h0 : functor.add_const (group (has_to_string pos)) pos) : @normalizer_condition.{0} (has_to_string.{0} pos) (@functor.add_const.run.{0 0} (group.{0} (has_to_string.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_130404 (h0 : topological_space (add_group (semiring num))) : totally_disconnected_space (add_group (semiring num)) := sorry --non-trivial
lemma new_lemma_130405 (h0 : group (semi_normed_comm_ring (has_ssubset to_additive.value_type))) : is_cyclic (semi_normed_comm_ring (has_ssubset to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_130406 (h0 : ring (has_ssubset (random_gen char))) : is_domain (has_ssubset (random_gen char)) := sorry --non-trivial
lemma new_lemma_130407 (h0 : complete_lattice (has_zero (has_to_string (has_zero pos)))) : is_compactly_generated (has_zero (has_to_string (has_zero pos))) := sorry --non-trivial
lemma new_lemma_130408 (h0 : complete_lattice (semi_normed_ring std_gen)) : is_compactly_generated (semi_normed_ring std_gen) := sorry --non-trivial
lemma new_lemma_130409 (h0 : num -> Prop) : exists_unique h0 := sorry --non-trivial
lemma new_lemma_130410 (h1 : not (has_mem.mem add_group has_emptyc.emptyc -> false)) : @is_add_cyclic.{0} (random_gen.{0} num) (@function.extfun_app.{2 1} Type add_group.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) add_group.{0} (@classical.by_contradiction'.{0} (@has_mem.mem.{1 1} (Type → Type) (finset.{1} (Type → Type)) (@finset.has_mem.{1} (Type → Type)) add_group.{0} (@has_emptyc.emptyc.{1} (finset.{1} (Type → Type)) (@finset.has_emptyc.{1} (Type → Type)))) h1)) (random_gen.{0} num))  := sorry --non-trivial
lemma new_lemma_130411 (h0 : complete_lattice (canonically_linear_ordered_monoid real)) : complete_lattice.is_Sup_finite_compact (canonically_linear_ordered_monoid real) := sorry --non-trivial
lemma new_lemma_130412 (h0 : complete_lattice (random_gen (has_lt char))) : complete_lattice.is_Sup_finite_compact (random_gen (has_lt char)) := sorry --non-trivial
lemma new_lemma_130413 (h0 h1 : multiset (uniform_space char)) : multiset.disjoint h0 h1 := sorry --non-trivial
lemma new_lemma_130414 (h0 : topological_space (has_zero (has_neg_part linarith.comp))) : totally_disconnected_space (has_zero (has_neg_part linarith.comp)) := sorry --non-trivial
lemma new_lemma_130415 (h0 : filter (semigroup (has_add (has_to_string (has_add pos))))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_130416 (h0 : topological_space (complete_linear_order (semiring unsigned))) : preirreducible_space (complete_linear_order (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_130417 (h0 : uniform_space (canonically_ordered_comm_semiring (option (option empty)))) : complete_space (canonically_ordered_comm_semiring (option (option empty))) := sorry --non-trivial
lemma new_lemma_130418 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : list.nodup (function.extfun_app (function.extfun_app h0 list) (has_norm to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_130419 (h0 : topological_space (has_neg (option (option unsigned)))) : path_connected_space (has_neg (option (option unsigned))) := sorry --non-trivial
lemma new_lemma_130420 (h0 : uniform_space (has_neg (option (finset Type)))) : complete_space (has_neg (option (finset Type))) := sorry --non-trivial
lemma new_lemma_130421 (h0 : not (topological_space (has_norm num) -> false)) : @locally_compact_space.{0} (has_norm.{0} num) (@classical.by_contradiction'.{1} (topological_space.{0} (has_norm.{0} num)) h0)  := sorry --non-trivial
lemma new_lemma_130422 (h0 : not (group (with_one num) -> false)) : @normalizer_condition.{0} (with_one.{0} num) (@classical.by_contradiction'.{1} (group.{0} (with_one.{0} num)) h0)  := sorry --non-trivial
lemma new_lemma_130423 (h0 : uniform_space (with_one (has_norm fun_info))) : separated_space (with_one (has_norm fun_info)) := sorry --non-trivial
lemma new_lemma_130424 (h0 : ring (normed_comm_ring pos)) : strong_rank_condition (normed_comm_ring pos) := sorry --non-trivial
lemma new_lemma_130425 (h0 : functor.add_const (monoid (semigroup linarith.comp)) (comm_group (has_add (boolean_algebra Type)))) : @monoid.fg.{0} (semigroup.{0} linarith.comp) (@functor.add_const.run.{0 1} (monoid.{0} (semigroup.{0} linarith.comp)) (comm_group.{1} (has_add.{1} (boolean_algebra.{1} Type))) h0)  := sorry --non-trivial
lemma new_lemma_130426 (h1 : measurable_space (has_lt std_gen)) (h2 : filter (has_lt std_gen)) : filter.is_measurably_generated h2 := sorry --non-trivial
lemma new_lemma_130427 (h0 : functor.add_const (complete_lattice (has_neg Type)) Type) : @complete_lattice.is_Sup_finite_compact.{1} (has_neg.{1} Type) (@functor.add_const.run.{1 1} (complete_lattice.{1} (has_neg.{1} Type)) Type h0)  := sorry --non-trivial
lemma new_lemma_130428 (h1 : ring (has_append (random_gen char))) : is_domain (has_append (random_gen char)) := sorry --non-trivial
lemma new_lemma_130429 (h0 : topological_space (monoid (option empty))) : path_connected_space (monoid (option empty)) := sorry --non-trivial
lemma new_lemma_130430 (h0 : function.extfun Type topological_space) : @loc_path_connected_space.{0} (boolean_algebra.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (boolean_algebra.{0} name))  := sorry --non-trivial
lemma new_lemma_130431 (h0 : topological_space (complete_semilattice_Sup congr_arg_kind)) : topological_space.separable_space (complete_semilattice_Sup congr_arg_kind) := sorry --non-trivial
lemma new_lemma_130432 (h0 : fin has_zero.zero) : @discrete_topology.{0} (generalized_boolean_algebra.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} (@matrix.vec_empty.{1} (function.extfun.{2 1} Type topological_space.{0}) h0) (generalized_boolean_algebra.{0} name))  := sorry --non-trivial
lemma new_lemma_130433 (h0 : functor.add_const Prop (has_zero (option pos))) : functor.add_const.run h0 := sorry --non-trivial
lemma new_lemma_130434 (h0 : group (mul_zero_class (option (option empty)))) : normalizer_condition (mul_zero_class (option (option empty))) := sorry --non-trivial
lemma new_lemma_130435 (h0 : not (ring (distrib fun_info) -> false)) : @is_domain.{0} (distrib.{0} fun_info) (@classical.by_contradiction'.{1} (ring.{0} (distrib.{0} fun_info)) h0)  := sorry --non-trivial
lemma new_lemma_130436 (h1 : filter bool) : filter.ne_bot h1 := sorry --non-trivial
lemma new_lemma_130437 (h0 : ring (has_zero (has_neg_part (normed_comm_ring Type)))) : rank_condition (has_zero (has_neg_part (normed_comm_ring Type))) := sorry --non-trivial
lemma new_lemma_130438 (h0 : topological_space (random_gen (has_top congr_arg_kind))) : preirreducible_space (random_gen (has_top congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_130439 (h0 : function.extfun Type group) : @group.fg.{0} (boolean_algebra.{0} linarith.comp) (@function.extfun_app.{2 1} Type group.{0} h0 (boolean_algebra.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_130440 (h0 : ring (non_unital_non_assoc_semiring (metric_space linarith.comp_source))) : rank_condition (non_unital_non_assoc_semiring (metric_space linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_130441 (h0 : functor.add_const (list (has_add linarith.comp)) pos) : list.nodup (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_130442 (h1 : ring (linear_ordered_add_comm_group char)) : strong_rank_condition (linear_ordered_add_comm_group char) := sorry --non-trivial
lemma new_lemma_130443 (h0 : filter (option ennreal)) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_130444 (h1 : set (has_lt linarith.ineq)) (h2 : has_lt linarith.ineq) : set.compl h1 h2 := sorry --non-trivial
lemma new_lemma_130445 (h0 : topological_space (has_nndist (has_add (has_add linarith.comp)))) : loc_path_connected_space (has_nndist (has_add (has_add linarith.comp))) := sorry --non-trivial
lemma new_lemma_130446 (h0 : filter (has_bot pos)) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_130447 (h0 : topological_space (option empty)) : preirreducible_space (option empty) := sorry --non-trivial
lemma new_lemma_130448 (h0 : function.extfun Type add_monoid) : @add_monoid.fg.{0} (normed_comm_ring.{0} ennreal) (@function.extfun_app.{2 1} Type add_monoid.{0} h0 (normed_comm_ring.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_130449 (h0 : function.extfun Type semiring) : @is_noetherian_ring.{0} (add_left_cancel_semigroup.{0} unsigned) (@function.extfun_app.{2 1} Type semiring.{0} h0 (add_left_cancel_semigroup.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_130450 (h0 : topological_space (with_one (has_norm (has_norm (has_norm (has_norm congr_arg_kind)))))) : totally_separated_space (with_one (has_norm (has_norm (has_norm (has_norm congr_arg_kind))))) := sorry --non-trivial
lemma new_lemma_130451 (h0 : ring (normed_group (has_inv (has_inv (has_top linarith.ineq))))) : is_domain (normed_group (has_inv (has_inv (has_top linarith.ineq)))) := sorry --non-trivial
lemma new_lemma_130452 (h1 : measurable_space enat) (h2 : set enat) : measurable_set h2 := sorry --non-trivial
lemma new_lemma_130453 (h0 : ring (with_bot (random_gen (has_norm num)))) : is_domain (with_bot (random_gen (has_norm num))) := sorry --non-trivial
lemma new_lemma_130454 (h0 : not (complete_lattice (simple_graph linarith.comp_source) -> false)) : @complete_lattice.is_Sup_finite_compact.{0} (simple_graph.{0} linarith.comp_source) (@classical.by_contradiction'.{1} (complete_lattice.{0} (simple_graph.{0} linarith.comp_source)) h0)  := sorry --non-trivial
lemma new_lemma_130455 (h0 : functor.add_const Prop (has_nndist (finset (finset (finset pos))))) : functor.add_const.run h0 := sorry --non-trivial
lemma new_lemma_130456 (h0 : function.extfun (finset (Type -> Type)) (has_mem.mem topological_space)) : @locally_compact_space.{0} fun_info (@function.extfun_app.{2 1} Type topological_space.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) topological_space.{0} (@function.extfun_app.{2 0} (finset.{1} (Type → Type)) (@has_mem.mem.{1 1} (Type → Type) (finset.{1} (Type → Type)) (@finset.has_mem.{1} (Type → Type)) topological_space.{0}) h0 (@has_emptyc.emptyc.{1} (finset.{1} (Type → Type)) (@finset.has_emptyc.{1} (Type → Type))))) fun_info)  := sorry --non-trivial
lemma new_lemma_130457 (h0 : topological_space (complete_distrib_lattice (finset (finset ennreal)))) : locally_compact_space (complete_distrib_lattice (finset (finset ennreal))) := sorry --non-trivial
lemma new_lemma_130458 (h0 : functor.add_const (topological_space (mul_zero_class environment.implicit_infer_kind)) Type) : @t1_space.{0} (mul_zero_class.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 1} (topological_space.{0} (mul_zero_class.{0} environment.implicit_infer_kind)) Type h0)  := sorry --non-trivial
lemma new_lemma_130459 (h0 : complete_lattice (has_nnnorm ereal)) : complete_lattice.is_Sup_finite_compact (has_nnnorm ereal) := sorry --non-trivial
lemma new_lemma_130460 (h0 : with_bot (topological_space (linear_order unsigned))) (h1 : ne h0 has_bot.bot) : @totally_disconnected_space.{0} (linear_order.{0} unsigned) (@with_bot.unbot.{0} (topological_space.{0} (linear_order.{0} unsigned)) h0 h1)  := sorry --non-trivial
lemma new_lemma_130461 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @discrete_topology.{0} (linear_ordered_add_comm_group_with_top.{0} (option.{0} empty)) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (linear_ordered_add_comm_group_with_top.{0} (option.{0} empty)))  := sorry --non-trivial
lemma new_lemma_130462 (h0 : topological_space (ordered_comm_ring (boolean_algebra.core (ring Type)))) : totally_disconnected_space (ordered_comm_ring (boolean_algebra.core (ring Type))) := sorry --non-trivial
lemma new_lemma_130463 (h0 : functor.add_const (ordered_comm_monoid Type) (has_neg name)) : @has_exists_mul_of_le.{1} Type (@functor.add_const.run.{1 0} (ordered_comm_monoid.{1} Type) (has_neg.{0} name) h0)  := sorry --non-trivial
lemma new_lemma_130464 (h0 : functor.add_const (topological_space (semigroup linarith.comp)) linarith.comp) : @regular_space.{0} (semigroup.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (semigroup.{0} linarith.comp)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_130465 (h0 : functor.add_const (finset name) num) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_130466 (h0 : topological_space (complete_distrib_lattice (ring (ring (ring (ring Type)))))) : locally_compact_space (complete_distrib_lattice (ring (ring (ring (ring Type))))) := sorry --non-trivial
lemma new_lemma_130467 (h0 : uniform_space (has_top linarith.comp_source)) : separated_space (has_top linarith.comp_source) := sorry --non-trivial
lemma new_lemma_130468 (h0 : function.extfun Type (functor.comp topological_space has_zero)) : @sequential_space.{0} (has_zero.{0} name) (@functor.comp.run.{0 0 0} topological_space.{0} has_zero.{0} name (@function.extfun_app.{2 1} Type (functor.comp.{0 0 0} topological_space.{0} has_zero.{0}) h0 name))  := sorry --non-trivial
lemma new_lemma_130469 (h0 : semiring (ring congr_arg_kind)) : is_noetherian_ring (ring congr_arg_kind) := sorry --non-trivial
lemma new_lemma_130470 (h0 : functor.add_const (group (canonically_ordered_add_monoid empty)) empty) : @group.fg.{0} (canonically_ordered_add_monoid.{0} empty) (@functor.add_const.run.{0 0} (group.{0} (canonically_ordered_add_monoid.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_130471 (h0 : add_monoid (has_Sup (option (option (option empty))))) : add_monoid.fg (has_Sup (option (option (option empty)))) := sorry --non-trivial
lemma new_lemma_130472 (h0 : ring (sub_neg_monoid (finset linarith.comp))) : is_domain (sub_neg_monoid (finset linarith.comp)) := sorry --non-trivial
lemma new_lemma_130473 (h0 : ordered_comm_monoid (normed_comm_ring (has_add ennreal))) : has_exists_mul_of_le (normed_comm_ring (has_add ennreal)) := sorry --non-trivial
lemma new_lemma_130474 (h0 : functor.add_const (semiring (has_edist empty)) empty) : @is_noetherian_ring.{0} (has_edist.{0} empty) (@functor.add_const.run.{0 0} (semiring.{0} (has_edist.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_130475 (h0 : function.extfun Type topological_space) : @totally_disconnected_space.{0} (has_dist.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_dist.{0} num))  := sorry --non-trivial
lemma new_lemma_130476 (h0 : topological_space (boolean_algebra (comm_group Type))) : t1_space (boolean_algebra (comm_group Type)) := sorry --non-trivial
lemma new_lemma_130477 (h0 : topological_space (has_norm (random_gen to_additive.value_type))) : path_connected_space (has_norm (random_gen to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_130478 (h0 : topological_space (has_add (has_neg pos))) : totally_separated_space (has_add (has_neg pos)) := sorry --non-trivial
lemma new_lemma_130479 (h0 : functor.add_const (topological_space (add_cancel_monoid unsigned)) congr_arg_kind) : @discrete_topology.{0} (add_cancel_monoid.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (add_cancel_monoid.{0} unsigned)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_130480 (h0 : topological_space (complete_linear_order (semiring (semiring congr_arg_kind)))) : topological_space.separable_space (complete_linear_order (semiring (semiring congr_arg_kind))) := sorry --non-trivial
lemma new_lemma_130481 (h0 : semiring (semigroup (has_add (semigroup unsigned)))) : is_noetherian_ring (semigroup (has_add (semigroup unsigned))) := sorry --non-trivial
lemma new_lemma_130482 (h0 : functor.comp topological_space ring environment.implicit_infer_kind) : @irreducible_space.{0} (ring.{0} environment.implicit_infer_kind) (@functor.comp.run.{0 0 0} topological_space.{0} ring.{0} environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_130483 (h0 : function.extfun (Type 1) (functor.add_const (complete_lattice Type))) : @is_atomistic.{1} Type (@functor.add_const.run.{1 1} (complete_lattice.{1} Type) Type (@function.extfun_app.{3 2} (Type 1) (functor.add_const.{1 1} (complete_lattice.{1} Type)) h0 Type))  := sorry --non-trivial
lemma new_lemma_130484 (h0 : topological_space (normed_lattice_add_comm_group pos)) : discrete_topology (normed_lattice_add_comm_group pos) := sorry --non-trivial
lemma new_lemma_130485 (h0 : not (ring (add_left_cancel_monoid char) -> false)) : @is_domain.{0} (add_left_cancel_monoid.{0} char) (@classical.by_contradiction'.{1} (ring.{0} (add_left_cancel_monoid.{0} char)) h0)  := sorry --non-trivial
lemma new_lemma_130486 (h0 : uniform_space (distrib_lattice fun_info)) : complete_space (distrib_lattice fun_info) := sorry --non-trivial
lemma new_lemma_130487 (h0 : topological_space (has_append (has_nnnorm fun_info))) : path_connected_space (has_append (has_nnnorm fun_info)) := sorry --non-trivial
lemma new_lemma_130488 (h0 : topological_space (has_pos_part (has_Inf (has_add real)))) : t0_space (has_pos_part (has_Inf (has_add real))) := sorry --non-trivial
lemma new_lemma_130489 (h0 : not (topological_space (normed_field string.iterator_imp) -> false)) : @t0_space.{0} (normed_field.{0} string.iterator_imp) (@classical.by_contradiction'.{1} (topological_space.{0} (normed_field.{0} string.iterator_imp)) h0)  := sorry --non-trivial
lemma new_lemma_130490 (h0 : topological_space (partial_order (semiring unsigned))) : irreducible_space (partial_order (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_130491 (h0 : topological_space (normed_lattice_add_comm_group (has_add (has_add real)))) : irreducible_space (normed_lattice_add_comm_group (has_add (has_add real))) := sorry --non-trivial
lemma new_lemma_130492 (h0 : set (pseudo_metric_space (mul_one_class char))) : set.finite h0 := sorry --non-trivial
lemma new_lemma_130493 (h1 : complete_lattice (denumerable string_imp)) : complete_lattice.is_Sup_finite_compact (denumerable string_imp) := sorry --non-trivial
lemma new_lemma_130494 (h0 : group (has_add (has_nndist pos))) : group.fg (has_add (has_nndist pos)) := sorry --non-trivial
lemma new_lemma_130495 (h0 : functor.add_const (ring (add_cancel_monoid pos)) environment.implicit_infer_kind) : @rank_condition.{0} (add_cancel_monoid.{0} pos) (@functor.add_const.run.{0 0} (ring.{0} (add_cancel_monoid.{0} pos)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_130496 (h0 : topological_space (measure_theory.measure_space (semiring (semiring empty)))) : topological_space.separable_space (measure_theory.measure_space (semiring (semiring empty))) := sorry --non-trivial
lemma new_lemma_130497 (h0 : topological_space (random_gen (random_gen linarith.comp_source))) : locally_compact_space (random_gen (random_gen linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_130498 (h0 : not (filter (left_cancel_semigroup empty) -> false)) : filter.ne_bot (classical.by_contradiction' h0) := sorry --non-trivial
lemma new_lemma_130499 (h0 : list (comm_group (has_add pos))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_130500 (h0 : topological_space (ordered_comm_monoid (has_add real))) : totally_disconnected_space (ordered_comm_monoid (has_add real)) := sorry --non-trivial
lemma new_lemma_130501 (h0 : functor.add_const (filter (has_to_string Type)) Type) : filter.ne_bot (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_130502 (h0 : topological_space (sub_neg_monoid name)) : t1_space (sub_neg_monoid name) := sorry --non-trivial
lemma new_lemma_130503 (h0 : function.extfun Type (functor.comp topological_space comm_group)) : @regular_space.{0} (comm_group.{0} pos) (@functor.comp.run.{0 0 0} topological_space.{0} comm_group.{0} pos (@function.extfun_app.{2 1} Type (functor.comp.{0 0 0} topological_space.{0} comm_group.{0}) h0 pos))  := sorry --non-trivial
lemma new_lemma_130504 (h0 : function.extfun Type topological_space) : @preirreducible_space.{0} (random_gen.{0} fun_info) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (random_gen.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_130505 (h0 : not (function.extfun Type topological_space -> false)) : @t0_space.{0} (option.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (option.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_130506 (h0 : functor.add_const (function.extfun Type topological_space) real) : @regular_space.{0} (comm_semigroup.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) real h0) (comm_semigroup.{0} name))  := sorry --non-trivial
lemma new_lemma_130507 (h0 : uniform_space (has_add (finset name))) : complete_space (has_add (finset name)) := sorry --non-trivial
lemma new_lemma_130508 (h0 : topological_space (filter unsigned)) : t1_space (filter unsigned) := sorry --non-trivial
lemma new_lemma_130509 (h0 : topological_space (has_one (semiring (semiring unsigned)))) : irreducible_space (has_one (semiring (semiring unsigned))) := sorry --non-trivial
lemma new_lemma_130510 (h0 : functor.add_const (filter (ring name)) Type) : filter.ne_bot (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_130511 (h0 : functor.add_const (function.extfun (Type 1) finset) (has_neg Type)) : finset.nonempty (function.extfun_app (functor.add_const.run h0) (semigroup Type)) := sorry --non-trivial
lemma new_lemma_130512 (h0 : monoid string.iterator) : monoid.fg string.iterator := sorry --non-trivial
lemma new_lemma_130513 (h0 : std_gen -> ereal) : function.bijective h0 := sorry --non-trivial
lemma new_lemma_130514 (h0 : topological_space (sub_neg_monoid (has_Inf linarith.comp))) : t0_space (sub_neg_monoid (has_Inf linarith.comp)) := sorry --non-trivial
lemma new_lemma_130515 (h0 : measurable_space char) (h1 : has_inf char) : has_measurable_inf char := sorry --non-trivial
lemma new_lemma_130516 (h0 : has_mem.mem (semiring (random_gen num)) has_emptyc.emptyc) : @totally_disconnected_space.{0} (semiring.{0} (random_gen.{0} num)) (@finset.pi.empty.{1 0} Type topological_space.{0} (semiring.{0} (random_gen.{0} num)) h0)  := sorry --non-trivial
lemma new_lemma_130517 (h0 : add_group (has_top (has_top num))) : is_add_cyclic (has_top (has_top num)) := sorry --non-trivial
lemma new_lemma_130518 (h0 : topological_space (comm_ring (has_ssubset linarith.ineq))) : path_connected_space (comm_ring (has_ssubset linarith.ineq)) := sorry --non-trivial
lemma new_lemma_130519 (h0 : functor.add_const (list (ring environment.implicit_infer_kind)) (has_add Type)) : list.nodup (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_130520 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_add_cyclic.{0} (ordered_comm_ring.{0} pos) (@function.extfun_app.{2 1} Type add_group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 add_group.{0}) (ordered_comm_ring.{0} pos))  := sorry --non-trivial
lemma new_lemma_130521 (h0 : function.extfun Type topological_space) : @discrete_topology.{0} (omega_complete_partial_order.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (omega_complete_partial_order.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_130522 (h0 : functor.add_const (topological_space auto.case_option) empty) : @normal_space.{0} auto.case_option (@functor.add_const.run.{0 0} (topological_space.{0} auto.case_option) empty h0)  := sorry --non-trivial
lemma new_lemma_130523 (h0 : setoid reducibility_hints) (h1 : complete_lattice (quotient h0)) : complete_lattice.is_Sup_finite_compact (quotient h0) := sorry --non-trivial
lemma new_lemma_130524 (h0 : topological_space (left_cancel_semigroup (semiring (semiring empty)))) : preirreducible_space (left_cancel_semigroup (semiring (semiring empty))) := sorry --non-trivial
lemma new_lemma_130525 (h0 : ring (semigroup (has_Inf Type))) : is_domain (semigroup (has_Inf Type)) := sorry --non-trivial
lemma new_lemma_130526 (h0 : topological_space (simple_graph linarith.comp)) : topological_space.separable_space (simple_graph linarith.comp) := sorry --non-trivial
lemma new_lemma_130527 (h0 : topological_space (ring (has_neg Type))) : totally_disconnected_space (ring (has_neg Type)) := sorry --non-trivial
lemma new_lemma_130528 (h0 : complete_lattice (semiring (semiring (semiring fun_info)))) : is_atomistic (semiring (semiring (semiring fun_info))) := sorry --non-trivial
lemma new_lemma_130529 (h0 : not (topological_space char -> false)) : @totally_disconnected_space.{0} char (@classical.by_contradiction'.{1} (topological_space.{0} char) h0)  := sorry --non-trivial
lemma new_lemma_130530 (h0 : complete_lattice (comm_ring (metric_space (random_gen reducibility_hints)))) : is_compactly_generated (comm_ring (metric_space (random_gen reducibility_hints))) := sorry --non-trivial
lemma new_lemma_130531 (h0 : ring (canonically_linear_ordered_monoid ennreal)) : rank_condition (canonically_linear_ordered_monoid ennreal) := sorry --non-trivial
lemma new_lemma_130532 (h0 : functor.add_const (complete_lattice (has_to_string pos)) linarith.comp) : @complete_lattice.is_Sup_finite_compact.{0} (has_to_string.{0} pos) (@functor.add_const.run.{0 0} (complete_lattice.{0} (has_to_string.{0} pos)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_130533 (h0 : topological_space (has_to_string (finset Type))) : totally_separated_space (has_to_string (finset Type)) := sorry --non-trivial
lemma new_lemma_130534 (h0 : ring (semiring (random_gen (random_gen fun_info)))) : is_domain (semiring (random_gen (random_gen fun_info))) := sorry --non-trivial
lemma new_lemma_130535 (h0 : functor.add_const (function.extfun Type ring) pos) : @rank_condition.{0} (boolean_algebra.core.{0} name) (@function.extfun_app.{2 1} Type ring.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type ring.{0}) pos h0) (boolean_algebra.core.{0} name))  := sorry --non-trivial
lemma new_lemma_130536 (h0 : ring (has_append (has_nnnorm (has_nnnorm linarith.comp_source)))) : strong_rank_condition (has_append (has_nnnorm (has_nnnorm linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_130537 (h0 : topological_space (has_to_string (ring linarith.comp))) : normal_space (has_to_string (ring linarith.comp)) := sorry --non-trivial
lemma new_lemma_130538 (h0 : ring (has_compl (has_inv (has_inv linarith.comp_source)))) : is_domain (has_compl (has_inv (has_inv linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_130539 (h0 : topological_space (linear_ordered_comm_group num)) : loc_path_connected_space (linear_ordered_comm_group num) := sorry --non-trivial
lemma new_lemma_130540 (h0 : ring (boolean_algebra.core (option (option empty)))) : is_domain (boolean_algebra.core (option (option empty))) := sorry --non-trivial
lemma new_lemma_130541 (h0 : functor.add_const (filter (cancel_monoid name)) ennreal) : filter.ne_bot (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_130542 (h0 : topological_space (measurable_space (random_gen (has_top to_additive.value_type)))) : locally_compact_space (measurable_space (random_gen (has_top to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_130543 (h0 : complete_lattice (ring (option (option (option (option (option (option empty)))))))) : is_atomistic (ring (option (option (option (option (option (option empty))))))) := sorry --non-trivial
lemma new_lemma_130544 (h0 : group (filter (has_Inf linarith.comp))) : is_cyclic (filter (has_Inf linarith.comp)) := sorry --non-trivial
lemma new_lemma_130545 (h0 : function.extfun Type group) : @is_cyclic.{0} (add_comm_monoid.{0} (option.{0} ennreal)) (@function.extfun_app.{2 1} Type group.{0} h0 (add_comm_monoid.{0} (option.{0} ennreal)))  := sorry --non-trivial
lemma new_lemma_130546 (h0 : semiring (has_bot (option empty))) : is_noetherian_ring (has_bot (option empty)) := sorry --non-trivial
lemma new_lemma_130547 (h0 : group (semiring (has_norm empty))) : normalizer_condition (semiring (has_norm empty)) := sorry --non-trivial
lemma new_lemma_130548 (h0 : functor.add_const (filter (boolean_algebra linarith.comp)) linarith.comp) : countable_Inter_filter (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_130549 (h0 : ring (has_add (random_gen char))) : is_domain (has_add (random_gen char)) := sorry --non-trivial
lemma new_lemma_130550 (h2 : uniform_space (denumerable char)) : complete_space (denumerable char) := sorry --non-trivial
lemma new_lemma_130551 (h0 : functor.add_const (topological_space (left_cancel_monoid empty)) congr_arg_kind) : @locally_compact_space.{0} (left_cancel_monoid.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (left_cancel_monoid.{0} empty)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_130552 (h0 : uniform_space (boolean_algebra (finset linarith.comp))) : separated_space (boolean_algebra (finset linarith.comp)) := sorry --non-trivial
lemma new_lemma_130553 (h0 : functor.add_const (functor.add_const (finset environment.implicit_infer_kind) pos) environment.implicit_infer_kind) : finset.nonempty (functor.add_const.run (functor.add_const.run h0)) := sorry --non-trivial
lemma new_lemma_130554 (h0 : ring (complete_distrib_lattice unsigned)) : is_principal_ideal_ring (complete_distrib_lattice unsigned) := sorry --non-trivial
lemma new_lemma_130555 (h0 : functor.add_const (ring (ordered_ring empty)) empty) : @rank_condition.{0} (ordered_ring.{0} empty) (@functor.add_const.run.{0 0} (ring.{0} (ordered_ring.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_130556 (h0 : functor.add_const (ordered_comm_monoid (complete_distrib_lattice linarith.comp)) linarith.comp) : @has_exists_mul_of_le.{0} (complete_distrib_lattice.{0} linarith.comp) (@functor.add_const.run.{0 0} (ordered_comm_monoid.{0} (complete_distrib_lattice.{0} linarith.comp)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_130557 (h1 : topological_space (has_emptyc to_additive.value_type)) : totally_separated_space (has_emptyc to_additive.value_type) := sorry --non-trivial
lemma new_lemma_130558 (h1 : has_le (nondiscrete_normed_field ereal)) (h2 : nondiscrete_normed_field ereal) : is_max h2 := sorry --non-trivial
lemma new_lemma_130559 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : palindrome (function.extfun_app (function.extfun_app h0 list) (ordered_comm_monoid name)) := sorry --non-trivial
lemma new_lemma_130560 (h0 : topological_space (simple_graph to_additive.value_type)) (h1 : add_group (simple_graph to_additive.value_type)) : topological_add_group (simple_graph to_additive.value_type) := sorry --non-trivial
lemma new_lemma_130561 (h0 : group (with_one (random_gen to_additive.value_type))) : is_cyclic (with_one (random_gen to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_130562 (h0 : ordered_comm_monoid (add_cancel_monoid (has_pos_part (has_pos_part pos)))) : has_exists_mul_of_le (add_cancel_monoid (has_pos_part (has_pos_part pos))) := sorry --non-trivial
lemma new_lemma_130563 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_add_cyclic.{0} linarith.comp_source (@function.extfun_app.{2 1} Type add_group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 add_group.{0}) linarith.comp_source)  := sorry --non-trivial
lemma new_lemma_130564 (h0 : functor.add_const (finset (boolean_algebra Type)) name) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_130565 (h0 : functor.add_const (topological_space (canonically_ordered_comm_semiring ennreal)) name) : @totally_disconnected_space.{0} (canonically_ordered_comm_semiring.{0} ennreal) (@functor.add_const.run.{0 0} (topological_space.{0} (canonically_ordered_comm_semiring.{0} ennreal)) name h0)  := sorry --non-trivial
lemma new_lemma_130566 (h0 : not (complete_lattice (semi_normed_ring (mul_one_class linarith.comp_source)) -> false)) : @is_compactly_generated.{0} (semi_normed_ring.{0} (mul_one_class.{0} linarith.comp_source)) (@classical.by_contradiction'.{1} (complete_lattice.{0} (semi_normed_ring.{0} (mul_one_class.{0} linarith.comp_source))) h0)  := sorry --non-trivial
lemma new_lemma_130567 (h0 : ring (boolean_algebra (has_neg linarith.comp))) : is_principal_ideal_ring (boolean_algebra (has_neg linarith.comp)) := sorry --non-trivial
lemma new_lemma_130568 (h2 : topological_space (measurable_space string_imp)) : locally_compact_space (measurable_space string_imp) := sorry --non-trivial
lemma new_lemma_130569 (h0 : functor.add_const (topological_space (boolean_algebra linarith.comp)) (add_comm_monoid pos)) : @t1_space.{0} (boolean_algebra.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (boolean_algebra.{0} linarith.comp)) (add_comm_monoid.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_130570 (h0 : add_monoid (semigroup (has_neg linarith.comp))) : add_monoid.fg (semigroup (has_neg linarith.comp)) := sorry --non-trivial
lemma new_lemma_130571 (h0 : semiring (monoid (option (option (option empty))))) : is_noetherian_ring (monoid (option (option (option empty)))) := sorry --non-trivial
lemma new_lemma_130572 (h0 : group (has_Sup (option empty))) : group.fg (has_Sup (option empty)) := sorry --non-trivial
lemma new_lemma_130573 (h0 : fin has_zero.zero) : @normalizer_condition.{0} (has_bot.{0} name) (@function.extfun_app.{2 1} Type group.{0} (@matrix.vec_empty.{1} (function.extfun.{2 1} Type group.{0}) h0) (has_bot.{0} name))  := sorry --non-trivial
lemma new_lemma_130574 (h0 : topological_space (normed_group (has_norm (has_norm congr_arg_kind)))) : discrete_topology (normed_group (has_norm (has_norm congr_arg_kind))) := sorry --non-trivial
lemma new_lemma_130575 (h0 : ring (linear_ordered_field (has_to_string pos))) : is_principal_ideal_ring (linear_ordered_field (has_to_string pos)) := sorry --non-trivial
lemma new_lemma_130576 (h0 : function.extfun Type (functor.add_const (function.extfun Type complete_lattice))) : @is_compactly_generated.{0} (mul_zero_class.{0} pos) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type complete_lattice.{0}) pos (@function.extfun_app.{2 2} Type (functor.add_const.{1 0} (function.extfun.{2 1} Type complete_lattice.{0})) h0 pos)) (mul_zero_class.{0} pos))  := sorry --non-trivial
lemma new_lemma_130577 (h0 : function.extfun Type (functor.add_const (ring linarith.comp))) : @is_domain.{0} linarith.comp (@functor.add_const.run.{0 0} (ring.{0} linarith.comp) linarith.comp (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (ring.{0} linarith.comp)) h0 linarith.comp))  := sorry --non-trivial
lemma new_lemma_130578 (h0 : function.extfun Type topological_space) : @preconnected_space.{0} (sub_neg_monoid.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (sub_neg_monoid.{0} pos))  := sorry --non-trivial
lemma new_lemma_130579 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @add_monoid.fg.{0} (ordered_cancel_add_comm_monoid.{0} unsigned) (@function.extfun_app.{2 1} Type add_monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 add_monoid.{0}) (ordered_cancel_add_comm_monoid.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_130580 (h0 : topological_space (generalized_boolean_algebra (boolean_algebra.core Type))) : discrete_topology (generalized_boolean_algebra (boolean_algebra.core Type)) := sorry --non-trivial
lemma new_lemma_130581 (h0 : group (add_cancel_monoid (comm_group pos))) : is_simple_group (add_cancel_monoid (comm_group pos)) := sorry --non-trivial
lemma new_lemma_130582 (h0 : topological_space (left_cancel_monoid (semiring empty))) : t0_space (left_cancel_monoid (semiring empty)) := sorry --non-trivial
lemma new_lemma_130583 (h1 h2 : multiset (add_comm_semigroup (mul_one_class std_gen))) : multiset.le h1 h2 := sorry --non-trivial
lemma new_lemma_130584 (h0 : function.extfun (Type 1) topological_space) : @t0_space.{1} (plift.{1} congr_arg_kind) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} h0 (plift.{1} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_130585 (h0 : topological_space (comm_group (option (option ennreal)))) : sequential_space (comm_group (option (option ennreal))) := sorry --non-trivial
lemma new_lemma_130586 (h0 : has_mem.mem (has_emptyc linarith.comp) has_emptyc.emptyc) : @totally_disconnected_space.{0} (has_emptyc.{0} linarith.comp) (@finset.pi.empty.{1 0} Type topological_space.{0} (has_emptyc.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_130587 (h0 : topological_space (has_pos_part (finset Type))) : preconnected_space (has_pos_part (finset Type)) := sorry --non-trivial
lemma new_lemma_130588 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @sequential_space.{0} (add_cancel_monoid.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (add_cancel_monoid.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_130589 (h0 : function.extfun Type monoid) : @monoid.fg.{0} (ordered_comm_ring.{0} linarith.comp) (@function.extfun_app.{2 1} Type monoid.{0} h0 (ordered_comm_ring.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_130590 (h0 : topological_space (with_one (has_norm linarith.comp))) : irreducible_space (with_one (has_norm linarith.comp)) := sorry --non-trivial
lemma new_lemma_130591 (h0 : functor.add_const (function.extfun (Type 1) topological_space) linarith.comp) : @topological_space.separable_space.{1} (has_add.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) topological_space.{1}) linarith.comp h0) (has_add.{1} Type))  := sorry --non-trivial
lemma new_lemma_130592 (h0 : functor.add_const (topological_space (add_cancel_monoid Type)) (has_add Type)) : @regular_space.{1} (add_cancel_monoid.{1} Type) (@functor.add_const.run.{1 1} (topological_space.{1} (add_cancel_monoid.{1} Type)) (has_add.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_130593 (h0 : functor.add_const (topological_space (canonically_ordered_monoid pos)) real) : @loc_path_connected_space.{0} (canonically_ordered_monoid.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (canonically_ordered_monoid.{0} pos)) real h0)  := sorry --non-trivial
lemma new_lemma_130594 (h0 h1 : list char) : list.is_infix h0 h1 := sorry --non-trivial
lemma new_lemma_130595 (h0 : function.extfun Type (prod (id empty))) : id_rel (function.extfun_app h0 (id empty)) := sorry --non-trivial
lemma new_lemma_130596 (h0 : topological_space (has_bot (has_Inf (has_Inf (has_Inf (sub_neg_monoid real)))))) : totally_separated_space (has_bot (has_Inf (has_Inf (has_Inf (sub_neg_monoid real))))) := sorry --non-trivial
lemma new_lemma_130597 (h0 : topological_space (boolean_algebra.core (has_neg_part Type))) : preconnected_space (boolean_algebra.core (has_neg_part Type)) := sorry --non-trivial
lemma new_lemma_130598 (h0 : functor.add_const (ring (boolean_algebra.core name)) Type) : @is_principal_ideal_ring.{0} (boolean_algebra.core.{0} name) (@functor.add_const.run.{0 1} (ring.{0} (boolean_algebra.core.{0} name)) Type h0)  := sorry --non-trivial
lemma new_lemma_130599 (h0 : functor.add_const (topological_space (has_add Type)) pos) : @normal_space.{1} (has_add.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (has_add.{1} Type)) pos h0)  := sorry --non-trivial
lemma new_lemma_130600 (h0 : not (group (semiring (has_norm linarith.comp_source)) -> false)) : @is_cyclic.{0} (semiring.{0} (has_norm.{0} linarith.comp_source)) (@classical.by_contradiction'.{1} (group.{0} (semiring.{0} (has_norm.{0} linarith.comp_source))) h0)  := sorry --non-trivial
lemma new_lemma_130601 (h0 : prod (has_zero (boolean_algebra.core Type)) (has_zero (boolean_algebra.core Type))) : id_rel h0 := sorry --non-trivial
lemma new_lemma_130602 (h0 : ring (linear_ordered_comm_group_with_zero environment.projection_info)) : is_domain (linear_ordered_comm_group_with_zero environment.projection_info) := sorry --non-trivial
lemma new_lemma_130603 (h0 : complete_lattice (complete_distrib_lattice (option empty))) : is_atomistic (complete_distrib_lattice (option empty)) := sorry --non-trivial
lemma new_lemma_130604 (h0 : functor.add_const (complete_lattice (has_add pos)) (has_to_string (has_add Type))) : @complete_lattice.is_Sup_finite_compact.{0} (has_add.{0} pos) (@functor.add_const.run.{0 1} (complete_lattice.{0} (has_add.{0} pos)) (has_to_string.{1} (has_add.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_130605 (h0 : topological_space (normed_lattice_add_comm_group (comm_semigroup pos))) : preconnected_space (normed_lattice_add_comm_group (comm_semigroup pos)) := sorry --non-trivial
lemma new_lemma_130606 (h0 : function.extfun Type topological_space) : @path_connected_space.{0} (generalized_boolean_algebra.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (generalized_boolean_algebra.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_130607 (h0 : function.extfun Type ordered_add_comm_monoid) : @archimedean.{0} (normed_comm_ring.{0} unsigned) (@function.extfun_app.{2 1} Type ordered_add_comm_monoid.{0} h0 (normed_comm_ring.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_130608 (h0 : add_group (is_R_or_C (semiring (semiring unsigned)))) : is_add_cyclic (is_R_or_C (semiring (semiring unsigned))) := sorry --non-trivial
lemma new_lemma_130609 (h0 : functor.add_const (functor.add_const (group linarith.comp) linarith.comp) (finset linarith.comp)) : @group.fg.{0} linarith.comp (@functor.add_const.run.{0 0} (group.{0} linarith.comp) linarith.comp (@functor.add_const.run.{0 0} (functor.add_const.{0 0} (group.{0} linarith.comp) linarith.comp) (finset.{0} linarith.comp) h0))  := sorry --non-trivial
lemma new_lemma_130610 (h0 : topological_space (has_div reducibility_hints)) (h1 : preorder (has_div reducibility_hints)) : order_topology (has_div reducibility_hints) := sorry --non-trivial
lemma new_lemma_130611 (h0 : function.extfun Type topological_space) : @totally_separated_space.{0} (linear_ordered_field.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (linear_ordered_field.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_130612 (h0 : function.extfun Type (functor.add_const (group (add_cancel_comm_monoid empty)))) : @is_cyclic.{0} (add_cancel_comm_monoid.{0} empty) (@functor.add_const.run.{0 0} (group.{0} (add_cancel_comm_monoid.{0} empty)) unsigned (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (group.{0} (add_cancel_comm_monoid.{0} empty))) h0 unsigned))  := sorry --non-trivial
lemma new_lemma_130613 (h1 : measurable_space (nondiscrete_normed_field (normed_field reducibility_hints))) (h2 : measure_theory.measure (nondiscrete_normed_field (normed_field reducibility_hints))) : measure_theory.is_finite_measure h2 := sorry --non-trivial
lemma new_lemma_130614 (h0 : function.extfun Type topological_space) : @t0_space.{0} (comm_ring.{0} (has_nnnorm.{0} (linear_ordered_add_comm_group.{0} linarith.ineq))) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (comm_ring.{0} (has_nnnorm.{0} (linear_ordered_add_comm_group.{0} linarith.ineq))))  := sorry --non-trivial
lemma new_lemma_130615 (h0 : uniform_space (has_add (ring linarith.comp))) : complete_space (has_add (ring linarith.comp)) := sorry --non-trivial
lemma new_lemma_130616 (h0 : finset (semigroup (has_neg (finset (finset linarith.comp))))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_130617 (h0 : group (ordered_comm_group unsigned)) : group.fg (ordered_comm_group unsigned) := sorry --non-trivial
lemma new_lemma_130618 (h0 : topological_space (has_pos_part (ring pos))) : sequential_space (has_pos_part (ring pos)) := sorry --non-trivial
lemma new_lemma_130619 (h1 : monoid (has_top (random_gen to_additive.value_type))) : monoid.fg (has_top (random_gen to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_130620 (h0 : function.extfun (Type 1) ordered_comm_monoid) : @has_exists_mul_of_le.{1} (generalized_boolean_algebra.{1} Type) (@function.extfun_app.{3 2} (Type 1) ordered_comm_monoid.{1} h0 (generalized_boolean_algebra.{1} Type))  := sorry --non-trivial
lemma new_lemma_130621 (h0 : function.extfun Type group) : @normalizer_condition.{0} (has_inv.{0} linarith.ineq) (@function.extfun_app.{2 1} Type group.{0} h0 (has_inv.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_130622 (h0 : topological_space (complete_distrib_lattice (boolean_algebra.core (boolean_algebra name)))) : t1_space (complete_distrib_lattice (boolean_algebra.core (boolean_algebra name))) := sorry --non-trivial
lemma new_lemma_130623 (h0 : has_mem.mem (random_gen fun_info) has_emptyc.emptyc) : @is_compactly_generated.{0} (random_gen.{0} fun_info) (@finset.pi.empty.{1 0} Type complete_lattice.{0} (random_gen.{0} fun_info) h0)  := sorry --non-trivial
lemma new_lemma_130624 (h0 : function.extfun Type topological_space) : @t0_space.{0} (has_ssubset.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_ssubset.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_130625 (h0 : add_group (with_bot (semiring num))) : is_add_cyclic (with_bot (semiring num)) := sorry --non-trivial
lemma new_lemma_130626 (h0 : topological_space (complete_distrib_lattice (sub_neg_monoid real))) : discrete_topology (complete_distrib_lattice (sub_neg_monoid real)) := sorry --non-trivial
lemma new_lemma_130627 (h0 : functor.add_const (finset (monoid num)) empty) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_130628 (h0 : functor.add_const (ring (ring pos)) (has_nndist (ring Type))) : @is_domain.{0} (ring.{0} pos) (@functor.add_const.run.{0 1} (ring.{0} (ring.{0} pos)) (has_nndist.{1} (ring.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_130629 (h0 : fin has_zero.zero) : @complete_space.{0} (has_bot.{0} (has_add.{0} linarith.comp)) (@matrix.vec_empty.{0} (uniform_space.{0} (has_bot.{0} (has_add.{0} linarith.comp))) h0)  := sorry --non-trivial
lemma new_lemma_130630 (h0 : topological_space (semigroup (finset (finset (finset (finset (has_pos_part (finset Type)))))))) : sequential_space (semigroup (finset (finset (finset (finset (has_pos_part (finset Type))))))) := sorry --non-trivial
lemma new_lemma_130631 (h0 : functor.add_const (semiring (ring Type)) (has_pos_part (has_add (boolean_algebra.core linarith.comp)))) : @is_noetherian_ring.{1} (ring.{1} Type) (@functor.add_const.run.{1 0} (semiring.{1} (ring.{1} Type)) (has_pos_part.{0} (has_add.{0} (boolean_algebra.core.{0} linarith.comp))) h0)  := sorry --non-trivial
lemma new_lemma_130632 (h0 : ordered_comm_monoid (ordered_comm_ring (has_add linarith.comp))) : has_exists_mul_of_le (ordered_comm_ring (has_add linarith.comp)) := sorry --non-trivial
lemma new_lemma_130633 (h0 : topological_space (simple_graph (has_Inf linarith.comp))) : t0_space (simple_graph (has_Inf linarith.comp)) := sorry --non-trivial
lemma new_lemma_130634 (h0 : semiring (has_Inf (ring (ring linarith.comp)))) : is_noetherian_ring (has_Inf (ring (ring linarith.comp))) := sorry --non-trivial
lemma new_lemma_130635 (h0 : topological_space (option (option (option (option (option unsigned)))))) : totally_separated_space (option (option (option (option (option unsigned))))) := sorry --non-trivial
lemma new_lemma_130636 (h0 : filter (metric_space num)) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_130637 (h3 : set (fun_info -> char)) : set.separates_points h3 := sorry --non-trivial
lemma new_lemma_130638 (h0 : complete_lattice (has_neg (finset pos))) : is_compactly_generated (has_neg (finset pos)) := sorry --non-trivial
lemma new_lemma_130639 (h0 : not (topological_space (has_nndist empty) -> false)) : @locally_compact_space.{0} (has_nndist.{0} empty) (@classical.by_contradiction'.{1} (topological_space.{0} (has_nndist.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_130640 (h0 : function.extfun Type topological_space) : @path_connected_space.{0} (canonically_linear_ordered_monoid.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (canonically_linear_ordered_monoid.{0} num))  := sorry --non-trivial
lemma new_lemma_130641 (h0 : function.extfun (Type 1 -> Type) (function.extfun (Type 1))) : functor.add_const.run (function.extfun_app (function.extfun_app h0 (functor.add_const Prop)) Type) := sorry --non-trivial
lemma new_lemma_130642 (h0 : function.extfun nat fin) : @group.fg.{1} (has_add.{1} Type) (@matrix.vec_empty.{1} (group.{1} (has_add.{1} Type)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_130643 (h0 : function.extfun Type topological_space) : @path_connected_space.{0} (measurable_space.{0} string_imp) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (measurable_space.{0} string_imp))  := sorry --non-trivial
lemma new_lemma_130644 (h0 : functor.add_const (topological_space (add_group unsigned)) (semiring unsigned)) : @locally_compact_space.{0} (add_group.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (add_group.{0} unsigned)) (semiring.{0} unsigned) h0)  := sorry --non-trivial
lemma new_lemma_130645 (h0 : functor.add_const (topological_space (add_cancel_monoid pos)) (has_nndist environment.implicit_infer_kind)) : @regular_space.{0} (add_cancel_monoid.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (add_cancel_monoid.{0} pos)) (has_nndist.{0} environment.implicit_infer_kind) h0)  := sorry --non-trivial
lemma new_lemma_130646 (h0 : add_monoid (add_comm_monoid (has_to_string (has_add name)))) : add_monoid.fg (add_comm_monoid (has_to_string (has_add name))) := sorry --non-trivial
lemma new_lemma_130647 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @separated_space.{0} (has_pos_part.{0} pos) (@function.extfun_app.{2 1} Type uniform_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 uniform_space.{0}) (has_pos_part.{0} pos))  := sorry --non-trivial
lemma new_lemma_130648 (h0 : function.extfun Type ring) : @is_domain.{0} (linear_ordered_add_comm_group.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type ring.{0} h0 (linear_ordered_add_comm_group.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_130649 (h0 : has_lt ordering) : no_max_order ordering := sorry --non-trivial
lemma new_lemma_130650 (h1 : complete_lattice (non_unital_non_assoc_semiring string_imp)) : complete_lattice.is_Sup_finite_compact (non_unital_non_assoc_semiring string_imp) := sorry --non-trivial
lemma new_lemma_130651 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @totally_disconnected_space.{0} (ring.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (ring.{0} empty))  := sorry --non-trivial
lemma new_lemma_130652 (h3 : filter (fintype (add_monoid to_additive.value_type))) : filter.ne_bot h3 := sorry --non-trivial
lemma new_lemma_130653 (h1 : group (has_add to_additive.value_type)) : is_cyclic (has_add to_additive.value_type) := sorry --non-trivial
lemma new_lemma_130654 (h0 : finset (has_union empty)) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_130655 (h0 : topological_space (group_with_zero (option ennreal))) : totally_disconnected_space (group_with_zero (option ennreal)) := sorry --non-trivial
lemma new_lemma_130656 (h0 : functor.add_const (topological_space (left_cancel_monoid num)) empty) : @totally_disconnected_space.{0} (left_cancel_monoid.{0} num) (@functor.add_const.run.{0 0} (topological_space.{0} (left_cancel_monoid.{0} num)) empty h0)  := sorry --non-trivial
lemma new_lemma_130657 (h0 : list (sub_neg_monoid pos)) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_130658 (h0 : list (has_emptyc (has_top linarith.comp_source))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_130659 (h0 : functor.add_const (topological_space (add_cancel_monoid linarith.comp)) (has_neg Type)) : @loc_path_connected_space.{0} (add_cancel_monoid.{0} linarith.comp) (@functor.add_const.run.{0 1} (topological_space.{0} (add_cancel_monoid.{0} linarith.comp)) (has_neg.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_130660 (h0 : ordered_add_comm_monoid (monoid (option ennreal))) : archimedean (monoid (option ennreal)) := sorry --non-trivial
lemma new_lemma_130661 (h0 : filter (dlist (has_norm string_imp))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_130662 (h0 : functor.add_const (topological_space (boolean_algebra environment.implicit_infer_kind)) name) : @path_connected_space.{0} (boolean_algebra.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (boolean_algebra.{0} environment.implicit_infer_kind)) name h0)  := sorry --non-trivial
lemma new_lemma_130663 (h0 : functor.add_const (group (boolean_algebra.core pos)) pos) : @is_cyclic.{0} (boolean_algebra.core.{0} pos) (@functor.add_const.run.{0 0} (group.{0} (boolean_algebra.core.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_130664 (h0 : ring (has_ssubset (denumerable reducibility_hints))) : rank_condition (has_ssubset (denumerable reducibility_hints)) := sorry --non-trivial
lemma new_lemma_130665 (h0 : ring (ordered_comm_ring (has_Inf (has_add Type)))) : is_domain (ordered_comm_ring (has_Inf (has_add Type))) := sorry --non-trivial
lemma new_lemma_130666 (h0 : functor.add_const (list (add_cancel_monoid unsigned)) unsigned) : palindrome (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_130667 (h0 : function.extfun Type (functor.add_const Prop)) : functor.add_const.run (function.extfun_app h0 (has_add ennreal)) := sorry --non-trivial
lemma new_lemma_130668 (h1 : complete_lattice (has_nnnorm (has_inv string_imp))) : is_compactly_generated (has_nnnorm (has_inv string_imp)) := sorry --non-trivial
lemma new_lemma_130669 (h0 : complete_lattice (complete_semilattice_Sup (has_inv (has_inv fun_info)))) : is_atomistic (complete_semilattice_Sup (has_inv (has_inv fun_info))) := sorry --non-trivial
lemma new_lemma_130670 (h0 : functor.add_const (topological_space (normed_comm_ring linarith.comp)) Type) : @t1_space.{0} (normed_comm_ring.{0} linarith.comp) (@functor.add_const.run.{0 1} (topological_space.{0} (normed_comm_ring.{0} linarith.comp)) Type h0)  := sorry --non-trivial
lemma new_lemma_130671 (h0 : topological_space (has_to_string (has_add (has_to_string (finset (finset pos)))))) : preconnected_space (has_to_string (has_add (has_to_string (finset (finset pos))))) := sorry --non-trivial
lemma new_lemma_130672 (h0 : function.extfun Type topological_space) : @totally_disconnected_space.{0} (monoid_with_zero.{0} ennreal) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (monoid_with_zero.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_130673 (h0 : function.extfun Type topological_space) : @totally_separated_space.{0} (boolean_algebra.core.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (boolean_algebra.core.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_130674 (h0 : add_group (has_Inf (has_add (has_Inf (has_add (has_add linarith.comp)))))) : is_add_cyclic (has_Inf (has_add (has_Inf (has_add (has_add linarith.comp))))) := sorry --non-trivial
lemma new_lemma_130675 (h0 : has_coe (add_comm_semigroup (nondiscrete_normed_field fun_info)) Prop) (h1 : add_comm_semigroup (nondiscrete_normed_field fun_info)) : @coe_b.{1 1} (add_comm_semigroup.{0} (nondiscrete_normed_field.{0} fun_info)) Prop h0 h1  := sorry --non-trivial
lemma new_lemma_130676 (h0 : ring (ring (normed_comm_ring environment.implicit_infer_kind))) : rank_condition (ring (normed_comm_ring environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_130677 (h0 : ring (complete_distrib_lattice (option empty))) : is_domain (complete_distrib_lattice (option empty)) := sorry --non-trivial
lemma new_lemma_130678 (h0 : topological_space (linear_ordered_semiring (semiring (linear_ordered_semiring unsigned)))) : irreducible_space (linear_ordered_semiring (semiring (linear_ordered_semiring unsigned))) := sorry --non-trivial
lemma new_lemma_130679 (h0 : functor.add_const (topological_space Type) (finset pos)) : @regular_space.{1} Type (@functor.add_const.run.{1 0} (topological_space.{1} Type) (finset.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_130680 (h0 : group (has_bot (has_add Type))) : is_cyclic (has_bot (has_add Type)) := sorry --non-trivial
lemma new_lemma_130681 (h0 : functor.add_const (topological_space (has_add environment.implicit_infer_kind)) Type) : @sequential_space.{0} (has_add.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 1} (topological_space.{0} (has_add.{0} environment.implicit_infer_kind)) Type h0)  := sorry --non-trivial
lemma new_lemma_130682 (h0 : has_mem.mem (id linarith.comp) has_emptyc.emptyc) : @is_add_cyclic.{0} (@id.{2} Type linarith.comp) (@finset.pi.empty.{1 0} Type add_group.{0} (@id.{2} Type linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_130683 (h0 : not (function.extfun Type group -> false)) : @group.fg.{0} (linear_ordered_semiring.{0} num) (@function.extfun_app.{2 1} Type group.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type group.{0}) h0) (linear_ordered_semiring.{0} num))  := sorry --non-trivial
lemma new_lemma_130684 (h0 : ordered_add_comm_monoid (comm_group (comm_group name))) : archimedean (comm_group (comm_group name)) := sorry --non-trivial
lemma new_lemma_130685 (h0 : functor.add_const (monoid (has_to_string unsigned)) (has_add (has_add Type))) : @monoid.fg.{0} (has_to_string.{0} unsigned) (@functor.add_const.run.{0 1} (monoid.{0} (has_to_string.{0} unsigned)) (has_add.{1} (has_add.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_130686 (h0 : has_mem.mem string_imp has_emptyc.emptyc) : @rank_condition.{0} string_imp (@finset.pi.empty.{1 0} Type ring.{0} string_imp h0)  := sorry --non-trivial
lemma new_lemma_130687 (h0 : function.extfun Type filter) : filter.ne_bot (function.extfun_app h0 (omega_complete_partial_order empty)) := sorry --non-trivial
lemma new_lemma_130688 (h0 : not (topological_space (has_sub congr_arg_kind) -> false)) : @irreducible_space.{0} (has_sub.{0} congr_arg_kind) (@classical.by_contradiction'.{1} (topological_space.{0} (has_sub.{0} congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_130689 (h0 : function.extfun Type ring) : @rank_condition.{0} (canonically_linear_ordered_monoid.{0} ennreal) (@function.extfun_app.{2 1} Type ring.{0} h0 (canonically_linear_ordered_monoid.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_130690 (h0 : functor.add_const (topological_space (has_neg pos)) Type) : @path_connected_space.{0} (has_neg.{0} pos) (@functor.add_const.run.{0 1} (topological_space.{0} (has_neg.{0} pos)) Type h0)  := sorry --non-trivial
lemma new_lemma_130691 (h0 : topological_space (finset (has_Inf pos))) : path_connected_space (finset (has_Inf pos)) := sorry --non-trivial
lemma new_lemma_130692 (h0 : has_mem.mem (filter Prop) has_emptyc.emptyc) : @Lim.{0} Prop sierpinski_space (@nonempty_of_inhabited.{1} Prop sort.inhabited.{0}) (@list.head.{0} (filter.{0} Prop) (@filter.inhabited.{0} Prop) (@finset.pi.empty.{1 0} Type list.{0} (filter.{0} Prop) h0))  := sorry --non-trivial
lemma new_lemma_130693 (h0 : list (finset (with_bot (option name)))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_130694 (h0 : cancel_comm_monoid_with_zero (has_to_string (finset ennreal))) : unique_factorization_monoid (has_to_string (finset ennreal)) := sorry --non-trivial
lemma new_lemma_130695 (h0 : functor.add_const (complete_lattice (non_assoc_semiring unsigned)) unsigned) : @complete_lattice.is_Sup_finite_compact.{0} (non_assoc_semiring.{0} unsigned) (@functor.add_const.run.{0 0} (complete_lattice.{0} (non_assoc_semiring.{0} unsigned)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_130696 (h0 : ring (has_compl (comm_ring linarith.comp_source)) -> fun_info) (h1 : coe_sort (set.range h0)) : @rank_condition.{0} (has_compl.{0} (comm_ring.{0} linarith.comp_source)) (@set.range_splitting.{0 0} (ring.{0} (has_compl.{0} (comm_ring.{0} linarith.comp_source))) fun_info h0 h1)  := sorry --non-trivial
lemma new_lemma_130697 (h0 : fin has_zero.zero) : @normal_space.{0} (boolean_algebra.{0} pos) (@matrix.vec_empty.{0} (topological_space.{0} (boolean_algebra.{0} pos)) (@matrix.vec_empty.{0} (fin (@has_zero.zero.{0} nat nat.has_zero)) (@matrix.vec_empty.{0} (fin (@has_zero.zero.{0} nat nat.has_zero)) h0)))  := sorry --non-trivial
lemma new_lemma_130698 (h0 : uniform_space char) (h1 : group char) : uniform_group char := sorry --non-trivial
lemma new_lemma_130699 (h0 : order_embedding nat Prop) : @monotonic_sequence_limit.{0} Prop (@complete_semilattice_Inf.to_partial_order.{0} Prop (@complete_lattice.to_complete_semilattice_Inf.{0} Prop Prop.complete_lattice)) (@order_embedding.to_order_hom.{0 0} nat Prop (@partial_order.to_preorder.{0} nat (@ordered_cancel_add_comm_monoid.to_partial_order.{0} nat (@ordered_semiring.to_ordered_cancel_add_comm_monoid.{0} nat nat.ordered_semiring))) (@partial_order.to_preorder.{0} Prop (@complete_semilattice_Inf.to_partial_order.{0} Prop (@complete_lattice.to_complete_semilattice_Inf.{0} Prop Prop.complete_lattice))) h0)  := sorry --non-trivial
lemma new_lemma_130700 (h0 : functor.add_const (group (normed_comm_ring empty)) (option unsigned)) : @normalizer_condition.{0} (normed_comm_ring.{0} empty) (@functor.add_const.run.{0 0} (group.{0} (normed_comm_ring.{0} empty)) (option.{0} unsigned) h0)  := sorry --non-trivial
lemma new_lemma_130701 (h0 : semiring (semigroup linarith.comp)) : is_noetherian_ring (semigroup linarith.comp) := sorry --non-trivial
lemma new_lemma_130702 (h0 : ring (ring (add_comm_monoid Type))) : is_domain (ring (add_comm_monoid Type)) := sorry --non-trivial
lemma new_lemma_130703 (h0 : functor.add_const (uniform_space (boolean_algebra ennreal)) name) : @separated_space.{0} (boolean_algebra.{0} ennreal) (@functor.add_const.run.{0 0} (uniform_space.{0} (boolean_algebra.{0} ennreal)) name h0)  := sorry --non-trivial
lemma new_lemma_130704 (h0 : function.extfun Type topological_space) : @t0_space.{0} (measurable_space.{0} (semiring.{0} (has_norm.{0} (random_gen.{0} (random_gen.{0} (has_top.{0} congr_arg_kind)))))) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (measurable_space.{0} (semiring.{0} (has_norm.{0} (random_gen.{0} (random_gen.{0} (has_top.{0} congr_arg_kind)))))))  := sorry --non-trivial
lemma new_lemma_130705 (h0 : function.extfun nat fin) : @is_cyclic.{0} (has_Inf.{0} linarith.comp) (@matrix.vec_empty.{0} (group.{0} (has_Inf.{0} linarith.comp)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_130706 (h0 : functor.add_const (topological_space (has_zero linarith.comp)) name) : @t1_space.{0} (has_zero.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (has_zero.{0} linarith.comp)) name h0)  := sorry --non-trivial
lemma new_lemma_130707 (h0 : list (list Prop)) : list.head (id (list.head h0)) := sorry --non-trivial
lemma new_lemma_130708 (h0 : topological_space (has_nndist (has_Inf Type))) : t0_space (has_nndist (has_Inf Type)) := sorry --non-trivial
lemma new_lemma_130709 (h0 : semiring (add_cancel_monoid ennreal)) : is_noetherian_ring (add_cancel_monoid ennreal) := sorry --non-trivial
lemma new_lemma_130710 (h0 : topological_space (uniform_space (non_unital_non_assoc_ring linarith.ineq))) : t0_space (uniform_space (non_unital_non_assoc_ring linarith.ineq)) := sorry --non-trivial
lemma new_lemma_130711 (h0 : uniform_space (sub_neg_monoid (has_Inf (has_add real)))) : complete_space (sub_neg_monoid (has_Inf (has_add real))) := sorry --non-trivial
lemma new_lemma_130712 (h0 : function.extfun ((Type -> Type) -> Type 1) (function.extfun (Type -> Type))) : @is_domain.{0} (with_bot.{0} linarith.ineq) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) (@function.extfun_app.{3 2} ((Type → Type) → Type 1) (function.extfun.{2 2} (Type → Type)) h0 (function.extfun.{2 1} Type)) ring.{0}) (with_bot.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_130713 (h0 : ring (comm_group (has_to_string unsigned))) : is_domain (comm_group (has_to_string unsigned)) := sorry --non-trivial
lemma new_lemma_130714 (h0 : ring (has_emptyc (has_top (random_gen fun_info)))) : strong_rank_condition (has_emptyc (has_top (random_gen fun_info))) := sorry --non-trivial
lemma new_lemma_130715 (h0 : linear_ordered_ring (has_union empty)) (h1 : ring (has_union (floor_ring (has_union empty)))) : rank_condition (has_union (floor_ring (has_union empty))) := sorry --non-trivial
lemma new_lemma_130716 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : countable_Inter_filter (function.extfun_app (function.extfun_app h0 filter) (simple_graph pos)) := sorry --non-trivial
lemma new_lemma_130717 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @totally_separated_space.{0} (with_one.{0} string_imp) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (with_one.{0} string_imp))  := sorry --non-trivial
lemma new_lemma_130718 (h0 : cancel_comm_monoid_with_zero (normed_group empty)) : unique_factorization_monoid (normed_group empty) := sorry --non-trivial
lemma new_lemma_130719 (h0 : cancel_comm_monoid_with_zero (canonically_ordered_comm_semiring (option (option (option empty))))) : unique_factorization_monoid (canonically_ordered_comm_semiring (option (option (option empty)))) := sorry --non-trivial
lemma new_lemma_130720 (h0 : functor.add_const (topological_space (ring Type)) Type) : @t1_space.{1} (ring.{1} Type) (@functor.add_const.run.{1 1} (topological_space.{1} (ring.{1} Type)) Type h0)  := sorry --non-trivial
lemma new_lemma_130721 (h1 : ring (complete_semilattice_Sup char)) : rank_condition (complete_semilattice_Sup char) := sorry --non-trivial
lemma new_lemma_130722 (h0 : topological_space (bin_tree unsigned)) : loc_path_connected_space (bin_tree unsigned) := sorry --non-trivial
lemma new_lemma_130723 (h0 : functor.add_const (ring (has_zero name)) linarith.comp) : @is_domain.{0} (has_zero.{0} name) (@functor.add_const.run.{0 0} (ring.{0} (has_zero.{0} name)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_130724 (h0 : finset (has_top congr_arg_kind)) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_130725 (h0 : function.extfun Type topological_space) : @totally_disconnected_space.{0} (boolean_algebra.core.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (boolean_algebra.core.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_130726 (h0 : uniform_space (random_gen (has_top (has_top (has_top fun_info))))) : complete_space (random_gen (has_top (has_top (has_top fun_info)))) := sorry --non-trivial
lemma new_lemma_130727 (h0 : has_mem.mem (comm_semigroup (random_gen num)) has_emptyc.emptyc) : @strong_rank_condition.{0} (comm_semigroup.{0} (random_gen.{0} num)) (@finset.pi.empty.{1 0} Type ring.{0} (comm_semigroup.{0} (random_gen.{0} num)) h0)  := sorry --non-trivial
lemma new_lemma_130728 (h0 : topological_space (semigroup (finset (finset linarith.comp)))) : t1_space (semigroup (finset (finset linarith.comp))) := sorry --non-trivial
lemma new_lemma_130729 (h0 : complete_lattice (free_add_monoid (option unsigned))) : is_atomistic (free_add_monoid (option unsigned)) := sorry --non-trivial
lemma new_lemma_130730 (h0 : functor.add_const (topological_space (finset pos)) Type) : @discrete_topology.{0} (finset.{0} pos) (@functor.add_const.run.{0 1} (topological_space.{0} (finset.{0} pos)) Type h0)  := sorry --non-trivial
lemma new_lemma_130731 (h0 : group (normed_comm_ring (ring Type))) : is_cyclic (normed_comm_ring (ring Type)) := sorry --non-trivial
lemma new_lemma_130732 (h0 : functor.add_const (topological_space (monoid empty)) unsigned) : @preirreducible_space.{0} (monoid.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (monoid.{0} empty)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_130733 (h0 : group (sub_neg_monoid (has_pos_part linarith.comp))) : is_cyclic (sub_neg_monoid (has_pos_part linarith.comp)) := sorry --non-trivial
lemma new_lemma_130734 (h1 : not (filter (fintype fun_info) -> false)) : filter.ne_bot (classical.by_contradiction' h1) := sorry --non-trivial
lemma new_lemma_130735 (h0 : add_monoid (has_pos_part (has_add linarith.comp))) : add_monoid.fg (has_pos_part (has_add linarith.comp)) := sorry --non-trivial
lemma new_lemma_130736 (h0 : monoid (add_comm_monoid (finset linarith.comp))) : monoid.fg (add_comm_monoid (finset linarith.comp)) := sorry --non-trivial
lemma new_lemma_130737 (h0 : functor.add_const (topological_space (has_neg pos)) name) : @sequential_space.{0} (has_neg.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (has_neg.{0} pos)) name h0)  := sorry --non-trivial
lemma new_lemma_130738 (h0 : has_mem.mem (id to_additive.value_type) has_emptyc.emptyc) : @is_compactly_generated.{0} (@id.{2} Type to_additive.value_type) (@finset.pi.empty.{1 0} Type complete_lattice.{0} (@id.{2} Type to_additive.value_type) h0)  := sorry --non-trivial
lemma new_lemma_130739 (h0 : functor.add_const (topological_space (has_pos_part Type)) (ordered_ring (has_neg linarith.comp))) : @topological_space.separable_space.{1} (has_pos_part.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (has_pos_part.{1} Type)) (ordered_ring.{0} (has_neg.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_130740 (h0 : functor.add_const (topological_space (ring Type)) linarith.comp) : @locally_compact_space.{1} (ring.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (ring.{1} Type)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_130741 (h0 : complete_lattice (comm_ring linarith.ineq)) : is_compactly_generated (comm_ring linarith.ineq) := sorry --non-trivial
lemma new_lemma_130742 (h1 : group fun_info) : is_cyclic fun_info := sorry --non-trivial
lemma new_lemma_130743 (h0 : topological_space (linear_ordered_semiring (has_top num))) : t0_space (linear_ordered_semiring (has_top num)) := sorry --non-trivial
lemma new_lemma_130744 (h0 : topological_space (cancel_monoid empty)) : t0_space (cancel_monoid empty) := sorry --non-trivial
lemma new_lemma_130745 (h0 : cancel_comm_monoid_with_zero (has_pos_part (has_add linarith.comp))) : unique_factorization_monoid (has_pos_part (has_add linarith.comp)) := sorry --non-trivial
lemma new_lemma_130746 (h0 : topological_space (has_emptyc (has_norm linarith.ineq))) : locally_compact_space (has_emptyc (has_norm linarith.ineq)) := sorry --non-trivial
lemma new_lemma_130747 (h0 : semiring (boolean_algebra (has_pos_part (has_Inf pos)))) : is_noetherian_ring (boolean_algebra (has_pos_part (has_Inf pos))) := sorry --non-trivial
lemma new_lemma_130748 (h0 : add_monoid (comm_group (pseudo_metric_space pos))) : add_monoid.fg (comm_group (pseudo_metric_space pos)) := sorry --non-trivial
lemma new_lemma_130749 (h0 : functor.add_const (complete_lattice (monoid ennreal)) ennreal) : @complete_lattice.is_Sup_finite_compact.{0} (monoid.{0} ennreal) (@functor.add_const.run.{0 0} (complete_lattice.{0} (monoid.{0} ennreal)) ennreal h0)  := sorry --non-trivial
lemma new_lemma_130750 (h0 : topological_space (normed_group (random_gen (has_top fun_info)))) : irreducible_space (normed_group (random_gen (has_top fun_info))) := sorry --non-trivial
lemma new_lemma_130751 (h0 : cancel_comm_monoid_with_zero (has_pos_part (has_neg (finset Type)))) : unique_factorization_monoid (has_pos_part (has_neg (finset Type))) := sorry --non-trivial
lemma new_lemma_130752 (h0 : ring (has_ssubset (random_gen fun_info))) : rank_condition (has_ssubset (random_gen fun_info)) := sorry --non-trivial
lemma new_lemma_130753 (h0 : group (boolean_algebra.core empty)) : group.fg (boolean_algebra.core empty) := sorry --non-trivial
lemma new_lemma_130754 (h0 : ring (has_inv (has_norm string_imp))) : is_domain (has_inv (has_norm string_imp)) := sorry --non-trivial
lemma new_lemma_130755 (h0 h1 : multiset (has_nnnorm enat)) : multiset.subset h0 h1 := sorry --non-trivial
lemma new_lemma_130756 (h0 : uniform_space (complete_linear_order (semiring unsigned))) : complete_space (complete_linear_order (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_130757 (h0 : has_mem.mem (complete_semilattice_Sup congr_arg_kind) has_emptyc.emptyc) : @is_compactly_generated.{0} (complete_semilattice_Sup.{0} congr_arg_kind) (@finset.pi.empty.{1 0} Type complete_lattice.{0} (complete_semilattice_Sup.{0} congr_arg_kind) h0)  := sorry --non-trivial
lemma new_lemma_130758 (h0 : function.extfun Type topological_space) : @locally_compact_space.{0} (canonically_ordered_comm_semiring.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (canonically_ordered_comm_semiring.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_130759 (h0 : group (has_add (has_pos_part pos))) : group.fg (has_add (has_pos_part pos)) := sorry --non-trivial
lemma new_lemma_130760 (h0 : uniform_space (normed_comm_ring (option unsigned))) : separated_space (normed_comm_ring (option unsigned)) := sorry --non-trivial
lemma new_lemma_130761 (h0 : functor.add_const (topological_space (ordered_comm_ring pos)) pos) : @t0_space.{0} (ordered_comm_ring.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (ordered_comm_ring.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_130762 (h0 : fin has_zero.zero) : @totally_disconnected_space.{0} (sub_neg_monoid.{0} linarith.comp) (@matrix.vec_empty.{0} (topological_space.{0} (sub_neg_monoid.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_130763 (h0 : function.extfun Type ring) : @is_domain.{0} (complete_semilattice_Sup.{0} linarith.ineq) (@function.extfun_app.{2 1} Type ring.{0} h0 (complete_semilattice_Sup.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_130764 (h0 : group (pseudo_metric_space (option (has_to_string pos)))) : normalizer_condition (pseudo_metric_space (option (has_to_string pos))) := sorry --non-trivial
lemma new_lemma_130765 (h0 : filter (with_zero (random_gen fun_info))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_130766 (h0 : not (topological_space (has_compl string.iterator_imp) -> false)) : @path_connected_space.{0} (has_compl.{0} string.iterator_imp) (@classical.by_contradiction'.{1} (topological_space.{0} (has_compl.{0} string.iterator_imp)) h0)  := sorry --non-trivial
lemma new_lemma_130767 (h1 : topological_space std_gen) : path_connected_space std_gen := sorry --non-trivial
lemma new_lemma_130768 (h0 : filter (cancel_monoid ennreal)) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_130769 (h0 : functor.add_const (add_group (semigroup name)) (has_add Type)) : @is_add_cyclic.{0} (semigroup.{0} name) (@functor.add_const.run.{0 1} (add_group.{0} (semigroup.{0} name)) (has_add.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_130770 (h0 : function.extfun Type group) : @group.fg.{0} (normed_group.{0} unsigned) (@function.extfun_app.{2 1} Type group.{0} h0 (normed_group.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_130771 (h0 : filter (has_pos_part (ring (has_neg pos)))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_130772 (h0 : function.extfun Type topological_space) : @irreducible_space.{0} (random_gen.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (random_gen.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_130773 (h0 : filter (ring (has_to_string name))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_130774 (h0 : functor.add_const (group (comm_group environment.implicit_infer_kind)) Type) : @normalizer_condition.{0} (comm_group.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 1} (group.{0} (comm_group.{0} environment.implicit_infer_kind)) Type h0)  := sorry --non-trivial
lemma new_lemma_130775 (h0 : function.extfun ((Type -> Type) -> Type 1) (function.extfun (Type -> Type))) : @monoid.fg.{0} (linear_ordered_add_comm_group.{0} fun_info) (@function.extfun_app.{2 1} Type monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) (@function.extfun_app.{3 2} ((Type → Type) → Type 1) (function.extfun.{2 2} (Type → Type)) h0 (function.extfun.{2 1} Type)) monoid.{0}) (linear_ordered_add_comm_group.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_130776 (h0 : ring (add_group num)) : strong_rank_condition (add_group num) := sorry --non-trivial
lemma new_lemma_130777 (h0 : topological_space (has_inv (has_norm to_additive.value_type))) : t0_space (has_inv (has_norm to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_130778 (h0 : complete_lattice (monoid (option empty))) : is_compactly_generated (monoid (option empty)) := sorry --non-trivial
lemma new_lemma_130779 (h0 : function.extfun Type topological_space) : @irreducible_space.{0} (generalized_boolean_algebra.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (generalized_boolean_algebra.{0} pos))  := sorry --non-trivial
lemma new_lemma_130780 (h0 : topological_space reducibility_hints) (h1 : preorder reducibility_hints) : order_closed_topology reducibility_hints := sorry --non-trivial
lemma new_lemma_130781 (h1 : topological_space (with_one string_imp)) : locally_compact_space (with_one string_imp) := sorry --non-trivial
lemma new_lemma_130782 (h0 : functor.add_const (cancel_comm_monoid_with_zero (bin_tree congr_arg_kind)) empty) : @unique_factorization_monoid.{0} (bin_tree.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (cancel_comm_monoid_with_zero.{0} (bin_tree.{0} congr_arg_kind)) empty h0)  := sorry --non-trivial
lemma new_lemma_130783 (h0 : group (has_inv (random_gen fun_info))) : group.fg (has_inv (random_gen fun_info)) := sorry --non-trivial
lemma new_lemma_130784 (h0 : functor.add_const (topological_space (semigroup Type)) name) : @preconnected_space.{1} (semigroup.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (semigroup.{1} Type)) name h0)  := sorry --non-trivial
lemma new_lemma_130785 (h0 : function.extfun Type topological_space) : @t0_space.{0} (random_gen.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (random_gen.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_130786 (h0 : monoid (has_union (has_union linarith.comp))) : monoid.fg (has_union (has_union linarith.comp)) := sorry --non-trivial
lemma new_lemma_130787 (h0 : function.extfun Type (functor.add_const (ring (ring linarith.comp)))) : @strong_rank_condition.{0} (ring.{0} linarith.comp) (@functor.add_const.run.{0 0} (ring.{0} (ring.{0} linarith.comp)) pos (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (ring.{0} (ring.{0} linarith.comp))) h0 pos))  := sorry --non-trivial
lemma new_lemma_130788 (h0 : functor.add_const (ring (add_comm_monoid linarith.comp)) Type) : @rank_condition.{0} (add_comm_monoid.{0} linarith.comp) (@functor.add_const.run.{0 1} (ring.{0} (add_comm_monoid.{0} linarith.comp)) Type h0)  := sorry --non-trivial
lemma new_lemma_130789 (h0 : topological_space (complete_distrib_lattice (option (option (option (option (option ennreal))))))) : discrete_topology (complete_distrib_lattice (option (option (option (option (option ennreal)))))) := sorry --non-trivial
lemma new_lemma_130790 (h0 : topological_space (complete_distrib_lattice (finset pos))) : locally_compact_space (complete_distrib_lattice (finset pos)) := sorry --non-trivial
lemma new_lemma_130791 (h0 : function.extfun Type topological_space) : @totally_disconnected_space.{0} (semiring.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (semiring.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_130792 (h0 : ring (add_cancel_monoid (finset (has_neg linarith.comp)))) : rank_condition (add_cancel_monoid (finset (has_neg linarith.comp))) := sorry --non-trivial
lemma new_lemma_130793 (h1 : complete_lattice (measurable_space (has_norm congr_arg_kind))) : is_compactly_generated (measurable_space (has_norm congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_130794 (h0 : functor.add_const (semiring (complete_distrib_lattice ennreal)) unsigned) : @is_noetherian_ring.{0} (complete_distrib_lattice.{0} ennreal) (@functor.add_const.run.{0 0} (semiring.{0} (complete_distrib_lattice.{0} ennreal)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_130795 (h0 : list (has_top (dlist string_imp))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_130796 (h0 : add_monoid (has_one (measurable_space.dynkin_system fun_info))) : add_monoid.fg (has_one (measurable_space.dynkin_system fun_info)) := sorry --non-trivial
lemma new_lemma_130797 (h0 : not (function.extfun Type topological_space -> false)) : @path_connected_space.{0} (measurable_space.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (measurable_space.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_130798 (h0 : functor.add_const (function.extfun Type ordered_comm_monoid) (finset Type)) : @has_exists_mul_of_le.{0} (boolean_algebra.{0} pos) (@function.extfun_app.{2 1} Type ordered_comm_monoid.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type ordered_comm_monoid.{0}) (finset.{1} Type) h0) (boolean_algebra.{0} pos))  := sorry --non-trivial
lemma new_lemma_130799 (h0 : topological_space (add_left_cancel_monoid to_additive.value_type)) : path_connected_space (add_left_cancel_monoid to_additive.value_type) := sorry --non-trivial
lemma new_lemma_130800 (h0 : functor.comp topological_space comm_group unsigned) : @locally_compact_space.{0} (comm_group.{0} unsigned) (@functor.comp.run.{0 0 0} topological_space.{0} comm_group.{0} unsigned h0)  := sorry --non-trivial
lemma new_lemma_130801 (h0 : functor.add_const (group (has_star empty)) num) : @normalizer_condition.{0} (has_star.{0} empty) (@functor.add_const.run.{0 0} (group.{0} (has_star.{0} empty)) num h0)  := sorry --non-trivial
lemma new_lemma_130802 (h0 : functor.add_const (cancel_comm_monoid_with_zero (generalized_boolean_algebra pos)) Type) : @unique_factorization_monoid.{0} (generalized_boolean_algebra.{0} pos) (@functor.add_const.run.{0 1} (cancel_comm_monoid_with_zero.{0} (generalized_boolean_algebra.{0} pos)) Type h0)  := sorry --non-trivial
lemma new_lemma_130803 (h0 : ring (with_zero linarith.comp_source)) : strong_rank_condition (with_zero linarith.comp_source) := sorry --non-trivial
lemma new_lemma_130804 (h0 : group (semigroup (has_add (has_add linarith.comp)))) : group.fg (semigroup (has_add (has_add linarith.comp))) := sorry --non-trivial
lemma new_lemma_130805 (h0 : group (add_cancel_monoid (has_neg (has_neg (finset (has_add linarith.comp)))))) : is_cyclic (add_cancel_monoid (has_neg (has_neg (finset (has_add linarith.comp))))) := sorry --non-trivial
lemma new_lemma_130806 (h0 : add_group (has_nnnorm (semi_normed_comm_ring linarith.comp_source))) : is_add_cyclic (has_nnnorm (semi_normed_comm_ring linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_130807 (h0 : topological_space (normed_comm_ring (has_add pos))) : locally_compact_space (normed_comm_ring (has_add pos)) := sorry --non-trivial
lemma new_lemma_130808 (h0 : topological_space (normed_comm_ring (ring (ring (finset (has_nndist Type)))))) : discrete_topology (normed_comm_ring (ring (ring (finset (has_nndist Type))))) := sorry --non-trivial
lemma new_lemma_130809 (h0 : functor.add_const (fin has_zero.zero) Type) : @irreducible_space.{1} (has_bot.{1} Type) (@matrix.vec_empty.{1} (topological_space.{1} (has_bot.{1} Type)) (@functor.add_const.run.{0 1} (fin (@has_zero.zero.{0} nat nat.has_zero)) Type h0))  := sorry --non-trivial
lemma new_lemma_130810 (h0 : function.extfun Type complete_lattice) : @complete_lattice.is_Sup_finite_compact.{0} (complete_linear_order.{0} empty) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (complete_linear_order.{0} empty))  := sorry --non-trivial
lemma new_lemma_130811 (h0 : function.extfun Type topological_space) : @locally_compact_space.{0} (complete_linear_order.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (complete_linear_order.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_130812 (h0 : list (has_nndist empty)) : palindrome h0 := sorry --non-trivial
lemma new_lemma_130813 (h0 : topological_space (has_inner empty congr_arg_kind)) : normal_space (has_inner empty congr_arg_kind) := sorry --non-trivial
lemma new_lemma_130814 (h0 : group (normed_lattice_add_comm_group (has_add real))) : normalizer_condition (normed_lattice_add_comm_group (has_add real)) := sorry --non-trivial
lemma new_lemma_130815 (h0 : topological_space (has_top (has_ssubset (has_inv fun_info)))) : path_connected_space (has_top (has_ssubset (has_inv fun_info))) := sorry --non-trivial
lemma new_lemma_130816 (h0 : ring (normed_linear_ordered_group (semiring (semiring empty)))) : is_domain (normed_linear_ordered_group (semiring (semiring empty))) := sorry --non-trivial
lemma new_lemma_130817 (h0 : topological_space (has_neg linarith.comp)) : totally_disconnected_space (has_neg linarith.comp) := sorry --non-trivial
lemma new_lemma_130818 (h0 : complete_lattice (semiring (has_norm (has_top (has_top (semiring to_additive.value_type)))))) : is_compactly_generated (semiring (has_norm (has_top (has_top (semiring to_additive.value_type))))) := sorry --non-trivial
lemma new_lemma_130819 (h0 : function.extfun Type ring) : @strong_rank_condition.{0} (canonically_linear_ordered_monoid.{0} unsigned) (@function.extfun_app.{2 1} Type ring.{0} h0 (canonically_linear_ordered_monoid.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_130820 (h0 : filter (has_zero (ring (boolean_algebra pos)))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_130821 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @monoid.fg.{0} (has_union.{0} empty) (@function.extfun_app.{2 1} Type monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 monoid.{0}) (has_union.{0} empty))  := sorry --non-trivial
lemma new_lemma_130822 (h0 : functor.add_const (topological_space (add_comm_monoid num)) num) : @totally_disconnected_space.{0} (add_comm_monoid.{0} num) (@functor.add_const.run.{0 0} (topological_space.{0} (add_comm_monoid.{0} num)) num h0)  := sorry --non-trivial
lemma new_lemma_130823 (h0 : topological_space (has_zero (has_to_string (comm_group pos)))) : regular_space (has_zero (has_to_string (comm_group pos))) := sorry --non-trivial
lemma new_lemma_130824 (h0 : ring (has_norm (random_gen (has_norm linarith.ineq)))) : strong_rank_condition (has_norm (random_gen (has_norm linarith.ineq))) := sorry --non-trivial
lemma new_lemma_130825 (h1 : ring (distrib string.iterator_imp)) : rank_condition (distrib string.iterator_imp) := sorry --non-trivial
lemma new_lemma_130826 (h0 : list (dlist (random_gen fun_info))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_130827 (h0 : topological_space (with_bot (random_gen (random_gen (comm_ring to_additive.value_type))))) : t0_space (with_bot (random_gen (random_gen (comm_ring to_additive.value_type)))) := sorry --non-trivial
lemma new_lemma_130828 (h0 : topological_space (semigroup name)) : loc_path_connected_space (semigroup name) := sorry --non-trivial
lemma new_lemma_130829 (h0 : functor.add_const (semiring (has_neg Type)) pos) : @is_noetherian_ring.{1} (has_neg.{1} Type) (@functor.add_const.run.{1 0} (semiring.{1} (has_neg.{1} Type)) pos h0)  := sorry --non-trivial
lemma new_lemma_130830 (h0 : functor.add_const (monoid (has_to_string pos)) (has_add unsigned)) : @monoid.fg.{0} (has_to_string.{0} pos) (@functor.add_const.run.{0 0} (monoid.{0} (has_to_string.{0} pos)) (has_add.{0} unsigned) h0)  := sorry --non-trivial
lemma new_lemma_130831 (h0 : function.extfun Type filter) : countable_Inter_filter (function.extfun_app h0 (canonically_linear_ordered_monoid linarith.comp)) := sorry --non-trivial
lemma new_lemma_130832 (h0 : semiring (ordered_comm_monoid (has_add pos))) : is_noetherian_ring (ordered_comm_monoid (has_add pos)) := sorry --non-trivial
lemma new_lemma_130833 (h0 : complete_lattice (non_unital_non_assoc_semiring to_additive.value_type)) : is_compactly_generated (non_unital_non_assoc_semiring to_additive.value_type) := sorry --non-trivial
lemma new_lemma_130834 (h0 : not (uniform_space (has_ssubset linarith.comp_source) -> false)) : @complete_space.{0} (has_ssubset.{0} linarith.comp_source) (@classical.by_contradiction'.{1} (uniform_space.{0} (has_ssubset.{0} linarith.comp_source)) h0)  := sorry --non-trivial
lemma new_lemma_130835 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @topological_space.separable_space.{0} (generalized_boolean_algebra.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (generalized_boolean_algebra.{0} pos))  := sorry --non-trivial
lemma new_lemma_130836 (h0 : fin has_zero.zero) : @path_connected_space.{1} (comm_semigroup.{1} Type) (@matrix.vec_empty.{1} (topological_space.{1} (comm_semigroup.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_130837 (h0 : group (id (random_gen (has_inv (random_gen fun_info))))) : normalizer_condition (id (random_gen (has_inv (random_gen fun_info)))) := sorry --non-trivial
lemma new_lemma_130838 (h0 : semiring string.iterator_imp) (h4 : Type) (h5 : h4) (h6 : h4 -> id (submodule string.iterator_imp string.iterator_imp)) : ideal.is_prime (id_bind h5 h6) := sorry --non-trivial
lemma new_lemma_130839 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @archimedean.{0} (has_dist.{0} unsigned) (@function.extfun_app.{2 1} Type ordered_add_comm_monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ordered_add_comm_monoid.{0}) (has_dist.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_130840 (h0 : functor.add_const (filter (has_add environment.implicit_infer_kind)) environment.implicit_infer_kind) : filter.ne_bot (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_130841 (h0 : function.extfun Type topological_space) : @irreducible_space.{0} (has_one.{0} fun_info) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_one.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_130842 (h0 : ring (finset pos)) : rank_condition (finset pos) := sorry --non-trivial
lemma new_lemma_130843 (h0 : functor.add_const (topological_space (add_comm_monoid name)) pos) : @locally_compact_space.{0} (add_comm_monoid.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (add_comm_monoid.{0} name)) pos h0)  := sorry --non-trivial
lemma new_lemma_130844 (h0 : group (comm_ring (has_nnnorm (has_nnnorm to_additive.value_type)))) : is_cyclic (comm_ring (has_nnnorm (has_nnnorm to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_130845 (h0 : topological_space (simple_graph (finset linarith.comp))) : totally_disconnected_space (simple_graph (finset linarith.comp)) := sorry --non-trivial
lemma new_lemma_130846 (h1 : topological_space (fintype (has_nnnorm (has_nnnorm fun_info)))) : path_connected_space (fintype (has_nnnorm (has_nnnorm fun_info))) := sorry --non-trivial
lemma new_lemma_130847 (h0 : cancel_comm_monoid_with_zero (has_zero (option ennreal))) : unique_factorization_monoid (has_zero (option ennreal)) := sorry --non-trivial
lemma new_lemma_130848 (h0 : functor.add_const (ring (canonically_ordered_comm_semiring unsigned)) linarith.comp) : @is_domain.{0} (canonically_ordered_comm_semiring.{0} unsigned) (@functor.add_const.run.{0 0} (ring.{0} (canonically_ordered_comm_semiring.{0} unsigned)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_130849 (h0 : list (ring (finset unsigned))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_130850 (h0 : functor.add_const (function.extfun (Type 1) topological_space) pos) : @totally_disconnected_space.{1} (complete_distrib_lattice.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) topological_space.{1}) pos h0) (complete_distrib_lattice.{1} Type))  := sorry --non-trivial
lemma new_lemma_130851 (h0 : filter (topological_space (random_gen to_additive.value_type))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_130852 (h2 : topological_space (add_left_cancel_monoid to_additive.value_type)) : totally_disconnected_space (add_left_cancel_monoid to_additive.value_type) := sorry --non-trivial
lemma new_lemma_130853 (h0 : functor.add_const (complete_lattice (has_to_string name)) environment.implicit_infer_kind) : @is_compactly_generated.{0} (has_to_string.{0} name) (@functor.add_const.run.{0 0} (complete_lattice.{0} (has_to_string.{0} name)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_130854 (h0 : topological_space (has_pos_part (has_add linarith.comp))) : loc_path_connected_space (has_pos_part (has_add linarith.comp)) := sorry --non-trivial
lemma new_lemma_130855 (h0 : group (has_add (has_neg pos))) : group.fg (has_add (has_neg pos)) := sorry --non-trivial
lemma new_lemma_130856 (h0 : function.extfun Type filter) : countable_Inter_filter (function.extfun_app h0 (canonically_ordered_comm_semiring num)) := sorry --non-trivial
lemma new_lemma_130857 (h0 : topological_space (has_div (mul_one_class (mul_one_class to_additive.value_type)))) : t0_space (has_div (mul_one_class (mul_one_class to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_130858 (h0 : uniform_space (has_union (linear_ordered_semiring (semiring (semiring congr_arg_kind))))) : separated_space (has_union (linear_ordered_semiring (semiring (semiring congr_arg_kind)))) := sorry --non-trivial
lemma new_lemma_130859 (h0 : not (ring (has_ssubset reducibility_hints) -> false)) : @strong_rank_condition.{0} (has_ssubset.{0} reducibility_hints) (@classical.by_contradiction'.{1} (ring.{0} (has_ssubset.{0} reducibility_hints)) h0)  := sorry --non-trivial
lemma new_lemma_130860 (h0 : not (function.extfun Type topological_space -> false)) : @totally_separated_space.{0} (has_union.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (has_union.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_130861 (h0 : add_group (normed_group (random_gen linarith.comp_source))) : is_add_cyclic (normed_group (random_gen linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_130862 (h0 : add_monoid (has_one fun_info)) : add_monoid.fg (has_one fun_info) := sorry --non-trivial
lemma new_lemma_130863 (h0 : functor.add_const (uniform_space (add_cancel_monoid unsigned)) congr_arg_kind) : @separated_space.{0} (add_cancel_monoid.{0} unsigned) (@functor.add_const.run.{0 0} (uniform_space.{0} (add_cancel_monoid.{0} unsigned)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_130864 (h0 : functor.add_const (topological_space (add_group empty)) unsigned) : @t0_space.{0} (add_group.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (add_group.{0} empty)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_130865 (h0 : function.extfun Type add_comm_group) (h1 : function.extfun Type has_norm) : @normed_group.core.{0} ennreal (@function.extfun_app.{2 1} Type add_comm_group.{0} h0 ennreal) (@function.extfun_app.{2 1} Type has_norm.{0} h1 ennreal)  := sorry --non-trivial
lemma new_lemma_130866 (h0 : complete_lattice (has_add (option (option (option ennreal))))) : is_compactly_generated (has_add (option (option (option ennreal)))) := sorry --non-trivial
lemma new_lemma_130867 (h0 : prod auto.case_option auto.case_option) : id_rel h0 := sorry --non-trivial
lemma new_lemma_130868 (h1 : topological_space (has_lt environment.projection_info)) : path_connected_space (has_lt environment.projection_info) := sorry --non-trivial
lemma new_lemma_130869 (h1 : topological_space (semi_normed_ring char)) : path_connected_space (semi_normed_ring char) := sorry --non-trivial
lemma new_lemma_130870 (h1 : ring (random_gen reducibility_hints)) : strong_rank_condition (random_gen reducibility_hints) := sorry --non-trivial
lemma new_lemma_130871 (h0 : list (linear_ordered_add_comm_group (random_gen (random_gen (random_gen string_imp))))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_130872 (h0 : function.extfun Type (functor.add_const (finset (linear_ordered_comm_monoid_with_zero empty)))) : finset.nonempty (functor.add_const.run (function.extfun_app h0 (semiring (semiring empty)))) := sorry --non-trivial
lemma new_lemma_130873 (h0 : group (has_norm (has_nnnorm (random_gen (has_nnnorm char))))) : is_cyclic (has_norm (has_nnnorm (random_gen (has_nnnorm char)))) := sorry --non-trivial
lemma new_lemma_130874 (h0 : topological_space (has_to_string (has_nndist (has_neg (finset Type))))) : totally_disconnected_space (has_to_string (has_nndist (has_neg (finset Type)))) := sorry --non-trivial
lemma new_lemma_130875 (h0 : functor.add_const (function.extfun Type list) pos) : palindrome (function.extfun_app (functor.add_const.run h0) (generalized_boolean_algebra pos)) := sorry --non-trivial
lemma new_lemma_130876 (h0 : function.extfun Type uniform_space) : @complete_space.{0} ennreal (@function.extfun_app.{2 1} Type uniform_space.{0} h0 ennreal)  := sorry --non-trivial
lemma new_lemma_130877 (h0 : not (topological_space (measurable_space empty) -> false)) : @t0_space.{0} (measurable_space.{0} empty) (@classical.by_contradiction'.{1} (topological_space.{0} (measurable_space.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_130878 (h0 : ring (boolean_algebra.core empty)) : strong_rank_condition (boolean_algebra.core empty) := sorry --non-trivial
lemma new_lemma_130879 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @preirreducible_space.{0} (cancel_monoid.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (cancel_monoid.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_130880 (h0 : functor.add_const (function.extfun (Type 1) topological_space) Type) : @t1_space.{1} Type (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@functor.add_const.run.{2 1} (function.extfun.{3 2} (Type 1) topological_space.{1}) Type h0) Type)  := sorry --non-trivial
lemma new_lemma_130881 (h0 : group (id (random_gen (random_gen to_additive.value_type)))) : is_cyclic (id (random_gen (random_gen to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_130882 (h0 : functor.add_const (topological_space (ordered_comm_ring real)) pos) : @locally_compact_space.{0} (ordered_comm_ring.{0} real) (@functor.add_const.run.{0 0} (topological_space.{0} (ordered_comm_ring.{0} real)) pos h0)  := sorry --non-trivial
lemma new_lemma_130883 (h0 : topological_space (canonically_linear_ordered_monoid char)) (h1 : has_sub (canonically_linear_ordered_monoid char)) : has_continuous_sub (canonically_linear_ordered_monoid char) := sorry --non-trivial
lemma new_lemma_130884 (h0 h1 h2 : pnat) : pnat.coprime h0 (pnat.gcd h1 h2) := sorry --non-trivial
lemma new_lemma_130885 (h0 : topological_space (has_to_string (comm_group Type))) : topological_space.separable_space (has_to_string (comm_group Type)) := sorry --non-trivial
lemma new_lemma_130886 (h0 : functor.add_const (cancel_comm_monoid_with_zero (add_cancel_monoid linarith.comp)) name) : @unique_factorization_monoid.{0} (add_cancel_monoid.{0} linarith.comp) (@functor.add_const.run.{0 0} (cancel_comm_monoid_with_zero.{0} (add_cancel_monoid.{0} linarith.comp)) name h0)  := sorry --non-trivial
lemma new_lemma_130887 (h0 : functor.add_const (topological_space (mul_zero_class pos)) Type) : @totally_separated_space.{0} (mul_zero_class.{0} pos) (@functor.add_const.run.{0 1} (topological_space.{0} (mul_zero_class.{0} pos)) Type h0)  := sorry --non-trivial
lemma new_lemma_130888 (h0 : functor.add_const (group (has_neg_part Type)) Type) : @group.fg.{1} (has_neg_part.{1} Type) (@functor.add_const.run.{1 1} (group.{1} (has_neg_part.{1} Type)) Type h0)  := sorry --non-trivial
lemma new_lemma_130889 (h0 : complete_lattice string) : complete_lattice.is_Sup_finite_compact string := sorry --non-trivial
lemma new_lemma_130890 (h0 : topological_space (has_bot (has_Inf real))) : discrete_topology (has_bot (has_Inf real)) := sorry --non-trivial
lemma new_lemma_130891 (h0 : topological_space (boolean_algebra (finset (has_Inf linarith.comp)))) : path_connected_space (boolean_algebra (finset (has_Inf linarith.comp))) := sorry --non-trivial
lemma new_lemma_130892 (h0 : monoid (semiring (random_gen linarith.comp_source))) : monoid.fg (semiring (random_gen linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_130893 (h0 : functor.add_const (topological_space (ring Type)) (boolean_algebra (has_zero Type))) : @preconnected_space.{1} (ring.{1} Type) (@functor.add_const.run.{1 1} (topological_space.{1} (ring.{1} Type)) (boolean_algebra.{1} (has_zero.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_130894 (h0 : ordered_add_comm_monoid (has_add (option ennreal))) : archimedean (has_add (option ennreal)) := sorry --non-trivial
lemma new_lemma_130895 (h0 : functor.add_const (monoid (linear_order empty)) (semiring (semiring (option empty)))) : @monoid.fg.{0} (linear_order.{0} empty) (@functor.add_const.run.{0 0} (monoid.{0} (linear_order.{0} empty)) (semiring.{0} (semiring.{0} (option.{0} empty))) h0)  := sorry --non-trivial
lemma new_lemma_130896 (h0 : topological_space (normed_comm_ring congr_arg_kind)) : t0_space (normed_comm_ring congr_arg_kind) := sorry --non-trivial
lemma new_lemma_130897 (h0 : pnat) (h1 : thunk (ulower pnat)) : @id.{1} Prop (pnat.coprime h0 (@ulower.up.{0} pnat encodable.pnat (@id.{1} (@ulower.{0} pnat encodable.pnat) (@trace_call_stack.{0} (@ulower.{0} pnat encodable.pnat) h1))))  := sorry --non-trivial
lemma new_lemma_130898 (h0 : add_group (with_one (semiring linarith.comp))) : is_add_cyclic (with_one (semiring linarith.comp)) := sorry --non-trivial
lemma new_lemma_130899 (h0 : functor.add_const (topological_space (has_nndist pos)) Type) : @loc_path_connected_space.{0} (has_nndist.{0} pos) (@functor.add_const.run.{0 1} (topological_space.{0} (has_nndist.{0} pos)) Type h0)  := sorry --non-trivial
lemma new_lemma_130900 (h0 : topological_space (add_left_cancel_monoid (has_nnnorm linarith.ineq))) : totally_disconnected_space (add_left_cancel_monoid (has_nnnorm linarith.ineq)) := sorry --non-trivial
lemma new_lemma_130901 (h0 : function.extfun nat fin) : @t1_space.{0} (simple_graph.{0} linarith.comp) (@matrix.vec_empty.{0} (topological_space.{0} (simple_graph.{0} linarith.comp)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_130902 (h0 : function.extfun Type monoid) : @monoid.fg.{0} (has_norm.{0} fun_info) (@function.extfun_app.{2 1} Type monoid.{0} h0 (has_norm.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_130903 (h1 : topological_space linarith.comp) : discrete_topology linarith.comp := sorry --non-trivial
lemma new_lemma_130904 (h0 : topological_space (has_nnnorm (mul_one_class string.iterator_imp))) : path_connected_space (has_nnnorm (mul_one_class string.iterator_imp)) := sorry --non-trivial
lemma new_lemma_130905 (h0 : topological_space (add_comm_monoid (comm_group pos))) : path_connected_space (add_comm_monoid (comm_group pos)) := sorry --non-trivial
lemma new_lemma_130906 (h1 : complete_lattice (random_gen string_imp)) : complete_lattice.is_Sup_finite_compact (random_gen string_imp) := sorry --non-trivial
lemma new_lemma_130907 (h0 : topological_space (has_zero (ring Type))) : sequential_space (has_zero (ring Type)) := sorry --non-trivial
lemma new_lemma_130908 (h0 : functor.add_const (topological_space (add_comm_monoid Type)) (has_neg Type)) : @topological_space.separable_space.{1} (add_comm_monoid.{1} Type) (@functor.add_const.run.{1 1} (topological_space.{1} (add_comm_monoid.{1} Type)) (has_neg.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_130909 (h0 : topological_space (is_R_or_C congr_arg_kind)) : t0_space (is_R_or_C congr_arg_kind) := sorry --non-trivial
lemma new_lemma_130910 (h0 : function.extfun (Type 1) topological_space) : @normal_space.{1} (has_nndist.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} h0 (has_nndist.{1} Type))  := sorry --non-trivial
lemma new_lemma_130911 (h0 : equiv.perm std_gen) (h1 h2 : std_gen) : equiv.perm.same_cycle h0 h1 h2 := sorry --non-trivial
lemma new_lemma_130912 (h0 : functor.add_const (function.extfun (Type 1) list) name) : list.nodup (function.extfun_app (functor.add_const.run h0) Type) := sorry --non-trivial
lemma new_lemma_130913 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @t0_space.{0} (has_inter.{0} ennreal) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_inter.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_130914 (h0 : functor.add_const (function.extfun Type group) Type) : @is_simple_group.{0} (add_cancel_monoid.{0} linarith.comp) (@function.extfun_app.{2 1} Type group.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type group.{0}) Type h0) (add_cancel_monoid.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_130915 (h0 : topological_space nnreal) : t0_space nnreal := sorry --non-trivial
lemma new_lemma_130916 (h0 : topological_space (has_norm congr_arg_kind)) : path_connected_space (has_norm congr_arg_kind) := sorry --non-trivial
lemma new_lemma_130917 (h0 : topological_space (canonically_linear_ordered_monoid real)) : preirreducible_space (canonically_linear_ordered_monoid real) := sorry --non-trivial
lemma new_lemma_130918 (h0 : functor.add_const (topological_space (boolean_algebra.core Type)) linarith.comp) : @regular_space.{1} (boolean_algebra.core.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (boolean_algebra.core.{1} Type)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_130919 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @normal_space.{0} (linear_ordered_comm_group.{0} (option.{0} (option.{0} ennreal))) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (linear_ordered_comm_group.{0} (option.{0} (option.{0} ennreal))))  := sorry --non-trivial
lemma new_lemma_130920 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_add_cyclic.{0} (has_inv.{0} string_imp) (@function.extfun_app.{2 1} Type add_group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 add_group.{0}) (has_inv.{0} string_imp))  := sorry --non-trivial
lemma new_lemma_130921 (h0 : functor.add_const (topological_space (has_nndist environment.implicit_infer_kind)) name) : @t0_space.{0} (has_nndist.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (has_nndist.{0} environment.implicit_infer_kind)) name h0)  := sorry --non-trivial
lemma new_lemma_130922 (h0 : fin has_zero.zero) : @t0_space.{0} (canonically_ordered_monoid.{0} real) (@matrix.vec_empty.{0} (topological_space.{0} (canonically_ordered_monoid.{0} real)) h0)  := sorry --non-trivial
lemma new_lemma_130923 (h0 : topological_space (preorder (semiring (semiring empty)))) : totally_separated_space (preorder (semiring (semiring empty))) := sorry --non-trivial
lemma new_lemma_130924 (h0 : topological_space (add_cancel_monoid (has_neg (has_neg pos)))) : discrete_topology (add_cancel_monoid (has_neg (has_neg pos))) := sorry --non-trivial
lemma new_lemma_130925 (h0 : functor.add_const (ring (has_neg_part name)) Type) : @strong_rank_condition.{0} (has_neg_part.{0} name) (@functor.add_const.run.{0 1} (ring.{0} (has_neg_part.{0} name)) Type h0)  := sorry --non-trivial
lemma new_lemma_130926 (h0 : topological_space (has_nndist (finset Type))) : totally_separated_space (has_nndist (finset Type)) := sorry --non-trivial
lemma new_lemma_130927 (h0 : ring (add_left_cancel_semigroup (semiring (option unsigned)))) : strong_rank_condition (add_left_cancel_semigroup (semiring (option unsigned))) := sorry --non-trivial
lemma new_lemma_130928 (h0 : functor.add_const (ring (has_Inf pos)) name) : @is_domain.{0} (has_Inf.{0} pos) (@functor.add_const.run.{0 0} (ring.{0} (has_Inf.{0} pos)) name h0)  := sorry --non-trivial
lemma new_lemma_130929 (h0 : function.extfun Type (functor.comp semiring has_nndist)) : @is_noetherian_ring.{0} (has_nndist.{0} ennreal) (@functor.comp.run.{0 0 0} semiring.{0} has_nndist.{0} ennreal (@function.extfun_app.{2 1} Type (functor.comp.{0 0 0} semiring.{0} has_nndist.{0}) h0 ennreal))  := sorry --non-trivial
lemma new_lemma_130930 (h0 : functor.add_const (topological_space (has_zero linarith.comp)) linarith.comp) : @irreducible_space.{0} (has_zero.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (has_zero.{0} linarith.comp)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_130931 (h0 : not (function.extfun (finset Type) (has_mem.mem (has_one empty)) -> false)) : @is_atomistic.{0} (has_one.{0} empty) (@finset.pi.empty.{1 0} Type complete_lattice.{0} (has_one.{0} empty) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (has_one.{0} empty)) (@classical.by_contradiction'.{0} (function.extfun.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (has_one.{0} empty))) h0) (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_130932 (h0 : functor.add_const (topological_space nnreal) unsigned) : discrete_topology nnreal := sorry --non-trivial
lemma new_lemma_130933 (h0 : functor.add_const (function.extfun (Type 1) topological_space) (has_add linarith.comp)) : @preirreducible_space.{1} (has_pos_part.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) topological_space.{1}) (has_add.{0} linarith.comp) h0) (has_pos_part.{1} Type))  := sorry --non-trivial
lemma new_lemma_130934 (h0 : not (ring (plift congr_arg_kind) -> false)) : @rank_condition.{1} (plift.{1} congr_arg_kind) (@classical.by_contradiction'.{2} (ring.{1} (plift.{1} congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_130935 (h0 : functor.add_const (group (generalized_boolean_algebra linarith.comp)) (has_neg name)) : @is_simple_group.{0} (generalized_boolean_algebra.{0} linarith.comp) (@functor.add_const.run.{0 0} (group.{0} (generalized_boolean_algebra.{0} linarith.comp)) (has_neg.{0} name) h0)  := sorry --non-trivial
lemma new_lemma_130936 (h0 : functor.add_const (topological_space (has_pos_part pos)) name) : @t0_space.{0} (has_pos_part.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (has_pos_part.{0} pos)) name h0)  := sorry --non-trivial
lemma new_lemma_130937 (h0 : function.extfun Type complete_lattice) : complete_lattice.is_Sup_finite_compact (filter (semiring (option unsigned))) := sorry --non-trivial
lemma new_lemma_130938 (h1 : topological_space real.angle) : path_connected_space real.angle := sorry --non-trivial
lemma new_lemma_130939 (h0 : topological_space (finset (has_add pos))) : totally_disconnected_space (finset (has_add pos)) := sorry --non-trivial
lemma new_lemma_130940 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_atomistic.{0} (has_emptyc.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (has_emptyc.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_130941 (h0 : add_group (random_gen (random_gen (random_gen num)))) : is_add_cyclic (random_gen (random_gen (random_gen num))) := sorry --non-trivial
lemma new_lemma_130942 (h0 : option (function.extfun (Type -> Type) (function.extfun Type))) (h1 : function.extfun (Type -> Type) (function.extfun Type)) : @totally_disconnected_space.{0} (ring.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) (@option.get_or_else.{1} (function.extfun.{2 2} (Type → Type) (function.extfun.{2 1} Type)) h0 h1) topological_space.{0}) (ring.{0} empty))  := sorry --non-trivial
lemma new_lemma_130943 (h0 : group (linear_ordered_field ennreal)) : is_simple_group (linear_ordered_field ennreal) := sorry --non-trivial
lemma new_lemma_130944 (h0 : ring (measure_theory.measure_space unsigned)) : is_principal_ideal_ring (measure_theory.measure_space unsigned) := sorry --non-trivial
lemma new_lemma_130945 (h0 : function.extfun Type add_group) : @is_add_cyclic.{0} (has_inter.{0} num) (@function.extfun_app.{2 1} Type add_group.{0} h0 (has_inter.{0} num))  := sorry --non-trivial
lemma new_lemma_130946 (h0 : not (topological_space (normed_field reducibility_hints) -> false)) : @path_connected_space.{0} (normed_field.{0} reducibility_hints) (@classical.by_contradiction'.{1} (topological_space.{0} (normed_field.{0} reducibility_hints)) h0)  := sorry --non-trivial
lemma new_lemma_130947 (h0 : complete_lattice (has_dist char)) : complete_lattice.is_Sup_finite_compact (has_dist char) := sorry --non-trivial
lemma new_lemma_130948 (h0 : ordered_add_comm_monoid (comm_group (ring Type))) : archimedean (comm_group (ring Type)) := sorry --non-trivial
lemma new_lemma_130949 (h0 : functor.add_const (group (ordered_comm_ring name)) Type) : @is_cyclic.{0} (ordered_comm_ring.{0} name) (@functor.add_const.run.{0 1} (group.{0} (ordered_comm_ring.{0} name)) Type h0)  := sorry --non-trivial
lemma new_lemma_130950 (h0 : complete_lattice (has_pos_part (sub_neg_monoid (has_Inf pos)))) : complete_lattice.is_Sup_finite_compact (has_pos_part (sub_neg_monoid (has_Inf pos))) := sorry --non-trivial
lemma new_lemma_130951 (h0 : ring (denumerable (random_gen (random_gen char)))) : is_domain (denumerable (random_gen (random_gen char))) := sorry --non-trivial
lemma new_lemma_130952 (h0 : ring (has_union (has_top unsigned))) : rank_condition (has_union (has_top unsigned)) := sorry --non-trivial
lemma new_lemma_130953 (h0 : cancel_comm_monoid_with_zero (non_assoc_semiring empty)) : unique_factorization_monoid (non_assoc_semiring empty) := sorry --non-trivial
lemma new_lemma_130954 (h0 : fin has_zero.zero) : @irreducible_space.{0} (has_add.{0} real) (@matrix.vec_empty.{0} (topological_space.{0} (has_add.{0} real)) h0)  := sorry --non-trivial
lemma new_lemma_130955 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @separated_space.{0} (boolean_algebra.{0} linarith.comp) (@function.extfun_app.{2 1} Type uniform_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 uniform_space.{0}) (boolean_algebra.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_130956 (h0 : function.extfun Type uniform_space) : @separated_space.{0} (has_nndist.{0} empty) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (has_nndist.{0} empty))  := sorry --non-trivial
lemma new_lemma_130957 (h0 : list (normed_comm_ring congr_arg_kind)) : palindrome h0 := sorry --non-trivial
lemma new_lemma_130958 (h0 : complete_lattice (complete_semilattice_Sup (has_inv to_additive.value_type))) : is_compactly_generated (complete_semilattice_Sup (has_inv to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_130959 (h0 : topological_space (semigroup (has_pos_part linarith.comp))) : irreducible_space (semigroup (has_pos_part linarith.comp)) := sorry --non-trivial
lemma new_lemma_130960 (h0 : functor.add_const (list (add_cancel_monoid Type)) linarith.comp) : palindrome (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_130961 (h0 : functor.add_const (list (cancel_monoid environment.implicit_infer_kind)) environment.implicit_infer_kind) : list.nodup (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_130962 (h0 : uniform_space (normed_comm_ring congr_arg_kind)) : separated_space (normed_comm_ring congr_arg_kind) := sorry --non-trivial
lemma new_lemma_130963 (h0 : ring (has_union (metric_space (has_one (semiring unsigned))))) : strong_rank_condition (has_union (metric_space (has_one (semiring unsigned)))) := sorry --non-trivial
lemma new_lemma_130964 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @monoid.fg.{0} (complete_distrib_lattice.{0} num) (@function.extfun_app.{2 1} Type monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 monoid.{0}) (complete_distrib_lattice.{0} num))  := sorry --non-trivial
lemma new_lemma_130965 (h0 : function.extfun Type complete_lattice) : @is_atomistic.{0} (linear_order.{0} empty) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (linear_order.{0} empty))  := sorry --non-trivial
lemma new_lemma_130966 (h0 : topological_space (linear_order (option (semiring (option empty))))) : totally_disconnected_space (linear_order (option (semiring (option empty)))) := sorry --non-trivial
lemma new_lemma_130967 (h0 : functor.add_const (topological_space (boolean_algebra pos)) name) : @loc_path_connected_space.{0} (boolean_algebra.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (boolean_algebra.{0} pos)) name h0)  := sorry --non-trivial
lemma new_lemma_130968 (h1 : add_group (has_nnnorm (random_gen char))) : is_add_cyclic (has_nnnorm (random_gen char)) := sorry --non-trivial
lemma new_lemma_130969 (h0 : has_mem.mem (measurable_space num) has_emptyc.emptyc) : @path_connected_space.{0} (measurable_space.{0} num) (@finset.pi.empty.{1 0} Type topological_space.{0} (measurable_space.{0} num) h0)  := sorry --non-trivial
lemma new_lemma_130970 (h0 : not (function.extfun (Type -> Type) (function.extfun Type) -> false)) : @is_noetherian_ring.{0} unsigned (@function.extfun_app.{2 1} Type semiring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) (@classical.by_contradiction'.{2} (function.extfun.{2 2} (Type → Type) (function.extfun.{2 1} Type)) h0) semiring.{0}) unsigned)  := sorry --non-trivial
lemma new_lemma_130971 (h0 : functor.add_const (complete_lattice (add_left_cancel_semigroup unsigned)) empty) : @complete_lattice.is_Sup_finite_compact.{0} (add_left_cancel_semigroup.{0} unsigned) (@functor.add_const.run.{0 0} (complete_lattice.{0} (add_left_cancel_semigroup.{0} unsigned)) empty h0)  := sorry --non-trivial
lemma new_lemma_130972 (h0 : complete_lattice (has_sub (semiring (semiring unsigned)))) : is_compactly_generated (has_sub (semiring (semiring unsigned))) := sorry --non-trivial
lemma new_lemma_130973 (h0 : topological_space (linear_order (option unsigned))) : path_connected_space (linear_order (option unsigned)) := sorry --non-trivial
lemma new_lemma_130974 (h0 : function.extfun Type topological_space) : @sequential_space.{0} (monoid_with_zero.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (monoid_with_zero.{0} pos))  := sorry --non-trivial
lemma new_lemma_130975 (h0 : topological_space (measurable_space (id (has_union linarith.comp)))) : locally_compact_space (measurable_space (id (has_union linarith.comp))) := sorry --non-trivial
lemma new_lemma_130976 (h0 : ring (has_compl (has_nnnorm (random_gen linarith.ineq)))) : strong_rank_condition (has_compl (has_nnnorm (random_gen linarith.ineq))) := sorry --non-trivial
lemma new_lemma_130977 (h0 : function.extfun Type topological_space) : @t1_space.{0} (linear_ordered_field.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (linear_ordered_field.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_130978 (h0 : add_group (linear_ordered_comm_group (option unsigned))) : is_add_cyclic (linear_ordered_comm_group (option unsigned)) := sorry --non-trivial
lemma new_lemma_130979 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @totally_separated_space.{0} auto.case_option (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) auto.case_option)  := sorry --non-trivial
lemma new_lemma_130980 (h1 : topological_space (dlist string_imp)) : path_connected_space (dlist string_imp) := sorry --non-trivial
lemma new_lemma_130981 (h0 : topological_space (has_pos_part (has_bot real))) : topological_space.separable_space (has_pos_part (has_bot real)) := sorry --non-trivial
lemma new_lemma_130982 (h0 : functor.add_const (complete_lattice (ring Type)) pos) : @is_compactly_generated.{1} (ring.{1} Type) (@functor.add_const.run.{1 0} (complete_lattice.{1} (ring.{1} Type)) pos h0)  := sorry --non-trivial
lemma new_lemma_130983 (h0 : cancel_comm_monoid_with_zero (metric_space congr_arg_kind)) : unique_factorization_monoid (metric_space congr_arg_kind) := sorry --non-trivial
lemma new_lemma_130984 (h0 : filter (normed_group (comm_ring (random_gen (comm_ring linarith.ineq))))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_130985 (h0 : function.extfun nat fin) : @normalizer_condition.{0} (generalized_boolean_algebra.{0} linarith.comp) (@matrix.vec_empty.{0} (group.{0} (generalized_boolean_algebra.{0} linarith.comp)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_130986 (h0 : functor.add_const (topological_space (semigroup linarith.comp)) Type) : @totally_disconnected_space.{0} (semigroup.{0} linarith.comp) (@functor.add_const.run.{0 1} (topological_space.{0} (semigroup.{0} linarith.comp)) Type h0)  := sorry --non-trivial
lemma new_lemma_130987 (h0 : not (topological_space (partial_order congr_arg_kind) -> false)) : @topological_space.separable_space.{0} (partial_order.{0} congr_arg_kind) (@classical.by_contradiction'.{1} (topological_space.{0} (partial_order.{0} congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_130988 (h0 : nat) (h1 h3 : list char) : list.is_infix (list.take h0 h1) h3 := sorry --non-trivial
lemma new_lemma_130989 (h0 : complete_lattice (normed_comm_ring (comm_group pos))) : complete_lattice.is_Sup_finite_compact (normed_comm_ring (comm_group pos)) := sorry --non-trivial
lemma new_lemma_130990 (h0 : uniform_space (with_bot (has_top (has_top to_additive.value_type)))) : complete_space (with_bot (has_top (has_top to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_130991 (h0 : functor.add_const (ring (has_neg linarith.comp)) pos) : @is_domain.{0} (has_neg.{0} linarith.comp) (@functor.add_const.run.{0 0} (ring.{0} (has_neg.{0} linarith.comp)) pos h0)  := sorry --non-trivial
lemma new_lemma_130992 (h0 : complete_lattice (semiring unsigned)) : is_compactly_generated (semiring unsigned) := sorry --non-trivial
lemma new_lemma_130993 (h0 : topological_space (linear_ordered_add_comm_group (random_gen congr_arg_kind))) : t0_space (linear_ordered_add_comm_group (random_gen congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_130994 (h0 : has_neg (has_lt linarith.ineq)) (h1 : measurable_space (has_lt linarith.ineq)) : has_measurable_neg (has_lt linarith.ineq) := sorry --non-trivial
lemma new_lemma_130995 (h0 : add_monoid (has_to_string (has_to_string (has_to_string pos)))) : add_monoid.fg (has_to_string (has_to_string (has_to_string pos))) := sorry --non-trivial
lemma new_lemma_130996 (h0 : group (has_to_string (has_nndist (ring Type)))) : is_simple_group (has_to_string (has_nndist (ring Type))) := sorry --non-trivial
lemma new_lemma_130997 (h0 : topological_space (ring (has_Inf Type))) : topological_space.separable_space (ring (has_Inf Type)) := sorry --non-trivial
lemma new_lemma_130998 (h0 : list (add_right_cancel_monoid congr_arg_kind)) : palindrome h0 := sorry --non-trivial
lemma new_lemma_130999 (h0 : functor.add_const (topological_space (has_nndist pos)) ennreal) : @locally_compact_space.{0} (has_nndist.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (has_nndist.{0} pos)) ennreal h0)  := sorry --non-trivial
lemma new_lemma_131000 (h0 : function.extfun Type ring) : @is_principal_ideal_ring.{0} (has_zero.{0} pos) (@function.extfun_app.{2 1} Type ring.{0} h0 (has_zero.{0} pos))  := sorry --non-trivial
lemma new_lemma_131001 (h0 : semiring (complete_distrib_lattice (has_neg pos))) : is_noetherian_ring (complete_distrib_lattice (has_neg pos)) := sorry --non-trivial
lemma new_lemma_131002 (h0 : functor.add_const (topological_space (add_cancel_monoid Type)) (has_neg_part name)) : @loc_path_connected_space.{1} (add_cancel_monoid.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (add_cancel_monoid.{1} Type)) (has_neg_part.{0} name) h0)  := sorry --non-trivial
lemma new_lemma_131003 (h0 : monoid (ring (has_add name))) : monoid.fg (ring (has_add name)) := sorry --non-trivial
lemma new_lemma_131004 (h0 : fin has_zero.zero) : @rank_condition.{0} (normed_lattice_add_comm_group.{0} real) (@matrix.vec_empty.{0} (ring.{0} (normed_lattice_add_comm_group.{0} real)) h0)  := sorry --non-trivial
lemma new_lemma_131005 (h0 : functor.add_const (uniform_space (ordered_comm_ring Type)) Type) : @separated_space.{1} (ordered_comm_ring.{1} Type) (@functor.add_const.run.{1 1} (uniform_space.{1} (ordered_comm_ring.{1} Type)) Type h0)  := sorry --non-trivial
lemma new_lemma_131006 (h0 : list (encodable (random_gen (has_norm char)))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_131007 (h0 : function.extfun Type topological_space) : @t0_space.{0} (cancel_monoid.{0} ennreal) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (cancel_monoid.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_131008 (h0 : set (add_comm_semigroup (add_comm_semigroup linarith.ineq) -> std_gen)) : set.separates_points h0 := sorry --non-trivial
lemma new_lemma_131009 (h0 : functor.add_const (function.extfun (Type 1) filter) pos) : filter.ne_bot (function.extfun_app (functor.add_const.run h0) Type) := sorry --non-trivial
lemma new_lemma_131010 (h0 : functor.add_const (cancel_comm_monoid_with_zero (generalized_boolean_algebra linarith.comp)) pos) : @unique_factorization_monoid.{0} (generalized_boolean_algebra.{0} linarith.comp) (@functor.add_const.run.{0 0} (cancel_comm_monoid_with_zero.{0} (generalized_boolean_algebra.{0} linarith.comp)) pos h0)  := sorry --non-trivial
lemma new_lemma_131011 (h1 : set fun_info) : set.subsingleton h1 := sorry --non-trivial
lemma new_lemma_131012 (h0 : topological_space (finset (has_add Type))) : irreducible_space (finset (has_add Type)) := sorry --non-trivial
lemma new_lemma_131013 (h0 : topological_space (ring (has_pos_part (has_Inf (has_add linarith.comp))))) : totally_separated_space (ring (has_pos_part (has_Inf (has_add linarith.comp)))) := sorry --non-trivial
lemma new_lemma_131014 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @group.fg.{0} (ordered_comm_ring.{0} name) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (ordered_comm_ring.{0} name))  := sorry --non-trivial
lemma new_lemma_131015 (h0 : filter (has_pos_part pos)) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_131016 (h0 : functor.add_const (prod (has_Sup num) (has_Sup num)) empty) : id_rel (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_131017 (h0 : function.extfun Type topological_space) : t0_space real := sorry --non-trivial
lemma new_lemma_131018 (h0 : topological_space (semiring (random_gen linarith.comp_source))) : locally_compact_space (semiring (random_gen linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_131019 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @irreducible_space.{0} pos (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) pos)  := sorry --non-trivial
lemma new_lemma_131020 (h0 : ring (has_compl (has_ssubset fun_info))) : rank_condition (has_compl (has_ssubset fun_info)) := sorry --non-trivial
lemma new_lemma_131021 (h0 : semiring (add_group (semiring (semiring empty)))) : is_noetherian_ring (add_group (semiring (semiring empty))) := sorry --non-trivial
lemma new_lemma_131022 (h0 : topological_space (pseudo_metric_space pos)) : regular_space (pseudo_metric_space pos) := sorry --non-trivial
lemma new_lemma_131023 (h0 : function.extfun Type uniform_space) : @complete_space.{0} (canonically_ordered_comm_semiring.{0} num) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (canonically_ordered_comm_semiring.{0} num))  := sorry --non-trivial
lemma new_lemma_131024 (h0 : ring (has_to_string (has_add (has_to_string (mul_one_class Type))))) : is_domain (has_to_string (has_add (has_to_string (mul_one_class Type)))) := sorry --non-trivial
lemma new_lemma_131025 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @totally_disconnected_space.{0} (add_comm_monoid.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (add_comm_monoid.{0} pos))  := sorry --non-trivial
lemma new_lemma_131026 (h0 : topological_space (has_add (finset (has_to_string (mul_one_class Type))))) : path_connected_space (has_add (finset (has_to_string (mul_one_class Type)))) := sorry --non-trivial
lemma new_lemma_131027 (h0 : not (ring (comm_ring linarith.ineq) -> false)) : @rank_condition.{0} (comm_ring.{0} linarith.ineq) (@classical.by_contradiction'.{1} (ring.{0} (comm_ring.{0} linarith.ineq)) h0)  := sorry --non-trivial
lemma new_lemma_131028 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @normal_space.{0} (sub_neg_monoid.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (sub_neg_monoid.{0} pos))  := sorry --non-trivial
lemma new_lemma_131029 (h0 : complete_lattice (has_add string_imp)) : complete_lattice.is_Sup_finite_compact (has_add string_imp) := sorry --non-trivial
lemma new_lemma_131030 (h0 : topological_space (with_one (has_norm num))) : discrete_topology (with_one (has_norm num)) := sorry --non-trivial
lemma new_lemma_131031 (h0 : function.extfun Type (functor.add_const (complete_lattice (ordered_ring unsigned)))) : @is_compactly_generated.{0} (ordered_ring.{0} unsigned) (@functor.add_const.run.{0 0} (complete_lattice.{0} (ordered_ring.{0} unsigned)) empty (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (complete_lattice.{0} (ordered_ring.{0} unsigned))) h0 empty))  := sorry --non-trivial
lemma new_lemma_131032 (h0 : finset (has_zero (finset linarith.comp))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_131033 (h0 : function.extfun Type ring) : @is_principal_ideal_ring.{0} (linear_ordered_field.{0} ennreal) (@function.extfun_app.{2 1} Type ring.{0} h0 (linear_ordered_field.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_131034 (h0 : topological_space (has_add (finset environment.implicit_infer_kind))) : regular_space (has_add (finset environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_131035 (h0 : functor.add_const (add_group (left_cancel_monoid unsigned)) unsigned) : @is_add_cyclic.{0} (left_cancel_monoid.{0} unsigned) (@functor.add_const.run.{0 0} (add_group.{0} (left_cancel_monoid.{0} unsigned)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_131036 (h0 : ring (complete_distrib_lattice (normed_comm_ring (has_add (boolean_algebra.core name))))) : rank_condition (complete_distrib_lattice (normed_comm_ring (has_add (boolean_algebra.core name)))) := sorry --non-trivial
lemma new_lemma_131037 (h1 : group (complete_semilattice_Sup char)) : group.fg (complete_semilattice_Sup char) := sorry --non-trivial
lemma new_lemma_131038 (h0 : not (ring (normed_field linarith.comp_source) -> false)) : @strong_rank_condition.{0} (normed_field.{0} linarith.comp_source) (@classical.by_contradiction'.{1} (ring.{0} (normed_field.{0} linarith.comp_source)) h0)  := sorry --non-trivial
lemma new_lemma_131039 (h0 : topological_space (semiring (random_gen fun_info))) : totally_disconnected_space (semiring (random_gen fun_info)) := sorry --non-trivial
lemma new_lemma_131040 (h0 : function.extfun Type (functor.comp uniform_space canonically_ordered_comm_semiring)) : @separated_space.{0} (canonically_ordered_comm_semiring.{0} pos) (@functor.comp.run.{0 0 0} uniform_space.{0} canonically_ordered_comm_semiring.{0} pos (@function.extfun_app.{2 1} Type (functor.comp.{0 0 0} uniform_space.{0} canonically_ordered_comm_semiring.{0}) h0 pos))  := sorry --non-trivial
lemma new_lemma_131041 (h0 : function.extfun Type topological_space) : @locally_compact_space.{0} (@id.{2} Type empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (@id.{2} Type empty))  := sorry --non-trivial
lemma new_lemma_131042 (h0 : topological_space (semigroup (has_add environment.implicit_infer_kind))) : irreducible_space (semigroup (has_add environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_131043 (h0 : complete_lattice (complete_semilattice_Sup string_imp)) : is_compactly_generated (complete_semilattice_Sup string_imp) := sorry --non-trivial
lemma new_lemma_131044 (h0 : function.extfun Type list) : list.nodup (function.extfun_app h0 (linear_ordered_comm_monoid_with_zero empty)) := sorry --non-trivial
lemma new_lemma_131045 (h0 : prod (add_group unsigned) (add_group unsigned)) : id_rel h0 := sorry --non-trivial
lemma new_lemma_131046 (h0 : topological_space (has_Inf (sub_neg_monoid real))) : t1_space (has_Inf (sub_neg_monoid real)) := sorry --non-trivial
lemma new_lemma_131047 (h0 : has_mem.mem group has_emptyc.emptyc) : @is_cyclic.{0} (random_gen.{0} fun_info) (@function.extfun_app.{2 1} Type group.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) group.{0} h0) (random_gen.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_131048 (h0 : uniform_space (monoid pos)) : separated_space (monoid pos) := sorry --non-trivial
lemma new_lemma_131049 (h0 : topological_space (random_gen (random_gen (random_gen reducibility_hints)))) : t0_space (random_gen (random_gen (random_gen reducibility_hints))) := sorry --non-trivial
lemma new_lemma_131050 (h0 : functor.add_const (add_group (has_zero linarith.comp)) (comm_group name)) : @is_add_cyclic.{0} (has_zero.{0} linarith.comp) (@functor.add_const.run.{0 0} (add_group.{0} (has_zero.{0} linarith.comp)) (comm_group.{0} name) h0)  := sorry --non-trivial
lemma new_lemma_131051 (h0 : uniform_space (with_bot num)) : separated_space (with_bot num) := sorry --non-trivial
lemma new_lemma_131052 (h0 : functor.add_const (function.extfun (Type 1) topological_space) pos) : @locally_compact_space.{1} (comm_group.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) topological_space.{1}) pos h0) (comm_group.{1} Type))  := sorry --non-trivial
lemma new_lemma_131053 (h0 : uniform_space (distrib_lattice (random_gen (random_gen (random_gen string_imp))))) : complete_space (distrib_lattice (random_gen (random_gen (random_gen string_imp)))) := sorry --non-trivial
lemma new_lemma_131054 (h0 : not (function.extfun Type uniform_space -> false)) : @separated_space.{0} (measurable_space.dynkin_system.{0} unsigned) (@function.extfun_app.{2 1} Type uniform_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type uniform_space.{0}) h0) (measurable_space.dynkin_system.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_131055 (h0 : function.extfun Type topological_space) : @preirreducible_space.{0} (generalized_boolean_algebra.{0} real) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (generalized_boolean_algebra.{0} real))  := sorry --non-trivial
lemma new_lemma_131056 (h0 : group num) : normalizer_condition num := sorry --non-trivial
lemma new_lemma_131057 (h0 : functor.add_const (topological_space (finset linarith.comp)) (finset Type)) : @loc_path_connected_space.{0} (finset.{0} linarith.comp) (@functor.add_const.run.{0 1} (topological_space.{0} (finset.{0} linarith.comp)) (finset.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_131058 (h0 : semiring (filter unsigned)) : is_noetherian_ring (filter unsigned) := sorry --non-trivial
lemma new_lemma_131059 (h0 : functor.add_const (topological_space (has_nndist environment.implicit_infer_kind)) environment.implicit_infer_kind) : @loc_path_connected_space.{0} (has_nndist.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (has_nndist.{0} environment.implicit_infer_kind)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_131060 (h0 : fin has_zero.zero) : @archimedean.{0} (ordered_comm_ring.{0} pos) (@function.extfun_app.{2 1} Type ordered_add_comm_monoid.{0} (@matrix.vec_empty.{1} (function.extfun.{2 1} Type ordered_add_comm_monoid.{0}) h0) (ordered_comm_ring.{0} pos))  := sorry --non-trivial
lemma new_lemma_131061 (h0 : not (list (measure_theory.measure_space empty) -> false)) : list.nodup (classical.by_contradiction' h0) := sorry --non-trivial
lemma new_lemma_131062 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @strong_rank_condition.{0} (linear_ordered_semiring.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (linear_ordered_semiring.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_131063 (h0 : topological_space (complete_distrib_lattice Type)) : path_connected_space (complete_distrib_lattice Type) := sorry --non-trivial
lemma new_lemma_131064 (h0 : function.extfun (finset Type) (has_mem.mem (measurable_space fun_info))) : is_compactly_generated (measurable_space fun_info) := sorry --non-trivial
lemma new_lemma_131065 (h0 : topological_space (nondiscrete_normed_field (mul_one_class environment.projection_info))) (h1 : add_group (nondiscrete_normed_field (mul_one_class environment.projection_info))) : topological_add_group (nondiscrete_normed_field (mul_one_class environment.projection_info)) := sorry --non-trivial
lemma new_lemma_131066 (h0 : function.extfun Type topological_space) : @preirreducible_space.{0} (mul_zero_class.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (mul_zero_class.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_131067 (h0 : function.extfun Type list) : palindrome (function.extfun_app h0 (as_linear_order unsigned)) := sorry --non-trivial
lemma new_lemma_131068 (h0 : function.extfun Type topological_space) : @topological_space.separable_space.{0} (ordered_comm_monoid.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (ordered_comm_monoid.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_131069 (h0 : ring (has_nndist (ring linarith.comp))) : rank_condition (has_nndist (ring linarith.comp)) := sorry --non-trivial
lemma new_lemma_131070 (h0 : ordered_add_comm_monoid (has_Inf (has_add (has_add (has_add (has_Inf linarith.comp)))))) : archimedean (has_Inf (has_add (has_add (has_add (has_Inf linarith.comp))))) := sorry --non-trivial
lemma new_lemma_131071 (h0 : cancel_comm_monoid_with_zero (ring pos)) : unique_factorization_monoid (ring pos) := sorry --non-trivial
lemma new_lemma_131072 (h0 : not (complete_lattice (encodable to_additive.value_type) -> false)) : @complete_lattice.is_Sup_finite_compact.{0} (encodable.{0} to_additive.value_type) (@classical.by_contradiction'.{1} (complete_lattice.{0} (encodable.{0} to_additive.value_type)) h0)  := sorry --non-trivial
lemma new_lemma_131073 (h0 : ring (boolean_algebra (has_pos_part linarith.comp))) : rank_condition (boolean_algebra (has_pos_part linarith.comp)) := sorry --non-trivial
lemma new_lemma_131074 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @complete_space.{0} (with_bot.{0} linarith.ineq) (@function.extfun_app.{2 1} Type uniform_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 uniform_space.{0}) (with_bot.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_131075 (h0 : complete_lattice (measurable_space (random_gen linarith.comp_source))) : complete_lattice.is_Sup_finite_compact (measurable_space (random_gen linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_131076 (h0 : set (has_nnnorm (has_dist string_imp))) : set.finite h0 := sorry --non-trivial
lemma new_lemma_131077 (h0 : function.extfun Type semiring) : @is_noetherian_ring.{0} (complete_semilattice_Sup.{0} linarith.ineq) (@function.extfun_app.{2 1} Type semiring.{0} h0 (complete_semilattice_Sup.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_131078 (h0 : uniform_space (linear_order (option unsigned))) : separated_space (linear_order (option unsigned)) := sorry --non-trivial
lemma new_lemma_131079 (h0 : ring (denumerable ennreal)) : rank_condition (denumerable ennreal) := sorry --non-trivial
lemma new_lemma_131080 (h0 : function.extfun (nat -> Type) (function.extfun nat)) : @is_cyclic.{0} (comm_semigroup.{0} pos) (@matrix.vec_empty.{0} (group.{0} (comm_semigroup.{0} pos)) (@function.extfun_app.{1 1} nat fin (@function.extfun_app.{2 1} (nat → Type) (function.extfun.{1 1} nat) h0 fin) (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_131081 (h0 : not (topological_space (semi_normed_ring (random_gen (random_gen linarith.ineq))) -> false)) : @t0_space.{0} (semi_normed_ring.{0} (random_gen.{0} (random_gen.{0} linarith.ineq))) (@classical.by_contradiction'.{1} (topological_space.{0} (semi_normed_ring.{0} (random_gen.{0} (random_gen.{0} linarith.ineq)))) h0)  := sorry --non-trivial
lemma new_lemma_131082 (h0 : measurable_space std_gen) (h2 : measure_theory.measure std_gen) : measure_theory.is_finite_measure h2 := sorry --non-trivial
lemma new_lemma_131083 (h0 : functor.add_const (function.extfun Type finset) pos) : finset.nonempty (function.extfun_app (functor.add_const.run h0) (has_add linarith.comp)) := sorry --non-trivial
lemma new_lemma_131084 (h0 : topological_space (has_top (has_top to_additive.value_type))) : totally_disconnected_space (has_top (has_top to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_131085 (h0 : not (function.extfun Type topological_space -> false)) : @locally_compact_space.{0} (complete_semilattice_Sup.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (complete_semilattice_Sup.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_131086 (h0 : topological_space (has_norm (has_norm (has_norm (semiring empty))))) : irreducible_space (has_norm (has_norm (has_norm (semiring empty)))) := sorry --non-trivial
lemma new_lemma_131087 (h0 : group (add_cancel_monoid (has_nndist (has_nndist linarith.comp)))) : group.fg (add_cancel_monoid (has_nndist (has_nndist linarith.comp))) := sorry --non-trivial
lemma new_lemma_131088 (h0 : function.extfun Type complete_lattice) : @is_compactly_generated.{0} (generalized_boolean_algebra.{0} linarith.comp) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (generalized_boolean_algebra.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_131089 (h0 : ring (has_nnnorm (metric_space char))) : rank_condition (has_nnnorm (metric_space char)) := sorry --non-trivial
lemma new_lemma_131090 (h0 : functor.add_const (topological_space (has_add pos)) name) : @normal_space.{0} (has_add.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (has_add.{0} pos)) name h0)  := sorry --non-trivial
lemma new_lemma_131091 (h0 : topological_space (has_one (has_top (semiring fun_info)))) : irreducible_space (has_one (has_top (semiring fun_info))) := sorry --non-trivial
lemma new_lemma_131092 (h0 : functor.add_const (topological_space znum) empty) : @totally_disconnected_space.{0} znum (@functor.add_const.run.{0 0} (topological_space.{0} znum) empty h0)  := sorry --non-trivial
lemma new_lemma_131093 (h0 : complete_lattice (has_zero (semigroup name))) : is_compactly_generated (has_zero (semigroup name)) := sorry --non-trivial
lemma new_lemma_131094 (h0 : list (canonically_ordered_comm_semiring (has_add (has_add name)))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_131095 (h0 : functor.add_const (list (ring linarith.comp)) environment.implicit_infer_kind) : palindrome (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_131096 (h0 : group (option (option pos))) : group.fg (option (option pos)) := sorry --non-trivial
lemma new_lemma_131097 (h0 : not (ring (distrib reducibility_hints) -> false)) : @strong_rank_condition.{0} (distrib.{0} reducibility_hints) (@classical.by_contradiction'.{1} (ring.{0} (distrib.{0} reducibility_hints)) h0)  := sorry --non-trivial
lemma new_lemma_131098 (h1 : Prop -> char) (h2 : coe_sort (set.range h1)) : set.range_splitting h1 h2 := sorry --non-trivial
lemma new_lemma_131099 (h0 : topological_space (mul_zero_class (semigroup name))) : irreducible_space (mul_zero_class (semigroup name)) := sorry --non-trivial
lemma new_lemma_131100 (h0 : topological_space (mul_zero_class (has_add (has_add (finset (finset pos)))))) : totally_disconnected_space (mul_zero_class (has_add (has_add (finset (finset pos))))) := sorry --non-trivial
lemma new_lemma_131101 (h1 : measurable_space environment.projection_info) (h2 : measure_theory.measure environment.projection_info) : measure_theory.is_finite_measure h2 := sorry --non-trivial
lemma new_lemma_131102 (h0 : topological_space (has_top (metric_space (metric_space empty)))) : preirreducible_space (has_top (metric_space (metric_space empty))) := sorry --non-trivial
lemma new_lemma_131103 (h0 : topological_space (ordered_comm_monoid (has_add (boolean_algebra.core (has_add pos))))) : totally_disconnected_space (ordered_comm_monoid (has_add (boolean_algebra.core (has_add pos)))) := sorry --non-trivial
lemma new_lemma_131104 (h0 : monoid (simple_graph (ordered_cancel_add_comm_monoid empty))) : monoid.fg (simple_graph (ordered_cancel_add_comm_monoid empty)) := sorry --non-trivial
lemma new_lemma_131105 (h0 : function.extfun Type topological_space) : @t1_space.{0} (bin_tree.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (bin_tree.{0} empty))  := sorry --non-trivial
lemma new_lemma_131106 (h1 : uniform_space (has_norm (has_norm congr_arg_kind))) : separated_space (has_norm (has_norm congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_131107 (h0 : topological_space (normed_comm_ring Type)) : t0_space (normed_comm_ring Type) := sorry --non-trivial
lemma new_lemma_131108 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @totally_disconnected_space.{0} (cancel_monoid.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (cancel_monoid.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_131109 (h0 : topological_space (sub_neg_monoid real)) : totally_disconnected_space (sub_neg_monoid real) := sorry --non-trivial
lemma new_lemma_131110 (h0 : function.extfun Type group) : @is_cyclic.{0} (generalized_boolean_algebra.{0} name) (@function.extfun_app.{2 1} Type group.{0} h0 (generalized_boolean_algebra.{0} name))  := sorry --non-trivial
lemma new_lemma_131111 (h0 : add_group (has_lt (mul_one_class fun_info))) : is_add_cyclic (has_lt (mul_one_class fun_info)) := sorry --non-trivial
lemma new_lemma_131112 (h0 : uniform_space (distrib (has_nnnorm (has_nnnorm (has_nnnorm (random_gen char)))))) : complete_space (distrib (has_nnnorm (has_nnnorm (has_nnnorm (random_gen char))))) := sorry --non-trivial
lemma new_lemma_131113 (h0 : functor.add_const (topological_space (semigroup Type)) name) : @path_connected_space.{1} (semigroup.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (semigroup.{1} Type)) name h0)  := sorry --non-trivial
lemma new_lemma_131114 (h0 : ring (simple_graph congr_arg_kind)) : is_domain (simple_graph congr_arg_kind) := sorry --non-trivial
lemma new_lemma_131115 (h0 : add_monoid (left_cancel_semigroup (semiring (semiring num)))) : add_monoid.fg (left_cancel_semigroup (semiring (semiring num))) := sorry --non-trivial
lemma new_lemma_131116 (h2 : topological_space enat) : totally_disconnected_space enat := sorry --non-trivial
lemma new_lemma_131117 (h0 : add_monoid (generalized_boolean_algebra (sub_neg_monoid pos))) : add_monoid.fg (generalized_boolean_algebra (sub_neg_monoid pos)) := sorry --non-trivial
lemma new_lemma_131118 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_domain.{0} (ordered_comm_ring.{0} linarith.comp) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (ordered_comm_ring.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_131119 (h0 : topological_space (normed_lattice_add_comm_group (has_add Type))) : sequential_space (normed_lattice_add_comm_group (has_add Type)) := sorry --non-trivial
lemma new_lemma_131120 (h0 : functor.add_const (group (boolean_algebra pos)) pos) : @is_cyclic.{0} (boolean_algebra.{0} pos) (@functor.add_const.run.{0 0} (group.{0} (boolean_algebra.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_131121 (h0 : fin has_zero.zero) : @normalizer_condition.{0} (canonically_linear_ordered_monoid.{0} pos) (@matrix.vec_empty.{0} (group.{0} (canonically_linear_ordered_monoid.{0} pos)) h0)  := sorry --non-trivial
lemma new_lemma_131122 (h0 : has_neg (mul_one_class (has_union std_gen))) (h1 : measurable_space (mul_one_class (has_union std_gen))) : has_measurable_neg (mul_one_class (has_union std_gen)) := sorry --non-trivial
lemma new_lemma_131123 (h0 : to_additive.value_type -> to_additive.value_type -> Prop) : total h0 := sorry --non-trivial
lemma new_lemma_131124 (h0 : not (function.extfun Type topological_space -> false)) : @preirreducible_space.{0} (has_union.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (has_union.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_131125 (h0 : topological_space (has_nndist (has_neg linarith.comp))) : totally_separated_space (has_nndist (has_neg linarith.comp)) := sorry --non-trivial
lemma new_lemma_131126 (h0 : not (group (has_append reducibility_hints) -> false)) : @is_cyclic.{0} (has_append.{0} reducibility_hints) (@classical.by_contradiction'.{1} (group.{0} (has_append.{0} reducibility_hints)) h0)  := sorry --non-trivial
lemma new_lemma_131127 (h0 : functor.add_const (topological_space (has_nndist linarith.comp)) (comm_group pos)) : @regular_space.{0} (has_nndist.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (has_nndist.{0} linarith.comp)) (comm_group.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_131128 (h0 : topological_space (comm_group (option (option environment.implicit_infer_kind)))) : totally_separated_space (comm_group (option (option environment.implicit_infer_kind))) := sorry --non-trivial
lemma new_lemma_131129 (h0 : topological_space (ring (finset Type))) : preirreducible_space (ring (finset Type)) := sorry --non-trivial
lemma new_lemma_131130 (h0 : functor.add_const (topological_space (metric_space unsigned)) unsigned) : @t0_space.{0} (metric_space.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (metric_space.{0} unsigned)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_131131 (h0 : complete_lattice name) (h1 : option (complete_lattice name)) : is_atomistic name := sorry --non-trivial
lemma new_lemma_131132 (h0 : filter (has_pos_part (has_add (has_pos_part Type)))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_131133 (h0 : semiring (has_one (semiring (semiring unsigned)))) : is_noetherian_ring (has_one (semiring (semiring unsigned))) := sorry --non-trivial
lemma new_lemma_131134 (h0 : uniform_space (normed_group (random_gen linarith.comp_source))) : complete_space (normed_group (random_gen linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_131135 (h1 : set (ereal -> ereal)) : set.separates_points h1 := sorry --non-trivial
lemma new_lemma_131136 (h0 : ordered_add_comm_monoid (finset (finset (has_Inf pos)))) : archimedean (finset (finset (has_Inf pos))) := sorry --non-trivial
lemma new_lemma_131137 (h0 : uniform_space (canonically_ordered_comm_semiring name)) : separated_space (canonically_ordered_comm_semiring name) := sorry --non-trivial
lemma new_lemma_131138 (h1 : uniform_space (uniform_space (mul_one_class (mul_one_class (distrib linarith.comp_source))))) : complete_space (uniform_space (mul_one_class (mul_one_class (distrib linarith.comp_source)))) := sorry --non-trivial
lemma new_lemma_131139 (h1 : function.extfun Type uniform_space) : @complete_space.{0} (with_one.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type uniform_space.{0} h1 (with_one.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_131140 (h0 : functor.add_const (function.extfun Type topological_space) linarith.comp) : @path_connected_space.{0} (has_Inf.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) linarith.comp h0) (has_Inf.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_131141 (h0 : set (environment.projection_info -> ereal)) : set.separates_points h0 := sorry --non-trivial
lemma new_lemma_131142 (h0 : Type -> Type -> Prop) : is_refl Type h0 := sorry --non-trivial
lemma new_lemma_131143 (h0 : add_monoid (ordered_comm_group (option (option empty)))) : add_monoid.fg (ordered_comm_group (option (option empty))) := sorry --non-trivial
lemma new_lemma_131144 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_atomistic.{0} (semiring.{0} linarith.comp) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (semiring.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_131145 (h0 : functor.add_const (group (add_cancel_monoid linarith.comp)) linarith.comp) : @group.fg.{0} (add_cancel_monoid.{0} linarith.comp) (@functor.add_const.run.{0 0} (group.{0} (add_cancel_monoid.{0} linarith.comp)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_131146 (h2 : ring (has_lt to_additive.value_type)) : rank_condition (has_lt to_additive.value_type) := sorry --non-trivial
lemma new_lemma_131147 (h0 : group (denumerable (linear_ordered_add_comm_group linarith.comp_source))) : is_cyclic (denumerable (linear_ordered_add_comm_group linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_131148 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @normalizer_condition.{0} (with_bot.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (with_bot.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_131149 (h0 : functor.add_const (function.extfun Type ordered_comm_monoid) Type) : @has_exists_mul_of_le.{0} (has_pos_part.{0} linarith.comp) (@function.extfun_app.{2 1} Type ordered_comm_monoid.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type ordered_comm_monoid.{0}) Type h0) (has_pos_part.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_131150 (h0 : function.extfun Type topological_space) : @topological_space.separable_space.{0} (has_zero.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_zero.{0} pos))  := sorry --non-trivial
lemma new_lemma_131151 (h0 : ring (free_add_monoid (semiring (semiring (option num))))) : is_principal_ideal_ring (free_add_monoid (semiring (semiring (option num)))) := sorry --non-trivial
lemma new_lemma_131152 (h0 : list (has_to_string (canonically_linear_ordered_monoid name))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_131153 (h0 : complete_lattice (has_append (has_nnnorm fun_info))) : complete_lattice.is_Sup_finite_compact (has_append (has_nnnorm fun_info)) := sorry --non-trivial
lemma new_lemma_131154 (h0 : not (topological_space (semiring (has_norm linarith.comp_source)) -> false)) : @totally_separated_space.{0} (semiring.{0} (has_norm.{0} linarith.comp_source)) (@classical.by_contradiction'.{1} (topological_space.{0} (semiring.{0} (has_norm.{0} linarith.comp_source))) h0)  := sorry --non-trivial
lemma new_lemma_131155 (h0 : topological_space (add_cancel_comm_monoid char)) : totally_disconnected_space (add_cancel_comm_monoid char) := sorry --non-trivial
lemma new_lemma_131156 (h0 : topological_space (random_gen (has_top linarith.ineq))) : totally_disconnected_space (random_gen (has_top linarith.ineq)) := sorry --non-trivial
lemma new_lemma_131157 (h0 : functor.add_const (uniform_space (non_assoc_semiring empty)) num) : @complete_space.{0} (non_assoc_semiring.{0} empty) (@functor.add_const.run.{0 0} (uniform_space.{0} (non_assoc_semiring.{0} empty)) num h0)  := sorry --non-trivial
lemma new_lemma_131158 (h0 : functor.add_const Prop (has_neg num)) : functor.add_const.run h0 := sorry --non-trivial
lemma new_lemma_131159 (h0 : functor.add_const (function.extfun Type topological_space) Type) : @topological_space.separable_space.{0} (has_neg.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type topological_space.{0}) Type h0) (has_neg.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_131160 (h0 : list (filter unsigned)) : palindrome h0 := sorry --non-trivial
lemma new_lemma_131161 (h0 : uniform_space (normed_field (has_nnnorm (has_nnnorm linarith.ineq)))) : complete_space (normed_field (has_nnnorm (has_nnnorm linarith.ineq))) := sorry --non-trivial
lemma new_lemma_131162 (h0 : not (topological_space (with_one congr_arg_kind) -> false)) : @locally_compact_space.{0} (with_one.{0} congr_arg_kind) (@classical.by_contradiction'.{1} (topological_space.{0} (with_one.{0} congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_131163 (h0 : not (function.extfun Type uniform_space -> false)) : @complete_space.{0} (normed_group.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type uniform_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type uniform_space.{0}) h0) (normed_group.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_131164 (h0 : topological_space (add_cancel_monoid (comm_group (comm_group unsigned)))) : totally_separated_space (add_cancel_monoid (comm_group (comm_group unsigned))) := sorry --non-trivial
lemma new_lemma_131165 (h0 : function.extfun nat fin) : @is_cyclic.{1} (complete_distrib_lattice.{1} Type) (@matrix.vec_empty.{1} (group.{1} (complete_distrib_lattice.{1} Type)) (@function.extfun_app.{1 1} nat fin (@matrix.vec_empty.{0} (function.extfun.{1 1} nat fin) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero))) (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_131166 (h0 : functor.add_const (function.extfun Type topological_space) unsigned) : @t0_space.{0} (pseudo_metric_space.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) unsigned h0) (pseudo_metric_space.{0} num))  := sorry --non-trivial
lemma new_lemma_131167 (h0 : not (ring (has_top empty) -> false)) : @rank_condition.{0} (has_top.{0} empty) (@classical.by_contradiction'.{1} (ring.{0} (has_top.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_131168 (h0 : ring (ring environment.implicit_infer_kind)) : is_principal_ideal_ring (ring environment.implicit_infer_kind) := sorry --non-trivial
lemma new_lemma_131169 (h0 : group (has_top (random_gen (random_gen (random_gen (random_gen linarith.ineq)))))) : group.fg (has_top (random_gen (random_gen (random_gen (random_gen linarith.ineq))))) := sorry --non-trivial
lemma new_lemma_131170 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : finset.nonempty (function.extfun_app (function.extfun_app h0 finset) (has_Inf pos)) := sorry --non-trivial
lemma new_lemma_131171 (h0 : function.extfun Type group) : @normalizer_condition.{0} (add_semigroup.{0} unsigned) (@function.extfun_app.{2 1} Type group.{0} h0 (add_semigroup.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_131172 (h0 : not (group (has_norm unsigned) -> false)) : @normalizer_condition.{0} (has_norm.{0} unsigned) (@classical.by_contradiction'.{1} (group.{0} (has_norm.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_131173 (h0 : functor.add_const (topological_space (has_add ennreal)) num) : @t0_space.{0} (has_add.{0} ennreal) (@functor.add_const.run.{0 0} (topological_space.{0} (has_add.{0} ennreal)) num h0)  := sorry --non-trivial
lemma new_lemma_131174 (h0 : functor.comp complete_lattice has_neg name) : @complete_lattice.is_Sup_finite_compact.{0} (has_neg.{0} name) (@functor.comp.run.{0 0 0} complete_lattice.{0} has_neg.{0} name h0)  := sorry --non-trivial
lemma new_lemma_131175 (h0 : functor.add_const (group (cancel_monoid Type)) (has_add (has_add (has_add (has_add name))))) : @group.fg.{1} (cancel_monoid.{1} Type) (@functor.add_const.run.{1 0} (group.{1} (cancel_monoid.{1} Type)) (has_add.{0} (has_add.{0} (has_add.{0} (has_add.{0} name)))) h0)  := sorry --non-trivial
lemma new_lemma_131176 (h0 : functor.add_const (topological_space (add_cancel_monoid name)) pos) : @normal_space.{0} (add_cancel_monoid.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (add_cancel_monoid.{0} name)) pos h0)  := sorry --non-trivial
lemma new_lemma_131177 (h0 : set (nondiscrete_normed_field (mul_one_class environment.projection_info))) : set.finite h0 := sorry --non-trivial
lemma new_lemma_131178 (h0 : ring (add_cancel_comm_monoid (has_nnnorm reducibility_hints))) : is_domain (add_cancel_comm_monoid (has_nnnorm reducibility_hints)) := sorry --non-trivial
lemma new_lemma_131179 (h0 : topological_space (normed_comm_ring num)) : discrete_topology (normed_comm_ring num) := sorry --non-trivial
lemma new_lemma_131180 (h0 : finset (ordered_comm_monoid (ring (ring (ring Type))))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_131181 (h0 : monoid (add_cancel_monoid num)) : monoid.fg (add_cancel_monoid num) := sorry --non-trivial
lemma new_lemma_131182 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : finset.nonempty (function.extfun_app (function.extfun_app h0 finset) (mul_zero_class pos)) := sorry --non-trivial
lemma new_lemma_131183 (h0 : functor.add_const (topological_space (boolean_algebra.core unsigned)) ennreal) : @normal_space.{0} (boolean_algebra.core.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (boolean_algebra.core.{0} unsigned)) ennreal h0)  := sorry --non-trivial
lemma new_lemma_131184 (h0 : functor.add_const (semiring (mul_zero_class Type)) name) : @is_noetherian_ring.{1} (mul_zero_class.{1} Type) (@functor.add_const.run.{1 0} (semiring.{1} (mul_zero_class.{1} Type)) name h0)  := sorry --non-trivial
lemma new_lemma_131185 (h2 : topological_space (comm_ring fun_info)) : totally_disconnected_space (comm_ring fun_info) := sorry --non-trivial
lemma new_lemma_131186 (h0 : topological_space (distrib_lattice (random_gen (random_gen (random_gen linarith.ineq))))) : totally_disconnected_space (distrib_lattice (random_gen (random_gen (random_gen linarith.ineq)))) := sorry --non-trivial
lemma new_lemma_131187 (h0 : ring (complete_linear_order (semiring num))) : is_principal_ideal_ring (complete_linear_order (semiring num)) := sorry --non-trivial
lemma new_lemma_131188 (h0 : topological_space (sub_neg_monoid (has_neg name))) : t1_space (sub_neg_monoid (has_neg name)) := sorry --non-trivial
lemma new_lemma_131189 (h0 : function.extfun Type monoid) : @monoid.fg.{0} (semiring.{0} linarith.ineq) (@function.extfun_app.{2 1} Type monoid.{0} h0 (semiring.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_131190 (h0 : linear_ordered_field (add_comm_monoid ennreal) -> linear_ordered_field (add_comm_monoid ennreal) -> Prop) : is_symm (linear_ordered_field (add_comm_monoid ennreal)) h0 := sorry --non-trivial
lemma new_lemma_131191 (h0 : complete_lattice (has_div ereal)) : is_compactly_generated (has_div ereal) := sorry --non-trivial
lemma new_lemma_131192 (h0 : topological_space (has_to_string (ring name))) : irreducible_space (has_to_string (ring name)) := sorry --non-trivial
lemma new_lemma_131193 (h0 : functor.add_const (topological_space (complete_distrib_lattice linarith.comp)) linarith.comp) : @t0_space.{0} (complete_distrib_lattice.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (complete_distrib_lattice.{0} linarith.comp)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_131194 (h0 : functor.comp topological_space ring name) : @locally_compact_space.{0} (ring.{0} name) (@functor.comp.run.{0 0 0} topological_space.{0} ring.{0} name h0)  := sorry --non-trivial
lemma new_lemma_131195 (h0 : functor.add_const (add_group (ring pos)) linarith.comp) : @is_add_cyclic.{0} (ring.{0} pos) (@functor.add_const.run.{0 0} (add_group.{0} (ring.{0} pos)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_131196 (h0 : functor.add_const (filter znum) num) : filter.ne_bot (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_131197 (h0 : functor.add_const (topological_space (add_group num)) empty) : @irreducible_space.{0} (add_group.{0} num) (@functor.add_const.run.{0 0} (topological_space.{0} (add_group.{0} num)) empty h0)  := sorry --non-trivial
lemma new_lemma_131198 (h0 : functor.add_const (topological_space (has_star num)) congr_arg_kind) : @normal_space.{0} (has_star.{0} num) (@functor.add_const.run.{0 0} (topological_space.{0} (has_star.{0} num)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_131199 (h0 : topological_space (ordered_comm_monoid (has_add (has_Inf name)))) : totally_separated_space (ordered_comm_monoid (has_add (has_Inf name))) := sorry --non-trivial
lemma new_lemma_131200 (h0 : group linarith.comp_source) (h1 : subgroup linarith.comp_source) : subgroup.normal h1 := sorry --non-trivial
lemma new_lemma_131201 (h0 : group (has_add (has_neg (has_neg (has_add name))))) : group.fg (has_add (has_neg (has_neg (has_add name)))) := sorry --non-trivial
lemma new_lemma_131202 (h0 : topological_space (normed_comm_ring (option name))) : loc_path_connected_space (normed_comm_ring (option name)) := sorry --non-trivial
lemma new_lemma_131203 (h0 : ring (div_inv_monoid char)) : is_domain (div_inv_monoid char) := sorry --non-trivial
lemma new_lemma_131204 (h0 : monoid (normed_group (semiring num))) : monoid.fg (normed_group (semiring num)) := sorry --non-trivial
lemma new_lemma_131205 (h0 : complete_lattice (has_pos_part (has_pos_part Type))) : is_compactly_generated (has_pos_part (has_pos_part Type)) := sorry --non-trivial
lemma new_lemma_131206 (h0 : topological_space (has_compl (has_ssubset linarith.comp_source))) : path_connected_space (has_compl (has_ssubset linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_131207 (h0 : topological_space (add_cancel_monoid (has_neg linarith.comp))) : normal_space (add_cancel_monoid (has_neg linarith.comp)) := sorry --non-trivial
lemma new_lemma_131208 (h0 : topological_space znum) : t0_space znum := sorry --non-trivial
lemma new_lemma_131209 (h0 : topological_space (mul_one_class ereal)) (h1 : set (set (mul_one_class ereal))) : topological_space.is_topological_basis h1 := sorry --non-trivial
lemma new_lemma_131210 (h1 : not (topological_space (has_norm to_additive.value_type) -> false)) : @discrete_topology.{0} (has_norm.{0} to_additive.value_type) (@classical.by_contradiction'.{1} (topological_space.{0} (has_norm.{0} to_additive.value_type)) h1)  := sorry --non-trivial
lemma new_lemma_131211 (h0 : ring (has_nndist unsigned)) : is_principal_ideal_ring (has_nndist unsigned) := sorry --non-trivial
lemma new_lemma_131212 (h0 : group (with_one (random_gen linarith.ineq))) : normalizer_condition (with_one (random_gen linarith.ineq)) := sorry --non-trivial
lemma new_lemma_131213 (h0 : has_lt (boolean_algebra.core ereal)) : no_max_order (boolean_algebra.core ereal) := sorry --non-trivial
lemma new_lemma_131214 (h0 : topological_space (has_neg (finset (finset environment.implicit_infer_kind)))) : path_connected_space (has_neg (finset (finset environment.implicit_infer_kind))) := sorry --non-trivial
lemma new_lemma_131215 (h0 : complete_lattice (mul_zero_class (has_add pos))) : is_atomistic (mul_zero_class (has_add pos)) := sorry --non-trivial
lemma new_lemma_131216 (h0 : functor.add_const (topological_space (add_cancel_monoid name)) Type) : @t1_space.{0} (add_cancel_monoid.{0} name) (@functor.add_const.run.{0 1} (topological_space.{0} (add_cancel_monoid.{0} name)) Type h0)  := sorry --non-trivial
lemma new_lemma_131217 (h0 : complete_lattice (has_to_string (has_neg linarith.comp))) : complete_lattice.is_Sup_finite_compact (has_to_string (has_neg linarith.comp)) := sorry --non-trivial
lemma new_lemma_131218 (h0 : group (normed_group unsigned)) : is_cyclic (normed_group unsigned) := sorry --non-trivial
lemma new_lemma_131219 (h0 : ordered_comm_monoid (boolean_algebra (has_pos_part linarith.comp))) : has_exists_mul_of_le (boolean_algebra (has_pos_part linarith.comp)) := sorry --non-trivial
lemma new_lemma_131220 (h0 : function.extfun (finset Type) (has_mem.mem (with_bot num))) : @complete_space.{0} (with_bot.{0} num) (@finset.pi.empty.{1 0} Type uniform_space.{0} (with_bot.{0} num) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (with_bot.{0} num)) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_131221 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @group.fg.{0} (has_emptyc.{0} (random_gen.{0} (random_gen.{0} (random_gen.{0} (random_gen.{0} linarith.ineq))))) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (has_emptyc.{0} (random_gen.{0} (random_gen.{0} (random_gen.{0} (random_gen.{0} linarith.ineq))))))  := sorry --non-trivial
lemma new_lemma_131222 (h0 : function.extfun (finset Type) (has_mem.mem (id num))) : @normalizer_condition.{0} (@id.{2} Type num) (@finset.pi.empty.{1 0} Type group.{0} (@id.{2} Type num) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (@id.{2} Type num)) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_131223 (h0 : add_monoid (add_cancel_monoid pos)) : add_monoid.fg (add_cancel_monoid pos) := sorry --non-trivial
lemma new_lemma_131224 (h0 : topological_space (add_cancel_monoid (has_add (has_add unsigned)))) : t0_space (add_cancel_monoid (has_add (has_add unsigned))) := sorry --non-trivial
lemma new_lemma_131225 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_add_cyclic.{0} (has_norm.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type add_group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 add_group.{0}) (has_norm.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_131226 (h0 : ring (add_right_cancel_monoid (semiring congr_arg_kind))) : is_principal_ideal_ring (add_right_cancel_monoid (semiring congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_131227 (h0 : filter (option (option name))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_131228 (h0 : add_group (comm_group (has_neg name))) : is_add_cyclic (comm_group (has_neg name)) := sorry --non-trivial
lemma new_lemma_131229 (h1 : add_group (add_monoid (has_nnnorm fun_info))) : is_add_cyclic (add_monoid (has_nnnorm fun_info)) := sorry --non-trivial
lemma new_lemma_131230 (h0 : functor.add_const (function.extfun Type filter) linarith.comp) : filter.ne_bot (function.extfun_app (functor.add_const.run h0) (normed_comm_ring linarith.comp)) := sorry --non-trivial
lemma new_lemma_131231 (h0 : not (ring (denumerable to_additive.value_type) -> false)) : @strong_rank_condition.{0} (denumerable.{0} to_additive.value_type) (@classical.by_contradiction'.{1} (ring.{0} (denumerable.{0} to_additive.value_type)) h0)  := sorry --non-trivial
lemma new_lemma_131232 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : finset.nonempty (function.extfun_app (function.extfun_app h0 finset) (semigroup ennreal)) := sorry --non-trivial
lemma new_lemma_131233 (h0 : topological_space (add_cancel_monoid name)) : discrete_topology (add_cancel_monoid name) := sorry --non-trivial
lemma new_lemma_131234 (h0 : functor.add_const (topological_space (boolean_algebra pos)) name) : @topological_space.separable_space.{0} (boolean_algebra.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (boolean_algebra.{0} pos)) name h0)  := sorry --non-trivial
lemma new_lemma_131235 (h0 : function.extfun Type ring) : @strong_rank_condition.{0} (group_with_zero.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type ring.{0} h0 (group_with_zero.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_131236 (h0 : functor.add_const (functor.comp semiring has_neg_part environment.implicit_infer_kind) pos) : @is_noetherian_ring.{0} (has_neg_part.{0} environment.implicit_infer_kind) (@functor.comp.run.{0 0 0} semiring.{0} has_neg_part.{0} environment.implicit_infer_kind (@functor.add_const.run.{0 0} (functor.comp.{0 0 0} semiring.{0} has_neg_part.{0} environment.implicit_infer_kind) pos h0))  := sorry --non-trivial
lemma new_lemma_131237 (h0 : topological_space (filter congr_arg_kind)) : normal_space (filter congr_arg_kind) := sorry --non-trivial
lemma new_lemma_131238 (h0 : functor.add_const (topological_space (has_pos_part Type)) (finset (finset pos))) : @sequential_space.{1} (has_pos_part.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (has_pos_part.{1} Type)) (finset.{0} (finset.{0} pos)) h0)  := sorry --non-trivial
lemma new_lemma_131239 (h0 : filter (canonically_ordered_monoid real)) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_131240 (h0 : topological_space (has_nndist unsigned)) : discrete_topology (has_nndist unsigned) := sorry --non-trivial
lemma new_lemma_131241 (h0 : function.extfun Type topological_space) : @path_connected_space.{0} (bin_tree.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (bin_tree.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_131242 (h0 : functor.add_const (topological_space (option name)) name) : @totally_separated_space.{0} (option.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (option.{0} name)) name h0)  := sorry --non-trivial
lemma new_lemma_131243 (h0 : topological_space (measurable_space ennreal)) : normal_space (measurable_space ennreal) := sorry --non-trivial
lemma new_lemma_131244 (h0 : topological_space (add_cancel_monoid (has_neg name))) : normal_space (add_cancel_monoid (has_neg name)) := sorry --non-trivial
lemma new_lemma_131245 (h0 : monoid (has_neg_part pos)) : monoid.fg (has_neg_part pos) := sorry --non-trivial
lemma new_lemma_131246 (h0 : topological_space (add_cancel_monoid (has_Inf (has_Inf (has_neg (has_neg (has_Inf Type))))))) : totally_separated_space (add_cancel_monoid (has_Inf (has_Inf (has_neg (has_neg (has_Inf Type)))))) := sorry --non-trivial
lemma new_lemma_131247 (h0 : topological_space (finset (has_neg (has_add Type)))) : normal_space (finset (has_neg (has_add Type))) := sorry --non-trivial
lemma new_lemma_131248 (h0 : functor.add_const (topological_space (semigroup Type)) pos) : @loc_path_connected_space.{1} (semigroup.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (semigroup.{1} Type)) pos h0)  := sorry --non-trivial
lemma new_lemma_131249 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : list.nodup (function.extfun_app (function.extfun_app h0 list) (boolean_algebra pos)) := sorry --non-trivial
lemma new_lemma_131250 (h0 : ring (add_monoid fun_info)) : is_domain (add_monoid fun_info) := sorry --non-trivial
lemma new_lemma_131251 (h0 : ordered_comm_monoid (has_zero (has_add (finset (ring (ring linarith.comp)))))) : has_exists_mul_of_le (has_zero (has_add (finset (ring (ring linarith.comp))))) := sorry --non-trivial
lemma new_lemma_131252 (h0 : fin has_zero.zero) : @is_atomistic.{0} (finset.{0} real) (@matrix.vec_empty.{0} (complete_lattice.{0} (finset.{0} real)) h0)  := sorry --non-trivial
lemma new_lemma_131253 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @preconnected_space.{1} (boolean_algebra.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 topological_space.{1}) (boolean_algebra.{1} Type))  := sorry --non-trivial
lemma new_lemma_131254 (h0 : complete_lattice (has_add environment.implicit_infer_kind)) : is_compactly_generated (has_add environment.implicit_infer_kind) := sorry --non-trivial
lemma new_lemma_131255 (h0 : topological_space (has_zero congr_arg_kind)) : totally_separated_space (has_zero congr_arg_kind) := sorry --non-trivial
lemma new_lemma_131256 (h0 : has_mem.mem Type has_emptyc.emptyc) : @is_cyclic.{1} Type (@finset.pi.empty.{2 1} (Type 1) group.{1} Type h0)  := sorry --non-trivial
lemma new_lemma_131257 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : palindrome (function.extfun_app (function.extfun_app h0 list) (boolean_algebra pos)) := sorry --non-trivial
lemma new_lemma_131258 (h0 : functor.add_const (uniform_space (add_cancel_monoid pos)) Type) : @separated_space.{0} (add_cancel_monoid.{0} pos) (@functor.add_const.run.{0 1} (uniform_space.{0} (add_cancel_monoid.{0} pos)) Type h0)  := sorry --non-trivial
lemma new_lemma_131259 (h0 : topological_space (canonically_ordered_monoid (has_neg (has_neg (has_neg name))))) : path_connected_space (canonically_ordered_monoid (has_neg (has_neg (has_neg name)))) := sorry --non-trivial
lemma new_lemma_131260 (h0 : list (measurable_space.dynkin_system num)) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_131261 (h0 : function.extfun Type group) : @is_cyclic.{0} (monoid.{0} num) (@function.extfun_app.{2 1} Type group.{0} h0 (monoid.{0} num))  := sorry --non-trivial
lemma new_lemma_131262 (h0 : function.extfun (finset (Type -> Type)) (has_mem.mem ring)) : @rank_condition.{0} (@id.{2} Type linarith.comp) (@function.extfun_app.{2 1} Type ring.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) ring.{0} (@function.extfun_app.{2 0} (finset.{1} (Type → Type)) (@has_mem.mem.{1 1} (Type → Type) (finset.{1} (Type → Type)) (@finset.has_mem.{1} (Type → Type)) ring.{0}) h0 (@has_emptyc.emptyc.{1} (finset.{1} (Type → Type)) (@finset.has_emptyc.{1} (Type → Type))))) (@id.{2} Type linarith.comp))  := sorry --non-trivial
lemma new_lemma_131263 (h0 : function.extfun Type group) : @normalizer_condition.{0} (linear_ordered_add_comm_group.{0} linarith.ineq) (@function.extfun_app.{2 1} Type group.{0} h0 (linear_ordered_add_comm_group.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_131264 (h2 : has_coe (has_ssubset fun_info) Prop) (h3 : has_ssubset fun_info) : @coe_b.{1 1} (has_ssubset.{0} fun_info) Prop h2 h3  := sorry --non-trivial
lemma new_lemma_131265 (h0 : functor.add_const (group pos) (option name)) : @is_simple_group.{0} pos (@functor.add_const.run.{0 0} (group.{0} pos) (option.{0} name) h0)  := sorry --non-trivial
lemma new_lemma_131266 (h0 : complete_lattice (with_bot (semiring (semiring unsigned)))) : is_compactly_generated (with_bot (semiring (semiring unsigned))) := sorry --non-trivial
lemma new_lemma_131267 (h0 : ring (has_div linarith.comp_source)) : strong_rank_condition (has_div linarith.comp_source) := sorry --non-trivial
lemma new_lemma_131268 (h0 : functor.add_const (list (left_cancel_semigroup num)) empty) : list.nodup (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_131269 (h0 : functor.add_const (topological_space (boolean_algebra unsigned)) name) : @loc_path_connected_space.{0} (boolean_algebra.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (boolean_algebra.{0} unsigned)) name h0)  := sorry --non-trivial
lemma new_lemma_131270 (h0 : function.extfun Type complete_lattice) : @is_compactly_generated.{0} unsigned (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 unsigned)  := sorry --non-trivial
lemma new_lemma_131271 (h2 : not (uniform_space (has_append char) -> false)) : @complete_space.{0} (has_append.{0} char) (@classical.by_contradiction'.{1} (uniform_space.{0} (has_append.{0} char)) h2)  := sorry --non-trivial
lemma new_lemma_131272 (h0 : fin has_zero.zero) : @separated_space.{0} (has_Inf.{0} pos) (@matrix.vec_empty.{0} (uniform_space.{0} (has_Inf.{0} pos)) h0)  := sorry --non-trivial
lemma new_lemma_131273 (h0 : ordered_comm_monoid (has_add (has_Inf (has_neg (finset (has_neg (has_pos_part linarith.comp))))))) : has_exists_mul_of_le (has_add (has_Inf (has_neg (finset (has_neg (has_pos_part linarith.comp)))))) := sorry --non-trivial
lemma new_lemma_131274 (h0 : has_mul char) (h1 : char) : is_regular h1 := sorry --non-trivial
lemma new_lemma_131275 (h0 : not (ring (has_append char) -> false)) : @is_domain.{0} (has_append.{0} char) (@classical.by_contradiction'.{1} (ring.{0} (has_append.{0} char)) h0)  := sorry --non-trivial
lemma new_lemma_131276 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @preirreducible_space.{0} (with_bot.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (with_bot.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_131277 (h0 : complete_lattice (normed_group (has_top linarith.comp_source))) : is_atomistic (normed_group (has_top linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_131278 (h3 : not (ring (fintype to_additive.value_type) -> false)) : @strong_rank_condition.{0} (fintype.{0} to_additive.value_type) (@classical.by_contradiction'.{1} (ring.{0} (fintype.{0} to_additive.value_type)) h3)  := sorry --non-trivial
lemma new_lemma_131279 (h0 : functor.add_const (function.extfun Type topological_space) (ring pos)) : @t0_space.{0} (finset.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) (ring.{0} pos) h0) (finset.{0} pos))  := sorry --non-trivial
lemma new_lemma_131280 (h0 : topological_space (has_norm (semiring (has_one empty)))) : normal_space (has_norm (semiring (has_one empty))) := sorry --non-trivial
lemma new_lemma_131281 (h0 : topological_space (has_append (random_gen (random_gen (random_gen (random_gen char)))))) : path_connected_space (has_append (random_gen (random_gen (random_gen (random_gen char))))) := sorry --non-trivial
lemma new_lemma_131282 (h0 : functor.add_const (topological_space (ordered_comm_monoid pos)) (has_Inf Type)) : @preirreducible_space.{0} (ordered_comm_monoid.{0} pos) (@functor.add_const.run.{0 1} (topological_space.{0} (ordered_comm_monoid.{0} pos)) (has_Inf.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_131283 (h0 : Prop) (h1 : fin has_zero.zero) : list.ilast' h0 (matrix.vec_empty h1) := sorry --non-trivial
lemma new_lemma_131284 (h0 : group (with_one (has_norm linarith.ineq))) : normalizer_condition (with_one (has_norm linarith.ineq)) := sorry --non-trivial
lemma new_lemma_131285 (h0 h1 : multiset (has_lt (mul_one_class to_additive.value_type))) : multiset.disjoint h0 h1 := sorry --non-trivial
lemma new_lemma_131286 (h0 : topological_space (ordered_cancel_add_comm_monoid (option (option ennreal)))) : locally_compact_space (ordered_cancel_add_comm_monoid (option (option ennreal))) := sorry --non-trivial
lemma new_lemma_131287 (h0 : function.extfun Type topological_space) : @locally_compact_space.{0} (add_group.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (add_group.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_131288 (h0 : ring (ordered_comm_ring (has_Inf name))) : rank_condition (ordered_comm_ring (has_Inf name)) := sorry --non-trivial
lemma new_lemma_131289 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @sequential_space.{1} (has_Inf.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 topological_space.{1}) (has_Inf.{1} Type))  := sorry --non-trivial
lemma new_lemma_131290 (h0 : function.extfun Type topological_space) : @preirreducible_space.{0} (left_cancel_semigroup.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (left_cancel_semigroup.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_131291 (h0 : fin has_zero.zero) : @normal_space.{1} (has_add.{1} Type) (@matrix.vec_empty.{1} (topological_space.{1} (has_add.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_131292 (h0 : topological_space (complete_lattice unsigned)) : loc_path_connected_space (complete_lattice unsigned) := sorry --non-trivial
lemma new_lemma_131293 (h0 : not (topological_space (has_top linarith.comp) -> false)) : @locally_compact_space.{0} (has_top.{0} linarith.comp) (@classical.by_contradiction'.{1} (topological_space.{0} (has_top.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_131294 (h1 : topological_space (measurable_space (semiring congr_arg_kind))) : discrete_topology (measurable_space (semiring congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_131295 (h0 : functor.add_const (topological_space (simple_graph name)) pos) : @sequential_space.{0} (simple_graph.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (simple_graph.{0} name)) pos h0)  := sorry --non-trivial
lemma new_lemma_131296 (h1 : topological_space (simple_graph char)) : path_connected_space (simple_graph char) := sorry --non-trivial
lemma new_lemma_131297 (h0 : uniform_space (semigroup (has_Inf linarith.comp))) : complete_space (semigroup (has_Inf linarith.comp)) := sorry --non-trivial
lemma new_lemma_131298 (h0 : topological_space (canonically_ordered_monoid (has_bot real))) : t1_space (canonically_ordered_monoid (has_bot real)) := sorry --non-trivial
lemma new_lemma_131299 (h0 : functor.add_const (list (boolean_algebra pos)) linarith.comp) : palindrome (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_131300 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @preconnected_space.{0} (monoid.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (monoid.{0} empty))  := sorry --non-trivial
lemma new_lemma_131301 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @normal_space.{0} (finset.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (finset.{0} pos))  := sorry --non-trivial
lemma new_lemma_131302 (h0 : add_group (has_nndist (comm_group name))) : is_add_cyclic (has_nndist (comm_group name)) := sorry --non-trivial
lemma new_lemma_131303 (h0 : ordered_comm_monoid (add_cancel_monoid (has_neg name))) : has_exists_mul_of_le (add_cancel_monoid (has_neg name)) := sorry --non-trivial
lemma new_lemma_131304 (h0 : ring (has_norm (has_top to_additive.value_type))) : is_domain (has_norm (has_top to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_131305 (h0 : functor.add_const (semiring (finset name)) Type) : @is_noetherian_ring.{0} (finset.{0} name) (@functor.add_const.run.{0 1} (semiring.{0} (finset.{0} name)) Type h0)  := sorry --non-trivial
lemma new_lemma_131306 (h0 : functor.add_const (ordered_comm_monoid (generalized_boolean_algebra name)) pos) : @has_exists_mul_of_le.{0} (generalized_boolean_algebra.{0} name) (@functor.add_const.run.{0 0} (ordered_comm_monoid.{0} (generalized_boolean_algebra.{0} name)) pos h0)  := sorry --non-trivial
lemma new_lemma_131307 (h0 : topological_space (has_norm linarith.ineq)) : locally_compact_space (has_norm linarith.ineq) := sorry --non-trivial
lemma new_lemma_131308 (h0 : topological_space (has_to_string (finset Type))) : topological_space.separable_space (has_to_string (finset Type)) := sorry --non-trivial
lemma new_lemma_131309 (h0 : not (group (with_bot num) -> false)) : @group.fg.{0} (with_bot.{0} num) (@classical.by_contradiction'.{1} (group.{0} (with_bot.{0} num)) h0)  := sorry --non-trivial
lemma new_lemma_131310 (h0 : function.extfun Type topological_space) : @topological_space.separable_space.{0} (monoid.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (monoid.{0} num))  := sorry --non-trivial
lemma new_lemma_131311 (h0 : function.extfun Type topological_space) : @topological_space.separable_space.{0} (normed_comm_ring.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (normed_comm_ring.{0} pos))  := sorry --non-trivial
lemma new_lemma_131312 (h1 : function.extfun (Type -> Type) (function.extfun Type)) : list.nodup (function.extfun_app (function.extfun_app h1 list) (has_emptyc linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_131313 (h0 : topological_space (has_ssubset enat)) : t0_space (has_ssubset enat) := sorry --non-trivial
lemma new_lemma_131314 (h0 : functor.comp topological_space semigroup (normed_comm_ring name)) : @path_connected_space.{0} (semigroup.{0} (normed_comm_ring.{0} name)) (@functor.comp.run.{0 0 0} topological_space.{0} semigroup.{0} (normed_comm_ring.{0} name) h0)  := sorry --non-trivial
lemma new_lemma_131315 (h0 : topological_space (has_nndist (has_add name))) : t0_space (has_nndist (has_add name)) := sorry --non-trivial
lemma new_lemma_131316 (h0 : topological_space (left_cancel_semigroup unsigned)) : path_connected_space (left_cancel_semigroup unsigned) := sorry --non-trivial
lemma new_lemma_131317 (h0 : function.extfun Type ring) : @strong_rank_condition.{0} (has_norm.{0} fun_info) (@function.extfun_app.{2 1} Type ring.{0} h0 (has_norm.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_131318 (h0 : semiring (boolean_algebra (has_neg (finset Type)))) : is_noetherian_ring (boolean_algebra (has_neg (finset Type))) := sorry --non-trivial
lemma new_lemma_131319 (h0 : topological_space (boolean_algebra (finset (has_neg Type)))) : t1_space (boolean_algebra (finset (has_neg Type))) := sorry --non-trivial
lemma new_lemma_131320 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @strong_rank_condition.{0} (add_cancel_comm_monoid.{0} unsigned) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (add_cancel_comm_monoid.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_131321 (h0 : uniform_space (normed_lattice_add_comm_group pos)) : separated_space (normed_lattice_add_comm_group pos) := sorry --non-trivial
lemma new_lemma_131322 (h0 : filter (finset (finset (has_to_string linarith.comp)))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_131323 (h0 : functor.add_const Prop (measurable_space name)) : functor.add_const.run h0 := sorry --non-trivial
lemma new_lemma_131324 (h0 h1 : multiset (has_ssubset fun_info)) : multiset.subset h0 h1 := sorry --non-trivial
lemma new_lemma_131325 (h0 : not (topological_space (has_nnnorm linarith.comp_source) -> false)) : @path_connected_space.{0} (has_nnnorm.{0} linarith.comp_source) (@classical.by_contradiction'.{1} (topological_space.{0} (has_nnnorm.{0} linarith.comp_source)) h0)  := sorry --non-trivial
lemma new_lemma_131326 (h0 : list (simple_graph (has_add pos))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_131327 (h0 : group (distrib_lattice char)) : group.fg (distrib_lattice char) := sorry --non-trivial
lemma new_lemma_131328 (h0 : functor.add_const (add_group (finset num)) empty) : @is_add_cyclic.{0} (finset.{0} num) (@functor.add_const.run.{0 0} (add_group.{0} (finset.{0} num)) empty h0)  := sorry --non-trivial
lemma new_lemma_131329 (h0 : filter (dlist (random_gen (comm_ring fun_info)))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_131330 (h0 : ring (ordered_cancel_add_comm_monoid (option (option (option empty))))) : is_principal_ideal_ring (ordered_cancel_add_comm_monoid (option (option (option empty)))) := sorry --non-trivial
lemma new_lemma_131331 (h0 : function.extfun nat fin) : @preconnected_space.{1} (sub_neg_monoid.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@matrix.vec_empty.{2} (function.extfun.{3 2} (Type 1) topological_space.{1}) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero))) (sub_neg_monoid.{1} Type))  := sorry --non-trivial
lemma new_lemma_131332 (h0 : functor.add_const (monoid (semigroup Type)) environment.implicit_infer_kind) : @monoid.fg.{1} (semigroup.{1} Type) (@functor.add_const.run.{1 0} (monoid.{1} (semigroup.{1} Type)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_131333 (h1 : group (complete_semilattice_Sup linarith.ineq)) : is_cyclic (complete_semilattice_Sup linarith.ineq) := sorry --non-trivial
lemma new_lemma_131334 (h0 : set (has_compl (mul_one_class (mul_one_class string_imp)))) : set.finite h0 := sorry --non-trivial
lemma new_lemma_131335 (h0 : functor.add_const (function.extfun Type topological_space) (has_neg Type)) : @t1_space.{0} (has_add.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type topological_space.{0}) (has_neg.{1} Type) h0) (has_add.{0} name))  := sorry --non-trivial
lemma new_lemma_131336 (h0 : set (has_compl fun_info)) : set.finite h0 := sorry --non-trivial
lemma new_lemma_131337 (h0 : function.extfun Type list) : palindrome (function.extfun_app h0 (partial_order empty)) := sorry --non-trivial
lemma new_lemma_131338 (h0 : functor.add_const (topological_space (add_cancel_monoid environment.implicit_infer_kind)) name) : @locally_compact_space.{0} (add_cancel_monoid.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (add_cancel_monoid.{0} environment.implicit_infer_kind)) name h0)  := sorry --non-trivial
lemma new_lemma_131339 (h0 : function.extfun Type topological_space) : @t1_space.{0} (canonically_linear_ordered_monoid.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (canonically_linear_ordered_monoid.{0} name))  := sorry --non-trivial
lemma new_lemma_131340 (h0 : function.extfun Type topological_space) : @totally_separated_space.{0} (linear_ordered_comm_group.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (linear_ordered_comm_group.{0} pos))  := sorry --non-trivial
lemma new_lemma_131341 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @rank_condition.{0} (normed_group.{0} linarith.ineq) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (normed_group.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_131342 (h1 : add_group (has_top to_additive.value_type)) : is_add_cyclic (has_top to_additive.value_type) := sorry --non-trivial
lemma new_lemma_131343 (h0 : functor.add_const (function.extfun Type group) Type) : @is_simple_group.{0} (mul_zero_class.{0} name) (@function.extfun_app.{2 1} Type group.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type group.{0}) Type h0) (mul_zero_class.{0} name))  := sorry --non-trivial
lemma new_lemma_131344 (h0 : topological_space (has_neg (option (option empty)))) : preirreducible_space (has_neg (option (option empty))) := sorry --non-trivial
lemma new_lemma_131345 (h2 : ring linarith.comp_source) : rank_condition linarith.comp_source := sorry --non-trivial
lemma new_lemma_131346 (h0 : functor.add_const (topological_space (has_add Type)) Type) : @t0_space.{1} (has_add.{1} Type) (@functor.add_const.run.{1 1} (topological_space.{1} (has_add.{1} Type)) Type h0)  := sorry --non-trivial
lemma new_lemma_131347 (h1 : ring (comm_ring (random_gen to_additive.value_type))) : rank_condition (comm_ring (random_gen to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_131348 (h0 : functor.add_const (topological_space (has_to_string Type)) environment.implicit_infer_kind) : @normal_space.{1} (has_to_string.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (has_to_string.{1} Type)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_131349 (h0 : topological_space (ordered_comm_monoid (generalized_boolean_algebra Type))) : discrete_topology (ordered_comm_monoid (generalized_boolean_algebra Type)) := sorry --non-trivial
lemma new_lemma_131350 (h0 : functor.comp topological_space normed_comm_ring pos) : @irreducible_space.{0} (normed_comm_ring.{0} pos) (@functor.comp.run.{0 0 0} topological_space.{0} normed_comm_ring.{0} pos h0)  := sorry --non-trivial
lemma new_lemma_131351 (h0 : topological_space (normed_group linarith.comp)) : path_connected_space (normed_group linarith.comp) := sorry --non-trivial
lemma new_lemma_131352 (h0 : filter (denumerable (has_inv fun_info))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_131353 (h0 : functor.add_const (ordered_add_comm_monoid (has_neg pos)) (has_Inf (has_Inf (finset linarith.comp)))) : @archimedean.{0} (has_neg.{0} pos) (@functor.add_const.run.{0 0} (ordered_add_comm_monoid.{0} (has_neg.{0} pos)) (has_Inf.{0} (has_Inf.{0} (finset.{0} linarith.comp))) h0)  := sorry --non-trivial
lemma new_lemma_131354 (h0 : add_monoid (bin_tree empty)) : add_monoid.fg (bin_tree empty) := sorry --non-trivial
lemma new_lemma_131355 (h1 : add_group (measurable_space string_imp)) : is_add_cyclic (measurable_space string_imp) := sorry --non-trivial
lemma new_lemma_131356 (h0 : group (has_ssubset char)) : is_cyclic (has_ssubset char) := sorry --non-trivial
lemma new_lemma_131357 (h0 : function.extfun (finset Type) (has_mem.mem (measurable_space linarith.ineq))) : @strong_rank_condition.{0} (measurable_space.{0} linarith.ineq) (@finset.pi.empty.{1 0} Type ring.{0} (measurable_space.{0} linarith.ineq) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (measurable_space.{0} linarith.ineq)) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_131358 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @totally_separated_space.{0} (ordered_cancel_add_comm_monoid.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (ordered_cancel_add_comm_monoid.{0} empty))  := sorry --non-trivial
lemma new_lemma_131359 (h0 : function.extfun (Type 1) monoid) : @monoid.fg.{1} (normed_comm_ring.{1} Type) (@function.extfun_app.{3 2} (Type 1) monoid.{1} h0 (normed_comm_ring.{1} Type))  := sorry --non-trivial
lemma new_lemma_131360 (h0 : group (has_nndist (has_Inf (has_add Type)))) : is_simple_group (has_nndist (has_Inf (has_add Type))) := sorry --non-trivial
lemma new_lemma_131361 (h0 : ring (has_nnnorm (random_gen reducibility_hints))) : rank_condition (has_nnnorm (random_gen reducibility_hints)) := sorry --non-trivial
lemma new_lemma_131362 (h1 : topological_space (normed_group fun_info)) : locally_compact_space (normed_group fun_info) := sorry --non-trivial
lemma new_lemma_131363 (h0 : topological_space (ring (ring (ring Type)))) : normal_space (ring (ring (ring Type))) := sorry --non-trivial
lemma new_lemma_131364 (h0 : not (topological_space (linear_ordered_add_comm_group to_additive.value_type) -> false)) : @path_connected_space.{0} (linear_ordered_add_comm_group.{0} to_additive.value_type) (@classical.by_contradiction'.{1} (topological_space.{0} (linear_ordered_add_comm_group.{0} to_additive.value_type)) h0)  := sorry --non-trivial
lemma new_lemma_131365 (h0 : list (has_Inf (has_neg (has_neg (has_neg (has_neg pos)))))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_131366 (h0 : topological_space (boolean_algebra real)) : normal_space (boolean_algebra real) := sorry --non-trivial
lemma new_lemma_131367 (h2 : complete_lattice (topological_space char)) : complete_lattice.is_Sup_finite_compact (topological_space char) := sorry --non-trivial
lemma new_lemma_131368 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @normal_space.{0} (boolean_algebra.core.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (boolean_algebra.core.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_131369 (h0 : functor.add_const (cancel_comm_monoid_with_zero (generalized_boolean_algebra name)) (has_nndist pos)) : @unique_factorization_monoid.{0} (generalized_boolean_algebra.{0} name) (@functor.add_const.run.{0 0} (cancel_comm_monoid_with_zero.{0} (generalized_boolean_algebra.{0} name)) (has_nndist.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_131370 (h0 : semiring (has_nndist (has_neg Type))) : is_noetherian_ring (has_nndist (has_neg Type)) := sorry --non-trivial
lemma new_lemma_131371 (h0 : topological_space (add_comm_monoid num)) : irreducible_space (add_comm_monoid num) := sorry --non-trivial
lemma new_lemma_131372 (h0 : functor.add_const (function.extfun Type add_monoid) (ring Type)) : @add_monoid.fg.{0} (finset.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type add_monoid.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type add_monoid.{0}) (ring.{1} Type) h0) (finset.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_131373 (h0 : functor.add_const (monoid (semigroup name)) pos) : @monoid.fg.{0} (semigroup.{0} name) (@functor.add_const.run.{0 0} (monoid.{0} (semigroup.{0} name)) pos h0)  := sorry --non-trivial
lemma new_lemma_131374 (h0 : prod (has_Sup unsigned) (has_Sup unsigned)) : id_rel h0 := sorry --non-trivial
lemma new_lemma_131375 (h0 : ring (bin_tree (semiring (semiring (semiring unsigned))))) : rank_condition (bin_tree (semiring (semiring (semiring unsigned)))) := sorry --non-trivial
lemma new_lemma_131376 : nonempty ordering := sorry --simp
lemma new_lemma_131377 (h0 : function.extfun (Type 1) topological_space) : @totally_disconnected_space.{1} (finset.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} h0 (finset.{1} Type))  := sorry --non-trivial
lemma new_lemma_131378 (h0 : has_mem.mem linarith.comp_source has_emptyc.emptyc) : @complete_space.{0} linarith.comp_source (@finset.pi.empty.{1 0} Type uniform_space.{0} linarith.comp_source h0)  := sorry --non-trivial
lemma new_lemma_131379 (h0 : semiring (add_comm_semigroup ereal)) (h1 : add_comm_semigroup ereal) : even h1 := sorry --non-trivial
lemma new_lemma_131380 (h1 : filter (linear_ordered_add_comm_group (random_gen (random_gen string_imp)))) : filter.ne_bot h1 := sorry --non-trivial
lemma new_lemma_131381 (h0 : functor.add_const (topological_space (monoid ennreal)) num) : @path_connected_space.{0} (monoid.{0} ennreal) (@functor.add_const.run.{0 0} (topological_space.{0} (monoid.{0} ennreal)) num h0)  := sorry --non-trivial
lemma new_lemma_131382 (h0 : functor.add_const (ring (mul_zero_class name)) name) : @rank_condition.{0} (mul_zero_class.{0} name) (@functor.add_const.run.{0 0} (ring.{0} (mul_zero_class.{0} name)) name h0)  := sorry --non-trivial
lemma new_lemma_131383 (h0 : complete_lattice (dlist (random_gen linarith.ineq))) : complete_lattice.is_Sup_finite_compact (dlist (random_gen linarith.ineq)) := sorry --non-trivial
lemma new_lemma_131384 (h0 : cancel_comm_monoid_with_zero (partial_order (has_top unsigned))) : unique_factorization_monoid (partial_order (has_top unsigned)) := sorry --non-trivial
lemma new_lemma_131385 (h0 : topological_space (add_cancel_comm_monoid empty)) : t1_space (add_cancel_comm_monoid empty) := sorry --non-trivial
lemma new_lemma_131386 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : finset.nonempty (function.extfun_app (function.extfun_app h0 finset) (sub_neg_monoid name)) := sorry --non-trivial
lemma new_lemma_131387 (h0 : functor.add_const (uniform_space (add_left_cancel_semigroup unsigned)) empty) : @complete_space.{0} (add_left_cancel_semigroup.{0} unsigned) (@functor.add_const.run.{0 0} (uniform_space.{0} (add_left_cancel_semigroup.{0} unsigned)) empty h0)  := sorry --non-trivial
lemma new_lemma_131388 (h0 : complete_lattice (has_one (has_top unsigned))) : is_compactly_generated (has_one (has_top unsigned)) := sorry --non-trivial
lemma new_lemma_131389 (h0 : not (has_mem.mem (has_top linarith.comp_source) has_emptyc.emptyc -> false)) : @strong_rank_condition.{0} (has_top.{0} linarith.comp_source) (@finset.pi.empty.{1 0} Type ring.{0} (has_top.{0} linarith.comp_source) (@classical.by_contradiction'.{0} (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (has_top.{0} linarith.comp_source) (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))) h0))  := sorry --non-trivial
lemma new_lemma_131390 (h0 : complete_lattice (has_neg (has_add linarith.comp))) : complete_lattice.is_Sup_finite_compact (has_neg (has_add linarith.comp)) := sorry --non-trivial
lemma new_lemma_131391 (h0 : list (list Prop)) : list.head (list.head (id h0)) := sorry --non-trivial
lemma new_lemma_131392 (h0 : not (function.extfun Type uniform_space -> false)) : @complete_space.{0} (semiring.{0} unsigned) (@function.extfun_app.{2 1} Type uniform_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type uniform_space.{0}) h0) (semiring.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_131393 (h0 : functor.add_const (ordered_add_comm_monoid (comm_group pos)) unsigned) : @archimedean.{0} (comm_group.{0} pos) (@functor.add_const.run.{0 0} (ordered_add_comm_monoid.{0} (comm_group.{0} pos)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_131394 (h0 : functor.add_const (function.extfun Type topological_space) pos) : @topological_space.separable_space.{0} (has_nndist.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) pos h0) (has_nndist.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_131395 (h0 : monoid (measure_theory.measure_space linarith.comp)) : monoid.fg (measure_theory.measure_space linarith.comp) := sorry --non-trivial
lemma new_lemma_131396 (h0 : functor.add_const (ordered_add_comm_monoid (is_R_or_C empty)) (option empty)) : @archimedean.{0} (is_R_or_C.{0} empty) (@functor.add_const.run.{0 0} (ordered_add_comm_monoid.{0} (is_R_or_C.{0} empty)) (option.{0} empty) h0)  := sorry --non-trivial
lemma new_lemma_131397 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @group.fg.{0} (mul_zero_class.{0} name) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (mul_zero_class.{0} name))  := sorry --non-trivial
lemma new_lemma_131398 (h0 : filter (preorder (semiring (semiring unsigned)))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_131399 (h0 : function.extfun Type topological_space) : @preirreducible_space.{0} (finset.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (finset.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_131400 (h0 : topological_space (comm_ring string_imp)) : path_connected_space (comm_ring string_imp) := sorry --non-trivial
lemma new_lemma_131401 (h0 : monoid (ring (boolean_algebra.core unsigned))) : monoid.fg (ring (boolean_algebra.core unsigned)) := sorry --non-trivial
lemma new_lemma_131402 (h0 : not (add_monoid (plift empty) -> false)) : @add_monoid.fg.{1} (plift.{1} empty) (@classical.by_contradiction'.{2} (add_monoid.{1} (plift.{1} empty)) h0)  := sorry --non-trivial
lemma new_lemma_131403 (h0 : function.extfun Type cancel_comm_monoid_with_zero) : @unique_factorization_monoid.{0} (add_cancel_monoid.{0} pos) (@function.extfun_app.{2 1} Type cancel_comm_monoid_with_zero.{0} h0 (add_cancel_monoid.{0} pos))  := sorry --non-trivial
lemma new_lemma_131404 (h0 : functor.add_const (topological_space (add_semigroup empty)) empty) : @discrete_topology.{0} (add_semigroup.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (add_semigroup.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_131405 (h0 : uniform_space (has_add (option (option num)))) : separated_space (has_add (option (option num))) := sorry --non-trivial
lemma new_lemma_131406 (h0 : topological_space (non_unital_non_assoc_semiring linarith.comp_source)) : t0_space (non_unital_non_assoc_semiring linarith.comp_source) := sorry --non-trivial
lemma new_lemma_131407 (h0 : complete_lattice (has_zero (has_Inf Type))) : is_compactly_generated (has_zero (has_Inf Type)) := sorry --non-trivial
lemma new_lemma_131408 (h0 : topological_space (add_cancel_monoid environment.implicit_infer_kind)) : preconnected_space (add_cancel_monoid environment.implicit_infer_kind) := sorry --non-trivial
lemma new_lemma_131409 (h0 : ring (has_pos_part Type)) : is_domain (has_pos_part Type) := sorry --non-trivial
lemma new_lemma_131410 (h0 : topological_space (has_append (comm_ring char))) : t0_space (has_append (comm_ring char)) := sorry --non-trivial
lemma new_lemma_131411 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @locally_compact_space.{0} (has_inv.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_inv.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_131412 (h0 : function.extfun Type ordered_add_comm_monoid) : @archimedean.{0} (complete_distrib_lattice.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type ordered_add_comm_monoid.{0} h0 (complete_distrib_lattice.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_131413 (h0 : add_group (boolean_algebra.core (has_neg (has_neg name)))) : is_add_cyclic (boolean_algebra.core (has_neg (has_neg name))) := sorry --non-trivial
lemma new_lemma_131414 (h1 : topological_space (has_emptyc (random_gen linarith.ineq))) : t0_space (has_emptyc (random_gen linarith.ineq)) := sorry --non-trivial
lemma new_lemma_131415 (h0 : function.extfun Type topological_space) : @totally_disconnected_space.{0} (linear_ordered_add_comm_group.{0} fun_info) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (linear_ordered_add_comm_group.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_131416 (h0 : topological_space (add_group empty)) : locally_compact_space (add_group empty) := sorry --non-trivial
lemma new_lemma_131417 (h0 : topological_space (mul_zero_class (mul_zero_class (option ennreal)))) : t0_space (mul_zero_class (mul_zero_class (option ennreal))) := sorry --non-trivial
lemma new_lemma_131418 (h0 : has_mem.mem linarith.comp has_emptyc.emptyc) : @is_domain.{0} linarith.comp (@finset.pi.empty.{1 0} Type ring.{0} linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_131419 (h0 : semiring (complete_linear_order (has_top empty))) : is_noetherian_ring (complete_linear_order (has_top empty)) := sorry --non-trivial
lemma new_lemma_131420 (h0 : topological_space (as_linear_order congr_arg_kind)) : path_connected_space (as_linear_order congr_arg_kind) := sorry --non-trivial
lemma new_lemma_131421 (h0 : functor.add_const (topological_space (has_nndist unsigned)) (option unsigned)) : @normal_space.{0} (has_nndist.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (has_nndist.{0} unsigned)) (option.{0} unsigned) h0)  := sorry --non-trivial
lemma new_lemma_131422 (h0 : function.extfun nat fin) : @path_connected_space.{0} (ordered_comm_monoid.{0} linarith.comp) (@matrix.vec_empty.{0} (topological_space.{0} (ordered_comm_monoid.{0} linarith.comp)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_131423 (h0 : topological_space (has_norm (semiring (semiring congr_arg_kind)))) : preirreducible_space (has_norm (semiring (semiring congr_arg_kind))) := sorry --non-trivial
lemma new_lemma_131424 (h0 : not (topological_space (add_group num) -> false)) : @totally_separated_space.{0} (add_group.{0} num) (@classical.by_contradiction'.{1} (topological_space.{0} (add_group.{0} num)) h0)  := sorry --non-trivial
lemma new_lemma_131425 (h0 : functor.add_const (group (has_bot unsigned)) empty) : @is_cyclic.{0} (has_bot.{0} unsigned) (@functor.add_const.run.{0 0} (group.{0} (has_bot.{0} unsigned)) empty h0)  := sorry --non-trivial
lemma new_lemma_131426 (h0 : function.extfun Type ring) : @is_domain.{0} (canonically_ordered_comm_semiring.{0} pos) (@function.extfun_app.{2 1} Type ring.{0} h0 (canonically_ordered_comm_semiring.{0} pos))  := sorry --non-trivial
lemma new_lemma_131427 (h0 : topological_space (canonically_linear_ordered_monoid (option (cancel_monoid (has_add name))))) : regular_space (canonically_linear_ordered_monoid (option (cancel_monoid (has_add name)))) := sorry --non-trivial
lemma new_lemma_131428 (h0 : ring (random_gen name)) : strong_rank_condition (random_gen name) := sorry --non-trivial
lemma new_lemma_131429 (h0 : ring (has_inner empty num)) : is_principal_ideal_ring (has_inner empty num) := sorry --non-trivial
lemma new_lemma_131430 (h0 : uniform_space (has_bot (has_neg Type))) : complete_space (has_bot (has_neg Type)) := sorry --non-trivial
lemma new_lemma_131431 (h0 : functor.add_const (function.extfun nat fin) (has_Inf (has_add Type))) : @is_atomistic.{1} (normed_lattice_add_comm_group.{1} Type) (@matrix.vec_empty.{1} (complete_lattice.{1} (normed_lattice_add_comm_group.{1} Type)) (@function.extfun_app.{1 1} nat fin (@functor.add_const.run.{0 1} (function.extfun.{1 1} nat fin) (has_Inf.{1} (has_add.{1} Type)) h0) (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_131432 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_add_cyclic.{0} (has_sub.{0} unsigned) (@function.extfun_app.{2 1} Type add_group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 add_group.{0}) (has_sub.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_131433 (h0 : group (linear_ordered_semiring linarith.ineq)) : normalizer_condition (linear_ordered_semiring linarith.ineq) := sorry --non-trivial
lemma new_lemma_131434 (h0 : list (bin_tree unsigned)) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_131435 (h0 : function.extfun Type (functor.add_const (ring ennreal))) : @is_principal_ideal_ring.{0} ennreal (@functor.add_const.run.{0 0} (ring.{0} ennreal) num (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (ring.{0} ennreal)) h0 num))  := sorry --non-trivial
lemma new_lemma_131436 (h0 : topological_space (semigroup (option (option (option (option empty)))))) : normal_space (semigroup (option (option (option (option empty))))) := sorry --non-trivial
lemma new_lemma_131437 (h0 : complete_lattice (canonically_linear_ordered_monoid (has_add pos))) : complete_lattice.is_Sup_finite_compact (canonically_linear_ordered_monoid (has_add pos)) := sorry --non-trivial
lemma new_lemma_131438 (h0 : not (add_group (option unsigned) -> false)) : @is_add_cyclic.{0} (option.{0} unsigned) (@classical.by_contradiction'.{1} (add_group.{0} (option.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_131439 (h0 : functor.comp topological_space has_nndist name) : @loc_path_connected_space.{0} (has_nndist.{0} name) (@functor.comp.run.{0 0 0} topological_space.{0} has_nndist.{0} name h0)  := sorry --non-trivial
lemma new_lemma_131440 (h0 : complete_lattice (add_cancel_comm_monoid string_imp)) : complete_lattice.is_Sup_finite_compact (add_cancel_comm_monoid string_imp) := sorry --non-trivial
lemma new_lemma_131441 (h0 : ring (fintype (random_gen string_imp))) : strong_rank_condition (fintype (random_gen string_imp)) := sorry --non-trivial
lemma new_lemma_131442 (h0 : has_mem.mem fun_info has_emptyc.emptyc) : @totally_separated_space.{0} fun_info (@finset.pi.empty.{1 0} Type topological_space.{0} fun_info h0)  := sorry --non-trivial
lemma new_lemma_131443 (h0 : complete_lattice (with_one (with_bot to_additive.value_type))) : is_atomistic (with_one (with_bot to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_131444 (h0 : not (function.extfun Type complete_lattice -> false)) : @complete_lattice.is_Sup_finite_compact.{0} (left_cancel_semigroup.{0} unsigned) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type complete_lattice.{0}) h0) (left_cancel_semigroup.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_131445 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_domain.{0} (linear_ordered_comm_ring.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (linear_ordered_comm_ring.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_131446 (h0 : functor.add_const (filter (partial_order empty)) num) : filter.ne_bot (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_131447 (h0 : functor.add_const (ring (cancel_monoid environment.implicit_infer_kind)) linarith.comp) : @is_domain.{0} (cancel_monoid.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (ring.{0} (cancel_monoid.{0} environment.implicit_infer_kind)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_131448 (h1 : function.extfun (finset (Type -> Type)) (has_mem.mem ring)) : @strong_rank_condition.{0} empty (@function.extfun_app.{2 1} Type ring.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) ring.{0} (@function.extfun_app.{2 0} (finset.{1} (Type → Type)) (@has_mem.mem.{1 1} (Type → Type) (finset.{1} (Type → Type)) (@finset.has_mem.{1} (Type → Type)) ring.{0}) h1 (@has_emptyc.emptyc.{1} (finset.{1} (Type → Type)) (@finset.has_emptyc.{1} (Type → Type))))) empty)  := sorry --non-trivial
lemma new_lemma_131449 (h0 : function.extfun Type topological_space) : @t1_space.{0} name (@function.extfun_app.{2 1} Type topological_space.{0} h0 name)  := sorry --non-trivial
lemma new_lemma_131450 (h0 : group (complete_distrib_lattice (has_Inf (has_Inf pos)))) : group.fg (complete_distrib_lattice (has_Inf (has_Inf pos))) := sorry --non-trivial
lemma new_lemma_131451 (h0 : list (boolean_algebra (finset pos))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_131452 (h0 : group (ordered_comm_ring (has_Inf (finset (has_add (has_add pos)))))) : is_cyclic (ordered_comm_ring (has_Inf (finset (has_add (has_add pos))))) := sorry --non-trivial
lemma new_lemma_131453 (h0 : functor.add_const (topological_space (normed_comm_ring pos)) linarith.comp) : @regular_space.{0} (normed_comm_ring.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (normed_comm_ring.{0} pos)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_131454 (h0 : functor.add_const (topological_space znum) unsigned) : @totally_separated_space.{0} znum (@functor.add_const.run.{0 0} (topological_space.{0} znum) unsigned h0)  := sorry --non-trivial
lemma new_lemma_131455 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_noetherian_ring.{0} (mul_zero_class.{0} name) (@function.extfun_app.{2 1} Type semiring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 semiring.{0}) (mul_zero_class.{0} name))  := sorry --non-trivial
lemma new_lemma_131456 (h0 : function.extfun Type (functor.add_const (topological_space (ordered_comm_group empty)))) : @discrete_topology.{0} (ordered_comm_group.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (ordered_comm_group.{0} empty)) empty (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (topological_space.{0} (ordered_comm_group.{0} empty))) h0 empty))  := sorry --non-trivial
lemma new_lemma_131457 (h0 : functor.add_const (ordered_comm_monoid (semigroup linarith.comp)) (mul_one_class environment.implicit_infer_kind)) : @has_exists_mul_of_le.{0} (semigroup.{0} linarith.comp) (@functor.add_const.run.{0 0} (ordered_comm_monoid.{0} (semigroup.{0} linarith.comp)) (mul_one_class.{0} environment.implicit_infer_kind) h0)  := sorry --non-trivial
lemma new_lemma_131458 (h0 : functor.add_const (topological_space (ring pos)) Type) : @preconnected_space.{0} (ring.{0} pos) (@functor.add_const.run.{0 1} (topological_space.{0} (ring.{0} pos)) Type h0)  := sorry --non-trivial
lemma new_lemma_131459 (h0 : functor.add_const (uniform_space (has_bot empty)) empty) : @complete_space.{0} (has_bot.{0} empty) (@functor.add_const.run.{0 0} (uniform_space.{0} (has_bot.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_131460 (h0 : function.extfun Type (functor.add_const (ring auto.case_option))) : @rank_condition.{0} auto.case_option (@functor.add_const.run.{0 0} (ring.{0} auto.case_option) unsigned (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (ring.{0} auto.case_option)) h0 unsigned))  := sorry --non-trivial
lemma new_lemma_131461 (h0 : topological_space (generalized_boolean_algebra (has_Inf (comm_semigroup Type)))) : regular_space (generalized_boolean_algebra (has_Inf (comm_semigroup Type))) := sorry --non-trivial
lemma new_lemma_131462 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @t1_space.{0} (group_with_zero.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (group_with_zero.{0} num))  := sorry --non-trivial
lemma new_lemma_131463 (h0 : functor.add_const (semiring (has_add unsigned)) pos) : @is_noetherian_ring.{0} (has_add.{0} unsigned) (@functor.add_const.run.{0 0} (semiring.{0} (has_add.{0} unsigned)) pos h0)  := sorry --non-trivial
lemma new_lemma_131464 (h0 : function.extfun Type topological_space) : @totally_separated_space.{0} (omega_complete_partial_order.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (omega_complete_partial_order.{0} empty))  := sorry --non-trivial
lemma new_lemma_131465 (h0 : topological_space (has_Inf (finset (has_add linarith.comp)))) : locally_compact_space (has_Inf (finset (has_add linarith.comp))) := sorry --non-trivial
lemma new_lemma_131466 (h0 : group (normed_group char)) : is_cyclic (normed_group char) := sorry --non-trivial
lemma new_lemma_131467 (h0 : functor.add_const (monoid (semigroup empty)) empty) : @monoid.fg.{0} (semigroup.{0} empty) (@functor.add_const.run.{0 0} (monoid.{0} (semigroup.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_131468 (h0 : ring (semi_normed_ring fun_info)) : strong_rank_condition (semi_normed_ring fun_info) := sorry --non-trivial
lemma new_lemma_131469 (h1 : topological_space (with_bot fun_info)) : totally_disconnected_space (with_bot fun_info) := sorry --non-trivial
lemma new_lemma_131470 (h0 : functor.add_const (ring (semiring unsigned)) unsigned) : @rank_condition.{0} (semiring.{0} unsigned) (@functor.add_const.run.{0 0} (ring.{0} (semiring.{0} unsigned)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_131471 (h0 : functor.add_const (topological_space (boolean_algebra environment.implicit_infer_kind)) linarith.comp) : @topological_space.separable_space.{0} (boolean_algebra.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (boolean_algebra.{0} environment.implicit_infer_kind)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_131472 (h0 : function.extfun Type ordered_add_comm_monoid) : @archimedean.{0} (add_cancel_monoid.{0} empty) (@function.extfun_app.{2 1} Type ordered_add_comm_monoid.{0} h0 (add_cancel_monoid.{0} empty))  := sorry --non-trivial
lemma new_lemma_131473 (h0 h1 : multiset (simple_graph environment.projection_info)) : multiset.disjoint h0 h1 := sorry --non-trivial
lemma new_lemma_131474 (h0 : functor.add_const (group (has_nndist linarith.comp)) (has_pos_part (finset linarith.comp))) : @normalizer_condition.{0} (has_nndist.{0} linarith.comp) (@functor.add_const.run.{0 0} (group.{0} (has_nndist.{0} linarith.comp)) (has_pos_part.{0} (finset.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_131475 (h0 : group (plift (semiring (semiring congr_arg_kind)))) : group.fg (plift (semiring (semiring congr_arg_kind))) := sorry --non-trivial
lemma new_lemma_131476 (h0 : filter (finset (ring linarith.comp))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_131477 (h0 : topological_space (has_to_string (option (option ennreal)))) : irreducible_space (has_to_string (option (option ennreal))) := sorry --non-trivial
lemma new_lemma_131478 (h0 : function.extfun Type topological_space) : @normal_space.{0} (mul_zero_class.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (mul_zero_class.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_131479 (h0 : functor.add_const (function.extfun (Type 1) cancel_comm_monoid_with_zero) linarith.comp) : @unique_factorization_monoid.{1} (semigroup.{1} Type) (@function.extfun_app.{3 2} (Type 1) cancel_comm_monoid_with_zero.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) cancel_comm_monoid_with_zero.{1}) linarith.comp h0) (semigroup.{1} Type))  := sorry --non-trivial
lemma new_lemma_131480 (h0 : group (random_gen (with_bot to_additive.value_type))) : normalizer_condition (random_gen (with_bot to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_131481 (h0 : fin has_zero.zero) : @totally_separated_space.{0} (generalized_boolean_algebra.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} (@matrix.vec_empty.{1} (function.extfun.{2 1} Type topological_space.{0}) h0) (generalized_boolean_algebra.{0} name))  := sorry --non-trivial
lemma new_lemma_131482 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_principal_ideal_ring.{0} (add_left_cancel_semigroup.{0} empty) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (add_left_cancel_semigroup.{0} empty))  := sorry --non-trivial
lemma new_lemma_131483 (h0 : not (add_group (distrib_lattice linarith.comp_source) -> false)) : @is_add_cyclic.{0} (distrib_lattice.{0} linarith.comp_source) (@classical.by_contradiction'.{1} (add_group.{0} (distrib_lattice.{0} linarith.comp_source)) h0)  := sorry --non-trivial
lemma new_lemma_131484 (h0 : list (add_left_cancel_semigroup empty)) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_131485 (h0 : not (add_group (has_ssubset linarith.comp_source) -> false)) : @is_add_cyclic.{0} (has_ssubset.{0} linarith.comp_source) (@classical.by_contradiction'.{1} (add_group.{0} (has_ssubset.{0} linarith.comp_source)) h0)  := sorry --non-trivial
lemma new_lemma_131486 (h0 : group (group_with_zero num)) : is_simple_group (group_with_zero num) := sorry --non-trivial
lemma new_lemma_131487 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : palindrome (function.extfun_app (function.extfun_app h0 list) (omega_complete_partial_order empty)) := sorry --non-trivial
lemma new_lemma_131488 (h0 : functor.add_const (function.extfun (Type 1) group) (finset pos)) : @normalizer_condition.{1} (has_nndist.{1} Type) (@function.extfun_app.{3 2} (Type 1) group.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) group.{1}) (finset.{0} pos) h0) (has_nndist.{1} Type))  := sorry --non-trivial
lemma new_lemma_131489 (h0 : function.extfun (finset Type) (has_mem.mem (has_one empty))) : @discrete_topology.{0} (has_one.{0} empty) (@finset.pi.empty.{1 0} Type topological_space.{0} (has_one.{0} empty) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (has_one.{0} empty)) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_131490 (h0 : add_group (add_comm_semigroup reducibility_hints)) : is_add_cyclic (add_comm_semigroup reducibility_hints) := sorry --non-trivial
lemma new_lemma_131491 (h0 : topological_space (has_Inf (has_Inf Type))) : preconnected_space (has_Inf (has_Inf Type)) := sorry --non-trivial
lemma new_lemma_131492 (h0 : functor.add_const (function.extfun Type topological_space) Type) : @topological_space.separable_space.{0} (semigroup.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type topological_space.{0}) Type h0) (semigroup.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_131493 (h0 : functor.add_const (add_monoid (has_to_string unsigned)) (option (option (option unsigned)))) : @add_monoid.fg.{0} (has_to_string.{0} unsigned) (@functor.add_const.run.{0 0} (add_monoid.{0} (has_to_string.{0} unsigned)) (option.{0} (option.{0} (option.{0} unsigned))) h0)  := sorry --non-trivial
lemma new_lemma_131494 (h0 : group (has_nnnorm (has_nnnorm (random_gen linarith.ineq)))) : is_cyclic (has_nnnorm (has_nnnorm (random_gen linarith.ineq))) := sorry --non-trivial
lemma new_lemma_131495 (h0 : not (topological_space (dlist to_additive.value_type) -> false)) : @t0_space.{0} (dlist.{0} to_additive.value_type) (@classical.by_contradiction'.{1} (topological_space.{0} (dlist.{0} to_additive.value_type)) h0)  := sorry --non-trivial
lemma new_lemma_131496 (h0 : functor.add_const (topological_space (measurable_space name)) Type) : @topological_space.separable_space.{0} (measurable_space.{0} name) (@functor.add_const.run.{0 1} (topological_space.{0} (measurable_space.{0} name)) Type h0)  := sorry --non-trivial
lemma new_lemma_131497 (h0 : fin has_zero.zero) : @group.fg.{0} (canonically_ordered_monoid.{0} pos) (@matrix.vec_empty.{0} (group.{0} (canonically_ordered_monoid.{0} pos)) h0)  := sorry --non-trivial
lemma new_lemma_131498 (h0 : functor.add_const (topological_space (canonically_ordered_comm_semiring unsigned)) pos) : @t0_space.{0} (canonically_ordered_comm_semiring.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (canonically_ordered_comm_semiring.{0} unsigned)) pos h0)  := sorry --non-trivial
lemma new_lemma_131499 (h1 : partial_order (uniform_space (add_cancel_comm_monoid char))) (h2 : order_top (uniform_space (add_cancel_comm_monoid char))) : is_coatomic (uniform_space (add_cancel_comm_monoid char)) := sorry --non-trivial
lemma new_lemma_131500 (h1 : complete_lattice (topological_space linarith.ineq)) : is_compactly_generated (topological_space linarith.ineq) := sorry --non-trivial
lemma new_lemma_131501 (h0 : topological_space (has_bot linarith.comp)) : sequential_space (has_bot linarith.comp) := sorry --non-trivial
lemma new_lemma_131502 (h0 : functor.add_const (monoid (complete_distrib_lattice Type)) Type) : @monoid.fg.{1} (complete_distrib_lattice.{1} Type) (@functor.add_const.run.{1 1} (monoid.{1} (complete_distrib_lattice.{1} Type)) Type h0)  := sorry --non-trivial
lemma new_lemma_131503 (h0 : group (has_neg_part (option (has_neg_part name)))) : group.fg (has_neg_part (option (has_neg_part name))) := sorry --non-trivial
lemma new_lemma_131504 (h0 : topological_space (has_nndist (finset environment.implicit_infer_kind))) : locally_compact_space (has_nndist (finset environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_131505 (h0 : group (random_gen (semiring empty))) : is_cyclic (random_gen (semiring empty)) := sorry --non-trivial
lemma new_lemma_131506 (h0 : topological_space (metric_space (semiring linarith.comp))) : totally_separated_space (metric_space (semiring linarith.comp)) := sorry --non-trivial
lemma new_lemma_131507 (h0 : monoid (with_one (has_inv to_additive.value_type))) : monoid.fg (with_one (has_inv to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_131508 (h0 : functor.add_const (list (semigroup linarith.comp)) environment.implicit_infer_kind) : palindrome (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_131509 (h0 : function.extfun Type (functor.add_const (functor.add_const (complete_lattice (partial_order empty)) empty))) : @is_atomistic.{0} (partial_order.{0} empty) (@functor.add_const.run.{0 0} (complete_lattice.{0} (partial_order.{0} empty)) empty (@functor.add_const.run.{0 0} (functor.add_const.{0 0} (complete_lattice.{0} (partial_order.{0} empty)) empty) empty (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (functor.add_const.{0 0} (complete_lattice.{0} (partial_order.{0} empty)) empty)) h0 empty)))  := sorry --non-trivial
lemma new_lemma_131510 (h0 : functor.add_const (ordered_comm_monoid (has_pos_part pos)) Type) : @has_exists_mul_of_le.{0} (has_pos_part.{0} pos) (@functor.add_const.run.{0 1} (ordered_comm_monoid.{0} (has_pos_part.{0} pos)) Type h0)  := sorry --non-trivial
lemma new_lemma_131511 (h0 : function.extfun nat fin) : @archimedean.{0} (finset.{0} pos) (@matrix.vec_empty.{0} (ordered_add_comm_monoid.{0} (finset.{0} pos)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_131512 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_compactly_generated.{0} (canonically_ordered_comm_semiring.{0} unsigned) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (canonically_ordered_comm_semiring.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_131513 (h1 : set (add_comm_semigroup char)) : set.finite h1 := sorry --non-trivial
lemma new_lemma_131514 (h0 : not (ring (add_group linarith.comp_source) -> false)) : @strong_rank_condition.{0} (add_group.{0} linarith.comp_source) (@classical.by_contradiction'.{1} (ring.{0} (add_group.{0} linarith.comp_source)) h0)  := sorry --non-trivial
lemma new_lemma_131515 (h0 : function.extfun (Type 1) complete_lattice) : @complete_lattice.is_Sup_finite_compact.{1} (add_cancel_monoid.{1} Type) (@function.extfun_app.{3 2} (Type 1) complete_lattice.{1} h0 (add_cancel_monoid.{1} Type))  := sorry --non-trivial
lemma new_lemma_131516 (h0 : functor.add_const (topological_space (left_cancel_monoid congr_arg_kind)) unsigned) : @discrete_topology.{0} (left_cancel_monoid.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (left_cancel_monoid.{0} congr_arg_kind)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_131517 (h1 : has_le to_additive.value_type -> linarith.ineq) (h2 : topological_space linarith.ineq) : @totally_disconnected_space.{0} (has_le.{0} to_additive.value_type) (@topological_space.induced.{0 0} (has_le.{0} to_additive.value_type) linarith.ineq h1 h2)  := sorry --non-trivial
lemma new_lemma_131518 (h0 : option Prop) (h1 : coe_sort (option.is_some h0)) : option.get h1 := sorry --non-trivial
lemma new_lemma_131519 (h0 : ring (comm_group (finset Type))) : is_principal_ideal_ring (comm_group (finset Type)) := sorry --non-trivial
lemma new_lemma_131520 (h0 : topological_space (add_cancel_monoid (add_cancel_monoid pos))) : path_connected_space (add_cancel_monoid (add_cancel_monoid pos)) := sorry --non-trivial
lemma new_lemma_131521 (h0 : not (uniform_space (with_one num) -> false)) : @separated_space.{0} (with_one.{0} num) (@classical.by_contradiction'.{1} (uniform_space.{0} (with_one.{0} num)) h0)  := sorry --non-trivial
lemma new_lemma_131522 (h0 : list (linear_ordered_field name)) : palindrome h0 := sorry --non-trivial
lemma new_lemma_131523 (h0 : has_lt (has_ssubset environment.projection_info)) : no_max_order (has_ssubset environment.projection_info) := sorry --non-trivial
lemma new_lemma_131524 (h0 : complete_lattice (linear_ordered_semiring linarith.comp)) : complete_lattice.is_Sup_finite_compact (linear_ordered_semiring linarith.comp) := sorry --non-trivial
lemma new_lemma_131525 (h0 : functor.add_const (topological_space (has_neg linarith.comp)) (finset pos)) : @normal_space.{0} (has_neg.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (has_neg.{0} linarith.comp)) (finset.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_131526 (h1 : not (complete_lattice (random_gen fun_info) -> false)) : @complete_lattice.is_Sup_finite_compact.{0} (random_gen.{0} fun_info) (@classical.by_contradiction'.{1} (complete_lattice.{0} (random_gen.{0} fun_info)) h1)  := sorry --non-trivial
lemma new_lemma_131527 (h0 : group (sub_neg_monoid (has_pos_part (has_pos_part (has_Inf linarith.comp))))) : normalizer_condition (sub_neg_monoid (has_pos_part (has_pos_part (has_Inf linarith.comp)))) := sorry --non-trivial
lemma new_lemma_131528 (h0 : complete_lattice (add_cancel_monoid (option (option ennreal)))) : complete_lattice.is_Sup_finite_compact (add_cancel_monoid (option (option ennreal))) := sorry --non-trivial
lemma new_lemma_131529 (h0 : topological_space (has_neg Type)) : regular_space (has_neg Type) := sorry --non-trivial
lemma new_lemma_131530 (h0 : is_empty (has_compl string.iterator_imp)) : set.finite (is_empty.elim' h0) := sorry --non-trivial
lemma new_lemma_131531 (h0 : topological_space (canonically_linear_ordered_monoid (sub_neg_monoid (has_bot Type)))) : irreducible_space (canonically_linear_ordered_monoid (sub_neg_monoid (has_bot Type))) := sorry --non-trivial
lemma new_lemma_131532 (h0 : functor.add_const (topological_space (add_cancel_monoid name)) linarith.comp) : @path_connected_space.{0} (add_cancel_monoid.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (add_cancel_monoid.{0} name)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_131533 (h0 : topological_space (random_gen (has_top linarith.comp_source))) : locally_compact_space (random_gen (has_top linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_131534 (h0 : not (function.extfun Type semiring -> false)) : @is_noetherian_ring.{0} (add_group.{0} unsigned) (@function.extfun_app.{2 1} Type semiring.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type semiring.{0}) h0) (add_group.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_131535 (h0 : topological_space (has_pos_part (has_add Type))) : totally_separated_space (has_pos_part (has_add Type)) := sorry --non-trivial
lemma new_lemma_131536 (h0 : functor.add_const (ring (has_zero Type)) (boolean_algebra.core environment.implicit_infer_kind)) : @is_domain.{1} (has_zero.{1} Type) (@functor.add_const.run.{1 0} (ring.{1} (has_zero.{1} Type)) (boolean_algebra.core.{0} environment.implicit_infer_kind) h0)  := sorry --non-trivial
lemma new_lemma_131537 (h0 : not (topological_space (semiring num) -> false)) : @normal_space.{0} (semiring.{0} num) (@classical.by_contradiction'.{1} (topological_space.{0} (semiring.{0} num)) h0)  := sorry --non-trivial
lemma new_lemma_131538 (h0 : topological_space (has_Inf (ring (has_add linarith.comp)))) : totally_separated_space (has_Inf (ring (has_add linarith.comp))) := sorry --non-trivial
lemma new_lemma_131539 (h0 : functor.add_const (topological_space (comm_group name)) linarith.comp) : @loc_path_connected_space.{0} (comm_group.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (comm_group.{0} name)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_131540 (h0 : functor.add_const (semiring (has_to_string pos)) unsigned) : @is_noetherian_ring.{0} (has_to_string.{0} pos) (@functor.add_const.run.{0 0} (semiring.{0} (has_to_string.{0} pos)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_131541 (h0 : topological_space (ordered_comm_ring (has_pos_part (has_Inf pos)))) : totally_separated_space (ordered_comm_ring (has_pos_part (has_Inf pos))) := sorry --non-trivial
lemma new_lemma_131542 (h0 : functor.add_const (uniform_space (add_cancel_monoid pos)) (has_Inf pos)) : @complete_space.{0} (add_cancel_monoid.{0} pos) (@functor.add_const.run.{0 0} (uniform_space.{0} (add_cancel_monoid.{0} pos)) (has_Inf.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_131543 (h0 : topological_space (normed_lattice_add_comm_group (has_neg name))) : normal_space (normed_lattice_add_comm_group (has_neg name)) := sorry --non-trivial
lemma new_lemma_131544 (h0 : function.extfun Type group) : @is_cyclic.{0} (monoid_with_zero.{0} ennreal) (@function.extfun_app.{2 1} Type group.{0} h0 (monoid_with_zero.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_131545 (h0 : function.extfun Type filter) : filter.ne_bot (function.extfun_app h0 (add_right_cancel_monoid unsigned)) := sorry --non-trivial
lemma new_lemma_131546 (h0 : not (topological_space (left_cancel_semigroup empty) -> false)) : @path_connected_space.{0} (left_cancel_semigroup.{0} empty) (@classical.by_contradiction'.{1} (topological_space.{0} (left_cancel_semigroup.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_131547 (h0 : topological_space (ring (has_add (has_add linarith.comp)))) : topological_space.separable_space (ring (has_add (has_add linarith.comp))) := sorry --non-trivial
lemma new_lemma_131548 (h0 : uniform_space (has_Inf (generalized_boolean_algebra linarith.comp))) : separated_space (has_Inf (generalized_boolean_algebra linarith.comp)) := sorry --non-trivial
lemma new_lemma_131549 (h0 : function.extfun Type complete_lattice) : @complete_lattice.is_Sup_finite_compact.{0} (complete_distrib_lattice.{0} empty) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (complete_distrib_lattice.{0} empty))  := sorry --non-trivial
lemma new_lemma_131550 (h0 : ring (add_comm_monoid (add_comm_monoid (has_add (has_add pos))))) : rank_condition (add_comm_monoid (add_comm_monoid (has_add (has_add pos)))) := sorry --non-trivial
lemma new_lemma_131551 (h0 : function.extfun Type group) : @is_cyclic.{0} (linear_ordered_field.{0} name) (@function.extfun_app.{2 1} Type group.{0} h0 (linear_ordered_field.{0} name))  := sorry --non-trivial
lemma new_lemma_131552 (h0 : functor.add_const (ring (canonically_ordered_monoid linarith.comp)) pos) : @rank_condition.{0} (canonically_ordered_monoid.{0} linarith.comp) (@functor.add_const.run.{0 0} (ring.{0} (canonically_ordered_monoid.{0} linarith.comp)) pos h0)  := sorry --non-trivial
lemma new_lemma_131553 (h0 : functor.add_const (cancel_comm_monoid_with_zero (boolean_algebra linarith.comp)) (ring pos)) : @unique_factorization_monoid.{0} (boolean_algebra.{0} linarith.comp) (@functor.add_const.run.{0 0} (cancel_comm_monoid_with_zero.{0} (boolean_algebra.{0} linarith.comp)) (ring.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_131554 (h1 : ring (has_append (comm_ring (comm_ring to_additive.value_type)))) : rank_condition (has_append (comm_ring (comm_ring to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_131555 (h0 : topological_space (measurable_space (semiring num))) : t0_space (measurable_space (semiring num)) := sorry --non-trivial
lemma new_lemma_131556 (h0 : functor.add_const (topological_space (boolean_algebra.core linarith.comp)) Type) : @t0_space.{0} (boolean_algebra.core.{0} linarith.comp) (@functor.add_const.run.{0 1} (topological_space.{0} (boolean_algebra.core.{0} linarith.comp)) Type h0)  := sorry --non-trivial
lemma new_lemma_131557 (h0 : monoid (dlist (has_top fun_info))) : monoid.fg (dlist (has_top fun_info)) := sorry --non-trivial
lemma new_lemma_131558 (h0 : fin has_zero.zero) : @add_monoid.fg.{0} (comm_semigroup.{0} pos) (@matrix.vec_empty.{0} (add_monoid.{0} (comm_semigroup.{0} pos)) (@matrix.vec_empty.{0} (fin (@has_zero.zero.{0} nat nat.has_zero)) h0))  := sorry --non-trivial
lemma new_lemma_131559 (h1 : group (normed_group num)) : normalizer_condition (normed_group num) := sorry --non-trivial
lemma new_lemma_131560 (h0 : function.extfun Type complete_lattice) : @is_atomistic.{0} (complete_linear_order.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (complete_linear_order.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_131561 (h0 : uniform_space (with_one (random_gen fun_info))) : complete_space (with_one (random_gen fun_info)) := sorry --non-trivial
lemma new_lemma_131562 (h0 : multiset (simple_graph (mul_one_class to_additive.value_type))) (h1 : not (multiset (simple_graph (mul_one_class to_additive.value_type)) -> false)) : multiset.disjoint h0 (classical.by_contradiction' h1) := sorry --non-trivial
lemma new_lemma_131563 (h0 : functor.add_const (add_monoid (has_neg pos)) pos) : @add_monoid.fg.{0} (has_neg.{0} pos) (@functor.add_const.run.{0 0} (add_monoid.{0} (has_neg.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_131564 (h0 : uniform_space (measurable_space (semiring empty))) : separated_space (measurable_space (semiring empty)) := sorry --non-trivial
lemma new_lemma_131565 (h0 : function.extfun Type topological_space) : @irreducible_space.{0} (metric_space.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (metric_space.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_131566 (h0 : topological_space ennreal) : locally_compact_space ennreal := sorry --non-trivial
lemma new_lemma_131567 (h0 : topological_space (complete_distrib_lattice (finset Type))) : t1_space (complete_distrib_lattice (finset Type)) := sorry --non-trivial
lemma new_lemma_131568 (h0 : topological_space (has_Inf (has_add pos))) : totally_separated_space (has_Inf (has_add pos)) := sorry --non-trivial
lemma new_lemma_131569 (h0 : complete_lattice (random_gen (semiring (id linarith.comp)))) : is_atomistic (random_gen (semiring (id linarith.comp))) := sorry --non-trivial
lemma new_lemma_131570 (h0 : function.extfun Type uniform_space) : @complete_space.{0} (simple_graph.{0} linarith.comp) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (simple_graph.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_131571 (h0 : add_monoid (comm_group (has_to_string pos))) : add_monoid.fg (comm_group (has_to_string pos)) := sorry --non-trivial
lemma new_lemma_131572 (h0 : function.extfun Type topological_space) : @discrete_topology.{0} (has_top.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_top.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_131573 (h0 : ring (add_comm_monoid (option empty))) : is_domain (add_comm_monoid (option empty)) := sorry --non-trivial
lemma new_lemma_131574 (h0 : topological_space (add_cancel_monoid (cancel_monoid linarith.comp))) : totally_separated_space (add_cancel_monoid (cancel_monoid linarith.comp)) := sorry --non-trivial
lemma new_lemma_131575 (h0 : fin has_zero.zero) : @t0_space.{0} (canonically_ordered_monoid.{0} (has_Inf.{0} pos)) (@matrix.vec_empty.{0} (topological_space.{0} (canonically_ordered_monoid.{0} (has_Inf.{0} pos))) h0)  := sorry --non-trivial
lemma new_lemma_131576 (h0 : semiring (ordered_ring (semiring (semiring empty)))) : is_noetherian_ring (ordered_ring (semiring (semiring empty))) := sorry --non-trivial
lemma new_lemma_131577 (h0 : ring (topological_space (semi_normed_ring reducibility_hints))) : is_domain (topological_space (semi_normed_ring reducibility_hints)) := sorry --non-trivial
lemma new_lemma_131578 (h0 : uniform_space (uniform_space (semi_normed_comm_ring reducibility_hints))) : complete_space (uniform_space (semi_normed_comm_ring reducibility_hints)) := sorry --non-trivial
lemma new_lemma_131579 (h0 : complete_lattice (add_cancel_comm_monoid (option unsigned))) : is_atomistic (add_cancel_comm_monoid (option unsigned)) := sorry --non-trivial
lemma new_lemma_131580 (h0 : function.extfun Type topological_space) : @discrete_topology.{0} (group_with_zero.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (group_with_zero.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_131581 (h0 : topological_space (has_compl (mul_one_class linarith.ineq))) : totally_disconnected_space (has_compl (mul_one_class linarith.ineq)) := sorry --non-trivial
lemma new_lemma_131582 (h0 : group (comm_monoid empty)) : group.fg (comm_monoid empty) := sorry --non-trivial
lemma new_lemma_131583 (h0 : measurable_space (add_comm_semigroup fun_info)) (h1 : measure_theory.measure (add_comm_semigroup fun_info)) : measure_theory.is_finite_measure h1 := sorry --non-trivial
lemma new_lemma_131584 (h0 : complete_lattice (boolean_algebra.core unsigned)) : is_atomistic (boolean_algebra.core unsigned) := sorry --non-trivial
lemma new_lemma_131585 (h0 : functor.add_const (ordered_comm_monoid (has_zero environment.implicit_infer_kind)) unsigned) : @has_exists_mul_of_le.{0} (has_zero.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (ordered_comm_monoid.{0} (has_zero.{0} environment.implicit_infer_kind)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_131586 (h0 : topological_space (has_to_string num)) : regular_space (has_to_string num) := sorry --non-trivial
lemma new_lemma_131587 (h0 : ring (canonically_linear_ordered_monoid (option name))) : is_domain (canonically_linear_ordered_monoid (option name)) := sorry --non-trivial
lemma new_lemma_131588 (h0 : function.extfun Type group) : @is_cyclic.{0} (parser unsigned) (@function.extfun_app.{2 1} Type group.{0} h0 (parser unsigned))  := sorry --non-trivial
lemma new_lemma_131589 (h0 : functor.add_const (function.extfun Type group) (has_pos_part linarith.comp)) : @group.fg.{0} (finset.{0} linarith.comp) (@function.extfun_app.{2 1} Type group.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type group.{0}) (has_pos_part.{0} linarith.comp) h0) (finset.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_131590 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @irreducible_space.{1} (boolean_algebra.core.{1} (has_add.{1} Type)) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 topological_space.{1}) (boolean_algebra.core.{1} (has_add.{1} Type)))  := sorry --non-trivial
lemma new_lemma_131591 (h0 : ordered_add_comm_monoid (boolean_algebra name)) : archimedean (boolean_algebra name) := sorry --non-trivial
lemma new_lemma_131592 (h0 : group (linear_ordered_comm_ring congr_arg_kind)) : is_cyclic (linear_ordered_comm_ring congr_arg_kind) := sorry --non-trivial
lemma new_lemma_131593 (h0 : functor.add_const (ordered_comm_monoid (comm_group pos)) pos) : @has_exists_mul_of_le.{0} (comm_group.{0} pos) (@functor.add_const.run.{0 0} (ordered_comm_monoid.{0} (comm_group.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_131594 (h0 : functor.add_const (topological_space (has_nndist linarith.comp)) (finset linarith.comp)) : @preirreducible_space.{0} (has_nndist.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (has_nndist.{0} linarith.comp)) (finset.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_131595 (h0 : ring (ring congr_arg_kind)) : rank_condition (ring congr_arg_kind) := sorry --non-trivial
lemma new_lemma_131596 (h0 : filter (has_Inf (has_pos_part linarith.comp))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_131597 (h1 : topological_space (normed_field ereal)) (h2 : add_group (normed_field ereal)) : topological_add_group (normed_field ereal) := sorry --non-trivial
lemma new_lemma_131598 (h0 : ring (distrib (metric_space linarith.comp_source))) : rank_condition (distrib (metric_space linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_131599 (h0 : function.extfun Type filter) : filter.ne_bot (function.extfun_app h0 (has_to_string congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_131600 (h0 : topological_space (is_R_or_C unsigned)) : path_connected_space (is_R_or_C unsigned) := sorry --non-trivial
lemma new_lemma_131601 (h0 : functor.add_const (topological_space (has_to_string Type)) name) : @loc_path_connected_space.{1} (has_to_string.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (has_to_string.{1} Type)) name h0)  := sorry --non-trivial
lemma new_lemma_131602 (h0 : group (has_bot (ring pos))) : group.fg (has_bot (ring pos)) := sorry --non-trivial
lemma new_lemma_131603 (h0 : functor.add_const (topological_space (comm_group pos)) ennreal) : @t1_space.{0} (comm_group.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (comm_group.{0} pos)) ennreal h0)  := sorry --non-trivial
lemma new_lemma_131604 (h1 : add_group (group linarith.ineq)) : is_add_cyclic (group linarith.ineq) := sorry --non-trivial
lemma new_lemma_131605 (h0 : function.extfun Type topological_space) : @regular_space.{0} (canonically_linear_ordered_monoid.{0} real) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (canonically_linear_ordered_monoid.{0} real))  := sorry --non-trivial
lemma new_lemma_131606 (h0 : has_mem.mem (has_emptyc linarith.ineq) has_emptyc.emptyc) : @complete_lattice.is_Sup_finite_compact.{0} (has_emptyc.{0} linarith.ineq) (@finset.pi.empty.{1 0} Type complete_lattice.{0} (has_emptyc.{0} linarith.ineq) h0)  := sorry --non-trivial
lemma new_lemma_131607 (h0 : topological_space (with_one (with_bot to_additive.value_type))) : irreducible_space (with_one (with_bot to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_131608 (h0 : functor.add_const (ordered_comm_monoid (semigroup environment.implicit_infer_kind)) (has_add Type)) : @has_exists_mul_of_le.{0} (semigroup.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 1} (ordered_comm_monoid.{0} (semigroup.{0} environment.implicit_infer_kind)) (has_add.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_131609 (h0 : functor.add_const (complete_lattice pos) ennreal) : @is_compactly_generated.{0} pos (@functor.add_const.run.{0 0} (complete_lattice.{0} pos) ennreal h0)  := sorry --non-trivial
lemma new_lemma_131610 (h0 : functor.add_const (ordered_comm_monoid (ring environment.implicit_infer_kind)) Type) : @has_exists_mul_of_le.{0} (ring.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 1} (ordered_comm_monoid.{0} (ring.{0} environment.implicit_infer_kind)) Type h0)  := sorry --non-trivial
lemma new_lemma_131611 (h0 : topological_space (comm_monoid (semiring empty))) : totally_separated_space (comm_monoid (semiring empty)) := sorry --non-trivial
lemma new_lemma_131612 (h0 : has_lt (add_comm_semigroup linarith.comp_source)) : no_max_order (add_comm_semigroup linarith.comp_source) := sorry --non-trivial
lemma new_lemma_131613 (h0 : topological_space (non_unital_non_assoc_semiring (mul_one_class to_additive.value_type))) : t0_space (non_unital_non_assoc_semiring (mul_one_class to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_131614 (h0 : filter (normed_group num)) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_131615 (h0 : functor.add_const (topological_space (ordered_cancel_add_comm_monoid ennreal)) ennreal) : @discrete_topology.{0} (ordered_cancel_add_comm_monoid.{0} ennreal) (@functor.add_const.run.{0 0} (topological_space.{0} (ordered_cancel_add_comm_monoid.{0} ennreal)) ennreal h0)  := sorry --non-trivial
lemma new_lemma_131616 (h0 : functor.add_const (complete_lattice (semigroup environment.implicit_infer_kind)) Type) : @complete_lattice.is_Sup_finite_compact.{0} (semigroup.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 1} (complete_lattice.{0} (semigroup.{0} environment.implicit_infer_kind)) Type h0)  := sorry --non-trivial
lemma new_lemma_131617 (h0 : functor.add_const (monoid auto.case_option) unsigned) : @monoid.fg.{0} auto.case_option (@functor.add_const.run.{0 0} (monoid.{0} auto.case_option) unsigned h0)  := sorry --non-trivial
lemma new_lemma_131618 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_noetherian_ring.{0} (complete_distrib_lattice.{0} name) (@function.extfun_app.{2 1} Type semiring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 semiring.{0}) (complete_distrib_lattice.{0} name))  := sorry --non-trivial
lemma new_lemma_131619 (h0 : fin has_zero.zero) : monoid.fg real := sorry --non-trivial
lemma new_lemma_131620 (h0 : topological_space (semi_normed_ring linarith.ineq)) : t0_space (semi_normed_ring linarith.ineq) := sorry --non-trivial
lemma new_lemma_131621 (h0 : topological_space (add_cancel_monoid (option pos))) : path_connected_space (add_cancel_monoid (option pos)) := sorry --non-trivial
lemma new_lemma_131622 (h1 : topological_space (topological_space linarith.ineq)) : path_connected_space (topological_space linarith.ineq) := sorry --non-trivial
lemma new_lemma_131623 (h0 : topological_space (plift (complete_linear_order (semiring num)))) : preirreducible_space (plift (complete_linear_order (semiring num))) := sorry --non-trivial
lemma new_lemma_131624 (h0 : functor.add_const (group (finset pos)) Type) : @normalizer_condition.{0} (finset.{0} pos) (@functor.add_const.run.{0 1} (group.{0} (finset.{0} pos)) Type h0)  := sorry --non-trivial
lemma new_lemma_131625 (h0 : function.extfun Type group) : @normalizer_condition.{0} (group_with_zero.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type group.{0} h0 (group_with_zero.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_131626 (h0 : topological_space (has_Inf (finset (has_add pos)))) : t0_space (has_Inf (finset (has_add pos))) := sorry --non-trivial
lemma new_lemma_131627 (h0 : functor.add_const (topological_space (has_to_string pos)) environment.implicit_infer_kind) : @normal_space.{0} (has_to_string.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (has_to_string.{0} pos)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_131628 (h0 : functor.add_const (topological_space (normed_comm_ring Type)) environment.implicit_infer_kind) : @t0_space.{1} (normed_comm_ring.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (normed_comm_ring.{1} Type)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_131629 (h0 : semiring (preorder num)) : is_noetherian_ring (preorder num) := sorry --non-trivial
lemma new_lemma_131630 (h1 : set (semi_normed_comm_ring string.iterator_imp)) : set.subsingleton h1 := sorry --non-trivial
lemma new_lemma_131631 (h0 : fin has_zero.zero) : @unique_factorization_monoid.{0} (has_add.{0} real) (@matrix.vec_empty.{0} (cancel_comm_monoid_with_zero.{0} (has_add.{0} real)) h0)  := sorry --non-trivial
lemma new_lemma_131632 (h0 : topological_space (with_one (has_top fun_info))) : irreducible_space (with_one (has_top fun_info)) := sorry --non-trivial
lemma new_lemma_131633 (h0 : group (finset (boolean_algebra (has_to_string (has_to_string (finset linarith.comp)))))) : is_cyclic (finset (boolean_algebra (has_to_string (has_to_string (finset linarith.comp))))) := sorry --non-trivial
lemma new_lemma_131634 (h1 : topological_space (has_nnnorm environment.projection_info)) : totally_disconnected_space (has_nnnorm environment.projection_info) := sorry --non-trivial
lemma new_lemma_131635 (h0 : topological_space (linear_ordered_semiring (has_subset num))) : locally_compact_space (linear_ordered_semiring (has_subset num)) := sorry --non-trivial
lemma new_lemma_131636 (h0 : list (has_dist num)) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_131637 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_add_cyclic.{0} linarith.ineq (@function.extfun_app.{2 1} Type add_group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 add_group.{0}) linarith.ineq)  := sorry --non-trivial
lemma new_lemma_131638 (h0 : not (function.extfun Type topological_space -> false)) : @totally_disconnected_space.{0} (has_top.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (has_top.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_131639 (h0 : uniform_space (distrib (has_nnnorm (has_nnnorm linarith.ineq)))) : complete_space (distrib (has_nnnorm (has_nnnorm linarith.ineq))) := sorry --non-trivial
lemma new_lemma_131640 (h0 : functor.add_const (ring (ring empty)) empty) : @rank_condition.{0} (ring.{0} empty) (@functor.add_const.run.{0 0} (ring.{0} (ring.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_131641 (h0 : complete_lattice (ring (option empty))) : is_compactly_generated (ring (option empty)) := sorry --non-trivial
lemma new_lemma_131642 (h0 : list (ring (has_neg (ring (ring linarith.comp))))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_131643 (h0 : functor.add_const (topological_space (has_zero pos)) Type) : @totally_disconnected_space.{0} (has_zero.{0} pos) (@functor.add_const.run.{0 1} (topological_space.{0} (has_zero.{0} pos)) Type h0)  := sorry --non-trivial
lemma new_lemma_131644 (h0 : functor.add_const (uniform_space (add_cancel_monoid Type)) (has_add (has_neg linarith.comp))) : @complete_space.{1} (add_cancel_monoid.{1} Type) (@functor.add_const.run.{1 0} (uniform_space.{1} (add_cancel_monoid.{1} Type)) (has_add.{0} (has_neg.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_131645 (h0 : has_mem.mem add_group has_emptyc.emptyc) : @is_add_cyclic.{0} (has_top.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type add_group.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) add_group.{0} h0) (has_top.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_131646 (h0 : functor.add_const (complete_lattice (has_dist unsigned)) congr_arg_kind) : @is_compactly_generated.{0} (has_dist.{0} unsigned) (@functor.add_const.run.{0 0} (complete_lattice.{0} (has_dist.{0} unsigned)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_131647 (h0 : ordered_add_comm_monoid (non_assoc_semiring (option unsigned))) : archimedean (non_assoc_semiring (option unsigned)) := sorry --non-trivial
lemma new_lemma_131648 (h0 : function.extfun ((Type -> Type) -> Type 1) (function.extfun (Type -> Type))) : @is_cyclic.{0} (normed_group.{0} linarith.ineq) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) (@function.extfun_app.{3 2} ((Type → Type) → Type 1) (function.extfun.{2 2} (Type → Type)) h0 (function.extfun.{2 1} Type)) group.{0}) (normed_group.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_131649 (h0 : topological_space (add_cancel_comm_monoid (has_nnnorm (mul_one_class (has_nnnorm (has_nnnorm fun_info)))))) : t0_space (add_cancel_comm_monoid (has_nnnorm (mul_one_class (has_nnnorm (has_nnnorm fun_info))))) := sorry --non-trivial
lemma new_lemma_131650 (h1 : complete_lattice string_imp) : is_compactly_generated string_imp := sorry --non-trivial
lemma new_lemma_131651 (h0 : function.extfun Type filter) : filter.ne_bot (function.extfun_app h0 (with_bot fun_info)) := sorry --non-trivial
lemma new_lemma_131652 (h0 : function.extfun Type group) : @is_cyclic.{0} (denumerable.{0} linarith.ineq) (@function.extfun_app.{2 1} Type group.{0} h0 (denumerable.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_131653 (h0 : group (comm_semigroup name)) : normalizer_condition (comm_semigroup name) := sorry --non-trivial
lemma new_lemma_131654 (h0 : function.extfun Type topological_space) : @path_connected_space.{0} (monoid.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (monoid.{0} num))  := sorry --non-trivial
lemma new_lemma_131655 (h0 : complete_lattice (plift (option num))) : is_atomistic (plift (option num)) := sorry --non-trivial
lemma new_lemma_131656 (h0 : measurable_space (random_gen empty) -> measurable_space (random_gen empty) -> Prop) : is_strict_order (measurable_space (random_gen empty)) h0 := sorry --non-trivial
lemma new_lemma_131657 (h0 : functor.add_const (function.extfun (Type 1) group) pos) : @normalizer_condition.{1} (has_neg.{1} Type) (@function.extfun_app.{3 2} (Type 1) group.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) group.{1}) pos h0) (has_neg.{1} Type))  := sorry --non-trivial
lemma new_lemma_131658 (h0 : functor.add_const (function.extfun Type topological_space) name) : @preirreducible_space.{0} (has_zero.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) name h0) (has_zero.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_131659 (h0 : topological_space (canonically_linear_ordered_monoid (sub_neg_monoid real))) : sequential_space (canonically_linear_ordered_monoid (sub_neg_monoid real)) := sorry --non-trivial
lemma new_lemma_131660 (h0 : ordered_add_comm_monoid (complete_linear_order unsigned)) : archimedean (complete_linear_order unsigned) := sorry --non-trivial
lemma new_lemma_131661 (h0 : topological_space (with_bot (with_bot linarith.comp))) : totally_separated_space (with_bot (with_bot linarith.comp)) := sorry --non-trivial
lemma new_lemma_131662 (h0 : functor.add_const (function.extfun Type semiring) linarith.comp) : @is_noetherian_ring.{0} (has_zero.{0} linarith.comp) (@function.extfun_app.{2 1} Type semiring.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type semiring.{0}) linarith.comp h0) (has_zero.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_131663 (h0 : functor.add_const (topological_space (boolean_algebra name)) linarith.comp) : @irreducible_space.{0} (boolean_algebra.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (boolean_algebra.{0} name)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_131664 (h0 : functor.comp ring has_neg name) : @strong_rank_condition.{0} (has_neg.{0} name) (@functor.comp.run.{0 0 0} ring.{0} has_neg.{0} name h0)  := sorry --non-trivial
lemma new_lemma_131665 (h0 : topological_space (has_neg linarith.comp)) : discrete_topology (has_neg linarith.comp) := sorry --non-trivial
lemma new_lemma_131666 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @sequential_space.{0} (ring.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (ring.{0} pos))  := sorry --non-trivial
lemma new_lemma_131667 (h0 : ring (free_add_monoid (semiring (semiring empty)))) : rank_condition (free_add_monoid (semiring (semiring empty))) := sorry --non-trivial
lemma new_lemma_131668 (h0 : function.extfun Type monoid) : @monoid.fg.{0} (has_repr.{0} pos) (@function.extfun_app.{2 1} Type monoid.{0} h0 (has_repr.{0} pos))  := sorry --non-trivial
lemma new_lemma_131669 (h0 : uniform_space (linear_ordered_semiring (random_gen fun_info))) : separated_space (linear_ordered_semiring (random_gen fun_info)) := sorry --non-trivial
lemma new_lemma_131670 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : finset.nonempty (function.extfun_app (function.extfun_app h0 finset) (add_cancel_monoid ennreal)) := sorry --non-trivial
lemma new_lemma_131671 (h0 : ring (denumerable (comm_ring char))) : strong_rank_condition (denumerable (comm_ring char)) := sorry --non-trivial
lemma new_lemma_131672 (h0 : functor.add_const (add_monoid (finset unsigned)) environment.implicit_infer_kind) : @add_monoid.fg.{0} (finset.{0} unsigned) (@functor.add_const.run.{0 0} (add_monoid.{0} (finset.{0} unsigned)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_131673 (h0 : group (normed_comm_ring (option unsigned))) : is_cyclic (normed_comm_ring (option unsigned)) := sorry --non-trivial
lemma new_lemma_131674 (h0 : topological_space (finset (option (option ennreal)))) : locally_compact_space (finset (option (option ennreal))) := sorry --non-trivial
lemma new_lemma_131675 (h0 : list (has_neg_part (has_add Type))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_131676 (h0 : topological_space (has_nnnorm (comm_group ereal))) : totally_disconnected_space (has_nnnorm (comm_group ereal)) := sorry --non-trivial
lemma new_lemma_131677 (h0 : function.extfun Type topological_space) : @loc_path_connected_space.{0} (has_bot.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_bot.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_131678 (h0 : functor.add_const (topological_space (add_comm_monoid environment.implicit_infer_kind)) linarith.comp) : @path_connected_space.{0} (add_comm_monoid.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (add_comm_monoid.{0} environment.implicit_infer_kind)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_131679 (h0 : functor.add_const (topological_space (free_add_monoid empty)) num) : @path_connected_space.{0} (free_add_monoid.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (free_add_monoid.{0} empty)) num h0)  := sorry --non-trivial
lemma new_lemma_131680 (h0 : cancel_comm_monoid_with_zero (has_nndist (has_nndist name))) : unique_factorization_monoid (has_nndist (has_nndist name)) := sorry --non-trivial
lemma new_lemma_131681 (h1 : ring (normed_field string.iterator_imp)) : is_domain (normed_field string.iterator_imp) := sorry --non-trivial
lemma new_lemma_131682 (h0 : topological_space (add_cancel_monoid (has_add Type))) : loc_path_connected_space (add_cancel_monoid (has_add Type)) := sorry --non-trivial
lemma new_lemma_131683 (h0 : monoid (ring (option num))) : monoid.fg (ring (option num)) := sorry --non-trivial
lemma new_lemma_131684 (h0 : ring (semigroup (has_pos_part (metric_space linarith.comp)))) : strong_rank_condition (semigroup (has_pos_part (metric_space linarith.comp))) := sorry --non-trivial
lemma new_lemma_131685 (h0 : functor.add_const (topological_space (has_star unsigned)) empty) : @loc_path_connected_space.{0} (has_star.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (has_star.{0} unsigned)) empty h0)  := sorry --non-trivial
lemma new_lemma_131686 (h0 : topological_space (id unsigned)) : t0_space (id unsigned) := sorry --non-trivial
lemma new_lemma_131687 (h0 : complete_lattice (linear_ordered_semiring empty)) : complete_lattice.is_Sup_finite_compact (linear_ordered_semiring empty) := sorry --non-trivial
lemma new_lemma_131688 (h0 : function.extfun Type ordered_add_comm_monoid) : @archimedean.{0} (boolean_algebra.{0} linarith.comp) (@function.extfun_app.{2 1} Type ordered_add_comm_monoid.{0} h0 (boolean_algebra.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_131689 (h0 : functor.add_const (monoid (measurable_space.dynkin_system empty)) (semiring empty)) : @monoid.fg.{0} (measurable_space.dynkin_system.{0} empty) (@functor.add_const.run.{0 0} (monoid.{0} (measurable_space.dynkin_system.{0} empty)) (semiring.{0} empty) h0)  := sorry --non-trivial
lemma new_lemma_131690 (h0 : function.extfun Type (functor.add_const (add_monoid name))) : @add_monoid.fg.{0} name (@functor.add_const.run.{0 0} (add_monoid.{0} name) congr_arg_kind (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (add_monoid.{0} name)) h0 congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_131691 (h0 : topological_space (ordered_comm_monoid (has_Inf real))) : irreducible_space (ordered_comm_monoid (has_Inf real)) := sorry --non-trivial
lemma new_lemma_131692 (h0 : ring (id empty)) : rank_condition (id empty) := sorry --non-trivial
lemma new_lemma_131693 (h0 : add_monoid (linear_ordered_field congr_arg_kind)) : add_monoid.fg (linear_ordered_field congr_arg_kind) := sorry --non-trivial
lemma new_lemma_131694 (h0 : function.extfun Type topological_space) : @totally_disconnected_space.{0} (has_norm.{0} linarith.ineq) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_norm.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_131695 (h0 : topological_space (group_with_zero (option (option (option empty))))) : locally_compact_space (group_with_zero (option (option (option empty)))) := sorry --non-trivial
lemma new_lemma_131696 (h0 : complete_lattice (with_bot (has_top (has_top linarith.comp_source)))) : complete_lattice.is_Sup_finite_compact (with_bot (has_top (has_top linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_131697 (h0 : topological_space (add_group (has_union (uniform_space num)))) : normal_space (add_group (has_union (uniform_space num))) := sorry --non-trivial
lemma new_lemma_131698 (h0 : group (with_one (random_gen (random_gen linarith.ineq)))) : group.fg (with_one (random_gen (random_gen linarith.ineq))) := sorry --non-trivial
lemma new_lemma_131699 (h0 : functor.comp topological_space boolean_algebra.core ennreal) : @regular_space.{0} (boolean_algebra.core.{0} ennreal) (@functor.comp.run.{0 0 0} topological_space.{0} boolean_algebra.core.{0} ennreal h0)  := sorry --non-trivial
lemma new_lemma_131700 (h0 : list (has_top (random_gen (random_gen string_imp)))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_131701 (h0 : function.extfun Type (prod (free_add_monoid (semiring empty)))) : id_rel (function.extfun_app h0 (free_add_monoid (semiring empty))) := sorry --non-trivial
lemma new_lemma_131702 (h0 : topological_space (ordered_cancel_add_comm_monoid ennreal)) : t0_space (ordered_cancel_add_comm_monoid ennreal) := sorry --non-trivial
lemma new_lemma_131703 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @separated_space.{0} (linear_ordered_field.{0} unsigned) (@function.extfun_app.{2 1} Type uniform_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 uniform_space.{0}) (linear_ordered_field.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_131704 (h0 : topological_space (has_bot empty)) : irreducible_space (has_bot empty) := sorry --non-trivial
lemma new_lemma_131705 (h2 : topological_space ereal) : t0_space ereal := sorry --non-trivial
lemma new_lemma_131706 (h0 : not (has_mem.mem (with_one linarith.comp_source) has_emptyc.emptyc -> false)) : @path_connected_space.{0} (with_one.{0} linarith.comp_source) (@finset.pi.empty.{1 0} Type topological_space.{0} (with_one.{0} linarith.comp_source) (@classical.by_contradiction'.{0} (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (with_one.{0} linarith.comp_source) (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))) h0))  := sorry --non-trivial
lemma new_lemma_131707 (h0 : not (ring (has_nnnorm to_additive.value_type) -> false)) : @rank_condition.{0} (has_nnnorm.{0} to_additive.value_type) (@classical.by_contradiction'.{1} (ring.{0} (has_nnnorm.{0} to_additive.value_type)) h0)  := sorry --non-trivial
lemma new_lemma_131708 (h0 : ring (has_lt (uniform_space linarith.ineq))) : rank_condition (has_lt (uniform_space linarith.ineq)) := sorry --non-trivial
lemma new_lemma_131709 (h0 : functor.add_const (function.extfun (Type 1) topological_space) (has_neg Type)) : @t0_space.{1} (has_Inf.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@functor.add_const.run.{2 1} (function.extfun.{3 2} (Type 1) topological_space.{1}) (has_neg.{1} Type) h0) (has_Inf.{1} Type))  := sorry --non-trivial
lemma new_lemma_131710 (h0 : group (normed_comm_ring (comm_group (comm_group unsigned)))) : group.fg (normed_comm_ring (comm_group (comm_group unsigned))) := sorry --non-trivial
lemma new_lemma_131711 (h0 : functor.add_const (topological_space (has_nndist name)) unsigned) : @regular_space.{0} (has_nndist.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (has_nndist.{0} name)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_131712 (h0 : functor.add_const (function.extfun Type complete_lattice) linarith.comp) : @complete_lattice.is_Sup_finite_compact.{0} (add_cancel_monoid.{0} name) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type complete_lattice.{0}) linarith.comp h0) (add_cancel_monoid.{0} name))  := sorry --non-trivial
lemma new_lemma_131713 (h0 : not (filter (add_left_cancel_monoid to_additive.value_type) -> false)) : filter.ne_bot (classical.by_contradiction' h0) := sorry --non-trivial
lemma new_lemma_131714 (h1 : ring (encodable to_additive.value_type)) : rank_condition (encodable to_additive.value_type) := sorry --non-trivial
lemma new_lemma_131715 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @monoid.fg.{0} (pseudo_metric_space.{0} empty) (@function.extfun_app.{2 1} Type monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 monoid.{0}) (pseudo_metric_space.{0} empty))  := sorry --non-trivial
lemma new_lemma_131716 (h0 : topological_space (with_bot (has_top (has_top (has_inv linarith.comp_source))))) : locally_compact_space (with_bot (has_top (has_top (has_inv linarith.comp_source)))) := sorry --non-trivial
lemma new_lemma_131717 (h0 : topological_space (ordered_comm_ring (has_Inf (boolean_algebra pos)))) : normal_space (ordered_comm_ring (has_Inf (boolean_algebra pos))) := sorry --non-trivial
lemma new_lemma_131718 (h0 : add_group (has_union (has_norm linarith.comp))) : is_add_cyclic (has_union (has_norm linarith.comp)) := sorry --non-trivial
lemma new_lemma_131719 (h0 : group (pseudo_metric_space num)) : is_cyclic (pseudo_metric_space num) := sorry --non-trivial
lemma new_lemma_131720 (h0 : function.extfun Type topological_space) : @preconnected_space.{0} (normed_comm_ring.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (normed_comm_ring.{0} name))  := sorry --non-trivial
lemma new_lemma_131721 (h0 : functor.add_const (cancel_comm_monoid_with_zero (canonically_ordered_comm_semiring Type)) unsigned) : @unique_factorization_monoid.{1} (canonically_ordered_comm_semiring.{1} Type) (@functor.add_const.run.{1 0} (cancel_comm_monoid_with_zero.{1} (canonically_ordered_comm_semiring.{1} Type)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_131722 (h0 : fin has_zero.zero) : @normalizer_condition.{1} (has_add.{1} Type) (@matrix.vec_empty.{1} (group.{1} (has_add.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_131723 (h0 : functor.add_const (group (ordered_comm_ring Type)) Type) : @normalizer_condition.{1} (ordered_comm_ring.{1} Type) (@functor.add_const.run.{1 1} (group.{1} (ordered_comm_ring.{1} Type)) Type h0)  := sorry --non-trivial
lemma new_lemma_131724 (h1 : not (functor.comp topological_space random_gen string_imp -> false)) : @t0_space.{0} (random_gen.{0} string_imp) (@functor.comp.run.{0 0 0} topological_space.{0} random_gen.{0} string_imp (@classical.by_contradiction'.{1} (functor.comp.{0 0 0} topological_space.{0} random_gen.{0} string_imp) h1))  := sorry --non-trivial
lemma new_lemma_131725 (h0 : function.extfun Type topological_space) : @path_connected_space.{0} (has_norm.{0} fun_info) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_norm.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_131726 (h0 : group (has_to_string Type)) : group.fg (has_to_string Type) := sorry --non-trivial
lemma new_lemma_131727 (h0 : functor.add_const (topological_space (has_zero Type)) linarith.comp) : @t0_space.{1} (has_zero.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (has_zero.{1} Type)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_131728 (h0 : function.extfun Type filter) : filter.ne_bot (function.extfun_app h0 (distrib_lattice to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_131729 (h0 : add_group (has_top num)) : is_add_cyclic (has_top num) := sorry --non-trivial
lemma new_lemma_131730 (h0 : topological_space (boolean_algebra.core unsigned)) : totally_separated_space (boolean_algebra.core unsigned) := sorry --non-trivial
lemma new_lemma_131731 (h0 : function.extfun Type complete_lattice) : @complete_lattice.is_Sup_finite_compact.{0} (canonically_ordered_comm_semiring.{0} ennreal) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (canonically_ordered_comm_semiring.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_131732 (h0 : topological_space (add_monoid char)) : totally_disconnected_space (add_monoid char) := sorry --non-trivial
lemma new_lemma_131733 (h0 : topological_space (comm_group (comm_group pos))) : t0_space (comm_group (comm_group pos)) := sorry --non-trivial
lemma new_lemma_131734 (h0 : functor.add_const (topological_space (has_neg unsigned)) name) : @sequential_space.{0} (has_neg.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (has_neg.{0} unsigned)) name h0)  := sorry --non-trivial
lemma new_lemma_131735 (h0 : topological_space (canonically_ordered_monoid (has_add (has_Inf Type)))) : preirreducible_space (canonically_ordered_monoid (has_add (has_Inf Type))) := sorry --non-trivial
lemma new_lemma_131736 (h0 : add_monoid (linear_ordered_comm_ring (semiring unsigned))) : add_monoid.fg (linear_ordered_comm_ring (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_131737 (h0 : finset (finset (ring (has_to_string (has_neg (ring Type)))))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_131738 (h0 : not (uniform_space (has_ssubset linarith.ineq) -> false)) : @complete_space.{0} (has_ssubset.{0} linarith.ineq) (@classical.by_contradiction'.{1} (uniform_space.{0} (has_ssubset.{0} linarith.ineq)) h0)  := sorry --non-trivial
lemma new_lemma_131739 (h0 : functor.add_const (ring (simple_graph linarith.comp)) name) : @is_principal_ideal_ring.{0} (simple_graph.{0} linarith.comp) (@functor.add_const.run.{0 0} (ring.{0} (simple_graph.{0} linarith.comp)) name h0)  := sorry --non-trivial
lemma new_lemma_131740 (h0 : function.extfun Type topological_space) : @preconnected_space.{0} (has_nndist.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_nndist.{0} pos))  := sorry --non-trivial
lemma new_lemma_131741 (h0 : uniform_space (has_edist unsigned)) : separated_space (has_edist unsigned) := sorry --non-trivial
lemma new_lemma_131742 (h0 : functor.add_const (group (has_zero pos)) (has_neg environment.implicit_infer_kind)) : @group.fg.{0} (has_zero.{0} pos) (@functor.add_const.run.{0 0} (group.{0} (has_zero.{0} pos)) (has_neg.{0} environment.implicit_infer_kind) h0)  := sorry --non-trivial
lemma new_lemma_131743 (h0 : fin has_zero.zero) : @totally_separated_space.{0} (generalized_boolean_algebra.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@matrix.vec_empty.{1} (function.extfun.{2 1} Type topological_space.{0}) h0) (generalized_boolean_algebra.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_131744 (h0 : function.extfun Type complete_lattice) : @complete_lattice.is_Sup_finite_compact.{0} (sub_neg_monoid.{0} name) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (sub_neg_monoid.{0} name))  := sorry --non-trivial
lemma new_lemma_131745 (h0 : filter (has_nndist (finset (finset (finset linarith.comp))))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_131746 (h0 : has_lt (nondiscrete_normed_field enat)) : no_max_order (nondiscrete_normed_field enat) := sorry --non-trivial
lemma new_lemma_131747 (h0 : not (uniform_space (uniform_space string.iterator_imp) -> false)) : @complete_space.{0} (uniform_space.{0} string.iterator_imp) (@classical.by_contradiction'.{1} (uniform_space.{0} (uniform_space.{0} string.iterator_imp)) h0)  := sorry --non-trivial
lemma new_lemma_131748 (h0 : functor.add_const (topological_space (semigroup Type)) ennreal) : @preconnected_space.{1} (semigroup.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (semigroup.{1} Type)) ennreal h0)  := sorry --non-trivial
lemma new_lemma_131749 (h0 : has_lt (simple_graph linarith.comp_source)) : no_max_order (simple_graph linarith.comp_source) := sorry --non-trivial
lemma new_lemma_131750 (h0 : function.extfun (finset Type) (has_mem.mem (linear_ordered_semiring empty))) : @add_monoid.fg.{0} (linear_ordered_semiring.{0} empty) (@finset.pi.empty.{1 0} Type add_monoid.{0} (linear_ordered_semiring.{0} empty) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (linear_ordered_semiring.{0} empty)) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_131751 (h0 : function.extfun Type add_group) : @is_add_cyclic.{0} (left_cancel_semigroup.{0} num) (@function.extfun_app.{2 1} Type add_group.{0} h0 (left_cancel_semigroup.{0} num))  := sorry --non-trivial
lemma new_lemma_131752 (h0 : group (semigroup (has_to_string (finset Type)))) : is_simple_group (semigroup (has_to_string (finset Type))) := sorry --non-trivial
lemma new_lemma_131753 (h0 : function.extfun Type filter) : filter.ne_bot (function.extfun_app h0 (comm_monoid unsigned)) := sorry --non-trivial
lemma new_lemma_131754 (h1 : topological_space (id (random_gen (with_bot linarith.comp_source)))) : totally_separated_space (id (random_gen (with_bot linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_131755 (h0 : topological_space (sub_neg_monoid unsigned)) : locally_compact_space (sub_neg_monoid unsigned) := sorry --non-trivial
lemma new_lemma_131756 (h0 : topological_space (has_div (mul_one_class (uniform_space enat)))) : t0_space (has_div (mul_one_class (uniform_space enat))) := sorry --non-trivial
lemma new_lemma_131757 (h0 : function.extfun Type topological_space) : @locally_compact_space.{0} (has_Sup.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_Sup.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_131758 (h0 : function.extfun Type add_group) : @is_add_cyclic.{0} (ordered_cancel_add_comm_monoid.{0} num) (@function.extfun_app.{2 1} Type add_group.{0} h0 (ordered_cancel_add_comm_monoid.{0} num))  := sorry --non-trivial
lemma new_lemma_131759 (h0 : functor.comp ring finset name) : @is_domain.{0} (finset.{0} name) (@functor.comp.run.{0 0 0} ring.{0} finset.{0} name h0)  := sorry --non-trivial
lemma new_lemma_131760 (h0 : function.extfun Type topological_space) : @totally_separated_space.{0} (has_zero.{0} ennreal) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_zero.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_131761 (h0 : uniform_space (normed_group unsigned)) : complete_space (normed_group unsigned) := sorry --non-trivial
lemma new_lemma_131762 (h2 : complete_lattice (has_div linarith.ineq)) : is_compactly_generated (has_div linarith.ineq) := sorry --non-trivial
lemma new_lemma_131763 (h0 : fin has_zero.zero) : @group.fg.{0} (has_Inf.{0} real) (@matrix.vec_empty.{0} (group.{0} (has_Inf.{0} real)) h0)  := sorry --non-trivial
lemma new_lemma_131764 (h0 : semiring (ring (option pos))) : is_noetherian_ring (ring (option pos)) := sorry --non-trivial
lemma new_lemma_131765 (h0 : functor.add_const (group (left_cancel_semigroup empty)) empty) : @is_cyclic.{0} (left_cancel_semigroup.{0} empty) (@functor.add_const.run.{0 0} (group.{0} (left_cancel_semigroup.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_131766 (h0 : fin has_zero.zero) : filter.ne_bot (function.extfun_app (matrix.vec_empty h0) (non_assoc_semiring unsigned)) := sorry --non-trivial
lemma new_lemma_131767 (h0 : list (dlist (has_ssubset fun_info))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_131768 (h0 : topological_space (has_bot (has_add Type))) : t1_space (has_bot (has_add Type)) := sorry --non-trivial
lemma new_lemma_131769 (h0 : ring (has_inv (has_norm (has_norm (has_ssubset (has_norm fun_info)))))) : rank_condition (has_inv (has_norm (has_norm (has_ssubset (has_norm fun_info))))) := sorry --non-trivial
lemma new_lemma_131770 (h1 : ring (distrib string_imp)) : strong_rank_condition (distrib string_imp) := sorry --non-trivial
lemma new_lemma_131771 (h0 : functor.add_const (add_monoid (partial_order empty)) (semiring num)) : @add_monoid.fg.{0} (partial_order.{0} empty) (@functor.add_const.run.{0 0} (add_monoid.{0} (partial_order.{0} empty)) (semiring.{0} num) h0)  := sorry --non-trivial
lemma new_lemma_131772 (h3 : ring (semi_normed_ring linarith.comp_source)) : strong_rank_condition (semi_normed_ring linarith.comp_source) := sorry --non-trivial
lemma new_lemma_131773 (h0 : filter (comm_group (has_add (canonically_linear_ordered_monoid name)))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_131774 (h2 : uniform_space (mul_one_class to_additive.value_type)) : complete_space (mul_one_class to_additive.value_type) := sorry --non-trivial
lemma new_lemma_131775 (h0 : functor.add_const (list (semigroup pos)) pos) : palindrome (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_131776 (h0 : list (has_top linarith.ineq)) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_131777 (h0 : not (prod (id empty) (id empty) -> false)) : id_rel (classical.by_contradiction' h0) := sorry --non-trivial
lemma new_lemma_131778 (h0 : has_mem.mem (has_top congr_arg_kind) has_emptyc.emptyc) : @normalizer_condition.{0} (has_top.{0} congr_arg_kind) (@finset.pi.empty.{1 0} Type group.{0} (has_top.{0} congr_arg_kind) h0)  := sorry --non-trivial
lemma new_lemma_131779 (h0 : functor.add_const (ring (ring name)) (has_neg_part pos)) : @strong_rank_condition.{0} (ring.{0} name) (@functor.add_const.run.{0 0} (ring.{0} (ring.{0} name)) (has_neg_part.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_131780 (h0 : functor.add_const (semiring (preorder num)) unsigned) : @is_noetherian_ring.{0} (preorder.{0} num) (@functor.add_const.run.{0 0} (semiring.{0} (preorder.{0} num)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_131781 (h0 : functor.add_const (complete_lattice (has_add pos)) pos) : @is_compactly_generated.{0} (has_add.{0} pos) (@functor.add_const.run.{0 0} (complete_lattice.{0} (has_add.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_131782 (h0 : topological_space (ring (has_pos_part (ring linarith.comp)))) : t1_space (ring (has_pos_part (ring linarith.comp))) := sorry --non-trivial
lemma new_lemma_131783 (h0 h1 : local_equiv char ereal) : local_equiv.eq_on_source h0 h1 := sorry --non-trivial
lemma new_lemma_131784 (h0 : topological_space (normed_group (random_gen (has_nnnorm fun_info)))) : locally_compact_space (normed_group (random_gen (has_nnnorm fun_info))) := sorry --non-trivial
lemma new_lemma_131785 (h0 : function.extfun (finset Type) (has_mem.mem empty)) : @rank_condition.{0} empty (@finset.pi.empty.{1 0} Type ring.{0} empty (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) empty) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_131786 (h0 : functor.add_const (ring (option num)) num) : @is_principal_ideal_ring.{0} (option.{0} num) (@functor.add_const.run.{0 0} (ring.{0} (option.{0} num)) num h0)  := sorry --non-trivial
lemma new_lemma_131787 (h0 : filter (canonically_ordered_comm_semiring (finset pos))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_131788 (h0 : not (complete_lattice (encodable fun_info) -> false)) : @complete_lattice.is_Sup_finite_compact.{0} (encodable.{0} fun_info) (@classical.by_contradiction'.{1} (complete_lattice.{0} (encodable.{0} fun_info)) h0)  := sorry --non-trivial
lemma new_lemma_131789 (h0 : functor.add_const (ordered_add_comm_monoid (finset pos)) name) : @archimedean.{0} (finset.{0} pos) (@functor.add_const.run.{0 0} (ordered_add_comm_monoid.{0} (finset.{0} pos)) name h0)  := sorry --non-trivial
lemma new_lemma_131790 (h1 : not (ring (topological_space string_imp) -> false)) : @is_domain.{0} (topological_space.{0} string_imp) (@classical.by_contradiction'.{1} (ring.{0} (topological_space.{0} string_imp)) h1)  := sorry --non-trivial
lemma new_lemma_131791 (h0 : topological_space (comm_group (has_neg_part (has_neg_part Type)))) : normal_space (comm_group (has_neg_part (has_neg_part Type))) := sorry --non-trivial
lemma new_lemma_131792 (h0 : not (has_mem.mem (measurable_space fun_info) has_emptyc.emptyc -> false)) : @strong_rank_condition.{0} (measurable_space.{0} fun_info) (@finset.pi.empty.{1 0} Type ring.{0} (measurable_space.{0} fun_info) (@classical.by_contradiction'.{0} (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (measurable_space.{0} fun_info) (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))) h0))  := sorry --non-trivial
lemma new_lemma_131793 (h0 : not (add_monoid (add_group congr_arg_kind) -> false)) : @add_monoid.fg.{0} (add_group.{0} congr_arg_kind) (@classical.by_contradiction'.{1} (add_monoid.{0} (add_group.{0} congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_131794 (h0 : semiring (canonically_ordered_monoid (has_neg name))) : is_noetherian_ring (canonically_ordered_monoid (has_neg name)) := sorry --non-trivial
lemma new_lemma_131795 (h0 : not (complete_lattice (has_emptyc to_additive.value_type) -> false)) : @is_compactly_generated.{0} (has_emptyc.{0} to_additive.value_type) (@classical.by_contradiction'.{1} (complete_lattice.{0} (has_emptyc.{0} to_additive.value_type)) h0)  := sorry --non-trivial
lemma new_lemma_131796 (h0 : finset (has_add (has_neg (has_neg_part (has_neg Type))))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_131797 (h0 : ring (add_comm_semigroup linarith.ineq)) : rank_condition (add_comm_semigroup linarith.ineq) := sorry --non-trivial
lemma new_lemma_131798 (h0 : ring (has_norm (random_gen linarith.comp_source))) : is_domain (has_norm (random_gen linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_131799 (h0 : topological_space (ring (has_add (ring (ring (ring Type)))))) : sequential_space (ring (has_add (ring (ring (ring Type))))) := sorry --non-trivial
lemma new_lemma_131800 (h1 : topological_space (complete_semilattice_Sup fun_info)) : path_connected_space (complete_semilattice_Sup fun_info) := sorry --non-trivial
lemma new_lemma_131801 (h0 : functor.add_const (add_monoid (has_bot unsigned)) empty) : @add_monoid.fg.{0} (has_bot.{0} unsigned) (@functor.add_const.run.{0 0} (add_monoid.{0} (has_bot.{0} unsigned)) empty h0)  := sorry --non-trivial
lemma new_lemma_131802 (h0 : add_monoid (has_Inf (has_neg Type))) : add_monoid.fg (has_Inf (has_neg Type)) := sorry --non-trivial
lemma new_lemma_131803 (h0 : add_group (complete_semilattice_Sup congr_arg_kind)) : is_add_cyclic (complete_semilattice_Sup congr_arg_kind) := sorry --non-trivial
lemma new_lemma_131804 (h0 : function.extfun Type topological_space) : @totally_separated_space.{0} (semigroup.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (semigroup.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_131805 (h0 : function.extfun (Type 1) complete_lattice) : @is_compactly_generated.{1} (canonically_linear_ordered_monoid.{1} Type) (@function.extfun_app.{3 2} (Type 1) complete_lattice.{1} h0 (canonically_linear_ordered_monoid.{1} Type))  := sorry --non-trivial
lemma new_lemma_131806 (h0 : topological_space (has_to_string (has_neg (has_neg (ring (ring Type)))))) : topological_space.separable_space (has_to_string (has_neg (has_neg (ring (ring Type))))) := sorry --non-trivial
lemma new_lemma_131807 (h0 : functor.add_const (ordered_add_comm_monoid (cancel_monoid ennreal)) num) : @archimedean.{0} (cancel_monoid.{0} ennreal) (@functor.add_const.run.{0 0} (ordered_add_comm_monoid.{0} (cancel_monoid.{0} ennreal)) num h0)  := sorry --non-trivial
lemma new_lemma_131808 (h0 : functor.add_const (finset (pseudo_metric_space empty)) unsigned) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_131809 (h0 : functor.add_const (topological_space name) empty) : @locally_compact_space.{0} name (@functor.add_const.run.{0 0} (topological_space.{0} name) empty h0)  := sorry --non-trivial
lemma new_lemma_131810 (h0 : set (measure_theory.measure_space reducibility_hints)) : set.finite h0 := sorry --non-trivial
lemma new_lemma_131811 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @add_monoid.fg.{0} (has_top.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type add_monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 add_monoid.{0}) (has_top.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_131812 (h1 : not (group (semi_normed_comm_ring to_additive.value_type) -> false)) : @is_cyclic.{0} (semi_normed_comm_ring.{0} to_additive.value_type) (@classical.by_contradiction'.{1} (group.{0} (semi_normed_comm_ring.{0} to_additive.value_type)) h1)  := sorry --non-trivial
lemma new_lemma_131813 (h0 : not (topological_space (has_div (mul_one_class enat)) -> false)) : @t0_space.{0} (has_div.{0} (mul_one_class.{0} enat)) (@classical.by_contradiction'.{1} (topological_space.{0} (has_div.{0} (mul_one_class.{0} enat))) h0)  := sorry --non-trivial
lemma new_lemma_131814 (h0 : functor.add_const (topological_space (has_to_string Type)) pos) : @sequential_space.{1} (has_to_string.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (has_to_string.{1} Type)) pos h0)  := sorry --non-trivial
lemma new_lemma_131815 (h0 : not (topological_space (has_nnnorm char) -> false)) : @path_connected_space.{0} (has_nnnorm.{0} char) (@classical.by_contradiction'.{1} (topological_space.{0} (has_nnnorm.{0} char)) h0)  := sorry --non-trivial
lemma new_lemma_131816 (h0 : functor.add_const (topological_space (ordered_ring num)) empty) : @path_connected_space.{0} (ordered_ring.{0} num) (@functor.add_const.run.{0 0} (topological_space.{0} (ordered_ring.{0} num)) empty h0)  := sorry --non-trivial
lemma new_lemma_131817 (h0 : not (function.extfun Type add_group -> false)) : @is_add_cyclic.{0} (topological_space.{0} fun_info) (@function.extfun_app.{2 1} Type add_group.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type add_group.{0}) h0) (topological_space.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_131818 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @t0_space.{0} (has_ssubset.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_ssubset.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_131819 (h0 : topological_space (normed_comm_ring (finset name))) : locally_compact_space (normed_comm_ring (finset name)) := sorry --non-trivial
lemma new_lemma_131820 (h0 : functor.add_const (topological_space (mul_zero_class pos)) (has_neg Type)) : @totally_separated_space.{0} (mul_zero_class.{0} pos) (@functor.add_const.run.{0 1} (topological_space.{0} (mul_zero_class.{0} pos)) (has_neg.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_131821 (h0 : not (function.extfun Type add_group -> false)) : @is_add_cyclic.{0} (mul_zero_class.{0} empty) (@function.extfun_app.{2 1} Type add_group.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type add_group.{0}) h0) (mul_zero_class.{0} empty))  := sorry --non-trivial
lemma new_lemma_131822 (h0 : group (simple_graph pos)) : is_simple_group (simple_graph pos) := sorry --non-trivial
lemma new_lemma_131823 (h0 : uniform_space (has_add (has_add (has_neg Type)))) : separated_space (has_add (has_add (has_neg Type))) := sorry --non-trivial
lemma new_lemma_131824 (h0 : topological_space (boolean_algebra real)) : preconnected_space (boolean_algebra real) := sorry --non-trivial
lemma new_lemma_131825 (h0 : functor.add_const (finset (has_Inf linarith.comp)) pos) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_131826 (h0 : fin has_zero.zero) : @sequential_space.{0} (boolean_algebra.{0} real) (@matrix.vec_empty.{0} (topological_space.{0} (boolean_algebra.{0} real)) h0)  := sorry --non-trivial
lemma new_lemma_131827 (h0 : complete_lattice (finset pos)) : complete_lattice.is_Sup_finite_compact (finset pos) := sorry --non-trivial
lemma new_lemma_131828 (h0 : function.extfun Type uniform_space) : @separated_space.{0} (cancel_monoid.{0} num) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (cancel_monoid.{0} num))  := sorry --non-trivial
lemma new_lemma_131829 (h0 : function.extfun (finset Type) (has_mem.mem (has_top linarith.comp_source))) : @rank_condition.{0} (has_top.{0} linarith.comp_source) (@finset.pi.empty.{1 0} Type ring.{0} (has_top.{0} linarith.comp_source) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (has_top.{0} linarith.comp_source)) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_131830 (h0 : group (normed_lattice_add_comm_group (has_add (has_add (has_add (has_add (has_add real))))))) : group.fg (normed_lattice_add_comm_group (has_add (has_add (has_add (has_add (has_add real)))))) := sorry --non-trivial
lemma new_lemma_131831 (h0 : functor.add_const (topological_space (generalized_boolean_algebra linarith.comp)) pos) : @t1_space.{0} (generalized_boolean_algebra.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (generalized_boolean_algebra.{0} linarith.comp)) pos h0)  := sorry --non-trivial
lemma new_lemma_131832 (h0 : filter (plift (semiring (semiring congr_arg_kind)))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_131833 (h0 : functor.add_const (group (ordered_comm_group empty)) empty) : @group.fg.{0} (ordered_comm_group.{0} empty) (@functor.add_const.run.{0 0} (group.{0} (ordered_comm_group.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_131834 (h0 : topological_space (has_neg_part ennreal)) : totally_disconnected_space (has_neg_part ennreal) := sorry --non-trivial
lemma new_lemma_131835 (h0 : topological_space (add_right_cancel_monoid (metric_space num))) : discrete_topology (add_right_cancel_monoid (metric_space num)) := sorry --non-trivial
lemma new_lemma_131836 (h0 : functor.add_const (topological_space (has_nndist Type)) (has_neg pos)) : @discrete_topology.{1} (has_nndist.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (has_nndist.{1} Type)) (has_neg.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_131837 (h0 : topological_space (option pos)) : irreducible_space (option pos) := sorry --non-trivial
lemma new_lemma_131838 (h0 : ring (has_lt (mul_one_class (mul_one_class (mul_one_class (mul_one_class char)))))) : strong_rank_condition (has_lt (mul_one_class (mul_one_class (mul_one_class (mul_one_class char))))) := sorry --non-trivial
lemma new_lemma_131839 (h0 : ring (sub_neg_monoid linarith.comp)) : rank_condition (sub_neg_monoid linarith.comp) := sorry --non-trivial
lemma new_lemma_131840 (h0 : ring (generalized_boolean_algebra (ring (has_Inf linarith.comp)))) : is_domain (generalized_boolean_algebra (ring (has_Inf linarith.comp))) := sorry --non-trivial
lemma new_lemma_131841 (h0 : functor.add_const (topological_space (add_cancel_monoid unsigned)) (option pos)) : @normal_space.{0} (add_cancel_monoid.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (add_cancel_monoid.{0} unsigned)) (option.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_131842 (h0 : topological_space (comm_ring (random_gen to_additive.value_type))) : totally_disconnected_space (comm_ring (random_gen to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_131843 (h0 : function.extfun Type topological_space) : @topological_space.separable_space.{0} (has_Inf.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_Inf.{0} name))  := sorry --non-trivial
lemma new_lemma_131844 (h0 : topological_space (has_add (has_add real))) : irreducible_space (has_add (has_add real)) := sorry --non-trivial
lemma new_lemma_131845 (h0 : not (topological_space (random_gen (has_nnnorm linarith.ineq)) -> false)) : @path_connected_space.{0} (random_gen.{0} (has_nnnorm.{0} linarith.ineq)) (@classical.by_contradiction'.{1} (topological_space.{0} (random_gen.{0} (has_nnnorm.{0} linarith.ineq))) h0)  := sorry --non-trivial
lemma new_lemma_131846 (h0 : set (semi_normed_ring enat)) : set.subsingleton h0 := sorry --non-trivial
lemma new_lemma_131847 (h0 : monoid (complete_semilattice_Sup (random_gen (comm_ring (random_gen string_imp))))) : monoid.fg (complete_semilattice_Sup (random_gen (comm_ring (random_gen string_imp)))) := sorry --non-trivial
lemma new_lemma_131848 (h0 : functor.add_const (group (has_neg name)) linarith.comp) : @is_simple_group.{0} (has_neg.{0} name) (@functor.add_const.run.{0 0} (group.{0} (has_neg.{0} name)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_131849 (h0 : function.extfun Type filter) : countable_Inter_filter (function.extfun_app h0 (ring name)) := sorry --non-trivial
lemma new_lemma_131850 (h0 : topological_space (has_zero (finset name))) : preirreducible_space (has_zero (finset name)) := sorry --non-trivial
lemma new_lemma_131851 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @complete_lattice.is_Sup_finite_compact.{0} (has_nndist.{0} name) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (has_nndist.{0} name))  := sorry --non-trivial
lemma new_lemma_131852 (h0 : topological_space (normed_group (has_top fun_info))) : path_connected_space (normed_group (has_top fun_info)) := sorry --non-trivial
lemma new_lemma_131853 (h0 : group (with_bot (semiring num))) : normalizer_condition (with_bot (semiring num)) := sorry --non-trivial
lemma new_lemma_131854 (h3 : ring (semi_normed_comm_ring string_imp)) : strong_rank_condition (semi_normed_comm_ring string_imp) := sorry --non-trivial
lemma new_lemma_131855 (h0 : function.extfun Type group) : @normalizer_condition.{0} (with_one.{0} (random_gen.{0} linarith.comp_source)) (@function.extfun_app.{2 1} Type group.{0} h0 (with_one.{0} (random_gen.{0} linarith.comp_source)))  := sorry --non-trivial
lemma new_lemma_131856 (h0 : functor.add_const (topological_space Type) pos) : @normal_space.{1} Type (@functor.add_const.run.{1 0} (topological_space.{1} Type) pos h0)  := sorry --non-trivial
lemma new_lemma_131857 (h0 : function.extfun (finset Type) (has_mem.mem (random_gen num))) : @locally_compact_space.{0} (random_gen.{0} num) (@finset.pi.empty.{1 0} Type topological_space.{0} (random_gen.{0} num) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (random_gen.{0} num)) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_131858 (h0 : function.extfun Type topological_space) : @totally_separated_space.{0} (random_gen.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (random_gen.{0} empty))  := sorry --non-trivial
lemma new_lemma_131859 (h0 : topological_space (complete_distrib_lattice (generalized_boolean_algebra pos))) : t1_space (complete_distrib_lattice (generalized_boolean_algebra pos)) := sorry --non-trivial
lemma new_lemma_131860 (h0 : ring (distrib (has_nnnorm (has_nnnorm (has_nnnorm (has_lt linarith.ineq)))))) : strong_rank_condition (distrib (has_nnnorm (has_nnnorm (has_nnnorm (has_lt linarith.ineq))))) := sorry --non-trivial
lemma new_lemma_131861 (h1 : ring (nondiscrete_normed_field environment.projection_info)) : strong_rank_condition (nondiscrete_normed_field environment.projection_info) := sorry --non-trivial
lemma new_lemma_131862 (h0 : filter (has_ssubset (has_nnnorm linarith.ineq))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_131863 (h0 : functor.add_const (uniform_space (has_to_string Type)) linarith.comp) : @complete_space.{1} (has_to_string.{1} Type) (@functor.add_const.run.{1 0} (uniform_space.{1} (has_to_string.{1} Type)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_131864 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_cyclic.{0} (complete_semilattice_Sup.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (complete_semilattice_Sup.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_131865 (h0 : functor.add_const (topological_space (has_pos_part name)) Type) : @path_connected_space.{0} (has_pos_part.{0} name) (@functor.add_const.run.{0 1} (topological_space.{0} (has_pos_part.{0} name)) Type h0)  := sorry --non-trivial
lemma new_lemma_131866 (h0 : uniform_space (normed_group (semiring (semiring fun_info)))) : complete_space (normed_group (semiring (semiring fun_info))) := sorry --non-trivial
lemma new_lemma_131867 (h0 : list (dlist linarith.ineq)) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_131868 (h0 : finset (has_nndist (option (option unsigned)))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_131869 (h1 : preorder (add_comm_semigroup (add_comm_semigroup enat))) (h2 : set (add_comm_semigroup (add_comm_semigroup enat))) : set.is_pwo h2 := sorry --non-trivial
lemma new_lemma_131870 (h0 : group (has_ssubset (random_gen (random_gen to_additive.value_type)))) : is_cyclic (has_ssubset (random_gen (random_gen to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_131871 (h0 : topological_space (semi_normed_ring (linear_ordered_comm_group (add_left_cancel_semigroup char)))) : t0_space (semi_normed_ring (linear_ordered_comm_group (add_left_cancel_semigroup char))) := sorry --non-trivial
lemma new_lemma_131872 (h0 : functor.add_const (ordered_add_comm_monoid (add_cancel_monoid pos)) (has_neg pos)) : @archimedean.{0} (add_cancel_monoid.{0} pos) (@functor.add_const.run.{0 0} (ordered_add_comm_monoid.{0} (add_cancel_monoid.{0} pos)) (has_neg.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_131873 (h0 : complete_lattice (semigroup (measurable_space (has_zero name)))) : complete_lattice.is_Sup_finite_compact (semigroup (measurable_space (has_zero name))) := sorry --non-trivial
lemma new_lemma_131874 (h0 : topological_space (boolean_algebra.core (comm_group (comm_group name)))) : locally_compact_space (boolean_algebra.core (comm_group (comm_group name))) := sorry --non-trivial
lemma new_lemma_131875 (h0 : not (function.extfun (Type -> Type) (function.extfun Type) -> false)) : @path_connected_space.{0} (with_one.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) (@classical.by_contradiction'.{2} (function.extfun.{2 2} (Type → Type) (function.extfun.{2 1} Type)) h0) topological_space.{0}) (with_one.{0} empty))  := sorry --non-trivial
lemma new_lemma_131876 (h0 : functor.add_const (uniform_space ennreal) (option ennreal) -> Prop) (h1 : Exists (fun (x : functor.add_const (uniform_space ennreal) (option ennreal)), h0 x)) : @separated_space.{0} ennreal (@functor.add_const.run.{0 0} (uniform_space.{0} ennreal) (option.{0} ennreal) (@classical.some.{1} (functor.add_const.{0 0} (uniform_space.{0} ennreal) (option.{0} ennreal)) h0 h1))  := sorry --non-trivial
lemma new_lemma_131877 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @totally_separated_space.{0} (boolean_algebra.core.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (boolean_algebra.core.{0} pos))  := sorry --non-trivial
lemma new_lemma_131878 (h0 : not (has_mem.mem (semiring linarith.ineq) has_emptyc.emptyc -> false)) : @totally_separated_space.{0} (semiring.{0} linarith.ineq) (@finset.pi.empty.{1 0} Type topological_space.{0} (semiring.{0} linarith.ineq) (@classical.by_contradiction'.{0} (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (semiring.{0} linarith.ineq) (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))) h0))  := sorry --non-trivial
lemma new_lemma_131879 (h0 : filter (has_one linarith.comp)) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_131880 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_principal_ideal_ring.{0} (complete_linear_order.{0} unsigned) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (complete_linear_order.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_131881 (h0 : topological_space (normed_comm_ring congr_arg_kind)) : loc_path_connected_space (normed_comm_ring congr_arg_kind) := sorry --non-trivial
lemma new_lemma_131882 (h0 : uniform_space (with_one (with_one linarith.comp_source))) : complete_space (with_one (with_one linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_131883 (h0 : functor.add_const (functor.add_const (topological_space (add_left_cancel_semigroup empty)) num) congr_arg_kind) : @loc_path_connected_space.{0} (add_left_cancel_semigroup.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (add_left_cancel_semigroup.{0} empty)) num (@functor.add_const.run.{0 0} (functor.add_const.{0 0} (topological_space.{0} (add_left_cancel_semigroup.{0} empty)) num) congr_arg_kind h0))  := sorry --non-trivial
lemma new_lemma_131884 (h0 : topological_space (has_zero (has_add (finset environment.implicit_infer_kind)))) : totally_disconnected_space (has_zero (has_add (finset environment.implicit_infer_kind))) := sorry --non-trivial
lemma new_lemma_131885 (h0 : uniform_space (normed_comm_ring (ring Type))) : complete_space (normed_comm_ring (ring Type)) := sorry --non-trivial
lemma new_lemma_131886 (h0 : function.extfun Type semiring) : @is_noetherian_ring.{0} (canonically_ordered_add_monoid.{0} empty) (@function.extfun_app.{2 1} Type semiring.{0} h0 (canonically_ordered_add_monoid.{0} empty))  := sorry --non-trivial
lemma new_lemma_131887 (h0 : filter (monoid_with_zero name)) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_131888 (h1 : nat) (h2 : not (filter (array h1 string_imp) -> false)) : filter.ne_bot (classical.by_contradiction' h2) := sorry --non-trivial
lemma new_lemma_131889 (h0 : functor.add_const (function.extfun Type group) name) : @normalizer_condition.{0} (simple_graph.{0} linarith.comp) (@function.extfun_app.{2 1} Type group.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type group.{0}) name h0) (simple_graph.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_131890 (h0 : add_group (comm_monoid empty)) (h1 : add_subgroup (comm_monoid empty)) : add_subgroup.normal h1 := sorry --non-trivial
lemma new_lemma_131891 (h0 : topological_space (ring (boolean_algebra linarith.comp))) : t1_space (ring (boolean_algebra linarith.comp)) := sorry --non-trivial
lemma new_lemma_131892 (h0 : functor.add_const (ring (is_R_or_C num)) congr_arg_kind) : @is_domain.{0} (is_R_or_C.{0} num) (@functor.add_const.run.{0 0} (ring.{0} (is_R_or_C.{0} num)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_131893 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @totally_disconnected_space.{0} (has_norm.{0} string_imp) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_norm.{0} string_imp))  := sorry --non-trivial
lemma new_lemma_131894 (h0 : functor.add_const (topological_space (has_add Type)) pos) : @regular_space.{1} (has_add.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (has_add.{1} Type)) pos h0)  := sorry --non-trivial
lemma new_lemma_131895 (h0 : nat) (h1 : fin h0) (h2 : ordered_semiring Prop) (h3 : fintype (fin h0)) : std_simplex Prop (fin h0) (fin.lt h1) := sorry --non-trivial
lemma new_lemma_131896 (h0 : topological_space (semi_normed_comm_ring std_gen)) (h1 : add_group (semi_normed_comm_ring std_gen)) : topological_add_group (semi_normed_comm_ring std_gen) := sorry --non-trivial
lemma new_lemma_131897 (h0 : topological_space (semigroup (option empty))) : t1_space (semigroup (option empty)) := sorry --non-trivial
lemma new_lemma_131898 (h0 : functor.add_const (complete_lattice (normed_comm_ring ennreal)) ennreal) : @is_atomistic.{0} (normed_comm_ring.{0} ennreal) (@functor.add_const.run.{0 0} (complete_lattice.{0} (normed_comm_ring.{0} ennreal)) ennreal h0)  := sorry --non-trivial
lemma new_lemma_131899 (h0 : has_mem.mem complete_lattice has_emptyc.emptyc) : @is_compactly_generated.{0} empty (@function.extfun_app.{2 1} Type complete_lattice.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) complete_lattice.{0} h0) empty)  := sorry --non-trivial
lemma new_lemma_131900 (h0 : functor.comp filter canonically_ordered_comm_semiring Type) : countable_Inter_filter (functor.comp.run h0) := sorry --non-trivial
lemma new_lemma_131901 (h0 : functor.add_const (function.extfun Type finset) Type) : finset.nonempty (function.extfun_app (functor.add_const.run h0) (has_zero pos)) := sorry --non-trivial
lemma new_lemma_131902 (h0 : complete_lattice (has_pos_part (is_R_or_C pos))) : complete_lattice.is_Sup_finite_compact (has_pos_part (is_R_or_C pos)) := sorry --non-trivial
lemma new_lemma_131903 (h0 : functor.add_const (topological_space (has_zero environment.implicit_infer_kind)) pos) : @t0_space.{0} (has_zero.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (has_zero.{0} environment.implicit_infer_kind)) pos h0)  := sorry --non-trivial
lemma new_lemma_131904 (h0 : functor.add_const (function.extfun (Type 1) ring) (has_add (has_add Type))) : @is_domain.{1} (normed_comm_ring.{1} Type) (@function.extfun_app.{3 2} (Type 1) ring.{1} (@functor.add_const.run.{2 1} (function.extfun.{3 2} (Type 1) ring.{1}) (has_add.{1} (has_add.{1} Type)) h0) (normed_comm_ring.{1} Type))  := sorry --non-trivial
lemma new_lemma_131905 (h0 : has_top (with_bot linarith.ineq) -> Prop) : Exists h0 := sorry --non-trivial
lemma new_lemma_131906 (h0 : topological_space (has_to_string unsigned)) : t0_space (has_to_string unsigned) := sorry --non-trivial
lemma new_lemma_131907 (h0 : function.extfun Type list) : palindrome (function.extfun_app h0 (has_Sup (option empty))) := sorry --non-trivial
lemma new_lemma_131908 (h0 : uniform_space string_imp) : complete_space string_imp := sorry --non-trivial
lemma new_lemma_131909 (h0 : semiring (semiring (has_norm num))) : is_noetherian_ring (semiring (has_norm num)) := sorry --non-trivial
lemma new_lemma_131910 (h0 : uniform_space (measurable_space (semiring (semiring (semiring congr_arg_kind))))) : complete_space (measurable_space (semiring (semiring (semiring congr_arg_kind)))) := sorry --non-trivial
lemma new_lemma_131911 (h0 : function.extfun Type monoid) : @monoid.fg.{0} (random_gen.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type monoid.{0} h0 (random_gen.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_131912 (h0 : functor.add_const (function.extfun Type topological_space) environment.implicit_infer_kind) : @preconnected_space.{0} (normed_comm_ring.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) environment.implicit_infer_kind h0) (normed_comm_ring.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_131913 (h0 : fin has_zero.zero) : @ulower.up.{0} Prop encodable.Prop (@matrix.vec_empty.{0} (@ulower.{0} Prop encodable.Prop) (@empty.elim.{1} (fin (@has_zero.zero.{0} nat nat.has_zero)) (@matrix.vec_empty.{0} empty h0)))  := sorry --non-trivial
lemma new_lemma_131914 (h0 : functor.add_const (add_monoid (boolean_algebra pos)) pos) : @add_monoid.fg.{0} (boolean_algebra.{0} pos) (@functor.add_const.run.{0 0} (add_monoid.{0} (boolean_algebra.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_131915 (h0 : functor.add_const (topological_space (add_comm_monoid Type)) linarith.comp) : @locally_compact_space.{1} (add_comm_monoid.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (add_comm_monoid.{1} Type)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_131916 (h0 : ring (has_Inf (ring name))) : rank_condition (has_Inf (ring name)) := sorry --non-trivial
lemma new_lemma_131917 (h0 : topological_space (has_star (semiring empty))) : normal_space (has_star (semiring empty)) := sorry --non-trivial
lemma new_lemma_131918 (h0 : functor.add_const (topological_space (has_neg name)) Type) : @normal_space.{0} (has_neg.{0} name) (@functor.add_const.run.{0 1} (topological_space.{0} (has_neg.{0} name)) Type h0)  := sorry --non-trivial
lemma new_lemma_131919 (h0 : function.extfun Type ring) : @strong_rank_condition.{0} (with_one.{0} empty) (@function.extfun_app.{2 1} Type ring.{0} h0 (with_one.{0} empty))  := sorry --non-trivial
lemma new_lemma_131920 (h0 : group (has_to_string (has_add (add_left_cancel_monoid pos)))) : is_simple_group (has_to_string (has_add (add_left_cancel_monoid pos))) := sorry --non-trivial
lemma new_lemma_131921 (h0 : functor.add_const (topological_space (normed_linear_ordered_group unsigned)) empty) : @normal_space.{0} (normed_linear_ordered_group.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (normed_linear_ordered_group.{0} unsigned)) empty h0)  := sorry --non-trivial
lemma new_lemma_131922 (h0 : function.extfun Type complete_lattice) : @is_compactly_generated.{0} (complete_semilattice_Sup.{0} fun_info) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (complete_semilattice_Sup.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_131923 (h0 : not (topological_space (partial_order num) -> false)) : @totally_disconnected_space.{0} (partial_order.{0} num) (@classical.by_contradiction'.{1} (topological_space.{0} (partial_order.{0} num)) h0)  := sorry --non-trivial
lemma new_lemma_131924 (h0 : not (function.extfun Type ring -> false)) : @strong_rank_condition.{0} (has_top.{0} num) (@function.extfun_app.{2 1} Type ring.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type ring.{0}) h0) (has_top.{0} num))  := sorry --non-trivial
lemma new_lemma_131925 (h0 : group (add_comm_monoid (has_to_string (comm_group Type)))) : normalizer_condition (add_comm_monoid (has_to_string (comm_group Type))) := sorry --non-trivial
lemma new_lemma_131926 (h0 : functor.add_const (topological_space (finset name)) Type) : @preconnected_space.{0} (finset.{0} name) (@functor.add_const.run.{0 1} (topological_space.{0} (finset.{0} name)) Type h0)  := sorry --non-trivial
lemma new_lemma_131927 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @t1_space.{0} (comm_group.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (comm_group.{0} name))  := sorry --non-trivial
lemma new_lemma_131928 (h0 : functor.add_const (topological_space (mul_zero_class num)) empty) : @irreducible_space.{0} (mul_zero_class.{0} num) (@functor.add_const.run.{0 0} (topological_space.{0} (mul_zero_class.{0} num)) empty h0)  := sorry --non-trivial
lemma new_lemma_131929 (h0 : uniform_space (normed_comm_ring pos)) : separated_space (normed_comm_ring pos) := sorry --non-trivial
lemma new_lemma_131930 (h0 : ring (measurable_space (semiring (semiring (has_norm congr_arg_kind))))) : is_domain (measurable_space (semiring (semiring (has_norm congr_arg_kind)))) := sorry --non-trivial
lemma new_lemma_131931 (h0 : ring (left_cancel_monoid (option (option empty)))) : strong_rank_condition (left_cancel_monoid (option (option empty))) := sorry --non-trivial
lemma new_lemma_131932 (h0 : function.extfun Type topological_space) : @preirreducible_space.{0} (simple_graph.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (simple_graph.{0} pos))  := sorry --non-trivial
lemma new_lemma_131933 (h0 : functor.add_const (group (add_cancel_monoid pos)) (finset Type)) : @normalizer_condition.{0} (add_cancel_monoid.{0} pos) (@functor.add_const.run.{0 1} (group.{0} (add_cancel_monoid.{0} pos)) (finset.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_131934 (h0 : ring (canonically_ordered_monoid pos)) : is_principal_ideal_ring (canonically_ordered_monoid pos) := sorry --non-trivial
lemma new_lemma_131935 (h0 : ring (boolean_algebra (has_add (has_add (has_add environment.implicit_infer_kind))))) : rank_condition (boolean_algebra (has_add (has_add (has_add environment.implicit_infer_kind)))) := sorry --non-trivial
lemma new_lemma_131936 (h0 : function.extfun Type ring) : @is_domain.{0} (normed_comm_ring.{0} (option.{0} ennreal)) (@function.extfun_app.{2 1} Type ring.{0} h0 (normed_comm_ring.{0} (option.{0} ennreal)))  := sorry --non-trivial
lemma new_lemma_131937 (h0 : function.extfun ((Type -> Type) -> Type 1) (function.extfun (Type -> Type))) : @complete_space.{0} (has_emptyc.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type uniform_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) (@function.extfun_app.{3 2} ((Type → Type) → Type 1) (function.extfun.{2 2} (Type → Type)) h0 (function.extfun.{2 1} Type)) uniform_space.{0}) (has_emptyc.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_131938 (h0 : ring (has_nnnorm (mul_one_class (mul_one_class reducibility_hints)))) : strong_rank_condition (has_nnnorm (mul_one_class (mul_one_class reducibility_hints))) := sorry --non-trivial
lemma new_lemma_131939 (h0 : functor.add_const (monoid (ring name)) linarith.comp) : @monoid.fg.{0} (ring.{0} name) (@functor.add_const.run.{0 0} (monoid.{0} (ring.{0} name)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_131940 (h0 : function.extfun Type topological_space) : @t1_space.{0} (mul_zero_class.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (mul_zero_class.{0} pos))  := sorry --non-trivial
lemma new_lemma_131941 (h0 : ordered_add_comm_monoid (semigroup (option (option unsigned)))) : archimedean (semigroup (option (option unsigned))) := sorry --non-trivial
lemma new_lemma_131942 (h0 : not (finset nnreal -> false)) : finset.nonempty (classical.by_contradiction' h0) := sorry --non-trivial
lemma new_lemma_131943 (h0 : not (function.extfun Type topological_space -> false)) : @normal_space.{0} (has_union.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (has_union.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_131944 (h0 : cancel_comm_monoid_with_zero (comm_group linarith.comp)) : unique_factorization_monoid (comm_group linarith.comp) := sorry --non-trivial
lemma new_lemma_131945 (h0 : functor.add_const (topological_space (pseudo_metric_space unsigned)) unsigned) : @discrete_topology.{0} (pseudo_metric_space.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (pseudo_metric_space.{0} unsigned)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_131946 (h0 : function.extfun (((Type -> Type) -> Type 1) -> Type 1) (function.extfun ((Type -> Type) -> Type 1))) : @is_add_cyclic.{0} (random_gen.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type add_group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) (@function.extfun_app.{3 2} ((Type → Type) → Type 1) (function.extfun.{2 2} (Type → Type)) (@function.extfun_app.{3 3} (((Type → Type) → Type 1) → Type 1) (function.extfun.{3 2} ((Type → Type) → Type 1)) h0 (function.extfun.{2 2} (Type → Type))) (function.extfun.{2 1} Type)) add_group.{0}) (random_gen.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_131947 (h0 : ring (semigroup (has_to_string environment.implicit_infer_kind))) : rank_condition (semigroup (has_to_string environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_131948 (h0 : topological_space (left_cancel_semigroup (semiring empty))) : irreducible_space (left_cancel_semigroup (semiring empty)) := sorry --non-trivial
lemma new_lemma_131949 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_simple_group.{0} (has_add.{0} pos) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (has_add.{0} pos))  := sorry --non-trivial
lemma new_lemma_131950 (h0 : fin has_zero.zero) : @separated_space.{0} (ordered_comm_ring.{0} linarith.comp) (@function.extfun_app.{2 1} Type uniform_space.{0} (@matrix.vec_empty.{1} (function.extfun.{2 1} Type uniform_space.{0}) h0) (ordered_comm_ring.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_131951 (h0 : function.extfun ((Type -> Type) -> Type 1) (function.extfun (Type -> Type))) : @totally_disconnected_space.{0} (has_norm.{0} linarith.ineq) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) (@function.extfun_app.{3 2} ((Type → Type) → Type 1) (function.extfun.{2 2} (Type → Type)) h0 (function.extfun.{2 1} Type)) topological_space.{0}) (has_norm.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_131952 (h0 : function.extfun Type group) : @normalizer_condition.{0} (distrib_lattice.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type group.{0} h0 (distrib_lattice.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_131953 (h0 : functor.add_const (group (preorder empty)) (option (option empty))) : @normalizer_condition.{0} (preorder.{0} empty) (@functor.add_const.run.{0 0} (group.{0} (preorder.{0} empty)) (option.{0} (option.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_131954 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @complete_lattice.is_Sup_finite_compact.{0} (has_emptyc.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (has_emptyc.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_131955 (h0 : complete_lattice (simple_graph (has_Inf name))) : is_compactly_generated (simple_graph (has_Inf name)) := sorry --non-trivial
lemma new_lemma_131956 (h1 : group (has_norm num)) : group.fg (has_norm num) := sorry --non-trivial
lemma new_lemma_131957 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @t0_space.{0} (bin_tree.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (bin_tree.{0} empty))  := sorry --non-trivial
lemma new_lemma_131958 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_noetherian_ring.{0} (complete_linear_order.{0} empty) (@function.extfun_app.{2 1} Type semiring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 semiring.{0}) (complete_linear_order.{0} empty))  := sorry --non-trivial
lemma new_lemma_131959 (h0 : function.extfun (finset Type) (has_mem.mem (semiring to_additive.value_type))) : @rank_condition.{0} (semiring.{0} to_additive.value_type) (@finset.pi.empty.{1 0} Type ring.{0} (semiring.{0} to_additive.value_type) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (semiring.{0} to_additive.value_type)) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_131960 (h0 : topological_space (comm_group (boolean_algebra.core environment.implicit_infer_kind))) : sequential_space (comm_group (boolean_algebra.core environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_131961 (h0 : topological_space (preorder unsigned)) : totally_disconnected_space (preorder unsigned) := sorry --non-trivial
lemma new_lemma_131962 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_add_cyclic.{0} (with_bot.{0} fun_info) (@function.extfun_app.{2 1} Type add_group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 add_group.{0}) (with_bot.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_131963 (h0 : ring (measurable_space.dynkin_system empty)) : rank_condition (measurable_space.dynkin_system empty) := sorry --non-trivial
lemma new_lemma_131964 (h1 : group (metric_space char)) : is_cyclic (metric_space char) := sorry --non-trivial
lemma new_lemma_131965 (h0 : function.extfun Type uniform_space) : @complete_space.{0} (has_dist.{0} num) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (has_dist.{0} num))  := sorry --non-trivial
lemma new_lemma_131966 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @totally_separated_space.{0} (has_bot.{0} real) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_bot.{0} real))  := sorry --non-trivial
lemma new_lemma_131967 (h0 : topological_space (normed_comm_ring (ring linarith.comp))) : preconnected_space (normed_comm_ring (ring linarith.comp)) := sorry --non-trivial
lemma new_lemma_131968 (h0 : semiring (linear_ordered_add_comm_monoid_with_top num)) : is_noetherian_ring (linear_ordered_add_comm_monoid_with_top num) := sorry --non-trivial
lemma new_lemma_131969 (h0 : bin_tree (semiring num) -> bin_tree (semiring num) -> bin_tree (semiring num)) : is_idempotent (bin_tree (semiring num)) h0 := sorry --non-trivial
lemma new_lemma_131970 (h0 : complete_lattice (has_zero (has_nndist name))) : complete_lattice.is_Sup_finite_compact (has_zero (has_nndist name)) := sorry --non-trivial
lemma new_lemma_131971 (h0 : functor.add_const (complete_lattice (cancel_monoid unsigned)) unsigned) : @is_compactly_generated.{0} (cancel_monoid.{0} unsigned) (@functor.add_const.run.{0 0} (complete_lattice.{0} (cancel_monoid.{0} unsigned)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_131972 (h0 : topological_space (normed_comm_ring name)) : preconnected_space (normed_comm_ring name) := sorry --non-trivial
lemma new_lemma_131973 (h0 : not (complete_lattice (metric_space to_additive.value_type) -> false)) : @complete_lattice.is_Sup_finite_compact.{0} (metric_space.{0} to_additive.value_type) (@classical.by_contradiction'.{1} (complete_lattice.{0} (metric_space.{0} to_additive.value_type)) h0)  := sorry --non-trivial
lemma new_lemma_131974 (h0 : complete_lattice (has_compl (random_gen (random_gen linarith.ineq)))) : complete_lattice.is_Sup_finite_compact (has_compl (random_gen (random_gen linarith.ineq))) := sorry --non-trivial
lemma new_lemma_131975 (h0 : topological_space (ring (normed_linear_ordered_group pos))) : sequential_space (ring (normed_linear_ordered_group pos)) := sorry --non-trivial
lemma new_lemma_131976 (h0 : uniform_space (option unsigned)) : complete_space (option unsigned) := sorry --non-trivial
lemma new_lemma_131977 (h0 : topological_space (random_gen reducibility_hints)) : totally_disconnected_space (random_gen reducibility_hints) := sorry --non-trivial
lemma new_lemma_131978 (h0 : group (has_one empty)) : group.fg (has_one empty) := sorry --non-trivial
lemma new_lemma_131979 (h1 : uniform_space (has_ssubset linarith.ineq)) : complete_space (has_ssubset linarith.ineq) := sorry --non-trivial
lemma new_lemma_131980 (h0 : group (simple_graph num)) : normalizer_condition (simple_graph num) := sorry --non-trivial
lemma new_lemma_131981 (h0 : ring (semigroup (ring (ring (has_neg (ring (add_semigroup (finset linarith.comp)))))))) : rank_condition (semigroup (ring (ring (has_neg (ring (add_semigroup (finset linarith.comp))))))) := sorry --non-trivial
lemma new_lemma_131982 (h0 : functor.add_const (monoid (normed_comm_ring ennreal)) pos) : @monoid.fg.{0} (normed_comm_ring.{0} ennreal) (@functor.add_const.run.{0 0} (monoid.{0} (normed_comm_ring.{0} ennreal)) pos h0)  := sorry --non-trivial
lemma new_lemma_131983 (h0 : group (has_union (semiring (has_norm congr_arg_kind)))) : group.fg (has_union (semiring (has_norm congr_arg_kind))) := sorry --non-trivial
lemma new_lemma_131984 (h0 : ordered_comm_monoid (option pos)) : has_exists_mul_of_le (option pos) := sorry --non-trivial
lemma new_lemma_131985 (h0 : ring (has_to_string (boolean_algebra.core name))) : is_principal_ideal_ring (has_to_string (boolean_algebra.core name)) := sorry --non-trivial
lemma new_lemma_131986 (h0 : complete_lattice (ring (has_neg_part Type))) : is_atomistic (ring (has_neg_part Type)) := sorry --non-trivial
lemma new_lemma_131987 (h0 : topological_space (finset (boolean_algebra.core environment.implicit_infer_kind))) : regular_space (finset (boolean_algebra.core environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_131988 (h0 : list (is_R_or_C (option (option unsigned)))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_131989 (h0 : add_monoid (add_group (semiring empty))) : add_monoid.fg (add_group (semiring empty)) := sorry --non-trivial
lemma new_lemma_131990 (h0 : list (id (with_bot to_additive.value_type))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_131991 (h0 : topological_space (ordered_comm_monoid (has_add Type))) : totally_separated_space (ordered_comm_monoid (has_add Type)) := sorry --non-trivial
lemma new_lemma_131992 (h0 : ring (has_norm (semiring (semiring congr_arg_kind)))) : is_principal_ideal_ring (has_norm (semiring (semiring congr_arg_kind))) := sorry --non-trivial
lemma new_lemma_131993 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @irreducible_space.{1} (has_pos_part.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 topological_space.{1}) (has_pos_part.{1} Type))  := sorry --non-trivial
lemma new_lemma_131994 (h0 : functor.add_const (ring (has_neg environment.implicit_infer_kind)) Type) : @is_principal_ideal_ring.{0} (has_neg.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 1} (ring.{0} (has_neg.{0} environment.implicit_infer_kind)) Type h0)  := sorry --non-trivial
lemma new_lemma_131995 (h0 : topological_space (has_norm (random_gen (has_norm fun_info)))) : locally_compact_space (has_norm (random_gen (has_norm fun_info))) := sorry --non-trivial
lemma new_lemma_131996 (h0 : not (add_group (uniform_space (uniform_space (has_nnnorm (comm_ring linarith.comp_source)))) -> false)) : @is_add_cyclic.{0} (uniform_space.{0} (uniform_space.{0} (has_nnnorm.{0} (comm_ring.{0} linarith.comp_source)))) (@classical.by_contradiction'.{1} (add_group.{0} (uniform_space.{0} (uniform_space.{0} (has_nnnorm.{0} (comm_ring.{0} linarith.comp_source))))) h0)  := sorry --non-trivial
lemma new_lemma_131997 (h0 : topological_space (has_inner (option empty) empty)) : loc_path_connected_space (has_inner (option empty) empty) := sorry --non-trivial
lemma new_lemma_131998 (h0 : function.extfun Type topological_space) : @path_connected_space.{0} (measurable_space.dynkin_system.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (measurable_space.dynkin_system.{0} empty))  := sorry --non-trivial
lemma new_lemma_131999 (h0 : topological_space (has_to_string (option (option ennreal)))) : loc_path_connected_space (has_to_string (option (option ennreal))) := sorry --non-trivial
lemma new_lemma_132000 (h0 : topological_space (ordered_cancel_add_comm_monoid (option num))) : totally_disconnected_space (ordered_cancel_add_comm_monoid (option num)) := sorry --non-trivial
lemma new_lemma_132001 (h0 h1 : multiset (has_nnnorm ereal)) : multiset.subset h0 h1 := sorry --non-trivial
lemma new_lemma_132002 (h0 : function.extfun Type topological_space) : @t0_space.{0} (has_dist.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_dist.{0} empty))  := sorry --non-trivial
lemma new_lemma_132003 (h0 : functor.add_const (topological_space (has_nndist pos)) (add_cancel_monoid Type)) : @normal_space.{0} (has_nndist.{0} pos) (@functor.add_const.run.{0 1} (topological_space.{0} (has_nndist.{0} pos)) (add_cancel_monoid.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_132004 (h0 : functor.add_const (topological_space (ring pos)) (has_neg (has_neg Type))) : @preirreducible_space.{0} (ring.{0} pos) (@functor.add_const.run.{0 1} (topological_space.{0} (ring.{0} pos)) (has_neg.{1} (has_neg.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_132005 (h0 : functor.add_const (cancel_comm_monoid_with_zero (semigroup unsigned)) pos) : @unique_factorization_monoid.{0} (semigroup.{0} unsigned) (@functor.add_const.run.{0 0} (cancel_comm_monoid_with_zero.{0} (semigroup.{0} unsigned)) pos h0)  := sorry --non-trivial
lemma new_lemma_132006 (h0 : functor.add_const (topological_space (has_zero name)) (has_add name)) : @preirreducible_space.{0} (has_zero.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (has_zero.{0} name)) (has_add.{0} name) h0)  := sorry --non-trivial
lemma new_lemma_132007 (h1 : ring (simple_graph string_imp)) : strong_rank_condition (simple_graph string_imp) := sorry --non-trivial
lemma new_lemma_132008 (h0 : topological_space (finset (has_neg linarith.comp))) : locally_compact_space (finset (has_neg linarith.comp)) := sorry --non-trivial
lemma new_lemma_132009 (h0 : functor.add_const (complete_lattice (measurable_space.dynkin_system num)) num) : @is_compactly_generated.{0} (measurable_space.dynkin_system.{0} num) (@functor.add_const.run.{0 0} (complete_lattice.{0} (measurable_space.dynkin_system.{0} num)) num h0)  := sorry --non-trivial
lemma new_lemma_132010 (h0 : function.extfun Type complete_lattice) : @complete_lattice.is_Sup_finite_compact.{0} (linear_ordered_add_comm_group.{0} fun_info) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (linear_ordered_add_comm_group.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_132011 (h0 : function.extfun Type topological_space) : @t0_space.{0} (left_cancel_monoid.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (left_cancel_monoid.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_132012 (h0 : ring (preorder (semiring (semiring (semiring num))))) : is_principal_ideal_ring (preorder (semiring (semiring (semiring num)))) := sorry --non-trivial
lemma new_lemma_132013 (h0 : add_group (linear_ordered_comm_group_with_zero (mul_one_class (mul_one_class (has_le std_gen))))) : is_add_cyclic (linear_ordered_comm_group_with_zero (mul_one_class (mul_one_class (has_le std_gen)))) := sorry --non-trivial
lemma new_lemma_132014 (h0 : function.extfun Type topological_space) : @totally_disconnected_space.{0} (complete_semilattice_Sup.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (complete_semilattice_Sup.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_132015 (h0 : add_group (with_bot (semiring congr_arg_kind))) : is_add_cyclic (with_bot (semiring congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_132016 (h0 : functor.add_const (topological_space (has_to_string unsigned)) name) : @totally_disconnected_space.{0} (has_to_string.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (has_to_string.{0} unsigned)) name h0)  := sorry --non-trivial
lemma new_lemma_132017 (h0 : topological_space (ring (option unsigned))) : discrete_topology (ring (option unsigned)) := sorry --non-trivial
lemma new_lemma_132018 (h0 : functor.add_const (ordered_add_comm_monoid (ordered_comm_ring name)) (ring linarith.comp)) : @archimedean.{0} (ordered_comm_ring.{0} name) (@functor.add_const.run.{0 0} (ordered_add_comm_monoid.{0} (ordered_comm_ring.{0} name)) (ring.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_132019 (h0 : add_monoid (boolean_algebra (comm_group name))) : add_monoid.fg (boolean_algebra (comm_group name)) := sorry --non-trivial
lemma new_lemma_132020 (h0 : functor.add_const (topological_space (finset environment.implicit_infer_kind)) name) : @preirreducible_space.{0} (finset.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (finset.{0} environment.implicit_infer_kind)) name h0)  := sorry --non-trivial
lemma new_lemma_132021 (h0 : topological_space (complete_semilattice_Sup (has_norm to_additive.value_type))) : locally_compact_space (complete_semilattice_Sup (has_norm to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_132022 (h0 : functor.add_const (complete_lattice (add_semigroup empty)) empty) : @is_compactly_generated.{0} (add_semigroup.{0} empty) (@functor.add_const.run.{0 0} (complete_lattice.{0} (add_semigroup.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_132023 (h0 : functor.add_const (topological_space (has_Inf linarith.comp)) Type) : @loc_path_connected_space.{0} (has_Inf.{0} linarith.comp) (@functor.add_const.run.{0 1} (topological_space.{0} (has_Inf.{0} linarith.comp)) Type h0)  := sorry --non-trivial
lemma new_lemma_132024 (h0 : function.extfun (finset Type) (has_mem.mem (has_norm congr_arg_kind))) : @is_atomistic.{0} (has_norm.{0} congr_arg_kind) (@finset.pi.empty.{1 0} Type complete_lattice.{0} (has_norm.{0} congr_arg_kind) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (has_norm.{0} congr_arg_kind)) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_132025 (h0 : cancel_comm_monoid_with_zero (comm_group (has_neg (has_add (has_add (boolean_algebra.core Type)))))) : unique_factorization_monoid (comm_group (has_neg (has_add (has_add (boolean_algebra.core Type))))) := sorry --non-trivial
lemma new_lemma_132026 (h0 : topological_space (canonically_ordered_comm_semiring (has_neg_part ennreal))) : totally_separated_space (canonically_ordered_comm_semiring (has_neg_part ennreal)) := sorry --non-trivial
lemma new_lemma_132027 (h0 : functor.add_const (filter (add_comm_monoid name)) linarith.comp) : filter.ne_bot (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_132028 (h0 : filter (semigroup (has_to_string pos))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_132029 (h0 : functor.add_const (finset (complete_distrib_lattice linarith.comp)) name) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_132030 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @locally_compact_space.{0} (denumerable.{0} linarith.ineq) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (denumerable.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_132031 (h0 : not (group (add_cancel_comm_monoid string.iterator_imp) -> false)) : @is_cyclic.{0} (add_cancel_comm_monoid.{0} string.iterator_imp) (@classical.by_contradiction'.{1} (group.{0} (add_cancel_comm_monoid.{0} string.iterator_imp)) h0)  := sorry --non-trivial
lemma new_lemma_132032 (h0 : topological_space (comm_semigroup (sub_neg_monoid (has_add (has_pos_part Type))))) : topological_space.separable_space (comm_semigroup (sub_neg_monoid (has_add (has_pos_part Type)))) := sorry --non-trivial
lemma new_lemma_132033 (h0 : monoid (normed_group (metric_space (has_union (metric_space (has_union empty)))))) : monoid.fg (normed_group (metric_space (has_union (metric_space (has_union empty))))) := sorry --non-trivial
lemma new_lemma_132034 (h0 : list (has_Inf (has_add pos))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_132035 (h0 : topological_space (normed_comm_ring ennreal)) : loc_path_connected_space (normed_comm_ring ennreal) := sorry --non-trivial
lemma new_lemma_132036 (h0 : topological_space (has_nnnorm (has_ssubset linarith.comp_source))) : totally_disconnected_space (has_nnnorm (has_ssubset linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_132037 (h0 : functor.add_const (topological_space (add_semigroup empty)) empty) : @locally_compact_space.{0} (add_semigroup.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (add_semigroup.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_132038 (h0 : topological_space (has_add congr_arg_kind)) : locally_compact_space (has_add congr_arg_kind) := sorry --non-trivial
lemma new_lemma_132039 (h0 : topological_space (has_top (has_norm (has_norm num)))) : normal_space (has_top (has_norm (has_norm num))) := sorry --non-trivial
lemma new_lemma_132040 (h0 : topological_space (semiring (semiring empty))) : discrete_topology (semiring (semiring empty)) := sorry --non-trivial
lemma new_lemma_132041 (h0 : functor.add_const (ring (has_Inf pos)) (has_Inf (has_Inf Type))) : @strong_rank_condition.{0} (has_Inf.{0} pos) (@functor.add_const.run.{0 1} (ring.{0} (has_Inf.{0} pos)) (has_Inf.{1} (has_Inf.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_132042 (h0 : fin has_zero.zero) : @complete_lattice.is_Sup_finite_compact.{0} (complete_distrib_lattice.{0} real) (@matrix.vec_empty.{0} (complete_lattice.{0} (complete_distrib_lattice.{0} real)) h0)  := sorry --non-trivial
lemma new_lemma_132043 (h0 : add_monoid (boolean_algebra (semigroup unsigned))) : add_monoid.fg (boolean_algebra (semigroup unsigned)) := sorry --non-trivial
lemma new_lemma_132044 (h0 : group (has_nndist (boolean_algebra name))) : is_cyclic (has_nndist (boolean_algebra name)) := sorry --non-trivial
lemma new_lemma_132045 (h0 : topological_space (add_monoid (random_gen char))) : t0_space (add_monoid (random_gen char)) := sorry --non-trivial
lemma new_lemma_132046 (h0 : functor.add_const (complete_lattice (option pos)) pos) : @is_compactly_generated.{0} (option.{0} pos) (@functor.add_const.run.{0 0} (complete_lattice.{0} (option.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_132047 (h0 : list (ordered_comm_ring (has_nndist (has_nndist Type)))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_132048 (h0 : functor.add_const (ordered_add_comm_monoid (preorder unsigned)) unsigned) : @archimedean.{0} (preorder.{0} unsigned) (@functor.add_const.run.{0 0} (ordered_add_comm_monoid.{0} (preorder.{0} unsigned)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_132049 (h0 : functor.add_const (topological_space (add_cancel_monoid name)) linarith.comp) : @regular_space.{0} (add_cancel_monoid.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (add_cancel_monoid.{0} name)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_132050 (h0 : function.extfun Type uniform_space) : @separated_space.{0} (ring.{0} (option.{0} ennreal)) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (ring.{0} (option.{0} ennreal)))  := sorry --non-trivial
lemma new_lemma_132051 (h0 : topological_space (measurable_space (has_top (random_gen linarith.comp_source)))) : path_connected_space (measurable_space (has_top (random_gen linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_132052 (h0 : functor.add_const (add_group (linear_ordered_field Type)) (has_neg_part Type)) : @is_add_cyclic.{1} (linear_ordered_field.{1} Type) (@functor.add_const.run.{1 1} (add_group.{1} (linear_ordered_field.{1} Type)) (has_neg_part.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_132053 (h0 : topological_space ennreal) : totally_disconnected_space ennreal := sorry --non-trivial
lemma new_lemma_132054 (h1 : function.extfun (Type -> Type) (function.extfun Type)) : @is_add_cyclic.{0} string_imp (@function.extfun_app.{2 1} Type add_group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h1 add_group.{0}) string_imp)  := sorry --non-trivial
lemma new_lemma_132055 (h4 : prod enat enat) : set.diagonal enat h4 := sorry --non-trivial
lemma new_lemma_132056 (h0 : function.extfun Type ring) : @strong_rank_condition.{0} (add_comm_monoid.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type ring.{0} h0 (add_comm_monoid.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_132057 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @topological_space.separable_space.{0} (add_comm_monoid.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (add_comm_monoid.{0} pos))  := sorry --non-trivial
lemma new_lemma_132058 (h0 : topological_space (has_nndist (has_add (ring name)))) : t0_space (has_nndist (has_add (ring name))) := sorry --non-trivial
lemma new_lemma_132059 (h0 : filter (add_comm_monoid (has_neg_part (has_to_string unsigned)))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_132060 (h0 : functor.add_const (complete_lattice (option ennreal)) ennreal) : @is_compactly_generated.{0} (option.{0} ennreal) (@functor.add_const.run.{0 0} (complete_lattice.{0} (option.{0} ennreal)) ennreal h0)  := sorry --non-trivial
lemma new_lemma_132061 (h0 : function.extfun Type topological_space) : @sequential_space.{0} (boolean_algebra.core.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (boolean_algebra.core.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_132062 (h0 : functor.add_const (add_monoid (has_nndist Type)) (has_Inf linarith.comp)) : @add_monoid.fg.{1} (has_nndist.{1} Type) (@functor.add_const.run.{1 0} (add_monoid.{1} (has_nndist.{1} Type)) (has_Inf.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_132063 (h0 : ring (multiplicative environment.projection_info)) : rank_condition (multiplicative environment.projection_info) := sorry --non-trivial
lemma new_lemma_132064 (h0 : functor.add_const (finset (has_neg name)) linarith.comp) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_132065 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_principal_ideal_ring.{0} (filter.{0} empty) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (filter.{0} empty))  := sorry --non-trivial
lemma new_lemma_132066 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @t0_space.{0} (add_group.{0} (semiring.{0} linarith.comp)) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (add_group.{0} (semiring.{0} linarith.comp)))  := sorry --non-trivial
lemma new_lemma_132067 (h0 : not (topological_space (distrib char) -> false)) : @t0_space.{0} (distrib.{0} char) (@classical.by_contradiction'.{1} (topological_space.{0} (distrib.{0} char)) h0)  := sorry --non-trivial
lemma new_lemma_132068 (h0 : has_mem.mem (with_bot num) has_emptyc.emptyc) : @monoid.fg.{0} (with_bot.{0} num) (@finset.pi.empty.{1 0} Type monoid.{0} (with_bot.{0} num) h0)  := sorry --non-trivial
lemma new_lemma_132069 (h0 : function.extfun Type topological_space) : @normal_space.{0} (group_with_zero.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (group_with_zero.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_132070 (h1 : topological_space (semi_normed_ring char)) : totally_disconnected_space (semi_normed_ring char) := sorry --non-trivial
lemma new_lemma_132071 (h0 : topological_space (has_zero (has_add pos))) : loc_path_connected_space (has_zero (has_add pos)) := sorry --non-trivial
lemma new_lemma_132072 (h0 : function.extfun Type complete_lattice) : @is_compactly_generated.{0} (add_comm_monoid.{0} (option.{0} ennreal)) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (add_comm_monoid.{0} (option.{0} ennreal)))  := sorry --non-trivial
lemma new_lemma_132073 (h0 : topological_space (complete_distrib_lattice (option (option empty)))) : t1_space (complete_distrib_lattice (option (option empty))) := sorry --non-trivial
lemma new_lemma_132074 (h1 : topological_space (add_comm_semigroup std_gen)) (h2 : preorder (add_comm_semigroup std_gen)) : order_closed_topology (add_comm_semigroup std_gen) := sorry --non-trivial
lemma new_lemma_132075 (h0 : add_group (ring environment.implicit_infer_kind)) : is_add_cyclic (ring environment.implicit_infer_kind) := sorry --non-trivial
lemma new_lemma_132076 (h0 : topological_space (normed_field environment.projection_info)) : totally_disconnected_space (normed_field environment.projection_info) := sorry --non-trivial
lemma new_lemma_132077 (h0 : topological_space (ordered_cancel_add_comm_monoid (option unsigned))) : irreducible_space (ordered_cancel_add_comm_monoid (option unsigned)) := sorry --non-trivial
lemma new_lemma_132078 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @t1_space.{0} (add_cancel_comm_monoid.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (add_cancel_comm_monoid.{0} empty))  := sorry --non-trivial
lemma new_lemma_132079 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @sequential_space.{0} (semigroup.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (semigroup.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_132080 (h0 : functor.add_const (ordered_add_comm_monoid (ordered_comm_ring linarith.comp)) (has_Inf (has_add Type))) : @archimedean.{0} (ordered_comm_ring.{0} linarith.comp) (@functor.add_const.run.{0 1} (ordered_add_comm_monoid.{0} (ordered_comm_ring.{0} linarith.comp)) (has_Inf.{1} (has_add.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_132081 (h0 : functor.add_const (topological_space (ordered_comm_group empty)) empty) : @totally_separated_space.{0} (ordered_comm_group.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (ordered_comm_group.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_132082 (h0 : topological_space (normed_comm_ring (option (option ennreal)))) : t0_space (normed_comm_ring (option (option ennreal))) := sorry --non-trivial
lemma new_lemma_132083 (h0 : topological_space (ring (has_neg_part name))) : t0_space (ring (has_neg_part name)) := sorry --non-trivial
lemma new_lemma_132084 (h0 : topological_space (has_bot (has_add real))) : path_connected_space (has_bot (has_add real)) := sorry --non-trivial
lemma new_lemma_132085 (h0 : complete_lattice (has_pos_part (comm_semigroup (has_add (sub_neg_monoid real))))) : is_atomistic (has_pos_part (comm_semigroup (has_add (sub_neg_monoid real)))) := sorry --non-trivial
lemma new_lemma_132086 (h0 : functor.add_const (topological_space (simple_graph pos)) pos) : @preirreducible_space.{0} (simple_graph.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (simple_graph.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_132087 (h0 : topological_space (ordered_comm_monoid (finset linarith.comp))) : t1_space (ordered_comm_monoid (finset linarith.comp)) := sorry --non-trivial
lemma new_lemma_132088 (h0 : ordered_add_comm_monoid (finset (add_left_cancel_monoid (ring linarith.comp)))) : archimedean (finset (add_left_cancel_monoid (ring linarith.comp))) := sorry --non-trivial
lemma new_lemma_132089 (h0 : Type -> has_neg pos -> Prop) : relator.bi_total h0 := sorry --non-trivial
lemma new_lemma_132090 (h0 : function.extfun Type topological_space) : @totally_disconnected_space.{0} (boolean_algebra.{0} real) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (boolean_algebra.{0} real))  := sorry --non-trivial
lemma new_lemma_132091 (h0 : topological_space (add_comm_semigroup (mul_one_class (mul_one_class string.iterator_imp)))) : totally_disconnected_space (add_comm_semigroup (mul_one_class (mul_one_class string.iterator_imp))) := sorry --non-trivial
lemma new_lemma_132092 (h0 : topological_space (dlist linarith.ineq)) : path_connected_space (dlist linarith.ineq) := sorry --non-trivial
lemma new_lemma_132093 (h0 : topological_space (complete_distrib_lattice (ring (has_neg Type)))) : preirreducible_space (complete_distrib_lattice (ring (has_neg Type))) := sorry --non-trivial
lemma new_lemma_132094 (h0 : functor.add_const (function.extfun Type topological_space) (ring Type)) : @locally_compact_space.{0} (boolean_algebra.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type topological_space.{0}) (ring.{1} Type) h0) (boolean_algebra.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_132095 (h0 : group (ring pos)) : is_cyclic (ring pos) := sorry --non-trivial
lemma new_lemma_132096 (h0 : group (add_cancel_monoid (has_nndist (has_nndist (finset pos))))) : is_cyclic (add_cancel_monoid (has_nndist (has_nndist (finset pos)))) := sorry --non-trivial
lemma new_lemma_132097 (h0 : functor.add_const (topological_space (measure_theory.measure_space num)) num) : @path_connected_space.{0} (measure_theory.measure_space.{0} num) (@functor.add_const.run.{0 0} (topological_space.{0} (measure_theory.measure_space.{0} num)) num h0)  := sorry --non-trivial
lemma new_lemma_132098 (h0 : uniform_space (sub_neg_monoid (has_neg pos))) : separated_space (sub_neg_monoid (has_neg pos)) := sorry --non-trivial
lemma new_lemma_132099 (h0 : topological_space (finset name)) : t1_space (finset name) := sorry --non-trivial
lemma new_lemma_132100 (h0 : function.extfun Type ring) : @is_domain.{0} (normed_comm_ring.{0} name) (@function.extfun_app.{2 1} Type ring.{0} h0 (normed_comm_ring.{0} name))  := sorry --non-trivial
lemma new_lemma_132101 (h0 : topological_space (has_Inf (has_bot (has_bot (has_Inf (has_bot real)))))) : path_connected_space (has_Inf (has_bot (has_bot (has_Inf (has_bot real))))) := sorry --non-trivial
lemma new_lemma_132102 (h0 : function.extfun Type topological_space) : @preirreducible_space.{0} (canonically_linear_ordered_monoid.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (canonically_linear_ordered_monoid.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_132103 (h0 : functor.comp (functor.comp ring add_comm_monoid) with_top nnreal) : @rank_condition.{0} (add_comm_monoid.{0} ennreal) (@functor.comp.run.{0 0 0} ring.{0} add_comm_monoid.{0} ennreal (@functor.comp.run.{0 0 0} (functor.comp.{0 0 0} ring.{0} add_comm_monoid.{0}) with_top.{0} nnreal h0))  := sorry --non-trivial
lemma new_lemma_132104 (h0 : has_mem.mem group has_emptyc.emptyc) : @normalizer_condition.{0} unsigned (@function.extfun_app.{2 1} Type group.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) group.{0} h0) unsigned)  := sorry --non-trivial
lemma new_lemma_132105 (h0 : functor.add_const (function.extfun (Type 1) ring) pos) : @is_domain.{1} (ring.{1} Type) (@function.extfun_app.{3 2} (Type 1) ring.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) ring.{1}) pos h0) (ring.{1} Type))  := sorry --non-trivial
lemma new_lemma_132106 (h0 : topological_space (add_cancel_monoid congr_arg_kind)) : preirreducible_space (add_cancel_monoid congr_arg_kind) := sorry --non-trivial
lemma new_lemma_132107 (h0 : topological_space (semiring linarith.comp)) : path_connected_space (semiring linarith.comp) := sorry --non-trivial
lemma new_lemma_132108 (h0 : topological_space (has_emptyc (has_norm linarith.comp_source))) : path_connected_space (has_emptyc (has_norm linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_132109 (h0 : measurable_space (has_ssubset environment.projection_info)) (h1 : filter (has_ssubset environment.projection_info)) : filter.is_measurably_generated h1 := sorry --non-trivial
lemma new_lemma_132110 (h0 : group (random_gen (has_norm empty))) : group.fg (random_gen (has_norm empty)) := sorry --non-trivial
lemma new_lemma_132111 (h0 : fin has_zero.zero) : @is_principal_ideal_ring.{0} (canonically_linear_ordered_monoid.{0} real) (@function.extfun_app.{2 1} Type ring.{0} (@matrix.vec_empty.{1} (function.extfun.{2 1} Type ring.{0}) h0) (canonically_linear_ordered_monoid.{0} real))  := sorry --non-trivial
lemma new_lemma_132112 (h0 : topological_space (linear_ordered_add_comm_monoid_with_top ennreal)) : preirreducible_space (linear_ordered_add_comm_monoid_with_top ennreal) := sorry --non-trivial
lemma new_lemma_132113 (h0 : function.extfun Type finset) : finset.nonempty (function.extfun_app h0 (partial_order num)) := sorry --non-trivial
lemma new_lemma_132114 (h0 : topological_space (has_add (normed_comm_ring environment.implicit_infer_kind))) : discrete_topology (has_add (normed_comm_ring environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_132115 (h0 : function.extfun Type topological_space) : @preirreducible_space.{0} (add_semigroup.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (add_semigroup.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_132116 (h0 : set (uniform_space (mul_one_class string.iterator_imp))) : set.finite h0 := sorry --non-trivial
lemma new_lemma_132117 (h0 : functor.add_const (topological_space (has_pos_part name)) name) : @irreducible_space.{0} (has_pos_part.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (has_pos_part.{0} name)) name h0)  := sorry --non-trivial
lemma new_lemma_132118 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_domain.{0} (measurable_space.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (measurable_space.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_132119 (h0 : function.extfun nat fin) : @strong_rank_condition.{1} (ordered_comm_monoid.{1} Type) (@matrix.vec_empty.{1} (ring.{1} (ordered_comm_monoid.{1} Type)) (@matrix.vec_empty.{0} (fin (@has_zero.zero.{0} nat nat.has_zero)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero))))  := sorry --non-trivial
lemma new_lemma_132120 (h0 : ring (has_to_string (boolean_algebra.core (has_add name)))) : rank_condition (has_to_string (boolean_algebra.core (has_add name))) := sorry --non-trivial
lemma new_lemma_132121 (h0 : multiset (topological_space (has_ssubset std_gen))) : @totally_disconnected_space.{0} (has_ssubset.{0} std_gen) (@multiset.inf.{0} (topological_space.{0} (has_ssubset.{0} std_gen)) (@lattice.to_semilattice_inf.{0} (topological_space.{0} (has_ssubset.{0} std_gen)) (@conditionally_complete_lattice.to_lattice.{0} (topological_space.{0} (has_ssubset.{0} std_gen)) (@complete_lattice.to_conditionally_complete_lattice.{0} (topological_space.{0} (has_ssubset.{0} std_gen)) (@topological_space.complete_lattice.{0} (has_ssubset.{0} std_gen))))) (@bounded_order.to_order_top.{0} (topological_space.{0} (has_ssubset.{0} std_gen)) (@preorder.to_has_le.{0} (topological_space.{0} (has_ssubset.{0} std_gen)) (@partial_order.to_preorder.{0} (topological_space.{0} (has_ssubset.{0} std_gen)) (@semilattice_inf.to_partial_order.{0} (topological_space.{0} (has_ssubset.{0} std_gen)) (@lattice.to_semilattice_inf.{0} (topological_space.{0} (has_ssubset.{0} std_gen)) (@conditionally_complete_lattice.to_lattice.{0} (topological_space.{0} (has_ssubset.{0} std_gen)) (@complete_lattice.to_conditionally_complete_lattice.{0} (topological_space.{0} (has_ssubset.{0} std_gen)) (@topological_space.complete_lattice.{0} (has_ssubset.{0} std_gen)))))))) (@complete_lattice.to_bounded_order.{0} (topological_space.{0} (has_ssubset.{0} std_gen)) (@topological_space.complete_lattice.{0} (has_ssubset.{0} std_gen)))) h0)  := sorry --non-trivial
lemma new_lemma_132122 (h0 : function.extfun Type topological_space) : @t0_space.{0} (has_zero.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_zero.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_132123 (h0 : complete_lattice (preorder congr_arg_kind)) : is_atomistic (preorder congr_arg_kind) := sorry --non-trivial
lemma new_lemma_132124 (h0 : functor.add_const (topological_space (semigroup Type)) environment.implicit_infer_kind) : @t1_space.{1} (semigroup.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (semigroup.{1} Type)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_132125 (h0 : ring (ring (option (option pos)))) : is_domain (ring (option (option pos))) := sorry --non-trivial
lemma new_lemma_132126 (h0 : function.extfun Type topological_space) : @path_connected_space.{0} (has_compl.{0} char) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_compl.{0} char))  := sorry --non-trivial
lemma new_lemma_132127 (h0 : topological_space (ordered_comm_monoid (has_add Type))) : irreducible_space (ordered_comm_monoid (has_add Type)) := sorry --non-trivial
lemma new_lemma_132128 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_domain.{0} (has_top.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (has_top.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_132129 (h0 : uniform_space (has_neg_part (has_nndist Type))) : complete_space (has_neg_part (has_nndist Type)) := sorry --non-trivial
lemma new_lemma_132130 (h0 : function.extfun Type complete_lattice) : @complete_lattice.is_Sup_finite_compact.{0} (has_neg.{0} num) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (has_neg.{0} num))  := sorry --non-trivial
lemma new_lemma_132131 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @discrete_topology.{1} (has_neg.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 topological_space.{1}) (has_neg.{1} Type))  := sorry --non-trivial
lemma new_lemma_132132 (h0 : function.extfun Type topological_space) : @t0_space.{0} (has_to_string.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_to_string.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_132133 (h2 : complete_lattice (normed_field (metric_space char))) : is_compactly_generated (normed_field (metric_space char)) := sorry --non-trivial
lemma new_lemma_132134 (h0 : group (normed_lattice_add_comm_group (has_add real))) : is_simple_group (normed_lattice_add_comm_group (has_add real)) := sorry --non-trivial
lemma new_lemma_132135 (h0 : list (semigroup (has_neg_part Type))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_132136 (h0 : function.extfun Type group) : @group.fg.{0} (mul_zero_class.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type group.{0} h0 (mul_zero_class.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_132137 (h0 : list (has_bot (option (option (option (option unsigned)))))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_132138 (h0 : functor.add_const (ring (semigroup pos)) pos) : @is_domain.{0} (semigroup.{0} pos) (@functor.add_const.run.{0 0} (ring.{0} (semigroup.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_132139 (h0 : functor.add_const (add_group (has_Inf pos)) linarith.comp) : @is_add_cyclic.{0} (has_Inf.{0} pos) (@functor.add_const.run.{0 0} (add_group.{0} (has_Inf.{0} pos)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_132140 (h0 : semiring (simple_graph (option (option num)))) : is_noetherian_ring (simple_graph (option (option num))) := sorry --non-trivial
lemma new_lemma_132141 (h0 : topological_space (semiring (has_top (has_top congr_arg_kind)))) : discrete_topology (semiring (has_top (has_top congr_arg_kind))) := sorry --non-trivial
lemma new_lemma_132142 (h0 : functor.comp ring add_comm_monoid Type) : @rank_condition.{1} (add_comm_monoid.{1} Type) (@functor.comp.run.{1 1 1} ring.{1} add_comm_monoid.{1} Type h0)  := sorry --non-trivial
lemma new_lemma_132143 (h0 : ring (has_union (id linarith.comp))) : rank_condition (has_union (id linarith.comp)) := sorry --non-trivial
lemma new_lemma_132144 (h0 : complete_lattice (has_append (has_nnnorm linarith.ineq))) : is_compactly_generated (has_append (has_nnnorm linarith.ineq)) := sorry --non-trivial
lemma new_lemma_132145 (h0 : ring (random_gen (has_norm (has_norm empty)))) : strong_rank_condition (random_gen (has_norm (has_norm empty))) := sorry --non-trivial
lemma new_lemma_132146 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @complete_lattice.is_Sup_finite_compact.{0} linarith.ineq (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) linarith.ineq)  := sorry --non-trivial
lemma new_lemma_132147 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @add_monoid.fg.{0} (measure_theory.measure_space.{0} empty) (@function.extfun_app.{2 1} Type add_monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 add_monoid.{0}) (measure_theory.measure_space.{0} empty))  := sorry --non-trivial
lemma new_lemma_132148 (h0 : topological_space (has_bot pos)) : locally_compact_space (has_bot pos) := sorry --non-trivial
lemma new_lemma_132149 (h0 : uniform_space (canonically_linear_ordered_monoid (option (option pos)))) : complete_space (canonically_linear_ordered_monoid (option (option pos))) := sorry --non-trivial
lemma new_lemma_132150 (h0 : function.extfun Type topological_space) : @path_connected_space.{0} (add_left_cancel_monoid.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (add_left_cancel_monoid.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_132151 (h0 : fin has_zero.zero) : list.head (id (id (id (matrix.vec_empty h0)))) := sorry --non-trivial
lemma new_lemma_132152 (h0 : topological_space (has_union (semiring empty))) : totally_separated_space (has_union (semiring empty)) := sorry --non-trivial
lemma new_lemma_132153 (h1 : add_group (add_comm_semigroup (mul_one_class string.iterator_imp))) : is_add_cyclic (add_comm_semigroup (mul_one_class string.iterator_imp)) := sorry --non-trivial
lemma new_lemma_132154 (h0 : function.extfun Type list) : list.nodup (function.extfun_app h0 (dlist fun_info)) := sorry --non-trivial
lemma new_lemma_132155 (h0 : functor.add_const (monoid (pseudo_metric_space empty)) ennreal) : @monoid.fg.{0} (pseudo_metric_space.{0} empty) (@functor.add_const.run.{0 0} (monoid.{0} (pseudo_metric_space.{0} empty)) ennreal h0)  := sorry --non-trivial
lemma new_lemma_132156 (h0 : group (linear_ordered_field unsigned)) : group.fg (linear_ordered_field unsigned) := sorry --non-trivial
lemma new_lemma_132157 (h0 : functor.comp topological_space mul_zero_class Type) : @preconnected_space.{1} (mul_zero_class.{1} Type) (@functor.comp.run.{1 1 1} topological_space.{1} mul_zero_class.{1} Type h0)  := sorry --non-trivial
lemma new_lemma_132158 (h0 : functor.add_const (ring (linear_ordered_cancel_comm_monoid num)) empty) : @is_domain.{0} (linear_ordered_cancel_comm_monoid.{0} num) (@functor.add_const.run.{0 0} (ring.{0} (linear_ordered_cancel_comm_monoid.{0} num)) empty h0)  := sorry --non-trivial
lemma new_lemma_132159 (h0 : topological_space (id (random_gen (random_gen to_additive.value_type)))) : totally_separated_space (id (random_gen (random_gen to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_132160 (h0 : finset (ring (finset (finset (has_neg (finset (finset (has_neg pos)))))))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_132161 (h0 : topological_space (has_bot (has_pos_part linarith.comp))) : sequential_space (has_bot (has_pos_part linarith.comp)) := sorry --non-trivial
lemma new_lemma_132162 (h0 : functor.add_const (ring (has_add name)) environment.implicit_infer_kind) : @rank_condition.{0} (has_add.{0} name) (@functor.add_const.run.{0 0} (ring.{0} (has_add.{0} name)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_132163 (h0 : functor.add_const (topological_space (boolean_algebra.core pos)) name) : @irreducible_space.{0} (boolean_algebra.core.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (boolean_algebra.core.{0} pos)) name h0)  := sorry --non-trivial
lemma new_lemma_132164 (h0 : add_group (semigroup (semigroup Type))) : is_add_cyclic (semigroup (semigroup Type)) := sorry --non-trivial
lemma new_lemma_132165 (h0 : has_lt (linear_ordered_comm_monoid_with_zero ereal)) : no_max_order (linear_ordered_comm_monoid_with_zero ereal) := sorry --non-trivial
lemma new_lemma_132166 (h0 : function.extfun Type topological_space) : @topological_space.separable_space.{0} (semigroup.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (semigroup.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_132167 (h0 : functor.add_const (topological_space (add_comm_monoid name)) environment.implicit_infer_kind) : @t1_space.{0} (add_comm_monoid.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (add_comm_monoid.{0} name)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_132168 (h0 : semiring (measurable_space char)) (h1 : measurable_space char) : even h1 := sorry --non-trivial
lemma new_lemma_132169 (h0 : function.extfun Type uniform_space) : @complete_space.{0} (has_pos_part.{0} real) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (has_pos_part.{0} real))  := sorry --non-trivial
lemma new_lemma_132170 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @t0_space.{0} (finset.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (finset.{0} empty))  := sorry --non-trivial
lemma new_lemma_132171 (h0 : function.extfun Type topological_space) : @t0_space.{0} (semiring.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (semiring.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_132172 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @preirreducible_space.{0} (preorder.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (preorder.{0} num))  := sorry --non-trivial
lemma new_lemma_132173 (h0 : topological_space (measurable_space.dynkin_system (has_top unsigned))) : irreducible_space (measurable_space.dynkin_system (has_top unsigned)) := sorry --non-trivial
lemma new_lemma_132174 (h1 : topological_space (measurable_space (random_gen (has_inv to_additive.value_type)))) : locally_compact_space (measurable_space (random_gen (has_inv to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_132175 (h2 : topological_space (random_gen to_additive.value_type)) : path_connected_space (random_gen to_additive.value_type) := sorry --non-trivial
lemma new_lemma_132176 (h0 : function.extfun Type complete_lattice) : @is_compactly_generated.{0} (ordered_comm_monoid.{0} pos) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (ordered_comm_monoid.{0} pos))  := sorry --non-trivial
lemma new_lemma_132177 (h0 : function.extfun (Type 1) uniform_space) : @complete_space.{1} (comm_group.{1} Type) (@function.extfun_app.{3 2} (Type 1) uniform_space.{1} h0 (comm_group.{1} Type))  := sorry --non-trivial
lemma new_lemma_132178 (h0 : has_mem.mem topological_space has_emptyc.emptyc) : @t0_space.{0} linarith.comp (@function.extfun_app.{2 1} Type topological_space.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) topological_space.{0} h0) linarith.comp)  := sorry --non-trivial
lemma new_lemma_132179 (h3 : set (string.iterator_imp -> enat)) : set.separates_points h3 := sorry --non-trivial
lemma new_lemma_132180 (h0 : topological_space (complete_distrib_lattice name)) : normal_space (complete_distrib_lattice name) := sorry --non-trivial
lemma new_lemma_132181 (h0 : functor.add_const (topological_space (add_comm_monoid unsigned)) empty) : @normal_space.{0} (add_comm_monoid.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (add_comm_monoid.{0} unsigned)) empty h0)  := sorry --non-trivial
lemma new_lemma_132182 (h0 : group (ordered_cancel_add_comm_monoid pos)) : is_simple_group (ordered_cancel_add_comm_monoid pos) := sorry --non-trivial
lemma new_lemma_132183 (h0 : functor.add_const (ring (has_add linarith.comp)) (has_to_string (has_to_string pos))) : @strong_rank_condition.{0} (has_add.{0} linarith.comp) (@functor.add_const.run.{0 0} (ring.{0} (has_add.{0} linarith.comp)) (has_to_string.{0} (has_to_string.{0} pos)) h0)  := sorry --non-trivial
lemma new_lemma_132184 (h0 : topological_space (mul_zero_class (option unsigned))) : locally_compact_space (mul_zero_class (option unsigned)) := sorry --non-trivial
lemma new_lemma_132185 (h0 : function.extfun Type ring) : @rank_condition.{0} (with_bot.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type ring.{0} h0 (with_bot.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_132186 (h0 : uniform_space (has_to_string (has_add pos))) : separated_space (has_to_string (has_add pos)) := sorry --non-trivial
lemma new_lemma_132187 (h0 : topological_space (distrib (distrib reducibility_hints))) : totally_disconnected_space (distrib (distrib reducibility_hints)) := sorry --non-trivial
lemma new_lemma_132188 (h0 : complete_lattice (parser num)) : complete_lattice.is_Sup_finite_compact (parser num) := sorry --non-trivial
lemma new_lemma_132189 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @loc_path_connected_space.{0} (has_pos_part.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_pos_part.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_132190 (h0 : functor.add_const (function.extfun Type group) pos) : @group.fg.{0} (normed_comm_ring.{0} pos) (@function.extfun_app.{2 1} Type group.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type group.{0}) pos h0) (normed_comm_ring.{0} pos))  := sorry --non-trivial
lemma new_lemma_132191 (h0 : topological_space (has_bot (has_neg name))) : discrete_topology (has_bot (has_neg name)) := sorry --non-trivial
lemma new_lemma_132192 (h0 : topological_space (normed_comm_ring (has_to_string pos))) : regular_space (normed_comm_ring (has_to_string pos)) := sorry --non-trivial
lemma new_lemma_132193 (h0 : functor.add_const (topological_space (has_to_string pos)) (has_neg (has_neg Type))) : @sequential_space.{0} (has_to_string.{0} pos) (@functor.add_const.run.{0 1} (topological_space.{0} (has_to_string.{0} pos)) (has_neg.{1} (has_neg.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_132194 (h0 : cancel_comm_monoid_with_zero (ordered_cancel_add_comm_monoid empty)) : unique_factorization_monoid (ordered_cancel_add_comm_monoid empty) := sorry --non-trivial
lemma new_lemma_132195 (h0 : complete_lattice (has_Inf (has_neg name))) : is_compactly_generated (has_Inf (has_neg name)) := sorry --non-trivial
lemma new_lemma_132196 (h0 : complete_lattice (cancel_monoid (has_add (add_comm_monoid Type)))) : is_atomistic (cancel_monoid (has_add (add_comm_monoid Type))) := sorry --non-trivial
lemma new_lemma_132197 (h0 : group (measurable_space (id (random_gen (has_one linarith.comp))))) : group.fg (measurable_space (id (random_gen (has_one linarith.comp)))) := sorry --non-trivial
lemma new_lemma_132198 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @locally_compact_space.{0} (semigroup.{0} (option.{0} name)) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (semigroup.{0} (option.{0} name)))  := sorry --non-trivial
lemma new_lemma_132199 (h0 : complete_lattice (normed_comm_ring (add_comm_monoid (has_add pos)))) : is_compactly_generated (normed_comm_ring (add_comm_monoid (has_add pos))) := sorry --non-trivial
lemma new_lemma_132200 (h0 : complete_lattice (has_neg_part Type)) : is_atomistic (has_neg_part Type) := sorry --non-trivial
lemma new_lemma_132201 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @complete_space.{0} (with_bot.{0} fun_info) (@function.extfun_app.{2 1} Type uniform_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 uniform_space.{0}) (with_bot.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_132202 (h1 : ring (linear_ordered_comm_group_with_zero string_imp)) : rank_condition (linear_ordered_comm_group_with_zero string_imp) := sorry --non-trivial
lemma new_lemma_132203 (h0 : topological_space (comm_ring (has_nnnorm linarith.ineq))) : path_connected_space (comm_ring (has_nnnorm linarith.ineq)) := sorry --non-trivial
lemma new_lemma_132204 (h0 : functor.add_const Prop (has_nndist pos)) : functor.add_const.run h0 := sorry --non-trivial
lemma new_lemma_132205 (h0 : functor.add_const (topological_space (has_nndist name)) (boolean_algebra (boolean_algebra name))) : @t1_space.{0} (has_nndist.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (has_nndist.{0} name)) (boolean_algebra.{0} (boolean_algebra.{0} name)) h0)  := sorry --non-trivial
lemma new_lemma_132206 (h0 : group (right_cancel_semigroup (has_norm (has_top num)))) : group.fg (right_cancel_semigroup (has_norm (has_top num))) := sorry --non-trivial
lemma new_lemma_132207 (h0 : uniform_space (comm_group (mul_zero_class Type))) : separated_space (comm_group (mul_zero_class Type)) := sorry --non-trivial
lemma new_lemma_132208 (h0 : topological_space (boolean_algebra.core (has_add (ring (has_add (ordered_ring Type)))))) : t0_space (boolean_algebra.core (has_add (ring (has_add (ordered_ring Type))))) := sorry --non-trivial
lemma new_lemma_132209 (h0 : functor.add_const (topological_space (has_pos_part pos)) Type) : @t0_space.{0} (has_pos_part.{0} pos) (@functor.add_const.run.{0 1} (topological_space.{0} (has_pos_part.{0} pos)) Type h0)  := sorry --non-trivial
lemma new_lemma_132210 (h0 : topological_space (normed_comm_ring (finset pos))) : topological_space.separable_space (normed_comm_ring (finset pos)) := sorry --non-trivial
lemma new_lemma_132211 (h0 : function.extfun Type ring) : @rank_condition.{0} (linear_order.{0} unsigned) (@function.extfun_app.{2 1} Type ring.{0} h0 (linear_order.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_132212 (h0 : uniform_space (mul_one_class (mul_one_class (mul_one_class char)))) : complete_space (mul_one_class (mul_one_class (mul_one_class char))) := sorry --non-trivial
lemma new_lemma_132213 (h0 : ordered_comm_monoid (ordered_cancel_add_comm_monoid congr_arg_kind)) : has_exists_mul_of_le (ordered_cancel_add_comm_monoid congr_arg_kind) := sorry --non-trivial
lemma new_lemma_132214 (h0 : function.extfun Type topological_space) : @t0_space.{0} (complete_lattice.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (complete_lattice.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_132215 (h0 : functor.add_const (ring (comm_group pos)) environment.implicit_infer_kind) : @strong_rank_condition.{0} (comm_group.{0} pos) (@functor.add_const.run.{0 0} (ring.{0} (comm_group.{0} pos)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_132216 (h0 : function.extfun Type topological_space) : @normal_space.{0} (boolean_algebra.core.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (boolean_algebra.core.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_132217 (h0 : ordered_comm_monoid (boolean_algebra.core (ring (option ennreal)))) : has_exists_mul_of_le (boolean_algebra.core (ring (option ennreal))) := sorry --non-trivial
lemma new_lemma_132218 (h2 : ring (topological_space linarith.ineq)) : rank_condition (topological_space linarith.ineq) := sorry --non-trivial
lemma new_lemma_132219 (h0 : functor.add_const (topological_space (monoid ennreal)) num) : @locally_compact_space.{0} (monoid.{0} ennreal) (@functor.add_const.run.{0 0} (topological_space.{0} (monoid.{0} ennreal)) num h0)  := sorry --non-trivial
lemma new_lemma_132220 (h0 : fin has_zero.zero) : @normal_space.{0} (normed_lattice_add_comm_group.{0} pos) (@matrix.vec_empty.{0} (topological_space.{0} (normed_lattice_add_comm_group.{0} pos)) h0)  := sorry --non-trivial
lemma new_lemma_132221 (h0 : topological_space (has_bot (has_bot (sub_neg_monoid (has_bot real))))) : regular_space (has_bot (has_bot (sub_neg_monoid (has_bot real)))) := sorry --non-trivial
lemma new_lemma_132222 (h0 : fin has_zero.zero) : @rank_condition.{0} (has_nndist.{0} name) (@matrix.vec_empty.{0} (ring.{0} (has_nndist.{0} name)) h0)  := sorry --non-trivial
lemma new_lemma_132223 (h0 : topological_space (has_top unsigned)) : regular_space (has_top unsigned) := sorry --non-trivial
lemma new_lemma_132224 (h3 : ring (uniform_space to_additive.value_type)) : strong_rank_condition (uniform_space to_additive.value_type) := sorry --non-trivial
lemma new_lemma_132225 (h0 : functor.add_const (topological_space (complete_distrib_lattice name)) environment.implicit_infer_kind) : @totally_separated_space.{0} (complete_distrib_lattice.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (complete_distrib_lattice.{0} name)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_132226 (h0 : functor.add_const (ring (add_cancel_comm_monoid empty)) (option (option empty))) : @is_domain.{0} (add_cancel_comm_monoid.{0} empty) (@functor.add_const.run.{0 0} (ring.{0} (add_cancel_comm_monoid.{0} empty)) (option.{0} (option.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_132227 (h0 : function.extfun Type topological_space) : @totally_separated_space.{0} (has_neg.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_neg.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_132228 (h0 : functor.add_const (add_monoid (comm_group ennreal)) unsigned) : @add_monoid.fg.{0} (comm_group.{0} ennreal) (@functor.add_const.run.{0 0} (add_monoid.{0} (comm_group.{0} ennreal)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_132229 (h0 : functor.add_const (cancel_comm_monoid_with_zero auto.case_option) congr_arg_kind) : @unique_factorization_monoid.{0} auto.case_option (@functor.add_const.run.{0 0} (cancel_comm_monoid_with_zero.{0} auto.case_option) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_132230 (h0 : functor.add_const (complete_lattice (has_to_string name)) name) : @is_compactly_generated.{0} (has_to_string.{0} name) (@functor.add_const.run.{0 0} (complete_lattice.{0} (has_to_string.{0} name)) name h0)  := sorry --non-trivial
lemma new_lemma_132231 (h0 : complete_lattice (has_add (has_neg (has_neg (has_neg pos))))) : is_atomistic (has_add (has_neg (has_neg (has_neg pos)))) := sorry --non-trivial
lemma new_lemma_132232 (h0 : nat) (h1 : topological_space (uniform_space (measurable_space.dynkin_system (composition h0)))) (h2 : preorder (uniform_space (measurable_space.dynkin_system (composition h0)))) : order_topology (uniform_space (measurable_space.dynkin_system (composition h0))) := sorry --non-trivial
lemma new_lemma_132233 (h0 : function.extfun Type topological_space) : @t1_space.{0} (add_comm_monoid.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (add_comm_monoid.{0} empty))  := sorry --non-trivial
lemma new_lemma_132234 (h0 : filter (has_neg (finset (finset (finset pos))))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_132235 (h0 : add_monoid (id (metric_space empty))) : add_monoid.fg (id (metric_space empty)) := sorry --non-trivial
lemma new_lemma_132236 (h0 : uniform_space (semiring (semiring empty))) : separated_space (semiring (semiring empty)) := sorry --non-trivial
lemma new_lemma_132237 (h0 : topological_space (normed_comm_ring (has_add Type))) : normal_space (normed_comm_ring (has_add Type)) := sorry --non-trivial
lemma new_lemma_132238 (h1 : function.extfun Type ring) : @is_domain.{0} (measurable_space.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type ring.{0} h1 (measurable_space.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_132239 (h0 : topological_space (has_zero (mul_zero_class Type))) : irreducible_space (has_zero (mul_zero_class Type)) := sorry --non-trivial
lemma new_lemma_132240 (h0 : topological_space (normed_lattice_add_comm_group (has_Inf real))) : path_connected_space (normed_lattice_add_comm_group (has_Inf real)) := sorry --non-trivial
lemma new_lemma_132241 (h0 : functor.add_const (ordered_comm_monoid pos) name) : @has_exists_mul_of_le.{0} pos (@functor.add_const.run.{0 0} (ordered_comm_monoid.{0} pos) name h0)  := sorry --non-trivial
lemma new_lemma_132242 (h0 : ring (has_nndist (boolean_algebra.core name))) : strong_rank_condition (has_nndist (boolean_algebra.core name)) := sorry --non-trivial
lemma new_lemma_132243 (h0 : group (boolean_algebra pos)) : group.fg (boolean_algebra pos) := sorry --non-trivial
lemma new_lemma_132244 (h0 : topological_space (add_cancel_monoid (has_add (has_neg_part Type)))) : preconnected_space (add_cancel_monoid (has_add (has_neg_part Type))) := sorry --non-trivial
lemma new_lemma_132245 (h0 : group (has_norm (has_top (has_nnnorm (has_nnnorm (has_nnnorm fun_info)))))) : group.fg (has_norm (has_top (has_nnnorm (has_nnnorm (has_nnnorm fun_info))))) := sorry --non-trivial
lemma new_lemma_132246 (h0 : not (ring (add_right_cancel_monoid congr_arg_kind) -> false)) : @is_principal_ideal_ring.{0} (add_right_cancel_monoid.{0} congr_arg_kind) (@classical.by_contradiction'.{1} (ring.{0} (add_right_cancel_monoid.{0} congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_132247 (h1 : group linarith.comp_source) : normalizer_condition linarith.comp_source := sorry --non-trivial
lemma new_lemma_132248 (h0 : group (semigroup (ring Type))) : group.fg (semigroup (ring Type)) := sorry --non-trivial
lemma new_lemma_132249 (h0 : topological_space (has_to_string (finset linarith.comp))) : t0_space (has_to_string (finset linarith.comp)) := sorry --non-trivial
lemma new_lemma_132250 (h0 : not (ring (measure_theory.measure_space unsigned) -> false)) : @strong_rank_condition.{0} (measure_theory.measure_space.{0} unsigned) (@classical.by_contradiction'.{1} (ring.{0} (measure_theory.measure_space.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_132251 (h0 : function.extfun Type ring) : @is_domain.{0} (complete_semilattice_Sup.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type ring.{0} h0 (complete_semilattice_Sup.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_132252 (h0 : ordered_comm_monoid (has_to_string (finset (has_pos_part pos)))) : has_exists_mul_of_le (has_to_string (finset (has_pos_part pos))) := sorry --non-trivial
lemma new_lemma_132253 (h2 : uniform_space (semi_normed_ring reducibility_hints)) : complete_space (semi_normed_ring reducibility_hints) := sorry --non-trivial
lemma new_lemma_132254 (h1 : ring (uniform_space char)) : is_domain (uniform_space char) := sorry --non-trivial
lemma new_lemma_132255 (h0 : topological_space (has_emptyc (has_norm num))) : path_connected_space (has_emptyc (has_norm num)) := sorry --non-trivial
lemma new_lemma_132256 (h0 : set (linarith.ineq -> mul_one_class ereal)) : set.separates_points h0 := sorry --non-trivial
lemma new_lemma_132257 (h0 : complete_lattice (distrib (mul_one_class char))) : complete_lattice.is_Sup_finite_compact (distrib (mul_one_class char)) := sorry --non-trivial
lemma new_lemma_132258 (h0 : functor.add_const (function.extfun Type ring) Type) : @rank_condition.{0} (finset.{0} pos) (@function.extfun_app.{2 1} Type ring.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type ring.{0}) Type h0) (finset.{0} pos))  := sorry --non-trivial
lemma new_lemma_132259 (h0 : topological_space (has_nndist (has_neg (finset Type)))) : locally_compact_space (has_nndist (has_neg (finset Type))) := sorry --non-trivial
lemma new_lemma_132260 (h0 : prod (plift (has_norm (has_top empty))) (plift (has_norm (has_top empty)))) : id_rel h0 := sorry --non-trivial
lemma new_lemma_132261 (h0 : functor.add_const (uniform_space (semigroup environment.implicit_infer_kind)) (has_zero Type)) : @complete_space.{0} (semigroup.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 1} (uniform_space.{0} (semigroup.{0} environment.implicit_infer_kind)) (has_zero.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_132262 (h0 : functor.add_const (topological_space (add_comm_monoid linarith.comp)) environment.implicit_infer_kind) : @totally_disconnected_space.{0} (add_comm_monoid.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (add_comm_monoid.{0} linarith.comp)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_132263 (h0 : add_monoid (canonically_ordered_comm_semiring (has_neg Type))) : add_monoid.fg (canonically_ordered_comm_semiring (has_neg Type)) := sorry --non-trivial
lemma new_lemma_132264 (h1 : uniform_space (linear_ordered_add_comm_group (has_nnnorm char))) : complete_space (linear_ordered_add_comm_group (has_nnnorm char)) := sorry --non-trivial
lemma new_lemma_132265 (h0 : list auto.case_option) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_132266 (h0 : group (with_bot (has_inv (denumerable (has_top (has_top linarith.ineq)))))) : normalizer_condition (with_bot (has_inv (denumerable (has_top (has_top linarith.ineq))))) := sorry --non-trivial
lemma new_lemma_132267 (h0 : function.extfun Type topological_space) : @normal_space.{0} (comm_group.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (comm_group.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_132268 (h0 : functor.add_const (list (has_zero linarith.comp)) pos) : palindrome (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_132269 (h0 : not (has_mem.mem (complete_semilattice_Sup fun_info) has_emptyc.emptyc -> false)) : @strong_rank_condition.{0} (complete_semilattice_Sup.{0} fun_info) (@finset.pi.empty.{1 0} Type ring.{0} (complete_semilattice_Sup.{0} fun_info) (@classical.by_contradiction'.{0} (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (complete_semilattice_Sup.{0} fun_info) (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))) h0))  := sorry --non-trivial
lemma new_lemma_132270 (h0 : functor.add_const (monoid (ordered_comm_ring pos)) real) : @monoid.fg.{0} (ordered_comm_ring.{0} pos) (@functor.add_const.run.{0 0} (monoid.{0} (ordered_comm_ring.{0} pos)) real h0)  := sorry --non-trivial
lemma new_lemma_132271 (h0 : group (with_bot (has_inv (has_inv fun_info)))) : normalizer_condition (with_bot (has_inv (has_inv fun_info))) := sorry --non-trivial
lemma new_lemma_132272 (h0 : topological_space (semigroup (has_pos_part Type))) : discrete_topology (semigroup (has_pos_part Type)) := sorry --non-trivial
lemma new_lemma_132273 (h0 : not (function.extfun Type topological_space -> false)) : @path_connected_space.{0} (random_gen.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (random_gen.{0} num))  := sorry --non-trivial
lemma new_lemma_132274 (h1 : ring (has_append (has_ssubset char))) : is_domain (has_append (has_ssubset char)) := sorry --non-trivial
lemma new_lemma_132275 (h0 : functor.add_const empty unsigned) : t1_space nnreal := sorry --non-trivial
lemma new_lemma_132276 (h0 : functor.comp topological_space has_neg environment.implicit_infer_kind) : @locally_compact_space.{0} (has_neg.{0} environment.implicit_infer_kind) (@functor.comp.run.{0 0 0} topological_space.{0} has_neg.{0} environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_132277 (h0 : topological_space (with_one (measurable_space to_additive.value_type))) : discrete_topology (with_one (measurable_space to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_132278 (h0 : topological_space (add_cancel_comm_monoid reducibility_hints)) : totally_disconnected_space (add_cancel_comm_monoid reducibility_hints) := sorry --non-trivial
lemma new_lemma_132279 (h0 : topological_space (has_top (has_norm (has_norm (random_gen linarith.comp_source))))) : path_connected_space (has_top (has_norm (has_norm (random_gen linarith.comp_source)))) := sorry --non-trivial
lemma new_lemma_132280 (h0 : topological_space (add_comm_monoid (boolean_algebra unsigned))) : totally_separated_space (add_comm_monoid (boolean_algebra unsigned)) := sorry --non-trivial
lemma new_lemma_132281 (h2 : not (ring (distrib linarith.comp_source) -> false)) : @is_domain.{0} (distrib.{0} linarith.comp_source) (@classical.by_contradiction'.{1} (ring.{0} (distrib.{0} linarith.comp_source)) h2)  := sorry --non-trivial
lemma new_lemma_132282 (h0 : ring (mul_zero_class (semiring num))) : is_principal_ideal_ring (mul_zero_class (semiring num)) := sorry --non-trivial
lemma new_lemma_132283 (h0 : functor.add_const (topological_space (has_dist empty)) unsigned) : @topological_space.separable_space.{0} (has_dist.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (has_dist.{0} empty)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_132284 (h0 : functor.add_const (functor.add_const (ring Type) linarith.comp) Type) : @is_domain.{1} Type (@functor.add_const.run.{1 0} (ring.{1} Type) linarith.comp (@functor.add_const.run.{1 1} (functor.add_const.{1 0} (ring.{1} Type) linarith.comp) Type h0))  := sorry --non-trivial
lemma new_lemma_132285 (h0 : topological_space (has_add (cancel_monoid ennreal))) : totally_disconnected_space (has_add (cancel_monoid ennreal)) := sorry --non-trivial
lemma new_lemma_132286 (h0 : functor.add_const (ordered_comm_monoid (normed_comm_ring Type)) Type) : @has_exists_mul_of_le.{1} (normed_comm_ring.{1} Type) (@functor.add_const.run.{1 1} (ordered_comm_monoid.{1} (normed_comm_ring.{1} Type)) Type h0)  := sorry --non-trivial
lemma new_lemma_132287 (h0 : filter (has_one (has_norm (has_norm empty)))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_132288 (h0 : topological_space (canonically_linear_ordered_monoid (has_neg (has_neg pos)))) : topological_space.separable_space (canonically_linear_ordered_monoid (has_neg (has_neg pos))) := sorry --non-trivial
lemma new_lemma_132289 (h0 : function.extfun (nat -> Type) (function.extfun nat)) : @is_cyclic.{1} (ordered_comm_monoid.{1} Type) (@matrix.vec_empty.{1} (group.{1} (ordered_comm_monoid.{1} Type)) (@function.extfun_app.{1 1} nat fin (@function.extfun_app.{2 1} (nat → Type) (function.extfun.{1 1} nat) h0 fin) (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_132290 (h0 : ring (has_add (ring (ring environment.implicit_infer_kind)))) : rank_condition (has_add (ring (ring environment.implicit_infer_kind))) := sorry --non-trivial
lemma new_lemma_132291 (h0 : group (monoid_with_zero congr_arg_kind)) : is_cyclic (monoid_with_zero congr_arg_kind) := sorry --non-trivial
lemma new_lemma_132292 (h0 : semiring (finset linarith.comp)) : is_noetherian_ring (finset linarith.comp) := sorry --non-trivial
lemma new_lemma_132293 (h0 : topological_space (complete_semilattice_Sup (semiring unsigned))) : normal_space (complete_semilattice_Sup (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_132294 (h0 : topological_space (ring (has_neg (has_Inf (ring Type))))) : t0_space (ring (has_neg (has_Inf (ring Type)))) := sorry --non-trivial
lemma new_lemma_132295 (h1 : function.extfun Type topological_space) : @totally_disconnected_space.{0} (comm_ring.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type topological_space.{0} h1 (comm_ring.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_132296 (h0 : group (complete_distrib_lattice num)) : is_simple_group (complete_distrib_lattice num) := sorry --non-trivial
lemma new_lemma_132297 (h0 : ring (has_top (has_norm (has_norm (has_norm (has_norm linarith.comp_source)))))) : is_domain (has_top (has_norm (has_norm (has_norm (has_norm linarith.comp_source))))) := sorry --non-trivial
lemma new_lemma_132298 (h0 : topological_space (has_bot (ordered_comm_monoid real))) : preirreducible_space (has_bot (ordered_comm_monoid real)) := sorry --non-trivial
lemma new_lemma_132299 (h0 : set (mul_one_class linarith.ineq)) : set.subsingleton h0 := sorry --non-trivial
lemma new_lemma_132300 (h0 : topological_space (ordered_comm_ring (finset (ring (ring linarith.comp))))) : path_connected_space (ordered_comm_ring (finset (ring (ring linarith.comp)))) := sorry --non-trivial
lemma new_lemma_132301 (h0 : topological_space (distrib_lattice (random_gen linarith.ineq))) : irreducible_space (distrib_lattice (random_gen linarith.ineq)) := sorry --non-trivial
lemma new_lemma_132302 (h0 : monoid (has_zero (has_neg Type))) : monoid.fg (has_zero (has_neg Type)) := sorry --non-trivial
lemma new_lemma_132303 (h0 : function.extfun nat fin) : @has_exists_mul_of_le.{0} (has_Inf.{0} name) (@function.extfun_app.{2 1} Type ordered_comm_monoid.{0} (@matrix.vec_empty.{1} (function.extfun.{2 1} Type ordered_comm_monoid.{0}) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero))) (has_Inf.{0} name))  := sorry --non-trivial
lemma new_lemma_132304 (h0 : ring (add_cancel_monoid (finset unsigned))) : is_principal_ideal_ring (add_cancel_monoid (finset unsigned)) := sorry --non-trivial
lemma new_lemma_132305 (h0 : not (add_monoid (add_group linarith.comp) -> false)) : @add_monoid.fg.{0} (add_group.{0} linarith.comp) (@classical.by_contradiction'.{1} (add_monoid.{0} (add_group.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_132306 (h0 : function.extfun Type group) : @normalizer_condition.{0} (has_top.{0} num) (@function.extfun_app.{2 1} Type group.{0} h0 (has_top.{0} num))  := sorry --non-trivial
lemma new_lemma_132307 (h0 : topological_space (mul_zero_class (semiring (semiring empty)))) : t0_space (mul_zero_class (semiring (semiring empty))) := sorry --non-trivial
lemma new_lemma_132308 (h0 : topological_space (canonically_linear_ordered_monoid (has_Inf pos))) : path_connected_space (canonically_linear_ordered_monoid (has_Inf pos)) := sorry --non-trivial
lemma new_lemma_132309 (h0 : functor.add_const (topological_space (add_group congr_arg_kind)) empty) : @locally_compact_space.{0} (add_group.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (add_group.{0} congr_arg_kind)) empty h0)  := sorry --non-trivial
lemma new_lemma_132310 (h0 : add_comm_semigroup linarith.ineq -> add_comm_semigroup linarith.ineq) (h1 : add_comm_semigroup linarith.ineq) : function.periodic_pts h0 h1 := sorry --non-trivial
lemma new_lemma_132311 (h0 : functor.comp topological_space semigroup (finset pos)) : @t1_space.{0} (semigroup.{0} (finset.{0} pos)) (@functor.comp.run.{0 0 0} topological_space.{0} semigroup.{0} (finset.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_132312 (h0 : topological_space (sub_neg_monoid (has_Inf Type))) : path_connected_space (sub_neg_monoid (has_Inf Type)) := sorry --non-trivial
lemma new_lemma_132313 (h0 : add_group (comm_group (has_to_string Type))) : is_add_cyclic (comm_group (has_to_string Type)) := sorry --non-trivial
lemma new_lemma_132314 (h0 : topological_space (normed_comm_ring (has_pos_part Type))) : irreducible_space (normed_comm_ring (has_pos_part Type)) := sorry --non-trivial
lemma new_lemma_132315 (h1 : ring (has_lt (metric_space char))) : is_domain (has_lt (metric_space char)) := sorry --non-trivial
lemma new_lemma_132316 (h0 : not (complete_lattice (semiring congr_arg_kind) -> false)) : @complete_lattice.is_Sup_finite_compact.{0} (semiring.{0} congr_arg_kind) (@classical.by_contradiction'.{1} (complete_lattice.{0} (semiring.{0} congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_132317 (h0 : not (complete_lattice (left_cancel_semigroup unsigned) -> false)) : @complete_lattice.is_Sup_finite_compact.{0} (left_cancel_semigroup.{0} unsigned) (@classical.by_contradiction'.{1} (complete_lattice.{0} (left_cancel_semigroup.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_132318 (h0 : not (ring (dlist fun_info) -> false)) : @strong_rank_condition.{0} (dlist.{0} fun_info) (@classical.by_contradiction'.{1} (ring.{0} (dlist.{0} fun_info)) h0)  := sorry --non-trivial
lemma new_lemma_132319 (h0 : simple_graph (random_gen (random_gen string_imp))) (h1 : sym2 (random_gen (random_gen string_imp))) : simple_graph.edge_set h0 h1 := sorry --non-trivial
lemma new_lemma_132320 (h0 : set string_imp) : set.finite h0 := sorry --non-trivial
lemma new_lemma_132321 (h0 : semiring (add_comm_monoid (has_nndist Type))) : is_noetherian_ring (add_comm_monoid (has_nndist Type)) := sorry --non-trivial
lemma new_lemma_132322 (h0 : function.extfun Type topological_space) : @locally_compact_space.{0} (has_neg.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_neg.{0} name))  := sorry --non-trivial
lemma new_lemma_132323 (h0 : ordered_comm_monoid (has_nndist (comm_group name))) : has_exists_mul_of_le (has_nndist (comm_group name)) := sorry --non-trivial
lemma new_lemma_132324 (h0 : topological_space (has_add (has_to_string pos))) : irreducible_space (has_add (has_to_string pos)) := sorry --non-trivial
lemma new_lemma_132325 (h0 : group (normed_field (has_nnnorm (has_lt (comm_ring linarith.comp_source))))) : is_cyclic (normed_field (has_nnnorm (has_lt (comm_ring linarith.comp_source)))) := sorry --non-trivial
lemma new_lemma_132326 (h0 : ring (non_unital_non_assoc_semiring (mul_one_class string_imp))) : is_domain (non_unital_non_assoc_semiring (mul_one_class string_imp)) := sorry --non-trivial
lemma new_lemma_132327 (h0 : add_monoid (has_union (semiring unsigned))) : add_monoid.fg (has_union (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_132328 (h0 : finset (has_nndist (has_add ennreal))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_132329 (h0 : topological_space (add_cancel_monoid (boolean_algebra linarith.comp))) : sequential_space (add_cancel_monoid (boolean_algebra linarith.comp)) := sorry --non-trivial
lemma new_lemma_132330 (h0 : functor.add_const (group (has_neg ennreal)) pos) : @is_simple_group.{0} (has_neg.{0} ennreal) (@functor.add_const.run.{0 0} (group.{0} (has_neg.{0} ennreal)) pos h0)  := sorry --non-trivial
lemma new_lemma_132331 (h0 : function.extfun Type topological_space) : @locally_compact_space.{0} (sub_neg_monoid.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (sub_neg_monoid.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_132332 (h0 : functor.add_const (monoid (add_comm_monoid environment.implicit_infer_kind)) pos) : @monoid.fg.{0} (add_comm_monoid.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (monoid.{0} (add_comm_monoid.{0} environment.implicit_infer_kind)) pos h0)  := sorry --non-trivial
lemma new_lemma_132333 (h0 : function.extfun Type ordered_add_comm_monoid) : @archimedean.{0} (cancel_monoid.{0} num) (@function.extfun_app.{2 1} Type ordered_add_comm_monoid.{0} h0 (cancel_monoid.{0} num))  := sorry --non-trivial
lemma new_lemma_132334 (h0 : topological_space (ordered_comm_ring (has_Inf linarith.comp))) : t0_space (ordered_comm_ring (has_Inf linarith.comp)) := sorry --non-trivial
lemma new_lemma_132335 (h0 : group (has_neg (has_add (has_add pos)))) : is_cyclic (has_neg (has_add (has_add pos))) := sorry --non-trivial
lemma new_lemma_132336 (h0 : functor.add_const (topological_space (ring Type)) (boolean_algebra linarith.comp)) : @loc_path_connected_space.{1} (ring.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (ring.{1} Type)) (boolean_algebra.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_132337 (h0 : functor.add_const (uniform_space (filter empty)) empty) : @complete_space.{0} (filter.{0} empty) (@functor.add_const.run.{0 0} (uniform_space.{0} (filter.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_132338 (h0 : group (has_add (complete_semilattice_Sup (has_to_string (finset Type))))) : is_simple_group (has_add (complete_semilattice_Sup (has_to_string (finset Type)))) := sorry --non-trivial
lemma new_lemma_132339 (h0 : add_monoid (linear_ordered_cancel_comm_monoid empty)) : add_monoid.fg (linear_ordered_cancel_comm_monoid empty) := sorry --non-trivial
lemma new_lemma_132340 (h0 : functor.add_const (topological_space (has_zero name)) Type) : @sequential_space.{0} (has_zero.{0} name) (@functor.add_const.run.{0 1} (topological_space.{0} (has_zero.{0} name)) Type h0)  := sorry --non-trivial
lemma new_lemma_132341 (h0 : add_zero_class empty) (h1 : topological_space (has_union (add_submonoid empty))) : normal_space (has_union (add_submonoid empty)) := sorry --non-trivial
lemma new_lemma_132342 (h0 : topological_space (ring (has_Inf linarith.comp))) : discrete_topology (ring (has_Inf linarith.comp)) := sorry --non-trivial
lemma new_lemma_132343 (h0 : cancel_comm_monoid_with_zero (boolean_algebra (ring environment.implicit_infer_kind))) : unique_factorization_monoid (boolean_algebra (ring environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_132344 (h0 : topological_space (metric_space unsigned)) : normal_space (metric_space unsigned) := sorry --non-trivial
lemma new_lemma_132345 (h2 : set (mul_one_class std_gen -> mul_one_class std_gen)) : set.separates_points h2 := sorry --non-trivial
lemma new_lemma_132346 (h0 : uniform_space (bin_tree (semiring empty))) : separated_space (bin_tree (semiring empty)) := sorry --non-trivial
lemma new_lemma_132347 (h0 : add_monoid (has_neg (option pos))) : add_monoid.fg (has_neg (option pos)) := sorry --non-trivial
lemma new_lemma_132348 (h0 : functor.add_const (complete_lattice (comm_group unsigned)) (comm_group Type)) : @is_atomistic.{0} (comm_group.{0} unsigned) (@functor.add_const.run.{0 1} (complete_lattice.{0} (comm_group.{0} unsigned)) (comm_group.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_132349 (h0 : function.extfun Type ring) : @strong_rank_condition.{0} (canonically_ordered_comm_semiring.{0} empty) (@function.extfun_app.{2 1} Type ring.{0} h0 (canonically_ordered_comm_semiring.{0} empty))  := sorry --non-trivial
lemma new_lemma_132350 (h0 : group (has_union (has_norm congr_arg_kind))) : normalizer_condition (has_union (has_norm congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_132351 (h0 : group (normed_lattice_add_comm_group (has_Inf real))) : group.fg (normed_lattice_add_comm_group (has_Inf real)) := sorry --non-trivial
lemma new_lemma_132352 (h0 : function.extfun Type topological_space) : @locally_compact_space.{0} (distrib_lattice.{0} char) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (distrib_lattice.{0} char))  := sorry --non-trivial
lemma new_lemma_132353 (h0 : functor.add_const (group (left_cancel_semigroup congr_arg_kind)) unsigned) : @is_cyclic.{0} (left_cancel_semigroup.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (group.{0} (left_cancel_semigroup.{0} congr_arg_kind)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_132354 (h0 : topological_space (uniform_space (mul_one_class (mul_one_class linarith.ineq)))) : t0_space (uniform_space (mul_one_class (mul_one_class linarith.ineq))) := sorry --non-trivial
lemma new_lemma_132355 (h0 : ring (dlist (random_gen (has_inv linarith.comp_source)))) : rank_condition (dlist (random_gen (has_inv linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_132356 (h0 : ring (canonically_linear_ordered_monoid (option (option (option ennreal))))) : is_principal_ideal_ring (canonically_linear_ordered_monoid (option (option (option ennreal)))) := sorry --non-trivial
lemma new_lemma_132357 (h0 : ring (parser string.iterator_imp)) : rank_condition (parser string.iterator_imp) := sorry --non-trivial
lemma new_lemma_132358 (h0 : function.extfun Type ring) : @strong_rank_condition.{0} (add_comm_monoid.{0} empty) (@function.extfun_app.{2 1} Type ring.{0} h0 (add_comm_monoid.{0} empty))  := sorry --non-trivial
lemma new_lemma_132359 (h0 : filter (has_nndist (has_add (finset (option name))))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_132360 (h0 : topological_space (non_unital_non_assoc_semiring string_imp)) : path_connected_space (non_unital_non_assoc_semiring string_imp) := sorry --non-trivial
lemma new_lemma_132361 (h0 : functor.add_const Prop (has_neg (has_neg_part Type))) : functor.add_const.run h0 := sorry --non-trivial
lemma new_lemma_132362 (h0 : functor.add_const (ring (complete_distrib_lattice pos)) linarith.comp) : @is_principal_ideal_ring.{0} (complete_distrib_lattice.{0} pos) (@functor.add_const.run.{0 0} (ring.{0} (complete_distrib_lattice.{0} pos)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_132363 (h0 : functor.add_const (topological_space (canonically_linear_ordered_monoid pos)) (option name)) : @sequential_space.{0} (canonically_linear_ordered_monoid.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (canonically_linear_ordered_monoid.{0} pos)) (option.{0} name) h0)  := sorry --non-trivial
lemma new_lemma_132364 (h0 : uniform_space (boolean_algebra.core (has_add (add_comm_monoid (has_add (has_add Type)))))) : complete_space (boolean_algebra.core (has_add (add_comm_monoid (has_add (has_add Type))))) := sorry --non-trivial
lemma new_lemma_132365 (h0 : function.extfun Type uniform_space) : @separated_space.{0} (finset.{0} name) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (finset.{0} name))  := sorry --non-trivial
lemma new_lemma_132366 (h0 : functor.add_const (topological_space (cancel_monoid pos)) (comm_group Type)) : @path_connected_space.{0} (cancel_monoid.{0} pos) (@functor.add_const.run.{0 1} (topological_space.{0} (cancel_monoid.{0} pos)) (comm_group.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_132367 (h0 : topological_space (ring linarith.comp)) : loc_path_connected_space (ring linarith.comp) := sorry --non-trivial
lemma new_lemma_132368 (h0 : functor.add_const (add_group (complete_distrib_lattice empty)) empty) : @is_add_cyclic.{0} (complete_distrib_lattice.{0} empty) (@functor.add_const.run.{0 0} (add_group.{0} (complete_distrib_lattice.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_132369 (h0 : list (has_top (distrib_lattice string_imp))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_132370 (h1 : set (has_ssubset ereal)) : set.finite h1 := sorry --non-trivial
lemma new_lemma_132371 (h0 : topological_space (add_comm_semigroup environment.projection_info)) : t0_space (add_comm_semigroup environment.projection_info) := sorry --non-trivial
lemma new_lemma_132372 (h0 : functor.add_const (topological_space (has_to_string Type)) congr_arg_kind) : @preconnected_space.{1} (has_to_string.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (has_to_string.{1} Type)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_132373 (h0 : list (has_top (has_top to_additive.value_type))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_132374 (h0 : has_mem.mem (has_top congr_arg_kind) has_emptyc.emptyc) : @locally_compact_space.{0} (has_top.{0} congr_arg_kind) (@finset.pi.empty.{1 0} Type topological_space.{0} (has_top.{0} congr_arg_kind) h0)  := sorry --non-trivial
lemma new_lemma_132375 (h0 : group (comm_ring to_additive.value_type)) : group.fg (comm_ring to_additive.value_type) := sorry --non-trivial
lemma new_lemma_132376 (h0 : ordered_add_comm_monoid (boolean_algebra Type)) : archimedean (boolean_algebra Type) := sorry --non-trivial
lemma new_lemma_132377 (h0 : functor.add_const (topological_space (mul_zero_class ennreal)) name) : @totally_disconnected_space.{0} (mul_zero_class.{0} ennreal) (@functor.add_const.run.{0 0} (topological_space.{0} (mul_zero_class.{0} ennreal)) name h0)  := sorry --non-trivial
lemma new_lemma_132378 (h0 : fin has_zero.zero) : @is_principal_ideal_ring.{0} (has_bot.{0} (has_add.{0} pos)) (@function.extfun_app.{2 1} Type ring.{0} (@matrix.vec_empty.{1} (function.extfun.{2 1} Type ring.{0}) h0) (has_bot.{0} (has_add.{0} pos)))  := sorry --non-trivial
lemma new_lemma_132379 (h0 : functor.comp topological_space has_to_string name) : @sequential_space.{0} (has_to_string.{0} name) (@functor.comp.run.{0 0 0} topological_space.{0} has_to_string.{0} name h0)  := sorry --non-trivial
lemma new_lemma_132380 (h0 : functor.add_const (topological_space (add_cancel_monoid Type)) Type) : @loc_path_connected_space.{1} (add_cancel_monoid.{1} Type) (@functor.add_const.run.{1 1} (topological_space.{1} (add_cancel_monoid.{1} Type)) Type h0)  := sorry --non-trivial
lemma new_lemma_132381 (h1 : measurable_space (nondiscrete_normed_field char)) (h2 : measure_theory.measure (nondiscrete_normed_field char)) : measure_theory.is_finite_measure h2 := sorry --non-trivial
lemma new_lemma_132382 (h0 : complete_lattice (has_lt std_gen)) : complete_lattice.is_Sup_finite_compact (has_lt std_gen) := sorry --non-trivial
lemma new_lemma_132383 (h0 : ring (has_add (has_Inf (has_Inf (has_pos_part (has_pos_part real)))))) : strong_rank_condition (has_add (has_Inf (has_Inf (has_pos_part (has_pos_part real))))) := sorry --non-trivial
lemma new_lemma_132384 (h0 : topological_space (has_Inf (ordered_ring name))) : regular_space (has_Inf (ordered_ring name)) := sorry --non-trivial
lemma new_lemma_132385 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @discrete_topology.{0} (add_right_cancel_monoid.{0} (option.{0} empty)) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (add_right_cancel_monoid.{0} (option.{0} empty)))  := sorry --non-trivial
lemma new_lemma_132386 (h0 : add_group (normed_group fun_info)) : is_add_cyclic (normed_group fun_info) := sorry --non-trivial
lemma new_lemma_132387 (h0 : functor.add_const (topological_space (boolean_algebra pos)) (has_zero (has_zero Type))) : @path_connected_space.{0} (boolean_algebra.{0} pos) (@functor.add_const.run.{0 1} (topological_space.{0} (boolean_algebra.{0} pos)) (has_zero.{1} (has_zero.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_132388 (h0 : functor.add_const (ring (has_neg_part name)) Type) : @is_domain.{0} (has_neg_part.{0} name) (@functor.add_const.run.{0 1} (ring.{0} (has_neg_part.{0} name)) Type h0)  := sorry --non-trivial
lemma new_lemma_132389 (h0 : complete_lattice (ring (ring (ring linarith.comp)))) : is_compactly_generated (ring (ring (ring linarith.comp))) := sorry --non-trivial
lemma new_lemma_132390 (h0 : functor.add_const (function.extfun Type finset) (finset (finset (finset (finset pos))))) : finset.nonempty (function.extfun_app (functor.add_const.run h0) (finset pos)) := sorry --non-trivial
lemma new_lemma_132391 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @path_connected_space.{1} (generalized_boolean_algebra.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 topological_space.{1}) (generalized_boolean_algebra.{1} Type))  := sorry --non-trivial
lemma new_lemma_132392 (h0 : uniform_space nnreal) : separated_space nnreal := sorry --non-trivial
lemma new_lemma_132393 (h0 : not (topological_space (has_nnnorm (comm_ring linarith.comp_source)) -> false)) : @t0_space.{0} (has_nnnorm.{0} (comm_ring.{0} linarith.comp_source)) (@classical.by_contradiction'.{1} (topological_space.{0} (has_nnnorm.{0} (comm_ring.{0} linarith.comp_source))) h0)  := sorry --non-trivial
lemma new_lemma_132394 (h0 : function.extfun Type add_group) : @is_add_cyclic.{0} (left_cancel_monoid.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type add_group.{0} h0 (left_cancel_monoid.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_132395 (h0 : finset (boolean_algebra (has_pos_part (finset linarith.comp)))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_132396 (h0 : function.extfun Type add_monoid) : @add_monoid.fg.{0} (simple_graph.{0} pos) (@function.extfun_app.{2 1} Type add_monoid.{0} h0 (simple_graph.{0} pos))  := sorry --non-trivial
lemma new_lemma_132397 (h0 : topological_space (mul_one_class string_imp)) : totally_disconnected_space (mul_one_class string_imp) := sorry --non-trivial
lemma new_lemma_132398 (h0 : ring (normed_field string.iterator_imp)) : is_domain (normed_field string.iterator_imp) := sorry --non-trivial
lemma new_lemma_132399 (h0 : group (normed_comm_ring Type)) : normalizer_condition (normed_comm_ring Type) := sorry --non-trivial
lemma new_lemma_132400 (h0 : function.extfun nat fin) : @t0_space.{0} (has_add.{0} linarith.comp) (@matrix.vec_empty.{0} (topological_space.{0} (has_add.{0} linarith.comp)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_132401 (h0 : complete_lattice (dlist (random_gen (random_gen (comm_ring fun_info))))) : complete_lattice.is_Sup_finite_compact (dlist (random_gen (random_gen (comm_ring fun_info)))) := sorry --non-trivial
lemma new_lemma_132402 (h0 : functor.add_const (uniform_space (comm_group name)) linarith.comp) : @complete_space.{0} (comm_group.{0} name) (@functor.add_const.run.{0 0} (uniform_space.{0} (comm_group.{0} name)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_132403 (h0 : function.extfun (finset Type) (has_mem.mem (with_one fun_info))) : @totally_separated_space.{0} (with_one.{0} fun_info) (@finset.pi.empty.{1 0} Type topological_space.{0} (with_one.{0} fun_info) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (with_one.{0} fun_info)) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_132404 (h0 : ring (ordered_comm_ring (ring linarith.comp))) : strong_rank_condition (ordered_comm_ring (ring linarith.comp)) := sorry --non-trivial
lemma new_lemma_132405 (h0 : topological_space (linear_ordered_comm_group (option empty))) : t0_space (linear_ordered_comm_group (option empty)) := sorry --non-trivial
lemma new_lemma_132406 (h0 : nat) (h1 : has_lt (fin h0)) : no_max_order (fin h0) := sorry --non-trivial
lemma new_lemma_132407 (h0 : complete_lattice (has_neg_part (has_add name))) : is_compactly_generated (has_neg_part (has_add name)) := sorry --non-trivial
lemma new_lemma_132408 (h0 : function.extfun Type monoid) : @monoid.fg.{0} (with_one.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type monoid.{0} h0 (with_one.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_132409 (h0 : complete_lattice (canonically_linear_ordered_monoid (option num))) : is_atomistic (canonically_linear_ordered_monoid (option num)) := sorry --non-trivial
lemma new_lemma_132410 (h0 : topological_space (has_dist (option ennreal))) : preirreducible_space (has_dist (option ennreal)) := sorry --non-trivial
lemma new_lemma_132411 (h0 : group (plift empty)) : group.fg (plift empty) := sorry --non-trivial
lemma new_lemma_132412 (h0 : complete_lattice (ordered_comm_ring (has_add (has_add Type)))) : complete_lattice.is_Sup_finite_compact (ordered_comm_ring (has_add (has_add Type))) := sorry --non-trivial
lemma new_lemma_132413 (h0 : topological_space (has_dist ennreal)) : loc_path_connected_space (has_dist ennreal) := sorry --non-trivial
lemma new_lemma_132414 (h0 : complete_lattice (with_one (has_top to_additive.value_type))) : complete_lattice.is_Sup_finite_compact (with_one (has_top to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_132415 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_compactly_generated.{0} (generalized_boolean_algebra.{0} real) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (generalized_boolean_algebra.{0} real))  := sorry --non-trivial
lemma new_lemma_132416 (h1 : set (has_ssubset (sub_neg_monoid ereal))) : set.finite h1 := sorry --non-trivial
lemma new_lemma_132417 (h1 : add_group (add_comm_semigroup reducibility_hints)) : is_add_cyclic (add_comm_semigroup reducibility_hints) := sorry --non-trivial
lemma new_lemma_132418 (h0 : topological_space (has_add (has_Inf (has_neg name)))) : normal_space (has_add (has_Inf (has_neg name))) := sorry --non-trivial
lemma new_lemma_132419 (h0 : complete_lattice (uniform_space (uniform_space linarith.ineq))) : complete_lattice.is_Sup_finite_compact (uniform_space (uniform_space linarith.ineq)) := sorry --non-trivial
lemma new_lemma_132420 (h0 : functor.add_const (topological_space (boolean_algebra pos)) linarith.comp) : @totally_disconnected_space.{0} (boolean_algebra.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (boolean_algebra.{0} pos)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_132421 (h0 : not (function.extfun Type group -> false)) : @group.fg.{0} (linear_ordered_add_comm_group.{0} fun_info) (@function.extfun_app.{2 1} Type group.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type group.{0}) h0) (linear_ordered_add_comm_group.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_132422 (h0 : topological_space (ordered_comm_monoid linarith.comp)) : sequential_space (ordered_comm_monoid linarith.comp) := sorry --non-trivial
lemma new_lemma_132423 (h0 : uniform_space (left_cancel_semigroup (semiring unsigned))) : separated_space (left_cancel_semigroup (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_132424 (h0 : set (has_ssubset (add_comm_semigroup char))) : set.finite h0 := sorry --non-trivial
lemma new_lemma_132425 (h0 : functor.add_const (topological_space (has_nndist name)) Type) : @normal_space.{0} (has_nndist.{0} name) (@functor.add_const.run.{0 1} (topological_space.{0} (has_nndist.{0} name)) Type h0)  := sorry --non-trivial
lemma new_lemma_132426 (h0 : ring (with_one (random_gen linarith.ineq))) : rank_condition (with_one (random_gen linarith.ineq)) := sorry --non-trivial
lemma new_lemma_132427 (h4 : complete_lattice (normed_field char)) : is_compactly_generated (normed_field char) := sorry --non-trivial
lemma new_lemma_132428 (h0 : topological_space (sub_neg_monoid (has_Inf (has_Inf Type)))) : loc_path_connected_space (sub_neg_monoid (has_Inf (has_Inf Type))) := sorry --non-trivial
lemma new_lemma_132429 (h0 : topological_space (has_div (mul_one_class string.iterator_imp))) : totally_disconnected_space (has_div (mul_one_class string.iterator_imp)) := sorry --non-trivial
lemma new_lemma_132430 (h0 : topological_space (mul_one_class (add_comm_semigroup (add_comm_semigroup enat)))) (h1 : set (mul_one_class (add_comm_semigroup (add_comm_semigroup enat)))) : is_seq_compact h1 := sorry --non-trivial
lemma new_lemma_132431 (h0 : topological_space (simple_graph linarith.comp_source)) (h1 : preorder (simple_graph linarith.comp_source)) : order_closed_topology (simple_graph linarith.comp_source) := sorry --non-trivial
lemma new_lemma_132432 (h0 : not (function.extfun (Type -> Type) (function.extfun Type) -> false)) : @separated_space.{0} (add_group.{0} num) (@function.extfun_app.{2 1} Type uniform_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) (@classical.by_contradiction'.{2} (function.extfun.{2 2} (Type → Type) (function.extfun.{2 1} Type)) h0) uniform_space.{0}) (add_group.{0} num))  := sorry --non-trivial
lemma new_lemma_132433 (h0 : topological_space (linear_ordered_comm_ring (semiring (has_top (semiring congr_arg_kind))))) : normal_space (linear_ordered_comm_ring (semiring (has_top (semiring congr_arg_kind)))) := sorry --non-trivial
lemma new_lemma_132434 (h0 : topological_space (generalized_boolean_algebra (has_pos_part Type))) : t1_space (generalized_boolean_algebra (has_pos_part Type)) := sorry --non-trivial
lemma new_lemma_132435 (h1 : ring (id congr_arg_kind)) : strong_rank_condition (id congr_arg_kind) := sorry --non-trivial
lemma new_lemma_132436 (h0 : ring (semi_normed_ring string.iterator_imp) -> Prop) (h1 : Exists (fun (x : ring (semi_normed_ring string.iterator_imp)), h0 x)) : @rank_condition.{0} (semi_normed_ring.{0} string.iterator_imp) (@classical.some.{1} (ring.{0} (semi_normed_ring.{0} string.iterator_imp)) h0 h1)  := sorry --non-trivial
lemma new_lemma_132437 (h0 : functor.add_const (list (ring environment.implicit_infer_kind)) (finset (has_neg environment.implicit_infer_kind))) : palindrome (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_132438 (h0 : functor.add_const (uniform_space (normed_comm_ring pos)) Type) : @complete_space.{0} (normed_comm_ring.{0} pos) (@functor.add_const.run.{0 1} (uniform_space.{0} (normed_comm_ring.{0} pos)) Type h0)  := sorry --non-trivial
lemma new_lemma_132439 (h0 : add_monoid (comm_monoid (option (option empty)))) : add_monoid.fg (comm_monoid (option (option empty))) := sorry --non-trivial
lemma new_lemma_132440 (h1 : group (measurable_space linarith.comp_source)) : is_cyclic (measurable_space linarith.comp_source) := sorry --non-trivial
lemma new_lemma_132441 (h0 : functor.add_const (topological_space (boolean_algebra.core unsigned)) linarith.comp) : @t1_space.{0} (boolean_algebra.core.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (boolean_algebra.core.{0} unsigned)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_132442 (h0 : function.extfun Type topological_space) : @preirreducible_space.{0} (random_gen.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (random_gen.{0} empty))  := sorry --non-trivial
lemma new_lemma_132443 (h0 : not (topological_space (has_star congr_arg_kind) -> false)) : @path_connected_space.{0} (has_star.{0} congr_arg_kind) (@classical.by_contradiction'.{1} (topological_space.{0} (has_star.{0} congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_132444 (h0 : functor.add_const (topological_space (boolean_algebra.core name)) Type) : @locally_compact_space.{0} (boolean_algebra.core.{0} name) (@functor.add_const.run.{0 1} (topological_space.{0} (boolean_algebra.core.{0} name)) Type h0)  := sorry --non-trivial
lemma new_lemma_132445 (h0 : function.extfun ((Type -> Type) -> Type 1) (function.extfun (Type -> Type))) : @strong_rank_condition.{0} (ring.{0} pos) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) (@function.extfun_app.{3 2} ((Type → Type) → Type 1) (function.extfun.{2 2} (Type → Type)) h0 (function.extfun.{2 1} Type)) ring.{0}) (ring.{0} pos))  := sorry --non-trivial
lemma new_lemma_132446 (h0 : topological_space (has_add (ring Type))) : locally_compact_space (has_add (ring Type)) := sorry --non-trivial
lemma new_lemma_132447 (h0 : has_star (non_assoc_semiring num) -> has_star (non_assoc_semiring num) -> Prop) : is_strict_order (has_star (non_assoc_semiring num)) h0 := sorry --non-trivial
lemma new_lemma_132448 (h0 : topological_space (complete_semilattice_Sup empty)) : discrete_topology (complete_semilattice_Sup empty) := sorry --non-trivial
lemma new_lemma_132449 (h0 : ordered_add_comm_monoid (canonically_ordered_add_monoid (complete_distrib_lattice (option (option empty))))) : archimedean (canonically_ordered_add_monoid (complete_distrib_lattice (option (option empty)))) := sorry --non-trivial
lemma new_lemma_132450 (h0 : topological_space (topological_space (has_ssubset (has_ssubset (has_ssubset string_imp))))) : path_connected_space (topological_space (has_ssubset (has_ssubset (has_ssubset string_imp)))) := sorry --non-trivial
lemma new_lemma_132451 (h0 : functor.add_const (topological_space (ordered_comm_group empty)) empty) : @preirreducible_space.{0} (ordered_comm_group.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (ordered_comm_group.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_132452 (h0 : not (complete_lattice (simple_graph string_imp) -> false)) : @is_compactly_generated.{0} (simple_graph.{0} string_imp) (@classical.by_contradiction'.{1} (complete_lattice.{0} (simple_graph.{0} string_imp)) h0)  := sorry --non-trivial
lemma new_lemma_132453 (h0 : functor.add_const (complete_lattice (has_dist unsigned)) num) : @is_compactly_generated.{0} (has_dist.{0} unsigned) (@functor.add_const.run.{0 0} (complete_lattice.{0} (has_dist.{0} unsigned)) num h0)  := sorry --non-trivial
lemma new_lemma_132454 (h0 : functor.add_const (topological_space (has_Inf name)) pos) : @regular_space.{0} (has_Inf.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (has_Inf.{0} name)) pos h0)  := sorry --non-trivial
lemma new_lemma_132455 (h0 : set (has_compl (mul_one_class char))) : set.subsingleton h0 := sorry --non-trivial
lemma new_lemma_132456 (h0 : topological_space (comm_semigroup pos)) : t0_space (comm_semigroup pos) := sorry --non-trivial
lemma new_lemma_132457 (h0 : topological_space (with_bot (random_gen (random_gen (has_inv linarith.ineq))))) : locally_compact_space (with_bot (random_gen (random_gen (has_inv linarith.ineq)))) := sorry --non-trivial
lemma new_lemma_132458 (h0 : topological_space (complete_semilattice_Sup (has_nnnorm (random_gen to_additive.value_type)))) : t0_space (complete_semilattice_Sup (has_nnnorm (random_gen to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_132459 (h0 : functor.add_const Prop (comm_group linarith.comp)) : functor.add_const.run h0 := sorry --non-trivial
lemma new_lemma_132460 (h0 : not (function.extfun Type complete_lattice -> false)) : @complete_lattice.is_Sup_finite_compact.{0} (linear_ordered_semiring.{0} linarith.comp) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type complete_lattice.{0}) h0) (linear_ordered_semiring.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_132461 (h0 : add_group (has_top congr_arg_kind)) : is_add_cyclic (has_top congr_arg_kind) := sorry --non-trivial
lemma new_lemma_132462 (h0 : topological_space (add_right_cancel_monoid num)) : totally_disconnected_space (add_right_cancel_monoid num) := sorry --non-trivial
lemma new_lemma_132463 (h0 : ring (has_append (metric_space (metric_space (metric_space linarith.comp_source))))) : strong_rank_condition (has_append (metric_space (metric_space (metric_space linarith.comp_source)))) := sorry --non-trivial
lemma new_lemma_132464 (h3 : complete_lattice string.iterator_imp) : complete_lattice.is_Sup_finite_compact string.iterator_imp := sorry --non-trivial
lemma new_lemma_132465 (h0 : topological_space (measurable_space (random_gen to_additive.value_type))) : totally_separated_space (measurable_space (random_gen to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_132466 (h0 : complete_lattice (has_norm (semiring fun_info))) : is_atomistic (has_norm (semiring fun_info)) := sorry --non-trivial
lemma new_lemma_132467 (h0 : function.extfun Type group) : @group.fg.{0} (ring.{0} linarith.comp) (@function.extfun_app.{2 1} Type group.{0} h0 (ring.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_132468 (h0 : functor.add_const (filter (has_neg environment.implicit_infer_kind)) environment.implicit_infer_kind) : filter.ne_bot (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_132469 (h0 : complete_lattice (add_cancel_monoid (add_comm_monoid (has_add (has_add (has_add Type)))))) : is_compactly_generated (add_cancel_monoid (add_comm_monoid (has_add (has_add (has_add Type))))) := sorry --non-trivial
lemma new_lemma_132470 (h0 : functor.add_const (finset (boolean_algebra.core environment.implicit_infer_kind)) Type) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_132471 (h0 : topological_space (semiring (semiring empty))) : topological_space.separable_space (semiring (semiring empty)) := sorry --non-trivial
lemma new_lemma_132472 (h0 : topological_space (has_union (has_union unsigned))) : t0_space (has_union (has_union unsigned)) := sorry --non-trivial
lemma new_lemma_132473 (h0 : not (ring (comm_ring to_additive.value_type) -> false)) : @rank_condition.{0} (comm_ring.{0} to_additive.value_type) (@classical.by_contradiction'.{1} (ring.{0} (comm_ring.{0} to_additive.value_type)) h0)  := sorry --non-trivial
lemma new_lemma_132474 (h0 : topological_space (has_pos_part (canonically_linear_ordered_monoid (has_Inf real)))) : locally_compact_space (has_pos_part (canonically_linear_ordered_monoid (has_Inf real))) := sorry --non-trivial
lemma new_lemma_132475 (h0 : not (group (has_ssubset linarith.comp) -> false)) : @is_cyclic.{0} (has_ssubset.{0} linarith.comp) (@classical.by_contradiction'.{1} (group.{0} (has_ssubset.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_132476 (h0 : not (group (measure_theory.measure_space unsigned) -> false)) : @is_cyclic.{0} (measure_theory.measure_space.{0} unsigned) (@classical.by_contradiction'.{1} (group.{0} (measure_theory.measure_space.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_132477 (h0 : function.extfun ((Type -> Type) -> Type 1) (function.extfun (Type -> Type))) : @t0_space.{0} (has_inter.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) (@function.extfun_app.{3 2} ((Type → Type) → Type 1) (function.extfun.{2 2} (Type → Type)) h0 (function.extfun.{2 1} Type)) topological_space.{0}) (has_inter.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_132478 (h0 : function.extfun Type topological_space) : @t0_space.{0} (encodable.{0} char) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (encodable.{0} char))  := sorry --non-trivial
lemma new_lemma_132479 (h0 : functor.add_const (topological_space (has_neg_part unsigned)) linarith.comp) : @normal_space.{0} (has_neg_part.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (has_neg_part.{0} unsigned)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_132480 (h0 : list (has_nndist (has_neg pos))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_132481 (h0 : topological_space (monoid_with_zero ennreal)) : t1_space (monoid_with_zero ennreal) := sorry --non-trivial
lemma new_lemma_132482 (h0 : function.extfun Type complete_lattice) : @is_compactly_generated.{0} (@id.{2} Type string_imp) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (@id.{2} Type string_imp))  := sorry --non-trivial
lemma new_lemma_132483 (h0 : uniform_space (boolean_algebra (finset (has_add linarith.comp)))) : separated_space (boolean_algebra (finset (has_add linarith.comp))) := sorry --non-trivial
lemma new_lemma_132484 (h0 : topological_space (has_to_string (has_add ennreal))) : loc_path_connected_space (has_to_string (has_add ennreal)) := sorry --non-trivial
lemma new_lemma_132485 (h0 : topological_space name) : t1_space name := sorry --non-trivial
lemma new_lemma_132486 (h0 : filter (ring (boolean_algebra name))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_132487 (h0 : complete_lattice (div_inv_monoid (with_zero fun_info))) : is_compactly_generated (div_inv_monoid (with_zero fun_info)) := sorry --non-trivial
lemma new_lemma_132488 (h1 : add_group (semi_normed_ring enat)) : is_add_cyclic (semi_normed_ring enat) := sorry --non-trivial
lemma new_lemma_132489 (h0 : topological_space (uniform_space (mul_one_class linarith.ineq))) : t0_space (uniform_space (mul_one_class linarith.ineq)) := sorry --non-trivial
lemma new_lemma_132490 (h0 : group (canonically_ordered_monoid (has_neg (has_neg (has_neg name))))) : is_cyclic (canonically_ordered_monoid (has_neg (has_neg (has_neg name)))) := sorry --non-trivial
lemma new_lemma_132491 (h0 : prod (has_zero (finset Type)) (has_zero (finset Type))) : id_rel h0 := sorry --non-trivial
lemma new_lemma_132492 (h0 : topological_space (has_union (semiring congr_arg_kind))) : preirreducible_space (has_union (semiring congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_132493 (h1 : add_group (has_lt string.iterator_imp)) : is_add_cyclic (has_lt string.iterator_imp) := sorry --non-trivial
lemma new_lemma_132494 (h0 : prod empty empty) : id_rel h0 := sorry --non-trivial
lemma new_lemma_132495 (h0 : function.extfun Type (prod (option unsigned))) : id_rel (function.extfun_app h0 (option unsigned)) := sorry --non-trivial
lemma new_lemma_132496 (h2 : group (with_one num)) : normalizer_condition (with_one num) := sorry --non-trivial
lemma new_lemma_132497 (h0 : functor.add_const (group (normed_comm_ring pos)) Type) : @group.fg.{0} (normed_comm_ring.{0} pos) (@functor.add_const.run.{0 1} (group.{0} (normed_comm_ring.{0} pos)) Type h0)  := sorry --non-trivial
lemma new_lemma_132498 (h0 : topological_space (bin_tree unsigned)) : t1_space (bin_tree unsigned) := sorry --non-trivial
lemma new_lemma_132499 (h0 : function.extfun Type ordered_comm_monoid) : @has_exists_mul_of_le.{0} (semigroup.{0} unsigned) (@function.extfun_app.{2 1} Type ordered_comm_monoid.{0} h0 (semigroup.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_132500 (h0 : fin has_zero.zero) : @loc_path_connected_space.{1} (sub_neg_monoid.{1} Type) (@matrix.vec_empty.{1} (topological_space.{1} (sub_neg_monoid.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_132501 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @preirreducible_space.{0} (has_inter.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_inter.{0} num))  := sorry --non-trivial
lemma new_lemma_132502 (h0 : complete_lattice (semigroup num)) : is_compactly_generated (semigroup num) := sorry --non-trivial
lemma new_lemma_132503 (h0 : ring pos) : strong_rank_condition pos := sorry --non-trivial
lemma new_lemma_132504 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_atomistic.{0} (has_nndist.{0} unsigned) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (has_nndist.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_132505 (h0 : functor.add_const (complete_lattice (has_dist congr_arg_kind)) congr_arg_kind) : @complete_lattice.is_Sup_finite_compact.{0} (has_dist.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (complete_lattice.{0} (has_dist.{0} congr_arg_kind)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_132506 (h0 : topological_space (linear_ordered_add_comm_monoid_with_top (option empty))) : t1_space (linear_ordered_add_comm_monoid_with_top (option empty)) := sorry --non-trivial
lemma new_lemma_132507 (h0 : topological_space (add_comm_semigroup linarith.ineq)) (h1 : add_group (add_comm_semigroup linarith.ineq)) : topological_add_group (add_comm_semigroup linarith.ineq) := sorry --non-trivial
lemma new_lemma_132508 (h0 : function.extfun (finset Type) (has_mem.mem (with_bot linarith.comp))) : @is_atomistic.{0} (with_bot.{0} linarith.comp) (@finset.pi.empty.{1 0} Type complete_lattice.{0} (with_bot.{0} linarith.comp) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (with_bot.{0} linarith.comp)) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_132509 (h0 : uniform_space (semigroup (semigroup environment.implicit_infer_kind))) : separated_space (semigroup (semigroup environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_132510 (h0 : finset (finset (has_Inf pos))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_132511 (h0 : function.extfun Type topological_space) : @irreducible_space.{0} (has_norm.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_norm.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_132512 (h0 : functor.add_const (add_monoid (ring Type)) Type) : @add_monoid.fg.{1} (ring.{1} Type) (@functor.add_const.run.{1 1} (add_monoid.{1} (ring.{1} Type)) Type h0)  := sorry --non-trivial
lemma new_lemma_132513 (h0 : function.extfun Type uniform_space) : @separated_space.{0} (mul_zero_class.{0} num) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (mul_zero_class.{0} num))  := sorry --non-trivial
lemma new_lemma_132514 (h0 : filter (has_one (semiring congr_arg_kind))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_132515 (h0 : functor.add_const (add_group (canonically_ordered_comm_semiring name)) ennreal) : @is_add_cyclic.{0} (canonically_ordered_comm_semiring.{0} name) (@functor.add_const.run.{0 0} (add_group.{0} (canonically_ordered_comm_semiring.{0} name)) ennreal h0)  := sorry --non-trivial
lemma new_lemma_132516 (h0 : functor.add_const (add_group (ring pos)) (has_add name)) : @is_add_cyclic.{0} (ring.{0} pos) (@functor.add_const.run.{0 0} (add_group.{0} (ring.{0} pos)) (has_add.{0} name) h0)  := sorry --non-trivial
lemma new_lemma_132517 (h0 : filter (has_to_string (has_add (has_add (has_add (has_add (has_add name))))))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_132518 (h0 : topological_space (comm_group unsigned)) : path_connected_space (comm_group unsigned) := sorry --non-trivial
lemma new_lemma_132519 (h0 : complete_lattice (linear_ordered_semiring unsigned)) : complete_lattice.is_Sup_finite_compact (linear_ordered_semiring unsigned) := sorry --non-trivial
lemma new_lemma_132520 (h0 : group (has_zero (has_to_string pos))) : group.fg (has_zero (has_to_string pos)) := sorry --non-trivial
lemma new_lemma_132521 (h1 : measurable_space reducibility_hints) (h2 : filter reducibility_hints) : filter.is_measurably_generated h2 := sorry --non-trivial
lemma new_lemma_132522 (h0 : fin has_zero.zero) : @monoid.fg.{0} (generalized_boolean_algebra.{0} pos) (@function.extfun_app.{2 1} Type monoid.{0} (@matrix.vec_empty.{1} (function.extfun.{2 1} Type monoid.{0}) h0) (generalized_boolean_algebra.{0} pos))  := sorry --non-trivial
lemma new_lemma_132523 (h0 : topological_space (canonically_ordered_monoid (has_Inf Type))) : topological_space.separable_space (canonically_ordered_monoid (has_Inf Type)) := sorry --non-trivial
lemma new_lemma_132524 (h0 : complete_lattice (measurable_space (has_norm empty))) : is_atomistic (measurable_space (has_norm empty)) := sorry --non-trivial
lemma new_lemma_132525 (h1 : uniform_space (distrib_lattice linarith.ineq)) : complete_space (distrib_lattice linarith.ineq) := sorry --non-trivial
lemma new_lemma_132526 (h0 : topological_space (add_comm_monoid (ring pos))) : regular_space (add_comm_monoid (ring pos)) := sorry --non-trivial
lemma new_lemma_132527 (h0 : functor.add_const (ring (has_neg_part name)) name) : @is_domain.{0} (has_neg_part.{0} name) (@functor.add_const.run.{0 0} (ring.{0} (has_neg_part.{0} name)) name h0)  := sorry --non-trivial
lemma new_lemma_132528 (h0 : complete_lattice (with_one (has_ssubset string_imp))) : is_compactly_generated (with_one (has_ssubset string_imp)) := sorry --non-trivial
lemma new_lemma_132529 (h0 : functor.add_const (list (has_to_string linarith.comp)) (finset linarith.comp)) : palindrome (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_132530 (h0 : monoid (with_one (measurable_space (with_one (with_one string_imp))))) : monoid.fg (with_one (measurable_space (with_one (with_one string_imp)))) := sorry --non-trivial
lemma new_lemma_132531 (h0 : function.extfun Type topological_space) : @preirreducible_space.{0} (linear_ordered_cancel_comm_monoid.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (linear_ordered_cancel_comm_monoid.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_132532 (h0 : not (function.extfun Type uniform_space -> false)) : @separated_space.{0} num (@function.extfun_app.{2 1} Type uniform_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type uniform_space.{0}) h0) num)  := sorry --non-trivial
lemma new_lemma_132533 (h0 : topological_space (semi_normed_comm_ring (has_nnnorm (has_nnnorm linarith.comp_source)))) : t0_space (semi_normed_comm_ring (has_nnnorm (has_nnnorm linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_132534 (h0 : topological_space (comm_group (has_add (has_bot Type)))) : preconnected_space (comm_group (has_add (has_bot Type))) := sorry --non-trivial
lemma new_lemma_132535 (h0 : functor.add_const (topological_space (semigroup unsigned)) (has_neg (has_neg linarith.comp))) : @normal_space.{0} (semigroup.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (semigroup.{0} unsigned)) (has_neg.{0} (has_neg.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_132536 (h0 : has_mem.mem (complete_semilattice_Sup congr_arg_kind) has_emptyc.emptyc) : @is_cyclic.{0} (complete_semilattice_Sup.{0} congr_arg_kind) (@finset.pi.empty.{1 0} Type group.{0} (complete_semilattice_Sup.{0} congr_arg_kind) h0)  := sorry --non-trivial
lemma new_lemma_132537 (h1 : uniform_space (mul_one_class std_gen)) : complete_space (mul_one_class std_gen) := sorry --non-trivial
lemma new_lemma_132538 (h0 : group (topological_space (random_gen (random_gen to_additive.value_type)))) : is_cyclic (topological_space (random_gen (random_gen to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_132539 (h0 : topological_space (normed_field (has_to_string char))) (h1 : set (normed_field (has_to_string char))) : is_path_connected h1 := sorry --non-trivial
lemma new_lemma_132540 (h0 : functor.add_const (filter (canonically_ordered_comm_semiring name)) Type) : filter.ne_bot (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_132541 (h0 : complete_lattice (generalized_boolean_algebra (sub_neg_monoid name))) : is_atomistic (generalized_boolean_algebra (sub_neg_monoid name)) := sorry --non-trivial
lemma new_lemma_132542 (h0 : functor.add_const (topological_space znum) num) : @path_connected_space.{0} znum (@functor.add_const.run.{0 0} (topological_space.{0} znum) num h0)  := sorry --non-trivial
lemma new_lemma_132543 (h0 : complete_lattice (has_top (has_inv (has_inv (random_gen to_additive.value_type))))) : is_atomistic (has_top (has_inv (has_inv (random_gen to_additive.value_type)))) := sorry --non-trivial
lemma new_lemma_132544 (h0 : not (function.extfun Type topological_space -> false)) : @path_connected_space.{0} (has_sub.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (has_sub.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_132545 (h0 : topological_space (ring linarith.comp)) : regular_space (ring linarith.comp) := sorry --non-trivial
lemma new_lemma_132546 (h0 : set (add_comm_semigroup ereal -> add_comm_semigroup (add_comm_semigroup (metric_space ereal)))) : set.separates_points h0 := sorry --non-trivial
lemma new_lemma_132547 (h0 : function.extfun num (fun (x : num), Prop)) : exists_unique (function.extfun_app h0) := sorry --non-trivial
lemma new_lemma_132548 (h0 : functor.add_const (ring (has_pos_part Type)) (generalized_boolean_algebra (complete_distrib_lattice pos))) : @rank_condition.{1} (has_pos_part.{1} Type) (@functor.add_const.run.{1 0} (ring.{1} (has_pos_part.{1} Type)) (generalized_boolean_algebra.{0} (complete_distrib_lattice.{0} pos)) h0)  := sorry --non-trivial
lemma new_lemma_132549 (h0 : complete_semilattice_Sup congr_arg_kind -> complete_semilattice_Sup congr_arg_kind -> Prop) : is_strict_order (complete_semilattice_Sup congr_arg_kind) h0 := sorry --non-trivial
lemma new_lemma_132550 (h0 : functor.add_const (add_monoid (ordered_ring congr_arg_kind)) empty) : @add_monoid.fg.{0} (ordered_ring.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (add_monoid.{0} (ordered_ring.{0} congr_arg_kind)) empty h0)  := sorry --non-trivial
lemma new_lemma_132551 (h0 : topological_space (has_neg (semigroup (add_comm_monoid environment.implicit_infer_kind)))) : locally_compact_space (has_neg (semigroup (add_comm_monoid environment.implicit_infer_kind))) := sorry --non-trivial
lemma new_lemma_132552 (h0 : monoid (normed_group (has_top (has_top fun_info)))) : monoid.fg (normed_group (has_top (has_top fun_info))) := sorry --non-trivial
lemma new_lemma_132553 (h0 : not (function.extfun Type list -> false)) : list.nodup (function.extfun_app (classical.by_contradiction' h0) (has_top to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_132554 (h0 : topological_space (has_pos_part (has_Inf pos))) : discrete_topology (has_pos_part (has_Inf pos)) := sorry --non-trivial
lemma new_lemma_132555 (h0 : uniform_space (canonically_linear_ordered_monoid (has_Inf pos))) : separated_space (canonically_linear_ordered_monoid (has_Inf pos)) := sorry --non-trivial
lemma new_lemma_132556 (h0 : prod (semigroup (semiring empty)) (semigroup (semiring empty))) : id_rel h0 := sorry --non-trivial
lemma new_lemma_132557 (h0 : not (function.extfun Type topological_space -> false)) : @totally_disconnected_space.{0} (denumerable.{0} fun_info) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (denumerable.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_132558 (h0 : function.extfun Type ordered_comm_monoid) : @has_exists_mul_of_le.{0} (canonically_linear_ordered_monoid.{0} unsigned) (@function.extfun_app.{2 1} Type ordered_comm_monoid.{0} h0 (canonically_linear_ordered_monoid.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_132559 (h0 : add_comm_monoid (pseudo_metric_space unsigned) -> add_comm_monoid (pseudo_metric_space unsigned) -> Prop) : is_symm (add_comm_monoid (pseudo_metric_space unsigned)) h0 := sorry --non-trivial
lemma new_lemma_132560 (h0 : function.extfun Type topological_space) : @totally_disconnected_space.{0} (ordered_comm_ring.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (ordered_comm_ring.{0} name))  := sorry --non-trivial
lemma new_lemma_132561 (h3 : topological_space (add_comm_semigroup linarith.ineq)) : t0_space (add_comm_semigroup linarith.ineq) := sorry --non-trivial
lemma new_lemma_132562 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @t0_space.{0} pos (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) pos)  := sorry --non-trivial
lemma new_lemma_132563 (h0 : group (has_nndist (has_nndist pos))) : group.fg (has_nndist (has_nndist pos)) := sorry --non-trivial
lemma new_lemma_132564 (h0 : add_monoid (has_add (option (option (option congr_arg_kind))))) : add_monoid.fg (has_add (option (option (option congr_arg_kind)))) := sorry --non-trivial
lemma new_lemma_132565 (h0 : group (has_Sup (option empty))) : is_cyclic (has_Sup (option empty)) := sorry --non-trivial
lemma new_lemma_132566 (h0 : not (ring (with_bot linarith.comp) -> false)) : @strong_rank_condition.{0} (with_bot.{0} linarith.comp) (@classical.by_contradiction'.{1} (ring.{0} (with_bot.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_132567 (h0 : not (topological_space (semi_normed_ring (has_compl (random_gen (distrib (has_lt char))))) -> false)) : @path_connected_space.{0} (semi_normed_ring.{0} (has_compl.{0} (random_gen.{0} (distrib.{0} (has_lt.{0} char))))) (@classical.by_contradiction'.{1} (topological_space.{0} (semi_normed_ring.{0} (has_compl.{0} (random_gen.{0} (distrib.{0} (has_lt.{0} char)))))) h0)  := sorry --non-trivial
lemma new_lemma_132568 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : finset.nonempty (function.extfun_app (function.extfun_app h0 finset) (has_add Type)) := sorry --non-trivial
lemma new_lemma_132569 (h0 : topological_space (has_nndist ennreal)) : totally_separated_space (has_nndist ennreal) := sorry --non-trivial
lemma new_lemma_132570 (h1 : ring (topological_space (has_nnnorm (random_gen char)))) : rank_condition (topological_space (has_nnnorm (random_gen char))) := sorry --non-trivial
lemma new_lemma_132571 (h0 : fin has_zero.zero) : @strong_rank_condition.{0} (has_one.{0} unsigned) (@matrix.vec_empty.{0} (ring.{0} (has_one.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_132572 (h0 : functor.add_const (group (semigroup pos)) pos) : @is_cyclic.{0} (semigroup.{0} pos) (@functor.add_const.run.{0 0} (group.{0} (semigroup.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_132573 (h0 : functor.add_const (cancel_comm_monoid_with_zero (add_group num)) empty) : @unique_factorization_monoid.{0} (add_group.{0} num) (@functor.add_const.run.{0 0} (cancel_comm_monoid_with_zero.{0} (add_group.{0} num)) empty h0)  := sorry --non-trivial
lemma new_lemma_132574 (h0 : not (ring (add_monoid fun_info) -> false)) : @strong_rank_condition.{0} (add_monoid.{0} fun_info) (@classical.by_contradiction'.{1} (ring.{0} (add_monoid.{0} fun_info)) h0)  := sorry --non-trivial
lemma new_lemma_132575 (h0 : add_group (pseudo_metric_space (option (option ennreal)))) : is_add_cyclic (pseudo_metric_space (option (option ennreal))) := sorry --non-trivial
lemma new_lemma_132576 (h0 : topological_space (has_edist empty)) : loc_path_connected_space (has_edist empty) := sorry --non-trivial
lemma new_lemma_132577 (h0 : functor.add_const (topological_space (has_add Type)) Type) : @normal_space.{1} (has_add.{1} Type) (@functor.add_const.run.{1 1} (topological_space.{1} (has_add.{1} Type)) Type h0)  := sorry --non-trivial
lemma new_lemma_132578 (h0 : set (normed_field to_additive.value_type)) : set.subsingleton h0 := sorry --non-trivial
lemma new_lemma_132579 (h0 : functor.comp topological_space has_zero unsigned) : @loc_path_connected_space.{0} (has_zero.{0} unsigned) (@functor.comp.run.{0 0 0} topological_space.{0} has_zero.{0} unsigned h0)  := sorry --non-trivial
lemma new_lemma_132580 (h0 : list (boolean_algebra.core (boolean_algebra (comm_group (has_zero name))))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_132581 (h0 : uniform_space (with_zero (has_nnnorm (has_nnnorm (has_nnnorm fun_info))))) : complete_space (with_zero (has_nnnorm (has_nnnorm (has_nnnorm fun_info)))) := sorry --non-trivial
lemma new_lemma_132582 (h0 : uniform_space (boolean_algebra.core unsigned)) : complete_space (boolean_algebra.core unsigned) := sorry --non-trivial
lemma new_lemma_132583 (h0 : ring (random_gen (has_inv linarith.ineq))) : rank_condition (random_gen (has_inv linarith.ineq)) := sorry --non-trivial
lemma new_lemma_132584 (h0 : functor.comp group boolean_algebra name) : @group.fg.{0} (boolean_algebra.{0} name) (@functor.comp.run.{0 0 0} group.{0} boolean_algebra.{0} name h0)  := sorry --non-trivial
lemma new_lemma_132585 (h0 : ring (has_compl (has_nnnorm linarith.ineq))) : strong_rank_condition (has_compl (has_nnnorm linarith.ineq)) := sorry --non-trivial
lemma new_lemma_132586 (h0 : topological_space (normed_group num)) : locally_compact_space (normed_group num) := sorry --non-trivial
lemma new_lemma_132587 (h0 : function.extfun Type ring) : @is_principal_ideal_ring.{0} (boolean_algebra.core.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type ring.{0} h0 (boolean_algebra.core.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_132588 (h0 : function.extfun Type topological_space) : @totally_separated_space.{0} (comm_monoid.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (comm_monoid.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_132589 (h0 : topological_space (mul_zero_class (ordered_cancel_comm_monoid congr_arg_kind))) : t1_space (mul_zero_class (ordered_cancel_comm_monoid congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_132590 (h0 : complete_lattice (has_top (random_gen (random_gen num)))) : is_compactly_generated (has_top (random_gen (random_gen num))) := sorry --non-trivial
lemma new_lemma_132591 (h0 : list (bin_tree (semiring empty))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_132592 (h0 : functor.add_const (topological_space (linear_ordered_cancel_comm_monoid empty)) empty) : @totally_disconnected_space.{0} (linear_ordered_cancel_comm_monoid.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (linear_ordered_cancel_comm_monoid.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_132593 (h0 : topological_space (simple_graph (boolean_algebra.core (has_add Type)))) : preirreducible_space (simple_graph (boolean_algebra.core (has_add Type))) := sorry --non-trivial
lemma new_lemma_132594 (h0 : topological_space (finset (has_to_string (has_to_string (finset (has_to_string unsigned)))))) : preirreducible_space (finset (has_to_string (has_to_string (finset (has_to_string unsigned))))) := sorry --non-trivial
lemma new_lemma_132595 (h0 : cancel_comm_monoid_with_zero (canonically_ordered_comm_semiring (finset pos))) : unique_factorization_monoid (canonically_ordered_comm_semiring (finset pos)) := sorry --non-trivial
lemma new_lemma_132596 (h0 : function.extfun Type complete_lattice) : @is_compactly_generated.{0} string_imp (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 string_imp)  := sorry --non-trivial
lemma new_lemma_132597 (h0 : not (topological_space (has_union linarith.comp) -> false)) : @preirreducible_space.{0} (has_union.{0} linarith.comp) (@classical.by_contradiction'.{1} (topological_space.{0} (has_union.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_132598 (h0 : uniform_space (comm_monoid (option (option empty)))) : separated_space (comm_monoid (option (option empty))) := sorry --non-trivial
lemma new_lemma_132599 (h0 : list (add_right_cancel_monoid (semiring (semiring empty)))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_132600 (h0 : functor.add_const (add_group (canonically_ordered_comm_semiring name)) environment.implicit_infer_kind) : @is_add_cyclic.{0} (canonically_ordered_comm_semiring.{0} name) (@functor.add_const.run.{0 0} (add_group.{0} (canonically_ordered_comm_semiring.{0} name)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_132601 (h0 : function.extfun Type uniform_space) : @complete_space.{0} (add_cancel_monoid.{0} unsigned) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (add_cancel_monoid.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_132602 (h0 : uniform_space (has_to_string (has_add name))) : separated_space (has_to_string (has_add name)) := sorry --non-trivial
lemma new_lemma_132603 (h0 : functor.add_const (topological_space (has_add pos)) environment.implicit_infer_kind) : @discrete_topology.{0} (has_add.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (has_add.{0} pos)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_132604 (h0 : ring (distrib (random_gen fun_info))) : rank_condition (distrib (random_gen fun_info)) := sorry --non-trivial
lemma new_lemma_132605 (h2 : topological_space (complete_semilattice_Sup to_additive.value_type)) : path_connected_space (complete_semilattice_Sup to_additive.value_type) := sorry --non-trivial
lemma new_lemma_132606 (h0 : complete_lattice (boolean_algebra (comm_group (comm_group (comm_group unsigned))))) : is_compactly_generated (boolean_algebra (comm_group (comm_group (comm_group unsigned)))) := sorry --non-trivial
lemma new_lemma_132607 (h0 : group (as_linear_order empty)) : normalizer_condition (as_linear_order empty) := sorry --non-trivial
lemma new_lemma_132608 (h2 : topological_space (distrib_lattice (has_nnnorm fun_info))) : totally_disconnected_space (distrib_lattice (has_nnnorm fun_info)) := sorry --non-trivial
lemma new_lemma_132609 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @preirreducible_space.{0} (comm_group.{0} (option.{0} unsigned)) (@functor.comp.run.{0 0 0} topological_space.{0} comm_group.{0} (option.{0} unsigned) (@function.extfun_app.{2 1} Type (functor.comp.{0 0 0} topological_space.{0} comm_group.{0}) (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 (functor.comp.{0 0 0} topological_space.{0} comm_group.{0})) (option.{0} unsigned)))  := sorry --non-trivial
lemma new_lemma_132610 (h0 : uniform_space (is_R_or_C congr_arg_kind)) : complete_space (is_R_or_C congr_arg_kind) := sorry --non-trivial
lemma new_lemma_132611 (h0 : topological_space (has_norm (semiring unsigned))) : discrete_topology (has_norm (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_132612 (h0 : topological_space (is_R_or_C (option (option unsigned)))) : locally_compact_space (is_R_or_C (option (option unsigned))) := sorry --non-trivial
lemma new_lemma_132613 (h0 : topological_space (has_top (has_norm (metric_space num)))) : normal_space (has_top (has_norm (metric_space num))) := sorry --non-trivial
lemma new_lemma_132614 (h0 : not (topological_space (measurable_space num) -> false)) : @path_connected_space.{0} (measurable_space.{0} num) (@classical.by_contradiction'.{1} (topological_space.{0} (measurable_space.{0} num)) h0)  := sorry --non-trivial
lemma new_lemma_132615 (h0 : function.extfun Type (functor.comp topological_space has_to_string)) : @preconnected_space.{0} (has_to_string.{0} pos) (@functor.comp.run.{0 0 0} topological_space.{0} has_to_string.{0} pos (@function.extfun_app.{2 1} Type (functor.comp.{0 0 0} topological_space.{0} has_to_string.{0}) h0 pos))  := sorry --non-trivial
lemma new_lemma_132616 (h0 : not (function.extfun Type topological_space -> false)) : @totally_separated_space.{0} (linear_ordered_semiring.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (linear_ordered_semiring.{0} num))  := sorry --non-trivial
lemma new_lemma_132617 (h0 : has_mul (ordered_comm_monoid linarith.comp)) (h1 : ordered_comm_monoid linarith.comp) : is_right_regular h1 := sorry --non-trivial
lemma new_lemma_132618 (h0 : topological_space (has_ssubset (has_nnnorm to_additive.value_type))) : locally_compact_space (has_ssubset (has_nnnorm to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_132619 (h0 : not (uniform_space (bin_tree unsigned) -> false)) : @separated_space.{0} (bin_tree.{0} unsigned) (@classical.by_contradiction'.{1} (uniform_space.{0} (bin_tree.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_132620 (h0 : group (has_inv (has_norm to_additive.value_type))) : is_cyclic (has_inv (has_norm to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_132621 (h0 : topological_space (mul_one_class (mul_one_class (mul_one_class std_gen)))) : totally_disconnected_space (mul_one_class (mul_one_class (mul_one_class std_gen))) := sorry --non-trivial
lemma new_lemma_132622 (h0 : functor.add_const (complete_lattice (is_R_or_C empty)) num) : @is_atomistic.{0} (is_R_or_C.{0} empty) (@functor.add_const.run.{0 0} (complete_lattice.{0} (is_R_or_C.{0} empty)) num h0)  := sorry --non-trivial
lemma new_lemma_132623 (h0 : ring (mv_power_series (semilattice_inf linarith.comp_source) fun_info)) : rank_condition (mv_power_series (semilattice_inf linarith.comp_source) fun_info) := sorry --non-trivial
lemma new_lemma_132624 (h0 : functor.add_const (topological_space (boolean_algebra name)) name) : @totally_separated_space.{0} (boolean_algebra.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (boolean_algebra.{0} name)) name h0)  := sorry --non-trivial
lemma new_lemma_132625 (h0 : has_pos_part real -> has_pos_part real -> Prop) : transitive h0 := sorry --non-trivial
lemma new_lemma_132626 (h0 : not (function.extfun Type topological_space -> false)) : @t0_space.{0} (normed_group.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (normed_group.{0} empty))  := sorry --non-trivial
lemma new_lemma_132627 (h0 : ring stieltjes_function) : rank_condition stieltjes_function := sorry --non-trivial
lemma new_lemma_132628 (h0 : function.extfun (finset (Type -> Type)) (has_mem.mem add_group)) : @is_add_cyclic.{0} (semiring.{0} unsigned) (@function.extfun_app.{2 1} Type add_group.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) add_group.{0} (@function.extfun_app.{2 0} (finset.{1} (Type → Type)) (@has_mem.mem.{1 1} (Type → Type) (finset.{1} (Type → Type)) (@finset.has_mem.{1} (Type → Type)) add_group.{0}) h0 (@has_emptyc.emptyc.{1} (finset.{1} (Type → Type)) (@finset.has_emptyc.{1} (Type → Type))))) (semiring.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_132629 (h0 : add_monoid (has_norm (semiring linarith.comp))) : add_monoid.fg (has_norm (semiring linarith.comp)) := sorry --non-trivial
lemma new_lemma_132630 (h0 : functor.add_const (topological_space nnreal) num) : preirreducible_space nnreal := sorry --non-trivial
lemma new_lemma_132631 (h0 : function.extfun Type linear_ordered_comm_group) : palindrome (list.ret (function.extfun_app h0 ennreal)) := sorry --non-trivial
lemma new_lemma_132632 (h0 : function.extfun Type topological_space) : @totally_separated_space.{0} (add_cancel_monoid.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (add_cancel_monoid.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_132633 (h0 : functor.add_const (function.extfun Type complete_lattice) (has_Inf (has_Inf (has_pos_part Type)))) : @complete_lattice.is_Sup_finite_compact.{0} (has_nndist.{0} pos) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type complete_lattice.{0}) (has_Inf.{1} (has_Inf.{1} (has_pos_part.{1} Type))) h0) (has_nndist.{0} pos))  := sorry --non-trivial
lemma new_lemma_132634 (h1 : topological_space (non_unital_non_assoc_semiring string_imp)) : path_connected_space (non_unital_non_assoc_semiring string_imp) := sorry --non-trivial
lemma new_lemma_132635 (h0 : not (complete_lattice (has_nnnorm linarith.comp_source) -> false)) : @is_compactly_generated.{0} (has_nnnorm.{0} linarith.comp_source) (@classical.by_contradiction'.{1} (complete_lattice.{0} (has_nnnorm.{0} linarith.comp_source)) h0)  := sorry --non-trivial
lemma new_lemma_132636 (h0 : add_group (add_cancel_monoid (random_gen char))) : is_add_cyclic (add_cancel_monoid (random_gen char)) := sorry --non-trivial
lemma new_lemma_132637 (h0 : topological_space (has_nnnorm (has_nnnorm (has_nnnorm (has_nnnorm reducibility_hints))))) : totally_disconnected_space (has_nnnorm (has_nnnorm (has_nnnorm (has_nnnorm reducibility_hints)))) := sorry --non-trivial
lemma new_lemma_132638 (h0 : topological_space (has_sub (semiring (semiring congr_arg_kind)))) : totally_disconnected_space (has_sub (semiring (semiring congr_arg_kind))) := sorry --non-trivial
lemma new_lemma_132639 (h0 : fin has_zero.zero) : @preirreducible_space.{0} (generalized_boolean_algebra.{0} real) (@function.extfun_app.{2 1} Type topological_space.{0} (@matrix.vec_empty.{1} (function.extfun.{2 1} Type topological_space.{0}) h0) (generalized_boolean_algebra.{0} real))  := sorry --non-trivial
lemma new_lemma_132640 (h0 : functor.comp add_group complete_distrib_lattice pos) : @is_add_cyclic.{0} (complete_distrib_lattice.{0} pos) (@functor.comp.run.{0 0 0} add_group.{0} complete_distrib_lattice.{0} pos h0)  := sorry --non-trivial
lemma new_lemma_132641 (h0 : functor.add_const (topological_space (finset linarith.comp)) (has_neg Type)) : @preconnected_space.{0} (finset.{0} linarith.comp) (@functor.add_const.run.{0 1} (topological_space.{0} (finset.{0} linarith.comp)) (has_neg.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_132642 (h0 : topological_space (add_cancel_monoid (ring (has_add (normed_lattice_add_comm_group linarith.comp))))) : discrete_topology (add_cancel_monoid (ring (has_add (normed_lattice_add_comm_group linarith.comp)))) := sorry --non-trivial
lemma new_lemma_132643 (h0 : has_coe (nondiscrete_normed_field (add_comm_semigroup (add_comm_semigroup fun_info))) Prop) (h1 : nondiscrete_normed_field (add_comm_semigroup (add_comm_semigroup fun_info))) : @coe_b.{1 1} (nondiscrete_normed_field.{0} (add_comm_semigroup.{0} (add_comm_semigroup.{0} fun_info))) Prop h0 h1  := sorry --non-trivial
lemma new_lemma_132644 (h0 : functor.add_const (group (has_neg unsigned)) name) : @normalizer_condition.{0} (has_neg.{0} unsigned) (@functor.add_const.run.{0 0} (group.{0} (has_neg.{0} unsigned)) name h0)  := sorry --non-trivial
lemma new_lemma_132645 (h0 : fin has_zero.zero) : @has_exists_mul_of_le.{0} (ordered_comm_ring.{0} real) (@matrix.vec_empty.{0} (ordered_comm_monoid.{0} (ordered_comm_ring.{0} real)) h0)  := sorry --non-trivial
lemma new_lemma_132646 (h0 : function.extfun Type topological_space) : @totally_separated_space.{0} (has_top.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_top.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_132647 (h0 : topological_space (with_zero (has_inv to_additive.value_type))) : totally_disconnected_space (with_zero (has_inv to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_132648 (h0 : ring (linear_ordered_add_comm_group (random_gen (non_assoc_semiring char)))) : is_domain (linear_ordered_add_comm_group (random_gen (non_assoc_semiring char))) := sorry --non-trivial
lemma new_lemma_132649 (h1 : set (distrib linarith.ineq)) : set.finite h1 := sorry --non-trivial
lemma new_lemma_132650 (h0 : filter (topological_space (uniform_space reducibility_hints))) : @totally_disconnected_space.{0} (uniform_space.{0} reducibility_hints) (@filter.Limsup.{0} (topological_space.{0} (uniform_space.{0} reducibility_hints)) (@complete_lattice.to_conditionally_complete_lattice.{0} (topological_space.{0} (uniform_space.{0} reducibility_hints)) (@topological_space.complete_lattice.{0} (uniform_space.{0} reducibility_hints))) h0)  := sorry --non-trivial
lemma new_lemma_132651 (h0 : functor.add_const (filter (free_add_monoid empty)) num) : filter.ne_bot (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_132652 (h0 : functor.add_const (topological_space (preorder empty)) num) : @totally_disconnected_space.{0} (preorder.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (preorder.{0} empty)) num h0)  := sorry --non-trivial
lemma new_lemma_132653 (h0 : ring (has_union (semiring (semiring congr_arg_kind)))) : strong_rank_condition (has_union (semiring (semiring congr_arg_kind))) := sorry --non-trivial
lemma new_lemma_132654 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @irreducible_space.{0} (option.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (option.{0} pos))  := sorry --non-trivial
lemma new_lemma_132655 (h0 : not (topological_space (distrib string_imp) -> false)) : @t0_space.{0} (distrib.{0} string_imp) (@classical.by_contradiction'.{1} (topological_space.{0} (distrib.{0} string_imp)) h0)  := sorry --non-trivial
lemma new_lemma_132656 (h0 : not (topological_space (add_group congr_arg_kind) -> false)) : @discrete_topology.{0} (add_group.{0} congr_arg_kind) (@classical.by_contradiction'.{1} (topological_space.{0} (add_group.{0} congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_132657 (h0 : not (multiset (semi_normed_ring linarith.ineq) -> false)) (h1 : multiset (semi_normed_ring linarith.ineq)) : multiset.disjoint (classical.by_contradiction' h0) h1 := sorry --non-trivial
lemma new_lemma_132658 (h0 : ring (has_Inf (finset (has_pos_part pos)))) : is_domain (has_Inf (finset (has_pos_part pos))) := sorry --non-trivial
lemma new_lemma_132659 (h0 : ring ordering) : is_domain ordering := sorry --non-trivial
lemma new_lemma_132660 (h0 : complete_lattice (boolean_algebra.core linarith.comp_source)) : is_compactly_generated (boolean_algebra.core linarith.comp_source) := sorry --non-trivial
lemma new_lemma_132661 (h0 : semiring (ordered_cancel_add_comm_monoid (option (option (option (option unsigned)))))) : is_noetherian_ring (ordered_cancel_add_comm_monoid (option (option (option (option unsigned))))) := sorry --non-trivial
lemma new_lemma_132662 (h0 : false) (h1 : preorder (has_nnnorm environment.projection_info)) : @order_closed_topology.{0} (has_nnnorm.{0} environment.projection_info) (@false.elim.{1} (topological_space.{0} (has_nnnorm.{0} environment.projection_info)) h0) h1  := sorry --trivial
lemma new_lemma_132663 (h0 : function.extfun Type uniform_space) : @separated_space.{0} (canonically_ordered_comm_semiring.{0} num) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (canonically_ordered_comm_semiring.{0} num))  := sorry --non-trivial
lemma new_lemma_132664 (h0 : functor.add_const (topological_space (normed_comm_ring Type)) Type) : @preirreducible_space.{1} (normed_comm_ring.{1} Type) (@functor.add_const.run.{1 1} (topological_space.{1} (normed_comm_ring.{1} Type)) Type h0)  := sorry --non-trivial
lemma new_lemma_132665 (h0 : uniform_space (add_group (semiring unsigned))) : separated_space (add_group (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_132666 (h0 : topological_space (topological_space linarith.comp_source)) : totally_disconnected_space (topological_space linarith.comp_source) := sorry --non-trivial
lemma new_lemma_132667 (h0 : set (set (add_comm_semigroup char))) (h1 : add_comm_semigroup char) : set.sInter h0 h1 := sorry --non-trivial
lemma new_lemma_132668 (h0 : fin has_zero.zero) : @archimedean.{0} (finset.{0} pos) (@matrix.vec_empty.{0} (ordered_add_comm_monoid.{0} (finset.{0} pos)) h0)  := sorry --non-trivial
lemma new_lemma_132669 (h0 : functor.add_const (monoid (has_nndist Type)) Type) : @monoid.fg.{1} (has_nndist.{1} Type) (@functor.add_const.run.{1 1} (monoid.{1} (has_nndist.{1} Type)) Type h0)  := sorry --non-trivial
lemma new_lemma_132670 (h0 : topological_space std_gen) (h1 : has_add std_gen) : has_continuous_add std_gen := sorry --non-trivial
lemma new_lemma_132671 (h3 : list (has_norm num)) : list.nodup h3 := sorry --non-trivial
lemma new_lemma_132672 (h0 : topological_space (boolean_algebra (has_to_string (has_neg linarith.comp)))) : loc_path_connected_space (boolean_algebra (has_to_string (has_neg linarith.comp))) := sorry --non-trivial
lemma new_lemma_132673 (h0 : function.extfun Type uniform_space) : @complete_space.{0} (has_nndist.{0} num) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (has_nndist.{0} num))  := sorry --non-trivial
lemma new_lemma_132674 (h0 : filter (has_one (semiring (semiring (semiring unsigned))))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_132675 (h0 : topological_space (add_group (has_top empty))) : path_connected_space (add_group (has_top empty)) := sorry --non-trivial
lemma new_lemma_132676 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @locally_compact_space.{0} (distrib_lattice.{0} fun_info) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (distrib_lattice.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_132677 (h0 : functor.add_const (group (simple_graph linarith.comp)) Type) : @normalizer_condition.{0} (simple_graph.{0} linarith.comp) (@functor.add_const.run.{0 1} (group.{0} (simple_graph.{0} linarith.comp)) Type h0)  := sorry --non-trivial
lemma new_lemma_132678 (h0 : complete_lattice (add_comm_monoid (has_neg_part name))) : is_compactly_generated (add_comm_monoid (has_neg_part name)) := sorry --non-trivial
lemma new_lemma_132679 (h0 : add_monoid ennreal) (h1 : function.extfun Type has_one) : char_zero ennreal := sorry --non-trivial
lemma new_lemma_132680 (h0 : function.extfun Type uniform_space) : @separated_space.{0} (non_assoc_semiring.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (non_assoc_semiring.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_132681 (h0 : function.extfun Type ordered_comm_monoid) : @has_exists_mul_of_le.{0} (linear_ordered_field.{0} pos) (@function.extfun_app.{2 1} Type ordered_comm_monoid.{0} h0 (linear_ordered_field.{0} pos))  := sorry --non-trivial
lemma new_lemma_132682 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @monoid.fg.{0} (has_neg_part.{0} pos) (@function.extfun_app.{2 1} Type monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 monoid.{0}) (has_neg_part.{0} pos))  := sorry --non-trivial
lemma new_lemma_132683 (h0 : function.extfun nat fin) : @is_cyclic.{1} (canonically_ordered_comm_semiring.{1} Type) (@matrix.vec_empty.{1} (group.{1} (canonically_ordered_comm_semiring.{1} Type)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_132684 (h0 : not (ring (has_lt linarith.comp_source) -> false)) : @strong_rank_condition.{0} (has_lt.{0} linarith.comp_source) (@classical.by_contradiction'.{1} (ring.{0} (has_lt.{0} linarith.comp_source)) h0)  := sorry --non-trivial
lemma new_lemma_132685 (h0 : add_group (semi_normed_comm_ring (comm_ring char))) : is_add_cyclic (semi_normed_comm_ring (comm_ring char)) := sorry --non-trivial
lemma new_lemma_132686 (h0 : function.extfun (Type 1) topological_space) : @totally_separated_space.{1} (has_Inf.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} h0 (has_Inf.{1} Type))  := sorry --non-trivial
lemma new_lemma_132687 (h0 : functor.add_const (topological_space (canonically_ordered_add_monoid empty)) empty) : @totally_disconnected_space.{0} (canonically_ordered_add_monoid.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (canonically_ordered_add_monoid.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_132688 (h0 : topological_space (has_union (semiring (semiring congr_arg_kind)))) : preirreducible_space (has_union (semiring (semiring congr_arg_kind))) := sorry --non-trivial
lemma new_lemma_132689 (h0 : group (add_cancel_monoid (has_add Type))) : group.fg (add_cancel_monoid (has_add Type)) := sorry --non-trivial
lemma new_lemma_132690 (h0 : functor.add_const (topological_space (has_nndist name)) environment.implicit_infer_kind) : @totally_disconnected_space.{0} (has_nndist.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (has_nndist.{0} name)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_132691 (h0 : function.extfun Type topological_space) (h1 : group ennreal) : topological_group ennreal := sorry --non-trivial
lemma new_lemma_132692 (h0 : filter (cancel_monoid (has_add (finset Type)))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_132693 (h0 : ring (ordered_comm_ring (has_Inf real))) : is_principal_ideal_ring (ordered_comm_ring (has_Inf real)) := sorry --non-trivial
lemma new_lemma_132694 (h0 : not (topological_space (complete_semilattice_Sup linarith.comp) -> false)) : @normal_space.{0} (complete_semilattice_Sup.{0} linarith.comp) (@classical.by_contradiction'.{1} (topological_space.{0} (complete_semilattice_Sup.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_132695 (h0 : topological_space (has_pos_part name)) : topological_space.separable_space (has_pos_part name) := sorry --non-trivial
lemma new_lemma_132696 (h0 : not (function.extfun Type uniform_space -> false)) : @separated_space.{0} (add_right_cancel_monoid.{0} empty) (@function.extfun_app.{2 1} Type uniform_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type uniform_space.{0}) h0) (add_right_cancel_monoid.{0} empty))  := sorry --non-trivial
lemma new_lemma_132697 (h0 : semiring (id (has_norm (semiring (has_top congr_arg_kind))))) : is_noetherian_ring (id (has_norm (semiring (has_top congr_arg_kind)))) := sorry --non-trivial
lemma new_lemma_132698 (h0 : complete_lattice (mul_zero_class (finset pos))) : complete_lattice.is_Sup_finite_compact (mul_zero_class (finset pos)) := sorry --non-trivial
lemma new_lemma_132699 (h0 : not (complete_lattice (id unsigned) -> false)) : @is_compactly_generated.{0} (@id.{2} Type unsigned) (@classical.by_contradiction'.{1} (complete_lattice.{0} (@id.{2} Type unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_132700 (h0 : topological_space (linear_ordered_semiring (semiring (has_top (random_gen (has_norm empty)))))) : discrete_topology (linear_ordered_semiring (semiring (has_top (random_gen (has_norm empty))))) := sorry --non-trivial
lemma new_lemma_132701 (h0 : function.extfun nat fin) : @sequential_space.{0} (has_add.{0} real) (@matrix.vec_empty.{0} (topological_space.{0} (has_add.{0} real)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_132702 (h0 : functor.add_const (topological_space (cancel_monoid environment.implicit_infer_kind)) pos) : @preconnected_space.{0} (cancel_monoid.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (cancel_monoid.{0} environment.implicit_infer_kind)) pos h0)  := sorry --non-trivial
lemma new_lemma_132703 (h0 : add_group (has_neg (has_add linarith.comp))) : is_add_cyclic (has_neg (has_add linarith.comp)) := sorry --non-trivial
lemma new_lemma_132704 (h0 : has_mem.mem Type has_emptyc.emptyc) : @separated_space.{1} Type (@finset.pi.empty.{2 1} (Type 1) uniform_space.{1} Type h0)  := sorry --non-trivial
lemma new_lemma_132705 (h0 : topological_space (has_bot (finset linarith.comp))) : irreducible_space (has_bot (finset linarith.comp)) := sorry --non-trivial
lemma new_lemma_132706 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @path_connected_space.{1} (has_neg_part.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 topological_space.{1}) (has_neg_part.{1} Type))  := sorry --non-trivial
lemma new_lemma_132707 (h0 : ring (ordered_comm_group (option empty))) : is_principal_ideal_ring (ordered_comm_group (option empty)) := sorry --non-trivial
lemma new_lemma_132708 (h0 : topological_space (linear_ordered_comm_ring (semiring (semiring unsigned)))) : normal_space (linear_ordered_comm_ring (semiring (semiring unsigned))) := sorry --non-trivial
lemma new_lemma_132709 (h0 : semiring (has_edist (option (option (option (option empty)))))) : is_noetherian_ring (has_edist (option (option (option (option empty))))) := sorry --non-trivial
lemma new_lemma_132710 (h0 : topological_space (finset name)) : loc_path_connected_space (finset name) := sorry --non-trivial
lemma new_lemma_132711 (h0 : thunk (fin has_zero.zero)) : @id.{1} Prop (@ulower.up.{0} Prop encodable.Prop (@matrix.vec_empty.{0} (@ulower.{0} Prop encodable.Prop) (@trace_call_stack.{0} (fin (@has_zero.zero.{0} nat nat.has_zero)) h0)))  := sorry --non-trivial
lemma new_lemma_132712 (h0 : add_group (has_nnnorm (mul_one_class (mul_one_class linarith.comp_source)))) : is_add_cyclic (has_nnnorm (mul_one_class (mul_one_class linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_132713 (h1 : not (function.extfun Type complete_lattice -> false)) : @is_compactly_generated.{0} (with_bot.{0} fun_info) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type complete_lattice.{0}) h1) (with_bot.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_132714 (h0 : functor.add_const (ring (comm_monoid empty)) empty) : @is_principal_ideal_ring.{0} (comm_monoid.{0} empty) (@functor.add_const.run.{0 0} (ring.{0} (comm_monoid.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_132715 (h0 : functor.add_const Prop (has_nndist (has_nndist unsigned))) : functor.add_const.run h0 := sorry --non-trivial
lemma new_lemma_132716 (h1 : function.extfun Type list) : list.nodup (function.extfun_app h1 (random_gen string_imp)) := sorry --non-trivial
lemma new_lemma_132717 (h0 : topological_space (linear_ordered_add_comm_group (has_top (has_top linarith.comp_source)))) : path_connected_space (linear_ordered_add_comm_group (has_top (has_top linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_132718 (h0 : functor.add_const (topological_space (add_comm_monoid empty)) num) : @locally_compact_space.{0} (add_comm_monoid.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (add_comm_monoid.{0} empty)) num h0)  := sorry --non-trivial
lemma new_lemma_132719 (h0 : monoid (sub_neg_monoid (has_pos_part linarith.comp))) : monoid.fg (sub_neg_monoid (has_pos_part linarith.comp)) := sorry --non-trivial
lemma new_lemma_132720 (h0 : topological_space (has_bot (has_Inf (sub_neg_monoid (has_Inf (has_Inf pos)))))) : discrete_topology (has_bot (has_Inf (sub_neg_monoid (has_Inf (has_Inf pos))))) := sorry --non-trivial
lemma new_lemma_132721 (h0 : function.extfun Type ring) : @rank_condition.{0} (add_cancel_monoid.{0} (option.{0} unsigned)) (@function.extfun_app.{2 1} Type ring.{0} h0 (add_cancel_monoid.{0} (option.{0} unsigned)))  := sorry --non-trivial
lemma new_lemma_132722 (h0 : topological_space (has_emptyc fun_info)) : discrete_topology (has_emptyc fun_info) := sorry --non-trivial
lemma new_lemma_132723 (h3 : add_group (distrib_lattice fun_info)) : is_add_cyclic (distrib_lattice fun_info) := sorry --non-trivial
lemma new_lemma_132724 (h0 : finset (linear_ordered_cancel_comm_monoid (option empty))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_132725 (h0 : topological_space (linear_ordered_comm_group (option pos))) : preirreducible_space (linear_ordered_comm_group (option pos)) := sorry --non-trivial
lemma new_lemma_132726 (h0 : uniform_space (ring (has_neg (has_neg name)))) : separated_space (ring (has_neg (has_neg name))) := sorry --non-trivial
lemma new_lemma_132727 (h0 : complete_lattice real.angle) : complete_lattice.is_Sup_finite_compact real.angle := sorry --non-trivial
lemma new_lemma_132728 (h0 : prod std_gen std_gen) : id_rel h0 := sorry --non-trivial
lemma new_lemma_132729 (h0 : function.extfun Type list) : list.nodup (function.extfun_app h0 (linear_ordered_comm_ring empty)) := sorry --non-trivial
lemma new_lemma_132730 (h0 : list (uniform_space (add_cancel_monoid (option unsigned)))) : @separated_space.{0} (add_cancel_monoid.{0} (option.{0} unsigned)) (@list.head.{0} (uniform_space.{0} (add_cancel_monoid.{0} (option.{0} unsigned))) (@inhabited_uniform_space.{0} (add_cancel_monoid.{0} (option.{0} unsigned))) h0)  := sorry --non-trivial
lemma new_lemma_132731 (h0 : topological_space (add_comm_monoid (cancel_monoid name))) : t1_space (add_comm_monoid (cancel_monoid name)) := sorry --non-trivial
lemma new_lemma_132732 (h0 : group (has_inv (has_ssubset linarith.ineq))) : group.fg (has_inv (has_ssubset linarith.ineq)) := sorry --non-trivial
lemma new_lemma_132733 (h0 : not (topological_space (with_bot num) -> false)) : @preirreducible_space.{0} (with_bot.{0} num) (@classical.by_contradiction'.{1} (topological_space.{0} (with_bot.{0} num)) h0)  := sorry --non-trivial
lemma new_lemma_132734 (h0 : functor.add_const (topological_space (boolean_algebra unsigned)) pos) : @regular_space.{0} (boolean_algebra.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (boolean_algebra.{0} unsigned)) pos h0)  := sorry --non-trivial
lemma new_lemma_132735 (h0 : cancel_comm_monoid_with_zero (left_cancel_monoid (semiring empty))) : unique_factorization_monoid (left_cancel_monoid (semiring empty)) := sorry --non-trivial
lemma new_lemma_132736 (h0 : preorder (has_ssubset (mul_one_class char))) (h1 : set (has_ssubset (mul_one_class char))) : set.is_pwo h1 := sorry --non-trivial
lemma new_lemma_132737 (h0 : complete_lattice (add_left_cancel_monoid to_additive.value_type)) : complete_lattice.is_Sup_finite_compact (add_left_cancel_monoid to_additive.value_type) := sorry --non-trivial
lemma new_lemma_132738 (h0 : not (group (topological_space char) -> false)) : @is_cyclic.{0} (topological_space.{0} char) (@classical.by_contradiction'.{1} (group.{0} (topological_space.{0} char)) h0)  := sorry --non-trivial
lemma new_lemma_132739 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @t0_space.{0} (with_bot.{0} linarith.ineq) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (with_bot.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_132740 (h0 : group (linear_ordered_add_comm_group (random_gen linarith.comp_source))) : is_cyclic (linear_ordered_add_comm_group (random_gen linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_132741 (h0 : uniform_space (measurable_space (semiring num))) : complete_space (measurable_space (semiring num)) := sorry --non-trivial
lemma new_lemma_132742 (h0 : topological_space (boolean_algebra.core (add_comm_monoid Type))) : locally_compact_space (boolean_algebra.core (add_comm_monoid Type)) := sorry --non-trivial
lemma new_lemma_132743 (h0 : group (complete_linear_order (semiring unsigned))) : normalizer_condition (complete_linear_order (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_132744 (h0 : list (dlist (has_top (random_gen (has_nnnorm linarith.ineq))))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_132745 (h0 : topological_space (cancel_monoid congr_arg_kind)) : preconnected_space (cancel_monoid congr_arg_kind) := sorry --non-trivial
lemma new_lemma_132746 (h0 : ordered_comm_monoid (has_add (has_zero Type))) : has_exists_mul_of_le (has_add (has_zero Type)) := sorry --non-trivial
lemma new_lemma_132747 (h0 : topological_space (has_neg_part (comm_group (has_add environment.implicit_infer_kind)))) : discrete_topology (has_neg_part (comm_group (has_add environment.implicit_infer_kind))) := sorry --non-trivial
lemma new_lemma_132748 (h0 : function.extfun Type filter) : filter.ne_bot (function.extfun_app h0 (with_one string_imp)) := sorry --non-trivial
lemma new_lemma_132749 (h0 : finset (rel occurrences unsigned)) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_132750 (h0 : functor.add_const (ordered_add_comm_monoid (ordered_ring congr_arg_kind)) unsigned) : @archimedean.{0} (ordered_ring.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (ordered_add_comm_monoid.{0} (ordered_ring.{0} congr_arg_kind)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_132751 (h0 : functor.add_const (topological_space (generalized_boolean_algebra pos)) pos) : @normal_space.{0} (generalized_boolean_algebra.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (generalized_boolean_algebra.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_132752 (h0 : topological_space (has_union unsigned)) : t0_space (has_union unsigned) := sorry --non-trivial
lemma new_lemma_132753 (h1 : topological_space (add_comm_semigroup (mul_one_class (add_comm_semigroup ereal)))) : path_connected_space (add_comm_semigroup (mul_one_class (add_comm_semigroup ereal))) := sorry --non-trivial
lemma new_lemma_132754 (h0 : functor.add_const (function.extfun (Type 1) topological_space) Type) : @discrete_topology.{1} (semigroup.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@functor.add_const.run.{2 1} (function.extfun.{3 2} (Type 1) topological_space.{1}) Type h0) (semigroup.{1} Type))  := sorry --non-trivial
lemma new_lemma_132755 (h1 : group (normed_field linarith.ineq)) : is_cyclic (normed_field linarith.ineq) := sorry --non-trivial
lemma new_lemma_132756 (h0 : functor.add_const (function.extfun Type cancel_comm_monoid_with_zero) Type) : @unique_factorization_monoid.{0} (add_cancel_monoid.{0} linarith.comp) (@function.extfun_app.{2 1} Type cancel_comm_monoid_with_zero.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type cancel_comm_monoid_with_zero.{0}) Type h0) (add_cancel_monoid.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_132757 (h0 : functor.add_const (function.extfun Type cancel_comm_monoid_with_zero) ennreal) : @unique_factorization_monoid.{0} (has_neg_part.{0} pos) (@function.extfun_app.{2 1} Type cancel_comm_monoid_with_zero.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type cancel_comm_monoid_with_zero.{0}) ennreal h0) (has_neg_part.{0} pos))  := sorry --non-trivial
lemma new_lemma_132758 (h0 : monoid (has_neg (has_pos_part pos))) : monoid.fg (has_neg (has_pos_part pos)) := sorry --non-trivial
lemma new_lemma_132759 (h0 : function.extfun Type ring) : @strong_rank_condition.{0} (random_gen.{0} empty) (@function.extfun_app.{2 1} Type ring.{0} h0 (random_gen.{0} empty))  := sorry --non-trivial
lemma new_lemma_132760 (h0 : topological_space (has_top (semiring empty))) : path_connected_space (has_top (semiring empty)) := sorry --non-trivial
lemma new_lemma_132761 (h0 : function.extfun Type topological_space) : @path_connected_space.{0} (canonically_ordered_comm_semiring.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (canonically_ordered_comm_semiring.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_132762 (h0 : functor.add_const (topological_space (normed_comm_ring linarith.comp)) linarith.comp) : @totally_disconnected_space.{0} (normed_comm_ring.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (normed_comm_ring.{0} linarith.comp)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_132763 (h0 : topological_space (ordered_cancel_add_comm_monoid (option empty))) : preirreducible_space (ordered_cancel_add_comm_monoid (option empty)) := sorry --non-trivial
lemma new_lemma_132764 (h0 : add_group (linear_ordered_field char)) : is_add_cyclic (linear_ordered_field char) := sorry --non-trivial
lemma new_lemma_132765 (h0 : functor.add_const (topological_space (ring name)) Type) : @t0_space.{0} (ring.{0} name) (@functor.add_const.run.{0 1} (topological_space.{0} (ring.{0} name)) Type h0)  := sorry --non-trivial
lemma new_lemma_132766 (h0 : has_mem.mem (normed_group congr_arg_kind) has_emptyc.emptyc) : @rank_condition.{0} (normed_group.{0} congr_arg_kind) (@finset.pi.empty.{1 0} Type ring.{0} (normed_group.{0} congr_arg_kind) h0)  := sorry --non-trivial
lemma new_lemma_132767 (h0 : has_lt (normed_field (mul_one_class string.iterator_imp))) : no_max_order (normed_field (mul_one_class string.iterator_imp)) := sorry --non-trivial
lemma new_lemma_132768 (h0 : not (filter (has_sub empty) -> false)) : filter.ne_bot (classical.by_contradiction' h0) := sorry --non-trivial
lemma new_lemma_132769 (h0 : functor.add_const (topological_space (semigroup name)) environment.implicit_infer_kind) : @locally_compact_space.{0} (semigroup.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (semigroup.{0} name)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_132770 (h0 : topological_space (has_to_string (finset ennreal))) : preirreducible_space (has_to_string (finset ennreal)) := sorry --non-trivial
lemma new_lemma_132771 (h0 : ordered_add_comm_monoid (has_add (ring Type))) : archimedean (has_add (ring Type)) := sorry --non-trivial
lemma new_lemma_132772 (h0 : add_monoid (comm_group (has_add (has_neg_part (has_to_string (has_add pos)))))) : add_monoid.fg (comm_group (has_add (has_neg_part (has_to_string (has_add pos))))) := sorry --non-trivial
lemma new_lemma_132773 (h0 : topological_space (canonically_ordered_monoid (has_Inf Type))) : normal_space (canonically_ordered_monoid (has_Inf Type)) := sorry --non-trivial
lemma new_lemma_132774 (h0 : topological_space (partial_order empty)) : locally_compact_space (partial_order empty) := sorry --non-trivial
lemma new_lemma_132775 (h0 : function.extfun Type semiring) : @is_noetherian_ring.{0} (add_semigroup.{0} unsigned) (@function.extfun_app.{2 1} Type semiring.{0} h0 (add_semigroup.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_132776 (h0 : filter (semiring (has_norm linarith.comp))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_132777 (h0 : topological_space (ordered_cancel_add_comm_monoid congr_arg_kind)) : t0_space (ordered_cancel_add_comm_monoid congr_arg_kind) := sorry --non-trivial
lemma new_lemma_132778 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @complete_lattice.is_Sup_finite_compact.{1} (add_comm_monoid.{1} Type) (@function.extfun_app.{3 2} (Type 1) complete_lattice.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 complete_lattice.{1}) (add_comm_monoid.{1} Type))  := sorry --non-trivial
lemma new_lemma_132779 (h0 : topological_space (has_to_string (option congr_arg_kind))) : topological_space.separable_space (has_to_string (option congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_132780 (h0 : function.extfun Type topological_space) : @path_connected_space.{0} (monoid_with_zero.{0} ennreal) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (monoid_with_zero.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_132781 (h0 : ring (random_gen (comm_ring reducibility_hints))) : strong_rank_condition (random_gen (comm_ring reducibility_hints)) := sorry --non-trivial
lemma new_lemma_132782 (h0 : semiring (simple_graph name)) : is_noetherian_ring (simple_graph name) := sorry --non-trivial
lemma new_lemma_132783 (h0 : uniform_space (add_right_cancel_monoid enat)) : complete_space (add_right_cancel_monoid enat) := sorry --non-trivial
lemma new_lemma_132784 (h0 : add_group (denumerable (has_inv (random_gen linarith.comp_source)))) : is_add_cyclic (denumerable (has_inv (random_gen linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_132785 (h0 : functor.add_const (filter (canonically_ordered_comm_semiring Type)) environment.implicit_infer_kind) : filter.ne_bot (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_132786 (h0 : function.extfun Type topological_space) : @preirreducible_space.{0} (normed_comm_ring.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (normed_comm_ring.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_132787 (h0 : complete_lattice (metric_space linarith.comp_source)) : complete_lattice.is_Sup_finite_compact (metric_space linarith.comp_source) := sorry --non-trivial
lemma new_lemma_132788 (h0 : function.extfun Type ring) : @is_domain.{0} (canonically_ordered_comm_semiring.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type ring.{0} h0 (canonically_ordered_comm_semiring.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_132789 (h0 : has_lt rat) : no_max_order rat := sorry --non-trivial
lemma new_lemma_132790 (h0 : group (boolean_algebra real)) : is_cyclic (boolean_algebra real) := sorry --non-trivial
lemma new_lemma_132791 (h0 : functor.add_const (topological_space (comm_group pos)) pos) : @t0_space.{0} (comm_group.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (comm_group.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_132792 (h0 : function.extfun Type ring) : @rank_condition.{0} (complete_distrib_lattice.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type ring.{0} h0 (complete_distrib_lattice.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_132793 (h0 : ring (random_gen (has_nnnorm (random_gen linarith.ineq)))) : rank_condition (random_gen (has_nnnorm (random_gen linarith.ineq))) := sorry --non-trivial
lemma new_lemma_132794 (h0 : topological_space (ordered_comm_group (semiring (semiring num)))) : loc_path_connected_space (ordered_comm_group (semiring (semiring num))) := sorry --non-trivial
lemma new_lemma_132795 (h0 : filter (ring num)) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_132796 (h0 : function.extfun Type group) : @is_cyclic.{0} (with_one.{0} unsigned) (@function.extfun_app.{2 1} Type group.{0} h0 (with_one.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_132797 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @normal_space.{0} (ring.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (ring.{0} empty))  := sorry --non-trivial
lemma new_lemma_132798 (h0 : functor.add_const (topological_space (generalized_boolean_algebra linarith.comp)) Type) : @t1_space.{0} (generalized_boolean_algebra.{0} linarith.comp) (@functor.add_const.run.{0 1} (topological_space.{0} (generalized_boolean_algebra.{0} linarith.comp)) Type h0)  := sorry --non-trivial
lemma new_lemma_132799 (h0 : uniform_space (complete_distrib_lattice (semigroup environment.implicit_infer_kind))) : complete_space (complete_distrib_lattice (semigroup environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_132800 (h0 : add_group (has_nnnorm linarith.comp_source)) : is_add_cyclic (has_nnnorm linarith.comp_source) := sorry --non-trivial
lemma new_lemma_132801 (h0 : list (complete_distrib_lattice congr_arg_kind)) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_132802 (h0 : functor.add_const (topological_space (add_comm_monoid pos)) linarith.comp) : @totally_disconnected_space.{0} (add_comm_monoid.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (add_comm_monoid.{0} pos)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_132803 (h0 : topological_space (has_to_string (has_neg linarith.comp))) : topological_space.separable_space (has_to_string (has_neg linarith.comp)) := sorry --non-trivial
lemma new_lemma_132804 (h0 : add_group (has_compl char)) : is_add_cyclic (has_compl char) := sorry --non-trivial
lemma new_lemma_132805 (h0 : uniform_space (ring (finset (finset pos)))) : complete_space (ring (finset (finset pos))) := sorry --non-trivial
lemma new_lemma_132806 (h0 : functor.add_const (finset (semigroup pos)) name) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_132807 (h0 : function.extfun Type topological_space) : @discrete_topology.{0} (as_linear_order.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (as_linear_order.{0} num))  := sorry --non-trivial
lemma new_lemma_132808 (h0 : preorder (add_monoid char)) (h1 : topological_space (locally_finite_order (add_monoid char))) : totally_disconnected_space (locally_finite_order (add_monoid char)) := sorry --non-trivial
lemma new_lemma_132809 (h0 : topological_space (semigroup (has_add (has_neg Type)))) : t0_space (semigroup (has_add (has_neg Type))) := sorry --non-trivial
lemma new_lemma_132810 (h0 : topological_space (linear_ordered_comm_group (option ennreal))) : locally_compact_space (linear_ordered_comm_group (option ennreal)) := sorry --non-trivial
lemma new_lemma_132811 (h0 : topological_space (ordered_comm_ring (has_pos_part linarith.comp))) : totally_separated_space (ordered_comm_ring (has_pos_part linarith.comp)) := sorry --non-trivial
lemma new_lemma_132812 (h1 : ring (monoid (denumerable char))) : rank_condition (monoid (denumerable char)) := sorry --non-trivial
lemma new_lemma_132813 (h0 : fin has_zero.zero) : @monoid.fg.{0} (generalized_boolean_algebra.{0} pos) (@matrix.vec_empty.{0} (monoid.{0} (generalized_boolean_algebra.{0} pos)) h0)  := sorry --non-trivial
lemma new_lemma_132814 (h0 : has_mem.mem (with_one (has_norm fun_info)) has_emptyc.emptyc) : @path_connected_space.{0} (with_one.{0} (has_norm.{0} fun_info)) (@finset.pi.empty.{1 0} Type topological_space.{0} (with_one.{0} (has_norm.{0} fun_info)) h0)  := sorry --non-trivial
lemma new_lemma_132815 (h0 : functor.add_const (topological_space (bin_tree empty)) unsigned) : @loc_path_connected_space.{0} (bin_tree.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (bin_tree.{0} empty)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_132816 (h0 : function.extfun Type topological_space) : @t1_space.{0} (sub_neg_monoid.{0} real) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (sub_neg_monoid.{0} real))  := sorry --non-trivial
lemma new_lemma_132817 (h0 : functor.add_const (topological_space (cancel_monoid name)) linarith.comp) : @normal_space.{0} (cancel_monoid.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (cancel_monoid.{0} name)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_132818 (h0 : not (add_monoid (plift congr_arg_kind) -> false)) : @add_monoid.fg.{1} (plift.{1} congr_arg_kind) (@classical.by_contradiction'.{2} (add_monoid.{1} (plift.{1} congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_132819 (h0 : functor.add_const (topological_space (generalized_boolean_algebra pos)) name) : @discrete_topology.{0} (generalized_boolean_algebra.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (generalized_boolean_algebra.{0} pos)) name h0)  := sorry --non-trivial
lemma new_lemma_132820 (h0 : function.extfun Type complete_lattice) : @is_atomistic.{0} (monoid_with_zero.{0} unsigned) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (monoid_with_zero.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_132821 (h0 : complete_lattice (comm_ring string_imp)) : is_compactly_generated (comm_ring string_imp) := sorry --non-trivial
lemma new_lemma_132822 (h0 : topological_space (has_bot unsigned)) : t1_space (has_bot unsigned) := sorry --non-trivial
lemma new_lemma_132823 (h0 : functor.add_const (uniform_space (comm_group pos)) (has_neg linarith.comp)) : @complete_space.{0} (comm_group.{0} pos) (@functor.add_const.run.{0 0} (uniform_space.{0} (comm_group.{0} pos)) (has_neg.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_132824 (h0 : topological_space (with_bot (add_group (semiring (semiring unsigned))))) : path_connected_space (with_bot (add_group (semiring (semiring unsigned)))) := sorry --non-trivial
lemma new_lemma_132825 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @is_domain.{1} (plift.{1} unsigned) (@function.extfun_app.{3 2} (Type 1) ring.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 ring.{1}) (plift.{1} unsigned))  := sorry --non-trivial
lemma new_lemma_132826 (h0 : function.extfun Type cancel_comm_monoid_with_zero) : @unique_factorization_monoid.{0} (left_cancel_semigroup.{0} unsigned) (@function.extfun_app.{2 1} Type cancel_comm_monoid_with_zero.{0} h0 (left_cancel_semigroup.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_132827 (h0 : fin has_zero.zero) : matrix.vec_empty (matrix.vec_empty (id (id (id (matrix.vec_empty (id h0)))))) := sorry --non-trivial
lemma new_lemma_132828 (h0 : uniform_space (has_lt (mul_one_class char))) : complete_space (has_lt (mul_one_class char)) := sorry --non-trivial
lemma new_lemma_132829 (h0 : function.extfun Type complete_lattice) : @complete_lattice.is_Sup_finite_compact.{0} (normed_group.{0} (semiring.{0} unsigned)) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (normed_group.{0} (semiring.{0} unsigned)))  := sorry --non-trivial
lemma new_lemma_132830 (h0 : functor.add_const (function.extfun Type group) Type) : @is_cyclic.{0} (boolean_algebra.{0} linarith.comp) (@function.extfun_app.{2 1} Type group.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type group.{0}) Type h0) (boolean_algebra.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_132831 (h0 : topological_space (plift (option unsigned))) : path_connected_space (plift (option unsigned)) := sorry --non-trivial
lemma new_lemma_132832 (h0 : functor.add_const (group (simple_graph unsigned)) congr_arg_kind) : @is_cyclic.{0} (simple_graph.{0} unsigned) (@functor.add_const.run.{0 0} (group.{0} (simple_graph.{0} unsigned)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_132833 (h0 : topological_space (finset (finset (has_to_string name)))) : loc_path_connected_space (finset (finset (has_to_string name))) := sorry --non-trivial
lemma new_lemma_132834 (h0 : finset (canonically_linear_ordered_monoid pos)) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_132835 (h0 : topological_space (simple_graph (has_Inf linarith.comp))) : loc_path_connected_space (simple_graph (has_Inf linarith.comp)) := sorry --non-trivial
lemma new_lemma_132836 (h0 : uniform_space (has_zero (has_zero pos))) : separated_space (has_zero (has_zero pos)) := sorry --non-trivial
lemma new_lemma_132837 (h3 : add_group (nondiscrete_normed_field string.iterator_imp)) : is_add_cyclic (nondiscrete_normed_field string.iterator_imp) := sorry --non-trivial
lemma new_lemma_132838 (h0 : function.extfun Type ring) : @is_domain.{0} (has_emptyc.{0} linarith.comp) (@function.extfun_app.{2 1} Type ring.{0} h0 (has_emptyc.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_132839 (h0 : not (has_add (comm_ring linarith.comp_source) -> false)) (h1 : has_le (comm_ring linarith.comp_source)) (h2 : comm_ring linarith.comp_source) : @add_le_cancellable.{0} (comm_ring.{0} linarith.comp_source) (@classical.by_contradiction'.{1} (has_add.{0} (comm_ring.{0} linarith.comp_source)) h0) h1 h2  := sorry --non-trivial
lemma new_lemma_132840 (h0 : functor.add_const Prop (has_to_string (has_to_string pos))) : functor.add_const.run h0 := sorry --non-trivial
lemma new_lemma_132841 (h0 : functor.add_const (topological_space (has_neg unsigned)) (option pos)) : @loc_path_connected_space.{0} (has_neg.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (has_neg.{0} unsigned)) (option.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_132842 (h0 : functor.add_const (group (add_comm_monoid pos)) pos) : @group.fg.{0} (add_comm_monoid.{0} pos) (@functor.add_const.run.{0 0} (group.{0} (add_comm_monoid.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_132843 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @discrete_topology.{0} (has_nndist.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_nndist.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_132844 (h0 : topological_space (has_top num)) : path_connected_space (has_top num) := sorry --non-trivial
lemma new_lemma_132845 (h0 : ordered_add_comm_monoid (boolean_algebra.core num)) : archimedean (boolean_algebra.core num) := sorry --non-trivial
lemma new_lemma_132846 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_domain.{0} environment.implicit_infer_kind (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) environment.implicit_infer_kind)  := sorry --non-trivial
lemma new_lemma_132847 (h0 : topological_space (semi_normed_comm_ring fun_info)) : path_connected_space (semi_normed_comm_ring fun_info) := sorry --non-trivial
lemma new_lemma_132848 (h0 : function.extfun Type list) : palindrome (function.extfun_app h0 (boolean_algebra environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_132849 (h0 : function.extfun Type topological_space) : @path_connected_space.{0} (has_norm.{0} string_imp) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_norm.{0} string_imp))  := sorry --non-trivial
lemma new_lemma_132850 (h0 : topological_space (canonically_ordered_add_monoid empty)) : locally_compact_space (canonically_ordered_add_monoid empty) := sorry --non-trivial
lemma new_lemma_132851 (h0 : ring (has_inter (option empty))) : strong_rank_condition (has_inter (option empty)) := sorry --non-trivial
lemma new_lemma_132852 (h0 : has_mem.mem topological_space has_emptyc.emptyc) : @irreducible_space.{0} (has_mul.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) topological_space.{0} h0) (has_mul.{0} num))  := sorry --non-trivial
lemma new_lemma_132853 (h0 : ring (has_compl (mul_one_class (mul_one_class (mul_one_class linarith.ineq))))) : strong_rank_condition (has_compl (mul_one_class (mul_one_class (mul_one_class linarith.ineq)))) := sorry --non-trivial
lemma new_lemma_132854 (h0 : functor.add_const (uniform_space (finset name)) name) : @separated_space.{0} (finset.{0} name) (@functor.add_const.run.{0 0} (uniform_space.{0} (finset.{0} name)) name h0)  := sorry --non-trivial
lemma new_lemma_132855 (h0 : functor.add_const (topological_space (finset ennreal)) (option (option unsigned))) : @t0_space.{0} (finset.{0} ennreal) (@functor.add_const.run.{0 0} (topological_space.{0} (finset.{0} ennreal)) (option.{0} (option.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_132856 (h0 : add_group (with_one (random_gen to_additive.value_type))) : is_add_cyclic (with_one (random_gen to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_132857 (h0 : function.extfun Type uniform_space) : @separated_space.{0} (linear_ordered_comm_monoid_with_zero.{0} (option.{0} empty)) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (linear_ordered_comm_monoid_with_zero.{0} (option.{0} empty)))  := sorry --non-trivial
lemma new_lemma_132858 (h0 : not (functor.add_const Prop (has_top unsigned) -> false)) : functor.add_const.run (classical.by_contradiction' h0) := sorry --non-trivial
lemma new_lemma_132859 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @archimedean.{0} (has_add.{0} linarith.comp) (@function.extfun_app.{2 1} Type ordered_add_comm_monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ordered_add_comm_monoid.{0}) (has_add.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_132860 (h0 : list (boolean_algebra (has_zero (semigroup environment.implicit_infer_kind)))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_132861 (h0 : semiring (nondiscrete_normed_field string.iterator_imp)) (h1 : option (ideal (nondiscrete_normed_field string.iterator_imp))) (h2 : ideal (nondiscrete_normed_field string.iterator_imp)) : ideal.is_prime (option.get_or_else h1 h2) := sorry --non-trivial
lemma new_lemma_132862 (h0 : complete_lattice (dlist (random_gen string_imp))) : complete_lattice.is_Sup_finite_compact (dlist (random_gen string_imp)) := sorry --non-trivial
lemma new_lemma_132863 (h0 : functor.comp ring boolean_algebra unsigned) : @is_domain.{0} (boolean_algebra.{0} unsigned) (@functor.comp.run.{0 0 0} ring.{0} boolean_algebra.{0} unsigned h0)  := sorry --non-trivial
lemma new_lemma_132864 (h0 : topological_space (ordered_cancel_add_comm_monoid (option unsigned))) : loc_path_connected_space (ordered_cancel_add_comm_monoid (option unsigned)) := sorry --non-trivial
lemma new_lemma_132865 (h0 : functor.add_const (function.extfun Type topological_space) name) : @t1_space.{0} (add_cancel_monoid.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) name h0) (add_cancel_monoid.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_132866 (h0 : topological_space (has_union (has_norm (has_norm (has_norm num))))) : locally_compact_space (has_union (has_norm (has_norm (has_norm num)))) := sorry --non-trivial
lemma new_lemma_132867 (h0 : fin has_zero.zero) : @is_noetherian_ring.{1} (ordered_comm_ring.{1} Type) (@matrix.vec_empty.{1} (semiring.{1} (ordered_comm_ring.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_132868 (h0 : function.extfun Type topological_space) : @preirreducible_space.{0} (has_top.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_top.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_132869 (h0 : functor.add_const (uniform_space znum) num) : @complete_space.{0} znum (@functor.add_const.run.{0 0} (uniform_space.{0} znum) num h0)  := sorry --non-trivial
lemma new_lemma_132870 (h0 : uniform_space (has_norm (semiring linarith.comp_source))) : complete_space (has_norm (semiring linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_132871 (h0 : functor.add_const (fin has_zero.zero) (has_Inf (has_Inf name))) : @add_monoid.fg.{1} (has_pos_part.{1} Type) (@matrix.vec_empty.{1} (add_monoid.{1} (has_pos_part.{1} Type)) (@functor.add_const.run.{0 0} (fin (@has_zero.zero.{0} nat nat.has_zero)) (has_Inf.{0} (has_Inf.{0} name)) h0))  := sorry --non-trivial
lemma new_lemma_132872 (h0 : function.extfun Type topological_space) : @loc_path_connected_space.{0} (comm_group.{0} (has_add.{0} (has_add.{0} (has_add.{0} (semigroup.{0} name))))) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (comm_group.{0} (has_add.{0} (has_add.{0} (has_add.{0} (semigroup.{0} name))))))  := sorry --non-trivial
lemma new_lemma_132873 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @separated_space.{0} (linear_ordered_semiring.{0} unsigned) (@function.extfun_app.{2 1} Type uniform_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 uniform_space.{0}) (linear_ordered_semiring.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_132874 (h0 : group (has_neg_part (finset pos))) : group.fg (has_neg_part (finset pos)) := sorry --non-trivial
lemma new_lemma_132875 (h1 : function.extfun Type list) : list.nodup (function.extfun_app h1 linarith.comp_source) := sorry --non-trivial
lemma new_lemma_132876 (h0 : function.extfun Type (functor.add_const (function.extfun Type group))) : @is_cyclic.{0} (has_Inf.{0} linarith.comp) (@function.extfun_app.{2 1} Type group.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type group.{0}) pos (@function.extfun_app.{2 2} Type (functor.add_const.{1 0} (function.extfun.{2 1} Type group.{0})) h0 pos)) (has_Inf.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_132877 (h0 : functor.add_const (topological_space (boolean_algebra.core name)) linarith.comp) : @loc_path_connected_space.{0} (boolean_algebra.core.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (boolean_algebra.core.{0} name)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_132878 (h0 : functor.add_const (ring (semigroup empty)) unsigned) : @rank_condition.{0} (semigroup.{0} empty) (@functor.add_const.run.{0 0} (ring.{0} (semigroup.{0} empty)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_132879 (h0 : add_monoid (complete_linear_order (semiring congr_arg_kind))) : add_monoid.fg (complete_linear_order (semiring congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_132880 (h0 : fin has_zero.zero) : @complete_space.{1} (finset.{1} Type) (@matrix.vec_empty.{1} (uniform_space.{1} (finset.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_132881 (h0 : add_group (normed_comm_ring ennreal)) : is_add_cyclic (normed_comm_ring ennreal) := sorry --non-trivial
lemma new_lemma_132882 (h0 : semiring (has_zero pos)) : is_noetherian_ring (has_zero pos) := sorry --non-trivial
lemma new_lemma_132883 (h0 : complete_lattice (with_bot (has_inv (has_inv fun_info)))) : is_atomistic (with_bot (has_inv (has_inv fun_info))) := sorry --non-trivial
lemma new_lemma_132884 (h0 : topological_space (boolean_algebra.core (has_add pos))) : locally_compact_space (boolean_algebra.core (has_add pos)) := sorry --non-trivial
lemma new_lemma_132885 (h0 : topological_space (id (has_top linarith.comp))) : preirreducible_space (id (has_top linarith.comp)) := sorry --non-trivial
lemma new_lemma_132886 (h0 : list (finset Type)) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_132887 (h0 : group (normed_group (has_norm unsigned))) : normalizer_condition (normed_group (has_norm unsigned)) := sorry --non-trivial
lemma new_lemma_132888 (h0 : functor.add_const (ring (add_cancel_monoid pos)) Type) : @is_domain.{0} (add_cancel_monoid.{0} pos) (@functor.add_const.run.{0 1} (ring.{0} (add_cancel_monoid.{0} pos)) Type h0)  := sorry --non-trivial
lemma new_lemma_132889 (h0 : ordered_comm_monoid (has_zero (has_to_string pos))) : has_exists_mul_of_le (has_zero (has_to_string pos)) := sorry --non-trivial
lemma new_lemma_132890 (h0 : has_mem.mem topological_space has_emptyc.emptyc) : @path_connected_space.{0} linarith.ineq (@function.extfun_app.{2 1} Type topological_space.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) topological_space.{0} h0) linarith.ineq)  := sorry --non-trivial
lemma new_lemma_132891 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @regular_space.{1} (has_neg_part.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 topological_space.{1}) (has_neg_part.{1} Type))  := sorry --non-trivial
lemma new_lemma_132892 (h0 : topological_space unsigned) (h1 : measurable_space unsigned) (h2 : measure_theory.measure unsigned) : measure_theory.measure.is_open_pos_measure h2 := sorry --non-trivial
lemma new_lemma_132893 (h0 : ordered_comm_monoid (has_bot name)) : has_exists_mul_of_le (has_bot name) := sorry --non-trivial
lemma new_lemma_132894 (h0 : topological_space (canonically_ordered_monoid linarith.comp)) : preconnected_space (canonically_ordered_monoid linarith.comp) := sorry --non-trivial
lemma new_lemma_132895 (h0 : function.extfun (Type 1) ring) : @rank_condition.{1} (plift.{1} (option.{0} empty)) (@function.extfun_app.{3 2} (Type 1) ring.{1} h0 (plift.{1} (option.{0} empty)))  := sorry --non-trivial
lemma new_lemma_132896 (h0 : topological_space (has_to_string num)) : totally_separated_space (has_to_string num) := sorry --non-trivial
lemma new_lemma_132897 (h0 : topological_space (canonically_ordered_comm_semiring (has_nndist (finset pos)))) : regular_space (canonically_ordered_comm_semiring (has_nndist (finset pos))) := sorry --non-trivial
lemma new_lemma_132898 (h0 : group (has_dist (option empty))) : is_cyclic (has_dist (option empty)) := sorry --non-trivial
lemma new_lemma_132899 (h0 : functor.add_const (topological_space (add_cancel_monoid pos)) linarith.comp) : @irreducible_space.{0} (add_cancel_monoid.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (add_cancel_monoid.{0} pos)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_132900 (h0 : topological_space (mul_zero_class (add_left_cancel_monoid (has_add ennreal)))) : loc_path_connected_space (mul_zero_class (add_left_cancel_monoid (has_add ennreal))) := sorry --non-trivial
lemma new_lemma_132901 (h0 : group (complete_semilattice_Sup (has_nnnorm (has_nnnorm (has_nnnorm linarith.ineq))))) : is_cyclic (complete_semilattice_Sup (has_nnnorm (has_nnnorm (has_nnnorm linarith.ineq)))) := sorry --non-trivial
lemma new_lemma_132902 (h0 : functor.add_const (uniform_space (has_dist empty)) num) : @complete_space.{0} (has_dist.{0} empty) (@functor.add_const.run.{0 0} (uniform_space.{0} (has_dist.{0} empty)) num h0)  := sorry --non-trivial
lemma new_lemma_132903 (h0 : function.extfun Type cancel_comm_monoid_with_zero) : @unique_factorization_monoid.{0} (linear_ordered_comm_ring.{0} empty) (@function.extfun_app.{2 1} Type cancel_comm_monoid_with_zero.{0} h0 (linear_ordered_comm_ring.{0} empty))  := sorry --non-trivial
lemma new_lemma_132904 (h0 : finset (boolean_algebra (finset (finset linarith.comp)))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_132905 (h0 : functor.add_const (list (normed_linear_ordered_group empty)) congr_arg_kind) : palindrome (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_132906 (h0 : function.extfun Type (functor.add_const (ring (left_cancel_monoid unsigned)))) : @is_domain.{0} (left_cancel_monoid.{0} unsigned) (@functor.add_const.run.{0 0} (ring.{0} (left_cancel_monoid.{0} unsigned)) (option.{0} empty) (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (ring.{0} (left_cancel_monoid.{0} unsigned))) h0 (option.{0} empty)))  := sorry --non-trivial
lemma new_lemma_132907 (h0 : ring (has_zero (add_comm_monoid Type))) : rank_condition (has_zero (add_comm_monoid Type)) := sorry --non-trivial
lemma new_lemma_132908 (h0 : not (topological_space (add_group unsigned) -> false)) : @totally_disconnected_space.{0} (add_group.{0} unsigned) (@classical.by_contradiction'.{1} (topological_space.{0} (add_group.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_132909 (h0 : functor.add_const (topological_space (semigroup pos)) (finset pos)) : @totally_disconnected_space.{0} (semigroup.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (semigroup.{0} pos)) (finset.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_132910 (h0 : set (distrib (mul_one_class linarith.comp_source))) : set.subsingleton h0 := sorry --non-trivial
lemma new_lemma_132911 (h0 : topological_space (ordered_comm_monoid (has_bot name))) : path_connected_space (ordered_comm_monoid (has_bot name)) := sorry --non-trivial
lemma new_lemma_132912 (h0 : not (topological_space (has_ssubset congr_arg_kind) -> false)) : @locally_compact_space.{0} (has_ssubset.{0} congr_arg_kind) (@classical.by_contradiction'.{1} (topological_space.{0} (has_ssubset.{0} congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_132913 (h0 : group (has_to_string (has_neg_part Type))) : is_simple_group (has_to_string (has_neg_part Type)) := sorry --non-trivial
lemma new_lemma_132914 (h0 : filter (finset (has_to_string (has_to_string pos)))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_132915 (h0 : ring (finset (option ennreal))) : is_domain (finset (option ennreal)) := sorry --non-trivial
lemma new_lemma_132916 (h0 : ordered_add_comm_monoid (semiring (has_edist unsigned))) : archimedean (semiring (has_edist unsigned)) := sorry --non-trivial
lemma new_lemma_132917 (h1 : topological_space enat) (h2 : set (set enat)) : topological_space.is_topological_basis h2 := sorry --non-trivial
lemma new_lemma_132918 (h0 : uniform_space (with_one (has_norm (has_norm congr_arg_kind)))) : separated_space (with_one (has_norm (has_norm congr_arg_kind))) := sorry --non-trivial
lemma new_lemma_132919 (h0 : finset (cancel_monoid (mul_zero_class unsigned))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_132920 (h0 : topological_space (ordered_comm_ring (has_pos_part pos))) : normal_space (ordered_comm_ring (has_pos_part pos)) := sorry --non-trivial
lemma new_lemma_132921 (h0 : function.extfun Type topological_space) : @normal_space.{0} (linear_ordered_comm_group.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (linear_ordered_comm_group.{0} num))  := sorry --non-trivial
lemma new_lemma_132922 (h0 : semiring (boolean_algebra (finset linarith.comp))) : is_noetherian_ring (boolean_algebra (finset linarith.comp)) := sorry --non-trivial
lemma new_lemma_132923 (h0 : topological_space (has_norm (semiring (has_top num)))) : t0_space (has_norm (semiring (has_top num))) := sorry --non-trivial
lemma new_lemma_132924 (h0 : function.extfun (nat -> Type) (function.extfun nat)) : @complete_space.{0} (normed_lattice_add_comm_group.{0} (has_add.{0} name)) (@matrix.vec_empty.{0} (uniform_space.{0} (normed_lattice_add_comm_group.{0} (has_add.{0} name))) (@function.extfun_app.{1 1} nat fin (@function.extfun_app.{2 1} (nat → Type) (function.extfun.{1 1} nat) h0 fin) (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_132925 (h0 : uniform_space (has_add (has_Inf pos))) : separated_space (has_add (has_Inf pos)) := sorry --non-trivial
lemma new_lemma_132926 (h0 : topological_space (complete_distrib_lattice (boolean_algebra.core environment.implicit_infer_kind))) : t1_space (complete_distrib_lattice (boolean_algebra.core environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_132927 (h0 : group (simple_graph (has_pos_part pos))) : is_cyclic (simple_graph (has_pos_part pos)) := sorry --non-trivial
lemma new_lemma_132928 (h1 : add_group (has_ssubset linarith.ineq)) : is_add_cyclic (has_ssubset linarith.ineq) := sorry --non-trivial
lemma new_lemma_132929 (h0 : uniform_space (has_bot unsigned)) : complete_space (has_bot unsigned) := sorry --non-trivial
lemma new_lemma_132930 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @monoid.fg.{1} (boolean_algebra.core.{1} Type) (@function.extfun_app.{3 2} (Type 1) monoid.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 monoid.{1}) (boolean_algebra.core.{1} Type))  := sorry --non-trivial
lemma new_lemma_132931 (h0 : not (function.extfun Type ring -> false)) : @is_domain.{0} empty (@function.extfun_app.{2 1} Type ring.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type ring.{0}) h0) empty)  := sorry --non-trivial
lemma new_lemma_132932 (h1 : group (comm_ring to_additive.value_type)) : group.fg (comm_ring to_additive.value_type) := sorry --non-trivial
lemma new_lemma_132933 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @t0_space.{0} (add_group.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (add_group.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_132934 (h0 : has_mem.mem (complete_semilattice_Sup linarith.comp) has_emptyc.emptyc) : @t0_space.{0} (complete_semilattice_Sup.{0} linarith.comp) (@finset.pi.empty.{1 0} Type topological_space.{0} (complete_semilattice_Sup.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_132935 (h0 : topological_space (has_top (has_norm (canonically_linear_ordered_monoid num)))) (h1 : set (has_top (has_norm (canonically_linear_ordered_monoid num)))) : is_compact h1 := sorry --non-trivial
lemma new_lemma_132936 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_cyclic.{0} (boolean_algebra.core.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (boolean_algebra.core.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_132937 (h0 : topological_space (ordered_cancel_add_comm_monoid unsigned)) : preconnected_space (ordered_cancel_add_comm_monoid unsigned) := sorry --non-trivial
lemma new_lemma_132938 (h0 : topological_space (partial_order empty)) : path_connected_space (partial_order empty) := sorry --non-trivial
lemma new_lemma_132939 (h0 : topological_space (with_bot congr_arg_kind)) : totally_separated_space (with_bot congr_arg_kind) := sorry --non-trivial
lemma new_lemma_132940 (h0 : functor.add_const (ring (has_to_string Type)) linarith.comp) : @strong_rank_condition.{1} (has_to_string.{1} Type) (@functor.add_const.run.{1 0} (ring.{1} (has_to_string.{1} Type)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_132941 (h0 : not (semiring (has_one congr_arg_kind) -> false)) : @is_noetherian_ring.{0} (has_one.{0} congr_arg_kind) (@classical.by_contradiction'.{1} (semiring.{0} (has_one.{0} congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_132942 (h0 : topological_space (has_nndist (has_to_string ennreal))) : preirreducible_space (has_nndist (has_to_string ennreal)) := sorry --non-trivial
lemma new_lemma_132943 (h0 : functor.add_const (finset (finset Type)) (boolean_algebra (ring (finset (boolean_algebra linarith.comp))))) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_132944 (h0 : functor.add_const (function.extfun Type uniform_space) pos) : @complete_space.{0} (complete_distrib_lattice.{0} pos) (@function.extfun_app.{2 1} Type uniform_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type uniform_space.{0}) pos h0) (complete_distrib_lattice.{0} pos))  := sorry --non-trivial
lemma new_lemma_132945 (h0 : uniform_space (non_unital_non_assoc_ring (has_top fun_info))) : complete_space (non_unital_non_assoc_ring (has_top fun_info)) := sorry --non-trivial
lemma new_lemma_132946 (h0 : list (canonically_ordered_comm_semiring (finset (has_neg Type)))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_132947 (h0 : functor.add_const (function.extfun Type uniform_space) Type) : @complete_space.{0} linarith.comp (@function.extfun_app.{2 1} Type uniform_space.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type uniform_space.{0}) Type h0) linarith.comp)  := sorry --non-trivial
lemma new_lemma_132948 (h0 : functor.add_const (topological_space (has_neg_part pos)) name) : @discrete_topology.{0} (has_neg_part.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (has_neg_part.{0} pos)) name h0)  := sorry --non-trivial
lemma new_lemma_132949 (h1 : add_group (has_nnnorm to_additive.value_type)) : is_add_cyclic (has_nnnorm to_additive.value_type) := sorry --non-trivial
lemma new_lemma_132950 (h0 : topological_space (linear_ordered_field (has_to_string congr_arg_kind))) : normal_space (linear_ordered_field (has_to_string congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_132951 (h0 : functor.add_const (complete_lattice (cancel_monoid empty)) num) : @complete_lattice.is_Sup_finite_compact.{0} (cancel_monoid.{0} empty) (@functor.add_const.run.{0 0} (complete_lattice.{0} (cancel_monoid.{0} empty)) num h0)  := sorry --non-trivial
lemma new_lemma_132952 (h0 : group (ring (option (option (option (option pos)))))) : normalizer_condition (ring (option (option (option (option pos))))) := sorry --non-trivial
lemma new_lemma_132953 (h1 : topological_space (has_ssubset (has_lt linarith.comp_source))) : path_connected_space (has_ssubset (has_lt linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_132954 (h0 : topological_space (has_nnnorm (random_gen fun_info))) : t0_space (has_nnnorm (random_gen fun_info)) := sorry --non-trivial
lemma new_lemma_132955 (h6 : topological_space linarith.ineq) : totally_disconnected_space linarith.ineq := sorry --non-trivial
lemma new_lemma_132956 (h0 : semiring (complete_linear_order empty) -> Prop) (h1 : Exists (fun (x : semiring (complete_linear_order empty)), h0 x)) : @is_noetherian_ring.{0} (complete_linear_order.{0} empty) (@classical.some.{1} (semiring.{0} (complete_linear_order.{0} empty)) h0 h1)  := sorry --non-trivial
lemma new_lemma_132957 (h0 : group (pseudo_metric_space (option (option unsigned)))) : group.fg (pseudo_metric_space (option (option unsigned))) := sorry --non-trivial
lemma new_lemma_132958 (h0 : functor.add_const (filter (complete_distrib_lattice Type)) name) : filter.ne_bot (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_132959 (h0 : list (has_add (finset (finset (finset linarith.comp))))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_132960 (h0 : functor.add_const (ring (add_cancel_monoid Type)) (has_neg_part environment.implicit_infer_kind)) : @is_principal_ideal_ring.{1} (add_cancel_monoid.{1} Type) (@functor.add_const.run.{1 0} (ring.{1} (add_cancel_monoid.{1} Type)) (has_neg_part.{0} environment.implicit_infer_kind) h0)  := sorry --non-trivial
lemma new_lemma_132961 (h0 : function.extfun Type ring) : @is_domain.{0} (measurable_space.dynkin_system.{0} num) (@function.extfun_app.{2 1} Type ring.{0} h0 (measurable_space.dynkin_system.{0} num))  := sorry --non-trivial
lemma new_lemma_132962 (h0 : functor.add_const (monoid (has_neg_part name)) name) : @monoid.fg.{0} (has_neg_part.{0} name) (@functor.add_const.run.{0 0} (monoid.{0} (has_neg_part.{0} name)) name h0)  := sorry --non-trivial
lemma new_lemma_132963 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @path_connected_space.{0} (ordered_comm_monoid.{0} real) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (ordered_comm_monoid.{0} real))  := sorry --non-trivial
lemma new_lemma_132964 (h0 : functor.add_const (function.extfun Type ring) pos) : @strong_rank_condition.{0} (has_nndist.{0} pos) (@function.extfun_app.{2 1} Type ring.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type ring.{0}) pos h0) (has_nndist.{0} pos))  := sorry --non-trivial
lemma new_lemma_132965 (h0 : list (cancel_monoid ennreal)) : palindrome h0 := sorry --non-trivial
lemma new_lemma_132966 (h0 : function.extfun Type topological_space) : @topological_space.separable_space.{0} (linear_ordered_comm_group.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (linear_ordered_comm_group.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_132967 (h0 : fun_info) (h1 : multiset fun_info) : multiset.mem h0 h1 := sorry --non-trivial
lemma new_lemma_132968 (h0 : group (comm_semigroup (has_Inf (has_Inf (has_Inf real))))) : normalizer_condition (comm_semigroup (has_Inf (has_Inf (has_Inf real)))) := sorry --non-trivial
lemma new_lemma_132969 (h0 : function.extfun Type ring) : @rank_condition.{0} (ordered_cancel_add_comm_monoid.{0} ennreal) (@function.extfun_app.{2 1} Type ring.{0} h0 (ordered_cancel_add_comm_monoid.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_132970 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @t0_space.{0} (simple_graph.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (simple_graph.{0} empty))  := sorry --non-trivial
lemma new_lemma_132971 (h0 : ring (has_le string_imp)) : strong_rank_condition (has_le string_imp) := sorry --non-trivial
lemma new_lemma_132972 (h0 : group (has_ssubset (random_gen (has_nnnorm (random_gen (has_nnnorm reducibility_hints)))))) : is_cyclic (has_ssubset (random_gen (has_nnnorm (random_gen (has_nnnorm reducibility_hints))))) := sorry --non-trivial
lemma new_lemma_132973 (h0 : topological_space (cancel_monoid (option (option unsigned)))) : preconnected_space (cancel_monoid (option (option unsigned))) := sorry --non-trivial
lemma new_lemma_132974 (h0 : topological_space (has_well_founded unsigned)) : totally_disconnected_space (has_well_founded unsigned) := sorry --non-trivial
lemma new_lemma_132975 (h0 : set (prod ennreal ennreal)) (h1 : prod ennreal ennreal) : symmetrize_rel h0 h1 := sorry --non-trivial
lemma new_lemma_132976 (h0 : complete_lattice (add_cancel_comm_monoid (mul_one_class linarith.ineq))) : is_compactly_generated (add_cancel_comm_monoid (mul_one_class linarith.ineq)) := sorry --non-trivial
lemma new_lemma_132977 (h0 : functor.add_const (topological_space (boolean_algebra pos)) (has_zero (finset pos))) : @loc_path_connected_space.{0} (boolean_algebra.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (boolean_algebra.{0} pos)) (has_zero.{0} (finset.{0} pos)) h0)  := sorry --non-trivial
lemma new_lemma_132978 (h0 : not (function.extfun Type complete_lattice -> false)) : @is_compactly_generated.{0} (has_ssubset.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type complete_lattice.{0}) h0) (has_ssubset.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_132979 (h3 : add_group (has_ssubset to_additive.value_type)) : is_add_cyclic (has_ssubset to_additive.value_type) := sorry --non-trivial
lemma new_lemma_132980 (h0 : function.extfun nat fin) : @t0_space.{0} (has_Inf.{0} real) (@matrix.vec_empty.{0} (topological_space.{0} (has_Inf.{0} real)) (@matrix.vec_empty.{0} (fin (@has_zero.zero.{0} nat nat.has_zero)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero))))  := sorry --non-trivial
lemma new_lemma_132981 (h0 : complete_lattice (has_lt (has_nnnorm reducibility_hints))) : complete_lattice.is_Sup_finite_compact (has_lt (has_nnnorm reducibility_hints)) := sorry --non-trivial
lemma new_lemma_132982 (h0 : topological_space (has_div (mul_one_class (mul_one_class fun_info)))) : path_connected_space (has_div (mul_one_class (mul_one_class fun_info))) := sorry --non-trivial
lemma new_lemma_132983 (h0 : not (function.extfun Type uniform_space -> false)) : @complete_space.{0} (dlist.{0} char) (@function.extfun_app.{2 1} Type uniform_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type uniform_space.{0}) h0) (dlist.{0} char))  := sorry --non-trivial
lemma new_lemma_132984 (h0 : topological_space (left_cancel_semigroup empty)) : totally_disconnected_space (left_cancel_semigroup empty) := sorry --non-trivial
lemma new_lemma_132985 (h0 : function.extfun Type (functor.comp topological_space has_nndist)) : @totally_disconnected_space.{0} (has_nndist.{0} pos) (@functor.comp.run.{0 0 0} topological_space.{0} has_nndist.{0} pos (@function.extfun_app.{2 1} Type (functor.comp.{0 0 0} topological_space.{0} has_nndist.{0}) h0 pos))  := sorry --non-trivial
lemma new_lemma_132986 (h0 : uniform_space (topological_space (has_ssubset linarith.comp_source))) : complete_space (topological_space (has_ssubset linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_132987 (h0 : functor.add_const (ring environment.implicit_infer_kind) pos) : @is_principal_ideal_ring.{0} environment.implicit_infer_kind (@functor.add_const.run.{0 0} (ring.{0} environment.implicit_infer_kind) pos h0)  := sorry --non-trivial
lemma new_lemma_132988 (h0 : function.extfun Type ordered_add_comm_monoid) : @archimedean.{0} (linear_ordered_field.{0} ennreal) (@function.extfun_app.{2 1} Type ordered_add_comm_monoid.{0} h0 (linear_ordered_field.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_132989 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @irreducible_space.{0} (add_cancel_monoid.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (add_cancel_monoid.{0} empty)) empty (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (topological_space.{0} (add_cancel_monoid.{0} empty))) (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 (functor.add_const.{0 0} (topological_space.{0} (add_cancel_monoid.{0} empty)))) empty))  := sorry --non-trivial
lemma new_lemma_132990 (h0 : ring (add_cancel_monoid (ring linarith.comp))) : is_principal_ideal_ring (add_cancel_monoid (ring linarith.comp)) := sorry --non-trivial
lemma new_lemma_132991 (h0 : functor.add_const (ordered_add_comm_monoid (has_to_string Type)) Type) : @archimedean.{1} (has_to_string.{1} Type) (@functor.add_const.run.{1 1} (ordered_add_comm_monoid.{1} (has_to_string.{1} Type)) Type h0)  := sorry --non-trivial
lemma new_lemma_132992 (h0 : ring (dlist (has_ssubset linarith.ineq))) : rank_condition (dlist (has_ssubset linarith.ineq)) := sorry --non-trivial
lemma new_lemma_132993 (h0 : ring (normed_group (semiring congr_arg_kind))) : strong_rank_condition (normed_group (semiring congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_132994 (h0 : functor.add_const Prop (add_comm_monoid empty)) : functor.add_const.run h0 := sorry --non-trivial
lemma new_lemma_132995 (h0 : prod (has_norm congr_arg_kind) (has_norm congr_arg_kind)) : id_rel h0 := sorry --non-trivial
lemma new_lemma_132996 (h0 : topological_space (has_norm (random_gen fun_info))) : compact_space (has_norm (random_gen fun_info)) := sorry --non-trivial
lemma new_lemma_132997 (h0 : function.extfun Type ring) : @is_domain.{0} (has_inv.{0} (has_top.{0} to_additive.value_type)) (@function.extfun_app.{2 1} Type ring.{0} h0 (has_inv.{0} (has_top.{0} to_additive.value_type)))  := sorry --non-trivial
lemma new_lemma_132998 (h0 : ring (semi_normed_ring (comm_ring linarith.ineq))) : rank_condition (semi_normed_ring (comm_ring linarith.ineq)) := sorry --non-trivial
lemma new_lemma_132999 (h0 : complete_lattice (complete_distrib_lattice congr_arg_kind)) : is_compactly_generated (complete_distrib_lattice congr_arg_kind) := sorry --non-trivial
lemma new_lemma_133000 (h0 : functor.add_const (topological_space (has_to_string linarith.comp)) name) : @discrete_topology.{0} (has_to_string.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (has_to_string.{0} linarith.comp)) name h0)  := sorry --non-trivial
lemma new_lemma_133001 (h0 : not (function.extfun Type uniform_space -> false)) : @complete_space.{0} (linear_ordered_semiring.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type uniform_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type uniform_space.{0}) h0) (linear_ordered_semiring.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_133002 (h0 : measurable_space (simple_graph linarith.ineq)) (h2 : filter (simple_graph linarith.ineq)) : filter.is_measurably_generated h2 := sorry --non-trivial
lemma new_lemma_133003 (h0 : group (has_nndist (has_zero (has_to_string congr_arg_kind)))) : group.fg (has_nndist (has_zero (has_to_string congr_arg_kind))) := sorry --non-trivial
lemma new_lemma_133004 (h0 : functor.add_const (ordered_add_comm_monoid (has_Inf pos)) linarith.comp) : @archimedean.{0} (has_Inf.{0} pos) (@functor.add_const.run.{0 0} (ordered_add_comm_monoid.{0} (has_Inf.{0} pos)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_133005 (h0 h1 : ulower pnat) : pnat.coprime (ulower.up h0) (ulower.up (id h1)) := sorry --non-trivial
lemma new_lemma_133006 (h0 : not (ring (partial_order reducibility_hints) -> false)) : @strong_rank_condition.{0} (partial_order.{0} reducibility_hints) (@classical.by_contradiction'.{1} (ring.{0} (partial_order.{0} reducibility_hints)) h0)  := sorry --non-trivial
lemma new_lemma_133007 (h0 : not (topological_space Type -> false)) : @t1_space.{1} Type (@classical.by_contradiction'.{2} (topological_space.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_133008 (h0 : add_monoid (add_comm_monoid num)) : add_monoid.fg (add_comm_monoid num) := sorry --non-trivial
lemma new_lemma_133009 (h0 : not (ring (measure_theory.measure_space unsigned) -> false)) : @is_domain.{0} (measure_theory.measure_space.{0} unsigned) (@classical.by_contradiction'.{1} (ring.{0} (measure_theory.measure_space.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_133010 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_compactly_generated.{0} (has_one.{0} unsigned) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (has_one.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_133011 (h0 : has_mem.mem topological_space has_emptyc.emptyc) : @path_connected_space.{0} (complete_semilattice_Sup.{0} (random_gen.{0} linarith.comp_source)) (@function.extfun_app.{2 1} Type topological_space.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) topological_space.{0} h0) (complete_semilattice_Sup.{0} (random_gen.{0} linarith.comp_source)))  := sorry --non-trivial
lemma new_lemma_133012 (h1 : uniform_space (has_ssubset (mul_one_class string.iterator_imp))) : complete_space (has_ssubset (mul_one_class string.iterator_imp)) := sorry --non-trivial
lemma new_lemma_133013 (h0 : add_group (dlist (random_gen char))) : is_add_cyclic (dlist (random_gen char)) := sorry --non-trivial
lemma new_lemma_133014 (h0 : function.extfun Type uniform_space) : @complete_space.{0} (finset.{0} name) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (finset.{0} name))  := sorry --non-trivial
lemma new_lemma_133015 (h0 : topological_space (has_zero (has_add (finset linarith.comp)))) : t0_space (has_zero (has_add (finset linarith.comp))) := sorry --non-trivial
lemma new_lemma_133016 (h0 : function.extfun Type topological_space) : @path_connected_space.{0} (has_compl.{0} linarith.ineq) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_compl.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_133017 (h0 : functor.add_const (uniform_space (boolean_algebra Type)) pos) : @complete_space.{1} (boolean_algebra.{1} Type) (@functor.add_const.run.{1 0} (uniform_space.{1} (boolean_algebra.{1} Type)) pos h0)  := sorry --non-trivial
lemma new_lemma_133018 (h0 : topological_space (has_one (has_top (semiring (semiring (semiring congr_arg_kind)))))) : irreducible_space (has_one (has_top (semiring (semiring (semiring congr_arg_kind))))) := sorry --non-trivial
lemma new_lemma_133019 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @complete_space.{0} (has_to_string.{0} unsigned) (@function.extfun_app.{2 1} Type uniform_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 uniform_space.{0}) (has_to_string.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_133020 (h0 : not (uniform_space (semiring fun_info) -> false)) : @separated_space.{0} (semiring.{0} fun_info) (@classical.by_contradiction'.{1} (uniform_space.{0} (semiring.{0} fun_info)) h0)  := sorry --non-trivial
lemma new_lemma_133021 (h0 : functor.add_const (ordered_add_comm_monoid (has_Inf pos)) (finset linarith.comp)) : @archimedean.{0} (has_Inf.{0} pos) (@functor.add_const.run.{0 0} (ordered_add_comm_monoid.{0} (has_Inf.{0} pos)) (finset.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_133022 (h0 : topological_space (id (has_norm empty))) : normal_space (id (has_norm empty)) := sorry --non-trivial
lemma new_lemma_133023 (h0 : topological_space (has_bot (generalized_boolean_algebra (complete_distrib_lattice real)))) : path_connected_space (has_bot (generalized_boolean_algebra (complete_distrib_lattice real))) := sorry --non-trivial
lemma new_lemma_133024 (h0 : function.extfun Type topological_space) : @preirreducible_space.{0} (add_cancel_monoid.{0} ennreal) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (add_cancel_monoid.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_133025 (h0 : function.extfun Type (functor.add_const (complete_lattice (left_cancel_monoid empty)))) : @is_atomistic.{0} (left_cancel_monoid.{0} empty) (@functor.add_const.run.{0 0} (complete_lattice.{0} (left_cancel_monoid.{0} empty)) empty (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (complete_lattice.{0} (left_cancel_monoid.{0} empty))) h0 empty))  := sorry --non-trivial
lemma new_lemma_133026 (h0 : topological_space (cancel_monoid (option pos))) : preconnected_space (cancel_monoid (option pos)) := sorry --non-trivial
lemma new_lemma_133027 (h0 : ring (semiring (has_top linarith.ineq))) : is_domain (semiring (has_top linarith.ineq)) := sorry --non-trivial
lemma new_lemma_133028 (h0 : ring (left_cancel_monoid (semiring empty))) : rank_condition (left_cancel_monoid (semiring empty)) := sorry --non-trivial
lemma new_lemma_133029 (h0 : add_group (has_neg (has_add unsigned))) : is_add_cyclic (has_neg (has_add unsigned)) := sorry --non-trivial
lemma new_lemma_133030 (h0 : ring (add_comm_monoid num)) : is_principal_ideal_ring (add_comm_monoid num) := sorry --non-trivial
lemma new_lemma_133031 (h0 : function.extfun nat fin) : @irreducible_space.{1} (complete_distrib_lattice.{1} Type) (@matrix.vec_empty.{1} (topological_space.{1} (complete_distrib_lattice.{1} Type)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_133032 (h0 : functor.add_const (add_monoid (has_star congr_arg_kind)) num) : @add_monoid.fg.{0} (has_star.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (add_monoid.{0} (has_star.{0} congr_arg_kind)) num h0)  := sorry --non-trivial
lemma new_lemma_133033 (h0 : filter (id (has_norm (has_norm num)))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_133034 (h0 : ordered_add_comm_monoid (mul_zero_class congr_arg_kind)) : archimedean (mul_zero_class congr_arg_kind) := sorry --non-trivial
lemma new_lemma_133035 (h0 : function.extfun Type add_monoid) : add_monoid.fg real.angle := sorry --non-trivial
lemma new_lemma_133036 (h0 : fin has_zero.zero) : @loc_path_connected_space.{0} (canonically_linear_ordered_monoid.{0} linarith.comp) (@matrix.vec_empty.{0} (topological_space.{0} (canonically_linear_ordered_monoid.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_133037 (h0 : uniform_space (sub_neg_monoid (has_Inf real))) : separated_space (sub_neg_monoid (has_Inf real)) := sorry --non-trivial
lemma new_lemma_133038 (h0 : topological_space (canonically_linear_ordered_monoid (has_add real))) : topological_space.separable_space (canonically_linear_ordered_monoid (has_add real)) := sorry --non-trivial
lemma new_lemma_133039 (h0 : complete_lattice (comm_group (option (ring pos)))) : complete_lattice.is_Sup_finite_compact (comm_group (option (ring pos))) := sorry --non-trivial
lemma new_lemma_133040 (h0 : has_mem.mem (has_emptyc linarith.ineq) has_emptyc.emptyc) : @path_connected_space.{0} (has_emptyc.{0} linarith.ineq) (@finset.pi.empty.{1 0} Type topological_space.{0} (has_emptyc.{0} linarith.ineq) h0)  := sorry --non-trivial
lemma new_lemma_133041 (h0 : ring (measurable_space (with_bot (distrib_lattice (random_gen string_imp))))) : is_domain (measurable_space (with_bot (distrib_lattice (random_gen string_imp)))) := sorry --non-trivial
lemma new_lemma_133042 (h0 : topological_space (normed_group num)) : irreducible_space (normed_group num) := sorry --non-trivial
lemma new_lemma_133043 (h0 : filter (add_cancel_monoid (has_add (has_add (has_pos_part (has_add (has_add linarith.comp))))))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_133044 (h0 : function.extfun ((Type -> Type) -> Type 1) (function.extfun (Type -> Type))) : @strong_rank_condition.{0} (has_add.{0} unsigned) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) (@function.extfun_app.{3 2} ((Type → Type) → Type 1) (function.extfun.{2 2} (Type → Type)) h0 (function.extfun.{2 1} Type)) ring.{0}) (has_add.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_133045 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @totally_disconnected_space.{0} (comm_monoid.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (comm_monoid.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_133046 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : list.nodup (function.extfun_app (function.extfun_app h0 list) (has_ssubset fun_info)) := sorry --non-trivial
lemma new_lemma_133047 (h0 : functor.add_const (function.extfun (Type 1) group) (has_add pos)) : @is_simple_group.{1} (finset.{1} Type) (@function.extfun_app.{3 2} (Type 1) group.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) group.{1}) (has_add.{0} pos) h0) (finset.{1} Type))  := sorry --non-trivial
lemma new_lemma_133048 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @has_exists_mul_of_le.{0} (add_cancel_monoid.{0} unsigned) (@function.extfun_app.{2 1} Type ordered_comm_monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ordered_comm_monoid.{0}) (add_cancel_monoid.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_133049 (h0 : functor.add_const (function.extfun Type ring) Type) : @strong_rank_condition.{0} (semigroup.{0} linarith.comp) (@function.extfun_app.{2 1} Type ring.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type ring.{0}) Type h0) (semigroup.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_133050 (h0 : topological_space (left_cancel_monoid empty)) : totally_disconnected_space (left_cancel_monoid empty) := sorry --non-trivial
lemma new_lemma_133051 (h0 : group (sub_neg_monoid (finset linarith.comp))) : is_simple_group (sub_neg_monoid (finset linarith.comp)) := sorry --non-trivial
lemma new_lemma_133052 (h0 : functor.add_const (complete_lattice (normed_linear_ordered_group empty)) unsigned) : @is_compactly_generated.{0} (normed_linear_ordered_group.{0} empty) (@functor.add_const.run.{0 0} (complete_lattice.{0} (normed_linear_ordered_group.{0} empty)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_133053 (h0 : topological_space (canonically_linear_ordered_monoid (option (option ennreal)))) : locally_compact_space (canonically_linear_ordered_monoid (option (option ennreal))) := sorry --non-trivial
lemma new_lemma_133054 (h0 : topological_space (has_union linarith.comp)) : totally_disconnected_space (has_union linarith.comp) := sorry --non-trivial
lemma new_lemma_133055 (h0 : topological_space (normed_comm_ring (has_Inf Type))) : loc_path_connected_space (normed_comm_ring (has_Inf Type)) := sorry --non-trivial
lemma new_lemma_133056 (h0 : ring (has_norm (semiring unsigned))) : rank_condition (has_norm (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_133057 (h0 : functor.add_const (topological_space (has_to_string pos)) Type) : @preconnected_space.{0} (has_to_string.{0} pos) (@functor.add_const.run.{0 1} (topological_space.{0} (has_to_string.{0} pos)) Type h0)  := sorry --non-trivial
lemma new_lemma_133058 (h0 : group (ring (ring linarith.comp))) : is_simple_group (ring (ring linarith.comp)) := sorry --non-trivial
lemma new_lemma_133059 (h0 : prod (plift (option unsigned)) (plift (option unsigned))) : id_rel h0 := sorry --non-trivial
lemma new_lemma_133060 (h0 : topological_space (cancel_monoid (has_add Type))) : totally_disconnected_space (cancel_monoid (has_add Type)) := sorry --non-trivial
lemma new_lemma_133061 (h0 : functor.add_const (topological_space (has_zero Type)) (ring pos)) : @loc_path_connected_space.{1} (has_zero.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (has_zero.{1} Type)) (ring.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_133062 (h0 : has_mem.mem Prop has_emptyc.emptyc) : @filter.Limsup.{0} Prop (@complete_lattice.to_conditionally_complete_lattice.{0} Prop Prop.complete_lattice) (@finset.pi.empty.{1 0} Type filter.{0} Prop h0)  := sorry --non-trivial
lemma new_lemma_133063 (h0 : functor.add_const (topological_space (semigroup name)) (finset Type)) : @preconnected_space.{0} (semigroup.{0} name) (@functor.add_const.run.{0 1} (topological_space.{0} (semigroup.{0} name)) (finset.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_133064 (h0 : functor.add_const (topological_space (partial_order empty)) empty) : @irreducible_space.{0} (partial_order.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (partial_order.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_133065 (h0 : function.extfun nat fin) : @normal_space.{0} (ordered_comm_ring.{0} real) (@matrix.vec_empty.{0} (topological_space.{0} (ordered_comm_ring.{0} real)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_133066 (h5 : add_group (nondiscrete_normed_field environment.projection_info)) : is_add_cyclic (nondiscrete_normed_field environment.projection_info) := sorry --non-trivial
lemma new_lemma_133067 (h0 : cancel_comm_monoid_with_zero (has_zero (has_zero Type))) : unique_factorization_monoid (has_zero (has_zero Type)) := sorry --non-trivial
lemma new_lemma_133068 (h0 : functor.add_const (complete_lattice (semigroup name)) Type) : @is_compactly_generated.{0} (semigroup.{0} name) (@functor.add_const.run.{0 1} (complete_lattice.{0} (semigroup.{0} name)) Type h0)  := sorry --non-trivial
lemma new_lemma_133069 (h0 : not (topological_space (with_one unsigned) -> false)) : @normal_space.{0} (with_one.{0} unsigned) (@classical.by_contradiction'.{1} (topological_space.{0} (with_one.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_133070 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @preconnected_space.{0} (semigroup.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (semigroup.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_133071 (h0 : function.extfun Type list) : list.nodup (function.extfun_app h0 (canonically_ordered_comm_semiring pos)) := sorry --non-trivial
lemma new_lemma_133072 (h0 : functor.add_const (semiring (semigroup linarith.comp)) (has_neg linarith.comp)) : @is_noetherian_ring.{0} (semigroup.{0} linarith.comp) (@functor.add_const.run.{0 0} (semiring.{0} (semigroup.{0} linarith.comp)) (has_neg.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_133073 (h0 : semiring (has_nndist (finset (finset (finset (finset (finset (finset unsigned)))))))) : is_noetherian_ring (has_nndist (finset (finset (finset (finset (finset (finset unsigned))))))) := sorry --non-trivial
lemma new_lemma_133074 (h0 : functor.add_const (function.extfun Type topological_space) (has_add Type)) : @normal_space.{0} (normed_comm_ring.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type topological_space.{0}) (has_add.{1} Type) h0) (normed_comm_ring.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_133075 (h0 : has_mem.mem ring has_emptyc.emptyc) : @is_domain.{0} (has_top.{0} num) (@function.extfun_app.{2 1} Type ring.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) ring.{0} h0) (has_top.{0} num))  := sorry --non-trivial
lemma new_lemma_133076 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @add_monoid.fg.{0} (has_to_string.{0} linarith.comp) (@function.extfun_app.{2 1} Type add_monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 add_monoid.{0}) (has_to_string.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_133077 (h0 : topological_space (has_pos_part (ring Type))) : preirreducible_space (has_pos_part (ring Type)) := sorry --non-trivial
lemma new_lemma_133078 (h0 : function.extfun (Type 1) monoid) : @monoid.fg.{1} (complete_distrib_lattice.{1} Type) (@function.extfun_app.{3 2} (Type 1) monoid.{1} h0 (complete_distrib_lattice.{1} Type))  := sorry --non-trivial
lemma new_lemma_133079 (h0 : topological_space (comm_group unsigned)) : totally_disconnected_space (comm_group unsigned) := sorry --non-trivial
lemma new_lemma_133080 (h0 : not (uniform_space (has_norm to_additive.value_type) -> false)) : @separated_space.{0} (has_norm.{0} to_additive.value_type) (@classical.by_contradiction'.{1} (uniform_space.{0} (has_norm.{0} to_additive.value_type)) h0)  := sorry --non-trivial
lemma new_lemma_133081 (h0 : functor.add_const (monoid (has_neg_part name)) ennreal) : @monoid.fg.{0} (has_neg_part.{0} name) (@functor.add_const.run.{0 0} (monoid.{0} (has_neg_part.{0} name)) ennreal h0)  := sorry --non-trivial
lemma new_lemma_133082 (h0 : group (semiring (semiring (has_norm (has_norm linarith.comp))))) : group.fg (semiring (semiring (has_norm (has_norm linarith.comp)))) := sorry --non-trivial
lemma new_lemma_133083 (h0 : topological_space (has_zero (has_add (ring (ring (has_to_string environment.implicit_infer_kind)))))) : t0_space (has_zero (has_add (ring (ring (has_to_string environment.implicit_infer_kind))))) := sorry --non-trivial
lemma new_lemma_133084 (h0 : topological_space (filter (linear_ordered_comm_monoid_with_zero unsigned))) : totally_separated_space (filter (linear_ordered_comm_monoid_with_zero unsigned)) := sorry --non-trivial
lemma new_lemma_133085 (h0 : topological_space (has_nnnorm (has_ssubset char))) (h1 : has_inf (has_nnnorm (has_ssubset char))) : has_continuous_inf (has_nnnorm (has_ssubset char)) := sorry --non-trivial
lemma new_lemma_133086 (h0 : function.extfun Type uniform_space) : @separated_space.{0} (ordered_comm_monoid.{0} linarith.comp) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (ordered_comm_monoid.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_133087 (h0 : functor.add_const (finset (has_add linarith.comp)) (finset environment.implicit_infer_kind)) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_133088 (h0 : functor.add_const (topological_space (has_pos_part pos)) linarith.comp) : @totally_separated_space.{0} (has_pos_part.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (has_pos_part.{0} pos)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_133089 (h0 : topological_space (has_top (has_norm num))) : discrete_topology (has_top (has_norm num)) := sorry --non-trivial
lemma new_lemma_133090 (h0 : not (ring (non_unital_non_assoc_semiring char) -> false)) : @is_domain.{0} (non_unital_non_assoc_semiring.{0} char) (@classical.by_contradiction'.{1} (ring.{0} (non_unital_non_assoc_semiring.{0} char)) h0)  := sorry --non-trivial
lemma new_lemma_133091 (h0 : functor.add_const (topological_space (has_Sup empty)) unsigned) : @totally_separated_space.{0} (has_Sup.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (has_Sup.{0} empty)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_133092 (h0 : functor.add_const (group (normed_comm_ring Type)) (has_neg pos)) : @is_cyclic.{1} (normed_comm_ring.{1} Type) (@functor.add_const.run.{1 0} (group.{1} (normed_comm_ring.{1} Type)) (has_neg.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_133093 (h0 : add_group (has_emptyc (has_top (has_top fun_info)))) : is_add_cyclic (has_emptyc (has_top (has_top fun_info))) := sorry --non-trivial
lemma new_lemma_133094 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @monoid.fg.{0} (ring.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 monoid.{0}) (ring.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_133095 (h1 : topological_space (nondiscrete_normed_field (normed_field (normed_field char)))) (h2 : set (nondiscrete_normed_field (normed_field (normed_field char)))) : is_path_connected h2 := sorry --non-trivial
lemma new_lemma_133096 (h0 : ring (has_neg Type)) : is_domain (has_neg Type) := sorry --non-trivial
lemma new_lemma_133097 (h0 : function.extfun (Type 1) ordered_add_comm_monoid) : @archimedean.{1} (has_add.{1} Type) (@function.extfun_app.{3 2} (Type 1) ordered_add_comm_monoid.{1} h0 (has_add.{1} Type))  := sorry --non-trivial
lemma new_lemma_133098 (h0 : not (cancel_comm_monoid_with_zero (add_right_cancel_monoid num) -> false)) : @unique_factorization_monoid.{0} (add_right_cancel_monoid.{0} num) (@classical.by_contradiction'.{1} (cancel_comm_monoid_with_zero.{0} (add_right_cancel_monoid.{0} num)) h0)  := sorry --non-trivial
lemma new_lemma_133099 (h0 : group (normed_group (semiring unsigned))) : is_cyclic (normed_group (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_133100 (h0 : list (has_inter ennreal)) : palindrome h0 := sorry --non-trivial
lemma new_lemma_133101 (h1 : function.extfun Type list) : list.nodup (function.extfun_app h1 (has_emptyc to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_133102 (h0 : functor.add_const (complete_lattice (semigroup Type)) pos) : @is_compactly_generated.{1} (semigroup.{1} Type) (@functor.add_const.run.{1 0} (complete_lattice.{1} (semigroup.{1} Type)) pos h0)  := sorry --non-trivial
lemma new_lemma_133103 (h0 : functor.add_const (add_group (canonically_ordered_monoid pos)) name) : @is_add_cyclic.{0} (canonically_ordered_monoid.{0} pos) (@functor.add_const.run.{0 0} (add_group.{0} (canonically_ordered_monoid.{0} pos)) name h0)  := sorry --non-trivial
lemma new_lemma_133104 (h0 : topological_space (measurable_space empty)) : totally_separated_space (measurable_space empty) := sorry --non-trivial
lemma new_lemma_133105 (h0 : uniform_space (has_add (has_nnnorm linarith.ineq))) : complete_space (has_add (has_nnnorm linarith.ineq)) := sorry --non-trivial
lemma new_lemma_133106 (h0 : monoid (ordered_comm_ring (ring (has_add pos)))) : monoid.fg (ordered_comm_ring (ring (has_add pos))) := sorry --non-trivial
lemma new_lemma_133107 (h0 : ring (canonically_ordered_monoid (finset (finset pos)))) : rank_condition (canonically_ordered_monoid (finset (finset pos))) := sorry --non-trivial
lemma new_lemma_133108 (h0 : topological_space (comm_group (has_neg pos))) : totally_disconnected_space (comm_group (has_neg pos)) := sorry --non-trivial
lemma new_lemma_133109 (h0 : group (has_zero (has_neg_part (has_neg_part Type)))) : is_cyclic (has_zero (has_neg_part (has_neg_part Type))) := sorry --non-trivial
lemma new_lemma_133110 (h0 : functor.add_const (topological_space (has_Sup unsigned)) unsigned) : @loc_path_connected_space.{0} (has_Sup.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (has_Sup.{0} unsigned)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_133111 (h0 : add_group (has_Sup unsigned)) : is_add_cyclic (has_Sup unsigned) := sorry --non-trivial
lemma new_lemma_133112 (h0 : functor.add_const (function.extfun Type finset) linarith.comp) : finset.nonempty (function.extfun_app (functor.add_const.run h0) (ring linarith.comp)) := sorry --non-trivial
lemma new_lemma_133113 (h0 : finset (monoid (option (option ennreal)))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_133114 (h0 : functor.add_const (topological_space (partial_order empty)) empty) : @loc_path_connected_space.{0} (partial_order.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (partial_order.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_133115 (h0 : list (cancel_monoid (finset (finset pos)))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_133116 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @totally_separated_space.{0} (normed_group.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (normed_group.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_133117 (h0 : topological_space (ordered_comm_ring pos)) : totally_disconnected_space (ordered_comm_ring pos) := sorry --non-trivial
lemma new_lemma_133118 (h0 : ring (omega_complete_partial_order (option (option congr_arg_kind)))) : strong_rank_condition (omega_complete_partial_order (option (option congr_arg_kind))) := sorry --non-trivial
lemma new_lemma_133119 (h0 : group (linear_ordered_add_comm_group (has_inv (has_top linarith.comp_source)))) : is_cyclic (linear_ordered_add_comm_group (has_inv (has_top linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_133120 (h0 : topological_space (ordered_comm_ring (has_pos_part Type))) : totally_separated_space (ordered_comm_ring (has_pos_part Type)) := sorry --non-trivial
lemma new_lemma_133121 (h0 : functor.add_const (uniform_space (add_cancel_monoid linarith.comp)) environment.implicit_infer_kind) : @complete_space.{0} (add_cancel_monoid.{0} linarith.comp) (@functor.add_const.run.{0 0} (uniform_space.{0} (add_cancel_monoid.{0} linarith.comp)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_133122 (h0 : fin has_zero.zero) : @complete_lattice.is_Sup_finite_compact.{0} (has_bot.{0} linarith.comp) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@matrix.vec_empty.{1} (function.extfun.{2 1} Type complete_lattice.{0}) h0) (has_bot.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_133123 (h2 : topological_space enat) (h3 : set enat) : is_path_connected h3 := sorry --non-trivial
lemma new_lemma_133124 (h0 : topological_space (has_to_string (has_to_string (has_add (semigroup ennreal))))) : t0_space (has_to_string (has_to_string (has_add (semigroup ennreal)))) := sorry --non-trivial
lemma new_lemma_133125 (h0 : add_group (has_neg_part (has_nndist name))) : is_add_cyclic (has_neg_part (has_nndist name)) := sorry --non-trivial
lemma new_lemma_133126 (h0 : functor.add_const (group (add_cancel_monoid pos)) linarith.comp) : @is_cyclic.{0} (add_cancel_monoid.{0} pos) (@functor.add_const.run.{0 0} (group.{0} (add_cancel_monoid.{0} pos)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_133127 (h0 : topological_space (linear_ordered_comm_monoid (has_neg fun_info))) : topological_space.first_countable_topology (linear_ordered_comm_monoid (has_neg fun_info)) := sorry --non-trivial
lemma new_lemma_133128 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : id_rel (function.extfun_app (function.extfun_app h0 (prod (has_zero ennreal))) (has_zero ennreal)) := sorry --non-trivial
lemma new_lemma_133129 (h0 : topological_space (metric_space (semiring empty))) : topological_space.separable_space (metric_space (semiring empty)) := sorry --non-trivial
lemma new_lemma_133130 (h0 : prod (mul_zero_class (boolean_algebra.core (has_add Type))) (mul_zero_class (boolean_algebra.core (has_add Type)))) : id_rel h0 := sorry --non-trivial
lemma new_lemma_133131 (h0 : group (random_gen to_additive.value_type)) : is_cyclic (random_gen to_additive.value_type) := sorry --non-trivial
lemma new_lemma_133132 (h0 : function.extfun Type topological_space) : @totally_separated_space.{0} (complete_distrib_lattice.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (complete_distrib_lattice.{0} pos))  := sorry --non-trivial
lemma new_lemma_133133 (h0 : topological_space (has_add (has_to_string (ring environment.implicit_infer_kind)))) : locally_compact_space (has_add (has_to_string (ring environment.implicit_infer_kind))) := sorry --non-trivial
lemma new_lemma_133134 (h0 : functor.add_const (function.extfun Type list) linarith.comp) : list.nodup (function.extfun_app (functor.add_const.run h0) (has_add linarith.comp)) := sorry --non-trivial
lemma new_lemma_133135 (h0 : topological_space (linear_ordered_field pos)) : locally_compact_space (linear_ordered_field pos) := sorry --non-trivial
lemma new_lemma_133136 (h0 : complete_lattice (has_zero (has_neg Type))) : is_compactly_generated (has_zero (has_neg Type)) := sorry --non-trivial
lemma new_lemma_133137 (h0 : topological_space (add_right_cancel_monoid (semiring unsigned))) : t0_space (add_right_cancel_monoid (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_133138 (h0 : not (ring (partial_order empty) -> false)) : @is_domain.{0} (partial_order.{0} empty) (@classical.by_contradiction'.{1} (ring.{0} (partial_order.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_133139 (h0 : has_mem.mem complete_lattice has_emptyc.emptyc) : @is_compactly_generated.{0} congr_arg_kind (@function.extfun_app.{2 1} Type complete_lattice.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) complete_lattice.{0} h0) congr_arg_kind)  := sorry --non-trivial
lemma new_lemma_133140 (h0 : ring (has_append reducibility_hints)) : strong_rank_condition (has_append reducibility_hints) := sorry --non-trivial
lemma new_lemma_133141 (h1 : uniform_space (has_top (has_inv to_additive.value_type))) : complete_space (has_top (has_inv to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_133142 (h0 : group (metric_space num)) : group.fg (metric_space num) := sorry --non-trivial
lemma new_lemma_133143 (h0 : complete_lattice (normed_linear_ordered_group (option empty))) : complete_lattice.is_Sup_finite_compact (normed_linear_ordered_group (option empty)) := sorry --non-trivial
lemma new_lemma_133144 (h1 : add_group reducibility_hints) (h2 : add_subgroup reducibility_hints) : add_subgroup.characteristic h2 := sorry --non-trivial
lemma new_lemma_133145 (h0 : cancel_comm_monoid_with_zero (finset (finset Type))) : unique_factorization_monoid (finset (finset Type)) := sorry --non-trivial
lemma new_lemma_133146 (h0 : has_lt (nondiscrete_normed_field fun_info)) : no_max_order (nondiscrete_normed_field fun_info) := sorry --non-trivial
lemma new_lemma_133147 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @rank_condition.{0} (has_inv.{0} fun_info) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (has_inv.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_133148 (h1 : function.extfun (Type -> Type) (function.extfun Type)) : @monoid.fg.{0} (has_emptyc.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h1 monoid.{0}) (has_emptyc.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_133149 (h0 : functor.add_const (function.extfun Type list) environment.implicit_infer_kind) : list.nodup (function.extfun_app (functor.add_const.run h0) linarith.comp) := sorry --non-trivial
lemma new_lemma_133150 (h0 : ordered_comm_monoid (has_bot (has_add (has_neg name)))) : has_exists_mul_of_le (has_bot (has_add (has_neg name))) := sorry --non-trivial
lemma new_lemma_133151 (h0 : functor.add_const (topological_space (ring name)) Type) : @discrete_topology.{0} (ring.{0} name) (@functor.add_const.run.{0 1} (topological_space.{0} (ring.{0} name)) Type h0)  := sorry --non-trivial
lemma new_lemma_133152 (h0 : topological_space linarith.comp_source) (h1 : function.extfun linarith.comp_source (fun (x : linarith.comp_source), Prop)) : is_open (function.extfun_app h1) := sorry --non-trivial
lemma new_lemma_133153 (h0 : group (normed_comm_ring (has_add pos))) : is_simple_group (normed_comm_ring (has_add pos)) := sorry --non-trivial
lemma new_lemma_133154 (h0 : function.extfun (Type 1) complete_lattice) : @is_compactly_generated.{1} (sub_neg_monoid.{1} Type) (@function.extfun_app.{3 2} (Type 1) complete_lattice.{1} h0 (sub_neg_monoid.{1} Type))  := sorry --non-trivial
lemma new_lemma_133155 (h0 : not (function.extfun Type topological_space -> false)) : @path_connected_space.{0} (has_top.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (has_top.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_133156 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_noetherian_ring.{0} (normed_comm_ring.{0} unsigned) (@function.extfun_app.{2 1} Type semiring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 semiring.{0}) (normed_comm_ring.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_133157 (h0 : ring (canonically_ordered_comm_semiring (finset pos))) : rank_condition (canonically_ordered_comm_semiring (finset pos)) := sorry --non-trivial
lemma new_lemma_133158 (h0 : complete_lattice (simple_graph (mul_one_class reducibility_hints))) : is_compactly_generated (simple_graph (mul_one_class reducibility_hints)) := sorry --non-trivial
lemma new_lemma_133159 (h0 : ring (random_gen (random_gen to_additive.value_type))) : is_domain (random_gen (random_gen to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_133160 (h0 : uniform_space (option (semiring congr_arg_kind))) : complete_space (option (semiring congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_133161 (h0 : functor.add_const (function.extfun Type complete_lattice) (has_neg pos)) : @is_atomistic.{0} (normed_comm_ring.{0} linarith.comp) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type complete_lattice.{0}) (has_neg.{0} pos) h0) (normed_comm_ring.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_133162 (h0 : prod (canonically_ordered_add_monoid (option empty)) (canonically_ordered_add_monoid (option empty))) : id_rel h0 := sorry --non-trivial
lemma new_lemma_133163 (h0 : ring (ring (has_Inf (has_Inf (has_Inf linarith.comp))))) : is_principal_ideal_ring (ring (has_Inf (has_Inf (has_Inf linarith.comp)))) := sorry --non-trivial
lemma new_lemma_133164 (h0 : topological_space (normed_comm_ring (comm_group name))) : path_connected_space (normed_comm_ring (comm_group name)) := sorry --non-trivial
lemma new_lemma_133165 (h0 : list (has_pos_part (has_add (has_pos_part (has_pos_part Type))))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_133166 (h2 : set (add_comm_semigroup char -> linarith.ineq)) : set.separates_points h2 := sorry --non-trivial
lemma new_lemma_133167 (h0 : function.extfun (Type 1) group) : @is_simple_group.{1} (boolean_algebra.core.{1} Type) (@function.extfun_app.{3 2} (Type 1) group.{1} h0 (boolean_algebra.core.{1} Type))  := sorry --non-trivial
lemma new_lemma_133168 (h0 : topological_space (semigroup (option (option (option (option ennreal)))))) : totally_separated_space (semigroup (option (option (option (option ennreal))))) := sorry --non-trivial
lemma new_lemma_133169 (h0 : topological_space (has_emptyc (has_norm linarith.comp_source))) : irreducible_space (has_emptyc (has_norm linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_133170 (h0 : functor.add_const (function.extfun (Type 1) topological_space) Type) : @path_connected_space.{1} (ordered_comm_ring.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@functor.add_const.run.{2 1} (function.extfun.{3 2} (Type 1) topological_space.{1}) Type h0) (ordered_comm_ring.{1} Type))  := sorry --non-trivial
lemma new_lemma_133171 (h0 : ring (add_group (semiring unsigned))) : strong_rank_condition (add_group (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_133172 (h0 : list (add_cancel_monoid (ring name))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_133173 (h0 : functor.add_const (list (boolean_algebra linarith.comp)) (finset pos)) : list.nodup (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_133174 (h0 : topological_space (id congr_arg_kind)) : totally_disconnected_space (id congr_arg_kind) := sorry --non-trivial
lemma new_lemma_133175 (h0 : topological_space (comm_group (option name))) : discrete_topology (comm_group (option name)) := sorry --non-trivial
lemma new_lemma_133176 (h0 : monoid (has_add (has_neg (mul_one_class linarith.comp)))) : monoid.fg (has_add (has_neg (mul_one_class linarith.comp))) := sorry --non-trivial
lemma new_lemma_133177 (h0 : function.extfun Type uniform_space) : @complete_space.{0} (has_emptyc.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (has_emptyc.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_133178 (h0 : ring (ordered_comm_ring (ordered_ring pos))) : is_principal_ideal_ring (ordered_comm_ring (ordered_ring pos)) := sorry --non-trivial
lemma new_lemma_133179 (h0 : functor.add_const (ring (has_add Type)) environment.implicit_infer_kind) : @is_domain.{1} (has_add.{1} Type) (@functor.add_const.run.{1 0} (ring.{1} (has_add.{1} Type)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_133180 (h0 : ring (has_add (has_add real))) : rank_condition (has_add (has_add real)) := sorry --non-trivial
lemma new_lemma_133181 (h0 : not (monoid (id congr_arg_kind) -> false)) : @monoid.fg.{0} (@id.{2} Type congr_arg_kind) (@classical.by_contradiction'.{1} (monoid.{0} (@id.{2} Type congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_133182 (h0 : complete_lattice (add_semigroup unsigned)) : complete_lattice.is_Sup_finite_compact (add_semigroup unsigned) := sorry --non-trivial
lemma new_lemma_133183 (h0 : topological_space (has_norm (has_norm to_additive.value_type))) : discrete_topology (has_norm (has_norm to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_133184 (h0 : ring (partial_order (semiring (semiring num)))) : strong_rank_condition (partial_order (semiring (semiring num))) := sorry --non-trivial
lemma new_lemma_133185 (h0 : ordered_add_comm_monoid (add_cancel_monoid (normed_comm_ring linarith.comp))) : archimedean (add_cancel_monoid (normed_comm_ring linarith.comp)) := sorry --non-trivial
lemma new_lemma_133186 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_compactly_generated.{0} (has_add.{0} real) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (has_add.{0} real))  := sorry --non-trivial
lemma new_lemma_133187 (h0 : topological_space (has_neg_part pos)) : irreducible_space (has_neg_part pos) := sorry --non-trivial
lemma new_lemma_133188 (h0 : topological_space (add_comm_semigroup enat)) (h1 : preorder (add_comm_semigroup enat)) : order_topology (add_comm_semigroup enat) := sorry --non-trivial
lemma new_lemma_133189 (h0 : group (mul_zero_class (has_nndist name))) : is_cyclic (mul_zero_class (has_nndist name)) := sorry --non-trivial
lemma new_lemma_133190 (h0 : topological_space (ordered_comm_ring (has_bot (has_add Type)))) : topological_space.separable_space (ordered_comm_ring (has_bot (has_add Type))) := sorry --non-trivial
lemma new_lemma_133191 (h1 : topological_space (has_compl (has_nnnorm string_imp))) : path_connected_space (has_compl (has_nnnorm string_imp)) := sorry --non-trivial
lemma new_lemma_133192 (h0 : group (canonically_linear_ordered_monoid (ordered_comm_monoid pos))) : group.fg (canonically_linear_ordered_monoid (ordered_comm_monoid pos)) := sorry --non-trivial
lemma new_lemma_133193 (h0 : complete_lattice (has_Inf (has_Inf Type))) : complete_lattice.is_Sup_finite_compact (has_Inf (has_Inf Type)) := sorry --non-trivial
lemma new_lemma_133194 (h0 : functor.add_const (functor.add_const (uniform_space auto.case_option) num) empty) : @complete_space.{0} auto.case_option (@functor.add_const.run.{0 0} (uniform_space.{0} auto.case_option) num (@functor.add_const.run.{0 0} (functor.add_const.{0 0} (uniform_space.{0} auto.case_option) num) empty h0))  := sorry --non-trivial
lemma new_lemma_133195 (h0 : topological_space (add_right_cancel_monoid congr_arg_kind)) : t1_space (add_right_cancel_monoid congr_arg_kind) := sorry --non-trivial
lemma new_lemma_133196 (h0 : has_mem.mem topological_space has_emptyc.emptyc) : @discrete_topology.{0} (has_neg.{0} fun_info) (@function.extfun_app.{2 1} Type topological_space.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) topological_space.{0} h0) (has_neg.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_133197 (h0 : function.extfun Type group) : @normalizer_condition.{0} (boolean_algebra.{0} real) (@function.extfun_app.{2 1} Type group.{0} h0 (boolean_algebra.{0} real))  := sorry --non-trivial
lemma new_lemma_133198 (h0 : function.extfun Type topological_space) : @preconnected_space.{0} (has_add.{0} ennreal) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_add.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_133199 (h0 : functor.add_const (function.extfun Type list) name) : list.nodup (function.extfun_app (functor.add_const.run h0) (has_pos_part linarith.comp)) := sorry --non-trivial
lemma new_lemma_133200 (h0 : topological_space (pseudo_metric_space (option pos))) : t0_space (pseudo_metric_space (option pos)) := sorry --non-trivial
lemma new_lemma_133201 (h0 : ring (normed_group (complete_semilattice_Sup linarith.comp))) : rank_condition (normed_group (complete_semilattice_Sup linarith.comp)) := sorry --non-trivial
lemma new_lemma_133202 (h0 : functor.add_const Prop (ordered_cancel_add_comm_monoid congr_arg_kind)) : functor.add_const.run h0 := sorry --non-trivial
lemma new_lemma_133203 (h0 : function.extfun Type ring) : @is_domain.{0} (linear_ordered_add_comm_group.{0} (has_nnnorm.{0} fun_info)) (@function.extfun_app.{2 1} Type ring.{0} h0 (linear_ordered_add_comm_group.{0} (has_nnnorm.{0} fun_info)))  := sorry --non-trivial
lemma new_lemma_133204 (h0 : not (function.extfun Type list -> false)) : list.nodup (function.extfun_app (classical.by_contradiction' h0) (encodable to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_133205 (h0 : group (add_right_cancel_monoid (semiring unsigned))) : group.fg (add_right_cancel_monoid (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_133206 (h0 : not (function.extfun Type topological_space -> false)) : @totally_separated_space.{0} (measurable_space.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (measurable_space.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_133207 (h0 : functor.comp topological_space has_neg_part ennreal) : @irreducible_space.{0} (has_neg_part.{0} ennreal) (@functor.comp.run.{0 0 0} topological_space.{0} has_neg_part.{0} ennreal h0)  := sorry --non-trivial
lemma new_lemma_133208 (h0 : list (monoid_with_zero pos)) : palindrome h0 := sorry --non-trivial
lemma new_lemma_133209 (h0 : function.extfun Type topological_space) : @sequential_space.{0} (has_neg_part.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_neg_part.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_133210 (h0 : ring (linear_ordered_comm_monoid_with_zero empty)) : strong_rank_condition (linear_ordered_comm_monoid_with_zero empty) := sorry --non-trivial
lemma new_lemma_133211 (h0 : topological_space (semigroup (has_add (has_add linarith.comp)))) : totally_separated_space (semigroup (has_add (has_add linarith.comp))) := sorry --non-trivial
lemma new_lemma_133212 (h0 : functor.add_const (group (add_comm_monoid name)) Type) : @is_cyclic.{0} (add_comm_monoid.{0} name) (@functor.add_const.run.{0 1} (group.{0} (add_comm_monoid.{0} name)) Type h0)  := sorry --non-trivial
lemma new_lemma_133213 (h0 : topological_space (has_neg_part (option unsigned))) : t1_space (has_neg_part (option unsigned)) := sorry --non-trivial
lemma new_lemma_133214 (h0 : group (boolean_algebra ennreal)) : is_simple_group (boolean_algebra ennreal) := sorry --non-trivial
lemma new_lemma_133215 (h0 : semiring (semigroup (option name))) : is_noetherian_ring (semigroup (option name)) := sorry --non-trivial
lemma new_lemma_133216 (h0 : ring (has_Inf (has_add pos))) : is_domain (has_Inf (has_add pos)) := sorry --non-trivial
lemma new_lemma_133217 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @t0_space.{1} (semigroup.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 topological_space.{1}) (semigroup.{1} Type))  := sorry --non-trivial
lemma new_lemma_133218 (h0 : uniform_space (has_nndist (has_to_string (has_to_string name)))) : separated_space (has_nndist (has_to_string (has_to_string name))) := sorry --non-trivial
lemma new_lemma_133219 (h0 : monoid (boolean_algebra (has_Inf Type))) : monoid.fg (boolean_algebra (has_Inf Type)) := sorry --non-trivial
lemma new_lemma_133220 (h0 : topological_space (comm_ring (random_gen (random_gen (random_gen to_additive.value_type))))) : t0_space (comm_ring (random_gen (random_gen (random_gen to_additive.value_type)))) := sorry --non-trivial
lemma new_lemma_133221 (h0 : function.extfun (finset Type) (has_mem.mem (has_norm linarith.comp_source))) : @locally_compact_space.{0} (has_norm.{0} linarith.comp_source) (@finset.pi.empty.{1 0} Type topological_space.{0} (has_norm.{0} linarith.comp_source) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (has_norm.{0} linarith.comp_source)) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_133222 (h0 : add_group (mul_zero_class empty)) : is_add_cyclic (mul_zero_class empty) := sorry --non-trivial
lemma new_lemma_133223 (h0 : topological_space (add_comm_monoid (has_add (has_Inf Type)))) : topological_space.separable_space (add_comm_monoid (has_add (has_Inf Type))) := sorry --non-trivial
lemma new_lemma_133224 (h0 : list (random_gen (random_gen (random_gen to_additive.value_type)))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_133225 (h0 : group (complete_distrib_lattice (ring Type))) : is_simple_group (complete_distrib_lattice (ring Type)) := sorry --non-trivial
lemma new_lemma_133226 (h0 : ring (add_cancel_monoid (finset name))) : rank_condition (add_cancel_monoid (finset name)) := sorry --non-trivial
lemma new_lemma_133227 (h0 : semiring (pseudo_metric_space (option (option unsigned)))) : is_noetherian_ring (pseudo_metric_space (option (option unsigned))) := sorry --non-trivial
lemma new_lemma_133228 (h0 : ring (canonically_ordered_monoid (has_neg pos))) : strong_rank_condition (canonically_ordered_monoid (has_neg pos)) := sorry --non-trivial
lemma new_lemma_133229 (h0 : topological_space (has_add (has_nnnorm linarith.ineq))) : totally_disconnected_space (has_add (has_nnnorm linarith.ineq)) := sorry --non-trivial
lemma new_lemma_133230 (h0 : group (with_bot (has_sub empty))) : is_cyclic (with_bot (has_sub empty)) := sorry --non-trivial
lemma new_lemma_133231 (h0 : add_monoid (has_norm empty)) : add_monoid.fg (has_norm empty) := sorry --non-trivial
lemma new_lemma_133232 (h0 : ring (complete_linear_order empty)) : rank_condition (complete_linear_order empty) := sorry --non-trivial
lemma new_lemma_133233 (h0 : uniform_space (add_left_cancel_monoid (has_nnnorm (has_append linarith.ineq)))) : complete_space (add_left_cancel_monoid (has_nnnorm (has_append linarith.ineq))) := sorry --non-trivial
lemma new_lemma_133234 (h0 : complete_lattice (has_lt (has_neg enat))) : is_compactly_generated (has_lt (has_neg enat)) := sorry --non-trivial
lemma new_lemma_133235 (h0 : add_group (semi_normed_ring (mul_one_class reducibility_hints))) : is_add_cyclic (semi_normed_ring (mul_one_class reducibility_hints)) := sorry --non-trivial
lemma new_lemma_133236 (h1 : preorder (mul_one_class enat)) (h2 : set (mul_one_class enat)) : set.is_pwo h2 := sorry --non-trivial
lemma new_lemma_133237 (h0 : functor.add_const (ring (plift empty)) congr_arg_kind) : @is_principal_ideal_ring.{1} (plift.{1} empty) (@functor.add_const.run.{1 0} (ring.{1} (plift.{1} empty)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_133238 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_compactly_generated.{0} (distrib_lattice.{0} num) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (distrib_lattice.{0} num))  := sorry --non-trivial
lemma new_lemma_133239 (h0 : functor.add_const (topological_space (has_zero unsigned)) name) : @path_connected_space.{0} (has_zero.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (has_zero.{0} unsigned)) name h0)  := sorry --non-trivial
lemma new_lemma_133240 (h0 : functor.add_const (function.extfun Type topological_space) pos) : @irreducible_space.{0} (semigroup.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) pos h0) (semigroup.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_133241 (h0 : ring (has_to_string (finset (finset name)))) : rank_condition (has_to_string (finset (finset name))) := sorry --non-trivial
lemma new_lemma_133242 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_noetherian_ring.{0} (ordered_comm_monoid.{0} linarith.comp) (@function.extfun_app.{2 1} Type semiring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 semiring.{0}) (ordered_comm_monoid.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_133243 (h0 : functor.add_const (add_group (finset empty)) unsigned) : @is_add_cyclic.{0} (finset.{0} empty) (@functor.add_const.run.{0 0} (add_group.{0} (finset.{0} empty)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_133244 (h0 : group (ordered_comm_ring (has_Inf name))) : normalizer_condition (ordered_comm_ring (has_Inf name)) := sorry --non-trivial
lemma new_lemma_133245 (h0 : topological_space (mul_zero_class name)) : discrete_topology (mul_zero_class name) := sorry --non-trivial
lemma new_lemma_133246 (h0 : prod (free_add_monoid unsigned) (free_add_monoid unsigned)) : id_rel h0 := sorry --non-trivial
lemma new_lemma_133247 (h0 : function.extfun (finset (Type -> Type)) (has_mem.mem ring)) : @rank_condition.{0} congr_arg_kind (@function.extfun_app.{2 1} Type ring.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) ring.{0} (@function.extfun_app.{2 0} (finset.{1} (Type → Type)) (@has_mem.mem.{1 1} (Type → Type) (finset.{1} (Type → Type)) (@finset.has_mem.{1} (Type → Type)) ring.{0}) h0 (@has_emptyc.emptyc.{1} (finset.{1} (Type → Type)) (@finset.has_emptyc.{1} (Type → Type))))) congr_arg_kind)  := sorry --non-trivial
lemma new_lemma_133248 (h0 : functor.add_const (topological_space (has_pos_part linarith.comp)) Type) : @sequential_space.{0} (has_pos_part.{0} linarith.comp) (@functor.add_const.run.{0 1} (topological_space.{0} (has_pos_part.{0} linarith.comp)) Type h0)  := sorry --non-trivial
lemma new_lemma_133249 (h0 : functor.add_const (topological_space (boolean_algebra environment.implicit_infer_kind)) Type) : @preirreducible_space.{0} (boolean_algebra.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 1} (topological_space.{0} (boolean_algebra.{0} environment.implicit_infer_kind)) Type h0)  := sorry --non-trivial
lemma new_lemma_133250 (h2 : topological_space (normed_field (random_gen (random_gen (random_gen (random_gen char)))))) : totally_disconnected_space (normed_field (random_gen (random_gen (random_gen (random_gen char))))) := sorry --non-trivial
lemma new_lemma_133251 (h0 : topological_space (with_bot (has_norm (semiring empty)))) : path_connected_space (with_bot (has_norm (semiring empty))) := sorry --non-trivial
lemma new_lemma_133252 (h0 : function.extfun Type monoid) : @monoid.fg.{0} linarith.ineq (@function.extfun_app.{2 1} Type monoid.{0} h0 linarith.ineq)  := sorry --non-trivial
lemma new_lemma_133253 (h0 : ordered_add_comm_monoid (add_comm_monoid (option (option (option unsigned))))) : archimedean (add_comm_monoid (option (option (option unsigned)))) := sorry --non-trivial
lemma new_lemma_133254 (h0 : complete_lattice (ordered_cancel_add_comm_monoid num)) : is_compactly_generated (ordered_cancel_add_comm_monoid num) := sorry --non-trivial
lemma new_lemma_133255 (h0 : functor.add_const (add_group (semigroup environment.implicit_infer_kind)) unsigned) : @is_add_cyclic.{0} (semigroup.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (add_group.{0} (semigroup.{0} environment.implicit_infer_kind)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_133256 (h0 : topological_space (comm_group (has_add pos))) : topological_space.separable_space (comm_group (has_add pos)) := sorry --non-trivial
lemma new_lemma_133257 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @totally_disconnected_space.{0} (has_bot.{0} real) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_bot.{0} real))  := sorry --non-trivial
lemma new_lemma_133258 (h0 : functor.comp topological_space has_neg linarith.comp) : @regular_space.{0} (has_neg.{0} linarith.comp) (@functor.comp.run.{0 0 0} topological_space.{0} has_neg.{0} linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_133259 (h0 : uniform_space (complete_semilattice_Sup Type)) : separated_space (complete_semilattice_Sup Type) := sorry --non-trivial
lemma new_lemma_133260 (h0 : topological_space (canonically_ordered_monoid (has_pos_part linarith.comp))) : regular_space (canonically_ordered_monoid (has_pos_part linarith.comp)) := sorry --non-trivial
lemma new_lemma_133261 (h0 : functor.add_const (filter (finset pos)) Type) : filter.ne_bot (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_133262 (h0 : ulower (fin has_zero.zero)) (h1 : pnat) : pnat.coprime (matrix.vec_empty (ulower.up h0)) (id h1) := sorry --non-trivial
lemma new_lemma_133263 (h0 : topological_space (complete_distrib_lattice congr_arg_kind)) : totally_separated_space (complete_distrib_lattice congr_arg_kind) := sorry --non-trivial
lemma new_lemma_133264 (h0 : function.extfun (Type 1) group) : @is_simple_group.{1} (cancel_monoid.{1} Type) (@function.extfun_app.{3 2} (Type 1) group.{1} h0 (cancel_monoid.{1} Type))  := sorry --non-trivial
lemma new_lemma_133265 (h0 : function.extfun Type filter) : filter.ne_bot (function.extfun_app h0 (normed_group string_imp)) := sorry --non-trivial
lemma new_lemma_133266 (h0 : ordered_comm_monoid (has_bot (sub_neg_monoid real))) : has_exists_mul_of_le (has_bot (sub_neg_monoid real)) := sorry --non-trivial
lemma new_lemma_133267 (h0 : group (has_zero (comm_group (has_neg_part (has_neg_part (comm_group Type)))))) : normalizer_condition (has_zero (comm_group (has_neg_part (has_neg_part (comm_group Type))))) := sorry --non-trivial
lemma new_lemma_133268 (h0 : not (group (id num) -> false)) : @is_cyclic.{0} (@id.{2} Type num) (@classical.by_contradiction'.{1} (group.{0} (@id.{2} Type num)) h0)  := sorry --non-trivial
lemma new_lemma_133269 (h0 : group (dlist char)) : is_cyclic (dlist char) := sorry --non-trivial
lemma new_lemma_133270 (h0 : topological_space (add_comm_semigroup char)) : t0_space (add_comm_semigroup char) := sorry --non-trivial
lemma new_lemma_133271 (h0 : uniform_space (with_one (with_one (with_one (normed_group linarith.ineq))))) : complete_space (with_one (with_one (with_one (normed_group linarith.ineq)))) := sorry --non-trivial
lemma new_lemma_133272 (h0 : complete_lattice (omega_complete_partial_order unsigned)) : complete_lattice.is_Sup_finite_compact (omega_complete_partial_order unsigned) := sorry --non-trivial
lemma new_lemma_133273 (h0 : list (with_bot linarith.ineq)) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_133274 (h0 : topological_space (ordered_ring (semiring empty))) : t0_space (ordered_ring (semiring empty)) := sorry --non-trivial
lemma new_lemma_133275 (h0 : group (ordered_comm_monoid (finset Type))) : is_cyclic (ordered_comm_monoid (finset Type)) := sorry --non-trivial
lemma new_lemma_133276 (h0 : functor.add_const (topological_space (complete_distrib_lattice linarith.comp)) pos) : @regular_space.{0} (complete_distrib_lattice.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (complete_distrib_lattice.{0} linarith.comp)) pos h0)  := sorry --non-trivial
lemma new_lemma_133277 (h0 : topological_space (uniform_space (mul_one_class reducibility_hints))) : t0_space (uniform_space (mul_one_class reducibility_hints)) := sorry --non-trivial
lemma new_lemma_133278 (h0 : functor.add_const (topological_space (has_nndist empty)) num) : @totally_separated_space.{0} (has_nndist.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (has_nndist.{0} empty)) num h0)  := sorry --non-trivial
lemma new_lemma_133279 (h0 : topological_space (has_zero (option unsigned))) : regular_space (has_zero (option unsigned)) := sorry --non-trivial
lemma new_lemma_133280 (h0 : function.extfun Type list) : list.nodup (function.extfun_app h0 (cancel_monoid (option num))) := sorry --non-trivial
lemma new_lemma_133281 (h0 : not (complete_lattice (id congr_arg_kind) -> false)) : @complete_lattice.is_Sup_finite_compact.{0} (@id.{2} Type congr_arg_kind) (@classical.by_contradiction'.{1} (complete_lattice.{0} (@id.{2} Type congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_133282 (h0 : functor.add_const (function.extfun (Type 1) topological_space) (has_Inf pos)) : @topological_space.separable_space.{1} Type (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) topological_space.{1}) (has_Inf.{0} pos) h0) Type)  := sorry --non-trivial
lemma new_lemma_133283 (h0 : topological_space (partial_order (semiring empty))) : preirreducible_space (partial_order (semiring empty)) := sorry --non-trivial
lemma new_lemma_133284 (h0 : not (uniform_space (mul_one_class char) -> false)) : @complete_space.{0} (mul_one_class.{0} char) (@classical.by_contradiction'.{1} (uniform_space.{0} (mul_one_class.{0} char)) h0)  := sorry --non-trivial
lemma new_lemma_133285 (h0 : functor.add_const (topological_space (ring Type)) Type) : @sequential_space.{1} (ring.{1} Type) (@functor.add_const.run.{1 1} (topological_space.{1} (ring.{1} Type)) Type h0)  := sorry --non-trivial
lemma new_lemma_133286 (h0 : group (has_to_string (has_neg_part Type))) : normalizer_condition (has_to_string (has_neg_part Type)) := sorry --non-trivial
lemma new_lemma_133287 (h2 : uniform_space (random_gen char)) : complete_space (random_gen char) := sorry --non-trivial
lemma new_lemma_133288 (h0 : functor.add_const (group pos) Type) : @group.fg.{0} pos (@functor.add_const.run.{0 1} (group.{0} pos) Type h0)  := sorry --non-trivial
lemma new_lemma_133289 (h0 : functor.add_const (function.extfun Type complete_lattice) (has_Inf linarith.comp)) : @complete_lattice.is_Sup_finite_compact.{0} environment.implicit_infer_kind (@function.extfun_app.{2 1} Type complete_lattice.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type complete_lattice.{0}) (has_Inf.{0} linarith.comp) h0) environment.implicit_infer_kind)  := sorry --non-trivial
lemma new_lemma_133290 (h0 : functor.add_const (complete_lattice (option empty)) congr_arg_kind) : @is_compactly_generated.{0} (option.{0} empty) (@functor.add_const.run.{0 0} (complete_lattice.{0} (option.{0} empty)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_133291 (h1 : not (topological_space (uniform_space string_imp) -> false)) : @totally_disconnected_space.{0} (uniform_space.{0} string_imp) (@classical.by_contradiction'.{1} (topological_space.{0} (uniform_space.{0} string_imp)) h1)  := sorry --non-trivial
lemma new_lemma_133292 (h0 : topological_space (normed_linear_ordered_group (option (option unsigned)))) : normal_space (normed_linear_ordered_group (option (option unsigned))) := sorry --non-trivial
lemma new_lemma_133293 (h0 : topological_space (with_one (has_norm (random_gen linarith.comp_source)))) : totally_separated_space (with_one (has_norm (random_gen linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_133294 (h0 : bool -> bool -> Prop) (h1 : symmetric h0) (h2 : sym2 bool) : sym2.from_rel h1 h2 := sorry --non-trivial
lemma new_lemma_133295 (h0 : group (encodable (has_nnnorm (has_nnnorm (has_nnnorm linarith.ineq))))) : is_cyclic (encodable (has_nnnorm (has_nnnorm (has_nnnorm linarith.ineq)))) := sorry --non-trivial
lemma new_lemma_133296 (h0 : measurable_space to_additive.value_type) (h1 : filter to_additive.value_type) : filter.is_measurably_generated h1 := sorry --non-trivial
lemma new_lemma_133297 (h0 : topological_space (sub_neg_monoid (has_Inf (has_add linarith.comp)))) : discrete_topology (sub_neg_monoid (has_Inf (has_add linarith.comp))) := sorry --non-trivial
lemma new_lemma_133298 (h0 : not (complete_lattice (has_add to_additive.value_type) -> false)) : @complete_lattice.is_Sup_finite_compact.{0} (has_add.{0} to_additive.value_type) (@classical.by_contradiction'.{1} (complete_lattice.{0} (has_add.{0} to_additive.value_type)) h0)  := sorry --non-trivial
lemma new_lemma_133299 (h0 : add_group (topological_space (random_gen fun_info))) : is_add_cyclic (topological_space (random_gen fun_info)) := sorry --non-trivial
lemma new_lemma_133300 (h0 : function.extfun Type topological_space) : @preirreducible_space.{0} (comm_group.{0} ennreal) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (comm_group.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_133301 (h0 : function.extfun Type topological_space) : @totally_disconnected_space.{0} (has_sub.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_sub.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_133302 (h0 : add_monoid (add_group (option congr_arg_kind))) : add_monoid.fg (add_group (option congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_133303 (h0 : group (encodable char)) : is_cyclic (encodable char) := sorry --non-trivial
lemma new_lemma_133304 (h0 : function.extfun Type (functor.comp topological_space has_zero)) : @t0_space.{0} (has_zero.{0} unsigned) (@functor.comp.run.{0 0 0} topological_space.{0} has_zero.{0} unsigned (@function.extfun_app.{2 1} Type (functor.comp.{0 0 0} topological_space.{0} has_zero.{0}) h0 unsigned))  := sorry --non-trivial
lemma new_lemma_133305 (h0 : functor.add_const (topological_space (has_nndist linarith.comp)) environment.implicit_infer_kind) : @totally_separated_space.{0} (has_nndist.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (has_nndist.{0} linarith.comp)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_133306 (h0 : function.extfun (Type 1) list) : palindrome (function.extfun_app h0 (has_Inf Type)) := sorry --non-trivial
lemma new_lemma_133307 (h1 : semiring to_additive.value_type) (h2 : ring (polynomial to_additive.value_type)) : is_domain (polynomial to_additive.value_type) := sorry --non-trivial
lemma new_lemma_133308 (h0 : topological_space (ordered_cancel_add_comm_monoid num)) : path_connected_space (ordered_cancel_add_comm_monoid num) := sorry --non-trivial
lemma new_lemma_133309 (h0 : add_group (nondiscrete_normed_field string.iterator_imp)) : is_add_cyclic (nondiscrete_normed_field string.iterator_imp) := sorry --non-trivial
lemma new_lemma_133310 (h0 : ring (has_add (ring pos))) : is_domain (has_add (ring pos)) := sorry --non-trivial
lemma new_lemma_133311 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @t1_space.{0} (add_cancel_monoid.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (add_cancel_monoid.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_133312 (h0 : topological_space (ordered_comm_ring (has_Inf name))) : normal_space (ordered_comm_ring (has_Inf name)) := sorry --non-trivial
lemma new_lemma_133313 (h0 : set (has_add linarith.comp_source)) : set.infinite h0 := sorry --non-trivial
lemma new_lemma_133314 (h0 : add_comm_monoid (has_zero pos) -> add_comm_monoid (has_zero pos) -> Prop) : is_symm (add_comm_monoid (has_zero pos)) h0 := sorry --non-trivial
lemma new_lemma_133315 (h0 : set (ring (mul_one_class linarith.ineq))) : set.finite h0 := sorry --non-trivial
lemma new_lemma_133316 (h0 : group (left_cancel_monoid congr_arg_kind)) : is_cyclic (left_cancel_monoid congr_arg_kind) := sorry --non-trivial
lemma new_lemma_133317 (h0 : semiring (has_to_string (option (option (option (option empty)))))) : is_noetherian_ring (has_to_string (option (option (option (option empty))))) := sorry --non-trivial
lemma new_lemma_133318 (h0 : ring (has_Inf (finset (has_add linarith.comp)))) : rank_condition (has_Inf (finset (has_add linarith.comp))) := sorry --non-trivial
lemma new_lemma_133319 (h0 : functor.add_const (topological_space (semigroup environment.implicit_infer_kind)) pos) : @irreducible_space.{0} (semigroup.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (semigroup.{0} environment.implicit_infer_kind)) pos h0)  := sorry --non-trivial
lemma new_lemma_133320 (h0 : not (topological_space (has_top fun_info) -> false)) : @t0_space.{0} (has_top.{0} fun_info) (@classical.by_contradiction'.{1} (topological_space.{0} (has_top.{0} fun_info)) h0)  := sorry --non-trivial
lemma new_lemma_133321 (h0 : add_group (measurable_space (random_gen fun_info))) : is_add_cyclic (measurable_space (random_gen fun_info)) := sorry --non-trivial
lemma new_lemma_133322 (h0 : function.extfun Type topological_space) : @regular_space.{0} (sub_neg_monoid.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (sub_neg_monoid.{0} name))  := sorry --non-trivial
lemma new_lemma_133323 (h0 : uniform_space (has_nnnorm (has_nnnorm (random_gen (random_gen (random_gen char)))))) : complete_space (has_nnnorm (has_nnnorm (random_gen (random_gen (random_gen char))))) := sorry --non-trivial
lemma new_lemma_133324 (h0 : complete_lattice (linear_ordered_field (has_neg_part pos))) : complete_lattice.is_Sup_finite_compact (linear_ordered_field (has_neg_part pos)) := sorry --non-trivial
lemma new_lemma_133325 (h0 : ring (linear_ordered_comm_group_with_zero std_gen)) : is_domain (linear_ordered_comm_group_with_zero std_gen) := sorry --non-trivial
lemma new_lemma_133326 (h0 : function.extfun Type topological_space) : @topological_space.separable_space.{0} (linear_ordered_comm_monoid_with_zero.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (linear_ordered_comm_monoid_with_zero.{0} num))  := sorry --non-trivial
lemma new_lemma_133327 (h0 : group (add_comm_monoid (has_add (has_add (has_add (has_add (has_add pos))))))) : is_simple_group (add_comm_monoid (has_add (has_add (has_add (has_add (has_add pos)))))) := sorry --non-trivial
lemma new_lemma_133328 (h2 : ring (uniform_space linarith.ineq)) : is_domain (uniform_space linarith.ineq) := sorry --non-trivial
lemma new_lemma_133329 (h0 : functor.add_const (function.extfun (Type 1) monoid) Type) : @monoid.fg.{1} (has_to_string.{1} Type) (@function.extfun_app.{3 2} (Type 1) monoid.{1} (@functor.add_const.run.{2 1} (function.extfun.{3 2} (Type 1) monoid.{1}) Type h0) (has_to_string.{1} Type))  := sorry --non-trivial
lemma new_lemma_133330 (h0 : ring (linear_ordered_cancel_comm_monoid empty)) : is_principal_ideal_ring (linear_ordered_cancel_comm_monoid empty) := sorry --non-trivial
lemma new_lemma_133331 (h0 : functor.add_const (topological_space (has_star congr_arg_kind)) unsigned) : @loc_path_connected_space.{0} (has_star.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (has_star.{0} congr_arg_kind)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_133332 (h0 : complete_lattice (has_append linarith.comp_source)) : complete_lattice.is_Sup_finite_compact (has_append linarith.comp_source) := sorry --non-trivial
lemma new_lemma_133333 (h0 : not (topological_space (semiring (has_norm num)) -> false)) : @discrete_topology.{0} (semiring.{0} (has_norm.{0} num)) (@classical.by_contradiction'.{1} (topological_space.{0} (semiring.{0} (has_norm.{0} num))) h0)  := sorry --non-trivial
lemma new_lemma_133334 (h0 : topological_space (has_ssubset (has_top to_additive.value_type))) : locally_compact_space (has_ssubset (has_top to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_133335 (h0 : topological_space (semigroup (has_add pos))) : loc_path_connected_space (semigroup (has_add pos)) := sorry --non-trivial
lemma new_lemma_133336 (h0 : has_lt (has_ssubset (mul_one_class (mul_one_class (mul_one_class linarith.ineq))))) : no_max_order (has_ssubset (mul_one_class (mul_one_class (mul_one_class linarith.ineq)))) := sorry --non-trivial
lemma new_lemma_133337 (h0 : list (monoid (option unsigned))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_133338 (h0 : uniform_space (non_unital_non_assoc_semiring (left_cancel_semigroup string_imp))) : complete_space (non_unital_non_assoc_semiring (left_cancel_semigroup string_imp)) := sorry --non-trivial
lemma new_lemma_133339 (h0 : functor.add_const (topological_space (comm_group unsigned)) pos) : @path_connected_space.{0} (comm_group.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (comm_group.{0} unsigned)) pos h0)  := sorry --non-trivial
lemma new_lemma_133340 (h0 : group (has_top (has_nnnorm (has_nnnorm (has_nnnorm (has_nnnorm linarith.ineq)))))) : group.fg (has_top (has_nnnorm (has_nnnorm (has_nnnorm (has_nnnorm linarith.ineq))))) := sorry --non-trivial
lemma new_lemma_133341 (h0 : function.extfun Type group) : @group.fg.{0} (has_top.{0} num) (@function.extfun_app.{2 1} Type group.{0} h0 (has_top.{0} num))  := sorry --non-trivial
lemma new_lemma_133342 (h0 : functor.add_const (finset (normed_comm_ring environment.implicit_infer_kind)) linarith.comp) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_133343 (h0 : has_lt (has_nnnorm (mul_one_class (nondiscrete_normed_field ereal)))) : no_max_order (has_nnnorm (mul_one_class (nondiscrete_normed_field ereal))) := sorry --non-trivial
lemma new_lemma_133344 (h0 : topological_space (add_cancel_monoid num)) : locally_compact_space (add_cancel_monoid num) := sorry --non-trivial
lemma new_lemma_133345 (h0 : has_mem.mem fun_info has_emptyc.emptyc) : @totally_disconnected_space.{0} fun_info (@finset.pi.empty.{1 0} Type topological_space.{0} fun_info h0)  := sorry --non-trivial
lemma new_lemma_133346 (h0 : filter (has_inv (has_norm to_additive.value_type))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_133347 (h0 : functor.add_const (function.extfun (Type 1) group) pos) : @is_simple_group.{1} Type (@function.extfun_app.{3 2} (Type 1) group.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) group.{1}) pos h0) Type)  := sorry --non-trivial
lemma new_lemma_133348 (h0 : functor.add_const (function.extfun Type ring) (has_Inf Type)) : @strong_rank_condition.{0} (ordered_comm_ring.{0} pos) (@function.extfun_app.{2 1} Type ring.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type ring.{0}) (has_Inf.{1} Type) h0) (ordered_comm_ring.{0} pos))  := sorry --non-trivial
lemma new_lemma_133349 (h0 : not (topological_space (measure_theory.measure_space empty) -> false)) : @totally_separated_space.{0} (measure_theory.measure_space.{0} empty) (@classical.by_contradiction'.{1} (topological_space.{0} (measure_theory.measure_space.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_133350 (h0 : topological_space (has_top (has_norm linarith.comp))) : totally_disconnected_space (has_top (has_norm linarith.comp)) := sorry --non-trivial
lemma new_lemma_133351 (h0 : functor.add_const (topological_space (boolean_algebra.core name)) linarith.comp) : @regular_space.{0} (boolean_algebra.core.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (boolean_algebra.core.{0} name)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_133352 (h0 : topological_space (has_Sup (option (add_group empty)))) : t0_space (has_Sup (option (add_group empty))) := sorry --non-trivial
lemma new_lemma_133353 (h0 : ultrafilter Prop) : @ultrafilter.Lim.{0} Prop sierpinski_space (@id.{1} (ultrafilter.{0} Prop) h0)  := sorry --non-trivial
lemma new_lemma_133354 (h0 : topological_space (has_add char)) : path_connected_space (has_add char) := sorry --non-trivial
lemma new_lemma_133355 (h0 : not (add_group (has_ssubset reducibility_hints) -> false)) : @is_add_cyclic.{0} (has_ssubset.{0} reducibility_hints) (@classical.by_contradiction'.{1} (add_group.{0} (has_ssubset.{0} reducibility_hints)) h0)  := sorry --non-trivial
lemma new_lemma_133356 (h0 : cancel_comm_monoid_with_zero (boolean_algebra (ring (normed_comm_ring (finset linarith.comp))))) : unique_factorization_monoid (boolean_algebra (ring (normed_comm_ring (finset linarith.comp)))) := sorry --non-trivial
lemma new_lemma_133357 (h0 : complete_lattice (has_lt (mul_one_class enat))) : complete_lattice.is_Sup_finite_compact (has_lt (mul_one_class enat)) := sorry --non-trivial
lemma new_lemma_133358 (h0 : group (boolean_algebra.core (ring Type))) : normalizer_condition (boolean_algebra.core (ring Type)) := sorry --non-trivial
lemma new_lemma_133359 (h0 : ring (add_cancel_monoid Type)) : strong_rank_condition (add_cancel_monoid Type) := sorry --non-trivial
lemma new_lemma_133360 (h0 : finset (has_zero (has_neg (has_neg linarith.comp)))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_133361 (h0 : functor.comp topological_space canonically_ordered_comm_semiring Type) : @normal_space.{1} (canonically_ordered_comm_semiring.{1} Type) (@functor.comp.run.{1 1 1} topological_space.{1} canonically_ordered_comm_semiring.{1} Type h0)  := sorry --non-trivial
lemma new_lemma_133362 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_domain.{0} (linear_ordered_add_comm_group.{0} linarith.ineq) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (linear_ordered_add_comm_group.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_133363 (h0 : functor.add_const (topological_space (comm_group Type)) Type) : @path_connected_space.{1} (comm_group.{1} Type) (@functor.add_const.run.{1 1} (topological_space.{1} (comm_group.{1} Type)) Type h0)  := sorry --non-trivial
lemma new_lemma_133364 (h0 : uniform_space (has_one linarith.comp)) : separated_space (has_one linarith.comp) := sorry --non-trivial
lemma new_lemma_133365 (h0 : uniform_space (topological_space (has_lt (random_gen char)))) : complete_space (topological_space (has_lt (random_gen char))) := sorry --non-trivial
lemma new_lemma_133366 (h0 : functor.add_const (ring (semiring congr_arg_kind)) (option empty)) : @is_domain.{0} (semiring.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (ring.{0} (semiring.{0} congr_arg_kind)) (option.{0} empty) h0)  := sorry --non-trivial
lemma new_lemma_133367 (h2 : function.extfun Type topological_space) : @totally_separated_space.{0} (complete_semilattice_Sup.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type topological_space.{0} h2 (complete_semilattice_Sup.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_133368 (h0 : functor.add_const (ordered_add_comm_monoid (boolean_algebra.core name)) environment.implicit_infer_kind) : @archimedean.{0} (boolean_algebra.core.{0} name) (@functor.add_const.run.{0 0} (ordered_add_comm_monoid.{0} (boolean_algebra.core.{0} name)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_133369 (h0 : topological_space (mul_zero_class pos)) : path_connected_space (mul_zero_class pos) := sorry --non-trivial
lemma new_lemma_133370 (h0 : group (has_norm (has_top to_additive.value_type))) : group.fg (has_norm (has_top to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_133371 (h0 : add_monoid (has_zero (has_add pos))) : add_monoid.fg (has_zero (has_add pos)) := sorry --non-trivial
lemma new_lemma_133372 (h0 : not (topological_space (plift unsigned) -> false)) : @totally_separated_space.{1} (plift.{1} unsigned) (@classical.by_contradiction'.{2} (topological_space.{1} (plift.{1} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_133373 (h0 : ring (distrib (random_gen (random_gen (random_gen char))))) : rank_condition (distrib (random_gen (random_gen (random_gen char)))) := sorry --non-trivial
lemma new_lemma_133374 (h0 : function.extfun Type finset) : finset.nonempty (function.extfun_app h0 (sub_neg_monoid real)) := sorry --non-trivial
lemma new_lemma_133375 (h0 : functor.add_const (ordered_add_comm_monoid (pseudo_metric_space empty)) congr_arg_kind) : @archimedean.{0} (pseudo_metric_space.{0} empty) (@functor.add_const.run.{0 0} (ordered_add_comm_monoid.{0} (pseudo_metric_space.{0} empty)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_133376 (h0 : filter (comm_group (has_add Type))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_133377 (h0 : functor.add_const (uniform_space (has_to_string pos)) environment.implicit_infer_kind) : @separated_space.{0} (has_to_string.{0} pos) (@functor.add_const.run.{0 0} (uniform_space.{0} (has_to_string.{0} pos)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_133378 (h0 : finset (boolean_algebra.core (ring linarith.comp))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_133379 (h0 : topological_space (comm_ring (has_compl string.iterator_imp))) : totally_disconnected_space (comm_ring (has_compl string.iterator_imp)) := sorry --non-trivial
lemma new_lemma_133380 (h0 : add_monoid (has_zero (has_add (has_neg_part (has_add Type))))) : add_monoid.fg (has_zero (has_add (has_neg_part (has_add Type)))) := sorry --non-trivial
lemma new_lemma_133381 (h0 : functor.add_const (filter auto.case_option) num) : filter.ne_bot (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_133382 (h0 : complete_lattice (semi_normed_comm_ring (has_nnnorm linarith.ineq))) : is_compactly_generated (semi_normed_comm_ring (has_nnnorm linarith.ineq)) := sorry --non-trivial
lemma new_lemma_133383 (h0 : list (measurable_space (random_gen (has_top string_imp)))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_133384 (h0 : function.extfun nat fin) : @t0_space.{0} (normed_lattice_add_comm_group.{0} real) (@matrix.vec_empty.{0} (topological_space.{0} (normed_lattice_add_comm_group.{0} real)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_133385 (h0 : fin has_zero.zero) : @complete_space.{0} (has_bot.{0} linarith.comp) (@matrix.vec_empty.{0} (uniform_space.{0} (has_bot.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_133386 (h0 : semiring (has_add real)) : is_noetherian_ring (has_add real) := sorry --non-trivial
lemma new_lemma_133387 (h3 : add_monoid reducibility_hints) (h4 : has_one reducibility_hints) : char_zero reducibility_hints := sorry --non-trivial
lemma new_lemma_133388 (h0 : group (semiring (random_gen (random_gen linarith.ineq)))) : normalizer_condition (semiring (random_gen (random_gen linarith.ineq))) := sorry --non-trivial
lemma new_lemma_133389 (h0 : semiring (has_pos_part (has_pos_part pos))) : is_noetherian_ring (has_pos_part (has_pos_part pos)) := sorry --non-trivial
lemma new_lemma_133390 (h0 : not (complete_lattice (semiring unsigned) -> false)) : @is_compactly_generated.{0} (semiring.{0} unsigned) (@classical.by_contradiction'.{1} (complete_lattice.{0} (semiring.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_133391 (h0 : function.extfun Type (functor.comp topological_space normed_comm_ring)) : @path_connected_space.{0} (normed_comm_ring.{0} pos) (@functor.comp.run.{0 0 0} topological_space.{0} normed_comm_ring.{0} pos (@function.extfun_app.{2 1} Type (functor.comp.{0 0 0} topological_space.{0} normed_comm_ring.{0}) h0 pos))  := sorry --non-trivial
lemma new_lemma_133392 (h0 : group (has_zero (finset ennreal))) : group.fg (has_zero (finset ennreal)) := sorry --non-trivial
lemma new_lemma_133393 (h0 : functor.add_const (filter (has_nndist pos)) linarith.comp) : filter.ne_bot (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_133394 (h0 : set (complete_linear_order (mul_one_class (mul_one_class linarith.ineq)))) : set.subsingleton h0 := sorry --non-trivial
lemma new_lemma_133395 (h0 : cancel_comm_monoid_with_zero (ordered_comm_group (option (option empty)))) : unique_factorization_monoid (ordered_comm_group (option (option empty))) := sorry --non-trivial
lemma new_lemma_133396 (h0 : topological_space (mul_zero_class (finset environment.implicit_infer_kind))) : t0_space (mul_zero_class (finset environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_133397 (h0 : functor.add_const (topological_space (has_pos_part real)) (sub_neg_monoid (sub_neg_monoid pos))) : @t1_space.{0} (has_pos_part.{0} real) (@functor.add_const.run.{0 0} (topological_space.{0} (has_pos_part.{0} real)) (sub_neg_monoid.{0} (sub_neg_monoid.{0} pos)) h0)  := sorry --non-trivial
lemma new_lemma_133398 (h0 : semiring (has_nndist (finset (has_add name)))) : is_noetherian_ring (has_nndist (finset (has_add name))) := sorry --non-trivial
lemma new_lemma_133399 (h0 : denumerable char -> denumerable char -> bool) : is_dec_refl h0 := sorry --non-trivial
lemma new_lemma_133400 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @normalizer_condition.{0} (linear_ordered_add_comm_group.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (linear_ordered_add_comm_group.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_133401 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @loc_path_connected_space.{0} (has_inter.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_inter.{0} pos))  := sorry --non-trivial
lemma new_lemma_133402 (h0 : functor.add_const (finset (has_add pos)) (has_Inf (has_Inf pos))) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_133403 (h0 : functor.add_const (semiring Type) pos) : @is_noetherian_ring.{1} Type (@functor.add_const.run.{1 0} (semiring.{1} Type) pos h0)  := sorry --non-trivial
lemma new_lemma_133404 (h0 : monoid (with_one (random_gen (random_gen to_additive.value_type)))) : monoid.fg (with_one (random_gen (random_gen to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_133405 (h0 : has_add (linear_ordered_comm_group ennreal) -> has_add (linear_ordered_comm_group ennreal) -> Prop) : reflexive h0 := sorry --non-trivial
lemma new_lemma_133406 (h0 : function.extfun Type uniform_space) : @separated_space.{0} (finset.{0} linarith.comp) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (finset.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_133407 (h0 : functor.add_const (group (ring linarith.comp)) linarith.comp) : @is_cyclic.{0} (ring.{0} linarith.comp) (@functor.add_const.run.{0 0} (group.{0} (ring.{0} linarith.comp)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_133408 (h2 : ring char) : is_domain char := sorry --non-trivial
lemma new_lemma_133409 (h0 : topological_space (monoid_with_zero pos)) : locally_compact_space (monoid_with_zero pos) := sorry --non-trivial
lemma new_lemma_133410 (h0 : has_lt (has_div (mul_one_class (mul_one_class (mul_one_class to_additive.value_type))))) : no_max_order (has_div (mul_one_class (mul_one_class (mul_one_class to_additive.value_type)))) := sorry --non-trivial
lemma new_lemma_133411 (h0 : not (group (linear_ordered_add_comm_group linarith.comp_source) -> false)) : @is_cyclic.{0} (linear_ordered_add_comm_group.{0} linarith.comp_source) (@classical.by_contradiction'.{1} (group.{0} (linear_ordered_add_comm_group.{0} linarith.comp_source)) h0)  := sorry --non-trivial
lemma new_lemma_133412 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_principal_ideal_ring.{0} (has_to_string.{0} ennreal) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (has_to_string.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_133413 (h0 : function.extfun Type complete_lattice) : is_atomistic (measurable_space linarith.comp_source) := sorry --non-trivial
lemma new_lemma_133414 (h0 : functor.add_const (topological_space (comm_group environment.implicit_infer_kind)) name) : @regular_space.{0} (comm_group.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (comm_group.{0} environment.implicit_infer_kind)) name h0)  := sorry --non-trivial
lemma new_lemma_133415 (h0 : functor.add_const (topological_space (boolean_algebra.core Type)) Type) : @t1_space.{1} (boolean_algebra.core.{1} Type) (@functor.add_const.run.{1 1} (topological_space.{1} (boolean_algebra.core.{1} Type)) Type h0)  := sorry --non-trivial
lemma new_lemma_133416 (h0 : uniform_space (has_pos_part (has_neg pos))) : separated_space (has_pos_part (has_neg pos)) := sorry --non-trivial
lemma new_lemma_133417 (h0 : cancel_comm_monoid_with_zero (comm_group (has_to_string ennreal))) : unique_factorization_monoid (comm_group (has_to_string ennreal)) := sorry --non-trivial
lemma new_lemma_133418 (h0 : function.extfun Type filter) : filter.ne_bot (function.extfun_app h0 (comm_group pos)) := sorry --non-trivial
lemma new_lemma_133419 (h0 : not (add_group (has_one congr_arg_kind) -> false)) : @is_add_cyclic.{0} (has_one.{0} congr_arg_kind) (@classical.by_contradiction'.{1} (add_group.{0} (has_one.{0} congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_133420 (h0 : function.extfun (Type 1) topological_space) : @preconnected_space.{1} (normed_comm_ring.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} h0 (normed_comm_ring.{1} Type))  := sorry --non-trivial
lemma new_lemma_133421 (h0 : finset (normed_comm_ring (has_add environment.implicit_infer_kind))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_133422 (h0 : group (boolean_algebra.core (has_add (has_neg_part name)))) : normalizer_condition (boolean_algebra.core (has_add (has_neg_part name))) := sorry --non-trivial
lemma new_lemma_133423 (h0 : functor.add_const (topological_space (boolean_algebra.core name)) name) : @sequential_space.{0} (boolean_algebra.core.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (boolean_algebra.core.{0} name)) name h0)  := sorry --non-trivial
lemma new_lemma_133424 (h0 : function.extfun ((Type -> Type) -> Type 1) (function.extfun (Type -> Type))) : @is_atomistic.{0} (with_one.{0} linarith.ineq) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) (@function.extfun_app.{3 2} ((Type → Type) → Type 1) (function.extfun.{2 2} (Type → Type)) h0 (function.extfun.{2 1} Type)) complete_lattice.{0}) (with_one.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_133425 (h0 : not (list (topological_space string_imp) -> false)) : list.nodup (classical.by_contradiction' h0) := sorry --non-trivial
lemma new_lemma_133426 (h3 : topological_space (denumerable (random_gen (has_ssubset (has_ssubset fun_info))))) : path_connected_space (denumerable (random_gen (has_ssubset (has_ssubset fun_info)))) := sorry --non-trivial
lemma new_lemma_133427 (h0 : functor.add_const (add_group (linear_ordered_comm_monoid_with_zero empty)) empty) : @is_add_cyclic.{0} (linear_ordered_comm_monoid_with_zero.{0} empty) (@functor.add_const.run.{0 0} (add_group.{0} (linear_ordered_comm_monoid_with_zero.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_133428 (h0 : set (set linarith.ineq)) (h1 : set linarith.ineq) : measurable_space.generate_measurable h0 h1 := sorry --non-trivial
lemma new_lemma_133429 (h0 : complete_lattice (has_add (has_pos_part real))) : is_atomistic (has_add (has_pos_part real)) := sorry --non-trivial
lemma new_lemma_133430 (h0 : ring (has_pos_part (has_Inf (has_Inf pos)))) : strong_rank_condition (has_pos_part (has_Inf (has_Inf pos))) := sorry --non-trivial
lemma new_lemma_133431 (h0 : uniform_space (add_group_with_zero_nhd ereal)) : complete_space (add_group_with_zero_nhd ereal) := sorry --non-trivial
lemma new_lemma_133432 (h0 : topological_space (finset (has_neg_part Type))) : regular_space (finset (has_neg_part Type)) := sorry --non-trivial
lemma new_lemma_133433 (h0 : functor.add_const (complete_lattice (complete_distrib_lattice unsigned)) Type) : @is_compactly_generated.{0} (complete_distrib_lattice.{0} unsigned) (@functor.add_const.run.{0 1} (complete_lattice.{0} (complete_distrib_lattice.{0} unsigned)) Type h0)  := sorry --non-trivial
lemma new_lemma_133434 (h0 : not (cancel_comm_monoid_with_zero (has_sub linarith.comp) -> false)) : @unique_factorization_monoid.{0} (has_sub.{0} linarith.comp) (@classical.by_contradiction'.{1} (cancel_comm_monoid_with_zero.{0} (has_sub.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_133435 (h0 : list (has_top (random_gen linarith.comp_source))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_133436 (h0 : functor.add_const (topological_space (normed_comm_ring name)) name) : @preconnected_space.{0} (normed_comm_ring.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (normed_comm_ring.{0} name)) name h0)  := sorry --non-trivial
lemma new_lemma_133437 (h0 : complete_lattice (has_add (comm_semigroup linarith.comp))) : is_compactly_generated (has_add (comm_semigroup linarith.comp)) := sorry --non-trivial
lemma new_lemma_133438 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @normal_space.{0} (left_cancel_monoid.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (left_cancel_monoid.{0} empty))  := sorry --non-trivial
lemma new_lemma_133439 (h0 : uniform_space (complete_distrib_lattice unsigned)) : complete_space (complete_distrib_lattice unsigned) := sorry --non-trivial
lemma new_lemma_133440 (h0 : functor.add_const (function.extfun (Type 1) group) linarith.comp) : @group.fg.{1} (has_neg.{1} Type) (@function.extfun_app.{3 2} (Type 1) group.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) group.{1}) linarith.comp h0) (has_neg.{1} Type))  := sorry --non-trivial
lemma new_lemma_133441 (h0 : topological_space (has_to_string (has_nndist (ring (has_neg Type))))) : normal_space (has_to_string (has_nndist (ring (has_neg Type)))) := sorry --non-trivial
lemma new_lemma_133442 (h0 : finset (ring environment.implicit_infer_kind)) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_133443 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_noetherian_ring.{0} (finset.{0} pos) (@function.extfun_app.{2 1} Type semiring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 semiring.{0}) (finset.{0} pos))  := sorry --non-trivial
lemma new_lemma_133444 (h0 : filter (has_to_string (has_neg environment.implicit_infer_kind))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_133445 (h0 : functor.add_const (group (cancel_monoid environment.implicit_infer_kind)) name) : @normalizer_condition.{0} (cancel_monoid.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (group.{0} (cancel_monoid.{0} environment.implicit_infer_kind)) name h0)  := sorry --non-trivial
lemma new_lemma_133446 (h0 : complete_lattice (left_cancel_semigroup congr_arg_kind)) : complete_lattice.is_Sup_finite_compact (left_cancel_semigroup congr_arg_kind) := sorry --non-trivial
lemma new_lemma_133447 (h0 : topological_space (boolean_algebra (has_bot name))) : preconnected_space (boolean_algebra (has_bot name)) := sorry --non-trivial
lemma new_lemma_133448 (h0 : not (complete_lattice (semiring unsigned) -> false)) : @is_atomistic.{0} (semiring.{0} unsigned) (@classical.by_contradiction'.{1} (complete_lattice.{0} (semiring.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_133449 (h0 : functor.add_const (topological_space (comm_group Type)) environment.implicit_infer_kind) : @path_connected_space.{1} (comm_group.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (comm_group.{1} Type)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_133450 (h0 : not (measurable_space (div_inv_monoid linarith.comp_source) -> false)) (h1 : has_sup (div_inv_monoid linarith.comp_source)) : @has_measurable_sup.{0} (div_inv_monoid.{0} linarith.comp_source) (@classical.by_contradiction'.{1} (measurable_space.{0} (div_inv_monoid.{0} linarith.comp_source)) h0) h1  := sorry --non-trivial
lemma new_lemma_133451 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @monoid.fg.{0} (finset.{0} linarith.comp) (@function.extfun_app.{2 1} Type monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 monoid.{0}) (finset.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_133452 (h0 : fin has_zero.zero) : @loc_path_connected_space.{1} (has_Inf.{1} Type) (@matrix.vec_empty.{1} (topological_space.{1} (has_Inf.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_133453 (h0 : topological_space (has_bot (has_add (has_bot (has_bot name))))) : path_connected_space (has_bot (has_add (has_bot (has_bot name)))) := sorry --non-trivial
lemma new_lemma_133454 (h0 : function.extfun Type topological_space) : @locally_compact_space.{0} znum (@function.extfun_app.{2 1} Type topological_space.{0} h0 znum)  := sorry --non-trivial
lemma new_lemma_133455 (h0 : function.extfun Type (functor.comp topological_space complete_distrib_lattice)) : @irreducible_space.{0} (complete_distrib_lattice.{0} ennreal) (@functor.comp.run.{0 0 0} topological_space.{0} complete_distrib_lattice.{0} ennreal (@function.extfun_app.{2 1} Type (functor.comp.{0 0 0} topological_space.{0} complete_distrib_lattice.{0}) h0 ennreal))  := sorry --non-trivial
lemma new_lemma_133456 (h0 : fin has_zero.zero) : @separated_space.{1} (comm_semigroup.{1} Type) (@matrix.vec_empty.{1} (uniform_space.{1} (comm_semigroup.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_133457 (h0 : ring (add_cancel_monoid Type)) : is_principal_ideal_ring (add_cancel_monoid Type) := sorry --non-trivial
lemma new_lemma_133458 (h0 : functor.add_const (topological_space (mul_zero_class unsigned)) pos) : @preirreducible_space.{0} (mul_zero_class.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (mul_zero_class.{0} unsigned)) pos h0)  := sorry --non-trivial
lemma new_lemma_133459 (h0 : functor.add_const Prop (normed_comm_ring linarith.comp)) : functor.add_const.run h0 := sorry --non-trivial
lemma new_lemma_133460 (h0 : topological_space (semigroup (option ennreal))) : t0_space (semigroup (option ennreal)) := sorry --non-trivial
lemma new_lemma_133461 (h1 : has_lt (add_comm_semigroup fun_info)) : no_max_order (add_comm_semigroup fun_info) := sorry --non-trivial
lemma new_lemma_133462 (h0 : functor.add_const (function.extfun Type group) Type) : @is_cyclic.{0} (complete_distrib_lattice.{0} pos) (@function.extfun_app.{2 1} Type group.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type group.{0}) Type h0) (complete_distrib_lattice.{0} pos))  := sorry --non-trivial
lemma new_lemma_133463 (h1 : filter (distrib_lattice string_imp)) : filter.ne_bot h1 := sorry --non-trivial
lemma new_lemma_133464 (h0 : complete_lattice (has_emptyc (has_top (has_top to_additive.value_type)))) : complete_lattice.is_Sup_finite_compact (has_emptyc (has_top (has_top to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_133465 (h0 : monoid (partial_order (semiring (semiring empty)))) : monoid.fg (partial_order (semiring (semiring empty))) := sorry --non-trivial
lemma new_lemma_133466 (h0 : ring (distrib (has_nnnorm linarith.comp_source))) : is_domain (distrib (has_nnnorm linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_133467 (h0 : list (has_ssubset (random_gen (has_ssubset (has_top fun_info))))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_133468 (h0 : topological_space (ordered_comm_monoid (has_bot (has_bot real)))) : sequential_space (ordered_comm_monoid (has_bot (has_bot real))) := sorry --non-trivial
lemma new_lemma_133469 (h0 : topological_space (has_nndist (add_comm_monoid name))) : totally_disconnected_space (has_nndist (add_comm_monoid name)) := sorry --non-trivial
lemma new_lemma_133470 (h0 : fin has_zero.zero) : @loc_path_connected_space.{0} (canonically_ordered_monoid.{0} pos) (@matrix.vec_empty.{0} (topological_space.{0} (canonically_ordered_monoid.{0} pos)) h0)  := sorry --non-trivial
lemma new_lemma_133471 (h0 : topological_space (has_Inf (finset Type))) : regular_space (has_Inf (finset Type)) := sorry --non-trivial
lemma new_lemma_133472 (h0 : group (complete_distrib_lattice (has_add real))) : is_simple_group (complete_distrib_lattice (has_add real)) := sorry --non-trivial
lemma new_lemma_133473 (h0 : functor.add_const (topological_space (has_to_string pos)) (has_nndist (ring (has_to_string Type)))) : @t0_space.{0} (has_to_string.{0} pos) (@functor.add_const.run.{0 1} (topological_space.{0} (has_to_string.{0} pos)) (has_nndist.{1} (ring.{1} (has_to_string.{1} Type))) h0)  := sorry --non-trivial
lemma new_lemma_133474 (h0 : ring (boolean_algebra (has_Inf pos))) : is_principal_ideal_ring (boolean_algebra (has_Inf pos)) := sorry --non-trivial
lemma new_lemma_133475 (h0 : functor.add_const (ordered_comm_monoid (add_comm_monoid linarith.comp)) Type) : @has_exists_mul_of_le.{0} (add_comm_monoid.{0} linarith.comp) (@functor.add_const.run.{0 1} (ordered_comm_monoid.{0} (add_comm_monoid.{0} linarith.comp)) Type h0)  := sorry --non-trivial
lemma new_lemma_133476 (h0 : functor.add_const (function.extfun Type complete_lattice) Type) : @is_atomistic.{0} (has_zero.{0} linarith.comp) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type complete_lattice.{0}) Type h0) (has_zero.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_133477 (h0 : topological_space (distrib_lattice (distrib_lattice (with_bot (random_gen linarith.comp))))) : irreducible_space (distrib_lattice (distrib_lattice (with_bot (random_gen linarith.comp)))) := sorry --non-trivial
lemma new_lemma_133478 (h1 : uniform_space (has_add to_additive.value_type)) : complete_space (has_add to_additive.value_type) := sorry --non-trivial
lemma new_lemma_133479 (h0 : function.extfun Type group) : @is_cyclic.{0} (denumerable.{0} fun_info) (@function.extfun_app.{2 1} Type group.{0} h0 (denumerable.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_133480 (h0 : not (topological_space reducibility_hints -> false)) : @totally_disconnected_space.{0} reducibility_hints (@classical.by_contradiction'.{1} (topological_space.{0} reducibility_hints) h0)  := sorry --non-trivial
lemma new_lemma_133481 (h0 : group (comm_semigroup pos)) : normalizer_condition (comm_semigroup pos) := sorry --non-trivial
lemma new_lemma_133482 (h0 : complete_lattice (semi_normed_comm_ring (mul_one_class fun_info))) : complete_lattice.is_Sup_finite_compact (semi_normed_comm_ring (mul_one_class fun_info)) := sorry --non-trivial
lemma new_lemma_133483 (h0 : ring (add_cancel_monoid environment.implicit_infer_kind)) : is_principal_ideal_ring (add_cancel_monoid environment.implicit_infer_kind) := sorry --non-trivial
lemma new_lemma_133484 (h0 : ring (option pos)) : strong_rank_condition (option pos) := sorry --non-trivial
lemma new_lemma_133485 (h0 : functor.add_const (topological_space (has_nndist ennreal)) ennreal) : @path_connected_space.{0} (has_nndist.{0} ennreal) (@functor.add_const.run.{0 0} (topological_space.{0} (has_nndist.{0} ennreal)) ennreal h0)  := sorry --non-trivial
lemma new_lemma_133486 (h0 : not (function.extfun Type group -> false)) : @is_cyclic.{0} (@id.{2} Type unsigned) (@function.extfun_app.{2 1} Type group.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type group.{0}) h0) (@id.{2} Type unsigned))  := sorry --non-trivial
lemma new_lemma_133487 (h0 : fin has_zero.zero) : @t1_space.{1} (boolean_algebra.{1} Type) (@matrix.vec_empty.{1} (topological_space.{1} (boolean_algebra.{1} Type)) (@matrix.vec_empty.{0} (fin (@has_zero.zero.{0} nat nat.has_zero)) (@matrix.vec_empty.{0} (fin (@has_zero.zero.{0} nat nat.has_zero)) (@matrix.vec_empty.{0} (fin (@has_zero.zero.{0} nat nat.has_zero)) h0))))  := sorry --non-trivial
lemma new_lemma_133488 (h0 : topological_space (has_le (mul_one_class string.iterator_imp))) (h1 : preorder (has_le (mul_one_class string.iterator_imp))) : order_closed_topology (has_le (mul_one_class string.iterator_imp)) := sorry --non-trivial
lemma new_lemma_133489 (h0 : function.extfun Type ring) : @is_domain.{0} (with_bot.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type ring.{0} h0 (with_bot.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_133490 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @monoid.fg.{0} (finset.{0} unsigned) (@function.extfun_app.{2 1} Type monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 monoid.{0}) (finset.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_133491 (h0 : functor.add_const (function.extfun Type topological_space) linarith.comp) : @t0_space.{0} (has_zero.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) linarith.comp h0) (has_zero.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_133492 (h0 : topological_space (option (semiring unsigned))) : t0_space (option (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_133493 (h0 : topological_space (comm_semigroup (has_pos_part real))) : regular_space (comm_semigroup (has_pos_part real)) := sorry --non-trivial
lemma new_lemma_133494 (h0 : functor.comp list comm_group Type) : palindrome (functor.comp.run h0) := sorry --non-trivial
lemma new_lemma_133495 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @normalizer_condition.{0} (has_inter.{0} unsigned) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (has_inter.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_133496 (h0 : has_mem.mem (semiring congr_arg_kind) has_emptyc.emptyc) : @is_domain.{0} (semiring.{0} congr_arg_kind) (@finset.pi.empty.{1 0} Type ring.{0} (semiring.{0} congr_arg_kind) h0)  := sorry --non-trivial
lemma new_lemma_133497 (h0 : function.extfun Type (functor.add_const (cancel_comm_monoid_with_zero znum))) : @unique_factorization_monoid.{0} znum (@functor.add_const.run.{0 0} (cancel_comm_monoid_with_zero.{0} znum) ennreal (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (cancel_comm_monoid_with_zero.{0} znum)) h0 ennreal))  := sorry --non-trivial
lemma new_lemma_133498 (h0 : functor.add_const (topological_space (ring name)) Type) : @normal_space.{0} (ring.{0} name) (@functor.add_const.run.{0 1} (topological_space.{0} (ring.{0} name)) Type h0)  := sorry --non-trivial
lemma new_lemma_133499 (h0 : functor.comp group has_to_string linarith.comp) : @is_simple_group.{0} (has_to_string.{0} linarith.comp) (@functor.comp.run.{0 0 0} group.{0} has_to_string.{0} linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_133500 (h0 : ring (comm_group unsigned)) : is_principal_ideal_ring (comm_group unsigned) := sorry --non-trivial
lemma new_lemma_133501 (h0 : filter (complete_linear_order unsigned)) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_133502 (h0 : functor.add_const (monoid (normed_ring unsigned)) congr_arg_kind) : @monoid.fg.{0} (normed_ring.{0} unsigned) (@functor.add_const.run.{0 0} (monoid.{0} (normed_ring.{0} unsigned)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_133503 (h0 : function.extfun Type topological_space) : @discrete_topology.{0} congr_arg_kind (@function.extfun_app.{2 1} Type topological_space.{0} h0 congr_arg_kind)  := sorry --non-trivial
lemma new_lemma_133504 (h0 : list (has_inter congr_arg_kind)) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_133505 (h0 : uniform_space (has_ssubset (has_nnnorm string_imp))) : complete_space (has_ssubset (has_nnnorm string_imp)) := sorry --non-trivial
lemma new_lemma_133506 (h0 : function.extfun Type uniform_space) : @complete_space.{0} (left_cancel_monoid.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (left_cancel_monoid.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_133507 (h0 : functor.add_const (group (semigroup ennreal)) name) : @normalizer_condition.{0} (semigroup.{0} ennreal) (@functor.add_const.run.{0 0} (group.{0} (semigroup.{0} ennreal)) name h0)  := sorry --non-trivial
lemma new_lemma_133508 (h0 : functor.add_const (topological_space (canonically_ordered_monoid linarith.comp)) linarith.comp) : @t0_space.{0} (canonically_ordered_monoid.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (canonically_ordered_monoid.{0} linarith.comp)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_133509 (h0 : topological_space (semigroup (has_pos_part (has_pos_part Type)))) : t0_space (semigroup (has_pos_part (has_pos_part Type))) := sorry --non-trivial
lemma new_lemma_133510 (h0 : functor.add_const (topological_space (boolean_algebra.core Type)) linarith.comp) : @topological_space.separable_space.{1} (boolean_algebra.core.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (boolean_algebra.core.{1} Type)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_133511 (h0 : functor.add_const (function.extfun Type topological_space) (has_Inf linarith.comp)) : @irreducible_space.{0} (has_add.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) (has_Inf.{0} linarith.comp) h0) (has_add.{0} name))  := sorry --non-trivial
lemma new_lemma_133512 (h0 : semiring fun_info) (h1 : polynomial fun_info) : polynomial.monic h1 := sorry --non-trivial
lemma new_lemma_133513 (h0 : topological_space (ring (ring name))) : totally_separated_space (ring (ring name)) := sorry --non-trivial
lemma new_lemma_133514 (h0 : topological_space (normed_comm_ring (has_add unsigned))) : loc_path_connected_space (normed_comm_ring (has_add unsigned)) := sorry --non-trivial
lemma new_lemma_133515 (h0 : ordered_comm_monoid (canonically_ordered_monoid pos)) : has_exists_mul_of_le (canonically_ordered_monoid pos) := sorry --non-trivial
lemma new_lemma_133516 (h0 : ordered_add_comm_monoid (comm_semigroup (sub_neg_monoid (sub_neg_monoid (has_add real))))) : archimedean (comm_semigroup (sub_neg_monoid (sub_neg_monoid (has_add real)))) := sorry --non-trivial
lemma new_lemma_133517 (h1 : add_group (distrib_lattice (fintype linarith.comp_source))) : is_add_cyclic (distrib_lattice (fintype linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_133518 (h0 : functor.add_const (group (boolean_algebra.core Type)) name) : @normalizer_condition.{1} (boolean_algebra.core.{1} Type) (@functor.add_const.run.{1 0} (group.{1} (boolean_algebra.core.{1} Type)) name h0)  := sorry --non-trivial
lemma new_lemma_133519 (h1 : random_gen (random_gen (with_bot to_additive.value_type)) -> Prop) : Exists h1 := sorry --non-trivial
lemma new_lemma_133520 (h0 : semiring (add_right_cancel_monoid (semiring (semiring empty)))) : is_noetherian_ring (add_right_cancel_monoid (semiring (semiring empty))) := sorry --non-trivial
lemma new_lemma_133521 (h0 : monoid (has_neg (has_add (has_neg (finset (has_nndist (has_pos_part pos))))))) : monoid.fg (has_neg (has_add (has_neg (finset (has_nndist (has_pos_part pos)))))) := sorry --non-trivial
lemma new_lemma_133522 (h0 : topological_space (has_nndist (option unsigned))) : totally_separated_space (has_nndist (option unsigned)) := sorry --non-trivial
lemma new_lemma_133523 (h0 : uniform_space (measurable_space.dynkin_system (semiring congr_arg_kind))) : complete_space (measurable_space.dynkin_system (semiring congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_133524 (h1 : not (uniform_space (random_gen (random_gen (semi_normed_comm_ring string_imp))) -> false)) : @complete_space.{0} (random_gen.{0} (random_gen.{0} (semi_normed_comm_ring.{0} string_imp))) (@classical.by_contradiction'.{1} (uniform_space.{0} (random_gen.{0} (random_gen.{0} (semi_normed_comm_ring.{0} string_imp)))) h1)  := sorry --non-trivial
lemma new_lemma_133525 (h0 : functor.add_const (ordered_add_comm_monoid (add_cancel_monoid empty)) empty) : @archimedean.{0} (add_cancel_monoid.{0} empty) (@functor.add_const.run.{0 0} (ordered_add_comm_monoid.{0} (add_cancel_monoid.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_133526 (h0 : monoid (complete_semilattice_Sup (has_top (has_inv linarith.comp_source)))) : monoid.fg (complete_semilattice_Sup (has_top (has_inv linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_133527 (h0 : not (group (left_cancel_semigroup congr_arg_kind) -> false)) : @group.fg.{0} (left_cancel_semigroup.{0} congr_arg_kind) (@classical.by_contradiction'.{1} (group.{0} (left_cancel_semigroup.{0} congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_133528 (h0 : functor.add_const (semiring (finset pos)) name) : @is_noetherian_ring.{0} (finset.{0} pos) (@functor.add_const.run.{0 0} (semiring.{0} (finset.{0} pos)) name h0)  := sorry --non-trivial
lemma new_lemma_133529 (h0 : monoid (id (semiring (semiring congr_arg_kind)))) : monoid.fg (id (semiring (semiring congr_arg_kind))) := sorry --non-trivial
lemma new_lemma_133530 (h0 : function.extfun Type topological_space) : @t0_space.{0} (normed_comm_ring.{0} ennreal) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (normed_comm_ring.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_133531 (h0 : function.extfun Type ring) : @rank_condition.{0} (random_gen.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type ring.{0} h0 (random_gen.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_133532 (h0 : fun_info -> fun_info) (h1 : fun_info) : function.is_fixed_pt h0 h1 := sorry --non-trivial
lemma new_lemma_133533 (h0 : functor.add_const (add_monoid (ring Type)) (has_neg linarith.comp)) : @add_monoid.fg.{1} (ring.{1} Type) (@functor.add_const.run.{1 0} (add_monoid.{1} (ring.{1} Type)) (has_neg.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_133534 (h0 : add_monoid num) : add_monoid.fg num := sorry --non-trivial
lemma new_lemma_133535 (h0 : function.extfun Type (functor.comp topological_space has_to_string)) : @regular_space.{0} (has_to_string.{0} name) (@functor.comp.run.{0 0 0} topological_space.{0} has_to_string.{0} name (@function.extfun_app.{2 1} Type (functor.comp.{0 0 0} topological_space.{0} has_to_string.{0}) h0 name))  := sorry --non-trivial
lemma new_lemma_133536 (h0 : group (has_star num)) : is_cyclic (has_star num) := sorry --non-trivial
lemma new_lemma_133537 (h0 : uniform_space (distrib (has_nnnorm (has_nnnorm (has_nnnorm (has_nnnorm reducibility_hints)))))) : complete_space (distrib (has_nnnorm (has_nnnorm (has_nnnorm (has_nnnorm reducibility_hints))))) := sorry --non-trivial
lemma new_lemma_133538 (h0 : function.extfun Type add_monoid) : @add_monoid.fg.{0} (canonically_ordered_comm_semiring.{0} ennreal) (@function.extfun_app.{2 1} Type add_monoid.{0} h0 (canonically_ordered_comm_semiring.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_133539 (h0 : function.extfun Type group) : @is_cyclic.{0} (semi_normed_comm_ring.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type group.{0} h0 (semi_normed_comm_ring.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_133540 (h0 : list (ordered_comm_ring (has_add (has_add real)))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_133541 (h0 : functor.add_const (group (cancel_monoid ennreal)) name) : @group.fg.{0} (cancel_monoid.{0} ennreal) (@functor.add_const.run.{0 0} (group.{0} (cancel_monoid.{0} ennreal)) name h0)  := sorry --non-trivial
lemma new_lemma_133542 (h0 : semiring (plift (semiring congr_arg_kind))) : is_noetherian_ring (plift (semiring congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_133543 (h0 : topological_space (comm_ring (has_nnnorm linarith.ineq))) : totally_disconnected_space (comm_ring (has_nnnorm linarith.ineq)) := sorry --non-trivial
lemma new_lemma_133544 (h0 : ordered_comm_monoid (finset Type)) : has_exists_mul_of_le (finset Type) := sorry --non-trivial
lemma new_lemma_133545 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @is_simple_group.{1} (ring.{1} Type) (@function.extfun_app.{3 2} (Type 1) group.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 group.{1}) (ring.{1} Type))  := sorry --non-trivial
lemma new_lemma_133546 (h0 : topological_space (normed_group (semiring (semiring linarith.comp)))) : discrete_topology (normed_group (semiring (semiring linarith.comp))) := sorry --non-trivial
lemma new_lemma_133547 (h0 : topological_space (ring (ring (mul_one_class linarith.comp)))) : preirreducible_space (ring (ring (mul_one_class linarith.comp))) := sorry --non-trivial
lemma new_lemma_133548 (h0 : filter (fintype string_imp)) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_133549 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_cyclic.{0} (denumerable.{0} fun_info) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (denumerable.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_133550 (h0 : group (add_cancel_monoid (complete_semilattice_Sup pos))) : is_simple_group (add_cancel_monoid (complete_semilattice_Sup pos)) := sorry --non-trivial
lemma new_lemma_133551 (h0 : functor.add_const (topological_space (finset environment.implicit_infer_kind)) (has_to_string pos)) : @irreducible_space.{0} (finset.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (finset.{0} environment.implicit_infer_kind)) (has_to_string.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_133552 (h0 : ordered_add_comm_monoid (comm_semigroup (sub_neg_monoid real))) : archimedean (comm_semigroup (sub_neg_monoid real)) := sorry --non-trivial
lemma new_lemma_133553 (h0 : function.extfun Type semiring) : @is_noetherian_ring.{0} (uniform_space.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type semiring.{0} h0 (uniform_space.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_133554 (h0 : topological_space (has_nnnorm (has_ssubset to_additive.value_type))) : t0_space (has_nnnorm (has_ssubset to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_133555 (h0 : topological_space (has_emptyc (random_gen fun_info))) : discrete_topology (has_emptyc (random_gen fun_info)) := sorry --non-trivial
lemma new_lemma_133556 (h0 h1 : multiset (has_div linarith.ineq)) : multiset.disjoint h0 h1 := sorry --non-trivial
lemma new_lemma_133557 (h0 : functor.add_const (function.extfun (Type 1) ordered_add_comm_monoid) (has_to_string pos)) : @archimedean.{1} (comm_group.{1} Type) (@function.extfun_app.{3 2} (Type 1) ordered_add_comm_monoid.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) ordered_add_comm_monoid.{1}) (has_to_string.{0} pos) h0) (comm_group.{1} Type))  := sorry --non-trivial
lemma new_lemma_133558 (h0 : not (function.extfun Type add_group -> false)) : @is_add_cyclic.{0} (random_gen.{0} empty) (@function.extfun_app.{2 1} Type add_group.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type add_group.{0}) h0) (random_gen.{0} empty))  := sorry --non-trivial
lemma new_lemma_133559 (h0 : function.extfun Type ordered_add_comm_monoid) : @archimedean.{0} (has_edist.{0} empty) (@function.extfun_app.{2 1} Type ordered_add_comm_monoid.{0} h0 (has_edist.{0} empty))  := sorry --non-trivial
lemma new_lemma_133560 (h0 : function.extfun Type topological_space) : @totally_disconnected_space.{0} (pseudo_metric_space.{0} ennreal) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (pseudo_metric_space.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_133561 (h0 : topological_space (ordered_comm_monoid (has_add (has_Inf (ordered_comm_monoid real))))) : locally_compact_space (ordered_comm_monoid (has_add (has_Inf (ordered_comm_monoid real)))) := sorry --non-trivial
lemma new_lemma_133562 (h6 : topological_space (uniform_space to_additive.value_type)) : totally_disconnected_space (uniform_space to_additive.value_type) := sorry --non-trivial
lemma new_lemma_133563 (h0 : topological_space (has_compl ereal)) : path_connected_space (has_compl ereal) := sorry --non-trivial
lemma new_lemma_133564 (h0 : function.extfun Type topological_space) : @locally_compact_space.{0} (has_inv.{0} char) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_inv.{0} char))  := sorry --non-trivial
lemma new_lemma_133565 (h0 : add_group (has_zero (has_neg_part (boolean_algebra Type)))) : is_add_cyclic (has_zero (has_neg_part (boolean_algebra Type))) := sorry --non-trivial
lemma new_lemma_133566 (h0 : not (filter (denumerable to_additive.value_type) -> false)) : filter.ne_bot (classical.by_contradiction' h0) := sorry --non-trivial
lemma new_lemma_133567 (h0 : group (normed_comm_ring (comm_group name))) : is_simple_group (normed_comm_ring (comm_group name)) := sorry --non-trivial
lemma new_lemma_133568 (h0 : uniform_space (has_emptyc (has_sub num))) : separated_space (has_emptyc (has_sub num)) := sorry --non-trivial
lemma new_lemma_133569 (h0 : add_monoid (add_cancel_comm_monoid (option (option empty)))) : add_monoid.fg (add_cancel_comm_monoid (option (option empty))) := sorry --non-trivial
lemma new_lemma_133570 (h0 : topological_space (generalized_boolean_algebra (ring (has_neg (ring Type))))) : t1_space (generalized_boolean_algebra (ring (has_neg (ring Type)))) := sorry --non-trivial
lemma new_lemma_133571 (h0 : complete_lattice (add_comm_monoid (comm_group pos))) : complete_lattice.is_Sup_finite_compact (add_comm_monoid (comm_group pos)) := sorry --non-trivial
lemma new_lemma_133572 (h0 : functor.add_const (group (ring linarith.comp)) name) : @normalizer_condition.{0} (ring.{0} linarith.comp) (@functor.add_const.run.{0 0} (group.{0} (ring.{0} linarith.comp)) name h0)  := sorry --non-trivial
lemma new_lemma_133573 (h0 : functor.add_const (add_monoid (boolean_algebra environment.implicit_infer_kind)) Type) : @add_monoid.fg.{0} (boolean_algebra.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 1} (add_monoid.{0} (boolean_algebra.{0} environment.implicit_infer_kind)) Type h0)  := sorry --non-trivial
lemma new_lemma_133574 (h0 : functor.add_const (function.extfun (Type 1) topological_space) Type) : @loc_path_connected_space.{1} (has_nndist.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@functor.add_const.run.{2 1} (function.extfun.{3 2} (Type 1) topological_space.{1}) Type h0) (has_nndist.{1} Type))  := sorry --non-trivial
lemma new_lemma_133575 (h0 : ring (simple_graph string.iterator_imp)) : strong_rank_condition (simple_graph string.iterator_imp) := sorry --non-trivial
lemma new_lemma_133576 (h0 : ordered_add_comm_monoid (canonically_linear_ordered_monoid congr_arg_kind)) : archimedean (canonically_linear_ordered_monoid congr_arg_kind) := sorry --non-trivial
lemma new_lemma_133577 (h2 : function.extfun Type topological_space) : @t0_space.{0} string_imp (@function.extfun_app.{2 1} Type topological_space.{0} h2 string_imp)  := sorry --non-trivial
lemma new_lemma_133578 (h0 : group (simple_graph pos)) : group.fg (simple_graph pos) := sorry --non-trivial
lemma new_lemma_133579 (h0 : topological_space (add_cancel_monoid (add_comm_monoid environment.implicit_infer_kind))) : totally_separated_space (add_cancel_monoid (add_comm_monoid environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_133580 (h0 : topological_space (add_group (semiring (semiring linarith.comp)))) : locally_compact_space (add_group (semiring (semiring linarith.comp))) := sorry --non-trivial
lemma new_lemma_133581 (h1 : complete_lattice (semi_normed_ring to_additive.value_type)) : is_compactly_generated (semi_normed_ring to_additive.value_type) := sorry --non-trivial
lemma new_lemma_133582 (h0 : topological_space (has_neg environment.implicit_infer_kind)) : preconnected_space (has_neg environment.implicit_infer_kind) := sorry --non-trivial
lemma new_lemma_133583 (h0 : semiring (simple_graph (has_add (has_Inf pos)))) : is_noetherian_ring (simple_graph (has_add (has_Inf pos))) := sorry --non-trivial
lemma new_lemma_133584 (h0 : finset (has_Inf (has_Inf (has_add (has_add pos))))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_133585 (h0 : topological_space (ordered_ring (semiring (semiring empty)))) : discrete_topology (ordered_ring (semiring (semiring empty))) := sorry --non-trivial
lemma new_lemma_133586 (h0 : function.extfun Type uniform_space) : @separated_space.{0} (has_union.{0} num) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (has_union.{0} num))  := sorry --non-trivial
lemma new_lemma_133587 (h0 : topological_space (monoid pos)) : path_connected_space (monoid pos) := sorry --non-trivial
lemma new_lemma_133588 (h0 : complete_lattice (add_monoid (random_gen char))) : complete_lattice.is_Sup_finite_compact (add_monoid (random_gen char)) := sorry --non-trivial
lemma new_lemma_133589 (h0 : not (topological_space (partial_order empty) -> false)) : @irreducible_space.{0} (partial_order.{0} empty) (@classical.by_contradiction'.{1} (topological_space.{0} (partial_order.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_133590 (h0 : complete_lattice (distrib_lattice (random_gen (has_nnnorm fun_info)))) : is_compactly_generated (distrib_lattice (random_gen (has_nnnorm fun_info))) := sorry --non-trivial
lemma new_lemma_133591 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @locally_compact_space.{0} (has_compl.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_compl.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_133592 (h0 : uniform_space (denumerable to_additive.value_type)) : complete_space (denumerable to_additive.value_type) := sorry --non-trivial
lemma new_lemma_133593 (h0 : function.extfun Type uniform_space) : @separated_space.{0} (has_to_string.{0} name) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (has_to_string.{0} name))  := sorry --non-trivial
lemma new_lemma_133594 (h1 : function.extfun (Type -> Type) (function.extfun Type)) : @path_connected_space.{0} (with_bot.{0} linarith.ineq) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h1 topological_space.{0}) (with_bot.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_133595 (h1 h2 : multiset (mul_one_class char)) : multiset.subset h1 h2 := sorry --non-trivial
lemma new_lemma_133596 (h0 : functor.add_const (semiring (comm_semigroup real)) (has_bot real)) : @is_noetherian_ring.{0} (comm_semigroup.{0} real) (@functor.add_const.run.{0 0} (semiring.{0} (comm_semigroup.{0} real)) (has_bot.{0} real) h0)  := sorry --non-trivial
lemma new_lemma_133597 (h0 : finset (linear_order (option (option unsigned)))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_133598 (h0 : functor.add_const (add_group (has_pos_part linarith.comp)) (ring name)) : @is_add_cyclic.{0} (has_pos_part.{0} linarith.comp) (@functor.add_const.run.{0 0} (add_group.{0} (has_pos_part.{0} linarith.comp)) (ring.{0} name) h0)  := sorry --non-trivial
lemma new_lemma_133599 (h1 : has_lt ereal) : no_min_order ereal := sorry --non-trivial
lemma new_lemma_133600 (h0 : ring (with_one (add_group num))) : strong_rank_condition (with_one (add_group num)) := sorry --non-trivial
lemma new_lemma_133601 (h0 : function.extfun Type (functor.comp ordered_add_comm_monoid normed_comm_ring)) : @archimedean.{0} (normed_comm_ring.{0} name) (@functor.comp.run.{0 0 0} ordered_add_comm_monoid.{0} normed_comm_ring.{0} name (@function.extfun_app.{2 1} Type (functor.comp.{0 0 0} ordered_add_comm_monoid.{0} normed_comm_ring.{0}) h0 name))  := sorry --non-trivial
lemma new_lemma_133602 (h0 : ring (has_top (random_gen string_imp))) : is_domain (has_top (random_gen string_imp)) := sorry --non-trivial
lemma new_lemma_133603 (h0 : function.extfun Type (functor.add_const (topological_space (filter unsigned)))) : @topological_space.separable_space.{0} (filter.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (filter.{0} unsigned)) empty (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (topological_space.{0} (filter.{0} unsigned))) h0 empty))  := sorry --non-trivial
lemma new_lemma_133604 (h0 : has_mem.mem (with_one to_additive.value_type) has_emptyc.emptyc) : @path_connected_space.{0} (with_one.{0} to_additive.value_type) (@finset.pi.empty.{1 0} Type topological_space.{0} (with_one.{0} to_additive.value_type) h0)  := sorry --non-trivial
lemma new_lemma_133605 (h1 : has_mem.mem (has_top congr_arg_kind) has_emptyc.emptyc) : @t0_space.{0} (has_top.{0} congr_arg_kind) (@finset.pi.empty.{1 0} Type topological_space.{0} (has_top.{0} congr_arg_kind) h1)  := sorry --non-trivial
lemma new_lemma_133606 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @totally_separated_space.{0} (monoid.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (monoid.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_133607 (h0 : topological_space (has_norm (random_gen (has_top (has_emptyc linarith.ineq))))) : irreducible_space (has_norm (random_gen (has_top (has_emptyc linarith.ineq)))) := sorry --non-trivial
lemma new_lemma_133608 (h0 : add_group (measurable_space.dynkin_system num)) : is_add_cyclic (measurable_space.dynkin_system num) := sorry --non-trivial
lemma new_lemma_133609 (h0 : functor.add_const (function.extfun (Type 1) topological_space) pos) : @preirreducible_space.{1} (add_cancel_monoid.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) topological_space.{1}) pos h0) (add_cancel_monoid.{1} Type))  := sorry --non-trivial
lemma new_lemma_133610 (h0 : functor.add_const (topological_space (ordered_comm_ring linarith.comp)) Type) : @sequential_space.{0} (ordered_comm_ring.{0} linarith.comp) (@functor.add_const.run.{0 1} (topological_space.{0} (ordered_comm_ring.{0} linarith.comp)) Type h0)  := sorry --non-trivial
lemma new_lemma_133611 (h0 : not (topological_space (has_append fun_info) -> false)) : @path_connected_space.{0} (has_append.{0} fun_info) (@classical.by_contradiction'.{1} (topological_space.{0} (has_append.{0} fun_info)) h0)  := sorry --non-trivial
lemma new_lemma_133612 (h0 : ring (with_bot empty)) : rank_condition (with_bot empty) := sorry --non-trivial
lemma new_lemma_133613 (h0 : filter (add_cancel_monoid environment.implicit_infer_kind)) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_133614 (h0 : group (has_ssubset (random_gen (random_gen linarith.ineq)))) : group.fg (has_ssubset (random_gen (random_gen linarith.ineq))) := sorry --non-trivial
lemma new_lemma_133615 (h0 : lattice (add_comm_semigroup fun_info)) : is_modular_lattice (add_comm_semigroup fun_info) := sorry --non-trivial
lemma new_lemma_133616 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_add_cyclic.{0} (semigroup.{0} empty) (@function.extfun_app.{2 1} Type add_group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 add_group.{0}) (semigroup.{0} empty))  := sorry --non-trivial
lemma new_lemma_133617 (h0 : function.extfun (finset Type) (has_mem.mem (measurable_space congr_arg_kind))) : is_atomistic (measurable_space congr_arg_kind) := sorry --non-trivial
lemma new_lemma_133618 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_domain.{0} (normed_comm_ring.{0} linarith.comp) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (normed_comm_ring.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_133619 (h0 : complete_lattice (generalized_boolean_algebra (has_bot real))) : is_atomistic (generalized_boolean_algebra (has_bot real)) := sorry --non-trivial
lemma new_lemma_133620 (h0 : fin has_zero.zero) : @group.fg.{0} (boolean_algebra.{0} linarith.comp) (@matrix.vec_empty.{0} (group.{0} (boolean_algebra.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_133621 (h0 : function.extfun Type group) : @is_simple_group.{0} (ordered_cancel_add_comm_monoid.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type group.{0} h0 (ordered_cancel_add_comm_monoid.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_133622 (h0 : functor.add_const Prop (linear_ordered_field (option ennreal))) : functor.add_const.run h0 := sorry --non-trivial
lemma new_lemma_133623 (h0 : function.extfun Type topological_space) : @preirreducible_space.{0} (filter.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (filter.{0} empty))  := sorry --non-trivial
lemma new_lemma_133624 (h0 : functor.add_const (topological_space (boolean_algebra pos)) linarith.comp) : @topological_space.separable_space.{0} (boolean_algebra.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (boolean_algebra.{0} pos)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_133625 (h0 : topological_space (linear_ordered_semiring unsigned)) : irreducible_space (linear_ordered_semiring unsigned) := sorry --non-trivial
lemma new_lemma_133626 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : list.nodup (function.extfun_app (function.extfun_app h0 list) (comm_ring fun_info)) := sorry --non-trivial
lemma new_lemma_133627 (h0 : topological_space (has_emptyc congr_arg_kind)) : discrete_topology (has_emptyc congr_arg_kind) := sorry --non-trivial
lemma new_lemma_133628 (h3 : complete_lattice (normed_group linarith.ineq)) : is_compactly_generated (normed_group linarith.ineq) := sorry --non-trivial
lemma new_lemma_133629 (h0 : uniform_space (partial_order (semiring (semiring congr_arg_kind)))) : complete_space (partial_order (semiring (semiring congr_arg_kind))) := sorry --non-trivial
lemma new_lemma_133630 (h0 : topological_space (has_pos_part (finset (has_add Type)))) : normal_space (has_pos_part (finset (has_add Type))) := sorry --non-trivial
lemma new_lemma_133631 (h0 : complete_lattice (boolean_algebra.core (has_nndist (has_add pos)))) : is_atomistic (boolean_algebra.core (has_nndist (has_add pos))) := sorry --non-trivial
lemma new_lemma_133632 (h0 : semiring (add_right_cancel_monoid (has_top unsigned))) : is_noetherian_ring (add_right_cancel_monoid (has_top unsigned)) := sorry --non-trivial
lemma new_lemma_133633 (h3 : has_mem.mem fun_info has_emptyc.emptyc) : @complete_lattice.is_Sup_finite_compact.{0} fun_info (@finset.pi.empty.{1 0} Type complete_lattice.{0} fun_info h3)  := sorry --non-trivial
lemma new_lemma_133634 (h0 : ring (non_assoc_semiring unsigned)) : is_principal_ideal_ring (non_assoc_semiring unsigned) := sorry --non-trivial
lemma new_lemma_133635 (h0 : functor.add_const (list (add_comm_monoid Type)) environment.implicit_infer_kind) : list.nodup (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_133636 (h0 : functor.add_const (function.extfun Type complete_lattice) linarith.comp) : @complete_lattice.is_Sup_finite_compact.{0} (has_add.{0} linarith.comp) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type complete_lattice.{0}) linarith.comp h0) (has_add.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_133637 (h0 : not (topological_space (ordered_semiring congr_arg_kind) -> false)) : @path_connected_space.{0} (ordered_semiring.{0} congr_arg_kind) (@classical.by_contradiction'.{1} (topological_space.{0} (ordered_semiring.{0} congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_133638 (h0 : set (has_sdiff linarith.comp_source)) : set.finite h0 := sorry --non-trivial
lemma new_lemma_133639 (h0 : topological_space (has_add (has_bot real))) : t0_space (has_add (has_bot real)) := sorry --non-trivial
lemma new_lemma_133640 (h1 : ring (mul_one_class ereal)) : rank_condition (mul_one_class ereal) := sorry --non-trivial
lemma new_lemma_133641 (h0 : topological_space ordering) : path_connected_space ordering := sorry --non-trivial
lemma new_lemma_133642 (h0 : cancel_comm_monoid_with_zero (comm_semigroup empty)) : unique_factorization_monoid (comm_semigroup empty) := sorry --non-trivial
lemma new_lemma_133643 (h0 : topological_space (has_union empty)) : discrete_topology (has_union empty) := sorry --non-trivial
lemma new_lemma_133644 (h0 : add_group (encodable (has_nnnorm fun_info))) : is_add_cyclic (encodable (has_nnnorm fun_info)) := sorry --non-trivial
lemma new_lemma_133645 (h0 : uniform_space (has_sub (semiring (semiring congr_arg_kind)))) : complete_space (has_sub (semiring (semiring congr_arg_kind))) := sorry --non-trivial
lemma new_lemma_133646 (h0 : function.extfun nat fin) : @locally_compact_space.{0} (has_pos_part.{0} name) (@matrix.vec_empty.{0} (topological_space.{0} (has_pos_part.{0} name)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_133647 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @preirreducible_space.{0} (has_norm.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_norm.{0} empty))  := sorry --non-trivial
lemma new_lemma_133648 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @rank_condition.{0} (has_sub.{0} string_imp) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (has_sub.{0} string_imp))  := sorry --non-trivial
lemma new_lemma_133649 (h0 : not (filter (option congr_arg_kind) -> false)) : filter.ne_bot (classical.by_contradiction' h0) := sorry --non-trivial
lemma new_lemma_133650 (h0 : functor.add_const (topological_space (has_neg Type)) pos) : @sequential_space.{1} (has_neg.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (has_neg.{1} Type)) pos h0)  := sorry --non-trivial
lemma new_lemma_133651 (h0 : topological_space (has_dist congr_arg_kind)) : preirreducible_space (has_dist congr_arg_kind) := sorry --non-trivial
lemma new_lemma_133652 (h2 : uniform_space (with_one to_additive.value_type)) : complete_space (with_one to_additive.value_type) := sorry --non-trivial
lemma new_lemma_133653 (h0 : uniform_space (normed_group num)) : complete_space (normed_group num) := sorry --non-trivial
lemma new_lemma_133654 (h0 : uniform_space (has_top (semiring empty))) : separated_space (has_top (semiring empty)) := sorry --non-trivial
lemma new_lemma_133655 (h0 : not (function.extfun Type ring -> false)) : @is_domain.{0} (dlist.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type ring.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type ring.{0}) h0) (dlist.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_133656 (h0 : not (topological_space (add_left_cancel_monoid linarith.ineq) -> false)) : @totally_disconnected_space.{0} (add_left_cancel_monoid.{0} linarith.ineq) (@classical.by_contradiction'.{1} (topological_space.{0} (add_left_cancel_monoid.{0} linarith.ineq)) h0)  := sorry --non-trivial
lemma new_lemma_133657 (h0 : function.extfun Type list) : list.nodup (function.extfun_app h0 (option pos)) := sorry --non-trivial
lemma new_lemma_133658 (h0 : topological_space (boolean_algebra.core pos)) : discrete_topology (boolean_algebra.core pos) := sorry --non-trivial
lemma new_lemma_133659 (h0 : functor.add_const (ring (complete_distrib_lattice linarith.comp)) (finset linarith.comp)) : @is_principal_ideal_ring.{0} (complete_distrib_lattice.{0} linarith.comp) (@functor.add_const.run.{0 0} (ring.{0} (complete_distrib_lattice.{0} linarith.comp)) (finset.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_133660 (h0 : not (function.extfun (finset Type) (has_mem.mem real.angle) -> false)) : @is_compactly_generated.{0} real.angle (@finset.pi.empty.{1 0} Type complete_lattice.{0} real.angle (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) real.angle) (@classical.by_contradiction'.{0} (function.extfun.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) real.angle)) h0) (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_133661 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_atomistic.{0} (ring.{0} pos) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (ring.{0} pos))  := sorry --non-trivial
lemma new_lemma_133662 (h0 : fin has_zero.zero) : @is_simple_group.{0} (comm_semigroup.{0} real) (@matrix.vec_empty.{0} (group.{0} (comm_semigroup.{0} real)) h0)  := sorry --non-trivial
lemma new_lemma_133663 (h0 : topological_space (preorder (semiring num))) : locally_compact_space (preorder (semiring num)) := sorry --non-trivial
lemma new_lemma_133664 (h1 : has_le (add_comm_semigroup fun_info)) (h2 : add_comm_semigroup fun_info) : is_bot h2 := sorry --non-trivial
lemma new_lemma_133665 (h0 : topological_space (comm_group (has_to_string unsigned))) : locally_compact_space (comm_group (has_to_string unsigned)) := sorry --non-trivial
lemma new_lemma_133666 (h0 : functor.add_const (function.extfun Type ordered_add_comm_monoid) Type) : @archimedean.{0} (normed_comm_ring.{0} linarith.comp) (@function.extfun_app.{2 1} Type ordered_add_comm_monoid.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type ordered_add_comm_monoid.{0}) Type h0) (normed_comm_ring.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_133667 (h0 : fin has_zero.zero) : @normalizer_condition.{0} (has_bot.{0} pos) (@matrix.vec_empty.{0} (group.{0} (has_bot.{0} pos)) h0)  := sorry --non-trivial
lemma new_lemma_133668 (h0 : functor.add_const (ordered_add_comm_monoid (linear_order unsigned)) (semiring empty)) : @archimedean.{0} (linear_order.{0} unsigned) (@functor.add_const.run.{0 0} (ordered_add_comm_monoid.{0} (linear_order.{0} unsigned)) (semiring.{0} empty) h0)  := sorry --non-trivial
lemma new_lemma_133669 (h0 : functor.add_const (uniform_space (add_comm_monoid pos)) linarith.comp) : @separated_space.{0} (add_comm_monoid.{0} pos) (@functor.add_const.run.{0 0} (uniform_space.{0} (add_comm_monoid.{0} pos)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_133670 (h0 : ring (linear_ordered_field pos)) : strong_rank_condition (linear_ordered_field pos) := sorry --non-trivial
lemma new_lemma_133671 (h0 : function.extfun Type complete_lattice) : @complete_lattice.is_Sup_finite_compact.{0} (has_zero.{0} (ring.{0} unsigned)) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (has_zero.{0} (ring.{0} unsigned)))  := sorry --non-trivial
lemma new_lemma_133672 (h0 : topological_space (canonically_ordered_comm_semiring linarith.comp)) : regular_space (canonically_ordered_comm_semiring linarith.comp) := sorry --non-trivial
lemma new_lemma_133673 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @sequential_space.{0} (finset.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (finset.{0} pos))  := sorry --non-trivial
lemma new_lemma_133674 (h0 : function.extfun Type complete_lattice) : @complete_lattice.is_Sup_finite_compact.{0} (complete_semilattice_Sup.{0} unsigned) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (complete_semilattice_Sup.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_133675 (h2 : uniform_space enat) : complete_space enat := sorry --non-trivial
lemma new_lemma_133676 (h0 : fin has_zero.zero) : @totally_disconnected_space.{0} (canonically_linear_ordered_monoid.{0} pos) (@matrix.vec_empty.{0} (topological_space.{0} (canonically_linear_ordered_monoid.{0} pos)) h0)  := sorry --non-trivial
lemma new_lemma_133677 (h0 : functor.comp topological_space comm_group pos) : @regular_space.{0} (comm_group.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (comm_group.{0} pos)) unsigned (@functor.comp.run.{0 0 0} topological_space.{0} comm_group.{0} pos h0))  := sorry --non-trivial
lemma new_lemma_133678 (h0 : function.extfun (Type 1) (functor.add_const (topological_space linarith.comp))) : @discrete_topology.{0} linarith.comp (@functor.add_const.run.{0 1} (topological_space.{0} linarith.comp) Type (@function.extfun_app.{3 1} (Type 1) (functor.add_const.{0 1} (topological_space.{0} linarith.comp)) h0 Type))  := sorry --non-trivial
lemma new_lemma_133679 (h0 : ordered_add_comm_monoid (generalized_boolean_algebra (ordered_ring name))) : archimedean (generalized_boolean_algebra (ordered_ring name)) := sorry --non-trivial
lemma new_lemma_133680 (h0 : function.extfun Type (functor.comp list mul_zero_class)) : list.nodup (functor.comp.run (function.extfun_app h0 (finset name))) := sorry --non-trivial
lemma new_lemma_133681 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_add_cyclic.{0} (has_top.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type add_group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 add_group.{0}) (has_top.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_133682 (h0 : functor.add_const (topological_space (has_neg_part environment.implicit_infer_kind)) name) : @preconnected_space.{0} (has_neg_part.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (has_neg_part.{0} environment.implicit_infer_kind)) name h0)  := sorry --non-trivial
lemma new_lemma_133683 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @rank_condition.{0} (monoid_with_zero.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (monoid_with_zero.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_133684 (h0 : group (id (has_norm (linear_ordered_semiring (semiring num))))) : is_cyclic (id (has_norm (linear_ordered_semiring (semiring num)))) := sorry --non-trivial
lemma new_lemma_133685 (h0 : functor.comp topological_space ordered_cancel_add_comm_monoid pos) : @t1_space.{0} (ordered_cancel_add_comm_monoid.{0} pos) (@functor.comp.run.{0 0 0} topological_space.{0} ordered_cancel_add_comm_monoid.{0} pos h0)  := sorry --non-trivial
lemma new_lemma_133686 (h0 : function.extfun nat fin) : @locally_compact_space.{1} (comm_semigroup.{1} Type) (@matrix.vec_empty.{1} (topological_space.{1} (comm_semigroup.{1} Type)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_133687 (h1 : ring (uniform_space reducibility_hints)) : rank_condition (uniform_space reducibility_hints) := sorry --non-trivial
lemma new_lemma_133688 (h0 : semiring (boolean_algebra (has_nndist Type))) : is_noetherian_ring (boolean_algebra (has_nndist Type)) := sorry --non-trivial
lemma new_lemma_133689 (h0 : functor.add_const (topological_space (semigroup pos)) Type) : @t0_space.{0} (semigroup.{0} pos) (@functor.add_const.run.{0 1} (topological_space.{0} (semigroup.{0} pos)) Type h0)  := sorry --non-trivial
lemma new_lemma_133690 (h1 : topological_space (denumerable (metric_space linarith.comp_source))) : t0_space (denumerable (metric_space linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_133691 (h0 : topological_space (has_pos_part (has_add pos))) : topological_space.separable_space (has_pos_part (has_add pos)) := sorry --non-trivial
lemma new_lemma_133692 (h0 : functor.add_const (function.extfun (Type 1) monoid) pos) : @monoid.fg.{1} (has_neg.{1} Type) (@function.extfun_app.{3 2} (Type 1) monoid.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) monoid.{1}) pos h0) (has_neg.{1} Type))  := sorry --non-trivial
lemma new_lemma_133693 (h0 : function.extfun Type complete_lattice) : @is_compactly_generated.{0} (complete_semilattice_Sup.{0} empty) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (complete_semilattice_Sup.{0} empty))  := sorry --non-trivial
lemma new_lemma_133694 (h0 : function.extfun Type topological_space) : @discrete_topology.{0} (preorder.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (preorder.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_133695 (h0 : topological_space (normed_comm_ring (has_to_string Type))) : preirreducible_space (normed_comm_ring (has_to_string Type)) := sorry --non-trivial
lemma new_lemma_133696 (h0 : function.extfun Type topological_space) : @t0_space.{0} unsigned (@function.extfun_app.{2 1} Type topological_space.{0} h0 unsigned)  := sorry --non-trivial
lemma new_lemma_133697 (h1 : ring (distrib (random_gen fun_info))) : strong_rank_condition (distrib (random_gen fun_info)) := sorry --non-trivial
lemma new_lemma_133698 (h0 : function.extfun nat fin) : @t0_space.{0} (ordered_comm_monoid.{0} name) (@matrix.vec_empty.{0} (topological_space.{0} (ordered_comm_monoid.{0} name)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_133699 (h1 : topological_space (with_bot (random_gen linarith.ineq))) : path_connected_space (with_bot (random_gen linarith.ineq)) := sorry --non-trivial
lemma new_lemma_133700 (h0 : functor.add_const Prop (boolean_algebra.core pos)) : functor.add_const.run h0 := sorry --non-trivial
lemma new_lemma_133701 (h0 : not (topological_space (with_one num) -> false)) : @locally_compact_space.{0} (with_one.{0} num) (@classical.by_contradiction'.{1} (topological_space.{0} (with_one.{0} num)) h0)  := sorry --non-trivial
lemma new_lemma_133702 (h0 : topological_space (has_neg (comm_group unsigned))) : discrete_topology (has_neg (comm_group unsigned)) := sorry --non-trivial
lemma new_lemma_133703 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_simple_group.{0} (boolean_algebra.{0} pos) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (boolean_algebra.{0} pos))  := sorry --non-trivial
lemma new_lemma_133704 (h0 : topological_space (has_norm (has_norm fun_info))) : t0_space (has_norm (has_norm fun_info)) := sorry --non-trivial
lemma new_lemma_133705 (h0 : list (ring (has_neg (has_nndist (has_add Type))))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_133706 (h0 : ring (add_comm_monoid (ring linarith.comp))) : rank_condition (add_comm_monoid (ring linarith.comp)) := sorry --non-trivial
lemma new_lemma_133707 (h0 : group (has_zero (ring (has_add (ring (has_neg (has_neg (ring Type)))))))) : is_simple_group (has_zero (ring (has_add (ring (has_neg (has_neg (ring Type))))))) := sorry --non-trivial
lemma new_lemma_133708 (h0 : functor.add_const (topological_space (left_cancel_semigroup unsigned)) congr_arg_kind) : @t1_space.{0} (left_cancel_semigroup.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (left_cancel_semigroup.{0} unsigned)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_133709 (h0 : topological_space (ordered_comm_monoid (has_Inf (has_add pos)))) : normal_space (ordered_comm_monoid (has_Inf (has_add pos))) := sorry --non-trivial
lemma new_lemma_133710 (h0 : uniform_space (comm_group (has_neg_part pos))) : separated_space (comm_group (has_neg_part pos)) := sorry --non-trivial
lemma new_lemma_133711 (h0 : function.extfun (Type 1) ring) : @is_principal_ideal_ring.{1} (ordered_comm_ring.{1} Type) (@function.extfun_app.{3 2} (Type 1) ring.{1} h0 (ordered_comm_ring.{1} Type))  := sorry --non-trivial
lemma new_lemma_133712 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @locally_compact_space.{0} (linear_ordered_field.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (linear_ordered_field.{0} pos))  := sorry --non-trivial
lemma new_lemma_133713 (h0 : topological_space (non_unital_non_assoc_semiring (mul_one_class char))) : t0_space (non_unital_non_assoc_semiring (mul_one_class char)) := sorry --non-trivial
lemma new_lemma_133714 (h0 : ring (linear_ordered_comm_ring environment.projection_info)) : is_domain (linear_ordered_comm_ring environment.projection_info) := sorry --non-trivial
lemma new_lemma_133715 (h3 : complete_lattice (comm_ring (random_gen linarith.comp_source))) : complete_lattice.is_Sup_finite_compact (comm_ring (random_gen linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_133716 (h0 : functor.add_const (function.extfun Type ring) name) : @rank_condition.{0} (boolean_algebra.{0} pos) (@function.extfun_app.{2 1} Type ring.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type ring.{0}) name h0) (boolean_algebra.{0} pos))  := sorry --non-trivial
lemma new_lemma_133717 (h0 : ring (canonically_ordered_monoid (has_add real))) : is_domain (canonically_ordered_monoid (has_add real)) := sorry --non-trivial
lemma new_lemma_133718 (h0 : set (has_top string_imp)) : set.nonempty h0 := sorry --non-trivial
lemma new_lemma_133719 (h0 : function.extfun Type topological_space) : @totally_disconnected_space.{0} (has_zero.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_zero.{0} pos))  := sorry --non-trivial
lemma new_lemma_133720 (h0 : group (with_bot (random_gen string_imp))) : is_cyclic (with_bot (random_gen string_imp)) := sorry --non-trivial
lemma new_lemma_133721 (h0 : ring (linear_ordered_semiring num)) : rank_condition (linear_ordered_semiring num) := sorry --non-trivial
lemma new_lemma_133722 (h0 : topological_space (has_inter (option empty))) : irreducible_space (has_inter (option empty)) := sorry --non-trivial
lemma new_lemma_133723 (h0 : function.extfun Type topological_space) : @t0_space.{0} (add_cancel_monoid.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (add_cancel_monoid.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_133724 (h0 : has_mem.mem (metric_space linarith.comp) has_emptyc.emptyc) : @locally_compact_space.{0} (metric_space.{0} linarith.comp) (@finset.pi.empty.{1 0} Type topological_space.{0} (metric_space.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_133725 (h0 : functor.add_const (functor.add_const (uniform_space Type) pos) linarith.comp) : @complete_space.{1} Type (@functor.add_const.run.{1 0} (uniform_space.{1} Type) pos (@functor.add_const.run.{1 0} (functor.add_const.{1 0} (uniform_space.{1} Type) pos) linarith.comp h0))  := sorry --non-trivial
lemma new_lemma_133726 (h0 : functor.add_const (ring (has_neg linarith.comp)) linarith.comp) : @is_domain.{0} (has_neg.{0} linarith.comp) (@functor.add_const.run.{0 0} (ring.{0} (has_neg.{0} linarith.comp)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_133727 (h0 : functor.add_const (filter (normed_comm_ring name)) environment.implicit_infer_kind) : filter.ne_bot (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_133728 (h0 : set (bin_tree num)) : set.nonempty h0 := sorry --non-trivial
lemma new_lemma_133729 (h0 : group (comm_semigroup (sub_neg_monoid pos))) : is_cyclic (comm_semigroup (sub_neg_monoid pos)) := sorry --non-trivial
lemma new_lemma_133730 (h0 : complete_lattice (has_top (random_gen (has_inv (random_gen linarith.ineq))))) : is_compactly_generated (has_top (random_gen (has_inv (random_gen linarith.ineq)))) := sorry --non-trivial
lemma new_lemma_133731 (h0 : fin has_zero.zero) : @locally_compact_space.{1} (canonically_linear_ordered_monoid.{1} Type) (@matrix.vec_empty.{1} (topological_space.{1} (canonically_linear_ordered_monoid.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_133732 (h0 : functor.add_const (add_group (add_comm_monoid pos)) (boolean_algebra linarith.comp)) : @is_add_cyclic.{0} (add_comm_monoid.{0} pos) (@functor.add_const.run.{0 0} (add_group.{0} (add_comm_monoid.{0} pos)) (boolean_algebra.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_133733 (h0 : topological_space (add_cancel_monoid (has_add environment.implicit_infer_kind))) : regular_space (add_cancel_monoid (has_add environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_133734 (h0 : set (char -> add_comm_semigroup ereal)) : set.separates_points h0 := sorry --non-trivial
lemma new_lemma_133735 (h0 : topological_space (has_add (has_ssubset to_additive.value_type))) : path_connected_space (has_add (has_ssubset to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_133736 (h0 : functor.add_const (topological_space (has_zero pos)) Type) : @sequential_space.{0} (has_zero.{0} pos) (@functor.add_const.run.{0 1} (topological_space.{0} (has_zero.{0} pos)) Type h0)  := sorry --non-trivial
lemma new_lemma_133737 (h0 : complete_lattice (cancel_monoid (has_add pos))) : is_compactly_generated (cancel_monoid (has_add pos)) := sorry --non-trivial
lemma new_lemma_133738 (h0 : group (monoid num)) : is_cyclic (monoid num) := sorry --non-trivial
lemma new_lemma_133739 (h0 : set.set_semiring (linear_ordered_add_comm_monoid_with_top real)) (h1 : function.extfun Type linear_ordered_add_comm_monoid_with_top) : set.set_semiring.down h0 (function.extfun_app h1 real) := sorry --non-trivial
lemma new_lemma_133740 (h0 : add_monoid (has_add (has_add Type))) : add_monoid.fg (has_add (has_add Type)) := sorry --non-trivial
lemma new_lemma_133741 (h0 : function.extfun Type ring) : @rank_condition.{0} ennreal (@function.extfun_app.{2 1} Type ring.{0} h0 ennreal)  := sorry --non-trivial
lemma new_lemma_133742 (h0 : not (function.extfun Type complete_lattice -> false)) : @is_compactly_generated.{0} (semiring.{0} fun_info) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type complete_lattice.{0}) h0) (semiring.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_133743 (h0 : topological_space (monoid (option (option (option unsigned))))) : normal_space (monoid (option (option (option unsigned)))) := sorry --non-trivial
lemma new_lemma_133744 (h0 : functor.add_const (topological_space (boolean_algebra.core name)) Type) : @path_connected_space.{0} (boolean_algebra.core.{0} name) (@functor.add_const.run.{0 1} (topological_space.{0} (boolean_algebra.core.{0} name)) Type h0)  := sorry --non-trivial
lemma new_lemma_133745 (h2 : measurable_space (fintype (has_nnnorm fun_info))) (h3 : has_sup (fintype (has_nnnorm fun_info))) : has_measurable_sup (fintype (has_nnnorm fun_info)) := sorry --non-trivial
lemma new_lemma_133746 (h0 : linarith.comp_source -> linarith.comp_source) (h1 : list linarith.comp_source) : function.periodic_pts h0 (list.head h1) := sorry --non-trivial
lemma new_lemma_133747 (h3 : not (topological_space (denumerable string_imp) -> false)) : @t0_space.{0} (denumerable.{0} string_imp) (@classical.by_contradiction'.{1} (topological_space.{0} (denumerable.{0} string_imp)) h3)  := sorry --non-trivial
lemma new_lemma_133748 (h0 : function.extfun Type semiring) : @is_noetherian_ring.{0} (has_to_string.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type semiring.{0} h0 (has_to_string.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_133749 (h0 : topological_space real) : preconnected_space real := sorry --non-trivial
lemma new_lemma_133750 (h0 : topological_space (ordered_cancel_add_comm_monoid (option (option (option (option empty)))))) : t0_space (ordered_cancel_add_comm_monoid (option (option (option (option empty))))) := sorry --non-trivial
lemma new_lemma_133751 (h0 : has_mem.mem (linear_ordered_semiring empty) has_emptyc.emptyc) : @rank_condition.{0} (linear_ordered_semiring.{0} empty) (@finset.pi.empty.{1 0} Type ring.{0} (linear_ordered_semiring.{0} empty) h0)  := sorry --non-trivial
lemma new_lemma_133752 (h1 : not (ring (random_gen fun_info) -> false)) : @is_domain.{0} (random_gen.{0} fun_info) (@classical.by_contradiction'.{1} (ring.{0} (random_gen.{0} fun_info)) h1)  := sorry --non-trivial
lemma new_lemma_133753 (h0 : complete_lattice (with_bot linarith.comp)) : is_atomistic (with_bot linarith.comp) := sorry --non-trivial
lemma new_lemma_133754 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @irreducible_space.{0} (random_gen.{0} complex) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (random_gen.{0} complex))  := sorry --non-trivial
lemma new_lemma_133755 (h0 : ring (fintype (random_gen to_additive.value_type))) : is_domain (fintype (random_gen to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_133756 (h0 : uniform_space (random_gen (random_gen (random_gen num)))) : separated_space (random_gen (random_gen (random_gen num))) := sorry --non-trivial
lemma new_lemma_133757 (h0 : ring (complete_distrib_lattice (has_add name))) : strong_rank_condition (complete_distrib_lattice (has_add name)) := sorry --non-trivial
lemma new_lemma_133758 (h0 : functor.add_const (add_monoid (plift congr_arg_kind)) unsigned) : @add_monoid.fg.{1} (plift.{1} congr_arg_kind) (@functor.add_const.run.{1 0} (add_monoid.{1} (plift.{1} congr_arg_kind)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_133759 (h2 : ring fun_info) : strong_rank_condition fun_info := sorry --non-trivial
lemma new_lemma_133760 (h0 : topological_space (has_inter ennreal)) : topological_space.separable_space (has_inter ennreal) := sorry --non-trivial
lemma new_lemma_133761 (h0 : list (dlist (dlist fun_info))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_133762 (h0 : topological_space (plift (semiring (semiring (semiring empty))))) : discrete_topology (plift (semiring (semiring (semiring empty)))) := sorry --non-trivial
lemma new_lemma_133763 (h5 : uniform_space (has_div string.iterator_imp)) : complete_space (has_div string.iterator_imp) := sorry --non-trivial
lemma new_lemma_133764 (h0 : function.extfun (Type 1) ring) : @rank_condition.{1} (cancel_monoid.{1} Type) (@function.extfun_app.{3 2} (Type 1) ring.{1} h0 (cancel_monoid.{1} Type))  := sorry --non-trivial
lemma new_lemma_133765 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @topological_space.separable_space.{0} (mul_zero_class.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (mul_zero_class.{0} num))  := sorry --non-trivial
lemma new_lemma_133766 (h0 : ring (with_bot (random_gen fun_info))) : strong_rank_condition (with_bot (random_gen fun_info)) := sorry --non-trivial
lemma new_lemma_133767 (h0 : add_group (has_Inf (has_nndist Type))) : is_add_cyclic (has_Inf (has_nndist Type)) := sorry --non-trivial
lemma new_lemma_133768 (h0 : complete_lattice (has_one unsigned)) : is_compactly_generated (has_one unsigned) := sorry --non-trivial
lemma new_lemma_133769 (h0 : group (linear_ordered_semiring (random_gen num))) : normalizer_condition (linear_ordered_semiring (random_gen num)) := sorry --non-trivial
lemma new_lemma_133770 (h0 : cancel_comm_monoid_with_zero (normed_lattice_add_comm_group (has_add Type))) : unique_factorization_monoid (normed_lattice_add_comm_group (has_add Type)) := sorry --non-trivial
lemma new_lemma_133771 (h0 : topological_space (has_pos_part linarith.comp)) : irreducible_space (has_pos_part linarith.comp) := sorry --non-trivial
lemma new_lemma_133772 (h0 : function.extfun Type topological_space) : @locally_compact_space.{0} (encodable.{0} char) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (encodable.{0} char))  := sorry --non-trivial
lemma new_lemma_133773 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_cyclic.{0} real (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) real)  := sorry --non-trivial
lemma new_lemma_133774 (h0 : functor.add_const (function.extfun Type uniform_space) environment.implicit_infer_kind) : @complete_space.{0} (semigroup.{0} linarith.comp) (@function.extfun_app.{2 1} Type uniform_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type uniform_space.{0}) environment.implicit_infer_kind h0) (semigroup.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_133775 (h0 : topological_space (canonically_ordered_monoid (has_add (has_add linarith.comp)))) : topological_space.separable_space (canonically_ordered_monoid (has_add (has_add linarith.comp))) := sorry --non-trivial
lemma new_lemma_133776 (h0 : topological_space (pseudo_metric_space (option pos))) : path_connected_space (pseudo_metric_space (option pos)) := sorry --non-trivial
lemma new_lemma_133777 (h0 : not (topological_space (has_inv linarith.comp_source) -> false)) : @locally_compact_space.{0} (has_inv.{0} linarith.comp_source) (@classical.by_contradiction'.{1} (topological_space.{0} (has_inv.{0} linarith.comp_source)) h0)  := sorry --non-trivial
lemma new_lemma_133778 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @add_monoid.fg.{0} (mul_zero_class.{0} empty) (@function.extfun_app.{2 1} Type add_monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 add_monoid.{0}) (mul_zero_class.{0} empty))  := sorry --non-trivial
lemma new_lemma_133779 (h0 : functor.comp ring has_neg_part name) : @is_domain.{0} (has_neg_part.{0} name) (@functor.comp.run.{0 0 0} ring.{0} has_neg_part.{0} name h0)  := sorry --non-trivial
lemma new_lemma_133780 (h1 : not (add_group (has_nnnorm string_imp) -> false)) : @is_add_cyclic.{0} (has_nnnorm.{0} string_imp) (@classical.by_contradiction'.{1} (add_group.{0} (has_nnnorm.{0} string_imp)) h1)  := sorry --non-trivial
lemma new_lemma_133781 (h0 : group (monoid_with_zero (option (option pos)))) : is_cyclic (monoid_with_zero (option (option pos))) := sorry --non-trivial
lemma new_lemma_133782 (h1 : topological_space (has_lt to_additive.value_type)) : totally_disconnected_space (has_lt to_additive.value_type) := sorry --non-trivial
lemma new_lemma_133783 (h2 : add_group ereal) : is_add_cyclic ereal := sorry --non-trivial
lemma new_lemma_133784 (h0 : topological_space (has_sub (semiring num))) : totally_disconnected_space (has_sub (semiring num)) := sorry --non-trivial
lemma new_lemma_133785 (h1 : add_group (mul_one_class ereal)) : is_add_cyclic (mul_one_class ereal) := sorry --non-trivial
lemma new_lemma_133786 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @archimedean.{0} (group_with_zero.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type ordered_add_comm_monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ordered_add_comm_monoid.{0}) (group_with_zero.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_133787 (h0 : functor.add_const (topological_space (normed_comm_ring ennreal)) linarith.comp) : @discrete_topology.{0} (normed_comm_ring.{0} ennreal) (@functor.add_const.run.{0 0} (topological_space.{0} (normed_comm_ring.{0} ennreal)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_133788 (h0 : uniform_space (ordered_comm_ring (has_neg name))) : complete_space (ordered_comm_ring (has_neg name)) := sorry --non-trivial
lemma new_lemma_133789 (h0 : functor.add_const (semiring (non_assoc_semiring num)) empty) : @is_noetherian_ring.{0} (non_assoc_semiring.{0} num) (@functor.add_const.run.{0 0} (semiring.{0} (non_assoc_semiring.{0} num)) empty h0)  := sorry --non-trivial
lemma new_lemma_133790 (h0 : group (pseudo_metric_space pos)) : is_simple_group (pseudo_metric_space pos) := sorry --non-trivial
lemma new_lemma_133791 (h0 : topological_space (normed_comm_ring (boolean_algebra name))) : normal_space (normed_comm_ring (boolean_algebra name)) := sorry --non-trivial
lemma new_lemma_133792 (h0 : ring (omega_complete_partial_order (option unsigned))) : rank_condition (omega_complete_partial_order (option unsigned)) := sorry --non-trivial
lemma new_lemma_133793 (h0 : complete_lattice (normed_comm_ring (has_add pos))) : is_atomistic (normed_comm_ring (has_add pos)) := sorry --non-trivial
lemma new_lemma_133794 (h1 : has_neg (nondiscrete_normed_field (add_comm_semigroup char))) (h2 : measurable_space (nondiscrete_normed_field (add_comm_semigroup char))) : has_measurable_neg (nondiscrete_normed_field (add_comm_semigroup char)) := sorry --non-trivial
lemma new_lemma_133795 (h0 : function.extfun (Type 1) uniform_space) : @separated_space.{1} (ordered_comm_ring.{1} Type) (@function.extfun_app.{3 2} (Type 1) uniform_space.{1} h0 (ordered_comm_ring.{1} Type))  := sorry --non-trivial
lemma new_lemma_133796 (h2 : not (ring (dlist to_additive.value_type) -> false)) : @strong_rank_condition.{0} (dlist.{0} to_additive.value_type) (@classical.by_contradiction'.{1} (ring.{0} (dlist.{0} to_additive.value_type)) h2)  := sorry --non-trivial
lemma new_lemma_133797 (h0 : complete_lattice (add_comm_monoid (has_neg linarith.comp))) : is_atomistic (add_comm_monoid (has_neg linarith.comp)) := sorry --non-trivial
lemma new_lemma_133798 (h0 : function.extfun Type finset) : finset.nonempty (function.extfun_app h0 (add_left_cancel_semigroup unsigned)) := sorry --non-trivial
lemma new_lemma_133799 (h0 : not (group (has_compl (has_nnnorm linarith.ineq)) -> false)) : @is_cyclic.{0} (has_compl.{0} (has_nnnorm.{0} linarith.ineq)) (@classical.by_contradiction'.{1} (group.{0} (has_compl.{0} (has_nnnorm.{0} linarith.ineq))) h0)  := sorry --non-trivial
lemma new_lemma_133800 (h0 : list (omega_complete_partial_order congr_arg_kind)) : palindrome h0 := sorry --non-trivial
lemma new_lemma_133801 (h0 : ring (ordered_cancel_add_comm_monoid (option (option (option empty))))) : strong_rank_condition (ordered_cancel_add_comm_monoid (option (option (option empty)))) := sorry --non-trivial
lemma new_lemma_133802 (h0 : ring (normed_comm_ring (comm_group pos))) : strong_rank_condition (normed_comm_ring (comm_group pos)) := sorry --non-trivial
lemma new_lemma_133803 (h0 : functor.add_const (group (boolean_algebra linarith.comp)) pos) : @group.fg.{0} (boolean_algebra.{0} linarith.comp) (@functor.add_const.run.{0 0} (group.{0} (boolean_algebra.{0} linarith.comp)) pos h0)  := sorry --non-trivial
lemma new_lemma_133804 (h0 : functor.add_const (cancel_comm_monoid_with_zero (has_Inf Type)) (has_pos_part pos)) : @unique_factorization_monoid.{1} (has_Inf.{1} Type) (@functor.add_const.run.{1 0} (cancel_comm_monoid_with_zero.{1} (has_Inf.{1} Type)) (has_pos_part.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_133805 (h0 : topological_space (preorder (option unsigned))) : totally_separated_space (preorder (option unsigned)) := sorry --non-trivial
lemma new_lemma_133806 (h1 : not (topological_space (has_union linarith.comp) -> false)) : @normal_space.{0} (has_union.{0} linarith.comp) (@classical.by_contradiction'.{1} (topological_space.{0} (has_union.{0} linarith.comp)) h1)  := sorry --non-trivial
lemma new_lemma_133807 (h0 : topological_space (boolean_algebra.core (has_Inf (has_add (ring name))))) : normal_space (boolean_algebra.core (has_Inf (has_add (ring name)))) := sorry --non-trivial
lemma new_lemma_133808 (h0 : not (complete_lattice (normed_field reducibility_hints) -> false)) : @is_compactly_generated.{0} (normed_field.{0} reducibility_hints) (@classical.by_contradiction'.{1} (complete_lattice.{0} (normed_field.{0} reducibility_hints)) h0)  := sorry --non-trivial
lemma new_lemma_133809 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_add_cyclic.{0} (cancel_monoid.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type add_group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 add_group.{0}) (cancel_monoid.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_133810 (h1 : not (ring (comm_ring fun_info) -> false)) : @rank_condition.{0} (comm_ring.{0} fun_info) (@classical.by_contradiction'.{1} (ring.{0} (comm_ring.{0} fun_info)) h1)  := sorry --non-trivial
lemma new_lemma_133811 (h0 : fin has_zero.zero) : @is_domain.{1} (normed_lattice_add_comm_group.{1} Type) (@matrix.vec_empty.{1} (ring.{1} (normed_lattice_add_comm_group.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_133812 (h0 : functor.add_const (function.extfun Type topological_space) Type) : @sequential_space.{0} (add_cancel_monoid.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type topological_space.{0}) Type h0) (add_cancel_monoid.{0} name))  := sorry --non-trivial
lemma new_lemma_133813 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @preirreducible_space.{0} (is_R_or_C.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (is_R_or_C.{0} empty))  := sorry --non-trivial
lemma new_lemma_133814 (h0 : functor.add_const (cancel_comm_monoid_with_zero (add_cancel_comm_monoid unsigned)) unsigned) : @unique_factorization_monoid.{0} (add_cancel_comm_monoid.{0} unsigned) (@functor.add_const.run.{0 0} (cancel_comm_monoid_with_zero.{0} (add_cancel_comm_monoid.{0} unsigned)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_133815 (h0 : functor.add_const (ring (simple_graph linarith.comp)) Type) : @is_principal_ideal_ring.{0} (simple_graph.{0} linarith.comp) (@functor.add_const.run.{0 1} (ring.{0} (simple_graph.{0} linarith.comp)) Type h0)  := sorry --non-trivial
lemma new_lemma_133816 (h0 : topological_space (has_pos_part (finset pos))) : preconnected_space (has_pos_part (finset pos)) := sorry --non-trivial
lemma new_lemma_133817 (h0 : topological_space (has_pos_part (finset (finset linarith.comp)))) : preirreducible_space (has_pos_part (finset (finset linarith.comp))) := sorry --non-trivial
lemma new_lemma_133818 (h0 : topological_space (ordered_comm_ring pos)) : t0_space (ordered_comm_ring pos) := sorry --non-trivial
lemma new_lemma_133819 (h1 : measurable_space (has_add fun_info)) (h2 : filter (has_add fun_info)) : filter.is_measurably_generated h2 := sorry --non-trivial
lemma new_lemma_133820 (h0 : function.extfun Type group) : @is_cyclic.{0} (finset.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type group.{0} h0 (finset.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_133821 (h0 : not (ring (complete_linear_order empty) -> false)) : @is_principal_ideal_ring.{0} (complete_linear_order.{0} empty) (@classical.by_contradiction'.{1} (ring.{0} (complete_linear_order.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_133822 (h0 : set (prod (has_pos_part Type) (has_pos_part Type))) (h1 : prod (has_pos_part Type) (has_pos_part Type)) : symmetrize_rel h0 h1 := sorry --non-trivial
lemma new_lemma_133823 (h0 : functor.add_const (topological_space (finset name)) environment.implicit_infer_kind) : @normal_space.{0} (finset.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (finset.{0} name)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_133824 (h0 : group (finset (has_add Type))) : is_cyclic (finset (has_add Type)) := sorry --non-trivial
lemma new_lemma_133825 (h0 : uniform_space (add_cancel_monoid (has_pos_part Type))) : complete_space (add_cancel_monoid (has_pos_part Type)) := sorry --non-trivial
lemma new_lemma_133826 (h0 : add_comm_monoid pos -> add_comm_monoid pos -> Prop) : is_symm (add_comm_monoid pos) h0 := sorry --non-trivial
lemma new_lemma_133827 (h0 : complete_lattice (has_inv (has_ssubset (has_ssubset (has_nnnorm fun_info))))) : complete_lattice.is_Sup_finite_compact (has_inv (has_ssubset (has_ssubset (has_nnnorm fun_info)))) := sorry --non-trivial
lemma new_lemma_133828 (h0 : topological_space (has_neg linarith.comp)) : loc_path_connected_space (has_neg linarith.comp) := sorry --non-trivial
lemma new_lemma_133829 (h0 : function.extfun Type topological_space) : @t0_space.{0} (with_one.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (with_one.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_133830 (h0 : complete_lattice (semiring fun_info)) : complete_lattice.is_Sup_finite_compact (semiring fun_info) := sorry --non-trivial
lemma new_lemma_133831 (h1 : not (topological_space (add_cancel_comm_monoid string_imp) -> false)) : @t0_space.{0} (add_cancel_comm_monoid.{0} string_imp) (@classical.by_contradiction'.{1} (topological_space.{0} (add_cancel_comm_monoid.{0} string_imp)) h1)  := sorry --non-trivial
lemma new_lemma_133832 (h0 : functor.add_const (monoid (cancel_monoid environment.implicit_infer_kind)) (add_comm_monoid (add_comm_monoid pos))) : @monoid.fg.{0} (cancel_monoid.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (monoid.{0} (cancel_monoid.{0} environment.implicit_infer_kind)) (add_comm_monoid.{0} (add_comm_monoid.{0} pos)) h0)  := sorry --non-trivial
lemma new_lemma_133833 (h0 : monoid (add_semigroup unsigned)) : monoid.fg (add_semigroup unsigned) := sorry --non-trivial
lemma new_lemma_133834 (h0 : uniform_space (has_norm (semiring (semiring (random_gen linarith.comp_source))))) : separated_space (has_norm (semiring (semiring (random_gen linarith.comp_source)))) := sorry --non-trivial
lemma new_lemma_133835 (h0 : functor.add_const (topological_space (finset linarith.comp)) (has_Inf pos)) : @sequential_space.{0} (finset.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (finset.{0} linarith.comp)) (has_Inf.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_133836 (h0 : topological_space (partial_order (semiring (semiring empty)))) : totally_disconnected_space (partial_order (semiring (semiring empty))) := sorry --non-trivial
lemma new_lemma_133837 (h0 : ring (topological_space to_additive.value_type)) : strong_rank_condition (topological_space to_additive.value_type) := sorry --non-trivial
lemma new_lemma_133838 (h0 : function.extfun Type uniform_space) : @separated_space.{0} (has_one.{0} linarith.comp) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (has_one.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_133839 (h0 : ring (plift (complete_linear_order num))) : strong_rank_condition (plift (complete_linear_order num)) := sorry --non-trivial
lemma new_lemma_133840 (h0 : filter (ring (add_comm_monoid pos))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_133841 (h0 : topological_space (normed_group (random_gen to_additive.value_type))) : t0_space (normed_group (random_gen to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_133842 (h0 : finset (add_cancel_monoid (option ennreal))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_133843 (h0 : functor.add_const Prop (div_inv_monoid (option (option (option unsigned))))) : functor.add_const.run h0 := sorry --non-trivial
lemma new_lemma_133844 (h0 : ring (linear_ordered_cancel_comm_monoid num)) : is_principal_ideal_ring (linear_ordered_cancel_comm_monoid num) := sorry --non-trivial
lemma new_lemma_133845 (h0 : complete_lattice (id congr_arg_kind)) : is_compactly_generated (id congr_arg_kind) := sorry --non-trivial
lemma new_lemma_133846 (h0 : functor.add_const (topological_space (free_add_monoid congr_arg_kind)) empty) : @totally_disconnected_space.{0} (free_add_monoid.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (free_add_monoid.{0} congr_arg_kind)) empty h0)  := sorry --non-trivial
lemma new_lemma_133847 (h0 : function.extfun Type (functor.add_const (prod (free_add_monoid congr_arg_kind) (free_add_monoid congr_arg_kind)))) : id_rel (functor.add_const.run (function.extfun_app h0 congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_133848 (h0 : topological_space linarith.comp) : totally_disconnected_space linarith.comp := sorry --non-trivial
lemma new_lemma_133849 (h1 : uniform_space (comm_ring char)) : complete_space (comm_ring char) := sorry --non-trivial
lemma new_lemma_133850 (h0 : functor.add_const (uniform_space (has_neg Type)) linarith.comp) : @complete_space.{1} (has_neg.{1} Type) (@functor.add_const.run.{1 0} (uniform_space.{1} (has_neg.{1} Type)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_133851 (h0 : topological_space (measure_theory.measure_space (semiring (semiring (semiring num))))) : preirreducible_space (measure_theory.measure_space (semiring (semiring (semiring num)))) := sorry --non-trivial
lemma new_lemma_133852 (h0 : topological_space (sub_neg_monoid (ordered_comm_ring real))) : totally_separated_space (sub_neg_monoid (ordered_comm_ring real)) := sorry --non-trivial
lemma new_lemma_133853 (h0 : function.extfun Type topological_space) : @totally_disconnected_space.{0} (has_neg.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_neg.{0} num))  := sorry --non-trivial
lemma new_lemma_133854 (h0 : topological_space (measurable_space.dynkin_system (has_norm empty))) : discrete_topology (measurable_space.dynkin_system (has_norm empty)) := sorry --non-trivial
lemma new_lemma_133855 (h0 : fin has_zero.zero) : @sequential_space.{1} (boolean_algebra.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@matrix.vec_empty.{2} (function.extfun.{3 2} (Type 1) topological_space.{1}) h0) (boolean_algebra.{1} Type))  := sorry --non-trivial
lemma new_lemma_133856 (h0 : add_monoid (with_bot (has_top num))) : add_monoid.fg (with_bot (has_top num)) := sorry --non-trivial
lemma new_lemma_133857 (h0 : add_group (option (option ennreal))) : is_add_cyclic (option (option ennreal)) := sorry --non-trivial
lemma new_lemma_133858 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_domain.{0} (is_R_or_C.{0} unsigned) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (is_R_or_C.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_133859 (h1 : function.extfun (Type -> Type) (function.extfun Type)) : @locally_compact_space.{0} (random_gen.{0} fun_info) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h1 topological_space.{0}) (random_gen.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_133860 (h0 : not (topological_space (metric_space empty) -> false)) : @preirreducible_space.{0} (metric_space.{0} empty) (@classical.by_contradiction'.{1} (topological_space.{0} (metric_space.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_133861 (h0 : not (has_mem.mem ring has_emptyc.emptyc -> false)) : @strong_rank_condition.{0} fun_info (@function.extfun_app.{2 1} Type ring.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) ring.{0} (@classical.by_contradiction'.{0} (@has_mem.mem.{1 1} (Type → Type) (finset.{1} (Type → Type)) (@finset.has_mem.{1} (Type → Type)) ring.{0} (@has_emptyc.emptyc.{1} (finset.{1} (Type → Type)) (@finset.has_emptyc.{1} (Type → Type)))) h0)) fun_info)  := sorry --non-trivial
lemma new_lemma_133862 (h0 : not (topological_space (has_top linarith.comp_source) -> false)) : @totally_disconnected_space.{0} (has_top.{0} linarith.comp_source) (@classical.by_contradiction'.{1} (topological_space.{0} (has_top.{0} linarith.comp_source)) h0)  := sorry --non-trivial
lemma new_lemma_133863 (h0 : function.extfun (finset (Type -> Type)) (has_mem.mem topological_space)) : @totally_separated_space.{0} (has_top.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type topological_space.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) topological_space.{0} (@function.extfun_app.{2 0} (finset.{1} (Type → Type)) (@has_mem.mem.{1 1} (Type → Type) (finset.{1} (Type → Type)) (@finset.has_mem.{1} (Type → Type)) topological_space.{0}) h0 (@has_emptyc.emptyc.{1} (finset.{1} (Type → Type)) (@finset.has_emptyc.{1} (Type → Type))))) (has_top.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_133864 (h0 : functor.add_const (group (bin_tree empty)) (semiring num)) : @group.fg.{0} (bin_tree.{0} empty) (@functor.add_const.run.{0 0} (group.{0} (bin_tree.{0} empty)) (semiring.{0} num) h0)  := sorry --non-trivial
lemma new_lemma_133865 (h0 : topological_space (partial_order congr_arg_kind)) : totally_disconnected_space (partial_order congr_arg_kind) := sorry --non-trivial
lemma new_lemma_133866 (h0 : functor.comp topological_space option (ring unsigned)) : @discrete_topology.{0} (option.{0} (ring.{0} unsigned)) (@functor.comp.run.{0 0 0} topological_space.{0} option.{0} (ring.{0} unsigned) h0)  := sorry --non-trivial
lemma new_lemma_133867 (h0 : topological_space (canonically_ordered_monoid (comm_semigroup (has_add real)))) : t0_space (canonically_ordered_monoid (comm_semigroup (has_add real))) := sorry --non-trivial
lemma new_lemma_133868 (h0 : functor.add_const (uniform_space (comm_group linarith.comp)) pos) : @separated_space.{0} (comm_group.{0} linarith.comp) (@functor.add_const.run.{0 0} (uniform_space.{0} (comm_group.{0} linarith.comp)) pos h0)  := sorry --non-trivial
lemma new_lemma_133869 (h0 : function.extfun (finset Type) (has_mem.mem (measurable_space linarith.comp_source))) : @monoid.fg.{0} (measurable_space.{0} linarith.comp_source) (@finset.pi.empty.{1 0} Type monoid.{0} (measurable_space.{0} linarith.comp_source) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (measurable_space.{0} linarith.comp_source)) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_133870 (h0 : list (semigroup (finset (has_to_string (has_to_string environment.implicit_infer_kind))))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_133871 (h0 : function.extfun Type add_monoid) : @add_monoid.fg.{0} (linear_ordered_field.{0} num) (@function.extfun_app.{2 1} Type add_monoid.{0} h0 (linear_ordered_field.{0} num))  := sorry --non-trivial
lemma new_lemma_133872 (h0 : not (topological_space (has_emptyc linarith.comp_source) -> false)) : @path_connected_space.{0} (has_emptyc.{0} linarith.comp_source) (@classical.by_contradiction'.{1} (topological_space.{0} (has_emptyc.{0} linarith.comp_source)) h0)  := sorry --non-trivial
lemma new_lemma_133873 (h0 : functor.add_const (add_group (semigroup name)) name) : @is_add_cyclic.{0} (semigroup.{0} name) (@functor.add_const.run.{0 0} (add_group.{0} (semigroup.{0} name)) name h0)  := sorry --non-trivial
lemma new_lemma_133874 (h0 : topological_space (finset (finset (finset linarith.comp)))) : topological_space.separable_space (finset (finset (finset linarith.comp))) := sorry --non-trivial
lemma new_lemma_133875 (h0 : group (has_zero (has_add (has_add pos)))) : is_simple_group (has_zero (has_add (has_add pos))) := sorry --non-trivial
lemma new_lemma_133876 (h0 : not (function.extfun Type ring -> false)) : @is_domain.{0} (left_cancel_semigroup.{0} empty) (@function.extfun_app.{2 1} Type ring.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type ring.{0}) h0) (left_cancel_semigroup.{0} empty))  := sorry --non-trivial
lemma new_lemma_133877 (h0 : topological_space (with_one (random_gen (random_gen (random_gen num))))) : discrete_topology (with_one (random_gen (random_gen (random_gen num)))) := sorry --non-trivial
lemma new_lemma_133878 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_compactly_generated.{0} nnreal (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) nnreal)  := sorry --non-trivial
lemma new_lemma_133879 (h0 : topological_space (has_neg_part (cancel_monoid (option unsigned)))) : preirreducible_space (has_neg_part (cancel_monoid (option unsigned))) := sorry --non-trivial
lemma new_lemma_133880 (h0 : finset (comm_group (finset pos))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_133881 (h0 : function.extfun Type uniform_space) : @complete_space.{0} (normed_comm_ring.{0} ennreal) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (normed_comm_ring.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_133882 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @preirreducible_space.{0} (measurable_space.dynkin_system.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (measurable_space.dynkin_system.{0} num))  := sorry --non-trivial
lemma new_lemma_133883 (h0 : not (topological_space (plift unsigned) -> false)) : @normal_space.{1} (plift.{1} unsigned) (@classical.by_contradiction'.{2} (topological_space.{1} (plift.{1} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_133884 (h0 : function.extfun Type uniform_space) : @separated_space.{0} (measurable_space.dynkin_system.{0} empty) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (measurable_space.dynkin_system.{0} empty))  := sorry --non-trivial
lemma new_lemma_133885 (h0 : function.extfun (finset (Type -> Type)) (has_mem.mem complete_lattice)) : complete_lattice.is_Sup_finite_compact (measurable_space fun_info) := sorry --non-trivial
lemma new_lemma_133886 (h0 : topological_space (semiring (has_norm (semiring linarith.comp)))) : totally_separated_space (semiring (has_norm (semiring linarith.comp))) := sorry --non-trivial
lemma new_lemma_133887 (h0 : functor.add_const (function.extfun Type topological_space) linarith.comp) : @irreducible_space.{0} (semigroup.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) linarith.comp h0) (semigroup.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_133888 (h0 : group (finset (has_Inf Type))) : normalizer_condition (finset (has_Inf Type)) := sorry --non-trivial
lemma new_lemma_133889 (h0 : uniform_space (with_one (random_gen linarith.ineq))) : complete_space (with_one (random_gen linarith.ineq)) := sorry --non-trivial
lemma new_lemma_133890 (h0 : function.extfun Type complete_lattice) : @complete_lattice.is_Sup_finite_compact.{0} (add_left_cancel_monoid.{0} num) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (add_left_cancel_monoid.{0} num))  := sorry --non-trivial
lemma new_lemma_133891 (h0 : topological_space (measurable_space (semiring linarith.comp))) : irreducible_space (measurable_space (semiring linarith.comp)) := sorry --non-trivial
lemma new_lemma_133892 (h0 : functor.add_const (group (has_neg Type)) pos) : @is_cyclic.{1} (has_neg.{1} Type) (@functor.add_const.run.{1 0} (group.{1} (has_neg.{1} Type)) pos h0)  := sorry --non-trivial
lemma new_lemma_133893 (h0 : topological_space (linear_ordered_semiring (semiring (semiring linarith.comp)))) : t0_space (linear_ordered_semiring (semiring (semiring linarith.comp))) := sorry --non-trivial
lemma new_lemma_133894 (h0 : group (random_gen (has_top to_additive.value_type))) : normalizer_condition (random_gen (has_top to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_133895 (h0 : ring (has_ssubset (linear_ordered_add_comm_monoid_with_top std_gen))) : is_domain (has_ssubset (linear_ordered_add_comm_monoid_with_top std_gen)) := sorry --non-trivial
lemma new_lemma_133896 (h0 : function.extfun Type add_monoid) : @add_monoid.fg.{0} (has_inter.{0} ennreal) (@function.extfun_app.{2 1} Type add_monoid.{0} h0 (has_inter.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_133897 (h0 : not (group (has_one num) -> false)) : @is_cyclic.{0} (has_one.{0} num) (@classical.by_contradiction'.{1} (group.{0} (has_one.{0} num)) h0)  := sorry --non-trivial
lemma new_lemma_133898 (h0 : not (function.extfun Type uniform_space -> false)) : @separated_space.{0} (measurable_space.dynkin_system.{0} num) (@function.extfun_app.{2 1} Type uniform_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type uniform_space.{0}) h0) (measurable_space.dynkin_system.{0} num))  := sorry --non-trivial
lemma new_lemma_133899 (h0 : complete_lattice (uniform_space (has_lt char))) : is_compactly_generated (uniform_space (has_lt char)) := sorry --non-trivial
lemma new_lemma_133900 (h1 : has_mem.mem linarith.comp_source has_emptyc.emptyc) : @totally_separated_space.{0} linarith.comp_source (@finset.pi.empty.{1 0} Type topological_space.{0} linarith.comp_source h1)  := sorry --non-trivial
lemma new_lemma_133901 (h0 : function.extfun Type topological_space) : @path_connected_space.{0} (measurable_space.dynkin_system.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (measurable_space.dynkin_system.{0} num))  := sorry --non-trivial
lemma new_lemma_133902 (h0 : functor.add_const (filter (ring linarith.comp)) environment.implicit_infer_kind) : filter.ne_bot (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_133903 (h0 : topological_space (finset (normed_comm_ring unsigned))) : sequential_space (finset (normed_comm_ring unsigned)) := sorry --non-trivial
lemma new_lemma_133904 (h0 : topological_space (add_cancel_monoid (finset (finset Type)))) : locally_compact_space (add_cancel_monoid (finset (finset Type))) := sorry --non-trivial
lemma new_lemma_133905 (h0 : functor.add_const (function.extfun (Type 1) ring) Type) : @is_principal_ideal_ring.{1} (normed_comm_ring.{1} Type) (@function.extfun_app.{3 2} (Type 1) ring.{1} (@functor.add_const.run.{2 1} (function.extfun.{3 2} (Type 1) ring.{1}) Type h0) (normed_comm_ring.{1} Type))  := sorry --non-trivial
lemma new_lemma_133906 (h0 : topological_space (cancel_monoid (has_zero pos))) : path_connected_space (cancel_monoid (has_zero pos)) := sorry --non-trivial
lemma new_lemma_133907 (h0 : functor.add_const (topological_space (has_neg_part ennreal)) name) : @t1_space.{0} (has_neg_part.{0} ennreal) (@functor.add_const.run.{0 0} (topological_space.{0} (has_neg_part.{0} ennreal)) name h0)  := sorry --non-trivial
lemma new_lemma_133908 (h0 : group (cancel_monoid unsigned)) : is_simple_group (cancel_monoid unsigned) := sorry --non-trivial
lemma new_lemma_133909 (h0 : filter (add_comm_monoid (has_add (comm_group Type)))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_133910 (h0 : function.extfun Type group) : @is_simple_group.{0} (canonically_ordered_monoid.{0} name) (@function.extfun_app.{2 1} Type group.{0} h0 (canonically_ordered_monoid.{0} name))  := sorry --non-trivial
lemma new_lemma_133911 (h0 : function.extfun Type list) : list.nodup (function.extfun_app h0 (id unsigned)) := sorry --non-trivial
lemma new_lemma_133912 (h0 : ring (random_gen (uniform_space char))) : strong_rank_condition (random_gen (uniform_space char)) := sorry --non-trivial
lemma new_lemma_133913 (h0 : functor.add_const (add_monoid (simple_graph linarith.comp)) environment.implicit_infer_kind) : @add_monoid.fg.{0} (simple_graph.{0} linarith.comp) (@functor.add_const.run.{0 0} (add_monoid.{0} (simple_graph.{0} linarith.comp)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_133914 (h0 : topological_space (add_cancel_monoid (mul_one_class Type))) : locally_compact_space (add_cancel_monoid (mul_one_class Type)) := sorry --non-trivial
lemma new_lemma_133915 (h0 : functor.add_const (ring (pseudo_metric_space pos)) pos) : @strong_rank_condition.{0} (pseudo_metric_space.{0} pos) (@functor.add_const.run.{0 0} (ring.{0} (pseudo_metric_space.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_133916 (h0 : complete_lattice (canonically_ordered_comm_semiring string.iterator_imp)) : is_compactly_generated (canonically_ordered_comm_semiring string.iterator_imp) := sorry --non-trivial
lemma new_lemma_133917 (h0 : functor.comp semiring semigroup (has_add unsigned)) : @is_noetherian_ring.{0} (semigroup.{0} (has_add.{0} unsigned)) (@functor.comp.run.{0 0 0} semiring.{0} semigroup.{0} (has_add.{0} unsigned) h0)  := sorry --non-trivial
lemma new_lemma_133918 (h0 : function.extfun Type topological_space) : @discrete_topology.{0} (measurable_space.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (measurable_space.{0} num))  := sorry --non-trivial
lemma new_lemma_133919 (h0 : functor.add_const (complete_lattice (has_pos_part linarith.comp)) (has_add pos)) : @complete_lattice.is_Sup_finite_compact.{0} (has_pos_part.{0} linarith.comp) (@functor.add_const.run.{0 0} (complete_lattice.{0} (has_pos_part.{0} linarith.comp)) (has_add.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_133920 (h0 : topological_space (has_norm (semiring congr_arg_kind))) : path_connected_space (has_norm (semiring congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_133921 (h0 : topological_space (distrib (has_ssubset reducibility_hints))) : t0_space (distrib (has_ssubset reducibility_hints)) := sorry --non-trivial
lemma new_lemma_133922 (h0 : topological_space (metric_space (denumerable to_additive.value_type))) : t0_space (metric_space (denumerable to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_133923 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @t0_space.{0} (has_edist.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_edist.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_133924 (h0 : filter (ring (has_to_string pos))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_133925 (h0 : functor.add_const (complete_lattice (add_comm_monoid pos)) (add_comm_monoid Type)) : @is_compactly_generated.{0} (add_comm_monoid.{0} pos) (@functor.add_const.run.{0 1} (complete_lattice.{0} (add_comm_monoid.{0} pos)) (add_comm_monoid.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_133926 (h0 : functor.add_const (topological_space (semiring unsigned)) unsigned) : @topological_space.separable_space.{0} (semiring.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (semiring.{0} unsigned)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_133927 (h0 : function.extfun (finset Type) (has_mem.mem (with_one linarith.comp))) : @t0_space.{0} (with_one.{0} linarith.comp) (@finset.pi.empty.{1 0} Type topological_space.{0} (with_one.{0} linarith.comp) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (with_one.{0} linarith.comp)) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_133928 (h0 : topological_space (canonically_ordered_comm_semiring Type)) : preconnected_space (canonically_ordered_comm_semiring Type) := sorry --non-trivial
lemma new_lemma_133929 (h0 : add_monoid (has_bot (option (option empty)))) : add_monoid.fg (has_bot (option (option empty))) := sorry --non-trivial
lemma new_lemma_133930 (h0 : function.extfun Type (prod (has_zero pos))) : id_rel (function.extfun_app h0 (has_zero pos)) := sorry --non-trivial
lemma new_lemma_133931 (h0 : topological_space (semigroup (boolean_algebra.core (has_Inf (finset pos))))) : topological_space.separable_space (semigroup (boolean_algebra.core (has_Inf (finset pos)))) := sorry --non-trivial
lemma new_lemma_133932 (h0 : complete_lattice (uniform_space (mul_one_class (mul_one_class linarith.ineq)))) : complete_lattice.is_Sup_finite_compact (uniform_space (mul_one_class (mul_one_class linarith.ineq))) := sorry --non-trivial
lemma new_lemma_133933 (h0 : has_neg (semi_normed_comm_ring char)) (h1 : measurable_space (semi_normed_comm_ring char)) : has_measurable_neg (semi_normed_comm_ring char) := sorry --non-trivial
lemma new_lemma_133934 (h0 : list (has_inv (has_inv (has_inv to_additive.value_type)))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_133935 (h0 : fin has_zero.zero) : @locally_compact_space.{0} (has_bot.{0} real) (@function.extfun_app.{2 1} Type topological_space.{0} (@matrix.vec_empty.{1} (function.extfun.{2 1} Type topological_space.{0}) h0) (has_bot.{0} real))  := sorry --non-trivial
lemma new_lemma_133936 (h0 : add_monoid (add_cancel_monoid (ring environment.implicit_infer_kind))) : add_monoid.fg (add_cancel_monoid (ring environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_133937 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @add_monoid.fg.{0} (has_neg.{0} ennreal) (@function.extfun_app.{2 1} Type add_monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 add_monoid.{0}) (has_neg.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_133938 (h0 : complete_lattice (has_zero (add_cancel_monoid linarith.comp))) : is_atomistic (has_zero (add_cancel_monoid linarith.comp)) := sorry --non-trivial
lemma new_lemma_133939 (h0 : ring (has_top (semiring (semiring num)))) : is_principal_ideal_ring (has_top (semiring (semiring num))) := sorry --non-trivial
lemma new_lemma_133940 (h0 : function.extfun Type ring) : @is_domain.{0} linarith.ineq (@function.extfun_app.{2 1} Type ring.{0} h0 linarith.ineq)  := sorry --non-trivial
lemma new_lemma_133941 (h0 : topological_space (add_cancel_monoid congr_arg_kind)) : irreducible_space (add_cancel_monoid congr_arg_kind) := sorry --non-trivial
lemma new_lemma_133942 (h1 : ring (has_ssubset (normed_field ereal))) : is_domain (has_ssubset (normed_field ereal)) := sorry --non-trivial
lemma new_lemma_133943 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @add_monoid.fg.{0} (metric_space.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type add_monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 add_monoid.{0}) (metric_space.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_133944 (h1 : topological_space (linear_ordered_add_comm_group string_imp)) : t0_space (linear_ordered_add_comm_group string_imp) := sorry --non-trivial
lemma new_lemma_133945 (h0 : function.extfun (finset (Type -> Type)) (has_mem.mem group)) : @normalizer_condition.{0} linarith.comp_source (@function.extfun_app.{2 1} Type group.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) group.{0} (@function.extfun_app.{2 0} (finset.{1} (Type → Type)) (@has_mem.mem.{1 1} (Type → Type) (finset.{1} (Type → Type)) (@finset.has_mem.{1} (Type → Type)) group.{0}) h0 (@has_emptyc.emptyc.{1} (finset.{1} (Type → Type)) (@finset.has_emptyc.{1} (Type → Type))))) linarith.comp_source)  := sorry --non-trivial
lemma new_lemma_133946 (h0 : not (topological_space (has_compl linarith.comp_source) -> false)) : @path_connected_space.{0} (has_compl.{0} linarith.comp_source) (@classical.by_contradiction'.{1} (topological_space.{0} (has_compl.{0} linarith.comp_source)) h0)  := sorry --non-trivial
lemma new_lemma_133947 (h0 : ring (normed_comm_ring (option num))) : is_principal_ideal_ring (normed_comm_ring (option num)) := sorry --non-trivial
lemma new_lemma_133948 (h0 : functor.add_const (finset (normed_comm_ring linarith.comp)) environment.implicit_infer_kind) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_133949 (h0 : function.extfun Type (functor.add_const (semiring pos))) : @is_noetherian_ring.{0} pos (@functor.add_const.run.{0 0} (semiring.{0} pos) pos (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (semiring.{0} pos)) h0 pos))  := sorry --non-trivial
lemma new_lemma_133950 (h2 : function.extfun Type group) : @normalizer_condition.{0} (has_emptyc.{0} linarith.ineq) (@function.extfun_app.{2 1} Type group.{0} h2 (has_emptyc.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_133951 (h0 : uniform_space (complete_semilattice_Sup (has_norm (has_norm (has_norm linarith.comp))))) : complete_space (complete_semilattice_Sup (has_norm (has_norm (has_norm linarith.comp)))) := sorry --non-trivial
lemma new_lemma_133952 (h0 : functor.add_const (ring (semigroup pos)) environment.implicit_infer_kind) : @is_domain.{0} (semigroup.{0} pos) (@functor.add_const.run.{0 0} (ring.{0} (semigroup.{0} pos)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_133953 (h0 : function.extfun Type monoid) : @monoid.fg.{0} (ordered_ring.{0} empty) (@function.extfun_app.{2 1} Type monoid.{0} h0 (ordered_ring.{0} empty))  := sorry --non-trivial
lemma new_lemma_133954 (h0 : function.extfun Type topological_space) : @sequential_space.{0} (comm_semigroup.{0} real) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (comm_semigroup.{0} real))  := sorry --non-trivial
lemma new_lemma_133955 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @totally_disconnected_space.{1} (ordered_comm_ring.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 topological_space.{1}) (ordered_comm_ring.{1} Type))  := sorry --non-trivial
lemma new_lemma_133956 (h0 : functor.add_const (ring (ordered_comm_ring Type)) pos) : @rank_condition.{1} (ordered_comm_ring.{1} Type) (@functor.add_const.run.{1 0} (ring.{1} (ordered_comm_ring.{1} Type)) pos h0)  := sorry --non-trivial
lemma new_lemma_133957 (h0 : prod (complete_linear_order (has_top empty)) (complete_linear_order (has_top empty))) : id_rel h0 := sorry --non-trivial
lemma new_lemma_133958 (h0 : filter (normed_comm_ring (has_to_string pos))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_133959 (h0 : monoid (has_add num)) : monoid.fg (has_add num) := sorry --non-trivial
lemma new_lemma_133960 (h0 : function.extfun Type (functor.add_const (group nnreal))) : @group.fg.{0} nnreal (@functor.add_const.run.{0 0} (group.{0} nnreal) congr_arg_kind (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (group.{0} nnreal)) h0 congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_133961 (h5 : add_group (semi_normed_ring string_imp)) : is_add_cyclic (semi_normed_ring string_imp) := sorry --non-trivial
lemma new_lemma_133962 (h0 : list (dlist (has_nnnorm fun_info))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_133963 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @totally_separated_space.{0} (generalized_boolean_algebra.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (generalized_boolean_algebra.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_133964 (h0 : ring (normed_field (mul_one_class to_additive.value_type))) : is_domain (normed_field (mul_one_class to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_133965 (h0 : function.extfun Type ordered_add_comm_monoid) : @archimedean.{0} (finset.{0} pos) (@function.extfun_app.{2 1} Type ordered_add_comm_monoid.{0} h0 (finset.{0} pos))  := sorry --non-trivial
lemma new_lemma_133966 (h0 : functor.add_const (topological_space (linear_order empty)) empty) : @locally_compact_space.{0} (linear_order.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (linear_order.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_133967 (h0 : complete_lattice (finset (has_add linarith.comp))) : is_compactly_generated (finset (has_add linarith.comp)) := sorry --non-trivial
lemma new_lemma_133968 (h0 : complete_lattice (with_zero fun_info)) : complete_lattice.is_Sup_finite_compact (with_zero fun_info) := sorry --non-trivial
lemma new_lemma_133969 (h0 : ring (has_to_string (has_pos_part (has_add Type)))) : is_domain (has_to_string (has_pos_part (has_add Type))) := sorry --non-trivial
lemma new_lemma_133970 (h0 : function.extfun Type topological_space) : @t0_space.{0} (dlist.{0} fun_info) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (dlist.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_133971 (h0 : function.extfun Type topological_space) : @preirreducible_space.{0} (has_pos_part.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_pos_part.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_133972 (h1 : ring (random_gen (has_nnnorm (has_nnnorm fun_info)))) : rank_condition (random_gen (has_nnnorm (has_nnnorm fun_info))) := sorry --non-trivial
lemma new_lemma_133973 (h0 : fin has_zero.zero) : @strong_rank_condition.{0} (has_pos_part.{0} real) (@matrix.vec_empty.{0} (ring.{0} (has_pos_part.{0} real)) h0)  := sorry --non-trivial
lemma new_lemma_133974 (h0 : ring (has_emptyc linarith.comp_source)) : is_domain (has_emptyc linarith.comp_source) := sorry --non-trivial
lemma new_lemma_133975 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : list.nodup (function.extfun_app (function.extfun_app h0 list) (ordered_comm_monoid linarith.comp)) := sorry --non-trivial
lemma new_lemma_133976 (h0 : functor.add_const (topological_space (preorder unsigned)) congr_arg_kind) : @discrete_topology.{0} (preorder.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (preorder.{0} unsigned)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_133977 (h0 : function.extfun Type ring) : @rank_condition.{0} (measurable_space.{0} empty) (@function.extfun_app.{2 1} Type ring.{0} h0 (measurable_space.{0} empty))  := sorry --non-trivial
lemma new_lemma_133978 (h0 : group (generalized_boolean_algebra pos)) : is_cyclic (generalized_boolean_algebra pos) := sorry --non-trivial
lemma new_lemma_133979 (h0 : function.extfun Type group) : @group.fg.{0} (encodable.{0} string_imp) (@function.extfun_app.{2 1} Type group.{0} h0 (encodable.{0} string_imp))  := sorry --non-trivial
lemma new_lemma_133980 (h0 : fin has_zero.zero) : @locally_compact_space.{0} (add_comm_monoid.{0} real) (@matrix.vec_empty.{0} (topological_space.{0} (add_comm_monoid.{0} real)) (@matrix.vec_empty.{0} (fin (@has_zero.zero.{0} nat nat.has_zero)) h0))  := sorry --non-trivial
lemma new_lemma_133981 (h0 : group (encodable (has_ssubset (random_gen linarith.ineq)))) : group.fg (encodable (has_ssubset (random_gen linarith.ineq))) := sorry --non-trivial
lemma new_lemma_133982 (h0 : function.extfun Type ring) : @rank_condition.{0} (complete_linear_order.{0} num) (@function.extfun_app.{2 1} Type ring.{0} h0 (complete_linear_order.{0} num))  := sorry --non-trivial
lemma new_lemma_133983 (h0 : set (nondiscrete_normed_field (add_comm_semigroup (add_comm_semigroup (add_comm_semigroup ereal))) -> fun_info)) : set.separates_points h0 := sorry --non-trivial
lemma new_lemma_133984 (h0 : function.extfun Type filter) : filter.ne_bot (function.extfun_app h0 (ordered_comm_ring empty)) := sorry --non-trivial
lemma new_lemma_133985 (h0 : topological_space (group_with_zero num)) : totally_separated_space (group_with_zero num) := sorry --non-trivial
lemma new_lemma_133986 (h0 : ring (has_zero (comm_group pos))) : strong_rank_condition (has_zero (comm_group pos)) := sorry --non-trivial
lemma new_lemma_133987 (h1 : topological_space (normed_field (topological_space (random_gen char)))) : totally_disconnected_space (normed_field (topological_space (random_gen char))) := sorry --non-trivial
lemma new_lemma_133988 (h0 : complete_lattice (monoid (option (option ennreal)))) : complete_lattice.is_Sup_finite_compact (monoid (option (option ennreal))) := sorry --non-trivial
lemma new_lemma_133989 (h0 : semiring (normed_comm_ring (has_add (has_add name)))) : is_noetherian_ring (normed_comm_ring (has_add (has_add name))) := sorry --non-trivial
lemma new_lemma_133990 (h0 : topological_space (has_ssubset (mul_one_class char))) (h1 : preorder (has_ssubset (mul_one_class char))) : order_closed_topology (has_ssubset (mul_one_class char)) := sorry --non-trivial
lemma new_lemma_133991 (h0 : topological_space (has_neg (finset (finset pos)))) : t1_space (has_neg (finset (finset pos))) := sorry --non-trivial
lemma new_lemma_133992 (h0 : filter (has_to_string (comm_group unsigned))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_133993 (h0 : function.extfun Type complete_lattice) : @complete_lattice.is_Sup_finite_compact.{0} (canonically_ordered_comm_semiring.{0} unsigned) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (canonically_ordered_comm_semiring.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_133994 (h0 : topological_space (random_gen (comm_ring reducibility_hints))) : path_connected_space (random_gen (comm_ring reducibility_hints)) := sorry --non-trivial
lemma new_lemma_133995 (h0 : functor.add_const (list (ordered_ring unsigned)) (semiring congr_arg_kind)) : palindrome (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_133996 (h0 : ring (boolean_algebra (finset pos))) : rank_condition (boolean_algebra (finset pos)) := sorry --non-trivial
lemma new_lemma_133997 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @topological_space.separable_space.{0} (linear_ordered_field.{0} ennreal) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (linear_ordered_field.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_133998 (h0 : function.extfun Type list) : palindrome (function.extfun_app h0 (simple_graph empty)) := sorry --non-trivial
lemma new_lemma_133999 (h1 : topological_space (denumerable (random_gen to_additive.value_type))) : totally_disconnected_space (denumerable (random_gen to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_134000 (h0 : topological_space (boolean_algebra (has_Inf Type))) : irreducible_space (boolean_algebra (has_Inf Type)) := sorry --non-trivial
lemma new_lemma_134001 (h0 : string_imp -> string_imp -> string_imp) : is_right_cancel string_imp h0 := sorry --non-trivial
lemma new_lemma_134002 (h0 : complete_lattice (comm_semigroup linarith.comp)) : is_compactly_generated (comm_semigroup linarith.comp) := sorry --non-trivial
lemma new_lemma_134003 (h0 : complete_lattice (has_add (has_nndist ennreal))) : is_compactly_generated (has_add (has_nndist ennreal)) := sorry --non-trivial
lemma new_lemma_134004 (h0 : topological_space (has_neg (has_add environment.implicit_infer_kind))) : preirreducible_space (has_neg (has_add environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_134005 (h0 : functor.add_const Prop congr_arg_kind) : functor.add_const.run h0 := sorry --non-trivial
lemma new_lemma_134006 (h0 : monoid (add_right_cancel_monoid (has_top empty))) : monoid.fg (add_right_cancel_monoid (has_top empty)) := sorry --non-trivial
lemma new_lemma_134007 (h0 : function.extfun (Type 1) topological_space) : @preirreducible_space.{1} (canonically_ordered_comm_semiring.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} h0 (canonically_ordered_comm_semiring.{1} Type))  := sorry --non-trivial
lemma new_lemma_134008 (h0 : ordered_add_comm_monoid (generalized_boolean_algebra (has_add linarith.comp))) : archimedean (generalized_boolean_algebra (has_add linarith.comp)) := sorry --non-trivial
lemma new_lemma_134009 (h0 : complete_lattice (has_top (semiring (semiring congr_arg_kind)))) : is_compactly_generated (has_top (semiring (semiring congr_arg_kind))) := sorry --non-trivial
lemma new_lemma_134010 (h0 : functor.add_const (topological_space (comm_group environment.implicit_infer_kind)) environment.implicit_infer_kind) : @regular_space.{0} (comm_group.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (comm_group.{0} environment.implicit_infer_kind)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_134011 (h0 : cancel_comm_monoid_with_zero (boolean_algebra.core (has_to_string Type))) : unique_factorization_monoid (boolean_algebra.core (has_to_string Type)) := sorry --non-trivial
lemma new_lemma_134012 (h0 : monoid (linear_ordered_add_comm_group linarith.comp_source)) : monoid.fg (linear_ordered_add_comm_group linarith.comp_source) := sorry --non-trivial
lemma new_lemma_134013 (h0 : function.extfun Type group) : @group.fg.{0} (has_neg_part.{0} ennreal) (@function.extfun_app.{2 1} Type group.{0} h0 (has_neg_part.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_134014 (h0 : function.extfun (finset (Type -> Type)) (has_mem.mem topological_space)) : @t0_space.{0} congr_arg_kind (@function.extfun_app.{2 1} Type topological_space.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) topological_space.{0} (@function.extfun_app.{2 0} (finset.{1} (Type → Type)) (@has_mem.mem.{1 1} (Type → Type) (finset.{1} (Type → Type)) (@finset.has_mem.{1} (Type → Type)) topological_space.{0}) h0 (@has_emptyc.emptyc.{1} (finset.{1} (Type → Type)) (@finset.has_emptyc.{1} (Type → Type))))) congr_arg_kind)  := sorry --non-trivial
lemma new_lemma_134015 (h0 : ring (left_cancel_monoid congr_arg_kind)) : strong_rank_condition (left_cancel_monoid congr_arg_kind) := sorry --non-trivial
lemma new_lemma_134016 (h0 : not (function.extfun Type add_monoid -> false)) : @add_monoid.fg.{0} (has_norm.{0} linarith.comp) (@function.extfun_app.{2 1} Type add_monoid.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type add_monoid.{0}) h0) (has_norm.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_134017 (h0 : ring (has_add linarith.comp)) : is_principal_ideal_ring (has_add linarith.comp) := sorry --non-trivial
lemma new_lemma_134018 (h0 : functor.add_const (topological_space (has_star unsigned)) unsigned) : @totally_disconnected_space.{0} (has_star.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (has_star.{0} unsigned)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_134019 (h0 : ring (boolean_algebra.core (has_add (add_comm_monoid environment.implicit_infer_kind)))) : rank_condition (boolean_algebra.core (has_add (add_comm_monoid environment.implicit_infer_kind))) := sorry --non-trivial
lemma new_lemma_134020 (h0 : functor.add_const (group (ring name)) linarith.comp) : @normalizer_condition.{0} (ring.{0} name) (@functor.add_const.run.{0 0} (group.{0} (ring.{0} name)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_134021 (h0 : function.extfun (finset Type) (has_mem.mem (normed_group congr_arg_kind))) : @totally_separated_space.{0} (normed_group.{0} congr_arg_kind) (@finset.pi.empty.{1 0} Type topological_space.{0} (normed_group.{0} congr_arg_kind) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (normed_group.{0} congr_arg_kind)) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_134022 (h0 : functor.add_const (filter auto.case_option) empty) : filter.ne_bot (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_134023 (h0 : uniform_space (comm_group (finset pos))) : complete_space (comm_group (finset pos)) := sorry --non-trivial
lemma new_lemma_134024 (h0 : ring (has_one (semiring (semiring congr_arg_kind)))) : strong_rank_condition (has_one (semiring (semiring congr_arg_kind))) := sorry --non-trivial
lemma new_lemma_134025 (h0 : not (ring (random_gen linarith.ineq) -> false)) : @is_domain.{0} (random_gen.{0} linarith.ineq) (@classical.by_contradiction'.{1} (ring.{0} (random_gen.{0} linarith.ineq)) h0)  := sorry --non-trivial
lemma new_lemma_134026 (h0 : ring (has_add (has_nnnorm linarith.comp_source))) : is_domain (has_add (has_nnnorm linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_134027 (h0 : ring (has_compl (mul_one_class string_imp))) : is_domain (has_compl (mul_one_class string_imp)) := sorry --non-trivial
lemma new_lemma_134028 (h0 : fin has_zero.zero) : @preirreducible_space.{0} (ordered_comm_ring.{0} real) (@matrix.vec_empty.{0} (topological_space.{0} (ordered_comm_ring.{0} real)) h0)  := sorry --non-trivial
lemma new_lemma_134029 (h0 : topological_space (boolean_algebra.core pos)) : preirreducible_space (boolean_algebra.core pos) := sorry --non-trivial
lemma new_lemma_134030 (h0 : add_group (comm_group (finset Type))) : is_add_cyclic (comm_group (finset Type)) := sorry --non-trivial
lemma new_lemma_134031 (h0 : topological_space (with_one fun_info)) : path_connected_space (with_one fun_info) := sorry --non-trivial
lemma new_lemma_134032 (h0 : complete_lattice (uniform_space linarith.ineq)) : complete_lattice.is_Sup_finite_compact (uniform_space linarith.ineq) := sorry --non-trivial
lemma new_lemma_134033 (h0 : complete_lattice (add_cancel_comm_monoid (random_gen string.iterator_imp))) : complete_lattice.is_Sup_finite_compact (add_cancel_comm_monoid (random_gen string.iterator_imp)) := sorry --non-trivial
lemma new_lemma_134034 (h0 : not (prod (metric_space unsigned) (metric_space unsigned) -> false)) : id_rel (classical.by_contradiction' h0) := sorry --non-trivial
lemma new_lemma_134035 (h0 : ring (mul_zero_class num)) : rank_condition (mul_zero_class num) := sorry --non-trivial
lemma new_lemma_134036 (h0 : ring (has_pos_part (has_add (has_add real)))) : is_domain (has_pos_part (has_add (has_add real))) := sorry --non-trivial
lemma new_lemma_134037 (h0 : function.extfun Type finset) : finset.nonempty (function.extfun_app h0 (boolean_algebra name)) := sorry --non-trivial
lemma new_lemma_134038 (h0 : complete_lattice (has_norm (random_gen to_additive.value_type))) : is_compactly_generated (has_norm (random_gen to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_134039 (h0 : semiring (simple_graph (has_add (has_add pos)))) : is_noetherian_ring (simple_graph (has_add (has_add pos))) := sorry --non-trivial
lemma new_lemma_134040 (h0 : functor.add_const (cancel_comm_monoid_with_zero (add_left_cancel_semigroup empty)) empty) : @unique_factorization_monoid.{0} (add_left_cancel_semigroup.{0} empty) (@functor.add_const.run.{0 0} (cancel_comm_monoid_with_zero.{0} (add_left_cancel_semigroup.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_134041 (h1 : topological_space (with_one to_additive.value_type)) : totally_disconnected_space (with_one to_additive.value_type) := sorry --non-trivial
lemma new_lemma_134042 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @topological_space.separable_space.{0} (ring.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (ring.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_134043 (h0 : topological_space (has_nndist (comm_group (comm_group (comm_group (comm_group unsigned)))))) : totally_disconnected_space (has_nndist (comm_group (comm_group (comm_group (comm_group unsigned))))) := sorry --non-trivial
lemma new_lemma_134044 (h0 : topological_space (has_nndist (comm_group (comm_group pos)))) : loc_path_connected_space (has_nndist (comm_group (comm_group pos))) := sorry --non-trivial
lemma new_lemma_134045 (h0 : functor.add_const (ring (left_cancel_semigroup unsigned)) empty) : @rank_condition.{0} (left_cancel_semigroup.{0} unsigned) (@functor.add_const.run.{0 0} (ring.{0} (left_cancel_semigroup.{0} unsigned)) empty h0)  := sorry --non-trivial
lemma new_lemma_134046 (h0 : group (distrib (has_inv (has_nnnorm string_imp)))) : is_cyclic (distrib (has_inv (has_nnnorm string_imp))) := sorry --non-trivial
lemma new_lemma_134047 (h0 : ring (normed_comm_ring (finset num))) : is_domain (normed_comm_ring (finset num)) := sorry --non-trivial
lemma new_lemma_134048 (h0 : function.extfun Type ring) : @is_domain.{0} (has_norm.{0} fun_info) (@function.extfun_app.{2 1} Type ring.{0} h0 (has_norm.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_134049 (h0 : functor.add_const (uniform_space (has_pos_part linarith.comp)) pos) : @complete_space.{0} (has_pos_part.{0} linarith.comp) (@functor.add_const.run.{0 0} (uniform_space.{0} (has_pos_part.{0} linarith.comp)) pos h0)  := sorry --non-trivial
lemma new_lemma_134050 (h0 : group (with_bot (random_gen num))) : normalizer_condition (with_bot (random_gen num)) := sorry --non-trivial
lemma new_lemma_134051 (h0 : functor.add_const (topological_space (semigroup Type)) (has_neg linarith.comp)) : @preconnected_space.{1} (semigroup.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (semigroup.{1} Type)) (has_neg.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_134052 (h0 : functor.add_const (functor.add_const (monoid Type) linarith.comp) pos) : @monoid.fg.{1} Type (@functor.add_const.run.{1 0} (monoid.{1} Type) linarith.comp (@functor.add_const.run.{1 0} (functor.add_const.{1 0} (monoid.{1} Type) linarith.comp) pos h0))  := sorry --non-trivial
lemma new_lemma_134053 (h0 : ring (semigroup num)) : rank_condition (semigroup num) := sorry --non-trivial
lemma new_lemma_134054 (h0 : topological_space (linear_ordered_semiring (random_gen (random_gen num)))) : totally_disconnected_space (linear_ordered_semiring (random_gen (random_gen num))) := sorry --non-trivial
lemma new_lemma_134055 (h0 : add_monoid (ordered_comm_ring (has_Inf linarith.comp))) : add_monoid.fg (ordered_comm_ring (has_Inf linarith.comp)) := sorry --non-trivial
lemma new_lemma_134056 (h0 : set (linarith.ineq -> add_comm_semigroup string.iterator_imp)) : set.separates_points h0 := sorry --non-trivial
lemma new_lemma_134057 (h0 : uniform_space (has_star (semiring (semiring (semiring (semiring num)))))) : complete_space (has_star (semiring (semiring (semiring (semiring num))))) := sorry --non-trivial
lemma new_lemma_134058 (h0 : functor.add_const (group (ring Type)) (has_neg Type)) : @group.fg.{1} (ring.{1} Type) (@functor.add_const.run.{1 1} (group.{1} (ring.{1} Type)) (has_neg.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_134059 (h0 : functor.add_const (functor.add_const (topological_space Type) pos) linarith.comp) : @t0_space.{1} Type (@functor.add_const.run.{1 0} (topological_space.{1} Type) pos (@functor.add_const.run.{1 0} (functor.add_const.{1 0} (topological_space.{1} Type) pos) linarith.comp h0))  := sorry --non-trivial
lemma new_lemma_134060 (h0 : functor.add_const (topological_space (has_add unsigned)) ennreal) : @path_connected_space.{0} (has_add.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (has_add.{0} unsigned)) ennreal h0)  := sorry --non-trivial
lemma new_lemma_134061 (h0 : fin has_zero.zero) : @separated_space.{0} (has_one.{0} unsigned) (@matrix.vec_empty.{0} (uniform_space.{0} (has_one.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_134062 (h0 : not (ring (with_one char) -> false)) : @strong_rank_condition.{0} (with_one.{0} char) (@classical.by_contradiction'.{1} (ring.{0} (with_one.{0} char)) h0)  := sorry --non-trivial
lemma new_lemma_134063 (h0 : filter (add_comm_monoid Type)) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_134064 (h0 : function.extfun Type topological_space) : @t1_space.{0} (measurable_space.dynkin_system.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (measurable_space.dynkin_system.{0} num))  := sorry --non-trivial
lemma new_lemma_134065 (h0 : ring (has_pos_part (has_pos_part (has_neg linarith.comp)))) : strong_rank_condition (has_pos_part (has_pos_part (has_neg linarith.comp))) := sorry --non-trivial
lemma new_lemma_134066 (h0 : filter (has_to_string (has_pos_part pos))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_134067 (h0 : functor.add_const (list (has_zero Type)) (has_neg name)) : palindrome (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_134068 (h0 : topological_space (has_pos_part (ring Type))) : totally_disconnected_space (has_pos_part (ring Type)) := sorry --non-trivial
lemma new_lemma_134069 (h0 : topological_space (monoid empty)) : t1_space (monoid empty) := sorry --non-trivial
lemma new_lemma_134070 (h0 : function.extfun Type (functor.add_const (ordered_add_comm_monoid linarith.comp))) : @archimedean.{0} linarith.comp (@functor.add_const.run.{0 0} (ordered_add_comm_monoid.{0} linarith.comp) linarith.comp (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (ordered_add_comm_monoid.{0} linarith.comp)) h0 linarith.comp))  := sorry --non-trivial
lemma new_lemma_134071 (h0 : ring (has_compl ereal)) : strong_rank_condition (has_compl ereal) := sorry --non-trivial
lemma new_lemma_134072 (h0 : add_group (distrib_lattice (add_right_cancel_monoid to_additive.value_type))) : is_add_cyclic (distrib_lattice (add_right_cancel_monoid to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_134073 (h0 : functor.add_const (ordered_add_comm_monoid (boolean_algebra pos)) pos) : @archimedean.{0} (boolean_algebra.{0} pos) (@functor.add_const.run.{0 0} (ordered_add_comm_monoid.{0} (boolean_algebra.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_134074 (h0 : topological_space (has_ssubset (has_ssubset (has_ssubset fun_info)))) : t0_space (has_ssubset (has_ssubset (has_ssubset fun_info))) := sorry --non-trivial
lemma new_lemma_134075 (h0 : functor.add_const (functor.comp topological_space canonically_ordered_comm_semiring name) name) : @topological_space.separable_space.{0} (canonically_ordered_comm_semiring.{0} name) (@functor.comp.run.{0 0 0} topological_space.{0} canonically_ordered_comm_semiring.{0} name (@functor.add_const.run.{0 0} (functor.comp.{0 0 0} topological_space.{0} canonically_ordered_comm_semiring.{0} name) name h0))  := sorry --non-trivial
lemma new_lemma_134076 (h0 : topological_space (encodable string_imp)) : irreducible_space (encodable string_imp) := sorry --non-trivial
lemma new_lemma_134077 (h0 : topological_space (normed_comm_ring (has_neg_part (has_to_string (has_to_string unsigned))))) : loc_path_connected_space (normed_comm_ring (has_neg_part (has_to_string (has_to_string unsigned)))) := sorry --non-trivial
lemma new_lemma_134078 (h0 : ring (has_neg (finset (finset pos)))) : is_principal_ideal_ring (has_neg (finset (finset pos))) := sorry --non-trivial
lemma new_lemma_134079 (h0 : function.extfun Type ring) : @is_domain.{0} (filter.{0} num) (@function.extfun_app.{2 1} Type ring.{0} h0 (filter.{0} num))  := sorry --non-trivial
lemma new_lemma_134080 (h0 : topological_space (boolean_algebra (semigroup pos))) : locally_compact_space (boolean_algebra (semigroup pos)) := sorry --non-trivial
lemma new_lemma_134081 (h0 : complete_lattice (boolean_algebra.core (add_cancel_monoid (measurable_space name)))) : is_atomistic (boolean_algebra.core (add_cancel_monoid (measurable_space name))) := sorry --non-trivial
lemma new_lemma_134082 (h0 : topological_space (complete_semilattice_Sup (has_ssubset to_additive.value_type))) : t0_space (complete_semilattice_Sup (has_ssubset to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_134083 (h0 : topological_space (has_add environment.implicit_infer_kind)) : path_connected_space (has_add environment.implicit_infer_kind) := sorry --non-trivial
lemma new_lemma_134084 (h0 : with_one (has_inv (random_gen (random_gen (random_gen linarith.comp_source)))) -> Prop) : Exists h0 := sorry --non-trivial
lemma new_lemma_134085 (h0 : function.extfun ((Type -> Type) -> Type 1) (function.extfun (Type -> Type))) : @locally_compact_space.{0} (random_gen.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) (@function.extfun_app.{3 2} ((Type → Type) → Type 1) (function.extfun.{2 2} (Type → Type)) h0 (function.extfun.{2 1} Type)) topological_space.{0}) (random_gen.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_134086 (h0 : ring (cancel_monoid (has_add name))) : rank_condition (cancel_monoid (has_add name)) := sorry --non-trivial
lemma new_lemma_134087 (h0 : add_group (has_zero (has_to_string pos))) : is_add_cyclic (has_zero (has_to_string pos)) := sorry --non-trivial
lemma new_lemma_134088 (h1 : functor.comp ring linear_ordered_comm_group_with_zero linarith.ineq) : @strong_rank_condition.{0} (linear_ordered_comm_group_with_zero.{0} linarith.ineq) (@functor.comp.run.{0 0 0} ring.{0} linear_ordered_comm_group_with_zero.{0} linarith.ineq h1)  := sorry --non-trivial
lemma new_lemma_134089 (h0 : not (group (normed_field to_additive.value_type) -> false)) : @is_cyclic.{0} (normed_field.{0} to_additive.value_type) (@classical.by_contradiction'.{1} (group.{0} (normed_field.{0} to_additive.value_type)) h0)  := sorry --non-trivial
lemma new_lemma_134090 (h0 : functor.add_const (functor.add_const (group Type) Type) linarith.comp) : @is_cyclic.{1} Type (@functor.add_const.run.{1 1} (group.{1} Type) Type (@functor.add_const.run.{1 0} (functor.add_const.{1 1} (group.{1} Type) Type) linarith.comp h0))  := sorry --non-trivial
lemma new_lemma_134091 (h0 : not (uniform_space (distrib (random_gen linarith.ineq)) -> false)) : @complete_space.{0} (distrib.{0} (random_gen.{0} linarith.ineq)) (@classical.by_contradiction'.{1} (uniform_space.{0} (distrib.{0} (random_gen.{0} linarith.ineq))) h0)  := sorry --non-trivial
lemma new_lemma_134092 (h0 : topological_space (with_one (has_top linarith.ineq))) : t0_space (with_one (has_top linarith.ineq)) := sorry --non-trivial
lemma new_lemma_134093 (h2 : add_group (has_top linarith.comp_source)) : is_add_cyclic (has_top linarith.comp_source) := sorry --non-trivial
lemma new_lemma_134094 (h0 : function.extfun nat fin) : @is_noetherian_ring.{0} (boolean_algebra.core.{0} name) (@matrix.vec_empty.{0} (semiring.{0} (boolean_algebra.core.{0} name)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_134095 (h0 : not (function.extfun Type uniform_space -> false)) : @complete_space.{0} (random_gen.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type uniform_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type uniform_space.{0}) h0) (random_gen.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_134096 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @normal_space.{0} (canonically_linear_ordered_monoid.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (canonically_linear_ordered_monoid.{0} pos))  := sorry --non-trivial
lemma new_lemma_134097 (h0 : uniform_space (pseudo_metric_space (finset name))) : separated_space (pseudo_metric_space (finset name)) := sorry --non-trivial
lemma new_lemma_134098 (h0 : functor.add_const (complete_lattice (has_neg_part pos)) (option pos)) : @complete_lattice.is_Sup_finite_compact.{0} (has_neg_part.{0} pos) (@functor.add_const.run.{0 0} (complete_lattice.{0} (has_neg_part.{0} pos)) (option.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_134099 (h0 : function.extfun Type topological_space) : @topological_space.separable_space.{0} (cancel_monoid.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (cancel_monoid.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_134100 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @preconnected_space.{0} (has_add.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_add.{0} pos))  := sorry --non-trivial
lemma new_lemma_134101 (h0 : ordered_comm_monoid (option (has_add pos))) : has_exists_mul_of_le (option (has_add pos)) := sorry --non-trivial
lemma new_lemma_134102 (h0 : topological_space (ordered_comm_monoid (has_Inf linarith.comp))) : irreducible_space (ordered_comm_monoid (has_Inf linarith.comp)) := sorry --non-trivial
lemma new_lemma_134103 (h3 : set (ereal -> enat)) : set.separates_points h3 := sorry --non-trivial
lemma new_lemma_134104 (h0 : function.extfun Type uniform_space) : @separated_space.{0} (ordered_cancel_add_comm_monoid.{0} name) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (ordered_cancel_add_comm_monoid.{0} name))  := sorry --non-trivial
lemma new_lemma_134105 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_add_cyclic.{0} (finset.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type add_group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 add_group.{0}) (finset.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_134106 (h0 : functor.add_const (topological_space (complete_distrib_lattice environment.implicit_infer_kind)) linarith.comp) : @totally_separated_space.{0} (complete_distrib_lattice.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (complete_distrib_lattice.{0} environment.implicit_infer_kind)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_134107 (h0 : complete_lattice (has_top (semiring linarith.comp))) : is_atomistic (has_top (semiring linarith.comp)) := sorry --non-trivial
lemma new_lemma_134108 (h0 : group (normed_comm_ring (finset (has_nndist Type)))) : group.fg (normed_comm_ring (finset (has_nndist Type))) := sorry --non-trivial
lemma new_lemma_134109 (h0 : functor.add_const (topological_space (left_cancel_monoid num)) num) : @preirreducible_space.{0} (left_cancel_monoid.{0} num) (@functor.add_const.run.{0 0} (topological_space.{0} (left_cancel_monoid.{0} num)) num h0)  := sorry --non-trivial
lemma new_lemma_134110 (h3 : ring (has_append to_additive.value_type)) : is_domain (has_append to_additive.value_type) := sorry --non-trivial
lemma new_lemma_134111 (h0 : function.extfun Type ring) : @rank_condition.{0} (uniform_space.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type ring.{0} h0 (uniform_space.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_134112 (h1 : has_lt (distrib std_gen)) : no_max_order (distrib std_gen) := sorry --non-trivial
lemma new_lemma_134113 (h0 : topological_space (random_gen (random_gen (has_top (has_top fun_info))))) : path_connected_space (random_gen (random_gen (has_top (has_top fun_info)))) := sorry --non-trivial
lemma new_lemma_134114 (h0 : functor.add_const (complete_lattice (cancel_monoid linarith.comp)) name) : @is_atomistic.{0} (cancel_monoid.{0} linarith.comp) (@functor.add_const.run.{0 0} (complete_lattice.{0} (cancel_monoid.{0} linarith.comp)) name h0)  := sorry --non-trivial
lemma new_lemma_134115 (h0 : complete_lattice (simple_graph (ring linarith.comp))) : is_compactly_generated (simple_graph (ring linarith.comp)) := sorry --non-trivial
lemma new_lemma_134116 (h0 : not (ring (has_inv to_additive.value_type) -> false)) : @is_domain.{0} (has_inv.{0} to_additive.value_type) (@classical.by_contradiction'.{1} (ring.{0} (has_inv.{0} to_additive.value_type)) h0)  := sorry --non-trivial
lemma new_lemma_134117 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @unique_factorization_monoid.{0} (boolean_algebra.core.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type cancel_comm_monoid_with_zero.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 cancel_comm_monoid_with_zero.{0}) (boolean_algebra.core.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_134118 (h0 : topological_space (generalized_boolean_algebra (ring Type))) : preconnected_space (generalized_boolean_algebra (ring Type)) := sorry --non-trivial
lemma new_lemma_134119 (h0 : function.extfun Type complete_lattice) : @complete_lattice.is_Sup_finite_compact.{0} (semigroup.{0} (semiring.{0} empty)) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (semigroup.{0} (semiring.{0} empty)))  := sorry --non-trivial
lemma new_lemma_134120 (h0 : not (topological_space (metric_space num) -> false)) : @topological_space.separable_space.{0} (metric_space.{0} num) (@classical.by_contradiction'.{1} (topological_space.{0} (metric_space.{0} num)) h0)  := sorry --non-trivial
lemma new_lemma_134121 (h0 : list (pseudo_metric_space (option (option ennreal)))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_134122 (h0 : complete_lattice (topological_space (random_gen string_imp))) : is_compactly_generated (topological_space (random_gen string_imp)) := sorry --non-trivial
lemma new_lemma_134123 (h0 : ring (distrib linarith.comp_source)) : strong_rank_condition (distrib linarith.comp_source) := sorry --non-trivial
lemma new_lemma_134124 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @t0_space.{0} (@id.{2} Type linarith.ineq) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (@id.{2} Type linarith.ineq))  := sorry --non-trivial
lemma new_lemma_134125 (h2 : ring (mul_one_class std_gen)) : strong_rank_condition (mul_one_class std_gen) := sorry --non-trivial
lemma new_lemma_134126 (h0 : ring (comm_ring enat)) : rank_condition (comm_ring enat) := sorry --non-trivial
lemma new_lemma_134127 (h0 : ring (has_to_string (option (option ennreal)))) : strong_rank_condition (has_to_string (option (option ennreal))) := sorry --non-trivial
lemma new_lemma_134128 (h0 : functor.add_const (monoid (is_R_or_C empty)) empty) : @monoid.fg.{0} (is_R_or_C.{0} empty) (@functor.add_const.run.{0 0} (monoid.{0} (is_R_or_C.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_134129 (h0 : ring (dlist (random_gen (random_gen (random_gen fun_info))))) : is_domain (dlist (random_gen (random_gen (random_gen fun_info)))) := sorry --non-trivial
lemma new_lemma_134130 (h0 : uniform_space (with_one (measurable_space (has_norm empty)))) : complete_space (with_one (measurable_space (has_norm empty))) := sorry --non-trivial
lemma new_lemma_134131 (h0 : topological_space (canonically_ordered_comm_semiring (has_add ennreal))) : regular_space (canonically_ordered_comm_semiring (has_add ennreal)) := sorry --non-trivial
lemma new_lemma_134132 (h0 : uniform_space (non_unital_non_assoc_semiring (metric_space linarith.comp_source))) : complete_space (non_unital_non_assoc_semiring (metric_space linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_134133 (h0 : uniform_space (has_nndist (has_dist empty))) : separated_space (has_nndist (has_dist empty)) := sorry --non-trivial
lemma new_lemma_134134 (h0 : topological_space (plift (option unsigned))) : normal_space (plift (option unsigned)) := sorry --non-trivial
lemma new_lemma_134135 (h0 : functor.add_const (group (linear_order empty)) (option (option unsigned))) : @normalizer_condition.{0} (linear_order.{0} empty) (@functor.add_const.run.{0 0} (group.{0} (linear_order.{0} empty)) (option.{0} (option.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_134136 (h0 : group (boolean_algebra name)) : normalizer_condition (boolean_algebra name) := sorry --non-trivial
lemma new_lemma_134137 (h0 : topological_space (has_nnnorm (random_gen fun_info))) : locally_compact_space (has_nnnorm (random_gen fun_info)) := sorry --non-trivial
lemma new_lemma_134138 (h0 : topological_space (linear_ordered_comm_ring (semiring empty))) : irreducible_space (linear_ordered_comm_ring (semiring empty)) := sorry --non-trivial
lemma new_lemma_134139 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @archimedean.{1} (plift.{1} congr_arg_kind) (@function.extfun_app.{3 2} (Type 1) ordered_add_comm_monoid.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 ordered_add_comm_monoid.{1}) (plift.{1} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_134140 (h0 : topological_space (has_lt (has_ssubset (has_lt (normed_field to_additive.value_type))))) : path_connected_space (has_lt (has_ssubset (has_lt (normed_field to_additive.value_type)))) := sorry --non-trivial
lemma new_lemma_134141 (h0 : functor.add_const (topological_space (has_add environment.implicit_infer_kind)) name) : @irreducible_space.{0} (has_add.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (has_add.{0} environment.implicit_infer_kind)) name h0)  := sorry --non-trivial
lemma new_lemma_134142 (h0 : functor.add_const (ordered_comm_monoid (add_cancel_monoid linarith.comp)) (has_neg linarith.comp)) : @has_exists_mul_of_le.{0} (add_cancel_monoid.{0} linarith.comp) (@functor.add_const.run.{0 0} (ordered_comm_monoid.{0} (add_cancel_monoid.{0} linarith.comp)) (has_neg.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_134143 (h0 : ring (add_comm_semigroup (mul_one_class (add_comm_semigroup enat)))) : rank_condition (add_comm_semigroup (mul_one_class (add_comm_semigroup enat))) := sorry --non-trivial
lemma new_lemma_134144 (h0 : add_monoid (ordered_comm_ring (has_pos_part pos))) : add_monoid.fg (ordered_comm_ring (has_pos_part pos)) := sorry --non-trivial
lemma new_lemma_134145 (h0 : monoid (with_bot (has_norm linarith.comp_source))) : monoid.fg (with_bot (has_norm linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_134146 (h0 : complete_lattice (normed_comm_ring (has_pos_part (ring linarith.comp)))) : complete_lattice.is_Sup_finite_compact (normed_comm_ring (has_pos_part (ring linarith.comp))) := sorry --non-trivial
lemma new_lemma_134147 (h0 : group (monoid (option empty))) : is_cyclic (monoid (option empty)) := sorry --non-trivial
lemma new_lemma_134148 (h0 : functor.add_const (topological_space (has_nndist name)) unsigned) : @discrete_topology.{0} (has_nndist.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (has_nndist.{0} name)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_134149 (h0 : group (with_bot (has_top (has_top (has_top num))))) : is_cyclic (with_bot (has_top (has_top (has_top num)))) := sorry --non-trivial
lemma new_lemma_134150 (h0 : comm_semiring (has_ssubset std_gen)) (h1 : semiring to_additive.value_type) (h2 : topological_space (algebra (has_ssubset std_gen) to_additive.value_type)) : totally_disconnected_space (algebra (has_ssubset std_gen) to_additive.value_type) := sorry --non-trivial
lemma new_lemma_134151 (h0 : functor.add_const (function.extfun Type semiring) name) : @is_noetherian_ring.{0} (has_add.{0} name) (@function.extfun_app.{2 1} Type semiring.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type semiring.{0}) name h0) (has_add.{0} name))  := sorry --non-trivial
lemma new_lemma_134152 (h0 : add_monoid (semiring empty)) : add_monoid.fg (semiring empty) := sorry --non-trivial
lemma new_lemma_134153 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @strong_rank_condition.{0} nnreal (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) nnreal)  := sorry --non-trivial
lemma new_lemma_134154 (h0 : functor.add_const (function.extfun (Type 1) finset) Type) : finset.nonempty (function.extfun_app (functor.add_const.run h0) (boolean_algebra Type)) := sorry --non-trivial
lemma new_lemma_134155 (h0 : thunk (filter Prop)) : @Lim.{0} Prop sierpinski_space (@nonempty_of_inhabited.{1} Prop sort.inhabited.{0}) (@trace_call_stack.{0} (filter.{0} Prop) h0)  := sorry --non-trivial
lemma new_lemma_134156 (h0 : function.extfun (Type 1) group) : @normalizer_condition.{1} (boolean_algebra.{1} Type) (@function.extfun_app.{3 2} (Type 1) group.{1} h0 (boolean_algebra.{1} Type))  := sorry --non-trivial
lemma new_lemma_134157 (h0 : group (linear_ordered_semiring (semiring (semiring (semiring (semiring empty)))))) : is_cyclic (linear_ordered_semiring (semiring (semiring (semiring (semiring empty))))) := sorry --non-trivial
lemma new_lemma_134158 (h0 : complete_lattice (random_gen (has_inv to_additive.value_type))) : complete_lattice.is_Sup_finite_compact (random_gen (has_inv to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_134159 (h0 : monoid (has_to_string (has_nndist (add_right_cancel_monoid (ring Type))))) : monoid.fg (has_to_string (has_nndist (add_right_cancel_monoid (ring Type)))) := sorry --non-trivial
lemma new_lemma_134160 (h0 : semiring (comm_group (has_neg (has_neg_part Type)))) : is_noetherian_ring (comm_group (has_neg (has_neg_part Type))) := sorry --non-trivial
lemma new_lemma_134161 (h0 : topological_space (random_gen (random_gen (with_bot (with_bot (random_gen fun_info)))))) : locally_compact_space (random_gen (random_gen (with_bot (with_bot (random_gen fun_info))))) := sorry --non-trivial
lemma new_lemma_134162 (h0 : add_group (has_append (ordered_cancel_comm_monoid char))) : is_add_cyclic (has_append (ordered_cancel_comm_monoid char)) := sorry --non-trivial
lemma new_lemma_134163 (h0 : function.extfun Type complete_lattice) : @is_compactly_generated.{0} (with_one.{0} (has_top.{0} (has_top.{0} (has_top.{0} (has_top.{0} (has_top.{0} congr_arg_kind)))))) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (with_one.{0} (has_top.{0} (has_top.{0} (has_top.{0} (has_top.{0} (has_top.{0} congr_arg_kind)))))))  := sorry --non-trivial
lemma new_lemma_134164 (h0 : add_monoid (linear_ordered_cancel_comm_monoid (option unsigned))) : add_monoid.fg (linear_ordered_cancel_comm_monoid (option unsigned)) := sorry --non-trivial
lemma new_lemma_134165 (h0 : ring (has_inter unsigned)) : is_domain (has_inter unsigned) := sorry --non-trivial
lemma new_lemma_134166 (h0 : complete_lattice (has_lt (has_nnnorm (mul_one_class char)))) : complete_lattice.is_Sup_finite_compact (has_lt (has_nnnorm (mul_one_class char))) := sorry --non-trivial
lemma new_lemma_134167 (h0 : monoid (left_cancel_monoid (semiring num))) : monoid.fg (left_cancel_monoid (semiring num)) := sorry --non-trivial
lemma new_lemma_134168 (h0 : not (topological_space (denumerable linarith.comp) -> false)) : @totally_disconnected_space.{0} (denumerable.{0} linarith.comp) (@classical.by_contradiction'.{1} (topological_space.{0} (denumerable.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_134169 (h0 : not (uniform_space (random_gen num) -> false)) : @complete_space.{0} (random_gen.{0} num) (@classical.by_contradiction'.{1} (uniform_space.{0} (random_gen.{0} num)) h0)  := sorry --non-trivial
lemma new_lemma_134170 (h0 : ring (normed_comm_ring (has_add (boolean_algebra.core (has_add Type))))) : is_principal_ideal_ring (normed_comm_ring (has_add (boolean_algebra.core (has_add Type)))) := sorry --non-trivial
lemma new_lemma_134171 (h0 : functor.add_const (complete_lattice (has_to_string Type)) linarith.comp) : @complete_lattice.is_Sup_finite_compact.{1} (has_to_string.{1} Type) (@functor.add_const.run.{1 0} (complete_lattice.{1} (has_to_string.{1} Type)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_134172 (h0 : monoid (has_top (has_top fun_info))) : monoid.fg (has_top (has_top fun_info)) := sorry --non-trivial
lemma new_lemma_134173 (h0 : ordered_comm_monoid (generalized_boolean_algebra (has_neg linarith.comp))) : has_exists_mul_of_le (generalized_boolean_algebra (has_neg linarith.comp)) := sorry --non-trivial
lemma new_lemma_134174 (h0 : functor.add_const (function.extfun Type topological_space) name) : @topological_space.separable_space.{0} (has_Inf.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) name h0) (has_Inf.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_134175 (h0 : not (has_mem.mem add_group has_emptyc.emptyc -> false)) : @add_group.fg.{0} (has_top.{0} num) (@function.extfun_app.{2 1} Type add_group.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) add_group.{0} (@classical.by_contradiction'.{0} (@has_mem.mem.{1 1} (Type → Type) (finset.{1} (Type → Type)) (@finset.has_mem.{1} (Type → Type)) add_group.{0} (@has_emptyc.emptyc.{1} (finset.{1} (Type → Type)) (@finset.has_emptyc.{1} (Type → Type)))) h0)) (has_top.{0} num))  := sorry --non-trivial
lemma new_lemma_134176 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @group.fg.{0} (has_to_string.{0} linarith.comp) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (has_to_string.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_134177 (h0 : topological_space (random_gen (semiring congr_arg_kind))) : locally_compact_space (random_gen (semiring congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_134178 (h0 : functor.add_const (topological_space (boolean_algebra pos)) name) : @totally_separated_space.{0} (boolean_algebra.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (boolean_algebra.{0} pos)) name h0)  := sorry --non-trivial
lemma new_lemma_134179 (h0 : ordered_comm_monoid (finset (has_Inf (has_Inf (has_nndist (has_Inf pos)))))) : has_exists_mul_of_le (finset (has_Inf (has_Inf (has_nndist (has_Inf pos))))) := sorry --non-trivial
lemma new_lemma_134180 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : finset.nonempty (function.extfun_app (function.extfun_app h0 finset) (preorder num)) := sorry --non-trivial
lemma new_lemma_134181 (h0 : group (has_neg_part name)) : normalizer_condition (has_neg_part name) := sorry --non-trivial
lemma new_lemma_134182 (h0 : not (has_mem.mem (with_bot num) has_emptyc.emptyc -> false)) : @separated_space.{0} (with_bot.{0} num) (@finset.pi.empty.{1 0} Type uniform_space.{0} (with_bot.{0} num) (@classical.by_contradiction'.{0} (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (with_bot.{0} num) (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))) h0))  := sorry --non-trivial
lemma new_lemma_134183 (h0 : uniform_space (semigroup (option (option pos)))) : complete_space (semigroup (option (option pos))) := sorry --non-trivial
lemma new_lemma_134184 (h0 : uniform_space (with_bot (with_bot string_imp))) : complete_space (with_bot (with_bot string_imp)) := sorry --non-trivial
lemma new_lemma_134185 (h0 : group (has_norm (has_norm fun_info))) : normalizer_condition (has_norm (has_norm fun_info)) := sorry --non-trivial
lemma new_lemma_134186 (h0 : group (simple_graph (finset (has_add pos)))) : is_cyclic (simple_graph (finset (has_add pos))) := sorry --non-trivial
lemma new_lemma_134187 (h0 : functor.add_const (complete_lattice (boolean_algebra Type)) (finset (finset Type))) : @is_compactly_generated.{1} (boolean_algebra.{1} Type) (@functor.add_const.run.{1 1} (complete_lattice.{1} (boolean_algebra.{1} Type)) (finset.{1} (finset.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_134188 (h0 : functor.add_const (topological_space (add_comm_monoid name)) name) : @totally_separated_space.{0} (add_comm_monoid.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (add_comm_monoid.{0} name)) name h0)  := sorry --non-trivial
lemma new_lemma_134189 (h0 : topological_space (has_Inf (has_add (has_add (has_neg (ring Type)))))) : irreducible_space (has_Inf (has_add (has_add (has_neg (ring Type))))) := sorry --non-trivial
lemma new_lemma_134190 (h0 : has_mem.mem topological_space has_emptyc.emptyc) : @path_connected_space.{0} (non_unital_non_assoc_ring.{0} fun_info) (@function.extfun_app.{2 1} Type topological_space.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) topological_space.{0} h0) (non_unital_non_assoc_ring.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_134191 (h0 : functor.add_const (topological_space (normed_comm_ring environment.implicit_infer_kind)) pos) : @regular_space.{0} (normed_comm_ring.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (normed_comm_ring.{0} environment.implicit_infer_kind)) pos h0)  := sorry --non-trivial
lemma new_lemma_134192 (h0 : functor.add_const (topological_space (boolean_algebra environment.implicit_infer_kind)) Type) : @irreducible_space.{0} (boolean_algebra.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 1} (topological_space.{0} (boolean_algebra.{0} environment.implicit_infer_kind)) Type h0)  := sorry --non-trivial
lemma new_lemma_134193 (h0 : functor.add_const (topological_space (has_to_string ordering)) pos) : @topological_space.separable_space.{0} (has_to_string.{0} ordering) (@functor.add_const.run.{0 0} (topological_space.{0} (has_to_string.{0} ordering)) pos h0)  := sorry --non-trivial
lemma new_lemma_134194 (h0 : set (distrib std_gen)) : set.subsingleton h0 := sorry --non-trivial
lemma new_lemma_134195 (h0 : not (function.extfun Type uniform_space -> false)) : @separated_space.{0} (semiring.{0} fun_info) (@function.extfun_app.{2 1} Type uniform_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type uniform_space.{0}) h0) (semiring.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_134196 (h0 : not (add_group (has_to_string string_imp) -> false)) : @is_add_cyclic.{0} (has_to_string.{0} string_imp) (@classical.by_contradiction'.{1} (add_group.{0} (has_to_string.{0} string_imp)) h0)  := sorry --non-trivial
lemma new_lemma_134197 (h0 : functor.add_const (function.extfun Type ring) environment.implicit_infer_kind) : @rank_condition.{0} (has_Inf.{0} pos) (@function.extfun_app.{2 1} Type ring.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type ring.{0}) environment.implicit_infer_kind h0) (has_Inf.{0} pos))  := sorry --non-trivial
lemma new_lemma_134198 (h0 : topological_space (ordered_comm_ring (has_add linarith.comp))) : t1_space (ordered_comm_ring (has_add linarith.comp)) := sorry --non-trivial
lemma new_lemma_134199 (h0 : functor.add_const (topological_space (normed_linear_ordered_group num)) empty) : @discrete_topology.{0} (normed_linear_ordered_group.{0} num) (@functor.add_const.run.{0 0} (topological_space.{0} (normed_linear_ordered_group.{0} num)) empty h0)  := sorry --non-trivial
lemma new_lemma_134200 (h0 : group (add_comm_monoid pos)) : is_simple_group (add_comm_monoid pos) := sorry --non-trivial
lemma new_lemma_134201 (h0 : group (has_pos_part pos)) : group.fg (has_pos_part pos) := sorry --non-trivial
lemma new_lemma_134202 (h0 : topological_space (normed_linear_ordered_group num)) : t1_space (normed_linear_ordered_group num) := sorry --non-trivial
lemma new_lemma_134203 (h0 : function.extfun Type topological_space) : @preconnected_space.{0} (add_cancel_monoid.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (add_cancel_monoid.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_134204 (h0 : topological_space (has_to_string (comm_group Type))) : sequential_space (has_to_string (comm_group Type)) := sorry --non-trivial
lemma new_lemma_134205 (h0 : not (topological_space (has_top num) -> false)) : @irreducible_space.{0} (has_top.{0} num) (@classical.by_contradiction'.{1} (topological_space.{0} (has_top.{0} num)) h0)  := sorry --non-trivial
lemma new_lemma_134206 (h0 : functor.add_const (ring (comm_group pos)) (has_add name)) : @rank_condition.{0} (comm_group.{0} pos) (@functor.add_const.run.{0 0} (ring.{0} (comm_group.{0} pos)) (has_add.{0} name) h0)  := sorry --non-trivial
lemma new_lemma_134207 (h0 : add_monoid (has_pos_part (has_bot Type))) : add_monoid.fg (has_pos_part (has_bot Type)) := sorry --non-trivial
lemma new_lemma_134208 (h0 : complete_lattice (normed_group (has_inv (has_inv (has_norm linarith.ineq))))) : is_atomistic (normed_group (has_inv (has_inv (has_norm linarith.ineq)))) := sorry --non-trivial
lemma new_lemma_134209 (h0 : function.extfun Type topological_space) : @t1_space.{0} (omega_complete_partial_order.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (omega_complete_partial_order.{0} empty))  := sorry --non-trivial
lemma new_lemma_134210 (h0 : not (function.extfun Type topological_space -> false)) : @totally_disconnected_space.{0} (@id.{2} Type linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (@id.{2} Type linarith.comp))  := sorry --non-trivial
lemma new_lemma_134211 (h0 : ordered_comm_monoid (add_comm_monoid (has_neg_part Type))) : has_exists_mul_of_le (add_comm_monoid (has_neg_part Type)) := sorry --non-trivial
lemma new_lemma_134212 (h0 : cancel_comm_monoid_with_zero (has_to_string (boolean_algebra.core (has_add pos)))) : unique_factorization_monoid (has_to_string (boolean_algebra.core (has_add pos))) := sorry --non-trivial
lemma new_lemma_134213 (h0 : function.extfun Type uniform_space) : @complete_space.{0} (complete_semilattice_Sup.{0} unsigned) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (complete_semilattice_Sup.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_134214 (h0 : function.extfun (Type 1) topological_space) : @t0_space.{1} (cancel_monoid.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} h0 (cancel_monoid.{1} Type))  := sorry --non-trivial
lemma new_lemma_134215 (h0 : function.extfun Type (functor.comp monoid has_neg)) : @monoid.fg.{0} (has_neg.{0} num) (@functor.comp.run.{0 0 0} monoid.{0} has_neg.{0} num (@function.extfun_app.{2 1} Type (functor.comp.{0 0 0} monoid.{0} has_neg.{0}) h0 num))  := sorry --non-trivial
lemma new_lemma_134216 (h0 : topological_space (measurable_space (has_norm (has_norm congr_arg_kind)))) : totally_separated_space (measurable_space (has_norm (has_norm congr_arg_kind))) := sorry --non-trivial
lemma new_lemma_134217 (h0 : functor.add_const (add_group (normed_comm_ring unsigned)) Type) : @is_add_cyclic.{0} (normed_comm_ring.{0} unsigned) (@functor.add_const.run.{0 1} (add_group.{0} (normed_comm_ring.{0} unsigned)) Type h0)  := sorry --non-trivial
lemma new_lemma_134218 (h0 : functor.add_const (topological_space (has_zero linarith.comp)) name) : @preconnected_space.{0} (has_zero.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (has_zero.{0} linarith.comp)) name h0)  := sorry --non-trivial
lemma new_lemma_134219 (h0 : topological_space (add_cancel_monoid (boolean_algebra.core name))) : path_connected_space (add_cancel_monoid (boolean_algebra.core name)) := sorry --non-trivial
lemma new_lemma_134220 (h0 : option (uniform_space (comm_monoid unsigned))) (h1 : uniform_space (comm_monoid unsigned)) : separated_space (comm_monoid unsigned) := sorry --non-trivial
lemma new_lemma_134221 (h1 : has_lt (nondiscrete_normed_field linarith.ineq)) : no_max_order (nondiscrete_normed_field linarith.ineq) := sorry --non-trivial
lemma new_lemma_134222 (h0 : list (has_norm (has_top (has_norm fun_info)))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_134223 (h2 : add_group (has_div to_additive.value_type)) : is_add_cyclic (has_div to_additive.value_type) := sorry --non-trivial
lemma new_lemma_134224 (h0 : ring (linear_ordered_semiring empty)) : is_domain (linear_ordered_semiring empty) := sorry --non-trivial
lemma new_lemma_134225 (h1 : topological_space (div_inv_monoid to_additive.value_type)) : path_connected_space (div_inv_monoid to_additive.value_type) := sorry --non-trivial
lemma new_lemma_134226 (h0 : topological_space (generalized_boolean_algebra (sub_neg_monoid pos))) : totally_disconnected_space (generalized_boolean_algebra (sub_neg_monoid pos)) := sorry --non-trivial
lemma new_lemma_134227 (h0 : function.extfun Type topological_space) : @preconnected_space.{0} (linear_ordered_comm_group.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (linear_ordered_comm_group.{0} empty))  := sorry --non-trivial
lemma new_lemma_134228 (h0 : add_group (preorder (semiring (semiring (semiring (semiring empty)))))) : is_add_cyclic (preorder (semiring (semiring (semiring (semiring empty))))) := sorry --non-trivial
lemma new_lemma_134229 (h0 : topological_space (canonically_linear_ordered_monoid (has_Inf (has_Inf (has_Inf name))))) : discrete_topology (canonically_linear_ordered_monoid (has_Inf (has_Inf (has_Inf name)))) := sorry --non-trivial
lemma new_lemma_134230 (h0 : not (has_mem.mem (has_norm linarith.ineq) has_emptyc.emptyc -> false)) : @path_connected_space.{0} (has_norm.{0} linarith.ineq) (@finset.pi.empty.{1 0} Type topological_space.{0} (has_norm.{0} linarith.ineq) (@classical.by_contradiction'.{0} (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (has_norm.{0} linarith.ineq) (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))) h0))  := sorry --non-trivial
lemma new_lemma_134231 (h0 : functor.add_const (list (semigroup environment.implicit_infer_kind)) name) : list.nodup (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_134232 (h0 : functor.add_const (monoid (canonically_ordered_comm_semiring linarith.comp)) pos) : @monoid.fg.{0} (canonically_ordered_comm_semiring.{0} linarith.comp) (@functor.add_const.run.{0 0} (monoid.{0} (canonically_ordered_comm_semiring.{0} linarith.comp)) pos h0)  := sorry --non-trivial
lemma new_lemma_134233 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @separated_space.{0} (filter.{0} empty) (@function.extfun_app.{2 1} Type uniform_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 uniform_space.{0}) (filter.{0} empty))  := sorry --non-trivial
lemma new_lemma_134234 (h0 : functor.add_const (uniform_space (preorder num)) unsigned) : @complete_space.{0} (preorder.{0} num) (@functor.add_const.run.{0 0} (uniform_space.{0} (preorder.{0} num)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_134235 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : filter.ne_bot (function.extfun_app (function.extfun_app h0 filter) (dlist fun_info)) := sorry --non-trivial
lemma new_lemma_134236 (h2 : group (normed_field (random_gen string_imp))) : is_cyclic (normed_field (random_gen string_imp)) := sorry --non-trivial
lemma new_lemma_134237 (h0 : finset (complete_distrib_lattice ennreal)) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_134238 (h0 : topological_space (canonically_ordered_monoid (finset (boolean_algebra.core (finset linarith.comp))))) : regular_space (canonically_ordered_monoid (finset (boolean_algebra.core (finset linarith.comp)))) := sorry --non-trivial
lemma new_lemma_134239 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_add_cyclic.{0} (with_bot.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type add_group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 add_group.{0}) (with_bot.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_134240 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @loc_path_connected_space.{0} (has_zero.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_zero.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_134241 (h0 : function.extfun Type (functor.add_const (topological_space (measurable_space.dynkin_system empty)))) : @preirreducible_space.{0} (measurable_space.dynkin_system.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (measurable_space.dynkin_system.{0} empty)) num (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (topological_space.{0} (measurable_space.dynkin_system.{0} empty))) h0 num))  := sorry --non-trivial
lemma new_lemma_134242 (h0 : monoid (random_gen (with_one (comm_ring to_additive.value_type)))) : monoid.fg (random_gen (with_one (comm_ring to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_134243 (h0 : function.extfun Type filter) : filter.ne_bot (function.extfun_app h0 (linear_ordered_comm_group congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_134244 (h0 : functor.add_const (semiring (finset Type)) Type) : @is_noetherian_ring.{1} (finset.{1} Type) (@functor.add_const.run.{1 1} (semiring.{1} (finset.{1} Type)) Type h0)  := sorry --non-trivial
lemma new_lemma_134245 (h0 : complete_lattice (has_to_string (comm_group Type))) : is_compactly_generated (has_to_string (comm_group Type)) := sorry --non-trivial
lemma new_lemma_134246 (h0 : topological_space (boolean_algebra (normed_comm_ring name))) : t1_space (boolean_algebra (normed_comm_ring name)) := sorry --non-trivial
lemma new_lemma_134247 (h1 : complete_lattice (has_top (with_bot string_imp))) : complete_lattice.is_Sup_finite_compact (has_top (with_bot string_imp)) := sorry --non-trivial
lemma new_lemma_134248 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_cyclic.{0} (denumerable.{0} string_imp) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (denumerable.{0} string_imp))  := sorry --non-trivial
lemma new_lemma_134249 (h0 : function.extfun Type (functor.add_const (add_monoid (as_linear_order unsigned)))) : @add_monoid.fg.{0} (as_linear_order.{0} unsigned) (@functor.add_const.run.{0 0} (add_monoid.{0} (as_linear_order.{0} unsigned)) empty (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (add_monoid.{0} (as_linear_order.{0} unsigned))) h0 empty))  := sorry --non-trivial
lemma new_lemma_134250 (h0 : function.extfun Type ring) : @strong_rank_condition.{0} (with_bot.{0} empty) (@function.extfun_app.{2 1} Type ring.{0} h0 (with_bot.{0} empty))  := sorry --non-trivial
lemma new_lemma_134251 (h0 : function.extfun Type complete_lattice) : @is_atomistic.{0} (complete_distrib_lattice.{0} linarith.comp) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (complete_distrib_lattice.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_134252 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : list.nodup (function.extfun_app (function.extfun_app h0 list) (has_top congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_134253 (h0 : complete_lattice (has_neg_part linarith.comp)) : is_compactly_generated (has_neg_part linarith.comp) := sorry --non-trivial
lemma new_lemma_134254 (h0 : topological_space (add_cancel_monoid (comm_group (comm_group pos)))) : normal_space (add_cancel_monoid (comm_group (comm_group pos))) := sorry --non-trivial
lemma new_lemma_134255 (h1 : uniform_space (normed_field string.iterator_imp)) : complete_space (normed_field string.iterator_imp) := sorry --non-trivial
lemma new_lemma_134256 (h0 : not (function.extfun Type ring -> false)) : @is_principal_ideal_ring.{0} (with_bot.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type ring.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type ring.{0}) h0) (with_bot.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_134257 (h0 : functor.add_const (topological_space (simple_graph pos)) linarith.comp) : @sequential_space.{0} (simple_graph.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (simple_graph.{0} pos)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_134258 (h0 : topological_space (measurable_space linarith.comp)) : totally_separated_space (measurable_space linarith.comp) := sorry --non-trivial
lemma new_lemma_134259 (h0 : function.extfun Type topological_space) : @locally_compact_space.{0} (complete_semilattice_Sup.{0} string_imp) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (complete_semilattice_Sup.{0} string_imp))  := sorry --non-trivial
lemma new_lemma_134260 (h0 : function.extfun Type ring) : @is_domain.{0} (cancel_monoid.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type ring.{0} h0 (cancel_monoid.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_134261 (h0 : ring (has_div (has_nnnorm (mul_one_class linarith.comp_source)))) : rank_condition (has_div (has_nnnorm (mul_one_class linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_134262 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @path_connected_space.{0} (add_comm_monoid.{0} ennreal) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (add_comm_monoid.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_134263 (h0 : functor.add_const (topological_space (has_Inf linarith.comp)) pos) : @irreducible_space.{0} (has_Inf.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (has_Inf.{0} linarith.comp)) pos h0)  := sorry --non-trivial
lemma new_lemma_134264 (h0 : group (add_comm_monoid empty)) : normalizer_condition (add_comm_monoid empty) := sorry --non-trivial
lemma new_lemma_134265 (h0 : functor.add_const (complete_lattice pos) (mul_zero_class (option name))) : @complete_lattice.is_Sup_finite_compact.{0} pos (@functor.add_const.run.{0 0} (complete_lattice.{0} pos) (mul_zero_class.{0} (option.{0} name)) h0)  := sorry --non-trivial
lemma new_lemma_134266 (h0 : topological_space (left_cancel_semigroup (semiring (semiring unsigned)))) : topological_space.separable_space (left_cancel_semigroup (semiring (semiring unsigned))) := sorry --non-trivial
lemma new_lemma_134267 (h0 : ring (omega_complete_partial_order (has_neg linarith.comp))) : strong_rank_condition (omega_complete_partial_order (has_neg linarith.comp)) := sorry --non-trivial
lemma new_lemma_134268 (h0 h1 : multiset fun_info) : multiset.subset h0 h1 := sorry --non-trivial
lemma new_lemma_134269 (h0 : list (comm_group Type)) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_134270 (h0 : function.extfun Type topological_space) : @path_connected_space.{0} (with_bot.{0} linarith.ineq) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (with_bot.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_134271 (h0 : functor.add_const (complete_lattice (boolean_algebra name)) name) : @complete_lattice.is_Sup_finite_compact.{0} (boolean_algebra.{0} name) (@functor.add_const.run.{0 0} (complete_lattice.{0} (boolean_algebra.{0} name)) name h0)  := sorry --non-trivial
lemma new_lemma_134272 (h0 : function.extfun Type cancel_comm_monoid_with_zero) : @unique_factorization_monoid.{0} znum (@function.extfun_app.{2 1} Type cancel_comm_monoid_with_zero.{0} h0 znum)  := sorry --non-trivial
lemma new_lemma_134273 (h0 : functor.add_const (topological_space (left_cancel_monoid unsigned)) empty) : @loc_path_connected_space.{0} (left_cancel_monoid.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (left_cancel_monoid.{0} unsigned)) empty h0)  := sorry --non-trivial
lemma new_lemma_134274 (h0 : functor.add_const (semiring (normed_comm_ring Type)) pos) : @is_noetherian_ring.{1} (normed_comm_ring.{1} Type) (@functor.add_const.run.{1 0} (semiring.{1} (normed_comm_ring.{1} Type)) pos h0)  := sorry --non-trivial
lemma new_lemma_134275 (h0 : not (function.extfun (Type -> Type) (function.extfun Type) -> false)) : @separated_space.{0} (linear_ordered_comm_ring.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type uniform_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) (@classical.by_contradiction'.{2} (function.extfun.{2 2} (Type → Type) (function.extfun.{2 1} Type)) h0) uniform_space.{0}) (linear_ordered_comm_ring.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_134276 (h0 : functor.add_const (ring (has_neg environment.implicit_infer_kind)) linarith.comp) : @is_principal_ideal_ring.{0} (has_neg.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (ring.{0} (has_neg.{0} environment.implicit_infer_kind)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_134277 (h0 : group (measurable_space (random_gen (random_gen to_additive.value_type)))) : is_cyclic (measurable_space (random_gen (random_gen to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_134278 (h0 : functor.add_const (topological_space (complete_distrib_lattice environment.implicit_infer_kind)) linarith.comp) : @irreducible_space.{0} (complete_distrib_lattice.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (complete_distrib_lattice.{0} environment.implicit_infer_kind)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_134279 (h0 : topological_space (has_zero (comm_group (comm_group (has_neg_part (comm_group pos)))))) : t1_space (has_zero (comm_group (comm_group (has_neg_part (comm_group pos))))) := sorry --non-trivial
lemma new_lemma_134280 (h0 : functor.add_const (function.extfun Type topological_space) linarith.comp) : @totally_disconnected_space.{0} (ring.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) linarith.comp h0) (ring.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_134281 (h0 : function.extfun Type complete_lattice) : @complete_lattice.is_Sup_finite_compact.{0} congr_arg_kind (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 congr_arg_kind)  := sorry --non-trivial
lemma new_lemma_134282 (h0 : functor.add_const (complete_lattice (has_nndist pos)) name) : @complete_lattice.is_Sup_finite_compact.{0} (has_nndist.{0} pos) (@functor.add_const.run.{0 0} (complete_lattice.{0} (has_nndist.{0} pos)) name h0)  := sorry --non-trivial
lemma new_lemma_134283 (h0 : uniform_space (linear_ordered_semiring fun_info)) : complete_space (linear_ordered_semiring fun_info) := sorry --non-trivial
lemma new_lemma_134284 (h0 : functor.add_const (topological_space (comm_group ennreal)) Type) : @locally_compact_space.{0} (comm_group.{0} ennreal) (@functor.add_const.run.{0 1} (topological_space.{0} (comm_group.{0} ennreal)) Type h0)  := sorry --non-trivial
lemma new_lemma_134285 (h0 : topological_space (linear_ordered_add_comm_group (with_bot (with_one string_imp)))) : path_connected_space (linear_ordered_add_comm_group (with_bot (with_one string_imp))) := sorry --non-trivial
lemma new_lemma_134286 (h0 : functor.add_const (function.extfun (Type 1) group) pos) : @is_simple_group.{1} (ordered_comm_ring.{1} Type) (@function.extfun_app.{3 2} (Type 1) group.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) group.{1}) pos h0) (ordered_comm_ring.{1} Type))  := sorry --non-trivial
lemma new_lemma_134287 (h0 : functor.add_const (topological_space (semigroup congr_arg_kind)) num) : @totally_separated_space.{0} (semigroup.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (semigroup.{0} congr_arg_kind)) num h0)  := sorry --non-trivial
lemma new_lemma_134288 (h0 : list (measurable_space (random_gen to_additive.value_type))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_134289 (h0 : function.extfun Type ring) : @rank_condition.{0} (option.{0} pos) (@function.extfun_app.{2 1} Type ring.{0} h0 (option.{0} pos))  := sorry --non-trivial
lemma new_lemma_134290 (h0 : functor.add_const (group (bin_tree empty)) (semiring (semiring empty))) : @group.fg.{0} (bin_tree.{0} empty) (@functor.add_const.run.{0 0} (group.{0} (bin_tree.{0} empty)) (semiring.{0} (semiring.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_134291 (h0 : functor.add_const (functor.add_const Prop pos) (finset environment.implicit_infer_kind)) : functor.add_const.run (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_134292 (h0 : complete_lattice (has_top (has_norm fun_info))) : is_atomistic (has_top (has_norm fun_info)) := sorry --non-trivial
lemma new_lemma_134293 (h0 : functor.add_const (complete_lattice (boolean_algebra.core environment.implicit_infer_kind)) linarith.comp) : @complete_lattice.is_Sup_finite_compact.{0} (boolean_algebra.core.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (complete_lattice.{0} (boolean_algebra.core.{0} environment.implicit_infer_kind)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_134294 (h0 : functor.add_const (topological_space (sub_neg_monoid pos)) name) : @preconnected_space.{0} (sub_neg_monoid.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (sub_neg_monoid.{0} pos)) name h0)  := sorry --non-trivial
lemma new_lemma_134295 (h0 : uniform_space (comm_group (has_to_string Type))) : complete_space (comm_group (has_to_string Type)) := sorry --non-trivial
lemma new_lemma_134296 (h0 : topological_space (has_inner empty unsigned)) : totally_separated_space (has_inner empty unsigned) := sorry --non-trivial
lemma new_lemma_134297 (h0 : functor.add_const (function.extfun (Type 1) complete_lattice) Type) : @complete_lattice.is_Sup_finite_compact.{1} Type (@function.extfun_app.{3 2} (Type 1) complete_lattice.{1} (@functor.add_const.run.{2 1} (function.extfun.{3 2} (Type 1) complete_lattice.{1}) Type h0) Type)  := sorry --non-trivial
lemma new_lemma_134298 (h0 : functor.add_const (add_monoid (has_zero Type)) Type) : @add_monoid.fg.{1} (has_zero.{1} Type) (@functor.add_const.run.{1 1} (add_monoid.{1} (has_zero.{1} Type)) Type h0)  := sorry --non-trivial
lemma new_lemma_134299 (h0 : topological_space (has_edist (finset pos))) : normal_space (has_edist (finset pos)) := sorry --non-trivial
lemma new_lemma_134300 (h0 : semiring (nondiscrete_normed_field bool)) (h1 : ideal (nondiscrete_normed_field bool)) : ideal.is_prime h1 := sorry --non-trivial
lemma new_lemma_134301 (h0 : function.extfun Type list) : list.nodup (function.extfun_app h0 (mul_zero_class congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_134302 (h0 : functor.add_const Prop (add_comm_monoid (boolean_algebra pos))) : functor.add_const.run h0 := sorry --non-trivial
lemma new_lemma_134303 (h0 : function.extfun Type topological_space) : @t1_space.{0} (is_R_or_C.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (is_R_or_C.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_134304 (h0 : ring (has_nnnorm (mul_one_class linarith.comp_source))) : strong_rank_condition (has_nnnorm (mul_one_class linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_134305 (h0 : functor.add_const (finset (normed_comm_ring linarith.comp)) name) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_134306 (h0 : function.extfun Type add_monoid) : @add_monoid.fg.{0} (has_edist.{0} empty) (@function.extfun_app.{2 1} Type add_monoid.{0} h0 (has_edist.{0} empty))  := sorry --non-trivial
lemma new_lemma_134307 (h0 : functor.add_const (group (ordered_comm_monoid real)) name) : @is_simple_group.{0} (ordered_comm_monoid.{0} real) (@functor.add_const.run.{0 0} (group.{0} (ordered_comm_monoid.{0} real)) name h0)  := sorry --non-trivial
lemma new_lemma_134308 (h0 : functor.add_const (complete_lattice (filter unsigned)) unsigned) : is_atomistic (filter unsigned) := sorry --non-trivial
lemma new_lemma_134309 (h0 : group (distrib_lattice to_additive.value_type)) : normalizer_condition (distrib_lattice to_additive.value_type) := sorry --non-trivial
lemma new_lemma_134310 (h0 : function.extfun Type topological_space) : @locally_compact_space.{0} (normed_linear_ordered_group.{0} (semiring.{0} (semiring.{0} congr_arg_kind))) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (normed_linear_ordered_group.{0} (semiring.{0} (semiring.{0} congr_arg_kind))))  := sorry --non-trivial
lemma new_lemma_134311 (h0 : has_lt (nondiscrete_normed_field (add_comm_semigroup char))) : no_max_order (nondiscrete_normed_field (add_comm_semigroup char)) := sorry --non-trivial
lemma new_lemma_134312 (h0 : complete_lattice (random_gen (has_norm fun_info))) : complete_lattice.is_Sup_finite_compact (random_gen (has_norm fun_info)) := sorry --non-trivial
lemma new_lemma_134313 (h0 : complete_lattice (denumerable (random_gen string_imp))) : complete_lattice.is_Sup_finite_compact (denumerable (random_gen string_imp)) := sorry --non-trivial
lemma new_lemma_134314 (h0 : function.extfun Type topological_space) : @t0_space.{0} (has_inv.{0} fun_info) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_inv.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_134315 (h0 : topological_space (has_ssubset (random_gen (random_gen (random_gen string_imp))))) : t0_space (has_ssubset (random_gen (random_gen (random_gen string_imp)))) := sorry --non-trivial
lemma new_lemma_134316 (h0 : functor.add_const (topological_space (comm_group name)) unsigned) : @sequential_space.{0} (comm_group.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (comm_group.{0} name)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_134317 (h0 : cancel_comm_monoid_with_zero (as_linear_order congr_arg_kind)) : unique_factorization_monoid (as_linear_order congr_arg_kind) := sorry --non-trivial
lemma new_lemma_134318 (h0 : function.extfun nat fin) : @complete_lattice.is_Sup_finite_compact.{0} (has_pos_part.{0} name) (@matrix.vec_empty.{0} (complete_lattice.{0} (has_pos_part.{0} name)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_134319 (h0 : functor.comp filter semigroup Type) : filter.ne_bot (functor.comp.run h0) := sorry --non-trivial
lemma new_lemma_134320 (h0 : group (boolean_algebra (finset (finset Type)))) : is_cyclic (boolean_algebra (finset (finset Type))) := sorry --non-trivial
lemma new_lemma_134321 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @locally_compact_space.{0} (has_zero.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_zero.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_134322 (h0 : function.extfun Type topological_space) : @totally_disconnected_space.{0} (cancel_monoid.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (cancel_monoid.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_134323 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @complete_space.{0} (monoid.{0} unsigned) (@function.extfun_app.{2 1} Type uniform_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 uniform_space.{0}) (monoid.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_134324 (h0 : topological_space (measurable_space (random_gen (random_gen congr_arg_kind)))) : totally_separated_space (measurable_space (random_gen (random_gen congr_arg_kind))) := sorry --non-trivial
lemma new_lemma_134325 (h0 : complete_lattice (comm_ring (random_gen string_imp))) : complete_lattice.is_Sup_finite_compact (comm_ring (random_gen string_imp)) := sorry --non-trivial
lemma new_lemma_134326 (h0 : complete_lattice (semiring (has_norm fun_info))) : is_atomistic (semiring (has_norm fun_info)) := sorry --non-trivial
lemma new_lemma_134327 (h0 : topological_space (has_neg (has_to_string pos))) : loc_path_connected_space (has_neg (has_to_string pos)) := sorry --non-trivial
lemma new_lemma_134328 (h0 : functor.add_const (uniform_space (plift nnreal)) unsigned) : @separated_space.{1} (plift.{1} nnreal) (@functor.add_const.run.{1 0} (uniform_space.{1} (plift.{1} nnreal)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_134329 (h0 : functor.add_const (topological_space environment.implicit_infer_kind) name) : @irreducible_space.{0} environment.implicit_infer_kind (@functor.add_const.run.{0 0} (topological_space.{0} environment.implicit_infer_kind) name h0)  := sorry --non-trivial
lemma new_lemma_134330 (h0 : topological_space (has_to_string (comm_group name))) : totally_separated_space (has_to_string (comm_group name)) := sorry --non-trivial
lemma new_lemma_134331 (h0 : functor.add_const (filter (add_comm_monoid Type)) name) : filter.ne_bot (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_134332 (h0 : function.extfun Type ring) : @is_principal_ideal_ring.{0} (add_group.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type ring.{0} h0 (add_group.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_134333 (h0 : filter (complete_distrib_lattice (option empty))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_134334 (h0 : semiring (free_add_monoid (semiring (semiring (semiring (semiring (semiring empty))))))) : is_noetherian_ring (free_add_monoid (semiring (semiring (semiring (semiring (semiring empty)))))) := sorry --non-trivial
lemma new_lemma_134335 (h0 : complete_lattice (boolean_algebra.core empty)) : is_compactly_generated (boolean_algebra.core empty) := sorry --non-trivial
lemma new_lemma_134336 (h0 : ring (plift unsigned)) : is_domain (plift unsigned) := sorry --non-trivial
lemma new_lemma_134337 (h0 : topological_space (has_top (has_ssubset fun_info))) : t0_space (has_top (has_ssubset fun_info)) := sorry --non-trivial
lemma new_lemma_134338 (h0 : topological_space (finset (canonically_ordered_comm_semiring Type))) : normal_space (finset (canonically_ordered_comm_semiring Type)) := sorry --non-trivial
lemma new_lemma_134339 (h1 : topological_space (add_comm_semigroup linarith.ineq)) (h2 : add_group (add_comm_semigroup linarith.ineq)) : topological_add_group (add_comm_semigroup linarith.ineq) := sorry --non-trivial
lemma new_lemma_134340 (h0 : cancel_comm_monoid_with_zero (add_left_cancel_semigroup empty)) : unique_factorization_monoid (add_left_cancel_semigroup empty) := sorry --non-trivial
lemma new_lemma_134341 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @normalizer_condition.{0} (canonically_ordered_comm_semiring.{0} ennreal) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (canonically_ordered_comm_semiring.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_134342 (h0 : topological_space (add_comm_monoid (has_nndist (finset (has_neg linarith.comp))))) : loc_path_connected_space (add_comm_monoid (has_nndist (finset (has_neg linarith.comp)))) := sorry --non-trivial
lemma new_lemma_134343 (h0 : list (random_gen (has_top fun_info))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_134344 (h0 : function.extfun Type topological_space) : @normal_space.{0} (metric_space.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (metric_space.{0} empty))  := sorry --non-trivial
lemma new_lemma_134345 (h0 : functor.add_const (topological_space (semigroup name)) (has_neg_part linarith.comp)) : @normal_space.{0} (semigroup.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (semigroup.{0} name)) (has_neg_part.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_134346 (h0 : topological_space (id unsigned)) : totally_separated_space (id unsigned) := sorry --non-trivial
lemma new_lemma_134347 (h0 : function.extfun (finset Type) (has_mem.mem (has_top unsigned))) : @irreducible_space.{0} (has_top.{0} unsigned) (@finset.pi.empty.{1 0} Type topological_space.{0} (has_top.{0} unsigned) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (has_top.{0} unsigned)) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_134348 (h0 : uniform_space (add_comm_monoid (has_Inf Type))) : complete_space (add_comm_monoid (has_Inf Type)) := sorry --non-trivial
lemma new_lemma_134349 (h0 : function.extfun Type (functor.add_const (ring auto.case_option))) : @is_principal_ideal_ring.{0} auto.case_option (@functor.add_const.run.{0 0} (ring.{0} auto.case_option) ennreal (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (ring.{0} auto.case_option)) h0 ennreal))  := sorry --non-trivial
lemma new_lemma_134350 (h0 : functor.add_const (topological_space (non_assoc_semiring empty)) empty) : @preirreducible_space.{0} (non_assoc_semiring.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (non_assoc_semiring.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_134351 (h1 : topological_space linarith.ineq) (h2 : set (set linarith.ineq)) : topological_space.is_topological_basis h2 := sorry --non-trivial
lemma new_lemma_134352 (h0 : topological_space (has_neg_part (has_add (has_add (has_nndist ennreal))))) : t1_space (has_neg_part (has_add (has_add (has_nndist ennreal)))) := sorry --non-trivial
lemma new_lemma_134353 (h0 : function.extfun Type group) : @is_cyclic.{0} (semigroup.{0} ennreal) (@function.extfun_app.{2 1} Type group.{0} h0 (semigroup.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_134354 (h0 : functor.comp (functor.add_const (ring (has_neg_part unsigned))) option pos) : @strong_rank_condition.{0} (has_neg_part.{0} unsigned) (@functor.add_const.run.{0 0} (ring.{0} (has_neg_part.{0} unsigned)) (option.{0} pos) (@functor.comp.run.{0 0 0} (functor.add_const.{0 0} (ring.{0} (has_neg_part.{0} unsigned))) option.{0} pos h0))  := sorry --non-trivial
lemma new_lemma_134355 (h0 : functor.add_const (complete_lattice pos) (option pos)) : @is_compactly_generated.{0} pos (@functor.add_const.run.{0 0} (complete_lattice.{0} pos) (option.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_134356 (h0 : function.extfun Type group) : @group.fg.{0} (div_inv_monoid.{0} fun_info) (@function.extfun_app.{2 1} Type group.{0} h0 (div_inv_monoid.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_134357 (h1 : uniform_space (has_emptyc (random_gen congr_arg_kind))) : complete_space (has_emptyc (random_gen congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_134358 (h0 : group (complete_semilattice_Sup (has_inv (has_top fun_info)))) : group.fg (complete_semilattice_Sup (has_inv (has_top fun_info))) := sorry --non-trivial
lemma new_lemma_134359 (h0 : function.extfun Type topological_space) : @preirreducible_space.{0} (canonically_ordered_monoid.{0} real) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (canonically_ordered_monoid.{0} real))  := sorry --non-trivial
lemma new_lemma_134360 (h1 : ring (has_lt string_imp)) : strong_rank_condition (has_lt string_imp) := sorry --non-trivial
lemma new_lemma_134361 (h0 : function.extfun Type topological_space) : @totally_disconnected_space.{0} (omega_complete_partial_order.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (omega_complete_partial_order.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_134362 (h0 : functor.add_const (function.extfun (Type 1) ring) Type) : @rank_condition.{1} (canonically_ordered_comm_semiring.{1} Type) (@function.extfun_app.{3 2} (Type 1) ring.{1} (@functor.add_const.run.{2 1} (function.extfun.{3 2} (Type 1) ring.{1}) Type h0) (canonically_ordered_comm_semiring.{1} Type))  := sorry --non-trivial
lemma new_lemma_134363 (h0 : function.extfun Type ordered_add_comm_monoid) : @archimedean.{0} (finset.{0} ennreal) (@function.extfun_app.{2 1} Type ordered_add_comm_monoid.{0} h0 (finset.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_134364 (h0 : topological_space (mul_one_class std_gen)) : t0_space (mul_one_class std_gen) := sorry --non-trivial
lemma new_lemma_134365 (h0 : group (has_inv (random_gen linarith.comp_source))) : group.fg (has_inv (random_gen linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_134366 (h1 : set (mul_one_class (mul_one_class (mul_one_class (mul_one_class std_gen))) -> char)) : set.separates_points h1 := sorry --non-trivial
lemma new_lemma_134367 (h0 : topological_space (add_cancel_monoid (option (option (option (option ennreal)))))) : totally_separated_space (add_cancel_monoid (option (option (option (option ennreal))))) := sorry --non-trivial
lemma new_lemma_134368 (h0 : topological_space (has_neg congr_arg_kind)) : irreducible_space (has_neg congr_arg_kind) := sorry --non-trivial
lemma new_lemma_134369 (h0 : functor.add_const (topological_space (left_cancel_monoid empty)) empty) : @t0_space.{0} (left_cancel_monoid.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (left_cancel_monoid.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_134370 (h0 : uniform_space (finset (has_add (has_bot real)))) : separated_space (finset (has_add (has_bot real))) := sorry --non-trivial
lemma new_lemma_134371 (h2 : topological_space ereal) (h3 : set ereal) : is_path_connected h3 := sorry --non-trivial
lemma new_lemma_134372 (h0 : function.extfun Type topological_space) : @loc_path_connected_space.{0} (has_Sup.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_Sup.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_134373 (h0 : filter (metric_space ennreal)) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_134374 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_domain.{0} (has_nndist.{0} (option.{0} (option.{0} unsigned))) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (has_nndist.{0} (option.{0} (option.{0} unsigned))))  := sorry --non-trivial
lemma new_lemma_134375 (h0 : group (has_edist (semiring empty))) : is_cyclic (has_edist (semiring empty)) := sorry --non-trivial
lemma new_lemma_134376 (h0 : complete_lattice (has_norm (semiring empty))) : is_compactly_generated (has_norm (semiring empty)) := sorry --non-trivial
lemma new_lemma_134377 (h0 : topological_space (finset (finset (has_pos_part pos)))) : loc_path_connected_space (finset (finset (has_pos_part pos))) := sorry --non-trivial
lemma new_lemma_134378 (h0 : Type -> has_neg environment.implicit_infer_kind -> Prop) : relator.bi_total h0 := sorry --non-trivial
lemma new_lemma_134379 (h0 : has_le (has_norm (random_gen (random_gen (random_gen (random_gen linarith.comp_source)))))) (h1 : bounded_order (has_norm (random_gen (random_gen (random_gen (random_gen linarith.comp_source)))))) : is_simple_order (has_norm (random_gen (random_gen (random_gen (random_gen linarith.comp_source))))) := sorry --non-trivial
lemma new_lemma_134380 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_domain.{0} (with_bot.{0} unsigned) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (with_bot.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_134381 (h0 : function.extfun Type uniform_space) : @complete_space.{0} (canonically_ordered_monoid.{0} real) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (canonically_ordered_monoid.{0} real))  := sorry --non-trivial
lemma new_lemma_134382 (h0 : function.extfun Type ring) : @strong_rank_condition.{0} (sub_neg_monoid.{0} linarith.comp) (@function.extfun_app.{2 1} Type ring.{0} h0 (sub_neg_monoid.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_134383 (h0 : ring (random_gen (has_nnnorm (has_nnnorm (has_nnnorm to_additive.value_type))))) : strong_rank_condition (random_gen (has_nnnorm (has_nnnorm (has_nnnorm to_additive.value_type)))) := sorry --non-trivial
lemma new_lemma_134384 (h0 : topological_space (normed_group (has_top (random_gen (has_norm (has_norm fun_info)))))) : totally_disconnected_space (normed_group (has_top (random_gen (has_norm (has_norm fun_info))))) := sorry --non-trivial
lemma new_lemma_134385 (h1 : uniform_space (encodable char)) : complete_space (encodable char) := sorry --non-trivial
lemma new_lemma_134386 (h0 : functor.add_const (function.extfun (Type 1) ordered_comm_monoid) Type) : @has_exists_mul_of_le.{1} (finset.{1} Type) (@function.extfun_app.{3 2} (Type 1) ordered_comm_monoid.{1} (@functor.add_const.run.{2 1} (function.extfun.{3 2} (Type 1) ordered_comm_monoid.{1}) Type h0) (finset.{1} Type))  := sorry --non-trivial
lemma new_lemma_134387 (h0 : complete_lattice (has_norm linarith.comp_source)) : is_atomistic (has_norm linarith.comp_source) := sorry --non-trivial
lemma new_lemma_134388 (h0 : cancel_comm_monoid_with_zero (canonically_linear_ordered_monoid (has_neg name))) : unique_factorization_monoid (canonically_linear_ordered_monoid (has_neg name)) := sorry --non-trivial
lemma new_lemma_134389 (h1 : not (group (add_cancel_comm_monoid linarith.comp_source) -> false)) : @is_cyclic.{0} (add_cancel_comm_monoid.{0} linarith.comp_source) (@classical.by_contradiction'.{1} (group.{0} (add_cancel_comm_monoid.{0} linarith.comp_source)) h1)  := sorry --non-trivial
lemma new_lemma_134390 (h0 : function.extfun Type topological_space) : @locally_compact_space.{0} (linear_ordered_field.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (linear_ordered_field.{0} num))  := sorry --non-trivial
lemma new_lemma_134391 (h0 : topological_space (add_cancel_monoid (has_add Type))) : normal_space (add_cancel_monoid (has_add Type)) := sorry --non-trivial
lemma new_lemma_134392 (h1 : functor.add_const Prop linarith.ineq) : functor.add_const.run h1 := sorry --non-trivial
lemma new_lemma_134393 (h0 : has_mem.mem (has_norm congr_arg_kind) has_emptyc.emptyc) : @monoid.fg.{0} (has_norm.{0} congr_arg_kind) (@finset.pi.empty.{1 0} Type monoid.{0} (has_norm.{0} congr_arg_kind) h0)  := sorry --non-trivial
lemma new_lemma_134394 (h0 : cancel_comm_monoid_with_zero (bin_tree (semiring (semiring congr_arg_kind)))) : unique_factorization_monoid (bin_tree (semiring (semiring congr_arg_kind))) := sorry --non-trivial
lemma new_lemma_134395 (h0 : complete_lattice (left_cancel_monoid congr_arg_kind)) : complete_lattice.is_Sup_finite_compact (left_cancel_monoid congr_arg_kind) := sorry --non-trivial
lemma new_lemma_134396 (h0 : topological_space (has_zero (finset (add_cancel_monoid linarith.comp)))) : locally_compact_space (has_zero (finset (add_cancel_monoid linarith.comp))) := sorry --non-trivial
lemma new_lemma_134397 (h0 : fin has_zero.zero) : @normal_space.{0} (has_bot.{0} pos) (@matrix.vec_empty.{0} (topological_space.{0} (has_bot.{0} pos)) h0)  := sorry --non-trivial
lemma new_lemma_134398 (h0 : function.extfun (finset (Type -> Type)) (has_mem.mem group)) : @group.fg.{0} (has_emptyc.{0} empty) (@function.extfun_app.{2 1} Type group.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) group.{0} (@function.extfun_app.{2 0} (finset.{1} (Type → Type)) (@has_mem.mem.{1 1} (Type → Type) (finset.{1} (Type → Type)) (@finset.has_mem.{1} (Type → Type)) group.{0}) h0 (@has_emptyc.emptyc.{1} (finset.{1} (Type → Type)) (@finset.has_emptyc.{1} (Type → Type))))) (has_emptyc.{0} empty))  := sorry --non-trivial
lemma new_lemma_134399 (h0 : functor.add_const (topological_space (add_cancel_monoid linarith.comp)) (finset pos)) : @topological_space.separable_space.{0} (add_cancel_monoid.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (add_cancel_monoid.{0} linarith.comp)) (finset.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_134400 (h0 : functor.add_const (group (has_to_string unsigned)) (ring pos)) : @is_simple_group.{0} (has_to_string.{0} unsigned) (@functor.add_const.run.{0 0} (group.{0} (has_to_string.{0} unsigned)) (ring.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_134401 (h0 : group (distrib_lattice (random_gen (random_gen fun_info)))) : group.fg (distrib_lattice (random_gen (random_gen fun_info))) := sorry --non-trivial
lemma new_lemma_134402 (h0 : function.extfun Type topological_space) : @topological_space.separable_space.{0} (add_comm_monoid.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (add_comm_monoid.{0} pos))  := sorry --non-trivial
lemma new_lemma_134403 (h0 : group (has_add (has_pos_part (has_Inf Type)))) : normalizer_condition (has_add (has_pos_part (has_Inf Type))) := sorry --non-trivial
lemma new_lemma_134404 (h0 : topological_space (emetric_space (has_nndist pos))) : discrete_topology (emetric_space (has_nndist pos)) := sorry --non-trivial
lemma new_lemma_134405 (h0 : complete_lattice (has_pos_part (has_neg real))) : is_compactly_generated (has_pos_part (has_neg real)) := sorry --non-trivial
lemma new_lemma_134406 (h0 : uniform_space (boolean_algebra (ring Type))) : complete_space (boolean_algebra (ring Type)) := sorry --non-trivial
lemma new_lemma_134407 (h0 : list (linear_ordered_add_comm_group linarith.ineq)) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_134408 (h0 : topological_space (has_Inf (has_add (has_to_string pos)))) : preirreducible_space (has_Inf (has_add (has_to_string pos))) := sorry --non-trivial
lemma new_lemma_134409 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @rank_condition.{1} (has_bot.{1} Type) (@function.extfun_app.{3 2} (Type 1) ring.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 ring.{1}) (has_bot.{1} Type))  := sorry --non-trivial
lemma new_lemma_134410 (h0 : ordered_add_comm_monoid (has_neg (semigroup name))) : archimedean (has_neg (semigroup name)) := sorry --non-trivial
lemma new_lemma_134411 (h0 : functor.add_const (cancel_comm_monoid_with_zero (has_neg_part environment.implicit_infer_kind)) (has_add name)) : @unique_factorization_monoid.{0} (has_neg_part.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (cancel_comm_monoid_with_zero.{0} (has_neg_part.{0} environment.implicit_infer_kind)) (has_add.{0} name) h0)  := sorry --non-trivial
lemma new_lemma_134412 (h0 : function.extfun Type ordered_add_comm_monoid) : @archimedean.{0} (comm_semigroup.{0} real) (@function.extfun_app.{2 1} Type ordered_add_comm_monoid.{0} h0 (comm_semigroup.{0} real))  := sorry --non-trivial
lemma new_lemma_134413 (h0 : group (complete_semilattice_Sup (has_norm (has_norm empty)))) : group.fg (complete_semilattice_Sup (has_norm (has_norm empty))) := sorry --non-trivial
lemma new_lemma_134414 (h0 : functor.add_const (finset (linear_ordered_comm_monoid_with_zero unsigned)) unsigned) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_134415 (h0 : functor.add_const (uniform_space (has_neg Type)) Type) : @separated_space.{1} (has_neg.{1} Type) (@functor.add_const.run.{1 1} (uniform_space.{1} (has_neg.{1} Type)) Type h0)  := sorry --non-trivial
lemma new_lemma_134416 (h0 : topological_space (has_ssubset (has_ssubset char))) : path_connected_space (has_ssubset (has_ssubset char)) := sorry --non-trivial
lemma new_lemma_134417 (h0 : topological_space (fintype to_additive.value_type)) : path_connected_space (fintype to_additive.value_type) := sorry --non-trivial
lemma new_lemma_134418 (h0 : topological_space (encodable (random_gen linarith.ineq))) : totally_disconnected_space (encodable (random_gen linarith.ineq)) := sorry --non-trivial
lemma new_lemma_134419 (h0 : functor.add_const (functor.add_const (topological_space ennreal) unsigned) (option unsigned)) : preconnected_space ennreal := sorry --non-trivial
lemma new_lemma_134420 (h0 : add_monoid (complete_distrib_lattice (semiring empty))) : add_monoid.fg (complete_distrib_lattice (semiring empty)) := sorry --non-trivial
lemma new_lemma_134421 (h0 : ring (has_inv (distrib_lattice linarith.ineq))) : is_domain (has_inv (distrib_lattice linarith.ineq)) := sorry --non-trivial
lemma new_lemma_134422 (h0 : complete_lattice (random_gen (semiring num))) : is_atomistic (random_gen (semiring num)) := sorry --non-trivial
lemma new_lemma_134423 (h3 : uniform_space (uniform_space linarith.ineq)) : complete_space (uniform_space linarith.ineq) := sorry --non-trivial
lemma new_lemma_134424 (h0 : functor.add_const (finset (add_comm_monoid linarith.comp)) linarith.comp) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_134425 (h0 : not (function.extfun Type uniform_space -> false)) : @separated_space.{0} (normed_group.{0} unsigned) (@function.extfun_app.{2 1} Type uniform_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type uniform_space.{0}) h0) (normed_group.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_134426 (h1 : topological_space (encodable (random_gen (random_gen (has_ssubset fun_info))))) : t0_space (encodable (random_gen (random_gen (has_ssubset fun_info)))) := sorry --non-trivial
lemma new_lemma_134427 (h0 : topological_space (ordered_comm_ring (has_neg name))) : t1_space (ordered_comm_ring (has_neg name)) := sorry --non-trivial
lemma new_lemma_134428 (h0 : finset (ring (boolean_algebra.core name))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_134429 (h0 : functor.add_const (topological_space (has_Inf linarith.comp)) (has_pos_part (finset pos))) : @irreducible_space.{0} (has_Inf.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (has_Inf.{0} linarith.comp)) (has_pos_part.{0} (finset.{0} pos)) h0)  := sorry --non-trivial
lemma new_lemma_134430 (h0 : function.extfun Type topological_space) : @totally_disconnected_space.{0} (normed_group.{0} linarith.ineq) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (normed_group.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_134431 (h1 : not (ring (normed_field reducibility_hints) -> false)) : @rank_condition.{0} (normed_field.{0} reducibility_hints) (@classical.by_contradiction'.{1} (ring.{0} (normed_field.{0} reducibility_hints)) h1)  := sorry --non-trivial
lemma new_lemma_134432 (h0 : functor.add_const (function.extfun Type topological_space) pos) : @t0_space.{0} (add_cancel_monoid.{0} ennreal) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) pos h0) (add_cancel_monoid.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_134433 (h0 : functor.comp list comm_group pos) : list.nodup (functor.comp.run h0) := sorry --non-trivial
lemma new_lemma_134434 (h0 : add_group (has_neg_part (has_add (has_add name)))) : is_add_cyclic (has_neg_part (has_add (has_add name))) := sorry --non-trivial
lemma new_lemma_134435 (h0 : function.extfun Type topological_space) : @regular_space.{0} (ordered_cancel_add_comm_monoid.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (ordered_cancel_add_comm_monoid.{0} pos))  := sorry --non-trivial
lemma new_lemma_134436 (h0 : complete_lattice (free_add_monoid num)) : is_compactly_generated (free_add_monoid num) := sorry --non-trivial
lemma new_lemma_134437 (h0 : functor.add_const (function.extfun Type add_monoid) Type) : @add_monoid.fg.{0} (normed_comm_ring.{0} pos) (@function.extfun_app.{2 1} Type add_monoid.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type add_monoid.{0}) Type h0) (normed_comm_ring.{0} pos))  := sorry --non-trivial
lemma new_lemma_134438 (h0 : topological_space (has_Inf (has_Inf (has_add real)))) : path_connected_space (has_Inf (has_Inf (has_add real))) := sorry --non-trivial
lemma new_lemma_134439 (h0 : topological_space (finset environment.implicit_infer_kind)) : preirreducible_space (finset environment.implicit_infer_kind) := sorry --non-trivial
lemma new_lemma_134440 (h0 : function.extfun Type (functor.comp topological_space has_neg_part)) : @topological_space.separable_space.{0} (has_neg_part.{0} name) (@functor.comp.run.{0 0 0} topological_space.{0} has_neg_part.{0} name (@function.extfun_app.{2 1} Type (functor.comp.{0 0 0} topological_space.{0} has_neg_part.{0}) h0 name))  := sorry --non-trivial
lemma new_lemma_134441 (h0 : group (with_one (has_top unsigned))) : normalizer_condition (with_one (has_top unsigned)) := sorry --non-trivial
lemma new_lemma_134442 (h0 : topological_space (has_top empty)) : discrete_topology (has_top empty) := sorry --non-trivial
lemma new_lemma_134443 (h0 : not (filter (has_top linarith.ineq) -> false)) : filter.ne_bot (classical.by_contradiction' h0) := sorry --non-trivial
lemma new_lemma_134444 (h0 : function.extfun Type (functor.add_const (semiring (is_R_or_C empty)))) : @is_noetherian_ring.{0} (is_R_or_C.{0} empty) (@functor.add_const.run.{0 0} (semiring.{0} (is_R_or_C.{0} empty)) empty (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (semiring.{0} (is_R_or_C.{0} empty))) h0 empty))  := sorry --non-trivial
lemma new_lemma_134445 (h0 : measurable_space (pseudo_metric_space empty)) (h1 : topological_space (measure_theory.measure (pseudo_metric_space empty))) : totally_disconnected_space (measure_theory.measure (pseudo_metric_space empty)) := sorry --non-trivial
lemma new_lemma_134446 (h0 : function.extfun Type cancel_comm_monoid_with_zero) : @unique_factorization_monoid.{0} (has_nndist.{0} unsigned) (@function.extfun_app.{2 1} Type cancel_comm_monoid_with_zero.{0} h0 (has_nndist.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_134447 (h0 : topological_space (linear_ordered_field (option unsigned))) : t0_space (linear_ordered_field (option unsigned)) := sorry --non-trivial
lemma new_lemma_134448 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @complete_space.{0} (preorder.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type uniform_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 uniform_space.{0}) (preorder.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_134449 (h0 : function.extfun Type (functor.add_const (topological_space (has_Inf linarith.comp)))) : @normal_space.{0} (has_Inf.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (has_Inf.{0} linarith.comp)) linarith.comp (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (topological_space.{0} (has_Inf.{0} linarith.comp))) h0 linarith.comp))  := sorry --non-trivial
lemma new_lemma_134450 (h0 : set (add_comm_semigroup (mul_one_class ereal) -> mul_one_class fun_info)) : set.separates_points h0 := sorry --non-trivial
lemma new_lemma_134451 (h0 : ring (group_with_zero num)) : rank_condition (group_with_zero num) := sorry --non-trivial
lemma new_lemma_134452 (h0 : ring (measurable_space (semiring linarith.comp))) : is_domain (measurable_space (semiring linarith.comp)) := sorry --non-trivial
lemma new_lemma_134453 (h0 : topological_space (has_to_string (has_nndist (has_nndist unsigned)))) : path_connected_space (has_to_string (has_nndist (has_nndist unsigned))) := sorry --non-trivial
lemma new_lemma_134454 (h0 : function.extfun Type topological_space) : @totally_disconnected_space.{0} (semiring.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (semiring.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_134455 (h0 : uniform_space (measurable_space (random_gen num))) : complete_space (measurable_space (random_gen num)) := sorry --non-trivial
lemma new_lemma_134456 (h0 : topological_space (semi_normed_ring fun_info)) : totally_disconnected_space (semi_normed_ring fun_info) := sorry --non-trivial
lemma new_lemma_134457 (h0 : function.extfun nat fin) : @normal_space.{1} (generalized_boolean_algebra.{1} Type) (@matrix.vec_empty.{1} (topological_space.{1} (generalized_boolean_algebra.{1} Type)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_134458 (h0 : ring (has_compl (random_gen (random_gen linarith.ineq)))) : rank_condition (has_compl (random_gen (random_gen linarith.ineq))) := sorry --non-trivial
lemma new_lemma_134459 (h0 : function.extfun Type topological_space) : @t1_space.{0} (has_bot.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_bot.{0} pos))  := sorry --non-trivial
lemma new_lemma_134460 (h0 : topological_space (pseudo_metric_space (has_nndist (has_add name)))) : topological_space.separable_space (pseudo_metric_space (has_nndist (has_add name))) := sorry --non-trivial
lemma new_lemma_134461 (h0 : function.extfun (Type 1) complete_lattice) : @is_compactly_generated.{1} (boolean_algebra.core.{1} Type) (@function.extfun_app.{3 2} (Type 1) complete_lattice.{1} h0 (boolean_algebra.core.{1} Type))  := sorry --non-trivial
lemma new_lemma_134462 (h0 : topological_space (random_gen (has_norm (semiring empty)))) : totally_disconnected_space (random_gen (has_norm (semiring empty))) := sorry --non-trivial
lemma new_lemma_134463 (h0 : topological_space (canonically_ordered_monoid (option (option (option empty))))) : path_connected_space (canonically_ordered_monoid (option (option (option empty)))) := sorry --non-trivial
lemma new_lemma_134464 (h0 : ring (ring (option (option unsigned)))) : strong_rank_condition (ring (option (option unsigned))) := sorry --non-trivial
lemma new_lemma_134465 (h0 : functor.add_const (finset (has_neg_part linarith.comp)) (finset pos)) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_134466 (h0 : topological_space (simple_graph (has_neg Type))) : normal_space (simple_graph (has_neg Type)) := sorry --non-trivial
lemma new_lemma_134467 (h0 : functor.add_const (complete_lattice (has_neg_part Type)) Type) : @is_compactly_generated.{1} (has_neg_part.{1} Type) (@functor.add_const.run.{1 1} (complete_lattice.{1} (has_neg_part.{1} Type)) Type h0)  := sorry --non-trivial
lemma new_lemma_134468 (h0 : uniform_space (finset (mul_one_class (ring linarith.comp)))) : separated_space (finset (mul_one_class (ring linarith.comp))) := sorry --non-trivial
lemma new_lemma_134469 (h0 : functor.add_const (complete_lattice (has_nndist Type)) unsigned) : @complete_lattice.is_Sup_finite_compact.{1} (has_nndist.{1} Type) (@functor.add_const.run.{1 0} (complete_lattice.{1} (has_nndist.{1} Type)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_134470 (h0 : filter (random_gen (random_gen (random_gen (random_gen (random_gen char)))))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_134471 (h0 : add_group (linear_ordered_semiring unsigned)) : is_add_cyclic (linear_ordered_semiring unsigned) := sorry --non-trivial
lemma new_lemma_134472 (h0 : uniform_space (complete_distrib_lattice (ring (ring Type)))) : separated_space (complete_distrib_lattice (ring (ring Type))) := sorry --non-trivial
lemma new_lemma_134473 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_cyclic.{0} fun_info (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) fun_info)  := sorry --non-trivial
lemma new_lemma_134474 (h0 : group (option (semiring (semiring unsigned)))) : group.fg (option (semiring (semiring unsigned))) := sorry --non-trivial
lemma new_lemma_134475 (h0 : function.extfun Type complete_lattice) : @is_atomistic.{0} (ring.{0} unsigned) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (ring.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_134476 (h0 : function.extfun Type uniform_space) : @complete_space.{0} (has_Inf.{0} pos) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (has_Inf.{0} pos))  := sorry --non-trivial
lemma new_lemma_134477 (h0 : ring (comm_ring (has_ssubset linarith.ineq))) : strong_rank_condition (comm_ring (has_ssubset linarith.ineq)) := sorry --non-trivial
lemma new_lemma_134478 (h0 : complete_lattice (non_unital_non_assoc_semiring std_gen)) : is_compactly_generated (non_unital_non_assoc_semiring std_gen) := sorry --non-trivial
lemma new_lemma_134479 (h0 : ring (has_neg (finset (has_add linarith.comp)))) : strong_rank_condition (has_neg (finset (has_add linarith.comp))) := sorry --non-trivial
lemma new_lemma_134480 (h1 : topological_space (encodable fun_info)) : path_connected_space (encodable fun_info) := sorry --non-trivial
lemma new_lemma_134481 (h0 : function.extfun Type add_group) : @is_add_cyclic.{0} string_imp (@function.extfun_app.{2 1} Type add_group.{0} h0 string_imp)  := sorry --non-trivial
lemma new_lemma_134482 (h0 : topological_space (has_to_string (semigroup pos))) : path_connected_space (has_to_string (semigroup pos)) := sorry --non-trivial
lemma new_lemma_134483 (h0 : has_mem.mem (semiring linarith.comp) has_emptyc.emptyc) : @is_domain.{0} (semiring.{0} linarith.comp) (@finset.pi.empty.{1 0} Type ring.{0} (semiring.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_134484 (h0 : not (topological_space (add_group num) -> false)) : @locally_compact_space.{0} (add_group.{0} num) (@classical.by_contradiction'.{1} (topological_space.{0} (add_group.{0} num)) h0)  := sorry --non-trivial
lemma new_lemma_134485 (h0 : functor.add_const (topological_space (add_cancel_monoid empty)) num) : @preirreducible_space.{0} (add_cancel_monoid.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (add_cancel_monoid.{0} empty)) num h0)  := sorry --non-trivial
lemma new_lemma_134486 (h0 : function.extfun Type topological_space) : @t0_space.{0} (semigroup.{0} (semiring.{0} (semiring.{0} (semiring.{0} unsigned)))) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (semigroup.{0} (semiring.{0} (semiring.{0} (semiring.{0} unsigned)))))  := sorry --non-trivial
lemma new_lemma_134487 (h0 : topological_space (has_nndist (normed_comm_ring (finset linarith.comp)))) : locally_compact_space (has_nndist (normed_comm_ring (finset linarith.comp))) := sorry --non-trivial
lemma new_lemma_134488 (h0 : functor.add_const (topological_space (canonically_linear_ordered_monoid unsigned)) pos) : @sequential_space.{0} (canonically_linear_ordered_monoid.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (canonically_linear_ordered_monoid.{0} unsigned)) pos h0)  := sorry --non-trivial
lemma new_lemma_134489 (h0 : add_group (uniform_space.core environment.implicit_infer_kind)) : is_add_cyclic (uniform_space.core environment.implicit_infer_kind) := sorry --non-trivial
lemma new_lemma_134490 (h0 : topological_space (has_pos_part (has_Inf (has_add Type)))) : sequential_space (has_pos_part (has_Inf (has_add Type))) := sorry --non-trivial
lemma new_lemma_134491 (h0 : function.extfun Type topological_space) : @discrete_topology.{0} (linear_ordered_comm_monoid_with_zero.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (linear_ordered_comm_monoid_with_zero.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_134492 (h0 : functor.comp list has_zero environment.implicit_infer_kind) : palindrome (functor.comp.run h0) := sorry --non-trivial
lemma new_lemma_134493 (h0 : ring (denumerable (has_nnnorm (has_nnnorm (has_nnnorm linarith.ineq))))) : strong_rank_condition (denumerable (has_nnnorm (has_nnnorm (has_nnnorm linarith.ineq)))) := sorry --non-trivial
lemma new_lemma_134494 (h0 : functor.add_const (topological_space (has_to_string unsigned)) Type) : @sequential_space.{0} (has_to_string.{0} unsigned) (@functor.add_const.run.{0 1} (topological_space.{0} (has_to_string.{0} unsigned)) Type h0)  := sorry --non-trivial
lemma new_lemma_134495 (h0 : not (function.extfun Type ring -> false)) : @rank_condition.{0} (has_union.{0} num) (@function.extfun_app.{2 1} Type ring.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type ring.{0}) h0) (has_union.{0} num))  := sorry --non-trivial
lemma new_lemma_134496 (h0 : functor.add_const (topological_space (has_to_string unsigned)) unsigned) : @discrete_topology.{0} (has_to_string.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (has_to_string.{0} unsigned)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_134497 (h0 h1 : multiset (comm_group (add_comm_semigroup (add_comm_semigroup fun_info)))) : multiset.disjoint h0 h1 := sorry --non-trivial
lemma new_lemma_134498 (h1 : measurable_space ereal) (h2 : measure_theory.measure ereal) : measure_theory.is_finite_measure h2 := sorry --non-trivial
lemma new_lemma_134499 (h0 : topological_space (has_bot (finset (has_Inf (has_Inf linarith.comp))))) : t0_space (has_bot (finset (has_Inf (has_Inf linarith.comp)))) := sorry --non-trivial
lemma new_lemma_134500 (h0 : ordered_add_comm_monoid (ordered_comm_ring (ring (has_add (with_bot Type))))) : archimedean (ordered_comm_ring (ring (has_add (with_bot Type)))) := sorry --non-trivial
lemma new_lemma_134501 (h0 : functor.add_const (topological_space (semigroup Type)) name) : @t0_space.{1} (semigroup.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (semigroup.{1} Type)) name h0)  := sorry --non-trivial
lemma new_lemma_134502 (h4 : topological_space string.iterator_imp) : totally_disconnected_space string.iterator_imp := sorry --non-trivial
lemma new_lemma_134503 (h1 : function.extfun (finset Type) (has_mem.mem (has_top num))) : @totally_disconnected_space.{0} (has_top.{0} num) (@finset.pi.empty.{1 0} Type topological_space.{0} (has_top.{0} num) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (has_top.{0} num)) h1 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_134504 (h0 : function.extfun Type ring) : @strong_rank_condition.{0} (linear_ordered_cancel_comm_monoid.{0} unsigned) (@function.extfun_app.{2 1} Type ring.{0} h0 (linear_ordered_cancel_comm_monoid.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_134505 (h0 : topological_space (generalized_boolean_algebra (has_add linarith.comp))) : sequential_space (generalized_boolean_algebra (has_add linarith.comp)) := sorry --non-trivial
lemma new_lemma_134506 (h0 : topological_space (finset (ring Type))) : irreducible_space (finset (ring Type)) := sorry --non-trivial
lemma new_lemma_134507 (h0 : ring (comm_ring (has_nnnorm fun_info))) : strong_rank_condition (comm_ring (has_nnnorm fun_info)) := sorry --non-trivial
lemma new_lemma_134508 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @t0_space.{0} (has_nndist.{0} ennreal) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_nndist.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_134509 (h0 : functor.add_const (ring (has_zero linarith.comp)) environment.implicit_infer_kind) : @rank_condition.{0} (has_zero.{0} linarith.comp) (@functor.add_const.run.{0 0} (ring.{0} (has_zero.{0} linarith.comp)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_134510 (h0 : functor.add_const (topological_space (generalized_boolean_algebra Type)) Type) : @irreducible_space.{1} (generalized_boolean_algebra.{1} Type) (@functor.add_const.run.{1 1} (topological_space.{1} (generalized_boolean_algebra.{1} Type)) Type h0)  := sorry --non-trivial
lemma new_lemma_134511 (h0 : function.extfun Type topological_space) : @path_connected_space.{0} (normed_linear_ordered_group.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (normed_linear_ordered_group.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_134512 (h0 : topological_space (has_pos_part (has_add linarith.comp))) : t1_space (has_pos_part (has_add linarith.comp)) := sorry --non-trivial
lemma new_lemma_134513 (h0 : complete_lattice (complete_distrib_lattice unsigned)) : complete_lattice.is_Sup_finite_compact (complete_distrib_lattice unsigned) := sorry --non-trivial
lemma new_lemma_134514 (h0 : function.extfun Type semiring) : @is_noetherian_ring.{0} (generalized_boolean_algebra.{0} pos) (@function.extfun_app.{2 1} Type semiring.{0} h0 (generalized_boolean_algebra.{0} pos))  := sorry --non-trivial
lemma new_lemma_134515 (h0 : ring (with_one (random_gen (random_gen empty)))) : rank_condition (with_one (random_gen (random_gen empty))) := sorry --non-trivial
lemma new_lemma_134516 (h0 : cancel_comm_monoid_with_zero (has_one (has_top num))) : unique_factorization_monoid (has_one (has_top num)) := sorry --non-trivial
lemma new_lemma_134517 (h2 : preorder string.iterator_imp) (h3 : set string.iterator_imp) : set.separates_points (id (fun (h0 : add_comm_semigroup ereal -> fun_info), set.is_pwo h3)) := sorry --non-trivial
lemma new_lemma_134518 (h0 : function.extfun Type (functor.add_const (topological_space (is_R_or_C empty)))) : @path_connected_space.{0} (is_R_or_C.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (is_R_or_C.{0} empty)) empty (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (topological_space.{0} (is_R_or_C.{0} empty))) h0 empty))  := sorry --non-trivial
lemma new_lemma_134519 (h0 : functor.add_const Prop (normed_comm_ring (has_add (normed_comm_ring Type)))) : functor.add_const.run h0 := sorry --non-trivial
lemma new_lemma_134520 (h0 : ring (ordered_comm_ring (has_add (has_Inf Type)))) : strong_rank_condition (ordered_comm_ring (has_add (has_Inf Type))) := sorry --non-trivial
lemma new_lemma_134521 (h0 : not (function.extfun Type topological_space -> false)) : @irreducible_space.{0} (complete_semilattice_Sup.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (complete_semilattice_Sup.{0} num))  := sorry --non-trivial
lemma new_lemma_134522 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @group.fg.{0} (boolean_algebra.core.{0} pos) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (boolean_algebra.core.{0} pos))  := sorry --non-trivial
lemma new_lemma_134523 (h0 : topological_space (monoid (has_dist unsigned))) : normal_space (monoid (has_dist unsigned)) := sorry --non-trivial
lemma new_lemma_134524 (h0 : function.extfun Type finset) : finset.nonempty (function.extfun_app h0 (measurable_space.dynkin_system num)) := sorry --non-trivial
lemma new_lemma_134525 (h1 : complete_lattice (normed_group (random_gen to_additive.value_type))) : is_compactly_generated (normed_group (random_gen to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_134526 (h0 : functor.add_const (topological_space (has_Inf Type)) pos) : @locally_compact_space.{1} (has_Inf.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (has_Inf.{1} Type)) pos h0)  := sorry --non-trivial
lemma new_lemma_134527 (h0 : functor.add_const (topological_space (semiring num)) (semiring num)) : @totally_separated_space.{0} (semiring.{0} num) (@functor.add_const.run.{0 0} (topological_space.{0} (semiring.{0} num)) (semiring.{0} num) h0)  := sorry --non-trivial
lemma new_lemma_134528 (h0 : functor.add_const (function.extfun Type topological_space) Type) : @preconnected_space.{0} (boolean_algebra.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type topological_space.{0}) Type h0) (boolean_algebra.{0} name))  := sorry --non-trivial
lemma new_lemma_134529 (h0 : topological_space (has_bot (has_add (has_add Type)))) : locally_compact_space (has_bot (has_add (has_add Type))) := sorry --non-trivial
lemma new_lemma_134530 (h0 : not (semiring (semiring num) -> false)) : @is_noetherian_ring.{0} (semiring.{0} num) (@classical.by_contradiction'.{1} (semiring.{0} (semiring.{0} num)) h0)  := sorry --non-trivial
lemma new_lemma_134531 (h0 : group (has_neg_part (has_add (finset Type)))) : group.fg (has_neg_part (has_add (finset Type))) := sorry --non-trivial
lemma new_lemma_134532 (h0 : ring (measurable_space (random_gen (random_gen (random_gen (random_gen string_imp)))))) : is_domain (measurable_space (random_gen (random_gen (random_gen (random_gen string_imp))))) := sorry --non-trivial
lemma new_lemma_134533 (h0 : functor.add_const (list (has_to_string Type)) (normed_comm_ring pos)) : list.nodup (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_134534 (h0 : not (ring (linear_ordered_comm_group_with_zero reducibility_hints) -> false)) : @rank_condition.{0} (linear_ordered_comm_group_with_zero.{0} reducibility_hints) (@classical.by_contradiction'.{1} (ring.{0} (linear_ordered_comm_group_with_zero.{0} reducibility_hints)) h0)  := sorry --non-trivial
lemma new_lemma_134535 (h1 : complete_lattice (random_gen reducibility_hints)) : is_compactly_generated (random_gen reducibility_hints) := sorry --non-trivial
lemma new_lemma_134536 (h0 : function.extfun Type group) : @normalizer_condition.{0} (ordered_ring.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type group.{0} h0 (ordered_ring.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_134537 (h0 : fin has_zero.zero) : @sequential_space.{0} pos (@matrix.vec_empty.{0} (topological_space.{0} pos) (@matrix.vec_empty.{0} (fin (@has_zero.zero.{0} nat nat.has_zero)) h0))  := sorry --non-trivial
lemma new_lemma_134538 (h0 : function.extfun Type ring) : @is_domain.{0} (linear_ordered_cancel_comm_monoid.{0} num) (@function.extfun_app.{2 1} Type ring.{0} h0 (linear_ordered_cancel_comm_monoid.{0} num))  := sorry --non-trivial
lemma new_lemma_134539 (h0 : topological_space (boolean_algebra unsigned)) : totally_separated_space (boolean_algebra unsigned) := sorry --non-trivial
lemma new_lemma_134540 (h0 : topological_space (add_right_cancel_monoid (semiring (semiring num)))) : t0_space (add_right_cancel_monoid (semiring (semiring num))) := sorry --non-trivial
lemma new_lemma_134541 (h0 : functor.add_const (group (has_to_string Type)) unsigned) : @group.fg.{1} (has_to_string.{1} Type) (@functor.add_const.run.{1 0} (group.{1} (has_to_string.{1} Type)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_134542 (h0 : function.extfun (Type 1) complete_lattice) : @is_atomistic.{1} (plift.{1} congr_arg_kind) (@function.extfun_app.{3 2} (Type 1) complete_lattice.{1} h0 (plift.{1} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_134543 (h0 : topological_space (normed_group (has_norm linarith.ineq))) : locally_compact_space (normed_group (has_norm linarith.ineq)) := sorry --non-trivial
lemma new_lemma_134544 (h0 : function.extfun Type uniform_space) : @separated_space.{0} (add_comm_monoid.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (add_comm_monoid.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_134545 (h0 : filter (has_add (finset pos))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_134546 (h0 : functor.add_const (function.extfun (Type 1) monoid) linarith.comp) : @monoid.fg.{1} (has_add.{1} Type) (@function.extfun_app.{3 2} (Type 1) monoid.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) monoid.{1}) linarith.comp h0) (has_add.{1} Type))  := sorry --non-trivial
lemma new_lemma_134547 (h0 : ring (has_nndist (generalized_boolean_algebra (ring (has_neg pos))))) : is_principal_ideal_ring (has_nndist (generalized_boolean_algebra (ring (has_neg pos)))) := sorry --non-trivial
lemma new_lemma_134548 (h0 : functor.add_const (complete_lattice (boolean_algebra.core pos)) name) : @is_compactly_generated.{0} (boolean_algebra.core.{0} pos) (@functor.add_const.run.{0 0} (complete_lattice.{0} (boolean_algebra.core.{0} pos)) name h0)  := sorry --non-trivial
lemma new_lemma_134549 (h0 : ring (comm_ring (mul_one_class char))) : rank_condition (comm_ring (mul_one_class char)) := sorry --non-trivial
lemma new_lemma_134550 (h0 : topological_space (has_to_string (option ennreal))) : loc_path_connected_space (has_to_string (option ennreal)) := sorry --non-trivial
lemma new_lemma_134551 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_compactly_generated.{0} (has_Inf.{0} name) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (has_Inf.{0} name))  := sorry --non-trivial
lemma new_lemma_134552 (h0 : complete_lattice (add_cancel_comm_monoid linarith.comp_source)) : is_compactly_generated (add_cancel_comm_monoid linarith.comp_source) := sorry --non-trivial
lemma new_lemma_134553 (h0 : topological_space (add_cancel_monoid (has_add unsigned))) : preirreducible_space (add_cancel_monoid (has_add unsigned)) := sorry --non-trivial
lemma new_lemma_134554 (h0 : finset (ordered_ring congr_arg_kind)) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_134555 (h0 : topological_space (linear_ordered_add_comm_group_with_top (option ennreal))) : normal_space (linear_ordered_add_comm_group_with_top (option ennreal)) := sorry --non-trivial
lemma new_lemma_134556 (h0 : functor.add_const (uniform_space (has_star num)) empty) : @complete_space.{0} (has_star.{0} num) (@functor.add_const.run.{0 0} (uniform_space.{0} (has_star.{0} num)) empty h0)  := sorry --non-trivial
lemma new_lemma_134557 (h0 : topological_space (linear_ordered_comm_ring (semiring (semiring congr_arg_kind)))) : discrete_topology (linear_ordered_comm_ring (semiring (semiring congr_arg_kind))) := sorry --non-trivial
lemma new_lemma_134558 (h1 : group (metric_space (random_gen char))) : is_cyclic (metric_space (random_gen char)) := sorry --non-trivial
lemma new_lemma_134559 (h1 : function.extfun Type topological_space) : @totally_disconnected_space.{0} (semiring.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type topological_space.{0} h1 (semiring.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_134560 (h0 : functor.add_const Prop (comm_semigroup (sub_neg_monoid pos))) : functor.add_const.run h0 := sorry --non-trivial
lemma new_lemma_134561 (h1 : group (denumerable linarith.comp_source)) : is_cyclic (denumerable linarith.comp_source) := sorry --non-trivial
lemma new_lemma_134562 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @complete_lattice.is_Sup_finite_compact.{0} (linear_ordered_field.{0} pos) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (linear_ordered_field.{0} pos))  := sorry --non-trivial
lemma new_lemma_134563 (h0 : functor.add_const (complete_lattice (semigroup pos)) (has_neg pos)) : @is_compactly_generated.{0} (semigroup.{0} pos) (@functor.add_const.run.{0 0} (complete_lattice.{0} (semigroup.{0} pos)) (has_neg.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_134564 (h0 : finset (has_zero ennreal)) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_134565 (h0 : topological_space (random_gen (metric_space to_additive.value_type))) : path_connected_space (random_gen (metric_space to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_134566 (h0 : function.extfun (add_monoid (has_one empty) -> false) (fun (x : add_monoid (has_one empty) -> false), false)) : @add_monoid.fg.{0} (has_one.{0} empty) (@classical.by_contradiction'.{1} (add_monoid.{0} (has_one.{0} empty)) (@function.extfun_app.{0 0} (add_monoid.{0} (has_one.{0} empty) → false) (λ (x : add_monoid.{0} (has_one.{0} empty) → false), false) h0))  := sorry --non-trivial
lemma new_lemma_134567 (h0 : not (function.extfun Type complete_lattice -> false)) : @is_atomistic.{0} (random_gen.{0} fun_info) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type complete_lattice.{0}) h0) (random_gen.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_134568 (h0 : add_group (normed_comm_ring (option pos))) : is_add_cyclic (normed_comm_ring (option pos)) := sorry --non-trivial
lemma new_lemma_134569 (h0 : topological_space (canonically_ordered_comm_semiring (option (option pos)))) : sequential_space (canonically_ordered_comm_semiring (option (option pos))) := sorry --non-trivial
lemma new_lemma_134570 (h0 : topological_space (has_add (mul_one_class (finset linarith.comp)))) : discrete_topology (has_add (mul_one_class (finset linarith.comp))) := sorry --non-trivial
lemma new_lemma_134571 (h0 : ring (denumerable (random_gen (div_inv_monoid fun_info)))) : strong_rank_condition (denumerable (random_gen (div_inv_monoid fun_info))) := sorry --non-trivial
lemma new_lemma_134572 (h0 : complete_lattice (uniform_space (mul_one_class (distrib string.iterator_imp)))) : is_compactly_generated (uniform_space (mul_one_class (distrib string.iterator_imp))) := sorry --non-trivial
lemma new_lemma_134573 (h0 : group (with_one (has_top linarith.comp_source))) : normalizer_condition (with_one (has_top linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_134574 (h0 : topological_space (normed_lattice_add_comm_group (has_add pos))) : totally_separated_space (normed_lattice_add_comm_group (has_add pos)) := sorry --non-trivial
lemma new_lemma_134575 (h0 : function.extfun Type group) : @is_cyclic.{0} (comm_group.{0} name) (@function.extfun_app.{2 1} Type group.{0} h0 (comm_group.{0} name))  := sorry --non-trivial
lemma new_lemma_134576 (h0 : functor.add_const (function.extfun (Type 1) uniform_space) (ring pos)) : @complete_space.{1} (has_add.{1} Type) (@function.extfun_app.{3 2} (Type 1) uniform_space.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) uniform_space.{1}) (ring.{0} pos) h0) (has_add.{1} Type))  := sorry --non-trivial
lemma new_lemma_134577 (h1 : not (uniform_space (semi_normed_comm_ring string_imp) -> false)) : @complete_space.{0} (semi_normed_comm_ring.{0} string_imp) (@classical.by_contradiction'.{1} (uniform_space.{0} (semi_normed_comm_ring.{0} string_imp)) h1)  := sorry --non-trivial
lemma new_lemma_134578 (h0 : functor.add_const Prop (monoid_with_zero ennreal)) : functor.add_const.run h0 := sorry --non-trivial
lemma new_lemma_134579 (h0 : not (has_mem.mem topological_space has_emptyc.emptyc -> false)) : @locally_compact_space.{0} (linear_ordered_semiring.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) topological_space.{0} (@classical.by_contradiction'.{0} (@has_mem.mem.{1 1} (Type → Type) (finset.{1} (Type → Type)) (@finset.has_mem.{1} (Type → Type)) topological_space.{0} (@has_emptyc.emptyc.{1} (finset.{1} (Type → Type)) (@finset.has_emptyc.{1} (Type → Type)))) h0)) (linear_ordered_semiring.{0} empty))  := sorry --non-trivial
lemma new_lemma_134580 (h0 : function.extfun Type topological_space) : @topological_space.separable_space.{0} (canonically_ordered_comm_semiring.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (canonically_ordered_comm_semiring.{0} name))  := sorry --non-trivial
lemma new_lemma_134581 (h0 : function.extfun Type ring) : @rank_condition.{0} (normed_group.{0} string_imp) (@function.extfun_app.{2 1} Type ring.{0} h0 (normed_group.{0} string_imp))  := sorry --non-trivial
lemma new_lemma_134582 (h0 : group (ordered_comm_monoid (has_add (has_add linarith.comp)))) : is_simple_group (ordered_comm_monoid (has_add (has_add linarith.comp))) := sorry --non-trivial
lemma new_lemma_134583 (h0 : monoid (complete_linear_order (semiring (semiring (semiring congr_arg_kind))))) : monoid.fg (complete_linear_order (semiring (semiring (semiring congr_arg_kind)))) := sorry --non-trivial
lemma new_lemma_134584 (h0 : ring (add_cancel_monoid (has_Inf (ring (has_pos_part linarith.comp))))) : rank_condition (add_cancel_monoid (has_Inf (ring (has_pos_part linarith.comp)))) := sorry --non-trivial
lemma new_lemma_134585 (h0 : function.extfun Type add_group) : @is_add_cyclic.{0} (has_edist.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type add_group.{0} h0 (has_edist.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_134586 (h0 : function.extfun Type monoid) : @monoid.fg.{0} (measure_theory.measure_space.{0} num) (@function.extfun_app.{2 1} Type monoid.{0} h0 (measure_theory.measure_space.{0} num))  := sorry --non-trivial
lemma new_lemma_134587 (h0 : group (has_emptyc (random_gen congr_arg_kind))) : group.fg (has_emptyc (random_gen congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_134588 (h0 : not (function.extfun Type monoid -> false)) : @monoid.fg.{0} (complete_semilattice_Sup.{0} empty) (@function.extfun_app.{2 1} Type monoid.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type monoid.{0}) h0) (complete_semilattice_Sup.{0} empty))  := sorry --non-trivial
lemma new_lemma_134589 (h0 : topological_space (mul_one_class enat)) (h1 : ring (topological_space.nonempty_compacts (mul_one_class enat))) : rank_condition (topological_space.nonempty_compacts (mul_one_class enat)) := sorry --non-trivial
lemma new_lemma_134590 (h0 : topological_space (non_assoc_semiring congr_arg_kind)) : t1_space (non_assoc_semiring congr_arg_kind) := sorry --non-trivial
lemma new_lemma_134591 (h0 : list (dlist (has_nnnorm (has_nnnorm (has_nnnorm fun_info))))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_134592 (h0 : ring (nondiscrete_normed_field fun_info)) : is_domain (nondiscrete_normed_field fun_info) := sorry --non-trivial
lemma new_lemma_134593 (h0 : semiring stieltjes_function) (h1 : ring (polynomial stieltjes_function)) : rank_condition (polynomial stieltjes_function) := sorry --non-trivial
lemma new_lemma_134594 (h0 : function.extfun Type topological_space) : @discrete_topology.{0} (monoid.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (monoid.{0} num))  := sorry --non-trivial
lemma new_lemma_134595 (h0 : functor.add_const (cancel_comm_monoid_with_zero (ring pos)) (has_add (has_add pos))) : @unique_factorization_monoid.{0} (ring.{0} pos) (@functor.add_const.run.{0 0} (cancel_comm_monoid_with_zero.{0} (ring.{0} pos)) (has_add.{0} (has_add.{0} pos)) h0)  := sorry --non-trivial
lemma new_lemma_134596 (h0 : measurable_space (semi_normed_comm_ring (mul_one_class reducibility_hints))) (h1 : filter (semi_normed_comm_ring (mul_one_class reducibility_hints))) : filter.is_measurably_generated h1 := sorry --non-trivial
lemma new_lemma_134597 (h0 : topological_space (add_group (semiring num))) : t0_space (add_group (semiring num)) := sorry --non-trivial
lemma new_lemma_134598 (h0 : ring (semi_normed_comm_ring (has_ssubset linarith.comp_source))) : strong_rank_condition (semi_normed_comm_ring (has_ssubset linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_134599 (h0 : functor.add_const (group (ring Type)) pos) : @normalizer_condition.{1} (ring.{1} Type) (@functor.add_const.run.{1 0} (group.{1} (ring.{1} Type)) pos h0)  := sorry --non-trivial
lemma new_lemma_134600 (h0 : uniform_space (monoid (option empty))) : complete_space (monoid (option empty)) := sorry --non-trivial
lemma new_lemma_134601 (h0 : complete_lattice (canonically_ordered_comm_semiring (finset ennreal))) : is_compactly_generated (canonically_ordered_comm_semiring (finset ennreal)) := sorry --non-trivial
lemma new_lemma_134602 (h0 : not (function.extfun Type ring -> false)) : @is_domain.{0} (linear_ordered_semiring.{0} empty) (@function.extfun_app.{2 1} Type ring.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type ring.{0}) h0) (linear_ordered_semiring.{0} empty))  := sorry --non-trivial
lemma new_lemma_134603 (h0 : function.extfun Type topological_space) : @locally_compact_space.{0} (linear_ordered_add_comm_group.{0} fun_info) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (linear_ordered_add_comm_group.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_134604 (h0 : function.extfun Type complete_lattice) : @complete_lattice.is_Sup_finite_compact.{0} (random_gen.{0} linarith.ineq) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (random_gen.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_134605 (h0 : not (group (measurable_space.dynkin_system empty) -> false)) : @group.fg.{0} (measurable_space.dynkin_system.{0} empty) (@classical.by_contradiction'.{1} (group.{0} (measurable_space.dynkin_system.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_134606 (h0 : group (comm_ring (has_nnnorm (random_gen to_additive.value_type)))) : group.fg (comm_ring (has_nnnorm (random_gen to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_134607 (h1 : add_group (encodable string_imp)) : is_add_cyclic (encodable string_imp) := sorry --non-trivial
lemma new_lemma_134608 (h0 : cancel_comm_monoid_with_zero (generalized_boolean_algebra pos)) : unique_factorization_monoid (generalized_boolean_algebra pos) := sorry --non-trivial
lemma new_lemma_134609 (h0 : topological_space (has_Inf (ordered_comm_monoid (has_Inf real)))) : locally_compact_space (has_Inf (ordered_comm_monoid (has_Inf real))) := sorry --non-trivial
lemma new_lemma_134610 (h0 : finset (add_comm_monoid ennreal)) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_134611 (h0 : topological_space (has_neg (has_neg_part pos))) : totally_disconnected_space (has_neg (has_neg_part pos)) := sorry --non-trivial
lemma new_lemma_134612 (h0 : set (omega_complete_partial_order to_additive.value_type)) : set.subsingleton h0 := sorry --non-trivial
lemma new_lemma_134613 (h0 : functor.add_const (topological_space (simple_graph Type)) pos) : @topological_space.separable_space.{1} (simple_graph.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (simple_graph.{1} Type)) pos h0)  := sorry --non-trivial
lemma new_lemma_134614 (h1 : group (denumerable reducibility_hints)) : is_cyclic (denumerable reducibility_hints) := sorry --non-trivial
lemma new_lemma_134615 (h0 : topological_space nnreal) : loc_path_connected_space nnreal := sorry --non-trivial
lemma new_lemma_134616 (h0 : not (function.extfun Type topological_space -> false)) : @t0_space.{0} (linear_ordered_semiring.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (linear_ordered_semiring.{0} empty))  := sorry --non-trivial
lemma new_lemma_134617 (h0 : complete_lattice (complete_distrib_lattice (finset (finset name)))) : is_compactly_generated (complete_distrib_lattice (finset (finset name))) := sorry --non-trivial
lemma new_lemma_134618 (h0 : has_lt (nondiscrete_normed_field (add_comm_semigroup string.iterator_imp))) : no_max_order (nondiscrete_normed_field (add_comm_semigroup string.iterator_imp)) := sorry --non-trivial
lemma new_lemma_134619 (h0 : uniform_space (has_neg name)) : complete_space (has_neg name) := sorry --non-trivial
lemma new_lemma_134620 (h0 : function.extfun Type complete_lattice) : @is_compactly_generated.{0} (has_sub.{0} empty) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (has_sub.{0} empty))  := sorry --non-trivial
lemma new_lemma_134621 (h0 : topological_space (boolean_algebra.core (has_add unsigned))) : t0_space (boolean_algebra.core (has_add unsigned)) := sorry --non-trivial
lemma new_lemma_134622 (h0 : list (add_cancel_monoid linarith.comp)) : palindrome h0 := sorry --non-trivial
lemma new_lemma_134623 (h1 : complete_lattice (random_gen (with_bot linarith.comp_source))) : is_atomistic (random_gen (with_bot linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_134624 (h0 : function.extfun Type monoid) : @monoid.fg.{0} (pseudo_metric_space.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type monoid.{0} h0 (pseudo_metric_space.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_134625 (h0 : topological_space (ordered_comm_monoid (finset linarith.comp))) : sequential_space (ordered_comm_monoid (finset linarith.comp)) := sorry --non-trivial
lemma new_lemma_134626 (h0 : finset (boolean_algebra (add_comm_monoid (comm_group name)))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_134627 (h0 : function.extfun Type ordered_add_comm_monoid) : @archimedean.{0} (has_add.{0} ennreal) (@function.extfun_app.{2 1} Type ordered_add_comm_monoid.{0} h0 (has_add.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_134628 (h0 : functor.add_const (ring (semiring num)) (semiring num)) : @is_principal_ideal_ring.{0} (semiring.{0} num) (@functor.add_const.run.{0 0} (ring.{0} (semiring.{0} num)) (semiring.{0} num) h0)  := sorry --non-trivial
lemma new_lemma_134629 (h0 : semiring (linear_ordered_semiring (semiring (has_norm num)))) : is_noetherian_ring (linear_ordered_semiring (semiring (has_norm num))) := sorry --non-trivial
lemma new_lemma_134630 (h0 : group (with_bot (has_inv linarith.ineq))) : normalizer_condition (with_bot (has_inv linarith.ineq)) := sorry --non-trivial
lemma new_lemma_134631 (h0 : topological_space (has_Sup num)) : t1_space (has_Sup num) := sorry --non-trivial
lemma new_lemma_134632 (h0 : functor.add_const (function.extfun Type ring) linarith.comp) : @rank_condition.{0} (has_pos_part.{0} name) (@function.extfun_app.{2 1} Type ring.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type ring.{0}) linarith.comp h0) (has_pos_part.{0} name))  := sorry --non-trivial
lemma new_lemma_134633 (h0 : ordered_comm_monoid (has_neg unsigned)) : has_exists_mul_of_le (has_neg unsigned) := sorry --non-trivial
lemma new_lemma_134634 (h0 : function.extfun Type add_monoid) : @add_monoid.fg.{0} (has_inter.{0} num) (@function.extfun_app.{2 1} Type add_monoid.{0} h0 (has_inter.{0} num))  := sorry --non-trivial
lemma new_lemma_134635 (h0 : functor.add_const (topological_space (ordered_comm_monoid linarith.comp)) linarith.comp) : @topological_space.separable_space.{0} (ordered_comm_monoid.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (ordered_comm_monoid.{0} linarith.comp)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_134636 (h0 : group (normed_comm_ring empty)) : group.fg (normed_comm_ring empty) := sorry --non-trivial
lemma new_lemma_134637 (h0 : monoid (finset (option unsigned))) : monoid.fg (finset (option unsigned)) := sorry --non-trivial
lemma new_lemma_134638 (h0 : semiring (has_ssubset (mul_one_class enat))) (h1 : ideal (has_ssubset (mul_one_class enat))) : ideal.is_prime h1 := sorry --non-trivial
lemma new_lemma_134639 (h0 : function.extfun Type (functor.comp topological_space complete_distrib_lattice)) : @discrete_topology.{0} (complete_distrib_lattice.{0} pos) (@functor.comp.run.{0 0 0} topological_space.{0} complete_distrib_lattice.{0} pos (@function.extfun_app.{2 1} Type (functor.comp.{0 0 0} topological_space.{0} complete_distrib_lattice.{0}) h0 pos))  := sorry --non-trivial
lemma new_lemma_134640 (h0 : topological_space (left_cancel_semigroup unsigned)) : t0_space (left_cancel_semigroup unsigned) := sorry --non-trivial
lemma new_lemma_134641 (h0 : group (normed_comm_ring (comm_group (has_add linarith.comp)))) : normalizer_condition (normed_comm_ring (comm_group (has_add linarith.comp))) := sorry --non-trivial
lemma new_lemma_134642 (h0 : functor.add_const Prop (ring (option (option pos)))) : functor.add_const.run h0 := sorry --non-trivial
lemma new_lemma_134643 (h1 : Prop) : set.separates_points (id (fun (h0 : fun_info -> enat), h1)) := sorry --non-trivial
lemma new_lemma_134644 (h0 : filter (canonically_ordered_comm_semiring pos)) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_134645 (h0 : topological_space (has_Sup congr_arg_kind)) : t1_space (has_Sup congr_arg_kind) := sorry --non-trivial
lemma new_lemma_134646 (h0 : fin has_zero.zero) : @normalizer_condition.{0} (normed_lattice_add_comm_group.{0} pos) (@matrix.vec_empty.{0} (group.{0} (normed_lattice_add_comm_group.{0} pos)) h0)  := sorry --non-trivial
lemma new_lemma_134647 (h0 : group (has_pos_part (ring (has_Inf pos)))) : is_cyclic (has_pos_part (ring (has_Inf pos))) := sorry --non-trivial
lemma new_lemma_134648 (h0 : topological_space (has_top (semiring linarith.comp))) : discrete_topology (has_top (semiring linarith.comp)) := sorry --non-trivial
lemma new_lemma_134649 (h0 : prod (canonically_linear_ordered_monoid ennreal) (canonically_linear_ordered_monoid ennreal)) : id_rel h0 := sorry --non-trivial
lemma new_lemma_134650 (h0 : topological_space (simple_graph Type)) : preconnected_space (simple_graph Type) := sorry --non-trivial
lemma new_lemma_134651 (h0 : topological_space (comm_semigroup (comm_semigroup real))) : preirreducible_space (comm_semigroup (comm_semigroup real)) := sorry --non-trivial
lemma new_lemma_134652 (h0 : functor.add_const (topological_space (left_cancel_monoid empty)) unsigned) : @topological_space.separable_space.{0} (left_cancel_monoid.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (left_cancel_monoid.{0} empty)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_134653 (h0 : list (add_cancel_comm_monoid (option unsigned))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_134654 (h0 : uniform_space (complete_distrib_lattice (has_bot (has_bot (has_Inf real))))) : complete_space (complete_distrib_lattice (has_bot (has_bot (has_Inf real)))) := sorry --non-trivial
lemma new_lemma_134655 (h0 : function.extfun Type semiring) : @is_noetherian_ring.{0} auto.case_option (@function.extfun_app.{2 1} Type semiring.{0} h0 auto.case_option)  := sorry --non-trivial
lemma new_lemma_134656 (h0 : functor.add_const (filter (boolean_algebra linarith.comp)) (normed_comm_ring (has_Inf linarith.comp))) : countable_Inter_filter (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_134657 (h0 : not (complete_lattice (has_append to_additive.value_type) -> false)) : @complete_lattice.is_Sup_finite_compact.{0} (has_append.{0} to_additive.value_type) (@classical.by_contradiction'.{1} (complete_lattice.{0} (has_append.{0} to_additive.value_type)) h0)  := sorry --non-trivial
lemma new_lemma_134658 (h0 : function.extfun Type list) : list.nodup (function.extfun_app h0 (option (option num))) := sorry --non-trivial
lemma new_lemma_134659 (h0 : not (ring (has_star empty) -> false)) : @is_domain.{0} (has_star.{0} empty) (@classical.by_contradiction'.{1} (ring.{0} (has_star.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_134660 (h0 h1 : list (has_nnnorm environment.projection_info)) : list.is_suffix h0 h1 := sorry --non-trivial
lemma new_lemma_134661 (h0 : topological_space (comm_semigroup (sub_neg_monoid (ordered_comm_monoid Type)))) : totally_separated_space (comm_semigroup (sub_neg_monoid (ordered_comm_monoid Type))) := sorry --non-trivial
lemma new_lemma_134662 (h0 : functor.add_const (topological_space (measure_theory.measure_space empty)) (semiring empty)) : @loc_path_connected_space.{0} (measure_theory.measure_space.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (measure_theory.measure_space.{0} empty)) (semiring.{0} empty) h0)  := sorry --non-trivial
lemma new_lemma_134663 (h0 : topological_space (has_zero (mul_zero_class (semigroup (has_neg name))))) : path_connected_space (has_zero (mul_zero_class (semigroup (has_neg name)))) := sorry --non-trivial
lemma new_lemma_134664 (h0 : functor.add_const (group (has_neg linarith.comp)) (ring (finset environment.implicit_infer_kind))) : @group.fg.{0} (has_neg.{0} linarith.comp) (@functor.add_const.run.{0 0} (group.{0} (has_neg.{0} linarith.comp)) (ring.{0} (finset.{0} environment.implicit_infer_kind)) h0)  := sorry --non-trivial
lemma new_lemma_134665 (h0 : list (cancel_monoid congr_arg_kind)) : palindrome h0 := sorry --non-trivial
lemma new_lemma_134666 (h0 : add_group (has_le (has_ssubset (simple_graph (normed_field std_gen))))) : is_add_cyclic (has_le (has_ssubset (simple_graph (normed_field std_gen)))) := sorry --non-trivial
lemma new_lemma_134667 (h0 : topological_space (omega_complete_partial_order (semiring (semiring (semiring empty))))) : locally_compact_space (omega_complete_partial_order (semiring (semiring (semiring empty)))) := sorry --non-trivial
lemma new_lemma_134668 (h0 : topological_space (option name)) : regular_space (option name) := sorry --non-trivial
lemma new_lemma_134669 (h0 : function.extfun Type topological_space) : @irreducible_space.{0} (cancel_monoid.{0} ennreal) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (cancel_monoid.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_134670 (h0 : complete_lattice (has_emptyc (random_gen (random_gen (random_gen to_additive.value_type))))) : is_atomistic (has_emptyc (random_gen (random_gen (random_gen to_additive.value_type)))) := sorry --non-trivial
lemma new_lemma_134671 (h0 : add_group (uniform_space (metric_space linarith.comp_source))) : is_add_cyclic (uniform_space (metric_space linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_134672 (h0 : complete_lattice (topological_space (denumerable (denumerable char)))) : is_compactly_generated (topological_space (denumerable (denumerable char))) := sorry --non-trivial
lemma new_lemma_134673 (h0 : ordered_add_comm_monoid (linear_ordered_comm_monoid_with_zero num)) : archimedean (linear_ordered_comm_monoid_with_zero num) := sorry --non-trivial
lemma new_lemma_134674 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_compactly_generated.{0} (add_group.{0} empty) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (add_group.{0} empty))  := sorry --non-trivial
lemma new_lemma_134675 (h0 : functor.add_const (function.extfun Type list) pos) : list.nodup (function.extfun_app (functor.add_const.run h0) linarith.comp) := sorry --non-trivial
lemma new_lemma_134676 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @preirreducible_space.{0} (monoid_with_zero.{0} (option.{0} unsigned)) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (monoid_with_zero.{0} (option.{0} unsigned)))  := sorry --non-trivial
lemma new_lemma_134677 (h0 : not (topological_space (distrib_lattice linarith.ineq) -> false)) : @locally_compact_space.{0} (distrib_lattice.{0} linarith.ineq) (@classical.by_contradiction'.{1} (topological_space.{0} (distrib_lattice.{0} linarith.ineq)) h0)  := sorry --non-trivial
lemma new_lemma_134678 (h0 : functor.add_const (ring (left_cancel_monoid num)) num) : @is_principal_ideal_ring.{0} (left_cancel_monoid.{0} num) (@functor.add_const.run.{0 0} (ring.{0} (left_cancel_monoid.{0} num)) num h0)  := sorry --non-trivial
lemma new_lemma_134679 (h0 : functor.comp topological_space add_cancel_monoid (finset name)) : @discrete_topology.{0} (add_cancel_monoid.{0} (finset.{0} name)) (@functor.comp.run.{0 0 0} topological_space.{0} add_cancel_monoid.{0} (finset.{0} name) h0)  := sorry --non-trivial
lemma new_lemma_134680 (h0 : prod (add_comm_semigroup (add_comm_semigroup ereal)) (add_comm_semigroup (add_comm_semigroup ereal))) : set.diagonal (add_comm_semigroup (add_comm_semigroup ereal)) h0 := sorry --non-trivial
lemma new_lemma_134681 (h0 : functor.add_const (complete_lattice (has_neg linarith.comp)) name) : @is_compactly_generated.{0} (has_neg.{0} linarith.comp) (@functor.add_const.run.{0 0} (complete_lattice.{0} (has_neg.{0} linarith.comp)) name h0)  := sorry --non-trivial
lemma new_lemma_134682 (h0 : fin has_zero.zero) : @monoid.fg.{0} (boolean_algebra.{0} real) (@matrix.vec_empty.{0} (monoid.{0} (boolean_algebra.{0} real)) h0)  := sorry --non-trivial
lemma new_lemma_134683 (h0 : topological_space (has_add (has_Inf pos))) : irreducible_space (has_add (has_Inf pos)) := sorry --non-trivial
lemma new_lemma_134684 (h0 : ring (has_top (has_norm to_additive.value_type))) : is_domain (has_top (has_norm to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_134685 (h1 : set (add_comm_semigroup (add_comm_semigroup char) -> std_gen)) : set.separates_points h1 := sorry --non-trivial
lemma new_lemma_134686 (h0 : topological_space (random_gen (has_top (has_top linarith.comp)))) : locally_compact_space (random_gen (has_top (has_top linarith.comp))) := sorry --non-trivial
lemma new_lemma_134687 (h0 : complete_lattice (free_add_monoid (option (option (option (option unsigned)))))) : is_atomistic (free_add_monoid (option (option (option (option unsigned))))) := sorry --non-trivial
lemma new_lemma_134688 (h1 : not (group linarith.comp -> false)) : @is_cyclic.{0} linarith.comp (@classical.by_contradiction'.{1} (group.{0} linarith.comp) h1)  := sorry --non-trivial
lemma new_lemma_134689 (h1 : function.extfun Type complete_lattice) : @is_compactly_generated.{0} (has_add.{0} string_imp) (@function.extfun_app.{2 1} Type complete_lattice.{0} h1 (has_add.{0} string_imp))  := sorry --non-trivial
lemma new_lemma_134690 (h0 : function.extfun Type topological_space) : @topological_space.separable_space.{0} (add_cancel_monoid.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (add_cancel_monoid.{0} num))  := sorry --non-trivial
lemma new_lemma_134691 (h0 : functor.add_const (topological_space (canonically_ordered_comm_semiring Type)) Type) : @locally_compact_space.{1} (canonically_ordered_comm_semiring.{1} Type) (@functor.add_const.run.{1 1} (topological_space.{1} (canonically_ordered_comm_semiring.{1} Type)) Type h0)  := sorry --non-trivial
lemma new_lemma_134692 (h0 h2 : nat) (h4 : Prop) : scope_trace (id (fun (h3 : unit), h4)) := sorry --non-trivial
lemma new_lemma_134693 (h0 : not (list (has_nnnorm linarith.comp_source) -> false)) : list.nodup (classical.by_contradiction' h0) := sorry --non-trivial
lemma new_lemma_134694 (h0 : topological_space (normed_lattice_add_comm_group pos)) : locally_compact_space (normed_lattice_add_comm_group pos) := sorry --non-trivial
lemma new_lemma_134695 (h2 : list linarith.ineq) : list.nodup h2 := sorry --non-trivial
lemma new_lemma_134696 (h0 : measurable_space (mul_one_class (mul_one_class (normed_field std_gen)))) (h1 : has_mul (mul_one_class (mul_one_class (normed_field std_gen)))) (h2 : measure_theory.measure (mul_one_class (mul_one_class (normed_field std_gen)))) : measure_theory.measure.is_mul_left_invariant h2 := sorry --non-trivial
lemma new_lemma_134697 (h0 : ordered_add_comm_monoid (ordered_comm_ring (has_add (finset linarith.comp)))) : archimedean (ordered_comm_ring (has_add (finset linarith.comp))) := sorry --non-trivial
lemma new_lemma_134698 (h0 : functor.add_const (function.extfun (Type 1) ring) linarith.comp) : @rank_condition.{1} (semigroup.{1} Type) (@function.extfun_app.{3 2} (Type 1) ring.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) ring.{1}) linarith.comp h0) (semigroup.{1} Type))  := sorry --non-trivial
lemma new_lemma_134699 (h1 : complete_lattice (has_emptyc linarith.comp)) : complete_lattice.is_Sup_finite_compact (has_emptyc linarith.comp) := sorry --non-trivial
lemma new_lemma_134700 (h0 : functor.add_const (function.extfun Type semiring) Type) : @is_noetherian_ring.{0} (semigroup.{0} name) (@function.extfun_app.{2 1} Type semiring.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type semiring.{0}) Type h0) (semigroup.{0} name))  := sorry --non-trivial
lemma new_lemma_134701 (h0 : topological_space (has_emptyc (random_gen (random_gen linarith.comp_source)))) : locally_compact_space (has_emptyc (random_gen (random_gen linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_134702 (h0 : ring (comm_ring (mul_one_class char))) : is_domain (comm_ring (mul_one_class char)) := sorry --non-trivial
lemma new_lemma_134703 (h1 : not (group (fintype to_additive.value_type) -> false)) : @is_cyclic.{0} (fintype.{0} to_additive.value_type) (@classical.by_contradiction'.{1} (group.{0} (fintype.{0} to_additive.value_type)) h1)  := sorry --non-trivial
lemma new_lemma_134704 (h0 : uniform_space (topological_space (has_nnnorm (has_lt (denumerable reducibility_hints))))) : complete_space (topological_space (has_nnnorm (has_lt (denumerable reducibility_hints)))) := sorry --non-trivial
lemma new_lemma_134705 (h0 : group (measurable_space.dynkin_system (has_norm unsigned))) : is_cyclic (measurable_space.dynkin_system (has_norm unsigned)) := sorry --non-trivial
lemma new_lemma_134706 (h0 : topological_space (has_one (semiring (semiring (semiring unsigned))))) : t0_space (has_one (semiring (semiring (semiring unsigned)))) := sorry --non-trivial
lemma new_lemma_134707 (h0 : not (topological_space fun_info -> false)) : @t0_space.{0} fun_info (@classical.by_contradiction'.{1} (topological_space.{0} fun_info) h0)  := sorry --non-trivial
lemma new_lemma_134708 (h0 : functor.add_const (add_group (has_to_string Type)) (ring name)) : @is_add_cyclic.{1} (has_to_string.{1} Type) (@functor.add_const.run.{1 0} (add_group.{1} (has_to_string.{1} Type)) (ring.{0} name) h0)  := sorry --non-trivial
lemma new_lemma_134709 (h1 : topological_space (linear_ordered_semiring fun_info)) : path_connected_space (linear_ordered_semiring fun_info) := sorry --non-trivial
lemma new_lemma_134710 (h0 : list (has_add name)) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_134711 (h0 : not (topological_space (non_unital_non_assoc_semiring char) -> false)) : @path_connected_space.{0} (non_unital_non_assoc_semiring.{0} char) (@classical.by_contradiction'.{1} (topological_space.{0} (non_unital_non_assoc_semiring.{0} char)) h0)  := sorry --non-trivial
lemma new_lemma_134712 (h0 : not (topological_space (denumerable reducibility_hints) -> false)) : @totally_disconnected_space.{0} (denumerable.{0} reducibility_hints) (@classical.by_contradiction'.{1} (topological_space.{0} (denumerable.{0} reducibility_hints)) h0)  := sorry --non-trivial
lemma new_lemma_134713 (h0 : functor.add_const (function.extfun (Type 1) complete_lattice) linarith.comp) : @complete_lattice.is_Sup_finite_compact.{1} (canonically_ordered_monoid.{1} Type) (@function.extfun_app.{3 2} (Type 1) complete_lattice.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) complete_lattice.{1}) linarith.comp h0) (canonically_ordered_monoid.{1} Type))  := sorry --non-trivial
lemma new_lemma_134714 (h0 : topological_space (has_to_string name)) : path_connected_space (has_to_string name) := sorry --non-trivial
lemma new_lemma_134715 (h0 : functor.add_const (group (canonically_ordered_comm_semiring ennreal)) (option name)) : @is_simple_group.{0} (canonically_ordered_comm_semiring.{0} ennreal) (@functor.add_const.run.{0 0} (group.{0} (canonically_ordered_comm_semiring.{0} ennreal)) (option.{0} name) h0)  := sorry --non-trivial
lemma new_lemma_134716 (h0 : cancel_comm_monoid_with_zero (metric_space (semiring (semiring unsigned)))) : unique_factorization_monoid (metric_space (semiring (semiring unsigned))) := sorry --non-trivial
lemma new_lemma_134717 (h0 : not (ring (has_append to_additive.value_type) -> false)) : @rank_condition.{0} (has_append.{0} to_additive.value_type) (@classical.by_contradiction'.{1} (ring.{0} (has_append.{0} to_additive.value_type)) h0)  := sorry --non-trivial
lemma new_lemma_134718 (h0 : functor.add_const (ring (comm_group linarith.comp)) (has_to_string Type)) : @is_principal_ideal_ring.{0} (comm_group.{0} linarith.comp) (@functor.add_const.run.{0 1} (ring.{0} (comm_group.{0} linarith.comp)) (has_to_string.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_134719 (h2 : ring (has_append to_additive.value_type)) : rank_condition (has_append to_additive.value_type) := sorry --non-trivial
lemma new_lemma_134720 (h0 : topological_space (has_edist unsigned)) : normal_space (has_edist unsigned) := sorry --non-trivial
lemma new_lemma_134721 (h0 : functor.add_const (complete_lattice (boolean_algebra.core Type)) (has_add pos)) : @is_atomistic.{1} (boolean_algebra.core.{1} Type) (@functor.add_const.run.{1 0} (complete_lattice.{1} (boolean_algebra.core.{1} Type)) (has_add.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_134722 (h1 : group (topological_space string_imp)) : is_cyclic (topological_space string_imp) := sorry --non-trivial
lemma new_lemma_134723 (h0 : uniform_space (with_one to_additive.value_type)) : separated_space (with_one to_additive.value_type) := sorry --non-trivial
lemma new_lemma_134724 (h0 : functor.add_const (ring (has_neg pos)) linarith.comp) : @strong_rank_condition.{0} (has_neg.{0} pos) (@functor.add_const.run.{0 0} (ring.{0} (has_neg.{0} pos)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_134725 (h0 : fin has_zero.zero) : @totally_disconnected_space.{0} (canonically_linear_ordered_monoid.{0} real) (@function.extfun_app.{2 1} Type topological_space.{0} (@matrix.vec_empty.{1} (function.extfun.{2 1} Type topological_space.{0}) h0) (canonically_linear_ordered_monoid.{0} real))  := sorry --non-trivial
lemma new_lemma_134726 (h0 : complete_lattice (cancel_monoid (option (option pos)))) : complete_lattice.is_Sup_finite_compact (cancel_monoid (option (option pos))) := sorry --non-trivial
lemma new_lemma_134727 (h0 : not (filter (complete_semilattice_Sup linarith.comp) -> false)) : filter.ne_bot (classical.by_contradiction' h0) := sorry --non-trivial
lemma new_lemma_134728 (h0 : group (complete_distrib_lattice (semigroup name))) : is_simple_group (complete_distrib_lattice (semigroup name)) := sorry --non-trivial
lemma new_lemma_134729 (h0 : ring (linear_ordered_semiring (has_top (has_top to_additive.value_type)))) : is_domain (linear_ordered_semiring (has_top (has_top to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_134730 (h0 : topological_space (boolean_algebra (has_neg_part (comm_group (has_add Type))))) : regular_space (boolean_algebra (has_neg_part (comm_group (has_add Type)))) := sorry --non-trivial
lemma new_lemma_134731 (h0 : function.extfun Type cancel_comm_monoid_with_zero) : @unique_factorization_monoid.{0} (boolean_algebra.core.{0} name) (@function.extfun_app.{2 1} Type cancel_comm_monoid_with_zero.{0} h0 (boolean_algebra.core.{0} name))  := sorry --non-trivial
lemma new_lemma_134732 (h0 : functor.add_const (list (finset Type)) pos) : palindrome (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_134733 (h0 : has_mem.mem (has_norm (has_norm empty)) has_emptyc.emptyc) : @is_domain.{0} (has_norm.{0} (has_norm.{0} empty)) (@finset.pi.empty.{1 0} Type ring.{0} (has_norm.{0} (has_norm.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_134734 (h0 : functor.add_const (topological_space (partial_order unsigned)) unsigned) : @regular_space.{0} (partial_order.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (partial_order.{0} unsigned)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_134735 (h0 : cancel_comm_monoid_with_zero (boolean_algebra.core (has_add Type))) : unique_factorization_monoid (boolean_algebra.core (has_add Type)) := sorry --non-trivial
lemma new_lemma_134736 (h0 : topological_space (has_add (has_neg_part unsigned))) : regular_space (has_add (has_neg_part unsigned)) := sorry --non-trivial
lemma new_lemma_134737 (h0 : group (generalized_boolean_algebra Type)) : is_cyclic (generalized_boolean_algebra Type) := sorry --non-trivial
lemma new_lemma_134738 (h0 : function.extfun (Type 1) semiring) : @is_noetherian_ring.{1} (plift.{1} congr_arg_kind) (@function.extfun_app.{3 2} (Type 1) semiring.{1} h0 (plift.{1} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_134739 (h0 : topological_space (generalized_boolean_algebra (sub_neg_monoid (has_add Type)))) : preirreducible_space (generalized_boolean_algebra (sub_neg_monoid (has_add Type))) := sorry --non-trivial
lemma new_lemma_134740 (h0 : function.extfun Type group) : @is_cyclic.{0} (normed_comm_ring.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type group.{0} h0 (normed_comm_ring.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_134741 (h0 : functor.add_const (topological_space (bin_tree num)) unsigned) : @t0_space.{0} (bin_tree.{0} num) (@functor.add_const.run.{0 0} (topological_space.{0} (bin_tree.{0} num)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_134742 (h1 : add_group (has_add linarith.comp_source)) : is_add_cyclic (has_add linarith.comp_source) := sorry --non-trivial
lemma new_lemma_134743 (h2 : function.extfun Type list) : list.nodup (function.extfun_app h2 (with_one linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_134744 (h0 : functor.add_const (ring (partial_order empty)) congr_arg_kind) : @rank_condition.{0} (partial_order.{0} empty) (@functor.add_const.run.{0 0} (ring.{0} (partial_order.{0} empty)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_134745 (h0 : ring (linear_ordered_semiring (has_top (semiring empty)))) : is_domain (linear_ordered_semiring (has_top (semiring empty))) := sorry --non-trivial
lemma new_lemma_134746 (h0 : functor.comp topological_space boolean_algebra name) : @topological_space.separable_space.{0} (boolean_algebra.{0} name) (@functor.comp.run.{0 0 0} topological_space.{0} boolean_algebra.{0} name h0)  := sorry --non-trivial
lemma new_lemma_134747 (h0 : functor.add_const (ordered_comm_monoid (finset linarith.comp)) name) : @has_exists_mul_of_le.{0} (finset.{0} linarith.comp) (@functor.add_const.run.{0 0} (ordered_comm_monoid.{0} (finset.{0} linarith.comp)) name h0)  := sorry --non-trivial
lemma new_lemma_134748 (h0 : function.extfun Type uniform_space) : @separated_space.{0} (has_sub.{0} num) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (has_sub.{0} num))  := sorry --non-trivial
lemma new_lemma_134749 (h0 : group (mul_zero_class pos)) : is_cyclic (mul_zero_class pos) := sorry --non-trivial
lemma new_lemma_134750 (h0 : functor.add_const (topological_space (has_neg_part unsigned)) linarith.comp) : @path_connected_space.{0} (has_neg_part.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (has_neg_part.{0} unsigned)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_134751 (h0 : ring (has_to_string (has_to_string (has_to_string (has_to_string (finset unsigned)))))) : is_domain (has_to_string (has_to_string (has_to_string (has_to_string (finset unsigned))))) := sorry --non-trivial
lemma new_lemma_134752 (h0 : topological_space (non_unital_non_assoc_semiring string_imp)) : totally_disconnected_space (non_unital_non_assoc_semiring string_imp) := sorry --non-trivial
lemma new_lemma_134753 (h0 : function.extfun Type uniform_space) : @complete_space.{0} (measurable_space.{0} string_imp) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (measurable_space.{0} string_imp))  := sorry --non-trivial
lemma new_lemma_134754 (h0 : topological_space (has_emptyc congr_arg_kind)) : t0_space (has_emptyc congr_arg_kind) := sorry --non-trivial
lemma new_lemma_134755 (h0 : complete_lattice (encodable (random_gen string_imp))) : is_compactly_generated (encodable (random_gen string_imp)) := sorry --non-trivial
lemma new_lemma_134756 (h0 : has_mem.mem string_imp has_emptyc.emptyc) : @is_atomistic.{0} string_imp (@finset.pi.empty.{1 0} Type complete_lattice.{0} string_imp h0)  := sorry --non-trivial
lemma new_lemma_134757 (h0 : functor.add_const (topological_space (add_cancel_monoid unsigned)) name) : @regular_space.{0} (add_cancel_monoid.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (add_cancel_monoid.{0} unsigned)) name h0)  := sorry --non-trivial
lemma new_lemma_134758 (h0 : functor.add_const (topological_space (finset environment.implicit_infer_kind)) linarith.comp) : @sequential_space.{0} (finset.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (finset.{0} environment.implicit_infer_kind)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_134759 (h0 : complete_lattice (has_Sup empty)) : is_compactly_generated (has_Sup empty) := sorry --non-trivial
lemma new_lemma_134760 (h0 : ring (plift num)) : strong_rank_condition (plift num) := sorry --non-trivial
lemma new_lemma_134761 (h0 : monoid (has_add real)) : monoid.fg (has_add real) := sorry --non-trivial
lemma new_lemma_134762 (h0 : functor.add_const (complete_lattice (ordered_comm_group empty)) empty) : @is_atomistic.{0} (ordered_comm_group.{0} empty) (@functor.add_const.run.{0 0} (complete_lattice.{0} (ordered_comm_group.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_134763 (h0 : functor.add_const (ring (has_to_string name)) linarith.comp) : @is_domain.{0} (has_to_string.{0} name) (@functor.add_const.run.{0 0} (ring.{0} (has_to_string.{0} name)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_134764 (h0 : list (linear_ordered_add_comm_group (measurable_space fun_info))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_134765 (h0 : functor.add_const (topological_space (cancel_monoid name)) environment.implicit_infer_kind) : @preirreducible_space.{0} (cancel_monoid.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (cancel_monoid.{0} name)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_134766 (h0 : topological_space (mul_one_class (mul_one_class (add_comm_semigroup fun_info)))) : t0_space (mul_one_class (mul_one_class (add_comm_semigroup fun_info))) := sorry --non-trivial
lemma new_lemma_134767 (h2 : add_group (add_monoid to_additive.value_type)) : is_add_cyclic (add_monoid to_additive.value_type) := sorry --non-trivial
lemma new_lemma_134768 (h0 : not (topological_space (denumerable linarith.comp_source) -> false)) : @t0_space.{0} (denumerable.{0} linarith.comp_source) (@classical.by_contradiction'.{1} (topological_space.{0} (denumerable.{0} linarith.comp_source)) h0)  := sorry --non-trivial
lemma new_lemma_134769 (h0 : semiring (simple_graph char)) (h1 : ideal (simple_graph char)) : ideal.is_prime h1 := sorry --non-trivial
lemma new_lemma_134770 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @group.fg.{0} (has_nndist.{0} linarith.comp) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (has_nndist.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_134771 (h0 : functor.add_const (group (has_zero pos)) (boolean_algebra linarith.comp)) : @is_cyclic.{0} (has_zero.{0} pos) (@functor.add_const.run.{0 0} (group.{0} (has_zero.{0} pos)) (boolean_algebra.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_134772 (h0 : function.extfun Type topological_space) : @totally_disconnected_space.{0} (cancel_monoid.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (cancel_monoid.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_134773 (h0 : topological_space (has_zero (finset (finset (finset pos))))) : regular_space (has_zero (finset (finset (finset pos)))) := sorry --non-trivial
lemma new_lemma_134774 (h0 : function.extfun Type semiring) : @is_noetherian_ring.{0} (add_group.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type semiring.{0} h0 (add_group.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_134775 (h1 : measurable_space (add_cancel_comm_monoid string_imp)) (h2 : filter (add_cancel_comm_monoid string_imp)) : filter.is_measurably_generated h2 := sorry --non-trivial
lemma new_lemma_134776 (h0 : functor.comp add_group has_add pos) : @is_add_cyclic.{0} (has_add.{0} pos) (@functor.comp.run.{0 0 0} add_group.{0} has_add.{0} pos h0)  := sorry --non-trivial
lemma new_lemma_134777 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @separated_space.{0} (ordered_cancel_add_comm_monoid.{0} num) (@function.extfun_app.{2 1} Type uniform_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 uniform_space.{0}) (ordered_cancel_add_comm_monoid.{0} num))  := sorry --non-trivial
lemma new_lemma_134778 (h0 : functor.add_const (topological_space (finset linarith.comp)) environment.implicit_infer_kind) : @totally_disconnected_space.{0} (finset.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (finset.{0} linarith.comp)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_134779 (h0 : ring (boolean_algebra.core linarith.comp)) : rank_condition (boolean_algebra.core linarith.comp) := sorry --non-trivial
lemma new_lemma_134780 (h0 : has_mem.mem (semiring linarith.comp_source) has_emptyc.emptyc) : @totally_disconnected_space.{0} (semiring.{0} linarith.comp_source) (@finset.pi.empty.{1 0} Type topological_space.{0} (semiring.{0} linarith.comp_source) h0)  := sorry --non-trivial
lemma new_lemma_134781 (h0 : ring (boolean_algebra.core (add_comm_monoid pos))) : is_principal_ideal_ring (boolean_algebra.core (add_comm_monoid pos)) := sorry --non-trivial
lemma new_lemma_134782 (h0 : list (boolean_algebra.core (comm_group Type))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_134783 (h0 : not (complete_lattice (has_ssubset string_imp) -> false)) : @complete_lattice.is_Sup_finite_compact.{0} (has_ssubset.{0} string_imp) (@classical.by_contradiction'.{1} (complete_lattice.{0} (has_ssubset.{0} string_imp)) h0)  := sorry --non-trivial
lemma new_lemma_134784 (h0 : functor.add_const Prop (has_Inf (has_add linarith.comp))) : functor.add_const.run h0 := sorry --non-trivial
lemma new_lemma_134785 (h0 : monoid (pseudo_metric_space (option empty))) : monoid.fg (pseudo_metric_space (option empty)) := sorry --non-trivial
lemma new_lemma_134786 (h0 : add_group (with_bot (has_norm fun_info))) : is_add_cyclic (with_bot (has_norm fun_info)) := sorry --non-trivial
lemma new_lemma_134787 (h0 : has_neg (nondiscrete_normed_field (add_comm_semigroup enat))) (h1 : measurable_space (nondiscrete_normed_field (add_comm_semigroup enat))) : has_measurable_neg (nondiscrete_normed_field (add_comm_semigroup enat)) := sorry --non-trivial
lemma new_lemma_134788 (h0 : function.extfun Type ring) : @is_principal_ideal_ring.{0} (ordered_comm_ring.{0} name) (@function.extfun_app.{2 1} Type ring.{0} h0 (ordered_comm_ring.{0} name))  := sorry --non-trivial
lemma new_lemma_134789 (h0 : uniform_space (has_pos_part (finset (has_pos_part (has_add linarith.comp))))) : separated_space (has_pos_part (finset (has_pos_part (has_add linarith.comp)))) := sorry --non-trivial
lemma new_lemma_134790 (h0 : function.extfun Type ring) : @is_domain.{0} (has_emptyc.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type ring.{0} h0 (has_emptyc.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_134791 (h0 : ring (with_one (comm_ring (random_gen to_additive.value_type)))) : is_domain (with_one (comm_ring (random_gen to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_134792 (h0 : not (finset (preorder unsigned) -> false)) : finset.nonempty (classical.by_contradiction' h0) := sorry --non-trivial
lemma new_lemma_134793 (h0 : not (ring (add_monoid char) -> false)) : @is_domain.{0} (add_monoid.{0} char) (@classical.by_contradiction'.{1} (ring.{0} (add_monoid.{0} char)) h0)  := sorry --non-trivial
lemma new_lemma_134794 (h0 : function.extfun Type topological_space) : @preirreducible_space.{0} (sub_neg_monoid.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (sub_neg_monoid.{0} name))  := sorry --non-trivial
lemma new_lemma_134795 (h0 : function.extfun Type topological_space) : @totally_separated_space.{0} (division_ring.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (division_ring.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_134796 (h0 : functor.add_const (complete_lattice (option ennreal)) ennreal) : @is_atomistic.{0} (option.{0} ennreal) (@functor.add_const.run.{0 0} (complete_lattice.{0} (option.{0} ennreal)) ennreal h0)  := sorry --non-trivial
lemma new_lemma_134797 (h0 : topological_space (linear_ordered_comm_group_with_zero string_imp)) : t0_space (linear_ordered_comm_group_with_zero string_imp) := sorry --non-trivial
lemma new_lemma_134798 (h0 : topological_space (has_Sup (semiring unsigned))) : t1_space (has_Sup (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_134799 (h0 : functor.add_const (complete_lattice (has_neg_part unsigned)) unsigned) : @complete_lattice.is_Sup_finite_compact.{0} (has_neg_part.{0} unsigned) (@functor.add_const.run.{0 0} (complete_lattice.{0} (has_neg_part.{0} unsigned)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_134800 (h0 : function.extfun Type group) : @normalizer_condition.{0} (add_right_cancel_monoid.{0} empty) (@function.extfun_app.{2 1} Type group.{0} h0 (add_right_cancel_monoid.{0} empty))  := sorry --non-trivial
lemma new_lemma_134801 (h0 : topological_space (left_cancel_monoid (semiring congr_arg_kind))) : totally_separated_space (left_cancel_monoid (semiring congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_134802 (h0 : topological_space (left_cancel_semigroup unsigned)) : topological_space.separable_space (left_cancel_semigroup unsigned) := sorry --non-trivial
lemma new_lemma_134803 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : filter.ne_bot (function.extfun_app (function.extfun_app h0 filter) (semiring empty)) := sorry --non-trivial
lemma new_lemma_134804 (h0 : function.extfun (Type 1) filter) : countable_Inter_filter (function.extfun_app h0 (pseudo_metric_space Type)) := sorry --non-trivial
lemma new_lemma_134805 (h0 : add_group (has_Sup (left_cancel_monoid unsigned))) : is_add_cyclic (has_Sup (left_cancel_monoid unsigned)) := sorry --non-trivial
lemma new_lemma_134806 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_noetherian_ring.{0} (has_to_string.{0} num) (@function.extfun_app.{2 1} Type semiring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 semiring.{0}) (has_to_string.{0} num))  := sorry --non-trivial
lemma new_lemma_134807 (h0 : ring (add_group (semiring linarith.comp))) : rank_condition (add_group (semiring linarith.comp)) := sorry --non-trivial
lemma new_lemma_134808 (h0 : monoid (with_one (has_top congr_arg_kind))) : monoid.fg (with_one (has_top congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_134809 (h0 : ring (cancel_monoid empty)) : strong_rank_condition (cancel_monoid empty) := sorry --non-trivial
lemma new_lemma_134810 (h0 : function.extfun Type group) : @is_cyclic.{0} (semigroup.{0} (option.{0} empty)) (@function.extfun_app.{2 1} Type group.{0} h0 (semigroup.{0} (option.{0} empty)))  := sorry --non-trivial
lemma new_lemma_134811 (h0 : not (topological_space (has_top linarith.ineq) -> false)) : @locally_compact_space.{0} (has_top.{0} linarith.ineq) (@classical.by_contradiction'.{1} (topological_space.{0} (has_top.{0} linarith.ineq)) h0)  := sorry --non-trivial
lemma new_lemma_134812 (h0 : function.extfun Type add_group) : @is_add_cyclic.{0} (canonically_ordered_comm_semiring.{0} name) (@function.extfun_app.{2 1} Type add_group.{0} h0 (canonically_ordered_comm_semiring.{0} name))  := sorry --non-trivial
lemma new_lemma_134813 (h0 : topological_space (finset (has_neg linarith.comp))) : path_connected_space (finset (has_neg linarith.comp)) := sorry --non-trivial
lemma new_lemma_134814 (h0 : group (sub_neg_monoid (has_add pos))) : normalizer_condition (sub_neg_monoid (has_add pos)) := sorry --non-trivial
lemma new_lemma_134815 (h0 : uniform_space (has_compl (has_nnnorm char))) : complete_space (has_compl (has_nnnorm char)) := sorry --non-trivial
lemma new_lemma_134816 (h0 : topological_space (has_pos_part (canonically_linear_ordered_monoid real))) : preirreducible_space (has_pos_part (canonically_linear_ordered_monoid real)) := sorry --non-trivial
lemma new_lemma_134817 (h0 : topological_space (normed_field (has_nnnorm (random_gen reducibility_hints)))) : t0_space (normed_field (has_nnnorm (random_gen reducibility_hints))) := sorry --non-trivial
lemma new_lemma_134818 (h0 : not (topological_space (measurable_space (semiring congr_arg_kind)) -> false)) : @totally_separated_space.{0} (measurable_space.{0} (semiring.{0} congr_arg_kind)) (@classical.by_contradiction'.{1} (topological_space.{0} (measurable_space.{0} (semiring.{0} congr_arg_kind))) h0)  := sorry --non-trivial
lemma new_lemma_134819 (h0 : list (has_Inf (has_add (ring pos)))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_134820 (h0 : functor.add_const (topological_space (ring environment.implicit_infer_kind)) linarith.comp) : @regular_space.{0} (ring.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (ring.{0} environment.implicit_infer_kind)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_134821 (h0 : function.extfun Type complete_lattice) : @complete_lattice.is_Sup_finite_compact.{0} string_imp (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 string_imp)  := sorry --non-trivial
lemma new_lemma_134822 (h0 : not (topological_space (add_group congr_arg_kind) -> false)) : @irreducible_space.{0} (add_group.{0} congr_arg_kind) (@classical.by_contradiction'.{1} (topological_space.{0} (add_group.{0} congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_134823 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_noetherian_ring.{0} (semigroup.{0} empty) (@function.extfun_app.{2 1} Type semiring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 semiring.{0}) (semigroup.{0} empty))  := sorry --non-trivial
lemma new_lemma_134824 (h0 : topological_space (has_dist empty)) : totally_separated_space (has_dist empty) := sorry --non-trivial
lemma new_lemma_134825 (h0 : functor.add_const (function.extfun (Type 1) topological_space) linarith.comp) : @topological_space.separable_space.{1} (semigroup.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) topological_space.{1}) linarith.comp h0) (semigroup.{1} Type))  := sorry --non-trivial
lemma new_lemma_134826 (h0 : topological_space (measurable_space (random_gen (has_top linarith.ineq)))) : discrete_topology (measurable_space (random_gen (has_top linarith.ineq))) := sorry --non-trivial
lemma new_lemma_134827 (h0 : topological_space (linear_order congr_arg_kind)) : irreducible_space (linear_order congr_arg_kind) := sorry --non-trivial
lemma new_lemma_134828 (h0 : function.extfun Type filter) : filter.ne_bot (function.extfun_app h0 (has_add unsigned)) := sorry --non-trivial
lemma new_lemma_134829 (h0 : function.extfun Type topological_space) : @locally_compact_space.{0} (left_cancel_monoid.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (left_cancel_monoid.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_134830 (h0 : group (measurable_space (semiring empty))) : group.fg (measurable_space (semiring empty)) := sorry --non-trivial
lemma new_lemma_134831 (h0 : topological_space (semiring (semiring empty))) : locally_compact_space (semiring (semiring empty)) := sorry --non-trivial
lemma new_lemma_134832 (h0 : finset (generalized_boolean_algebra (generalized_boolean_algebra pos))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_134833 (h0 : not (function.extfun Type topological_space -> false)) : @t0_space.{0} (option.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (option.{0} empty))  := sorry --non-trivial
lemma new_lemma_134834 (h0 : function.extfun Type ring) : @is_principal_ideal_ring.{0} (ordered_comm_monoid.{0} linarith.comp) (@function.extfun_app.{2 1} Type ring.{0} h0 (ordered_comm_monoid.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_134835 (h0 : uniform_space (denumerable linarith.comp_source)) : complete_space (denumerable linarith.comp_source) := sorry --non-trivial
lemma new_lemma_134836 (h0 : functor.add_const (topological_space (has_zero environment.implicit_infer_kind)) Type) : @t1_space.{0} (has_zero.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 1} (topological_space.{0} (has_zero.{0} environment.implicit_infer_kind)) Type h0)  := sorry --non-trivial
lemma new_lemma_134837 (h0 : function.extfun Type topological_space) : @sequential_space.{0} (complete_distrib_lattice.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (complete_distrib_lattice.{0} pos))  := sorry --non-trivial
lemma new_lemma_134838 (h0 : filter (dlist (random_gen linarith.comp_source))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_134839 (h0 : topological_space (has_top (has_emptyc linarith.ineq))) : path_connected_space (has_top (has_emptyc linarith.ineq)) := sorry --non-trivial
lemma new_lemma_134840 (h0 : list (ordered_cancel_add_comm_monoid (option unsigned))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_134841 (h0 : add_group (id linarith.ineq)) : is_add_cyclic (id linarith.ineq) := sorry --non-trivial
lemma new_lemma_134842 (h0 : ring (simple_graph ereal)) : rank_condition (simple_graph ereal) := sorry --non-trivial
lemma new_lemma_134843 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @is_noetherian_ring.{1} (complete_distrib_lattice.{1} Type) (@function.extfun_app.{3 2} (Type 1) semiring.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 semiring.{1}) (complete_distrib_lattice.{1} Type))  := sorry --non-trivial
lemma new_lemma_134844 (h0 : fin has_zero.zero) : @normalizer_condition.{0} (add_comm_monoid.{0} real) (@matrix.vec_empty.{0} (group.{0} (add_comm_monoid.{0} real)) h0)  := sorry --non-trivial
lemma new_lemma_134845 (h0 : functor.add_const (uniform_space (simple_graph Type)) name) : @complete_space.{1} (simple_graph.{1} Type) (@functor.add_const.run.{1 0} (uniform_space.{1} (simple_graph.{1} Type)) name h0)  := sorry --non-trivial
lemma new_lemma_134846 (h0 : topological_space (complete_distrib_lattice (normed_comm_ring Type))) : normal_space (complete_distrib_lattice (normed_comm_ring Type)) := sorry --non-trivial
lemma new_lemma_134847 (h0 : topological_space (canonically_ordered_comm_semiring ennreal)) : locally_compact_space (canonically_ordered_comm_semiring ennreal) := sorry --non-trivial
lemma new_lemma_134848 (h2 : not (topological_space (measurable_space num) -> false)) : @locally_compact_space.{0} (measurable_space.{0} num) (@classical.by_contradiction'.{1} (topological_space.{0} (measurable_space.{0} num)) h2)  := sorry --non-trivial
lemma new_lemma_134849 (h0 : filter (has_norm empty)) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_134850 (h0 : topological_space (canonically_ordered_comm_semiring (has_add (has_add pos)))) : sequential_space (canonically_ordered_comm_semiring (has_add (has_add pos))) := sorry --non-trivial
lemma new_lemma_134851 (h0 : topological_space (random_gen (has_nnnorm char))) : t0_space (random_gen (has_nnnorm char)) := sorry --non-trivial
lemma new_lemma_134852 (h0 : ring (pseudo_metric_space (option (option ennreal)))) : is_domain (pseudo_metric_space (option (option ennreal))) := sorry --non-trivial
lemma new_lemma_134853 (h1 : ring (fintype fun_info)) : strong_rank_condition (fintype fun_info) := sorry --non-trivial
lemma new_lemma_134854 (h0 : ring (id (semiring num))) : is_domain (id (semiring num)) := sorry --non-trivial
lemma new_lemma_134855 (h0 : topological_space (has_neg (has_add (has_add name)))) : t0_space (has_neg (has_add (has_add name))) := sorry --non-trivial
lemma new_lemma_134856 (h0 : function.extfun Type (prod (has_to_string ennreal))) : id_rel (function.extfun_app h0 (has_to_string ennreal)) := sorry --non-trivial
lemma new_lemma_134857 (h0 : topological_space (has_neg_part Type)) : t0_space (has_neg_part Type) := sorry --non-trivial
lemma new_lemma_134858 (h0 : uniform_space (normed_group to_additive.value_type)) : complete_space (normed_group to_additive.value_type) := sorry --non-trivial
lemma new_lemma_134859 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : is_noetherian_ring real := sorry --non-trivial
lemma new_lemma_134860 (h0 : topological_space (complete_distrib_lattice (has_pos_part pos))) : totally_separated_space (complete_distrib_lattice (has_pos_part pos)) := sorry --non-trivial
lemma new_lemma_134861 (h0 : ring (bin_tree unsigned)) : is_domain (bin_tree unsigned) := sorry --non-trivial
lemma new_lemma_134862 (h0 : complete_lattice (canonically_linear_ordered_monoid pos)) : complete_lattice.is_Sup_finite_compact (canonically_linear_ordered_monoid pos) := sorry --non-trivial
lemma new_lemma_134863 (h0 : function.extfun Type complete_lattice) : @complete_lattice.is_Sup_finite_compact.{0} (normed_comm_ring.{0} ennreal) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (normed_comm_ring.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_134864 (h1 : not (filter (lattice to_additive.value_type) -> false)) : filter.ne_bot (classical.by_contradiction' h1) := sorry --non-trivial
lemma new_lemma_134865 (h0 : topological_space (complete_distrib_lattice (option empty))) : loc_path_connected_space (complete_distrib_lattice (option empty)) := sorry --non-trivial
lemma new_lemma_134866 (h0 : has_mem.mem (measurable_space fun_info) has_emptyc.emptyc) : @irreducible_space.{0} (measurable_space.{0} fun_info) (@finset.pi.empty.{1 0} Type topological_space.{0} (measurable_space.{0} fun_info) h0)  := sorry --non-trivial
lemma new_lemma_134867 (h0 : function.extfun Type complete_lattice) : @is_compactly_generated.{0} (has_inv.{0} fun_info) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (has_inv.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_134868 (h0 : has_top (semiring unsigned) -> has_top (semiring unsigned) -> Prop) : is_strict_order (has_top (semiring unsigned)) h0 := sorry --non-trivial
lemma new_lemma_134869 (h1 : set (add_comm_semigroup (add_comm_semigroup std_gen) -> fun_info)) : set.separates_points h1 := sorry --non-trivial
lemma new_lemma_134870 (h0 : ring (has_neg (option (option (option ennreal))))) : is_domain (has_neg (option (option (option ennreal)))) := sorry --non-trivial
lemma new_lemma_134871 (h0 : topological_space (has_star (has_Inf pos))) : discrete_topology (has_star (has_Inf pos)) := sorry --non-trivial
lemma new_lemma_134872 (h0 : functor.add_const (ordered_comm_monoid (has_Inf linarith.comp)) (has_pos_part pos)) : @has_exists_mul_of_le.{0} (has_Inf.{0} linarith.comp) (@functor.add_const.run.{0 0} (ordered_comm_monoid.{0} (has_Inf.{0} linarith.comp)) (has_pos_part.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_134873 (h0 : function.extfun Type topological_space) : @loc_path_connected_space.{0} (option.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (option.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_134874 (h0 : ring (canonically_linear_ordered_monoid name)) : rank_condition (canonically_linear_ordered_monoid name) := sorry --non-trivial
lemma new_lemma_134875 (h0 : functor.add_const (uniform_space (partial_order empty)) empty) : @separated_space.{0} (partial_order.{0} empty) (@functor.add_const.run.{0 0} (uniform_space.{0} (partial_order.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_134876 (h0 : topological_space (ordered_comm_monoid (has_Inf real))) : normal_space (ordered_comm_monoid (has_Inf real)) := sorry --non-trivial
lemma new_lemma_134877 (h0 : functor.add_const (complete_lattice (has_edist empty)) empty) : @is_atomistic.{0} (has_edist.{0} empty) (@functor.add_const.run.{0 0} (complete_lattice.{0} (has_edist.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_134878 (h0 : complete_lattice (measurable_space (has_norm (has_norm (has_norm to_additive.value_type))))) : is_compactly_generated (measurable_space (has_norm (has_norm (has_norm to_additive.value_type)))) := sorry --non-trivial
lemma new_lemma_134879 (h0 : group (distrib_lattice (has_nnnorm linarith.comp_source))) : is_cyclic (distrib_lattice (has_nnnorm linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_134880 (h0 : functor.comp topological_space mul_zero_class pos) : @path_connected_space.{0} (mul_zero_class.{0} pos) (@functor.comp.run.{0 0 0} topological_space.{0} mul_zero_class.{0} pos h0)  := sorry --non-trivial
lemma new_lemma_134881 (h0 : topological_space (generalized_boolean_algebra real)) : preconnected_space (generalized_boolean_algebra real) := sorry --non-trivial
lemma new_lemma_134882 (h0 : uniform_space (has_emptyc linarith.ineq)) : complete_space (has_emptyc linarith.ineq) := sorry --non-trivial
lemma new_lemma_134883 (h0 : group (has_neg (ring Type))) : normalizer_condition (has_neg (ring Type)) := sorry --non-trivial
lemma new_lemma_134884 (h1 : group (comm_ring reducibility_hints)) : is_cyclic (comm_ring reducibility_hints) := sorry --non-trivial
lemma new_lemma_134885 (h0 : list (cancel_monoid (finset ennreal))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_134886 (h0 : functor.add_const (semiring (preorder empty)) (semiring unsigned)) : @is_noetherian_ring.{0} (preorder.{0} empty) (@functor.add_const.run.{0 0} (semiring.{0} (preorder.{0} empty)) (semiring.{0} unsigned) h0)  := sorry --non-trivial
lemma new_lemma_134887 (h0 : monoid (boolean_algebra.core num)) : monoid.fg (boolean_algebra.core num) := sorry --non-trivial
lemma new_lemma_134888 (h0 : set (set char)) (h1 : set char) : filter.generate_sets h0 h1 := sorry --non-trivial
lemma new_lemma_134889 (h0 : topological_space (boolean_algebra (has_add (boolean_algebra.core (has_add Type))))) : normal_space (boolean_algebra (has_add (boolean_algebra.core (has_add Type)))) := sorry --non-trivial
lemma new_lemma_134890 (h0 : topological_space (add_cancel_monoid (has_Inf (has_add (has_neg (has_add name)))))) : discrete_topology (add_cancel_monoid (has_Inf (has_add (has_neg (has_add name))))) := sorry --non-trivial
lemma new_lemma_134891 (h0 : semiring (add_comm_semigroup linarith.ineq)) (h1 : add_comm_semigroup linarith.ineq) : even h1 := sorry --non-trivial
lemma new_lemma_134892 (h0 : function.extfun Type complete_lattice) : @complete_lattice.is_Sup_finite_compact.{0} (add_comm_monoid.{0} pos) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (add_comm_monoid.{0} pos))  := sorry --non-trivial
lemma new_lemma_134893 (h0 : functor.add_const (finset (linear_ordered_comm_monoid_with_zero empty)) empty) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_134894 (h0 : functor.add_const (ordered_add_comm_monoid (add_cancel_monoid name)) linarith.comp) : @archimedean.{0} (add_cancel_monoid.{0} name) (@functor.add_const.run.{0 0} (ordered_add_comm_monoid.{0} (add_cancel_monoid.{0} name)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_134895 (h0 : function.extfun Type add_group) : @is_add_cyclic.{0} (has_inter.{0} ennreal) (@function.extfun_app.{2 1} Type add_group.{0} h0 (has_inter.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_134896 (h0 : topological_space (plift num)) : irreducible_space (plift num) := sorry --non-trivial
lemma new_lemma_134897 (h0 : topological_space (has_star num)) : preirreducible_space (has_star num) := sorry --non-trivial
lemma new_lemma_134898 (h0 : functor.add_const (ring (has_to_string Type)) environment.implicit_infer_kind) : @rank_condition.{1} (has_to_string.{1} Type) (@functor.add_const.run.{1 0} (ring.{1} (has_to_string.{1} Type)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_134899 (h0 : functor.add_const (function.extfun Type topological_space) (has_pos_part linarith.comp)) : @normal_space.{0} (finset.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) (has_pos_part.{0} linarith.comp) h0) (finset.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_134900 (h0 : function.extfun Type group) : @group.fg.{0} (option.{0} ennreal) (@function.extfun_app.{2 1} Type group.{0} h0 (option.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_134901 (h0 : function.extfun (finset Type) (has_mem.mem (random_gen fun_info))) : @complete_space.{0} (random_gen.{0} fun_info) (@finset.pi.empty.{1 0} Type uniform_space.{0} (random_gen.{0} fun_info) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (random_gen.{0} fun_info)) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_134902 (h0 : topological_space (semigroup (boolean_algebra pos))) : t1_space (semigroup (boolean_algebra pos)) := sorry --non-trivial
lemma new_lemma_134903 (h0 : function.extfun Type topological_space) : @t0_space.{0} (denumerable.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (denumerable.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_134904 (h0 : uniform_space (has_ssubset to_additive.value_type)) : complete_space (has_ssubset to_additive.value_type) := sorry --non-trivial
lemma new_lemma_134905 (h0 : not (function.extfun Type topological_space -> false)) : @discrete_topology.{0} (semiring.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (semiring.{0} num))  := sorry --non-trivial
lemma new_lemma_134906 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @unique_factorization_monoid.{0} (has_zero.{0} linarith.comp) (@function.extfun_app.{2 1} Type cancel_comm_monoid_with_zero.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 cancel_comm_monoid_with_zero.{0}) (has_zero.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_134907 (h3 : set (fun_info -> std_gen)) : set.separates_points h3 := sorry --non-trivial
lemma new_lemma_134908 (h0 : list (has_nndist (ring Type))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_134909 (h0 : functor.comp ring has_nndist pos) : @is_principal_ideal_ring.{0} (has_nndist.{0} pos) (@functor.comp.run.{0 0 0} ring.{0} has_nndist.{0} pos h0)  := sorry --non-trivial
lemma new_lemma_134910 (h0 : complete_lattice (semiring (random_gen num))) : complete_lattice.is_Sup_finite_compact (semiring (random_gen num)) := sorry --non-trivial
lemma new_lemma_134911 (h0 : monoid (canonically_ordered_comm_semiring (ring linarith.comp))) : monoid.fg (canonically_ordered_comm_semiring (ring linarith.comp)) := sorry --non-trivial
lemma new_lemma_134912 (h0 : functor.add_const (ring (add_cancel_monoid environment.implicit_infer_kind)) (has_nndist ennreal)) : @is_domain.{0} (add_cancel_monoid.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (ring.{0} (add_cancel_monoid.{0} environment.implicit_infer_kind)) (has_nndist.{0} ennreal) h0)  := sorry --non-trivial
lemma new_lemma_134913 (h0 : topological_space (mul_zero_class (has_neg_part Type))) : regular_space (mul_zero_class (has_neg_part Type)) := sorry --non-trivial
lemma new_lemma_134914 (h0 : function.extfun Type finset) : finset.nonempty (function.extfun_app h0 (is_R_or_C congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_134915 (h0 : functor.add_const (topological_space (add_comm_monoid linarith.comp)) pos) : @t0_space.{0} (add_comm_monoid.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (add_comm_monoid.{0} linarith.comp)) pos h0)  := sorry --non-trivial
lemma new_lemma_134916 (h0 : function.extfun Type ring) : @rank_condition.{0} (has_neg_part.{0} name) (@function.extfun_app.{2 1} Type ring.{0} h0 (has_neg_part.{0} name))  := sorry --non-trivial
lemma new_lemma_134917 (h0 : complete_lattice (has_top (has_norm (has_norm unsigned)))) : is_compactly_generated (has_top (has_norm (has_norm unsigned))) := sorry --non-trivial
lemma new_lemma_134918 (h0 : not (topological_space (complete_semilattice_Sup congr_arg_kind) -> false)) : @locally_compact_space.{0} (complete_semilattice_Sup.{0} congr_arg_kind) (@classical.by_contradiction'.{1} (topological_space.{0} (complete_semilattice_Sup.{0} congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_134919 (h0 : ordered_add_comm_monoid (comm_ring fun_info)) : has_exists_add_of_le (comm_ring fun_info) := sorry --non-trivial
lemma new_lemma_134920 (h0 : topological_space (linear_ordered_comm_ring (semiring congr_arg_kind))) : preirreducible_space (linear_ordered_comm_ring (semiring congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_134921 (h0 : functor.add_const (list (has_add name)) environment.implicit_infer_kind) : list.nodup (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_134922 (h0 : function.extfun Type topological_space) : @topological_space.separable_space.{0} (has_edist.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_edist.{0} empty))  := sorry --non-trivial
lemma new_lemma_134923 (h0 : functor.comp ordered_comm_monoid complete_distrib_lattice pos) : @has_exists_mul_of_le.{0} (complete_distrib_lattice.{0} pos) (@functor.comp.run.{0 0 0} ordered_comm_monoid.{0} complete_distrib_lattice.{0} pos h0)  := sorry --non-trivial
lemma new_lemma_134924 (h0 : set linarith.comp_source) : set.finite h0 := sorry --non-trivial
lemma new_lemma_134925 (h0 : ring (has_top (has_norm (random_gen congr_arg_kind)))) : is_domain (has_top (has_norm (random_gen congr_arg_kind))) := sorry --non-trivial
lemma new_lemma_134926 (h0 : topological_space (cancel_monoid name)) : sequential_space (cancel_monoid name) := sorry --non-trivial
lemma new_lemma_134927 (h0 : filter (denumerable char)) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_134928 (h0 : functor.add_const (complete_lattice (has_neg pos)) (finset (finset ennreal))) : @is_compactly_generated.{0} (has_neg.{0} pos) (@functor.add_const.run.{0 0} (complete_lattice.{0} (has_neg.{0} pos)) (finset.{0} (finset.{0} ennreal)) h0)  := sorry --non-trivial
lemma new_lemma_134929 (h2 : filter (topological_space (has_nnnorm char))) : filter.ne_bot h2 := sorry --non-trivial
lemma new_lemma_134930 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @group.fg.{1} Type (@function.extfun_app.{3 2} (Type 1) group.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 group.{1}) Type)  := sorry --non-trivial
lemma new_lemma_134931 (h0 : functor.add_const (topological_space (has_dist empty)) (option empty)) : @locally_compact_space.{0} (has_dist.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (has_dist.{0} empty)) (option.{0} empty) h0)  := sorry --non-trivial
lemma new_lemma_134932 (h0 : complete_lattice (has_nnnorm to_additive.value_type)) : is_compactly_generated (has_nnnorm to_additive.value_type) := sorry --non-trivial
lemma new_lemma_134933 (h0 : group (has_zero (has_add (add_cancel_monoid (has_add (has_add (has_add pos))))))) : is_cyclic (has_zero (has_add (add_cancel_monoid (has_add (has_add (has_add pos)))))) := sorry --non-trivial
lemma new_lemma_134934 (h0 : not (topological_space (linear_ordered_semiring to_additive.value_type) -> false)) : @discrete_topology.{0} (linear_ordered_semiring.{0} to_additive.value_type) (@classical.by_contradiction'.{1} (topological_space.{0} (linear_ordered_semiring.{0} to_additive.value_type)) h0)  := sorry --non-trivial
lemma new_lemma_134935 (h0 : complete_lattice (generalized_boolean_algebra (has_neg name))) : is_compactly_generated (generalized_boolean_algebra (has_neg name)) := sorry --non-trivial
lemma new_lemma_134936 (h0 : functor.add_const (ring (preorder unsigned)) congr_arg_kind) : @is_domain.{0} (preorder.{0} unsigned) (@functor.add_const.run.{0 0} (ring.{0} (preorder.{0} unsigned)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_134937 (h0 : ring (ordered_comm_ring name)) : is_principal_ideal_ring (ordered_comm_ring name) := sorry --non-trivial
lemma new_lemma_134938 (h0 : function.extfun Type (functor.add_const (uniform_space (omega_complete_partial_order empty)))) : @separated_space.{0} (omega_complete_partial_order.{0} empty) (@functor.add_const.run.{0 0} (uniform_space.{0} (omega_complete_partial_order.{0} empty)) unsigned (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (uniform_space.{0} (omega_complete_partial_order.{0} empty))) h0 unsigned))  := sorry --non-trivial
lemma new_lemma_134939 (h0 : functor.add_const (add_monoid (ordered_comm_monoid linarith.comp)) Type) : @add_monoid.fg.{0} (ordered_comm_monoid.{0} linarith.comp) (@functor.add_const.run.{0 1} (add_monoid.{0} (ordered_comm_monoid.{0} linarith.comp)) Type h0)  := sorry --non-trivial
lemma new_lemma_134940 (h0 : group (has_pos_part (has_add linarith.comp))) : group.fg (has_pos_part (has_add linarith.comp)) := sorry --non-trivial
lemma new_lemma_134941 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_noetherian_ring.{0} (left_cancel_monoid.{0} empty) (@function.extfun_app.{2 1} Type semiring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 semiring.{0}) (left_cancel_monoid.{0} empty))  := sorry --non-trivial
lemma new_lemma_134942 (h0 : functor.add_const (topological_space (normed_linear_ordered_group unsigned)) empty) : @irreducible_space.{0} (normed_linear_ordered_group.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (normed_linear_ordered_group.{0} unsigned)) empty h0)  := sorry --non-trivial
lemma new_lemma_134943 (h0 : ordered_add_comm_monoid (has_neg (has_neg_part (boolean_algebra Type)))) : archimedean (has_neg (has_neg_part (boolean_algebra Type))) := sorry --non-trivial
lemma new_lemma_134944 (h0 : has_mem.mem (has_ssubset fun_info) has_emptyc.emptyc) : @monoid.fg.{0} (has_ssubset.{0} fun_info) (@finset.pi.empty.{1 0} Type monoid.{0} (has_ssubset.{0} fun_info) h0)  := sorry --non-trivial
lemma new_lemma_134945 (h0 : ring (add_cancel_monoid pos)) : rank_condition (add_cancel_monoid pos) := sorry --non-trivial
lemma new_lemma_134946 (h1 : add_group (has_div linarith.comp_source)) : is_add_cyclic (has_div linarith.comp_source) := sorry --non-trivial
lemma new_lemma_134947 (h0 : functor.add_const (function.extfun Type topological_space) pos) : @t0_space.{0} (has_add.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) pos h0) (has_add.{0} name))  := sorry --non-trivial
lemma new_lemma_134948 (h0 : ring (plift empty)) : is_principal_ideal_ring (plift empty) := sorry --non-trivial
lemma new_lemma_134949 (h0 : functor.add_const (monoid (add_right_cancel_monoid empty)) empty) : @monoid.fg.{0} (add_right_cancel_monoid.{0} empty) (@functor.add_const.run.{0 0} (monoid.{0} (add_right_cancel_monoid.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_134950 (h0 : list (has_top (has_nnnorm (has_ssubset fun_info)))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_134951 (h1 : topological_space (measurable_space empty)) : irreducible_space (measurable_space empty) := sorry --non-trivial
lemma new_lemma_134952 (h0 : complete_lattice (has_compl reducibility_hints)) : complete_lattice.is_Sup_finite_compact (has_compl reducibility_hints) := sorry --non-trivial
lemma new_lemma_134953 (h0 : ordered_add_comm_monoid (omega_complete_partial_order unsigned)) : archimedean (omega_complete_partial_order unsigned) := sorry --non-trivial
lemma new_lemma_134954 (h0 : ordered_comm_monoid (has_neg (has_neg_part pos))) : has_exists_mul_of_le (has_neg (has_neg_part pos)) := sorry --non-trivial
lemma new_lemma_134955 (h0 : function.extfun Type list) : list.nodup (function.extfun_app h0 (complete_distrib_lattice pos)) := sorry --non-trivial
lemma new_lemma_134956 (h0 : topological_space (has_pos_part (has_Inf (has_Inf Type)))) : locally_compact_space (has_pos_part (has_Inf (has_Inf Type))) := sorry --non-trivial
lemma new_lemma_134957 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @add_monoid.fg.{0} (complete_linear_order.{0} empty) (@function.extfun_app.{2 1} Type add_monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 add_monoid.{0}) (complete_linear_order.{0} empty))  := sorry --non-trivial
lemma new_lemma_134958 (h0 : monoid (normed_comm_ring (comm_group (finset Type)))) : monoid.fg (normed_comm_ring (comm_group (finset Type))) := sorry --non-trivial
lemma new_lemma_134959 (h0 : function.extfun Type group) : @is_cyclic.{0} (distrib_lattice.{0} string_imp) (@function.extfun_app.{2 1} Type group.{0} h0 (distrib_lattice.{0} string_imp))  := sorry --non-trivial
lemma new_lemma_134960 (h0 : topological_space (uniform_space (mul_one_class string.iterator_imp))) : t0_space (uniform_space (mul_one_class string.iterator_imp)) := sorry --non-trivial
lemma new_lemma_134961 (h0 : not (uniform_space (topological_space linarith.comp_source) -> false)) : @complete_space.{0} (topological_space.{0} linarith.comp_source) (@classical.by_contradiction'.{1} (uniform_space.{0} (topological_space.{0} linarith.comp_source)) h0)  := sorry --non-trivial
lemma new_lemma_134962 (h0 : functor.add_const Prop (cancel_monoid name)) : functor.add_const.run h0 := sorry --non-trivial
lemma new_lemma_134963 (h0 : functor.add_const (topological_space (boolean_algebra.core name)) pos) : @irreducible_space.{0} (boolean_algebra.core.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (boolean_algebra.core.{0} name)) pos h0)  := sorry --non-trivial
lemma new_lemma_134964 (h0 : topological_space (with_one (random_gen (random_gen (random_gen linarith.ineq))))) : path_connected_space (with_one (random_gen (random_gen (random_gen linarith.ineq)))) := sorry --non-trivial
lemma new_lemma_134965 (h0 : function.extfun Type finset) : finset.nonempty (function.extfun_app h0 (ordered_cancel_add_comm_monoid num)) := sorry --non-trivial
lemma new_lemma_134966 (h1 : has_le (add_comm_semigroup char)) (h2 : add_comm_semigroup char) : is_bot h2 := sorry --non-trivial
lemma new_lemma_134967 (h0 : functor.add_const (function.extfun (Type 1) topological_space) pos) : @path_connected_space.{1} (has_Inf.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) topological_space.{1}) pos h0) (has_Inf.{1} Type))  := sorry --non-trivial
lemma new_lemma_134968 (h0 : functor.add_const (ring environment.implicit_infer_kind) linarith.comp) : @is_domain.{0} environment.implicit_infer_kind (@functor.add_const.run.{0 0} (ring.{0} environment.implicit_infer_kind) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_134969 (h0 : function.extfun (Type 1) ordered_add_comm_monoid) : @archimedean.{1} (plift.{1} empty) (@function.extfun_app.{3 2} (Type 1) ordered_add_comm_monoid.{1} h0 (plift.{1} empty))  := sorry --non-trivial
lemma new_lemma_134970 (h0 : functor.add_const (monoid (has_star empty)) empty) : @monoid.fg.{0} (has_star.{0} empty) (@functor.add_const.run.{0 0} (monoid.{0} (has_star.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_134971 (h0 : functor.add_const (monoid (has_edist unsigned)) (option empty)) : @monoid.fg.{0} (has_edist.{0} unsigned) (@functor.add_const.run.{0 0} (monoid.{0} (has_edist.{0} unsigned)) (option.{0} empty) h0)  := sorry --non-trivial
lemma new_lemma_134972 (h0 : monoid name) : monoid.fg name := sorry --non-trivial
lemma new_lemma_134973 (h0 : function.extfun Type (functor.comp topological_space ring)) : @sequential_space.{0} (ring.{0} unsigned) (@functor.comp.run.{0 0 0} topological_space.{0} ring.{0} unsigned (@function.extfun_app.{2 1} Type (functor.comp.{0 0 0} topological_space.{0} ring.{0}) h0 unsigned))  := sorry --non-trivial
lemma new_lemma_134974 (h0 : list (distrib_lattice (has_nnnorm (has_nnnorm fun_info)))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_134975 (h0 : topological_space (semi_normed_comm_ring fun_info)) : locally_compact_space (semi_normed_comm_ring fun_info) := sorry --non-trivial
lemma new_lemma_134976 (h0 : function.extfun Type topological_space) : @regular_space.{0} (boolean_algebra.core.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (boolean_algebra.core.{0} name))  := sorry --non-trivial
lemma new_lemma_134977 (h0 : list (normed_comm_ring (has_add linarith.comp))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_134978 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @totally_separated_space.{0} (canonically_linear_ordered_monoid.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (canonically_linear_ordered_monoid.{0} name))  := sorry --non-trivial
lemma new_lemma_134979 (h0 : ring (left_cancel_semigroup empty)) : rank_condition (left_cancel_semigroup empty) := sorry --non-trivial
lemma new_lemma_134980 (h0 : fin has_zero.zero) : @is_cyclic.{0} (canonically_linear_ordered_monoid.{0} pos) (@matrix.vec_empty.{0} (group.{0} (canonically_linear_ordered_monoid.{0} pos)) h0)  := sorry --non-trivial
lemma new_lemma_134981 (h0 : complete_lattice (with_bot (semiring (semiring empty)))) : is_atomistic (with_bot (semiring (semiring empty))) := sorry --non-trivial
lemma new_lemma_134982 (h0 : functor.add_const (complete_lattice (boolean_algebra unsigned)) environment.implicit_infer_kind) : @is_compactly_generated.{0} (boolean_algebra.{0} unsigned) (@functor.add_const.run.{0 0} (complete_lattice.{0} (boolean_algebra.{0} unsigned)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_134983 (h0 : complete_lattice (boolean_algebra.core (comm_group name))) : is_atomistic (boolean_algebra.core (comm_group name)) := sorry --non-trivial
lemma new_lemma_134984 (h0 : functor.add_const (function.extfun Type complete_lattice) pos) : @is_atomistic.{0} (pseudo_metric_space.{0} (finset.{0} name)) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type complete_lattice.{0}) pos h0) (pseudo_metric_space.{0} (finset.{0} name)))  := sorry --non-trivial
lemma new_lemma_134985 (h0 : prod (has_to_string (has_to_string pos)) (has_to_string (has_to_string pos))) : id_rel h0 := sorry --non-trivial
lemma new_lemma_134986 (h0 : monoid (add_comm_monoid (option unsigned))) : monoid.fg (add_comm_monoid (option unsigned)) := sorry --non-trivial
lemma new_lemma_134987 (h0 : ring (ordered_comm_ring (finset pos))) : is_principal_ideal_ring (ordered_comm_ring (finset pos)) := sorry --non-trivial
lemma new_lemma_134988 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @preirreducible_space.{0} (has_nndist.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_nndist.{0} name))  := sorry --non-trivial
lemma new_lemma_134989 (h0 : functor.add_const (monoid (ordered_comm_monoid linarith.comp)) pos) : @monoid.fg.{0} (ordered_comm_monoid.{0} linarith.comp) (@functor.add_const.run.{0 0} (monoid.{0} (ordered_comm_monoid.{0} linarith.comp)) pos h0)  := sorry --non-trivial
lemma new_lemma_134990 (h0 : add_group (has_zero (finset linarith.comp))) : is_add_cyclic (has_zero (finset linarith.comp)) := sorry --non-trivial
lemma new_lemma_134991 (h0 : monoid (has_add ennreal)) : monoid.fg (has_add ennreal) := sorry --non-trivial
lemma new_lemma_134992 (h0 : function.extfun Type ring) : @strong_rank_condition.{0} (ordered_comm_group.{0} empty) (@function.extfun_app.{2 1} Type ring.{0} h0 (ordered_comm_group.{0} empty))  := sorry --non-trivial
lemma new_lemma_134993 (h0 : ring (has_emptyc (random_gen linarith.comp_source))) : strong_rank_condition (has_emptyc (random_gen linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_134994 (h0 : topological_space (has_top unsigned)) : irreducible_space (has_top unsigned) := sorry --non-trivial
lemma new_lemma_134995 (h0 : fin has_zero.zero) : @is_noetherian_ring.{0} (canonically_ordered_monoid.{0} real) (@matrix.vec_empty.{0} (semiring.{0} (canonically_ordered_monoid.{0} real)) h0)  := sorry --non-trivial
lemma new_lemma_134996 (h0 : topological_space (has_bot (has_Inf real))) : t0_space (has_bot (has_Inf real)) := sorry --non-trivial
lemma new_lemma_134997 (h0 : ring (normed_group (has_top (has_top (has_top (has_top linarith.ineq)))))) : is_domain (normed_group (has_top (has_top (has_top (has_top linarith.ineq))))) := sorry --non-trivial
lemma new_lemma_134998 (h0 : functor.add_const (function.extfun Type group) name) : @is_simple_group.{0} (has_pos_part.{0} pos) (@function.extfun_app.{2 1} Type group.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type group.{0}) name h0) (has_pos_part.{0} pos))  := sorry --non-trivial
lemma new_lemma_134999 (h0 : complete_lattice (has_nndist (has_pos_part linarith.comp))) : complete_lattice.is_Sup_finite_compact (has_nndist (has_pos_part linarith.comp)) := sorry --non-trivial
lemma new_lemma_135000 (h0 : topological_space (canonically_linear_ordered_monoid (has_Inf (has_add (has_add (has_Inf (has_Inf Type))))))) : t1_space (canonically_linear_ordered_monoid (has_Inf (has_add (has_add (has_Inf (has_Inf Type)))))) := sorry --non-trivial
lemma new_lemma_135001 (h0 : cancel_comm_monoid_with_zero (boolean_algebra (has_add real))) : unique_factorization_monoid (boolean_algebra (has_add real)) := sorry --non-trivial
lemma new_lemma_135002 (h0 : function.extfun nat fin) : @add_monoid.fg.{0} (ordered_comm_ring.{0} pos) (@matrix.vec_empty.{0} (add_monoid.{0} (ordered_comm_ring.{0} pos)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_135003 (h0 : ring (has_to_string (has_neg (boolean_algebra linarith.comp)))) : rank_condition (has_to_string (has_neg (boolean_algebra linarith.comp))) := sorry --non-trivial
lemma new_lemma_135004 (h0 : functor.add_const (complete_lattice (has_neg_part ennreal)) pos) : @is_atomistic.{0} (has_neg_part.{0} ennreal) (@functor.add_const.run.{0 0} (complete_lattice.{0} (has_neg_part.{0} ennreal)) pos h0)  := sorry --non-trivial
lemma new_lemma_135005 (h0 : function.extfun Type group) : @normalizer_condition.{0} (has_dist.{0} empty) (@function.extfun_app.{2 1} Type group.{0} h0 (has_dist.{0} empty))  := sorry --non-trivial
lemma new_lemma_135006 (h0 : ring (has_add name)) : is_principal_ideal_ring (has_add name) := sorry --non-trivial
lemma new_lemma_135007 (h0 : finset (boolean_algebra (finset linarith.comp))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_135008 (h0 : functor.add_const (topological_space (has_Inf linarith.comp)) (has_add linarith.comp)) : @t0_space.{0} (has_Inf.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (has_Inf.{0} linarith.comp)) (has_add.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_135009 (h0 : fin has_zero.zero) : @group.fg.{0} (semi_normed_comm_ring.{0} string_imp) (@matrix.vec_empty.{0} (group.{0} (semi_normed_comm_ring.{0} string_imp)) h0)  := sorry --non-trivial
lemma new_lemma_135010 (h0 : finset (left_cancel_semigroup (semiring empty))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_135011 (h0 : topological_space (with_bot congr_arg_kind)) : discrete_topology (with_bot congr_arg_kind) := sorry --non-trivial
lemma new_lemma_135012 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_cyclic.{0} (generalized_boolean_algebra.{0} real) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (generalized_boolean_algebra.{0} real))  := sorry --non-trivial
lemma new_lemma_135013 (h0 : function.extfun nat fin) : @monoid.fg.{0} (ordered_comm_ring.{0} real) (@matrix.vec_empty.{0} (monoid.{0} (ordered_comm_ring.{0} real)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_135014 (h0 : functor.add_const (functor.add_const (topological_space pos) name) pos) : @sequential_space.{0} pos (@functor.add_const.run.{0 0} (topological_space.{0} pos) name (@functor.add_const.run.{0 0} (functor.add_const.{0 0} (topological_space.{0} pos) name) pos h0))  := sorry --non-trivial
lemma new_lemma_135015 (h0 : topological_space (denumerable char) -> char) (h1 : coe_sort (set.range h0)) : @t0_space.{0} (denumerable.{0} char) (@set.range_splitting.{0 0} (topological_space.{0} (denumerable.{0} char)) char h0 h1)  := sorry --non-trivial
lemma new_lemma_135016 (h0 : fin has_zero.zero) : @archimedean.{1} (has_pos_part.{1} Type) (@matrix.vec_empty.{1} (ordered_add_comm_monoid.{1} (has_pos_part.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_135017 (h0 : uniform_space (add_cancel_monoid ennreal)) : separated_space (add_cancel_monoid ennreal) := sorry --non-trivial
lemma new_lemma_135018 (h0 : functor.add_const (topological_space (pseudo_metric_space ennreal)) ennreal) : @t0_space.{0} (pseudo_metric_space.{0} ennreal) (@functor.add_const.run.{0 0} (topological_space.{0} (pseudo_metric_space.{0} ennreal)) ennreal h0)  := sorry --non-trivial
lemma new_lemma_135019 (h0 : topological_space (add_cancel_monoid (has_add unsigned))) : irreducible_space (add_cancel_monoid (has_add unsigned)) := sorry --non-trivial
lemma new_lemma_135020 (h0 : complete_lattice (linear_ordered_field (option (option empty)))) : is_compactly_generated (linear_ordered_field (option (option empty))) := sorry --non-trivial
lemma new_lemma_135021 (h0 : functor.add_const (list (has_nndist name)) (has_neg linarith.comp)) : palindrome (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_135022 (h0 : has_coe linarith.ineq Prop) (h1 : with_bot linarith.ineq) (h2 : ne h1 has_bot.bot) : @coe_b.{1 1} linarith.ineq Prop h0 (@with_bot.unbot.{0} linarith.ineq h1 h2)  := sorry --non-trivial
lemma new_lemma_135023 (h0 : function.extfun Type complete_lattice) : @is_atomistic.{0} (option.{0} unsigned) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (option.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_135024 (h0 : not (complete_lattice (complete_semilattice_Sup num) -> false)) : @complete_lattice.is_Sup_finite_compact.{0} (complete_semilattice_Sup.{0} num) (@classical.by_contradiction'.{1} (complete_lattice.{0} (complete_semilattice_Sup.{0} num)) h0)  := sorry --non-trivial
lemma new_lemma_135025 (h0 : topological_space (has_nndist pos)) : sequential_space (has_nndist pos) := sorry --non-trivial
lemma new_lemma_135026 (h0 : functor.add_const (function.extfun (Type 1) topological_space) environment.implicit_infer_kind) : @discrete_topology.{1} (semigroup.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) topological_space.{1}) environment.implicit_infer_kind h0) (semigroup.{1} Type))  := sorry --non-trivial
lemma new_lemma_135027 (h0 : group (simple_graph (has_add pos))) : is_cyclic (simple_graph (has_add pos)) := sorry --non-trivial
lemma new_lemma_135028 (h0 : topological_space (add_cancel_monoid (option (option pos)))) : t0_space (add_cancel_monoid (option (option pos))) := sorry --non-trivial
lemma new_lemma_135029 (h0 : functor.add_const (ring (complete_distrib_lattice name)) (has_Inf name)) : @rank_condition.{0} (complete_distrib_lattice.{0} name) (@functor.add_const.run.{0 0} (ring.{0} (complete_distrib_lattice.{0} name)) (has_Inf.{0} name) h0)  := sorry --non-trivial
lemma new_lemma_135030 (h0 : function.extfun Type semiring) : @is_noetherian_ring.{0} (@id.{2} Type num) (@function.extfun_app.{2 1} Type semiring.{0} h0 (@id.{2} Type num))  := sorry --non-trivial
lemma new_lemma_135031 (h0 : function.extfun Type topological_space) : @topological_space.separable_space.{0} (canonically_ordered_comm_semiring.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (canonically_ordered_comm_semiring.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_135032 (h0 : has_mem.mem (has_top num) has_emptyc.emptyc) : @complete_space.{0} (has_top.{0} num) (@finset.pi.empty.{1 0} Type uniform_space.{0} (has_top.{0} num) h0)  := sorry --non-trivial
lemma new_lemma_135033 (h0 : topological_space (semiring (has_norm num))) : irreducible_space (semiring (has_norm num)) := sorry --non-trivial
lemma new_lemma_135034 (h0 : not (function.extfun Type group -> false)) : @normalizer_condition.{0} (normed_group.{0} empty) (@function.extfun_app.{2 1} Type group.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type group.{0}) h0) (normed_group.{0} empty))  := sorry --non-trivial
lemma new_lemma_135035 (h0 : functor.add_const (topological_space (comm_group linarith.comp)) Type) : @irreducible_space.{0} (comm_group.{0} linarith.comp) (@functor.add_const.run.{0 1} (topological_space.{0} (comm_group.{0} linarith.comp)) Type h0)  := sorry --non-trivial
lemma new_lemma_135036 (h0 : complete_lattice (with_one (random_gen string_imp))) : complete_lattice.is_Sup_finite_compact (with_one (random_gen string_imp)) := sorry --non-trivial
lemma new_lemma_135037 (h0 : functor.add_const (list (comm_monoid empty)) unsigned) : list.nodup (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_135038 (h0 : ordered_add_comm_monoid (simple_graph (has_pos_part linarith.comp))) : archimedean (simple_graph (has_pos_part linarith.comp)) := sorry --non-trivial
lemma new_lemma_135039 (h0 : topological_space (comm_ring fun_info)) : totally_disconnected_space (comm_ring fun_info) := sorry --non-trivial
lemma new_lemma_135040 (h0 : functor.add_const (filter (has_zero linarith.comp)) Type) : countable_Inter_filter (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_135041 (h0 : function.extfun (Type 1) list) : list.nodup (function.extfun_app h0 (plift empty)) := sorry --non-trivial
lemma new_lemma_135042 (h0 : topological_space (canonically_ordered_monoid (has_neg pos))) : t1_space (canonically_ordered_monoid (has_neg pos)) := sorry --non-trivial
lemma new_lemma_135043 (h0 : functor.add_const (list (has_nndist environment.implicit_infer_kind)) name) : palindrome (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_135044 (h0 : not (complete_lattice (normed_group num) -> false)) : @is_compactly_generated.{0} (normed_group.{0} num) (@classical.by_contradiction'.{1} (complete_lattice.{0} (normed_group.{0} num)) h0)  := sorry --non-trivial
lemma new_lemma_135045 (h0 : not (ring (has_nnnorm fun_info) -> false)) : @is_domain.{0} (has_nnnorm.{0} fun_info) (@classical.by_contradiction'.{1} (ring.{0} (has_nnnorm.{0} fun_info)) h0)  := sorry --non-trivial
lemma new_lemma_135046 (h0 : ordered_add_comm_monoid (boolean_algebra.core ennreal)) : archimedean (boolean_algebra.core ennreal) := sorry --non-trivial
lemma new_lemma_135047 (h0 : functor.add_const (topological_space (has_zero unsigned)) environment.implicit_infer_kind) : @path_connected_space.{0} (has_zero.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (has_zero.{0} unsigned)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_135048 (h0 : uniform_space (semi_normed_comm_ring to_additive.value_type)) : complete_space (semi_normed_comm_ring to_additive.value_type) := sorry --non-trivial
lemma new_lemma_135049 (h0 : functor.add_const (uniform_space (has_nndist name)) environment.implicit_infer_kind) : @complete_space.{0} (has_nndist.{0} name) (@functor.add_const.run.{0 0} (uniform_space.{0} (has_nndist.{0} name)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_135050 (h0 : not (add_group (normed_field (mul_one_class char)) -> false)) : @is_add_cyclic.{0} (normed_field.{0} (mul_one_class.{0} char)) (@classical.by_contradiction'.{1} (add_group.{0} (normed_field.{0} (mul_one_class.{0} char))) h0)  := sorry --non-trivial
lemma new_lemma_135051 (h0 : topological_space (normed_comm_ring (option (option (option empty))))) : discrete_topology (normed_comm_ring (option (option (option empty)))) := sorry --non-trivial
lemma new_lemma_135052 (h0 : function.extfun Type topological_space) : @preirreducible_space.{0} (cancel_monoid.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (cancel_monoid.{0} pos))  := sorry --non-trivial
lemma new_lemma_135053 (h1 : topological_space string_imp) : t0_space string_imp := sorry --non-trivial
lemma new_lemma_135054 (h0 : topological_space (metric_space (semiring linarith.comp))) : locally_compact_space (metric_space (semiring linarith.comp)) := sorry --non-trivial
lemma new_lemma_135055 (h0 : add_group (sub_neg_monoid (has_Inf real))) : is_add_cyclic (sub_neg_monoid (has_Inf real)) := sorry --non-trivial
lemma new_lemma_135056 (h0 : function.extfun Type uniform_space) : @separated_space.{0} (has_bot.{0} pos) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (has_bot.{0} pos))  := sorry --non-trivial
lemma new_lemma_135057 (h0 : functor.add_const (ring (comm_group name)) (has_add Type)) : @strong_rank_condition.{0} (comm_group.{0} name) (@functor.add_const.run.{0 1} (ring.{0} (comm_group.{0} name)) (has_add.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_135058 (h0 : ring (semigroup (ring (has_nndist (has_add Type))))) : strong_rank_condition (semigroup (ring (has_nndist (has_add Type)))) := sorry --non-trivial
lemma new_lemma_135059 (h0 : ring (with_zero (has_ssubset (has_inv (has_nnnorm linarith.ineq))))) : rank_condition (with_zero (has_ssubset (has_inv (has_nnnorm linarith.ineq)))) := sorry --non-trivial
lemma new_lemma_135060 (h0 : has_mem.mem topological_space has_emptyc.emptyc) : @irreducible_space.{0} (with_bot.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) topological_space.{0} h0) (with_bot.{0} num))  := sorry --non-trivial
lemma new_lemma_135061 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @strong_rank_condition.{0} (add_group.{0} unsigned) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (add_group.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_135062 (h0 : not (group (left_cancel_semigroup unsigned) -> false)) : @normalizer_condition.{0} (left_cancel_semigroup.{0} unsigned) (@classical.by_contradiction'.{1} (group.{0} (left_cancel_semigroup.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_135063 (h0 : group (has_bot empty)) : is_cyclic (has_bot empty) := sorry --non-trivial
lemma new_lemma_135064 (h0 : function.extfun Type list) : list.nodup (function.extfun_app h0 (has_norm num)) := sorry --non-trivial
lemma new_lemma_135065 (h0 : topological_space (complete_distrib_lattice (has_Inf pos))) : locally_compact_space (complete_distrib_lattice (has_Inf pos)) := sorry --non-trivial
lemma new_lemma_135066 (h0 : functor.add_const (topological_space (left_cancel_semigroup num)) num) : @normal_space.{0} (left_cancel_semigroup.{0} num) (@functor.add_const.run.{0 0} (topological_space.{0} (left_cancel_semigroup.{0} num)) num h0)  := sorry --non-trivial
lemma new_lemma_135067 (h0 : not (ring (with_one num) -> false)) : @strong_rank_condition.{0} (with_one.{0} num) (@classical.by_contradiction'.{1} (ring.{0} (with_one.{0} num)) h0)  := sorry --non-trivial
lemma new_lemma_135068 (h1 : complete_lattice (denumerable (random_gen (random_gen (random_gen char))))) : complete_lattice.is_Sup_finite_compact (denumerable (random_gen (random_gen (random_gen char)))) := sorry --non-trivial
lemma new_lemma_135069 (h0 : functor.add_const (complete_lattice (boolean_algebra real)) real) : @is_atomistic.{0} (boolean_algebra.{0} real) (@functor.add_const.run.{0 0} (complete_lattice.{0} (boolean_algebra.{0} real)) real h0)  := sorry --non-trivial
lemma new_lemma_135070 (h0 : function.extfun Type add_monoid) : @add_monoid.fg.{0} (measurable_space.{0} num) (@function.extfun_app.{2 1} Type add_monoid.{0} h0 (measurable_space.{0} num))  := sorry --non-trivial
lemma new_lemma_135071 (h0 : topological_space (semigroup (has_add (has_to_string Type)))) : preconnected_space (semigroup (has_add (has_to_string Type))) := sorry --non-trivial
lemma new_lemma_135072 (h0 : complete_lattice (has_nnnorm (mul_one_class linarith.comp_source))) : is_compactly_generated (has_nnnorm (mul_one_class linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_135073 (h0 : functor.add_const (topological_space (comm_group name)) Type) : @discrete_topology.{0} (comm_group.{0} name) (@functor.add_const.run.{0 1} (topological_space.{0} (comm_group.{0} name)) Type h0)  := sorry --non-trivial
lemma new_lemma_135074 (h0 : functor.add_const (add_monoid pos) Type) : @add_monoid.fg.{0} pos (@functor.add_const.run.{0 1} (add_monoid.{0} pos) Type h0)  := sorry --non-trivial
lemma new_lemma_135075 (h0 : nat) (h1 : fin (nat.succ h0) -> fin has_zero.zero) (h2 : fin h0) : matrix.vec_empty (matrix.vec_tail h1 (id h2)) := sorry --non-trivial
lemma new_lemma_135076 (h0 : topological_space (has_nndist (has_to_string linarith.comp))) : path_connected_space (has_nndist (has_to_string linarith.comp)) := sorry --non-trivial
lemma new_lemma_135077 (h0 : ring (comm_ring (topological_space fun_info))) : rank_condition (comm_ring (topological_space fun_info)) := sorry --non-trivial
lemma new_lemma_135078 (h0 : function.extfun Type topological_space) : @discrete_topology.{0} (linear_ordered_field.{0} ennreal) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (linear_ordered_field.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_135079 (h0 : ring (has_to_string (finset (has_add pos)))) : rank_condition (has_to_string (finset (has_add pos))) := sorry --non-trivial
lemma new_lemma_135080 (h0 : add_group (semiring (semiring (semiring num)))) : is_add_cyclic (semiring (semiring (semiring num))) := sorry --non-trivial
lemma new_lemma_135081 (h0 : group (complete_distrib_lattice (ring (finset (has_add Type))))) : group.fg (complete_distrib_lattice (ring (finset (has_add Type)))) := sorry --non-trivial
lemma new_lemma_135082 (h0 : functor.add_const (topological_space (ordered_ring unsigned)) (semiring empty)) : @discrete_topology.{0} (ordered_ring.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (ordered_ring.{0} unsigned)) (semiring.{0} empty) h0)  := sorry --non-trivial
lemma new_lemma_135083 (h0 : functor.add_const (complete_lattice (has_zero ennreal)) pos) : @is_compactly_generated.{0} (has_zero.{0} ennreal) (@functor.add_const.run.{0 0} (complete_lattice.{0} (has_zero.{0} ennreal)) pos h0)  := sorry --non-trivial
lemma new_lemma_135084 (h0 : function.extfun Type topological_space) : @t0_space.{0} (simple_graph.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (simple_graph.{0} empty))  := sorry --non-trivial
lemma new_lemma_135085 (h0 : topological_space (comm_ring reducibility_hints)) : path_connected_space (comm_ring reducibility_hints) := sorry --non-trivial
lemma new_lemma_135086 (h0 : group (add_cancel_monoid (add_comm_monoid Type))) : is_cyclic (add_cancel_monoid (add_comm_monoid Type)) := sorry --non-trivial
lemma new_lemma_135087 (h0 : function.extfun (finset Type) (has_mem.mem num)) : @is_compactly_generated.{0} num (@finset.pi.empty.{1 0} Type complete_lattice.{0} num (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) num) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_135088 (h0 : add_group (plift (option (option (option unsigned))))) : is_add_cyclic (plift (option (option (option unsigned)))) := sorry --non-trivial
lemma new_lemma_135089 (h0 : not (function.extfun Type complete_lattice -> false)) : @is_atomistic.{0} (add_group.{0} empty) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type complete_lattice.{0}) h0) (add_group.{0} empty))  := sorry --non-trivial
lemma new_lemma_135090 (h0 : group (semiring (random_gen (random_gen linarith.comp)))) : normalizer_condition (semiring (random_gen (random_gen linarith.comp))) := sorry --non-trivial
lemma new_lemma_135091 (h0 : group (comm_group (has_neg_part unsigned))) : normalizer_condition (comm_group (has_neg_part unsigned)) := sorry --non-trivial
lemma new_lemma_135092 (h0 : group (random_gen (random_gen (random_gen (random_gen linarith.comp_source))))) : group.fg (random_gen (random_gen (random_gen (random_gen linarith.comp_source)))) := sorry --non-trivial
lemma new_lemma_135093 (h0 : not (complete_lattice (id linarith.comp) -> false)) : @complete_lattice.is_Sup_finite_compact.{0} (@id.{2} Type linarith.comp) (@classical.by_contradiction'.{1} (complete_lattice.{0} (@id.{2} Type linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_135094 (h0 : complete_lattice (ring Type)) : is_atomistic (ring Type) := sorry --non-trivial
lemma new_lemma_135095 (h0 : functor.add_const (topological_space (has_edist empty)) empty) : @t1_space.{0} (has_edist.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (has_edist.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_135096 (h0 : functor.add_const (monoid (generalized_boolean_algebra linarith.comp)) linarith.comp) : @monoid.fg.{0} (generalized_boolean_algebra.{0} linarith.comp) (@functor.add_const.run.{0 0} (monoid.{0} (generalized_boolean_algebra.{0} linarith.comp)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_135097 (h0 : list (complete_linear_order congr_arg_kind)) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_135098 (h0 : semiring (semigroup (boolean_algebra.core Type))) : is_noetherian_ring (semigroup (boolean_algebra.core Type)) := sorry --non-trivial
lemma new_lemma_135099 (h0 : add_group (has_le (has_le reducibility_hints))) : is_add_cyclic (has_le (has_le reducibility_hints)) := sorry --non-trivial
lemma new_lemma_135100 (h0 : cancel_comm_monoid_with_zero (non_assoc_semiring (semiring unsigned))) : unique_factorization_monoid (non_assoc_semiring (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_135101 (h0 : complete_lattice (canonically_ordered_monoid real)) : is_atomistic (canonically_ordered_monoid real) := sorry --non-trivial
lemma new_lemma_135102 (h0 : set (mul_one_class (mul_one_class (ordered_cancel_comm_monoid reducibility_hints)))) : set.finite h0 := sorry --non-trivial
lemma new_lemma_135103 (h0 : ring (nondiscrete_normed_field (linear_ordered_semiring enat))) : strong_rank_condition (nondiscrete_normed_field (linear_ordered_semiring enat)) := sorry --non-trivial
lemma new_lemma_135104 (h0 : functor.add_const (topological_space (has_nndist linarith.comp)) environment.implicit_infer_kind) : @loc_path_connected_space.{0} (has_nndist.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (has_nndist.{0} linarith.comp)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_135105 (h1 : group (id (has_top (has_top linarith.ineq)))) : normalizer_condition (id (has_top (has_top linarith.ineq))) := sorry --non-trivial
lemma new_lemma_135106 (h0 : filter (finset (add_comm_monoid (cancel_monoid name)))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_135107 (h1 : not (ring (has_norm congr_arg_kind) -> false)) : @strong_rank_condition.{0} (has_norm.{0} congr_arg_kind) (@classical.by_contradiction'.{1} (ring.{0} (has_norm.{0} congr_arg_kind)) h1)  := sorry --non-trivial
lemma new_lemma_135108 (h0 : group (denumerable string_imp)) : normalizer_condition (denumerable string_imp) := sorry --non-trivial
lemma new_lemma_135109 (h0 : group (has_inner (option empty) num)) : normalizer_condition (has_inner (option empty) num) := sorry --non-trivial
lemma new_lemma_135110 (h0 : not (add_group (with_zero to_additive.value_type) -> false)) : @is_add_cyclic.{0} (with_zero.{0} to_additive.value_type) (@classical.by_contradiction'.{1} (add_group.{0} (with_zero.{0} to_additive.value_type)) h0)  := sorry --non-trivial
lemma new_lemma_135111 (h0 : ring (generalized_boolean_algebra (comm_semigroup Type))) : rank_condition (generalized_boolean_algebra (comm_semigroup Type)) := sorry --non-trivial
lemma new_lemma_135112 (h0 : not (function.extfun Type ring -> false)) : @strong_rank_condition.{0} (linear_ordered_semiring.{0} empty) (@function.extfun_app.{2 1} Type ring.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type ring.{0}) h0) (linear_ordered_semiring.{0} empty))  := sorry --non-trivial
lemma new_lemma_135113 (h0 : topological_space (has_lt linarith.comp_source)) : path_connected_space (has_lt linarith.comp_source) := sorry --non-trivial
lemma new_lemma_135114 (h0 : complete_lattice znum) : complete_lattice.is_Sup_finite_compact znum := sorry --non-trivial
lemma new_lemma_135115 (h0 : complete_lattice (has_ssubset (has_ssubset to_additive.value_type))) : complete_lattice.is_Sup_finite_compact (has_ssubset (has_ssubset to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_135116 (h0 : not (monoid (semiring congr_arg_kind) -> false)) : @monoid.fg.{0} (semiring.{0} congr_arg_kind) (@classical.by_contradiction'.{1} (monoid.{0} (semiring.{0} congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_135117 (h0 : monoid (has_inter empty)) : monoid.fg (has_inter empty) := sorry --non-trivial
lemma new_lemma_135118 (h0 : functor.add_const (uniform_space (comm_group environment.implicit_infer_kind)) (has_nndist (ring Type))) : @complete_space.{0} (comm_group.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 1} (uniform_space.{0} (comm_group.{0} environment.implicit_infer_kind)) (has_nndist.{1} (ring.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_135119 (h0 : functor.add_const (filter (is_R_or_C unsigned)) empty) : filter.ne_bot (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_135120 (h0 : monoid (has_norm (comm_ring (random_gen linarith.ineq)))) : monoid.fg (has_norm (comm_ring (random_gen linarith.ineq))) := sorry --non-trivial
lemma new_lemma_135121 (h0 : ereal -> ereal -> ereal) (h3 : ereal) : right_identity h0 h3 := sorry --non-trivial
lemma new_lemma_135122 (h0 : function.extfun Type topological_space) : @discrete_topology.{0} (boolean_algebra.core.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (boolean_algebra.core.{0} name))  := sorry --non-trivial
lemma new_lemma_135123 (h0 : complete_lattice (cancel_monoid (canonically_ordered_add_monoid real))) : complete_lattice.is_Sup_finite_compact (cancel_monoid (canonically_ordered_add_monoid real)) := sorry --non-trivial
lemma new_lemma_135124 (h0 : complete_lattice (has_add (has_pos_part linarith.comp))) : is_compactly_generated (has_add (has_pos_part linarith.comp)) := sorry --non-trivial
lemma new_lemma_135125 (h0 : functor.add_const (ring (has_nndist name)) (comm_group ennreal)) : @is_principal_ideal_ring.{0} (has_nndist.{0} name) (@functor.add_const.run.{0 0} (ring.{0} (has_nndist.{0} name)) (comm_group.{0} ennreal) h0)  := sorry --non-trivial
lemma new_lemma_135126 (h0 : functor.add_const (ordered_add_comm_monoid (ordered_comm_ring Type)) name) : @archimedean.{1} (ordered_comm_ring.{1} Type) (@functor.add_const.run.{1 0} (ordered_add_comm_monoid.{1} (ordered_comm_ring.{1} Type)) name h0)  := sorry --non-trivial
lemma new_lemma_135127 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @archimedean.{0} (has_zero.{0} name) (@function.extfun_app.{2 1} Type ordered_add_comm_monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ordered_add_comm_monoid.{0}) (has_zero.{0} name))  := sorry --non-trivial
lemma new_lemma_135128 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @locally_compact_space.{0} (distrib_lattice.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (distrib_lattice.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_135129 (h0 : functor.add_const (list (plift empty)) num) : list.nodup (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_135130 (h0 : not (add_group (random_gen linarith.comp_source) -> false)) : @is_add_cyclic.{0} (random_gen.{0} linarith.comp_source) (@classical.by_contradiction'.{1} (add_group.{0} (random_gen.{0} linarith.comp_source)) h0)  := sorry --non-trivial
lemma new_lemma_135131 (h0 : not (function.extfun Type group -> false)) : @group.fg.{0} (with_one.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type group.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type group.{0}) h0) (with_one.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_135132 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @locally_compact_space.{0} (has_to_string.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_to_string.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_135133 (h0 : complete_lattice (has_inv (has_norm (has_norm (random_gen to_additive.value_type))))) : is_atomistic (has_inv (has_norm (has_norm (random_gen to_additive.value_type)))) := sorry --non-trivial
lemma new_lemma_135134 (h0 : functor.add_const (group (add_cancel_comm_monoid unsigned)) unsigned) : @is_cyclic.{0} (add_cancel_comm_monoid.{0} unsigned) (@functor.add_const.run.{0 0} (group.{0} (add_cancel_comm_monoid.{0} unsigned)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_135135 (h0 : complete_lattice (nondiscrete_normed_field environment.projection_info)) : complete_lattice.is_Sup_finite_compact (nondiscrete_normed_field environment.projection_info) := sorry --non-trivial
lemma new_lemma_135136 (h0 : has_top (has_top congr_arg_kind) -> has_top (has_top congr_arg_kind) -> Prop) : is_strict_order (has_top (has_top congr_arg_kind)) h0 := sorry --non-trivial
lemma new_lemma_135137 (h0 : option (uniform_space (distrib (metric_space to_additive.value_type)))) (h1 : not (coe_sort (option.is_some h0) -> false)) : @complete_space.{0} (distrib.{0} (metric_space.{0} to_additive.value_type)) (@option.get.{0} (uniform_space.{0} (distrib.{0} (metric_space.{0} to_additive.value_type))) h0 (@classical.by_contradiction'.{0} (@coe_sort.{1 1} bool Prop coe_sort_bool (@option.is_some.{0} (uniform_space.{0} (distrib.{0} (metric_space.{0} to_additive.value_type))) h0)) h1))  := sorry --non-trivial
lemma new_lemma_135138 (h0 : topological_space (canonically_ordered_comm_semiring empty)) : locally_compact_space (canonically_ordered_comm_semiring empty) := sorry --non-trivial
lemma new_lemma_135139 (h0 : add_group (ordered_ring empty)) : is_add_cyclic (ordered_ring empty) := sorry --non-trivial
lemma new_lemma_135140 (h0 : set (normed_field (normed_field std_gen))) : set.finite h0 := sorry --non-trivial
lemma new_lemma_135141 (h0 : ring (has_to_string (has_add name))) : is_principal_ideal_ring (has_to_string (has_add name)) := sorry --non-trivial
lemma new_lemma_135142 (h0 : fin has_zero.zero) : @sequential_space.{0} (sub_neg_monoid.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@matrix.vec_empty.{1} (function.extfun.{2 1} Type topological_space.{0}) h0) (sub_neg_monoid.{0} pos))  := sorry --non-trivial
lemma new_lemma_135143 (h1 : complete_lattice (with_one (with_bot linarith.comp_source))) : is_atomistic (with_one (with_bot linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_135144 (h0 : ordered_add_comm_monoid (add_cancel_monoid (comm_group (comm_group Type)))) : archimedean (add_cancel_monoid (comm_group (comm_group Type))) := sorry --non-trivial
lemma new_lemma_135145 (h0 : functor.add_const (function.extfun Type ordered_add_comm_monoid) (normed_comm_ring name)) : @archimedean.{0} (has_zero.{0} name) (@function.extfun_app.{2 1} Type ordered_add_comm_monoid.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type ordered_add_comm_monoid.{0}) (normed_comm_ring.{0} name) h0) (has_zero.{0} name))  := sorry --non-trivial
lemma new_lemma_135146 (h1 : set (semi_normed_ring string_imp)) : set.finite h1 := sorry --non-trivial
lemma new_lemma_135147 (h0 : cancel_comm_monoid_with_zero (bin_tree empty)) : unique_factorization_monoid (bin_tree empty) := sorry --non-trivial
lemma new_lemma_135148 (h0 : group (semigroup (has_to_string unsigned))) : normalizer_condition (semigroup (has_to_string unsigned)) := sorry --non-trivial
lemma new_lemma_135149 (h0 : not (group (random_gen num) -> false)) : @is_cyclic.{0} (random_gen.{0} num) (@classical.by_contradiction'.{1} (group.{0} (random_gen.{0} num)) h0)  := sorry --non-trivial
lemma new_lemma_135150 (h0 : add_monoid (ring (has_add pos))) : add_monoid.fg (ring (has_add pos)) := sorry --non-trivial
lemma new_lemma_135151 (h1 : add_group (has_lt environment.projection_info)) : is_add_cyclic (has_lt environment.projection_info) := sorry --non-trivial
lemma new_lemma_135152 (h0 : functor.add_const (function.extfun Type uniform_space) (mul_zero_class (has_neg Type))) : @separated_space.{0} (mul_zero_class.{0} ennreal) (@function.extfun_app.{2 1} Type uniform_space.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type uniform_space.{0}) (mul_zero_class.{1} (has_neg.{1} Type)) h0) (mul_zero_class.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_135153 (h1 : add_group (dlist (has_nnnorm (has_nnnorm (has_nnnorm (random_gen fun_info)))))) : is_add_cyclic (dlist (has_nnnorm (has_nnnorm (has_nnnorm (random_gen fun_info))))) := sorry --non-trivial
lemma new_lemma_135154 (h0 : topological_space (cancel_monoid (comm_group (comm_group (comm_group Type))))) : locally_compact_space (cancel_monoid (comm_group (comm_group (comm_group Type)))) := sorry --non-trivial
lemma new_lemma_135155 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @topological_space.separable_space.{0} (has_nndist.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_nndist.{0} num))  := sorry --non-trivial
lemma new_lemma_135156 (h0 : functor.add_const (complete_lattice (has_neg_part Type)) name) : @is_compactly_generated.{1} (has_neg_part.{1} Type) (@functor.add_const.run.{1 0} (complete_lattice.{1} (has_neg_part.{1} Type)) name h0)  := sorry --non-trivial
lemma new_lemma_135157 (h0 : function.extfun Type group) : @is_cyclic.{0} num (@function.extfun_app.{2 1} Type group.{0} h0 num)  := sorry --non-trivial
lemma new_lemma_135158 (h0 : topological_space (id (semiring (semiring (semiring linarith.comp))))) : t0_space (id (semiring (semiring (semiring linarith.comp)))) := sorry --non-trivial
lemma new_lemma_135159 (h0 : topological_space (has_zero (has_zero linarith.comp))) : totally_disconnected_space (has_zero (has_zero linarith.comp)) := sorry --non-trivial
lemma new_lemma_135160 (h0 : topological_space (measure_theory.measure_space empty)) : normal_space (measure_theory.measure_space empty) := sorry --non-trivial
lemma new_lemma_135161 (h0 : add_monoid (linear_ordered_semiring (semiring num))) : add_monoid.fg (linear_ordered_semiring (semiring num)) := sorry --non-trivial
lemma new_lemma_135162 (h0 : topological_space (has_to_string (has_to_string (has_neg_part Type)))) : locally_compact_space (has_to_string (has_to_string (has_neg_part Type))) := sorry --non-trivial
lemma new_lemma_135163 (h0 : topological_space (semiring (has_norm congr_arg_kind))) : discrete_topology (semiring (has_norm congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_135164 (h1 : topological_space fun_info) : topological_space.first_countable_topology fun_info := sorry --non-trivial
lemma new_lemma_135165 (h0 : topological_space (denumerable (random_gen to_additive.value_type))) : t0_space (denumerable (random_gen to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_135166 (h0 : function.extfun Type group) : @is_simple_group.{0} (has_dist.{0} num) (@function.extfun_app.{2 1} Type group.{0} h0 (has_dist.{0} num))  := sorry --non-trivial
lemma new_lemma_135167 (h0 : functor.add_const (cancel_comm_monoid_with_zero (group_with_zero ennreal)) unsigned) : @unique_factorization_monoid.{0} (group_with_zero.{0} ennreal) (@functor.add_const.run.{0 0} (cancel_comm_monoid_with_zero.{0} (group_with_zero.{0} ennreal)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_135168 (h0 : functor.add_const (ring (ring linarith.comp)) pos) : @rank_condition.{0} (ring.{0} linarith.comp) (@functor.add_const.run.{0 0} (ring.{0} (ring.{0} linarith.comp)) pos h0)  := sorry --non-trivial
lemma new_lemma_135169 (h0 : functor.add_const (function.extfun (Type 1) topological_space) pos) : @locally_compact_space.{1} (finset.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) topological_space.{1}) pos h0) (finset.{1} Type))  := sorry --non-trivial
lemma new_lemma_135170 (h0 : group (complete_distrib_lattice (option pos))) : is_cyclic (complete_distrib_lattice (option pos)) := sorry --non-trivial
lemma new_lemma_135171 (h0 : functor.add_const (function.extfun Type complete_lattice) linarith.comp) : @complete_lattice.is_Sup_finite_compact.{0} (simple_graph.{0} linarith.comp) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type complete_lattice.{0}) linarith.comp h0) (simple_graph.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_135172 (h0 : ring (encodable (has_nnnorm (random_gen char)))) : rank_condition (encodable (has_nnnorm (random_gen char))) := sorry --non-trivial
lemma new_lemma_135173 (h0 : functor.add_const (group (has_star empty)) empty) : @normalizer_condition.{0} (has_star.{0} empty) (@functor.add_const.run.{0 0} (group.{0} (has_star.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_135174 (h2 : uniform_space (random_gen to_additive.value_type)) : complete_space (random_gen to_additive.value_type) := sorry --non-trivial
lemma new_lemma_135175 (h0 : add_monoid (canonically_ordered_monoid (sub_neg_monoid (has_bot pos)))) : add_monoid.fg (canonically_ordered_monoid (sub_neg_monoid (has_bot pos))) := sorry --non-trivial
lemma new_lemma_135176 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @sequential_space.{0} (canonically_linear_ordered_monoid.{0} real) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (canonically_linear_ordered_monoid.{0} real))  := sorry --non-trivial
lemma new_lemma_135177 (h0 : fin has_zero.zero) : @complete_lattice.is_Sup_finite_compact.{1} (has_bot.{1} Type) (@matrix.vec_empty.{1} (complete_lattice.{1} (has_bot.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_135178 (h0 : functor.add_const Prop (sub_neg_monoid real)) : functor.add_const.run h0 := sorry --non-trivial
lemma new_lemma_135179 (h0 : functor.add_const (function.extfun (Type 1) list) linarith.comp) : palindrome (function.extfun_app (functor.add_const.run h0) Type) := sorry --non-trivial
lemma new_lemma_135180 (h0 : has_zero to_additive.value_type) (h1 : to_additive.value_type) : ne_zero h1 := sorry --non-trivial
lemma new_lemma_135181 (h0 : topological_space (add_comm_semigroup fun_info)) (h1 : set (add_comm_semigroup fun_info)) : is_path_connected h1 := sorry --non-trivial
lemma new_lemma_135182 (h0 : function.extfun Type uniform_space) : @complete_space.{0} (with_zero.{0} linarith.ineq) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (with_zero.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_135183 (h0 : semiring (with_one (has_norm empty))) : is_noetherian_ring (with_one (has_norm empty)) := sorry --non-trivial
lemma new_lemma_135184 (h0 : group (comm_ring (has_nnnorm linarith.ineq))) : group.fg (comm_ring (has_nnnorm linarith.ineq)) := sorry --non-trivial
lemma new_lemma_135185 (h0 : complete_lattice (is_R_or_C (has_div string.iterator_imp))) : complete_lattice.is_Sup_finite_compact (is_R_or_C (has_div string.iterator_imp)) := sorry --non-trivial
lemma new_lemma_135186 (h0 : monoid (random_gen (has_inv to_additive.value_type))) : monoid.fg (random_gen (has_inv to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_135187 (h0 : topological_space (canonically_ordered_add_monoid empty)) : path_connected_space (canonically_ordered_add_monoid empty) := sorry --non-trivial
lemma new_lemma_135188 (h1 : ring (with_zero char)) : is_domain (with_zero char) := sorry --non-trivial
lemma new_lemma_135189 (h0 : functor.add_const (topological_space (measurable_space.dynkin_system congr_arg_kind)) unsigned) : @irreducible_space.{0} (measurable_space.dynkin_system.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (measurable_space.dynkin_system.{0} congr_arg_kind)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_135190 (h0 : monoid (has_inv (random_gen to_additive.value_type))) : monoid.fg (has_inv (random_gen to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_135191 (h0 : functor.add_const (topological_space (comm_group name)) pos) : @t1_space.{0} (comm_group.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (comm_group.{0} name)) pos h0)  := sorry --non-trivial
lemma new_lemma_135192 (h0 : topological_space (has_norm to_additive.value_type)) : discrete_topology (has_norm to_additive.value_type) := sorry --non-trivial
lemma new_lemma_135193 (h0 : monoid (add_right_cancel_monoid (semiring unsigned))) : monoid.fg (add_right_cancel_monoid (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_135194 (h0 : cancel_comm_monoid_with_zero (div_inv_monoid (option empty))) : unique_factorization_monoid (div_inv_monoid (option empty)) := sorry --non-trivial
lemma new_lemma_135195 (h0 : functor.add_const (add_group (comm_group Type)) (normed_comm_ring pos)) : @is_add_cyclic.{1} (comm_group.{1} Type) (@functor.add_const.run.{1 0} (add_group.{1} (comm_group.{1} Type)) (normed_comm_ring.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_135196 (h0 : ring (measurable_space (has_norm (has_norm fun_info)))) : is_domain (measurable_space (has_norm (has_norm fun_info))) := sorry --non-trivial
lemma new_lemma_135197 (h0 : uniform_space (has_Sup num)) : complete_space (has_Sup num) := sorry --non-trivial
lemma new_lemma_135198 (h0 : list num) (h1 : function.extfun Type (functor.add_const Prop)) : yyy_to (palindrome h0) (functor.add_const.run (function.extfun_app h1 congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_135199 (h0 : prod (finset (option unsigned)) (finset (option unsigned))) : id_rel h0 := sorry --non-trivial
lemma new_lemma_135200 (h0 : add_group (semiring (has_union (has_norm (has_union linarith.comp))))) : is_add_cyclic (semiring (has_union (has_norm (has_union linarith.comp)))) := sorry --non-trivial
lemma new_lemma_135201 (h1 : topological_space (has_nnnorm (metric_space linarith.comp_source))) : t0_space (has_nnnorm (metric_space linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_135202 (h0 : ring (has_top fun_info)) : is_domain (has_top fun_info) := sorry --non-trivial
lemma new_lemma_135203 (h0 : functor.add_const (topological_space (has_zero unsigned)) name) : @loc_path_connected_space.{0} (has_zero.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (has_zero.{0} unsigned)) name h0)  := sorry --non-trivial
lemma new_lemma_135204 (h0 : functor.add_const (ring (has_Inf linarith.comp)) name) : @rank_condition.{0} (has_Inf.{0} linarith.comp) (@functor.add_const.run.{0 0} (ring.{0} (has_Inf.{0} linarith.comp)) name h0)  := sorry --non-trivial
lemma new_lemma_135205 (h0 : topological_space (has_union (semiring empty))) : discrete_topology (has_union (semiring empty)) := sorry --non-trivial
lemma new_lemma_135206 (h0 : function.extfun Type filter) : countable_Inter_filter (function.extfun_app h0 (cancel_monoid congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_135207 (h0 : ring (complete_distrib_lattice environment.implicit_infer_kind)) : rank_condition (complete_distrib_lattice environment.implicit_infer_kind) := sorry --non-trivial
lemma new_lemma_135208 (h0 : functor.add_const (filter (has_to_string Type)) name) : countable_Inter_filter (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_135209 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : list.nodup (function.extfun_app (function.extfun_app h0 list) real) := sorry --non-trivial
lemma new_lemma_135210 (h0 : group (has_norm empty)) : group.fg (has_norm empty) := sorry --non-trivial
lemma new_lemma_135211 (h0 : functor.add_const (uniform_space (has_bot pos)) linarith.comp) : @complete_space.{0} (has_bot.{0} pos) (@functor.add_const.run.{0 0} (uniform_space.{0} (has_bot.{0} pos)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_135212 (h0 : add_group (has_edist (option (option empty)))) : is_add_cyclic (has_edist (option (option empty))) := sorry --non-trivial
lemma new_lemma_135213 (h0 : semiring (generalized_boolean_algebra (ordered_comm_ring linarith.comp))) : is_noetherian_ring (generalized_boolean_algebra (ordered_comm_ring linarith.comp)) := sorry --non-trivial
lemma new_lemma_135214 (h0 : complete_lattice (complete_distrib_lattice (has_Inf name))) : is_compactly_generated (complete_distrib_lattice (has_Inf name)) := sorry --non-trivial
lemma new_lemma_135215 (h2 : uniform_space (has_append (denumerable to_additive.value_type))) : complete_space (has_append (denumerable to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_135216 (h0 : ring (has_nndist (comm_group (comm_group pos)))) : strong_rank_condition (has_nndist (comm_group (comm_group pos))) := sorry --non-trivial
lemma new_lemma_135217 (h0 : function.extfun Type ordered_add_comm_monoid) : @archimedean.{0} (omega_complete_partial_order.{0} unsigned) (@function.extfun_app.{2 1} Type ordered_add_comm_monoid.{0} h0 (omega_complete_partial_order.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_135218 (h0 : function.extfun (finset (Type -> Type) -> Prop) (function.extfun (finset (Type -> Type)))) : @preirreducible_space.{0} (has_norm.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) topological_space.{0} (@function.extfun_app.{2 0} (finset.{1} (Type → Type)) (@has_mem.mem.{1 1} (Type → Type) (finset.{1} (Type → Type)) (@finset.has_mem.{1} (Type → Type)) topological_space.{0}) (@function.extfun_app.{2 0} (finset.{1} (Type → Type) → Prop) (function.extfun.{2 0} (finset.{1} (Type → Type))) (@id.{0} (function.extfun.{2 0} (finset.{1} (Type → Type) → Prop) (function.extfun.{2 0} (finset.{1} (Type → Type)))) h0) (@has_mem.mem.{1 1} (Type → Type) (finset.{1} (Type → Type)) (@finset.has_mem.{1} (Type → Type)) topological_space.{0})) (@has_emptyc.emptyc.{1} (finset.{1} (Type → Type)) (@finset.has_emptyc.{1} (Type → Type))))) (has_norm.{0} empty))  := sorry --non-trivial
lemma new_lemma_135219 (h2 : add_group (denumerable fun_info)) : is_add_cyclic (denumerable fun_info) := sorry --non-trivial
lemma new_lemma_135220 (h0 : functor.add_const (functor.add_const (topological_space pos) name) Type) : @path_connected_space.{0} pos (@functor.add_const.run.{0 0} (topological_space.{0} pos) name (@functor.add_const.run.{0 1} (functor.add_const.{0 0} (topological_space.{0} pos) name) Type h0))  := sorry --non-trivial
lemma new_lemma_135221 (h0 : cancel_comm_monoid_with_zero (has_top (semiring unsigned))) : unique_factorization_monoid (has_top (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_135222 (h0 : function.extfun Type (functor.add_const Prop)) : functor.add_const.run (function.extfun_app h0 (boolean_algebra.core pos)) := sorry --non-trivial
lemma new_lemma_135223 (h0 : topological_space (semigroup stieltjes_function)) : normal_space (semigroup stieltjes_function) := sorry --non-trivial
lemma new_lemma_135224 (h0 h1 : multiset (uniform_space string.iterator_imp)) : multiset.disjoint h0 h1 := sorry --non-trivial
lemma new_lemma_135225 (h0 : group (finset (ring linarith.comp))) : normalizer_condition (finset (ring linarith.comp)) := sorry --non-trivial
lemma new_lemma_135226 (h0 : topological_space (complete_semilattice_Sup char)) : path_connected_space (complete_semilattice_Sup char) := sorry --non-trivial
lemma new_lemma_135227 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @complete_space.{0} (has_nndist.{0} name) (@function.extfun_app.{2 1} Type uniform_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 uniform_space.{0}) (has_nndist.{0} name))  := sorry --non-trivial
lemma new_lemma_135228 (h0 : semiring (boolean_algebra Type)) : is_noetherian_ring (boolean_algebra Type) := sorry --non-trivial
lemma new_lemma_135229 (h0 : function.extfun (finset Type) (has_mem.mem (measurable_space num))) : is_atomistic (measurable_space num) := sorry --non-trivial
lemma new_lemma_135230 (h0 : complete_lattice (plift (has_star (semiring num)))) : is_compactly_generated (plift (has_star (semiring num))) := sorry --non-trivial
lemma new_lemma_135231 (h3 h4 : multiset (has_nnnorm (linear_ordered_comm_monoid char))) : multiset.subset h3 h4 := sorry --non-trivial
lemma new_lemma_135232 (h0 : group (omega_complete_partial_order empty)) : is_cyclic (omega_complete_partial_order empty) := sorry --non-trivial
lemma new_lemma_135233 (h0 : ordered_comm_monoid (ring (has_neg (has_neg Type)))) : has_exists_mul_of_le (ring (has_neg (has_neg Type))) := sorry --non-trivial
lemma new_lemma_135234 (h0 : list (boolean_algebra (has_Inf pos))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_135235 (h0 : functor.add_const (function.extfun (Type 1) group) (has_Inf (has_pos_part (has_pos_part linarith.comp)))) : @normalizer_condition.{1} (semigroup.{1} Type) (@function.extfun_app.{3 2} (Type 1) group.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) group.{1}) (has_Inf.{0} (has_pos_part.{0} (has_pos_part.{0} linarith.comp))) h0) (semigroup.{1} Type))  := sorry --non-trivial
lemma new_lemma_135236 (h0 : function.extfun Type ring) : @strong_rank_condition.{0} (ring.{0} empty) (@function.extfun_app.{2 1} Type ring.{0} h0 (ring.{0} empty))  := sorry --non-trivial
lemma new_lemma_135237 (h1 : ring (uniform_space linarith.ineq)) : rank_condition (uniform_space linarith.ineq) := sorry --non-trivial
lemma new_lemma_135238 (h0 : ring (with_one (semiring congr_arg_kind))) : rank_condition (with_one (semiring congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_135239 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @unique_factorization_monoid.{0} (preorder.{0} empty) (@function.extfun_app.{2 1} Type cancel_comm_monoid_with_zero.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 cancel_comm_monoid_with_zero.{0}) (preorder.{0} empty))  := sorry --non-trivial
lemma new_lemma_135240 (h0 : complete_lattice (has_norm (semiring empty))) : complete_lattice.is_Sup_finite_compact (has_norm (semiring empty)) := sorry --non-trivial
lemma new_lemma_135241 (h0 : complete_lattice (non_assoc_semiring (has_inv linarith.comp_source))) : complete_lattice.is_Sup_finite_compact (non_assoc_semiring (has_inv linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_135242 (h0 : comm_semiring (measure_theory.measure_space unsigned)) (h1 : topological_space (mv_polynomial ennreal (measure_theory.measure_space unsigned))) : path_connected_space (mv_polynomial ennreal (measure_theory.measure_space unsigned)) := sorry --non-trivial
lemma new_lemma_135243 (h0 : list (normed_linear_ordered_group (option (option empty)))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_135244 (h0 : topological_space (canonically_linear_ordered_monoid pos)) : topological_space.separable_space (canonically_linear_ordered_monoid pos) := sorry --non-trivial
lemma new_lemma_135245 (h0 : function.extfun Type group) : @group.fg.{0} (linear_ordered_semiring.{0} unsigned) (@function.extfun_app.{2 1} Type group.{0} h0 (linear_ordered_semiring.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_135246 (h0 : group (has_union (semiring (semiring empty)))) : normalizer_condition (has_union (semiring (semiring empty))) := sorry --non-trivial
lemma new_lemma_135247 (h0 : functor.add_const (function.extfun Type topological_space) linarith.comp) : @preconnected_space.{0} (has_neg.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) linarith.comp h0) (has_neg.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_135248 (h0 : not (complete_lattice (complete_linear_order unsigned) -> false)) : @is_atomistic.{0} (complete_linear_order.{0} unsigned) (@classical.by_contradiction'.{1} (complete_lattice.{0} (complete_linear_order.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_135249 (h1 : uniform_space congr_arg_kind) : separated_space congr_arg_kind := sorry --non-trivial
lemma new_lemma_135250 (h0 : function.extfun Type complete_lattice) : @complete_lattice.is_Sup_finite_compact.{0} (normed_group.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (normed_group.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_135251 (h0 : functor.add_const (filter (ring pos)) (has_neg_part pos)) : filter.ne_bot (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_135252 (h0 : function.extfun ((Type -> Type) -> Type 1) (function.extfun (Type -> Type))) : @monoid.fg.{0} (normed_group.{0} fun_info) (@function.extfun_app.{2 1} Type monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) (@function.extfun_app.{3 2} ((Type → Type) → Type 1) (function.extfun.{2 2} (Type → Type)) h0 (function.extfun.{2 1} Type)) monoid.{0}) (normed_group.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_135253 (h0 : list (div_inv_monoid (option unsigned))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_135254 (h0 : topological_space (has_to_string (has_nndist environment.implicit_infer_kind))) : preirreducible_space (has_to_string (has_nndist environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_135255 (h0 : functor.add_const (semiring (add_cancel_monoid pos)) environment.implicit_infer_kind) : @is_noetherian_ring.{0} (add_cancel_monoid.{0} pos) (@functor.add_const.run.{0 0} (semiring.{0} (add_cancel_monoid.{0} pos)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_135256 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @has_exists_mul_of_le.{0} (has_nndist.{0} unsigned) (@function.extfun_app.{2 1} Type ordered_comm_monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ordered_comm_monoid.{0}) (has_nndist.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_135257 (h0 : monoid (normed_lattice_add_comm_group pos)) : monoid.fg (normed_lattice_add_comm_group pos) := sorry --non-trivial
lemma new_lemma_135258 (h0 : topological_space (comm_semigroup (sub_neg_monoid Type))) : preirreducible_space (comm_semigroup (sub_neg_monoid Type)) := sorry --non-trivial
lemma new_lemma_135259 (h0 : topological_space (measurable_space.dynkin_system (semiring num))) : locally_compact_space (measurable_space.dynkin_system (semiring num)) := sorry --non-trivial
lemma new_lemma_135260 (h0 : topological_space (sub_neg_monoid (finset (has_add pos)))) : topological_space.separable_space (sub_neg_monoid (finset (has_add pos))) := sorry --non-trivial
lemma new_lemma_135261 (h0 : complete_lattice (cancel_monoid (semigroup name))) : is_atomistic (cancel_monoid (semigroup name)) := sorry --non-trivial
lemma new_lemma_135262 (h0 : not (function.extfun Type uniform_space -> false)) : @separated_space.{0} (normed_group.{0} num) (@function.extfun_app.{2 1} Type uniform_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type uniform_space.{0}) h0) (normed_group.{0} num))  := sorry --non-trivial
lemma new_lemma_135263 (h0 : not (group (has_star empty) -> false)) : @normalizer_condition.{0} (has_star.{0} empty) (@classical.by_contradiction'.{1} (group.{0} (has_star.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_135264 (h0 : not (ring (semi_normed_comm_ring fun_info) -> false)) : @is_domain.{0} (semi_normed_comm_ring.{0} fun_info) (@classical.by_contradiction'.{1} (ring.{0} (semi_normed_comm_ring.{0} fun_info)) h0)  := sorry --non-trivial
lemma new_lemma_135265 (h0 : finset (simple_graph (has_Inf Type))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_135266 (h0 : not (topological_space (conditionally_complete_linear_order to_additive.value_type) -> false)) : @path_connected_space.{0} (conditionally_complete_linear_order.{0} to_additive.value_type) (@classical.by_contradiction'.{1} (topological_space.{0} (conditionally_complete_linear_order.{0} to_additive.value_type)) h0)  := sorry --non-trivial
lemma new_lemma_135267 (h0 : add_group (add_comm_monoid pos)) : is_add_cyclic (add_comm_monoid pos) := sorry --non-trivial
lemma new_lemma_135268 (h0 : functor.add_const (list (has_neg name)) linarith.comp) : list.nodup (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_135269 (h0 : topological_space (with_bot (has_ssubset linarith.ineq))) : totally_disconnected_space (with_bot (has_ssubset linarith.ineq)) := sorry --non-trivial
lemma new_lemma_135270 (h0 : option (add_monoid (add_cancel_monoid (option (option (option (option (option num)))))))) (h1 : add_monoid (add_cancel_monoid (option (option (option (option (option num))))))) : add_monoid.fg (add_cancel_monoid (option (option (option (option (option num)))))) := sorry --non-trivial
lemma new_lemma_135271 (h0 : fin has_zero.zero) : @is_add_cyclic.{1} (ordered_comm_monoid.{1} Type) (@matrix.vec_empty.{1} (add_group.{1} (ordered_comm_monoid.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_135272 (h0 : not (ring (has_one unsigned) -> false)) : @is_principal_ideal_ring.{0} (has_one.{0} unsigned) (@classical.by_contradiction'.{1} (ring.{0} (has_one.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_135273 (h0 : function.extfun Type topological_space) : @topological_space.separable_space.{0} (linear_ordered_field.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (linear_ordered_field.{0} empty))  := sorry --non-trivial
lemma new_lemma_135274 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @t0_space.{0} (topological_space.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (topological_space.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_135275 (h0 : topological_space (has_append (mul_one_class fun_info))) : t0_space (has_append (mul_one_class fun_info)) := sorry --non-trivial
lemma new_lemma_135276 (h0 : functor.add_const (topological_space (free_add_monoid unsigned)) empty) : @t0_space.{0} (free_add_monoid.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (free_add_monoid.{0} unsigned)) empty h0)  := sorry --non-trivial
lemma new_lemma_135277 (h0 : ordered_add_comm_monoid (option name)) : archimedean (option name) := sorry --non-trivial
lemma new_lemma_135278 (h0 : add_group (left_cancel_monoid congr_arg_kind)) : is_add_cyclic (left_cancel_monoid congr_arg_kind) := sorry --non-trivial
lemma new_lemma_135279 (h0 : topological_space (add_comm_monoid (comm_group Type))) : preconnected_space (add_comm_monoid (comm_group Type)) := sorry --non-trivial
lemma new_lemma_135280 (h0 : functor.add_const (topological_space (boolean_algebra.core Type)) linarith.comp) : @irreducible_space.{1} (boolean_algebra.core.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (boolean_algebra.core.{1} Type)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_135281 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @preirreducible_space.{0} (ordered_comm_monoid.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (ordered_comm_monoid.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_135282 (h0 : complete_lattice (distrib_lattice (random_gen char))) : complete_lattice.is_Sup_finite_compact (distrib_lattice (random_gen char)) := sorry --non-trivial
lemma new_lemma_135283 (h0 : functor.add_const (complete_lattice (complete_linear_order unsigned)) empty) : @is_atomistic.{0} (complete_linear_order.{0} unsigned) (@functor.add_const.run.{0 0} (complete_lattice.{0} (complete_linear_order.{0} unsigned)) empty h0)  := sorry --non-trivial
lemma new_lemma_135284 (h0 : functor.add_const (group (has_nndist unsigned)) pos) : @group.fg.{0} (has_nndist.{0} unsigned) (@functor.add_const.run.{0 0} (group.{0} (has_nndist.{0} unsigned)) pos h0)  := sorry --non-trivial
lemma new_lemma_135285 (h0 : group (has_append (comm_ring (metric_space reducibility_hints)))) : is_cyclic (has_append (comm_ring (metric_space reducibility_hints))) := sorry --non-trivial
lemma new_lemma_135286 (h0 : function.extfun Type add_monoid) : @add_monoid.fg.{0} (add_left_cancel_semigroup.{0} unsigned) (@function.extfun_app.{2 1} Type add_monoid.{0} h0 (add_left_cancel_semigroup.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_135287 (h0 : functor.add_const (function.extfun Type add_group) (finset pos)) : @is_add_cyclic.{0} (has_zero.{0} pos) (@function.extfun_app.{2 1} Type add_group.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type add_group.{0}) (finset.{0} pos) h0) (has_zero.{0} pos))  := sorry --non-trivial
lemma new_lemma_135288 (h0 : functor.add_const (topological_space (comm_group environment.implicit_infer_kind)) name) : @sequential_space.{0} (comm_group.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (comm_group.{0} environment.implicit_infer_kind)) name h0)  := sorry --non-trivial
lemma new_lemma_135289 (h0 : functor.add_const (function.extfun Type group) Type) : @normalizer_condition.{0} (has_to_string.{0} pos) (@function.extfun_app.{2 1} Type group.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type group.{0}) Type h0) (has_to_string.{0} pos))  := sorry --non-trivial
lemma new_lemma_135290 (h0 : cancel_comm_monoid_with_zero (has_nndist (has_neg_part Type))) : unique_factorization_monoid (has_nndist (has_neg_part Type)) := sorry --non-trivial
lemma new_lemma_135291 (h0 : functor.add_const (functor.add_const (list pos) (ring linarith.comp)) pos) : list.nodup (functor.add_const.run (functor.add_const.run h0)) := sorry --non-trivial
lemma new_lemma_135292 (h2 : set (add_comm_semigroup enat -> ereal)) : set.separates_points h2 := sorry --non-trivial
lemma new_lemma_135293 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : list.nodup (function.extfun_app (function.extfun_app h0 list) (id to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_135294 (h0 : group (comm_ring (has_nnnorm linarith.comp_source))) : group.fg (comm_ring (has_nnnorm linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_135295 (h0 : list (has_Inf (has_Inf Type))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_135296 (h0 : topological_space (ordered_comm_monoid (has_add name))) : t1_space (ordered_comm_monoid (has_add name)) := sorry --non-trivial
lemma new_lemma_135297 (h0 : topological_space (normed_field (metric_space string_imp))) : t0_space (normed_field (metric_space string_imp)) := sorry --non-trivial
lemma new_lemma_135298 (h0 : add_group (boolean_algebra real)) : is_add_cyclic (boolean_algebra real) := sorry --non-trivial
lemma new_lemma_135299 (h0 : ring (has_pos_part (has_neg (has_nndist Type)))) : strong_rank_condition (has_pos_part (has_neg (has_nndist Type))) := sorry --non-trivial
lemma new_lemma_135300 (h0 : topological_space (comm_group (add_comm_monoid Type))) : preirreducible_space (comm_group (add_comm_monoid Type)) := sorry --non-trivial
lemma new_lemma_135301 (h0 : functor.add_const (topological_space (cancel_monoid pos)) pos) : @path_connected_space.{0} (cancel_monoid.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (cancel_monoid.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_135302 (h0 : has_lt (distrib string_imp)) : no_max_order (distrib string_imp) := sorry --non-trivial
lemma new_lemma_135303 (h0 : functor.add_const (uniform_space (semiring fun_info)) linarith.ineq) : @complete_space.{0} (semiring.{0} fun_info) (@functor.add_const.run.{0 0} (uniform_space.{0} (semiring.{0} fun_info)) linarith.ineq h0)  := sorry --non-trivial
lemma new_lemma_135304 (h0 : uniform_space (random_gen (random_gen (has_top (random_gen (random_gen num)))))) : separated_space (random_gen (random_gen (has_top (random_gen (random_gen num))))) := sorry --non-trivial
lemma new_lemma_135305 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @locally_compact_space.{0} (linear_ordered_add_comm_group_with_top.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (linear_ordered_add_comm_group_with_top.{0} pos))  := sorry --non-trivial
lemma new_lemma_135306 (h0 : functor.add_const (group (option num)) empty) : @normalizer_condition.{0} (option.{0} num) (@functor.add_const.run.{0 0} (group.{0} (option.{0} num)) empty h0)  := sorry --non-trivial
lemma new_lemma_135307 (h0 : filter (canonically_ordered_comm_semiring (has_nndist name))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_135308 (h0 : function.extfun Type topological_space) : @discrete_topology.{0} (has_add.{0} real) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_add.{0} real))  := sorry --non-trivial
lemma new_lemma_135309 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @archimedean.{0} (has_to_string.{0} linarith.comp) (@function.extfun_app.{2 1} Type ordered_add_comm_monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ordered_add_comm_monoid.{0}) (has_to_string.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_135310 (h0 : uniform_space (canonically_linear_ordered_monoid linarith.comp)) : complete_space (canonically_linear_ordered_monoid linarith.comp) := sorry --non-trivial
lemma new_lemma_135311 (h0 : not (add_group (linear_ordered_comm_group_with_zero linarith.comp_source) -> false)) : @is_add_cyclic.{0} (linear_ordered_comm_group_with_zero.{0} linarith.comp_source) (@classical.by_contradiction'.{1} (add_group.{0} (linear_ordered_comm_group_with_zero.{0} linarith.comp_source)) h0)  := sorry --non-trivial
lemma new_lemma_135312 (h0 : functor.add_const (uniform_space (normed_comm_ring unsigned)) pos) : @complete_space.{0} (normed_comm_ring.{0} unsigned) (@functor.add_const.run.{0 0} (uniform_space.{0} (normed_comm_ring.{0} unsigned)) pos h0)  := sorry --non-trivial
lemma new_lemma_135313 (h0 : fin has_zero.zero) : @regular_space.{1} (canonically_ordered_monoid.{1} Type) (@matrix.vec_empty.{1} (topological_space.{1} (canonically_ordered_monoid.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_135314 (h0 : functor.add_const (functor.add_const Prop Type) pos) : functor.add_const.run (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_135315 (h0 : topological_space (has_norm (has_norm (semiring (metric_space linarith.comp))))) : path_connected_space (has_norm (has_norm (semiring (metric_space linarith.comp)))) := sorry --non-trivial
lemma new_lemma_135316 (h0 : function.extfun Type topological_space) : @totally_disconnected_space.{0} (complete_linear_order.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (complete_linear_order.{0} num))  := sorry --non-trivial
lemma new_lemma_135317 (h0 : topological_space (semi_normed_ring (uniform_space char))) : totally_disconnected_space (semi_normed_ring (uniform_space char)) := sorry --non-trivial
lemma new_lemma_135318 (h0 : fin has_zero.zero) : @rank_condition.{0} (finset.{0} real) (@function.extfun_app.{2 1} Type ring.{0} (@matrix.vec_empty.{1} (function.extfun.{2 1} Type ring.{0}) h0) (finset.{0} real))  := sorry --non-trivial
lemma new_lemma_135319 (h0 : list (monoid (option (option (option ennreal))))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_135320 (h0 : ring (nondiscrete_normed_field (normed_field reducibility_hints))) : is_domain (nondiscrete_normed_field (normed_field reducibility_hints)) := sorry --non-trivial
lemma new_lemma_135321 (h0 : functor.add_const (topological_space (complete_distrib_lattice pos)) Type) : @normal_space.{0} (complete_distrib_lattice.{0} pos) (@functor.add_const.run.{0 1} (topological_space.{0} (complete_distrib_lattice.{0} pos)) Type h0)  := sorry --non-trivial
lemma new_lemma_135322 (h0 : function.extfun nat fin) : @is_simple_group.{1} (normed_lattice_add_comm_group.{1} Type) (@matrix.vec_empty.{1} (group.{1} (normed_lattice_add_comm_group.{1} Type)) (@function.extfun_app.{1 1} nat fin (@matrix.vec_empty.{0} (function.extfun.{1 1} nat fin) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero))) (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_135323 (h0 : ordered_add_comm_monoid (pseudo_metric_space (option ennreal))) : archimedean (pseudo_metric_space (option ennreal)) := sorry --non-trivial
lemma new_lemma_135324 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @monoid.fg.{0} (with_bot.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 monoid.{0}) (with_bot.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_135325 (h0 : uniform_space (has_norm (has_nnnorm linarith.comp_source))) : complete_space (has_norm (has_nnnorm linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_135326 (h0 : functor.add_const (ring (mul_zero_class num)) (semiring (semiring num))) : @is_principal_ideal_ring.{0} (mul_zero_class.{0} num) (@functor.add_const.run.{0 0} (ring.{0} (mul_zero_class.{0} num)) (semiring.{0} (semiring.{0} num)) h0)  := sorry --non-trivial
lemma new_lemma_135327 (h2 : ring (has_compl linarith.ineq)) : strong_rank_condition (has_compl linarith.ineq) := sorry --non-trivial
lemma new_lemma_135328 (h0 : functor.add_const (topological_space (has_neg linarith.comp)) Type) : @discrete_topology.{0} (has_neg.{0} linarith.comp) (@functor.add_const.run.{0 1} (topological_space.{0} (has_neg.{0} linarith.comp)) Type h0)  := sorry --non-trivial
lemma new_lemma_135329 (h0 : has_mem.mem (with_bot num) has_emptyc.emptyc) : @strong_rank_condition.{0} (with_bot.{0} num) (@finset.pi.empty.{1 0} Type ring.{0} (with_bot.{0} num) h0)  := sorry --non-trivial
lemma new_lemma_135330 (h0 : not (topological_space (distrib reducibility_hints) -> false)) : @t0_space.{0} (distrib.{0} reducibility_hints) (@classical.by_contradiction'.{1} (topological_space.{0} (distrib.{0} reducibility_hints)) h0)  := sorry --non-trivial
lemma new_lemma_135331 (h0 : ring (with_bot (has_norm unsigned))) : rank_condition (with_bot (has_norm unsigned)) := sorry --non-trivial
lemma new_lemma_135332 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @monoid.fg.{0} (partial_order.{0} (semiring.{0} (semiring.{0} (semiring.{0} (semiring.{0} (semiring.{0} empty)))))) (@function.extfun_app.{2 1} Type monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 monoid.{0}) (partial_order.{0} (semiring.{0} (semiring.{0} (semiring.{0} (semiring.{0} (semiring.{0} empty)))))))  := sorry --non-trivial
lemma new_lemma_135333 (h0 : topological_space (linear_ordered_field unsigned)) : path_connected_space (linear_ordered_field unsigned) := sorry --non-trivial
lemma new_lemma_135334 (h4 : function.extfun Type uniform_space) : @complete_space.{0} (has_emptyc.{0} fun_info) (@function.extfun_app.{2 1} Type uniform_space.{0} h4 (has_emptyc.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_135335 (h0 : group (has_norm to_additive.value_type)) : normalizer_condition (has_norm to_additive.value_type) := sorry --non-trivial
lemma new_lemma_135336 (h0 : has_mem.mem group has_emptyc.emptyc) : @is_cyclic.{0} (@id.{2} Type linarith.comp) (@function.extfun_app.{2 1} Type group.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) group.{0} h0) (@id.{2} Type linarith.comp))  := sorry --non-trivial
lemma new_lemma_135337 (h0 : functor.add_const (ring pos) unsigned) : @is_principal_ideal_ring.{0} pos (@functor.add_const.run.{0 0} (ring.{0} pos) unsigned h0)  := sorry --non-trivial
lemma new_lemma_135338 (h0 : topological_space (option (option (option pos)))) : locally_compact_space (option (option (option pos))) := sorry --non-trivial
lemma new_lemma_135339 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @loc_path_connected_space.{1} (has_pos_part.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 topological_space.{1}) (has_pos_part.{1} Type))  := sorry --non-trivial
lemma new_lemma_135340 (h0 : function.extfun Type topological_space) : @irreducible_space.{0} (ordered_comm_ring.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (ordered_comm_ring.{0} pos))  := sorry --non-trivial
lemma new_lemma_135341 (h0 : monoid (boolean_algebra (ring (has_zero (has_add Type))))) : monoid.fg (boolean_algebra (ring (has_zero (has_add Type)))) := sorry --non-trivial
lemma new_lemma_135342 (h0 : functor.add_const (topological_space (has_neg_part name)) unsigned) : @irreducible_space.{0} (has_neg_part.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (has_neg_part.{0} name)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_135343 (h0 : fin has_zero.zero) : @add_monoid.fg.{0} (sub_neg_monoid.{0} name) (@matrix.vec_empty.{0} (add_monoid.{0} (sub_neg_monoid.{0} name)) h0)  := sorry --non-trivial
lemma new_lemma_135344 (h0 : functor.comp ring boolean_algebra unsigned) : @rank_condition.{0} (boolean_algebra.{0} unsigned) (@functor.comp.run.{0 0 0} ring.{0} boolean_algebra.{0} unsigned h0)  := sorry --non-trivial
lemma new_lemma_135345 (h0 : topological_space (add_comm_semigroup ereal)) : totally_disconnected_space (add_comm_semigroup ereal) := sorry --non-trivial
lemma new_lemma_135346 (h1 : uniform_space (semiring (random_gen to_additive.value_type))) : complete_space (semiring (random_gen to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_135347 (h0 : functor.add_const (topological_space (has_zero linarith.comp)) (finset (finset pos))) : @path_connected_space.{0} (has_zero.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (has_zero.{0} linarith.comp)) (finset.{0} (finset.{0} pos)) h0)  := sorry --non-trivial
lemma new_lemma_135348 (h0 : ring (has_inv string_imp)) : strong_rank_condition (has_inv string_imp) := sorry --non-trivial
lemma new_lemma_135349 (h0 : topological_space (canonically_ordered_comm_semiring (ring Type))) : discrete_topology (canonically_ordered_comm_semiring (ring Type)) := sorry --non-trivial
lemma new_lemma_135350 (h0 : functor.add_const (group (generalized_boolean_algebra pos)) (has_neg linarith.comp)) : @is_simple_group.{0} (generalized_boolean_algebra.{0} pos) (@functor.add_const.run.{0 0} (group.{0} (generalized_boolean_algebra.{0} pos)) (has_neg.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_135351 (h0 : not (ring (random_gen reducibility_hints) -> false)) : @strong_rank_condition.{0} (random_gen.{0} reducibility_hints) (@classical.by_contradiction'.{1} (ring.{0} (random_gen.{0} reducibility_hints)) h0)  := sorry --non-trivial
lemma new_lemma_135352 (h0 : functor.add_const (ring (finset environment.implicit_infer_kind)) Type) : @is_domain.{0} (finset.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 1} (ring.{0} (finset.{0} environment.implicit_infer_kind)) Type h0)  := sorry --non-trivial
lemma new_lemma_135353 (h0 : not (topological_space (id unsigned) -> false)) : @discrete_topology.{0} (@id.{2} Type unsigned) (@classical.by_contradiction'.{1} (topological_space.{0} (@id.{2} Type unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_135354 (h0 : uniform_space (add_comm_monoid (option (option ennreal)))) : complete_space (add_comm_monoid (option (option ennreal))) := sorry --non-trivial
lemma new_lemma_135355 (h0 : set (linear_ordered_comm_group_with_zero (mul_one_class string.iterator_imp))) : set.subsingleton h0 := sorry --non-trivial
lemma new_lemma_135356 (h0 : function.extfun Type topological_space) : @totally_separated_space.{0} auto.case_option (@function.extfun_app.{2 1} Type topological_space.{0} h0 auto.case_option)  := sorry --non-trivial
lemma new_lemma_135357 (h0 : topological_space (random_gen (linear_ordered_semiring empty))) : totally_separated_space (random_gen (linear_ordered_semiring empty)) := sorry --non-trivial
lemma new_lemma_135358 (h0 : preorder (add_comm_semigroup fun_info)) (h1 : topological_space (add_comm_semigroup fun_info)) : Sup_convergence_class (add_comm_semigroup fun_info) := sorry --non-trivial
lemma new_lemma_135359 (h0 : topological_space (add_semigroup (semiring unsigned))) : totally_disconnected_space (add_semigroup (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_135360 (h0 : topological_space (linear_ordered_comm_group (option (option empty)))) : preconnected_space (linear_ordered_comm_group (option (option empty))) := sorry --non-trivial
lemma new_lemma_135361 (h0 : functor.comp topological_space has_add Type) : @totally_separated_space.{1} (has_add.{1} Type) (@functor.comp.run.{1 1 1} topological_space.{1} has_add.{1} Type h0)  := sorry --non-trivial
lemma new_lemma_135362 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @separated_space.{0} (measurable_space.{0} num) (@function.extfun_app.{2 1} Type uniform_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 uniform_space.{0}) (measurable_space.{0} num))  := sorry --non-trivial
lemma new_lemma_135363 (h0 : finset (complete_distrib_lattice (ordered_ring pos))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_135364 (h0 : functor.add_const (topological_space (cancel_monoid name)) name) : @preconnected_space.{0} (cancel_monoid.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (cancel_monoid.{0} name)) name h0)  := sorry --non-trivial
lemma new_lemma_135365 (h0 : set (has_nnnorm fun_info)) : set.subsingleton h0 := sorry --non-trivial
lemma new_lemma_135366 (h0 : not (function.extfun Type topological_space -> false)) : @t0_space.{0} (has_norm.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (has_norm.{0} num))  := sorry --non-trivial
lemma new_lemma_135367 (h0 : topological_space (canonically_ordered_monoid (has_add (has_Inf (has_Inf (has_Inf (has_add pos))))))) : irreducible_space (canonically_ordered_monoid (has_add (has_Inf (has_Inf (has_Inf (has_add pos)))))) := sorry --non-trivial
lemma new_lemma_135368 (h0 : complete_lattice (mul_one_class (add_comm_semigroup fun_info))) : complete_lattice.is_Sup_finite_compact (mul_one_class (add_comm_semigroup fun_info)) := sorry --non-trivial
lemma new_lemma_135369 (h0 : topological_space (ring (has_nndist name))) : preconnected_space (ring (has_nndist name)) := sorry --non-trivial
lemma new_lemma_135370 (h0 : not (topological_space (bin_tree unsigned) -> false)) : @locally_compact_space.{0} (bin_tree.{0} unsigned) (@classical.by_contradiction'.{1} (topological_space.{0} (bin_tree.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_135371 (h0 : topological_space (has_dist (option (option ennreal)))) : t0_space (has_dist (option (option ennreal))) := sorry --non-trivial
lemma new_lemma_135372 (h0 : topological_space (add_comm_monoid ennreal)) : regular_space (add_comm_monoid ennreal) := sorry --non-trivial
lemma new_lemma_135373 (h0 : functor.add_const (topological_space (mul_zero_class ennreal)) name) : @preconnected_space.{0} (mul_zero_class.{0} ennreal) (@functor.add_const.run.{0 0} (topological_space.{0} (mul_zero_class.{0} ennreal)) name h0)  := sorry --non-trivial
lemma new_lemma_135374 (h1 : not (complete_lattice (has_ssubset linarith.comp_source) -> false)) : @is_compactly_generated.{0} (has_ssubset.{0} linarith.comp_source) (@classical.by_contradiction'.{1} (complete_lattice.{0} (has_ssubset.{0} linarith.comp_source)) h1)  := sorry --non-trivial
lemma new_lemma_135375 (h0 : semiring (has_neg (finset pos))) : is_noetherian_ring (has_neg (finset pos)) := sorry --non-trivial
lemma new_lemma_135376 (h0 : semiring (with_bot congr_arg_kind)) : is_noetherian_ring (with_bot congr_arg_kind) := sorry --non-trivial
lemma new_lemma_135377 (h0 : topological_space (cancel_monoid (has_to_string environment.implicit_infer_kind))) : regular_space (cancel_monoid (has_to_string environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_135378 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_domain.{0} (linear_ordered_field.{0} pos) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (linear_ordered_field.{0} pos))  := sorry --non-trivial
lemma new_lemma_135379 (h0 : not (add_monoid (has_one num) -> false)) : @add_monoid.fg.{0} (has_one.{0} num) (@classical.by_contradiction'.{1} (add_monoid.{0} (has_one.{0} num)) h0)  := sorry --non-trivial
lemma new_lemma_135380 (h0 h1 : multiset (add_comm_semigroup enat)) : multiset.le h0 h1 := sorry --non-trivial
lemma new_lemma_135381 (h1 : uniform_space (div_inv_monoid string_imp)) : complete_space (div_inv_monoid string_imp) := sorry --non-trivial
lemma new_lemma_135382 (h0 : topological_space (has_neg (option (option ennreal)))) : loc_path_connected_space (has_neg (option (option ennreal))) := sorry --non-trivial
lemma new_lemma_135383 (h0 : finset (has_Inf (ring name))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_135384 (h0 : group (has_nndist (ring pos))) : is_simple_group (has_nndist (ring pos)) := sorry --non-trivial
lemma new_lemma_135385 (h0 : function.extfun Type group) : @group.fg.{0} (with_one.{0} fun_info) (@function.extfun_app.{2 1} Type group.{0} h0 (with_one.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_135386 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @totally_disconnected_space.{0} (preorder.{0} (option.{0} (option.{0} empty))) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (preorder.{0} (option.{0} (option.{0} empty))))  := sorry --non-trivial
lemma new_lemma_135387 (h0 : topological_space (has_top (semiring (with_bot congr_arg_kind)))) : preirreducible_space (has_top (semiring (with_bot congr_arg_kind))) := sorry --non-trivial
lemma new_lemma_135388 (h0 : complete_lattice (has_top (has_inv to_additive.value_type))) : is_compactly_generated (has_top (has_inv to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_135389 (h0 : function.extfun Type monoid) : @monoid.fg.{0} (boolean_algebra.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type monoid.{0} h0 (boolean_algebra.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_135390 (h0 : topological_space (has_nnnorm (mul_one_class (mul_one_class fun_info)))) : path_connected_space (has_nnnorm (mul_one_class (mul_one_class fun_info))) := sorry --non-trivial
lemma new_lemma_135391 (h0 : functor.add_const (monoid (has_zero pos)) (has_add Type)) : @monoid.fg.{0} (has_zero.{0} pos) (@functor.add_const.run.{0 1} (monoid.{0} (has_zero.{0} pos)) (has_add.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_135392 (h0 : ordered_comm_monoid (ring (ring linarith.comp))) : has_exists_mul_of_le (ring (ring linarith.comp)) := sorry --non-trivial
lemma new_lemma_135393 (h0 : group (add_comm_monoid (comm_group (comm_group unsigned)))) : group.fg (add_comm_monoid (comm_group (comm_group unsigned))) := sorry --non-trivial
lemma new_lemma_135394 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @discrete_topology.{0} (pseudo_metric_space.{0} ennreal) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (pseudo_metric_space.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_135395 (h0 : topological_space (cancel_monoid (has_sub congr_arg_kind))) : t0_space (cancel_monoid (has_sub congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_135396 (h0 : function.extfun Type (functor.add_const (monoid pos))) : @monoid.fg.{0} pos (@functor.add_const.run.{0 0} (monoid.{0} pos) (has_add.{0} (has_add.{0} (ring.{0} (has_add.{0} environment.implicit_infer_kind)))) (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (monoid.{0} pos)) h0 (has_add.{0} (has_add.{0} (ring.{0} (has_add.{0} environment.implicit_infer_kind))))))  := sorry --non-trivial
lemma new_lemma_135397 (h0 : cancel_comm_monoid_with_zero (cancel_monoid pos)) : unique_factorization_monoid (cancel_monoid pos) := sorry --non-trivial
lemma new_lemma_135398 (h0 : function.extfun Type topological_space) : @path_connected_space.{0} (normed_group.{0} (has_top.{0} (has_top.{0} (has_top.{0} (has_top.{0} fun_info))))) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (normed_group.{0} (has_top.{0} (has_top.{0} (has_top.{0} (has_top.{0} fun_info))))))  := sorry --non-trivial
lemma new_lemma_135399 (h0 : function.extfun Type complete_lattice) : @complete_lattice.is_Sup_finite_compact.{0} (dlist.{0} fun_info) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (dlist.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_135400 (h0 : functor.comp topological_space has_add Type) : @sequential_space.{1} (has_add.{1} Type) (@functor.comp.run.{1 1 1} topological_space.{1} has_add.{1} Type h0)  := sorry --non-trivial
lemma new_lemma_135401 (h0 : topological_space (partial_order num)) : t0_space (partial_order num) := sorry --non-trivial
lemma new_lemma_135402 (h0 : topological_space (has_neg (option (option pos)))) : topological_space.separable_space (has_neg (option (option pos))) := sorry --non-trivial
lemma new_lemma_135403 (h0 : ring (linear_order congr_arg_kind)) : is_domain (linear_order congr_arg_kind) := sorry --non-trivial
lemma new_lemma_135404 (h0 : function.extfun Type complete_lattice) : @is_atomistic.{0} (boolean_algebra.{0} pos) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (boolean_algebra.{0} pos))  := sorry --non-trivial
lemma new_lemma_135405 (h0 : list (has_nndist (cancel_monoid (finset ennreal)))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_135406 (h0 : ring (topological_space (comm_ring fun_info))) : is_domain (topological_space (comm_ring fun_info)) := sorry --non-trivial
lemma new_lemma_135407 (h0 : complete_lattice (encodable linarith.comp_source)) : complete_lattice.is_Sup_finite_compact (encodable linarith.comp_source) := sorry --non-trivial
lemma new_lemma_135408 (h0 : not (function.extfun Type topological_space -> false)) : @discrete_topology.{0} (normed_group.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (normed_group.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_135409 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @unique_factorization_monoid.{0} (option.{0} pos) (@function.extfun_app.{2 1} Type cancel_comm_monoid_with_zero.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 cancel_comm_monoid_with_zero.{0}) (option.{0} pos))  := sorry --non-trivial
lemma new_lemma_135410 (h0 : functor.add_const (topological_space (has_Inf linarith.comp)) Type) : @normal_space.{0} (has_Inf.{0} linarith.comp) (@functor.add_const.run.{0 1} (topological_space.{0} (has_Inf.{0} linarith.comp)) Type h0)  := sorry --non-trivial
lemma new_lemma_135411 (h1 : linarith.comp_source -> Prop) : @infi.{0 1} Prop (@conditionally_complete_lattice.to_has_Inf.{0} Prop (@complete_lattice.to_conditionally_complete_lattice.{0} Prop Prop.complete_lattice)) linarith.comp_source h1  := sorry --non-trivial
lemma new_lemma_135412 (h0 : not (complete_lattice (has_norm empty) -> false)) : @complete_lattice.is_Sup_finite_compact.{0} (has_norm.{0} empty) (@classical.by_contradiction'.{1} (complete_lattice.{0} (has_norm.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_135413 (h0 : list (normed_linear_ordered_group empty)) : palindrome h0 := sorry --non-trivial
lemma new_lemma_135414 (h0 : add_group (with_bot fun_info) -> Prop) (h1 : Exists (fun (x : add_group (with_bot fun_info)), h0 x)) : @is_add_cyclic.{0} (with_bot.{0} fun_info) (@classical.some.{1} (add_group.{0} (with_bot.{0} fun_info)) h0 h1)  := sorry --non-trivial
lemma new_lemma_135415 (h0 : function.extfun Type uniform_space) : @separated_space.{0} (linear_ordered_field.{0} empty) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (linear_ordered_field.{0} empty))  := sorry --non-trivial
lemma new_lemma_135416 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @totally_disconnected_space.{0} (metric_space.{0} (has_norm.{0} unsigned)) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (metric_space.{0} (has_norm.{0} unsigned)))  := sorry --non-trivial
lemma new_lemma_135417 (h0 : filter (denumerable fun_info)) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_135418 (h0 : functor.add_const (ring pos) (option unsigned)) : @is_domain.{0} pos (@functor.add_const.run.{0 0} (ring.{0} pos) (option.{0} unsigned) h0)  := sorry --non-trivial
lemma new_lemma_135419 (h0 : monoid (has_Inf pos)) : monoid.fg (has_Inf pos) := sorry --non-trivial
lemma new_lemma_135420 (h0 : not (complete_lattice (has_compl to_additive.value_type) -> false)) : @is_compactly_generated.{0} (has_compl.{0} to_additive.value_type) (@classical.by_contradiction'.{1} (complete_lattice.{0} (has_compl.{0} to_additive.value_type)) h0)  := sorry --non-trivial
lemma new_lemma_135421 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @locally_compact_space.{0} (as_linear_order.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (as_linear_order.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_135422 (h0 : topological_space num) : t0_space num := sorry --non-trivial
lemma new_lemma_135423 (h0 : uniform_space (has_compl (mul_one_class (mul_one_class linarith.ineq)))) : complete_space (has_compl (mul_one_class (mul_one_class linarith.ineq))) := sorry --non-trivial
lemma new_lemma_135424 (h0 : topological_space (has_div (mul_one_class to_additive.value_type))) : t0_space (has_div (mul_one_class to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_135425 (h0 : topological_space (linear_ordered_semiring num)) : path_connected_space (linear_ordered_semiring num) := sorry --non-trivial
lemma new_lemma_135426 (h2 : has_mem.mem congr_arg_kind has_emptyc.emptyc) : @irreducible_space.{0} congr_arg_kind (@finset.pi.empty.{1 0} Type topological_space.{0} congr_arg_kind h2)  := sorry --non-trivial
lemma new_lemma_135427 (h0 : functor.add_const (topological_space (generalized_boolean_algebra pos)) (has_bot (has_bot (has_Inf Type)))) : @sequential_space.{0} (generalized_boolean_algebra.{0} pos) (@functor.add_const.run.{0 1} (topological_space.{0} (generalized_boolean_algebra.{0} pos)) (has_bot.{1} (has_bot.{1} (has_Inf.{1} Type))) h0)  := sorry --non-trivial
lemma new_lemma_135428 (h0 : functor.add_const (ring (semigroup linarith.comp)) (has_pos_part (finset pos))) : @strong_rank_condition.{0} (semigroup.{0} linarith.comp) (@functor.add_const.run.{0 0} (ring.{0} (semigroup.{0} linarith.comp)) (has_pos_part.{0} (finset.{0} pos)) h0)  := sorry --non-trivial
lemma new_lemma_135429 (h0 : group (with_bot (has_inv fun_info))) : group.fg (with_bot (has_inv fun_info)) := sorry --non-trivial
lemma new_lemma_135430 (h0 : ring (uniform_space (mul_one_class fun_info))) : strong_rank_condition (uniform_space (mul_one_class fun_info)) := sorry --non-trivial
lemma new_lemma_135431 (h0 : function.extfun Type filter) : countable_Inter_filter (function.extfun_app h0 (monoid_with_zero congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_135432 (h1 : measurable_space (semiring num)) (h2 : not (has_mul (semiring num) -> false)) : @has_measurable_mul.{0} (semiring.{0} num) h1 (@classical.by_contradiction'.{1} (has_mul.{0} (semiring.{0} num)) h2)  := sorry --non-trivial
lemma new_lemma_135433 (h0 : functor.add_const (topological_space (semigroup linarith.comp)) Type) : @t0_space.{0} (semigroup.{0} linarith.comp) (@functor.add_const.run.{0 1} (topological_space.{0} (semigroup.{0} linarith.comp)) Type h0)  := sorry --non-trivial
lemma new_lemma_135434 (h0 : finset (has_neg (ring (has_zero (finset Type))))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_135435 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @topological_space.separable_space.{0} (boolean_algebra.core.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (boolean_algebra.core.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_135436 (h0 : complete_lattice (uniform_space (has_lt string.iterator_imp))) : complete_lattice.is_Sup_finite_compact (uniform_space (has_lt string.iterator_imp)) := sorry --non-trivial
lemma new_lemma_135437 (h0 : uniform_space (add_left_cancel_monoid (has_nnnorm linarith.ineq))) : complete_space (add_left_cancel_monoid (has_nnnorm linarith.ineq)) := sorry --non-trivial
lemma new_lemma_135438 (h0 : function.extfun Type (functor.add_const (complete_lattice (filter unsigned)))) : is_compactly_generated (filter unsigned) := sorry --non-trivial
lemma new_lemma_135439 (h0 : not (uniform_space linarith.comp -> false)) : @separated_space.{0} linarith.comp (@classical.by_contradiction'.{1} (uniform_space.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_135440 (h0 : set (string.iterator_imp -> add_comm_semigroup char)) : set.separates_points h0 := sorry --non-trivial
lemma new_lemma_135441 (h0 : functor.add_const (topological_space (has_to_string environment.implicit_infer_kind)) name) : @t1_space.{0} (has_to_string.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (has_to_string.{0} environment.implicit_infer_kind)) name h0)  := sorry --non-trivial
lemma new_lemma_135442 (h0 : function.extfun Type topological_space) : @t1_space.{0} (normed_lattice_add_comm_group.{0} real) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (normed_lattice_add_comm_group.{0} real))  := sorry --non-trivial
lemma new_lemma_135443 (h0 : set (add_comm_semigroup fun_info -> linarith.ineq)) : set.separates_points h0 := sorry --non-trivial
lemma new_lemma_135444 (h0 : function.extfun Type topological_space) : @sequential_space.{0} (has_neg.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_neg.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_135445 (h0 : functor.add_const (ring (ordered_comm_ring linarith.comp)) Type) : @is_domain.{0} (ordered_comm_ring.{0} linarith.comp) (@functor.add_const.run.{0 1} (ring.{0} (ordered_comm_ring.{0} linarith.comp)) Type h0)  := sorry --non-trivial
lemma new_lemma_135446 (h0 : functor.comp topological_space has_neg_part name) : @topological_space.separable_space.{0} (has_neg_part.{0} name) (@functor.comp.run.{0 0 0} topological_space.{0} has_neg_part.{0} name h0)  := sorry --non-trivial
lemma new_lemma_135447 (h0 : ordered_add_comm_monoid (complete_distrib_lattice environment.implicit_infer_kind)) : archimedean (complete_distrib_lattice environment.implicit_infer_kind) := sorry --non-trivial
lemma new_lemma_135448 (h0 : function.extfun Type add_group) (h1 : Prop) : yyy_to (@is_add_cyclic.{0} (has_Inf.{0} name) (@function.extfun_app.{2 1} Type add_group.{0} h0 (has_Inf.{0} name))) h1  := sorry --non-trivial
lemma new_lemma_135449 (h0 : topological_space (metric_space (has_norm empty))) : locally_compact_space (metric_space (has_norm empty)) := sorry --non-trivial
lemma new_lemma_135450 (h0 : topological_space (semigroup (has_to_string pos))) : t1_space (semigroup (has_to_string pos)) := sorry --non-trivial
lemma new_lemma_135451 (h0 : topological_space (has_sub num)) : totally_disconnected_space (has_sub num) := sorry --non-trivial
lemma new_lemma_135452 (h0 : function.extfun Type (functor.add_const (ring pos))) : @rank_condition.{0} pos (@functor.add_const.run.{0 0} (ring.{0} pos) pos (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (ring.{0} pos)) h0 pos))  := sorry --non-trivial
lemma new_lemma_135453 (h0 : topological_space (has_add (has_neg pos))) : t0_space (has_add (has_neg pos)) := sorry --non-trivial
lemma new_lemma_135454 (h0 : function.extfun (finset Type) (has_mem.mem (measurable_space linarith.comp_source))) : @path_connected_space.{0} (measurable_space.{0} linarith.comp_source) (@finset.pi.empty.{1 0} Type topological_space.{0} (measurable_space.{0} linarith.comp_source) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (measurable_space.{0} linarith.comp_source)) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_135455 (h0 : topological_space (has_pos_part (has_pos_part Type))) : path_connected_space (has_pos_part (has_pos_part Type)) := sorry --non-trivial
lemma new_lemma_135456 (h1 : complete_lattice (normed_field linarith.comp_source)) : complete_lattice.is_Sup_finite_compact (normed_field linarith.comp_source) := sorry --non-trivial
lemma new_lemma_135457 (h0 : topological_space (has_edist (semiring (semiring unsigned)))) : loc_path_connected_space (has_edist (semiring (semiring unsigned))) := sorry --non-trivial
lemma new_lemma_135458 (h0 h1 : multiset (has_nnnorm (mul_one_class (mul_one_class string.iterator_imp)))) : multiset.disjoint h0 h1 := sorry --non-trivial
lemma new_lemma_135459 (h0 : functor.add_const (topological_space (measure_theory.measure_space num)) congr_arg_kind) : @discrete_topology.{0} (measure_theory.measure_space.{0} num) (@functor.add_const.run.{0 0} (topological_space.{0} (measure_theory.measure_space.{0} num)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_135460 (h0 : monoid (has_pos_part (has_add pos))) : monoid.fg (has_pos_part (has_add pos)) := sorry --non-trivial
lemma new_lemma_135461 (h0 : ring (canonically_ordered_comm_semiring (option ennreal))) : is_domain (canonically_ordered_comm_semiring (option ennreal)) := sorry --non-trivial
lemma new_lemma_135462 (h0 : functor.add_const (topological_space (has_zero linarith.comp)) linarith.comp) : @locally_compact_space.{0} (has_zero.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (has_zero.{0} linarith.comp)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_135463 (h0 : complete_lattice (pseudo_metric_space (option num))) : is_compactly_generated (pseudo_metric_space (option num)) := sorry --non-trivial
lemma new_lemma_135464 (h0 : set (has_ssubset environment.projection_info)) : set.finite h0 := sorry --non-trivial
lemma new_lemma_135465 (h0 : function.extfun Type complete_lattice) : @is_atomistic.{0} (linear_ordered_field.{0} pos) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (linear_ordered_field.{0} pos))  := sorry --non-trivial
lemma new_lemma_135466 (h0 : finset (canonically_ordered_monoid (has_add (has_add name)))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_135467 (h0 : functor.add_const (topological_space (ring pos)) (boolean_algebra.core pos)) : @path_connected_space.{0} (ring.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (ring.{0} pos)) (boolean_algebra.core.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_135468 (h0 : functor.add_const (filter (boolean_algebra Type)) (has_neg linarith.comp)) : filter.ne_bot (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_135469 (h0 : monoid (finset (finset pos))) : monoid.fg (finset (finset pos)) := sorry --non-trivial
lemma new_lemma_135470 (h0 : group (has_emptyc (has_top to_additive.value_type))) : normalizer_condition (has_emptyc (has_top to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_135471 (h0 : topological_space (cancel_monoid (option pos))) : totally_disconnected_space (cancel_monoid (option pos)) := sorry --non-trivial
lemma new_lemma_135472 (h0 : topological_space (has_nndist (has_pos_part pos))) : sequential_space (has_nndist (has_pos_part pos)) := sorry --non-trivial
lemma new_lemma_135473 (h0 : cancel_comm_monoid_with_zero (add_cancel_monoid (option (option (option empty))))) : unique_factorization_monoid (add_cancel_monoid (option (option (option empty)))) := sorry --non-trivial
lemma new_lemma_135474 (h0 : function.extfun (nat -> Type) (function.extfun nat)) : @totally_separated_space.{0} (ordered_comm_monoid.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@matrix.vec_empty.{1} (function.extfun.{2 1} Type topological_space.{0}) (@function.extfun_app.{1 1} nat fin (@function.extfun_app.{2 1} (nat → Type) (function.extfun.{1 1} nat) h0 fin) (@has_zero.zero.{0} nat nat.has_zero))) (ordered_comm_monoid.{0} pos))  := sorry --non-trivial
lemma new_lemma_135475 (h0 : topological_space (option (semiring empty))) : path_connected_space (option (semiring empty)) := sorry --non-trivial
lemma new_lemma_135476 (h0 : topological_space (normed_group (has_norm (has_ssubset linarith.ineq)))) : t0_space (normed_group (has_norm (has_ssubset linarith.ineq))) := sorry --non-trivial
lemma new_lemma_135477 (h1 : ring (with_one string_imp)) : strong_rank_condition (with_one string_imp) := sorry --non-trivial
lemma new_lemma_135478 (h0 : finset (bin_tree (semiring (semiring (semiring num))))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_135479 (h0 : ordered_comm_monoid (comm_group (cancel_monoid ennreal))) : has_exists_mul_of_le (comm_group (cancel_monoid ennreal)) := sorry --non-trivial
lemma new_lemma_135480 (h0 : function.extfun Type ring) : @is_principal_ideal_ring.{0} (option.{0} unsigned) (@function.extfun_app.{2 1} Type ring.{0} h0 (option.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_135481 (h0 : function.extfun Type group) : @normalizer_condition.{0} (linear_ordered_add_comm_monoid_with_top.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type group.{0} h0 (linear_ordered_add_comm_monoid_with_top.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_135482 (h0 : topological_space (add_cancel_monoid environment.implicit_infer_kind)) : t1_space (add_cancel_monoid environment.implicit_infer_kind) := sorry --non-trivial
lemma new_lemma_135483 (h0 : list (sub_neg_monoid real)) : palindrome h0 := sorry --non-trivial
lemma new_lemma_135484 (h0 : function.extfun (finset (Type -> Type)) (has_mem.mem add_group)) : @is_add_cyclic.{0} congr_arg_kind (@function.extfun_app.{2 1} Type add_group.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) add_group.{0} (@function.extfun_app.{2 0} (finset.{1} (Type → Type)) (@has_mem.mem.{1 1} (Type → Type) (finset.{1} (Type → Type)) (@finset.has_mem.{1} (Type → Type)) add_group.{0}) h0 (@has_emptyc.emptyc.{1} (finset.{1} (Type → Type)) (@finset.has_emptyc.{1} (Type → Type))))) congr_arg_kind)  := sorry --non-trivial
lemma new_lemma_135485 (h0 : complete_lattice (has_add (has_Inf real))) : is_atomistic (has_add (has_Inf real)) := sorry --non-trivial
lemma new_lemma_135486 (h0 : complete_lattice (has_inv (has_top linarith.comp_source))) : complete_lattice.is_Sup_finite_compact (has_inv (has_top linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_135487 (h0 : monoid (add_right_cancel_monoid (semiring num))) : monoid.fg (add_right_cancel_monoid (semiring num)) := sorry --non-trivial
lemma new_lemma_135488 (h0 : function.extfun Type ring) : @rank_condition.{0} (with_one.{0} string_imp) (@function.extfun_app.{2 1} Type ring.{0} h0 (with_one.{0} string_imp))  := sorry --non-trivial
lemma new_lemma_135489 (h0 : finset (has_bot (has_Inf name))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_135490 (h0 : function.extfun Type topological_space) : @loc_path_connected_space.{0} (measure_theory.measure_space.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (measure_theory.measure_space.{0} num))  := sorry --non-trivial
lemma new_lemma_135491 (h0 : functor.add_const (uniform_space (mul_zero_class name)) name) : @complete_space.{0} (mul_zero_class.{0} name) (@functor.add_const.run.{0 0} (uniform_space.{0} (mul_zero_class.{0} name)) name h0)  := sorry --non-trivial
lemma new_lemma_135492 (h1 : group (normed_field (has_nnnorm string_imp))) : is_cyclic (normed_field (has_nnnorm string_imp)) := sorry --non-trivial
lemma new_lemma_135493 (h0 : topological_space (add_comm_monoid (has_Inf (has_Inf (has_neg name))))) : preirreducible_space (add_comm_monoid (has_Inf (has_Inf (has_neg name)))) := sorry --non-trivial
lemma new_lemma_135494 (h0 : uniform_space (id (has_norm num))) : complete_space (id (has_norm num)) := sorry --non-trivial
lemma new_lemma_135495 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @totally_separated_space.{0} (semigroup.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (semigroup.{0} name))  := sorry --non-trivial
lemma new_lemma_135496 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @irreducible_space.{0} (normed_group.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (normed_group.{0} num))  := sorry --non-trivial
lemma new_lemma_135497 (h0 : group (semigroup (has_add (has_add (has_add pos))))) : is_cyclic (semigroup (has_add (has_add (has_add pos)))) := sorry --non-trivial
lemma new_lemma_135498 (h0 : group (has_nndist (ring environment.implicit_infer_kind))) : normalizer_condition (has_nndist (ring environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_135499 (h0 : functor.add_const (ring (has_neg environment.implicit_infer_kind)) name) : @is_principal_ideal_ring.{0} (has_neg.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (ring.{0} (has_neg.{0} environment.implicit_infer_kind)) name h0)  := sorry --non-trivial
lemma new_lemma_135500 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @locally_compact_space.{0} (has_to_string.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_to_string.{0} num))  := sorry --non-trivial
lemma new_lemma_135501 (h0 : functor.add_const (function.extfun Type topological_space) name) : @sequential_space.{0} (finset.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) name h0) (finset.{0} pos))  := sorry --non-trivial
lemma new_lemma_135502 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @totally_disconnected_space.{1} (add_cancel_monoid.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 topological_space.{1}) (add_cancel_monoid.{1} Type))  := sorry --non-trivial
lemma new_lemma_135503 (h0 : not (topological_space (has_nnnorm reducibility_hints) -> false)) : @path_connected_space.{0} (has_nnnorm.{0} reducibility_hints) (@classical.by_contradiction'.{1} (topological_space.{0} (has_nnnorm.{0} reducibility_hints)) h0)  := sorry --non-trivial
lemma new_lemma_135504 (h0 : functor.add_const (topological_space (has_Sup unsigned)) unsigned) : @totally_disconnected_space.{0} (has_Sup.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (has_Sup.{0} unsigned)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_135505 (h0 : function.extfun (finset Type) (has_mem.mem (complete_semilattice_Sup congr_arg_kind))) : @is_atomistic.{0} (complete_semilattice_Sup.{0} congr_arg_kind) (@finset.pi.empty.{1 0} Type complete_lattice.{0} (complete_semilattice_Sup.{0} congr_arg_kind) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (complete_semilattice_Sup.{0} congr_arg_kind)) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_135506 (h0 : list (has_neg_part (has_add name))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_135507 (h0 : topological_space (add_comm_monoid (semigroup name))) : normal_space (add_comm_monoid (semigroup name)) := sorry --non-trivial
lemma new_lemma_135508 (h0 : uniform_space (boolean_algebra.core unsigned)) : separated_space (boolean_algebra.core unsigned) := sorry --non-trivial
lemma new_lemma_135509 (h0 : topological_space (has_nndist (finset (finset (finset (finset name)))))) : t1_space (has_nndist (finset (finset (finset (finset name))))) := sorry --non-trivial
lemma new_lemma_135510 (h1 : ring (distrib (comm_ring reducibility_hints))) : strong_rank_condition (distrib (comm_ring reducibility_hints)) := sorry --non-trivial
lemma new_lemma_135511 (h0 : add_monoid (normed_group (semiring unsigned))) : add_monoid.fg (normed_group (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_135512 (h0 : function.extfun Type topological_space) : @locally_compact_space.{0} (measurable_space.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (measurable_space.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_135513 (h1 : uniform_space (random_gen (denumerable char))) : complete_space (random_gen (denumerable char)) := sorry --non-trivial
lemma new_lemma_135514 (h0 : function.extfun Type (functor.add_const (group (add_cancel_comm_monoid empty)))) : @normalizer_condition.{0} (add_cancel_comm_monoid.{0} empty) (@functor.add_const.run.{0 0} (group.{0} (add_cancel_comm_monoid.{0} empty)) empty (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (group.{0} (add_cancel_comm_monoid.{0} empty))) h0 empty))  := sorry --non-trivial
lemma new_lemma_135515 (h0 : fin has_zero.zero) : @is_cyclic.{1} (canonically_ordered_comm_semiring.{1} Type) (@matrix.vec_empty.{1} (group.{1} (canonically_ordered_comm_semiring.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_135516 (h0 : functor.add_const (function.extfun Type topological_space) pos) : @normal_space.{0} (normed_comm_ring.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) pos h0) (normed_comm_ring.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_135517 (h0 : group (semi_normed_comm_ring (has_nnnorm (has_nnnorm to_additive.value_type)))) : group.fg (semi_normed_comm_ring (has_nnnorm (has_nnnorm to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_135518 (h0 : functor.add_const (cancel_comm_monoid_with_zero (omega_complete_partial_order empty)) empty) : @unique_factorization_monoid.{0} (omega_complete_partial_order.{0} empty) (@functor.add_const.run.{0 0} (cancel_comm_monoid_with_zero.{0} (omega_complete_partial_order.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_135519 (h0 : ring (semi_normed_ring (mul_one_class enat))) : rank_condition (semi_normed_ring (mul_one_class enat)) := sorry --non-trivial
lemma new_lemma_135520 (h0 : functor.add_const (function.extfun Type ring) pos) : @rank_condition.{0} (finset.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type ring.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type ring.{0}) pos h0) (finset.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_135521 (h0 : topological_space (semi_normed_comm_ring (random_gen (random_gen to_additive.value_type)))) : totally_disconnected_space (semi_normed_comm_ring (random_gen (random_gen to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_135522 (h0 : group (has_to_string (has_to_string pos))) : is_simple_group (has_to_string (has_to_string pos)) := sorry --non-trivial
lemma new_lemma_135523 (h0 : ring (comm_monoid num)) : strong_rank_condition (comm_monoid num) := sorry --non-trivial
lemma new_lemma_135524 (h0 : functor.add_const (ring (has_neg Type)) environment.implicit_infer_kind) : @is_domain.{1} (has_neg.{1} Type) (@functor.add_const.run.{1 0} (ring.{1} (has_neg.{1} Type)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_135525 (h0 : group (cancel_monoid (comm_group name))) : is_simple_group (cancel_monoid (comm_group name)) := sorry --non-trivial
lemma new_lemma_135526 (h0 : function.extfun Type group) : @group.fg.{0} (linear_ordered_add_comm_group.{0} char) (@function.extfun_app.{2 1} Type group.{0} h0 (linear_ordered_add_comm_group.{0} char))  := sorry --non-trivial
lemma new_lemma_135527 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_noetherian_ring.{0} (bin_tree.{0} num) (@function.extfun_app.{2 1} Type semiring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 semiring.{0}) (bin_tree.{0} num))  := sorry --non-trivial
lemma new_lemma_135528 (h0 : group (distrib (topological_space linarith.ineq))) : is_cyclic (distrib (topological_space linarith.ineq)) := sorry --non-trivial
lemma new_lemma_135529 (h0 : complete_lattice (has_div (mul_one_class char))) : complete_lattice.is_Sup_finite_compact (has_div (mul_one_class char)) := sorry --non-trivial
lemma new_lemma_135530 (h0 : fin has_zero.zero) : @normalizer_condition.{0} (complete_distrib_lattice.{0} name) (@matrix.vec_empty.{0} (group.{0} (complete_distrib_lattice.{0} name)) (@matrix.vec_empty.{0} (fin (@has_zero.zero.{0} nat nat.has_zero)) h0))  := sorry --non-trivial
lemma new_lemma_135531 (h0 : function.extfun Type ring) : @rank_condition.{0} (ring.{0} empty) (@function.extfun_app.{2 1} Type ring.{0} h0 (ring.{0} empty))  := sorry --non-trivial
lemma new_lemma_135532 (h0 : uniform_space (semi_normed_ring (has_ssubset (has_ssubset (has_ssubset linarith.ineq))))) : complete_space (semi_normed_ring (has_ssubset (has_ssubset (has_ssubset linarith.ineq)))) := sorry --non-trivial
lemma new_lemma_135533 (h0 : complete_lattice (uniform_space (mul_one_class string.iterator_imp))) : complete_lattice.is_Sup_finite_compact (uniform_space (mul_one_class string.iterator_imp)) := sorry --non-trivial
lemma new_lemma_135534 (h0 : ring (left_cancel_monoid (semiring num))) : strong_rank_condition (left_cancel_monoid (semiring num)) := sorry --non-trivial
lemma new_lemma_135535 (h0 : topological_space (canonically_ordered_comm_semiring (boolean_algebra.core (has_add name)))) : t1_space (canonically_ordered_comm_semiring (boolean_algebra.core (has_add name))) := sorry --non-trivial
lemma new_lemma_135536 (h0 : group (denumerable num)) : group.fg (denumerable num) := sorry --non-trivial
lemma new_lemma_135537 (h0 : topological_space (boolean_algebra.core pos)) : irreducible_space (boolean_algebra.core pos) := sorry --non-trivial
lemma new_lemma_135538 (h0 : monoid (non_assoc_semiring (semiring empty))) : monoid.fg (non_assoc_semiring (semiring empty)) := sorry --non-trivial
lemma new_lemma_135539 (h0 : functor.add_const (cancel_comm_monoid_with_zero (finset Type)) (has_add (has_add (has_neg_part ennreal)))) : @unique_factorization_monoid.{1} (finset.{1} Type) (@functor.add_const.run.{1 0} (cancel_comm_monoid_with_zero.{1} (finset.{1} Type)) (has_add.{0} (has_add.{0} (has_neg_part.{0} ennreal))) h0)  := sorry --non-trivial
lemma new_lemma_135540 (h0 : filter (has_to_string (has_to_string name))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_135541 (h0 : function.extfun Type ring) : @is_domain.{0} (has_pos_part.{0} pos) (@function.extfun_app.{2 1} Type ring.{0} h0 (has_pos_part.{0} pos))  := sorry --non-trivial
lemma new_lemma_135542 (h0 : semiring (has_neg environment.implicit_infer_kind)) : is_noetherian_ring (has_neg environment.implicit_infer_kind) := sorry --non-trivial
lemma new_lemma_135543 (h0 : function.extfun Type topological_space) : @preconnected_space.{0} (normed_lattice_add_comm_group.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (normed_lattice_add_comm_group.{0} pos))  := sorry --non-trivial
lemma new_lemma_135544 (h0 : ring (measure_theory.measure_space (semiring (semiring (semiring congr_arg_kind))))) : rank_condition (measure_theory.measure_space (semiring (semiring (semiring congr_arg_kind)))) := sorry --non-trivial
lemma new_lemma_135545 (h0 : ring (plift (semiring empty))) : strong_rank_condition (plift (semiring empty)) := sorry --non-trivial
lemma new_lemma_135546 (h0 : ring (linear_ordered_semiring (random_gen (random_gen linarith.comp_source)))) : rank_condition (linear_ordered_semiring (random_gen (random_gen linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_135547 (h0 : functor.add_const (function.extfun (Type 1) uniform_space) pos) : @complete_space.{1} (has_nndist.{1} Type) (@function.extfun_app.{3 2} (Type 1) uniform_space.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) uniform_space.{1}) pos h0) (has_nndist.{1} Type))  := sorry --non-trivial
lemma new_lemma_135548 (h0 : monoid (add_left_cancel_semigroup num)) : monoid.fg (add_left_cancel_semigroup num) := sorry --non-trivial
lemma new_lemma_135549 (h0 : ring (has_ssubset std_gen)) : strong_rank_condition (has_ssubset std_gen) := sorry --non-trivial
lemma new_lemma_135550 (h0 : function.extfun Type semiring) : @is_noetherian_ring.{0} (add_comm_monoid.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type semiring.{0} h0 (add_comm_monoid.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_135551 (h0 : not (filter (normed_group linarith.comp) -> false)) : filter.ne_bot (classical.by_contradiction' h0) := sorry --non-trivial
lemma new_lemma_135552 (h0 : topological_space (has_to_string (has_to_string (has_to_string linarith.comp)))) : topological_space.separable_space (has_to_string (has_to_string (has_to_string linarith.comp))) := sorry --non-trivial
lemma new_lemma_135553 (h0 : functor.add_const (uniform_space (complete_distrib_lattice Type)) linarith.comp) : @complete_space.{1} (complete_distrib_lattice.{1} Type) (@functor.add_const.run.{1 0} (uniform_space.{1} (complete_distrib_lattice.{1} Type)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_135554 (h0 : functor.add_const (topological_space (add_left_cancel_semigroup empty)) empty) : @locally_compact_space.{0} (add_left_cancel_semigroup.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (add_left_cancel_semigroup.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_135555 (h0 : functor.comp filter comm_group Type) : countable_Inter_filter (functor.comp.run h0) := sorry --non-trivial
lemma new_lemma_135556 (h0 : function.extfun Type group) : @group.fg.{0} (has_Inf.{0} pos) (@function.extfun_app.{2 1} Type group.{0} h0 (has_Inf.{0} pos))  := sorry --non-trivial
lemma new_lemma_135557 (h0 : function.extfun Type group) : @is_cyclic.{0} (has_to_string.{0} linarith.comp) (@function.extfun_app.{2 1} Type group.{0} h0 (has_to_string.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_135558 (h0 : finset (right_cancel_semigroup (option unsigned))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_135559 (h0 h1 : multiset (simple_graph (mul_one_class char))) : multiset.disjoint h0 h1 := sorry --non-trivial
lemma new_lemma_135560 (h0 : functor.add_const (list (normed_comm_ring linarith.comp)) name) : list.nodup (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_135561 (h0 : functor.add_const (topological_space (complete_distrib_lattice linarith.comp)) name) : @regular_space.{0} (complete_distrib_lattice.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (complete_distrib_lattice.{0} linarith.comp)) name h0)  := sorry --non-trivial
lemma new_lemma_135562 (h0 : functor.add_const (function.extfun Type topological_space) pos) : @preirreducible_space.{0} (generalized_boolean_algebra.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) pos h0) (generalized_boolean_algebra.{0} pos))  := sorry --non-trivial
lemma new_lemma_135563 (h0 : functor.add_const (topological_space (measurable_space.dynkin_system congr_arg_kind)) congr_arg_kind) : @t0_space.{0} (measurable_space.dynkin_system.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (measurable_space.dynkin_system.{0} congr_arg_kind)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_135564 (h0 : topological_space (has_neg (add_comm_monoid pos))) : sequential_space (has_neg (add_comm_monoid pos)) := sorry --non-trivial
lemma new_lemma_135565 (h0 : topological_space (has_add (has_bot (has_Inf (has_add (has_add (has_bot real))))))) : t0_space (has_add (has_bot (has_Inf (has_add (has_add (has_bot real)))))) := sorry --non-trivial
lemma new_lemma_135566 (h0 : functor.add_const (complete_lattice (finset ennreal)) ennreal) : @complete_lattice.is_Sup_finite_compact.{0} (finset.{0} ennreal) (@functor.add_const.run.{0 0} (complete_lattice.{0} (finset.{0} ennreal)) ennreal h0)  := sorry --non-trivial
lemma new_lemma_135567 (h1 : topological_space (has_emptyc (with_bot linarith.comp_source))) : locally_compact_space (has_emptyc (with_bot linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_135568 (h1 : not (function.extfun Type add_group -> false)) : @is_add_cyclic.{0} linarith.comp (@function.extfun_app.{2 1} Type add_group.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type add_group.{0}) h1) linarith.comp)  := sorry --non-trivial
lemma new_lemma_135569 (h0 : ring (add_group (semiring congr_arg_kind))) : is_domain (add_group (semiring congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_135570 (h0 : has_lt (nondiscrete_normed_field ereal)) : no_max_order (nondiscrete_normed_field ereal) := sorry --non-trivial
lemma new_lemma_135571 (h0 : ring (distrib (semigroup (add_cancel_comm_monoid (random_gen (semigroup char)))))) : strong_rank_condition (distrib (semigroup (add_cancel_comm_monoid (random_gen (semigroup char))))) := sorry --non-trivial
lemma new_lemma_135572 (h0 : topological_space (add_right_cancel_monoid (add_group congr_arg_kind))) : irreducible_space (add_right_cancel_monoid (add_group congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_135573 (h0 : topological_space (add_comm_monoid (option (option ennreal)))) : t0_space (add_comm_monoid (option (option ennreal))) := sorry --non-trivial
lemma new_lemma_135574 (h0 : ring (has_top (has_norm (has_norm linarith.comp)))) : strong_rank_condition (has_top (has_norm (has_norm linarith.comp))) := sorry --non-trivial
lemma new_lemma_135575 (h1 : has_mem.mem to_additive.value_type has_emptyc.emptyc) : @t0_space.{0} to_additive.value_type (@finset.pi.empty.{1 0} Type topological_space.{0} to_additive.value_type h1)  := sorry --non-trivial
lemma new_lemma_135576 (h0 : functor.add_const (uniform_space (has_Inf pos)) Type) : @complete_space.{0} (has_Inf.{0} pos) (@functor.add_const.run.{0 1} (uniform_space.{0} (has_Inf.{0} pos)) Type h0)  := sorry --non-trivial
lemma new_lemma_135577 (h0 : add_monoid (left_cancel_semigroup unsigned)) : add_monoid.fg (left_cancel_semigroup unsigned) := sorry --non-trivial
lemma new_lemma_135578 (h0 : function.extfun Type topological_space) : @t0_space.{0} (measurable_space.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (measurable_space.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_135579 (h0 : list (denumerable (random_gen linarith.ineq))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_135580 (h0 : functor.add_const (topological_space (boolean_algebra Type)) pos) : @path_connected_space.{1} (boolean_algebra.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (boolean_algebra.{1} Type)) pos h0)  := sorry --non-trivial
lemma new_lemma_135581 (h0 : uniform_space (has_nndist pos)) : separated_space (has_nndist pos) := sorry --non-trivial
lemma new_lemma_135582 (h0 : topological_space (ring (option (option unsigned)))) : path_connected_space (ring (option (option unsigned))) := sorry --non-trivial
lemma new_lemma_135583 (h0 : not (uniform_space (semiring (random_gen linarith.comp_source)) -> false)) : @complete_space.{0} (semiring.{0} (random_gen.{0} linarith.comp_source)) (@classical.by_contradiction'.{1} (uniform_space.{0} (semiring.{0} (random_gen.{0} linarith.comp_source))) h0)  := sorry --non-trivial
lemma new_lemma_135584 (h0 : group (with_zero string_imp)) : group.fg (with_zero string_imp) := sorry --non-trivial
lemma new_lemma_135585 (h0 : group (canonically_ordered_add_monoid (semiring empty))) : group.fg (canonically_ordered_add_monoid (semiring empty)) := sorry --non-trivial
lemma new_lemma_135586 (h0 : functor.comp group comm_group pos) : @is_simple_group.{0} (comm_group.{0} pos) (@functor.comp.run.{0 0 0} group.{0} comm_group.{0} pos h0)  := sorry --non-trivial
lemma new_lemma_135587 (h0 : complete_lattice (has_neg_part (semigroup unsigned))) : is_atomistic (has_neg_part (semigroup unsigned)) := sorry --non-trivial
lemma new_lemma_135588 (h0 : topological_space (linear_ordered_comm_ring num)) : t0_space (linear_ordered_comm_ring num) := sorry --non-trivial
lemma new_lemma_135589 (h0 : ring (pseudo_metric_space unsigned)) : is_principal_ideal_ring (pseudo_metric_space unsigned) := sorry --non-trivial
lemma new_lemma_135590 (h0 : ordered_comm_monoid (has_add (has_pos_part linarith.comp))) : has_exists_mul_of_le (has_add (has_pos_part linarith.comp)) := sorry --non-trivial
lemma new_lemma_135591 (h0 : add_monoid (mul_zero_class unsigned)) (h1 : option (add_monoid (mul_zero_class unsigned))) : add_monoid.fg (mul_zero_class unsigned) := sorry --non-trivial
lemma new_lemma_135592 (h0 : function.extfun Type topological_space) : @topological_space.separable_space.{0} (mul_zero_class.{0} ennreal) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (mul_zero_class.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_135593 (h0 : not (ring (has_nnnorm num) -> false)) : @rank_condition.{0} (has_nnnorm.{0} num) (@classical.by_contradiction'.{1} (ring.{0} (has_nnnorm.{0} num)) h0)  := sorry --non-trivial
lemma new_lemma_135594 (h0 : functor.add_const (complete_lattice (has_add linarith.comp)) name) : @is_atomistic.{0} (has_add.{0} linarith.comp) (@functor.add_const.run.{0 0} (complete_lattice.{0} (has_add.{0} linarith.comp)) name h0)  := sorry --non-trivial
lemma new_lemma_135595 (h0 : function.extfun Type group) : @is_simple_group.{0} (semigroup.{0} pos) (@function.extfun_app.{2 1} Type group.{0} h0 (semigroup.{0} pos))  := sorry --non-trivial
lemma new_lemma_135596 (h0 : topological_space (comm_group (has_neg_part (has_neg_part (option pos))))) : totally_disconnected_space (comm_group (has_neg_part (has_neg_part (option pos)))) := sorry --non-trivial
lemma new_lemma_135597 (h0 : not (add_group (distrib char) -> false)) : @is_add_cyclic.{0} (distrib.{0} char) (@classical.by_contradiction'.{1} (add_group.{0} (distrib.{0} char)) h0)  := sorry --non-trivial
lemma new_lemma_135598 (h0 : functor.add_const (topological_space (has_to_string name)) (has_neg Type)) : @normal_space.{0} (has_to_string.{0} name) (@functor.add_const.run.{0 1} (topological_space.{0} (has_to_string.{0} name)) (has_neg.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_135599 (h2 : topological_space reducibility_hints) (h3 : add_group reducibility_hints) : topological_add_group reducibility_hints := sorry --non-trivial
lemma new_lemma_135600 (h0 : topological_space (has_ssubset string.iterator_imp)) (h1 : preorder (has_ssubset string.iterator_imp)) : order_topology (has_ssubset string.iterator_imp) := sorry --non-trivial
lemma new_lemma_135601 (h0 : ring (semi_normed_ring (has_ssubset reducibility_hints))) : is_domain (semi_normed_ring (has_ssubset reducibility_hints)) := sorry --non-trivial
lemma new_lemma_135602 (h0 : functor.add_const (topological_space (has_zero unsigned)) linarith.comp) : @preconnected_space.{0} (has_zero.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (has_zero.{0} unsigned)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_135603 (h0 : prod (has_one (semiring num)) (has_one (semiring num))) : id_rel h0 := sorry --non-trivial
lemma new_lemma_135604 (h0 : complete_lattice (has_union (has_norm (has_norm num)))) : is_compactly_generated (has_union (has_norm (has_norm num))) := sorry --non-trivial
lemma new_lemma_135605 (h0 : functor.add_const (topological_space (has_edist unsigned)) empty) : @t1_space.{0} (has_edist.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (has_edist.{0} unsigned)) empty h0)  := sorry --non-trivial
lemma new_lemma_135606 (h0 : uniform_space (semiring (has_norm congr_arg_kind))) : complete_space (semiring (has_norm congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_135607 (h0 : not (ring (has_ssubset to_additive.value_type) -> false)) : @is_domain.{0} (has_ssubset.{0} to_additive.value_type) (@classical.by_contradiction'.{1} (ring.{0} (has_ssubset.{0} to_additive.value_type)) h0)  := sorry --non-trivial
lemma new_lemma_135608 (h0 : finset (mul_zero_class empty)) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_135609 (h0 : functor.add_const (function.extfun Type topological_space) linarith.comp) : @totally_disconnected_space.{0} (has_to_string.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) linarith.comp h0) (has_to_string.{0} pos))  := sorry --non-trivial
lemma new_lemma_135610 (h0 : functor.add_const (finset (add_cancel_monoid name)) name) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_135611 (h0 : fin has_zero.zero) : @totally_disconnected_space.{0} (complete_distrib_lattice.{0} linarith.comp) (@matrix.vec_empty.{0} (topological_space.{0} (complete_distrib_lattice.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_135612 (h0 : topological_space (ordered_comm_ring Type)) : normal_space (ordered_comm_ring Type) := sorry --non-trivial
lemma new_lemma_135613 (h0 : topological_space (has_Inf (has_add Type))) : t0_space (has_Inf (has_add Type)) := sorry --non-trivial
lemma new_lemma_135614 (h0 : ring (normed_field (mul_one_class (mul_one_class to_additive.value_type)))) : is_domain (normed_field (mul_one_class (mul_one_class to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_135615 (h0 : ring (has_top fun_info)) : strong_rank_condition (has_top fun_info) := sorry --non-trivial
lemma new_lemma_135616 (h0 : functor.add_const Prop (has_norm string)) : functor.add_const.run h0 := sorry --non-trivial
lemma new_lemma_135617 (h0 : complete_lattice (boolean_algebra.core (add_comm_monoid name))) : is_compactly_generated (boolean_algebra.core (add_comm_monoid name)) := sorry --non-trivial
lemma new_lemma_135618 (h0 : topological_space (has_top (semiring (semiring empty)))) : normal_space (has_top (semiring (semiring empty))) := sorry --non-trivial
lemma new_lemma_135619 (h0 : complete_lattice (complete_distrib_lattice congr_arg_kind)) : is_atomistic (complete_distrib_lattice congr_arg_kind) := sorry --non-trivial
lemma new_lemma_135620 (h4 : semiring enat) (h5 : ideal enat) : ideal.is_prime h5 := sorry --non-trivial
lemma new_lemma_135621 (h0 : uniform_space (ordered_ring (semiring (semiring empty)))) : separated_space (ordered_ring (semiring (semiring empty))) := sorry --non-trivial
lemma new_lemma_135622 (h0 : ring (has_compl (has_ssubset to_additive.value_type))) : rank_condition (has_compl (has_ssubset to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_135623 (h0 : ring (random_gen (has_ssubset (has_ssubset string.iterator_imp)))) : is_domain (random_gen (has_ssubset (has_ssubset string.iterator_imp))) := sorry --non-trivial
lemma new_lemma_135624 (h0 : monoid (add_cancel_monoid (option ennreal))) : monoid.fg (add_cancel_monoid (option ennreal)) := sorry --non-trivial
lemma new_lemma_135625 (h0 : topological_space (add_cancel_comm_monoid (fintype char))) : t0_space (add_cancel_comm_monoid (fintype char)) := sorry --non-trivial
lemma new_lemma_135626 (h0 : function.extfun Type multiset) (h1 : multiset (has_le fun_info)) : multiset.disjoint (function.extfun_app h0 (has_le fun_info)) h1 := sorry --non-trivial
lemma new_lemma_135627 (h0 : functor.add_const (group (boolean_algebra name)) linarith.comp) : @normalizer_condition.{0} (boolean_algebra.{0} name) (@functor.add_const.run.{0 0} (group.{0} (boolean_algebra.{0} name)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_135628 (h0 : functor.add_const (add_monoid (has_neg linarith.comp)) linarith.comp) : @add_monoid.fg.{0} (has_neg.{0} linarith.comp) (@functor.add_const.run.{0 0} (add_monoid.{0} (has_neg.{0} linarith.comp)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_135629 (h0 : topological_space (metric_space unsigned)) : locally_compact_space (metric_space unsigned) := sorry --non-trivial
lemma new_lemma_135630 (h5 : prod linarith.ineq linarith.ineq) : set.diagonal linarith.ineq h5 := sorry --non-trivial
lemma new_lemma_135631 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @preconnected_space.{0} (ordered_cancel_add_comm_monoid.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (ordered_cancel_add_comm_monoid.{0} empty))  := sorry --non-trivial
lemma new_lemma_135632 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @separated_space.{0} (has_add.{0} pos) (@function.extfun_app.{2 1} Type uniform_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 uniform_space.{0}) (has_add.{0} pos))  := sorry --non-trivial
lemma new_lemma_135633 (h0 : topological_space (has_Inf (has_Inf (has_pos_part Type)))) : preconnected_space (has_Inf (has_Inf (has_pos_part Type))) := sorry --non-trivial
lemma new_lemma_135634 (h0 : functor.add_const (filter (add_cancel_monoid environment.implicit_infer_kind)) Type) : filter.ne_bot (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_135635 (h0 : topological_space (measurable_space.dynkin_system (has_top unsigned))) : locally_compact_space (measurable_space.dynkin_system (has_top unsigned)) := sorry --non-trivial
lemma new_lemma_135636 (h0 : functor.add_const (topological_space (boolean_algebra environment.implicit_infer_kind)) name) : @locally_compact_space.{0} (boolean_algebra.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (boolean_algebra.{0} environment.implicit_infer_kind)) name h0)  := sorry --non-trivial
lemma new_lemma_135637 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_cyclic.{0} (with_bot.{0} fun_info) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (with_bot.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_135638 (h0 : function.extfun Type complete_lattice) : @is_compactly_generated.{0} (canonically_ordered_comm_semiring.{0} linarith.comp) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (canonically_ordered_comm_semiring.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_135639 (h0 : uniform_space (semigroup name)) : complete_space (semigroup name) := sorry --non-trivial
lemma new_lemma_135640 (h0 : filter (has_inv (has_nnnorm to_additive.value_type))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_135641 (h0 : functor.comp ordered_add_comm_monoid has_nndist pos) : @archimedean.{0} (has_nndist.{0} pos) (@functor.comp.run.{0 0 0} ordered_add_comm_monoid.{0} has_nndist.{0} pos h0)  := sorry --non-trivial
lemma new_lemma_135642 (h0 : list (simple_graph (has_Inf (ring linarith.comp)))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_135643 (h0 : function.extfun Type ring) : @is_domain.{0} (has_nnnorm.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type ring.{0} h0 (has_nnnorm.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_135644 (h1 : topological_space (has_div linarith.comp_source)) : totally_disconnected_space (has_div linarith.comp_source) := sorry --non-trivial
lemma new_lemma_135645 (h0 : group (comm_semigroup (has_Inf real))) : group.fg (comm_semigroup (has_Inf real)) := sorry --non-trivial
lemma new_lemma_135646 (h0 : topological_space (finset (finset environment.implicit_infer_kind))) : discrete_topology (finset (finset environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_135647 (h0 : topological_space (ring (cancel_monoid Type))) : locally_compact_space (ring (cancel_monoid Type)) := sorry --non-trivial
lemma new_lemma_135648 (h0 : functor.add_const (topological_space (cancel_monoid name)) unsigned) : @regular_space.{0} (cancel_monoid.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (cancel_monoid.{0} name)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_135649 (h0 : ring (has_append (random_gen to_additive.value_type))) : is_domain (has_append (random_gen to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_135650 (h0 : topological_space (has_Inf (has_Inf (has_Inf (ring name))))) : locally_compact_space (has_Inf (has_Inf (has_Inf (ring name)))) := sorry --non-trivial
lemma new_lemma_135651 (h0 : topological_space (random_gen (has_top num))) : preirreducible_space (random_gen (has_top num)) := sorry --non-trivial
lemma new_lemma_135652 (h0 : function.extfun Type has_le) (h1 : monoid empty) : @is_max.{0} (monoid.{0} empty) (@function.extfun_app.{2 1} Type has_le.{0} h0 (monoid.{0} empty)) h1  := sorry --non-trivial
lemma new_lemma_135653 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @complete_lattice.is_Sup_finite_compact.{0} (@id.{2} Type to_additive.value_type) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (@id.{2} Type to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_135654 (h0 : functor.add_const (topological_space (comm_group linarith.comp)) (has_neg linarith.comp)) : @totally_disconnected_space.{0} (comm_group.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (comm_group.{0} linarith.comp)) (has_neg.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_135655 (h0 : function.extfun Type ring) : @is_principal_ideal_ring.{0} (left_cancel_monoid.{0} num) (@function.extfun_app.{2 1} Type ring.{0} h0 (left_cancel_monoid.{0} num))  := sorry --non-trivial
lemma new_lemma_135656 (h1 : filter (with_zero (has_nnnorm (has_nnnorm char)))) : filter.ne_bot h1 := sorry --non-trivial
lemma new_lemma_135657 (h0 : topological_space (pseudo_metric_space unsigned)) : path_connected_space (pseudo_metric_space unsigned) := sorry --non-trivial
lemma new_lemma_135658 (h0 : functor.add_const (topological_space (semigroup unsigned)) empty) : @totally_disconnected_space.{0} (semigroup.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (semigroup.{0} unsigned)) empty h0)  := sorry --non-trivial
lemma new_lemma_135659 (h0 : topological_space (normed_group (random_gen (random_gen num)))) : totally_separated_space (normed_group (random_gen (random_gen num))) := sorry --non-trivial
lemma new_lemma_135660 (h0 : function.extfun (complete_semilattice_Sup linarith.ineq) (fun (x : complete_semilattice_Sup linarith.ineq), Prop)) : set.nonempty (function.extfun_app h0) := sorry --non-trivial
lemma new_lemma_135661 (h1 : has_mem.mem (has_norm congr_arg_kind) has_emptyc.emptyc) : @t0_space.{0} (has_norm.{0} congr_arg_kind) (@finset.pi.empty.{1 0} Type topological_space.{0} (has_norm.{0} congr_arg_kind) h1)  := sorry --non-trivial
lemma new_lemma_135662 (h0 : fin has_zero.zero) : @regular_space.{0} (boolean_algebra.core.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@matrix.vec_empty.{1} (function.extfun.{2 1} Type topological_space.{0}) h0) (boolean_algebra.core.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_135663 (h1 : add_group (monoid string_imp)) : is_add_cyclic (monoid string_imp) := sorry --non-trivial
lemma new_lemma_135664 (h0 : complete_lattice (has_zero (has_zero linarith.comp))) : is_compactly_generated (has_zero (has_zero linarith.comp)) := sorry --non-trivial
lemma new_lemma_135665 (h0 : group (has_inter empty)) : normalizer_condition (has_inter empty) := sorry --non-trivial
lemma new_lemma_135666 (h0 : ring (boolean_algebra.core (option (option ennreal)))) : rank_condition (boolean_algebra.core (option (option ennreal))) := sorry --non-trivial
lemma new_lemma_135667 (h1 : function.extfun Type filter) : filter.ne_bot (function.extfun_app h1 linarith.comp) := sorry --non-trivial
lemma new_lemma_135668 (h0 : function.extfun Type topological_space) : @preirreducible_space.{0} (complete_distrib_lattice.{0} real) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (complete_distrib_lattice.{0} real))  := sorry --non-trivial
lemma new_lemma_135669 (h3 : set environment.projection_info) : set.finite h3 := sorry --non-trivial
lemma new_lemma_135670 (h0 : add_monoid (ordered_comm_monoid (has_add (has_add (boolean_algebra.core pos))))) : add_monoid.fg (ordered_comm_monoid (has_add (has_add (boolean_algebra.core pos)))) := sorry --non-trivial
lemma new_lemma_135671 (h0 : complete_lattice (has_zero (has_to_string (mul_one_class linarith.comp)))) : is_compactly_generated (has_zero (has_to_string (mul_one_class linarith.comp))) := sorry --non-trivial
lemma new_lemma_135672 (h0 : not (topological_space (has_top empty) -> false)) : @t0_space.{0} (has_top.{0} empty) (@classical.by_contradiction'.{1} (topological_space.{0} (has_top.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_135673 (h0 : function.extfun Type (functor.add_const (topological_space (semigroup empty)))) : @path_connected_space.{0} (semigroup.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (semigroup.{0} empty)) empty (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (topological_space.{0} (semigroup.{0} empty))) h0 empty))  := sorry --non-trivial
lemma new_lemma_135674 (h0 : functor.comp ring finset Type) : @rank_condition.{1} (finset.{1} Type) (@functor.comp.run.{1 1 1} ring.{1} finset.{1} Type h0)  := sorry --non-trivial
lemma new_lemma_135675 (h0 : ring (has_add (option (option ennreal)))) : strong_rank_condition (has_add (option (option ennreal))) := sorry --non-trivial
lemma new_lemma_135676 (h0 : group (has_to_string (add_comm_monoid (has_neg environment.implicit_infer_kind)))) : group.fg (has_to_string (add_comm_monoid (has_neg environment.implicit_infer_kind))) := sorry --non-trivial
lemma new_lemma_135677 (h0 : functor.add_const (ring (add_cancel_monoid pos)) linarith.comp) : @rank_condition.{0} (add_cancel_monoid.{0} pos) (@functor.add_const.run.{0 0} (ring.{0} (add_cancel_monoid.{0} pos)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_135678 (h0 : complete_lattice (add_group (semiring (semiring (semiring (semiring (semiring num))))))) : is_compactly_generated (add_group (semiring (semiring (semiring (semiring (semiring num)))))) := sorry --non-trivial
lemma new_lemma_135679 (h0 : functor.add_const (function.extfun (Type 1) group) Type) : @group.fg.{1} (boolean_algebra.core.{1} Type) (@function.extfun_app.{3 2} (Type 1) group.{1} (@functor.add_const.run.{2 1} (function.extfun.{3 2} (Type 1) group.{1}) Type h0) (boolean_algebra.core.{1} Type))  := sorry --non-trivial
lemma new_lemma_135680 (h0 : functor.add_const (add_group (boolean_algebra.core pos)) (finset pos)) : @is_add_cyclic.{0} (boolean_algebra.core.{0} pos) (@functor.add_const.run.{0 0} (add_group.{0} (boolean_algebra.core.{0} pos)) (finset.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_135681 (h0 : cancel_comm_monoid_with_zero (pseudo_metric_space Type)) : unique_factorization_monoid (pseudo_metric_space Type) := sorry --non-trivial
lemma new_lemma_135682 (h0 : semiring (boolean_algebra (ring linarith.comp))) : is_noetherian_ring (boolean_algebra (ring linarith.comp)) := sorry --non-trivial
lemma new_lemma_135683 (h0 : finset (add_cancel_monoid (normed_comm_ring pos))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_135684 (h0 : uniform_space (has_top empty)) : complete_space (has_top empty) := sorry --non-trivial
lemma new_lemma_135685 (h0 : not (complete_lattice (semiring linarith.ineq) -> false)) : @is_compactly_generated.{0} (semiring.{0} linarith.ineq) (@classical.by_contradiction'.{1} (complete_lattice.{0} (semiring.{0} linarith.ineq)) h0)  := sorry --non-trivial
lemma new_lemma_135686 (h0 : uniform_space (add_monoid char)) : complete_space (add_monoid char) := sorry --non-trivial
lemma new_lemma_135687 (h0 : ring (has_add (has_zero Type))) : is_principal_ideal_ring (has_add (has_zero Type)) := sorry --non-trivial
lemma new_lemma_135688 (h1 : function.extfun Type ring) : @is_domain.{0} (with_bot.{0} linarith.ineq) (@function.extfun_app.{2 1} Type ring.{0} h1 (with_bot.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_135689 (h0 : function.extfun Type (functor.add_const (function.extfun Type monoid))) : @monoid.fg.{0} (has_dist.{0} num) (@function.extfun_app.{2 1} Type monoid.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type monoid.{0}) num (@function.extfun_app.{2 2} Type (functor.add_const.{1 0} (function.extfun.{2 1} Type monoid.{0})) h0 num)) (has_dist.{0} num))  := sorry --non-trivial
lemma new_lemma_135690 (h0 : cancel_comm_monoid_with_zero (has_zero (has_neg_part unsigned))) : unique_factorization_monoid (has_zero (has_neg_part unsigned)) := sorry --non-trivial
lemma new_lemma_135691 (h0 : topological_space (id congr_arg_kind) -> Prop) : @preirreducible_space.{0} (@id.{2} Type congr_arg_kind) (@classical.epsilon.{1} (topological_space.{0} (@id.{2} Type congr_arg_kind)) (@nonempty_of_inhabited.{1} (topological_space.{0} (@id.{2} Type congr_arg_kind)) (@inhabited_topological_space.{0} (@id.{2} Type congr_arg_kind))) h0)  := sorry --non-trivial
lemma new_lemma_135692 (h0 : uniform_space (has_pos_part pos)) : complete_space (has_pos_part pos) := sorry --non-trivial
lemma new_lemma_135693 (h1 : topological_space linarith.ineq) (h2 : preorder linarith.ineq) : order_closed_topology linarith.ineq := sorry --non-trivial
lemma new_lemma_135694 (h0 : functor.add_const (ring (add_cancel_monoid name)) Type) : @is_principal_ideal_ring.{0} (add_cancel_monoid.{0} name) (@functor.add_const.run.{0 1} (ring.{0} (add_cancel_monoid.{0} name)) Type h0)  := sorry --non-trivial
lemma new_lemma_135695 (h0 : function.extfun Type ring) : @is_domain.{0} (linear_ordered_cancel_comm_monoid.{0} empty) (@function.extfun_app.{2 1} Type ring.{0} h0 (linear_ordered_cancel_comm_monoid.{0} empty))  := sorry --non-trivial
lemma new_lemma_135696 (h0 : functor.add_const (function.extfun Type semiring) linarith.comp) : @is_noetherian_ring.{0} (has_to_string.{0} linarith.comp) (@function.extfun_app.{2 1} Type semiring.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type semiring.{0}) linarith.comp h0) (has_to_string.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_135697 (h0 : ring (encodable (has_inv string_imp))) : is_domain (encodable (has_inv string_imp)) := sorry --non-trivial
lemma new_lemma_135698 (h0 : semiring (ordered_comm_ring (finset linarith.comp))) : is_noetherian_ring (ordered_comm_ring (finset linarith.comp)) := sorry --non-trivial
lemma new_lemma_135699 (h0 : topological_space (has_bot name)) : regular_space (has_bot name) := sorry --non-trivial
lemma new_lemma_135700 (h0 : topological_space (semigroup (finset linarith.comp))) : preconnected_space (semigroup (finset linarith.comp)) := sorry --non-trivial
lemma new_lemma_135701 (h0 : function.extfun Type complete_lattice) : @complete_lattice.is_Sup_finite_compact.{0} (add_right_cancel_monoid.{0} unsigned) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (add_right_cancel_monoid.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_135702 (h0 : functor.add_const (add_monoid (has_neg linarith.comp)) environment.implicit_infer_kind) : @add_monoid.fg.{0} (has_neg.{0} linarith.comp) (@functor.add_const.run.{0 0} (add_monoid.{0} (has_neg.{0} linarith.comp)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_135703 (h0 : fin has_zero.zero) : @totally_separated_space.{0} (add_comm_monoid.{0} real) (@matrix.vec_empty.{0} (topological_space.{0} (add_comm_monoid.{0} real)) h0)  := sorry --non-trivial
lemma new_lemma_135704 (h0 : add_group (dlist (random_gen (random_gen linarith.ineq)))) : is_add_cyclic (dlist (random_gen (random_gen linarith.ineq))) := sorry --non-trivial
lemma new_lemma_135705 (h0 : complete_lattice (is_R_or_C (option (option empty)))) : is_compactly_generated (is_R_or_C (option (option empty))) := sorry --non-trivial
lemma new_lemma_135706 (h0 : topological_space (has_nndist (has_add Type))) : loc_path_connected_space (has_nndist (has_add Type)) := sorry --non-trivial
lemma new_lemma_135707 (h0 : ring (normed_field (random_gen char))) : rank_condition (normed_field (random_gen char)) := sorry --non-trivial
lemma new_lemma_135708 (h0 : not (ring (linear_ordered_comm_group_with_zero to_additive.value_type) -> false)) : @strong_rank_condition.{0} (linear_ordered_comm_group_with_zero.{0} to_additive.value_type) (@classical.by_contradiction'.{1} (ring.{0} (linear_ordered_comm_group_with_zero.{0} to_additive.value_type)) h0)  := sorry --non-trivial
lemma new_lemma_135709 (h0 : function.extfun Type topological_space) : @t0_space.{0} (filter.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (filter.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_135710 (h0 : complete_lattice (has_pos_part (finset (has_add linarith.comp)))) : complete_lattice.is_Sup_finite_compact (has_pos_part (finset (has_add linarith.comp))) := sorry --non-trivial
lemma new_lemma_135711 (h0 : functor.add_const (function.extfun (Type 1) ring) linarith.comp) : @strong_rank_condition.{1} (has_Inf.{1} Type) (@function.extfun_app.{3 2} (Type 1) ring.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) ring.{1}) linarith.comp h0) (has_Inf.{1} Type))  := sorry --non-trivial
lemma new_lemma_135712 (h0 : functor.add_const (topological_space Type) (has_neg linarith.comp)) : @discrete_topology.{1} Type (@functor.add_const.run.{1 0} (topological_space.{1} Type) (has_neg.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_135713 (h0 : functor.add_const (topological_space (has_Inf Type)) (has_Inf linarith.comp)) : @discrete_topology.{1} (has_Inf.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (has_Inf.{1} Type)) (has_Inf.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_135714 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @rank_condition.{0} (monoid_with_zero.{0} ennreal) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (monoid_with_zero.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_135715 (h0 : topological_space (boolean_algebra (sub_neg_monoid Type))) : t1_space (boolean_algebra (sub_neg_monoid Type)) := sorry --non-trivial
lemma new_lemma_135716 (h0 : topological_space (complete_semilattice_Sup (random_gen linarith.comp_source))) : t0_space (complete_semilattice_Sup (random_gen linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_135717 (h0 : ring (has_Inf pos)) : is_domain (has_Inf pos) := sorry --non-trivial
lemma new_lemma_135718 (h1 : not (ring (simple_graph string_imp) -> false)) : @is_domain.{0} (simple_graph.{0} string_imp) (@classical.by_contradiction'.{1} (ring.{0} (simple_graph.{0} string_imp)) h1)  := sorry --non-trivial
lemma new_lemma_135719 (h0 : functor.add_const (semiring (left_cancel_monoid empty)) congr_arg_kind) : @is_noetherian_ring.{0} (left_cancel_monoid.{0} empty) (@functor.add_const.run.{0 0} (semiring.{0} (left_cancel_monoid.{0} empty)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_135720 (h0 : fin has_zero.zero) : @rank_condition.{0} (boolean_algebra.{0} real) (@function.extfun_app.{2 1} Type ring.{0} (@matrix.vec_empty.{1} (function.extfun.{2 1} Type ring.{0}) h0) (boolean_algebra.{0} real))  := sorry --non-trivial
lemma new_lemma_135721 (h0 : group (canonically_ordered_comm_semiring environment.implicit_infer_kind)) : normalizer_condition (canonically_ordered_comm_semiring environment.implicit_infer_kind) := sorry --non-trivial
lemma new_lemma_135722 (h0 : uniform_space (semi_normed_comm_ring (has_ssubset (has_ssubset linarith.ineq)))) : complete_space (semi_normed_comm_ring (has_ssubset (has_ssubset linarith.ineq))) := sorry --non-trivial
lemma new_lemma_135723 (h1 : topological_space (simple_graph to_additive.value_type)) : t0_space (simple_graph to_additive.value_type) := sorry --non-trivial
lemma new_lemma_135724 (h2 : topological_space (semi_normed_ring (random_gen to_additive.value_type))) : t0_space (semi_normed_ring (random_gen to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_135725 (h0 : complete_lattice (finset pos)) : is_compactly_generated (finset pos) := sorry --non-trivial
lemma new_lemma_135726 (h0 : topological_space (add_comm_monoid (option ennreal))) : t0_space (add_comm_monoid (option ennreal)) := sorry --non-trivial
lemma new_lemma_135727 (h0 : functor.add_const (ring (partial_order num)) congr_arg_kind) : @strong_rank_condition.{0} (partial_order.{0} num) (@functor.add_const.run.{0 0} (ring.{0} (partial_order.{0} num)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_135728 (h0 : functor.add_const (topological_space (semigroup linarith.comp)) linarith.comp) : @discrete_topology.{0} (semigroup.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (semigroup.{0} linarith.comp)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_135729 (h0 : list (has_neg_part (option (option (option (option pos)))))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_135730 (h0 : topological_space (has_one num)) : totally_separated_space (has_one num) := sorry --non-trivial
lemma new_lemma_135731 (h0 : ring (has_div environment.projection_info)) : strong_rank_condition (has_div environment.projection_info) := sorry --non-trivial
lemma new_lemma_135732 (h0 : filter (linear_ordered_comm_ring (semiring (semiring num)))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_135733 (h0 : function.extfun Type uniform_space) : @complete_space.{0} (has_top.{0} linarith.ineq) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (has_top.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_135734 (h0 : topological_space (has_norm (semiring num))) : totally_disconnected_space (has_norm (semiring num)) := sorry --non-trivial
lemma new_lemma_135735 (h0 : functor.add_const (topological_space (has_zero linarith.comp)) linarith.comp) : @t1_space.{0} (has_zero.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (has_zero.{0} linarith.comp)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_135736 (h0 : function.extfun (nat -> Type) (function.extfun nat)) : @regular_space.{1} (comm_semigroup.{1} Type) (@matrix.vec_empty.{1} (topological_space.{1} (comm_semigroup.{1} Type)) (@function.extfun_app.{1 1} nat fin (@function.extfun_app.{2 1} (nat → Type) (function.extfun.{1 1} nat) h0 fin) (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_135737 (h0 : uniform_space (has_ssubset (random_gen reducibility_hints))) : complete_space (has_ssubset (random_gen reducibility_hints)) := sorry --non-trivial
lemma new_lemma_135738 (h0 : fin has_zero.zero) : @path_connected_space.{0} (boolean_algebra.{0} real) (@matrix.vec_empty.{0} (topological_space.{0} (boolean_algebra.{0} real)) h0)  := sorry --non-trivial
lemma new_lemma_135739 (h0 : topological_space (has_zero linarith.comp)) : t0_space (has_zero linarith.comp) := sorry --non-trivial
lemma new_lemma_135740 (h0 : functor.add_const (complete_lattice (finset empty)) congr_arg_kind) : @complete_lattice.is_Sup_finite_compact.{0} (finset.{0} empty) (@functor.add_const.run.{0 0} (complete_lattice.{0} (finset.{0} empty)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_135741 (h0 : functor.add_const (uniform_space (cancel_monoid name)) environment.implicit_infer_kind) : @complete_space.{0} (cancel_monoid.{0} name) (@functor.add_const.run.{0 0} (uniform_space.{0} (cancel_monoid.{0} name)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_135742 (h0 : not (function.extfun Type topological_space -> false)) : @normal_space.{0} (add_group.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (add_group.{0} num))  := sorry --non-trivial
lemma new_lemma_135743 (h0 : function.extfun Type semiring) : @is_noetherian_ring.{0} (has_neg.{0} empty) (@function.extfun_app.{2 1} Type semiring.{0} h0 (has_neg.{0} empty))  := sorry --non-trivial
lemma new_lemma_135744 (h0 : ring (has_neg (has_Inf linarith.comp))) : is_domain (has_neg (has_Inf linarith.comp)) := sorry --non-trivial
lemma new_lemma_135745 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : list.nodup (function.extfun_app (function.extfun_app h0 list) (finset congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_135746 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_cyclic.{0} (has_one.{0} empty) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (has_one.{0} empty))  := sorry --non-trivial
lemma new_lemma_135747 (h0 : complete_lattice (has_top (linear_ordered_add_comm_group (has_emptyc congr_arg_kind)))) : is_compactly_generated (has_top (linear_ordered_add_comm_group (has_emptyc congr_arg_kind))) := sorry --non-trivial
lemma new_lemma_135748 (h0 : functor.add_const (uniform_space (semiring unsigned)) unsigned) : @complete_space.{0} (semiring.{0} unsigned) (@functor.add_const.run.{0 0} (uniform_space.{0} (semiring.{0} unsigned)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_135749 (h0 : functor.add_const (function.extfun Type complete_lattice) Type) : @is_compactly_generated.{0} (has_add.{0} linarith.comp) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type complete_lattice.{0}) Type h0) (has_add.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_135750 (h0 : semiring (linear_ordered_comm_monoid_with_zero (option empty))) : is_noetherian_ring (linear_ordered_comm_monoid_with_zero (option empty)) := sorry --non-trivial
lemma new_lemma_135751 (h0 : functor.add_const (ring (has_neg_part name)) pos) : @rank_condition.{0} (has_neg_part.{0} name) (@functor.add_const.run.{0 0} (ring.{0} (has_neg_part.{0} name)) pos h0)  := sorry --non-trivial
lemma new_lemma_135752 (h0 : complete_lattice (sub_neg_monoid pos)) : is_compactly_generated (sub_neg_monoid pos) := sorry --non-trivial
lemma new_lemma_135753 (h0 : ring (comm_group (option (option unsigned)))) : is_domain (comm_group (option (option unsigned))) := sorry --non-trivial
lemma new_lemma_135754 (h1 : complete_lattice (measurable_space (has_top fun_info))) : is_compactly_generated (measurable_space (has_top fun_info)) := sorry --non-trivial
lemma new_lemma_135755 (h0 : not (multiset (has_nnnorm linarith.ineq) -> false)) (h1 : multiset (has_nnnorm linarith.ineq)) : multiset.disjoint (classical.by_contradiction' h0) h1 := sorry --non-trivial
lemma new_lemma_135756 (h0 : functor.add_const (add_monoid (has_zero environment.implicit_infer_kind)) environment.implicit_infer_kind) : @add_monoid.fg.{0} (has_zero.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (add_monoid.{0} (has_zero.{0} environment.implicit_infer_kind)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_135757 (h0 : finset (complete_distrib_lattice (option (option (option pos))))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_135758 (h0 : monoid (normed_comm_ring ennreal)) : monoid.fg (normed_comm_ring ennreal) := sorry --non-trivial
lemma new_lemma_135759 (h0 : functor.add_const (function.extfun Type add_group) pos) : @is_add_cyclic.{0} (has_to_string.{0} pos) (@function.extfun_app.{2 1} Type add_group.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type add_group.{0}) pos h0) (has_to_string.{0} pos))  := sorry --non-trivial
lemma new_lemma_135760 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @complete_lattice.is_Sup_finite_compact.{0} (has_neg.{0} pos) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (has_neg.{0} pos))  := sorry --non-trivial
lemma new_lemma_135761 (h0 : with_bot (random_gen (random_gen linarith.comp_source)) -> Prop) : Exists h0 := sorry --non-trivial
lemma new_lemma_135762 (h0 : functor.add_const (group (add_comm_monoid Type)) Type) : @group.fg.{1} (add_comm_monoid.{1} Type) (@functor.add_const.run.{1 1} (group.{1} (add_comm_monoid.{1} Type)) Type h0)  := sorry --non-trivial
lemma new_lemma_135763 (h0 : ring (normed_comm_ring (option (mul_zero_class name)))) : is_principal_ideal_ring (normed_comm_ring (option (mul_zero_class name))) := sorry --non-trivial
lemma new_lemma_135764 (h0 : ring (has_nndist (has_to_string (has_to_string (ring (has_to_string unsigned)))))) : rank_condition (has_nndist (has_to_string (has_to_string (ring (has_to_string unsigned))))) := sorry --non-trivial
lemma new_lemma_135765 (h0 : function.extfun Type topological_space) : @preirreducible_space.{0} (finset.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (finset.{0} name))  := sorry --non-trivial
lemma new_lemma_135766 (h1 : function.extfun (Type -> Type) (function.extfun Type)) : @locally_compact_space.{0} (with_bot.{0} string_imp) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h1 topological_space.{0}) (with_bot.{0} string_imp))  := sorry --non-trivial
lemma new_lemma_135767 (h0 : group (encodable string_imp)) : is_cyclic (encodable string_imp) := sorry --non-trivial
lemma new_lemma_135768 (h1 : topological_space (has_norm to_additive.value_type)) : t0_space (has_norm to_additive.value_type) := sorry --non-trivial
lemma new_lemma_135769 (h0 : ring (mul_zero_class (boolean_algebra Type))) : is_domain (mul_zero_class (boolean_algebra Type)) := sorry --non-trivial
lemma new_lemma_135770 (h0 : function.extfun Type group) : @group.fg.{0} (has_sub.{0} unsigned) (@function.extfun_app.{2 1} Type group.{0} h0 (has_sub.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_135771 (h0 : functor.add_const (monoid (has_to_string linarith.comp)) pos) : @monoid.fg.{0} (has_to_string.{0} linarith.comp) (@functor.add_const.run.{0 0} (monoid.{0} (has_to_string.{0} linarith.comp)) pos h0)  := sorry --non-trivial
lemma new_lemma_135772 (h0 : topological_space (comm_ring to_additive.value_type)) : path_connected_space (comm_ring to_additive.value_type) := sorry --non-trivial
lemma new_lemma_135773 (h0 : semiring (linear_ordered_semiring (semiring linarith.comp))) : is_noetherian_ring (linear_ordered_semiring (semiring linarith.comp)) := sorry --non-trivial
lemma new_lemma_135774 (h0 : topological_space (ordered_comm_monoid (ring (ring (ring linarith.comp))))) : normal_space (ordered_comm_monoid (ring (ring (ring linarith.comp)))) := sorry --non-trivial
lemma new_lemma_135775 (h0 : topological_space (random_gen (has_norm linarith.comp))) : normal_space (random_gen (has_norm linarith.comp)) := sorry --non-trivial
lemma new_lemma_135776 (h0 : functor.add_const (topological_space (ordered_ring empty)) empty) : @loc_path_connected_space.{0} (ordered_ring.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (ordered_ring.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_135777 (h0 : set (nondiscrete_normed_field (add_comm_semigroup (mul_one_class string.iterator_imp)) -> string.iterator_imp)) : set.separates_points h0 := sorry --non-trivial
lemma new_lemma_135778 (h0 : function.extfun Type uniform_space) : @separated_space.{0} (option.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (option.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_135779 (h0 : topological_space (ordered_comm_monoid string_imp)) (h1 : group (compact_exhaustion (ordered_comm_monoid string_imp))) : group.fg (compact_exhaustion (ordered_comm_monoid string_imp)) := sorry --non-trivial
lemma new_lemma_135780 (h0 : ring (complete_distrib_lattice (comm_group Type))) : is_principal_ideal_ring (complete_distrib_lattice (comm_group Type)) := sorry --non-trivial
lemma new_lemma_135781 (h0 : function.extfun Type topological_space) : @preconnected_space.{0} (boolean_algebra.{0} real) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (boolean_algebra.{0} real))  := sorry --non-trivial
lemma new_lemma_135782 (h0 : function.extfun Type topological_space) : @totally_disconnected_space.{0} (random_gen.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (random_gen.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_135783 (h0 : functor.add_const (topological_space (add_comm_monoid ennreal)) unsigned) : @irreducible_space.{0} (add_comm_monoid.{0} ennreal) (@functor.add_const.run.{0 0} (topological_space.{0} (add_comm_monoid.{0} ennreal)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_135784 (h0 : functor.add_const (topological_space (plift unsigned)) congr_arg_kind) : @discrete_topology.{1} (plift.{1} unsigned) (@functor.add_const.run.{1 0} (topological_space.{1} (plift.{1} unsigned)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_135785 (h0 : functor.add_const (group (sub_neg_monoid pos)) (has_Inf linarith.comp)) : @group.fg.{0} (sub_neg_monoid.{0} pos) (@functor.add_const.run.{0 0} (group.{0} (sub_neg_monoid.{0} pos)) (has_Inf.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_135786 (h0 : has_mem.mem (with_one linarith.comp_source) has_emptyc.emptyc) : @is_domain.{0} (with_one.{0} linarith.comp_source) (@finset.pi.empty.{1 0} Type ring.{0} (with_one.{0} linarith.comp_source) h0)  := sorry --non-trivial
lemma new_lemma_135787 (h0 : ring (monoid (option (option (option (option empty)))))) : strong_rank_condition (monoid (option (option (option (option empty))))) := sorry --non-trivial
lemma new_lemma_135788 (h0 : ring (has_nndist (semigroup Type))) : rank_condition (has_nndist (semigroup Type)) := sorry --non-trivial
lemma new_lemma_135789 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_principal_ideal_ring.{0} (has_to_string.{0} linarith.comp) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (has_to_string.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_135790 (h0 : complete_lattice (linear_ordered_add_comm_group (has_inv fun_info))) : is_compactly_generated (linear_ordered_add_comm_group (has_inv fun_info)) := sorry --non-trivial
lemma new_lemma_135791 (h0 : complete_lattice (semiring linarith.comp)) : is_atomistic (semiring linarith.comp) := sorry --non-trivial
lemma new_lemma_135792 (h0 : topological_space (has_Inf (has_neg name))) : loc_path_connected_space (has_Inf (has_neg name)) := sorry --non-trivial
lemma new_lemma_135793 (h0 : finset (has_Inf (has_neg (has_neg (ring Type))))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_135794 (h0 : filter (linear_ordered_field num)) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_135795 (h0 : add_group (has_ssubset (has_ssubset char))) : is_add_cyclic (has_ssubset (has_ssubset char)) := sorry --non-trivial
lemma new_lemma_135796 (h1 : option Type) (h2 : topological_space (has_norm (option.lhoare linarith.comp h1))) : discrete_topology (has_norm (option.lhoare linarith.comp h1)) := sorry --non-trivial
lemma new_lemma_135797 (h0 : function.extfun Type topological_space) : @discrete_topology.{0} (preorder.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (preorder.{0} empty))  := sorry --non-trivial
lemma new_lemma_135798 (h0 : complete_lattice (semiring fun_info)) : is_atomistic (semiring fun_info) := sorry --non-trivial
lemma new_lemma_135799 (h0 : topological_space (id (semiring congr_arg_kind))) : locally_compact_space (id (semiring congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_135800 (h0 : functor.add_const (topological_space (linear_ordered_comm_monoid_with_zero unsigned)) empty) : @path_connected_space.{0} (linear_ordered_comm_monoid_with_zero.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (linear_ordered_comm_monoid_with_zero.{0} unsigned)) empty h0)  := sorry --non-trivial
lemma new_lemma_135801 (h0 : functor.add_const (ring (finset pos)) linarith.comp) : @rank_condition.{0} (finset.{0} pos) (@functor.add_const.run.{0 0} (ring.{0} (finset.{0} pos)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_135802 (h0 : topological_space (has_to_string (mul_one_class Type))) : normal_space (has_to_string (mul_one_class Type)) := sorry --non-trivial
lemma new_lemma_135803 (h0 : functor.add_const (list (non_assoc_semiring unsigned)) unsigned) : list.nodup (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_135804 (h0 : topological_space (mul_one_class std_gen)) (h1 : preorder (mul_one_class std_gen)) : order_topology (mul_one_class std_gen) := sorry --non-trivial
lemma new_lemma_135805 (h0 : functor.add_const (function.extfun (Type 1) cancel_comm_monoid_with_zero) (has_zero name)) : @unique_factorization_monoid.{1} (has_Inf.{1} Type) (@function.extfun_app.{3 2} (Type 1) cancel_comm_monoid_with_zero.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) cancel_comm_monoid_with_zero.{1}) (has_zero.{0} name) h0) (has_Inf.{1} Type))  := sorry --non-trivial
lemma new_lemma_135806 (h0 : functor.add_const (filter (boolean_algebra.core name)) Type) : filter.ne_bot (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_135807 (h0 : topological_space (has_edist empty)) : t1_space (has_edist empty) := sorry --non-trivial
lemma new_lemma_135808 (h0 : ring (add_left_cancel_monoid fun_info)) : is_domain (add_left_cancel_monoid fun_info) := sorry --non-trivial
lemma new_lemma_135809 (h0 : has_mem.mem topological_space has_emptyc.emptyc) : @normal_space.{0} num (@function.extfun_app.{2 1} Type topological_space.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) topological_space.{0} h0) num)  := sorry --non-trivial
lemma new_lemma_135810 (h0 : monoid (has_neg_part (finset Type))) : monoid.fg (has_neg_part (finset Type)) := sorry --non-trivial
lemma new_lemma_135811 (h0 : filter (has_star (semiring (semiring (semiring (semiring unsigned)))))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_135812 (h0 : topological_space (has_ssubset string.iterator_imp)) (h1 : add_group (has_ssubset (topological_space.opens (has_ssubset string.iterator_imp)))) : is_add_cyclic (has_ssubset (topological_space.opens (has_ssubset string.iterator_imp))) := sorry --non-trivial
lemma new_lemma_135813 (h0 : not (complete_lattice (measurable_space.dynkin_system unsigned) -> false)) : @complete_lattice.is_Sup_finite_compact.{0} (measurable_space.dynkin_system.{0} unsigned) (@classical.by_contradiction'.{1} (complete_lattice.{0} (measurable_space.dynkin_system.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_135814 (h0 : ordered_comm_monoid (comm_semigroup (has_pos_part (has_bot Type)))) : has_exists_mul_of_le (comm_semigroup (has_pos_part (has_bot Type))) := sorry --non-trivial
lemma new_lemma_135815 (h0 : filter (complete_semilattice_Sup empty)) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_135816 (h0 : topological_space (complete_distrib_lattice (has_add (sub_neg_monoid (sub_neg_monoid pos))))) : discrete_topology (complete_distrib_lattice (has_add (sub_neg_monoid (sub_neg_monoid pos)))) := sorry --non-trivial
lemma new_lemma_135817 (h0 : topological_space (has_ssubset string.iterator_imp)) (h1 : preorder (has_ssubset string.iterator_imp)) : order_closed_topology (has_ssubset string.iterator_imp) := sorry --non-trivial
lemma new_lemma_135818 (h0 : not (function.extfun Type topological_space -> false)) : @preirreducible_space.{0} (linear_ordered_semiring.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (linear_ordered_semiring.{0} num))  := sorry --non-trivial
lemma new_lemma_135819 (h0 : functor.add_const (function.extfun Type cancel_comm_monoid_with_zero) Type) : @unique_factorization_monoid.{0} (finset.{0} name) (@function.extfun_app.{2 1} Type cancel_comm_monoid_with_zero.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type cancel_comm_monoid_with_zero.{0}) Type h0) (finset.{0} name))  := sorry --non-trivial
lemma new_lemma_135820 (h0 : topological_space (sub_neg_monoid (has_neg (has_neg (has_neg (has_neg Type)))))) : totally_disconnected_space (sub_neg_monoid (has_neg (has_neg (has_neg (has_neg Type))))) := sorry --non-trivial
lemma new_lemma_135821 (h0 : not (has_mem.mem (id num) has_emptyc.emptyc -> false)) : @locally_compact_space.{0} (@id.{2} Type num) (@finset.pi.empty.{1 0} Type topological_space.{0} (@id.{2} Type num) (@classical.by_contradiction'.{0} (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (@id.{2} Type num) (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))) h0))  := sorry --non-trivial
lemma new_lemma_135822 (h0 : functor.add_const (topological_space (ring Type)) name) : @t1_space.{1} (ring.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (ring.{1} Type)) name h0)  := sorry --non-trivial
lemma new_lemma_135823 (h0 : function.extfun Type ordered_add_comm_monoid) : @archimedean.{0} (normed_linear_ordered_group.{0} (semiring.{0} (semiring.{0} (semiring.{0} empty)))) (@function.extfun_app.{2 1} Type ordered_add_comm_monoid.{0} h0 (normed_linear_ordered_group.{0} (semiring.{0} (semiring.{0} (semiring.{0} empty)))))  := sorry --non-trivial
lemma new_lemma_135824 (h0 : functor.add_const (list (simple_graph linarith.comp)) linarith.comp) : palindrome (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_135825 (h0 : functor.add_const (topological_space (add_cancel_monoid pos)) linarith.comp) : @discrete_topology.{0} (add_cancel_monoid.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (add_cancel_monoid.{0} pos)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_135826 (h0 : functor.add_const (ring (semiring num)) num) : @is_domain.{0} (semiring.{0} num) (@functor.add_const.run.{0 0} (ring.{0} (semiring.{0} num)) num h0)  := sorry --non-trivial
lemma new_lemma_135827 (h0 : filter (has_nndist (has_nndist Type))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_135828 (h0 : topological_space (has_ssubset std_gen)) : t0_space (has_ssubset std_gen) := sorry --non-trivial
lemma new_lemma_135829 (h0 : not (complete_lattice auto.case_option -> false)) : @is_atomistic.{0} auto.case_option (@classical.by_contradiction'.{1} (complete_lattice.{0} auto.case_option) h0)  := sorry --non-trivial
lemma new_lemma_135830 (h0 : fin has_zero.zero) : @separated_space.{0} (generalized_boolean_algebra.{0} name) (@function.extfun_app.{2 1} Type uniform_space.{0} (@matrix.vec_empty.{1} (function.extfun.{2 1} Type uniform_space.{0}) h0) (generalized_boolean_algebra.{0} name))  := sorry --non-trivial
lemma new_lemma_135831 (h0 : function.extfun Type (functor.add_const (topological_space (omega_complete_partial_order empty)))) : @t0_space.{0} (omega_complete_partial_order.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (omega_complete_partial_order.{0} empty)) empty (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (topological_space.{0} (omega_complete_partial_order.{0} empty))) h0 empty))  := sorry --non-trivial
lemma new_lemma_135832 (h0 : function.extfun Type ring) : @rank_condition.{0} (complete_semilattice_Sup.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type ring.{0} h0 (complete_semilattice_Sup.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_135833 (h0 : functor.add_const (list (linear_ordered_comm_monoid_with_zero unsigned)) congr_arg_kind) : palindrome (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_135834 (h0 : functor.add_const (topological_space (id empty)) empty) : @normal_space.{0} (@id.{2} Type empty) (@functor.add_const.run.{0 0} (topological_space.{0} (@id.{2} Type empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_135835 (h0 : topological_space (boolean_algebra (normed_comm_ring linarith.comp))) : path_connected_space (boolean_algebra (normed_comm_ring linarith.comp)) := sorry --non-trivial
lemma new_lemma_135836 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_atomistic.{0} (linear_ordered_comm_ring.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (linear_ordered_comm_ring.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_135837 (h0 : functor.add_const (ring (normed_comm_ring Type)) Type) : @is_domain.{1} (normed_comm_ring.{1} Type) (@functor.add_const.run.{1 1} (ring.{1} (normed_comm_ring.{1} Type)) Type h0)  := sorry --non-trivial
lemma new_lemma_135838 (h0 : functor.add_const (topological_space (has_nndist name)) Type) : @regular_space.{0} (has_nndist.{0} name) (@functor.add_const.run.{0 1} (topological_space.{0} (has_nndist.{0} name)) Type h0)  := sorry --non-trivial
lemma new_lemma_135839 (h0 : cancel_comm_monoid_with_zero (cancel_monoid empty)) : unique_factorization_monoid (cancel_monoid empty) := sorry --non-trivial
lemma new_lemma_135840 (h0 : not (function.extfun (Type -> Type) (function.extfun Type) -> false)) : @totally_separated_space.{0} string_imp (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) (@classical.by_contradiction'.{2} (function.extfun.{2 2} (Type → Type) (function.extfun.{2 1} Type)) h0) topological_space.{0}) string_imp)  := sorry --non-trivial
lemma new_lemma_135841 (h1 : not (topological_space (linear_ordered_semiring fun_info) -> false)) : @discrete_topology.{0} (linear_ordered_semiring.{0} fun_info) (@classical.by_contradiction'.{1} (topological_space.{0} (linear_ordered_semiring.{0} fun_info)) h1)  := sorry --non-trivial
lemma new_lemma_135842 (h0 : function.extfun Type (functor.comp finset add_comm_monoid)) : finset.nonempty (functor.comp.run (function.extfun_app h0 unsigned)) := sorry --non-trivial
lemma new_lemma_135843 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_cyclic.{0} (normed_group.{0} empty) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (normed_group.{0} empty))  := sorry --non-trivial
lemma new_lemma_135844 (h0 : functor.add_const (uniform_space (bin_tree empty)) (semiring (semiring empty))) : @separated_space.{0} (bin_tree.{0} empty) (@functor.add_const.run.{0 0} (uniform_space.{0} (bin_tree.{0} empty)) (semiring.{0} (semiring.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_135845 (h0 : ring (has_neg (comm_group (has_add (has_to_string Type))))) : strong_rank_condition (has_neg (comm_group (has_add (has_to_string Type)))) := sorry --non-trivial
lemma new_lemma_135846 (h0 : list (partial_order real)) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_135847 (h0 : ring (has_pos_part (has_Inf linarith.comp))) : is_domain (has_pos_part (has_Inf linarith.comp)) := sorry --non-trivial
lemma new_lemma_135848 (h1 : has_coe (nondiscrete_normed_field enat) Prop) (h2 : nondiscrete_normed_field enat) : @coe_b.{1 1} (nondiscrete_normed_field.{0} enat) Prop h1 h2  := sorry --non-trivial
lemma new_lemma_135849 (h0 : function.extfun Type complete_lattice) : @is_atomistic.{0} (semigroup.{0} name) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (semigroup.{0} name))  := sorry --non-trivial
lemma new_lemma_135850 (h0 : filter (has_bot (option (option empty)))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_135851 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @complete_space.{0} (add_comm_monoid.{0} name) (@function.extfun_app.{2 1} Type uniform_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 uniform_space.{0}) (add_comm_monoid.{0} name))  := sorry --non-trivial
lemma new_lemma_135852 (h0 : not (complete_lattice (normed_field string.iterator_imp) -> false)) : @is_compactly_generated.{0} (normed_field.{0} string.iterator_imp) (@classical.by_contradiction'.{1} (complete_lattice.{0} (normed_field.{0} string.iterator_imp)) h0)  := sorry --non-trivial
lemma new_lemma_135853 (h0 : topological_space (has_top (has_norm (has_norm fun_info)))) : t0_space (has_top (has_norm (has_norm fun_info))) := sorry --non-trivial
lemma new_lemma_135854 (h0 : uniform_space (complete_distrib_lattice Type)) : complete_space (complete_distrib_lattice Type) := sorry --non-trivial
lemma new_lemma_135855 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @complete_lattice.is_Sup_finite_compact.{0} (has_top.{0} unsigned) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (has_top.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_135856 (h0 : ring (non_assoc_semiring num)) : rank_condition (non_assoc_semiring num) := sorry --non-trivial
lemma new_lemma_135857 (h0 : functor.add_const (topological_space (has_zero ennreal)) Type) : @path_connected_space.{0} (has_zero.{0} ennreal) (@functor.add_const.run.{0 1} (topological_space.{0} (has_zero.{0} ennreal)) Type h0)  := sorry --non-trivial
lemma new_lemma_135858 (h0 : cancel_comm_monoid_with_zero (simple_graph pos)) : unique_factorization_monoid (simple_graph pos) := sorry --non-trivial
lemma new_lemma_135859 (h0 : function.extfun Type group) : @normalizer_condition.{0} (has_add.{0} pos) (@function.extfun_app.{2 1} Type group.{0} h0 (has_add.{0} pos))  := sorry --non-trivial
lemma new_lemma_135860 (h0 : function.extfun Type topological_space) : @totally_disconnected_space.{0} (has_to_string.{0} ennreal) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_to_string.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_135861 (h0 : functor.add_const (function.extfun Type topological_space) pos) : @regular_space.{0} (boolean_algebra.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) pos h0) (boolean_algebra.{0} pos))  := sorry --non-trivial
lemma new_lemma_135862 (h0 : set (string.iterator_imp -> add_comm_semigroup (add_comm_semigroup (add_comm_semigroup fun_info)))) : set.separates_points h0 := sorry --non-trivial
lemma new_lemma_135863 (h0 : list (boolean_algebra.core (has_add name))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_135864 (h0 : has_mem.mem topological_space has_emptyc.emptyc) : @totally_disconnected_space.{0} (complete_semilattice_Sup.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) topological_space.{0} h0) (complete_semilattice_Sup.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_135865 (h0 : ring (semiring (has_union (semiring linarith.comp)))) : is_domain (semiring (has_union (semiring linarith.comp))) := sorry --non-trivial
lemma new_lemma_135866 (h0 : functor.add_const (topological_space (semigroup name)) pos) : @loc_path_connected_space.{0} (semigroup.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (semigroup.{0} name)) pos h0)  := sorry --non-trivial
lemma new_lemma_135867 (h0 : functor.add_const (topological_space (ordered_ring empty)) num) : @totally_disconnected_space.{0} (ordered_ring.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (ordered_ring.{0} empty)) num h0)  := sorry --non-trivial
lemma new_lemma_135868 (h0 : complete_lattice (with_bot linarith.comp_source)) : complete_lattice.is_Sup_finite_compact (with_bot linarith.comp_source) := sorry --non-trivial
lemma new_lemma_135869 (h0 : ring (boolean_algebra.core (option (option (option empty))))) : rank_condition (boolean_algebra.core (option (option (option empty)))) := sorry --non-trivial
lemma new_lemma_135870 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @archimedean.{0} (finset.{0} pos) (@function.extfun_app.{2 1} Type ordered_add_comm_monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ordered_add_comm_monoid.{0}) (finset.{0} pos))  := sorry --non-trivial
lemma new_lemma_135871 (h0 : function.extfun Type ordered_add_comm_monoid) : @archimedean.{0} (ordered_comm_group.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type ordered_add_comm_monoid.{0} h0 (ordered_comm_group.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_135872 (h0 : monoid (has_norm (random_gen (random_gen empty)))) : monoid.fg (has_norm (random_gen (random_gen empty))) := sorry --non-trivial
lemma new_lemma_135873 (h0 : topological_space (canonically_ordered_monoid (has_add (has_add linarith.comp)))) : t1_space (canonically_ordered_monoid (has_add (has_add linarith.comp))) := sorry --non-trivial
lemma new_lemma_135874 (h0 : functor.add_const (filter (semigroup Type)) linarith.comp) : countable_Inter_filter (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_135875 (h0 : function.extfun Type (functor.add_const (add_group (has_nndist ennreal)))) : @is_add_cyclic.{0} (has_nndist.{0} ennreal) (@functor.add_const.run.{0 0} (add_group.{0} (has_nndist.{0} ennreal)) empty (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (add_group.{0} (has_nndist.{0} ennreal))) h0 empty))  := sorry --non-trivial
lemma new_lemma_135876 (h0 : function.extfun Type complete_lattice) : @complete_lattice.is_Sup_finite_compact.{0} (linear_ordered_cancel_comm_monoid.{0} unsigned) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (linear_ordered_cancel_comm_monoid.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_135877 (h0 : functor.add_const (filter (has_neg Type)) linarith.comp) : countable_Inter_filter (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_135878 (h0 : ordered_add_comm_monoid (comm_monoid unsigned)) : archimedean (comm_monoid unsigned) := sorry --non-trivial
lemma new_lemma_135879 (h1 : topological_space (simple_graph ereal)) : path_connected_space (simple_graph ereal) := sorry --non-trivial
lemma new_lemma_135880 (h0 : complete_lattice (semigroup unsigned)) : is_atomistic (semigroup unsigned) := sorry --non-trivial
lemma new_lemma_135881 (h0 : semiring (complete_semilattice_Sup unsigned)) : is_noetherian_ring (complete_semilattice_Sup unsigned) := sorry --non-trivial
lemma new_lemma_135882 (h0 : ring (id unsigned)) : strong_rank_condition (id unsigned) := sorry --non-trivial
lemma new_lemma_135883 (h0 : not (uniform_space (normed_group char) -> false)) : @complete_space.{0} (normed_group.{0} char) (@classical.by_contradiction'.{1} (uniform_space.{0} (normed_group.{0} char)) h0)  := sorry --non-trivial
lemma new_lemma_135884 (h0 : group (with_bot (has_norm num))) : normalizer_condition (with_bot (has_norm num)) := sorry --non-trivial
lemma new_lemma_135885 (h0 : functor.add_const (function.extfun (Type 1) topological_space) (ring name)) : @preconnected_space.{1} (generalized_boolean_algebra.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) topological_space.{1}) (ring.{0} name) h0) (generalized_boolean_algebra.{1} Type))  := sorry --non-trivial
lemma new_lemma_135886 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @monoid.fg.{0} (normed_group.{0} (has_top.{0} to_additive.value_type)) (@function.extfun_app.{2 1} Type monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 monoid.{0}) (normed_group.{0} (has_top.{0} to_additive.value_type)))  := sorry --non-trivial
lemma new_lemma_135887 (h0 : group (dlist (has_ssubset linarith.ineq))) : group.fg (dlist (has_ssubset linarith.ineq)) := sorry --non-trivial
lemma new_lemma_135888 (h0 : has_top fun_info -> has_top fun_info -> bool) : is_dec_refl h0 := sorry --non-trivial
lemma new_lemma_135889 (h0 : ring (semigroup environment.implicit_infer_kind)) : strong_rank_condition (semigroup environment.implicit_infer_kind) := sorry --non-trivial
lemma new_lemma_135890 (h1 : ring (normed_field (normed_field char))) : strong_rank_condition (normed_field (normed_field char)) := sorry --non-trivial
lemma new_lemma_135891 (h0 : functor.add_const (ordered_add_comm_monoid (has_bot pos)) real) : @archimedean.{0} (has_bot.{0} pos) (@functor.add_const.run.{0 0} (ordered_add_comm_monoid.{0} (has_bot.{0} pos)) real h0)  := sorry --non-trivial
lemma new_lemma_135892 (h0 : not (topological_space (normed_group linarith.comp_source) -> false)) : @totally_separated_space.{0} (normed_group.{0} linarith.comp_source) (@classical.by_contradiction'.{1} (topological_space.{0} (normed_group.{0} linarith.comp_source)) h0)  := sorry --non-trivial
lemma new_lemma_135893 (h0 : filter (has_neg_part (has_add (comm_group (has_add Type))))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_135894 (h1 : topological_space (dlist string_imp)) : t0_space (dlist string_imp) := sorry --non-trivial
lemma new_lemma_135895 (h0 : uniform_space (linear_ordered_comm_ring (semiring (semiring (semiring (semiring num)))))) : separated_space (linear_ordered_comm_ring (semiring (semiring (semiring (semiring num))))) := sorry --non-trivial
lemma new_lemma_135896 (h0 : topological_space (has_to_string (has_add (has_Inf (has_Inf (has_Inf pos)))))) : irreducible_space (has_to_string (has_add (has_Inf (has_Inf (has_Inf pos))))) := sorry --non-trivial
lemma new_lemma_135897 (h0 : topological_space (dlist (has_nnnorm (has_nnnorm (random_gen to_additive.value_type))))) : path_connected_space (dlist (has_nnnorm (has_nnnorm (random_gen to_additive.value_type)))) := sorry --non-trivial
lemma new_lemma_135898 (h0 : topological_space (has_append (has_nnnorm (comm_ring (random_gen linarith.ineq))))) : t0_space (has_append (has_nnnorm (comm_ring (random_gen linarith.ineq)))) := sorry --non-trivial
lemma new_lemma_135899 (h0 : has_mem.mem uniform_space has_emptyc.emptyc) : @separated_space.{0} (with_bot.{0} fun_info) (@function.extfun_app.{2 1} Type uniform_space.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) uniform_space.{0} h0) (with_bot.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_135900 (h0 : ring (topological_space (random_gen (random_gen char)))) : strong_rank_condition (topological_space (random_gen (random_gen char))) := sorry --non-trivial
lemma new_lemma_135901 (h0 : monoid (ordered_cancel_add_comm_monoid congr_arg_kind)) : monoid.fg (ordered_cancel_add_comm_monoid congr_arg_kind) := sorry --non-trivial
lemma new_lemma_135902 (h0 : topological_space (normed_field linarith.comp_source)) : sequential_space (normed_field linarith.comp_source) := sorry --non-trivial
lemma new_lemma_135903 (h0 : function.extfun Type topological_space) : @totally_disconnected_space.{0} (semiring.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (semiring.{0} empty))  := sorry --non-trivial
lemma new_lemma_135904 (h1 : complete_lattice (distrib (has_ssubset char))) : is_compactly_generated (distrib (has_ssubset char)) := sorry --non-trivial
lemma new_lemma_135905 (h0 : functor.add_const (topological_space (ring environment.implicit_infer_kind)) Type) : @locally_compact_space.{0} (ring.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 1} (topological_space.{0} (ring.{0} environment.implicit_infer_kind)) Type h0)  := sorry --non-trivial
lemma new_lemma_135906 (h0 : functor.add_const (topological_space (linear_ordered_field pos)) num) : @loc_path_connected_space.{0} (linear_ordered_field.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (linear_ordered_field.{0} pos)) num h0)  := sorry --non-trivial
lemma new_lemma_135907 (h0 : not (ring (semi_normed_comm_ring reducibility_hints) -> false)) : @strong_rank_condition.{0} (semi_normed_comm_ring.{0} reducibility_hints) (@classical.by_contradiction'.{1} (ring.{0} (semi_normed_comm_ring.{0} reducibility_hints)) h0)  := sorry --non-trivial
lemma new_lemma_135908 (h0 : uniform_space linarith.ineq) : separated_space linarith.ineq := sorry --non-trivial
lemma new_lemma_135909 (h0 : functor.add_const (ring (is_R_or_C unsigned)) (option empty)) : @strong_rank_condition.{0} (is_R_or_C.{0} unsigned) (@functor.add_const.run.{0 0} (ring.{0} (is_R_or_C.{0} unsigned)) (option.{0} empty) h0)  := sorry --non-trivial
lemma new_lemma_135910 (h0 : monoid (complete_distrib_lattice num)) : monoid.fg (complete_distrib_lattice num) := sorry --non-trivial
lemma new_lemma_135911 (h0 : has_mem.mem (id linarith.comp) has_emptyc.emptyc) : @strong_rank_condition.{0} (@id.{2} Type linarith.comp) (@finset.pi.empty.{1 0} Type ring.{0} (@id.{2} Type linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_135912 (h0 : topological_space (has_bot (has_Inf real))) : irreducible_space (has_bot (has_Inf real)) := sorry --non-trivial
lemma new_lemma_135913 (h0 : function.extfun Type ordered_comm_monoid) : @has_exists_mul_of_le.{0} (normed_comm_ring.{0} ennreal) (@function.extfun_app.{2 1} Type ordered_comm_monoid.{0} h0 (normed_comm_ring.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_135914 (h0 : topological_space (with_one (random_gen (random_gen congr_arg_kind)))) : totally_separated_space (with_one (random_gen (random_gen congr_arg_kind))) := sorry --non-trivial
lemma new_lemma_135915 (h0 : topological_space (measurable_space (has_norm (has_top linarith.ineq)))) : path_connected_space (measurable_space (has_norm (has_top linarith.ineq))) := sorry --non-trivial
lemma new_lemma_135916 (h0 : functor.add_const (topological_space (add_comm_monoid name)) pos) : @totally_disconnected_space.{0} (add_comm_monoid.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (add_comm_monoid.{0} name)) pos h0)  := sorry --non-trivial
lemma new_lemma_135917 (h0 : topological_space (measurable_space (has_inv (has_norm to_additive.value_type)))) : locally_compact_space (measurable_space (has_inv (has_norm to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_135918 (h0 : cancel_comm_monoid_with_zero (linear_ordered_cancel_comm_monoid unsigned)) : unique_factorization_monoid (linear_ordered_cancel_comm_monoid unsigned) := sorry --non-trivial
lemma new_lemma_135919 (h0 : topological_space (id (random_gen (random_gen string_imp)))) : locally_compact_space (id (random_gen (random_gen string_imp))) := sorry --non-trivial
lemma new_lemma_135920 (h0 : not (group (normed_field linarith.ineq) -> false)) : @is_cyclic.{0} (normed_field.{0} linarith.ineq) (@classical.by_contradiction'.{1} (group.{0} (normed_field.{0} linarith.ineq)) h0)  := sorry --non-trivial
lemma new_lemma_135921 (h0 : add_group (add_cancel_monoid (option (option pos)))) : is_add_cyclic (add_cancel_monoid (option (option pos))) := sorry --non-trivial
lemma new_lemma_135922 (h0 : add_group (normed_group (has_norm (has_inv linarith.comp_source)))) : is_add_cyclic (normed_group (has_norm (has_inv linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_135923 (h0 : uniform_space (has_zero (mul_zero_class name))) : complete_space (has_zero (mul_zero_class name)) := sorry --non-trivial
lemma new_lemma_135924 (h0 : filter (complete_distrib_lattice (has_neg_part Type))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_135925 (h0 : functor.add_const (topological_space (has_zero (ring name))) pos) : @irreducible_space.{0} (has_zero.{0} (ring.{0} name)) (@functor.add_const.run.{0 0} (topological_space.{0} (has_zero.{0} (ring.{0} name))) pos h0)  := sorry --non-trivial
lemma new_lemma_135926 (h0 : functor.add_const (topological_space (complete_distrib_lattice name)) Type) : @preirreducible_space.{0} (complete_distrib_lattice.{0} name) (@functor.add_const.run.{0 1} (topological_space.{0} (complete_distrib_lattice.{0} name)) Type h0)  := sorry --non-trivial
lemma new_lemma_135927 (h0 : topological_space (canonically_ordered_monoid (sub_neg_monoid real))) : totally_disconnected_space (canonically_ordered_monoid (sub_neg_monoid real)) := sorry --non-trivial
lemma new_lemma_135928 (h0 : function.extfun nat fin) : @is_add_cyclic.{0} (simple_graph.{0} linarith.comp) (@matrix.vec_empty.{0} (add_group.{0} (simple_graph.{0} linarith.comp)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_135929 (h0 : not (ring (has_top linarith.comp) -> false)) : @strong_rank_condition.{0} (has_top.{0} linarith.comp) (@classical.by_contradiction'.{1} (ring.{0} (has_top.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_135930 (h1 : topological_space (nondiscrete_normed_field string.iterator_imp)) : t0_space (nondiscrete_normed_field string.iterator_imp) := sorry --non-trivial
lemma new_lemma_135931 (h0 : topological_space (add_comm_semigroup linarith.ineq)) : locally_compact_space (add_comm_semigroup linarith.ineq) := sorry --non-trivial
lemma new_lemma_135932 (h0 : function.extfun Type topological_space) : @totally_separated_space.{0} (ordered_ring.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (ordered_ring.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_135933 (h0 : topological_space (semigroup (has_neg linarith.comp))) : totally_disconnected_space (semigroup (has_neg linarith.comp)) := sorry --non-trivial
lemma new_lemma_135934 (h0 : group (has_add (add_comm_monoid (has_neg name)))) : normalizer_condition (has_add (add_comm_monoid (has_neg name))) := sorry --non-trivial
lemma new_lemma_135935 (h0 : has_mem.mem group has_emptyc.emptyc) : @is_cyclic.{0} (semiring.{0} fun_info) (@function.extfun_app.{2 1} Type group.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) group.{0} h0) (semiring.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_135936 (h0 : not (topological_space (div_inv_monoid char) -> false)) : @path_connected_space.{0} (div_inv_monoid.{0} char) (@classical.by_contradiction'.{1} (topological_space.{0} (div_inv_monoid.{0} char)) h0)  := sorry --non-trivial
lemma new_lemma_135937 (h0 : topological_space (semigroup (finset Type))) : discrete_topology (semigroup (finset Type)) := sorry --non-trivial
lemma new_lemma_135938 (h0 : functor.add_const (ring (complete_distrib_lattice environment.implicit_infer_kind)) (has_neg_part linarith.comp)) : @is_principal_ideal_ring.{0} (complete_distrib_lattice.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (ring.{0} (complete_distrib_lattice.{0} environment.implicit_infer_kind)) (has_neg_part.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_135939 (h0 : functor.add_const (ring (add_comm_monoid linarith.comp)) name) : @is_principal_ideal_ring.{0} (add_comm_monoid.{0} linarith.comp) (@functor.add_const.run.{0 0} (ring.{0} (add_comm_monoid.{0} linarith.comp)) name h0)  := sorry --non-trivial
lemma new_lemma_135940 (h0 : topological_space (random_gen (comm_ring linarith.ineq))) : totally_disconnected_space (random_gen (comm_ring linarith.ineq)) := sorry --non-trivial
lemma new_lemma_135941 (h0 : group (monoid_with_zero (option (option unsigned)))) : is_cyclic (monoid_with_zero (option (option unsigned))) := sorry --non-trivial
lemma new_lemma_135942 (h0 : list (has_ssubset to_additive.value_type)) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_135943 (h0 : functor.add_const (semiring (semigroup pos)) linarith.comp) : @is_noetherian_ring.{0} (semigroup.{0} pos) (@functor.add_const.run.{0 0} (semiring.{0} (semigroup.{0} pos)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_135944 (h1 : ring (comm_ring to_additive.value_type)) : strong_rank_condition (comm_ring to_additive.value_type) := sorry --non-trivial
lemma new_lemma_135945 (h0 : uniform_space (has_compl (has_nnnorm linarith.ineq))) : complete_space (has_compl (has_nnnorm linarith.ineq)) := sorry --non-trivial
lemma new_lemma_135946 (h0 : function.extfun Type topological_space) : @t0_space.{0} num (@function.extfun_app.{2 1} Type topological_space.{0} h0 num)  := sorry --non-trivial
lemma new_lemma_135947 (h0 : list (add_cancel_monoid (add_comm_monoid name))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_135948 (h0 : topological_space (has_nndist (finset pos))) : topological_space.separable_space (has_nndist (finset pos)) := sorry --non-trivial
lemma new_lemma_135949 (h0 : functor.add_const (topological_space (ring unsigned)) name) : @irreducible_space.{0} (ring.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (ring.{0} unsigned)) name h0)  := sorry --non-trivial
lemma new_lemma_135950 (h0 : complete_lattice (fintype to_additive.value_type)) : is_compactly_generated (fintype to_additive.value_type) := sorry --non-trivial
lemma new_lemma_135951 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @add_monoid.fg.{0} (has_union.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type add_monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 add_monoid.{0}) (has_union.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_135952 (h0 : ring (sub_neg_monoid (has_Inf linarith.comp))) : rank_condition (sub_neg_monoid (has_Inf linarith.comp)) := sorry --non-trivial
lemma new_lemma_135953 (h0 : topological_space (cancel_monoid name)) : discrete_topology (cancel_monoid name) := sorry --non-trivial
lemma new_lemma_135954 (h0 : finset (semigroup (has_neg (has_neg pos)))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_135955 (h0 : uniform_space (non_unital_non_assoc_semiring (add_group reducibility_hints))) : complete_space (non_unital_non_assoc_semiring (add_group reducibility_hints)) := sorry --non-trivial
lemma new_lemma_135956 (h0 : topological_space (with_one (has_norm num))) : locally_compact_space (with_one (has_norm num)) := sorry --non-trivial
lemma new_lemma_135957 (h0 : group (id fun_info)) : is_cyclic (id fun_info) := sorry --non-trivial
lemma new_lemma_135958 (h0 : uniform_space (simple_graph (has_add linarith.comp))) : complete_space (simple_graph (has_add linarith.comp)) := sorry --non-trivial
lemma new_lemma_135959 (h0 : functor.add_const (function.extfun (Type 1) ring) Type) : @is_principal_ideal_ring.{1} (has_nndist.{1} Type) (@function.extfun_app.{3 2} (Type 1) ring.{1} (@functor.add_const.run.{2 1} (function.extfun.{3 2} (Type 1) ring.{1}) Type h0) (has_nndist.{1} Type))  := sorry --non-trivial
lemma new_lemma_135960 (h0 : topological_space (has_Sup congr_arg_kind)) : normal_space (has_Sup congr_arg_kind) := sorry --non-trivial
lemma new_lemma_135961 (h0 : topological_space (simple_graph (finset Type))) : preirreducible_space (simple_graph (finset Type)) := sorry --non-trivial
lemma new_lemma_135962 (h0 : function.extfun Type semiring) : @is_noetherian_ring.{0} (generalized_boolean_algebra.{0} name) (@function.extfun_app.{2 1} Type semiring.{0} h0 (generalized_boolean_algebra.{0} name))  := sorry --non-trivial
lemma new_lemma_135963 (h0 : functor.add_const (topological_space (left_cancel_monoid congr_arg_kind)) num) : @irreducible_space.{0} (left_cancel_monoid.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (left_cancel_monoid.{0} congr_arg_kind)) num h0)  := sorry --non-trivial
lemma new_lemma_135964 (h0 : topological_space (random_gen (semiring unsigned))) : normal_space (random_gen (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_135965 (h0 : topological_space reducibility_hints) (h1 : uniform_space (canonically_ordered_add_monoid (measure_theory.content reducibility_hints))) : complete_space (canonically_ordered_add_monoid (measure_theory.content reducibility_hints)) := sorry --non-trivial
lemma new_lemma_135966 (h0 : not (ring (has_union congr_arg_kind) -> false)) : @is_principal_ideal_ring.{0} (has_union.{0} congr_arg_kind) (@classical.by_contradiction'.{1} (ring.{0} (has_union.{0} congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_135967 (h0 : list (has_add (has_neg_part (has_neg_part Type)))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_135968 (h0 : topological_space (normed_field (has_nnnorm (random_gen (uniform_space reducibility_hints))))) : t0_space (normed_field (has_nnnorm (random_gen (uniform_space reducibility_hints)))) := sorry --non-trivial
lemma new_lemma_135969 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @discrete_topology.{0} (option.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (option.{0} num))  := sorry --non-trivial
lemma new_lemma_135970 (h1 : ring (dlist (random_gen (random_gen to_additive.value_type)))) : is_domain (dlist (random_gen (random_gen to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_135971 (h3 : uniform_space (random_gen linarith.comp_source)) : complete_space (random_gen linarith.comp_source) := sorry --non-trivial
lemma new_lemma_135972 (h0 : uniform_space (has_add char)) (h1 : complete_lattice (uniform_space.separation_quotient (has_add char))) : complete_lattice.is_Sup_finite_compact (uniform_space.separation_quotient (has_add char)) := sorry --non-trivial
lemma new_lemma_135973 (h0 : group (topological_space (mul_one_class (mul_one_class char)))) : is_cyclic (topological_space (mul_one_class (mul_one_class char))) := sorry --non-trivial
lemma new_lemma_135974 (h0 : function.extfun Type ring) : @rank_condition.{0} fun_info (@function.extfun_app.{2 1} Type ring.{0} h0 fun_info)  := sorry --non-trivial
lemma new_lemma_135975 (h0 : functor.add_const (topological_space (has_add name)) linarith.comp) : @normal_space.{0} (has_add.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (has_add.{0} name)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_135976 (h0 : fin has_zero.zero) : @complete_space.{0} (has_bot.{0} real) (@function.extfun_app.{2 1} Type uniform_space.{0} (@matrix.vec_empty.{1} (function.extfun.{2 1} Type uniform_space.{0}) h0) (has_bot.{0} real))  := sorry --non-trivial
lemma new_lemma_135977 (h0 : group (distrib linarith.ineq)) : group.fg (distrib linarith.ineq) := sorry --non-trivial
lemma new_lemma_135978 (h0 : topological_space (bin_tree (semiring unsigned))) : totally_separated_space (bin_tree (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_135979 (h0 : pnat) (h1 : ulower pnat) : pnat.coprime h0 (ulower.up h1) := sorry --non-trivial
lemma new_lemma_135980 (h0 : functor.add_const (topological_space (has_zero Type)) Type) : @irreducible_space.{1} (has_zero.{1} Type) (@functor.add_const.run.{1 1} (topological_space.{1} (has_zero.{1} Type)) Type h0)  := sorry --non-trivial
lemma new_lemma_135981 (h1 : topological_space (add_monoid (has_nnnorm linarith.comp_source))) : path_connected_space (add_monoid (has_nnnorm linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_135982 (h1 : ring (has_nnnorm (complete_semilattice_Sup (encodable char)))) : is_domain (has_nnnorm (complete_semilattice_Sup (encodable char))) := sorry --non-trivial
lemma new_lemma_135983 (h0 : function.extfun (finset Type -> Prop) (function.extfun (finset Type))) : @is_domain.{0} fun_info (@finset.pi.empty.{1 0} Type ring.{0} fun_info (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) fun_info) (@function.extfun_app.{2 0} (finset.{1} Type → Prop) (function.extfun.{2 0} (finset.{1} Type)) h0 (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) fun_info)) (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_135984 (h0 : topological_space (with_bot linarith.ineq)) : irreducible_space (with_bot linarith.ineq) := sorry --non-trivial
lemma new_lemma_135985 (h0 : topological_space (distrib (mul_one_class to_additive.value_type))) : path_connected_space (distrib (mul_one_class to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_135986 (h0 : list (id (has_top linarith.ineq))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_135987 (h1 : ring (encodable char)) : strong_rank_condition (encodable char) := sorry --non-trivial
lemma new_lemma_135988 (h0 : order_hom nat (topological_space (topological_space fun_info))) : @t0_space.{0} (topological_space.{0} fun_info) (@monotonic_sequence_limit.{0} (topological_space.{0} (topological_space.{0} fun_info)) (@topological_space.partial_order.{0} (topological_space.{0} fun_info)) h0)  := sorry --non-trivial
lemma new_lemma_135989 (h0 : filter (linear_ordered_comm_monoid_with_zero (option empty))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_135990 (h0 : complete_lattice (linear_ordered_add_comm_group (has_nnnorm (has_nnnorm fun_info)))) : is_compactly_generated (linear_ordered_add_comm_group (has_nnnorm (has_nnnorm fun_info))) := sorry --non-trivial
lemma new_lemma_135991 (h0 : function.extfun Type topological_space) : @locally_compact_space.{0} (has_bot.{0} real) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_bot.{0} real))  := sorry --non-trivial
lemma new_lemma_135992 (h0 : functor.add_const (group (has_bot linarith.comp)) linarith.comp) : @is_simple_group.{0} (has_bot.{0} linarith.comp) (@functor.add_const.run.{0 0} (group.{0} (has_bot.{0} linarith.comp)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_135993 (h0 : function.extfun Type filter) : countable_Inter_filter (function.extfun_app h0 (group_with_zero congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_135994 (h0 : ring (ordered_cancel_add_comm_monoid (option (option (option ennreal))))) : is_domain (ordered_cancel_add_comm_monoid (option (option (option ennreal)))) := sorry --non-trivial
lemma new_lemma_135995 (h0 : functor.add_const (group (semiring congr_arg_kind)) num) : @group.fg.{0} (semiring.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (group.{0} (semiring.{0} congr_arg_kind)) num h0)  := sorry --non-trivial
lemma new_lemma_135996 (h0 : function.extfun Type cancel_comm_monoid_with_zero) : @unique_factorization_monoid.{0} (monoid.{0} unsigned) (@function.extfun_app.{2 1} Type cancel_comm_monoid_with_zero.{0} h0 (monoid.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_135997 (h0 : not (group (has_norm unsigned) -> false)) : @is_cyclic.{0} (has_norm.{0} unsigned) (@classical.by_contradiction'.{1} (group.{0} (has_norm.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_135998 (h0 : topological_space (cancel_monoid (has_neg_part environment.implicit_infer_kind))) : sequential_space (cancel_monoid (has_neg_part environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_135999 (h0 : has_mem.mem fun_info has_emptyc.emptyc) : @is_atomistic.{0} fun_info (@finset.pi.empty.{1 0} Type complete_lattice.{0} fun_info h0)  := sorry --non-trivial
