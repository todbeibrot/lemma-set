lemma new_lemma_1 (h0 : topological_space (has_nndist (has_to_string pos))) : t1_space (has_nndist (has_to_string pos)) := sorry --non-trivial
lemma new_lemma_2 (h1 : topological_space (distrib_lattice (has_nnnorm (has_nnnorm (has_nnnorm char))))) : totally_disconnected_space (distrib_lattice (has_nnnorm (has_nnnorm (has_nnnorm char)))) := sorry --non-trivial
lemma new_lemma_3 (h0 : function.extfun Type uniform_space) : @complete_space.{0} (comm_ring.{0} (has_nnnorm.{0} (has_nnnorm.{0} linarith.comp_source))) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (comm_ring.{0} (has_nnnorm.{0} (has_nnnorm.{0} linarith.comp_source))))  := sorry --non-trivial
lemma new_lemma_4 (h0 : ring (has_nndist (add_cancel_monoid Type))) : strong_rank_condition (has_nndist (add_cancel_monoid Type)) := sorry --non-trivial
lemma new_lemma_5 (h0 : function.extfun Type filter) : countable_Inter_filter (function.extfun_app h0 (canonically_ordered_comm_semiring unsigned)) := sorry --non-trivial
lemma new_lemma_6 (h0 : functor.add_const (topological_space (ring unsigned)) linarith.comp) : @irreducible_space.{0} (ring.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (ring.{0} unsigned)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_7 (h0 : function.extfun Type uniform_space) : @separated_space.{0} (with_one.{0} unsigned) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (with_one.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_8 (h2 : add_group (add_monoid (has_nnnorm to_additive.value_type))) : is_add_cyclic (add_monoid (has_nnnorm to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_9 (h0 : monoid (ordered_comm_monoid (has_add (sub_neg_monoid (sub_neg_monoid real))))) : monoid.fg (ordered_comm_monoid (has_add (sub_neg_monoid (sub_neg_monoid real)))) := sorry --non-trivial
lemma new_lemma_10 (h0 : ring (linear_ordered_add_comm_group (has_compl char))) : is_domain (linear_ordered_add_comm_group (has_compl char)) := sorry --non-trivial
lemma new_lemma_11 (h0 : measurable_space (add_monoid to_additive.value_type)) (h1 : function.extfun Type has_add) : @has_measurable_add.{0} (add_monoid.{0} to_additive.value_type) h0 (@function.extfun_app.{2 1} Type has_add.{0} h1 (add_monoid.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_12 (h0 : functor.add_const (filter (has_add unsigned)) pos) : filter.ne_bot (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_13 (h0 : not (ring (has_append string_imp) -> false)) : @is_domain.{0} (has_append.{0} string_imp) (@classical.by_contradiction'.{1} (ring.{0} (has_append.{0} string_imp)) h0)  := sorry --non-trivial
lemma new_lemma_14 (h0 : topological_space (measure_theory.measure_space (has_star (has_star num)))) : topological_space.separable_space (measure_theory.measure_space (has_star (has_star num))) := sorry --non-trivial
lemma new_lemma_15 (h0 : not (function.extfun Type complete_lattice -> false)) : @is_atomistic.{0} (with_bot.{0} num) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type complete_lattice.{0}) h0) (with_bot.{0} num))  := sorry --non-trivial
lemma new_lemma_16 (h1 : topological_space (mul_one_class string.iterator_imp)) (h2 : set (mul_one_class string.iterator_imp)) : is_path_connected h2 := sorry --non-trivial
lemma new_lemma_17 (h0 : functor.add_const (complete_lattice (ring Type)) pos) : @complete_lattice.is_Sup_finite_compact.{1} (ring.{1} Type) (@functor.add_const.run.{1 0} (complete_lattice.{1} (ring.{1} Type)) pos h0)  := sorry --non-trivial
lemma new_lemma_18 (h0 : list (has_to_string (has_to_string pos))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_19 (h0 : function.extfun Type complete_lattice) : @is_compactly_generated.{0} (option.{0} (option.{0} ennreal)) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (option.{0} (option.{0} ennreal)))  := sorry --non-trivial
lemma new_lemma_20 (h0 : has_mem.mem complete_lattice has_emptyc.emptyc) : @is_compactly_generated.{0} (with_one.{0} linarith.comp) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) complete_lattice.{0} h0) (with_one.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_21 (h0 : topological_space (mul_one_class (mul_one_class (mul_one_class (add_comm_semigroup std_gen))))) : path_connected_space (mul_one_class (mul_one_class (mul_one_class (add_comm_semigroup std_gen)))) := sorry --non-trivial
lemma new_lemma_22 (h0 : functor.add_const (finset (option ennreal)) ennreal) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_23 (h0 : functor.add_const (uniform_space (finset Type)) linarith.comp) : @separated_space.{1} (finset.{1} Type) (@functor.add_const.run.{1 0} (uniform_space.{1} (finset.{1} Type)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_24 (h0 : complete_lattice (semigroup (add_comm_monoid (has_add Type)))) : is_compactly_generated (semigroup (add_comm_monoid (has_add Type))) := sorry --non-trivial
lemma new_lemma_25 (h0 : ring (canonically_linear_ordered_monoid (has_bot real))) : is_principal_ideal_ring (canonically_linear_ordered_monoid (has_bot real)) := sorry --non-trivial
lemma new_lemma_26 (h0 : functor.add_const (uniform_space (comm_group pos)) name) : @separated_space.{0} (comm_group.{0} pos) (@functor.add_const.run.{0 0} (uniform_space.{0} (comm_group.{0} pos)) name h0)  := sorry --non-trivial
lemma new_lemma_27 (h0 : not (function.extfun Type complete_lattice -> false)) : @is_atomistic.{0} (@id.{2} Type congr_arg_kind) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type complete_lattice.{0}) h0) (@id.{2} Type congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_28 (h0 : group (has_Sup num)) : normalizer_condition (has_Sup num) := sorry --non-trivial
lemma new_lemma_29 (h0 : ring (has_neg (has_add Type))) : rank_condition (has_neg (has_add Type)) := sorry --non-trivial
lemma new_lemma_30 (h0 : function.extfun (nat -> Type) (function.extfun nat)) : @regular_space.{1} (canonically_linear_ordered_monoid.{1} Type) (@matrix.vec_empty.{1} (topological_space.{1} (canonically_linear_ordered_monoid.{1} Type)) (@function.extfun_app.{1 1} nat fin (@function.extfun_app.{2 1} (nat → Type) (function.extfun.{1 1} nat) h0 fin) (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_31 (h0 : has_mem.mem (normed_group unsigned) has_emptyc.emptyc) : @totally_disconnected_space.{0} (normed_group.{0} unsigned) (@finset.pi.empty.{1 0} Type topological_space.{0} (normed_group.{0} unsigned) h0)  := sorry --non-trivial
lemma new_lemma_32 (h0 : function.extfun (finset Type) (has_mem.mem (has_top fun_info))) : @strong_rank_condition.{0} (has_top.{0} fun_info) (@finset.pi.empty.{1 0} Type ring.{0} (has_top.{0} fun_info) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (has_top.{0} fun_info)) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_33 (h0 : topological_space (measurable_space (has_norm (semiring empty)))) : preirreducible_space (measurable_space (has_norm (semiring empty))) := sorry --non-trivial
lemma new_lemma_34 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @normal_space.{0} (has_neg.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_neg.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_35 (h0 : function.extfun Type add_group) : @is_add_cyclic.{0} (has_emptyc.{0} linarith.ineq) (@function.extfun_app.{2 1} Type add_group.{0} h0 (has_emptyc.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_36 (h0 : ordered_comm_monoid (sub_neg_monoid (ordered_comm_monoid (has_pos_part linarith.comp)))) : has_exists_mul_of_le (sub_neg_monoid (ordered_comm_monoid (has_pos_part linarith.comp))) := sorry --non-trivial
lemma new_lemma_37 (h0 : topological_space (normed_lattice_add_comm_group real)) : path_connected_space (normed_lattice_add_comm_group real) := sorry --non-trivial
lemma new_lemma_38 (h0 : add_group (semigroup (has_add pos))) : is_add_cyclic (semigroup (has_add pos)) := sorry --non-trivial
lemma new_lemma_39 (h0 : filter (measurable_space (random_gen num))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_40 (h0 : functor.add_const (topological_space (partial_order num)) num) : @topological_space.separable_space.{0} (partial_order.{0} num) (@functor.add_const.run.{0 0} (topological_space.{0} (partial_order.{0} num)) num h0)  := sorry --non-trivial
lemma new_lemma_41 (h0 : semiring (plift (semiring empty))) : is_noetherian_ring (plift (semiring empty)) := sorry --non-trivial
lemma new_lemma_42 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : list.nodup (function.extfun_app (function.extfun_app h0 list) (option name)) := sorry --non-trivial
lemma new_lemma_43 (h1 : ring (uniform_space (denumerable (metric_space reducibility_hints)))) : rank_condition (uniform_space (denumerable (metric_space reducibility_hints))) := sorry --non-trivial
lemma new_lemma_44 (h0 : has_mem.mem (semiring empty) has_emptyc.emptyc) : @locally_compact_space.{0} (semiring.{0} empty) (@finset.pi.empty.{1 0} Type topological_space.{0} (semiring.{0} empty) h0)  := sorry --non-trivial
lemma new_lemma_45 (h0 : function.extfun Type complete_lattice) : @is_compactly_generated.{0} (simple_graph.{0} linarith.comp) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (simple_graph.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_46 (h0 : functor.add_const (complete_lattice (ring empty)) empty) : @is_compactly_generated.{0} (ring.{0} empty) (@functor.add_const.run.{0 0} (complete_lattice.{0} (ring.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_47 (h0 : functor.add_const (ordered_add_comm_monoid (add_cancel_monoid pos)) pos) : @archimedean.{0} (add_cancel_monoid.{0} pos) (@functor.add_const.run.{0 0} (ordered_add_comm_monoid.{0} (add_cancel_monoid.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_48 (h0 : functor.add_const (topological_space (partial_order congr_arg_kind)) num) : @totally_separated_space.{0} (partial_order.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (partial_order.{0} congr_arg_kind)) num h0)  := sorry --non-trivial
lemma new_lemma_49 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @complete_space.{0} (as_linear_order.{0} empty) (@function.extfun_app.{2 1} Type uniform_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 uniform_space.{0}) (as_linear_order.{0} empty))  := sorry --non-trivial
lemma new_lemma_50 (h0 : not (ring (linear_ordered_add_comm_group fun_info) -> false)) : @rank_condition.{0} (linear_ordered_add_comm_group.{0} fun_info) (@classical.by_contradiction'.{1} (ring.{0} (linear_ordered_add_comm_group.{0} fun_info)) h0)  := sorry --non-trivial
lemma new_lemma_51 (h0 : fin has_zero.zero) : @is_simple_group.{0} (ordered_comm_ring.{0} real) (@matrix.vec_empty.{0} (group.{0} (ordered_comm_ring.{0} real)) h0)  := sorry --non-trivial
lemma new_lemma_52 (h0 : uniform_space (has_inner pos pos)) : complete_space (has_inner pos pos) := sorry --non-trivial
lemma new_lemma_53 (h0 : topological_space (has_lt (mul_one_class linarith.comp_source))) : path_connected_space (has_lt (mul_one_class linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_54 (h1 : function.extfun Type ring) : @is_domain.{0} (has_top.{0} string_imp) (@function.extfun_app.{2 1} Type ring.{0} h1 (has_top.{0} string_imp))  := sorry --non-trivial
lemma new_lemma_55 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_principal_ideal_ring.{0} (canonically_ordered_comm_semiring.{0} unsigned) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (canonically_ordered_comm_semiring.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_56 (h0 h1 : linarith.ineq -> char) : set.separates_points (set.Ioc h0 h1) := sorry --non-trivial
lemma new_lemma_57 (h0 : not (topological_space (has_union unsigned) -> false)) : @t0_space.{0} (has_union.{0} unsigned) (@classical.by_contradiction'.{1} (topological_space.{0} (has_union.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_58 (h0 : ordered_comm_monoid (has_Inf (has_to_string Type))) : has_exists_mul_of_le (has_Inf (has_to_string Type)) := sorry --non-trivial
lemma new_lemma_59 (h0 : topological_space (finset (finset (has_add pos)))) : totally_separated_space (finset (finset (has_add pos))) := sorry --non-trivial
lemma new_lemma_60 (h0 : uniform_space (comm_group (add_comm_monoid pos))) : complete_space (comm_group (add_comm_monoid pos)) := sorry --non-trivial
lemma new_lemma_61 (h0 : topological_space (has_neg_part name)) : loc_path_connected_space (has_neg_part name) := sorry --non-trivial
lemma new_lemma_62 (h0 : measurable_space std_gen) (h1 : measure_theory.measure std_gen) : measure_theory.has_no_atoms h1 := sorry --non-trivial
lemma new_lemma_63 (h0 : add_group (topological_space string_imp)) : is_add_cyclic (topological_space string_imp) := sorry --non-trivial
lemma new_lemma_64 (h0 : functor.add_const (group (has_zero pos)) name) : @group.fg.{0} (has_zero.{0} pos) (@functor.add_const.run.{0 0} (group.{0} (has_zero.{0} pos)) name h0)  := sorry --non-trivial
lemma new_lemma_65 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : list.nodup (function.extfun_app (function.extfun_app h0 list) (ring name)) := sorry --non-trivial
lemma new_lemma_66 (h0 : functor.add_const (ring (has_to_string pos)) (boolean_algebra pos)) : @is_domain.{0} (has_to_string.{0} pos) (@functor.add_const.run.{0 0} (ring.{0} (has_to_string.{0} pos)) (boolean_algebra.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_67 (h0 : semiring (measurable_space.dynkin_system (semiring (semiring (semiring (semiring num)))))) : is_noetherian_ring (measurable_space.dynkin_system (semiring (semiring (semiring (semiring num))))) := sorry --non-trivial
lemma new_lemma_68 (h0 : list (normed_group unsigned)) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_69 (h0 : topological_space (mul_one_class (mul_one_class char))) : totally_disconnected_space (mul_one_class (mul_one_class char)) := sorry --non-trivial
lemma new_lemma_70 (h0 : add_group (measurable_space (with_bot linarith.comp))) : is_add_cyclic (measurable_space (with_bot linarith.comp)) := sorry --non-trivial
lemma new_lemma_71 (h0 : ring (has_pos_part (has_add Type))) : is_principal_ideal_ring (has_pos_part (has_add Type)) := sorry --non-trivial
lemma new_lemma_72 (h0 : topological_space (has_neg pos)) : totally_disconnected_space (has_neg pos) := sorry --non-trivial
lemma new_lemma_73 (h0 : function.extfun Type ring) : @is_domain.{0} (complete_semilattice_Sup.{0} fun_info) (@function.extfun_app.{2 1} Type ring.{0} h0 (complete_semilattice_Sup.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_74 (h0 : complete_lattice (has_emptyc fun_info)) : complete_lattice.is_Sup_finite_compact (has_emptyc fun_info) := sorry --non-trivial
lemma new_lemma_75 (h0 : not (group (normed_group congr_arg_kind) -> false)) : @is_cyclic.{0} (normed_group.{0} congr_arg_kind) (@classical.by_contradiction'.{1} (group.{0} (normed_group.{0} congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_76 (h0 : topological_space (has_nndist (has_nndist name))) : t0_space (has_nndist (has_nndist name)) := sorry --non-trivial
lemma new_lemma_77 (h0 : function.extfun (Type 1) topological_space) : @regular_space.{1} (cancel_monoid.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} h0 (cancel_monoid.{1} Type))  := sorry --non-trivial
lemma new_lemma_78 (h0 : functor.add_const (topological_space environment.implicit_infer_kind) Type) : @totally_disconnected_space.{0} environment.implicit_infer_kind (@functor.add_const.run.{0 1} (topological_space.{0} environment.implicit_infer_kind) Type h0)  := sorry --non-trivial
lemma new_lemma_79 (h0 : group (has_sub empty)) : is_cyclic (has_sub empty) := sorry --non-trivial
lemma new_lemma_80 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @archimedean.{0} (ring.{0} (has_add.{0} environment.implicit_infer_kind)) (@function.extfun_app.{2 1} Type ordered_add_comm_monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ordered_add_comm_monoid.{0}) (ring.{0} (has_add.{0} environment.implicit_infer_kind)))  := sorry --non-trivial
lemma new_lemma_81 (h0 : list (normed_group (semiring unsigned))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_82 (h0 : functor.add_const (topological_space (boolean_algebra Type)) pos) : @totally_separated_space.{1} (boolean_algebra.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (boolean_algebra.{1} Type)) pos h0)  := sorry --non-trivial
lemma new_lemma_83 (h0 : functor.add_const (ring (mul_zero_class name)) ennreal) : @strong_rank_condition.{0} (mul_zero_class.{0} name) (@functor.add_const.run.{0 0} (ring.{0} (mul_zero_class.{0} name)) ennreal h0)  := sorry --non-trivial
lemma new_lemma_84 (h0 : functor.add_const (topological_space (has_nndist Type)) Type) : @irreducible_space.{1} (has_nndist.{1} Type) (@functor.add_const.run.{1 1} (topological_space.{1} (has_nndist.{1} Type)) Type h0)  := sorry --non-trivial
lemma new_lemma_85 (h0 : not (ring (add_monoid linarith.ineq) -> false)) : @is_domain.{0} (add_monoid.{0} linarith.ineq) (@classical.by_contradiction'.{1} (ring.{0} (add_monoid.{0} linarith.ineq)) h0)  := sorry --non-trivial
lemma new_lemma_86 (h0 : topological_space (boolean_algebra.core (has_Inf (has_add linarith.comp)))) : path_connected_space (boolean_algebra.core (has_Inf (has_add linarith.comp))) := sorry --non-trivial
lemma new_lemma_87 (h0 : function.extfun Type topological_space) : @t0_space.{0} (has_neg.{0} (option.{0} ennreal)) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_neg.{0} (option.{0} ennreal)))  := sorry --non-trivial
lemma new_lemma_88 (h0 : ordered_add_comm_monoid (has_to_string congr_arg_kind)) : archimedean (has_to_string congr_arg_kind) := sorry --non-trivial
lemma new_lemma_89 (h0 : semiring (boolean_algebra (has_to_string (comm_group unsigned)))) : is_noetherian_ring (boolean_algebra (has_to_string (comm_group unsigned))) := sorry --non-trivial
lemma new_lemma_90 (h0 : not (has_mem.mem (semiring linarith.comp_source) has_emptyc.emptyc -> false)) : @rank_condition.{0} (semiring.{0} linarith.comp_source) (@finset.pi.empty.{1 0} Type ring.{0} (semiring.{0} linarith.comp_source) (@classical.by_contradiction'.{0} (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (semiring.{0} linarith.comp_source) (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))) h0))  := sorry --non-trivial
lemma new_lemma_91 (h0 : monoid (normed_comm_ring (has_neg (finset (finset linarith.comp))))) : monoid.fg (normed_comm_ring (has_neg (finset (finset linarith.comp)))) := sorry --non-trivial
lemma new_lemma_92 (h0 : functor.add_const (ring (left_cancel_monoid empty)) empty) : @is_domain.{0} (left_cancel_monoid.{0} empty) (@functor.add_const.run.{0 0} (ring.{0} (left_cancel_monoid.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_93 (h0 : add_monoid (simple_graph (option empty))) : add_monoid.fg (simple_graph (option empty)) := sorry --non-trivial
lemma new_lemma_94 (h0 : ring (has_norm (semiring fun_info))) : strong_rank_condition (has_norm (semiring fun_info)) := sorry --non-trivial
lemma new_lemma_95 (h0 : topological_space (has_nnnorm string.iterator_imp)) : totally_disconnected_space (has_nnnorm string.iterator_imp) := sorry --non-trivial
lemma new_lemma_96 (h0 : functor.add_const (ordered_comm_monoid (complete_distrib_lattice pos)) pos) : @has_exists_mul_of_le.{0} (complete_distrib_lattice.{0} pos) (@functor.add_const.run.{0 0} (ordered_comm_monoid.{0} (complete_distrib_lattice.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_97 (h0 : ring (add_cancel_monoid (comm_group (comm_group pos)))) : is_principal_ideal_ring (add_cancel_monoid (comm_group (comm_group pos))) := sorry --non-trivial
lemma new_lemma_98 (h0 : function.extfun Type group) : @is_simple_group.{0} (has_Inf.{0} linarith.comp) (@function.extfun_app.{2 1} Type group.{0} h0 (has_Inf.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_99 (h0 : topological_space (has_to_string (has_to_string (comm_group Type)))) : totally_separated_space (has_to_string (has_to_string (comm_group Type))) := sorry --non-trivial
lemma new_lemma_100 (h0 : functor.add_const (monoid (preorder num)) empty) : @monoid.fg.{0} (preorder.{0} num) (@functor.add_const.run.{0 0} (monoid.{0} (preorder.{0} num)) empty h0)  := sorry --non-trivial
lemma new_lemma_101 (h0 : complete_lattice (has_div environment.projection_info)) : complete_lattice.is_Sup_finite_compact (has_div environment.projection_info) := sorry --non-trivial
lemma new_lemma_102 (h0 : topological_space (normed_comm_ring unsigned)) : locally_compact_space (normed_comm_ring unsigned) := sorry --non-trivial
lemma new_lemma_103 (h0 : not (complete_lattice empty -> false)) : @complete_lattice.is_Sup_finite_compact.{0} empty (@classical.by_contradiction'.{1} (complete_lattice.{0} empty) h0)  := sorry --non-trivial
lemma new_lemma_104 (h0 : functor.add_const (ring (has_neg linarith.comp)) (has_neg name)) : @strong_rank_condition.{0} (has_neg.{0} linarith.comp) (@functor.add_const.run.{0 0} (ring.{0} (has_neg.{0} linarith.comp)) (has_neg.{0} name) h0)  := sorry --non-trivial
lemma new_lemma_105 (h0 : complete_lattice (normed_comm_ring (comm_group (finset linarith.comp)))) : is_compactly_generated (normed_comm_ring (comm_group (finset linarith.comp))) := sorry --non-trivial
lemma new_lemma_106 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @normal_space.{0} (ordered_cancel_add_comm_monoid.{0} ennreal) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (ordered_cancel_add_comm_monoid.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_107 (h0 : functor.add_const (group (has_to_string unsigned)) ennreal) : @is_simple_group.{0} (has_to_string.{0} unsigned) (@functor.add_const.run.{0 0} (group.{0} (has_to_string.{0} unsigned)) ennreal h0)  := sorry --non-trivial
lemma new_lemma_108 (h0 : function.extfun Type ordered_comm_monoid) : @has_exists_mul_of_le.{0} (has_neg_part.{0} name) (@function.extfun_app.{2 1} Type ordered_comm_monoid.{0} h0 (has_neg_part.{0} name))  := sorry --non-trivial
lemma new_lemma_109 (h0 : topological_space (has_pos_part (has_nndist (finset (finset (ring linarith.comp)))))) : preconnected_space (has_pos_part (has_nndist (finset (finset (ring linarith.comp))))) := sorry --non-trivial
lemma new_lemma_110 (h0 : function.extfun Type topological_space) : @totally_disconnected_space.{0} (has_dist.{0} ennreal) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_dist.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_111 (h0 : functor.add_const (finset (cancel_monoid pos)) unsigned) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_112 (h0 : not (function.extfun Type group -> false)) : @normalizer_condition.{0} (has_one.{0} linarith.comp) (@function.extfun_app.{2 1} Type group.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type group.{0}) h0) (has_one.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_113 (h0 : functor.add_const (function.extfun (Type 1) ordered_comm_monoid) pos) : @has_exists_mul_of_le.{1} (has_nndist.{1} Type) (@function.extfun_app.{3 2} (Type 1) ordered_comm_monoid.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) ordered_comm_monoid.{1}) pos h0) (has_nndist.{1} Type))  := sorry --non-trivial
lemma new_lemma_114 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @loc_path_connected_space.{0} (has_edist.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_edist.{0} empty))  := sorry --non-trivial
lemma new_lemma_115 (h0 : function.extfun Type (functor.add_const (ring int))) : is_principal_ideal_ring int := sorry --non-trivial
lemma new_lemma_116 (h0 : functor.add_const (function.extfun Type ordered_comm_monoid) (has_add (ring linarith.comp))) : @has_exists_mul_of_le.{0} (has_to_string.{0} linarith.comp) (@function.extfun_app.{2 1} Type ordered_comm_monoid.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type ordered_comm_monoid.{0}) (has_add.{0} (ring.{0} linarith.comp)) h0) (has_to_string.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_117 (h0 : not (topological_space (has_one unsigned) -> false)) : @preirreducible_space.{0} (has_one.{0} unsigned) (@classical.by_contradiction'.{1} (topological_space.{0} (has_one.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_118 (h0 : functor.add_const (filter (complete_distrib_lattice unsigned)) empty) : filter.ne_bot (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_119 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @add_monoid.fg.{0} (has_norm.{0} num) (@function.extfun_app.{2 1} Type add_monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 add_monoid.{0}) (has_norm.{0} num))  := sorry --non-trivial
lemma new_lemma_120 (h2 : complete_lattice (has_div linarith.ineq)) : complete_lattice.is_Sup_finite_compact (has_div linarith.ineq) := sorry --non-trivial
lemma new_lemma_121 (h0 : has_neg (has_ssubset to_additive.value_type) -> Prop) (h1 : Exists (fun (x : has_neg (has_ssubset to_additive.value_type)), h0 x)) (h2 : list (measurable_space (has_ssubset to_additive.value_type))) : @has_measurable_neg.{0} (has_ssubset.{0} to_additive.value_type) (@classical.some.{1} (has_neg.{0} (has_ssubset.{0} to_additive.value_type)) h0 h1) (@list.ilast.{0} (measurable_space.{0} (has_ssubset.{0} to_additive.value_type)) (@measurable_space.inhabited.{0} (has_ssubset.{0} to_additive.value_type)) h2)  := sorry --non-trivial
lemma new_lemma_122 (h0 : ring (has_add linarith.comp)) : rank_condition (has_add linarith.comp) := sorry --non-trivial
lemma new_lemma_123 (h0 : uniform_space (has_append (denumerable to_additive.value_type))) : complete_space (has_append (denumerable to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_124 (h0 : functor.add_const (fin has_zero.zero) Type) : @path_connected_space.{0} (normed_lattice_add_comm_group.{0} real) (@function.extfun_app.{2 1} Type topological_space.{0} (@matrix.vec_empty.{1} (function.extfun.{2 1} Type topological_space.{0}) (@functor.add_const.run.{0 1} (fin (@has_zero.zero.{0} nat nat.has_zero)) Type h0)) (normed_lattice_add_comm_group.{0} real))  := sorry --non-trivial
lemma new_lemma_125 (h0 : topological_space (has_norm (comm_ring (random_gen (comm_ring linarith.comp_source))))) : irreducible_space (has_norm (comm_ring (random_gen (comm_ring linarith.comp_source)))) := sorry --non-trivial
lemma new_lemma_126 (h1 : linarith.ineq -> linarith.ineq -> Prop) : is_total linarith.ineq h1 := sorry --non-trivial
lemma new_lemma_127 (h0 : functor.add_const (function.extfun Type group) pos) : @is_cyclic.{0} (has_nndist.{0} pos) (@function.extfun_app.{2 1} Type group.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type group.{0}) pos h0) (has_nndist.{0} pos))  := sorry --non-trivial
lemma new_lemma_128 (h3 : set ereal) : set.finite h3 := sorry --non-trivial
lemma new_lemma_129 (h0 : uniform_space (omega_complete_partial_order unsigned)) : separated_space (omega_complete_partial_order unsigned) := sorry --non-trivial
lemma new_lemma_130 (h0 : topological_space (has_top num)) : totally_disconnected_space (has_top num) := sorry --non-trivial
lemma new_lemma_131 (h0 : measurable_space (semi_normed_ring linarith.ineq)) (h1 : filter (semi_normed_ring linarith.ineq)) : filter.is_measurably_generated h1 := sorry --non-trivial
lemma new_lemma_132 (h0 : not (uniform_space (complete_linear_order empty) -> false)) : @complete_space.{0} (complete_linear_order.{0} empty) (@classical.by_contradiction'.{1} (uniform_space.{0} (complete_linear_order.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_133 (h0 : filter (comm_group (comm_group (comm_group pos)))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_134 (h0 : topological_space (linear_ordered_add_comm_group (has_add (has_add to_additive.value_type)))) : t0_space (linear_ordered_add_comm_group (has_add (has_add to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_135 (h0 : function.extfun Type monoid) : @monoid.fg.{0} (has_norm.{0} empty) (@function.extfun_app.{2 1} Type monoid.{0} h0 (has_norm.{0} empty))  := sorry --non-trivial
lemma new_lemma_136 (h0 : topological_space (comm_semigroup (has_bot real))) : topological_space.separable_space (comm_semigroup (has_bot real)) := sorry --non-trivial
lemma new_lemma_137 (h0 : filter (fintype (fintype linarith.comp_source))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_138 (h0 : list (normed_lattice_add_comm_group (has_Inf real))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_139 (h0 : topological_space (simple_graph (mul_one_class enat))) : totally_disconnected_space (simple_graph (mul_one_class enat)) := sorry --non-trivial
lemma new_lemma_140 (h2 : complete_lattice (random_gen char)) : complete_lattice.is_Sup_finite_compact (random_gen char) := sorry --non-trivial
lemma new_lemma_141 (h0 : has_lt (has_ssubset (mul_one_class (simple_graph linarith.ineq)))) : no_max_order (has_ssubset (mul_one_class (simple_graph linarith.ineq))) := sorry --non-trivial
lemma new_lemma_142 (h0 : group (add_comm_monoid real)) : normalizer_condition (add_comm_monoid real) := sorry --non-trivial
lemma new_lemma_143 (h0 : topological_space (has_add (sub_neg_monoid Type))) : regular_space (has_add (sub_neg_monoid Type)) := sorry --non-trivial
lemma new_lemma_144 (h0 : ring (has_norm linarith.comp_source)) : rank_condition (has_norm linarith.comp_source) := sorry --non-trivial
lemma new_lemma_145 (h0 : not (group (has_top fun_info) -> false)) : @is_cyclic.{0} (has_top.{0} fun_info) (@classical.by_contradiction'.{1} (group.{0} (has_top.{0} fun_info)) h0)  := sorry --non-trivial
lemma new_lemma_146 (h0 : topological_space (has_add pos)) : preconnected_space (has_add pos) := sorry --non-trivial
lemma new_lemma_147 (h2 : topological_space (with_one congr_arg_kind)) : totally_disconnected_space (with_one congr_arg_kind) := sorry --non-trivial
lemma new_lemma_148 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_compactly_generated.{0} (boolean_algebra.core.{0} name) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (boolean_algebra.core.{0} name))  := sorry --non-trivial
lemma new_lemma_149 (h0 : has_mem.mem ring has_emptyc.emptyc) : @is_domain.{0} to_additive.value_type (@function.extfun_app.{2 1} Type ring.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) ring.{0} h0) to_additive.value_type)  := sorry --non-trivial
lemma new_lemma_150 (h0 : topological_space (non_assoc_semiring unsigned)) : preirreducible_space (non_assoc_semiring unsigned) := sorry --non-trivial
lemma new_lemma_151 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : filter.ne_bot (function.extfun_app (function.extfun_app h0 filter) (add_comm_monoid empty)) := sorry --non-trivial
lemma new_lemma_152 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @monoid.fg.{1} (ring.{1} Type) (@function.extfun_app.{3 2} (Type 1) monoid.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 monoid.{1}) (ring.{1} Type))  := sorry --non-trivial
lemma new_lemma_153 (h2 : ring (distrib linarith.comp_source)) : strong_rank_condition (distrib linarith.comp_source) := sorry --non-trivial
lemma new_lemma_154 (h0 : add_group (distrib (complete_semilattice_Sup (has_ssubset char)))) : is_add_cyclic (distrib (complete_semilattice_Sup (has_ssubset char))) := sorry --non-trivial
lemma new_lemma_155 (h0 : function.extfun Type group) : @is_simple_group.{0} (cancel_monoid.{0} pos) (@function.extfun_app.{2 1} Type group.{0} h0 (cancel_monoid.{0} pos))  := sorry --non-trivial
lemma new_lemma_156 (h0 : has_le (has_norm (random_gen (random_gen to_additive.value_type)))) (h1 : bounded_order (has_norm (random_gen (random_gen to_additive.value_type)))) : is_simple_order (has_norm (random_gen (random_gen to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_157 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @irreducible_space.{0} (semigroup.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (semigroup.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_158 (h0 : topological_space (linear_ordered_semiring (has_top (semiring congr_arg_kind)))) : totally_disconnected_space (linear_ordered_semiring (has_top (semiring congr_arg_kind))) := sorry --non-trivial
lemma new_lemma_159 (h0 : function.extfun Type topological_space) : @normal_space.{0} (mul_zero_class.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (mul_zero_class.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_160 (h0 : uniform_space (ordered_comm_monoid (finset linarith.comp))) : complete_space (ordered_comm_monoid (finset linarith.comp)) := sorry --non-trivial
lemma new_lemma_161 (h0 : functor.add_const (functor.comp ring comm_group unsigned) environment.implicit_infer_kind) : @strong_rank_condition.{0} (comm_group.{0} unsigned) (@functor.comp.run.{0 0 0} ring.{0} comm_group.{0} unsigned (@functor.add_const.run.{0 0} (functor.comp.{0 0 0} ring.{0} comm_group.{0} unsigned) environment.implicit_infer_kind h0))  := sorry --non-trivial
lemma new_lemma_162 (h0 : topological_space (complete_distrib_lattice (option (option (option (option empty)))))) : t0_space (complete_distrib_lattice (option (option (option (option empty))))) := sorry --non-trivial
lemma new_lemma_163 (h0 : topological_space (has_dist ennreal)) : preirreducible_space (has_dist ennreal) := sorry --non-trivial
lemma new_lemma_164 (h0 : functor.add_const (list (complete_distrib_lattice pos)) (ring pos)) : palindrome (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_165 (h0 : filter (has_zero (comm_group (comm_group (comm_group Type))))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_166 (h0 : group (dlist (random_gen (random_gen (random_gen (random_gen (random_gen linarith.ineq))))))) : is_cyclic (dlist (random_gen (random_gen (random_gen (random_gen (random_gen linarith.ineq)))))) := sorry --non-trivial
lemma new_lemma_167 (h0 : topological_space (bin_tree (semiring (option unsigned)))) : loc_path_connected_space (bin_tree (semiring (option unsigned))) := sorry --non-trivial
lemma new_lemma_168 (h0 : topological_space (topological_space (has_ssubset (denumerable (random_gen string_imp))))) : t0_space (topological_space (has_ssubset (denumerable (random_gen string_imp)))) := sorry --non-trivial
lemma new_lemma_169 (h0 : group (sub_neg_monoid (finset (finset pos)))) : is_simple_group (sub_neg_monoid (finset (finset pos))) := sorry --non-trivial
lemma new_lemma_170 (h0 : function.extfun Type complete_lattice) : @is_compactly_generated.{0} (free_add_monoid.{0} unsigned) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (free_add_monoid.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_171 (h0 : functor.add_const (topological_space (comm_group linarith.comp)) (has_neg name)) : @preirreducible_space.{0} (comm_group.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (comm_group.{0} linarith.comp)) (has_neg.{0} name) h0)  := sorry --non-trivial
lemma new_lemma_172 (h0 : topological_space (complete_linear_order (semiring unsigned))) : locally_compact_space (complete_linear_order (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_173 (h0 : uniform_space (non_assoc_semiring (semiring (semiring (semiring (semiring unsigned)))))) : complete_space (non_assoc_semiring (semiring (semiring (semiring (semiring unsigned))))) := sorry --non-trivial
lemma new_lemma_174 (h0 : ordered_comm_monoid (boolean_algebra.core (has_add (finset (finset (finset name)))))) : has_exists_mul_of_le (boolean_algebra.core (has_add (finset (finset (finset name))))) := sorry --non-trivial
lemma new_lemma_175 (h0 : ring (has_Inf linarith.comp)) : strong_rank_condition (has_Inf linarith.comp) := sorry --non-trivial
lemma new_lemma_176 (h0 : uniform_space (normed_comm_ring linarith.comp)) : separated_space (normed_comm_ring linarith.comp) := sorry --non-trivial
lemma new_lemma_177 (h0 : group (ordered_comm_ring (has_neg (has_neg name)))) : is_cyclic (ordered_comm_ring (has_neg (has_neg name))) := sorry --non-trivial
lemma new_lemma_178 (h0 : function.extfun Type topological_space) : @t0_space.{0} (semi_normed_comm_ring.{0} fun_info) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (semi_normed_comm_ring.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_179 (h0 : ring (normed_field (has_compl linarith.comp_source))) : rank_condition (normed_field (has_compl linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_180 (h0 : topological_space (normed_comm_ring (has_nndist name))) : topological_space.separable_space (normed_comm_ring (has_nndist name)) := sorry --non-trivial
lemma new_lemma_181 (h1 : topological_space (linear_ordered_add_comm_group (has_nnnorm linarith.ineq))) : totally_disconnected_space (linear_ordered_add_comm_group (has_nnnorm linarith.ineq)) := sorry --non-trivial
lemma new_lemma_182 (h0 : filter (has_top (has_nnnorm linarith.ineq))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_183 (h0 : complete_lattice (with_one linarith.ineq)) : is_atomistic (with_one linarith.ineq) := sorry --non-trivial
lemma new_lemma_184 (h1 : not (topological_space (add_monoid to_additive.value_type) -> false)) : @path_connected_space.{0} (add_monoid.{0} to_additive.value_type) (@classical.by_contradiction'.{1} (topological_space.{0} (add_monoid.{0} to_additive.value_type)) h1)  := sorry --non-trivial
lemma new_lemma_185 (h0 : ring (with_bot (random_gen (semiring (random_gen (semiring num)))))) : rank_condition (with_bot (random_gen (semiring (random_gen (semiring num))))) := sorry --non-trivial
lemma new_lemma_186 (h0 : complete_lattice (distrib (comm_ring char))) : is_compactly_generated (distrib (comm_ring char)) := sorry --non-trivial
lemma new_lemma_187 (h1 : ring (has_norm (measurable_space congr_arg_kind))) : rank_condition (has_norm (measurable_space congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_188 (h0 : topological_space (complete_distrib_lattice (ring Type))) : locally_compact_space (complete_distrib_lattice (ring Type)) := sorry --non-trivial
lemma new_lemma_189 (h0 : complete_lattice (has_nnnorm (mul_one_class (mul_one_class fun_info)))) : is_compactly_generated (has_nnnorm (mul_one_class (mul_one_class fun_info))) := sorry --non-trivial
lemma new_lemma_190 (h1 : topological_space congr_arg_kind) : totally_disconnected_space congr_arg_kind := sorry --non-trivial
lemma new_lemma_191 (h0 : filter (has_neg_part (comm_group name))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_192 (h0 : function.extfun Type complete_lattice) : @is_atomistic.{0} (add_cancel_monoid.{0} unsigned) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (add_cancel_monoid.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_193 (h0 : ring (boolean_algebra.core (comm_group (has_add (comm_group name))))) : strong_rank_condition (boolean_algebra.core (comm_group (has_add (comm_group name)))) := sorry --non-trivial
lemma new_lemma_194 (h0 : has_mem.mem (has_top fun_info) has_emptyc.emptyc) : @totally_separated_space.{0} (has_top.{0} fun_info) (@finset.pi.empty.{1 0} Type topological_space.{0} (has_top.{0} fun_info) h0)  := sorry --non-trivial
lemma new_lemma_195 (h0 : complete_lattice (cancel_monoid ennreal)) : is_atomistic (cancel_monoid ennreal) := sorry --non-trivial
lemma new_lemma_196 (h0 : not (topological_space (with_one (random_gen linarith.ineq)) -> false)) : @totally_separated_space.{0} (with_one.{0} (random_gen.{0} linarith.ineq)) (@classical.by_contradiction'.{1} (topological_space.{0} (with_one.{0} (random_gen.{0} linarith.ineq))) h0)  := sorry --non-trivial
lemma new_lemma_197 (h0 : functor.add_const (cancel_comm_monoid_with_zero (has_zero environment.implicit_infer_kind)) name) : @unique_factorization_monoid.{0} (has_zero.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (cancel_comm_monoid_with_zero.{0} (has_zero.{0} environment.implicit_infer_kind)) name h0)  := sorry --non-trivial
lemma new_lemma_198 (h0 : topological_space (as_linear_order unsigned)) : loc_path_connected_space (as_linear_order unsigned) := sorry --non-trivial
lemma new_lemma_199 (h0 : uniform_space (non_assoc_semiring (semiring (semiring (semiring (semiring congr_arg_kind)))))) : complete_space (non_assoc_semiring (semiring (semiring (semiring (semiring congr_arg_kind))))) := sorry --non-trivial
lemma new_lemma_200 (h0 : function.extfun Type topological_space) : @locally_compact_space.{0} (sub_neg_monoid.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (sub_neg_monoid.{0} pos))  := sorry --non-trivial
lemma new_lemma_201 (h0 : nat) (h1 h2 : fin (id (id h0))) : fin.lt (id (id h1)) h2 := sorry --non-trivial
lemma new_lemma_202 (h0 : not (has_mem.mem (has_norm num) has_emptyc.emptyc -> false)) : @t0_space.{0} (has_norm.{0} num) (@finset.pi.empty.{1 0} Type topological_space.{0} (has_norm.{0} num) (@classical.by_contradiction'.{0} (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (has_norm.{0} num) (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))) h0))  := sorry --non-trivial
lemma new_lemma_203 (h0 : function.extfun Type topological_space) : @normal_space.{0} (add_right_cancel_monoid.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (add_right_cancel_monoid.{0} empty))  := sorry --non-trivial
lemma new_lemma_204 (h0 : char -> char -> Prop) (h1 h2 : char) : relation.join h0 h1 h2 := sorry --non-trivial
lemma new_lemma_205 (h0 : topological_space (comm_monoid congr_arg_kind)) : irreducible_space (comm_monoid congr_arg_kind) := sorry --non-trivial
lemma new_lemma_206 (h0 : functor.add_const (topological_space (generalized_boolean_algebra name)) Type) : @normal_space.{0} (generalized_boolean_algebra.{0} name) (@functor.add_const.run.{0 1} (topological_space.{0} (generalized_boolean_algebra.{0} name)) Type h0)  := sorry --non-trivial
lemma new_lemma_207 (h0 : functor.add_const (complete_lattice (has_add environment.implicit_infer_kind)) (has_neg pos)) : @is_compactly_generated.{0} (has_add.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (complete_lattice.{0} (has_add.{0} environment.implicit_infer_kind)) (has_neg.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_208 (h0 : functor.add_const (group (mul_zero_class congr_arg_kind)) congr_arg_kind) : @normalizer_condition.{0} (mul_zero_class.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (group.{0} (mul_zero_class.{0} congr_arg_kind)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_209 (h0 : ring (ordered_comm_ring (has_pos_part linarith.comp))) : is_domain (ordered_comm_ring (has_pos_part linarith.comp)) := sorry --non-trivial
lemma new_lemma_210 (h0 : prod (has_edist congr_arg_kind) (has_edist congr_arg_kind)) : id_rel h0 := sorry --non-trivial
lemma new_lemma_211 (h0 : ring (semiring num)) : strong_rank_condition (semiring num) := sorry --non-trivial
lemma new_lemma_212 (h0 : comm_ring (left_cancel_monoid (semiring empty))) : local_ring (left_cancel_monoid (semiring empty)) := sorry --non-trivial
lemma new_lemma_213 (h0 : functor.add_const (filter (has_nndist pos)) (has_neg (has_neg (finset Type)))) : filter.ne_bot (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_214 (h0 : functor.add_const (topological_space (generalized_boolean_algebra real)) real) : @t0_space.{0} (generalized_boolean_algebra.{0} real) (@functor.add_const.run.{0 0} (topological_space.{0} (generalized_boolean_algebra.{0} real)) real h0)  := sorry --non-trivial
lemma new_lemma_215 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @strong_rank_condition.{0} (boolean_algebra.{0} linarith.comp) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (boolean_algebra.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_216 (h0 : topological_space (has_top (random_gen (with_one (random_gen char))))) : locally_compact_space (has_top (random_gen (with_one (random_gen char)))) := sorry --non-trivial
lemma new_lemma_217 (h0 : topological_space (non_assoc_semiring (semiring congr_arg_kind))) : path_connected_space (non_assoc_semiring (semiring congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_218 (h0 : topological_space (cancel_monoid (option unsigned))) : normal_space (cancel_monoid (option unsigned)) := sorry --non-trivial
lemma new_lemma_219 (h0 : functor.add_const (fin has_zero.zero) name) : @unique_factorization_monoid.{1} (has_add.{1} Type) (@matrix.vec_empty.{1} (cancel_comm_monoid_with_zero.{1} (has_add.{1} Type)) (@functor.add_const.run.{0 0} (fin (@has_zero.zero.{0} nat nat.has_zero)) name h0))  := sorry --non-trivial
lemma new_lemma_220 (h0 : function.extfun Type topological_space) : @totally_separated_space.{0} (has_nndist.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_nndist.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_221 (h0 : group (semigroup unsigned)) : is_cyclic (semigroup unsigned) := sorry --non-trivial
lemma new_lemma_222 (h0 : topological_space (has_ssubset enat)) (h1 : preorder (has_ssubset enat)) : order_closed_topology (has_ssubset enat) := sorry --non-trivial
lemma new_lemma_223 (h0 : function.extfun Type ring) : @strong_rank_condition.{0} (has_add.{0} num) (@function.extfun_app.{2 1} Type ring.{0} h0 (has_add.{0} num))  := sorry --non-trivial
lemma new_lemma_224 (h0 : functor.add_const (topological_space (semigroup unsigned)) name) : @t1_space.{0} (semigroup.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (semigroup.{0} unsigned)) name h0)  := sorry --non-trivial
lemma new_lemma_225 (h0 : ring (has_compl (random_gen (has_inv fun_info)))) : rank_condition (has_compl (random_gen (has_inv fun_info))) := sorry --non-trivial
lemma new_lemma_226 (h0 : uniform_space (measurable_space.dynkin_system (has_top unsigned))) : separated_space (measurable_space.dynkin_system (has_top unsigned)) := sorry --non-trivial
lemma new_lemma_227 (h0 : list (has_to_string (boolean_algebra unsigned))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_228 (h0 : not (complete_lattice (metric_space char) -> false)) : @is_compactly_generated.{0} (metric_space.{0} char) (@classical.by_contradiction'.{1} (complete_lattice.{0} (metric_space.{0} char)) h0)  := sorry --non-trivial
lemma new_lemma_229 (h0 : ring (measurable_space.dynkin_system (semiring linarith.comp))) : rank_condition (measurable_space.dynkin_system (semiring linarith.comp)) := sorry --non-trivial
lemma new_lemma_230 (h0 : functor.add_const (ring (semigroup environment.implicit_infer_kind)) pos) : @is_principal_ideal_ring.{0} (semigroup.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (ring.{0} (semigroup.{0} environment.implicit_infer_kind)) pos h0)  := sorry --non-trivial
lemma new_lemma_231 (h0 : topological_space (ring (has_Inf Type))) : t0_space (ring (has_Inf Type)) := sorry --non-trivial
lemma new_lemma_232 (h0 : function.extfun (finset (Type -> Type)) (has_mem.mem ring)) : @strong_rank_condition.{0} (has_top.{0} linarith.ineq) (@function.extfun_app.{2 1} Type ring.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) ring.{0} (@function.extfun_app.{2 0} (finset.{1} (Type → Type)) (@has_mem.mem.{1 1} (Type → Type) (finset.{1} (Type → Type)) (@finset.has_mem.{1} (Type → Type)) ring.{0}) h0 (@has_emptyc.emptyc.{1} (finset.{1} (Type → Type)) (@finset.has_emptyc.{1} (Type → Type))))) (has_top.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_233 (h0 : function.extfun Type list) : list.nodup (function.extfun_app h0 (is_R_or_C empty)) := sorry --non-trivial
lemma new_lemma_234 (h0 : uniform_space (add_left_cancel_semigroup (option empty))) : complete_space (add_left_cancel_semigroup (option empty)) := sorry --non-trivial
lemma new_lemma_235 (h0 : functor.add_const (filter (has_add name)) unsigned) : filter.ne_bot (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_236 (h0 : uniform_space (normed_comm_ring (ring Type))) : separated_space (normed_comm_ring (ring Type)) := sorry --non-trivial
lemma new_lemma_237 (h0 : topological_space (has_Inf linarith.comp)) : t0_space (has_Inf linarith.comp) := sorry --non-trivial
lemma new_lemma_238 (h0 : semiring (add_right_cancel_monoid (semiring num))) : is_noetherian_ring (add_right_cancel_monoid (semiring num)) := sorry --non-trivial
lemma new_lemma_239 (h0 : function.extfun Type ring) : @rank_condition.{0} (has_union.{0} unsigned) (@function.extfun_app.{2 1} Type ring.{0} h0 (has_union.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_240 (h0 : function.extfun Type topological_space) : @totally_disconnected_space.{0} (add_cancel_monoid.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (add_cancel_monoid.{0} name))  := sorry --non-trivial
lemma new_lemma_241 (h0 : group (linear_ordered_add_comm_group (partial_order to_additive.value_type))) : is_cyclic (linear_ordered_add_comm_group (partial_order to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_242 (h0 : function.extfun (Type -> Type) (function.extfun Type)) (h1 : has_le (semilattice_inf congr_arg_kind)) (h2 : semilattice_inf congr_arg_kind) : @add_le_cancellable.{0} (semilattice_inf.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type has_add.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 has_add.{0}) (semilattice_inf.{0} congr_arg_kind)) h1 h2  := sorry --non-trivial
lemma new_lemma_243 (h0 : topological_space (has_compl (has_compl (mul_one_class fun_info)))) : path_connected_space (has_compl (has_compl (mul_one_class fun_info))) := sorry --non-trivial
lemma new_lemma_244 (h0 : topological_space (has_le linarith.comp_source)) (h1 : preorder (has_le linarith.comp_source)) : order_closed_topology (has_le linarith.comp_source) := sorry --non-trivial
lemma new_lemma_245 (h0 : function.extfun (finset Type) (has_mem.mem (has_norm fun_info))) : @complete_space.{0} (has_norm.{0} fun_info) (@finset.pi.empty.{1 0} Type uniform_space.{0} (has_norm.{0} fun_info) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (has_norm.{0} fun_info)) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_246 (h0 : complete_lattice (semi_normed_comm_ring (linear_ordered_cancel_add_comm_monoid linarith.ineq))) : is_compactly_generated (semi_normed_comm_ring (linear_ordered_cancel_add_comm_monoid linarith.ineq)) := sorry --non-trivial
lemma new_lemma_247 (h0 : functor.add_const (filter (ring environment.implicit_infer_kind)) unsigned) : filter.ne_bot (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_248 (h0 : ring (normed_comm_ring num)) : is_principal_ideal_ring (normed_comm_ring num) := sorry --non-trivial
lemma new_lemma_249 (h0 : functor.add_const (topological_space (ordered_ring empty)) congr_arg_kind) : @loc_path_connected_space.{0} (ordered_ring.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (ordered_ring.{0} empty)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_250 (h0 : functor.add_const (topological_space (free_add_monoid congr_arg_kind)) empty) : @preirreducible_space.{0} (free_add_monoid.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (free_add_monoid.{0} congr_arg_kind)) empty h0)  := sorry --non-trivial
lemma new_lemma_251 (h0 : filter (has_norm (has_norm to_additive.value_type))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_252 (h0 : function.extfun (finset (Type -> Type)) (has_mem.mem topological_space)) : @discrete_topology.{0} (linear_ordered_semiring.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type topological_space.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) topological_space.{0} (@function.extfun_app.{2 0} (finset.{1} (Type → Type)) (@has_mem.mem.{1 1} (Type → Type) (finset.{1} (Type → Type)) (@finset.has_mem.{1} (Type → Type)) topological_space.{0}) h0 (@has_emptyc.emptyc.{1} (finset.{1} (Type → Type)) (@finset.has_emptyc.{1} (Type → Type))))) (linear_ordered_semiring.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_253 (h0 : filter (finset (finset ennreal))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_254 (h0 : function.extfun Type topological_space) : @preconnected_space.{0} (option.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (option.{0} pos))  := sorry --non-trivial
lemma new_lemma_255 (h0 : list (has_inter num)) : palindrome h0 := sorry --non-trivial
lemma new_lemma_256 (h0 : topological_space (ring (add_cancel_monoid linarith.comp))) : t0_space (ring (add_cancel_monoid linarith.comp)) := sorry --non-trivial
lemma new_lemma_257 (h0 : function.extfun (Type 1) complete_lattice) : @is_atomistic.{1} (ordered_comm_ring.{1} Type) (@function.extfun_app.{3 2} (Type 1) complete_lattice.{1} h0 (ordered_comm_ring.{1} Type))  := sorry --non-trivial
lemma new_lemma_258 (h0 : ordered_add_comm_monoid (semigroup Type)) : archimedean (semigroup Type) := sorry --non-trivial
lemma new_lemma_259 (h0 : uniform_space (random_gen (metric_space (has_nnnorm char)))) : complete_space (random_gen (metric_space (has_nnnorm char))) := sorry --non-trivial
lemma new_lemma_260 (h0 : functor.add_const (topological_space (free_add_monoid congr_arg_kind)) unsigned) : @locally_compact_space.{0} (free_add_monoid.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (free_add_monoid.{0} congr_arg_kind)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_261 (h1 : complete_lattice (semi_normed_comm_ring fun_info)) : complete_lattice.is_Sup_finite_compact (semi_normed_comm_ring fun_info) := sorry --non-trivial
lemma new_lemma_262 (h1 : uniform_space (topological_space reducibility_hints)) : complete_space (topological_space reducibility_hints) := sorry --non-trivial
lemma new_lemma_263 (h0 : group (canonically_ordered_comm_semiring ennreal)) : group.fg (canonically_ordered_comm_semiring ennreal) := sorry --non-trivial
lemma new_lemma_264 (h1 : topological_space (has_div to_additive.value_type)) : totally_disconnected_space (has_div to_additive.value_type) := sorry --non-trivial
lemma new_lemma_265 (h1 : topological_space (fintype (random_gen string_imp))) : t0_space (fintype (random_gen string_imp)) := sorry --non-trivial
lemma new_lemma_266 (h0 : functor.add_const (group (has_neg pos)) linarith.comp) : @is_simple_group.{0} (has_neg.{0} pos) (@functor.add_const.run.{0 0} (group.{0} (has_neg.{0} pos)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_267 (h0 : topological_space (comm_semigroup (sub_neg_monoid Type))) : regular_space (comm_semigroup (sub_neg_monoid Type)) := sorry --non-trivial
lemma new_lemma_268 (h0 : function.extfun Type uniform_space) : @complete_space.{0} (has_bot.{0} stieltjes_function) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (has_bot.{0} stieltjes_function))  := sorry --non-trivial
lemma new_lemma_269 (h0 : functor.add_const (function.extfun (Type 1) list) name) : list.nodup (function.extfun_app (functor.add_const.run h0) (boolean_algebra.core Type)) := sorry --non-trivial
lemma new_lemma_270 (h0 : topological_space (complete_distrib_lattice (has_add Type))) : preconnected_space (complete_distrib_lattice (has_add Type)) := sorry --non-trivial
lemma new_lemma_271 (h0 : function.extfun Type uniform_space) : @complete_space.{0} (add_comm_monoid.{0} ennreal) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (add_comm_monoid.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_272 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_domain.{0} (monoid_with_zero.{0} ennreal) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (monoid_with_zero.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_273 (h0 : char) (h1 : set char) (h2 : char) : set.insert h0 h1 h2 := sorry --non-trivial
lemma new_lemma_274 (h0 : topological_space (normed_field fun_info)) : t0_space (normed_field fun_info) := sorry --non-trivial
lemma new_lemma_275 (h0 : topological_space (has_compl (has_nnnorm string.iterator_imp))) : t0_space (has_compl (has_nnnorm string.iterator_imp)) := sorry --non-trivial
lemma new_lemma_276 (h0 : filter (has_inv fun_info)) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_277 (h0 : topological_space (has_zero (comm_group (comm_group Type)))) : t1_space (has_zero (comm_group (comm_group Type))) := sorry --non-trivial
lemma new_lemma_278 (h0 : not (topological_space (has_emptyc linarith.comp_source) -> false)) : @t0_space.{0} (has_emptyc.{0} linarith.comp_source) (@classical.by_contradiction'.{1} (topological_space.{0} (has_emptyc.{0} linarith.comp_source)) h0)  := sorry --non-trivial
lemma new_lemma_279 (h2 : topological_space (with_one num)) : totally_separated_space (with_one num) := sorry --non-trivial
lemma new_lemma_280 (h0 : ring (has_emptyc num)) : strong_rank_condition (has_emptyc num) := sorry --non-trivial
lemma new_lemma_281 (h0 : group (option (semiring (semiring (semiring (semiring (semiring (semiring num)))))))) : normalizer_condition (option (semiring (semiring (semiring (semiring (semiring (semiring num))))))) := sorry --non-trivial
lemma new_lemma_282 (h2 : group (uniform_space to_additive.value_type)) : is_cyclic (uniform_space to_additive.value_type) := sorry --non-trivial
lemma new_lemma_283 (h0 : fin has_zero.zero) : @is_principal_ideal_ring.{0} (has_pos_part.{0} real) (@matrix.vec_empty.{0} (ring.{0} (has_pos_part.{0} real)) h0)  := sorry --non-trivial
lemma new_lemma_284 (h0 : ring (semiring num)) : is_principal_ideal_ring (semiring num) := sorry --non-trivial
lemma new_lemma_285 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_add_cyclic.{0} (random_gen.{0} string_imp) (@function.extfun_app.{2 1} Type add_group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 add_group.{0}) (random_gen.{0} string_imp))  := sorry --non-trivial
lemma new_lemma_286 (h0 : group (has_zero (has_add (add_comm_monoid (finset (finset (has_to_string linarith.comp))))))) : group.fg (has_zero (has_add (add_comm_monoid (finset (finset (has_to_string linarith.comp)))))) := sorry --non-trivial
lemma new_lemma_287 (h0 : group (comm_ring (has_top char))) : is_cyclic (comm_ring (has_top char)) := sorry --non-trivial
lemma new_lemma_288 (h0 : functor.add_const (group (plift congr_arg_kind)) unsigned) : @group.fg.{1} (plift.{1} congr_arg_kind) (@functor.add_const.run.{1 0} (group.{1} (plift.{1} congr_arg_kind)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_289 (h0 : topological_space (finset linarith.comp)) : preconnected_space (finset linarith.comp) := sorry --non-trivial
lemma new_lemma_290 (h0 : ring (has_inter (option empty))) : is_principal_ideal_ring (has_inter (option empty)) := sorry --non-trivial
lemma new_lemma_291 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @loc_path_connected_space.{0} (normed_linear_ordered_group.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (normed_linear_ordered_group.{0} empty))  := sorry --non-trivial
lemma new_lemma_292 (h0 : topological_space (linear_ordered_field num)) : preconnected_space (linear_ordered_field num) := sorry --non-trivial
lemma new_lemma_293 (h0 : has_neg enat) (h1 : measurable_space enat) : has_measurable_neg enat := sorry --non-trivial
lemma new_lemma_294 (h0 : topological_space (as_linear_order (option (option (option empty))))) : t0_space (as_linear_order (option (option (option empty)))) := sorry --non-trivial
lemma new_lemma_295 (h0 : list (normed_group (has_norm fun_info))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_296 (h0 : topological_space (has_ssubset linarith.comp_source)) : t0_space (has_ssubset linarith.comp_source) := sorry --non-trivial
lemma new_lemma_297 (h0 : functor.add_const (topological_space (cancel_monoid linarith.comp)) environment.implicit_infer_kind) : @t1_space.{0} (cancel_monoid.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (cancel_monoid.{0} linarith.comp)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_298 (h0 : functor.add_const (topological_space (complete_distrib_lattice name)) name) : @irreducible_space.{0} (complete_distrib_lattice.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (complete_distrib_lattice.{0} name)) name h0)  := sorry --non-trivial
lemma new_lemma_299 (h0 : functor.add_const (filter (has_zero Type)) (finset (has_nndist environment.implicit_infer_kind))) : countable_Inter_filter (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_300 (h0 : functor.add_const (ring (linear_ordered_cancel_comm_monoid num)) empty) : @strong_rank_condition.{0} (linear_ordered_cancel_comm_monoid.{0} num) (@functor.add_const.run.{0 0} (ring.{0} (linear_ordered_cancel_comm_monoid.{0} num)) empty h0)  := sorry --non-trivial
lemma new_lemma_301 (h0 : topological_space (has_neg (option (option empty)))) : totally_separated_space (has_neg (option (option empty))) := sorry --non-trivial
lemma new_lemma_302 (h0 : group (linear_ordered_field pos)) : group.fg (linear_ordered_field pos) := sorry --non-trivial
lemma new_lemma_303 (h0 : function.extfun (finset Type -> Prop) (function.extfun (finset Type))) : @complete_lattice.is_Sup_finite_compact.{0} (random_gen.{0} linarith.comp_source) (@finset.pi.empty.{1 0} Type complete_lattice.{0} (random_gen.{0} linarith.comp_source) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (random_gen.{0} linarith.comp_source)) (@function.extfun_app.{2 0} (finset.{1} Type → Prop) (function.extfun.{2 0} (finset.{1} Type)) h0 (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (random_gen.{0} linarith.comp_source))) (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_304 (h0 : add_monoid (semigroup (ring linarith.comp))) : add_monoid.fg (semigroup (ring linarith.comp)) := sorry --non-trivial
lemma new_lemma_305 (h0 : function.extfun Type (functor.add_const (topological_space (has_Inf linarith.comp)))) : @locally_compact_space.{0} (has_Inf.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (has_Inf.{0} linarith.comp)) linarith.comp (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (topological_space.{0} (has_Inf.{0} linarith.comp))) h0 linarith.comp))  := sorry --non-trivial
lemma new_lemma_306 (h0 : functor.add_const (ordered_comm_monoid (add_comm_monoid pos)) (finset name)) : @has_exists_mul_of_le.{0} (add_comm_monoid.{0} pos) (@functor.add_const.run.{0 0} (ordered_comm_monoid.{0} (add_comm_monoid.{0} pos)) (finset.{0} name) h0)  := sorry --non-trivial
lemma new_lemma_307 (h0 : not (topological_space (random_gen linarith.ineq) -> false)) : @totally_separated_space.{0} (random_gen.{0} linarith.ineq) (@classical.by_contradiction'.{1} (topological_space.{0} (random_gen.{0} linarith.ineq)) h0)  := sorry --non-trivial
lemma new_lemma_308 (h0 : semiring (add_comm_semigroup (add_comm_semigroup ereal))) (h1 : ideal (add_comm_semigroup (add_comm_semigroup ereal))) : ideal.is_prime h1 := sorry --non-trivial
lemma new_lemma_309 (h0 : functor.add_const (cancel_comm_monoid_with_zero (ordered_comm_ring linarith.comp)) (ring linarith.comp)) : @unique_factorization_monoid.{0} (ordered_comm_ring.{0} linarith.comp) (@functor.add_const.run.{0 0} (cancel_comm_monoid_with_zero.{0} (ordered_comm_ring.{0} linarith.comp)) (ring.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_310 (h0 : add_group (has_zero (has_add pos))) : is_add_cyclic (has_zero (has_add pos)) := sorry --non-trivial
lemma new_lemma_311 (h0 : function.extfun Type group) : @normalizer_condition.{0} (with_bot.{0} linarith.ineq) (@function.extfun_app.{2 1} Type group.{0} h0 (with_bot.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_312 (h0 : complete_lattice (add_right_cancel_monoid (semiring (semiring (semiring (semiring (semiring empty))))))) : is_atomistic (add_right_cancel_monoid (semiring (semiring (semiring (semiring (semiring empty)))))) := sorry --non-trivial
lemma new_lemma_313 (h0 : topological_space (distrib (has_inv char))) : totally_disconnected_space (distrib (has_inv char)) := sorry --non-trivial
lemma new_lemma_314 (h0 : functor.add_const (topological_space (add_cancel_monoid name)) (finset linarith.comp)) : @sequential_space.{0} (add_cancel_monoid.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (add_cancel_monoid.{0} name)) (finset.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_315 (h0 : uniform_space (ring (ordered_comm_ring (finset (ring name))))) : separated_space (ring (ordered_comm_ring (finset (ring name)))) := sorry --non-trivial
lemma new_lemma_316 (h0 : functor.add_const (group (canonically_ordered_comm_semiring name)) unsigned) : @group.fg.{0} (canonically_ordered_comm_semiring.{0} name) (@functor.add_const.run.{0 0} (group.{0} (canonically_ordered_comm_semiring.{0} name)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_317 (h0 : group (simple_graph congr_arg_kind)) : normalizer_condition (simple_graph congr_arg_kind) := sorry --non-trivial
lemma new_lemma_318 (h0 : functor.add_const (topological_space (semigroup empty)) empty) : @discrete_topology.{0} (semigroup.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (semigroup.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_319 (h0 : functor.add_const (uniform_space (has_to_string pos)) unsigned) : @separated_space.{0} (has_to_string.{0} pos) (@functor.add_const.run.{0 0} (uniform_space.{0} (has_to_string.{0} pos)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_320 (h0 : functor.add_const (topological_space (has_neg_part pos)) unsigned) : @topological_space.separable_space.{0} (has_neg_part.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (has_neg_part.{0} pos)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_321 (h0 : group (with_one (random_gen (random_gen (random_gen to_additive.value_type))))) : normalizer_condition (with_one (random_gen (random_gen (random_gen to_additive.value_type)))) := sorry --non-trivial
lemma new_lemma_322 (h0 : function.extfun Type complete_lattice) : @is_atomistic.{0} (has_add.{0} linarith.comp) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (has_add.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_323 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @is_cyclic.{1} (has_nndist.{1} Type) (@function.extfun_app.{3 2} (Type 1) group.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 group.{1}) (has_nndist.{1} Type))  := sorry --non-trivial
lemma new_lemma_324 (h0 : topological_space (bin_tree congr_arg_kind)) : topological_space.separable_space (bin_tree congr_arg_kind) := sorry --non-trivial
lemma new_lemma_325 (h0 : group (has_Inf (has_add name))) : normalizer_condition (has_Inf (has_add name)) := sorry --non-trivial
lemma new_lemma_326 (h0 : functor.add_const (group (boolean_algebra Type)) Type) : @is_simple_group.{1} (boolean_algebra.{1} Type) (@functor.add_const.run.{1 1} (group.{1} (boolean_algebra.{1} Type)) Type h0)  := sorry --non-trivial
lemma new_lemma_327 (h0 : not (ring (has_top num) -> false)) : @is_principal_ideal_ring.{0} (has_top.{0} num) (@classical.by_contradiction'.{1} (ring.{0} (has_top.{0} num)) h0)  := sorry --non-trivial
lemma new_lemma_328 (h0 : finset (complete_distrib_lattice (comm_monoid (option (option unsigned))))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_329 (h0 : not (group (has_append (has_nnnorm linarith.ineq)) -> false)) : @is_cyclic.{0} (has_append.{0} (has_nnnorm.{0} linarith.ineq)) (@classical.by_contradiction'.{1} (group.{0} (has_append.{0} (has_nnnorm.{0} linarith.ineq))) h0)  := sorry --non-trivial
lemma new_lemma_330 (h1 : topological_space (has_one num)) : discrete_topology (has_one num) := sorry --non-trivial
lemma new_lemma_331 (h0 : topological_space (normed_lattice_add_comm_group real)) : locally_compact_space (normed_lattice_add_comm_group real) := sorry --non-trivial
lemma new_lemma_332 (h0 : list (has_to_string (has_neg Type))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_333 (h0 : function.extfun Type list) : palindrome (function.extfun_app h0 (finset ennreal)) := sorry --non-trivial
lemma new_lemma_334 (h0 : monoid (div_inv_monoid string_imp)) (h1 : add_group (star_monoid (div_inv_monoid string_imp))) : is_add_cyclic (star_monoid (div_inv_monoid string_imp)) := sorry --non-trivial
lemma new_lemma_335 (h1 : uniform_space (nondiscrete_normed_field (add_comm_semigroup char))) : complete_space (nondiscrete_normed_field (add_comm_semigroup char)) := sorry --non-trivial
lemma new_lemma_336 (h0 : uniform_space (with_one (semiring fun_info))) : complete_space (with_one (semiring fun_info)) := sorry --non-trivial
lemma new_lemma_337 (h0 : function.extfun Type topological_space) : @preirreducible_space.{0} (metric_space.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (metric_space.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_338 (h0 : Type -> Type -> Prop) (h1 : function.extfun (Type -> Type -> Prop) well_founded) (h2 : Pi (x : Type), (Pi (y : Type), h0 y x -> monoid y) -> monoid x) : @monoid.fg.{0} (complete_semilattice_Sup.{0} linarith.comp_source) (@well_founded.recursion.{2 1} Type h0 (@function.extfun_app.{2 0} (Type → Type → Prop) (@well_founded.{2} Type) h1 h0) monoid.{0} (complete_semilattice_Sup.{0} linarith.comp_source) h2)  := sorry --non-trivial
lemma new_lemma_339 (h0 : topological_space (add_group (has_norm (has_union linarith.comp)))) : totally_separated_space (add_group (has_norm (has_union linarith.comp))) := sorry --non-trivial
lemma new_lemma_340 (h0 : function.extfun Type topological_space) : @preirreducible_space.{0} (finset.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (finset.{0} num))  := sorry --non-trivial
lemma new_lemma_341 (h0 : functor.add_const (topological_space (has_to_string environment.implicit_infer_kind)) (boolean_algebra name)) : @discrete_topology.{0} (has_to_string.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (has_to_string.{0} environment.implicit_infer_kind)) (boolean_algebra.{0} name) h0)  := sorry --non-trivial
lemma new_lemma_342 (h0 : not (topological_space (option num) -> false)) : @locally_compact_space.{0} (option.{0} num) (@classical.by_contradiction'.{1} (topological_space.{0} (option.{0} num)) h0)  := sorry --non-trivial
lemma new_lemma_343 (h0 : functor.comp topological_space mul_zero_class name) : @preirreducible_space.{0} (mul_zero_class.{0} name) (@functor.comp.run.{0 0 0} topological_space.{0} mul_zero_class.{0} name h0)  := sorry --non-trivial
lemma new_lemma_344 (h0 : complete_lattice (has_neg_part (comm_group (has_add (comm_group Type))))) : is_atomistic (has_neg_part (comm_group (has_add (comm_group Type)))) := sorry --non-trivial
lemma new_lemma_345 (h0 : list (add_cancel_monoid (finset Type))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_346 (h0 : functor.add_const (ordered_add_comm_monoid (generalized_boolean_algebra pos)) pos) : @archimedean.{0} (generalized_boolean_algebra.{0} pos) (@functor.add_const.run.{0 0} (ordered_add_comm_monoid.{0} (generalized_boolean_algebra.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_347 (h0 : filter (bin_tree (semiring num))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_348 (h0 : group (sub_neg_monoid (finset (ring (has_pos_part (finset linarith.comp)))))) : is_cyclic (sub_neg_monoid (finset (ring (has_pos_part (finset linarith.comp))))) := sorry --non-trivial
lemma new_lemma_349 (h0 : function.extfun Type finset) : finset.nonempty (function.extfun_app h0 (complete_distrib_lattice unsigned)) := sorry --non-trivial
lemma new_lemma_350 (h0 : topological_space (linear_ordered_comm_group_with_zero linarith.comp_source)) : path_connected_space (linear_ordered_comm_group_with_zero linarith.comp_source) := sorry --non-trivial
lemma new_lemma_351 (h0 : functor.add_const (topological_space (add_cancel_monoid pos)) pos) : @totally_separated_space.{0} (add_cancel_monoid.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (add_cancel_monoid.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_352 (h0 : fin has_zero.zero) : @strong_rank_condition.{1} (ring.{1} Type) (@matrix.vec_empty.{1} (ring.{1} (ring.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_353 (h0 : function.extfun Type group) : @is_simple_group.{0} (normed_lattice_add_comm_group.{0} real) (@function.extfun_app.{2 1} Type group.{0} h0 (normed_lattice_add_comm_group.{0} real))  := sorry --non-trivial
lemma new_lemma_354 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_domain.{0} (has_union.{0} unsigned) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (has_union.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_355 (h0 : group (normed_lattice_add_comm_group (sub_neg_monoid linarith.comp))) : group.fg (normed_lattice_add_comm_group (sub_neg_monoid linarith.comp)) := sorry --non-trivial
lemma new_lemma_356 (h0 : topological_space (semigroup (comm_group name))) : regular_space (semigroup (comm_group name)) := sorry --non-trivial
lemma new_lemma_357 (h0 : not (uniform_space (with_zero linarith.ineq) -> false)) : @complete_space.{0} (with_zero.{0} linarith.ineq) (@classical.by_contradiction'.{1} (uniform_space.{0} (with_zero.{0} linarith.ineq)) h0)  := sorry --non-trivial
lemma new_lemma_358 (h0 : not (topological_space (has_append to_additive.value_type) -> false)) : @totally_disconnected_space.{0} (has_append.{0} to_additive.value_type) (@classical.by_contradiction'.{1} (topological_space.{0} (has_append.{0} to_additive.value_type)) h0)  := sorry --non-trivial
lemma new_lemma_359 (h0 : topological_space (has_add (option (option unsigned)))) : discrete_topology (has_add (option (option unsigned))) := sorry --non-trivial
lemma new_lemma_360 (h0 : complete_lattice (sub_neg_monoid (finset linarith.comp))) : is_compactly_generated (sub_neg_monoid (finset linarith.comp)) := sorry --non-trivial
lemma new_lemma_361 (h0 : functor.add_const (filter (boolean_algebra environment.implicit_infer_kind)) pos) : countable_Inter_filter (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_362 (h0 : complete_lattice (boolean_algebra (add_comm_monoid environment.implicit_infer_kind))) : is_atomistic (boolean_algebra (add_comm_monoid environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_363 (h0 : functor.add_const (add_monoid (has_nndist environment.implicit_infer_kind)) Type) : @add_monoid.fg.{0} (has_nndist.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 1} (add_monoid.{0} (has_nndist.{0} environment.implicit_infer_kind)) Type h0)  := sorry --non-trivial
lemma new_lemma_364 (h0 : function.extfun Type (functor.add_const (group (generalized_boolean_algebra linarith.comp)))) : @is_simple_group.{0} (generalized_boolean_algebra.{0} linarith.comp) (@functor.add_const.run.{0 0} (group.{0} (generalized_boolean_algebra.{0} linarith.comp)) name (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (group.{0} (generalized_boolean_algebra.{0} linarith.comp))) h0 name))  := sorry --non-trivial
lemma new_lemma_365 (h0 : ring (linear_ordered_field (option unsigned))) : strong_rank_condition (linear_ordered_field (option unsigned)) := sorry --non-trivial
lemma new_lemma_366 (h0 : topological_space (measurable_space (has_norm empty))) : normal_space (measurable_space (has_norm empty)) := sorry --non-trivial
lemma new_lemma_367 (h0 : group (has_norm (has_norm (semiring (has_norm num))))) : normalizer_condition (has_norm (has_norm (semiring (has_norm num)))) := sorry --non-trivial
lemma new_lemma_368 (h0 : add_group (semigroup (semigroup (boolean_algebra environment.implicit_infer_kind)))) : is_add_cyclic (semigroup (semigroup (boolean_algebra environment.implicit_infer_kind))) := sorry --non-trivial
lemma new_lemma_369 (h0 : functor.add_const (ordered_add_comm_monoid (boolean_algebra.core Type)) (finset Type)) : @archimedean.{1} (boolean_algebra.core.{1} Type) (@functor.add_const.run.{1 1} (ordered_add_comm_monoid.{1} (boolean_algebra.core.{1} Type)) (finset.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_370 (h0 : ring (has_bot real)) : rank_condition (has_bot real) := sorry --non-trivial
lemma new_lemma_371 (h0 : functor.add_const (list (has_neg name)) pos) : palindrome (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_372 (h0 : topological_space (ring (has_add pos))) : regular_space (ring (has_add pos)) := sorry --non-trivial
lemma new_lemma_373 (h0 : has_mem.mem (distrib_lattice string_imp) has_zero.zero) : @is_cyclic.{0} (distrib_lattice.{0} string_imp) (@multiset.pi.empty.{1 0} Type group.{0} (distrib_lattice.{0} string_imp) h0)  := sorry --non-trivial
lemma new_lemma_374 (h0 : topological_space (add_cancel_monoid (has_pos_part Type))) : t0_space (add_cancel_monoid (has_pos_part Type)) := sorry --non-trivial
lemma new_lemma_375 (h0 : ring (distrib (mul_one_class (has_compl string_imp)))) : rank_condition (distrib (mul_one_class (has_compl string_imp))) := sorry --non-trivial
lemma new_lemma_376 (h0 : has_lt (has_nnnorm fun_info)) : no_max_order (has_nnnorm fun_info) := sorry --non-trivial
lemma new_lemma_377 (h0 : function.extfun ((Type -> Type) -> Type 1) (function.extfun (Type -> Type))) : @complete_lattice.is_Sup_finite_compact.{0} (@id.{2} Type to_additive.value_type) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) (@function.extfun_app.{3 2} ((Type → Type) → Type 1) (function.extfun.{2 2} (Type → Type)) h0 (function.extfun.{2 1} Type)) complete_lattice.{0}) (@id.{2} Type to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_378 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @t1_space.{0} (mul_zero_class.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (mul_zero_class.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_379 (h1 : not (complete_lattice (linear_ordered_add_comm_group char) -> false)) : @is_compactly_generated.{0} (linear_ordered_add_comm_group.{0} char) (@classical.by_contradiction'.{1} (complete_lattice.{0} (linear_ordered_add_comm_group.{0} char)) h1)  := sorry --non-trivial
lemma new_lemma_380 (h0 : function.extfun nat fin) : @group.fg.{0} (has_pos_part.{0} real) (@function.extfun_app.{2 1} Type group.{0} (@matrix.vec_empty.{1} (function.extfun.{2 1} Type group.{0}) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero))) (has_pos_part.{0} real))  := sorry --non-trivial
lemma new_lemma_381 (h0 : topological_space (add_cancel_monoid (cancel_monoid pos))) : sequential_space (add_cancel_monoid (cancel_monoid pos)) := sorry --non-trivial
lemma new_lemma_382 (h0 : function.extfun Type topological_space) : @totally_disconnected_space.{0} (semi_normed_comm_ring.{0} string_imp) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (semi_normed_comm_ring.{0} string_imp))  := sorry --non-trivial
lemma new_lemma_383 (h0 : functor.add_const (topological_space (canonically_ordered_comm_semiring pos)) unsigned) : @t0_space.{0} (canonically_ordered_comm_semiring.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (canonically_ordered_comm_semiring.{0} pos)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_384 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @monoid.fg.{0} (monoid.{0} unsigned) (@function.extfun_app.{2 1} Type monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 monoid.{0}) (monoid.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_385 (h0 : topological_space (group_with_zero ennreal)) : t0_space (group_with_zero ennreal) := sorry --non-trivial
lemma new_lemma_386 (h0 : complete_lattice (encodable (random_gen fun_info))) : is_compactly_generated (encodable (random_gen fun_info)) := sorry --non-trivial
lemma new_lemma_387 (h0 : not (complete_lattice (has_one num) -> false)) : @is_atomistic.{0} (has_one.{0} num) (@classical.by_contradiction'.{1} (complete_lattice.{0} (has_one.{0} num)) h0)  := sorry --non-trivial
lemma new_lemma_388 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @topological_space.separable_space.{1} (plift.{1} unsigned) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 topological_space.{1}) (plift.{1} unsigned))  := sorry --non-trivial
lemma new_lemma_389 (h0 : function.extfun Type topological_space) : @topological_space.separable_space.{0} (linear_ordered_field.{0} (option.{0} (option.{0} empty))) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (linear_ordered_field.{0} (option.{0} (option.{0} empty))))  := sorry --non-trivial
lemma new_lemma_390 (h0 : ring (denumerable fun_info)) : is_domain (denumerable fun_info) := sorry --non-trivial
lemma new_lemma_391 (h0 : not (function.extfun Type topological_space -> false)) : @irreducible_space.{0} (semiring.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (semiring.{0} num))  := sorry --non-trivial
lemma new_lemma_392 (h0 : has_mul (ordered_comm_semiring (semiring congr_arg_kind))) (h1 : filter (con (ordered_comm_semiring (semiring congr_arg_kind)))) : filter.ne_bot h1 := sorry --non-trivial
lemma new_lemma_393 (h0 : topological_space (topological_space (has_nnnorm (has_nnnorm linarith.ineq)))) : totally_disconnected_space (topological_space (has_nnnorm (has_nnnorm linarith.ineq))) := sorry --non-trivial
lemma new_lemma_394 (h0 : function.extfun Type topological_space) : @totally_separated_space.{0} (has_neg_part.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_neg_part.{0} name))  := sorry --non-trivial
lemma new_lemma_395 (h0 : function.extfun Type topological_space) : @topological_space.separable_space.{0} (ordered_cancel_add_comm_monoid.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (ordered_cancel_add_comm_monoid.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_396 (h0 : fin has_zero.zero) : nat.perfect (matrix.vec_empty (matrix.vec_empty (matrix.vec_empty (id (id (matrix.vec_empty h0)))))) := sorry --non-trivial
lemma new_lemma_397 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_simple_group.{0} (option.{0} unsigned) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (option.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_398 (h0 : functor.add_const (list (linear_ordered_comm_monoid_with_zero unsigned)) (option empty)) : list.nodup (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_399 (h0 : group (has_nndist (has_add pos))) : normalizer_condition (has_nndist (has_add pos)) := sorry --non-trivial
lemma new_lemma_400 (h0 : monoid congr_arg_kind) : monoid.fg congr_arg_kind := sorry --non-trivial
lemma new_lemma_401 (h0 : topological_space (random_gen (semiring linarith.ineq))) : path_connected_space (random_gen (semiring linarith.ineq)) := sorry --non-trivial
lemma new_lemma_402 (h0 : list (is_R_or_C (option (option empty)))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_403 (h0 : function.extfun (Type 1) add_monoid) : @add_monoid.fg.{1} (has_zero.{1} Type) (@function.extfun_app.{3 2} (Type 1) add_monoid.{1} h0 (has_zero.{1} Type))  := sorry --non-trivial
lemma new_lemma_404 (h0 : group (distrib_lattice (random_gen fun_info))) : normalizer_condition (distrib_lattice (random_gen fun_info)) := sorry --non-trivial
lemma new_lemma_405 (h1 : has_lt (add_comm_semigroup char)) : no_max_order (add_comm_semigroup char) := sorry --non-trivial
lemma new_lemma_406 (h0 : function.extfun Type topological_space) : @t0_space.{0} (ordered_ring.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (ordered_ring.{0} num))  := sorry --non-trivial
lemma new_lemma_407 (h1 : ring (uniform_space linarith.comp_source)) : is_domain (uniform_space linarith.comp_source) := sorry --non-trivial
lemma new_lemma_408 (h0 : functor.add_const (topological_space (ordered_ring congr_arg_kind)) unsigned) : @loc_path_connected_space.{0} (ordered_ring.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (ordered_ring.{0} congr_arg_kind)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_409 (h0 : topological_space (plift (option (option empty)))) : totally_disconnected_space (plift (option (option empty))) := sorry --non-trivial
lemma new_lemma_410 (h0 : functor.add_const (topological_space (add_cancel_monoid linarith.comp)) linarith.comp) : @path_connected_space.{0} (add_cancel_monoid.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (add_cancel_monoid.{0} linarith.comp)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_411 (h0 : functor.add_const (topological_space (normed_comm_ring ennreal)) num) : @loc_path_connected_space.{0} (normed_comm_ring.{0} ennreal) (@functor.add_const.run.{0 0} (topological_space.{0} (normed_comm_ring.{0} ennreal)) num h0)  := sorry --non-trivial
lemma new_lemma_412 (h0 : functor.add_const (topological_space (add_group unsigned)) empty) : @discrete_topology.{0} (add_group.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (add_group.{0} unsigned)) empty h0)  := sorry --non-trivial
lemma new_lemma_413 (h0 : list (boolean_algebra (has_add pos))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_414 (h0 : group (has_append (comm_ring char))) : is_cyclic (has_append (comm_ring char)) := sorry --non-trivial
lemma new_lemma_415 (h0 : group (has_zero (has_add ennreal))) : group.fg (has_zero (has_add ennreal)) := sorry --non-trivial
lemma new_lemma_416 (h0 : not (ring (dlist linarith.ineq) -> false)) : @is_domain.{0} (dlist.{0} linarith.ineq) (@classical.by_contradiction'.{1} (ring.{0} (dlist.{0} linarith.ineq)) h0)  := sorry --non-trivial
lemma new_lemma_417 (h0 : ring (has_zero (has_add unsigned))) : is_principal_ideal_ring (has_zero (has_add unsigned)) := sorry --non-trivial
lemma new_lemma_418 (h0 : add_group (has_Inf (has_add linarith.comp))) : is_add_cyclic (has_Inf (has_add linarith.comp)) := sorry --non-trivial
lemma new_lemma_419 (h1 : has_mem.mem linarith.comp has_emptyc.emptyc) : @totally_separated_space.{0} linarith.comp (@finset.pi.empty.{1 0} Type topological_space.{0} linarith.comp h1)  := sorry --non-trivial
lemma new_lemma_420 (h0 : functor.add_const (function.extfun Type add_monoid) Type) : @add_monoid.fg.{0} (semigroup.{0} linarith.comp) (@function.extfun_app.{2 1} Type add_monoid.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type add_monoid.{0}) Type h0) (semigroup.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_421 (h0 : topological_space (monoid (option congr_arg_kind))) : path_connected_space (monoid (option congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_422 (h0 : function.extfun Type add_monoid) : @add_monoid.fg.{0} (has_top.{0} linarith.comp) (@function.extfun_app.{2 1} Type add_monoid.{0} h0 (has_top.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_423 (h0 : not (topological_space (has_top unsigned) -> false)) : @discrete_topology.{0} (has_top.{0} unsigned) (@classical.by_contradiction'.{1} (topological_space.{0} (has_top.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_424 (h0 : functor.add_const (topological_space (ring Type)) pos) : @totally_disconnected_space.{1} (ring.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (ring.{1} Type)) pos h0)  := sorry --non-trivial
lemma new_lemma_425 (h0 : not (topological_space (random_gen empty) -> false)) : @normal_space.{0} (random_gen.{0} empty) (@classical.by_contradiction'.{1} (topological_space.{0} (random_gen.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_426 (h1 : function.extfun (finset (Type -> Type)) (has_mem.mem complete_lattice)) : is_compactly_generated (measurable_space fun_info) := sorry --non-trivial
lemma new_lemma_427 (h0 : function.extfun Type topological_space) : @t0_space.{0} (comm_semigroup.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (comm_semigroup.{0} name))  := sorry --non-trivial
lemma new_lemma_428 (h0 : topological_space (has_Inf (has_Inf (ring linarith.comp)))) : t0_space (has_Inf (has_Inf (ring linarith.comp))) := sorry --non-trivial
lemma new_lemma_429 (h0 : topological_space (has_add (normed_comm_ring (has_pos_part (has_Inf linarith.comp))))) : path_connected_space (has_add (normed_comm_ring (has_pos_part (has_Inf linarith.comp)))) := sorry --non-trivial
lemma new_lemma_430 (h2 : set std_gen) : set.finite h2 := sorry --non-trivial
lemma new_lemma_431 (h0 : topological_space (has_star (semiring (semiring (semiring unsigned))))) : normal_space (has_star (semiring (semiring (semiring unsigned)))) := sorry --non-trivial
lemma new_lemma_432 (h0 : fin has_zero.zero) : @is_simple_group.{1} (generalized_boolean_algebra.{1} Type) (@matrix.vec_empty.{1} (group.{1} (generalized_boolean_algebra.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_433 (h0 : topological_space (add_comm_monoid ennreal)) : discrete_topology (add_comm_monoid ennreal) := sorry --non-trivial
lemma new_lemma_434 (h0 : functor.add_const (topological_space (comm_group Type)) name) : @preconnected_space.{1} (comm_group.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (comm_group.{1} Type)) name h0)  := sorry --non-trivial
lemma new_lemma_435 (h2 : add_group (distrib (random_gen (random_gen to_additive.value_type)))) : is_add_cyclic (distrib (random_gen (random_gen to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_436 (h0 : add_group (measure_theory.measure_space (semiring unsigned))) : is_add_cyclic (measure_theory.measure_space (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_437 (h0 : function.extfun Type topological_space) : @totally_separated_space.{0} (has_zero.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_zero.{0} name))  := sorry --non-trivial
lemma new_lemma_438 (h0 : functor.add_const (ordered_comm_monoid (canonically_ordered_comm_semiring name)) (has_neg linarith.comp)) : @has_exists_mul_of_le.{0} (canonically_ordered_comm_semiring.{0} name) (@functor.add_const.run.{0 0} (ordered_comm_monoid.{0} (canonically_ordered_comm_semiring.{0} name)) (has_neg.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_439 (h0 : functor.comp group has_zero name) : @is_simple_group.{0} (has_zero.{0} name) (@functor.comp.run.{0 0 0} group.{0} has_zero.{0} name h0)  := sorry --non-trivial
lemma new_lemma_440 (h0 : set (semi_normed_ring reducibility_hints)) : set.finite h0 := sorry --non-trivial
lemma new_lemma_441 (h0 : group (complete_semilattice_Sup (random_gen linarith.comp_source))) : group.fg (complete_semilattice_Sup (random_gen linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_442 (h0 : filter (normed_lattice_add_comm_group pos)) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_443 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_domain.{0} (random_gen.{0} fun_info) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (random_gen.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_444 (h2 : ring (semi_normed_ring char)) : rank_condition (semi_normed_ring char) := sorry --non-trivial
lemma new_lemma_445 (h0 : not (uniform_space (linear_ordered_semiring linarith.comp) -> false)) : @separated_space.{0} (linear_ordered_semiring.{0} linarith.comp) (@classical.by_contradiction'.{1} (uniform_space.{0} (linear_ordered_semiring.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_446 (h0 : topological_space (has_zero fun_info)) : path_connected_space (has_zero fun_info) := sorry --non-trivial
lemma new_lemma_447 (h0 : list (with_bot linarith.comp_source)) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_448 (h0 h1 : multiset (has_ssubset enat)) : multiset.subset h0 h1 := sorry --non-trivial
lemma new_lemma_449 (h0 : add_group (has_ssubset (metric_space char))) : is_add_cyclic (has_ssubset (metric_space char)) := sorry --non-trivial
lemma new_lemma_450 (h0 : pnat) (h1 : ulower (fin has_zero.zero)) : pnat.coprime h0 (matrix.vec_empty (ulower.up h1)) := sorry --non-trivial
lemma new_lemma_451 (h0 : ring (boolean_algebra (has_pos_part environment.implicit_infer_kind))) : is_domain (boolean_algebra (has_pos_part environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_452 (h0 : function.extfun (finset (Type -> Type)) (has_mem.mem topological_space)) : @irreducible_space.{0} (normed_group.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) topological_space.{0} (@function.extfun_app.{2 0} (finset.{1} (Type → Type)) (@has_mem.mem.{1 1} (Type → Type) (finset.{1} (Type → Type)) (@finset.has_mem.{1} (Type → Type)) topological_space.{0}) h0 (@has_emptyc.emptyc.{1} (finset.{1} (Type → Type)) (@finset.has_emptyc.{1} (Type → Type))))) (normed_group.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_453 (h0 : monoid (bin_tree (semiring (has_top empty)))) : monoid.fg (bin_tree (semiring (has_top empty))) := sorry --non-trivial
lemma new_lemma_454 (h0 : not (complete_lattice (measurable_space empty) -> false)) : is_compactly_generated (measurable_space empty) := sorry --non-trivial
lemma new_lemma_455 (h0 : topological_space (boolean_algebra.core (option ennreal))) : totally_separated_space (boolean_algebra.core (option ennreal)) := sorry --non-trivial
lemma new_lemma_456 (h1 : uniform_space (add_cancel_comm_monoid (metric_space char))) : complete_space (add_cancel_comm_monoid (metric_space char)) := sorry --non-trivial
lemma new_lemma_457 (h0 : complete_lattice (ordered_comm_monoid (has_Inf real))) : is_atomistic (ordered_comm_monoid (has_Inf real)) := sorry --non-trivial
lemma new_lemma_458 (h0 : monoid (has_nndist (has_add linarith.comp))) : monoid.fg (has_nndist (has_add linarith.comp)) := sorry --non-trivial
lemma new_lemma_459 (h0 : topological_space (has_Inf (has_Inf (ordered_ring name)))) : sequential_space (has_Inf (has_Inf (ordered_ring name))) := sorry --non-trivial
lemma new_lemma_460 (h0 : functor.comp complete_lattice canonically_ordered_comm_semiring Type) : @complete_lattice.is_Sup_finite_compact.{1} (canonically_ordered_comm_semiring.{1} Type) (@functor.add_const.run.{1 0} (complete_lattice.{1} (canonically_ordered_comm_semiring.{1} Type)) name (@functor.comp.run.{1 1 1} complete_lattice.{1} canonically_ordered_comm_semiring.{1} Type h0))  := sorry --non-trivial
lemma new_lemma_461 (h0 : topological_space (has_neg_part Type)) : regular_space (has_neg_part Type) := sorry --non-trivial
lemma new_lemma_462 (h0 : uniform_space (boolean_algebra (finset real))) : complete_space (boolean_algebra (finset real)) := sorry --non-trivial
lemma new_lemma_463 (h1 : topological_space (has_norm (has_top to_additive.value_type))) : discrete_topology (has_norm (has_top to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_464 (h0 : ring (random_gen num)) : is_domain (random_gen num) := sorry --non-trivial
lemma new_lemma_465 (h0 : complete_lattice (denumerable (has_nnnorm (has_nnnorm linarith.comp_source)))) : is_compactly_generated (denumerable (has_nnnorm (has_nnnorm linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_466 (h0 : ring (has_norm (has_top (has_top (has_top (has_top fun_info)))))) : rank_condition (has_norm (has_top (has_top (has_top (has_top fun_info))))) := sorry --non-trivial
lemma new_lemma_467 (h0 : functor.add_const (topological_space (has_nndist linarith.comp)) pos) : @discrete_topology.{0} (has_nndist.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (has_nndist.{0} linarith.comp)) pos h0)  := sorry --non-trivial
lemma new_lemma_468 (h0 : ring (has_top (semiring (semiring unsigned)))) : rank_condition (has_top (semiring (semiring unsigned))) := sorry --non-trivial
lemma new_lemma_469 (h0 : functor.add_const (topological_space (has_nndist unsigned)) name) : @discrete_topology.{0} (has_nndist.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (has_nndist.{0} unsigned)) name h0)  := sorry --non-trivial
lemma new_lemma_470 (h0 : group (has_zero (has_add (has_add (has_add (has_add linarith.comp)))))) : is_cyclic (has_zero (has_add (has_add (has_add (has_add linarith.comp))))) := sorry --non-trivial
lemma new_lemma_471 (h0 : functor.add_const (group (ring name)) (ring name)) : @group.fg.{0} (ring.{0} name) (@functor.add_const.run.{0 0} (group.{0} (ring.{0} name)) (ring.{0} name) h0)  := sorry --non-trivial
lemma new_lemma_472 (h0 : topological_space (normed_group string_imp)) : t0_space (normed_group string_imp) := sorry --non-trivial
lemma new_lemma_473 (h0 : not (topological_space (uniform_space (mul_one_class reducibility_hints)) -> false)) : @t0_space.{0} (uniform_space.{0} (mul_one_class.{0} reducibility_hints)) (@classical.by_contradiction'.{1} (topological_space.{0} (uniform_space.{0} (mul_one_class.{0} reducibility_hints))) h0)  := sorry --non-trivial
lemma new_lemma_474 (h0 : functor.add_const (uniform_space (normed_comm_ring name)) pos) : @complete_space.{0} (normed_comm_ring.{0} name) (@functor.add_const.run.{0 0} (uniform_space.{0} (normed_comm_ring.{0} name)) pos h0)  := sorry --non-trivial
lemma new_lemma_475 (h0 : function.extfun Type ring) : @rank_condition.{0} (measurable_space.dynkin_system.{0} unsigned) (@function.extfun_app.{2 1} Type ring.{0} h0 (measurable_space.dynkin_system.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_476 (h0 : functor.add_const (topological_space (add_cancel_monoid pos)) (has_neg name)) : @preconnected_space.{0} (add_cancel_monoid.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (add_cancel_monoid.{0} pos)) (has_neg.{0} name) h0)  := sorry --non-trivial
lemma new_lemma_477 (h0 : function.extfun Type complete_lattice) : @complete_lattice.is_Sup_finite_compact.{0} (has_emptyc.{0} fun_info) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (has_emptyc.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_478 (h0 : ring (complete_semilattice_Sup (has_ssubset (has_inv (random_gen to_additive.value_type))))) : is_domain (complete_semilattice_Sup (has_ssubset (has_inv (random_gen to_additive.value_type)))) := sorry --non-trivial
lemma new_lemma_479 (h0 : topological_space (ordered_comm_monoid real)) : discrete_topology (ordered_comm_monoid real) := sorry --non-trivial
lemma new_lemma_480 (h0 : not (function.extfun Type topological_space -> false)) : @locally_compact_space.{0} (random_gen.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (random_gen.{0} num))  := sorry --non-trivial
lemma new_lemma_481 (h0 : functor.add_const (topological_space (has_zero pos)) linarith.comp) : @preconnected_space.{0} (has_zero.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (has_zero.{0} pos)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_482 (h0 : topological_space (has_to_string congr_arg_kind)) : normal_space (has_to_string congr_arg_kind) := sorry --non-trivial
lemma new_lemma_483 (h0 : topological_space (option congr_arg_kind)) : t0_space (option congr_arg_kind) := sorry --non-trivial
lemma new_lemma_484 (h0 : group (with_bot (has_inv (has_inv (has_top fun_info))))) : is_cyclic (with_bot (has_inv (has_inv (has_top fun_info)))) := sorry --non-trivial
lemma new_lemma_485 (h0 : measurable_space (comm_ring char)) (h1 : not (has_sub (comm_ring char) -> false)) : @has_measurable_sub₂.{0} (comm_ring.{0} char) h0 (@classical.by_contradiction'.{1} (has_sub.{0} (comm_ring.{0} char)) h1)  := sorry --non-trivial
lemma new_lemma_486 (h0 : function.extfun Type uniform_space) : @complete_space.{0} (linear_ordered_add_comm_group.{0} string_imp) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (linear_ordered_add_comm_group.{0} string_imp))  := sorry --non-trivial
lemma new_lemma_487 (h0 : ring (normed_group (random_gen (random_gen to_additive.value_type)))) : strong_rank_condition (normed_group (random_gen (random_gen to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_488 (h0 : topological_space (comm_ring (has_nnnorm to_additive.value_type))) : locally_compact_space (comm_ring (has_nnnorm to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_489 (h0 : ring (boolean_algebra.core unsigned)) : rank_condition (boolean_algebra.core unsigned) := sorry --non-trivial
lemma new_lemma_490 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @is_atomistic.{1} (boolean_algebra.core.{1} Type) (@function.extfun_app.{3 2} (Type 1) complete_lattice.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 complete_lattice.{1}) (boolean_algebra.core.{1} Type))  := sorry --non-trivial
lemma new_lemma_491 (h0 : group (random_gen (random_gen (random_gen (has_norm linarith.ineq))))) : is_cyclic (random_gen (random_gen (random_gen (has_norm linarith.ineq)))) := sorry --non-trivial
lemma new_lemma_492 (h0 : function.extfun Type cancel_comm_monoid_with_zero) : @unique_factorization_monoid.{0} (has_Sup.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type cancel_comm_monoid_with_zero.{0} h0 (has_Sup.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_493 (h0 : functor.add_const (function.extfun (Type 1) topological_space) environment.implicit_infer_kind) : @t0_space.{1} (has_to_string.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) topological_space.{1}) environment.implicit_infer_kind h0) (has_to_string.{1} Type))  := sorry --non-trivial
lemma new_lemma_494 (h0 : function.extfun Type ring) : @is_domain.{0} (semigroup.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type ring.{0} h0 (semigroup.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_495 (h0 : functor.add_const (topological_space (cancel_monoid name)) linarith.comp) : @path_connected_space.{0} (cancel_monoid.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (cancel_monoid.{0} name)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_496 (h0 : functor.add_const (ring (normed_comm_ring Type)) environment.implicit_infer_kind) : @rank_condition.{1} (normed_comm_ring.{1} Type) (@functor.add_const.run.{1 0} (ring.{1} (normed_comm_ring.{1} Type)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_497 (h0 : topological_space (canonically_ordered_monoid (has_Inf (has_add Type)))) : discrete_topology (canonically_ordered_monoid (has_Inf (has_add Type))) := sorry --non-trivial
lemma new_lemma_498 (h0 : not (function.extfun Type list -> false)) : list.nodup (function.extfun_app (classical.by_contradiction' h0) (with_one unsigned)) := sorry --non-trivial
lemma new_lemma_499 (h1 : set (add_comm_semigroup (add_comm_semigroup string.iterator_imp))) : set.finite h1 := sorry --non-trivial
lemma new_lemma_500 (h0 : ring (partial_order empty)) : is_principal_ideal_ring (partial_order empty) := sorry --non-trivial
lemma new_lemma_501 (h0 : function.extfun Type group) : @normalizer_condition.{0} (sub_neg_monoid.{0} linarith.comp) (@function.extfun_app.{2 1} Type group.{0} h0 (sub_neg_monoid.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_502 (h0 : function.extfun Type complete_lattice) : @complete_lattice.is_Sup_finite_compact.{0} (normed_group.{0} string_imp) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (normed_group.{0} string_imp))  := sorry --non-trivial
lemma new_lemma_503 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_noetherian_ring.{0} (has_neg.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type semiring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 semiring.{0}) (has_neg.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_504 (h0 : functor.add_const (complete_lattice (has_neg_part name)) (has_to_string Type)) : @is_compactly_generated.{0} (has_neg_part.{0} name) (@functor.add_const.run.{0 1} (complete_lattice.{0} (has_neg_part.{0} name)) (has_to_string.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_505 (h0 : topological_space (complete_distrib_lattice (comm_group name))) : regular_space (complete_distrib_lattice (comm_group name)) := sorry --non-trivial
lemma new_lemma_506 (h0 : functor.add_const (topological_space (has_star empty)) (semiring num)) : @t1_space.{0} (has_star.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (has_star.{0} empty)) (semiring.{0} num) h0)  := sorry --non-trivial
lemma new_lemma_507 (h0 : uniform_space (ordered_comm_group (semiring (semiring empty)))) : complete_space (ordered_comm_group (semiring (semiring empty))) := sorry --non-trivial
lemma new_lemma_508 (h0 : topological_space (complete_semilattice_Sup empty)) : irreducible_space (complete_semilattice_Sup empty) := sorry --non-trivial
lemma new_lemma_509 (h0 : group (distrib_lattice (with_bot string_imp))) : is_cyclic (distrib_lattice (with_bot string_imp)) := sorry --non-trivial
lemma new_lemma_510 (h0 : filter (measurable_space unsigned)) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_511 (h0 : fin has_zero.zero) : @path_connected_space.{1} (sub_neg_monoid.{1} Type) (@matrix.vec_empty.{1} (topological_space.{1} (sub_neg_monoid.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_512 (h0 : topological_space (has_to_string (finset Type))) : normal_space (has_to_string (finset Type)) := sorry --non-trivial
lemma new_lemma_513 (h0 : complete_lattice (has_emptyc (has_norm (has_norm (has_norm (has_norm linarith.comp_source)))))) : is_atomistic (has_emptyc (has_norm (has_norm (has_norm (has_norm linarith.comp_source))))) := sorry --non-trivial
lemma new_lemma_514 (h0 : group (has_one (semiring (linear_ordered_semiring num)))) : normalizer_condition (has_one (semiring (linear_ordered_semiring num))) := sorry --non-trivial
lemma new_lemma_515 (h3 : add_group (has_nnnorm ereal)) : is_add_cyclic (has_nnnorm ereal) := sorry --non-trivial
lemma new_lemma_516 (h0 : not (function.extfun Type topological_space -> false)) : @totally_disconnected_space.{0} (random_gen.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (random_gen.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_517 (h1 : topological_space (add_comm_semigroup ereal)) : t0_space (add_comm_semigroup ereal) := sorry --non-trivial
lemma new_lemma_518 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : filter.ne_bot (function.extfun_app (function.extfun_app h0 filter) (has_sub empty)) := sorry --non-trivial
lemma new_lemma_519 (h0 : ring (topological_space (has_ssubset string_imp))) : rank_condition (topological_space (has_ssubset string_imp)) := sorry --non-trivial
lemma new_lemma_520 (h0 : functor.add_const (ring (has_zero Type)) linarith.comp) : @rank_condition.{1} (has_zero.{1} Type) (@functor.add_const.run.{1 0} (ring.{1} (has_zero.{1} Type)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_521 (h0 : function.extfun Type topological_space) : @totally_disconnected_space.{0} (boolean_algebra.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (boolean_algebra.{0} name))  := sorry --non-trivial
lemma new_lemma_522 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_noetherian_ring.{0} (ordered_cancel_add_comm_monoid.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type semiring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 semiring.{0}) (ordered_cancel_add_comm_monoid.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_523 (h0 : not (complete_lattice (has_nnnorm reducibility_hints) -> false)) : @is_compactly_generated.{0} (has_nnnorm.{0} reducibility_hints) (@classical.by_contradiction'.{1} (complete_lattice.{0} (has_nnnorm.{0} reducibility_hints)) h0)  := sorry --non-trivial
lemma new_lemma_524 (h0 : group (has_union (has_norm (has_norm num)))) : is_cyclic (has_union (has_norm (has_norm num))) := sorry --non-trivial
lemma new_lemma_525 (h0 : not (topological_space (denumerable to_additive.value_type) -> false)) : @locally_compact_space.{0} (denumerable.{0} to_additive.value_type) (@classical.by_contradiction'.{1} (topological_space.{0} (denumerable.{0} to_additive.value_type)) h0)  := sorry --non-trivial
lemma new_lemma_526 (h0 : add_group (partial_order unsigned)) : is_add_cyclic (partial_order unsigned) := sorry --non-trivial
lemma new_lemma_527 (h0 : ring (has_nnnorm linarith.comp_source)) : strong_rank_condition (has_nnnorm linarith.comp_source) := sorry --non-trivial
lemma new_lemma_528 (h0 : topological_space (plift empty)) : topological_space.separable_space (plift empty) := sorry --non-trivial
lemma new_lemma_529 (h0 : complete_lattice (has_one (has_norm unsigned))) : is_atomistic (has_one (has_norm unsigned)) := sorry --non-trivial
lemma new_lemma_530 (h0 : functor.add_const (function.extfun Type uniform_space) pos) : @separated_space.{0} (has_nndist.{0} pos) (@function.extfun_app.{2 1} Type uniform_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type uniform_space.{0}) pos h0) (has_nndist.{0} pos))  := sorry --non-trivial
lemma new_lemma_531 (h0 : topological_space (option num)) : irreducible_space (option num) := sorry --non-trivial
lemma new_lemma_532 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @totally_separated_space.{0} (@id.{2} Type unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (@id.{2} Type unsigned))  := sorry --non-trivial
lemma new_lemma_533 (h0 : topological_space (has_one num)) : path_connected_space (has_one num) := sorry --non-trivial
lemma new_lemma_534 (h0 : function.extfun Type ring) : @is_domain.{0} (has_to_string.{0} num) (@function.extfun_app.{2 1} Type ring.{0} h0 (has_to_string.{0} num))  := sorry --non-trivial
lemma new_lemma_535 (h0 : ring (simple_graph (mul_one_class (mul_one_class enat)))) : strong_rank_condition (simple_graph (mul_one_class (mul_one_class enat))) := sorry --non-trivial
lemma new_lemma_536 (h0 : group (has_Inf (has_Inf (has_add real)))) : is_simple_group (has_Inf (has_Inf (has_add real))) := sorry --non-trivial
lemma new_lemma_537 (h0 : complete_lattice (has_zero (ring (has_neg_part (has_neg_part (has_neg_part Type)))))) : is_atomistic (has_zero (ring (has_neg_part (has_neg_part (has_neg_part Type))))) := sorry --non-trivial
lemma new_lemma_538 (h0 h1 : multiset (linear_ordered_comm_group_with_zero string.iterator_imp)) : multiset.disjoint h0 h1 := sorry --non-trivial
lemma new_lemma_539 (h0 : functor.add_const (cancel_comm_monoid_with_zero (pseudo_metric_space pos)) pos) : @unique_factorization_monoid.{0} (pseudo_metric_space.{0} pos) (@functor.add_const.run.{0 0} (cancel_comm_monoid_with_zero.{0} (pseudo_metric_space.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_540 (h0 : functor.add_const (topological_space (has_star unsigned)) (semiring num)) : @discrete_topology.{0} (has_star.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (has_star.{0} unsigned)) (semiring.{0} num) h0)  := sorry --non-trivial
lemma new_lemma_541 (h0 : cancel_comm_monoid_with_zero (bin_tree unsigned)) : unique_factorization_monoid (bin_tree unsigned) := sorry --non-trivial
lemma new_lemma_542 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @irreducible_space.{0} (add_comm_monoid.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (add_comm_monoid.{0} pos))  := sorry --non-trivial
lemma new_lemma_543 (h0 : functor.comp group boolean_algebra.core ennreal) : @is_simple_group.{0} (boolean_algebra.core.{0} ennreal) (@functor.comp.run.{0 0 0} group.{0} boolean_algebra.core.{0} ennreal h0)  := sorry --non-trivial
lemma new_lemma_544 (h0 : functor.add_const (filter (finset linarith.comp)) linarith.comp) : countable_Inter_filter (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_545 (h0 : ring (pseudo_metric_space (option ennreal))) : is_domain (pseudo_metric_space (option ennreal)) := sorry --non-trivial
lemma new_lemma_546 (h0 : functor.add_const (functor.add_const (topological_space Type) Type) (ring (ring (has_add linarith.comp)))) : @discrete_topology.{1} Type (@functor.add_const.run.{1 1} (topological_space.{1} Type) Type (@functor.add_const.run.{1 0} (functor.add_const.{1 1} (topological_space.{1} Type) Type) (ring.{0} (ring.{0} (has_add.{0} linarith.comp))) h0))  := sorry --non-trivial
lemma new_lemma_547 (h0 : functor.add_const (ordered_add_comm_monoid (plift empty)) (semiring empty)) : @archimedean.{1} (plift.{1} empty) (@functor.add_const.run.{1 0} (ordered_add_comm_monoid.{1} (plift.{1} empty)) (semiring.{0} empty) h0)  := sorry --non-trivial
lemma new_lemma_548 (h0 : functor.add_const (function.extfun (Type 1) topological_space) environment.implicit_infer_kind) : @path_connected_space.{1} (finset.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) topological_space.{1}) environment.implicit_infer_kind h0) (finset.{1} Type))  := sorry --non-trivial
lemma new_lemma_549 (h0 : functor.add_const (topological_space (has_edist unsigned)) congr_arg_kind) : @locally_compact_space.{0} (has_edist.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (has_edist.{0} unsigned)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_550 (h0 : functor.add_const (topological_space (mul_zero_class pos)) name) : @path_connected_space.{0} (mul_zero_class.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (mul_zero_class.{0} pos)) name h0)  := sorry --non-trivial
lemma new_lemma_551 (h0 : complete_lattice (distrib_lattice (denumerable to_additive.value_type))) : is_compactly_generated (distrib_lattice (denumerable to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_552 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @locally_compact_space.{0} (has_neg.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_neg.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_553 (h0 : function.extfun (Type 1) (functor.comp filter semigroup)) : countable_Inter_filter (functor.comp.run (function.extfun_app h0 Type)) := sorry --non-trivial
lemma new_lemma_554 (h0 : topological_space (add_cancel_monoid ennreal)) : totally_separated_space (add_cancel_monoid ennreal) := sorry --non-trivial
lemma new_lemma_555 (h0 : topological_space (has_star unsigned)) : normal_space (has_star unsigned) := sorry --non-trivial
lemma new_lemma_556 (h0 : functor.add_const (function.extfun Type filter) environment.implicit_infer_kind) : filter.ne_bot (function.extfun_app (functor.add_const.run h0) (has_to_string pos)) := sorry --non-trivial
lemma new_lemma_557 (h0 : not (finset (with_bot congr_arg_kind) -> false)) : finset.nonempty (classical.by_contradiction' h0) := sorry --non-trivial
lemma new_lemma_558 (h0 : ordered_comm_monoid pos) : has_exists_mul_of_le pos := sorry --non-trivial
lemma new_lemma_559 (h0 : function.extfun Type (functor.add_const (topological_space name))) : @discrete_topology.{0} name (@functor.add_const.run.{0 0} (topological_space.{0} name) num (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (topological_space.{0} name)) h0 num))  := sorry --non-trivial
lemma new_lemma_560 (h1 : topological_space (add_right_cancel_monoid linarith.comp_source)) : path_connected_space (add_right_cancel_monoid linarith.comp_source) := sorry --non-trivial
lemma new_lemma_561 (h0 : topological_space (left_cancel_monoid unsigned)) : loc_path_connected_space (left_cancel_monoid unsigned) := sorry --non-trivial
lemma new_lemma_562 (h0 : topological_space (has_dist (comm_monoid unsigned))) : normal_space (has_dist (comm_monoid unsigned)) := sorry --non-trivial
lemma new_lemma_563 (h1 : not (function.extfun (finset Type) (has_mem.mem linarith.comp) -> false)) : @strong_rank_condition.{0} linarith.comp (@finset.pi.empty.{1 0} Type ring.{0} linarith.comp (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) linarith.comp) (@classical.by_contradiction'.{0} (function.extfun.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) linarith.comp)) h1) (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_564 (h0 : semiring (generalized_boolean_algebra (has_pos_part (has_Inf real)))) : is_noetherian_ring (generalized_boolean_algebra (has_pos_part (has_Inf real))) := sorry --non-trivial
lemma new_lemma_565 (h0 : function.extfun Type topological_space) : @loc_path_connected_space.{0} (semiring.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (semiring.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_566 (h0 : group (semigroup (has_scalar pos (has_nndist pos)))) : group.fg (semigroup (has_scalar pos (has_nndist pos))) := sorry --non-trivial
lemma new_lemma_567 (h0 : functor.add_const (topological_space (boolean_algebra unsigned)) linarith.comp) : @locally_compact_space.{0} (boolean_algebra.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (boolean_algebra.{0} unsigned)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_568 (h0 : functor.add_const (uniform_space (comm_group pos)) Type) : @complete_space.{0} (comm_group.{0} pos) (@functor.add_const.run.{0 1} (uniform_space.{0} (comm_group.{0} pos)) Type h0)  := sorry --non-trivial
lemma new_lemma_569 (h0 : topological_space (has_bot real)) : topological_space.separable_space (has_bot real) := sorry --non-trivial
lemma new_lemma_570 (h0 : topological_space (simple_graph (has_Inf (finset (finset Type))))) : totally_separated_space (simple_graph (has_Inf (finset (finset Type)))) := sorry --non-trivial
lemma new_lemma_571 (h0 : functor.add_const (function.extfun (Type 1) ordered_comm_monoid) name) : @has_exists_mul_of_le.{1} (has_zero.{1} Type) (@function.extfun_app.{3 2} (Type 1) ordered_comm_monoid.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) ordered_comm_monoid.{1}) name h0) (has_zero.{1} Type))  := sorry --non-trivial
lemma new_lemma_572 (h0 : topological_space (has_neg (boolean_algebra pos))) : totally_disconnected_space (has_neg (boolean_algebra pos)) := sorry --non-trivial
lemma new_lemma_573 (h0 : ring (has_one (has_zero unsigned))) : is_domain (has_one (has_zero unsigned)) := sorry --non-trivial
lemma new_lemma_574 (h0 : group (complete_semilattice_Sup (comm_ring (comm_ring linarith.ineq)))) : is_cyclic (complete_semilattice_Sup (comm_ring (comm_ring linarith.ineq))) := sorry --non-trivial
lemma new_lemma_575 (h0 : function.extfun Type topological_space) : @preconnected_space.{0} (mul_zero_class.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (mul_zero_class.{0} pos))  := sorry --non-trivial
lemma new_lemma_576 (h0 : complete_lattice (canonically_ordered_comm_semiring unsigned)) : is_atomistic (canonically_ordered_comm_semiring unsigned) := sorry --non-trivial
lemma new_lemma_577 (h0 : group (dlist (linear_ordered_add_comm_group char))) : is_cyclic (dlist (linear_ordered_add_comm_group char)) := sorry --non-trivial
lemma new_lemma_578 (h0 : list (has_neg (option (option empty)))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_579 (h0 : ring (has_nnnorm (random_gen (has_nnnorm (has_nnnorm string_imp))))) : rank_condition (has_nnnorm (random_gen (has_nnnorm (has_nnnorm string_imp)))) := sorry --non-trivial
lemma new_lemma_580 (h0 : not (add_group (finset to_additive.value_type) -> false)) : @is_add_cyclic.{0} (finset.{0} to_additive.value_type) (@classical.by_contradiction'.{1} (add_group.{0} (finset.{0} to_additive.value_type)) h0)  := sorry --non-trivial
lemma new_lemma_581 (h0 : group (with_one (random_gen char))) : group.fg (with_one (random_gen char)) := sorry --non-trivial
lemma new_lemma_582 (h0 : functor.add_const (topological_space (normed_comm_ring ennreal)) pos) : @locally_compact_space.{0} (normed_comm_ring.{0} ennreal) (@functor.add_const.run.{0 0} (topological_space.{0} (normed_comm_ring.{0} ennreal)) pos h0)  := sorry --non-trivial
lemma new_lemma_583 (h0 : functor.add_const (function.extfun (Type 1) topological_space) pos) : @totally_disconnected_space.{1} (has_neg.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) topological_space.{1}) pos h0) (has_neg.{1} Type))  := sorry --non-trivial
lemma new_lemma_584 (h0 : topological_space (add_cancel_monoid (finset environment.implicit_infer_kind))) : loc_path_connected_space (add_cancel_monoid (finset environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_585 (h0 : group (add_cancel_monoid (has_to_string (has_to_string pos)))) : normalizer_condition (add_cancel_monoid (has_to_string (has_to_string pos))) := sorry --non-trivial
lemma new_lemma_586 (h0 : topological_space (generalized_boolean_algebra name)) : path_connected_space (generalized_boolean_algebra name) := sorry --non-trivial
lemma new_lemma_587 (h0 : topological_space (has_sdiff (ordered_comm_monoid real))) : t1_space (has_sdiff (ordered_comm_monoid real)) := sorry --non-trivial
lemma new_lemma_588 (h0 : function.extfun Type topological_space) : @locally_compact_space.{0} (lex.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (lex.{0} num))  := sorry --non-trivial
lemma new_lemma_589 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @add_monoid.fg.{0} (comm_semigroup.{0} real) (@function.extfun_app.{2 1} Type add_monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 add_monoid.{0}) (comm_semigroup.{0} real))  := sorry --non-trivial
lemma new_lemma_590 (h0 : topological_space (has_nndist (option unsigned))) : sequential_space (has_nndist (option unsigned)) := sorry --non-trivial
lemma new_lemma_591 (h0 : uniform_space (plift num)) : separated_space (plift num) := sorry --non-trivial
lemma new_lemma_592 (h0 : not (topological_space (normed_group real.angle) -> false)) : @path_connected_space.{0} (normed_group.{0} real.angle) (@classical.by_contradiction'.{1} (topological_space.{0} (normed_group.{0} real.angle)) h0)  := sorry --non-trivial
lemma new_lemma_593 (h1 : add_group string_imp) : is_add_cyclic string_imp := sorry --non-trivial
lemma new_lemma_594 (h0 : functor.add_const (add_group (add_cancel_monoid name)) unsigned) : @is_add_cyclic.{0} (add_cancel_monoid.{0} name) (@functor.add_const.run.{0 0} (add_group.{0} (add_cancel_monoid.{0} name)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_595 (h0 : filter (has_inv (random_gen char))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_596 (h1 : topological_space (simple_graph linarith.ineq)) (h2 : preorder (simple_graph linarith.ineq)) : order_topology (simple_graph linarith.ineq) := sorry --non-trivial
lemma new_lemma_597 (h0 : topological_space (has_to_string (comm_group (has_add pos)))) : irreducible_space (has_to_string (comm_group (has_add pos))) := sorry --non-trivial
lemma new_lemma_598 (h0 h1 : multiset (simple_graph std_gen)) : multiset.subset h0 h1 := sorry --non-trivial
lemma new_lemma_599 (h0 : ordered_add_comm_monoid (has_add (option (option ennreal)))) : archimedean (has_add (option (option ennreal))) := sorry --non-trivial
lemma new_lemma_600 (h0 : topological_space (normed_lattice_add_comm_group (sub_neg_monoid real))) : discrete_topology (normed_lattice_add_comm_group (sub_neg_monoid real)) := sorry --non-trivial
lemma new_lemma_601 (h1 : has_le linarith.ineq) (h2 : linarith.ineq) : is_bot h2 := sorry --non-trivial
lemma new_lemma_602 (h0 : functor.add_const (group (left_cancel_semigroup empty)) (semiring empty)) : @group.fg.{0} (left_cancel_semigroup.{0} empty) (@functor.add_const.run.{0 0} (group.{0} (left_cancel_semigroup.{0} empty)) (semiring.{0} empty) h0)  := sorry --non-trivial
lemma new_lemma_603 (h0 : topological_space (plift num)) : preirreducible_space (plift num) := sorry --non-trivial
lemma new_lemma_604 (h0 : ordered_add_comm_monoid (semigroup (option (ring name)))) : archimedean (semigroup (option (ring name))) := sorry --non-trivial
lemma new_lemma_605 (h0 : ring unsigned) : is_principal_ideal_ring unsigned := sorry --non-trivial
lemma new_lemma_606 (h0 : function.extfun Type topological_space) : @regular_space.{0} (pseudo_metric_space.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (pseudo_metric_space.{0} pos))  := sorry --non-trivial
lemma new_lemma_607 (h0 : group (comm_group environment.implicit_infer_kind)) : is_cyclic (comm_group environment.implicit_infer_kind) := sorry --non-trivial
lemma new_lemma_608 (h0 : group (complete_linear_order (semiring (semiring (semiring (semiring num)))))) : group.fg (complete_linear_order (semiring (semiring (semiring (semiring num))))) := sorry --non-trivial
lemma new_lemma_609 (h0 : functor.add_const (topological_space (normed_comm_ring linarith.comp)) (has_neg linarith.comp)) : @t0_space.{0} (normed_comm_ring.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (normed_comm_ring.{0} linarith.comp)) (has_neg.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_610 (h0 : add_monoid (partial_order (semiring congr_arg_kind))) : add_monoid.fg (partial_order (semiring congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_611 (h0 : topological_space (has_nnnorm (random_gen linarith.comp_source))) : t0_space (has_nnnorm (random_gen linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_612 (h0 : complete_lattice (measurable_space (has_norm empty))) : complete_lattice.is_Sup_finite_compact (measurable_space (has_norm empty)) := sorry --non-trivial
lemma new_lemma_613 (h0 : functor.add_const (filter (normed_comm_ring Type)) (has_add environment.implicit_infer_kind)) : filter.ne_bot (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_614 (h0 : add_group (has_compl (has_ssubset (has_ssubset (has_ssubset to_additive.value_type))))) : is_add_cyclic (has_compl (has_ssubset (has_ssubset (has_ssubset to_additive.value_type)))) := sorry --non-trivial
lemma new_lemma_615 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : list.nodup (function.extfun_app (function.extfun_app h0 list) (left_cancel_semigroup empty)) := sorry --non-trivial
lemma new_lemma_616 (h0 : functor.add_const (topological_space (boolean_algebra.core environment.implicit_infer_kind)) pos) : @preirreducible_space.{0} (boolean_algebra.core.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (boolean_algebra.core.{0} environment.implicit_infer_kind)) pos h0)  := sorry --non-trivial
lemma new_lemma_617 (h0 : topological_space (has_to_string (finset environment.implicit_infer_kind))) : regular_space (has_to_string (finset environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_618 (h0 : function.extfun Type topological_space) : @irreducible_space.{0} (group_with_zero.{0} ennreal) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (group_with_zero.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_619 (h0 : functor.add_const (ring (has_neg Type)) environment.implicit_infer_kind) : @rank_condition.{1} (has_neg.{1} Type) (@functor.add_const.run.{1 0} (ring.{1} (has_neg.{1} Type)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_620 (h0 : topological_space (normed_lattice_add_comm_group (has_Inf Type))) : path_connected_space (normed_lattice_add_comm_group (has_Inf Type)) := sorry --non-trivial
lemma new_lemma_621 (h0 : functor.add_const (function.extfun (Type 1) complete_lattice) name) : @is_atomistic.{1} Type (@function.extfun_app.{3 2} (Type 1) complete_lattice.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) complete_lattice.{1}) name h0) Type)  := sorry --non-trivial
lemma new_lemma_622 (h0 : functor.add_const (ordered_comm_monoid (ring name)) Type) : @has_exists_mul_of_le.{0} (ring.{0} name) (@functor.add_const.run.{0 1} (ordered_comm_monoid.{0} (ring.{0} name)) Type h0)  := sorry --non-trivial
lemma new_lemma_623 (h0 : add_monoid (cancel_monoid (boolean_algebra.core name))) : add_monoid.fg (cancel_monoid (boolean_algebra.core name)) := sorry --non-trivial
lemma new_lemma_624 (h0 : monoid (add_comm_monoid (has_add (finset (has_add (has_Inf name)))))) : monoid.fg (add_comm_monoid (has_add (finset (has_add (has_Inf name))))) := sorry --non-trivial
lemma new_lemma_625 (h0 : topological_space (normed_comm_ring name)) : preirreducible_space (normed_comm_ring name) := sorry --non-trivial
lemma new_lemma_626 (h0 : function.extfun (finset (Type -> Type)) (has_mem.mem group)) : @normalizer_condition.{0} (has_top.{0} num) (@function.extfun_app.{2 1} Type group.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) group.{0} (@function.extfun_app.{2 0} (finset.{1} (Type → Type)) (@has_mem.mem.{1 1} (Type → Type) (finset.{1} (Type → Type)) (@finset.has_mem.{1} (Type → Type)) group.{0}) h0 (@has_emptyc.emptyc.{1} (finset.{1} (Type → Type)) (@finset.has_emptyc.{1} (Type → Type))))) (has_top.{0} num))  := sorry --non-trivial
lemma new_lemma_627 (h0 : not (topological_space (semi_normed_comm_ring linarith.ineq) -> false)) : @path_connected_space.{0} (semi_normed_comm_ring.{0} linarith.ineq) (@classical.by_contradiction'.{1} (topological_space.{0} (semi_normed_comm_ring.{0} linarith.ineq)) h0)  := sorry --non-trivial
lemma new_lemma_628 (h0 : uniform_space (has_emptyc to_additive.value_type)) : complete_space (has_emptyc to_additive.value_type) := sorry --non-trivial
lemma new_lemma_629 (h0 : topological_space (sub_neg_monoid (has_Inf (ordered_comm_monoid (has_Inf real))))) : irreducible_space (sub_neg_monoid (has_Inf (ordered_comm_monoid (has_Inf real)))) := sorry --non-trivial
lemma new_lemma_630 (h0 : functor.comp uniform_space has_to_string pos) : @separated_space.{0} (has_to_string.{0} pos) (@functor.comp.run.{0 0 0} uniform_space.{0} has_to_string.{0} pos h0)  := sorry --non-trivial
lemma new_lemma_631 (h0 : ring (semigroup (has_nndist pos))) : strong_rank_condition (semigroup (has_nndist pos)) := sorry --non-trivial
lemma new_lemma_632 (h0 : not (topological_space (random_gen empty) -> false)) : @preirreducible_space.{0} (random_gen.{0} empty) (@classical.by_contradiction'.{1} (topological_space.{0} (random_gen.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_633 (h0 : topological_space (boolean_algebra (has_add Type))) : totally_separated_space (boolean_algebra (has_add Type)) := sorry --non-trivial
lemma new_lemma_634 (h0 : topological_space (has_union (has_top (has_top empty)))) : discrete_topology (has_union (has_top (has_top empty))) := sorry --non-trivial
lemma new_lemma_635 (h0 : topological_space (has_pos_part (has_Inf (has_add (has_Inf pos))))) : path_connected_space (has_pos_part (has_Inf (has_add (has_Inf pos)))) := sorry --non-trivial
lemma new_lemma_636 (h0 : topological_space (finset (option (option (option pos))))) : path_connected_space (finset (option (option (option pos)))) := sorry --non-trivial
lemma new_lemma_637 (h0 : monoid (option (semiring (semiring (semiring (semiring (semiring empty))))))) : monoid.fg (option (semiring (semiring (semiring (semiring (semiring empty)))))) := sorry --non-trivial
lemma new_lemma_638 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @monoid.fg.{0} (semiring.{0} linarith.ineq) (@function.extfun_app.{2 1} Type monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 monoid.{0}) (semiring.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_639 (h0 : topological_space (has_bot (has_Inf real))) : regular_space (has_bot (has_Inf real)) := sorry --non-trivial
lemma new_lemma_640 (h0 : complete_lattice (complete_distrib_lattice (has_Inf pos))) : complete_lattice.is_Sup_finite_compact (complete_distrib_lattice (has_Inf pos)) := sorry --non-trivial
lemma new_lemma_641 (h1 : function.extfun (Type -> Type) (function.extfun Type)) : @is_domain.{0} (dlist.{0} string_imp) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h1 ring.{0}) (dlist.{0} string_imp))  := sorry --non-trivial
lemma new_lemma_642 (h0 : functor.add_const (add_group (has_nndist pos)) linarith.comp) : @is_add_cyclic.{0} (has_nndist.{0} pos) (@functor.add_const.run.{0 0} (add_group.{0} (has_nndist.{0} pos)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_643 (h0 : functor.add_const (topological_space (measure_theory.measure_space congr_arg_kind)) empty) : @totally_disconnected_space.{0} (measure_theory.measure_space.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (measure_theory.measure_space.{0} congr_arg_kind)) empty h0)  := sorry --non-trivial
lemma new_lemma_644 (h0 : function.extfun Type add_group) : @is_add_cyclic.{0} (random_gen.{0} linarith.comp) (@function.extfun_app.{2 1} Type add_group.{0} h0 (random_gen.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_645 (h0 : ring (add_comm_monoid (has_add environment.implicit_infer_kind))) : is_domain (add_comm_monoid (has_add environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_646 (h0 : group (has_inv (has_inv string_imp))) : normalizer_condition (has_inv (has_inv string_imp)) := sorry --non-trivial
lemma new_lemma_647 (h0 : monoid (normed_group linarith.ineq)) : monoid.fg (normed_group linarith.ineq) := sorry --non-trivial
lemma new_lemma_648 (h0 : not (function.extfun Type add_monoid -> false)) : @add_monoid.fg.{0} (measure_theory.measure_space.{0} unsigned) (@function.extfun_app.{2 1} Type add_monoid.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type add_monoid.{0}) h0) (measure_theory.measure_space.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_649 (h0 : function.extfun Type topological_space) : @normal_space.{0} (add_cancel_monoid.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (add_cancel_monoid.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_650 (h0 : topological_space (has_to_string (has_to_string congr_arg_kind))) : t1_space (has_to_string (has_to_string congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_651 (h0 : topological_space (has_nnnorm (metric_space enat))) : path_connected_space (has_nnnorm (metric_space enat)) := sorry --non-trivial
lemma new_lemma_652 (h0 : ring (add_comm_semigroup char)) : strong_rank_condition (add_comm_semigroup char) := sorry --non-trivial
lemma new_lemma_653 (h0 : functor.add_const (topological_space (non_assoc_semiring unsigned)) num) : @preirreducible_space.{0} (non_assoc_semiring.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (non_assoc_semiring.{0} unsigned)) num h0)  := sorry --non-trivial
lemma new_lemma_654 (h0 : monoid (option (option (option empty)))) : monoid.fg (option (option (option empty))) := sorry --non-trivial
lemma new_lemma_655 (h0 : function.extfun Type (functor.add_const (function.extfun Type uniform_space))) : @complete_space.{0} (has_zero.{0} linarith.comp) (@function.extfun_app.{2 1} Type uniform_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type uniform_space.{0}) pos (@function.extfun_app.{2 2} Type (functor.add_const.{1 0} (function.extfun.{2 1} Type uniform_space.{0})) h0 pos)) (has_zero.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_656 (h0 : ring (fintype (has_top fun_info))) : rank_condition (fintype (has_top fun_info)) := sorry --non-trivial
lemma new_lemma_657 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @t1_space.{1} (has_Inf.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 topological_space.{1}) (has_Inf.{1} Type))  := sorry --non-trivial
lemma new_lemma_658 (h0 : complete_lattice (comm_ring (has_nnnorm reducibility_hints))) : complete_lattice.is_Sup_finite_compact (comm_ring (has_nnnorm reducibility_hints)) := sorry --non-trivial
lemma new_lemma_659 (h0 : functor.add_const (function.extfun (Type 1) ordered_comm_monoid) (has_to_string environment.implicit_infer_kind)) : @has_exists_mul_of_le.{1} (add_comm_monoid.{1} Type) (@function.extfun_app.{3 2} (Type 1) ordered_comm_monoid.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) ordered_comm_monoid.{1}) (has_to_string.{0} environment.implicit_infer_kind) h0) (add_comm_monoid.{1} Type))  := sorry --non-trivial
lemma new_lemma_660 (h2 : add_group (has_inv to_additive.value_type)) : is_add_cyclic (has_inv to_additive.value_type) := sorry --non-trivial
lemma new_lemma_661 (h0 : semiring (add_comm_monoid (sub_neg_monoid name))) : is_noetherian_ring (add_comm_monoid (sub_neg_monoid name)) := sorry --non-trivial
lemma new_lemma_662 (h0 : function.extfun Type topological_space) : @totally_disconnected_space.{0} (denumerable.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (denumerable.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_663 (h0 : has_mem.mem (has_top congr_arg_kind) has_emptyc.emptyc) : @totally_disconnected_space.{0} (has_top.{0} congr_arg_kind) (@finset.pi.empty.{1 0} Type topological_space.{0} (has_top.{0} congr_arg_kind) h0)  := sorry --non-trivial
lemma new_lemma_664 (h0 : function.extfun Type topological_space) : @totally_separated_space.{0} (has_norm.{0} string_imp) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_norm.{0} string_imp))  := sorry --non-trivial
lemma new_lemma_665 (h0 : functor.add_const (add_monoid (add_cancel_monoid empty)) empty) : @add_monoid.fg.{0} (add_cancel_monoid.{0} empty) (@functor.add_const.run.{0 0} (add_monoid.{0} (add_cancel_monoid.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_666 (h0 : functor.add_const (ring (has_nndist unsigned)) (option empty)) : @strong_rank_condition.{0} (has_nndist.{0} unsigned) (@functor.add_const.run.{0 0} (ring.{0} (has_nndist.{0} unsigned)) (option.{0} empty) h0)  := sorry --non-trivial
lemma new_lemma_667 (h0 : topological_space (filter congr_arg_kind)) : t0_space (filter congr_arg_kind) := sorry --non-trivial
lemma new_lemma_668 (h0 : functor.add_const (complete_lattice (has_nndist Type)) pos) : @complete_lattice.is_Sup_finite_compact.{1} (has_nndist.{1} Type) (@functor.add_const.run.{1 0} (complete_lattice.{1} (has_nndist.{1} Type)) pos h0)  := sorry --non-trivial
lemma new_lemma_669 (h0 : functor.add_const (topological_space (has_Inf pos)) name) : @totally_disconnected_space.{0} (has_Inf.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (has_Inf.{0} pos)) name h0)  := sorry --non-trivial
lemma new_lemma_670 (h0 : functor.add_const Prop (has_nndist unsigned)) : functor.add_const.run h0 := sorry --non-trivial
lemma new_lemma_671 (h0 : ordered_comm_monoid (normed_comm_ring (ring (finset environment.implicit_infer_kind)))) : has_exists_mul_of_le (normed_comm_ring (ring (finset environment.implicit_infer_kind))) := sorry --non-trivial
lemma new_lemma_672 (h0 : functor.add_const (ring (has_nndist Type)) name) : @is_domain.{1} (has_nndist.{1} Type) (@functor.add_const.run.{1 0} (ring.{1} (has_nndist.{1} Type)) name h0)  := sorry --non-trivial
lemma new_lemma_673 (h0 : function.extfun Type (prod (linear_order unsigned))) : id_rel (function.extfun_app h0 (linear_order unsigned)) := sorry --non-trivial
lemma new_lemma_674 (h0 : functor.add_const (function.extfun Type topological_space) linarith.comp) : @totally_disconnected_space.{0} (has_zero.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) linarith.comp h0) (has_zero.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_675 (h0 : functor.comp ordered_comm_monoid add_comm_monoid linarith.comp) : @has_exists_mul_of_le.{0} (add_comm_monoid.{0} linarith.comp) (@functor.comp.run.{0 0 0} ordered_comm_monoid.{0} add_comm_monoid.{0} linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_676 (h0 : function.extfun (Type 1) topological_space) : @discrete_topology.{1} (plift.{1} empty) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} h0 (plift.{1} empty))  := sorry --non-trivial
lemma new_lemma_677 (h0 : complete_lattice (has_to_string (linear_ordered_semiring linarith.comp))) : complete_lattice.is_Sup_finite_compact (has_to_string (linear_ordered_semiring linarith.comp)) := sorry --non-trivial
lemma new_lemma_678 (h0 : topological_space (has_neg (finset (has_neg Type)))) : locally_compact_space (has_neg (finset (has_neg Type))) := sorry --non-trivial
lemma new_lemma_679 (h0 : topological_space (mul_zero_class (has_add name))) : preirreducible_space (mul_zero_class (has_add name)) := sorry --non-trivial
lemma new_lemma_680 (h0 : monoid (has_top (has_top num))) : monoid.fg (has_top (has_top num)) := sorry --non-trivial
lemma new_lemma_681 (h0 : ring (ordered_comm_ring (sub_neg_monoid (ring (has_neg Type))))) : is_domain (ordered_comm_ring (sub_neg_monoid (ring (has_neg Type)))) := sorry --non-trivial
lemma new_lemma_682 (h0 : topological_space (bin_tree num)) : normal_space (bin_tree num) := sorry --non-trivial
lemma new_lemma_683 (h0 : add_group (has_top linarith.ineq)) : is_add_cyclic (has_top linarith.ineq) := sorry --non-trivial
lemma new_lemma_684 (h0 : not (ring (has_norm linarith.ineq) -> false)) : @strong_rank_condition.{0} (has_norm.{0} linarith.ineq) (@classical.by_contradiction'.{1} (ring.{0} (has_norm.{0} linarith.ineq)) h0)  := sorry --non-trivial
lemma new_lemma_685 (h0 : function.extfun Type group) : @group.fg.{0} (has_add.{0} (option.{0} (option.{0} ennreal))) (@function.extfun_app.{2 1} Type group.{0} h0 (has_add.{0} (option.{0} (option.{0} ennreal))))  := sorry --non-trivial
lemma new_lemma_686 (h0 : topological_space (ordered_comm_ring (ring linarith.comp))) : totally_separated_space (ordered_comm_ring (ring linarith.comp)) := sorry --non-trivial
lemma new_lemma_687 (h0 : functor.add_const (ordered_comm_monoid (finset Type)) linarith.comp) : @has_exists_mul_of_le.{1} (finset.{1} Type) (@functor.add_const.run.{1 0} (ordered_comm_monoid.{1} (finset.{1} Type)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_688 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @sequential_space.{0} (has_zero.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_zero.{0} name))  := sorry --non-trivial
lemma new_lemma_689 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_atomistic.{0} fun_info (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) fun_info)  := sorry --non-trivial
lemma new_lemma_690 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_domain.{0} (has_Inf.{0} real) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (has_Inf.{0} real))  := sorry --non-trivial
lemma new_lemma_691 (h0 : group (canonically_ordered_add_monoid congr_arg_kind)) : group.fg (canonically_ordered_add_monoid congr_arg_kind) := sorry --non-trivial
lemma new_lemma_692 (h1 : linarith.comp_source -> linarith.comp_source -> Prop) : is_trans linarith.comp_source h1 := sorry --non-trivial
lemma new_lemma_693 (h0 : ring (has_add congr_arg_kind)) : strong_rank_condition (has_add congr_arg_kind) := sorry --non-trivial
lemma new_lemma_694 (h0 : functor.add_const (topological_space (canonically_ordered_comm_semiring pos)) environment.implicit_infer_kind) : @preirreducible_space.{0} (canonically_ordered_comm_semiring.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (canonically_ordered_comm_semiring.{0} pos)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_695 (h0 : add_group (nondiscrete_normed_field (normed_field char))) : is_add_cyclic (nondiscrete_normed_field (normed_field char)) := sorry --non-trivial
lemma new_lemma_696 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @discrete_topology.{0} num (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) num)  := sorry --non-trivial
lemma new_lemma_697 (h0 : not (filter (add_left_cancel_monoid fun_info) -> false)) : filter.ne_bot (classical.by_contradiction' h0) := sorry --non-trivial
lemma new_lemma_698 (h0 : topological_space (has_to_string (finset (has_nndist environment.implicit_infer_kind)))) : totally_separated_space (has_to_string (finset (has_nndist environment.implicit_infer_kind))) := sorry --non-trivial
lemma new_lemma_699 (h0 : add_group (has_le ereal)) : is_add_cyclic (has_le ereal) := sorry --non-trivial
lemma new_lemma_700 (h0 : topological_space (non_unital_non_assoc_semiring std_gen)) : t0_space (non_unital_non_assoc_semiring std_gen) := sorry --non-trivial
lemma new_lemma_701 (h0 : functor.add_const (filter (ring pos)) linarith.comp) : filter.ne_bot (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_702 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @loc_path_connected_space.{0} (cancel_monoid.{0} ennreal) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (cancel_monoid.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_703 (h0 : ring (boolean_algebra.core (has_add (has_add (has_neg_part unsigned))))) : rank_condition (boolean_algebra.core (has_add (has_add (has_neg_part unsigned)))) := sorry --non-trivial
lemma new_lemma_704 (h0 : not (has_mem.mem topological_space has_emptyc.emptyc -> false)) : @irreducible_space.{0} (has_emptyc.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) topological_space.{0} (@classical.by_contradiction'.{0} (@has_mem.mem.{1 1} (Type → Type) (finset.{1} (Type → Type)) (@finset.has_mem.{1} (Type → Type)) topological_space.{0} (@has_emptyc.emptyc.{1} (finset.{1} (Type → Type)) (@finset.has_emptyc.{1} (Type → Type)))) h0)) (has_emptyc.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_705 (h0 : functor.add_const (topological_space (has_zero linarith.comp)) environment.implicit_infer_kind) : @path_connected_space.{0} (has_zero.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (has_zero.{0} linarith.comp)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_706 (h0 : not (function.extfun Type monoid -> false)) : @monoid.fg.{0} (has_union.{0} num) (@function.extfun_app.{2 1} Type monoid.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type monoid.{0}) h0) (has_union.{0} num))  := sorry --non-trivial
lemma new_lemma_707 (h0 : list (has_nndist (option unsigned))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_708 (h1 : group (has_norm string_imp)) : normalizer_condition (has_norm string_imp) := sorry --non-trivial
lemma new_lemma_709 (h0 : function.extfun Type add_monoid) : @add_monoid.fg.{0} (add_comm_monoid.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type add_monoid.{0} h0 (add_comm_monoid.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_710 (h1 : function.extfun Type group) : @is_cyclic.{0} (measurable_space.{0} string_imp) (@function.extfun_app.{2 1} Type group.{0} h1 (measurable_space.{0} string_imp))  := sorry --non-trivial
lemma new_lemma_711 (h0 : group (normed_group (denumerable (has_inv linarith.ineq)))) : is_cyclic (normed_group (denumerable (has_inv linarith.ineq))) := sorry --non-trivial
lemma new_lemma_712 (h0 : functor.add_const (filter (ring Type)) (boolean_algebra (has_neg_part pos))) : countable_Inter_filter (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_713 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : palindrome (function.extfun_app (function.extfun_app h0 list) (has_to_string ennreal)) := sorry --non-trivial
lemma new_lemma_714 (h0 : function.extfun Type topological_space) : @totally_disconnected_space.{0} (bin_tree.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (bin_tree.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_715 (h0 : uniform_space (with_one (semiring linarith.comp))) : complete_space (with_one (semiring linarith.comp)) := sorry --non-trivial
lemma new_lemma_716 (h0 : fin has_zero.zero) : @t1_space.{0} (has_bot.{0} linarith.comp) (@matrix.vec_empty.{0} (topological_space.{0} (has_bot.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_717 (h1 : topological_space (has_one num)) : normal_space (has_one num) := sorry --non-trivial
lemma new_lemma_718 (h0 : ring (complete_distrib_lattice (ring (has_pos_part pos)))) : is_domain (complete_distrib_lattice (ring (has_pos_part pos))) := sorry --non-trivial
lemma new_lemma_719 (h0 : functor.add_const (complete_lattice (semigroup name)) Type) : @complete_lattice.is_Sup_finite_compact.{0} (semigroup.{0} name) (@functor.add_const.run.{0 1} (complete_lattice.{0} (semigroup.{0} name)) Type h0)  := sorry --non-trivial
lemma new_lemma_720 (h0 : uniform_space (linear_ordered_comm_monoid_with_zero unsigned)) : complete_space (linear_ordered_comm_monoid_with_zero unsigned) := sorry --non-trivial
lemma new_lemma_721 (h0 : add_monoid (linear_ordered_semiring (has_norm linarith.comp))) : add_monoid.fg (linear_ordered_semiring (has_norm linarith.comp)) := sorry --non-trivial
lemma new_lemma_722 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @totally_separated_space.{0} (preorder.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (preorder.{0} empty))  := sorry --non-trivial
lemma new_lemma_723 (h0 : function.extfun Type topological_space) : @topological_space.separable_space.{0} (has_union.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_union.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_724 (h0 : function.extfun Type complete_lattice) : @is_compactly_generated.{0} (finset.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (finset.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_725 (h0 : functor.add_const (add_monoid (boolean_algebra.core unsigned)) name) : @add_monoid.fg.{0} (boolean_algebra.core.{0} unsigned) (@functor.add_const.run.{0 0} (add_monoid.{0} (boolean_algebra.core.{0} unsigned)) name h0)  := sorry --non-trivial
lemma new_lemma_726 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_atomistic.{0} (with_one.{0} fun_info) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (with_one.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_727 (h0 : ordered_add_comm_monoid (ring (has_neg (has_neg (ring Type))))) : archimedean (ring (has_neg (has_neg (ring Type)))) := sorry --non-trivial
lemma new_lemma_728 (h0 : functor.add_const (functor.add_const (topological_space name) congr_arg_kind) congr_arg_kind) : @path_connected_space.{0} name (@functor.add_const.run.{0 0} (topological_space.{0} name) congr_arg_kind (@functor.add_const.run.{0 0} (functor.add_const.{0 0} (topological_space.{0} name) congr_arg_kind) congr_arg_kind h0))  := sorry --non-trivial
lemma new_lemma_729 (h0 : functor.add_const (topological_space (normed_comm_ring pos)) Type) : @preconnected_space.{0} (normed_comm_ring.{0} pos) (@functor.add_const.run.{0 1} (topological_space.{0} (normed_comm_ring.{0} pos)) Type h0)  := sorry --non-trivial
lemma new_lemma_730 (h0 : functor.add_const (topological_space (has_add linarith.comp)) (has_Inf (has_Inf (has_Inf linarith.comp)))) : @locally_compact_space.{0} (has_add.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (has_add.{0} linarith.comp)) (has_Inf.{0} (has_Inf.{0} (has_Inf.{0} linarith.comp))) h0)  := sorry --non-trivial
lemma new_lemma_731 (h1 : add_group (nondiscrete_normed_field linarith.ineq)) : is_add_cyclic (nondiscrete_normed_field linarith.ineq) := sorry --non-trivial
lemma new_lemma_732 (h0 : fin has_zero.zero) : @is_atomistic.{0} (canonically_linear_ordered_monoid.{0} name) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@matrix.vec_empty.{1} (function.extfun.{2 1} Type complete_lattice.{0}) h0) (canonically_linear_ordered_monoid.{0} name))  := sorry --non-trivial
lemma new_lemma_733 (h2 : topological_space (add_comm_semigroup linarith.ineq)) (h3 : preorder (add_comm_semigroup linarith.ineq)) : order_closed_topology (add_comm_semigroup linarith.ineq) := sorry --non-trivial
lemma new_lemma_734 (h0 : functor.add_const (function.extfun Type add_monoid) name) : @add_monoid.fg.{0} (has_add.{0} unsigned) (@function.extfun_app.{2 1} Type add_monoid.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type add_monoid.{0}) name h0) (has_add.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_735 (h2 : ring enat) : strong_rank_condition enat := sorry --non-trivial
lemma new_lemma_736 (h0 : functor.add_const (function.extfun Type add_group) pos) : @is_add_cyclic.{0} (add_comm_monoid.{0} linarith.comp) (@function.extfun_app.{2 1} Type add_group.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type add_group.{0}) pos h0) (add_comm_monoid.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_737 (h0 : function.extfun Type complete_lattice) : @is_compactly_generated.{0} (complete_semilattice_Sup.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (complete_semilattice_Sup.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_738 (h0 : ring (mul_zero_class (semiring (semiring unsigned)))) : strong_rank_condition (mul_zero_class (semiring (semiring unsigned))) := sorry --non-trivial
lemma new_lemma_739 (h0 : topological_space (add_cancel_monoid (has_neg linarith.comp))) : irreducible_space (add_cancel_monoid (has_neg linarith.comp)) := sorry --non-trivial
lemma new_lemma_740 (h0 : function.extfun Type add_group) : @is_add_cyclic.{0} (has_nndist.{0} unsigned) (@function.extfun_app.{2 1} Type add_group.{0} h0 (has_nndist.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_741 (h0 : functor.add_const (topological_space (comm_group name)) (has_neg_part (comm_group Type))) : @path_connected_space.{0} (comm_group.{0} name) (@functor.add_const.run.{0 1} (topological_space.{0} (comm_group.{0} name)) (has_neg_part.{1} (comm_group.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_742 (h0 : topological_space (uniform_space fun_info)) : path_connected_space (uniform_space fun_info) := sorry --non-trivial
lemma new_lemma_743 (h0 : function.extfun (Type 1) complete_lattice) : @is_atomistic.{1} (has_to_string.{1} Type) (@function.extfun_app.{3 2} (Type 1) complete_lattice.{1} h0 (has_to_string.{1} Type))  := sorry --non-trivial
lemma new_lemma_744 (h0 : filter (boolean_algebra (has_add Type))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_745 (h0 : cancel_comm_monoid_with_zero (finset linarith.comp)) : unique_factorization_monoid (finset linarith.comp) := sorry --non-trivial
lemma new_lemma_746 (h0 : complete_lattice (generalized_boolean_algebra pos)) : is_atomistic (generalized_boolean_algebra pos) := sorry --non-trivial
lemma new_lemma_747 (h0 : functor.add_const (ordered_add_comm_monoid (has_neg linarith.comp)) Type) : @archimedean.{0} (has_neg.{0} linarith.comp) (@functor.add_const.run.{0 1} (ordered_add_comm_monoid.{0} (has_neg.{0} linarith.comp)) Type h0)  := sorry --non-trivial
lemma new_lemma_748 (h0 : has_mem.mem complete_lattice has_emptyc.emptyc) : @complete_lattice.is_Sup_finite_compact.{0} (semiring.{0} fun_info) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) complete_lattice.{0} h0) (semiring.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_749 (h0 : function.extfun Type topological_space) : @t1_space.{0} (normed_group.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (normed_group.{0} num))  := sorry --non-trivial
lemma new_lemma_750 (h0 : function.extfun Type group) : @group.fg.{0} (cancel_monoid.{0} pos) (@function.extfun_app.{2 1} Type group.{0} h0 (cancel_monoid.{0} pos))  := sorry --non-trivial
lemma new_lemma_751 (h0 : not (complete_lattice (has_one num) -> false)) : @is_compactly_generated.{0} (has_one.{0} num) (@classical.by_contradiction'.{1} (complete_lattice.{0} (has_one.{0} num)) h0)  := sorry --non-trivial
lemma new_lemma_752 (h0 : cancel_comm_monoid_with_zero (canonically_ordered_monoid pos)) : unique_factorization_monoid (canonically_ordered_monoid pos) := sorry --non-trivial
lemma new_lemma_753 (h0 : ring (has_pos_part (has_pos_part (finset linarith.comp)))) : is_principal_ideal_ring (has_pos_part (has_pos_part (finset linarith.comp))) := sorry --non-trivial
lemma new_lemma_754 (h0 : topological_space (complete_distrib_lattice (has_add (has_add environment.implicit_infer_kind)))) : t0_space (complete_distrib_lattice (has_add (has_add environment.implicit_infer_kind))) := sorry --non-trivial
lemma new_lemma_755 (h0 : ring (has_union unsigned)) : is_domain (has_union unsigned) := sorry --non-trivial
lemma new_lemma_756 (h0 : complete_lattice (has_dist num)) : is_compactly_generated (has_dist num) := sorry --non-trivial
lemma new_lemma_757 (h0 : topological_space (has_pos_part real)) : locally_compact_space (has_pos_part real) := sorry --non-trivial
lemma new_lemma_758 (h0 : set (set fun_info)) (h1 : fun_info) : set.sInter h0 h1 := sorry --non-trivial
lemma new_lemma_759 (h0 : complete_lattice (topological_space (topological_space reducibility_hints))) : is_compactly_generated (topological_space (topological_space reducibility_hints)) := sorry --non-trivial
lemma new_lemma_760 (h0 : functor.add_const (ring (generalized_boolean_algebra linarith.comp)) Type) : @strong_rank_condition.{0} (generalized_boolean_algebra.{0} linarith.comp) (@functor.add_const.run.{0 1} (ring.{0} (generalized_boolean_algebra.{0} linarith.comp)) Type h0)  := sorry --non-trivial
lemma new_lemma_761 (h0 : functor.add_const (uniform_space (has_to_string pos)) Type) : @complete_space.{0} (has_to_string.{0} pos) (@functor.add_const.run.{0 1} (uniform_space.{0} (has_to_string.{0} pos)) Type h0)  := sorry --non-trivial
lemma new_lemma_762 (h0 : finset (has_edist empty)) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_763 (h0 : function.extfun (finset (Type -> Type)) (has_mem.mem group)) : @normalizer_condition.{0} (measurable_space.{0} (has_norm.{0} (semiring.{0} (semiring.{0} (has_norm.{0} empty))))) (@function.extfun_app.{2 1} Type group.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) group.{0} (@function.extfun_app.{2 0} (finset.{1} (Type → Type)) (@has_mem.mem.{1 1} (Type → Type) (finset.{1} (Type → Type)) (@finset.has_mem.{1} (Type → Type)) group.{0}) h0 (@has_emptyc.emptyc.{1} (finset.{1} (Type → Type)) (@finset.has_emptyc.{1} (Type → Type))))) (measurable_space.{0} (has_norm.{0} (semiring.{0} (semiring.{0} (has_norm.{0} empty))))))  := sorry --non-trivial
lemma new_lemma_764 : @trace_call_stack.{0} Prop (@set.center.{0} unit (@distrib.to_has_mul.{0} unit (@ring.to_distrib.{0} unit (@normed_ring.to_ring.{0} unit (@normed_comm_ring.to_normed_ring.{0} unit punit.normed_comm_ring.{0})))))  := sorry --simp
lemma new_lemma_765 (h0 : functor.add_const (ring (ring pos)) environment.implicit_infer_kind) : @rank_condition.{0} (ring.{0} pos) (@functor.add_const.run.{0 0} (ring.{0} (ring.{0} pos)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_766 (h0 : topological_space (with_one (semiring congr_arg_kind))) : discrete_topology (with_one (semiring congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_767 (h0 : ring (distrib (mul_one_class (mul_one_class linarith.ineq)))) : is_domain (distrib (mul_one_class (mul_one_class linarith.ineq))) := sorry --non-trivial
lemma new_lemma_768 (h0 : ring (left_cancel_semigroup (semiring empty))) : is_domain (left_cancel_semigroup (semiring empty)) := sorry --non-trivial
lemma new_lemma_769 (h0 : topological_space (has_neg (finset pos))) : locally_compact_space (has_neg (finset pos)) := sorry --non-trivial
lemma new_lemma_770 (h0 : uniform_space (linear_ordered_field ennreal)) : complete_space (linear_ordered_field ennreal) := sorry --non-trivial
lemma new_lemma_771 (h0 : functor.add_const (function.extfun Type topological_space) name) : @normal_space.{0} (semigroup.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) name h0) (semigroup.{0} pos))  := sorry --non-trivial
lemma new_lemma_772 (h0 : function.extfun Type list) : palindrome (function.extfun_app h0 (ring environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_773 (h0 : function.extfun Type add_monoid) : @add_monoid.fg.{0} (semigroup.{0} (has_neg_part.{0} name)) (@function.extfun_app.{2 1} Type add_monoid.{0} h0 (semigroup.{0} (has_neg_part.{0} name)))  := sorry --non-trivial
lemma new_lemma_774 (h0 : filter (monoid_with_zero unsigned)) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_775 (h0 : function.extfun (finset (Type -> Type) -> Prop) (function.extfun (finset (Type -> Type)))) : @is_cyclic.{0} string_imp (@function.extfun_app.{2 1} Type group.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) group.{0} (@function.extfun_app.{2 0} (finset.{1} (Type → Type)) (@has_mem.mem.{1 1} (Type → Type) (finset.{1} (Type → Type)) (@finset.has_mem.{1} (Type → Type)) group.{0}) (@function.extfun_app.{2 0} (finset.{1} (Type → Type) → Prop) (function.extfun.{2 0} (finset.{1} (Type → Type))) h0 (@has_mem.mem.{1 1} (Type → Type) (finset.{1} (Type → Type)) (@finset.has_mem.{1} (Type → Type)) group.{0})) (@has_emptyc.emptyc.{1} (finset.{1} (Type → Type)) (@finset.has_emptyc.{1} (Type → Type))))) string_imp)  := sorry --non-trivial
lemma new_lemma_776 (h0 : ring (canonically_linear_ordered_monoid (option (has_neg_part unsigned)))) : strong_rank_condition (canonically_linear_ordered_monoid (option (has_neg_part unsigned))) := sorry --non-trivial
lemma new_lemma_777 (h0 : group (add_comm_monoid real)) : is_simple_group (add_comm_monoid real) := sorry --non-trivial
lemma new_lemma_778 (h0 : topological_space (comm_group (boolean_algebra.core Type))) : path_connected_space (comm_group (boolean_algebra.core Type)) := sorry --non-trivial
lemma new_lemma_779 (h0 : fin has_zero.zero) : @complete_lattice.is_Sup_finite_compact.{1} (boolean_algebra.{1} Type) (@matrix.vec_empty.{1} (complete_lattice.{1} (boolean_algebra.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_780 (h0 : group (has_nndist (has_to_string pos))) : group.fg (has_nndist (has_to_string pos)) := sorry --non-trivial
lemma new_lemma_781 (h0 : complete_lattice (with_bot (has_inv linarith.ineq))) : is_atomistic (with_bot (has_inv linarith.ineq)) := sorry --non-trivial
lemma new_lemma_782 (h0 : filter (has_Inf (ring (has_neg (has_add (finset pos)))))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_783 (h1 : complete_lattice (add_comm_semigroup enat)) : complete_lattice.is_Sup_finite_compact (add_comm_semigroup enat) := sorry --non-trivial
lemma new_lemma_784 (h0 : functor.add_const (group (comm_group linarith.comp)) (has_neg linarith.comp)) : @normalizer_condition.{0} (comm_group.{0} linarith.comp) (@functor.add_const.run.{0 0} (group.{0} (comm_group.{0} linarith.comp)) (has_neg.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_785 (h0 : function.extfun Type finset) : finset.nonempty (function.extfun_app h0 (comm_group pos)) := sorry --non-trivial
lemma new_lemma_786 (h0 : preorder (random_gen (has_top num))) (h1 : topological_space (random_gen (has_top num))) : Inf_convergence_class (random_gen (has_top num)) := sorry --non-trivial
lemma new_lemma_787 (h0 : group (add_cancel_monoid (canonically_ordered_comm_semiring (has_neg Type)))) : normalizer_condition (add_cancel_monoid (canonically_ordered_comm_semiring (has_neg Type))) := sorry --non-trivial
lemma new_lemma_788 (h0 : not (topological_space (has_sub unsigned) -> false)) : @t0_space.{0} (has_sub.{0} unsigned) (@classical.by_contradiction'.{1} (topological_space.{0} (has_sub.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_789 (h3 : function.extfun (Type -> Type) (function.extfun Type)) : @t0_space.{0} fun_info (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h3 topological_space.{0}) fun_info)  := sorry --non-trivial
lemma new_lemma_790 (h0 : topological_space (has_ssubset (random_gen (random_gen (random_gen (random_gen (random_gen string_imp))))))) : t0_space (has_ssubset (random_gen (random_gen (random_gen (random_gen (random_gen string_imp)))))) := sorry --non-trivial
lemma new_lemma_791 (h0 : functor.add_const (semiring (has_neg_part ennreal)) name) : @is_noetherian_ring.{0} (has_neg_part.{0} ennreal) (@functor.add_const.run.{0 0} (semiring.{0} (has_neg_part.{0} ennreal)) name h0)  := sorry --non-trivial
lemma new_lemma_792 (h0 : ordered_add_comm_monoid (has_to_string (normed_comm_ring Type))) : archimedean (has_to_string (normed_comm_ring Type)) := sorry --non-trivial
lemma new_lemma_793 (h1 : add_group (has_append (random_gen char))) : is_add_cyclic (has_append (random_gen char)) := sorry --non-trivial
lemma new_lemma_794 (h1 : Prop) : set.finite (id (fun (h0 : char), h1)) := sorry --non-trivial
lemma new_lemma_795 (h0 : not (add_group stieltjes_function -> false)) : @is_add_cyclic.{0} stieltjes_function (@classical.by_contradiction'.{1} (add_group.{0} stieltjes_function) h0)  := sorry --non-trivial
lemma new_lemma_796 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @path_connected_space.{0} (@id.{2} Type congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (@id.{2} Type congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_797 (h0 : functor.add_const (function.extfun Type topological_space) pos) : @preconnected_space.{0} (has_zero.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) pos h0) (has_zero.{0} pos))  := sorry --non-trivial
lemma new_lemma_798 (h0 : topological_space (has_Inf (has_neg linarith.comp))) : t0_space (has_Inf (has_neg linarith.comp)) := sorry --non-trivial
lemma new_lemma_799 (h0 : ordered_comm_monoid (has_bot (canonically_linear_ordered_monoid real))) : has_exists_mul_of_le (has_bot (canonically_linear_ordered_monoid real)) := sorry --non-trivial
lemma new_lemma_800 (h0 : function.extfun Type semiring) : @is_noetherian_ring.{0} (has_norm.{0} unsigned) (@function.extfun_app.{2 1} Type semiring.{0} h0 (has_norm.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_801 (h0 : function.extfun Type list) : list.nodup (function.extfun_app h0 (with_bot fun_info)) := sorry --non-trivial
lemma new_lemma_802 (h0 : functor.comp uniform_space boolean_algebra.core (option pos)) : @separated_space.{0} (boolean_algebra.core.{0} (option.{0} pos)) (@functor.comp.run.{0 0 0} uniform_space.{0} boolean_algebra.core.{0} (option.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_803 (h0 : function.extfun Type topological_space) : @locally_compact_space.{0} (has_zero.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_zero.{0} name))  := sorry --non-trivial
lemma new_lemma_804 (h0 : not (function.extfun Type complete_lattice -> false)) : @is_compactly_generated.{0} (has_top.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type complete_lattice.{0}) h0) (has_top.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_805 (h0 : not (function.extfun Type cancel_comm_monoid_with_zero -> false)) : @unique_factorization_monoid.{0} (with_one.{0} empty) (@function.extfun_app.{2 1} Type cancel_comm_monoid_with_zero.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type cancel_comm_monoid_with_zero.{0}) h0) (with_one.{0} empty))  := sorry --non-trivial
lemma new_lemma_806 (h0 : function.extfun Type ring) : @rank_condition.{0} (with_bot.{0} string_imp) (@function.extfun_app.{2 1} Type ring.{0} h0 (with_bot.{0} string_imp))  := sorry --non-trivial
lemma new_lemma_807 (h1 : topological_space (has_nnnorm (has_nnnorm string_imp))) : t0_space (has_nnnorm (has_nnnorm string_imp)) := sorry --non-trivial
lemma new_lemma_808 (h0 : not (group (id fun_info) -> false)) : @normalizer_condition.{0} (@id.{2} Type fun_info) (@classical.by_contradiction'.{1} (group.{0} (@id.{2} Type fun_info)) h0)  := sorry --non-trivial
lemma new_lemma_809 (h0 : ring (has_append (comm_ring (comm_ring linarith.ineq)))) : rank_condition (has_append (comm_ring (comm_ring linarith.ineq))) := sorry --non-trivial
lemma new_lemma_810 (h0 : group (boolean_algebra (has_to_string pos))) : group.fg (boolean_algebra (has_to_string pos)) := sorry --non-trivial
lemma new_lemma_811 (h0 : functor.add_const (topological_space (ring Type)) Type) : @discrete_topology.{1} (ring.{1} Type) (@functor.add_const.run.{1 1} (topological_space.{1} (ring.{1} Type)) Type h0)  := sorry --non-trivial
lemma new_lemma_812 (h0 : has_lt linarith.ineq -> ereal) (h1 : coe_sort (set.range h0)) : @no_max_order.{0} linarith.ineq (@set.range_splitting.{0 0} (has_lt.{0} linarith.ineq) ereal h0 h1)  := sorry --non-trivial
lemma new_lemma_813 (h0 : not (function.extfun Type topological_space -> false)) : @path_connected_space.{0} (complete_semilattice_Sup.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (complete_semilattice_Sup.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_814 (h0 : not (function.extfun Type topological_space -> false)) : @totally_separated_space.{0} (has_emptyc.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (has_emptyc.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_815 (h0 : ring (random_gen (random_gen empty))) : strong_rank_condition (random_gen (random_gen empty)) := sorry --non-trivial
lemma new_lemma_816 (h0 : topological_space (normed_comm_ring (option ennreal))) : loc_path_connected_space (normed_comm_ring (option ennreal)) := sorry --non-trivial
lemma new_lemma_817 (h0 : topological_space (has_nndist (finset linarith.comp))) : sequential_space (has_nndist (finset linarith.comp)) := sorry --non-trivial
lemma new_lemma_818 (h0 : topological_space (has_Sup (semiring (semiring empty)))) : normal_space (has_Sup (semiring (semiring empty))) := sorry --non-trivial
lemma new_lemma_819 (h0 : topological_space (has_add (has_to_string pos))) : normal_space (has_add (has_to_string pos)) := sorry --non-trivial
lemma new_lemma_820 (h0 : list linarith.comp) : palindrome h0 := sorry --non-trivial
lemma new_lemma_821 (h0 : functor.add_const (topological_space (canonically_ordered_comm_semiring ennreal)) name) : @path_connected_space.{0} (canonically_ordered_comm_semiring.{0} ennreal) (@functor.add_const.run.{0 0} (topological_space.{0} (canonically_ordered_comm_semiring.{0} ennreal)) name h0)  := sorry --non-trivial
lemma new_lemma_822 (h0 : function.extfun Type finset) : finset.nonempty (function.extfun_app h0 (linear_order empty)) := sorry --non-trivial
lemma new_lemma_823 (h0 : add_group (boolean_algebra.core (has_neg name))) : is_add_cyclic (boolean_algebra.core (has_neg name)) := sorry --non-trivial
lemma new_lemma_824 (h0 : function.extfun Type (functor.add_const (function.extfun Type complete_lattice))) : @complete_lattice.is_Sup_finite_compact.{0} pos (@function.extfun_app.{2 1} Type complete_lattice.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type complete_lattice.{0}) pos (@function.extfun_app.{2 2} Type (functor.add_const.{1 0} (function.extfun.{2 1} Type complete_lattice.{0})) h0 pos)) pos)  := sorry --non-trivial
lemma new_lemma_825 (h0 : functor.add_const (topological_space (ordered_ring congr_arg_kind)) unsigned) : @locally_compact_space.{0} (ordered_ring.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (ordered_ring.{0} congr_arg_kind)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_826 (h0 : not (topological_space (random_gen reducibility_hints) -> false)) : @t0_space.{0} (random_gen.{0} reducibility_hints) (@classical.by_contradiction'.{1} (topological_space.{0} (random_gen.{0} reducibility_hints)) h0)  := sorry --non-trivial
lemma new_lemma_827 (h0 : topological_space (has_add (has_pos_part (finset pos)))) : totally_disconnected_space (has_add (has_pos_part (finset pos))) := sorry --non-trivial
lemma new_lemma_828 (h0 : topological_space (simple_graph (ring (ring (has_pos_part linarith.comp))))) : totally_disconnected_space (simple_graph (ring (ring (has_pos_part linarith.comp)))) := sorry --non-trivial
lemma new_lemma_829 (h0 : topological_space (finset (option ennreal))) : totally_separated_space (finset (option ennreal)) := sorry --non-trivial
lemma new_lemma_830 (h0 : functor.add_const (function.extfun (Type 1) cancel_comm_monoid_with_zero) pos) : @unique_factorization_monoid.{1} Type (@function.extfun_app.{3 2} (Type 1) cancel_comm_monoid_with_zero.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) cancel_comm_monoid_with_zero.{1}) pos h0) Type)  := sorry --non-trivial
lemma new_lemma_831 (h0 : ring (sub_neg_monoid Type)) : is_domain (sub_neg_monoid Type) := sorry --non-trivial
lemma new_lemma_832 (h0 : ring (normed_comm_ring Type)) : strong_rank_condition (normed_comm_ring Type) := sorry --non-trivial
lemma new_lemma_833 (h0 : ordered_add_comm_monoid (linear_ordered_field (option ennreal))) : archimedean (linear_ordered_field (option ennreal)) := sorry --non-trivial
lemma new_lemma_834 (h0 : function.extfun Type topological_space) : @totally_separated_space.{0} (has_pos_part.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_pos_part.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_835 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @strong_rank_condition.{0} (has_add.{0} name) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (has_add.{0} name))  := sorry --non-trivial
lemma new_lemma_836 (h0 : topological_space (option (semiring unsigned))) : path_connected_space (option (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_837 (h0 : functor.add_const (group (mul_zero_class name)) unsigned) : @is_simple_group.{0} (mul_zero_class.{0} name) (@functor.add_const.run.{0 0} (group.{0} (mul_zero_class.{0} name)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_838 (h0 : functor.add_const (add_group (mul_zero_class num)) num) : @is_add_cyclic.{0} (mul_zero_class.{0} num) (@functor.add_const.run.{0 0} (add_group.{0} (mul_zero_class.{0} num)) num h0)  := sorry --non-trivial
lemma new_lemma_839 (h0 : group (with_one (semiring congr_arg_kind))) : group.fg (with_one (semiring congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_840 (h0 : function.extfun Type complete_lattice) : @complete_lattice.is_Sup_finite_compact.{0} (bin_tree.{0} unsigned) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (bin_tree.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_841 (h0 : function.extfun Type complete_lattice) : @complete_lattice.is_Sup_finite_compact.{0} (encodable.{0} string_imp) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (encodable.{0} string_imp))  := sorry --non-trivial
lemma new_lemma_842 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_domain.{0} (measurable_space.dynkin_system.{0} unsigned) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (measurable_space.dynkin_system.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_843 (h0 : add_group (with_bot (random_gen linarith.ineq))) : is_add_cyclic (with_bot (random_gen linarith.ineq)) := sorry --non-trivial
lemma new_lemma_844 (h0 : function.extfun Type topological_space) : @totally_separated_space.{0} (complete_semilattice_Sup.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (complete_semilattice_Sup.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_845 (h0 : semiring empty) : is_noetherian_ring empty := sorry --non-trivial
lemma new_lemma_846 (h0 : uniform_space (comm_group (finset pos))) : separated_space (comm_group (finset pos)) := sorry --non-trivial
lemma new_lemma_847 (h0 : topological_space (generalized_boolean_algebra (ring name))) : t1_space (generalized_boolean_algebra (ring name)) := sorry --non-trivial
lemma new_lemma_848 (h0 : topological_space (semigroup (ring (boolean_algebra linarith.comp)))) : topological_space.separable_space (semigroup (ring (boolean_algebra linarith.comp))) := sorry --non-trivial
lemma new_lemma_849 (h0 : functor.add_const (topological_space (semigroup Type)) (finset pos)) : @discrete_topology.{1} (semigroup.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (semigroup.{1} Type)) (finset.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_850 (h0 : function.extfun Type ring) : @is_principal_ideal_ring.{0} (ordered_cancel_add_comm_monoid.{0} (option.{0} ennreal)) (@function.extfun_app.{2 1} Type ring.{0} h0 (ordered_cancel_add_comm_monoid.{0} (option.{0} ennreal)))  := sorry --non-trivial
lemma new_lemma_851 (h0 : complete_lattice (comm_group (has_nndist name))) : is_compactly_generated (comm_group (has_nndist name)) := sorry --non-trivial
lemma new_lemma_852 (h0 : functor.add_const (topological_space (mul_zero_class pos)) pos) : @sequential_space.{0} (mul_zero_class.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (mul_zero_class.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_853 (h0 : function.extfun Type topological_space) : @irreducible_space.{0} (with_one.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (with_one.{0} empty))  := sorry --non-trivial
lemma new_lemma_854 (h0 : topological_space (add_comm_monoid (comm_group name))) : totally_separated_space (add_comm_monoid (comm_group name)) := sorry --non-trivial
lemma new_lemma_855 (h0 : not (topological_space (random_gen num) -> false)) : @locally_compact_space.{0} (random_gen.{0} num) (@classical.by_contradiction'.{1} (topological_space.{0} (random_gen.{0} num)) h0)  := sorry --non-trivial
lemma new_lemma_856 (h0 : functor.add_const (topological_space (cancel_monoid empty)) empty) : @totally_disconnected_space.{0} (cancel_monoid.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (cancel_monoid.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_857 (h0 : ring (normed_linear_ordered_group empty)) : rank_condition (normed_linear_ordered_group empty) := sorry --non-trivial
lemma new_lemma_858 (h0 : functor.add_const (ring (boolean_algebra.core Type)) pos) : @strong_rank_condition.{1} (boolean_algebra.core.{1} Type) (@functor.add_const.run.{1 0} (ring.{1} (boolean_algebra.core.{1} Type)) pos h0)  := sorry --non-trivial
lemma new_lemma_859 (h0 : not (function.extfun Type monoid -> false)) : @monoid.fg.{0} (option.{0} unsigned) (@function.extfun_app.{2 1} Type monoid.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type monoid.{0}) h0) (option.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_860 (h0 : functor.add_const (complete_lattice (semigroup linarith.comp)) (has_to_string Type)) : @is_compactly_generated.{0} (semigroup.{0} linarith.comp) (@functor.add_const.run.{0 1} (complete_lattice.{0} (semigroup.{0} linarith.comp)) (has_to_string.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_861 (h0 : ring (ring (option (option (option unsigned))))) : strong_rank_condition (ring (option (option (option unsigned)))) := sorry --non-trivial
lemma new_lemma_862 (h1 : topological_space (has_nnnorm char)) (h2 : preorder (has_nnnorm char)) : order_closed_topology (has_nnnorm char) := sorry --non-trivial
lemma new_lemma_863 (h0 : group (canonically_ordered_comm_semiring unsigned)) : is_cyclic (canonically_ordered_comm_semiring unsigned) := sorry --non-trivial
lemma new_lemma_864 (h0 : monoid (boolean_algebra.core (comm_group pos))) : monoid.fg (boolean_algebra.core (comm_group pos)) := sorry --non-trivial
lemma new_lemma_865 (h0 : functor.add_const (ring (bin_tree unsigned)) congr_arg_kind) : @is_domain.{0} (bin_tree.{0} unsigned) (@functor.add_const.run.{0 0} (ring.{0} (bin_tree.{0} unsigned)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_866 (h0 : functor.add_const (group (pseudo_metric_space ennreal)) name) : @normalizer_condition.{0} (pseudo_metric_space.{0} ennreal) (@functor.add_const.run.{0 0} (group.{0} (pseudo_metric_space.{0} ennreal)) name h0)  := sorry --non-trivial
lemma new_lemma_867 (h0 : function.extfun ((Type -> Type) -> Type 1) (function.extfun (Type -> Type))) : @is_cyclic.{0} (random_gen.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) (@function.extfun_app.{3 2} ((Type → Type) → Type 1) (function.extfun.{2 2} (Type → Type)) h0 (function.extfun.{2 1} Type)) group.{0}) (random_gen.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_868 (h0 : not (function.extfun Type complete_lattice -> false)) : @is_atomistic.{0} (complete_semilattice_Sup.{0} linarith.comp) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type complete_lattice.{0}) h0) (complete_semilattice_Sup.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_869 (h0 : ordered_comm_monoid (semigroup (has_add unsigned))) : has_exists_mul_of_le (semigroup (has_add unsigned)) := sorry --non-trivial
lemma new_lemma_870 (h0 : topological_space (finset (has_to_string unsigned))) : irreducible_space (finset (has_to_string unsigned)) := sorry --non-trivial
lemma new_lemma_871 (h0 : topological_space (has_zero (has_neg_part ennreal))) : regular_space (has_zero (has_neg_part ennreal)) := sorry --non-trivial
lemma new_lemma_872 (h0 : topological_space (multiplicative linarith.ineq)) (h1 : add_group (multiplicative linarith.ineq)) : topological_add_group (multiplicative linarith.ineq) := sorry --non-trivial
lemma new_lemma_873 (h0 : functor.add_const (complete_lattice (has_zero pos)) environment.implicit_infer_kind) : @complete_lattice.is_Sup_finite_compact.{0} (has_zero.{0} pos) (@functor.add_const.run.{0 0} (complete_lattice.{0} (has_zero.{0} pos)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_874 (h0 : functor.add_const (topological_space (ordered_comm_semiring environment.implicit_infer_kind)) name) : @preconnected_space.{0} (ordered_comm_semiring.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (ordered_comm_semiring.{0} environment.implicit_infer_kind)) name h0)  := sorry --non-trivial
lemma new_lemma_875 (h0 : topological_space (canonically_ordered_comm_semiring (finset name))) : preconnected_space (canonically_ordered_comm_semiring (finset name)) := sorry --non-trivial
lemma new_lemma_876 (h0 : topological_space (add_comm_monoid (has_to_string pos))) : regular_space (add_comm_monoid (has_to_string pos)) := sorry --non-trivial
lemma new_lemma_877 (h0 : ring (ordered_comm_monoid (has_nndist (sub_neg_monoid name)))) : rank_condition (ordered_comm_monoid (has_nndist (sub_neg_monoid name))) := sorry --non-trivial
lemma new_lemma_878 (h0 : topological_space (add_comm_monoid (has_to_string unsigned))) : totally_disconnected_space (add_comm_monoid (has_to_string unsigned)) := sorry --non-trivial
lemma new_lemma_879 (h0 : topological_space (has_to_string (random_gen (random_gen string_imp)))) : path_connected_space (has_to_string (random_gen (random_gen string_imp))) := sorry --non-trivial
lemma new_lemma_880 (h0 : group (semigroup (has_neg (has_neg environment.implicit_infer_kind)))) : is_cyclic (semigroup (has_neg (has_neg environment.implicit_infer_kind))) := sorry --non-trivial
lemma new_lemma_881 (h0 : function.extfun Type topological_space) : @path_connected_space.{0} (has_Inf.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_Inf.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_882 (h0 : function.extfun Type topological_space) : @preirreducible_space.{0} (normed_comm_ring.{0} ennreal) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (normed_comm_ring.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_883 (h0 : not (ring (uniform_space string.iterator_imp) -> false)) : @strong_rank_condition.{0} (uniform_space.{0} string.iterator_imp) (@classical.by_contradiction'.{1} (ring.{0} (uniform_space.{0} string.iterator_imp)) h0)  := sorry --non-trivial
lemma new_lemma_884 (h0 : functor.comp ring boolean_algebra name) : @is_principal_ideal_ring.{0} (boolean_algebra.{0} name) (@functor.comp.run.{0 0 0} ring.{0} boolean_algebra.{0} name (@functor.comp.run.{0 0 0} ring.{0} boolean_algebra.{0} name h0))  := sorry --non-trivial
lemma new_lemma_885 (h0 : functor.add_const (ring (boolean_algebra pos)) linarith.comp) : @is_domain.{0} (boolean_algebra.{0} pos) (@functor.add_const.run.{0 0} (ring.{0} (boolean_algebra.{0} pos)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_886 (h0 : topological_space (canonically_ordered_comm_semiring ennreal)) : regular_space (canonically_ordered_comm_semiring ennreal) := sorry --non-trivial
lemma new_lemma_887 (h0 : topological_space (ordered_comm_ring (ordered_comm_monoid pos))) : t0_space (ordered_comm_ring (ordered_comm_monoid pos)) := sorry --non-trivial
lemma new_lemma_888 (h0 : function.extfun Type add_group) : @is_add_cyclic.{0} (bin_tree.{0} num) (@function.extfun_app.{2 1} Type add_group.{0} h0 (bin_tree.{0} num))  := sorry --non-trivial
lemma new_lemma_889 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_simple_group.{0} (boolean_algebra.core.{0} ennreal) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (boolean_algebra.core.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_890 (h0 : functor.add_const (add_group (generalized_boolean_algebra linarith.comp)) name) : @is_add_cyclic.{0} (generalized_boolean_algebra.{0} linarith.comp) (@functor.add_const.run.{0 0} (add_group.{0} (generalized_boolean_algebra.{0} linarith.comp)) name h0)  := sorry --non-trivial
lemma new_lemma_891 (h0 : ring (add_left_cancel_monoid char)) : is_domain (add_left_cancel_monoid char) := sorry --non-trivial
lemma new_lemma_892 (h0 : functor.add_const (function.extfun (Type 1) topological_space) Type) : @irreducible_space.{1} (semigroup.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@functor.add_const.run.{2 1} (function.extfun.{3 2} (Type 1) topological_space.{1}) Type h0) (semigroup.{1} Type))  := sorry --non-trivial
lemma new_lemma_893 (h0 : functor.add_const (group (add_cancel_monoid name)) environment.implicit_infer_kind) : @is_simple_group.{0} (add_cancel_monoid.{0} name) (@functor.add_const.run.{0 0} (group.{0} (add_cancel_monoid.{0} name)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_894 (h0 : function.extfun Type topological_space) : @t0_space.{0} (normed_comm_ring.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (normed_comm_ring.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_895 (h0 : functor.add_const (finset (has_neg_part name)) (option unsigned)) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_896 (h0 : functor.add_const (semiring (finset environment.implicit_infer_kind)) Type) : @is_noetherian_ring.{0} (finset.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 1} (semiring.{0} (finset.{0} environment.implicit_infer_kind)) Type h0)  := sorry --non-trivial
lemma new_lemma_897 (h0 : has_lt (nondiscrete_normed_field (normed_field std_gen))) : no_max_order (nondiscrete_normed_field (normed_field std_gen)) := sorry --non-trivial
lemma new_lemma_898 (h0 : topological_space (pseudo_metric_space (option pos))) : sequential_space (pseudo_metric_space (option pos)) := sorry --non-trivial
lemma new_lemma_899 (h0 : group (finset (finset linarith.comp))) : normalizer_condition (finset (finset linarith.comp)) := sorry --non-trivial
lemma new_lemma_900 (h0 : uniform_space (with_bot (has_norm congr_arg_kind))) : separated_space (with_bot (has_norm congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_901 (h0 : cancel_monoid (finset (option (option (option pos)))) -> Prop) : zzz_forall h0 := sorry --non-trivial
lemma new_lemma_902 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @separated_space.{0} (has_edist.{0} empty) (@functor.add_const.run.{0 0} (uniform_space.{0} (has_edist.{0} empty)) (option.{0} (option.{0} (option.{0} (option.{0} empty)))) (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (uniform_space.{0} (has_edist.{0} empty))) (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 (functor.add_const.{0 0} (uniform_space.{0} (has_edist.{0} empty)))) (option.{0} (option.{0} (option.{0} (option.{0} empty))))))  := sorry --non-trivial
lemma new_lemma_903 (h0 : functor.add_const (topological_space (add_cancel_monoid Type)) linarith.comp) : @t1_space.{1} (add_cancel_monoid.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (add_cancel_monoid.{1} Type)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_904 (h0 : add_group (has_emptyc (has_inv fun_info))) : is_add_cyclic (has_emptyc (has_inv fun_info)) := sorry --non-trivial
lemma new_lemma_905 (h0 : topological_space (cancel_monoid (has_add (has_neg pos)))) : locally_compact_space (cancel_monoid (has_add (has_neg pos))) := sorry --non-trivial
lemma new_lemma_906 (h2 : function.extfun Type topological_space) : @totally_disconnected_space.{0} (with_one.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h2 (with_one.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_907 (h2 : add_group (semi_normed_comm_ring to_additive.value_type)) : is_add_cyclic (semi_normed_comm_ring to_additive.value_type) := sorry --non-trivial
lemma new_lemma_908 (h0 : uniform_space (preorder empty)) : complete_space (preorder empty) := sorry --non-trivial
lemma new_lemma_909 (h0 : ordered_comm_monoid (has_zero (option unsigned))) : has_exists_mul_of_le (has_zero (option unsigned)) := sorry --non-trivial
lemma new_lemma_910 (h0 : group (random_gen (has_top to_additive.value_type))) : is_cyclic (random_gen (has_top to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_911 (h0 : list (has_zero (option (option unsigned)))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_912 (h0 : ring (linear_ordered_semiring fun_info)) : is_domain (linear_ordered_semiring fun_info) := sorry --non-trivial
lemma new_lemma_913 (h0 : topological_space (plift (semiring num))) : preirreducible_space (plift (semiring num)) := sorry --non-trivial
lemma new_lemma_914 (h0 : functor.comp uniform_space has_zero pos) : @separated_space.{0} (has_zero.{0} pos) (@functor.comp.run.{0 0 0} uniform_space.{0} has_zero.{0} pos h0)  := sorry --non-trivial
lemma new_lemma_915 (h0 : topological_space (complete_distrib_lattice ennreal)) : locally_compact_space (complete_distrib_lattice ennreal) := sorry --non-trivial
lemma new_lemma_916 (h0 : functor.add_const (topological_space (has_to_string Type)) linarith.comp) : @topological_space.separable_space.{1} (has_to_string.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (has_to_string.{1} Type)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_917 (h0 : add_comm_semigroup fun_info -> add_comm_semigroup fun_info -> Prop) (h1 : set (add_comm_semigroup fun_info)) : zorn.chain h0 h1 := sorry --non-trivial
lemma new_lemma_918 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @group.fg.{0} (has_inv.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (has_inv.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_919 (h2 : ring (comm_ring fun_info)) : rank_condition (comm_ring fun_info) := sorry --non-trivial
lemma new_lemma_920 (h0 : functor.comp add_monoid comm_group pos) : @add_monoid.fg.{0} (comm_group.{0} pos) (@functor.comp.run.{0 0 0} add_monoid.{0} comm_group.{0} pos h0)  := sorry --non-trivial
lemma new_lemma_921 (h0 : filter (boolean_algebra (has_neg_part name))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_922 (h0 : list (semigroup (option unsigned))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_923 (h0 : has_lt (simple_graph string_imp)) : no_max_order (simple_graph string_imp) := sorry --non-trivial
lemma new_lemma_924 (h0 : function.extfun Type topological_space) : @t0_space.{0} (omega_complete_partial_order.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (omega_complete_partial_order.{0} empty))  := sorry --non-trivial
lemma new_lemma_925 (h0 : topological_space (canonically_linear_ordered_monoid (sub_neg_monoid real))) : totally_disconnected_space (canonically_linear_ordered_monoid (sub_neg_monoid real)) := sorry --non-trivial
lemma new_lemma_926 (h0 : functor.add_const (function.extfun Type ring) linarith.comp) : @is_domain.{0} (boolean_algebra.{0} linarith.comp) (@function.extfun_app.{2 1} Type ring.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type ring.{0}) linarith.comp h0) (boolean_algebra.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_927 (h0 : function.extfun Type complete_lattice) : @is_compactly_generated.{0} (distrib_lattice.{0} string_imp) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (distrib_lattice.{0} string_imp))  := sorry --non-trivial
lemma new_lemma_928 (h0 : topological_space (add_right_cancel_monoid (semiring empty))) : topological_space.separable_space (add_right_cancel_monoid (semiring empty)) := sorry --non-trivial
lemma new_lemma_929 (h0 : not (function.extfun Type topological_space -> false)) : @discrete_topology.{0} linarith.comp_source (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) linarith.comp_source)  := sorry --non-trivial
lemma new_lemma_930 (h0 : uniform_space (has_add (option num))) : separated_space (has_add (option num)) := sorry --non-trivial
lemma new_lemma_931 (h0 : functor.add_const (complete_lattice (boolean_algebra.core environment.implicit_infer_kind)) Type) : @is_compactly_generated.{0} (boolean_algebra.core.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 1} (complete_lattice.{0} (boolean_algebra.core.{0} environment.implicit_infer_kind)) Type h0)  := sorry --non-trivial
lemma new_lemma_932 (h0 : not (uniform_space (uniform_space fun_info) -> false)) : @complete_space.{0} (uniform_space.{0} fun_info) (@classical.by_contradiction'.{1} (uniform_space.{0} (uniform_space.{0} fun_info)) h0)  := sorry --non-trivial
lemma new_lemma_933 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @archimedean.{0} (has_inter.{0} ennreal) (@function.extfun_app.{2 1} Type ordered_add_comm_monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ordered_add_comm_monoid.{0}) (has_inter.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_934 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : palindrome (function.extfun_app (function.extfun_app h0 list) (has_pos_part Type)) := sorry --non-trivial
lemma new_lemma_935 (h0 : topological_space (free_add_monoid (semiring num))) : t1_space (free_add_monoid (semiring num)) := sorry --non-trivial
lemma new_lemma_936 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @rank_condition.{0} (linear_ordered_comm_ring.{0} empty) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (linear_ordered_comm_ring.{0} empty))  := sorry --non-trivial
lemma new_lemma_937 (h0 : uniform_space (random_gen (has_norm (has_norm fun_info)))) : complete_space (random_gen (has_norm (has_norm fun_info))) := sorry --non-trivial
lemma new_lemma_938 (h4 : topological_space (add_comm_semigroup linarith.ineq)) : topological_space.first_countable_topology (add_comm_semigroup linarith.ineq) := sorry --non-trivial
lemma new_lemma_939 (h0 : complete_lattice (left_cancel_semigroup (semiring (semiring num)))) : complete_lattice.is_Sup_finite_compact (left_cancel_semigroup (semiring (semiring num))) := sorry --non-trivial
lemma new_lemma_940 (h0 : function.extfun Type topological_space) : @totally_separated_space.{0} (linear_ordered_semiring.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (linear_ordered_semiring.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_941 (h1 : ring (semi_normed_ring string_imp)) : is_domain (semi_normed_ring string_imp) := sorry --non-trivial
lemma new_lemma_942 (h0 : not (topological_space (add_group num) -> false)) : @discrete_topology.{0} (add_group.{0} num) (@classical.by_contradiction'.{1} (topological_space.{0} (add_group.{0} num)) h0)  := sorry --non-trivial
lemma new_lemma_943 (h0 : ring (has_compl (has_ssubset string_imp))) : strong_rank_condition (has_compl (has_ssubset string_imp)) := sorry --non-trivial
lemma new_lemma_944 (h0 : fin has_zero.zero) : @path_connected_space.{0} (has_bot.{0} pos) (@matrix.vec_empty.{0} (topological_space.{0} (has_bot.{0} pos)) h0)  := sorry --non-trivial
lemma new_lemma_945 (h0 : function.extfun Type topological_space) : @preirreducible_space.{0} (has_top.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_top.{0} num))  := sorry --non-trivial
lemma new_lemma_946 (h0 : complete_lattice (semigroup (has_to_string unsigned))) : is_compactly_generated (semigroup (has_to_string unsigned)) := sorry --non-trivial
lemma new_lemma_947 (h0 : functor.add_const (topological_space (ordered_ring unsigned)) num) : @discrete_topology.{0} (ordered_ring.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (ordered_ring.{0} unsigned)) num h0)  := sorry --non-trivial
lemma new_lemma_948 (h0 : functor.add_const (group (has_zero name)) name) : @is_simple_group.{0} (has_zero.{0} name) (@functor.add_const.run.{0 0} (group.{0} (has_zero.{0} name)) name h0)  := sorry --non-trivial
lemma new_lemma_949 (h0 : topological_space (has_nnnorm (mul_one_class string_imp))) : path_connected_space (has_nnnorm (mul_one_class string_imp)) := sorry --non-trivial
lemma new_lemma_950 (h0 : function.extfun (Type 1) uniform_space) : @complete_space.{1} (canonically_ordered_monoid.{1} Type) (@function.extfun_app.{3 2} (Type 1) uniform_space.{1} h0 (canonically_ordered_monoid.{1} Type))  := sorry --non-trivial
lemma new_lemma_951 (h0 : filter (boolean_algebra.core (semigroup unsigned))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_952 (h0 : function.extfun Type ordered_comm_monoid) : @has_exists_mul_of_le.{0} (has_Inf.{0} pos) (@function.extfun_app.{2 1} Type ordered_comm_monoid.{0} h0 (has_Inf.{0} pos))  := sorry --non-trivial
lemma new_lemma_953 (h0 : functor.add_const (function.extfun Type topological_space) Type) : @irreducible_space.{0} (finset.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type topological_space.{0}) Type h0) (finset.{0} name))  := sorry --non-trivial
lemma new_lemma_954 (h0 : functor.add_const (monoid (has_nndist name)) (boolean_algebra Type)) : @monoid.fg.{0} (has_nndist.{0} name) (@functor.add_const.run.{0 1} (monoid.{0} (has_nndist.{0} name)) (boolean_algebra.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_955 (h0 : group (canonically_ordered_monoid (has_pos_part pos))) : is_simple_group (canonically_ordered_monoid (has_pos_part pos)) := sorry --non-trivial
lemma new_lemma_956 (h0 : topological_space (distrib_lattice (has_top linarith.ineq))) : locally_compact_space (distrib_lattice (has_top linarith.ineq)) := sorry --non-trivial
lemma new_lemma_957 (h0 : topological_space (has_nndist (mul_zero_class name))) : topological_space.separable_space (has_nndist (mul_zero_class name)) := sorry --non-trivial
lemma new_lemma_958 (h0 : topological_space (has_add char)) : totally_disconnected_space (has_add char) := sorry --non-trivial
lemma new_lemma_959 (h0 : functor.add_const (uniform_space (boolean_algebra name)) pos) : @separated_space.{0} (boolean_algebra.{0} name) (@functor.add_const.run.{0 0} (uniform_space.{0} (boolean_algebra.{0} name)) pos h0)  := sorry --non-trivial
lemma new_lemma_960 (h0 : topological_space (has_neg (has_to_string Type))) : t1_space (has_neg (has_to_string Type)) := sorry --non-trivial
lemma new_lemma_961 (h0 : topological_space (normed_lattice_add_comm_group (has_Inf linarith.comp))) : regular_space (normed_lattice_add_comm_group (has_Inf linarith.comp)) := sorry --non-trivial
lemma new_lemma_962 (h0 : ring (boolean_algebra.core (option (option (option ennreal))))) : rank_condition (boolean_algebra.core (option (option (option ennreal)))) := sorry --non-trivial
lemma new_lemma_963 (h0 : group (cancel_monoid (option (option (option ennreal))))) : normalizer_condition (cancel_monoid (option (option (option ennreal)))) := sorry --non-trivial
lemma new_lemma_964 (h0 : topological_space (simple_graph (has_neg (has_add (has_neg (has_neg linarith.comp)))))) : discrete_topology (simple_graph (has_neg (has_add (has_neg (has_neg linarith.comp))))) := sorry --non-trivial
lemma new_lemma_965 (h0 : semiring (finset real)) : is_noetherian_ring (finset real) := sorry --non-trivial
lemma new_lemma_966 (h0 : uniform_space (option (option (option unsigned)))) : separated_space (option (option (option unsigned))) := sorry --non-trivial
lemma new_lemma_967 (h0 : fin has_zero.zero) : @separated_space.{1} (simple_graph.{1} Type) (@matrix.vec_empty.{1} (uniform_space.{1} (simple_graph.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_968 (h0 : not (function.extfun Type topological_space -> false)) : @t0_space.{0} (metric_space.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (metric_space.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_969 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @archimedean.{0} (linear_ordered_field.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type ordered_add_comm_monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ordered_add_comm_monoid.{0}) (linear_ordered_field.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_970 (h0 : topological_space (canonically_ordered_comm_semiring (mul_zero_class name))) : irreducible_space (canonically_ordered_comm_semiring (mul_zero_class name)) := sorry --non-trivial
lemma new_lemma_971 (h0 : monoid num) : monoid.fg num := sorry --non-trivial
lemma new_lemma_972 (h0 : topological_space (add_cancel_monoid (has_neg linarith.comp))) : topological_space.separable_space (add_cancel_monoid (has_neg linarith.comp)) := sorry --non-trivial
lemma new_lemma_973 (h0 : complete_lattice (has_dist (option (option (option congr_arg_kind))))) : is_atomistic (has_dist (option (option (option congr_arg_kind)))) := sorry --non-trivial
lemma new_lemma_974 (h0 : add_group (complete_distrib_lattice linarith.comp)) : is_add_cyclic (complete_distrib_lattice linarith.comp) := sorry --non-trivial
lemma new_lemma_975 (h0 : uniform_space (normed_comm_ring (finset Type))) : separated_space (normed_comm_ring (finset Type)) := sorry --non-trivial
lemma new_lemma_976 (h0 : functor.add_const (group (add_group num)) num) : @group.fg.{0} (add_group.{0} num) (@functor.add_const.run.{0 0} (group.{0} (add_group.{0} num)) num h0)  := sorry --non-trivial
lemma new_lemma_977 (h0 : not (ring (id num) -> false)) : @rank_condition.{0} (@id.{2} Type num) (@classical.by_contradiction'.{1} (ring.{0} (@id.{2} Type num)) h0)  := sorry --non-trivial
lemma new_lemma_978 (h0 : topological_space (linear_ordered_cancel_comm_monoid empty)) : irreducible_space (linear_ordered_cancel_comm_monoid empty) := sorry --non-trivial
lemma new_lemma_979 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @preconnected_space.{0} (cancel_monoid.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (cancel_monoid.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_980 (h0 : topological_space (has_union (semiring empty))) : irreducible_space (has_union (semiring empty)) := sorry --non-trivial
lemma new_lemma_981 (h0 : function.extfun Type topological_space) : @totally_disconnected_space.{0} (option.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (option.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_982 (h0 : function.extfun Type monoid) : @monoid.fg.{0} (boolean_algebra.core.{0} ennreal) (@function.extfun_app.{2 1} Type monoid.{0} h0 (boolean_algebra.core.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_983 (h0 : functor.add_const (complete_lattice (boolean_algebra.core name)) (semigroup (semigroup unsigned))) : @is_compactly_generated.{0} (boolean_algebra.core.{0} name) (@functor.add_const.run.{0 0} (complete_lattice.{0} (boolean_algebra.core.{0} name)) (semigroup.{0} (semigroup.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_984 (h0 : functor.add_const (topological_space (add_comm_monoid linarith.comp)) pos) : @path_connected_space.{0} (add_comm_monoid.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (add_comm_monoid.{0} linarith.comp)) pos h0)  := sorry --non-trivial
lemma new_lemma_985 (h0 : not (uniform_space (distrib char) -> false)) : @complete_space.{0} (distrib.{0} char) (@classical.by_contradiction'.{1} (uniform_space.{0} (distrib.{0} char)) h0)  := sorry --non-trivial
lemma new_lemma_986 (h1 : set (has_compl environment.projection_info)) : set.finite h1 := sorry --non-trivial
lemma new_lemma_987 (h0 : function.extfun Type topological_space) : @totally_separated_space.{0} (add_group.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (add_group.{0} empty))  := sorry --non-trivial
lemma new_lemma_988 (h0 : group (ordered_ring congr_arg_kind)) : normalizer_condition (ordered_ring congr_arg_kind) := sorry --non-trivial
lemma new_lemma_989 (h0 : complete_lattice (finset (finset (has_zero Type)))) : is_compactly_generated (finset (finset (has_zero Type))) := sorry --non-trivial
lemma new_lemma_990 (h0 : ordered_comm_monoid (semigroup (has_neg (finset linarith.comp)))) : has_exists_mul_of_le (semigroup (has_neg (finset linarith.comp))) := sorry --non-trivial
lemma new_lemma_991 (h0 : function.extfun Type topological_space) : @locally_compact_space.{0} (filter.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (filter.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_992 (h0 : not (complete_lattice (comm_ring string.iterator_imp) -> false)) : @is_compactly_generated.{0} (comm_ring.{0} string.iterator_imp) (@classical.by_contradiction'.{1} (complete_lattice.{0} (comm_ring.{0} string.iterator_imp)) h0)  := sorry --non-trivial
lemma new_lemma_993 (h0 : uniform_space (has_inter (option (option unsigned)))) : complete_space (has_inter (option (option unsigned))) := sorry --non-trivial
lemma new_lemma_994 (h0 : not (ring (normed_group empty) -> false)) : @is_principal_ideal_ring.{0} (normed_group.{0} empty) (@classical.by_contradiction'.{1} (ring.{0} (normed_group.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_995 (h0 : complete_lattice (has_compl linarith.comp_source)) : complete_lattice.is_Sup_finite_compact (has_compl linarith.comp_source) := sorry --non-trivial
lemma new_lemma_996 (h1 : topological_space (semi_normed_comm_ring reducibility_hints)) : t0_space (semi_normed_comm_ring reducibility_hints) := sorry --non-trivial
lemma new_lemma_997 (h0 : ring (topological_space (has_nnnorm char))) : rank_condition (topological_space (has_nnnorm char)) := sorry --non-trivial
lemma new_lemma_998 (h0 : add_group (has_neg num)) : is_add_cyclic (has_neg num) := sorry --non-trivial
lemma new_lemma_999 (h0 : functor.add_const (ring (has_to_string name)) Type) : @is_domain.{0} (has_to_string.{0} name) (@functor.add_const.run.{0 1} (ring.{0} (has_to_string.{0} name)) Type h0)  := sorry --non-trivial
lemma new_lemma_1000 (h0 : functor.comp topological_space complete_distrib_lattice Type) : @t1_space.{1} (complete_distrib_lattice.{1} Type) (@functor.comp.run.{1 1 1} topological_space.{1} complete_distrib_lattice.{1} Type h0)  := sorry --non-trivial
lemma new_lemma_1001 (h0 : ring (has_Inf (has_add (has_add linarith.comp)))) : is_domain (has_Inf (has_add (has_add linarith.comp))) := sorry --non-trivial
lemma new_lemma_1002 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_atomistic.{0} (add_comm_monoid.{0} unsigned) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (add_comm_monoid.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_1003 (h0 : functor.add_const (filter (has_nndist linarith.comp)) linarith.comp) : filter.ne_bot (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_1004 (h0 : functor.add_const (group (dlist linarith.comp_source)) (linear_ordered_add_comm_group fun_info)) : @is_cyclic.{0} (dlist.{0} linarith.comp_source) (@functor.add_const.run.{0 0} (group.{0} (dlist.{0} linarith.comp_source)) (linear_ordered_add_comm_group.{0} fun_info) h0)  := sorry --non-trivial
lemma new_lemma_1005 (h0 : not (topological_space (bin_tree unsigned) -> false)) : @topological_space.separable_space.{0} (bin_tree.{0} unsigned) (@classical.by_contradiction'.{1} (topological_space.{0} (bin_tree.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_1006 (h0 : function.extfun Type add_monoid) : @add_monoid.fg.{0} (metric_space.{0} linarith.comp) (@function.extfun_app.{2 1} Type add_monoid.{0} h0 (metric_space.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_1007 (h0 : topological_space (complete_distrib_lattice empty)) : t1_space (complete_distrib_lattice empty) := sorry --non-trivial
lemma new_lemma_1008 (h0 : not (uniform_space (add_left_cancel_monoid linarith.ineq) -> false)) : @complete_space.{0} (add_left_cancel_monoid.{0} linarith.ineq) (@classical.by_contradiction'.{1} (uniform_space.{0} (add_left_cancel_monoid.{0} linarith.ineq)) h0)  := sorry --non-trivial
lemma new_lemma_1009 (h0 : functor.add_const (add_group (has_zero linarith.comp)) environment.implicit_infer_kind) : @is_add_cyclic.{0} (has_zero.{0} linarith.comp) (@functor.add_const.run.{0 0} (add_group.{0} (has_zero.{0} linarith.comp)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_1010 (h0 : function.extfun Type topological_space) : @topological_space.separable_space.{0} (complete_distrib_lattice.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (complete_distrib_lattice.{0} pos))  := sorry --non-trivial
lemma new_lemma_1011 (h0 : list (cancel_monoid (option (option empty)))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_1012 (h0 : functor.add_const (monoid (has_pos_part Type)) linarith.comp) : @monoid.fg.{1} (has_pos_part.{1} Type) (@functor.add_const.run.{1 0} (monoid.{1} (has_pos_part.{1} Type)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_1013 (h0 : has_nndist (has_add pos) -> has_nndist (has_add pos) -> Prop) : well_founded h0 := sorry --non-trivial
lemma new_lemma_1014 (h0 : ring (has_ssubset (has_nnnorm linarith.ineq))) : is_domain (has_ssubset (has_nnnorm linarith.ineq)) := sorry --non-trivial
lemma new_lemma_1015 (h0 : not (cancel_comm_monoid_with_zero (add_right_cancel_monoid unsigned) -> false)) : @unique_factorization_monoid.{0} (add_right_cancel_monoid.{0} unsigned) (@classical.by_contradiction'.{1} (cancel_comm_monoid_with_zero.{0} (add_right_cancel_monoid.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_1016 (h0 : function.extfun Type topological_space) : @t1_space.{0} (boolean_algebra.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (boolean_algebra.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_1017 (h0 : list (add_group (semiring (semiring (semiring (semiring (semiring empty))))))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_1018 (h0 : functor.add_const (topological_space nnreal) unsigned) : path_connected_space nnreal := sorry --non-trivial
lemma new_lemma_1019 (h0 : functor.add_const (topological_space (semigroup environment.implicit_infer_kind)) Type) : @topological_space.separable_space.{0} (semigroup.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 1} (topological_space.{0} (semigroup.{0} environment.implicit_infer_kind)) Type h0)  := sorry --non-trivial
lemma new_lemma_1020 (h0 : functor.add_const (list (has_zero environment.implicit_infer_kind)) name) : palindrome (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_1021 (h0 h3 : multiset (add_comm_semigroup linarith.ineq)) : multiset.disjoint h0 h3 := sorry --non-trivial
lemma new_lemma_1022 (h0 : functor.add_const (add_monoid pos) (ring (finset linarith.comp))) : @add_monoid.fg.{0} pos (@functor.add_const.run.{0 0} (add_monoid.{0} pos) (ring.{0} (finset.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_1023 (h0 : functor.add_const (ring (semiring congr_arg_kind)) empty) : @is_domain.{0} (semiring.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (ring.{0} (semiring.{0} congr_arg_kind)) empty h0)  := sorry --non-trivial
lemma new_lemma_1024 (h0 : functor.comp group has_nndist pos) : @is_simple_group.{0} (has_nndist.{0} pos) (@functor.comp.run.{0 0 0} group.{0} has_nndist.{0} pos (@functor.comp.run.{0 0 0} group.{0} has_nndist.{0} pos (@functor.comp.run.{0 0 0} group.{0} has_nndist.{0} pos (@functor.comp.run.{0 0 0} group.{0} has_nndist.{0} pos (@functor.comp.run.{0 0 0} group.{0} has_nndist.{0} pos (@functor.comp.run.{0 0 0} group.{0} has_nndist.{0} pos (@functor.comp.run.{0 0 0} group.{0} has_nndist.{0} pos (@functor.comp.run.{0 0 0} group.{0} has_nndist.{0} pos (@functor.comp.run.{0 0 0} group.{0} has_nndist.{0} pos (@functor.comp.run.{0 0 0} group.{0} has_nndist.{0} pos (@functor.comp.run.{0 0 0} group.{0} has_nndist.{0} pos (@functor.comp.run.{0 0 0} group.{0} has_nndist.{0} pos (@functor.comp.run.{0 0 0} group.{0} has_nndist.{0} pos (@functor.comp.run.{0 0 0} group.{0} has_nndist.{0} pos (@functor.comp.run.{0 0 0} group.{0} has_nndist.{0} pos (@functor.comp.run.{0 0 0} group.{0} has_nndist.{0} pos (@functor.comp.run.{0 0 0} group.{0} has_nndist.{0} pos (@functor.comp.run.{0 0 0} group.{0} has_nndist.{0} pos (@functor.comp.run.{0 0 0} group.{0} has_nndist.{0} pos (@functor.comp.run.{0 0 0} group.{0} has_nndist.{0} pos (@functor.comp.run.{0 0 0} group.{0} has_nndist.{0} pos (@functor.comp.run.{0 0 0} group.{0} has_nndist.{0} pos (@functor.comp.run.{0 0 0} group.{0} has_nndist.{0} pos (@functor.comp.run.{0 0 0} group.{0} has_nndist.{0} pos h0))))))))))))))))))))))))  := sorry --non-trivial
lemma new_lemma_1025 (h0 : ordered_add_comm_monoid (simple_graph (option empty))) : archimedean (simple_graph (option empty)) := sorry --non-trivial
lemma new_lemma_1026 (h0 : function.extfun Type uniform_space) : @separated_space.{0} (has_norm.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (has_norm.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_1027 (h0 : function.extfun (Type 1) complete_lattice) : @is_atomistic.{1} (boolean_algebra.core.{1} Type) (@function.extfun_app.{3 2} (Type 1) complete_lattice.{1} h0 (boolean_algebra.core.{1} Type))  := sorry --non-trivial
lemma new_lemma_1028 (h0 : group (ordered_comm_monoid pos)) : is_cyclic (ordered_comm_monoid pos) := sorry --non-trivial
lemma new_lemma_1029 (h0 : functor.add_const (uniform_space (mul_zero_class empty)) (semiring num)) : @separated_space.{0} (mul_zero_class.{0} empty) (@functor.add_const.run.{0 0} (uniform_space.{0} (mul_zero_class.{0} empty)) (semiring.{0} num) h0)  := sorry --non-trivial
lemma new_lemma_1030 (h0 : uniform_space (has_nndist (finset linarith.comp))) : separated_space (has_nndist (finset linarith.comp)) := sorry --non-trivial
lemma new_lemma_1031 (h0 : uniform_space (add_cancel_monoid (has_neg linarith.comp))) : separated_space (add_cancel_monoid (has_neg linarith.comp)) := sorry --non-trivial
lemma new_lemma_1032 (h0 : function.extfun ((Type -> Type) -> Type 1) (function.extfun (Type -> Type))) : @group.fg.{0} linarith.comp (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) (@function.extfun_app.{3 2} ((Type → Type) → Type 1) (function.extfun.{2 2} (Type → Type)) h0 (function.extfun.{2 1} Type)) group.{0}) linarith.comp)  := sorry --non-trivial
lemma new_lemma_1033 (h0 : functor.add_const (topological_space (has_neg Type)) (finset pos)) : @discrete_topology.{1} (has_neg.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (has_neg.{1} Type)) (finset.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_1034 (h0 : topological_space (add_cancel_monoid (add_cancel_monoid (has_neg_part Type)))) : totally_separated_space (add_cancel_monoid (add_cancel_monoid (has_neg_part Type))) := sorry --non-trivial
lemma new_lemma_1035 (h0 : function.extfun Type topological_space) : @totally_separated_space.{0} (has_norm.{0} linarith.ineq) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_norm.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_1036 (h0 : finset (has_star empty)) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_1037 (h0 : not (has_mem.mem linarith.ineq has_emptyc.emptyc -> false)) : @irreducible_space.{0} linarith.ineq (@finset.pi.empty.{1 0} Type topological_space.{0} linarith.ineq (@classical.by_contradiction'.{0} (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) linarith.ineq (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))) h0))  := sorry --non-trivial
lemma new_lemma_1038 (h0 : filter (add_comm_monoid (option num))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_1039 (h0 : topological_space (ordered_comm_monoid (has_bot (has_bot real)))) : path_connected_space (ordered_comm_monoid (has_bot (has_bot real))) := sorry --non-trivial
lemma new_lemma_1040 (h0 : functor.add_const (group (semigroup name)) (has_neg linarith.comp)) : @is_cyclic.{0} (semigroup.{0} name) (@functor.add_const.run.{0 0} (group.{0} (semigroup.{0} name)) (has_neg.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_1041 (h0 : add_group (has_bot (has_neg pos))) : is_add_cyclic (has_bot (has_neg pos)) := sorry --non-trivial
lemma new_lemma_1042 (h0 : topological_space (has_emptyc linarith.comp)) : totally_separated_space (has_emptyc linarith.comp) := sorry --non-trivial
lemma new_lemma_1043 (h0 : function.extfun Type group) : @group.fg.{0} (partial_order.{0} num) (@function.extfun_app.{2 1} Type group.{0} h0 (partial_order.{0} num))  := sorry --non-trivial
lemma new_lemma_1044 (h1 : function.extfun (finset Type) (has_mem.mem (with_one congr_arg_kind))) : @t0_space.{0} (with_one.{0} congr_arg_kind) (@finset.pi.empty.{1 0} Type topological_space.{0} (with_one.{0} congr_arg_kind) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (with_one.{0} congr_arg_kind)) h1 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_1045 (h0 : not (cancel_comm_monoid_with_zero (normed_group num) -> false)) : @unique_factorization_monoid.{0} (normed_group.{0} num) (@classical.by_contradiction'.{1} (cancel_comm_monoid_with_zero.{0} (normed_group.{0} num)) h0)  := sorry --non-trivial
lemma new_lemma_1046 (h1 : uniform_space (measurable_space to_additive.value_type)) : complete_space (measurable_space to_additive.value_type) := sorry --non-trivial
lemma new_lemma_1047 (h0 : ring (finset linarith.comp)) : rank_condition (finset linarith.comp) := sorry --non-trivial
lemma new_lemma_1048 (h0 : topological_space (linear_ordered_add_comm_group (complete_semilattice_Sup string_imp))) : locally_compact_space (linear_ordered_add_comm_group (complete_semilattice_Sup string_imp)) := sorry --non-trivial
lemma new_lemma_1049 (h0 : topological_space (boolean_algebra.core num)) : irreducible_space (boolean_algebra.core num) := sorry --non-trivial
lemma new_lemma_1050 (h0 : topological_space (ordered_comm_ring (has_add linarith.comp))) : preirreducible_space (ordered_comm_ring (has_add linarith.comp)) := sorry --non-trivial
lemma new_lemma_1051 (h0 : list (boolean_algebra (has_add (has_neg_part (has_add Type))))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_1052 (h0 : functor.add_const (semiring (simple_graph empty)) congr_arg_kind) : @is_noetherian_ring.{0} (simple_graph.{0} empty) (@functor.add_const.run.{0 0} (semiring.{0} (simple_graph.{0} empty)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_1053 (h0 : function.extfun nat fin) : @is_add_cyclic.{0} (ordered_comm_ring.{0} real) (@matrix.vec_empty.{0} (add_group.{0} (ordered_comm_ring.{0} real)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_1054 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @monoid.fg.{0} (distrib_lattice.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 monoid.{0}) (distrib_lattice.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_1055 (h0 : topological_space (has_norm (semiring linarith.comp))) : preirreducible_space (has_norm (semiring linarith.comp)) := sorry --non-trivial
lemma new_lemma_1056 (h0 : functor.add_const (function.extfun (Type 1) topological_space) (has_nndist (has_neg_part pos))) : @loc_path_connected_space.{1} (boolean_algebra.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) topological_space.{1}) (has_nndist.{0} (has_neg_part.{0} pos)) h0) (boolean_algebra.{1} Type))  := sorry --non-trivial
lemma new_lemma_1057 (h0 : topological_space (comm_group (mul_zero_class Type))) : totally_separated_space (comm_group (mul_zero_class Type)) := sorry --non-trivial
lemma new_lemma_1058 (h0 : not (function.extfun Type list -> false)) : list.nodup (function.extfun_app (classical.by_contradiction' h0) (has_norm fun_info)) := sorry --non-trivial
lemma new_lemma_1059 (h0 : topological_space (has_neg Type)) : normal_space (has_neg Type) := sorry --non-trivial
lemma new_lemma_1060 (h0 : add_group (comm_ring (random_gen char))) : is_add_cyclic (comm_ring (random_gen char)) := sorry --non-trivial
lemma new_lemma_1061 (h0 : fin has_zero.zero) : @locally_compact_space.{0} (sub_neg_monoid.{0} name) (@matrix.vec_empty.{0} (topological_space.{0} (sub_neg_monoid.{0} name)) h0)  := sorry --non-trivial
lemma new_lemma_1062 (h0 : monoid (has_neg_part (comm_group (comm_group unsigned)))) : monoid.fg (has_neg_part (comm_group (comm_group unsigned))) := sorry --non-trivial
lemma new_lemma_1063 (h0 : function.extfun Type monoid) : @monoid.fg.{0} (has_neg_part.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type monoid.{0} h0 (has_neg_part.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_1064 (h0 : function.extfun Type (functor.add_const (list pos))) : list.nodup (functor.add_const.run (function.extfun_app h0 linarith.comp)) := sorry --non-trivial
lemma new_lemma_1065 (h0 : not (function.extfun Type ring -> false)) : @strong_rank_condition.{0} (has_emptyc.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type ring.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type ring.{0}) h0) (has_emptyc.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_1066 (h0 : functor.add_const (topological_space (has_Inf name)) linarith.comp) : @discrete_topology.{0} (has_Inf.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (has_Inf.{0} name)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_1067 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @totally_disconnected_space.{0} (measure_theory.measure_space.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (measure_theory.measure_space.{0} num))  := sorry --non-trivial
lemma new_lemma_1068 (h0 : function.extfun Type add_group) : @is_add_cyclic.{0} (linear_ordered_comm_monoid_with_zero.{0} unsigned) (@function.extfun_app.{2 1} Type add_group.{0} h0 (linear_ordered_comm_monoid_with_zero.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_1069 (h0 : fin has_zero.zero) : @preconnected_space.{1} (add_comm_monoid.{1} Type) (@matrix.vec_empty.{1} (topological_space.{1} (add_comm_monoid.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_1070 (h0 : topological_space (has_nndist (option (option (option unsigned))))) : discrete_topology (has_nndist (option (option (option unsigned)))) := sorry --non-trivial
lemma new_lemma_1071 (h0 : function.extfun Type topological_space) : @t0_space.{0} (with_one.{0} string_imp) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (with_one.{0} string_imp))  := sorry --non-trivial
lemma new_lemma_1072 (h0 : topological_space (normed_lattice_add_comm_group Type)) : regular_space (normed_lattice_add_comm_group Type) := sorry --non-trivial
lemma new_lemma_1073 (h0 : not (function.extfun Type add_monoid -> false)) : @add_monoid.fg.{0} (add_right_cancel_monoid.{0} empty) (@function.extfun_app.{2 1} Type add_monoid.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type add_monoid.{0}) h0) (add_right_cancel_monoid.{0} empty))  := sorry --non-trivial
lemma new_lemma_1074 (h0 : functor.add_const (function.extfun Type topological_space) pos) : @discrete_topology.{0} (pseudo_emetric_space.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) pos h0) (pseudo_emetric_space.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_1075 (h0 : has_mem.mem (linear_ordered_semiring linarith.comp) has_emptyc.emptyc) : @irreducible_space.{0} (linear_ordered_semiring.{0} linarith.comp) (@finset.pi.empty.{1 0} Type topological_space.{0} (linear_ordered_semiring.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_1076 (h0 : topological_space (measurable_space (semiring unsigned))) : t0_space (measurable_space (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_1077 (h0 : functor.add_const (add_group (finset Type)) unsigned) : @is_add_cyclic.{1} (finset.{1} Type) (@functor.add_const.run.{1 0} (add_group.{1} (finset.{1} Type)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_1078 (h0 : add_group (has_top (has_top linarith.ineq))) : is_add_cyclic (has_top (has_top linarith.ineq)) := sorry --non-trivial
lemma new_lemma_1079 (h0 : functor.add_const (ordered_comm_monoid (normed_comm_ring pos)) environment.implicit_infer_kind) : @has_exists_mul_of_le.{0} (normed_comm_ring.{0} pos) (@functor.add_const.run.{0 0} (ordered_comm_monoid.{0} (normed_comm_ring.{0} pos)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_1080 (h0 : functor.add_const (topological_space (mul_zero_class ennreal)) unsigned) : @normal_space.{0} (mul_zero_class.{0} ennreal) (@functor.add_const.run.{0 0} (topological_space.{0} (mul_zero_class.{0} ennreal)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_1081 (h0 : function.extfun Type topological_space) : @irreducible_space.{0} (left_cancel_semigroup.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (left_cancel_semigroup.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_1082 (h0 : topological_space (cancel_monoid (semigroup (semigroup pos)))) : preconnected_space (cancel_monoid (semigroup (semigroup pos))) := sorry --non-trivial
lemma new_lemma_1083 (h0 : add_group (has_nnnorm (random_gen (random_gen (has_lt (random_gen char)))))) : is_add_cyclic (has_nnnorm (random_gen (random_gen (has_lt (random_gen char))))) := sorry --non-trivial
lemma new_lemma_1084 (h0 : topological_space (add_cancel_monoid (has_neg Type))) : t1_space (add_cancel_monoid (has_neg Type)) := sorry --non-trivial
lemma new_lemma_1085 (h0 : functor.add_const (ring (semigroup unsigned)) environment.implicit_infer_kind) : @rank_condition.{0} (semigroup.{0} unsigned) (@functor.add_const.run.{0 0} (ring.{0} (semigroup.{0} unsigned)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_1086 (h0 : filter (topological_space linarith.comp_source)) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_1087 (h0 : function.extfun Type monoid) : @monoid.fg.{0} (measurable_space.{0} fun_info) (@function.extfun_app.{2 1} Type monoid.{0} h0 (measurable_space.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_1088 (h0 : topological_space (has_le environment.projection_info)) (h1 : preorder (has_le environment.projection_info)) : order_topology (has_le environment.projection_info) := sorry --non-trivial
lemma new_lemma_1089 (h0 : fin has_zero.zero) : @archimedean.{0} (boolean_algebra.{0} pos) (@matrix.vec_empty.{0} (ordered_add_comm_monoid.{0} (boolean_algebra.{0} pos)) h0)  := sorry --non-trivial
lemma new_lemma_1090 (h0 : functor.add_const (filter (add_cancel_monoid name)) linarith.comp) : filter.ne_bot (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_1091 (h0 : function.extfun Type topological_space) : @normal_space.{0} (with_bot.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (with_bot.{0} empty))  := sorry --non-trivial
lemma new_lemma_1092 (h0 : list (normed_comm_ring (finset (has_Inf pos)))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_1093 (h0 : functor.add_const (topological_space (simple_graph unsigned)) congr_arg_kind) : @t1_space.{0} (simple_graph.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (simple_graph.{0} unsigned)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_1094 (h0 : function.extfun Type semiring) : @is_noetherian_ring.{0} (complete_distrib_lattice.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type semiring.{0} h0 (complete_distrib_lattice.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_1095 (h0 : uniform_space (with_zero (has_nnnorm fun_info))) : complete_space (with_zero (has_nnnorm fun_info)) := sorry --non-trivial
lemma new_lemma_1096 (h0 : set (uniform_space (distrib string.iterator_imp))) : set.finite h0 := sorry --non-trivial
lemma new_lemma_1097 (h0 : group (left_cancel_monoid (semiring (semiring unsigned)))) : group.fg (left_cancel_monoid (semiring (semiring unsigned))) := sorry --non-trivial
lemma new_lemma_1098 (h0 : uniform_space string.iterator_imp) : complete_space string.iterator_imp := sorry --non-trivial
lemma new_lemma_1099 (h0 : function.extfun Type (prod (ordered_cancel_add_comm_monoid unsigned))) : id_rel (function.extfun_app h0 (ordered_cancel_add_comm_monoid unsigned)) := sorry --non-trivial
lemma new_lemma_1100 (h0 : functor.add_const (topological_space (comm_group ennreal)) name) : @t1_space.{0} (comm_group.{0} ennreal) (@functor.add_const.run.{0 0} (topological_space.{0} (comm_group.{0} ennreal)) name h0)  := sorry --non-trivial
lemma new_lemma_1101 (h0 : prod (monoid ennreal) (monoid ennreal)) : id_rel h0 := sorry --non-trivial
lemma new_lemma_1102 (h0 : group (has_add pos)) : group.fg (has_add pos) := sorry --non-trivial
lemma new_lemma_1103 (h0 : topological_space (ring (comm_group Type))) : totally_separated_space (ring (comm_group Type)) := sorry --non-trivial
lemma new_lemma_1104 (h0 : complete_lattice (has_add (option pos))) : is_atomistic (has_add (option pos)) := sorry --non-trivial
lemma new_lemma_1105 (h0 : functor.add_const (topological_space (has_to_string unsigned)) Type) : @discrete_topology.{0} (has_to_string.{0} unsigned) (@functor.add_const.run.{0 1} (topological_space.{0} (has_to_string.{0} unsigned)) Type h0)  := sorry --non-trivial
lemma new_lemma_1106 (h0 : functor.add_const (ring (has_zero pos)) linarith.comp) : @rank_condition.{0} (has_zero.{0} pos) (@functor.add_const.run.{0 0} (ring.{0} (has_zero.{0} pos)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_1107 (h0 : not (filter (add_right_cancel_monoid num) -> false)) : filter.ne_bot (classical.by_contradiction' h0) := sorry --non-trivial
lemma new_lemma_1108 (h1 : ring num) : rank_condition num := sorry --non-trivial
lemma new_lemma_1109 (h0 : topological_space (random_gen empty)) : totally_disconnected_space (random_gen empty) := sorry --non-trivial
lemma new_lemma_1110 (h0 : list (ring unsigned)) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_1111 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @is_principal_ideal_ring.{1} (has_pos_part.{1} Type) (@function.extfun_app.{3 2} (Type 1) ring.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 ring.{1}) (has_pos_part.{1} Type))  := sorry --non-trivial
lemma new_lemma_1112 (h0 : function.extfun Type topological_space) : @irreducible_space.{0} (complete_semilattice_Sup.{0} string_imp) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (complete_semilattice_Sup.{0} string_imp))  := sorry --non-trivial
lemma new_lemma_1113 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @normalizer_condition.{0} (has_add.{0} pos) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (has_add.{0} pos))  := sorry --non-trivial
lemma new_lemma_1114 (h0 : not (complete_lattice (linear_ordered_comm_group_with_zero linarith.ineq) -> false)) : @is_compactly_generated.{0} (linear_ordered_comm_group_with_zero.{0} linarith.ineq) (@classical.by_contradiction'.{1} (complete_lattice.{0} (linear_ordered_comm_group_with_zero.{0} linarith.ineq)) h0)  := sorry --non-trivial
lemma new_lemma_1115 (h1 : complete_lattice (has_ssubset (has_nnnorm to_additive.value_type))) : complete_lattice.is_Sup_finite_compact (has_ssubset (has_nnnorm to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_1116 (h0 : function.extfun Type add_group) : @is_add_cyclic.{0} (has_norm.{0} unsigned) (@function.extfun_app.{2 1} Type add_group.{0} h0 (has_norm.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_1117 (h0 : not (function.extfun Type topological_space -> false)) : @totally_separated_space.{0} (semiring.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (semiring.{0} empty))  := sorry --non-trivial
lemma new_lemma_1118 (h0 : complete_lattice (partial_order (semiring congr_arg_kind))) : complete_lattice.is_Sup_finite_compact (partial_order (semiring congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_1119 (h0 : functor.add_const (topological_space (add_cancel_monoid unsigned)) empty) : @t1_space.{0} (add_cancel_monoid.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (add_cancel_monoid.{0} unsigned)) empty h0)  := sorry --non-trivial
lemma new_lemma_1120 (h0 : ring (preorder (semiring (semiring unsigned)))) : is_domain (preorder (semiring (semiring unsigned))) := sorry --non-trivial
lemma new_lemma_1121 (h0 : function.extfun Type topological_space) : @totally_disconnected_space.{0} (non_assoc_semiring.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (non_assoc_semiring.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_1122 (h0 : topological_space (has_bot (has_pos_part Type))) : t1_space (has_bot (has_pos_part Type)) := sorry --non-trivial
lemma new_lemma_1123 (h0 : topological_space (complete_semilattice_Sup (semiring (semiring (semiring unsigned))))) : path_connected_space (complete_semilattice_Sup (semiring (semiring (semiring unsigned)))) := sorry --non-trivial
lemma new_lemma_1124 (h0 : set (nondiscrete_normed_field std_gen)) : set.finite h0 := sorry --non-trivial
lemma new_lemma_1125 (h0 : function.extfun Type topological_space) : @path_connected_space.{0} (simple_graph.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (simple_graph.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_1126 (h0 : not (function.extfun Type topological_space -> false)) : @path_connected_space.{0} (has_one.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (has_one.{0} empty))  := sorry --non-trivial
lemma new_lemma_1127 (h0 : ring (comm_ring (random_gen (random_gen (has_nnnorm (random_gen linarith.ineq)))))) : strong_rank_condition (comm_ring (random_gen (random_gen (has_nnnorm (random_gen linarith.ineq))))) := sorry --non-trivial
lemma new_lemma_1128 (h0 : uniform_space (ordered_comm_monoid (has_add name))) : separated_space (ordered_comm_monoid (has_add name)) := sorry --non-trivial
lemma new_lemma_1129 (h0 : Prop) (h1 : fin has_zero.zero) : list.ilast' h0 (matrix.vec_empty (id h1)) := sorry --non-trivial
lemma new_lemma_1130 (h0 : list (finset (cancel_monoid ennreal))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_1131 (h0 : function.extfun (finset Type) (has_mem.mem (semiring linarith.comp))) : @complete_space.{0} (semiring.{0} linarith.comp) (@finset.pi.empty.{1 0} Type uniform_space.{0} (semiring.{0} linarith.comp) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (semiring.{0} linarith.comp)) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_1132 (h0 : functor.add_const (ordered_add_comm_monoid (is_R_or_C unsigned)) empty) : @archimedean.{0} (is_R_or_C.{0} unsigned) (@functor.add_const.run.{0 0} (ordered_add_comm_monoid.{0} (is_R_or_C.{0} unsigned)) empty h0)  := sorry --non-trivial
lemma new_lemma_1133 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @totally_disconnected_space.{0} (add_cancel_monoid.{0} ennreal) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (add_cancel_monoid.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_1134 (h0 : function.extfun Type add_monoid) : @add_monoid.fg.{0} (semigroup.{0} (option.{0} empty)) (@function.extfun_app.{2 1} Type add_monoid.{0} h0 (semigroup.{0} (option.{0} empty)))  := sorry --non-trivial
lemma new_lemma_1135 (h0 : not (function.extfun Type complete_lattice -> false)) : @is_compactly_generated.{0} (semiring.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type complete_lattice.{0}) h0) (semiring.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_1136 (h0 : functor.add_const (group (has_pos_part linarith.comp)) Type) : @group.fg.{0} (has_pos_part.{0} linarith.comp) (@functor.add_const.run.{0 1} (group.{0} (has_pos_part.{0} linarith.comp)) Type h0)  := sorry --non-trivial
lemma new_lemma_1137 (h0 : function.extfun Type group) : @is_cyclic.{0} (add_cancel_comm_monoid.{0} unsigned) (@function.extfun_app.{2 1} Type group.{0} h0 (add_cancel_comm_monoid.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_1138 (h3 : topological_space (linear_ordered_add_comm_group to_additive.value_type)) : totally_disconnected_space (linear_ordered_add_comm_group to_additive.value_type) := sorry --non-trivial
lemma new_lemma_1139 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @add_monoid.fg.{0} (normed_lattice_add_comm_group.{0} real) (@function.extfun_app.{2 1} Type add_monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 add_monoid.{0}) (normed_lattice_add_comm_group.{0} real))  := sorry --non-trivial
lemma new_lemma_1140 (h1 : function.extfun Type group) : @normalizer_condition.{0} linarith.comp_source (@function.extfun_app.{2 1} Type group.{0} h1 linarith.comp_source)  := sorry --non-trivial
lemma new_lemma_1141 (h0 : add_monoid (finset (add_comm_monoid name))) : add_monoid.fg (finset (add_comm_monoid name)) := sorry --non-trivial
lemma new_lemma_1142 (h0 : not (ring (linear_ordered_comm_ring congr_arg_kind) -> false)) : @is_domain.{0} (linear_ordered_comm_ring.{0} congr_arg_kind) (@classical.by_contradiction'.{1} (ring.{0} (linear_ordered_comm_ring.{0} congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_1143 (h0 : topological_space (has_nndist (ring pos))) : path_connected_space (has_nndist (ring pos)) := sorry --non-trivial
lemma new_lemma_1144 (h0 : add_monoid (linear_ordered_comm_group (option (option empty)))) : add_monoid.fg (linear_ordered_comm_group (option (option empty))) := sorry --non-trivial
lemma new_lemma_1145 (h0 : group (has_to_string (option unsigned))) : is_simple_group (has_to_string (option unsigned)) := sorry --non-trivial
lemma new_lemma_1146 (h0 : filter (has_emptyc linarith.comp_source)) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_1147 (h0 : functor.add_const (ring (has_to_string linarith.comp)) Type) : @rank_condition.{0} (has_to_string.{0} linarith.comp) (@functor.add_const.run.{0 1} (ring.{0} (has_to_string.{0} linarith.comp)) Type h0)  := sorry --non-trivial
lemma new_lemma_1148 (h0 : topological_space (id (has_norm (has_norm (random_gen num))))) : totally_disconnected_space (id (has_norm (has_norm (random_gen num)))) := sorry --non-trivial
lemma new_lemma_1149 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @totally_separated_space.{0} (has_zero.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_zero.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_1150 (h0 : functor.add_const (topological_space (has_Inf pos)) linarith.comp) : @loc_path_connected_space.{0} (has_Inf.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (has_Inf.{0} pos)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_1151 (h0 : cancel_comm_monoid_with_zero (complete_distrib_lattice (ordered_comm_ring pos))) : unique_factorization_monoid (complete_distrib_lattice (ordered_comm_ring pos)) := sorry --non-trivial
lemma new_lemma_1152 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : is_compactly_generated (measurable_space fun_info) := sorry --non-trivial
lemma new_lemma_1153 (h0 : not (complete_lattice (topological_space fun_info) -> false)) : complete_lattice.is_Sup_finite_compact (topological_space fun_info) := sorry --non-trivial
lemma new_lemma_1154 (h0 : topological_space (complete_distrib_lattice pos)) : totally_separated_space (complete_distrib_lattice pos) := sorry --non-trivial
lemma new_lemma_1155 (h0 : not (function.extfun Type group -> false)) : @normalizer_condition.{0} (with_bot.{0} linarith.ineq) (@function.extfun_app.{2 1} Type group.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type group.{0}) h0) (with_bot.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_1156 (h0 : topological_space (boolean_algebra (boolean_algebra pos))) : locally_compact_space (boolean_algebra (boolean_algebra pos)) := sorry --non-trivial
lemma new_lemma_1157 (h0 : topological_space (boolean_algebra (ring (has_add Type)))) : sequential_space (boolean_algebra (ring (has_add Type))) := sorry --non-trivial
lemma new_lemma_1158 (h0 : ordered_comm_monoid (ordered_comm_monoid (ring Type))) : has_exists_mul_of_le (ordered_comm_monoid (ring Type)) := sorry --non-trivial
lemma new_lemma_1159 (h0 : functor.comp topological_space has_neg environment.implicit_infer_kind) : @normal_space.{0} (has_neg.{0} environment.implicit_infer_kind) (@functor.comp.run.{0 0 0} topological_space.{0} has_neg.{0} environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_1160 (h0 : topological_space (simple_graph (mul_one_class enat))) (h1 : add_group (simple_graph (mul_one_class enat))) : topological_add_group (simple_graph (mul_one_class enat)) := sorry --non-trivial
lemma new_lemma_1161 (h0 : list (is_R_or_C num)) : palindrome h0 := sorry --non-trivial
lemma new_lemma_1162 (h0 : ordered_add_comm_monoid (canonically_ordered_monoid real)) : archimedean (canonically_ordered_monoid real) := sorry --non-trivial
lemma new_lemma_1163 (h0 : topological_space (boolean_algebra (has_pos_part Type))) : preirreducible_space (boolean_algebra (has_pos_part Type)) := sorry --non-trivial
lemma new_lemma_1164 (h0 : topological_space (add_comm_monoid real)) : t1_space (add_comm_monoid real) := sorry --non-trivial
lemma new_lemma_1165 (h0 : finset (has_Inf real)) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_1166 (h0 : function.extfun Type add_monoid) : @add_monoid.fg.{0} (omega_complete_partial_order.{0} unsigned) (@function.extfun_app.{2 1} Type add_monoid.{0} h0 (omega_complete_partial_order.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_1167 (h0 : ring (dlist (random_gen to_additive.value_type))) : rank_condition (dlist (random_gen to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_1168 (h0 : functor.add_const (ring (comm_group unsigned)) (semigroup ennreal)) : @is_domain.{0} (comm_group.{0} unsigned) (@functor.add_const.run.{0 0} (ring.{0} (comm_group.{0} unsigned)) (semigroup.{0} ennreal) h0)  := sorry --non-trivial
lemma new_lemma_1169 (h0 : function.extfun Type (functor.add_const (uniform_space (add_left_cancel_semigroup empty)))) : @complete_space.{0} (add_left_cancel_semigroup.{0} empty) (@functor.add_const.run.{0 0} (uniform_space.{0} (add_left_cancel_semigroup.{0} empty)) unsigned (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (uniform_space.{0} (add_left_cancel_semigroup.{0} empty))) h0 unsigned))  := sorry --non-trivial
lemma new_lemma_1170 (h0 : list (cancel_monoid (cancel_monoid (finset Type)))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_1171 (h0 : functor.add_const (function.extfun Type topological_space) pos) : @totally_disconnected_space.{0} (has_neg.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) pos h0) (has_neg.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_1172 (h0 : functor.add_const (topological_space (has_to_string pos)) name) : @loc_path_connected_space.{0} (has_to_string.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (has_to_string.{0} pos)) name h0)  := sorry --non-trivial
lemma new_lemma_1173 (h0 : group (normed_comm_ring (has_add (comm_group Type)))) : normalizer_condition (normed_comm_ring (has_add (comm_group Type))) := sorry --non-trivial
lemma new_lemma_1174 (h0 : cancel_comm_monoid_with_zero (has_zero environment.implicit_infer_kind)) : unique_factorization_monoid (has_zero environment.implicit_infer_kind) := sorry --non-trivial
lemma new_lemma_1175 (h0 : complete_lattice (add_monoid linarith.comp_source)) : complete_lattice.is_Sup_finite_compact (add_monoid linarith.comp_source) := sorry --non-trivial
lemma new_lemma_1176 (h0 : functor.add_const (cancel_comm_monoid_with_zero (partial_order empty)) empty) : @unique_factorization_monoid.{0} (partial_order.{0} empty) (@functor.add_const.run.{0 0} (cancel_comm_monoid_with_zero.{0} (partial_order.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_1177 (h0 : list (has_pos_part (ring pos))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_1178 (h0 : add_group (add_comm_monoid (has_neg Type))) : is_add_cyclic (add_comm_monoid (has_neg Type)) := sorry --non-trivial
lemma new_lemma_1179 (h0 : group (has_neg (has_neg (has_neg (has_neg pos))))) : group.fg (has_neg (has_neg (has_neg (has_neg pos)))) := sorry --non-trivial
lemma new_lemma_1180 (h0 : topological_space (finset (has_add linarith.comp))) : sequential_space (finset (has_add linarith.comp)) := sorry --non-trivial
lemma new_lemma_1181 (h0 : functor.add_const (topological_space (canonically_ordered_comm_semiring Type)) Type) : @loc_path_connected_space.{1} (canonically_ordered_comm_semiring.{1} Type) (@functor.add_const.run.{1 1} (topological_space.{1} (canonically_ordered_comm_semiring.{1} Type)) Type h0)  := sorry --non-trivial
lemma new_lemma_1182 (h1 : not (has_mem.mem (with_bot string_imp) has_emptyc.emptyc -> false)) : @is_domain.{0} (with_bot.{0} string_imp) (@finset.pi.empty.{1 0} Type ring.{0} (with_bot.{0} string_imp) (@classical.by_contradiction'.{0} (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (with_bot.{0} string_imp) (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))) h1))  := sorry --non-trivial
lemma new_lemma_1183 (h0 : functor.add_const (function.extfun Type topological_space) (has_pos_part pos)) : @irreducible_space.{0} (has_to_string.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) (has_pos_part.{0} pos) h0) (has_to_string.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_1184 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @regular_space.{0} (sub_neg_monoid.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (sub_neg_monoid.{0} name))  := sorry --non-trivial
lemma new_lemma_1185 (h0 : group (has_zero (finset (finset (has_neg Type))))) : group.fg (has_zero (finset (finset (has_neg Type)))) := sorry --non-trivial
lemma new_lemma_1186 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : finset.nonempty (function.extfun_app (function.extfun_app h0 finset) (sub_neg_monoid real)) := sorry --non-trivial
lemma new_lemma_1187 (h1 : function.extfun Type topological_space) : @t0_space.{0} (normed_group.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type topological_space.{0} h1 (normed_group.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_1188 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @has_exists_mul_of_le.{1} (has_pos_part.{1} Type) (@function.extfun_app.{3 2} (Type 1) ordered_comm_monoid.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 ordered_comm_monoid.{1}) (has_pos_part.{1} Type))  := sorry --non-trivial
lemma new_lemma_1189 (h0 : ordered_comm_monoid (boolean_algebra.core (finset (finset Type)))) : has_exists_mul_of_le (boolean_algebra.core (finset (finset Type))) := sorry --non-trivial
lemma new_lemma_1190 (h0 : function.extfun Type topological_space) : @preirreducible_space.{0} (ring.{0} (option.{0} congr_arg_kind)) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (ring.{0} (option.{0} congr_arg_kind)))  := sorry --non-trivial
lemma new_lemma_1191 (h0 : ring (has_compl reducibility_hints)) : strong_rank_condition (has_compl reducibility_hints) := sorry --non-trivial
lemma new_lemma_1192 (h1 : complete_lattice (has_nnnorm enat)) : is_compactly_generated (has_nnnorm enat) := sorry --non-trivial
lemma new_lemma_1193 (h0 : topological_space (with_zero linarith.ineq)) : t0_space (with_zero linarith.ineq) := sorry --non-trivial
lemma new_lemma_1194 (h0 : function.extfun Type filter) : countable_Inter_filter (function.extfun_app h0 (comm_group name)) := sorry --non-trivial
lemma new_lemma_1195 (h0 : cancel_comm_monoid_with_zero (free_add_monoid num)) : unique_factorization_monoid (free_add_monoid num) := sorry --non-trivial
lemma new_lemma_1196 (h0 : ring (comm_monoid empty)) : is_domain (comm_monoid empty) := sorry --non-trivial
lemma new_lemma_1197 (h1 : preorder (mul_one_class (mul_one_class char))) (h2 : set (mul_one_class (mul_one_class char))) : set.is_pwo h2 := sorry --non-trivial
lemma new_lemma_1198 (h0 : group (has_add (has_add (has_add (has_add pos))))) : is_simple_group (has_add (has_add (has_add (has_add pos)))) := sorry --non-trivial
lemma new_lemma_1199 (h0 : functor.add_const (topological_space (comm_group name)) linarith.comp) : @totally_separated_space.{0} (comm_group.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (comm_group.{0} name)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_1200 (h0 : topological_space (has_neg (has_neg (finset (has_add pos))))) : regular_space (has_neg (has_neg (finset (has_add pos)))) := sorry --non-trivial
lemma new_lemma_1201 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @regular_space.{0} (ordered_comm_ring.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (ordered_comm_ring.{0} name))  := sorry --non-trivial
lemma new_lemma_1202 (h0 : functor.add_const (ring (boolean_algebra name)) (has_neg_part (comm_group name))) : @strong_rank_condition.{0} (boolean_algebra.{0} name) (@functor.add_const.run.{0 0} (ring.{0} (boolean_algebra.{0} name)) (has_neg_part.{0} (comm_group.{0} name)) h0)  := sorry --non-trivial
lemma new_lemma_1203 (h0 : functor.comp topological_space boolean_algebra environment.implicit_infer_kind) : @totally_disconnected_space.{0} (boolean_algebra.{0} environment.implicit_infer_kind) (@functor.comp.run.{0 0 0} topological_space.{0} boolean_algebra.{0} environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_1204 (h0 : functor.add_const (topological_space (monoid unsigned)) empty) : @loc_path_connected_space.{0} (monoid.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (monoid.{0} unsigned)) empty h0)  := sorry --non-trivial
lemma new_lemma_1205 (h0 : ordered_add_comm_monoid (add_comm_monoid name)) : archimedean (add_comm_monoid name) := sorry --non-trivial
lemma new_lemma_1206 (h0 : functor.add_const (group (has_to_string pos)) linarith.comp) : @group.fg.{0} (has_to_string.{0} pos) (@functor.add_const.run.{0 0} (group.{0} (has_to_string.{0} pos)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_1207 (h0 : topological_space (add_cancel_monoid (option (option (option (normed_comm_ring unsigned)))))) : normal_space (add_cancel_monoid (option (option (option (normed_comm_ring unsigned))))) := sorry --non-trivial
lemma new_lemma_1208 (h0 : functor.add_const (ordered_add_comm_monoid (has_zero linarith.comp)) (ring (ring (ring Type)))) : @archimedean.{0} (has_zero.{0} linarith.comp) (@functor.add_const.run.{0 1} (ordered_add_comm_monoid.{0} (has_zero.{0} linarith.comp)) (ring.{1} (ring.{1} (ring.{1} Type))) h0)  := sorry --non-trivial
lemma new_lemma_1209 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @rank_condition.{0} (complete_semilattice_Sup.{0} fun_info) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (complete_semilattice_Sup.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_1210 (h0 : complete_lattice (uniform_space (random_gen reducibility_hints))) : complete_lattice.is_Sup_finite_compact (uniform_space (random_gen reducibility_hints)) := sorry --non-trivial
lemma new_lemma_1211 (h0 : function.extfun Type topological_space) : @path_connected_space.{0} (complete_linear_order.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (complete_linear_order.{0} empty))  := sorry --non-trivial
lemma new_lemma_1212 (h0 : functor.add_const (function.extfun (Type 1) topological_space) Type) : @preirreducible_space.{1} (comm_group.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@functor.add_const.run.{2 1} (function.extfun.{3 2} (Type 1) topological_space.{1}) Type h0) (comm_group.{1} Type))  := sorry --non-trivial
lemma new_lemma_1213 (h0 : ordered_comm_monoid (has_zero (has_neg linarith.comp))) : has_exists_mul_of_le (has_zero (has_neg linarith.comp)) := sorry --non-trivial
lemma new_lemma_1214 (h0 : fin has_zero.zero) : @rank_condition.{0} (canonically_linear_ordered_monoid.{0} real) (@matrix.vec_empty.{0} (ring.{0} (canonically_linear_ordered_monoid.{0} real)) h0)  := sorry --non-trivial
lemma new_lemma_1215 (h0 : functor.add_const (function.extfun (Type 1) topological_space) environment.implicit_infer_kind) : @preconnected_space.{1} (has_add.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) topological_space.{1}) environment.implicit_infer_kind h0) (has_add.{1} Type))  := sorry --non-trivial
lemma new_lemma_1216 (h0 : filter (mul_zero_class Type)) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_1217 (h0 : semiring (comm_group linarith.comp)) : is_noetherian_ring (comm_group linarith.comp) := sorry --non-trivial
lemma new_lemma_1218 (h0 : function.extfun ((finset Type -> Prop) -> Prop) (function.extfun (finset Type -> Prop))) : @complete_lattice.is_Sup_finite_compact.{0} (random_gen.{0} linarith.ineq) (@finset.pi.empty.{1 0} Type complete_lattice.{0} (random_gen.{0} linarith.ineq) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (random_gen.{0} linarith.ineq)) (@function.extfun_app.{2 0} (finset.{1} Type → Prop) (function.extfun.{2 0} (finset.{1} Type)) (@function.extfun_app.{2 0} ((finset.{1} Type → Prop) → Prop) (function.extfun.{2 0} (finset.{1} Type → Prop)) h0 (function.extfun.{2 0} (finset.{1} Type))) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (random_gen.{0} linarith.ineq))) (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_1219 (h0 : uniform_space (has_one (semiring empty))) : separated_space (has_one (semiring empty)) := sorry --non-trivial
lemma new_lemma_1220 (h0 : function.extfun Type (functor.add_const (ring ennreal))) : @rank_condition.{0} ennreal (@functor.add_const.run.{0 0} (ring.{0} ennreal) num (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (ring.{0} ennreal)) h0 num))  := sorry --non-trivial
lemma new_lemma_1221 (h0 : option (add_cancel_monoid pos) -> option (add_cancel_monoid pos) -> Prop) : is_refl (option (add_cancel_monoid pos)) h0 := sorry --non-trivial
lemma new_lemma_1222 (h4 : set (mul_one_class (mul_one_class std_gen) -> char)) : set.separates_points h4 := sorry --non-trivial
lemma new_lemma_1223 (h0 : group (simple_graph unsigned)) : normalizer_condition (simple_graph unsigned) := sorry --non-trivial
lemma new_lemma_1224 (h0 : functor.add_const (function.extfun Type finset) Type) : finset.nonempty (function.extfun_app (functor.add_const.run h0) (complete_distrib_lattice pos)) := sorry --non-trivial
lemma new_lemma_1225 (h0 : topological_space (add_cancel_monoid congr_arg_kind)) : locally_compact_space (add_cancel_monoid congr_arg_kind) := sorry --non-trivial
lemma new_lemma_1226 (h0 : not (has_mem.mem group has_emptyc.emptyc -> false)) : @is_cyclic.{0} string_imp (@function.extfun_app.{2 1} Type group.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) group.{0} (@classical.by_contradiction'.{0} (@has_mem.mem.{1 1} (Type → Type) (finset.{1} (Type → Type)) (@finset.has_mem.{1} (Type → Type)) group.{0} (@has_emptyc.emptyc.{1} (finset.{1} (Type → Type)) (@finset.has_emptyc.{1} (Type → Type)))) h0)) string_imp)  := sorry --non-trivial
lemma new_lemma_1227 (h0 : ring (mul_one_class enat)) : rank_condition (mul_one_class enat) := sorry --non-trivial
lemma new_lemma_1228 (h1 : group (comm_ring (normed_field string_imp))) : is_cyclic (comm_ring (normed_field string_imp)) := sorry --non-trivial
lemma new_lemma_1229 (h0 : uniform_space (add_cancel_monoid num)) : separated_space (add_cancel_monoid num) := sorry --non-trivial
lemma new_lemma_1230 (h0 : functor.add_const (uniform_space (comm_group Type)) pos) : @separated_space.{1} (comm_group.{1} Type) (@functor.add_const.run.{1 0} (uniform_space.{1} (comm_group.{1} Type)) pos h0)  := sorry --non-trivial
lemma new_lemma_1231 (h0 : not (uniform_space (has_compl char) -> false)) : @complete_space.{0} (has_compl.{0} char) (@classical.by_contradiction'.{1} (uniform_space.{0} (has_compl.{0} char)) h0)  := sorry --non-trivial
lemma new_lemma_1232 (h0 : functor.add_const (function.extfun Type monoid) (has_neg Type)) : @monoid.fg.{0} (semigroup.{0} pos) (@function.extfun_app.{2 1} Type monoid.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type monoid.{0}) (has_neg.{1} Type) h0) (semigroup.{0} pos))  := sorry --non-trivial
lemma new_lemma_1233 (h0 : ring (has_neg (comm_group unsigned))) : strong_rank_condition (has_neg (comm_group unsigned)) := sorry --non-trivial
lemma new_lemma_1234 (h0 : complete_lattice (has_Inf num)) : is_atomistic (has_Inf num) := sorry --non-trivial
lemma new_lemma_1235 (h0 : function.extfun Type finset) : finset.nonempty (function.extfun_app h0 (add_cancel_monoid name)) := sorry --non-trivial
lemma new_lemma_1236 (h0 : functor.add_const (uniform_space (boolean_algebra.core Type)) name) : @separated_space.{1} (boolean_algebra.core.{1} Type) (@functor.add_const.run.{1 0} (uniform_space.{1} (boolean_algebra.core.{1} Type)) name h0)  := sorry --non-trivial
lemma new_lemma_1237 (h0 : function.extfun nat fin) : @add_monoid.fg.{0} (comm_semigroup.{0} linarith.comp) (@matrix.vec_empty.{0} (add_monoid.{0} (comm_semigroup.{0} linarith.comp)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_1238 (h0 : topological_space (has_neg_part (has_neg Type))) : totally_separated_space (has_neg_part (has_neg Type)) := sorry --non-trivial
lemma new_lemma_1239 (h0 : not (monoid (has_top fun_info) -> false)) : @monoid.fg.{0} (has_top.{0} fun_info) (@classical.by_contradiction'.{1} (monoid.{0} (has_top.{0} fun_info)) h0)  := sorry --non-trivial
lemma new_lemma_1240 (h0 : ring (add_cancel_comm_monoid reducibility_hints)) : strong_rank_condition (add_cancel_comm_monoid reducibility_hints) := sorry --non-trivial
lemma new_lemma_1241 (h0 : function.extfun Type ring) : @strong_rank_condition.{0} (has_dist.{0} empty) (@function.extfun_app.{2 1} Type ring.{0} h0 (has_dist.{0} empty))  := sorry --non-trivial
lemma new_lemma_1242 (h0 : ring (comm_ring (random_gen (random_gen (has_nnnorm to_additive.value_type))))) : rank_condition (comm_ring (random_gen (random_gen (has_nnnorm to_additive.value_type)))) := sorry --non-trivial
lemma new_lemma_1243 (h0 : set (has_le ereal)) : set.finite h0 := sorry --non-trivial
lemma new_lemma_1244 (h0 : complete_lattice (random_gen (random_gen (random_gen (random_gen linarith.ineq))))) : is_atomistic (random_gen (random_gen (random_gen (random_gen linarith.ineq)))) := sorry --non-trivial
lemma new_lemma_1245 (h0 : topological_space (comm_group (has_to_string unsigned))) : topological_space.separable_space (comm_group (has_to_string unsigned)) := sorry --non-trivial
lemma new_lemma_1246 (h0 : has_mem.mem group has_emptyc.emptyc) : @is_cyclic.{0} (has_top.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type group.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) group.{0} h0) (has_top.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_1247 (h0 : multiset (filter (dlist linarith.ineq))) : filter.ne_bot (multiset.inf h0) := sorry --non-trivial
lemma new_lemma_1248 (h0 : filter (ordered_ring congr_arg_kind)) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_1249 (h0 : function.extfun Type topological_space) : @path_connected_space.{0} (linear_order.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (linear_order.{0} empty))  := sorry --non-trivial
lemma new_lemma_1250 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : finset.nonempty (function.extfun_app (function.extfun_app h0 finset) (pseudo_metric_space empty)) := sorry --non-trivial
lemma new_lemma_1251 (h0 : list (ring (semigroup environment.implicit_infer_kind))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_1252 (h0 : functor.add_const (function.extfun Type topological_space) pos) : @totally_separated_space.{0} (ordered_comm_ring.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) pos h0) (ordered_comm_ring.{0} pos))  := sorry --non-trivial
lemma new_lemma_1253 (h0 : not (topological_space (normed_group unsigned) -> false)) : @totally_disconnected_space.{0} (normed_group.{0} unsigned) (@classical.by_contradiction'.{1} (topological_space.{0} (normed_group.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_1254 (h0 : topological_space (linear_ordered_cancel_comm_monoid unsigned)) : preirreducible_space (linear_ordered_cancel_comm_monoid unsigned) := sorry --non-trivial
lemma new_lemma_1255 (h0 : fin has_zero.zero) : @preirreducible_space.{0} (ordered_comm_monoid.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} (@matrix.vec_empty.{1} (function.extfun.{2 1} Type topological_space.{0}) (@matrix.vec_empty.{0} (fin (@has_zero.zero.{0} nat nat.has_zero)) h0)) (ordered_comm_monoid.{0} name))  := sorry --non-trivial
lemma new_lemma_1256 (h0 : topological_space (encodable (random_gen linarith.ineq))) : irreducible_space (encodable (random_gen linarith.ineq)) := sorry --non-trivial
lemma new_lemma_1257 (h0 : topological_space (has_nndist (option empty))) : t0_space (has_nndist (option empty)) := sorry --non-trivial
lemma new_lemma_1258 (h0 : functor.add_const (filter (has_add ennreal)) name) : countable_Inter_filter (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_1259 (h0 : topological_space (has_star (has_norm unsigned))) : irreducible_space (has_star (has_norm unsigned)) := sorry --non-trivial
lemma new_lemma_1260 (h0 : group (canonically_linear_ordered_monoid (has_add Type))) : is_simple_group (canonically_linear_ordered_monoid (has_add Type)) := sorry --non-trivial
lemma new_lemma_1261 (h0 : function.extfun (finset Type) (has_mem.mem (linear_ordered_semiring empty))) : @path_connected_space.{0} (linear_ordered_semiring.{0} empty) (@finset.pi.empty.{1 0} Type topological_space.{0} (linear_ordered_semiring.{0} empty) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (linear_ordered_semiring.{0} empty)) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_1262 (h0 : function.extfun Type topological_space) : @preirreducible_space.{0} (has_to_string.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_to_string.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_1263 (h0 : function.extfun Type topological_space) : @discrete_topology.{0} (pseudo_metric_space.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (pseudo_metric_space.{0} empty))  := sorry --non-trivial
lemma new_lemma_1264 (h0 : function.extfun Type group) : @is_simple_group.{0} (has_nndist.{0} num) (@function.extfun_app.{2 1} Type group.{0} h0 (has_nndist.{0} num))  := sorry --non-trivial
lemma new_lemma_1265 (h0 : functor.add_const (finset (free_add_monoid empty)) num) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_1266 (h0 : uniform_space (topological_space (random_gen to_additive.value_type))) : complete_space (topological_space (random_gen to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_1267 (h0 : complete_lattice (boolean_algebra (has_neg pos))) : is_compactly_generated (boolean_algebra (has_neg pos)) := sorry --non-trivial
lemma new_lemma_1268 (h0 : functor.add_const (topological_space (ring linarith.comp)) pos) : @preconnected_space.{0} (ring.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (ring.{0} linarith.comp)) pos h0)  := sorry --non-trivial
lemma new_lemma_1269 (h0 : not (group (has_top fun_info) -> false)) : @group.fg.{0} (has_top.{0} fun_info) (@classical.by_contradiction'.{1} (group.{0} (has_top.{0} fun_info)) h0)  := sorry --non-trivial
lemma new_lemma_1270 (h0 : topological_space (mul_zero_class (semiring unsigned))) : t0_space (mul_zero_class (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_1271 (h0 : not (function.extfun Type uniform_space -> false)) : @separated_space.{0} (@id.{2} Type num) (@function.extfun_app.{2 1} Type uniform_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type uniform_space.{0}) h0) (@id.{2} Type num))  := sorry --non-trivial
lemma new_lemma_1272 (h0 : list (linear_order unsigned)) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_1273 (h0 : list (has_to_string (mul_zero_class name))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_1274 (h0 : finset (complete_distrib_lattice (semiring empty))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_1275 (h0 : topological_space (fintype (has_nnnorm (has_nnnorm (has_nnnorm (has_nnnorm linarith.ineq)))))) : t0_space (fintype (has_nnnorm (has_nnnorm (has_nnnorm (has_nnnorm linarith.ineq))))) := sorry --non-trivial
lemma new_lemma_1276 (h1 : not (function.extfun Type topological_space -> false)) : @path_connected_space.{0} (semiring.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h1) (semiring.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_1277 (h0 : functor.add_const (topological_space ennreal) congr_arg_kind) : irreducible_space ennreal := sorry --non-trivial
lemma new_lemma_1278 (h0 : ring (semigroup (has_add environment.implicit_infer_kind))) : is_principal_ideal_ring (semigroup (has_add environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_1279 (h1 : function.extfun (Type -> Type) (function.extfun Type)) : @totally_disconnected_space.{0} (has_top.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h1 topological_space.{0}) (has_top.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_1280 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @regular_space.{0} (has_neg_part.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_neg_part.{0} pos))  := sorry --non-trivial
lemma new_lemma_1281 (h5 : has_coe (normed_field (normed_field (normed_field char))) Prop) (h6 : normed_field (normed_field (normed_field char))) : @coe_b.{1 1} (normed_field.{0} (normed_field.{0} (normed_field.{0} char))) Prop h5 h6  := sorry --non-trivial
lemma new_lemma_1282 (h0 : topological_space (normed_comm_ring environment.implicit_infer_kind)) : t1_space (normed_comm_ring environment.implicit_infer_kind) := sorry --non-trivial
lemma new_lemma_1283 (h0 : filter (bin_tree num)) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_1284 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : list.nodup (function.extfun_app (function.extfun_app h0 list) (with_bot fun_info)) := sorry --non-trivial
lemma new_lemma_1285 (h0 : functor.add_const (topological_space (has_pos_part pos)) Type) : @t1_space.{0} (has_pos_part.{0} pos) (@functor.add_const.run.{0 1} (topological_space.{0} (has_pos_part.{0} pos)) Type h0)  := sorry --non-trivial
lemma new_lemma_1286 (h0 : functor.add_const (monoid (is_R_or_C unsigned)) empty) : @monoid.fg.{0} (is_R_or_C.{0} unsigned) (@functor.add_const.run.{0 0} (monoid.{0} (is_R_or_C.{0} unsigned)) empty h0)  := sorry --non-trivial
lemma new_lemma_1287 (h0 : topological_space (mul_zero_class (semiring empty))) : preirreducible_space (mul_zero_class (semiring empty)) := sorry --non-trivial
lemma new_lemma_1288 (h0 : ring (ordered_cancel_add_comm_monoid num)) : is_principal_ideal_ring (ordered_cancel_add_comm_monoid num) := sorry --non-trivial
lemma new_lemma_1289 (h0 : function.extfun Type topological_space) : @t0_space.{0} (has_bot.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_bot.{0} name))  := sorry --non-trivial
lemma new_lemma_1290 (h0 : filter (has_neg_part (semigroup name))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_1291 (h0 : function.extfun Type (functor.add_const Prop)) : functor.add_const.run (function.extfun_app h0 (complete_distrib_lattice ennreal)) := sorry --non-trivial
lemma new_lemma_1292 (h1 : function.extfun Type add_group) : @is_add_cyclic.{0} string_imp (@function.extfun_app.{2 1} Type add_group.{0} h1 string_imp)  := sorry --non-trivial
lemma new_lemma_1293 (h0 : topological_space (linear_ordered_semiring (random_gen (has_norm linarith.comp)))) : normal_space (linear_ordered_semiring (random_gen (has_norm linarith.comp))) := sorry --non-trivial
lemma new_lemma_1294 (h0 : function.extfun Type ring) : @strong_rank_condition.{0} (monoid.{0} num) (@function.extfun_app.{2 1} Type ring.{0} h0 (monoid.{0} num))  := sorry --non-trivial
lemma new_lemma_1295 (h0 : functor.add_const (topological_space (partial_order congr_arg_kind)) num) : @preirreducible_space.{0} (partial_order.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (partial_order.{0} congr_arg_kind)) num h0)  := sorry --non-trivial
lemma new_lemma_1296 (h0 : group (option congr_arg_kind)) : group.fg (option congr_arg_kind) := sorry --non-trivial
lemma new_lemma_1297 (h0 : not (function.extfun Type topological_space -> false)) : @discrete_topology.{0} congr_arg_kind (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) congr_arg_kind)  := sorry --non-trivial
lemma new_lemma_1298 (h0 : fin has_zero.zero) : @is_add_cyclic.{1} (has_add.{1} Type) (@matrix.vec_empty.{1} (add_group.{1} (has_add.{1} Type)) (@matrix.vec_empty.{0} (fin (@has_zero.zero.{0} nat nat.has_zero)) h0))  := sorry --non-trivial
lemma new_lemma_1299 (h0 : functor.add_const (complete_lattice (has_mul environment.implicit_infer_kind)) (finset linarith.comp)) : @is_compactly_generated.{0} (has_mul.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (complete_lattice.{0} (has_mul.{0} environment.implicit_infer_kind)) (finset.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_1300 (h1 : topological_space (has_le string.iterator_imp)) (h2 : add_group (has_le string.iterator_imp)) : topological_add_group (has_le string.iterator_imp) := sorry --non-trivial
lemma new_lemma_1301 (h0 : function.extfun Type cancel_comm_monoid_with_zero) : @unique_factorization_monoid.{0} (ring.{0} num) (@function.extfun_app.{2 1} Type cancel_comm_monoid_with_zero.{0} h0 (ring.{0} num))  := sorry --non-trivial
lemma new_lemma_1302 (h0 : functor.add_const (add_monoid (left_cancel_monoid empty)) (semiring (semiring (semiring empty)))) : @add_monoid.fg.{0} (left_cancel_monoid.{0} empty) (@functor.add_const.run.{0 0} (add_monoid.{0} (left_cancel_monoid.{0} empty)) (semiring.{0} (semiring.{0} (semiring.{0} empty))) h0)  := sorry --non-trivial
lemma new_lemma_1303 (h0 : uniform_space (has_neg_part ennreal)) : separated_space (has_neg_part ennreal) := sorry --non-trivial
lemma new_lemma_1304 (h0 : monoid (normed_comm_ring (option ennreal))) : monoid.fg (normed_comm_ring (option ennreal)) := sorry --non-trivial
lemma new_lemma_1305 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @preirreducible_space.{0} (has_zero.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_zero.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_1306 (h0 : topological_space (cancel_monoid num)) : preirreducible_space (cancel_monoid num) := sorry --non-trivial
lemma new_lemma_1307 (h0 : function.extfun (finset (Type -> Type)) (has_mem.mem group)) : @is_cyclic.{0} string_imp (@function.extfun_app.{2 1} Type group.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) group.{0} (@function.extfun_app.{2 0} (finset.{1} (Type → Type)) (@has_mem.mem.{1 1} (Type → Type) (finset.{1} (Type → Type)) (@finset.has_mem.{1} (Type → Type)) group.{0}) h0 (@has_emptyc.emptyc.{1} (finset.{1} (Type → Type)) (@finset.has_emptyc.{1} (Type → Type))))) string_imp)  := sorry --non-trivial
lemma new_lemma_1308 (h0 : add_group (complete_semilattice_Sup (has_norm (has_norm linarith.comp_source)))) : is_add_cyclic (complete_semilattice_Sup (has_norm (has_norm linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_1309 (h0 : uniform_space (has_lt (uniform_space string.iterator_imp))) : complete_space (has_lt (uniform_space string.iterator_imp)) := sorry --non-trivial
lemma new_lemma_1310 (h1 : function.extfun Type filter) : filter.ne_bot (function.extfun_app h1 (with_one string_imp)) := sorry --non-trivial
lemma new_lemma_1311 (h0 : functor.add_const (topological_space pos) (finset Type)) : @t0_space.{0} pos (@functor.add_const.run.{0 1} (topological_space.{0} pos) (finset.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_1312 (h0 : topological_space (normed_comm_ring (option (option (option (option (option empty))))))) : locally_compact_space (normed_comm_ring (option (option (option (option (option empty)))))) := sorry --non-trivial
lemma new_lemma_1313 (h0 : cancel_comm_monoid_with_zero (ordered_comm_group congr_arg_kind)) : unique_factorization_monoid (ordered_comm_group congr_arg_kind) := sorry --non-trivial
lemma new_lemma_1314 (h0 : add_comm_semigroup fun_info -> add_comm_semigroup fun_info -> Prop) (h1 : filter (add_comm_semigroup fun_info)) : filter.is_bounded h0 h1 := sorry --non-trivial
lemma new_lemma_1315 (h0 : function.extfun (finset Type) (has_mem.mem (semiring fun_info))) : @discrete_topology.{0} (semiring.{0} fun_info) (@finset.pi.empty.{1 0} Type topological_space.{0} (semiring.{0} fun_info) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (semiring.{0} fun_info)) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_1316 (h0 : group (comm_group (semigroup (has_add name)))) : group.fg (comm_group (semigroup (has_add name))) := sorry --non-trivial
lemma new_lemma_1317 (h0 : function.extfun Type topological_space) : @path_connected_space.{0} (mul_zero_class.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (mul_zero_class.{0} pos))  := sorry --non-trivial
lemma new_lemma_1318 (h0 : topological_space (random_gen (random_gen empty))) : totally_separated_space (random_gen (random_gen empty)) := sorry --non-trivial
lemma new_lemma_1319 (h0 : filter (boolean_algebra.core (has_add Type))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_1320 (h0 : filter (has_neg (has_add linarith.comp))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_1321 (h0 : functor.add_const (group (has_neg_part pos)) pos) : @group.fg.{0} (has_neg_part.{0} pos) (@functor.add_const.run.{0 0} (group.{0} (has_neg_part.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_1322 (h2 : Prop) : set.separates_points (id (fun (h1 : char -> char), h2)) := sorry --non-trivial
lemma new_lemma_1323 (h0 : function.extfun Type topological_space) : @discrete_topology.{0} (cancel_monoid.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (cancel_monoid.{0} empty))  := sorry --non-trivial
lemma new_lemma_1324 (h0 : topological_space (has_nndist environment.implicit_infer_kind)) : regular_space (has_nndist environment.implicit_infer_kind) := sorry --non-trivial
lemma new_lemma_1325 (h0 : ring (cancel_monoid (comm_group (comm_group (comm_group (comm_group name)))))) : rank_condition (cancel_monoid (comm_group (comm_group (comm_group (comm_group name))))) := sorry --non-trivial
lemma new_lemma_1326 (h0 : functor.add_const (finset (mul_zero_class num)) num) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_1327 (h0 : function.extfun (Type 1) group) : @normalizer_condition.{1} (boolean_algebra.core.{1} Type) (@function.extfun_app.{3 2} (Type 1) group.{1} h0 (boolean_algebra.core.{1} Type))  := sorry --non-trivial
lemma new_lemma_1328 (h1 : ring (has_add linarith.comp_source)) : strong_rank_condition (has_add linarith.comp_source) := sorry --non-trivial
lemma new_lemma_1329 (h0 : complete_lattice (has_add fun_info)) : is_compactly_generated (has_add fun_info) := sorry --non-trivial
lemma new_lemma_1330 (h0 : functor.add_const (add_monoid (boolean_algebra pos)) linarith.comp) : @add_monoid.fg.{0} (boolean_algebra.{0} pos) (@functor.add_const.run.{0 0} (add_monoid.{0} (boolean_algebra.{0} pos)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_1331 (h0 : topological_space (linear_ordered_comm_group empty)) : discrete_topology (linear_ordered_comm_group empty) := sorry --non-trivial
lemma new_lemma_1332 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @rank_condition.{1} (simple_graph.{1} Type) (@function.extfun_app.{3 2} (Type 1) ring.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 ring.{1}) (simple_graph.{1} Type))  := sorry --non-trivial
lemma new_lemma_1333 (h0 : ring (simple_graph (mul_one_class enat))) : is_domain (simple_graph (mul_one_class enat)) := sorry --non-trivial
lemma new_lemma_1334 (h0 : topological_space (has_one (semiring empty))) : topological_space.separable_space (has_one (semiring empty)) := sorry --non-trivial
lemma new_lemma_1335 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @rank_condition.{0} (ordered_cancel_add_comm_monoid.{0} num) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (ordered_cancel_add_comm_monoid.{0} num))  := sorry --non-trivial
lemma new_lemma_1336 (h0 : group (ordered_comm_monoid linarith.comp)) : is_simple_group (ordered_comm_monoid linarith.comp) := sorry --non-trivial
lemma new_lemma_1337 (h0 : not (uniform_space (has_top unsigned) -> false)) : @separated_space.{0} (has_top.{0} unsigned) (@classical.by_contradiction'.{1} (uniform_space.{0} (has_top.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_1338 (h0 : complete_lattice (add_cancel_comm_monoid (random_gen reducibility_hints))) : complete_lattice.is_Sup_finite_compact (add_cancel_comm_monoid (random_gen reducibility_hints)) := sorry --non-trivial
lemma new_lemma_1339 (h0 : topological_space (linear_ordered_comm_group (option empty))) : preirreducible_space (linear_ordered_comm_group (option empty)) := sorry --non-trivial
lemma new_lemma_1340 (h0 : group (has_to_string (has_add (has_add Type)))) : group.fg (has_to_string (has_add (has_add Type))) := sorry --non-trivial
lemma new_lemma_1341 (h0 : functor.add_const (topological_space (boolean_algebra Type)) linarith.comp) : @t1_space.{1} (boolean_algebra.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (boolean_algebra.{1} Type)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_1342 (h0 : functor.add_const (list (has_neg unsigned)) unsigned) : list.nodup (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_1343 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @locally_compact_space.{0} (add_cancel_monoid.{0} ennreal) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (add_cancel_monoid.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_1344 (h0 : add_group (denumerable (has_nnnorm linarith.ineq))) : is_add_cyclic (denumerable (has_nnnorm linarith.ineq)) := sorry --non-trivial
lemma new_lemma_1345 (h0 : function.extfun Type group) : @group.fg.{0} (topological_space.{0} char) (@function.extfun_app.{2 1} Type group.{0} h0 (topological_space.{0} char))  := sorry --non-trivial
lemma new_lemma_1346 (h0 : topological_space (has_div (mul_one_class (mul_one_class (mul_one_class linarith.comp_source))))) : path_connected_space (has_div (mul_one_class (mul_one_class (mul_one_class linarith.comp_source)))) := sorry --non-trivial
lemma new_lemma_1347 (h0 : not (function.extfun Type complete_lattice -> false)) : @is_atomistic.{0} (add_group.{0} unsigned) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type complete_lattice.{0}) h0) (add_group.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_1348 (h0 : not (ring (semi_normed_comm_ring fun_info) -> false)) : @strong_rank_condition.{0} (semi_normed_comm_ring.{0} fun_info) (@classical.by_contradiction'.{1} (ring.{0} (semi_normed_comm_ring.{0} fun_info)) h0)  := sorry --non-trivial
lemma new_lemma_1349 (h0 : not (group (measurable_space.dynkin_system empty) -> false)) : @normalizer_condition.{0} (measurable_space.dynkin_system.{0} empty) (@classical.by_contradiction'.{1} (group.{0} (measurable_space.dynkin_system.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_1350 (h0 : multiset (random_gen reducibility_hints)) (h1 : not (multiset (random_gen reducibility_hints) -> false)) : multiset.disjoint h0 (classical.by_contradiction' h1) := sorry --non-trivial
lemma new_lemma_1351 (h0 : linarith.comp_source -> linarith.comp_source -> Prop) : is_directed linarith.comp_source h0 := sorry --non-trivial
lemma new_lemma_1352 (h0 : function.extfun Type group) : @normalizer_condition.{0} (denumerable.{0} linarith.ineq) (@function.extfun_app.{2 1} Type group.{0} h0 (denumerable.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_1353 (h0 : functor.add_const (filter (ordered_comm_ring Type)) Type) : countable_Inter_filter (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_1354 (h0 : functor.add_const (topological_space (complete_distrib_lattice pos)) pos) : @loc_path_connected_space.{0} (complete_distrib_lattice.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (complete_distrib_lattice.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_1355 (h0 : topological_space (add_comm_monoid (comm_group name))) : preconnected_space (add_comm_monoid (comm_group name)) := sorry --non-trivial
lemma new_lemma_1356 (h1 : topological_space (dlist char)) : path_connected_space (dlist char) := sorry --non-trivial
lemma new_lemma_1357 (h0 : not (topological_space (linear_ordered_add_comm_group linarith.ineq) -> false)) : @totally_separated_space.{0} (linear_ordered_add_comm_group.{0} linarith.ineq) (@classical.by_contradiction'.{1} (topological_space.{0} (linear_ordered_add_comm_group.{0} linarith.ineq)) h0)  := sorry --non-trivial
lemma new_lemma_1358 (h0 : functor.add_const (list (add_comm_monoid name)) linarith.comp) : list.nodup (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_1359 (h0 : functor.add_const (topological_space (has_neg_part ennreal)) pos) : @totally_separated_space.{0} (has_neg_part.{0} ennreal) (@functor.add_const.run.{0 0} (topological_space.{0} (has_neg_part.{0} ennreal)) pos h0)  := sorry --non-trivial
lemma new_lemma_1360 (h0 : functor.add_const (filter (ordered_cancel_add_comm_monoid pos)) pos) : filter.ne_bot (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_1361 (h0 : uniform_space (mul_zero_class congr_arg_kind)) : separated_space (mul_zero_class congr_arg_kind) := sorry --non-trivial
lemma new_lemma_1362 (h0 : functor.add_const (ring (has_nndist environment.implicit_infer_kind)) Type) : @is_domain.{0} (has_nndist.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 1} (ring.{0} (has_nndist.{0} environment.implicit_infer_kind)) Type h0)  := sorry --non-trivial
lemma new_lemma_1363 (h0 : add_group (has_neg (comm_group Type))) : is_add_cyclic (has_neg (comm_group Type)) := sorry --non-trivial
lemma new_lemma_1364 (h1 : topological_space (mul_one_class enat)) (h2 : preorder (mul_one_class enat)) : order_topology (mul_one_class enat) := sorry --non-trivial
lemma new_lemma_1365 (h0 : functor.add_const (topological_space (boolean_algebra name)) name) : @locally_compact_space.{0} (boolean_algebra.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (boolean_algebra.{0} name)) name h0)  := sorry --non-trivial
lemma new_lemma_1366 (h0 : topological_space (denumerable (has_inv (has_inv (has_inv linarith.ineq))))) : totally_disconnected_space (denumerable (has_inv (has_inv (has_inv linarith.ineq)))) := sorry --non-trivial
lemma new_lemma_1367 (h1 : function.extfun Type topological_space) : @irreducible_space.{0} (has_norm.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} h1 (has_norm.{0} num))  := sorry --non-trivial
lemma new_lemma_1368 (h0 : filter (normed_comm_ring (has_pos_part (finset pos)))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_1369 (h0 : group (canonically_ordered_comm_semiring (finset name))) : group.fg (canonically_ordered_comm_semiring (finset name)) := sorry --non-trivial
lemma new_lemma_1370 (h0 : list (canonically_ordered_add_monoid (canonically_ordered_add_monoid unsigned))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_1371 (h0 : group (cancel_monoid (has_add (has_add linarith.comp)))) : is_simple_group (cancel_monoid (has_add (has_add linarith.comp))) := sorry --non-trivial
lemma new_lemma_1372 (h0 : group (with_bot (random_gen (has_inv (has_norm fun_info))))) : is_cyclic (with_bot (random_gen (has_inv (has_norm fun_info)))) := sorry --non-trivial
lemma new_lemma_1373 (h0 : topological_space (complete_distrib_lattice real)) : path_connected_space (complete_distrib_lattice real) := sorry --non-trivial
lemma new_lemma_1374 (h0 : function.extfun Type group) : @normalizer_condition.{0} (ordered_comm_group.{0} unsigned) (@function.extfun_app.{2 1} Type group.{0} h0 (ordered_comm_group.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_1375 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @complete_lattice.is_Sup_finite_compact.{0} (with_bot.{0} (random_gen.{0} to_additive.value_type)) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (with_bot.{0} (random_gen.{0} to_additive.value_type)))  := sorry --non-trivial
lemma new_lemma_1376 (h0 : functor.add_const (topological_space (simple_graph linarith.comp)) Type) : @t1_space.{0} (simple_graph.{0} linarith.comp) (@functor.add_const.run.{0 1} (topological_space.{0} (simple_graph.{0} linarith.comp)) Type h0)  := sorry --non-trivial
lemma new_lemma_1377 (h0 : functor.add_const (complete_lattice (canonically_ordered_comm_semiring ennreal)) unsigned) : @is_atomistic.{0} (canonically_ordered_comm_semiring.{0} ennreal) (@functor.add_const.run.{0 0} (complete_lattice.{0} (canonically_ordered_comm_semiring.{0} ennreal)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_1378 (h0 : functor.add_const (topological_space (boolean_algebra environment.implicit_infer_kind)) (comm_group Type)) : @regular_space.{0} (boolean_algebra.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 1} (topological_space.{0} (boolean_algebra.{0} environment.implicit_infer_kind)) (comm_group.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_1379 (h0 : semiring (semigroup (finset Type))) : is_noetherian_ring (semigroup (finset Type)) := sorry --non-trivial
lemma new_lemma_1380 (h0 : function.extfun Type topological_space) : @t1_space.{0} (normed_comm_ring.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (normed_comm_ring.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_1381 (h0 : topological_space (semigroup (has_add Type))) : preirreducible_space (semigroup (has_add Type)) := sorry --non-trivial
lemma new_lemma_1382 (h0 : ordered_comm_monoid (add_comm_monoid (has_neg pos))) : has_exists_mul_of_le (add_comm_monoid (has_neg pos)) := sorry --non-trivial
lemma new_lemma_1383 (h0 : function.extfun Type complete_lattice) : is_atomistic (filter empty) := sorry --non-trivial
lemma new_lemma_1384 (h0 : monoid (partial_order (partial_order (semiring (partial_order empty))))) : monoid.fg (partial_order (partial_order (semiring (partial_order empty)))) := sorry --non-trivial
lemma new_lemma_1385 (h0 : complete_lattice (simple_graph unsigned)) : complete_lattice.is_Sup_finite_compact (simple_graph unsigned) := sorry --non-trivial
lemma new_lemma_1386 (h0 : not (topological_space (has_one linarith.comp) -> false)) : @normal_space.{0} (has_one.{0} linarith.comp) (@classical.by_contradiction'.{1} (topological_space.{0} (has_one.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_1387 (h0 : finset (linear_ordered_field empty)) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_1388 (h0 : has_lt string) : no_max_order string := sorry --non-trivial
lemma new_lemma_1389 (h0 : topological_space (cancel_monoid (has_to_string pos))) : locally_compact_space (cancel_monoid (has_to_string pos)) := sorry --non-trivial
lemma new_lemma_1390 (h0 : functor.add_const (topological_space (ring unsigned)) Type) : @totally_disconnected_space.{0} (ring.{0} unsigned) (@functor.add_const.run.{0 1} (topological_space.{0} (ring.{0} unsigned)) Type h0)  := sorry --non-trivial
lemma new_lemma_1391 (h0 : function.extfun Type group) : @is_cyclic.{0} (linear_ordered_cancel_comm_monoid.{0} unsigned) (@function.extfun_app.{2 1} Type group.{0} h0 (linear_ordered_cancel_comm_monoid.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_1392 (h0 : ring (comm_group (has_neg_part pos))) : is_principal_ideal_ring (comm_group (has_neg_part pos)) := sorry --non-trivial
lemma new_lemma_1393 (h0 : topological_space (is_R_or_C num)) : t0_space (is_R_or_C num) := sorry --non-trivial
lemma new_lemma_1394 (h0 : semiring (add_group (semiring fun_info))) : is_noetherian_ring (add_group (semiring fun_info)) := sorry --non-trivial
lemma new_lemma_1395 (h0 : topological_space (has_union (semiring unsigned))) : irreducible_space (has_union (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_1396 (h0 : functor.add_const (topological_space (as_linear_order unsigned)) empty) : @totally_separated_space.{0} (as_linear_order.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (as_linear_order.{0} unsigned)) empty h0)  := sorry --non-trivial
lemma new_lemma_1397 (h0 : topological_space (simple_graph (ring Type))) : preirreducible_space (simple_graph (ring Type)) := sorry --non-trivial
lemma new_lemma_1398 (h0 : function.extfun Type filter) : filter.ne_bot (function.extfun_app h0 char) := sorry --non-trivial
lemma new_lemma_1399 (h0 : group (denumerable (has_top (has_ssubset linarith.comp_source)))) : group.fg (denumerable (has_top (has_ssubset linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_1400 (h0 : topological_space (ring (ring Type))) : irreducible_space (ring (ring Type)) := sorry --non-trivial
lemma new_lemma_1401 (h2 : complete_lattice (semi_normed_comm_ring to_additive.value_type)) : complete_lattice.is_Sup_finite_compact (semi_normed_comm_ring to_additive.value_type) := sorry --non-trivial
lemma new_lemma_1402 (h0 : uniform_space (has_neg (boolean_algebra environment.implicit_infer_kind))) : separated_space (has_neg (boolean_algebra environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_1403 (h0 : functor.comp add_group has_neg Type) : @is_add_cyclic.{1} (has_neg.{1} Type) (@functor.comp.run.{1 1 1} add_group.{1} has_neg.{1} Type h0)  := sorry --non-trivial
lemma new_lemma_1404 (h0 : functor.add_const (topological_space (normed_comm_ring Type)) name) : @totally_disconnected_space.{1} (normed_comm_ring.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (normed_comm_ring.{1} Type)) name h0)  := sorry --non-trivial
lemma new_lemma_1405 (h0 : uniform_space (uniform_space to_additive.value_type)) : complete_space (uniform_space to_additive.value_type) := sorry --non-trivial
lemma new_lemma_1406 (h0 : monoid (has_zero (boolean_algebra (boolean_algebra name)))) : monoid.fg (has_zero (boolean_algebra (boolean_algebra name))) := sorry --non-trivial
lemma new_lemma_1407 (h0 : functor.add_const (ring (has_nndist ennreal)) name) : @strong_rank_condition.{0} (has_nndist.{0} ennreal) (@functor.add_const.run.{0 0} (ring.{0} (has_nndist.{0} ennreal)) name h0)  := sorry --non-trivial
lemma new_lemma_1408 (h0 : topological_space (has_zero name)) : loc_path_connected_space (has_zero name) := sorry --non-trivial
lemma new_lemma_1409 (h0 : function.extfun Type topological_space) : @path_connected_space.{0} (with_one.{0} linarith.ineq) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (with_one.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_1410 (h0 : semiring (linear_ordered_cancel_comm_monoid empty)) : is_noetherian_ring (linear_ordered_cancel_comm_monoid empty) := sorry --non-trivial
lemma new_lemma_1411 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_domain.{0} (group_with_zero.{0} ennreal) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (group_with_zero.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_1412 (h0 : complete_lattice (add_comm_semigroup char)) : complete_lattice.is_Sup_finite_compact (add_comm_semigroup char) := sorry --non-trivial
lemma new_lemma_1413 (h0 : functor.add_const (topological_space (has_add linarith.comp)) (has_zero name)) : @path_connected_space.{0} (has_add.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (has_add.{0} linarith.comp)) (has_zero.{0} name) h0)  := sorry --non-trivial
lemma new_lemma_1414 (h0 : functor.add_const (ordered_add_comm_monoid (finset pos)) (has_neg (finset Type))) : @archimedean.{0} (finset.{0} pos) (@functor.add_const.run.{0 1} (ordered_add_comm_monoid.{0} (finset.{0} pos)) (has_neg.{1} (finset.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_1415 (h0 : finset (cancel_monoid (has_add name))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_1416 (h0 : finset (comm_group environment.implicit_infer_kind)) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_1417 (h0 : function.extfun (function.extfun Type ring -> false) (fun (x : function.extfun Type ring -> false), false)) : @is_domain.{0} (has_norm.{0} fun_info) (@function.extfun_app.{2 1} Type ring.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type ring.{0}) (@function.extfun_app.{0 0} (function.extfun.{2 1} Type ring.{0} → false) (λ (x : function.extfun.{2 1} Type ring.{0} → false), false) h0)) (has_norm.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_1418 (h0 : ring (has_append linarith.ineq)) : strong_rank_condition (has_append linarith.ineq) := sorry --non-trivial
lemma new_lemma_1419 (h0 : semiring (semilattice_inf ennreal)) : is_noetherian_ring (semilattice_inf ennreal) := sorry --non-trivial
lemma new_lemma_1420 (h0 : functor.add_const (function.extfun Type monoid) name) : @monoid.fg.{0} (boolean_algebra.{0} linarith.comp) (@function.extfun_app.{2 1} Type monoid.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type monoid.{0}) name h0) (boolean_algebra.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_1421 (h1 : not (uniform_space (distrib char) -> false)) : @complete_space.{0} (distrib.{0} char) (@classical.by_contradiction'.{1} (uniform_space.{0} (distrib.{0} char)) h1)  := sorry --non-trivial
lemma new_lemma_1422 (h1 : function.extfun Type complete_lattice) : @is_atomistic.{0} (with_one.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type complete_lattice.{0} h1 (with_one.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_1423 (h0 : function.extfun nat fin) : @is_domain.{0} (canonically_linear_ordered_monoid.{0} real) (@matrix.vec_empty.{0} (ring.{0} (canonically_linear_ordered_monoid.{0} real)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_1424 (h0 : add_monoid (has_Inf (has_Inf pos))) : add_monoid.fg (has_Inf (has_Inf pos)) := sorry --non-trivial
lemma new_lemma_1425 (h0 : functor.add_const Prop (option (option (option (option (option empty)))))) : functor.add_const.run h0 := sorry --non-trivial
lemma new_lemma_1426 (h0 : topological_space (linear_ordered_semiring (has_top linarith.comp))) : totally_disconnected_space (linear_ordered_semiring (has_top linarith.comp)) := sorry --non-trivial
lemma new_lemma_1427 (h0 : filter (normed_lattice_add_comm_group (has_Inf (has_Inf Type)))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_1428 (h0 : list (encodable (has_nnnorm linarith.comp_source))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_1429 (h0 : topological_space (has_pos_part (has_pos_part (has_add linarith.comp)))) : preconnected_space (has_pos_part (has_pos_part (has_add linarith.comp))) := sorry --non-trivial
lemma new_lemma_1430 (h0 : list (measurable_space.dynkin_system (semiring congr_arg_kind))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_1431 (h0 : topological_space (simple_graph (has_Inf (finset (has_Inf pos))))) : preirreducible_space (simple_graph (has_Inf (finset (has_Inf pos)))) := sorry --non-trivial
lemma new_lemma_1432 (h0 : function.extfun Type topological_space) : @t1_space.{0} (has_nndist.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_nndist.{0} empty))  := sorry --non-trivial
lemma new_lemma_1433 (h0 : functor.add_const (add_group (complete_distrib_lattice empty)) unsigned) : @is_add_cyclic.{0} (complete_distrib_lattice.{0} empty) (@functor.add_const.run.{0 0} (add_group.{0} (complete_distrib_lattice.{0} empty)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_1434 (h0 : functor.add_const (finset (semiring num)) (semiring (semiring empty))) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_1435 (h0 : ring (semi_normed_comm_ring string.iterator_imp)) : rank_condition (semi_normed_comm_ring string.iterator_imp) := sorry --non-trivial
lemma new_lemma_1436 (h0 : functor.add_const (ring (has_pos_part Type)) linarith.comp) : @is_principal_ideal_ring.{1} (has_pos_part.{1} Type) (@functor.add_const.run.{1 0} (ring.{1} (has_pos_part.{1} Type)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_1437 (h0 : topological_space (mul_zero_class empty)) : totally_separated_space (mul_zero_class empty) := sorry --non-trivial
lemma new_lemma_1438 (h0 : add_group (rel reducibility_hints reducibility_hints)) : is_add_cyclic (rel reducibility_hints reducibility_hints) := sorry --non-trivial
lemma new_lemma_1439 (h0 : functor.add_const (list (ordered_comm_group empty)) empty) : palindrome (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_1440 (h0 : functor.add_const (topological_space pos) Type) : @totally_disconnected_space.{0} pos (@functor.add_const.run.{0 1} (topological_space.{0} pos) Type h0)  := sorry --non-trivial
lemma new_lemma_1441 (h0 : functor.add_const (topological_space (free_add_monoid empty)) num) : @normal_space.{0} (free_add_monoid.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (free_add_monoid.{0} empty)) num h0)  := sorry --non-trivial
lemma new_lemma_1442 (h0 : functor.add_const Prop (semiring (has_norm (measurable_space.dynkin_system empty)))) : functor.add_const.run h0 := sorry --non-trivial
lemma new_lemma_1443 (h0 : topological_space (generalized_boolean_algebra (has_Inf pos))) : preconnected_space (generalized_boolean_algebra (has_Inf pos)) := sorry --non-trivial
lemma new_lemma_1444 (h0 : not (topological_space string_imp -> false)) : @t0_space.{0} string_imp (@classical.by_contradiction'.{1} (topological_space.{0} string_imp) h0)  := sorry --non-trivial
lemma new_lemma_1445 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @monoid.fg.{0} (linear_ordered_add_comm_group.{0} num) (@function.extfun_app.{2 1} Type monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 monoid.{0}) (linear_ordered_add_comm_group.{0} num))  := sorry --non-trivial
lemma new_lemma_1446 (h0 : group (has_zero (cancel_monoid environment.implicit_infer_kind))) : group.fg (has_zero (cancel_monoid environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_1447 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @normal_space.{0} (add_cancel_monoid.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (add_cancel_monoid.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_1448 (h0 h1 : multiset (uniform_space (has_ssubset char))) : multiset.disjoint h0 h1 := sorry --non-trivial
lemma new_lemma_1449 (h0 : topological_space (has_append (random_gen char))) : t0_space (has_append (random_gen char)) := sorry --non-trivial
lemma new_lemma_1450 (h0 : group (measurable_space (with_bot (with_bot string_imp)))) : normalizer_condition (measurable_space (with_bot (with_bot string_imp))) := sorry --non-trivial
lemma new_lemma_1451 (h0 : function.extfun Type topological_space) : @t0_space.{0} (with_one.{0} fun_info) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (with_one.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_1452 (h0 : topological_space (measurable_space.dynkin_system unsigned)) : totally_disconnected_space (measurable_space.dynkin_system unsigned) := sorry --non-trivial
lemma new_lemma_1453 (h0 : cancel_comm_monoid_with_zero (pseudo_metric_space (option (option (option (option empty)))))) : unique_factorization_monoid (pseudo_metric_space (option (option (option (option empty))))) := sorry --non-trivial
lemma new_lemma_1454 (h0 : ring (has_norm (random_gen (random_gen to_additive.value_type)))) : is_domain (has_norm (random_gen (random_gen to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_1455 (h0 : group (canonically_ordered_comm_semiring (ring (ring (boolean_algebra.core Type))))) : group.fg (canonically_ordered_comm_semiring (ring (ring (boolean_algebra.core Type)))) := sorry --non-trivial
lemma new_lemma_1456 (h1 : ring (has_nnnorm (random_gen string_imp))) : is_domain (has_nnnorm (random_gen string_imp)) := sorry --non-trivial
lemma new_lemma_1457 (h0 : functor.add_const (topological_space (has_nndist unsigned)) linarith.comp) : @preirreducible_space.{0} (has_nndist.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (has_nndist.{0} unsigned)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_1458 (h0 : ordered_comm_monoid (ring (has_add name))) : has_exists_mul_of_le (ring (has_add name)) := sorry --non-trivial
lemma new_lemma_1459 (h0 : function.extfun Type complete_lattice) : @complete_lattice.is_Sup_finite_compact.{0} (normed_comm_ring.{0} linarith.comp) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (normed_comm_ring.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_1460 (h0 : cancel_comm_monoid_with_zero (has_Inf (has_pos_part name))) : unique_factorization_monoid (has_Inf (has_pos_part name)) := sorry --non-trivial
lemma new_lemma_1461 (h0 : group (boolean_algebra (has_add (has_Inf (canonically_linear_ordered_monoid real))))) : normalizer_condition (boolean_algebra (has_add (has_Inf (canonically_linear_ordered_monoid real)))) := sorry --non-trivial
lemma new_lemma_1462 (h0 : functor.add_const (topological_space (ring name)) Type) : @t1_space.{0} (ring.{0} name) (@functor.add_const.run.{0 1} (topological_space.{0} (ring.{0} name)) Type h0)  := sorry --non-trivial
lemma new_lemma_1463 (h0 : group (has_norm (has_nnnorm to_additive.value_type))) : group.fg (has_norm (has_nnnorm to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_1464 (h0 : add_monoid (has_pos_part (finset (has_Inf (has_add pos))))) : add_monoid.fg (has_pos_part (finset (has_Inf (has_add pos)))) := sorry --non-trivial
lemma new_lemma_1465 (h0 : ring (mul_zero_class (finset Type))) : rank_condition (mul_zero_class (finset Type)) := sorry --non-trivial
lemma new_lemma_1466 (h1 : function.extfun (finset Type) (has_mem.mem (measurable_space linarith.comp_source))) : complete_lattice.is_Sup_finite_compact (measurable_space linarith.comp_source) := sorry --non-trivial
lemma new_lemma_1467 (h1 : topological_space (encodable string_imp)) : t0_space (encodable string_imp) := sorry --non-trivial
lemma new_lemma_1468 (h0 : ring (comm_semigroup (add_comm_monoid Type))) : rank_condition (comm_semigroup (add_comm_monoid Type)) := sorry --non-trivial
lemma new_lemma_1469 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @is_add_cyclic.{1} (ring.{1} Type) (@function.extfun_app.{3 2} (Type 1) add_group.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 add_group.{1}) (ring.{1} Type))  := sorry --non-trivial
lemma new_lemma_1470 (h0 : functor.add_const (semiring (finset Type)) linarith.comp) : @is_noetherian_ring.{1} (finset.{1} Type) (@functor.add_const.run.{1 0} (semiring.{1} (finset.{1} Type)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_1471 (h0 : topological_space (add_comm_monoid (ring pos))) : irreducible_space (add_comm_monoid (ring pos)) := sorry --non-trivial
lemma new_lemma_1472 (h0 : ordered_comm_monoid (ordered_comm_monoid (has_Inf (has_add Type)))) : has_exists_mul_of_le (ordered_comm_monoid (has_Inf (has_add Type))) := sorry --non-trivial
lemma new_lemma_1473 (h0 : topological_space (preorder num)) : totally_disconnected_space (preorder num) := sorry --non-trivial
lemma new_lemma_1474 (h0 : measurable_space linarith.comp_source) (h1 : has_div linarith.comp_source) : has_measurable_div₂ linarith.comp_source := sorry --non-trivial
lemma new_lemma_1475 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @normalizer_condition.{0} (comm_group.{0} name) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (comm_group.{0} name))  := sorry --non-trivial
lemma new_lemma_1476 (h0 : ordered_add_comm_monoid (add_cancel_monoid (mul_one_class (has_neg pos)))) : archimedean (add_cancel_monoid (mul_one_class (has_neg pos))) := sorry --non-trivial
lemma new_lemma_1477 (h0 : ring (normed_field (has_nnnorm (has_nnnorm char)))) : is_domain (normed_field (has_nnnorm (has_nnnorm char))) := sorry --non-trivial
lemma new_lemma_1478 (h0 : add_monoid (preorder (option (option unsigned)))) : add_monoid.fg (preorder (option (option unsigned))) := sorry --non-trivial
lemma new_lemma_1479 (h0 : complete_lattice (canonically_ordered_comm_semiring (has_add environment.implicit_infer_kind))) : is_atomistic (canonically_ordered_comm_semiring (has_add environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_1480 (h0 : has_lt (linear_ordered_comm_group_with_zero string.iterator_imp)) : no_max_order (linear_ordered_comm_group_with_zero string.iterator_imp) := sorry --non-trivial
lemma new_lemma_1481 (h0 : group (boolean_algebra.core linarith.comp)) : is_simple_group (boolean_algebra.core linarith.comp) := sorry --non-trivial
lemma new_lemma_1482 (h0 : not (ring (semi_normed_ring char) -> false)) : @is_domain.{0} (semi_normed_ring.{0} char) (@classical.by_contradiction'.{1} (ring.{0} (semi_normed_ring.{0} char)) h0)  := sorry --non-trivial
lemma new_lemma_1483 (h0 : functor.add_const (complete_lattice (complete_distrib_lattice linarith.comp)) environment.implicit_infer_kind) : @is_compactly_generated.{0} (complete_distrib_lattice.{0} linarith.comp) (@functor.add_const.run.{0 0} (complete_lattice.{0} (complete_distrib_lattice.{0} linarith.comp)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_1484 (h0 : monoid (boolean_algebra (boolean_algebra pos))) : monoid.fg (boolean_algebra (boolean_algebra pos)) := sorry --non-trivial
lemma new_lemma_1485 (h0 : list (boolean_algebra (has_pos_part (has_pos_part (has_pos_part linarith.comp))))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_1486 (h0 : topological_space (canonically_ordered_comm_semiring (has_neg name))) : preirreducible_space (canonically_ordered_comm_semiring (has_neg name)) := sorry --non-trivial
lemma new_lemma_1487 (h0 : ring (boolean_algebra.core (has_add Type))) : strong_rank_condition (boolean_algebra.core (has_add Type)) := sorry --non-trivial
lemma new_lemma_1488 (h0 : functor.add_const (topological_space (generalized_boolean_algebra linarith.comp)) linarith.comp) : @t1_space.{0} (generalized_boolean_algebra.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (generalized_boolean_algebra.{0} linarith.comp)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_1489 (h0 : functor.add_const (ring (add_cancel_monoid pos)) pos) : @is_domain.{0} (add_cancel_monoid.{0} pos) (@functor.add_const.run.{0 0} (ring.{0} (add_cancel_monoid.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_1490 (h0 : function.extfun Type topological_space) : @loc_path_connected_space.{0} (group_with_zero.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (group_with_zero.{0} num))  := sorry --non-trivial
lemma new_lemma_1491 (h0 : ring (boolean_algebra (has_nndist Type))) : rank_condition (boolean_algebra (has_nndist Type)) := sorry --non-trivial
lemma new_lemma_1492 (h0 : group (with_bot (random_gen to_additive.value_type))) : is_cyclic (with_bot (random_gen to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_1493 (h0 : topological_space (ordered_comm_group (option (option unsigned)))) : path_connected_space (ordered_comm_group (option (option unsigned))) := sorry --non-trivial
lemma new_lemma_1494 (h0 : set (mul_one_class char -> std_gen)) : set.separates_points h0 := sorry --non-trivial
lemma new_lemma_1495 (h0 : function.extfun nat fin) : @is_atomistic.{0} (canonically_ordered_monoid.{0} real) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@matrix.vec_empty.{1} (function.extfun.{2 1} Type complete_lattice.{0}) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero))) (canonically_ordered_monoid.{0} real))  := sorry --non-trivial
lemma new_lemma_1496 (h0 : functor.add_const (topological_space Type) pos) : @topological_space.separable_space.{1} Type (@functor.add_const.run.{1 0} (topological_space.{1} Type) pos h0)  := sorry --non-trivial
lemma new_lemma_1497 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @unique_factorization_monoid.{0} (is_R_or_C.{0} empty) (@function.extfun_app.{2 1} Type cancel_comm_monoid_with_zero.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 cancel_comm_monoid_with_zero.{0}) (is_R_or_C.{0} empty))  := sorry --non-trivial
lemma new_lemma_1498 (h0 : functor.add_const Prop (comm_group (finset Type))) : functor.add_const.run h0 := sorry --non-trivial
lemma new_lemma_1499 (h0 : topological_space (add_comm_monoid (has_pos_part Type))) : preirreducible_space (add_comm_monoid (has_pos_part Type)) := sorry --non-trivial
lemma new_lemma_1500 (h0 : ring (topological_space (comm_ring char))) : strong_rank_condition (topological_space (comm_ring char)) := sorry --non-trivial
lemma new_lemma_1501 (h0 : functor.add_const (function.extfun Type add_group) (has_neg linarith.comp)) : @is_add_cyclic.{0} pos (@function.extfun_app.{2 1} Type add_group.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type add_group.{0}) (has_neg.{0} linarith.comp) h0) pos)  := sorry --non-trivial
lemma new_lemma_1502 (h0 : complete_lattice (semi_normed_ring (has_compl fun_info))) : is_compactly_generated (semi_normed_ring (has_compl fun_info)) := sorry --non-trivial
lemma new_lemma_1503 (h0 : topological_space (boolean_algebra (ordered_comm_monoid (has_Inf real)))) : path_connected_space (boolean_algebra (ordered_comm_monoid (has_Inf real))) := sorry --non-trivial
lemma new_lemma_1504 (h0 : group (canonically_ordered_monoid (has_Inf Type))) : normalizer_condition (canonically_ordered_monoid (has_Inf Type)) := sorry --non-trivial
lemma new_lemma_1505 (h0 : functor.add_const (ring (cancel_monoid ennreal)) (option ennreal)) : @strong_rank_condition.{0} (cancel_monoid.{0} ennreal) (@functor.add_const.run.{0 0} (ring.{0} (cancel_monoid.{0} ennreal)) (option.{0} ennreal) h0)  := sorry --non-trivial
lemma new_lemma_1506 (h0 : functor.add_const (topological_space (boolean_algebra.core name)) linarith.comp) : @preirreducible_space.{0} (boolean_algebra.core.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (boolean_algebra.core.{0} name)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_1507 (h0 : functor.add_const (topological_space (has_nndist unsigned)) environment.implicit_infer_kind) : @regular_space.{0} (has_nndist.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (has_nndist.{0} unsigned)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_1508 (h0 : function.extfun Type topological_space) : @topological_space.separable_space.{0} (semigroup.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (semigroup.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_1509 (h1 : uniform_space char) : separated_space char := sorry --non-trivial
lemma new_lemma_1510 (h0 : function.extfun Type group) : @is_simple_group.{0} (canonically_ordered_comm_semiring.{0} linarith.comp) (@function.extfun_app.{2 1} Type group.{0} h0 (canonically_ordered_comm_semiring.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_1511 (h0 : functor.add_const (topological_space (comm_group pos)) (option (option name))) : @preconnected_space.{0} (comm_group.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (comm_group.{0} pos)) (option.{0} (option.{0} name)) h0)  := sorry --non-trivial
lemma new_lemma_1512 (h0 : functor.add_const (monoid (linear_order unsigned)) unsigned) : @monoid.fg.{0} (linear_order.{0} unsigned) (@functor.add_const.run.{0 0} (monoid.{0} (linear_order.{0} unsigned)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_1513 (h0 : add_group (add_comm_monoid (add_comm_monoid environment.implicit_infer_kind))) : is_add_cyclic (add_comm_monoid (add_comm_monoid environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_1514 (h0 : ring (div_inv_monoid (random_gen (random_gen to_additive.value_type)))) : is_domain (div_inv_monoid (random_gen (random_gen to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_1515 (h0 : functor.comp topological_space has_neg_part environment.implicit_infer_kind) : @t1_space.{0} (has_neg_part.{0} environment.implicit_infer_kind) (@functor.comp.run.{0 0 0} topological_space.{0} has_neg_part.{0} environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_1516 (h0 : complete_lattice (semi_normed_comm_ring (mul_one_class string.iterator_imp))) : is_compactly_generated (semi_normed_comm_ring (mul_one_class string.iterator_imp)) := sorry --non-trivial
lemma new_lemma_1517 (h0 : functor.add_const (topological_space (has_neg_part environment.implicit_infer_kind)) pos) : @discrete_topology.{0} (has_neg_part.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (has_neg_part.{0} environment.implicit_infer_kind)) pos h0)  := sorry --non-trivial
lemma new_lemma_1518 (h0 : functor.add_const (uniform_space (boolean_algebra.core Type)) (ring Type)) : @complete_space.{1} (boolean_algebra.core.{1} Type) (@functor.add_const.run.{1 1} (uniform_space.{1} (boolean_algebra.core.{1} Type)) (ring.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_1519 (h0 : topological_space (simple_graph (has_Inf (has_Inf (has_add (has_Inf linarith.comp)))))) : t1_space (simple_graph (has_Inf (has_Inf (has_add (has_Inf linarith.comp))))) := sorry --non-trivial
lemma new_lemma_1520 (h0 : topological_space (with_one (has_norm num))) : preirreducible_space (with_one (has_norm num)) := sorry --non-trivial
lemma new_lemma_1521 (h0 : functor.add_const (function.extfun (Type 1) topological_space) pos) : @loc_path_connected_space.{1} (has_nndist.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) topological_space.{1}) pos h0) (has_nndist.{1} Type))  := sorry --non-trivial
lemma new_lemma_1522 (h0 : filter (has_nnnorm string_imp)) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_1523 (h0 : finset (normed_comm_ring (has_add Type))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_1524 (h0 : functor.add_const (topological_space (finset pos)) Type) : @preirreducible_space.{0} (finset.{0} pos) (@functor.add_const.run.{0 1} (topological_space.{0} (finset.{0} pos)) Type h0)  := sorry --non-trivial
lemma new_lemma_1525 (h0 : fin has_zero.zero) : @is_add_cyclic.{0} to_additive.value_type (@matrix.vec_empty.{0} (add_group.{0} to_additive.value_type) h0)  := sorry --non-trivial
lemma new_lemma_1526 (h0 : complete_lattice (linear_ordered_comm_group_with_zero (mul_one_class char))) : is_compactly_generated (linear_ordered_comm_group_with_zero (mul_one_class char)) := sorry --non-trivial
lemma new_lemma_1527 (h0 : list (add_group (semiring empty))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_1528 (h0 : functor.add_const (topological_space (comm_group pos)) num) : @irreducible_space.{0} (comm_group.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (comm_group.{0} pos)) num h0)  := sorry --non-trivial
lemma new_lemma_1529 (h0 : add_monoid (ordered_comm_monoid (has_pos_part (has_add (has_add pos))))) : add_monoid.fg (ordered_comm_monoid (has_pos_part (has_add (has_add pos)))) := sorry --non-trivial
lemma new_lemma_1530 (h0 : group (random_gen (has_inv (has_inv (has_inv fun_info))))) : normalizer_condition (random_gen (has_inv (has_inv (has_inv fun_info)))) := sorry --non-trivial
lemma new_lemma_1531 (h0 : topological_space (simple_graph enat)) : t0_space (simple_graph enat) := sorry --non-trivial
lemma new_lemma_1532 (h0 : not (add_monoid (id linarith.comp) -> false)) : @add_monoid.fg.{0} (@id.{2} Type linarith.comp) (@classical.by_contradiction'.{1} (add_monoid.{0} (@id.{2} Type linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_1533 (h0 : group (canonically_ordered_monoid (has_add linarith.comp))) : is_simple_group (canonically_ordered_monoid (has_add linarith.comp)) := sorry --non-trivial
lemma new_lemma_1534 (h0 : set (has_ssubset linarith.comp_source)) : set.finite h0 := sorry --non-trivial
lemma new_lemma_1535 (h0 : add_group (partial_order (semiring congr_arg_kind))) : is_add_cyclic (partial_order (semiring congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_1536 (h0 : topological_space (linear_ordered_semiring (semiring (semiring congr_arg_kind)))) : preirreducible_space (linear_ordered_semiring (semiring (semiring congr_arg_kind))) := sorry --non-trivial
lemma new_lemma_1537 (h0 : topological_space (has_edist fun_info)) : topological_space.first_countable_topology (has_edist fun_info) := sorry --non-trivial
lemma new_lemma_1538 (h0 : add_group (canonically_linear_ordered_add_monoid (comm_group unsigned))) : is_add_cyclic (canonically_linear_ordered_add_monoid (comm_group unsigned)) := sorry --non-trivial
lemma new_lemma_1539 (h0 : add_comm_semigroup ereal -> add_comm_semigroup ereal) (h1 : add_comm_semigroup ereal) : function.is_fixed_pt h0 h1 := sorry --non-trivial
lemma new_lemma_1540 (h0 : not (function.extfun Type topological_space -> false)) : @topological_space.separable_space.{0} (complete_linear_order.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (complete_linear_order.{0} num))  := sorry --non-trivial
lemma new_lemma_1541 (h0 : not (topological_space (uniform_space to_additive.value_type) -> false)) : @totally_disconnected_space.{0} (uniform_space.{0} to_additive.value_type) (@classical.by_contradiction'.{1} (topological_space.{0} (uniform_space.{0} to_additive.value_type)) h0)  := sorry --non-trivial
lemma new_lemma_1542 (h0 : list (canonically_ordered_monoid (sub_neg_monoid real))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_1543 (h0 : topological_space (normed_group to_additive.value_type)) : locally_compact_space (normed_group to_additive.value_type) := sorry --non-trivial
lemma new_lemma_1544 (h0 : functor.add_const (topological_space (boolean_algebra.core pos)) unsigned) : @path_connected_space.{0} (boolean_algebra.core.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (boolean_algebra.core.{0} pos)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_1545 (h0 : topological_space (normed_group (has_norm (has_norm num)))) : totally_disconnected_space (normed_group (has_norm (has_norm num))) := sorry --non-trivial
lemma new_lemma_1546 (h0 : topological_space (has_add string_imp)) : t0_space (has_add string_imp) := sorry --non-trivial
lemma new_lemma_1547 (h0 : function.extfun Type uniform_space) : @complete_space.{0} (canonically_ordered_comm_semiring.{0} name) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (canonically_ordered_comm_semiring.{0} name))  := sorry --non-trivial
lemma new_lemma_1548 (h0 : functor.add_const (topological_space (has_zero ennreal)) (option pos)) : @totally_separated_space.{0} (has_zero.{0} ennreal) (@functor.add_const.run.{0 0} (topological_space.{0} (has_zero.{0} ennreal)) (option.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_1549 (h0 : function.extfun Type group) : @is_cyclic.{0} (ring.{0} name) (@function.extfun_app.{2 1} Type group.{0} h0 (ring.{0} name))  := sorry --non-trivial
lemma new_lemma_1550 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @complete_lattice.is_Sup_finite_compact.{0} (denumerable.{0} fun_info) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (denumerable.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_1551 (h0 : semiring (random_gen fun_info)) (h1 : ring (polynomial (random_gen fun_info))) : strong_rank_condition (polynomial (random_gen fun_info)) := sorry --non-trivial
lemma new_lemma_1552 (h3 : group (normed_field (metric_space (random_gen char)))) : is_cyclic (normed_field (metric_space (random_gen char))) := sorry --non-trivial
lemma new_lemma_1553 (h0 : functor.add_const (list (has_to_string pos)) name) : palindrome (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_1554 (h0 : functor.add_const (complete_lattice (boolean_algebra pos)) (boolean_algebra Type)) : @is_compactly_generated.{0} (boolean_algebra.{0} pos) (@functor.add_const.run.{0 1} (complete_lattice.{0} (boolean_algebra.{0} pos)) (boolean_algebra.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_1555 (h0 : functor.add_const (topological_space (complete_distrib_lattice Type)) linarith.comp) : @loc_path_connected_space.{1} (complete_distrib_lattice.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (complete_distrib_lattice.{1} Type)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_1556 (h0 : cancel_comm_monoid_with_zero (complete_distrib_lattice pos)) : unique_factorization_monoid (complete_distrib_lattice pos) := sorry --non-trivial
lemma new_lemma_1557 (h0 : filter (has_union (id linarith.comp))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_1558 (h1 : has_mem.mem (has_emptyc to_additive.value_type) has_emptyc.emptyc) : @is_compactly_generated.{0} (has_emptyc.{0} to_additive.value_type) (@finset.pi.empty.{1 0} Type complete_lattice.{0} (has_emptyc.{0} to_additive.value_type) h1)  := sorry --non-trivial
lemma new_lemma_1559 (h0 : function.extfun Type (prod (has_top unsigned))) : id_rel (function.extfun_app h0 (has_top unsigned)) := sorry --non-trivial
lemma new_lemma_1560 (h0 : uniform_space (semiring (has_top linarith.comp_source))) : complete_space (semiring (has_top linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_1561 (h0 : functor.add_const (topological_space (canonically_ordered_comm_semiring Type)) linarith.comp) : @normal_space.{1} (canonically_ordered_comm_semiring.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (canonically_ordered_comm_semiring.{1} Type)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_1562 (h0 : group (has_Sup (semiring (option empty)))) : normalizer_condition (has_Sup (semiring (option empty))) := sorry --non-trivial
lemma new_lemma_1563 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @separated_space.{1} (has_pos_part.{1} Type) (@function.extfun_app.{3 2} (Type 1) uniform_space.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 uniform_space.{1}) (has_pos_part.{1} Type))  := sorry --non-trivial
lemma new_lemma_1564 (h0 : functor.add_const (complete_lattice (add_comm_monoid unsigned)) pos) : @is_compactly_generated.{0} (add_comm_monoid.{0} unsigned) (@functor.add_const.run.{0 0} (complete_lattice.{0} (add_comm_monoid.{0} unsigned)) pos h0)  := sorry --non-trivial
lemma new_lemma_1565 (h0 : monoid (left_cancel_semigroup (semiring num))) : monoid.fg (left_cancel_semigroup (semiring num)) := sorry --non-trivial
lemma new_lemma_1566 (h0 : ring (normed_comm_ring (option unsigned))) : strong_rank_condition (normed_comm_ring (option unsigned)) := sorry --non-trivial
lemma new_lemma_1567 (h0 : function.extfun (finset Type) (has_mem.mem (with_bot to_additive.value_type))) : @totally_separated_space.{0} (with_bot.{0} to_additive.value_type) (@finset.pi.empty.{1 0} Type topological_space.{0} (with_bot.{0} to_additive.value_type) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (with_bot.{0} to_additive.value_type)) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_1568 (h0 : functor.add_const (filter (has_neg_part name)) environment.implicit_infer_kind) : countable_Inter_filter (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_1569 (h0 : complete_lattice (has_emptyc congr_arg_kind)) : is_compactly_generated (has_emptyc congr_arg_kind) := sorry --non-trivial
lemma new_lemma_1570 (h0 : functor.add_const (topological_space (add_cancel_monoid linarith.comp)) linarith.comp) : @topological_space.separable_space.{0} (add_cancel_monoid.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (add_cancel_monoid.{0} linarith.comp)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_1571 (h0 : function.extfun Type (functor.comp list comm_group)) : palindrome (functor.comp.run (functor.comp.run (function.extfun_app h0 pos))) := sorry --non-trivial
lemma new_lemma_1572 (h0 : functor.add_const (topological_space (has_neg Type)) (finset Type)) : @regular_space.{1} (has_neg.{1} Type) (@functor.add_const.run.{1 1} (topological_space.{1} (has_neg.{1} Type)) (finset.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_1573 (h0 : uniform_space (add_group (semiring congr_arg_kind))) : separated_space (add_group (semiring congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_1574 (h0 : functor.add_const (topological_space (add_group empty)) num) : @loc_path_connected_space.{0} (add_group.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (add_group.{0} empty)) num h0)  := sorry --non-trivial
lemma new_lemma_1575 (h0 : functor.add_const (topological_space (boolean_algebra.core name)) linarith.comp) : @sequential_space.{0} (boolean_algebra.core.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (boolean_algebra.core.{0} name)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_1576 (h1 : ring (plift (has_inv (has_nnnorm fun_info)))) : strong_rank_condition (plift (has_inv (has_nnnorm fun_info))) := sorry --non-trivial
lemma new_lemma_1577 (h0 : ring (has_one (semiring (semiring empty)))) : is_domain (has_one (semiring (semiring empty))) := sorry --non-trivial
lemma new_lemma_1578 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : finset.nonempty (function.extfun_app (function.extfun_app h0 finset) (filter empty)) := sorry --non-trivial
lemma new_lemma_1579 (h0 : group (has_inv (random_gen (random_gen linarith.ineq)))) : is_cyclic (has_inv (random_gen (random_gen linarith.ineq))) := sorry --non-trivial
lemma new_lemma_1580 (h0 : topological_space (add_comm_monoid (normed_comm_ring environment.implicit_infer_kind))) : t0_space (add_comm_monoid (normed_comm_ring environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_1581 (h0 : topological_space (semiring (option empty))) : topological_space.separable_space (semiring (option empty)) := sorry --non-trivial
lemma new_lemma_1582 (h0 : add_group (normed_group (has_inv to_additive.value_type))) : is_add_cyclic (normed_group (has_inv to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_1583 (h0 : functor.add_const (ring (canonically_ordered_comm_semiring pos)) environment.implicit_infer_kind) : @is_domain.{0} (canonically_ordered_comm_semiring.{0} pos) (@functor.add_const.run.{0 0} (ring.{0} (canonically_ordered_comm_semiring.{0} pos)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_1584 (h0 : functor.add_const (uniform_space (normed_comm_ring pos)) (finset Type)) : @complete_space.{0} (normed_comm_ring.{0} pos) (@functor.add_const.run.{0 1} (uniform_space.{0} (normed_comm_ring.{0} pos)) (finset.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_1585 (h0 : complete_lattice (has_bot (has_Inf (has_Inf pos)))) : is_atomistic (has_bot (has_Inf (has_Inf pos))) := sorry --non-trivial
lemma new_lemma_1586 (h2 : function.extfun (finset Type) (has_mem.mem (random_gen congr_arg_kind))) : @irreducible_space.{0} (random_gen.{0} congr_arg_kind) (@finset.pi.empty.{1 0} Type topological_space.{0} (random_gen.{0} congr_arg_kind) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (random_gen.{0} congr_arg_kind)) h2 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_1587 (h0 : function.extfun Type topological_space) : @totally_disconnected_space.{0} (simple_graph.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (simple_graph.{0} name))  := sorry --non-trivial
lemma new_lemma_1588 (h0 : functor.add_const (group (add_cancel_monoid name)) Type) : @is_cyclic.{0} (add_cancel_monoid.{0} name) (@functor.add_const.run.{0 1} (group.{0} (add_cancel_monoid.{0} name)) Type h0)  := sorry --non-trivial
lemma new_lemma_1589 (h1 : has_mem.mem (metric_space linarith.comp) has_emptyc.emptyc) : @t0_space.{0} (metric_space.{0} linarith.comp) (@finset.pi.empty.{1 0} Type topological_space.{0} (metric_space.{0} linarith.comp) h1)  := sorry --non-trivial
lemma new_lemma_1590 (h0 : list (has_neg (ring linarith.comp))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_1591 (h0 : uniform_space (with_one linarith.comp_source)) : complete_space (with_one linarith.comp_source) := sorry --non-trivial
lemma new_lemma_1592 (h0 : not (function.extfun Type complete_lattice -> false)) : @is_atomistic.{0} (with_bot.{0} fun_info) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type complete_lattice.{0}) h0) (with_bot.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_1593 (h0 : ordered_add_comm_monoid (generalized_boolean_algebra (sub_neg_monoid pos))) : archimedean (generalized_boolean_algebra (sub_neg_monoid pos)) := sorry --non-trivial
lemma new_lemma_1594 (h0 : has_mem.mem (complete_semilattice_Sup num) has_emptyc.emptyc) : @complete_lattice.is_Sup_finite_compact.{0} (complete_semilattice_Sup.{0} num) (@finset.pi.empty.{1 0} Type complete_lattice.{0} (complete_semilattice_Sup.{0} num) h0)  := sorry --non-trivial
lemma new_lemma_1595 (h0 : topological_space (mul_one_class linarith.comp_source)) : path_connected_space (mul_one_class linarith.comp_source) := sorry --non-trivial
lemma new_lemma_1596 (h0 : topological_space (denumerable (has_top fun_info))) : path_connected_space (denumerable (has_top fun_info)) := sorry --non-trivial
lemma new_lemma_1597 (h0 : fin has_zero.zero) : @t1_space.{0} (generalized_boolean_algebra.{0} real) (@matrix.vec_empty.{0} (topological_space.{0} (generalized_boolean_algebra.{0} real)) h0)  := sorry --non-trivial
lemma new_lemma_1598 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @complete_space.{0} (boolean_algebra.core.{0} unsigned) (@function.extfun_app.{2 1} Type uniform_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 uniform_space.{0}) (boolean_algebra.core.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_1599 (h0 : not (function.extfun Type monoid -> false)) : @monoid.fg.{0} to_additive.value_type (@function.extfun_app.{2 1} Type monoid.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type monoid.{0}) h0) to_additive.value_type)  := sorry --non-trivial
lemma new_lemma_1600 (h0 : list (monoid (option (option (option empty))))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_1601 (h0 : filter (id (has_top congr_arg_kind))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_1602 (h1 : uniform_space (dlist char)) : complete_space (dlist char) := sorry --non-trivial
lemma new_lemma_1603 (h0 : functor.add_const (ordered_comm_monoid (ring Type)) linarith.comp) : @has_exists_mul_of_le.{1} (ring.{1} Type) (@functor.add_const.run.{1 0} (ordered_comm_monoid.{1} (ring.{1} Type)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_1604 (h0 : semiring (add_right_cancel_monoid (semiring unsigned))) : is_noetherian_ring (add_right_cancel_monoid (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_1605 (h0 : function.extfun Type complete_lattice) : @complete_lattice.is_Sup_finite_compact.{0} (linear_ordered_cancel_comm_monoid.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (linear_ordered_cancel_comm_monoid.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_1606 (h3 : topological_space enat) (h4 : preorder enat) : order_closed_topology enat := sorry --non-trivial
lemma new_lemma_1607 (h0 : complete_lattice (add_comm_monoid (add_cancel_monoid name))) : is_atomistic (add_comm_monoid (add_cancel_monoid name)) := sorry --non-trivial
lemma new_lemma_1608 (h0 : ring (comm_ring (random_gen reducibility_hints))) : is_domain (comm_ring (random_gen reducibility_hints)) := sorry --non-trivial
lemma new_lemma_1609 (h0 : not (add_group (fintype linarith.comp_source) -> false)) : @is_add_cyclic.{0} (fintype.{0} linarith.comp_source) (@classical.by_contradiction'.{1} (add_group.{0} (fintype.{0} linarith.comp_source)) h0)  := sorry --non-trivial
lemma new_lemma_1610 (h1 : monoid (has_emptyc fun_info)) : monoid.fg (has_emptyc fun_info) := sorry --non-trivial
lemma new_lemma_1611 (h0 : filter (canonically_linear_ordered_monoid real)) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_1612 (h0 : function.extfun Type group) : @group.fg.{0} (mul_zero_class.{0} ennreal) (@function.extfun_app.{2 1} Type group.{0} h0 (mul_zero_class.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_1613 (h0 : functor.add_const (topological_space (has_Inf Type)) pos) : @preconnected_space.{1} (has_Inf.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (has_Inf.{1} Type)) pos h0)  := sorry --non-trivial
lemma new_lemma_1614 (h0 : functor.add_const (add_monoid (add_cancel_monoid linarith.comp)) pos) : @add_monoid.fg.{0} (add_cancel_monoid.{0} linarith.comp) (@functor.add_const.run.{0 0} (add_monoid.{0} (add_cancel_monoid.{0} linarith.comp)) pos h0)  := sorry --non-trivial
lemma new_lemma_1615 (h0 : topological_space (pseudo_metric_space (option unsigned))) : preirreducible_space (pseudo_metric_space (option unsigned)) := sorry --non-trivial
lemma new_lemma_1616 (h0 : uniform_space (boolean_algebra pos)) : complete_space (boolean_algebra pos) := sorry --non-trivial
lemma new_lemma_1617 (h0 : topological_space (has_scalar (sub_neg_monoid Type) real)) : path_connected_space (has_scalar (sub_neg_monoid Type) real) := sorry --non-trivial
lemma new_lemma_1618 (h0 : add_group pos) : is_add_cyclic pos := sorry --non-trivial
lemma new_lemma_1619 (h0 : topological_space (linear_ordered_comm_group ennreal)) : discrete_topology (linear_ordered_comm_group ennreal) := sorry --non-trivial
lemma new_lemma_1620 (h0 : complete_lattice (has_compl (complete_semilattice_Sup fun_info))) : complete_lattice.is_Sup_finite_compact (has_compl (complete_semilattice_Sup fun_info)) := sorry --non-trivial
lemma new_lemma_1621 (h0 : functor.add_const (ring Type) (has_pos_part pos)) : @is_domain.{1} Type (@functor.add_const.run.{1 0} (ring.{1} Type) (has_pos_part.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_1622 (h1 : ring (nondiscrete_normed_field std_gen)) : strong_rank_condition (nondiscrete_normed_field std_gen) := sorry --non-trivial
lemma new_lemma_1623 (h0 : functor.add_const (group (normed_comm_ring unsigned)) num) : @normalizer_condition.{0} (normed_comm_ring.{0} unsigned) (@functor.add_const.run.{0 0} (group.{0} (normed_comm_ring.{0} unsigned)) num h0)  := sorry --non-trivial
lemma new_lemma_1624 (h0 : has_mem.mem topological_space has_emptyc.emptyc) : @locally_compact_space.{0} (random_gen.{0} linarith.ineq) (@function.extfun_app.{2 1} Type topological_space.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) topological_space.{0} h0) (random_gen.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_1625 (h0 : functor.add_const (semiring (has_Inf linarith.comp)) (has_Inf (has_Inf pos))) : @is_noetherian_ring.{0} (has_Inf.{0} linarith.comp) (@functor.add_const.run.{0 0} (semiring.{0} (has_Inf.{0} linarith.comp)) (has_Inf.{0} (has_Inf.{0} pos)) h0)  := sorry --non-trivial
lemma new_lemma_1626 (h0 : ordered_add_comm_monoid (left_cancel_monoid (option empty))) : archimedean (left_cancel_monoid (option empty)) := sorry --non-trivial
lemma new_lemma_1627 (h0 : not (function.extfun (finset Type) (has_mem.mem linarith.ineq) -> false)) : @irreducible_space.{0} linarith.ineq (@finset.pi.empty.{1 0} Type topological_space.{0} linarith.ineq (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) linarith.ineq) (@classical.by_contradiction'.{0} (function.extfun.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) linarith.ineq)) h0) (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_1628 (h3 : complete_lattice (fintype char)) : complete_lattice.is_Sup_finite_compact (fintype char) := sorry --non-trivial
lemma new_lemma_1629 (h0 : functor.add_const (function.extfun Type list) (finset Type)) : palindrome (function.extfun_app (functor.add_const.run h0) (boolean_algebra pos)) := sorry --non-trivial
lemma new_lemma_1630 (h0 : group (ring (has_neg (has_add pos)))) : group.fg (ring (has_neg (has_add pos))) := sorry --non-trivial
lemma new_lemma_1631 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @preconnected_space.{0} (has_to_string.{0} (option.{0} unsigned)) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_to_string.{0} (option.{0} unsigned)))  := sorry --non-trivial
lemma new_lemma_1632 (h0 : functor.add_const (topological_space (mul_zero_class name)) pos) : @t1_space.{0} (mul_zero_class.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (mul_zero_class.{0} name)) pos h0)  := sorry --non-trivial
lemma new_lemma_1633 (h0 : list (boolean_algebra.core (generalized_boolean_algebra pos))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_1634 (h0 : not (function.extfun Type semiring -> false)) : @is_noetherian_ring.{0} (add_group.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type semiring.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type semiring.{0}) h0) (add_group.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_1635 (h0 : function.extfun (Type 1) uniform_space) : @complete_space.{1} (plift.{1} unsigned) (@function.extfun_app.{3 2} (Type 1) uniform_space.{1} h0 (plift.{1} unsigned))  := sorry --non-trivial
lemma new_lemma_1636 (h0 : functor.add_const (ring (has_to_string name)) Type) : @is_principal_ideal_ring.{0} (has_to_string.{0} name) (@functor.add_const.run.{0 1} (ring.{0} (has_to_string.{0} name)) Type h0)  := sorry --non-trivial
lemma new_lemma_1637 (h0 : functor.add_const (topological_space znum) num) : @t0_space.{0} znum (@functor.add_const.run.{0 0} (topological_space.{0} znum) num h0)  := sorry --non-trivial
lemma new_lemma_1638 (h0 : functor.add_const (add_monoid (has_to_string linarith.comp)) name) : @add_monoid.fg.{0} (has_to_string.{0} linarith.comp) (@functor.add_const.run.{0 0} (add_monoid.{0} (has_to_string.{0} linarith.comp)) name h0)  := sorry --non-trivial
lemma new_lemma_1639 (h0 : ordered_comm_monoid (boolean_algebra.core (has_add (ring pos)))) : has_exists_mul_of_le (boolean_algebra.core (has_add (ring pos))) := sorry --non-trivial
lemma new_lemma_1640 (h0 : functor.add_const (topological_space (cancel_monoid pos)) pos) : @sequential_space.{0} (cancel_monoid.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (cancel_monoid.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_1641 (h0 : uniform_space (add_semigroup empty)) : complete_space (add_semigroup empty) := sorry --non-trivial
lemma new_lemma_1642 (h0 : add_monoid (option (semiring congr_arg_kind))) : add_monoid.fg (option (semiring congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_1643 (h0 : not (complete_lattice Type -> false)) : @is_compactly_generated.{1} Type (@classical.by_contradiction'.{2} (complete_lattice.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_1644 (h0 : function.extfun Type topological_space) : @topological_space.separable_space.{0} (with_bot.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (with_bot.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_1645 (h0 : ring (has_norm (semiring (has_top (semiring congr_arg_kind))))) : is_domain (has_norm (semiring (has_top (semiring congr_arg_kind)))) := sorry --non-trivial
lemma new_lemma_1646 (h0 : function.extfun (Type 1) complete_lattice) : @is_compactly_generated.{1} (canonically_ordered_monoid.{1} Type) (@function.extfun_app.{3 2} (Type 1) complete_lattice.{1} h0 (canonically_ordered_monoid.{1} Type))  := sorry --non-trivial
lemma new_lemma_1647 (h0 : functor.add_const (group (comm_group linarith.comp)) environment.implicit_infer_kind) : @is_simple_group.{0} (comm_group.{0} linarith.comp) (@functor.add_const.run.{0 0} (group.{0} (comm_group.{0} linarith.comp)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_1648 (h0 : functor.add_const (topological_space (add_cancel_monoid empty)) empty) : @loc_path_connected_space.{0} (add_cancel_monoid.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (add_cancel_monoid.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_1649 (h0 : group (random_gen unsigned)) : group.fg (random_gen unsigned) := sorry --non-trivial
lemma new_lemma_1650 (h0 : complete_lattice (has_pos_part (has_Inf Type))) : is_atomistic (has_pos_part (has_Inf Type)) := sorry --non-trivial
lemma new_lemma_1651 (h0 : functor.add_const (add_monoid (canonically_ordered_comm_semiring Type)) pos) : @add_monoid.fg.{1} (canonically_ordered_comm_semiring.{1} Type) (@functor.add_const.run.{1 0} (add_monoid.{1} (canonically_ordered_comm_semiring.{1} Type)) pos h0)  := sorry --non-trivial
lemma new_lemma_1652 (h0 : ereal -> ereal -> ereal) : is_associative ereal h0 := sorry --non-trivial
lemma new_lemma_1653 (h0 : functor.add_const (topological_space (has_to_string Type)) (normed_comm_ring pos)) : @sequential_space.{1} (has_to_string.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (has_to_string.{1} Type)) (normed_comm_ring.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_1654 (h0 : ordered_add_comm_monoid (has_zero ennreal)) : archimedean (has_zero ennreal) := sorry --non-trivial
lemma new_lemma_1655 (h0 : monoid (sub_neg_monoid (has_Inf name))) : monoid.fg (sub_neg_monoid (has_Inf name)) := sorry --non-trivial
lemma new_lemma_1656 (h0 : finset (canonically_ordered_comm_semiring unsigned)) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_1657 (h0 : topological_space (has_norm (random_gen (has_norm (semiring num))))) : totally_separated_space (has_norm (random_gen (has_norm (semiring num)))) := sorry --non-trivial
lemma new_lemma_1658 (h0 : ring (normed_field (random_gen (has_nnnorm linarith.comp_source)))) : strong_rank_condition (normed_field (random_gen (has_nnnorm linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_1659 (h1 : topological_space (semi_normed_ring linarith.ineq)) (h2 : set (semi_normed_ring linarith.ineq)) : is_preirreducible h2 := sorry --non-trivial
lemma new_lemma_1660 (h0 : topological_space (has_ssubset (has_ssubset fun_info))) : totally_disconnected_space (has_ssubset (has_ssubset fun_info)) := sorry --non-trivial
lemma new_lemma_1661 (h0 : measurable_space (plift empty)) (h1 : measure_theory.measure (plift empty)) : measure_theory.measure.is_complete h1 := sorry --non-trivial
lemma new_lemma_1662 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : countable_Inter_filter (function.extfun_app (function.extfun_app h0 filter) (has_to_string name)) := sorry --non-trivial
lemma new_lemma_1663 (h0 : functor.add_const (cancel_comm_monoid_with_zero (has_neg name)) (finset ennreal)) : @unique_factorization_monoid.{0} (has_neg.{0} name) (@functor.add_const.run.{0 0} (cancel_comm_monoid_with_zero.{0} (has_neg.{0} name)) (finset.{0} ennreal) h0)  := sorry --non-trivial
lemma new_lemma_1664 (h1 : complete_lattice (has_compl (has_compl (nondiscrete_normed_field enat)))) : is_compactly_generated (has_compl (has_compl (nondiscrete_normed_field enat))) := sorry --non-trivial
lemma new_lemma_1665 (h0 : group (semi_normed_ring (uniform_space (has_nnnorm char)))) : is_cyclic (semi_normed_ring (uniform_space (has_nnnorm char))) := sorry --non-trivial
lemma new_lemma_1666 (h1 : topological_space (with_bot linarith.ineq)) : t0_space (with_bot linarith.ineq) := sorry --non-trivial
lemma new_lemma_1667 (h0 : function.extfun Type topological_space) : @normal_space.{0} (option.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (option.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_1668 (h0 : topological_space (linear_ordered_comm_monoid_with_zero empty)) : normal_space (linear_ordered_comm_monoid_with_zero empty) := sorry --non-trivial
lemma new_lemma_1669 (h0 : complete_lattice (normed_field (has_nnnorm reducibility_hints))) : complete_lattice.is_Sup_finite_compact (normed_field (has_nnnorm reducibility_hints)) := sorry --non-trivial
lemma new_lemma_1670 (h0 : uniform_space (has_neg (has_neg Type))) : complete_space (has_neg (has_neg Type)) := sorry --non-trivial
lemma new_lemma_1671 (h0 : not (ring (denumerable to_additive.value_type) -> false)) : @rank_condition.{0} (denumerable.{0} to_additive.value_type) (@classical.by_contradiction'.{1} (ring.{0} (denumerable.{0} to_additive.value_type)) h0)  := sorry --non-trivial
lemma new_lemma_1672 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @locally_compact_space.{0} (option.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (option.{0} pos))  := sorry --non-trivial
lemma new_lemma_1673 (h0 : topological_space (has_norm (random_gen (has_inv (has_inv fun_info))))) : path_connected_space (has_norm (random_gen (has_inv (has_inv fun_info)))) := sorry --non-trivial
lemma new_lemma_1674 (h0 : functor.add_const (uniform_space (normed_comm_ring pos)) (ring environment.implicit_infer_kind)) : @complete_space.{0} (normed_comm_ring.{0} pos) (@functor.add_const.run.{0 0} (uniform_space.{0} (normed_comm_ring.{0} pos)) (ring.{0} environment.implicit_infer_kind) h0)  := sorry --non-trivial
lemma new_lemma_1675 (h0 : ordered_add_comm_monoid (boolean_algebra (has_nndist (has_add linarith.comp)))) : archimedean (boolean_algebra (has_nndist (has_add linarith.comp))) := sorry --non-trivial
lemma new_lemma_1676 (h0 : ring (ring (finset (has_neg_part unsigned)))) : is_domain (ring (finset (has_neg_part unsigned))) := sorry --non-trivial
lemma new_lemma_1677 (h0 : complete_lattice (has_add (mul_one_class environment.implicit_infer_kind))) : is_compactly_generated (has_add (mul_one_class environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_1678 (h0 : function.extfun Type finset) : finset.nonempty (function.extfun_app h0 (normed_comm_ring pos)) := sorry --non-trivial
lemma new_lemma_1679 (h0 : group (simple_graph (option unsigned))) : is_cyclic (simple_graph (option unsigned)) := sorry --non-trivial
lemma new_lemma_1680 (h0 : ring (has_le std_gen)) : is_domain (has_le std_gen) := sorry --non-trivial
lemma new_lemma_1681 (h0 : functor.add_const (function.extfun Type ring) linarith.comp) : @strong_rank_condition.{0} (ring.{0} linarith.comp) (@function.extfun_app.{2 1} Type ring.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type ring.{0}) linarith.comp h0) (ring.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_1682 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @complete_space.{0} (has_bot.{0} real) (@function.extfun_app.{2 1} Type uniform_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 uniform_space.{0}) (has_bot.{0} real))  := sorry --non-trivial
lemma new_lemma_1683 (h0 : topological_space (add_monoid (has_ssubset (has_nnnorm linarith.comp_source)))) : t0_space (add_monoid (has_ssubset (has_nnnorm linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_1684 (h0 : topological_space (measurable_space string_imp)) (h1 : set (measurable_space string_imp)) : is_totally_separated h1 := sorry --non-trivial
lemma new_lemma_1685 (h0 : ring (ordered_comm_ring (finset (ring linarith.comp)))) : strong_rank_condition (ordered_comm_ring (finset (ring linarith.comp))) := sorry --non-trivial
lemma new_lemma_1686 (h0 : functor.add_const (add_group Type) linarith.comp) : @is_add_cyclic.{1} Type (@functor.add_const.run.{1 0} (add_group.{1} Type) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_1687 (h0 : topological_space (has_to_string (option (ring unsigned)))) : t0_space (has_to_string (option (ring unsigned))) := sorry --non-trivial
lemma new_lemma_1688 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @separated_space.{0} (has_union.{0} empty) (@function.extfun_app.{2 1} Type uniform_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 uniform_space.{0}) (has_union.{0} empty))  := sorry --non-trivial
lemma new_lemma_1689 (h0 : function.extfun nat fin) : @is_principal_ideal_ring.{0} (comm_semigroup.{0} real) (@matrix.vec_empty.{0} (ring.{0} (comm_semigroup.{0} real)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_1690 (h0 : functor.add_const (function.extfun (Type 1) monoid) Type) : @monoid.fg.{1} (has_Inf.{1} Type) (@function.extfun_app.{3 2} (Type 1) monoid.{1} (@functor.add_const.run.{2 1} (function.extfun.{3 2} (Type 1) monoid.{1}) Type h0) (has_Inf.{1} Type))  := sorry --non-trivial
lemma new_lemma_1691 (h0 : set (has_le environment.projection_info)) : set.subsingleton h0 := sorry --non-trivial
lemma new_lemma_1692 (h2 : topological_space (has_add (has_ssubset to_additive.value_type))) : t0_space (has_add (has_ssubset to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_1693 (h0 : semiring (has_inter unsigned)) : is_noetherian_ring (has_inter unsigned) := sorry --non-trivial
lemma new_lemma_1694 (h0 : topological_space (has_top (random_gen (with_bot string_imp)))) : locally_compact_space (has_top (random_gen (with_bot string_imp))) := sorry --non-trivial
lemma new_lemma_1695 (h0 : topological_space (has_Inf (has_add (has_add pos)))) : totally_disconnected_space (has_Inf (has_add (has_add pos))) := sorry --non-trivial
lemma new_lemma_1696 (h0 : topological_space (canonically_ordered_comm_semiring linarith.comp)) : t0_space (canonically_ordered_comm_semiring linarith.comp) := sorry --non-trivial
lemma new_lemma_1697 (h0 : group (complete_linear_order empty)) : is_cyclic (complete_linear_order empty) := sorry --non-trivial
lemma new_lemma_1698 (h0 : uniform_space (measurable_space (has_norm congr_arg_kind))) : complete_space (measurable_space (has_norm congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_1699 (h0 : complete_lattice (has_emptyc (random_gen fun_info))) : is_compactly_generated (has_emptyc (random_gen fun_info)) := sorry --non-trivial
lemma new_lemma_1700 (h0 : topological_space (comm_group (option (has_neg_part ennreal)))) : totally_disconnected_space (comm_group (option (has_neg_part ennreal))) := sorry --non-trivial
lemma new_lemma_1701 (h0 : topological_space (boolean_algebra (has_neg pos))) : regular_space (boolean_algebra (has_neg pos)) := sorry --non-trivial
lemma new_lemma_1702 (h1 : add_group (uniform_space to_additive.value_type)) : is_add_cyclic (uniform_space to_additive.value_type) := sorry --non-trivial
lemma new_lemma_1703 (h0 : has_mem.mem topological_space has_emptyc.emptyc) : @t0_space.{0} (has_norm.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) topological_space.{0} h0) (has_norm.{0} num))  := sorry --non-trivial
lemma new_lemma_1704 (h0 : topological_space (boolean_algebra (boolean_algebra.core unsigned))) : normal_space (boolean_algebra (boolean_algebra.core unsigned)) := sorry --non-trivial
lemma new_lemma_1705 (h0 : fin has_zero.zero) : @locally_compact_space.{0} (has_add.{0} real) (@matrix.vec_empty.{0} (topological_space.{0} (has_add.{0} real)) h0)  := sorry --non-trivial
lemma new_lemma_1706 (h0 : list (encodable string_imp)) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_1707 (h0 : topological_space (complete_distrib_lattice (option ennreal))) : preconnected_space (complete_distrib_lattice (option ennreal)) := sorry --non-trivial
lemma new_lemma_1708 (h0 : function.extfun (Type -> Type) (function.extfun Type)) (h1 : not (has_mul (measure_theory.measure_space empty) -> false)) : @has_measurable_mul₂.{0} (measure_theory.measure_space.{0} empty) (@function.extfun_app.{2 1} Type measurable_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 measurable_space.{0}) (measure_theory.measure_space.{0} empty)) (@classical.by_contradiction'.{1} (has_mul.{0} (measure_theory.measure_space.{0} empty)) h1)  := sorry --non-trivial
lemma new_lemma_1709 (h0 : topological_space (has_Inf Type)) : sequential_space (has_Inf Type) := sorry --non-trivial
lemma new_lemma_1710 (h0 : functor.add_const (list (add_cancel_monoid Type)) (has_neg Type)) : list.nodup (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_1711 (h0 : topological_space (partial_order (semiring (semiring (semiring unsigned))))) : totally_separated_space (partial_order (semiring (semiring (semiring unsigned)))) := sorry --non-trivial
lemma new_lemma_1712 (h0 : functor.add_const (topological_space (boolean_algebra.core unsigned)) Type) : @totally_disconnected_space.{0} (boolean_algebra.core.{0} unsigned) (@functor.add_const.run.{0 1} (topological_space.{0} (boolean_algebra.core.{0} unsigned)) Type h0)  := sorry --non-trivial
lemma new_lemma_1713 (h0 : ring (normed_group (has_top (has_top fun_info)))) : is_domain (normed_group (has_top (has_top fun_info))) := sorry --non-trivial
lemma new_lemma_1714 (h0 : prod (has_to_string num) (has_to_string num)) : id_rel h0 := sorry --non-trivial
lemma new_lemma_1715 (h0 : complete_lattice (distrib (mul_one_class char))) : is_compactly_generated (distrib (mul_one_class char)) := sorry --non-trivial
lemma new_lemma_1716 (h0 : add_monoid (ordered_comm_ring (has_bot (ordered_comm_monoid real)))) : add_monoid.fg (ordered_comm_ring (has_bot (ordered_comm_monoid real))) := sorry --non-trivial
lemma new_lemma_1717 (h0 : not (function.extfun Type uniform_space -> false)) : complete_space empty := sorry --non-trivial
lemma new_lemma_1718 (h0 : monoid (with_one (semiring unsigned))) : monoid.fg (with_one (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_1719 (h0 : functor.add_const (group (ring pos)) Type) : @is_simple_group.{0} (ring.{0} pos) (@functor.add_const.run.{0 1} (group.{0} (ring.{0} pos)) Type h0)  := sorry --non-trivial
lemma new_lemma_1720 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : finset.nonempty (function.extfun_app (function.extfun_app h0 finset) (semigroup pos)) := sorry --non-trivial
lemma new_lemma_1721 (h0 : topological_space (canonically_ordered_comm_semiring (finset linarith.comp))) : locally_compact_space (canonically_ordered_comm_semiring (finset linarith.comp)) := sorry --non-trivial
lemma new_lemma_1722 (h0 : semiring (ordered_comm_ring (has_add (has_add (has_add real))))) : is_noetherian_ring (ordered_comm_ring (has_add (has_add (has_add real)))) := sorry --non-trivial
lemma new_lemma_1723 (h0 : functor.add_const (ring (finset environment.implicit_infer_kind)) name) : @is_domain.{0} (finset.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (ring.{0} (finset.{0} environment.implicit_infer_kind)) name h0)  := sorry --non-trivial
lemma new_lemma_1724 (h0 : function.extfun Type topological_space) : @discrete_topology.{0} (has_to_string.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_to_string.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_1725 (h0 : functor.add_const (complete_lattice (finset pos)) unsigned) : @complete_lattice.is_Sup_finite_compact.{0} (finset.{0} pos) (@functor.add_const.run.{0 0} (complete_lattice.{0} (finset.{0} pos)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_1726 (h0 : not (topological_space linarith.comp_source -> false)) : @totally_separated_space.{0} linarith.comp_source (@classical.by_contradiction'.{1} (topological_space.{0} linarith.comp_source) h0)  := sorry --non-trivial
lemma new_lemma_1727 (h0 : functor.add_const (add_monoid (simple_graph linarith.comp)) linarith.comp) : @add_monoid.fg.{0} (simple_graph.{0} linarith.comp) (@functor.add_const.run.{0 0} (add_monoid.{0} (simple_graph.{0} linarith.comp)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_1728 (h0 : group (has_inv to_additive.value_type)) : is_cyclic (has_inv to_additive.value_type) := sorry --non-trivial
lemma new_lemma_1729 (h0 : function.extfun Type uniform_space) : @complete_space.{0} (@id.{2} Type (has_top.{0} num)) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (@id.{2} Type (has_top.{0} num)))  := sorry --non-trivial
lemma new_lemma_1730 (h0 : group (comm_semigroup (has_Inf Type))) : group.fg (comm_semigroup (has_Inf Type)) := sorry --non-trivial
lemma new_lemma_1731 (h0 : topological_space (ordered_comm_monoid linarith.comp)) : t1_space (ordered_comm_monoid linarith.comp) := sorry --non-trivial
lemma new_lemma_1732 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_compactly_generated.{0} (mul_zero_class.{0} empty) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (mul_zero_class.{0} empty))  := sorry --non-trivial
lemma new_lemma_1733 (h0 : ordered_comm_monoid (canonically_linear_ordered_monoid name)) : has_exists_mul_of_le (canonically_linear_ordered_monoid name) := sorry --non-trivial
lemma new_lemma_1734 (h0 : not (ring (linear_ordered_semiring empty) -> false)) : @is_domain.{0} (linear_ordered_semiring.{0} empty) (@classical.by_contradiction'.{1} (ring.{0} (linear_ordered_semiring.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_1735 (h0 : not (function.extfun Type ring -> false)) : @is_domain.{0} (add_group.{0} unsigned) (@function.extfun_app.{2 1} Type ring.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type ring.{0}) h0) (add_group.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_1736 (h0 : not (functor.add_const Prop (semiring num) -> false)) : functor.add_const.run (classical.by_contradiction' h0) := sorry --non-trivial
lemma new_lemma_1737 (h0 : function.extfun (Type 1) monoid) : @monoid.fg.{1} (boolean_algebra.core.{1} Type) (@function.extfun_app.{3 2} (Type 1) monoid.{1} h0 (boolean_algebra.core.{1} Type))  := sorry --non-trivial
lemma new_lemma_1738 (h0 : functor.add_const (function.extfun Type ordered_comm_monoid) pos) : @has_exists_mul_of_le.{0} (finset.{0} linarith.comp) (@function.extfun_app.{2 1} Type ordered_comm_monoid.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type ordered_comm_monoid.{0}) pos h0) (finset.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_1739 (h0 : has_mem.mem topological_space has_emptyc.emptyc) : @totally_separated_space.{0} (has_top.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) topological_space.{0} h0) (has_top.{0} num))  := sorry --non-trivial
lemma new_lemma_1740 (h0 : group (has_neg (pseudo_metric_space (option num)))) : is_simple_group (has_neg (pseudo_metric_space (option num))) := sorry --non-trivial
lemma new_lemma_1741 (h1 : group (id linarith.comp)) : group.fg (id linarith.comp) := sorry --non-trivial
lemma new_lemma_1742 (h0 : ring (boolean_algebra (ordered_ring linarith.comp))) : is_domain (boolean_algebra (ordered_ring linarith.comp)) := sorry --non-trivial
lemma new_lemma_1743 (h0 : topological_space (has_pos_part (boolean_algebra Type))) : regular_space (has_pos_part (boolean_algebra Type)) := sorry --non-trivial
lemma new_lemma_1744 (h0 : complete_lattice (has_inter (option num))) : complete_lattice.is_Sup_finite_compact (has_inter (option num)) := sorry --non-trivial
lemma new_lemma_1745 (h1 : ring (denumerable (random_gen (random_gen (has_ssubset to_additive.value_type))))) : strong_rank_condition (denumerable (random_gen (random_gen (has_ssubset to_additive.value_type)))) := sorry --non-trivial
lemma new_lemma_1746 (h0 : topological_space (has_add (has_pos_part (ring linarith.comp)))) : t0_space (has_add (has_pos_part (ring linarith.comp))) := sorry --non-trivial
lemma new_lemma_1747 (h0 : group (normed_group (has_top linarith.comp_source))) : group.fg (normed_group (has_top linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_1748 (h0 : function.extfun Type uniform_space) : @complete_space.{0} (@id.{2} Type num) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (@id.{2} Type num))  := sorry --non-trivial
lemma new_lemma_1749 (h0 : functor.add_const (topological_space (complete_distrib_lattice pos)) linarith.comp) : @totally_separated_space.{0} (complete_distrib_lattice.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (complete_distrib_lattice.{0} pos)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_1750 (h0 : functor.add_const (semiring (comm_group name)) Type) : @is_noetherian_ring.{0} (comm_group.{0} name) (@functor.add_const.run.{0 1} (semiring.{0} (comm_group.{0} name)) Type h0)  := sorry --non-trivial
lemma new_lemma_1751 (h0 : function.extfun Type group) : @group.fg.{0} (boolean_algebra.core.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type group.{0} h0 (boolean_algebra.core.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_1752 (h0 : functor.add_const (ring (linear_order unsigned)) congr_arg_kind) : @strong_rank_condition.{0} (linear_order.{0} unsigned) (@functor.add_const.run.{0 0} (ring.{0} (linear_order.{0} unsigned)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_1753 (h0 : functor.add_const (ordered_comm_monoid (comm_group linarith.comp)) (has_add Type)) : @has_exists_mul_of_le.{0} (comm_group.{0} linarith.comp) (@functor.add_const.run.{0 1} (ordered_comm_monoid.{0} (comm_group.{0} linarith.comp)) (has_add.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_1754 (h0 : group (semiring (random_gen (random_gen linarith.comp_source)))) : is_cyclic (semiring (random_gen (random_gen linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_1755 (h0 : functor.add_const (filter (boolean_algebra pos)) name) : countable_Inter_filter (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_1756 (h0 : functor.add_const (topological_space (ordered_comm_monoid linarith.comp)) Type) : @loc_path_connected_space.{0} (ordered_comm_monoid.{0} linarith.comp) (@functor.add_const.run.{0 1} (topological_space.{0} (ordered_comm_monoid.{0} linarith.comp)) Type h0)  := sorry --non-trivial
lemma new_lemma_1757 (h0 : complete_lattice (left_cancel_monoid unsigned)) : is_compactly_generated (left_cancel_monoid unsigned) := sorry --non-trivial
lemma new_lemma_1758 (h0 : topological_space (has_add (has_add linarith.comp))) : totally_disconnected_space (has_add (has_add linarith.comp)) := sorry --non-trivial
lemma new_lemma_1759 (h0 : function.extfun Type (prod (canonically_ordered_comm_semiring empty))) : id_rel (function.extfun_app h0 (canonically_ordered_comm_semiring empty)) := sorry --non-trivial
lemma new_lemma_1760 (h0 : not (function.extfun Type topological_space -> false)) : @normal_space.{0} (has_top.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (has_top.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_1761 (h1 : list (with_bot string_imp)) : list.nodup h1 := sorry --non-trivial
lemma new_lemma_1762 (h0 : functor.add_const (uniform_space Type) (finset pos)) : @separated_space.{1} Type (@functor.add_const.run.{1 0} (uniform_space.{1} Type) (finset.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_1763 (h0 : functor.add_const (ordered_add_comm_monoid (has_dist unsigned)) num) : @archimedean.{0} (has_dist.{0} unsigned) (@functor.add_const.run.{0 0} (ordered_add_comm_monoid.{0} (has_dist.{0} unsigned)) num h0)  := sorry --non-trivial
lemma new_lemma_1764 (h0 : ordered_comm_monoid (has_nndist (has_pos_part (has_Inf (metric_space pos))))) : has_exists_mul_of_le (has_nndist (has_pos_part (has_Inf (metric_space pos)))) := sorry --non-trivial
lemma new_lemma_1765 (h3 : ring (add_comm_semigroup fun_info)) : strong_rank_condition (add_comm_semigroup fun_info) := sorry --non-trivial
lemma new_lemma_1766 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @locally_compact_space.{0} (ring.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (ring.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_1767 (h0 : add_monoid (partial_order (ordered_ring empty))) : add_monoid.fg (partial_order (ordered_ring empty)) := sorry --non-trivial
lemma new_lemma_1768 (h0 : ordered_add_comm_monoid (ordered_comm_monoid (has_bot (sub_neg_monoid (sub_neg_monoid real))))) : archimedean (ordered_comm_monoid (has_bot (sub_neg_monoid (sub_neg_monoid real)))) := sorry --non-trivial
lemma new_lemma_1769 (h0 : ring (comm_ring (has_lt (mul_one_class string_imp)))) : strong_rank_condition (comm_ring (has_lt (mul_one_class string_imp))) := sorry --non-trivial
lemma new_lemma_1770 (h0 : not (complete_lattice (normed_field linarith.comp_source) -> false)) : @is_compactly_generated.{0} (normed_field.{0} linarith.comp_source) (@classical.by_contradiction'.{1} (complete_lattice.{0} (normed_field.{0} linarith.comp_source)) h0)  := sorry --non-trivial
lemma new_lemma_1771 (h0 : complete_lattice (boolean_algebra real)) : is_atomistic (boolean_algebra real) := sorry --non-trivial
lemma new_lemma_1772 (h0 : topological_space (normed_group (has_top (has_top linarith.comp_source)))) : t0_space (normed_group (has_top (has_top linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_1773 (h0 : ordered_comm_monoid (ordered_comm_ring (has_Inf (ring (has_nndist Type))))) : has_exists_mul_of_le (ordered_comm_ring (has_Inf (ring (has_nndist Type)))) := sorry --non-trivial
lemma new_lemma_1774 (h0 : functor.add_const (topological_space (add_comm_monoid Type)) Type) : @totally_disconnected_space.{1} (add_comm_monoid.{1} Type) (@functor.add_const.run.{1 1} (topological_space.{1} (add_comm_monoid.{1} Type)) Type h0)  := sorry --non-trivial
lemma new_lemma_1775 (h0 : topological_space (comm_group (has_neg_part (finset (has_to_string pos))))) : discrete_topology (comm_group (has_neg_part (finset (has_to_string pos)))) := sorry --non-trivial
lemma new_lemma_1776 (h0 : filter (random_gen (has_norm (random_gen linarith.comp_source)))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_1777 (h0 : function.extfun (finset (Type -> Type)) (has_mem.mem topological_space)) : @totally_separated_space.{0} congr_arg_kind (@function.extfun_app.{2 1} Type topological_space.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) topological_space.{0} (@function.extfun_app.{2 0} (finset.{1} (Type → Type)) (@has_mem.mem.{1 1} (Type → Type) (finset.{1} (Type → Type)) (@finset.has_mem.{1} (Type → Type)) topological_space.{0}) h0 (@has_emptyc.emptyc.{1} (finset.{1} (Type → Type)) (@finset.has_emptyc.{1} (Type → Type))))) congr_arg_kind)  := sorry --non-trivial
lemma new_lemma_1778 (h0 : not (function.extfun Type monoid -> false)) : @monoid.fg.{0} (normed_group.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type monoid.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type monoid.{0}) h0) (normed_group.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_1779 (h0 : function.extfun Type (functor.add_const (topological_space (semiring empty)))) : @preirreducible_space.{0} (semiring.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (semiring.{0} empty)) congr_arg_kind (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (topological_space.{0} (semiring.{0} empty))) h0 congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_1780 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @strong_rank_condition.{0} (comm_semigroup.{0} real) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (comm_semigroup.{0} real))  := sorry --non-trivial
lemma new_lemma_1781 (h0 : function.extfun nat fin) : @separated_space.{0} (normed_lattice_add_comm_group.{0} linarith.comp) (@function.extfun_app.{2 1} Type uniform_space.{0} (@matrix.vec_empty.{1} (function.extfun.{2 1} Type uniform_space.{0}) (@matrix.vec_empty.{0} (fin (@has_zero.zero.{0} nat nat.has_zero)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))) (normed_lattice_add_comm_group.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_1782 (h0 : cancel_comm_monoid_with_zero (id num)) : unique_factorization_monoid (id num) := sorry --non-trivial
lemma new_lemma_1783 (h0 : semiring (has_edist (option (option unsigned)))) : is_noetherian_ring (has_edist (option (option unsigned))) := sorry --non-trivial
lemma new_lemma_1784 (h0 : topological_space (option (semiring (semiring (semiring num))))) : t0_space (option (semiring (semiring (semiring num)))) := sorry --non-trivial
lemma new_lemma_1785 (h1 : group (linear_ordered_semiring (has_norm fun_info))) : is_cyclic (linear_ordered_semiring (has_norm fun_info)) := sorry --non-trivial
lemma new_lemma_1786 (h0 : list (has_nndist (finset (finset linarith.comp)))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_1787 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @rank_condition.{0} (linear_ordered_comm_group.{0} unsigned) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (linear_ordered_comm_group.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_1788 (h0 : functor.add_const (topological_space (boolean_algebra.core empty)) empty) : @preirreducible_space.{0} (boolean_algebra.core.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (boolean_algebra.core.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_1789 (h0 : functor.add_const (function.extfun (Type 1) topological_space) environment.implicit_infer_kind) : @locally_compact_space.{1} (semigroup.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) topological_space.{1}) environment.implicit_infer_kind h0) (semigroup.{1} Type))  := sorry --non-trivial
lemma new_lemma_1790 (h0 : list (mul_zero_class (semiring empty))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_1791 (h0 : group (ordered_comm_ring (ordered_ring (ordered_ring Type)))) : is_cyclic (ordered_comm_ring (ordered_ring (ordered_ring Type))) := sorry --non-trivial
lemma new_lemma_1792 (h0 : functor.add_const (topological_space (boolean_algebra.core environment.implicit_infer_kind)) (has_neg name)) : @topological_space.separable_space.{0} (boolean_algebra.core.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (boolean_algebra.core.{0} environment.implicit_infer_kind)) (has_neg.{0} name) h0)  := sorry --non-trivial
lemma new_lemma_1793 (h0 : functor.add_const (topological_space (has_to_string linarith.comp)) name) : @path_connected_space.{0} (has_to_string.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (has_to_string.{0} linarith.comp)) name h0)  := sorry --non-trivial
lemma new_lemma_1794 (h0 : cancel_comm_monoid_with_zero (semigroup (finset (has_nndist (finset pos))))) : unique_factorization_monoid (semigroup (finset (has_nndist (finset pos)))) := sorry --non-trivial
lemma new_lemma_1795 (h0 : function.extfun Type ordered_add_comm_monoid) : @archimedean.{0} (pseudo_metric_space.{0} name) (@function.extfun_app.{2 1} Type ordered_add_comm_monoid.{0} h0 (pseudo_metric_space.{0} name))  := sorry --non-trivial
lemma new_lemma_1796 (h0 : function.extfun (Type 1) ring) : @rank_condition.{1} (add_comm_monoid.{1} Type) (@function.extfun_app.{3 2} (Type 1) ring.{1} h0 (add_comm_monoid.{1} Type))  := sorry --non-trivial
lemma new_lemma_1797 (h0 : uniform_space (has_neg (option name))) : separated_space (has_neg (option name)) := sorry --non-trivial
lemma new_lemma_1798 (h0 : topological_space (has_nndist (add_comm_monoid Type))) : topological_space.separable_space (has_nndist (add_comm_monoid Type)) := sorry --non-trivial
lemma new_lemma_1799 (h2 h3 : topological_space char) (h4 : char -> char) : closed_embedding h4 := sorry --non-trivial
lemma new_lemma_1800 (h0 : add_monoid (semigroup (finset linarith.comp))) : add_monoid.fg (semigroup (finset linarith.comp)) := sorry --non-trivial
lemma new_lemma_1801 (h0 : functor.add_const (topological_space (cancel_monoid name)) Type) : @regular_space.{0} (cancel_monoid.{0} name) (@functor.add_const.run.{0 1} (topological_space.{0} (cancel_monoid.{0} name)) Type h0)  := sorry --non-trivial
lemma new_lemma_1802 (h0 : topological_space (group_with_zero empty)) : loc_path_connected_space (group_with_zero empty) := sorry --non-trivial
lemma new_lemma_1803 (h0 : topological_space (has_edist (semiring (semiring num)))) : totally_separated_space (has_edist (semiring (semiring num))) := sorry --non-trivial
lemma new_lemma_1804 (h0 : functor.add_const (topological_space (has_zero environment.implicit_infer_kind)) environment.implicit_infer_kind) : @topological_space.separable_space.{0} (has_zero.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (has_zero.{0} environment.implicit_infer_kind)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_1805 (h0 : functor.add_const (ordered_comm_monoid (comm_group unsigned)) name) : @has_exists_mul_of_le.{0} (comm_group.{0} unsigned) (@functor.add_const.run.{0 0} (ordered_comm_monoid.{0} (comm_group.{0} unsigned)) name h0)  := sorry --non-trivial
lemma new_lemma_1806 (h0 : add_group (add_comm_monoid (comm_group pos))) : is_add_cyclic (add_comm_monoid (comm_group pos)) := sorry --non-trivial
lemma new_lemma_1807 (h0 : group (finset (add_left_cancel_monoid linarith.comp))) : is_simple_group (finset (add_left_cancel_monoid linarith.comp)) := sorry --non-trivial
lemma new_lemma_1808 (h0 : add_group (mul_zero_class (semiring (semiring congr_arg_kind)))) : is_add_cyclic (mul_zero_class (semiring (semiring congr_arg_kind))) := sorry --non-trivial
lemma new_lemma_1809 (h0 : has_mem.mem (metric_space linarith.comp) has_emptyc.emptyc) : @discrete_topology.{0} (metric_space.{0} linarith.comp) (@finset.pi.empty.{1 0} Type topological_space.{0} (metric_space.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_1810 (h0 : filter (has_top (with_one string_imp))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_1811 (h0 : complete_lattice (topological_space (random_gen (random_gen string_imp)))) : complete_lattice.is_Sup_finite_compact (topological_space (random_gen (random_gen string_imp))) := sorry --non-trivial
lemma new_lemma_1812 (h1 : complete_lattice linarith.ineq) : complete_lattice.is_Sup_finite_compact linarith.ineq := sorry --non-trivial
lemma new_lemma_1813 (h0 : not (function.extfun Type topological_space -> false)) : locally_compact_space empty := sorry --non-trivial
lemma new_lemma_1814 (h0 : topological_space (add_group (random_gen empty))) : irreducible_space (add_group (random_gen empty)) := sorry --non-trivial
lemma new_lemma_1815 (h0 : not (monoid (semiring num) -> false)) : @monoid.fg.{0} (semiring.{0} num) (@classical.by_contradiction'.{1} (monoid.{0} (semiring.{0} num)) h0)  := sorry --non-trivial
lemma new_lemma_1816 (h0 : not (function.extfun Type uniform_space -> false)) : @separated_space.{0} (with_bot.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type uniform_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type uniform_space.{0}) h0) (with_bot.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_1817 (h0 : topological_space (semigroup Type)) : locally_compact_space (semigroup Type) := sorry --non-trivial
lemma new_lemma_1818 (h0 : function.extfun (finset (Type -> Type)) (has_mem.mem topological_space)) : @totally_disconnected_space.{0} string_imp (@function.extfun_app.{2 1} Type topological_space.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) topological_space.{0} (@function.extfun_app.{2 0} (finset.{1} (Type → Type)) (@has_mem.mem.{1 1} (Type → Type) (finset.{1} (Type → Type)) (@finset.has_mem.{1} (Type → Type)) topological_space.{0}) h0 (@has_emptyc.emptyc.{1} (finset.{1} (Type → Type)) (@finset.has_emptyc.{1} (Type → Type))))) string_imp)  := sorry --non-trivial
lemma new_lemma_1819 (h0 : monoid (has_one congr_arg_kind)) : monoid.fg (has_one congr_arg_kind) := sorry --non-trivial
lemma new_lemma_1820 (h0 : functor.add_const (filter (has_neg_part pos)) linarith.comp) : filter.ne_bot (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_1821 (h0 : ring (add_cancel_monoid (comm_group Type))) : rank_condition (add_cancel_monoid (comm_group Type)) := sorry --non-trivial
lemma new_lemma_1822 (h0 : functor.add_const (ring (has_neg_part name)) linarith.comp) : @is_domain.{0} (has_neg_part.{0} name) (@functor.add_const.run.{0 0} (ring.{0} (has_neg_part.{0} name)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_1823 (h0 : not (monoid (semiring linarith.ineq) -> false)) : @monoid.fg.{0} (semiring.{0} linarith.ineq) (@classical.by_contradiction'.{1} (monoid.{0} (semiring.{0} linarith.ineq)) h0)  := sorry --non-trivial
lemma new_lemma_1824 (h0 : topological_space (measurable_space (semiring unsigned))) : normal_space (measurable_space (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_1825 (h0 : list (has_add (add_cancel_monoid name))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_1826 (h0 : functor.add_const (uniform_space (add_cancel_monoid Type)) linarith.comp) : @complete_space.{1} (add_cancel_monoid.{1} Type) (@functor.add_const.run.{1 0} (uniform_space.{1} (add_cancel_monoid.{1} Type)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_1827 (h0 : group (boolean_algebra (comm_group pos))) : group.fg (boolean_algebra (comm_group pos)) := sorry --non-trivial
lemma new_lemma_1828 (h0 : functor.add_const (topological_space (boolean_algebra linarith.comp)) (has_add linarith.comp)) : @regular_space.{0} (boolean_algebra.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (boolean_algebra.{0} linarith.comp)) (has_add.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_1829 (h0 : topological_space (with_one (random_gen (random_gen to_additive.value_type)))) : totally_disconnected_space (with_one (random_gen (random_gen to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_1830 (h0 : topological_space (option congr_arg_kind)) : topological_space.separable_space (option congr_arg_kind) := sorry --non-trivial
lemma new_lemma_1831 (h0 : has_mem.mem Type has_emptyc.emptyc) : @group.fg.{1} Type (@finset.pi.empty.{2 1} (Type 1) group.{1} Type h0)  := sorry --non-trivial
lemma new_lemma_1832 (h0 : functor.add_const (function.extfun Type cancel_comm_monoid_with_zero) empty) : @unique_factorization_monoid.{0} (add_semigroup.{0} empty) (@function.extfun_app.{2 1} Type cancel_comm_monoid_with_zero.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type cancel_comm_monoid_with_zero.{0}) empty h0) (add_semigroup.{0} empty))  := sorry --non-trivial
lemma new_lemma_1833 (h0 : ordered_add_comm_monoid (has_add unsigned)) : archimedean (has_add unsigned) := sorry --non-trivial
lemma new_lemma_1834 (h0 : topological_space (add_cancel_monoid (has_add (has_add Type)))) : loc_path_connected_space (add_cancel_monoid (has_add (has_add Type))) := sorry --non-trivial
lemma new_lemma_1835 (h0 : monoid (add_comm_monoid (has_to_string (has_to_string pos)))) : monoid.fg (add_comm_monoid (has_to_string (has_to_string pos))) := sorry --non-trivial
lemma new_lemma_1836 (h0 : topological_space (uniform_space (random_gen (random_gen string_imp)))) : t0_space (uniform_space (random_gen (random_gen string_imp))) := sorry --non-trivial
lemma new_lemma_1837 (h0 : topological_space (linear_ordered_comm_ring (semiring (semiring (semiring empty))))) : t1_space (linear_ordered_comm_ring (semiring (semiring (semiring empty)))) := sorry --non-trivial
lemma new_lemma_1838 (h0 : complete_lattice (has_add (has_bot (has_add Type)))) : is_atomistic (has_add (has_bot (has_add Type))) := sorry --non-trivial
lemma new_lemma_1839 (h0 : add_monoid (ordered_comm_ring name)) : add_monoid.fg (ordered_comm_ring name) := sorry --non-trivial
lemma new_lemma_1840 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_compactly_generated.{0} (preorder.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (preorder.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_1841 (h0 : topological_space (ordered_comm_ring (finset (has_pos_part Type)))) : sequential_space (ordered_comm_ring (finset (has_pos_part Type))) := sorry --non-trivial
lemma new_lemma_1842 (h0 : topological_space (semiring congr_arg_kind)) : preirreducible_space (semiring congr_arg_kind) := sorry --non-trivial
lemma new_lemma_1843 (h0 : group (normed_comm_ring name)) : group.fg (normed_comm_ring name) := sorry --non-trivial
lemma new_lemma_1844 (h0 : not (uniform_space (comm_ring char) -> false)) : @complete_space.{0} (comm_ring.{0} char) (@classical.by_contradiction'.{1} (uniform_space.{0} (comm_ring.{0} char)) h0)  := sorry --non-trivial
lemma new_lemma_1845 (h0 : function.extfun Type complete_lattice) : @is_compactly_generated.{0} (normed_group.{0} linarith.ineq) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (normed_group.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_1846 (h0 : topological_space (ordered_comm_monoid (ring (ring Type)))) : normal_space (ordered_comm_monoid (ring (ring Type))) := sorry --non-trivial
lemma new_lemma_1847 (h0 : topological_space (has_neg (ring linarith.comp))) : t1_space (has_neg (ring linarith.comp)) := sorry --non-trivial
lemma new_lemma_1848 (h0 : topological_space (with_bot (random_gen (random_gen num)))) : discrete_topology (with_bot (random_gen (random_gen num))) := sorry --non-trivial
lemma new_lemma_1849 (h0 : ring (has_nndist (has_to_string unsigned))) : is_principal_ideal_ring (has_nndist (has_to_string unsigned)) := sorry --non-trivial
lemma new_lemma_1850 (h0 : add_group (boolean_algebra (has_neg (has_bot real)))) : is_add_cyclic (boolean_algebra (has_neg (has_bot real))) := sorry --non-trivial
lemma new_lemma_1851 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @preirreducible_space.{0} (has_neg.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_neg.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_1852 (h0 : functor.add_const (ordered_comm_monoid (ring name)) environment.implicit_infer_kind) : @has_exists_mul_of_le.{0} (ring.{0} name) (@functor.add_const.run.{0 0} (ordered_comm_monoid.{0} (ring.{0} name)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_1853 (h0 : topological_space (has_pos_part (has_to_string linarith.comp))) : path_connected_space (has_pos_part (has_to_string linarith.comp)) := sorry --non-trivial
lemma new_lemma_1854 (h1 : not (function.extfun Type topological_space -> false)) : @totally_separated_space.{0} (with_one.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h1) (with_one.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_1855 (h0 : group (has_emptyc (has_norm empty))) : is_cyclic (has_emptyc (has_norm empty)) := sorry --non-trivial
lemma new_lemma_1856 (h0 : functor.add_const (list (add_right_cancel_monoid unsigned)) unsigned) : list.nodup (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_1857 (h0 : group (has_nnnorm (has_nnnorm to_additive.value_type))) : is_cyclic (has_nnnorm (has_nnnorm to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_1858 (h0 : add_group (has_zero (option unsigned))) : is_add_cyclic (has_zero (option unsigned)) := sorry --non-trivial
lemma new_lemma_1859 (h0 : topological_space (canonically_ordered_monoid (has_pos_part (finset linarith.comp)))) : discrete_topology (canonically_ordered_monoid (has_pos_part (finset linarith.comp))) := sorry --non-trivial
lemma new_lemma_1860 (h0 : group (has_inv (has_nnnorm (random_gen linarith.comp_source)))) : group.fg (has_inv (has_nnnorm (random_gen linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_1861 (h0 : ordered_add_comm_monoid (comm_semigroup real)) : archimedean (comm_semigroup real) := sorry --non-trivial
lemma new_lemma_1862 (h0 : functor.add_const (filter (comm_group ennreal)) pos) : countable_Inter_filter (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_1863 (h0 : function.extfun Type ring) : @strong_rank_condition.{0} (semiring.{0} linarith.ineq) (@function.extfun_app.{2 1} Type ring.{0} h0 (semiring.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_1864 (h0 : finset (cancel_monoid (boolean_algebra.core pos))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_1865 (h1 : set (enat -> add_comm_semigroup char)) : set.separates_points h1 := sorry --non-trivial
lemma new_lemma_1866 (h0 : functor.add_const (function.extfun Type list) empty) : palindrome (function.extfun_app (functor.add_const.run h0) (has_dist unsigned)) := sorry --non-trivial
lemma new_lemma_1867 (h0 : ring (distrib (has_lt (has_nnnorm (has_nnnorm linarith.ineq))))) : is_domain (distrib (has_lt (has_nnnorm (has_nnnorm linarith.ineq)))) := sorry --non-trivial
lemma new_lemma_1868 (h0 : add_group (add_comm_semigroup (normed_field ereal))) : is_add_cyclic (add_comm_semigroup (normed_field ereal)) := sorry --non-trivial
lemma new_lemma_1869 (h0 : topological_space (semigroup (has_add pos))) : regular_space (semigroup (has_add pos)) := sorry --non-trivial
lemma new_lemma_1870 (h0 : topological_space (free_add_monoid empty)) : normal_space (free_add_monoid empty) := sorry --non-trivial
lemma new_lemma_1871 (h0 : function.extfun Type (functor.comp topological_space has_neg_part)) : @preirreducible_space.{0} (has_neg_part.{0} name) (@functor.comp.run.{0 0 0} topological_space.{0} has_neg_part.{0} name (@functor.comp.run.{0 0 0} topological_space.{0} has_neg_part.{0} name (@functor.comp.run.{0 0 0} topological_space.{0} has_neg_part.{0} name (@functor.comp.run.{0 0 0} topological_space.{0} has_neg_part.{0} name (@function.extfun_app.{2 1} Type (functor.comp.{0 0 0} topological_space.{0} has_neg_part.{0}) h0 name)))))  := sorry --non-trivial
lemma new_lemma_1872 (h1 : measurable_space (mul_one_class enat)) (h2 : measure_theory.measure (mul_one_class enat)) : measure_theory.is_finite_measure h2 := sorry --non-trivial
lemma new_lemma_1873 (h0 : function.extfun Type topological_space) : @preirreducible_space.{0} (has_bot.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_bot.{0} pos))  := sorry --non-trivial
lemma new_lemma_1874 (h0 : finset (comm_group (has_to_string ennreal))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_1875 (h0 : not (topological_space (add_right_cancel_monoid unsigned) -> false)) : @preirreducible_space.{0} (add_right_cancel_monoid.{0} unsigned) (@classical.by_contradiction'.{1} (topological_space.{0} (add_right_cancel_monoid.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_1876 (h0 : functor.add_const (function.extfun Type semiring) name) : @is_noetherian_ring.{0} (finset.{0} name) (@function.extfun_app.{2 1} Type semiring.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type semiring.{0}) name h0) (finset.{0} name))  := sorry --non-trivial
lemma new_lemma_1877 (h0 : uniform_space (linear_ordered_field (finset ennreal))) : separated_space (linear_ordered_field (finset ennreal)) := sorry --non-trivial
lemma new_lemma_1878 (h0 : group (preorder (semiring empty))) : normalizer_condition (preorder (semiring empty)) := sorry --non-trivial
lemma new_lemma_1879 (h0 : ring (canonically_ordered_monoid (ordered_comm_monoid real))) : rank_condition (canonically_ordered_monoid (ordered_comm_monoid real)) := sorry --non-trivial
lemma new_lemma_1880 (h0 : filter (comm_ring (comm_ring (with_one fun_info)))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_1881 (h0 : functor.comp topological_space add_cancel_monoid pos) : @path_connected_space.{0} (add_cancel_monoid.{0} pos) (@functor.comp.run.{0 0 0} topological_space.{0} add_cancel_monoid.{0} pos h0)  := sorry --non-trivial
lemma new_lemma_1882 (h0 : topological_space (has_union num)) : totally_disconnected_space (has_union num) := sorry --non-trivial
lemma new_lemma_1883 (h0 : group (has_one (has_top congr_arg_kind))) : normalizer_condition (has_one (has_top congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_1884 (h0 : functor.add_const (function.extfun (Type 1) ring) (has_neg Type)) : @is_domain.{1} (has_nndist.{1} Type) (@function.extfun_app.{3 2} (Type 1) ring.{1} (@functor.add_const.run.{2 1} (function.extfun.{3 2} (Type 1) ring.{1}) (has_neg.{1} Type) h0) (has_nndist.{1} Type))  := sorry --non-trivial
lemma new_lemma_1885 (h0 : topological_space (has_le fun_info)) : path_connected_space (has_le fun_info) := sorry --non-trivial
lemma new_lemma_1886 (h0 : ordered_add_comm_monoid (has_Inf (ordered_comm_ring pos))) : archimedean (has_Inf (ordered_comm_ring pos)) := sorry --non-trivial
lemma new_lemma_1887 (h0 : functor.add_const (topological_space (boolean_algebra.core Type)) Type) : @regular_space.{1} (boolean_algebra.core.{1} Type) (@functor.add_const.run.{1 1} (topological_space.{1} (boolean_algebra.core.{1} Type)) Type h0)  := sorry --non-trivial
lemma new_lemma_1888 (h2 : set (add_comm_semigroup (add_comm_semigroup std_gen) -> std_gen)) : set.separates_points h2 := sorry --non-trivial
lemma new_lemma_1889 (h0 : list (normed_group (has_inv (random_gen (random_gen fun_info))))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_1890 (h0 : add_monoid (has_pos_part (has_Inf Type))) : add_monoid.fg (has_pos_part (has_Inf Type)) := sorry --non-trivial
lemma new_lemma_1891 (h0 h1 : multiset (add_comm_semigroup ereal)) : multiset.disjoint h0 h1 := sorry --non-trivial
lemma new_lemma_1892 (h0 : add_group (mul_zero_class ennreal)) : is_add_cyclic (mul_zero_class ennreal) := sorry --non-trivial
lemma new_lemma_1893 (h0 : functor.add_const (finset (comm_group linarith.comp)) environment.implicit_infer_kind) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_1894 (h0 : group (has_neg_part (comm_group name))) : normalizer_condition (has_neg_part (comm_group name)) := sorry --non-trivial
lemma new_lemma_1895 (h0 : topological_space (measurable_space.dynkin_system (semiring (semiring unsigned)))) : discrete_topology (measurable_space.dynkin_system (semiring (semiring unsigned))) := sorry --non-trivial
lemma new_lemma_1896 (h2 : not (filter (fintype to_additive.value_type) -> false)) : filter.ne_bot (classical.by_contradiction' h2) := sorry --non-trivial
lemma new_lemma_1897 (h0 : filter (with_bot (random_gen string_imp))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_1898 (h0 : group (has_nnnorm (has_nnnorm (random_gen char)))) : group.fg (has_nnnorm (has_nnnorm (random_gen char))) := sorry --non-trivial
lemma new_lemma_1899 (h0 : topological_space (boolean_algebra (finset (finset pos)))) : irreducible_space (boolean_algebra (finset (finset pos))) := sorry --non-trivial
lemma new_lemma_1900 (h0 : group (has_neg (ring Type))) : is_cyclic (has_neg (ring Type)) := sorry --non-trivial
lemma new_lemma_1901 (h0 : function.extfun nat fin) : @is_atomistic.{0} (comm_semigroup.{0} real) (@matrix.vec_empty.{0} (complete_lattice.{0} (comm_semigroup.{0} real)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_1902 (h1 : topological_space (mul_one_class std_gen)) (h2 : preorder (mul_one_class std_gen)) : order_topology (mul_one_class std_gen) := sorry --non-trivial
lemma new_lemma_1903 (h0 : functor.add_const (finset (generalized_boolean_algebra Type)) pos) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_1904 (h0 : semiring (ordered_comm_monoid (has_add linarith.comp))) : is_noetherian_ring (ordered_comm_monoid (has_add linarith.comp)) := sorry --non-trivial
lemma new_lemma_1905 (h0 : group (canonically_ordered_monoid (has_add (has_pos_part (has_Inf linarith.comp))))) : is_cyclic (canonically_ordered_monoid (has_add (has_pos_part (has_Inf linarith.comp)))) := sorry --non-trivial
lemma new_lemma_1906 (h0 : topological_space (add_cancel_monoid (has_neg (has_add environment.implicit_infer_kind)))) : discrete_topology (add_cancel_monoid (has_neg (has_add environment.implicit_infer_kind))) := sorry --non-trivial
lemma new_lemma_1907 (h1 : complete_lattice (random_gen num)) : complete_lattice.is_Sup_finite_compact (random_gen num) := sorry --non-trivial
lemma new_lemma_1908 (h0 : add_group (measurable_space.dynkin_system (linear_ordered_semiring num))) : is_add_cyclic (measurable_space.dynkin_system (linear_ordered_semiring num)) := sorry --non-trivial
lemma new_lemma_1909 (h0 : list (filter empty)) : palindrome h0 := sorry --non-trivial
lemma new_lemma_1910 (h0 : functor.add_const (topological_space (has_Inf name)) linarith.comp) : @path_connected_space.{0} (has_Inf.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (has_Inf.{0} name)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_1911 (h0 : functor.add_const (ordered_add_comm_monoid (has_to_string unsigned)) pos) : @archimedean.{0} (has_to_string.{0} unsigned) (@functor.add_const.run.{0 0} (ordered_add_comm_monoid.{0} (has_to_string.{0} unsigned)) pos h0)  := sorry --non-trivial
lemma new_lemma_1912 (h0 : ring (id (semiring (semiring congr_arg_kind)))) : is_domain (id (semiring (semiring congr_arg_kind))) := sorry --non-trivial
lemma new_lemma_1913 (h0 : topological_space (has_pos_part linarith.comp)) : totally_separated_space (has_pos_part linarith.comp) := sorry --non-trivial
lemma new_lemma_1914 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_domain.{0} string_imp (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) string_imp)  := sorry --non-trivial
lemma new_lemma_1915 (h0 : has_neg (nondiscrete_normed_field enat)) (h1 : measurable_space (nondiscrete_normed_field enat)) : has_measurable_neg (nondiscrete_normed_field enat) := sorry --non-trivial
lemma new_lemma_1916 (h0 : ring (ordered_comm_monoid name)) : strong_rank_condition (ordered_comm_monoid name) := sorry --non-trivial
lemma new_lemma_1917 (h0 h1 : multiset (linear_ordered_comm_group_with_zero (mul_one_class reducibility_hints))) : multiset.subset h0 h1 := sorry --non-trivial
lemma new_lemma_1918 (h0 : fin has_zero.zero) : @complete_space.{0} (ordered_comm_monoid.{0} real) (@function.extfun_app.{2 1} Type uniform_space.{0} (@matrix.vec_empty.{1} (function.extfun.{2 1} Type uniform_space.{0}) h0) (ordered_comm_monoid.{0} real))  := sorry --non-trivial
lemma new_lemma_1919 (h0 : functor.add_const (topological_space (add_left_cancel_semigroup empty)) empty) : @totally_disconnected_space.{0} (add_left_cancel_semigroup.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (add_left_cancel_semigroup.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_1920 (h0 : function.extfun Type topological_space) : @totally_separated_space.{0} (has_top.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_top.{0} empty))  := sorry --non-trivial
lemma new_lemma_1921 (h0 : functor.add_const (ring (finset unsigned)) environment.implicit_infer_kind) : @is_principal_ideal_ring.{0} (finset.{0} unsigned) (@functor.add_const.run.{0 0} (ring.{0} (finset.{0} unsigned)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_1922 (h0 : function.extfun Type topological_space) : @loc_path_connected_space.{0} (linear_ordered_comm_group.{0} ennreal) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (linear_ordered_comm_group.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_1923 (h1 : not (topological_space (random_gen linarith.comp_source) -> false)) : @t0_space.{0} (random_gen.{0} linarith.comp_source) (@classical.by_contradiction'.{1} (topological_space.{0} (random_gen.{0} linarith.comp_source)) h1)  := sorry --non-trivial
lemma new_lemma_1924 (h0 : not (function.extfun Type complete_lattice -> false)) : complete_lattice.is_Sup_finite_compact (measurable_space empty) := sorry --non-trivial
lemma new_lemma_1925 (h0 : functor.comp topological_space boolean_algebra unsigned) : @locally_compact_space.{0} (boolean_algebra.{0} unsigned) (@functor.comp.run.{0 0 0} topological_space.{0} boolean_algebra.{0} unsigned h0)  := sorry --non-trivial
lemma new_lemma_1926 (h0 : filter (ordered_comm_monoid (has_neg Type))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_1927 (h0 : function.extfun Type measurable_space) (h1 : has_inf (has_inv linarith.comp_source)) : @has_measurable_inf₂.{0} (has_inv.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type measurable_space.{0} h0 (has_inv.{0} linarith.comp_source)) h1  := sorry --non-trivial
lemma new_lemma_1928 (h0 : not (function.extfun Type ring -> false)) : @strong_rank_condition.{0} (add_right_cancel_monoid.{0} num) (@function.extfun_app.{2 1} Type ring.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type ring.{0}) h0) (add_right_cancel_monoid.{0} num))  := sorry --non-trivial
lemma new_lemma_1929 (h0 : complete_lattice (normed_field (metric_space to_additive.value_type))) : is_compactly_generated (normed_field (metric_space to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_1930 (h0 : ring (has_add (has_pos_part pos))) : rank_condition (has_add (has_pos_part pos)) := sorry --non-trivial
lemma new_lemma_1931 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @separated_space.{0} (linear_ordered_comm_monoid_with_zero.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type uniform_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 uniform_space.{0}) (linear_ordered_comm_monoid_with_zero.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_1932 (h0 : ring (mul_one_class (mul_one_class char))) : rank_condition (mul_one_class (mul_one_class char)) := sorry --non-trivial
lemma new_lemma_1933 (h0 : set (set fun_info)) (h2 : fun_info) : set.sInter h0 h2 := sorry --non-trivial
lemma new_lemma_1934 (h0 : complete_lattice (cancel_monoid (has_neg_part pos))) : is_atomistic (cancel_monoid (has_neg_part pos)) := sorry --non-trivial
lemma new_lemma_1935 (h0 : topological_space (has_zero pos)) : irreducible_space (has_zero pos) := sorry --non-trivial
lemma new_lemma_1936 (h0 : functor.add_const (topological_space (pseudo_metric_space unsigned)) name) : @t1_space.{0} (pseudo_metric_space.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (pseudo_metric_space.{0} unsigned)) name h0)  := sorry --non-trivial
lemma new_lemma_1937 (h0 : function.extfun Type topological_space) : @sequential_space.{0} (has_add.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_add.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_1938 (h0 : not (complete_lattice (with_one fun_info) -> false)) : @complete_lattice.is_Sup_finite_compact.{0} (with_one.{0} fun_info) (@classical.by_contradiction'.{1} (complete_lattice.{0} (with_one.{0} fun_info)) h0)  := sorry --non-trivial
lemma new_lemma_1939 (h0 : has_mem.mem to_additive.value_type has_emptyc.emptyc) : @locally_compact_space.{0} to_additive.value_type (@finset.pi.empty.{1 0} Type topological_space.{0} to_additive.value_type h0)  := sorry --non-trivial
lemma new_lemma_1940 (h0 : topological_space (canonically_linear_ordered_monoid (has_Inf (has_Inf real)))) : t0_space (canonically_linear_ordered_monoid (has_Inf (has_Inf real))) := sorry --non-trivial
lemma new_lemma_1941 (h0 : function.extfun Type ring) : @rank_condition.{0} string_imp (@function.extfun_app.{2 1} Type ring.{0} h0 string_imp)  := sorry --non-trivial
lemma new_lemma_1942 (h0 : ring (has_add (finset (finset environment.implicit_infer_kind)))) : is_principal_ideal_ring (has_add (finset (finset environment.implicit_infer_kind))) := sorry --non-trivial
lemma new_lemma_1943 (h0 : function.extfun Type topological_space) : @t0_space.{0} auto.case_option (@function.extfun_app.{2 1} Type topological_space.{0} h0 auto.case_option)  := sorry --non-trivial
lemma new_lemma_1944 (h0 : ring (linear_ordered_add_comm_group (random_gen string_imp))) : strong_rank_condition (linear_ordered_add_comm_group (random_gen string_imp)) := sorry --non-trivial
lemma new_lemma_1945 (h0 : group (complete_semilattice_Sup (random_gen fun_info))) : normalizer_condition (complete_semilattice_Sup (random_gen fun_info)) := sorry --non-trivial
lemma new_lemma_1946 (h0 : functor.add_const (ordered_add_comm_monoid (has_edist empty)) empty) : @archimedean.{0} (has_edist.{0} empty) (@functor.add_const.run.{0 0} (ordered_add_comm_monoid.{0} (has_edist.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_1947 (h0 : complete_lattice (random_gen (has_top (semiring congr_arg_kind)))) : complete_lattice.is_Sup_finite_compact (random_gen (has_top (semiring congr_arg_kind))) := sorry --non-trivial
lemma new_lemma_1948 (h0 : function.extfun Type topological_space) : @path_connected_space.{0} (as_linear_order.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (as_linear_order.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_1949 (h1 h2 : multiset (mul_one_class (add_comm_semigroup ereal))) : multiset.subset h1 h2 := sorry --non-trivial
lemma new_lemma_1950 (h0 : functor.add_const (function.extfun (Type 1) topological_space) environment.implicit_infer_kind) : @t0_space.{1} (semigroup.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) topological_space.{1}) environment.implicit_infer_kind h0) (semigroup.{1} Type))  := sorry --non-trivial
lemma new_lemma_1951 (h0 : ring (normed_field ereal)) : is_domain (normed_field ereal) := sorry --non-trivial
lemma new_lemma_1952 (h0 : ordered_add_comm_monoid (linear_order unsigned)) : archimedean (linear_order unsigned) := sorry --non-trivial
lemma new_lemma_1953 (h0 : cancel_comm_monoid_with_zero (mul_zero_class (rel name Type))) : unique_factorization_monoid (mul_zero_class (rel name Type)) := sorry --non-trivial
lemma new_lemma_1954 (h0 : filter (linear_ordered_semiring (semiring (semiring (has_top (semiring unsigned)))))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_1955 (h0 : function.extfun (finset Type) (has_mem.mem (linear_ordered_semiring num))) : @is_domain.{0} (linear_ordered_semiring.{0} num) (@finset.pi.empty.{1 0} Type ring.{0} (linear_ordered_semiring.{0} num) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (linear_ordered_semiring.{0} num)) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_1956 (h0 : topological_space (semiring (has_norm fun_info))) : irreducible_space (semiring (has_norm fun_info)) := sorry --non-trivial
lemma new_lemma_1957 (h0 : ring (cancel_monoid unsigned)) : rank_condition (cancel_monoid unsigned) := sorry --non-trivial
lemma new_lemma_1958 (h0 : function.extfun Type topological_space) : @irreducible_space.{0} (boolean_algebra.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (boolean_algebra.{0} pos))  := sorry --non-trivial
lemma new_lemma_1959 (h0 : group (add_cancel_monoid (option pos))) : normalizer_condition (add_cancel_monoid (option pos)) := sorry --non-trivial
lemma new_lemma_1960 (h0 : functor.add_const (topological_space (add_comm_monoid name)) unsigned) : @path_connected_space.{0} (add_comm_monoid.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (add_comm_monoid.{0} name)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_1961 (h0 : unsigned -> Prop) : @infi.{0 1} Prop (@conditionally_complete_lattice.to_has_Inf.{0} Prop (@complete_lattice.to_conditionally_complete_lattice.{0} Prop Prop.complete_lattice)) unsigned h0  := sorry --non-trivial
lemma new_lemma_1962 (h0 : topological_space (has_neg (has_neg environment.implicit_infer_kind))) : preconnected_space (has_neg (has_neg environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_1963 (h0 : function.extfun Type (functor.comp group has_to_string)) : @normalizer_condition.{0} (has_to_string.{0} pos) (@functor.comp.run.{0 0 0} group.{0} has_to_string.{0} pos (@function.extfun_app.{2 1} Type (functor.comp.{0 0 0} group.{0} has_to_string.{0}) h0 pos))  := sorry --non-trivial
lemma new_lemma_1964 (h0 : ring (has_neg (finset (ring (finset linarith.comp))))) : is_principal_ideal_ring (has_neg (finset (ring (finset linarith.comp)))) := sorry --non-trivial
lemma new_lemma_1965 (h0 : functor.add_const (ring Type) Type) : @strong_rank_condition.{1} Type (@functor.add_const.run.{1 1} (ring.{1} Type) Type h0)  := sorry --non-trivial
lemma new_lemma_1966 (h0 : ring (has_to_string environment.implicit_infer_kind)) : rank_condition (has_to_string environment.implicit_infer_kind) := sorry --non-trivial
lemma new_lemma_1967 (h0 : filter (has_pos_part (has_neg (has_nndist (has_neg linarith.comp))))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_1968 (h0 : function.extfun Type topological_space) : @locally_compact_space.{0} congr_arg_kind (@function.extfun_app.{2 1} Type topological_space.{0} h0 congr_arg_kind)  := sorry --non-trivial
lemma new_lemma_1969 (h0 : monoid (comm_group (ring linarith.comp))) : monoid.fg (comm_group (ring linarith.comp)) := sorry --non-trivial
lemma new_lemma_1970 (h0 : group (has_nndist (boolean_algebra.core Type))) : group.fg (has_nndist (boolean_algebra.core Type)) := sorry --non-trivial
lemma new_lemma_1971 (h0 : uniform_space (has_dist empty)) : separated_space (has_dist empty) := sorry --non-trivial
lemma new_lemma_1972 (h0 : function.extfun Type group) : @is_cyclic.{0} (linear_ordered_comm_group.{0} unsigned) (@function.extfun_app.{2 1} Type group.{0} h0 (linear_ordered_comm_group.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_1973 (h0 : not (filter (distrib string_imp) -> false)) : filter.ne_bot (classical.by_contradiction' h0) := sorry --non-trivial
lemma new_lemma_1974 (h0 : topological_space (has_Inf (has_to_string (has_add name)))) : loc_path_connected_space (has_Inf (has_to_string (has_add name))) := sorry --non-trivial
lemma new_lemma_1975 (h0 : function.extfun Type complete_lattice) : @is_compactly_generated.{0} (linear_ordered_cancel_comm_monoid.{0} unsigned) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (linear_ordered_cancel_comm_monoid.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_1976 (h1 : std_gen -> std_gen -> Prop) (h2 : set std_gen) : directed_on h1 h2 := sorry --non-trivial
lemma new_lemma_1977 (h0 : group (canonically_ordered_add_monoid congr_arg_kind)) : normalizer_condition (canonically_ordered_add_monoid congr_arg_kind) := sorry --non-trivial
lemma new_lemma_1978 (h0 : function.extfun Type topological_space) : @irreducible_space.{0} (complete_semilattice_Sup.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (complete_semilattice_Sup.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_1979 (h0 : group (boolean_algebra.core (has_to_string congr_arg_kind))) : group.fg (boolean_algebra.core (has_to_string congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_1980 (h0 : functor.add_const (topological_space (semigroup pos)) pos) : @t1_space.{0} (semigroup.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (semigroup.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_1981 (h0 : topological_space (measurable_space empty)) : path_connected_space (measurable_space empty) := sorry --non-trivial
lemma new_lemma_1982 (h0 : topological_space (ordered_comm_ring (has_neg (has_neg pos)))) : sequential_space (ordered_comm_ring (has_neg (has_neg pos))) := sorry --non-trivial
lemma new_lemma_1983 (h0 : functor.add_const (ordered_add_comm_monoid (monoid ennreal)) unsigned) : @archimedean.{0} (monoid.{0} ennreal) (@functor.add_const.run.{0 0} (ordered_add_comm_monoid.{0} (monoid.{0} ennreal)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_1984 (h0 : functor.add_const (topological_space (bin_tree empty)) empty) : @irreducible_space.{0} (bin_tree.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (bin_tree.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_1985 (h0 : complete_lattice (normed_lattice_add_comm_group (comm_semigroup Type))) : is_compactly_generated (normed_lattice_add_comm_group (comm_semigroup Type)) := sorry --non-trivial
lemma new_lemma_1986 (h0 : not (add_group (comm_ring linarith.comp_source) -> false)) : @is_add_cyclic.{0} (comm_ring.{0} linarith.comp_source) (@classical.by_contradiction'.{1} (add_group.{0} (comm_ring.{0} linarith.comp_source)) h0)  := sorry --non-trivial
lemma new_lemma_1987 (h0 : semiring (has_neg (generalized_boolean_algebra Type))) : is_noetherian_ring (has_neg (generalized_boolean_algebra Type)) := sorry --non-trivial
lemma new_lemma_1988 (h0 : topological_space (semiring empty)) : topological_space.separable_space (semiring empty) := sorry --non-trivial
lemma new_lemma_1989 (h0 : functor.add_const (ring (has_neg linarith.comp)) pos) : @rank_condition.{0} (has_neg.{0} linarith.comp) (@functor.add_const.run.{0 0} (ring.{0} (has_neg.{0} linarith.comp)) pos h0)  := sorry --non-trivial
lemma new_lemma_1990 (h0 : monoid (add_right_cancel_monoid (semiring (has_top empty)))) : monoid.fg (add_right_cancel_monoid (semiring (has_top empty))) := sorry --non-trivial
lemma new_lemma_1991 (h1 : ring (topological_space (has_nnnorm to_additive.value_type))) : rank_condition (topological_space (has_nnnorm to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_1992 (h0 : functor.add_const (function.extfun Type topological_space) Type) : @irreducible_space.{0} (has_Inf.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type topological_space.{0}) Type h0) (has_Inf.{0} pos))  := sorry --non-trivial
lemma new_lemma_1993 (h1 : ring (uniform_space reducibility_hints)) : is_domain (uniform_space reducibility_hints) := sorry --non-trivial
lemma new_lemma_1994 (h1 : ring (with_one num)) : strong_rank_condition (with_one num) := sorry --non-trivial
lemma new_lemma_1995 (h0 : functor.add_const (add_monoid (canonically_ordered_comm_semiring linarith.comp)) name) : @add_monoid.fg.{0} (canonically_ordered_comm_semiring.{0} linarith.comp) (@functor.add_const.run.{0 0} (add_monoid.{0} (canonically_ordered_comm_semiring.{0} linarith.comp)) name h0)  := sorry --non-trivial
lemma new_lemma_1996 (h1 : add_group (add_monoid to_additive.value_type)) : is_add_cyclic (add_monoid to_additive.value_type) := sorry --non-trivial
lemma new_lemma_1997 (h0 : group (random_gen (comm_ring reducibility_hints))) : is_cyclic (random_gen (comm_ring reducibility_hints)) := sorry --non-trivial
lemma new_lemma_1998 (h0 : function.extfun (Type 1) topological_space) : @regular_space.{1} (has_neg_part.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} h0 (has_neg_part.{1} Type))  := sorry --non-trivial
lemma new_lemma_1999 (h0 : ring (left_cancel_monoid num)) : is_domain (left_cancel_monoid num) := sorry --non-trivial
lemma new_lemma_2000 (h0 : ring (comm_ring (mul_one_class linarith.comp_source))) : strong_rank_condition (comm_ring (mul_one_class linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_2001 (h0 : function.extfun Type group) : @normalizer_condition.{0} (ring.{0} name) (@function.extfun_app.{2 1} Type group.{0} h0 (ring.{0} name))  := sorry --non-trivial
lemma new_lemma_2002 (h1 : group (topological_space (comm_ring reducibility_hints))) : is_cyclic (topological_space (comm_ring reducibility_hints)) := sorry --non-trivial
lemma new_lemma_2003 (h0 : group (has_to_string (has_neg (has_neg linarith.comp)))) : normalizer_condition (has_to_string (has_neg (has_neg linarith.comp))) := sorry --non-trivial
lemma new_lemma_2004 (h0 : uniform_space (measurable_space (semiring unsigned))) : separated_space (measurable_space (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_2005 (h0 : functor.add_const (topological_space (canonically_ordered_comm_semiring name)) Type) : @preirreducible_space.{0} (canonically_ordered_comm_semiring.{0} name) (@functor.add_const.run.{0 1} (topological_space.{0} (canonically_ordered_comm_semiring.{0} name)) Type h0)  := sorry --non-trivial
lemma new_lemma_2006 (h0 : add_monoid (normed_comm_ring pos)) : add_monoid.fg (normed_comm_ring pos) := sorry --non-trivial
lemma new_lemma_2007 (h1 : has_mem.mem group has_emptyc.emptyc) : @normalizer_condition.{0} (random_gen.{0} linarith.ineq) (@function.extfun_app.{2 1} Type group.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) group.{0} h1) (random_gen.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_2008 (h0 : functor.add_const (add_group (linear_order unsigned)) empty) : @is_add_cyclic.{0} (linear_order.{0} unsigned) (@functor.add_const.run.{0 0} (add_group.{0} (linear_order.{0} unsigned)) empty h0)  := sorry --non-trivial
lemma new_lemma_2009 (h0 : prod (has_sub congr_arg_kind) (has_sub congr_arg_kind)) : id_rel h0 := sorry --non-trivial
lemma new_lemma_2010 (h0 : cancel_comm_monoid_with_zero (add_cancel_monoid (option pos))) : unique_factorization_monoid (add_cancel_monoid (option pos)) := sorry --non-trivial
lemma new_lemma_2011 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @normalizer_condition.{0} (measurable_space.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (measurable_space.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_2012 (h0 : has_neg (additive linarith.comp_source)) (h1 : measurable_space (additive linarith.comp_source)) : has_measurable_neg (additive linarith.comp_source) := sorry --non-trivial
lemma new_lemma_2013 (h0 : function.extfun Type finset) : finset.nonempty (function.extfun_app h0 (ordered_comm_semiring num)) := sorry --non-trivial
lemma new_lemma_2014 (h0 : not (complete_lattice (add_right_cancel_monoid empty) -> false)) : @complete_lattice.is_Sup_finite_compact.{0} (add_right_cancel_monoid.{0} empty) (@classical.by_contradiction'.{1} (complete_lattice.{0} (add_right_cancel_monoid.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_2015 (h0 : complete_lattice (set environment.projection_info)) : complete_lattice.is_Sup_finite_compact (set environment.projection_info) := sorry --non-trivial
lemma new_lemma_2016 (h1 : complete_lattice (div_inv_monoid char)) : is_compactly_generated (div_inv_monoid char) := sorry --non-trivial
lemma new_lemma_2017 (h0 : topological_space (has_zero (normed_comm_ring (has_pos_part (has_Inf linarith.comp))))) : locally_compact_space (has_zero (normed_comm_ring (has_pos_part (has_Inf linarith.comp)))) := sorry --non-trivial
lemma new_lemma_2018 (h0 : topological_space (denumerable (has_ssubset linarith.ineq))) : t0_space (denumerable (has_ssubset linarith.ineq)) := sorry --non-trivial
lemma new_lemma_2019 (h0 : not (filter (with_one linarith.ineq) -> false)) : filter.ne_bot (classical.by_contradiction' h0) := sorry --non-trivial
lemma new_lemma_2020 (h0 : not (function.extfun Type topological_space -> false)) : @irreducible_space.{0} (measurable_space.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (measurable_space.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_2021 (h0 : function.extfun Type topological_space) : @t0_space.{0} (generalized_boolean_algebra.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (generalized_boolean_algebra.{0} pos))  := sorry --non-trivial
lemma new_lemma_2022 (h1 : ring enat) : is_field enat := sorry --non-trivial
lemma new_lemma_2023 (h0 : functor.add_const (topological_space (has_add Type)) Type) : @preirreducible_space.{1} (has_add.{1} Type) (@functor.add_const.run.{1 1} (topological_space.{1} (has_add.{1} Type)) Type h0)  := sorry --non-trivial
lemma new_lemma_2024 (h0 : group (add_right_cancel_monoid (semiring congr_arg_kind))) : group.fg (add_right_cancel_monoid (semiring congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_2025 (h0 : topological_space (add_semigroup (option empty))) : preirreducible_space (add_semigroup (option empty)) := sorry --non-trivial
lemma new_lemma_2026 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @normal_space.{0} (boolean_algebra.core.{0} ennreal) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (boolean_algebra.core.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_2027 (h0 : ring (has_inv (random_gen string_imp))) : is_domain (has_inv (random_gen string_imp)) := sorry --non-trivial
lemma new_lemma_2028 (h0 : function.extfun Type uniform_space) : @complete_space.{0} (add_comm_monoid.{0} pos) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (add_comm_monoid.{0} pos))  := sorry --non-trivial
lemma new_lemma_2029 (h0 : topological_space environment.implicit_infer_kind) : totally_separated_space environment.implicit_infer_kind := sorry --non-trivial
lemma new_lemma_2030 (h0 : topological_space (has_emptyc (has_norm fun_info))) : totally_separated_space (has_emptyc (has_norm fun_info)) := sorry --non-trivial
lemma new_lemma_2031 (h0 : functor.add_const (topological_space (boolean_algebra name)) pos) : @totally_separated_space.{0} (boolean_algebra.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (boolean_algebra.{0} name)) pos h0)  := sorry --non-trivial
lemma new_lemma_2032 (h0 : topological_space (has_Inf (ring (has_neg linarith.comp)))) : regular_space (has_Inf (ring (has_neg linarith.comp))) := sorry --non-trivial
lemma new_lemma_2033 (h1 : list (complete_semilattice_Sup string_imp)) : list.nodup h1 := sorry --non-trivial
lemma new_lemma_2034 (h0 : functor.add_const (topological_space (has_nndist ennreal)) pos) : @topological_space.separable_space.{0} (has_nndist.{0} ennreal) (@functor.add_const.run.{0 0} (topological_space.{0} (has_nndist.{0} ennreal)) pos h0)  := sorry --non-trivial
lemma new_lemma_2035 (h0 : functor.add_const (ordered_comm_monoid (has_nndist pos)) name) : @has_exists_mul_of_le.{0} (has_nndist.{0} pos) (@functor.add_const.run.{0 0} (ordered_comm_monoid.{0} (has_nndist.{0} pos)) name h0)  := sorry --non-trivial
lemma new_lemma_2036 (h0 : topological_space (has_neg (has_add name))) : totally_separated_space (has_neg (has_add name)) := sorry --non-trivial
lemma new_lemma_2037 (h0 : cancel_comm_monoid_with_zero (semigroup linarith.comp)) : unique_factorization_monoid (semigroup linarith.comp) := sorry --non-trivial
lemma new_lemma_2038 (h0 : function.extfun Type topological_space) : @path_connected_space.{0} (random_gen.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (random_gen.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_2039 (h0 : functor.add_const (prod (left_cancel_monoid congr_arg_kind) (left_cancel_monoid congr_arg_kind)) empty) : id_rel (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_2040 (h0 : ring (has_emptyc (has_top (has_top (has_top (has_top to_additive.value_type)))))) : is_domain (has_emptyc (has_top (has_top (has_top (has_top to_additive.value_type))))) := sorry --non-trivial
lemma new_lemma_2041 (h2 : uniform_space (has_div to_additive.value_type)) : complete_space (has_div to_additive.value_type) := sorry --non-trivial
lemma new_lemma_2042 (h0 : list (bin_tree congr_arg_kind)) : palindrome h0 := sorry --non-trivial
lemma new_lemma_2043 (h0 : functor.add_const (complete_lattice (preorder unsigned)) empty) : @is_compactly_generated.{0} (preorder.{0} unsigned) (@functor.add_const.run.{0 0} (complete_lattice.{0} (preorder.{0} unsigned)) empty h0)  := sorry --non-trivial
lemma new_lemma_2044 (h0 : functor.add_const (topological_space (ring Type)) (finset linarith.comp)) : @normal_space.{1} (ring.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (ring.{1} Type)) (finset.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_2045 (h0 : functor.add_const (topological_space (ordered_ring unsigned)) unsigned) : @loc_path_connected_space.{0} (ordered_ring.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (ordered_ring.{0} unsigned)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_2046 (h0 : group (topological_space linarith.ineq)) : is_cyclic (topological_space linarith.ineq) := sorry --non-trivial
lemma new_lemma_2047 (h0 : topological_space (has_neg (has_neg name))) : path_connected_space (has_neg (has_neg name)) := sorry --non-trivial
lemma new_lemma_2048 (h0 : functor.add_const (ring (has_nndist name)) linarith.comp) : @strong_rank_condition.{0} (has_nndist.{0} name) (@functor.add_const.run.{0 0} (ring.{0} (has_nndist.{0} name)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_2049 (h0 : uniform_space (boolean_algebra.core (ring (has_neg_part (has_add Type))))) : complete_space (boolean_algebra.core (ring (has_neg_part (has_add Type)))) := sorry --non-trivial
lemma new_lemma_2050 (h0 : not (has_mem.mem congr_arg_kind has_emptyc.emptyc -> false)) : @rank_condition.{0} congr_arg_kind (@finset.pi.empty.{1 0} Type ring.{0} congr_arg_kind (@classical.by_contradiction'.{0} (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) congr_arg_kind (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))) h0))  := sorry --non-trivial
lemma new_lemma_2051 (h0 : functor.add_const (complete_lattice (comm_group name)) linarith.comp) : @id.{1} Prop (@complete_lattice.is_Sup_finite_compact.{0} (comm_group.{0} name) (@functor.add_const.run.{0 0} (complete_lattice.{0} (comm_group.{0} name)) linarith.comp h0))  := sorry --non-trivial
lemma new_lemma_2052 (h0 : list (has_bot (option (option empty)))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_2053 (h0 : topological_space (has_zero (boolean_algebra.core linarith.comp))) : preconnected_space (has_zero (boolean_algebra.core linarith.comp)) := sorry --non-trivial
lemma new_lemma_2054 (h0 : group (ordered_cancel_add_comm_monoid congr_arg_kind)) : group.fg (ordered_cancel_add_comm_monoid congr_arg_kind) := sorry --non-trivial
lemma new_lemma_2055 (h0 : complete_lattice (metric_space (has_top num))) : complete_lattice.is_Sup_finite_compact (metric_space (has_top num)) := sorry --non-trivial
lemma new_lemma_2056 (h0 : topological_space (linear_ordered_semiring (random_gen empty))) : totally_separated_space (linear_ordered_semiring (random_gen empty)) := sorry --non-trivial
lemma new_lemma_2057 (h0 : uniform_space (plift (has_edist (option empty)))) : complete_space (plift (has_edist (option empty))) := sorry --non-trivial
lemma new_lemma_2058 (h0 : function.extfun Type ordered_comm_monoid) : @has_exists_mul_of_le.{0} (canonically_linear_ordered_monoid.{0} name) (@function.extfun_app.{2 1} Type ordered_comm_monoid.{0} h0 (canonically_linear_ordered_monoid.{0} name))  := sorry --non-trivial
lemma new_lemma_2059 (h0 : function.extfun (Type 1) topological_space) : @locally_compact_space.{1} (has_neg_part.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} h0 (has_neg_part.{1} Type))  := sorry --non-trivial
lemma new_lemma_2060 (h0 : topological_space (has_add (finset pos))) : totally_disconnected_space (has_add (finset pos)) := sorry --non-trivial
lemma new_lemma_2061 (h0 : list (cancel_monoid (boolean_algebra.core environment.implicit_infer_kind))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_2062 (h0 : functor.add_const (add_monoid (normed_comm_ring ennreal)) unsigned) : @add_monoid.fg.{0} (normed_comm_ring.{0} ennreal) (@functor.add_const.run.{0 0} (add_monoid.{0} (normed_comm_ring.{0} ennreal)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_2063 (h0 : topological_space (normed_comm_ring (ring unsigned))) : normal_space (normed_comm_ring (ring unsigned)) := sorry --non-trivial
lemma new_lemma_2064 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_domain.{0} (cancel_monoid.{0} empty) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (cancel_monoid.{0} empty))  := sorry --non-trivial
lemma new_lemma_2065 (h0 : topological_space (has_zero (has_to_string (cancel_monoid name)))) : preirreducible_space (has_zero (has_to_string (cancel_monoid name))) := sorry --non-trivial
lemma new_lemma_2066 (h0 : function.extfun ((Type -> Type) -> Type 1) (function.extfun (Type -> Type))) : @is_add_cyclic.{0} (complete_semilattice_Sup.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type add_group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) (@function.extfun_app.{3 2} ((Type → Type) → Type 1) (function.extfun.{2 2} (Type → Type)) h0 (function.extfun.{2 1} Type)) add_group.{0}) (complete_semilattice_Sup.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_2067 (h0 : group (boolean_algebra (finset linarith.comp))) : group.fg (boolean_algebra (finset linarith.comp)) := sorry --non-trivial
lemma new_lemma_2068 (h0 : ring (has_neg congr_arg_kind)) : rank_condition (has_neg congr_arg_kind) := sorry --non-trivial
lemma new_lemma_2069 (h0 : functor.add_const (filter (ring linarith.comp)) pos) : countable_Inter_filter (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_2070 (h0 : not (filter (measurable_space.dynkin_system unsigned) -> false)) : filter.ne_bot (classical.by_contradiction' h0) := sorry --non-trivial
lemma new_lemma_2071 (h1 : topological_space (normed_field (comm_ring reducibility_hints))) : t0_space (normed_field (comm_ring reducibility_hints)) := sorry --non-trivial
lemma new_lemma_2072 (h0 : complete_lattice (boolean_algebra (has_to_string (has_to_string pos)))) : complete_lattice.is_Sup_finite_compact (boolean_algebra (has_to_string (has_to_string pos))) := sorry --non-trivial
lemma new_lemma_2073 (h0 : topological_space (finset (finset (finset (finset ennreal))))) : path_connected_space (finset (finset (finset (finset ennreal)))) := sorry --non-trivial
lemma new_lemma_2074 (h0 : function.extfun Type list) : list.nodup (function.extfun_app h0 (ordered_comm_monoid (ring linarith.comp))) := sorry --non-trivial
lemma new_lemma_2075 (h0 : linarith.comp_source -> linarith.comp_source -> Prop) (h1 : set linarith.comp_source) : set.bounded h0 h1 := sorry --non-trivial
lemma new_lemma_2076 (h0 : functor.comp add_group normed_comm_ring pos) : @is_add_cyclic.{0} (normed_comm_ring.{0} pos) (@functor.comp.run.{0 0 0} add_group.{0} normed_comm_ring.{0} pos h0)  := sorry --non-trivial
lemma new_lemma_2077 (h0 : not (topological_space (with_one linarith.ineq) -> false)) : @totally_separated_space.{0} (with_one.{0} linarith.ineq) (@classical.by_contradiction'.{1} (topological_space.{0} (with_one.{0} linarith.ineq)) h0)  := sorry --non-trivial
lemma new_lemma_2078 (h0 : functor.add_const (topological_space (boolean_algebra.core Type)) linarith.comp) : @normal_space.{1} (boolean_algebra.core.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (boolean_algebra.core.{1} Type)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_2079 (h0 : function.extfun Type list) : list.nodup (function.extfun_app h0 (has_neg (option unsigned))) := sorry --non-trivial
lemma new_lemma_2080 (h0 : topological_space (normed_comm_ring (has_add (has_add (has_add Type))))) : t1_space (normed_comm_ring (has_add (has_add (has_add Type)))) := sorry --non-trivial
lemma new_lemma_2081 (h0 : fin has_zero.zero) : @has_exists_mul_of_le.{1} (add_comm_monoid.{1} Type) (@matrix.vec_empty.{1} (ordered_comm_monoid.{1} (add_comm_monoid.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_2082 (h0 : topological_space (simple_graph (distrib string.iterator_imp))) : t0_space (simple_graph (distrib string.iterator_imp)) := sorry --non-trivial
lemma new_lemma_2083 (h0 : cancel_comm_monoid_with_zero (monoid_with_zero (option unsigned))) : unique_factorization_monoid (monoid_with_zero (option unsigned)) := sorry --non-trivial
lemma new_lemma_2084 (h0 : function.extfun Type (functor.add_const (list (has_edist empty)))) : palindrome (functor.add_const.run (function.extfun_app h0 unsigned)) := sorry --non-trivial
lemma new_lemma_2085 (h0 : group (normed_field (has_nnnorm reducibility_hints))) : is_cyclic (normed_field (has_nnnorm reducibility_hints)) := sorry --non-trivial
lemma new_lemma_2086 (h0 : filter (ordered_comm_group unsigned)) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_2087 (h0 : function.extfun Type (functor.add_const (group (add_group congr_arg_kind)))) : @normalizer_condition.{0} (add_group.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (group.{0} (add_group.{0} congr_arg_kind)) num (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (group.{0} (add_group.{0} congr_arg_kind))) h0 num))  := sorry --non-trivial
lemma new_lemma_2088 (h0 : complete_lattice (has_neg congr_arg_kind)) : complete_lattice.is_Sup_finite_compact (has_neg congr_arg_kind) := sorry --non-trivial
lemma new_lemma_2089 (h0 : function.extfun Type topological_space) : @t0_space.{0} (metric_space.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (metric_space.{0} empty))  := sorry --non-trivial
lemma new_lemma_2090 (h0 : topological_space (has_nndist (comm_group Type))) : t1_space (has_nndist (comm_group Type)) := sorry --non-trivial
lemma new_lemma_2091 (h0 : functor.add_const (group (ordered_cancel_add_comm_monoid ennreal)) ennreal) : @is_simple_group.{0} (ordered_cancel_add_comm_monoid.{0} ennreal) (@functor.add_const.run.{0 0} (group.{0} (ordered_cancel_add_comm_monoid.{0} ennreal)) ennreal h0)  := sorry --non-trivial
lemma new_lemma_2092 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @t0_space.{0} (complete_semilattice_Sup.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (complete_semilattice_Sup.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_2093 (h0 : topological_space (monoid (option unsigned))) : totally_separated_space (monoid (option unsigned)) := sorry --non-trivial
lemma new_lemma_2094 (h0 : function.extfun Type topological_space) : @discrete_topology.{0} (linear_ordered_field.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (linear_ordered_field.{0} empty))  := sorry --non-trivial
lemma new_lemma_2095 (h0 : group (add_comm_monoid (add_cancel_monoid name))) : normalizer_condition (add_comm_monoid (add_cancel_monoid name)) := sorry --non-trivial
lemma new_lemma_2096 (h0 : functor.add_const (group (has_to_string environment.implicit_infer_kind)) environment.implicit_infer_kind) : @normalizer_condition.{0} (has_to_string.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (group.{0} (has_to_string.{0} environment.implicit_infer_kind)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_2097 (h0 : topological_space (comm_group (has_neg_part (cancel_monoid (option ennreal))))) : totally_disconnected_space (comm_group (has_neg_part (cancel_monoid (option ennreal)))) := sorry --non-trivial
lemma new_lemma_2098 (h0 : function.extfun Type topological_space) : @normal_space.{0} (has_add.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_add.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_2099 (h0 : function.extfun Type list) : palindrome (function.extfun_app h0 (pseudo_metric_space num)) := sorry --non-trivial
lemma new_lemma_2100 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @totally_disconnected_space.{0} (simple_graph.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (simple_graph.{0} name))  := sorry --non-trivial
lemma new_lemma_2101 (h0 : semiring (has_to_string (boolean_algebra.core ennreal))) : is_noetherian_ring (has_to_string (boolean_algebra.core ennreal)) := sorry --non-trivial
lemma new_lemma_2102 (h1 : ring (linear_ordered_add_comm_group (has_nnnorm to_additive.value_type))) : is_domain (linear_ordered_add_comm_group (has_nnnorm to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_2103 (h0 : complete_lattice (has_neg (option pos))) : is_atomistic (has_neg (option pos)) := sorry --non-trivial
lemma new_lemma_2104 (h0 : uniform_space (normed_lattice_add_comm_group real)) : separated_space (normed_lattice_add_comm_group real) := sorry --non-trivial
lemma new_lemma_2105 (h2 : topological_space (add_comm_semigroup char)) (h3 : preorder (add_comm_semigroup char)) : order_closed_topology (add_comm_semigroup char) := sorry --non-trivial
lemma new_lemma_2106 (h0 : topological_space (has_neg_part (has_add ennreal))) : topological_space.separable_space (has_neg_part (has_add ennreal)) := sorry --non-trivial
lemma new_lemma_2107 (h0 : topological_space (semigroup (has_to_string (has_to_string (has_to_string unsigned))))) : t0_space (semigroup (has_to_string (has_to_string (has_to_string unsigned)))) := sorry --non-trivial
lemma new_lemma_2108 (h0 : functor.add_const (monoid Type) (has_add environment.implicit_infer_kind)) : @monoid.fg.{1} Type (@functor.add_const.run.{1 0} (monoid.{1} Type) (has_add.{0} environment.implicit_infer_kind) h0)  := sorry --non-trivial
lemma new_lemma_2109 (h1 : complete_lattice (has_top num)) : complete_lattice.is_Sup_finite_compact (has_top num) := sorry --non-trivial
lemma new_lemma_2110 (h0 : group (sub_neg_monoid linarith.comp)) : normalizer_condition (sub_neg_monoid linarith.comp) := sorry --non-trivial
lemma new_lemma_2111 (h0 : functor.add_const (function.extfun Type topological_space) real) : @discrete_topology.{0} (boolean_algebra.{0} real) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) real h0) (boolean_algebra.{0} real))  := sorry --non-trivial
lemma new_lemma_2112 (h0 : topological_space (has_star num)) : totally_separated_space (has_star num) := sorry --non-trivial
lemma new_lemma_2113 (h0 : functor.add_const (topological_space (generalized_boolean_algebra linarith.comp)) name) : @irreducible_space.{0} (generalized_boolean_algebra.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (generalized_boolean_algebra.{0} linarith.comp)) name h0)  := sorry --non-trivial
lemma new_lemma_2114 (h0 : topological_space (semigroup (boolean_algebra.core linarith.comp))) : path_connected_space (semigroup (boolean_algebra.core linarith.comp)) := sorry --non-trivial
lemma new_lemma_2115 (h0 : ring (measurable_space (random_gen (complete_semilattice_Sup to_additive.value_type)))) : rank_condition (measurable_space (random_gen (complete_semilattice_Sup to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_2116 (h0 : functor.add_const (functor.add_const (function.extfun (Type 1) add_group) environment.implicit_infer_kind) pos) : @is_add_cyclic.{1} (boolean_algebra.core.{1} Type) (@function.extfun_app.{3 2} (Type 1) add_group.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) add_group.{1}) environment.implicit_infer_kind (@functor.add_const.run.{2 0} (functor.add_const.{2 0} (function.extfun.{3 2} (Type 1) add_group.{1}) environment.implicit_infer_kind) pos h0)) (boolean_algebra.core.{1} Type))  := sorry --non-trivial
lemma new_lemma_2117 (h0 : add_group (ordered_ring (semiring empty))) : is_add_cyclic (ordered_ring (semiring empty)) := sorry --non-trivial
lemma new_lemma_2118 (h0 : function.extfun (nat -> Type) (function.extfun nat)) : @t0_space.{0} (sub_neg_monoid.{0} name) (@matrix.vec_empty.{0} (topological_space.{0} (sub_neg_monoid.{0} name)) (@function.extfun_app.{1 1} nat fin (@function.extfun_app.{2 1} (nat → Type) (function.extfun.{1 1} nat) h0 fin) (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_2119 (h0 : not (uniform_space (complete_semilattice_Sup congr_arg_kind) -> false)) : @separated_space.{0} (complete_semilattice_Sup.{0} congr_arg_kind) (@classical.by_contradiction'.{1} (uniform_space.{0} (complete_semilattice_Sup.{0} congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_2120 (h0 : topological_space (has_zero name)) : path_connected_space (has_zero name) := sorry --non-trivial
lemma new_lemma_2121 (h0 : topological_space (linear_ordered_semiring linarith.comp)) : totally_disconnected_space (linear_ordered_semiring linarith.comp) := sorry --non-trivial
lemma new_lemma_2122 (h0 : not (topological_space string_imp -> false)) : @totally_disconnected_space.{0} string_imp (@classical.by_contradiction'.{1} (topological_space.{0} string_imp) h0)  := sorry --non-trivial
lemma new_lemma_2123 (h0 : ring (semi_normed_comm_ring (random_gen linarith.ineq))) : rank_condition (semi_normed_comm_ring (random_gen linarith.ineq)) := sorry --non-trivial
lemma new_lemma_2124 (h0 : topological_space (pseudo_metric_space (option ennreal))) : regular_space (pseudo_metric_space (option ennreal)) := sorry --non-trivial
lemma new_lemma_2125 (h0 : ring (monoid_with_zero ennreal)) : is_principal_ideal_ring (monoid_with_zero ennreal) := sorry --non-trivial
lemma new_lemma_2126 (h0 : topological_space (has_Inf congr_arg_kind)) : locally_compact_space (has_Inf congr_arg_kind) := sorry --non-trivial
lemma new_lemma_2127 (h0 : complete_lattice (has_emptyc linarith.ineq)) : complete_lattice.is_Sup_finite_compact (has_emptyc linarith.ineq) := sorry --non-trivial
lemma new_lemma_2128 (h0 : uniform_space (add_comm_monoid real)) : separated_space (add_comm_monoid real) := sorry --non-trivial
lemma new_lemma_2129 (h1 : complete_lattice (nondiscrete_normed_field enat)) : complete_lattice.is_Sup_finite_compact (nondiscrete_normed_field enat) := sorry --non-trivial
lemma new_lemma_2130 (h0 : topological_space (simple_graph string_imp)) : t0_space (simple_graph string_imp) := sorry --non-trivial
lemma new_lemma_2131 (h0 : functor.add_const (list (has_nndist empty)) empty) : palindrome (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_2132 (h0 : function.extfun Type ordered_comm_monoid) : @has_exists_mul_of_le.{0} (add_comm_monoid.{0} ennreal) (@function.extfun_app.{2 1} Type ordered_comm_monoid.{0} h0 (add_comm_monoid.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_2133 (h0 : has_mem.mem (normed_field string_imp) has_emptyc.emptyc) : @rank_condition.{0} (normed_field.{0} string_imp) (@finset.pi.empty.{1 0} Type ring.{0} (normed_field.{0} string_imp) h0)  := sorry --non-trivial
lemma new_lemma_2134 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @normalizer_condition.{0} (normed_comm_ring.{0} name) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (normed_comm_ring.{0} name))  := sorry --non-trivial
lemma new_lemma_2135 (h0 : topological_space (semigroup (semiring unsigned))) : topological_space.separable_space (semigroup (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_2136 (h1 : function.extfun Type group) : @group.fg.{0} (with_one.{0} num) (@function.extfun_app.{2 1} Type group.{0} h1 (with_one.{0} num))  := sorry --non-trivial
lemma new_lemma_2137 (h0 : finset (ordered_comm_monoid pos)) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_2138 (h0 : function.extfun Type ring) : @rank_condition.{0} (has_union.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type ring.{0} h0 (has_union.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_2139 (h0 : function.extfun Type ring) : @is_principal_ideal_ring.{0} (add_cancel_comm_monoid.{0} empty) (@function.extfun_app.{2 1} Type ring.{0} h0 (add_cancel_comm_monoid.{0} empty))  := sorry --non-trivial
lemma new_lemma_2140 (h0 : add_group (add_comm_monoid (option (option (option empty))))) : is_add_cyclic (add_comm_monoid (option (option (option empty)))) := sorry --non-trivial
lemma new_lemma_2141 (h0 : function.extfun Type cancel_comm_monoid_with_zero) : @unique_factorization_monoid.{0} (complete_distrib_lattice.{0} linarith.comp) (@function.extfun_app.{2 1} Type cancel_comm_monoid_with_zero.{0} h0 (complete_distrib_lattice.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_2142 (h0 : list (ordered_cancel_add_comm_monoid (has_dist num))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_2143 (h0 : functor.add_const (uniform_space (mul_zero_class empty)) empty) : @complete_space.{0} (mul_zero_class.{0} empty) (@functor.add_const.run.{0 0} (uniform_space.{0} (mul_zero_class.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_2144 (h0 : function.extfun (finset Type) (has_mem.mem (with_bot congr_arg_kind))) : @separated_space.{0} (with_bot.{0} congr_arg_kind) (@finset.pi.empty.{1 0} Type uniform_space.{0} (with_bot.{0} congr_arg_kind) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (with_bot.{0} congr_arg_kind)) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_2145 (h0 : list (linear_ordered_field (has_to_string name))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_2146 (h0 : function.extfun nat fin) : @has_exists_mul_of_le.{1} (sub_neg_monoid.{1} Type) (@matrix.vec_empty.{1} (ordered_comm_monoid.{1} (sub_neg_monoid.{1} Type)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_2147 (h0 : complete_lattice (has_pos_part (has_pos_part (has_add pos)))) : is_compactly_generated (has_pos_part (has_pos_part (has_add pos))) := sorry --non-trivial
lemma new_lemma_2148 (h0 : functor.add_const (topological_space (has_Inf pos)) (has_Inf linarith.comp)) : @irreducible_space.{0} (has_Inf.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (has_Inf.{0} pos)) (has_Inf.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_2149 (h0 : uniform_space (has_nndist Type)) : complete_space (has_nndist Type) := sorry --non-trivial
lemma new_lemma_2150 (h0 : function.extfun Type (functor.add_const (topological_space pos))) : @path_connected_space.{0} pos (@functor.add_const.run.{0 0} (topological_space.{0} pos) pos (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (topological_space.{0} pos)) h0 pos))  := sorry --non-trivial
lemma new_lemma_2151 (h0 : functor.add_const (uniform_space (has_star num)) (semiring empty)) : @separated_space.{0} (has_star.{0} num) (@functor.add_const.run.{0 0} (uniform_space.{0} (has_star.{0} num)) (semiring.{0} empty) h0)  := sorry --non-trivial
lemma new_lemma_2152 (h0 : function.extfun Type (functor.add_const (ring (normed_linear_ordered_group empty)))) : @rank_condition.{0} (normed_linear_ordered_group.{0} empty) (@functor.add_const.run.{0 0} (ring.{0} (normed_linear_ordered_group.{0} empty)) empty (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (ring.{0} (normed_linear_ordered_group.{0} empty))) h0 empty))  := sorry --non-trivial
lemma new_lemma_2153 (h0 : ordered_comm_monoid (boolean_algebra (has_neg linarith.comp))) : has_exists_mul_of_le (boolean_algebra (has_neg linarith.comp)) := sorry --non-trivial
lemma new_lemma_2154 (h0 : functor.add_const (topological_space (has_bot name)) real) : @loc_path_connected_space.{0} (has_bot.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (has_bot.{0} name)) real h0)  := sorry --non-trivial
lemma new_lemma_2155 (h0 : filter (dlist (linear_ordered_add_comm_group char))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_2156 (h0 : complete_lattice (topological_space linarith.ineq)) : is_compactly_generated (topological_space linarith.ineq) := sorry --non-trivial
lemma new_lemma_2157 (h0 : functor.add_const (topological_space (normed_comm_ring pos)) pos) : @regular_space.{0} (normed_comm_ring.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (normed_comm_ring.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_2158 (h2 : set (has_div to_additive.value_type)) : set.subsingleton h2 := sorry --non-trivial
lemma new_lemma_2159 (h0 : functor.add_const (topological_space (has_to_string name)) linarith.comp) : @topological_space.separable_space.{0} (has_to_string.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (has_to_string.{0} name)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_2160 (h0 : function.extfun Type ordered_add_comm_monoid) : @archimedean.{0} (cancel_monoid.{0} empty) (@function.extfun_app.{2 1} Type ordered_add_comm_monoid.{0} h0 (cancel_monoid.{0} empty))  := sorry --non-trivial
lemma new_lemma_2161 (h0 : semiring (nondiscrete_normed_field environment.projection_info)) (h1 : ideal (nondiscrete_normed_field environment.projection_info)) : ideal.is_prime h1 := sorry --non-trivial
lemma new_lemma_2162 (h0 : function.extfun nat fin) : @unique_factorization_monoid.{0} (add_comm_monoid.{0} linarith.comp) (@matrix.vec_empty.{0} (cancel_comm_monoid_with_zero.{0} (add_comm_monoid.{0} linarith.comp)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_2163 (h0 : topological_space (partial_order unsigned)) : t1_space (partial_order unsigned) := sorry --non-trivial
lemma new_lemma_2164 (h0 : topological_space (add_cancel_monoid congr_arg_kind)) : topological_space.separable_space (add_cancel_monoid congr_arg_kind) := sorry --non-trivial
lemma new_lemma_2165 (h0 : function.extfun Type topological_space) : @discrete_topology.{0} (ordered_ring.{0} (semiring.{0} (semiring.{0} (semiring.{0} empty)))) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (ordered_ring.{0} (semiring.{0} (semiring.{0} (semiring.{0} empty)))))  := sorry --non-trivial
lemma new_lemma_2166 (h0 : complete_lattice (has_union (semiring (semiring linarith.comp)))) : complete_lattice.is_Sup_finite_compact (has_union (semiring (semiring linarith.comp))) := sorry --non-trivial
lemma new_lemma_2167 (h0 : topological_space (has_emptyc (random_gen fun_info))) : t0_space (has_emptyc (random_gen fun_info)) := sorry --non-trivial
lemma new_lemma_2168 (h1 : group (with_zero (linear_ordered_comm_ring linarith.ineq))) : is_cyclic (with_zero (linear_ordered_comm_ring linarith.ineq)) := sorry --non-trivial
lemma new_lemma_2169 (h0 : functor.add_const (complete_lattice (ordered_cancel_add_comm_monoid unsigned)) num) : @is_compactly_generated.{0} (ordered_cancel_add_comm_monoid.{0} unsigned) (@functor.add_const.run.{0 0} (complete_lattice.{0} (ordered_cancel_add_comm_monoid.{0} unsigned)) num h0)  := sorry --non-trivial
lemma new_lemma_2170 (h0 : function.extfun Type list) : list.nodup (function.extfun_app h0 (canonically_ordered_comm_semiring empty)) := sorry --non-trivial
lemma new_lemma_2171 (h0 : prod (metric_space unsigned) (metric_space unsigned)) : id_rel h0 := sorry --non-trivial
lemma new_lemma_2172 (h0 : function.extfun Type topological_space) : @totally_separated_space.{0} (has_to_string.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_to_string.{0} pos))  := sorry --non-trivial
lemma new_lemma_2173 (h0 : functor.comp topological_space cancel_monoid ennreal) : @t0_space.{0} (cancel_monoid.{0} ennreal) (@functor.comp.run.{0 0 0} topological_space.{0} cancel_monoid.{0} ennreal h0)  := sorry --non-trivial
lemma new_lemma_2174 (h0 : topological_space (boolean_algebra (finset (finset (has_nndist (finset pos)))))) : totally_disconnected_space (boolean_algebra (finset (finset (has_nndist (finset pos))))) := sorry --non-trivial
lemma new_lemma_2175 (h0 : topological_space (canonically_linear_ordered_monoid real)) : topological_space.separable_space (canonically_linear_ordered_monoid real) := sorry --non-trivial
lemma new_lemma_2176 (h1 : group (random_gen fun_info)) : is_cyclic (random_gen fun_info) := sorry --non-trivial
lemma new_lemma_2177 (h0 : function.extfun Type group) : @normalizer_condition.{0} (has_Inf.{0} name) (@function.extfun_app.{2 1} Type group.{0} h0 (has_Inf.{0} name))  := sorry --non-trivial
lemma new_lemma_2178 (h0 : ring (ordered_comm_semiring (random_gen char))) : strong_rank_condition (ordered_comm_semiring (random_gen char)) := sorry --non-trivial
lemma new_lemma_2179 (h0 : ring (non_assoc_semiring (option unsigned))) : is_principal_ideal_ring (non_assoc_semiring (option unsigned)) := sorry --non-trivial
lemma new_lemma_2180 (h1 : ring (simple_graph linarith.ineq)) : is_domain (simple_graph linarith.ineq) := sorry --non-trivial
lemma new_lemma_2181 (h0 : functor.add_const (ring (complete_linear_order num)) num) : @is_principal_ideal_ring.{0} (complete_linear_order.{0} num) (@functor.add_const.run.{0 0} (ring.{0} (complete_linear_order.{0} num)) num h0)  := sorry --non-trivial
lemma new_lemma_2182 (h0 : topological_space (has_nndist (has_add pos))) : totally_disconnected_space (has_nndist (has_add pos)) := sorry --non-trivial
lemma new_lemma_2183 (h0 : topological_space (has_add (has_pos_part (has_pos_part (has_pos_part (has_pos_part (has_Inf pos))))))) : t0_space (has_add (has_pos_part (has_pos_part (has_pos_part (has_pos_part (has_Inf pos)))))) := sorry --non-trivial
lemma new_lemma_2184 (h0 : functor.add_const (group (has_zero linarith.comp)) (has_neg linarith.comp)) : @group.fg.{0} (has_zero.{0} linarith.comp) (@functor.add_const.run.{0 0} (group.{0} (has_zero.{0} linarith.comp)) (has_neg.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_2185 (h0 : ring (distrib_lattice (random_gen (linear_ordered_add_comm_group char)))) : is_domain (distrib_lattice (random_gen (linear_ordered_add_comm_group char))) := sorry --non-trivial
lemma new_lemma_2186 (h0 : uniform_space (has_dist ennreal)) : complete_space (has_dist ennreal) := sorry --non-trivial
lemma new_lemma_2187 (h0 : topological_space (ordered_ring empty)) : discrete_topology (ordered_ring empty) := sorry --non-trivial
lemma new_lemma_2188 (h0 : function.extfun Type complete_lattice) : @is_compactly_generated.{0} (has_nndist.{0} pos) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (has_nndist.{0} pos))  := sorry --non-trivial
lemma new_lemma_2189 (h0 : group pos) : is_simple_group pos := sorry --non-trivial
lemma new_lemma_2190 (h0 : complete_lattice (has_norm (has_top (has_top linarith.comp_source)))) : complete_lattice.is_Sup_finite_compact (has_norm (has_top (has_top linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_2191 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @t0_space.{0} (linear_ordered_field.{0} (option.{0} empty)) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (linear_ordered_field.{0} (option.{0} empty)))  := sorry --non-trivial
lemma new_lemma_2192 (h0 : set (char -> ereal)) : set.separates_points h0 := sorry --non-trivial
lemma new_lemma_2193 (h0 : add_monoid (has_zero (finset name))) : add_monoid.fg (has_zero (finset name)) := sorry --non-trivial
lemma new_lemma_2194 (h0 : topological_space (has_nndist (has_to_string name))) : discrete_topology (has_nndist (has_to_string name)) := sorry --non-trivial
lemma new_lemma_2195 (h0 : complete_lattice (has_neg (finset linarith.comp))) : is_compactly_generated (has_neg (finset linarith.comp)) := sorry --non-trivial
lemma new_lemma_2196 (h1 : topological_space (encodable (has_nnnorm char))) : path_connected_space (encodable (has_nnnorm char)) := sorry --non-trivial
lemma new_lemma_2197 (h0 : uniform_space (as_linear_order (option empty))) : separated_space (as_linear_order (option empty)) := sorry --non-trivial
lemma new_lemma_2198 (h0 : function.extfun Type add_monoid) : @add_monoid.fg.{0} (has_one.{0} num) (@function.extfun_app.{2 1} Type add_monoid.{0} h0 (has_one.{0} num))  := sorry --non-trivial
lemma new_lemma_2199 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @unique_factorization_monoid.{0} (boolean_algebra.core.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type cancel_comm_monoid_with_zero.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 cancel_comm_monoid_with_zero.{0}) (boolean_algebra.core.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_2200 (h0 : measurable_space environment.projection_info) (h1 : has_inf environment.projection_info) : has_measurable_inf environment.projection_info := sorry --non-trivial
lemma new_lemma_2201 (h0 : functor.add_const (uniform_space (add_group num)) num) : @complete_space.{0} (add_group.{0} num) (@functor.add_const.run.{0 0} (uniform_space.{0} (add_group.{0} num)) num h0)  := sorry --non-trivial
lemma new_lemma_2202 (h0 : topological_space (has_nndist (has_Inf (finset environment.implicit_infer_kind)))) : regular_space (has_nndist (has_Inf (finset environment.implicit_infer_kind))) := sorry --non-trivial
lemma new_lemma_2203 (h0 : function.extfun Type topological_space) : @totally_separated_space.{0} (complete_linear_order.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (complete_linear_order.{0} empty))  := sorry --non-trivial
lemma new_lemma_2204 (h0 : ring (has_to_string (cancel_monoid pos))) : rank_condition (has_to_string (cancel_monoid pos)) := sorry --non-trivial
lemma new_lemma_2205 (h0 : function.extfun Type group) : @is_cyclic.{0} (partial_order.{0} unsigned) (@function.extfun_app.{2 1} Type group.{0} h0 (partial_order.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_2206 (h0 : functor.add_const (topological_space (id empty)) congr_arg_kind) : @preirreducible_space.{0} (@id.{2} Type empty) (@functor.add_const.run.{0 0} (topological_space.{0} (@id.{2} Type empty)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_2207 (h0 : topological_space (left_cancel_semigroup (semiring (semiring congr_arg_kind)))) : locally_compact_space (left_cancel_semigroup (semiring (semiring congr_arg_kind))) := sorry --non-trivial
lemma new_lemma_2208 (h0 : functor.add_const (function.extfun Type add_monoid) pos) : @add_monoid.fg.{0} (has_to_string.{0} pos) (@function.extfun_app.{2 1} Type add_monoid.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type add_monoid.{0}) pos h0) (has_to_string.{0} pos))  := sorry --non-trivial
lemma new_lemma_2209 (h0 : monoid (mul_one_class to_additive.value_type)) (h1 : not (topological_space (mul_one_class (conj_classes (mul_one_class to_additive.value_type))) -> false)) : @totally_disconnected_space.{0} (mul_one_class.{0} (@conj_classes.{0} (mul_one_class.{0} to_additive.value_type) h0)) (@classical.by_contradiction'.{1} (topological_space.{0} (mul_one_class.{0} (@conj_classes.{0} (mul_one_class.{0} to_additive.value_type) h0))) h1)  := sorry --non-trivial
lemma new_lemma_2210 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @complete_lattice.is_Sup_finite_compact.{0} (has_neg.{0} num) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (has_neg.{0} num))  := sorry --non-trivial
lemma new_lemma_2211 (h0 : group (complete_distrib_lattice real)) : group.fg (complete_distrib_lattice real) := sorry --non-trivial
lemma new_lemma_2212 (h0 : ordered_add_comm_monoid (canonically_ordered_monoid (has_bot Type))) : archimedean (canonically_ordered_monoid (has_bot Type)) := sorry --non-trivial
lemma new_lemma_2213 (h0 : ordered_add_comm_monoid (cancel_monoid (add_comm_monoid (boolean_algebra.core environment.implicit_infer_kind)))) : archimedean (cancel_monoid (add_comm_monoid (boolean_algebra.core environment.implicit_infer_kind))) := sorry --non-trivial
lemma new_lemma_2214 (h0 : topological_space (has_top (semiring empty))) : normal_space (has_top (semiring empty)) := sorry --non-trivial
lemma new_lemma_2215 (h0 : ring (has_append (has_ssubset (random_gen (random_gen (random_gen char)))))) : strong_rank_condition (has_append (has_ssubset (random_gen (random_gen (random_gen char))))) := sorry --non-trivial
lemma new_lemma_2216 (h0 : add_monoid (boolean_algebra.core (finset pos))) : add_monoid.fg (boolean_algebra.core (finset pos)) := sorry --non-trivial
lemma new_lemma_2217 (h0 : function.extfun Type topological_space) : @t0_space.{0} (random_gen.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (random_gen.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_2218 (h0 : topological_space (topological_space (random_gen to_additive.value_type))) : locally_compact_space (topological_space (random_gen to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_2219 (h0 : functor.add_const (topological_space (left_cancel_monoid num)) empty) : @locally_compact_space.{0} (left_cancel_monoid.{0} num) (@functor.add_const.run.{0 0} (topological_space.{0} (left_cancel_monoid.{0} num)) empty h0)  := sorry --non-trivial
lemma new_lemma_2220 (h0 : topological_space (id (random_gen string_imp))) : locally_compact_space (id (random_gen string_imp)) := sorry --non-trivial
lemma new_lemma_2221 (h0 : functor.add_const (topological_space (simple_graph pos)) linarith.comp) : @loc_path_connected_space.{0} (simple_graph.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (simple_graph.{0} pos)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_2222 (h0 : uniform_space (complete_linear_order congr_arg_kind)) : separated_space (complete_linear_order congr_arg_kind) := sorry --non-trivial
lemma new_lemma_2223 (h0 : functor.add_const (topological_space (has_Inf Type)) (has_pos_part (has_Inf Type))) : @locally_compact_space.{1} (has_Inf.{1} Type) (@functor.add_const.run.{1 1} (topological_space.{1} (has_Inf.{1} Type)) (has_pos_part.{1} (has_Inf.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_2224 (h0 : not (group (with_one congr_arg_kind) -> false)) : @group.fg.{0} (with_one.{0} congr_arg_kind) (@classical.by_contradiction'.{1} (group.{0} (with_one.{0} congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_2225 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @complete_lattice.is_Sup_finite_compact.{0} (has_add.{0} pos) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (has_add.{0} pos))  := sorry --non-trivial
lemma new_lemma_2226 (h1 : not (ring (topological_space linarith.comp_source) -> false)) : @is_domain.{0} (topological_space.{0} linarith.comp_source) (@classical.by_contradiction'.{1} (ring.{0} (topological_space.{0} linarith.comp_source)) h1)  := sorry --non-trivial
lemma new_lemma_2227 (h0 : cancel_comm_monoid_with_zero (canonically_ordered_monoid (has_neg name))) : unique_factorization_monoid (canonically_ordered_monoid (has_neg name)) := sorry --non-trivial
lemma new_lemma_2228 (h0 : measurable_space (monoid (comm_monoid unsigned))) (h1 : measure_theory.measure (monoid (comm_monoid unsigned))) : measure_theory.is_probability_measure h1 := sorry --non-trivial
lemma new_lemma_2229 (h1 h2 : multiset (distrib (has_nnnorm string.iterator_imp))) : multiset.disjoint h1 h2 := sorry --non-trivial
lemma new_lemma_2230 (h0 : function.extfun Type topological_space) : @locally_compact_space.{0} (finset.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (finset.{0} empty))  := sorry --non-trivial
lemma new_lemma_2231 (h1 : topological_space (has_compl (random_gen char))) : path_connected_space (has_compl (random_gen char)) := sorry --non-trivial
lemma new_lemma_2232 (h0 : functor.add_const (group (has_pos_part linarith.comp)) pos) : @is_cyclic.{0} (has_pos_part.{0} linarith.comp) (@functor.add_const.run.{0 0} (group.{0} (has_pos_part.{0} linarith.comp)) pos h0)  := sorry --non-trivial
lemma new_lemma_2233 (h0 : topological_space (has_div (has_compl (mul_one_class string.iterator_imp)))) : totally_disconnected_space (has_div (has_compl (mul_one_class string.iterator_imp))) := sorry --non-trivial
lemma new_lemma_2234 (h0 : functor.add_const (topological_space (is_R_or_C num)) empty) : @irreducible_space.{0} (is_R_or_C.{0} num) (@functor.add_const.run.{0 0} (topological_space.{0} (is_R_or_C.{0} num)) empty h0)  := sorry --non-trivial
lemma new_lemma_2235 (h0 : ring (ring (option pos))) : rank_condition (ring (option pos)) := sorry --non-trivial
lemma new_lemma_2236 (h0 : functor.add_const (topological_space (has_nndist unsigned)) environment.implicit_infer_kind) : @topological_space.separable_space.{0} (has_nndist.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (has_nndist.{0} unsigned)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_2237 (h0 : function.extfun Type add_monoid) : @add_monoid.fg.{0} (with_bot.{0} empty) (@function.extfun_app.{2 1} Type add_monoid.{0} h0 (with_bot.{0} empty))  := sorry --non-trivial
lemma new_lemma_2238 (h1 : topological_space (with_one (random_gen string_imp))) : t0_space (with_one (random_gen string_imp)) := sorry --non-trivial
lemma new_lemma_2239 (h0 : complete_lattice (normed_comm_ring (has_to_string pos))) : is_compactly_generated (normed_comm_ring (has_to_string pos)) := sorry --non-trivial
lemma new_lemma_2240 (h0 : ring (non_unital_non_assoc_semiring reducibility_hints)) : rank_condition (non_unital_non_assoc_semiring reducibility_hints) := sorry --non-trivial
lemma new_lemma_2241 (h0 : functor.add_const (topological_space (semigroup pos)) linarith.comp) : @discrete_topology.{0} (semigroup.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (semigroup.{0} pos)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_2242 (h0 : add_group (add_zero_class string_imp)) : is_add_cyclic (add_zero_class string_imp) := sorry --non-trivial
lemma new_lemma_2243 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @loc_path_connected_space.{0} (normed_lattice_add_comm_group.{0} real) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (normed_lattice_add_comm_group.{0} real))  := sorry --non-trivial
lemma new_lemma_2244 (h0 : has_mem.mem (has_emptyc congr_arg_kind) has_emptyc.emptyc) : @totally_separated_space.{0} (has_emptyc.{0} congr_arg_kind) (@finset.pi.empty.{1 0} Type topological_space.{0} (has_emptyc.{0} congr_arg_kind) h0)  := sorry --non-trivial
lemma new_lemma_2245 (h0 : topological_space (has_nndist (has_Inf pos))) : locally_compact_space (has_nndist (has_Inf pos)) := sorry --non-trivial
lemma new_lemma_2246 (h0 : ring (has_pos_part (has_pos_part (finset (has_pos_part pos))))) : strong_rank_condition (has_pos_part (has_pos_part (finset (has_pos_part pos)))) := sorry --non-trivial
lemma new_lemma_2247 (h0 : functor.add_const (ordered_comm_monoid (normed_comm_ring pos)) (ring (ring Type))) : @has_exists_mul_of_le.{0} (normed_comm_ring.{0} pos) (@functor.add_const.run.{0 1} (ordered_comm_monoid.{0} (normed_comm_ring.{0} pos)) (ring.{1} (ring.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_2248 (h0 : functor.add_const (topological_space (as_linear_order unsigned)) (option empty)) : @t0_space.{0} (as_linear_order.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (as_linear_order.{0} unsigned)) (option.{0} empty) h0)  := sorry --non-trivial
lemma new_lemma_2249 (h0 : function.extfun Type topological_space) : @sequential_space.{0} (canonically_ordered_comm_semiring.{0} ennreal) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (canonically_ordered_comm_semiring.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_2250 (h0 : topological_space (cancel_monoid (finset name))) : locally_compact_space (cancel_monoid (finset name)) := sorry --non-trivial
lemma new_lemma_2251 (h1 : topological_space (add_left_cancel_monoid (has_nnnorm fun_info))) : totally_disconnected_space (add_left_cancel_monoid (has_nnnorm fun_info)) := sorry --non-trivial
lemma new_lemma_2252 (h0 : not (add_group (div_inv_monoid linarith.comp_source) -> false)) : @is_add_cyclic.{0} (div_inv_monoid.{0} linarith.comp_source) (@classical.by_contradiction'.{1} (add_group.{0} (div_inv_monoid.{0} linarith.comp_source)) h0)  := sorry --non-trivial
lemma new_lemma_2253 (h0 : group (linear_ordered_add_comm_group (has_inv to_additive.value_type))) : group.fg (linear_ordered_add_comm_group (has_inv to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_2254 (h0 : topological_space (normed_lattice_add_comm_group (has_neg real))) : topological_space.separable_space (normed_lattice_add_comm_group (has_neg real)) := sorry --non-trivial
lemma new_lemma_2255 (h0 : ring (preorder (option unsigned))) : is_domain (preorder (option unsigned)) := sorry --non-trivial
lemma new_lemma_2256 (h0 : function.extfun Type topological_space) : @preirreducible_space.{0} (has_zero.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_zero.{0} pos))  := sorry --non-trivial
lemma new_lemma_2257 (h0 : topological_space (linear_ordered_semiring (has_top (semiring num)))) : t0_space (linear_ordered_semiring (has_top (semiring num))) := sorry --non-trivial
lemma new_lemma_2258 (h0 : complete_lattice (has_to_string (cancel_monoid (has_nndist name)))) : is_atomistic (has_to_string (cancel_monoid (has_nndist name))) := sorry --non-trivial
lemma new_lemma_2259 (h0 : semiring (add_comm_monoid (ring environment.implicit_infer_kind))) : is_noetherian_ring (add_comm_monoid (ring environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_2260 (h0 : complete_lattice (with_bot (random_gen (has_top (random_gen fun_info))))) : complete_lattice.is_Sup_finite_compact (with_bot (random_gen (has_top (random_gen fun_info)))) := sorry --non-trivial
lemma new_lemma_2261 (h0 : functor.add_const (complete_lattice (finset environment.implicit_infer_kind)) unsigned) : @is_compactly_generated.{0} (finset.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (complete_lattice.{0} (finset.{0} environment.implicit_infer_kind)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_2262 (h0 : functor.add_const (group (add_comm_monoid pos)) (boolean_algebra Type)) : @group.fg.{0} (add_comm_monoid.{0} pos) (@functor.add_const.run.{0 1} (group.{0} (add_comm_monoid.{0} pos)) (boolean_algebra.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_2263 (h0 : topological_space (has_nnnorm to_additive.value_type)) : t0_space (has_nnnorm to_additive.value_type) := sorry --non-trivial
lemma new_lemma_2264 (h0 : group (has_inv (has_inv (has_inv to_additive.value_type)))) : is_cyclic (has_inv (has_inv (has_inv to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_2265 (h0 : filter (has_to_string (option (option (option (option (option (option (option unsigned))))))))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_2266 (h1 : ring (has_top char)) : is_domain (has_top char) := sorry --non-trivial
lemma new_lemma_2267 (h0 : uniform_space (canonically_linear_ordered_monoid real)) : separated_space (canonically_linear_ordered_monoid real) := sorry --non-trivial
lemma new_lemma_2268 (h0 : functor.add_const (topological_space (boolean_algebra.core unsigned)) environment.implicit_infer_kind) : @totally_separated_space.{0} (boolean_algebra.core.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (boolean_algebra.core.{0} unsigned)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_2269 (h0 : not (function.extfun Type topological_space -> false)) : @totally_separated_space.{0} fun_info (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) fun_info)  := sorry --non-trivial
lemma new_lemma_2270 (h0 : has_mem.mem add_group has_emptyc.emptyc) : @is_add_cyclic.{0} (normed_group.{0} fun_info) (@function.extfun_app.{2 1} Type add_group.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) add_group.{0} h0) (normed_group.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_2271 (h2 : ring (normed_field string.iterator_imp)) : rank_condition (normed_field string.iterator_imp) := sorry --non-trivial
lemma new_lemma_2272 (h0 : topological_space (has_bot (ordered_comm_monoid Type))) : t1_space (has_bot (ordered_comm_monoid Type)) := sorry --non-trivial
lemma new_lemma_2273 (h0 : ring (ring (boolean_algebra (boolean_algebra name)))) : rank_condition (ring (boolean_algebra (boolean_algebra name))) := sorry --non-trivial
lemma new_lemma_2274 (h0 : ring (has_nndist (comm_group Type))) : strong_rank_condition (has_nndist (comm_group Type)) := sorry --non-trivial
lemma new_lemma_2275 (h0 : preorder char) (h1 : set char) : set.is_pwo h1 := sorry --non-trivial
lemma new_lemma_2276 (h0 : function.extfun Type ring) : @rank_condition.{0} (has_pos_part.{0} pos) (@function.extfun_app.{2 1} Type ring.{0} h0 (has_pos_part.{0} pos))  := sorry --non-trivial
lemma new_lemma_2277 (h0 : ring (normed_comm_ring (has_add name))) : is_domain (normed_comm_ring (has_add name)) := sorry --non-trivial
lemma new_lemma_2278 (h0 : function.extfun Type group) : @normalizer_condition.{0} (has_to_string.{0} (option.{0} name)) (@function.extfun_app.{2 1} Type group.{0} h0 (has_to_string.{0} (option.{0} name)))  := sorry --non-trivial
lemma new_lemma_2279 (h0 : nat) (h1 : not (group (array h0 char) -> false)) : @is_cyclic.{0} (array.{0} h0 char) (@classical.by_contradiction'.{1} (group.{0} (array.{0} h0 char)) h1)  := sorry --non-trivial
lemma new_lemma_2280 (h1 : complete_lattice (distrib (comm_ring linarith.comp_source))) : complete_lattice.is_Sup_finite_compact (distrib (comm_ring linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_2281 (h0 : functor.add_const (topological_space (complete_distrib_lattice Type)) linarith.comp) : @totally_disconnected_space.{1} (complete_distrib_lattice.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (complete_distrib_lattice.{1} Type)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_2282 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @loc_path_connected_space.{0} (add_semigroup.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (add_semigroup.{0} empty))  := sorry --non-trivial
lemma new_lemma_2283 (h0 : functor.add_const (list (linear_order congr_arg_kind)) unsigned) : palindrome (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_2284 (h0 : functor.add_const (ring (cancel_monoid Type)) environment.implicit_infer_kind) : @strong_rank_condition.{1} (cancel_monoid.{1} Type) (@functor.add_const.run.{1 0} (ring.{1} (cancel_monoid.{1} Type)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_2285 (h0 : functor.add_const (topological_space (mul_zero_class ennreal)) Type) : @locally_compact_space.{0} (mul_zero_class.{0} ennreal) (@functor.add_const.run.{0 1} (topological_space.{0} (mul_zero_class.{0} ennreal)) Type h0)  := sorry --non-trivial
lemma new_lemma_2286 (h1 : not (topological_space (complete_semilattice_Sup string_imp) -> false)) : @totally_disconnected_space.{0} (complete_semilattice_Sup.{0} string_imp) (@classical.by_contradiction'.{1} (topological_space.{0} (complete_semilattice_Sup.{0} string_imp)) h1)  := sorry --non-trivial
lemma new_lemma_2287 (h0 : function.extfun Type (functor.add_const (topological_space (normed_linear_ordered_group unsigned)))) : @discrete_topology.{0} (normed_linear_ordered_group.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (normed_linear_ordered_group.{0} unsigned)) unsigned (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (topological_space.{0} (normed_linear_ordered_group.{0} unsigned))) h0 unsigned))  := sorry --non-trivial
lemma new_lemma_2288 (h1 : not (function.extfun Type topological_space -> false)) : @locally_compact_space.{0} (with_bot.{0} fun_info) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h1) (with_bot.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_2289 (h0 : ring (option unsigned)) : is_principal_ideal_ring (option unsigned) := sorry --non-trivial
lemma new_lemma_2290 (h0 : uniform_space (normed_linear_ordered_group num)) : separated_space (normed_linear_ordered_group num) := sorry --non-trivial
lemma new_lemma_2291 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_add_cyclic.{0} (has_top.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type add_group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 add_group.{0}) (has_top.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_2292 (h0 : topological_space (simple_graph (random_gen (random_gen to_additive.value_type)))) : path_connected_space (simple_graph (random_gen (random_gen to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_2293 (h0 : topological_space (simple_graph (has_neg linarith.comp))) : normal_space (simple_graph (has_neg linarith.comp)) := sorry --non-trivial
lemma new_lemma_2294 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_atomistic.{0} (left_cancel_monoid.{0} num) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (left_cancel_monoid.{0} num))  := sorry --non-trivial
lemma new_lemma_2295 (h0 : topological_space (random_gen (comm_ring (has_inv linarith.ineq)))) : locally_compact_space (random_gen (comm_ring (has_inv linarith.ineq))) := sorry --non-trivial
lemma new_lemma_2296 (h0 : ring (comm_semigroup (has_Inf Type))) : strong_rank_condition (comm_semigroup (has_Inf Type)) := sorry --non-trivial
lemma new_lemma_2297 (h0 : ring (nondiscrete_normed_field environment.projection_info)) : strong_rank_condition (nondiscrete_normed_field environment.projection_info) := sorry --non-trivial
lemma new_lemma_2298 (h0 : complete_lattice (has_div (mul_one_class (has_nnnorm linarith.ineq)))) : complete_lattice.is_Sup_finite_compact (has_div (mul_one_class (has_nnnorm linarith.ineq))) := sorry --non-trivial
lemma new_lemma_2299 (h0 : functor.add_const (filter (has_neg pos)) (ring (has_add Type))) : countable_Inter_filter (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_2300 (h0 : group (with_bot empty)) : normalizer_condition (with_bot empty) := sorry --non-trivial
lemma new_lemma_2301 (h0 : ring (monoid_with_zero unsigned) -> ring (monoid_with_zero unsigned) -> Prop) : is_symm (ring (monoid_with_zero unsigned)) h0 := sorry --non-trivial
lemma new_lemma_2302 (h0 : topological_space (mul_zero_class ennreal)) : preirreducible_space (mul_zero_class ennreal) := sorry --non-trivial
lemma new_lemma_2303 (h0 : group (random_gen (comm_ring (comm_ring to_additive.value_type)))) : is_cyclic (random_gen (comm_ring (comm_ring to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_2304 (h0 : functor.add_const (topological_space (normed_comm_ring environment.implicit_infer_kind)) name) : @preconnected_space.{0} (normed_comm_ring.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (normed_comm_ring.{0} environment.implicit_infer_kind)) name h0)  := sorry --non-trivial
lemma new_lemma_2305 (h0 : group (add_right_cancel_monoid (semiring num))) : group.fg (add_right_cancel_monoid (semiring num)) := sorry --non-trivial
lemma new_lemma_2306 (h0 : add_group (has_nndist (has_add linarith.comp))) : is_add_cyclic (has_nndist (has_add linarith.comp)) := sorry --non-trivial
lemma new_lemma_2307 (h0 : functor.add_const (function.extfun (Type 1) topological_space) pos) : @irreducible_space.{1} Type (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) topological_space.{1}) pos h0) Type)  := sorry --non-trivial
lemma new_lemma_2308 (h0 : topological_space (has_add (has_to_string congr_arg_kind))) : preirreducible_space (has_add (has_to_string congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_2309 (h0 : fin has_zero.zero) : @is_simple_group.{0} (normed_lattice_add_comm_group.{0} real) (@matrix.vec_empty.{0} (group.{0} (normed_lattice_add_comm_group.{0} real)) h0)  := sorry --non-trivial
lemma new_lemma_2310 (h0 : topological_space (semigroup (has_nndist Type))) : preconnected_space (semigroup (has_nndist Type)) := sorry --non-trivial
lemma new_lemma_2311 (h0 : has_lt (has_nnnorm to_additive.value_type)) : no_max_order (has_nnnorm to_additive.value_type) := sorry --non-trivial
lemma new_lemma_2312 (h0 : topological_space (has_nndist (has_add (finset (finset linarith.comp))))) : t0_space (has_nndist (has_add (finset (finset linarith.comp)))) := sorry --non-trivial
lemma new_lemma_2313 (h0 : not (topological_space (denumerable linarith.comp_source) -> false)) : @totally_disconnected_space.{0} (denumerable.{0} linarith.comp_source) (@classical.by_contradiction'.{1} (topological_space.{0} (denumerable.{0} linarith.comp_source)) h0)  := sorry --non-trivial
lemma new_lemma_2314 (h0 : function.extfun Type list) : palindrome (function.extfun_app h0 (linear_order unsigned)) := sorry --non-trivial
lemma new_lemma_2315 (h0 : function.extfun Type ring) : @is_domain.{0} (semigroup.{0} ennreal) (@function.extfun_app.{2 1} Type ring.{0} h0 (semigroup.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_2316 (h0 : ring (boolean_algebra (has_add (has_add name)))) : strong_rank_condition (boolean_algebra (has_add (has_add name))) := sorry --non-trivial
lemma new_lemma_2317 (h0 : functor.add_const (topological_space (generalized_boolean_algebra pos)) (finset pos)) : @regular_space.{0} (generalized_boolean_algebra.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (generalized_boolean_algebra.{0} pos)) (finset.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_2318 (h0 : topological_space (has_Inf (has_Inf Type))) : t1_space (has_Inf (has_Inf Type)) := sorry --non-trivial
lemma new_lemma_2319 (h0 : topological_space (topological_space linarith.ineq)) : path_connected_space (topological_space linarith.ineq) := sorry --non-trivial
lemma new_lemma_2320 (h0 : functor.add_const (topological_space (add_cancel_monoid pos)) (cancel_monoid pos)) : @sequential_space.{0} (add_cancel_monoid.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (add_cancel_monoid.{0} pos)) (cancel_monoid.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_2321 (h0 : topological_space (has_pos_part (has_neg (has_Inf linarith.comp)))) : t0_space (has_pos_part (has_neg (has_Inf linarith.comp))) := sorry --non-trivial
lemma new_lemma_2322 (h0 : topological_space (complete_linear_order (semiring num))) : t1_space (complete_linear_order (semiring num)) := sorry --non-trivial
lemma new_lemma_2323 (h0 : topological_space (encodable to_additive.value_type)) : t0_space (encodable to_additive.value_type) := sorry --non-trivial
lemma new_lemma_2324 (h0 : not (topological_space (random_gen fun_info) -> false)) : @totally_separated_space.{0} (random_gen.{0} fun_info) (@classical.by_contradiction'.{1} (topological_space.{0} (random_gen.{0} fun_info)) h0)  := sorry --non-trivial
lemma new_lemma_2325 (h0 : ring (has_norm (has_norm num))) : rank_condition (has_norm (has_norm num)) := sorry --non-trivial
lemma new_lemma_2326 (h0 : topological_space (comm_group name)) : discrete_topology (comm_group name) := sorry --non-trivial
lemma new_lemma_2327 (h0 : topological_space (complete_distrib_lattice (option (option unsigned)))) : loc_path_connected_space (complete_distrib_lattice (option (option unsigned))) := sorry --non-trivial
lemma new_lemma_2328 (h0 : monoid (normed_lattice_add_comm_group (sub_neg_monoid real))) : monoid.fg (normed_lattice_add_comm_group (sub_neg_monoid real)) := sorry --non-trivial
lemma new_lemma_2329 (h0 : not (topological_space (encodable to_additive.value_type) -> false)) : @locally_compact_space.{0} (encodable.{0} to_additive.value_type) (@classical.by_contradiction'.{1} (topological_space.{0} (encodable.{0} to_additive.value_type)) h0)  := sorry --non-trivial
lemma new_lemma_2330 (h0 : fin has_zero.zero) : @group.fg.{0} (complete_distrib_lattice.{0} name) (@matrix.vec_empty.{0} (group.{0} (complete_distrib_lattice.{0} name)) h0)  := sorry --non-trivial
lemma new_lemma_2331 (h0 : uniform_space (add_comm_monoid (comm_group Type))) : complete_space (add_comm_monoid (comm_group Type)) := sorry --non-trivial
lemma new_lemma_2332 (h0 : add_monoid (add_left_cancel_semigroup empty)) : add_monoid.fg (add_left_cancel_semigroup empty) := sorry --non-trivial
lemma new_lemma_2333 (h0 : function.extfun Type (functor.add_const (ring (add_left_cancel_semigroup unsigned)))) : @is_domain.{0} (add_left_cancel_semigroup.{0} unsigned) (@functor.add_const.run.{0 0} (ring.{0} (add_left_cancel_semigroup.{0} unsigned)) empty (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (ring.{0} (add_left_cancel_semigroup.{0} unsigned))) h0 empty))  := sorry --non-trivial
lemma new_lemma_2334 (h0 : functor.add_const (topological_space (semigroup empty)) empty) : @locally_compact_space.{0} (semigroup.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (semigroup.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_2335 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @monoid.fg.{0} (linear_ordered_comm_group.{0} unsigned) (@function.extfun_app.{2 1} Type monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 monoid.{0}) (linear_ordered_comm_group.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_2336 (h0 : not (function.extfun Type topological_space -> false)) : @irreducible_space.{0} (measurable_space.{0} linarith.ineq) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (measurable_space.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_2337 (h0 : function.extfun Type topological_space) : @t0_space.{0} (left_cancel_semigroup.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (left_cancel_semigroup.{0} num))  := sorry --non-trivial
lemma new_lemma_2338 (h0 : topological_space (has_neg_part (has_add Type))) : loc_path_connected_space (has_neg_part (has_add Type)) := sorry --non-trivial
lemma new_lemma_2339 (h0 : topological_space (uniform_space (has_ssubset (has_ssubset reducibility_hints)))) : path_connected_space (uniform_space (has_ssubset (has_ssubset reducibility_hints))) := sorry --non-trivial
lemma new_lemma_2340 (h0 : complete_lattice (has_compl (random_gen (random_gen linarith.ineq)))) : is_compactly_generated (has_compl (random_gen (random_gen linarith.ineq))) := sorry --non-trivial
lemma new_lemma_2341 (h0 : function.extfun (finset (Type -> Type)) (has_mem.mem topological_space)) : @totally_disconnected_space.{0} congr_arg_kind (@function.extfun_app.{2 1} Type topological_space.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) topological_space.{0} (@function.extfun_app.{2 0} (finset.{1} (Type → Type)) (@has_mem.mem.{1 1} (Type → Type) (finset.{1} (Type → Type)) (@finset.has_mem.{1} (Type → Type)) topological_space.{0}) h0 (@has_emptyc.emptyc.{1} (finset.{1} (Type → Type)) (@finset.has_emptyc.{1} (Type → Type))))) congr_arg_kind)  := sorry --non-trivial
lemma new_lemma_2342 (h0 : topological_space (finset name)) : regular_space (finset name) := sorry --non-trivial
lemma new_lemma_2343 (h0 : not (function.extfun Type topological_space -> false)) : @t0_space.{0} (mul_one_class.{0} char) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (mul_one_class.{0} char))  := sorry --non-trivial
lemma new_lemma_2344 (h0 : topological_space (linear_ordered_add_comm_group (has_nnnorm (random_gen linarith.ineq)))) : path_connected_space (linear_ordered_add_comm_group (has_nnnorm (random_gen linarith.ineq))) := sorry --non-trivial
lemma new_lemma_2345 (h0 : cancel_comm_monoid_with_zero (finset (comm_group Type))) : unique_factorization_monoid (finset (comm_group Type)) := sorry --non-trivial
lemma new_lemma_2346 (h0 : group (complete_distrib_lattice (semiring (semiring (semiring (semiring empty)))))) : group.fg (complete_distrib_lattice (semiring (semiring (semiring (semiring empty))))) := sorry --non-trivial
lemma new_lemma_2347 (h0 : function.extfun Type topological_space) : @topological_space.separable_space.{0} (linear_order.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (linear_order.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_2348 (h0 : functor.add_const (add_group (as_linear_order empty)) congr_arg_kind) : @is_add_cyclic.{0} (as_linear_order.{0} empty) (@functor.add_const.run.{0 0} (add_group.{0} (as_linear_order.{0} empty)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_2349 (h0 : topological_space (topological_space (has_nnnorm (random_gen (random_gen fun_info))))) : locally_compact_space (topological_space (has_nnnorm (random_gen (random_gen fun_info)))) := sorry --non-trivial
lemma new_lemma_2350 (h0 : topological_space (has_Inf (has_add name))) : irreducible_space (has_Inf (has_add name)) := sorry --non-trivial
lemma new_lemma_2351 (h0 : topological_space (add_comm_semigroup string.iterator_imp)) (h1 : preorder (add_comm_semigroup string.iterator_imp)) : order_topology (add_comm_semigroup string.iterator_imp) := sorry --non-trivial
lemma new_lemma_2352 (h1 : set (semi_normed_comm_ring string_imp)) : set.subsingleton h1 := sorry --non-trivial
lemma new_lemma_2353 (h0 : function.extfun Type ring) : @is_domain.{0} (comm_semigroup.{0} real) (@function.extfun_app.{2 1} Type ring.{0} h0 (comm_semigroup.{0} real))  := sorry --non-trivial
lemma new_lemma_2354 (h0 : ring (random_gen char)) : is_domain (random_gen char) := sorry --non-trivial
lemma new_lemma_2355 (h0 : topological_space (boolean_algebra (add_comm_monoid environment.implicit_infer_kind))) : preconnected_space (boolean_algebra (add_comm_monoid environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_2356 (h0 : functor.add_const (ring (comm_group environment.implicit_infer_kind)) name) : @is_principal_ideal_ring.{0} (comm_group.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (ring.{0} (comm_group.{0} environment.implicit_infer_kind)) name h0)  := sorry --non-trivial
lemma new_lemma_2357 (h1 : topological_space ereal) (h2 : preorder ereal) : order_topology ereal := sorry --non-trivial
lemma new_lemma_2358 (h0 : functor.add_const (ring (has_add unsigned)) ennreal) : @is_domain.{0} (has_add.{0} unsigned) (@functor.add_const.run.{0 0} (ring.{0} (has_add.{0} unsigned)) ennreal h0)  := sorry --non-trivial
lemma new_lemma_2359 (h0 : functor.add_const (topological_space (has_to_string linarith.comp)) linarith.comp) : @t0_space.{0} (has_to_string.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (has_to_string.{0} linarith.comp)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_2360 (h0 : function.extfun Type topological_space) : @path_connected_space.{0} (has_inter.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_inter.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_2361 (h0 : topological_space (has_zero environment.implicit_infer_kind)) : regular_space (has_zero environment.implicit_infer_kind) := sorry --non-trivial
lemma new_lemma_2362 (h0 : function.extfun Type list) : list.nodup (function.extfun_app h0 (normed_group fun_info)) := sorry --non-trivial
lemma new_lemma_2363 (h0 : function.extfun nat fin) : @preconnected_space.{1} (has_bot.{1} Type) (@matrix.vec_empty.{1} (topological_space.{1} (has_bot.{1} Type)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_2364 (h0 : topological_space (semiring congr_arg_kind)) : loc_path_connected_space (semiring congr_arg_kind) := sorry --non-trivial
lemma new_lemma_2365 (h0 : ring (left_cancel_monoid fun_info)) : is_domain (left_cancel_monoid fun_info) := sorry --non-trivial
lemma new_lemma_2366 (h0 : not (function.extfun Type topological_space -> false)) : @locally_compact_space.{0} congr_arg_kind (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) congr_arg_kind)  := sorry --non-trivial
lemma new_lemma_2367 (h0 : has_inv (has_top (has_inv to_additive.value_type)) -> has_inv (has_top (has_inv to_additive.value_type)) -> Prop) : is_order_connected (has_inv (has_top (has_inv to_additive.value_type))) h0 := sorry --non-trivial
lemma new_lemma_2368 (h1 h2 : multiset (has_ssubset reducibility_hints)) : multiset.subset h1 h2 := sorry --non-trivial
lemma new_lemma_2369 (h0 : function.extfun Type monoid) : @monoid.fg.{0} (cancel_monoid.{0} empty) (@function.extfun_app.{2 1} Type monoid.{0} h0 (cancel_monoid.{0} empty))  := sorry --non-trivial
lemma new_lemma_2370 (h0 : complete_lattice (with_bot (canonically_ordered_add_monoid empty))) : is_compactly_generated (with_bot (canonically_ordered_add_monoid empty)) := sorry --non-trivial
lemma new_lemma_2371 (h0 : fin has_zero.zero) : @is_compactly_generated.{0} (has_add.{0} real) (@matrix.vec_empty.{0} (complete_lattice.{0} (has_add.{0} real)) h0)  := sorry --non-trivial
lemma new_lemma_2372 (h0 : group (generalized_boolean_algebra (ring (has_Inf Type)))) : normalizer_condition (generalized_boolean_algebra (ring (has_Inf Type))) := sorry --non-trivial
lemma new_lemma_2373 (h0 : topological_space (ordered_ring (semiring unsigned))) : locally_compact_space (ordered_ring (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_2374 (h0 : topological_space (linear_ordered_field ennreal)) : normal_space (linear_ordered_field ennreal) := sorry --non-trivial
lemma new_lemma_2375 (h0 : topological_space (linear_ordered_add_comm_monoid_with_top ennreal)) : irreducible_space (linear_ordered_add_comm_monoid_with_top ennreal) := sorry --non-trivial
lemma new_lemma_2376 (h0 : function.extfun Type finset) : finset.nonempty (function.extfun_app h0 (ordered_comm_ring name)) := sorry --non-trivial
lemma new_lemma_2377 (h0 : add_group (canonically_ordered_comm_semiring (ring (ring linarith.comp)))) : is_add_cyclic (canonically_ordered_comm_semiring (ring (ring linarith.comp))) := sorry --non-trivial
lemma new_lemma_2378 (h0 : topological_space (cancel_monoid (semigroup (has_add (has_add name))))) : normal_space (cancel_monoid (semigroup (has_add (has_add name)))) := sorry --non-trivial
lemma new_lemma_2379 (h0 : ring (comm_monoid empty)) : rank_condition (comm_monoid empty) := sorry --non-trivial
lemma new_lemma_2380 (h0 : functor.add_const Prop pos) : functor.add_const.run h0 := sorry --non-trivial
lemma new_lemma_2381 (h0 h1 : multiset (simple_graph enat)) : multiset.disjoint h0 h1 := sorry --non-trivial
lemma new_lemma_2382 (h0 : functor.comp topological_space comm_group environment.implicit_infer_kind) : @path_connected_space.{0} (comm_group.{0} environment.implicit_infer_kind) (@functor.comp.run.{0 0 0} topological_space.{0} comm_group.{0} environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_2383 (h0 : topological_space (boolean_algebra.core (finset (finset ennreal)))) : preirreducible_space (boolean_algebra.core (finset (finset ennreal))) := sorry --non-trivial
lemma new_lemma_2384 (h0 : topological_space (has_ssubset (comm_ring (random_gen to_additive.value_type)))) : totally_disconnected_space (has_ssubset (comm_ring (random_gen to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_2385 (h0 : function.extfun Type topological_space) : @loc_path_connected_space.{0} (add_cancel_monoid.{0} ennreal) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (add_cancel_monoid.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_2386 (h0 : function.extfun Type group) : @is_simple_group.{0} (has_add.{0} ennreal) (@function.extfun_app.{2 1} Type group.{0} h0 (has_add.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_2387 (h0 : function.extfun Type filter) : filter.ne_bot (function.extfun_app h0 real.angle) := sorry --non-trivial
lemma new_lemma_2388 (h0 : functor.add_const (topological_space (pseudo_metric_space pos)) pos) : @loc_path_connected_space.{0} (pseudo_metric_space.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (pseudo_metric_space.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_2389 (h0 : topological_space (has_zero (cancel_monoid (option unsigned)))) : t1_space (has_zero (cancel_monoid (option unsigned))) := sorry --non-trivial
lemma new_lemma_2390 (h0 : topological_space (has_neg (finset linarith.comp))) : topological_space.separable_space (has_neg (finset linarith.comp)) := sorry --non-trivial
lemma new_lemma_2391 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @group.fg.{0} (semi_normed_comm_ring.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (semi_normed_comm_ring.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_2392 (h0 : uniform_space (has_to_string (has_add linarith.comp))) : complete_space (has_to_string (has_add linarith.comp)) := sorry --non-trivial
lemma new_lemma_2393 (h0 : not (ring (has_star congr_arg_kind) -> false)) : @is_principal_ideal_ring.{0} (has_star.{0} congr_arg_kind) (@classical.by_contradiction'.{1} (ring.{0} (has_star.{0} congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_2394 (h8 : not (topological_space (linear_ordered_comm_group_with_zero reducibility_hints) -> false)) : @totally_disconnected_space.{0} (linear_ordered_comm_group_with_zero.{0} reducibility_hints) (@classical.by_contradiction'.{1} (topological_space.{0} (linear_ordered_comm_group_with_zero.{0} reducibility_hints)) h8)  := sorry --non-trivial
lemma new_lemma_2395 (h0 : topological_space (has_union (has_union congr_arg_kind))) : normal_space (has_union (has_union congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_2396 (h0 : functor.add_const (topological_space (has_neg_part pos)) unsigned) : @path_connected_space.{0} (has_neg_part.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (has_neg_part.{0} pos)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_2397 (h1 : function.extfun (Type -> Type) (function.extfun Type)) : @rank_condition.{0} (has_top.{0} string_imp) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h1 ring.{0}) (has_top.{0} string_imp))  := sorry --non-trivial
lemma new_lemma_2398 (h0 : functor.add_const (topological_space (semigroup unsigned)) unsigned) : @locally_compact_space.{0} (semigroup.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (semigroup.{0} unsigned)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_2399 (h0 : topological_space (ring (has_pos_part linarith.comp))) : locally_compact_space (ring (has_pos_part linarith.comp)) := sorry --non-trivial
lemma new_lemma_2400 (h0 : not (add_group (has_top linarith.comp_source) -> false)) : @is_add_cyclic.{0} (has_top.{0} linarith.comp_source) (@classical.by_contradiction'.{1} (add_group.{0} (has_top.{0} linarith.comp_source)) h0)  := sorry --non-trivial
lemma new_lemma_2401 (h0 : monoid (has_to_string (ring (has_neg (has_zero (finset (has_neg Type))))))) : monoid.fg (has_to_string (ring (has_neg (has_zero (finset (has_neg Type)))))) := sorry --non-trivial
lemma new_lemma_2402 (h0 : functor.add_const (ring (monoid empty)) empty) : @strong_rank_condition.{0} (monoid.{0} empty) (@functor.add_const.run.{0 0} (ring.{0} (monoid.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_2403 (h0 : topological_space (denumerable (has_ssubset (random_gen to_additive.value_type)))) : t0_space (denumerable (has_ssubset (random_gen to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_2404 (h0 : functor.add_const (function.extfun Type topological_space) name) : @loc_path_connected_space.{0} (comm_group.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) name h0) (comm_group.{0} pos))  := sorry --non-trivial
lemma new_lemma_2405 (h0 : topological_space (has_neg (semigroup pos))) : t0_space (has_neg (semigroup pos)) := sorry --non-trivial
lemma new_lemma_2406 (h0 : group (is_R_or_C (semiring (semiring (semiring (semiring empty)))))) : group.fg (is_R_or_C (semiring (semiring (semiring (semiring empty))))) := sorry --non-trivial
lemma new_lemma_2407 (h0 : not (function.extfun Type uniform_space -> false)) : @complete_space.{0} (with_bot.{0} linarith.ineq) (@function.extfun_app.{2 1} Type uniform_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type uniform_space.{0}) h0) (with_bot.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_2408 (h0 : complete_lattice (canonically_linear_ordered_monoid num)) : is_atomistic (canonically_linear_ordered_monoid num) := sorry --non-trivial
lemma new_lemma_2409 (h0 : functor.add_const (monoid (normed_comm_ring linarith.comp)) (has_to_string (ring pos))) : @monoid.fg.{0} (normed_comm_ring.{0} linarith.comp) (@functor.add_const.run.{0 0} (monoid.{0} (normed_comm_ring.{0} linarith.comp)) (has_to_string.{0} (ring.{0} pos)) h0)  := sorry --non-trivial
lemma new_lemma_2410 (h0 : cancel_comm_monoid_with_zero (normed_comm_ring (semigroup Type))) : unique_factorization_monoid (normed_comm_ring (semigroup Type)) := sorry --non-trivial
lemma new_lemma_2411 (h0 : list (has_norm (dlist to_additive.value_type))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_2412 (h0 : functor.add_const (function.extfun (Type 1) topological_space) Type) : @topological_space.separable_space.{1} (normed_comm_ring.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@functor.add_const.run.{2 1} (function.extfun.{3 2} (Type 1) topological_space.{1}) Type h0) (normed_comm_ring.{1} Type))  := sorry --non-trivial
lemma new_lemma_2413 (h0 : ordered_add_comm_monoid (boolean_algebra.core (option (option empty)))) : archimedean (boolean_algebra.core (option (option empty))) := sorry --non-trivial
lemma new_lemma_2414 (h0 : topological_space (has_bot real)) : normal_space (has_bot real) := sorry --non-trivial
lemma new_lemma_2415 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @separated_space.{0} (has_norm.{0} (semiring.{0} (semiring.{0} (has_norm.{0} (has_norm.{0} linarith.comp))))) (@function.extfun_app.{2 1} Type uniform_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 uniform_space.{0}) (has_norm.{0} (semiring.{0} (semiring.{0} (has_norm.{0} (has_norm.{0} linarith.comp))))))  := sorry --non-trivial
lemma new_lemma_2416 (h0 : functor.add_const (topological_space (has_nndist pos)) linarith.comp) : @path_connected_space.{0} (has_nndist.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (has_nndist.{0} pos)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_2417 (h0 : functor.add_const (ring (add_cancel_monoid linarith.comp)) Type) : @rank_condition.{0} (add_cancel_monoid.{0} linarith.comp) (@functor.add_const.run.{0 1} (ring.{0} (add_cancel_monoid.{0} linarith.comp)) Type h0)  := sorry --non-trivial
lemma new_lemma_2418 (h0 : uniform_space (has_zero (has_add pos))) : separated_space (has_zero (has_add pos)) := sorry --non-trivial
lemma new_lemma_2419 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @monoid.fg.{0} (linear_ordered_add_comm_group.{0} fun_info) (@function.extfun_app.{2 1} Type monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 monoid.{0}) (linear_ordered_add_comm_group.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_2420 (h0 : topological_space (simple_graph (has_Inf Type))) : sequential_space (simple_graph (has_Inf Type)) := sorry --non-trivial
lemma new_lemma_2421 (h0 : function.extfun Type semiring) : @is_noetherian_ring.{0} (pseudo_metric_space.{0} ennreal) (@function.extfun_app.{2 1} Type semiring.{0} h0 (pseudo_metric_space.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_2422 (h2 : group (with_one (with_bot congr_arg_kind))) : normalizer_condition (with_one (with_bot congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_2423 (h0 : functor.add_const (topological_space (left_cancel_semigroup congr_arg_kind)) unsigned) : @normal_space.{0} (left_cancel_semigroup.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (left_cancel_semigroup.{0} congr_arg_kind)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_2424 (h0 : topological_space (boolean_algebra.core (add_comm_monoid Type))) : preirreducible_space (boolean_algebra.core (add_comm_monoid Type)) := sorry --non-trivial
lemma new_lemma_2425 (h0 : topological_space (ring (option (option (option pos))))) : preirreducible_space (ring (option (option (option pos)))) := sorry --non-trivial
lemma new_lemma_2426 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @add_monoid.fg.{0} (add_cancel_monoid.{0} unsigned) (@function.extfun_app.{2 1} Type add_monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 add_monoid.{0}) (add_cancel_monoid.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_2427 (h0 : functor.add_const (cancel_comm_monoid_with_zero (has_nndist pos)) name) : @unique_factorization_monoid.{0} (has_nndist.{0} pos) (@functor.add_const.run.{0 0} (cancel_comm_monoid_with_zero.{0} (has_nndist.{0} pos)) name h0)  := sorry --non-trivial
lemma new_lemma_2428 (h0 : functor.add_const (topological_space znum) (option (option empty))) : @t0_space.{0} znum (@functor.add_const.run.{0 0} (topological_space.{0} znum) (option.{0} (option.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_2429 (h0 : ring (topological_space (comm_ring (comm_ring reducibility_hints)))) : rank_condition (topological_space (comm_ring (comm_ring reducibility_hints))) := sorry --non-trivial
lemma new_lemma_2430 (h0 : has_inv (comm_ring (random_gen linarith.ineq)) -> Prop) : @infi.{0 1} Prop (@conditionally_complete_lattice.to_has_Inf.{0} Prop (@complete_lattice.to_conditionally_complete_lattice.{0} Prop Prop.complete_lattice)) (has_inv.{0} (comm_ring.{0} (random_gen.{0} linarith.ineq))) h0  := sorry --non-trivial
lemma new_lemma_2431 (h0 : not (function.extfun Type complete_lattice -> false)) : @is_compactly_generated.{0} (add_right_cancel_monoid.{0} empty) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type complete_lattice.{0}) h0) (add_right_cancel_monoid.{0} empty))  := sorry --non-trivial
lemma new_lemma_2432 (h0 : not (topological_space (ordered_cancel_add_comm_monoid num) -> false)) : @path_connected_space.{0} (ordered_cancel_add_comm_monoid.{0} num) (@classical.by_contradiction'.{1} (topological_space.{0} (ordered_cancel_add_comm_monoid.{0} num)) h0)  := sorry --non-trivial
lemma new_lemma_2433 (h1 : uniform_space (semi_normed_comm_ring reducibility_hints)) : complete_space (semi_normed_comm_ring reducibility_hints) := sorry --non-trivial
lemma new_lemma_2434 (h0 : functor.add_const (ring (has_neg name)) name) : @is_principal_ideal_ring.{0} (has_neg.{0} name) (@functor.add_const.run.{0 0} (ring.{0} (has_neg.{0} name)) name h0)  := sorry --non-trivial
lemma new_lemma_2435 (h0 : topological_space (add_group (semiring congr_arg_kind))) : normal_space (add_group (semiring congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_2436 (h0 : complete_lattice (has_add (finset (has_zero pos)))) : complete_lattice.is_Sup_finite_compact (has_add (finset (has_zero pos))) := sorry --non-trivial
lemma new_lemma_2437 (h0 : topological_space (has_compl (boolean_algebra string_imp))) : locally_compact_space (has_compl (boolean_algebra string_imp)) := sorry --non-trivial
lemma new_lemma_2438 (h0 : semiring (has_add (ring name))) : is_noetherian_ring (has_add (ring name)) := sorry --non-trivial
lemma new_lemma_2439 (h0 : functor.add_const (topological_space (has_Inf linarith.comp)) Type) : @t0_space.{0} (has_Inf.{0} linarith.comp) (@functor.add_const.run.{0 1} (topological_space.{0} (has_Inf.{0} linarith.comp)) Type h0)  := sorry --non-trivial
lemma new_lemma_2440 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @locally_compact_space.{0} (complete_distrib_lattice.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (complete_distrib_lattice.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_2441 (h0 : add_group (ring (ring (ring (ring pos))))) : is_add_cyclic (ring (ring (ring (ring pos)))) := sorry --non-trivial
lemma new_lemma_2442 (h0 : function.extfun Type add_monoid) : @add_monoid.fg.{0} (has_Sup.{0} (option.{0} empty)) (@function.extfun_app.{2 1} Type add_monoid.{0} h0 (has_Sup.{0} (option.{0} empty)))  := sorry --non-trivial
lemma new_lemma_2443 (h0 : topological_space (has_add (mul_one_class (has_add (mul_one_class linarith.comp))))) : preconnected_space (has_add (mul_one_class (has_add (mul_one_class linarith.comp)))) := sorry --non-trivial
lemma new_lemma_2444 (h0 : ordered_add_comm_monoid (add_comm_monoid unsigned)) : archimedean (add_comm_monoid unsigned) := sorry --non-trivial
lemma new_lemma_2445 (h0 : fin has_zero.zero) : @monoid.fg.{0} (ordered_comm_ring.{0} real) (@matrix.vec_empty.{0} (monoid.{0} (ordered_comm_ring.{0} real)) (@matrix.vec_empty.{0} (fin (@has_zero.zero.{0} nat nat.has_zero)) h0))  := sorry --non-trivial
lemma new_lemma_2446 (h0 : function.extfun Type ordered_comm_monoid) : @has_exists_mul_of_le.{0} pos (@function.extfun_app.{2 1} Type ordered_comm_monoid.{0} h0 pos)  := sorry --non-trivial
lemma new_lemma_2447 (h0 : functor.add_const (topological_space (normed_comm_ring unsigned)) environment.implicit_infer_kind) : @topological_space.separable_space.{0} (normed_comm_ring.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (normed_comm_ring.{0} unsigned)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_2448 (h1 : not (ring (has_div reducibility_hints) -> false)) : @strong_rank_condition.{0} (has_div.{0} reducibility_hints) (@classical.by_contradiction'.{1} (ring.{0} (has_div.{0} reducibility_hints)) h1)  := sorry --non-trivial
lemma new_lemma_2449 (h0 : semiring (monoid (semiring (option (option (option (semiring (semiring empty)))))))) : is_noetherian_ring (monoid (semiring (option (option (option (semiring (semiring empty))))))) := sorry --non-trivial
lemma new_lemma_2450 (h0 : rel (has_lt enat) (mul_one_class linarith.ineq)) : set.subsingleton (rel.dom h0) := sorry --non-trivial
lemma new_lemma_2451 (h0 : functor.add_const (complete_lattice (ring pos)) (comm_group name)) : @complete_lattice.is_Sup_finite_compact.{0} (ring.{0} pos) (@functor.add_const.run.{0 0} (complete_lattice.{0} (ring.{0} pos)) (comm_group.{0} name) h0)  := sorry --non-trivial
lemma new_lemma_2452 (h0 : group (mul_zero_class (partial_order num))) : normalizer_condition (mul_zero_class (partial_order num)) := sorry --non-trivial
lemma new_lemma_2453 (h1 : ring (has_norm (has_nnnorm fun_info))) : strong_rank_condition (has_norm (has_nnnorm fun_info)) := sorry --non-trivial
lemma new_lemma_2454 (h0 : function.extfun nat fin) : @totally_disconnected_space.{0} (ordered_comm_monoid.{0} linarith.comp) (@matrix.vec_empty.{0} (topological_space.{0} (ordered_comm_monoid.{0} linarith.comp)) (@matrix.vec_empty.{0} (fin (@has_zero.zero.{0} nat nat.has_zero)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero))))  := sorry --non-trivial
lemma new_lemma_2455 (h0 : functor.add_const (topological_space (comm_group linarith.comp)) Type) : @topological_space.separable_space.{0} (comm_group.{0} linarith.comp) (@functor.add_const.run.{0 1} (topological_space.{0} (comm_group.{0} linarith.comp)) Type h0)  := sorry --non-trivial
lemma new_lemma_2456 (h1 : not (ring (has_lt string_imp) -> false)) : @strong_rank_condition.{0} (has_lt.{0} string_imp) (@classical.by_contradiction'.{1} (ring.{0} (has_lt.{0} string_imp)) h1)  := sorry --non-trivial
lemma new_lemma_2457 (h0 : uniform_space (ring linarith.comp)) : separated_space (ring linarith.comp) := sorry --non-trivial
lemma new_lemma_2458 (h0 : functor.add_const (topological_space (has_nndist name)) pos) : @totally_disconnected_space.{0} (has_nndist.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (has_nndist.{0} name)) pos h0)  := sorry --non-trivial
lemma new_lemma_2459 (h0 : functor.add_const Prop (semiring (semiring (semiring num)))) : functor.add_const.run h0 := sorry --non-trivial
lemma new_lemma_2460 (h0 : fin has_zero.zero) : @preirreducible_space.{1} (add_comm_monoid.{1} Type) (@matrix.vec_empty.{1} (topological_space.{1} (add_comm_monoid.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_2461 (h0 : topological_space (has_add (ring (ring Type)))) : totally_separated_space (has_add (ring (ring Type))) := sorry --non-trivial
lemma new_lemma_2462 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @totally_separated_space.{0} (random_gen.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (random_gen.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_2463 (h0 : function.extfun Type topological_space) : @preirreducible_space.{0} (has_Sup.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_Sup.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_2464 (h0 : functor.add_const (topological_space (preorder num)) (semiring (semiring num))) : @totally_disconnected_space.{0} (preorder.{0} num) (@functor.add_const.run.{0 0} (topological_space.{0} (preorder.{0} num)) (semiring.{0} (semiring.{0} num)) h0)  := sorry --non-trivial
lemma new_lemma_2465 (h0 : not (function.extfun Type topological_space -> false)) : @totally_disconnected_space.{0} (has_union.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (has_union.{0} num))  := sorry --non-trivial
lemma new_lemma_2466 (h0 : topological_space (has_to_string (has_pos_part Type))) : path_connected_space (has_to_string (has_pos_part Type)) := sorry --non-trivial
lemma new_lemma_2467 (h0 : ordered_comm_monoid (boolean_algebra.core Type)) : has_exists_mul_of_le (boolean_algebra.core Type) := sorry --non-trivial
lemma new_lemma_2468 (h0 : fin has_zero.zero) : @t0_space.{0} (canonically_ordered_monoid.{0} linarith.comp) (@matrix.vec_empty.{0} (topological_space.{0} (canonically_ordered_monoid.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_2469 (h0 : topological_space (semigroup (has_to_string (has_to_string (has_to_string name))))) : totally_disconnected_space (semigroup (has_to_string (has_to_string (has_to_string name)))) := sorry --non-trivial
lemma new_lemma_2470 (h1 : set (has_ssubset string.iterator_imp)) : set.finite h1 := sorry --non-trivial
lemma new_lemma_2471 (h0 : functor.add_const (function.extfun Type add_monoid) linarith.comp) : @add_monoid.fg.{0} (semigroup.{0} linarith.comp) (@function.extfun_app.{2 1} Type add_monoid.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type add_monoid.{0}) linarith.comp h0) (semigroup.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_2472 (h0 : functor.add_const (monoid (add_comm_monoid pos)) (has_to_string (has_to_string pos))) : @monoid.fg.{0} (add_comm_monoid.{0} pos) (@functor.add_const.run.{0 0} (monoid.{0} (add_comm_monoid.{0} pos)) (has_to_string.{0} (has_to_string.{0} pos)) h0)  := sorry --non-trivial
lemma new_lemma_2473 (h0 : functor.add_const (topological_space (option unsigned)) unsigned) : @t0_space.{0} (option.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (option.{0} unsigned)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_2474 (h0 : not (complete_lattice (complete_semilattice_Sup (denumerable linarith.ineq)) -> false)) : @is_compactly_generated.{0} (complete_semilattice_Sup.{0} (denumerable.{0} linarith.ineq)) (@classical.by_contradiction'.{1} (complete_lattice.{0} (complete_semilattice_Sup.{0} (denumerable.{0} linarith.ineq))) h0)  := sorry --non-trivial
lemma new_lemma_2475 (h0 : complete_lattice (id (with_bot to_additive.value_type))) : complete_lattice.is_Sup_finite_compact (id (with_bot to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_2476 (h0 : prod (ordered_cancel_add_comm_monoid num) (ordered_cancel_add_comm_monoid num)) : id_rel h0 := sorry --non-trivial
lemma new_lemma_2477 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_domain.{0} (add_group.{0} num) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (add_group.{0} num))  := sorry --non-trivial
lemma new_lemma_2478 (h0 : functor.add_const (topological_space Type) Type) : @loc_path_connected_space.{1} Type (@functor.add_const.run.{1 1} (topological_space.{1} Type) Type h0)  := sorry --non-trivial
lemma new_lemma_2479 (h0 : functor.add_const (cancel_comm_monoid_with_zero (has_Inf Type)) pos) : @unique_factorization_monoid.{1} (has_Inf.{1} Type) (@functor.add_const.run.{1 0} (cancel_comm_monoid_with_zero.{1} (has_Inf.{1} Type)) pos h0)  := sorry --non-trivial
lemma new_lemma_2480 (h0 : group (has_top (free_add_monoid linarith.comp))) : is_cyclic (has_top (free_add_monoid linarith.comp)) := sorry --non-trivial
lemma new_lemma_2481 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @t0_space.{0} (canonically_ordered_add_monoid.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (canonically_ordered_add_monoid.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_2482 (h0 : functor.add_const (group (has_nndist Type)) pos) : @group.fg.{1} (has_nndist.{1} Type) (@functor.add_const.run.{1 0} (group.{1} (has_nndist.{1} Type)) pos h0)  := sorry --non-trivial
lemma new_lemma_2483 (h0 : semiring (generalized_boolean_algebra pos)) : is_noetherian_ring (generalized_boolean_algebra pos) := sorry --non-trivial
lemma new_lemma_2484 (h0 : finset (has_neg (finset (comm_group (has_add pos))))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_2485 (h0 : ring (with_bot (random_gen (has_inv linarith.comp_source)))) : is_domain (with_bot (random_gen (has_inv linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_2486 (h0 : function.extfun Type add_group) : @is_add_cyclic.{0} (has_to_string.{0} unsigned) (@function.extfun_app.{2 1} Type add_group.{0} h0 (has_to_string.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_2487 (h0 : functor.add_const (list (linear_ordered_cancel_comm_monoid empty)) (option empty)) : palindrome (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_2488 (h0 : functor.add_const (topological_space (left_cancel_monoid num)) num) : @normal_space.{0} (left_cancel_monoid.{0} num) (@functor.add_const.run.{0 0} (topological_space.{0} (left_cancel_monoid.{0} num)) num h0)  := sorry --non-trivial
lemma new_lemma_2489 (h0 : function.extfun (finset Type) (has_mem.mem (complete_semilattice_Sup fun_info))) : @irreducible_space.{0} (complete_semilattice_Sup.{0} fun_info) (@finset.pi.empty.{1 0} Type topological_space.{0} (complete_semilattice_Sup.{0} fun_info) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (complete_semilattice_Sup.{0} fun_info)) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_2490 (h0 : group (with_one (random_gen fun_info))) : group.fg (with_one (random_gen fun_info)) := sorry --non-trivial
lemma new_lemma_2491 (h0 : function.extfun Type monoid) : @monoid.fg.{0} (has_emptyc.{0} num) (@function.extfun_app.{2 1} Type monoid.{0} h0 (has_emptyc.{0} num))  := sorry --non-trivial
lemma new_lemma_2492 (h0 : has_lt (mul_one_class char)) : no_max_order (mul_one_class char) := sorry --non-trivial
lemma new_lemma_2493 (h0 : complete_lattice (has_neg_part (has_add (has_add name)))) : is_compactly_generated (has_neg_part (has_add (has_add name))) := sorry --non-trivial
lemma new_lemma_2494 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_principal_ideal_ring.{0} nnreal (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) nnreal)  := sorry --non-trivial
lemma new_lemma_2495 (h0 : topological_space (as_linear_order (has_pos_part linarith.comp))) : preconnected_space (as_linear_order (has_pos_part linarith.comp)) := sorry --non-trivial
lemma new_lemma_2496 (h0 : topological_space (has_dist empty)) : discrete_topology (has_dist empty) := sorry --non-trivial
lemma new_lemma_2497 (h0 : functor.add_const (cancel_comm_monoid_with_zero (finset pos)) (finset (finset Type))) : @unique_factorization_monoid.{0} (finset.{0} pos) (@functor.add_const.run.{0 1} (cancel_comm_monoid_with_zero.{0} (finset.{0} pos)) (finset.{1} (finset.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_2498 (h0 : ring (linear_ordered_add_comm_group (has_lt (denumerable to_additive.value_type)))) : is_domain (linear_ordered_add_comm_group (has_lt (denumerable to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_2499 (h0 : not (topological_space (linear_ordered_comm_ring unsigned) -> false)) : @t0_space.{0} (linear_ordered_comm_ring.{0} unsigned) (@classical.by_contradiction'.{1} (topological_space.{0} (linear_ordered_comm_ring.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_2500 (h0 : not (add_group (measurable_space (complete_semilattice_Sup empty)) -> false)) : @is_add_cyclic.{0} (measurable_space.{0} (complete_semilattice_Sup.{0} empty)) (@classical.by_contradiction'.{1} (add_group.{0} (measurable_space.{0} (complete_semilattice_Sup.{0} empty))) h0)  := sorry --non-trivial
lemma new_lemma_2501 (h0 : topological_space (add_cancel_monoid (option (option unsigned)))) : locally_compact_space (add_cancel_monoid (option (option unsigned))) := sorry --non-trivial
lemma new_lemma_2502 (h0 : filter (has_one (has_norm num))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_2503 (h0 : ring (finset ennreal)) : is_domain (finset ennreal) := sorry --non-trivial
lemma new_lemma_2504 (h0 : topological_space (has_inner unsigned unsigned)) : totally_separated_space (has_inner unsigned unsigned) := sorry --non-trivial
lemma new_lemma_2505 (h1 : topological_space (has_append fun_info)) : path_connected_space (has_append fun_info) := sorry --non-trivial
lemma new_lemma_2506 (h1 : complete_lattice (normed_field to_additive.value_type)) : complete_lattice.is_Sup_finite_compact (normed_field to_additive.value_type) := sorry --non-trivial
lemma new_lemma_2507 (h0 : semiring (add_group (semiring (semiring congr_arg_kind)))) : is_noetherian_ring (add_group (semiring (semiring congr_arg_kind))) := sorry --non-trivial
lemma new_lemma_2508 (h0 : functor.add_const (topological_space (has_zero name)) name) : @t1_space.{0} (has_zero.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (has_zero.{0} name)) name h0)  := sorry --non-trivial
lemma new_lemma_2509 (h0 : functor.add_const (topological_space (ordered_comm_ring pos)) linarith.comp) : @t1_space.{0} (ordered_comm_ring.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (ordered_comm_ring.{0} pos)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_2510 (h0 : functor.add_const (topological_space (sub_neg_monoid linarith.comp)) name) : @t1_space.{0} (sub_neg_monoid.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (sub_neg_monoid.{0} linarith.comp)) name h0)  := sorry --non-trivial
lemma new_lemma_2511 (h0 : functor.add_const (topological_space (left_cancel_monoid num)) unsigned) : @totally_separated_space.{0} (left_cancel_monoid.{0} num) (@functor.add_const.run.{0 0} (topological_space.{0} (left_cancel_monoid.{0} num)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_2512 (h0 : topological_space (ring (finset Type))) : discrete_topology (ring (finset Type)) := sorry --non-trivial
lemma new_lemma_2513 (h0 : add_group (has_norm (semiring unsigned))) : is_add_cyclic (has_norm (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_2514 (h1 : complete_lattice (distrib (has_ssubset reducibility_hints))) : is_compactly_generated (distrib (has_ssubset reducibility_hints)) := sorry --non-trivial
lemma new_lemma_2515 (h0 : functor.add_const (topological_space (has_zero pos)) Type) : @totally_separated_space.{0} (has_zero.{0} pos) (@functor.add_const.run.{0 1} (topological_space.{0} (has_zero.{0} pos)) Type h0)  := sorry --non-trivial
lemma new_lemma_2516 (h0 : complete_lattice (linear_ordered_field (monoid_with_zero pos))) : complete_lattice.is_Sup_finite_compact (linear_ordered_field (monoid_with_zero pos)) := sorry --non-trivial
lemma new_lemma_2517 (h0 : functor.add_const (group (has_nndist empty)) (option (option empty))) : @group.fg.{0} (has_nndist.{0} empty) (@functor.add_const.run.{0 0} (group.{0} (has_nndist.{0} empty)) (option.{0} (option.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_2518 (h0 : functor.add_const (function.extfun Type uniform_space) Type) : @complete_space.{0} (ordered_comm_monoid.{0} name) (@function.extfun_app.{2 1} Type uniform_space.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type uniform_space.{0}) Type h0) (ordered_comm_monoid.{0} name))  := sorry --non-trivial
lemma new_lemma_2519 (h0 : fin has_zero.zero) : @strong_rank_condition.{0} (canonically_linear_ordered_monoid.{0} linarith.comp) (@matrix.vec_empty.{0} (ring.{0} (canonically_linear_ordered_monoid.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_2520 (h0 : topological_space (random_gen (has_norm (has_norm empty)))) : normal_space (random_gen (has_norm (has_norm empty))) := sorry --non-trivial
lemma new_lemma_2521 (h1 : complete_lattice (with_zero (with_one char))) : complete_lattice.is_Sup_finite_compact (with_zero (with_one char)) := sorry --non-trivial
lemma new_lemma_2522 (h0 : monoid (add_cancel_monoid (has_add (has_add Type)))) : monoid.fg (add_cancel_monoid (has_add (has_add Type))) := sorry --non-trivial
lemma new_lemma_2523 (h0 : fin has_zero.zero) : @archimedean.{1} (canonically_ordered_monoid.{1} Type) (@matrix.vec_empty.{1} (ordered_add_comm_monoid.{1} (canonically_ordered_monoid.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_2524 (h0 : function.extfun (finset Type -> Prop) (function.extfun (finset Type))) : @totally_separated_space.{0} linarith.comp_source (@finset.pi.empty.{1 0} Type topological_space.{0} linarith.comp_source (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) linarith.comp_source) (@function.extfun_app.{2 0} (finset.{1} Type → Prop) (function.extfun.{2 0} (finset.{1} Type)) h0 (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) linarith.comp_source)) (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_2525 (h0 : cancel_comm_monoid_with_zero (has_sub (has_top (semiring unsigned)))) : unique_factorization_monoid (has_sub (has_top (semiring unsigned))) := sorry --non-trivial
lemma new_lemma_2526 (h0 : topological_space (cancel_monoid (complete_distrib_lattice environment.implicit_infer_kind))) : totally_separated_space (cancel_monoid (complete_distrib_lattice environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_2527 (h0 : group (distrib_lattice (has_nnnorm to_additive.value_type))) : group.fg (distrib_lattice (has_nnnorm to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_2528 (h0 : topological_space (linear_ordered_comm_group (option (option pos)))) : totally_disconnected_space (linear_ordered_comm_group (option (option pos))) := sorry --non-trivial
lemma new_lemma_2529 (h0 : add_group (has_ssubset (mul_one_class (mul_one_class string_imp)))) : is_add_cyclic (has_ssubset (mul_one_class (mul_one_class string_imp))) := sorry --non-trivial
lemma new_lemma_2530 (h0 : functor.add_const (topological_space (partial_order congr_arg_kind)) empty) : @t0_space.{0} (partial_order.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (partial_order.{0} congr_arg_kind)) empty h0)  := sorry --non-trivial
lemma new_lemma_2531 (h1 : group (id (random_gen (random_gen string_imp)))) : normalizer_condition (id (random_gen (random_gen string_imp))) := sorry --non-trivial
lemma new_lemma_2532 (h0 : not (add_group (has_append linarith.comp_source) -> false)) : @is_add_cyclic.{0} (has_append.{0} linarith.comp_source) (@classical.by_contradiction'.{1} (add_group.{0} (has_append.{0} linarith.comp_source)) h0)  := sorry --non-trivial
lemma new_lemma_2533 (h0 : fin has_zero.zero) : @normalizer_condition.{1} (canonically_ordered_comm_semiring.{1} Type) (@matrix.vec_empty.{1} (group.{1} (canonically_ordered_comm_semiring.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_2534 (h0 : ring (has_add (has_pos_part linarith.comp))) : is_domain (has_add (has_pos_part linarith.comp)) := sorry --non-trivial
lemma new_lemma_2535 (h0 : add_monoid (with_one (has_top fun_info))) : add_monoid.fg (with_one (has_top fun_info)) := sorry --non-trivial
lemma new_lemma_2536 (h0 : functor.add_const (topological_space (is_R_or_C num)) empty) : @topological_space.separable_space.{0} (is_R_or_C.{0} num) (@functor.add_const.run.{0 0} (topological_space.{0} (is_R_or_C.{0} num)) empty h0)  := sorry --non-trivial
lemma new_lemma_2537 (h0 : ring (linear_ordered_add_comm_group (has_inv linarith.comp_source))) : strong_rank_condition (linear_ordered_add_comm_group (has_inv linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_2538 (h0 : function.extfun nat fin) : @sequential_space.{0} (sub_neg_monoid.{0} linarith.comp) (@matrix.vec_empty.{0} (topological_space.{0} (sub_neg_monoid.{0} linarith.comp)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_2539 (h0 h1 : multiset (nondiscrete_normed_field (mul_one_class string.iterator_imp))) : multiset.subset h0 h1 := sorry --non-trivial
lemma new_lemma_2540 (h0 : functor.add_const (topological_space (finset pos)) Type) : @locally_compact_space.{0} (finset.{0} pos) (@functor.add_const.run.{0 1} (topological_space.{0} (finset.{0} pos)) Type h0)  := sorry --non-trivial
lemma new_lemma_2541 (h0 : function.extfun Type topological_space) : @totally_disconnected_space.{0} (distrib_lattice.{0} string_imp) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (distrib_lattice.{0} string_imp))  := sorry --non-trivial
lemma new_lemma_2542 (h0 : functor.add_const (topological_space (has_inf num)) num) : @t0_space.{0} (has_inf.{0} num) (@functor.add_const.run.{0 0} (topological_space.{0} (has_inf.{0} num)) num h0)  := sorry --non-trivial
lemma new_lemma_2543 (h0 : topological_space (normed_group (semiring congr_arg_kind))) : irreducible_space (normed_group (semiring congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_2544 (h0 : function.extfun Type list) : list.nodup (function.extfun_app h0 (canonically_ordered_comm_semiring name)) := sorry --non-trivial
lemma new_lemma_2545 (h0 : group (mul_zero_class (cancel_monoid name))) : group.fg (mul_zero_class (cancel_monoid name)) := sorry --non-trivial
lemma new_lemma_2546 (h0 : functor.add_const (add_group (add_cancel_monoid name)) Type) : @is_add_cyclic.{0} (add_cancel_monoid.{0} name) (@functor.add_const.run.{0 1} (add_group.{0} (add_cancel_monoid.{0} name)) Type h0)  := sorry --non-trivial
lemma new_lemma_2547 (h0 : topological_space (normed_lattice_add_comm_group (has_add Type))) : discrete_topology (normed_lattice_add_comm_group (has_add Type)) := sorry --non-trivial
lemma new_lemma_2548 (h0 : monoid (has_to_string (finset name))) : monoid.fg (has_to_string (finset name)) := sorry --non-trivial
lemma new_lemma_2549 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_compactly_generated.{0} (has_neg.{0} name) (@functor.comp.run.{0 0 0} complete_lattice.{0} has_neg.{0} name (@functor.comp.run.{0 0 0} complete_lattice.{0} has_neg.{0} name (@function.extfun_app.{2 1} Type (functor.comp.{0 0 0} complete_lattice.{0} has_neg.{0}) (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 (functor.comp.{0 0 0} complete_lattice.{0} has_neg.{0})) name)))  := sorry --non-trivial
lemma new_lemma_2550 (h0 : function.extfun (Type 1) cancel_comm_monoid_with_zero) : @unique_factorization_monoid.{1} (normed_comm_ring.{1} Type) (@function.extfun_app.{3 2} (Type 1) cancel_comm_monoid_with_zero.{1} h0 (normed_comm_ring.{1} Type))  := sorry --non-trivial
lemma new_lemma_2551 (h1 : topological_space (has_lt (has_compl fun_info))) : t0_space (has_lt (has_compl fun_info)) := sorry --non-trivial
lemma new_lemma_2552 (h0 : has_lt (has_compl std_gen)) : no_max_order (has_compl std_gen) := sorry --non-trivial
lemma new_lemma_2553 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @normal_space.{0} (has_neg.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_neg.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_2554 (h0 : group (mul_zero_class (finset pos))) : is_simple_group (mul_zero_class (finset pos)) := sorry --non-trivial
lemma new_lemma_2555 (h1 : topological_space (with_one fun_info)) : path_connected_space (with_one fun_info) := sorry --non-trivial
lemma new_lemma_2556 (h0 : topological_space (mul_zero_class (has_add (has_to_string name)))) : totally_separated_space (mul_zero_class (has_add (has_to_string name))) := sorry --non-trivial
lemma new_lemma_2557 (h0 : function.extfun Type topological_space) : @topological_space.separable_space.{0} (add_left_cancel_semigroup.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (add_left_cancel_semigroup.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_2558 (h0 : add_group (semiring (semiring (has_norm fun_info)))) : is_add_cyclic (semiring (semiring (has_norm fun_info))) := sorry --non-trivial
lemma new_lemma_2559 (h0 : ring (has_Sup (option (option (option (option (option num))))))) : is_principal_ideal_ring (has_Sup (option (option (option (option (option num)))))) := sorry --non-trivial
lemma new_lemma_2560 (h0 : group (dlist (has_nnnorm fun_info))) : group.fg (dlist (has_nnnorm fun_info)) := sorry --non-trivial
lemma new_lemma_2561 (h0 : functor.add_const (ordered_add_comm_monoid (comm_group linarith.comp)) unsigned) : @archimedean.{0} (comm_group.{0} linarith.comp) (@functor.add_const.run.{0 0} (ordered_add_comm_monoid.{0} (comm_group.{0} linarith.comp)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_2562 (h0 : topological_space (has_zero (has_to_string linarith.comp))) : loc_path_connected_space (has_zero (has_to_string linarith.comp)) := sorry --non-trivial
lemma new_lemma_2563 (h0 : functor.add_const (topological_space (bin_tree empty)) congr_arg_kind) : @topological_space.separable_space.{0} (bin_tree.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (bin_tree.{0} empty)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_2564 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_compactly_generated.{0} (ordered_cancel_add_comm_monoid.{0} (option.{0} (option.{0} (option.{0} unsigned)))) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (ordered_cancel_add_comm_monoid.{0} (option.{0} (option.{0} (option.{0} unsigned)))))  := sorry --non-trivial
lemma new_lemma_2565 (h0 : topological_space (add_comm_monoid (has_neg linarith.comp))) : totally_separated_space (add_comm_monoid (has_neg linarith.comp)) := sorry --non-trivial
lemma new_lemma_2566 (h0 : ring (has_to_string (has_Inf linarith.comp))) : is_principal_ideal_ring (has_to_string (has_Inf linarith.comp)) := sorry --non-trivial
lemma new_lemma_2567 (h0 : function.extfun Type topological_space) : @path_connected_space.{0} (has_emptyc.{0} fun_info) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_emptyc.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_2568 (h0 : functor.add_const (topological_space (has_Sup num)) num) : @irreducible_space.{0} (has_Sup.{0} num) (@functor.add_const.run.{0 0} (topological_space.{0} (has_Sup.{0} num)) num h0)  := sorry --non-trivial
lemma new_lemma_2569 (h0 : functor.add_const (function.extfun Type topological_space) linarith.comp) : @discrete_topology.{0} (has_pos_part.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) linarith.comp h0) (has_pos_part.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_2570 (h0 : functor.add_const (list (normed_comm_ring pos)) pos) : list.nodup (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_2571 (h0 : functor.add_const (finset (comm_group pos)) name) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_2572 (h0 : functor.add_const (add_group (complete_distrib_lattice pos)) real) : @is_add_cyclic.{0} (complete_distrib_lattice.{0} pos) (@functor.add_const.run.{0 0} (add_group.{0} (complete_distrib_lattice.{0} pos)) real h0)  := sorry --non-trivial
lemma new_lemma_2573 (h0 : not (filter (complete_semilattice_Sup unsigned) -> false)) : filter.ne_bot (classical.by_contradiction' h0) := sorry --non-trivial
lemma new_lemma_2574 (h0 : functor.comp topological_space boolean_algebra environment.implicit_infer_kind) : @totally_separated_space.{0} (boolean_algebra.{0} environment.implicit_infer_kind) (@functor.comp.run.{0 0 0} topological_space.{0} boolean_algebra.{0} environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_2575 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @complete_lattice.is_Sup_finite_compact.{0} (has_zero.{0} name) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (has_zero.{0} name))  := sorry --non-trivial
lemma new_lemma_2576 (h2 : set (has_ssubset linarith.comp_source)) : set.subsingleton h2 := sorry --non-trivial
lemma new_lemma_2577 (h0 : uniform_space (simple_graph (mul_one_class (mul_one_class to_additive.value_type)))) : complete_space (simple_graph (mul_one_class (mul_one_class to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_2578 (h0 : topological_space (distrib (metric_space linarith.ineq))) : t0_space (distrib (metric_space linarith.ineq)) := sorry --non-trivial
lemma new_lemma_2579 (h0 : function.extfun (multiset Type) (has_mem.mem ennreal)) : is_compactly_generated ennreal := sorry --non-trivial
lemma new_lemma_2580 (h0 : topological_space string_imp) : path_connected_space string_imp := sorry --non-trivial
lemma new_lemma_2581 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_add_cyclic.{0} (ordered_cancel_add_comm_monoid.{0} num) (@function.extfun_app.{2 1} Type add_group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 add_group.{0}) (ordered_cancel_add_comm_monoid.{0} num))  := sorry --non-trivial
lemma new_lemma_2582 (h0 : functor.add_const (function.extfun Type topological_space) (has_neg name)) : @normal_space.{0} (generalized_boolean_algebra.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) (has_neg.{0} name) h0) (generalized_boolean_algebra.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_2583 (h0 : topological_space (id (semiring (semiring congr_arg_kind)))) : discrete_topology (id (semiring (semiring congr_arg_kind))) := sorry --non-trivial
lemma new_lemma_2584 (h0 : topological_space (ordered_comm_monoid linarith.comp)) : topological_space.separable_space (ordered_comm_monoid linarith.comp) := sorry --non-trivial
lemma new_lemma_2585 (h0 : group (add_cancel_monoid Type)) : is_simple_group (add_cancel_monoid Type) := sorry --non-trivial
lemma new_lemma_2586 (h0 : not (topological_space (random_gen unsigned) -> false)) : @totally_disconnected_space.{0} (random_gen.{0} unsigned) (@classical.by_contradiction'.{1} (topological_space.{0} (random_gen.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_2587 (h0 : ring (has_ssubset linarith.ineq)) : strong_rank_condition (has_ssubset linarith.ineq) := sorry --non-trivial
lemma new_lemma_2588 (h6 : set (has_div (has_lt linarith.comp_source))) : set.finite h6 := sorry --non-trivial
lemma new_lemma_2589 (h0 : add_group (has_top (distrib_lattice (has_norm linarith.ineq)))) : is_add_cyclic (has_top (distrib_lattice (has_norm linarith.ineq))) := sorry --non-trivial
lemma new_lemma_2590 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @locally_compact_space.{0} (monoid_with_zero.{0} ennreal) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (monoid_with_zero.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_2591 (h0 : ring (has_pos_part (has_pos_part linarith.comp))) : rank_condition (has_pos_part (has_pos_part linarith.comp)) := sorry --non-trivial
lemma new_lemma_2592 (h0 : functor.add_const (topological_space (ring name)) (has_neg_part Type)) : @loc_path_connected_space.{0} (ring.{0} name) (@functor.add_const.run.{0 1} (topological_space.{0} (ring.{0} name)) (has_neg_part.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_2593 (h0 : has_mem.mem (id empty) has_emptyc.emptyc) : @complete_space.{0} (@id.{2} Type empty) (@finset.pi.empty.{1 0} Type uniform_space.{0} (@id.{2} Type empty) h0)  := sorry --non-trivial
lemma new_lemma_2594 (h0 : has_mem.mem uniform_space has_emptyc.emptyc) : @complete_space.{0} linarith.comp (@function.extfun_app.{2 1} Type uniform_space.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) uniform_space.{0} h0) linarith.comp)  := sorry --non-trivial
lemma new_lemma_2595 (h0 : add_group (denumerable (comm_ring char))) : is_add_cyclic (denumerable (comm_ring char)) := sorry --non-trivial
lemma new_lemma_2596 (h0 : functor.add_const (add_monoid (generalized_boolean_algebra Type)) linarith.comp) : @add_monoid.fg.{1} (generalized_boolean_algebra.{1} Type) (@functor.add_const.run.{1 0} (add_monoid.{1} (generalized_boolean_algebra.{1} Type)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_2597 (h0 : cancel_comm_monoid_with_zero (has_add (ring (has_add (has_Inf (has_Inf (finset pos))))))) : unique_factorization_monoid (has_add (ring (has_add (has_Inf (has_Inf (finset pos)))))) := sorry --non-trivial
lemma new_lemma_2598 (h0 : not (ring (encodable fun_info) -> false)) : @strong_rank_condition.{0} (encodable.{0} fun_info) (@classical.by_contradiction'.{1} (ring.{0} (encodable.{0} fun_info)) h0)  := sorry --non-trivial
lemma new_lemma_2599 (h0 : function.extfun Type ring) : @is_domain.{0} (has_add.{0} ennreal) (@function.extfun_app.{2 1} Type ring.{0} h0 (has_add.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_2600 (h0 : ring (has_nndist name)) : rank_condition (has_nndist name) := sorry --non-trivial
lemma new_lemma_2601 (h0 : ring (comm_ring (comm_ring (metric_space char)))) : rank_condition (comm_ring (comm_ring (metric_space char))) := sorry --non-trivial
lemma new_lemma_2602 (h0 : ordered_add_comm_monoid (linear_ordered_field (option (option num)))) : archimedean (linear_ordered_field (option (option num))) := sorry --non-trivial
lemma new_lemma_2603 (h0 : complete_lattice (has_sub (has_top empty))) : is_compactly_generated (has_sub (has_top empty)) := sorry --non-trivial
lemma new_lemma_2604 (h0 : ring (has_top (random_gen (has_ssubset to_additive.value_type)))) : rank_condition (has_top (random_gen (has_ssubset to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_2605 (h0 : function.extfun Type topological_space) : @path_connected_space.{0} (metric_space.{0} (has_norm.{0} unsigned)) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (metric_space.{0} (has_norm.{0} unsigned)))  := sorry --non-trivial
lemma new_lemma_2606 (h0 : topological_space (has_div (uniform_space linarith.ineq))) : t0_space (has_div (uniform_space linarith.ineq)) := sorry --non-trivial
lemma new_lemma_2607 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @normalizer_condition.{0} (cancel_monoid.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (cancel_monoid.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_2608 (h1 : topological_space (mul_one_class fun_info)) (h2 : preorder (mul_one_class fun_info)) : order_topology (mul_one_class fun_info) := sorry --non-trivial
lemma new_lemma_2609 (h0 : topological_space (has_dist (option (option congr_arg_kind)))) : normal_space (has_dist (option (option congr_arg_kind))) := sorry --non-trivial
lemma new_lemma_2610 (h1 : function.extfun Type topological_space) : @locally_compact_space.{0} (complete_semilattice_Sup.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type topological_space.{0} h1 (complete_semilattice_Sup.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_2611 (h0 : uniform_space (add_monoid linarith.comp_source)) : complete_space (add_monoid linarith.comp_source) := sorry --non-trivial
lemma new_lemma_2612 (h3 : not (ring (normed_field (mul_one_class (simple_graph (has_lt to_additive.value_type)))) -> false)) : @strong_rank_condition.{0} (normed_field.{0} (mul_one_class.{0} (simple_graph.{0} (has_lt.{0} to_additive.value_type)))) (@classical.by_contradiction'.{1} (ring.{0} (normed_field.{0} (mul_one_class.{0} (simple_graph.{0} (has_lt.{0} to_additive.value_type))))) h3)  := sorry --non-trivial
lemma new_lemma_2613 (h0 : functor.add_const (group (has_neg_part environment.implicit_infer_kind)) name) : @normalizer_condition.{0} (has_neg_part.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (group.{0} (has_neg_part.{0} environment.implicit_infer_kind)) name h0)  := sorry --non-trivial
lemma new_lemma_2614 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @path_connected_space.{0} fun_info (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) fun_info)  := sorry --non-trivial
lemma new_lemma_2615 (h0 : functor.add_const (finset (finset pos)) (has_nndist pos)) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_2616 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @monoid.fg.{0} (simple_graph.{0} empty) (@function.extfun_app.{2 1} Type monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 monoid.{0}) (simple_graph.{0} empty))  := sorry --non-trivial
lemma new_lemma_2617 (h0 : not (function.extfun Type uniform_space -> false)) : @separated_space.{0} (has_norm.{0} empty) (@function.extfun_app.{2 1} Type uniform_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type uniform_space.{0}) h0) (has_norm.{0} empty))  := sorry --non-trivial
lemma new_lemma_2618 (h0 : fin has_zero.zero) : @archimedean.{1} (ordered_comm_monoid.{1} Type) (@matrix.vec_empty.{1} (ordered_add_comm_monoid.{1} (ordered_comm_monoid.{1} Type)) (@matrix.vec_empty.{0} (fin (@has_zero.zero.{0} nat nat.has_zero)) (@matrix.vec_empty.{0} (fin (@has_zero.zero.{0} nat nat.has_zero)) h0)))  := sorry --non-trivial
lemma new_lemma_2619 (h0 : functor.add_const (function.extfun Type topological_space) pos) : @regular_space.{0} (has_to_string.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) pos h0) (has_to_string.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_2620 (h0 : ring (add_cancel_monoid (has_add linarith.comp))) : strong_rank_condition (add_cancel_monoid (has_add linarith.comp)) := sorry --non-trivial
lemma new_lemma_2621 (h0 : functor.add_const (topological_space znum) (option (option num))) : @topological_space.separable_space.{0} znum (@functor.add_const.run.{0 0} (topological_space.{0} znum) (option.{0} (option.{0} num)) h0)  := sorry --non-trivial
lemma new_lemma_2622 (h0 : group (has_one (semiring (semiring congr_arg_kind)))) : normalizer_condition (has_one (semiring (semiring congr_arg_kind))) := sorry --non-trivial
lemma new_lemma_2623 (h0 : set (has_ssubset reducibility_hints)) : set.subsingleton h0 := sorry --non-trivial
lemma new_lemma_2624 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_add_cyclic.{0} (has_ssubset.{0} fun_info) (@function.extfun_app.{2 1} Type add_group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 add_group.{0}) (has_ssubset.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_2625 (h0 : not (function.extfun (Type -> Type) (function.extfun Type) -> false)) : @t0_space.{0} (has_emptyc.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) (@classical.by_contradiction'.{2} (function.extfun.{2 2} (Type → Type) (function.extfun.{2 1} Type)) h0) topological_space.{0}) (has_emptyc.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_2626 (h0 : functor.add_const (group (plift empty)) empty) : @is_cyclic.{1} (plift.{1} empty) (@functor.add_const.run.{1 0} (group.{1} (plift.{1} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_2627 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @locally_compact_space.{0} (cancel_monoid.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (cancel_monoid.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_2628 (h0 : has_mem.mem (complete_semilattice_Sup empty) has_emptyc.emptyc) : @complete_lattice.is_Sup_finite_compact.{0} (complete_semilattice_Sup.{0} empty) (@finset.pi.empty.{1 0} Type complete_lattice.{0} (complete_semilattice_Sup.{0} empty) h0)  := sorry --non-trivial
lemma new_lemma_2629 (h1 : function.extfun Type group) : @group.fg.{0} (with_bot.{0} linarith.ineq) (@function.extfun_app.{2 1} Type group.{0} h1 (with_bot.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_2630 (h0 : topological_space (has_pos_part (boolean_algebra Type))) : t0_space (has_pos_part (boolean_algebra Type)) := sorry --non-trivial
lemma new_lemma_2631 (h0 : topological_space environment.implicit_infer_kind) : t0_space environment.implicit_infer_kind := sorry --non-trivial
lemma new_lemma_2632 (h0 : fin has_zero.zero) : @totally_disconnected_space.{1} (ordered_comm_ring.{1} Type) (@matrix.vec_empty.{1} (topological_space.{1} (ordered_comm_ring.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_2633 (h0 : uniform_space (random_gen (semiring (has_norm fun_info)))) : complete_space (random_gen (semiring (has_norm fun_info))) := sorry --non-trivial
lemma new_lemma_2634 (h0 : topological_space (has_to_string (ring linarith.comp))) : sequential_space (has_to_string (ring linarith.comp)) := sorry --non-trivial
lemma new_lemma_2635 (h0 : add_group (bin_tree (semiring unsigned))) : is_add_cyclic (bin_tree (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_2636 (h0 : functor.add_const (topological_space (normed_comm_ring unsigned)) name) : @locally_compact_space.{0} (normed_comm_ring.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (normed_comm_ring.{0} unsigned)) name h0)  := sorry --non-trivial
lemma new_lemma_2637 (h0 : group (metric_space (semiring num))) : is_cyclic (metric_space (semiring num)) := sorry --non-trivial
lemma new_lemma_2638 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @sequential_space.{0} (normed_comm_ring.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (normed_comm_ring.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_2639 (h0 : complete_lattice (ring (finset linarith.comp))) : complete_lattice.is_Sup_finite_compact (ring (finset linarith.comp)) := sorry --non-trivial
lemma new_lemma_2640 (h0 : topological_space (has_add (semigroup pos))) : path_connected_space (has_add (semigroup pos)) := sorry --non-trivial
lemma new_lemma_2641 (h0 : function.extfun (Type 1) add_group) : @is_add_cyclic.{1} (plift.{1} unsigned) (@function.extfun_app.{3 2} (Type 1) add_group.{1} h0 (plift.{1} unsigned))  := sorry --non-trivial
lemma new_lemma_2642 (h0 : list (cancel_monoid (finset (finset (finset (finset (finset ennreal))))))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_2643 (h0 : function.extfun Type topological_space) : @t1_space.{0} (canonically_linear_ordered_monoid.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (canonically_linear_ordered_monoid.{0} pos))  := sorry --non-trivial
lemma new_lemma_2644 (h0 : functor.add_const (group (simple_graph linarith.comp)) (has_neg linarith.comp)) : @normalizer_condition.{0} (simple_graph.{0} linarith.comp) (@functor.add_const.run.{0 0} (group.{0} (simple_graph.{0} linarith.comp)) (has_neg.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_2645 (h0 : complete_lattice (has_add (cancel_monoid (has_neg (option pos))))) : is_atomistic (has_add (cancel_monoid (has_neg (option pos)))) := sorry --non-trivial
lemma new_lemma_2646 (h0 : function.extfun Type group) : @normalizer_condition.{0} (option.{0} num) (@function.extfun_app.{2 1} Type group.{0} h0 (option.{0} num))  := sorry --non-trivial
lemma new_lemma_2647 (h2 : add_comm_group (metric_space char)) (h3 : ring (normed_field (add_comm_group.total_positive_cone (metric_space char)))) : rank_condition (normed_field (add_comm_group.total_positive_cone (metric_space char))) := sorry --non-trivial
lemma new_lemma_2648 (h0 : list (linear_ordered_add_comm_group linarith.comp_source)) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_2649 (h0 : function.extfun Type topological_space) : @totally_disconnected_space.{0} (has_Inf.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_Inf.{0} name))  := sorry --non-trivial
lemma new_lemma_2650 (h0 : topological_space (add_cancel_comm_monoid linarith.comp_source)) : t0_space (add_cancel_comm_monoid linarith.comp_source) := sorry --non-trivial
lemma new_lemma_2651 (h0 : topological_space (pseudo_metric_space unsigned)) : sequential_space (pseudo_metric_space unsigned) := sorry --non-trivial
lemma new_lemma_2652 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @regular_space.{0} (ordered_comm_ring.{0} real) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (ordered_comm_ring.{0} real))  := sorry --non-trivial
lemma new_lemma_2653 (h0 : complete_lattice (has_add pos)) : complete_lattice.is_Sup_finite_compact (has_add pos) := sorry --non-trivial
lemma new_lemma_2654 (h0 : functor.add_const (ring (has_neg_part pos)) (has_neg_part (comm_group (semigroup ennreal)))) : @is_domain.{0} (has_neg_part.{0} pos) (@functor.add_const.run.{0 0} (ring.{0} (has_neg_part.{0} pos)) (has_neg_part.{0} (comm_group.{0} (semigroup.{0} ennreal))) h0)  := sorry --non-trivial
lemma new_lemma_2655 (h0 : functor.add_const (filter (semigroup pos)) pos) : countable_Inter_filter (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_2656 (h1 : function.extfun (Type -> Type) (function.extfun Type)) : @totally_disconnected_space.{0} (random_gen.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h1 topological_space.{0}) (random_gen.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_2657 (h0 : not (function.extfun Type group -> false)) : @normalizer_condition.{0} (has_star.{0} num) (@function.extfun_app.{2 1} Type group.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type group.{0}) h0) (has_star.{0} num))  := sorry --non-trivial
lemma new_lemma_2658 (h0 : ring (linear_ordered_add_comm_group (has_nnnorm linarith.comp_source))) : is_domain (linear_ordered_add_comm_group (has_nnnorm linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_2659 (h0 : function.extfun Type filter) : @filter.Liminf.{0} Prop (@complete_lattice.to_conditionally_complete_lattice.{0} Prop Prop.complete_lattice) (@function.extfun_app.{2 1} Type filter.{0} h0 Prop)  := sorry --non-trivial
lemma new_lemma_2660 (h0 : function.extfun Type ring) : @strong_rank_condition.{0} (div_inv_monoid.{0} linarith.ineq) (@function.extfun_app.{2 1} Type ring.{0} h0 (div_inv_monoid.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_2661 (h0 : uniform_space (linear_ordered_semiring (semiring (has_norm (semiring (has_norm linarith.comp)))))) : complete_space (linear_ordered_semiring (semiring (has_norm (semiring (has_norm linarith.comp))))) := sorry --non-trivial
lemma new_lemma_2662 (h0 : topological_space (cancel_monoid (option ennreal))) : path_connected_space (cancel_monoid (option ennreal)) := sorry --non-trivial
lemma new_lemma_2663 (h0 : functor.add_const (ring (has_neg pos)) (has_to_string environment.implicit_infer_kind)) : @is_principal_ideal_ring.{0} (has_neg.{0} pos) (@functor.add_const.run.{0 0} (ring.{0} (has_neg.{0} pos)) (has_to_string.{0} environment.implicit_infer_kind) h0)  := sorry --non-trivial
lemma new_lemma_2664 (h0 : topological_space (has_union (semiring (has_top congr_arg_kind)))) : t0_space (has_union (semiring (has_top congr_arg_kind))) := sorry --non-trivial
lemma new_lemma_2665 (h0 : group (denumerable reducibility_hints)) : is_cyclic (denumerable reducibility_hints) := sorry --non-trivial
lemma new_lemma_2666 (h0 : functor.add_const (list (has_Inf name)) linarith.comp) : palindrome (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_2667 (h0 : list (has_add (boolean_algebra name))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_2668 (h0 : complete_lattice (comm_group (cancel_monoid (option name)))) : is_atomistic (comm_group (cancel_monoid (option name))) := sorry --non-trivial
lemma new_lemma_2669 (h0 : topological_space (has_norm (has_norm (has_norm congr_arg_kind)))) : locally_compact_space (has_norm (has_norm (has_norm congr_arg_kind))) := sorry --non-trivial
lemma new_lemma_2670 (h0 : functor.add_const (topological_space (pseudo_metric_space empty)) congr_arg_kind) : @totally_separated_space.{0} (pseudo_metric_space.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (pseudo_metric_space.{0} empty)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_2671 (h0 : functor.add_const (fin has_zero.zero) name) : @strong_rank_condition.{1} (sub_neg_monoid.{1} Type) (@matrix.vec_empty.{1} (ring.{1} (sub_neg_monoid.{1} Type)) (@functor.add_const.run.{0 0} (fin (@has_zero.zero.{0} nat nat.has_zero)) name h0))  := sorry --non-trivial
lemma new_lemma_2672 (h0 : functor.add_const (ring (has_neg_part Type)) name) : @rank_condition.{1} (has_neg_part.{1} Type) (@functor.add_const.run.{1 0} (ring.{1} (has_neg_part.{1} Type)) name h0)  := sorry --non-trivial
lemma new_lemma_2673 (h0 : has_mul (simple_graph linarith.comp_source)) (h1 : pfun (con (simple_graph linarith.comp_source)) Prop) (h2 : con (simple_graph linarith.comp_source)) (h3 : pfun.dom h1 h2) : pfun.fn h1 h2 h3 := sorry --non-trivial
lemma new_lemma_2674 (h0 : functor.add_const (topological_space (partial_order empty)) num) : @preirreducible_space.{0} (partial_order.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (partial_order.{0} empty)) num h0)  := sorry --non-trivial
lemma new_lemma_2675 (h0 : group (uniform_space congr_arg_kind)) : is_cyclic (uniform_space congr_arg_kind) := sorry --non-trivial
lemma new_lemma_2676 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_domain.{0} to_additive.value_type (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) to_additive.value_type)  := sorry --non-trivial
lemma new_lemma_2677 (h0 : functor.add_const (semiring (comm_group unsigned)) pos) : @is_noetherian_ring.{0} (comm_group.{0} unsigned) (@functor.add_const.run.{0 0} (semiring.{0} (comm_group.{0} unsigned)) pos h0)  := sorry --non-trivial
lemma new_lemma_2678 (h0 : uniform_space (measurable_space (semiring (semiring num)))) : complete_space (measurable_space (semiring (semiring num))) := sorry --non-trivial
lemma new_lemma_2679 (h0 : list (complete_distrib_lattice (option empty))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_2680 (h0 : functor.add_const (uniform_space (has_add unsigned)) (option (option (pseudo_metric_space (has_neg_part pos))))) : @complete_space.{0} (has_add.{0} unsigned) (@functor.add_const.run.{0 0} (uniform_space.{0} (has_add.{0} unsigned)) (option.{0} (option.{0} (pseudo_metric_space.{0} (has_neg_part.{0} pos)))) h0)  := sorry --non-trivial
lemma new_lemma_2681 (h0 : complete_lattice (measurable_space (semiring linarith.comp))) : is_atomistic (measurable_space (semiring linarith.comp)) := sorry --non-trivial
lemma new_lemma_2682 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @rank_condition.{0} (linear_ordered_add_comm_group.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (linear_ordered_add_comm_group.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_2683 (h0 : functor.add_const (uniform_space (canonically_ordered_comm_semiring linarith.comp)) linarith.comp) : @complete_space.{0} (canonically_ordered_comm_semiring.{0} linarith.comp) (@functor.add_const.run.{0 0} (uniform_space.{0} (canonically_ordered_comm_semiring.{0} linarith.comp)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_2684 (h0 : functor.add_const (list (free_add_monoid unsigned)) unsigned) : palindrome (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_2685 (h0 : functor.add_const (functor.comp ring normed_comm_ring pos) (option unsigned)) : @is_domain.{0} (normed_comm_ring.{0} pos) (@functor.comp.run.{0 0 0} ring.{0} normed_comm_ring.{0} pos (@functor.add_const.run.{0 0} (functor.comp.{0 0 0} ring.{0} normed_comm_ring.{0} pos) (option.{0} unsigned) h0))  := sorry --non-trivial
lemma new_lemma_2686 (h0 : group (complete_linear_order (semiring num))) : group.fg (complete_linear_order (semiring num)) := sorry --non-trivial
lemma new_lemma_2687 (h0 : not (function.extfun Type topological_space -> false)) : @t0_space.{0} (encodable.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (encodable.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_2688 (h0 : functor.add_const (ordered_comm_monoid (normed_comm_ring pos)) Type) : @has_exists_mul_of_le.{0} (normed_comm_ring.{0} pos) (@functor.add_const.run.{0 1} (ordered_comm_monoid.{0} (normed_comm_ring.{0} pos)) Type h0)  := sorry --non-trivial
lemma new_lemma_2689 (h0 : functor.add_const (monoid (has_neg environment.implicit_infer_kind)) Type) : @monoid.fg.{0} (has_neg.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 1} (monoid.{0} (has_neg.{0} environment.implicit_infer_kind)) Type h0)  := sorry --non-trivial
lemma new_lemma_2690 (h0 : topological_space (has_neg_part (cancel_monoid environment.implicit_infer_kind))) : t1_space (has_neg_part (cancel_monoid environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_2691 (h0 : functor.add_const (filter (add_cancel_monoid name)) name) : countable_Inter_filter (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_2692 (h0 : group (has_add (option name))) : normalizer_condition (has_add (option name)) := sorry --non-trivial
lemma new_lemma_2693 (h0 : function.extfun Type group) : @is_cyclic.{0} (with_one.{0} linarith.ineq) (@function.extfun_app.{2 1} Type group.{0} h0 (with_one.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_2694 (h0 : topological_space (canonically_ordered_comm_semiring (add_comm_monoid pos))) : sequential_space (canonically_ordered_comm_semiring (add_comm_monoid pos)) := sorry --non-trivial
lemma new_lemma_2695 (h0 : not (function.extfun Type topological_space -> false)) : @preirreducible_space.{0} unsigned (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) unsigned)  := sorry --non-trivial
lemma new_lemma_2696 (h0 : uniform_space (has_pos_part (has_add (has_pos_part (has_pos_part real))))) : complete_space (has_pos_part (has_add (has_pos_part (has_pos_part real)))) := sorry --non-trivial
lemma new_lemma_2697 (h0 : ring (div_inv_monoid (has_inv fun_info))) : strong_rank_condition (div_inv_monoid (has_inv fun_info)) := sorry --non-trivial
lemma new_lemma_2698 (h0 : functor.add_const (topological_space (mul_zero_class environment.implicit_infer_kind)) pos) : @sequential_space.{0} (mul_zero_class.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (mul_zero_class.{0} environment.implicit_infer_kind)) pos h0)  := sorry --non-trivial
lemma new_lemma_2699 (h0 : function.extfun Type monoid) : @monoid.fg.{0} (has_zero.{0} num) (@function.extfun_app.{2 1} Type monoid.{0} h0 (has_zero.{0} num))  := sorry --non-trivial
lemma new_lemma_2700 (h2 : ring (has_nnnorm reducibility_hints)) : is_domain (has_nnnorm reducibility_hints) := sorry --non-trivial
lemma new_lemma_2701 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @complete_lattice.is_Sup_finite_compact.{1} (boolean_algebra.{1} Type) (@function.extfun_app.{3 2} (Type 1) complete_lattice.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 complete_lattice.{1}) (boolean_algebra.{1} Type))  := sorry --non-trivial
lemma new_lemma_2702 (h0 : not (function.extfun (Type 1) topological_space -> false)) : @totally_separated_space.{1} (plift.{1} unsigned) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@classical.by_contradiction'.{3} (function.extfun.{3 2} (Type 1) topological_space.{1}) h0) (plift.{1} unsigned))  := sorry --non-trivial
lemma new_lemma_2703 (h0 : function.extfun Type finset) (h1 : finset.nonempty (function.extfun_app h0 Prop)) : @finset.max'.{0} Prop Prop.linear_order (@function.extfun_app.{2 1} Type finset.{0} h0 Prop) h1  := sorry --non-trivial
lemma new_lemma_2704 (h0 : topological_space (ring (ring Type))) : sequential_space (ring (ring Type)) := sorry --non-trivial
lemma new_lemma_2705 (h0 : uniform_space (denumerable to_additive.value_type)) (h1 : filter (denumerable to_additive.value_type)) : cauchy h1 := sorry --non-trivial
lemma new_lemma_2706 (h0 : functor.add_const (topological_space (complete_linear_order empty)) congr_arg_kind) : @preirreducible_space.{0} (complete_linear_order.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (complete_linear_order.{0} empty)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_2707 (h0 : group (metric_space congr_arg_kind)) : group.fg (metric_space congr_arg_kind) := sorry --non-trivial
lemma new_lemma_2708 (h0 : not (complete_lattice (normed_group (has_top num)) -> false)) : @is_atomistic.{0} (normed_group.{0} (has_top.{0} num)) (@classical.by_contradiction'.{1} (complete_lattice.{0} (normed_group.{0} (has_top.{0} num))) h0)  := sorry --non-trivial
lemma new_lemma_2709 (h0 : topological_space (boolean_algebra (finset pos))) : t1_space (boolean_algebra (finset pos)) := sorry --non-trivial
lemma new_lemma_2710 (h0 : topological_space (has_neg_part (comm_group (boolean_algebra.core (comm_group name))))) : path_connected_space (has_neg_part (comm_group (boolean_algebra.core (comm_group name)))) := sorry --non-trivial
lemma new_lemma_2711 (h0 : list (add_cancel_monoid (has_neg (ring name)))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_2712 (h0 : filter (add_cancel_monoid (has_pos_part (has_Inf (finset Type))))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_2713 (h0 : functor.add_const (complete_lattice environment.implicit_infer_kind) (has_Inf pos)) : @is_compactly_generated.{0} environment.implicit_infer_kind (@functor.add_const.run.{0 0} (complete_lattice.{0} environment.implicit_infer_kind) (has_Inf.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_2714 (h0 : topological_space (finset unsigned)) : discrete_topology (finset unsigned) := sorry --non-trivial
lemma new_lemma_2715 (h0 : function.extfun Type complete_lattice) : @is_compactly_generated.{0} (add_comm_monoid.{0} empty) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (add_comm_monoid.{0} empty))  := sorry --non-trivial
lemma new_lemma_2716 (h1 : topological_space (random_gen (comm_ring char))) : t0_space (random_gen (comm_ring char)) := sorry --non-trivial
lemma new_lemma_2717 (h0 : topological_space (boolean_algebra.core (comm_group Type))) : sequential_space (boolean_algebra.core (comm_group Type)) := sorry --non-trivial
lemma new_lemma_2718 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @normalizer_condition.{1} (boolean_algebra.{1} Type) (@function.extfun_app.{3 2} (Type 1) group.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 group.{1}) (boolean_algebra.{1} Type))  := sorry --non-trivial
lemma new_lemma_2719 (h0 : cancel_comm_monoid_with_zero (has_Sup congr_arg_kind)) : unique_factorization_monoid (has_Sup congr_arg_kind) := sorry --non-trivial
lemma new_lemma_2720 (h0 : functor.add_const (topological_space (ordered_ring empty)) empty) : @topological_space.separable_space.{0} (ordered_ring.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (ordered_ring.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_2721 (h0 : functor.add_const (topological_space (mul_zero_class pos)) name) : @t0_space.{0} (mul_zero_class.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (mul_zero_class.{0} pos)) name h0)  := sorry --non-trivial
lemma new_lemma_2722 (h0 : functor.add_const (function.extfun Type uniform_space) Type) : @complete_space.{0} (comm_group.{0} pos) (@function.extfun_app.{2 1} Type uniform_space.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type uniform_space.{0}) Type h0) (comm_group.{0} pos))  := sorry --non-trivial
lemma new_lemma_2723 (h0 : topological_space (has_compl (has_inv linarith.ineq))) : totally_disconnected_space (has_compl (has_inv linarith.ineq)) := sorry --non-trivial
lemma new_lemma_2724 (h0 : uniform_space (semiring (semiring (random_gen fun_info)))) : complete_space (semiring (semiring (random_gen fun_info))) := sorry --non-trivial
lemma new_lemma_2725 (h0 : list (canonically_ordered_comm_semiring num)) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_2726 (h0 : functor.add_const (topological_space (measure_theory.measure_space empty)) empty) : @normal_space.{0} (measure_theory.measure_space.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (measure_theory.measure_space.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_2727 (h0 : functor.add_const (ordered_comm_monoid (has_add unsigned)) environment.implicit_infer_kind) : @has_exists_mul_of_le.{0} (has_add.{0} unsigned) (@functor.add_const.run.{0 0} (ordered_comm_monoid.{0} (has_add.{0} unsigned)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_2728 (h0 : uniform_space (semigroup (ring (finset linarith.comp)))) : separated_space (semigroup (ring (finset linarith.comp))) := sorry --non-trivial
lemma new_lemma_2729 (h0 : functor.add_const (uniform_space (add_comm_monoid name)) name) : @complete_space.{0} (add_comm_monoid.{0} name) (@functor.add_const.run.{0 0} (uniform_space.{0} (add_comm_monoid.{0} name)) name h0)  := sorry --non-trivial
lemma new_lemma_2730 (h0 : list (complete_distrib_lattice (option (option (comm_group pos))))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_2731 (h0 : topological_space (measurable_space (has_norm num))) : preirreducible_space (measurable_space (has_norm num)) := sorry --non-trivial
lemma new_lemma_2732 (h0 : finset (has_zero (boolean_algebra.core Type))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_2733 (h0 : topological_space (measurable_space (has_inv to_additive.value_type))) : totally_disconnected_space (measurable_space (has_inv to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_2734 (h0 : filter (finset Type)) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_2735 (h1 : ring char) : strong_rank_condition char := sorry --non-trivial
lemma new_lemma_2736 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : list.nodup (function.extfun_app (function.extfun_app h0 list) (has_neg name)) := sorry --non-trivial
lemma new_lemma_2737 (h0 : functor.add_const (ordered_add_comm_monoid (has_pos_part Type)) name) : @archimedean.{1} (has_pos_part.{1} Type) (@functor.add_const.run.{1 0} (ordered_add_comm_monoid.{1} (has_pos_part.{1} Type)) name h0)  := sorry --non-trivial
lemma new_lemma_2738 (h0 : functor.add_const (finset (bin_tree empty)) (semiring (semiring empty))) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_2739 (h0 : finset (has_neg (option pos))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_2740 (h0 : function.extfun Type list) : list.nodup (function.extfun_app h0 (has_neg pos)) := sorry --non-trivial
lemma new_lemma_2741 (h0 : ring (fintype to_additive.value_type)) : strong_rank_condition (fintype to_additive.value_type) := sorry --non-trivial
lemma new_lemma_2742 (h0 : complete_lattice (generalized_boolean_algebra real)) : is_atomistic (generalized_boolean_algebra real) := sorry --non-trivial
lemma new_lemma_2743 (h0 : functor.add_const (ordered_comm_monoid (has_zero environment.implicit_infer_kind)) pos) : @has_exists_mul_of_le.{0} (has_zero.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (ordered_comm_monoid.{0} (has_zero.{0} environment.implicit_infer_kind)) pos h0)  := sorry --non-trivial
lemma new_lemma_2744 (h0 : ring (has_add (has_pos_part name))) : strong_rank_condition (has_add (has_pos_part name)) := sorry --non-trivial
lemma new_lemma_2745 (h0 : group (ordered_comm_ring (has_neg name))) : is_cyclic (ordered_comm_ring (has_neg name)) := sorry --non-trivial
lemma new_lemma_2746 (h0 : add_group (add_comm_semigroup char)) : is_add_cyclic (add_comm_semigroup char) := sorry --non-trivial
lemma new_lemma_2747 (h0 : finset (boolean_algebra.core unsigned)) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_2748 (h0 : functor.add_const (function.extfun Type topological_space) linarith.comp) : @locally_compact_space.{0} (finset.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) linarith.comp h0) (finset.{0} pos))  := sorry --non-trivial
lemma new_lemma_2749 (h0 : add_group (add_group unsigned)) : is_add_cyclic (add_group unsigned) := sorry --non-trivial
lemma new_lemma_2750 (h0 : topological_space (distrib_lattice fun_info)) : irreducible_space (distrib_lattice fun_info) := sorry --non-trivial
lemma new_lemma_2751 (h2 : complete_lattice (rel (has_nnnorm (has_nnnorm to_additive.value_type)) to_additive.value_type)) : is_compactly_generated (rel (has_nnnorm (has_nnnorm to_additive.value_type)) to_additive.value_type) := sorry --non-trivial
lemma new_lemma_2752 (h0 : function.extfun nat fin) : @complete_lattice.is_Sup_finite_compact.{0} (has_bot.{0} pos) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@matrix.vec_empty.{1} (function.extfun.{2 1} Type complete_lattice.{0}) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero))) (has_bot.{0} pos))  := sorry --non-trivial
lemma new_lemma_2753 (h0 : function.extfun Type (functor.comp topological_space mul_zero_class)) : @discrete_topology.{0} (mul_zero_class.{0} ennreal) (@functor.comp.run.{0 0 0} topological_space.{0} mul_zero_class.{0} ennreal (@function.extfun_app.{2 1} Type (functor.comp.{0 0 0} topological_space.{0} mul_zero_class.{0}) h0 ennreal))  := sorry --non-trivial
lemma new_lemma_2754 (h0 : topological_space (has_bot (option (option empty)))) : t1_space (has_bot (option (option empty))) := sorry --non-trivial
lemma new_lemma_2755 (h0 : functor.add_const (monoid (finset Type)) name) : @monoid.fg.{1} (finset.{1} Type) (@functor.add_const.run.{1 0} (monoid.{1} (finset.{1} Type)) name h0)  := sorry --non-trivial
lemma new_lemma_2756 (h0 : function.extfun Type topological_space) : @preirreducible_space.{0} (complete_distrib_lattice.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (complete_distrib_lattice.{0} num))  := sorry --non-trivial
lemma new_lemma_2757 (h0 : function.extfun Type topological_space) : @preconnected_space.{0} (pseudo_metric_space.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (pseudo_metric_space.{0} pos))  := sorry --non-trivial
lemma new_lemma_2758 (h0 : not (topological_space (has_one empty) -> false)) : @preirreducible_space.{0} (has_one.{0} empty) (@classical.by_contradiction'.{1} (topological_space.{0} (has_one.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_2759 (h0 : functor.add_const (complete_lattice (mul_zero_class unsigned)) congr_arg_kind) : @complete_lattice.is_Sup_finite_compact.{0} (mul_zero_class.{0} unsigned) (@functor.add_const.run.{0 0} (complete_lattice.{0} (mul_zero_class.{0} unsigned)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_2760 (h0 : not (topological_space (normed_field (has_nnnorm linarith.ineq)) -> false)) : @totally_disconnected_space.{0} (normed_field.{0} (has_nnnorm.{0} linarith.ineq)) (@classical.by_contradiction'.{1} (topological_space.{0} (normed_field.{0} (has_nnnorm.{0} linarith.ineq))) h0)  := sorry --non-trivial
lemma new_lemma_2761 (h0 : function.extfun Type topological_space) : @discrete_topology.{0} (add_cancel_monoid.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (add_cancel_monoid.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_2762 (h0 : cancel_comm_monoid_with_zero (generalized_boolean_algebra (has_neg linarith.comp))) : unique_factorization_monoid (generalized_boolean_algebra (has_neg linarith.comp)) := sorry --non-trivial
lemma new_lemma_2763 (h0 : topological_space (add_comm_monoid linarith.comp)) : locally_compact_space (add_comm_monoid linarith.comp) := sorry --non-trivial
lemma new_lemma_2764 (h0 : topological_space (distrib (has_nnnorm linarith.ineq))) : t0_space (distrib (has_nnnorm linarith.ineq)) := sorry --non-trivial
lemma new_lemma_2765 (h0 : topological_space (has_union (metric_space linarith.comp))) : totally_disconnected_space (has_union (metric_space linarith.comp)) := sorry --non-trivial
lemma new_lemma_2766 (h0 : topological_space (linear_ordered_field (option pos))) : normal_space (linear_ordered_field (option pos)) := sorry --non-trivial
lemma new_lemma_2767 (h0 : linarith.comp_source -> nat) (h1 h2 : linarith.comp_source) : measure h0 h1 h2 := sorry --non-trivial
lemma new_lemma_2768 (h1 : topological_space (has_emptyc (has_top linarith.ineq))) : totally_separated_space (has_emptyc (has_top linarith.ineq)) := sorry --non-trivial
lemma new_lemma_2769 (h0 : ring (has_top unsigned)) : strong_rank_condition (has_top unsigned) := sorry --non-trivial
lemma new_lemma_2770 (h0 : functor.add_const (topological_space (canonically_ordered_monoid real)) linarith.comp) : @totally_separated_space.{0} (canonically_ordered_monoid.{0} real) (@functor.add_const.run.{0 0} (topological_space.{0} (canonically_ordered_monoid.{0} real)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_2771 (h0 : topological_space (has_neg_part (has_zero pos))) : preconnected_space (has_neg_part (has_zero pos)) := sorry --non-trivial
lemma new_lemma_2772 (h0 : linarith.comp_source -> linarith.comp_source -> linarith.comp_source) : is_idempotent linarith.comp_source h0 := sorry --non-trivial
lemma new_lemma_2773 (h0 : functor.add_const (list (ordered_comm_ring Type)) Type) : list.nodup (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_2774 (h0 : group (has_to_string (has_add pos))) : is_simple_group (has_to_string (has_add pos)) := sorry --non-trivial
lemma new_lemma_2775 (h0 : preorder (add_comm_semigroup (mul_one_class string.iterator_imp))) (h1 : set (add_comm_semigroup (mul_one_class string.iterator_imp))) : set.is_pwo h1 := sorry --non-trivial
lemma new_lemma_2776 (h0 : function.extfun Type topological_space) : @totally_separated_space.{0} (has_top.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_top.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_2777 (h0 : functor.add_const (function.extfun (Type 1) complete_lattice) linarith.comp) : @complete_lattice.is_Sup_finite_compact.{1} (has_neg.{1} Type) (@function.extfun_app.{3 2} (Type 1) complete_lattice.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) complete_lattice.{1}) linarith.comp h0) (has_neg.{1} Type))  := sorry --non-trivial
lemma new_lemma_2778 (h0 : topological_space (has_zero (finset Type))) : irreducible_space (has_zero (finset Type)) := sorry --non-trivial
lemma new_lemma_2779 (h0 : function.extfun Type topological_space) : @irreducible_space.{0} (linear_ordered_add_comm_group.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (linear_ordered_add_comm_group.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_2780 (h0 : ordered_add_comm_monoid (as_linear_order unsigned)) : archimedean (as_linear_order unsigned) := sorry --non-trivial
lemma new_lemma_2781 (h0 : ring (boolean_algebra (sub_neg_monoid Type))) : is_domain (boolean_algebra (sub_neg_monoid Type)) := sorry --non-trivial
lemma new_lemma_2782 (h0 : ordered_add_comm_monoid (is_R_or_C (semiring empty))) : archimedean (is_R_or_C (semiring empty)) := sorry --non-trivial
lemma new_lemma_2783 (h1 : semiring (nondiscrete_normed_field environment.projection_info)) (h2 : ideal (nondiscrete_normed_field environment.projection_info)) : ideal.is_prime h2 := sorry --non-trivial
lemma new_lemma_2784 (h0 : ring (complete_linear_order num)) : is_domain (complete_linear_order num) := sorry --non-trivial
lemma new_lemma_2785 (h0 : functor.add_const (topological_space (has_nndist ennreal)) ennreal) : @preirreducible_space.{0} (has_nndist.{0} ennreal) (@functor.add_const.run.{0 0} (topological_space.{0} (has_nndist.{0} ennreal)) ennreal h0)  := sorry --non-trivial
lemma new_lemma_2786 (h0 : topological_space (simple_graph string.iterator_imp)) : t0_space (simple_graph string.iterator_imp) := sorry --non-trivial
lemma new_lemma_2787 (h0 : functor.add_const (add_monoid (add_comm_monoid linarith.comp)) Type) : @add_monoid.fg.{0} (add_comm_monoid.{0} linarith.comp) (@functor.add_const.run.{0 1} (add_monoid.{0} (add_comm_monoid.{0} linarith.comp)) Type h0)  := sorry --non-trivial
lemma new_lemma_2788 (h0 : ring (boolean_algebra (has_add Type))) : strong_rank_condition (boolean_algebra (has_add Type)) := sorry --non-trivial
lemma new_lemma_2789 (h0 : functor.add_const (function.extfun Type ordered_add_comm_monoid) pos) : @archimedean.{0} (ordered_comm_ring.{0} pos) (@function.extfun_app.{2 1} Type ordered_add_comm_monoid.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type ordered_add_comm_monoid.{0}) pos h0) (ordered_comm_ring.{0} pos))  := sorry --non-trivial
lemma new_lemma_2790 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @sequential_space.{0} (semigroup.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (semigroup.{0} name))  := sorry --non-trivial
lemma new_lemma_2791 (h0 : functor.add_const (ordered_add_comm_monoid (has_neg name)) environment.implicit_infer_kind) : @archimedean.{0} (has_neg.{0} name) (@functor.add_const.run.{0 0} (ordered_add_comm_monoid.{0} (has_neg.{0} name)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_2792 (h0 : topological_space (linear_ordered_add_comm_group (comm_ring linarith.ineq))) : totally_disconnected_space (linear_ordered_add_comm_group (comm_ring linarith.ineq)) := sorry --non-trivial
lemma new_lemma_2793 (h0 : topological_space (has_pos_part (ordered_comm_monoid (ordered_comm_monoid real)))) : totally_disconnected_space (has_pos_part (ordered_comm_monoid (ordered_comm_monoid real))) := sorry --non-trivial
lemma new_lemma_2794 (h0 : ring (left_cancel_semigroup (mul_zero_class congr_arg_kind))) : strong_rank_condition (left_cancel_semigroup (mul_zero_class congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_2795 (h0 : topological_space (has_Inf (has_Inf (has_Inf Type)))) : t1_space (has_Inf (has_Inf (has_Inf Type))) := sorry --non-trivial
lemma new_lemma_2796 (h0 : function.extfun Type ring) : @strong_rank_condition.{0} (ordered_ring.{0} empty) (@function.extfun_app.{2 1} Type ring.{0} h0 (ordered_ring.{0} empty))  := sorry --non-trivial
lemma new_lemma_2797 (h0 : function.extfun Type uniform_space) : @complete_space.{0} (has_sdiff.{0} ennreal) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (has_sdiff.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_2798 (h0 : complete_lattice (has_Inf (has_Inf pos))) : complete_lattice.is_Sup_finite_compact (has_Inf (has_Inf pos)) := sorry --non-trivial
lemma new_lemma_2799 (h0 : functor.add_const (topological_space (preorder num)) (semiring num)) : @t0_space.{0} (preorder.{0} num) (@functor.add_const.run.{0 0} (topological_space.{0} (preorder.{0} num)) (semiring.{0} num) h0)  := sorry --non-trivial
lemma new_lemma_2800 (h0 : functor.add_const (group (has_neg name)) environment.implicit_infer_kind) : @normalizer_condition.{0} (has_neg.{0} name) (@functor.add_const.run.{0 0} (group.{0} (has_neg.{0} name)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_2801 (h0 : function.extfun Type finset) : finset.nonempty (function.extfun_app h0 (finset congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_2802 (h0 : topological_space (add_comm_monoid (comm_group pos))) : normal_space (add_comm_monoid (comm_group pos)) := sorry --non-trivial
lemma new_lemma_2803 (h0 : functor.add_const (group (linear_ordered_comm_monoid_with_zero unsigned)) empty) : @group.fg.{0} (linear_ordered_comm_monoid_with_zero.{0} unsigned) (@functor.add_const.run.{0 0} (group.{0} (linear_ordered_comm_monoid_with_zero.{0} unsigned)) empty h0)  := sorry --non-trivial
lemma new_lemma_2804 (h0 : topological_space (generalized_boolean_algebra (has_neg name))) : preconnected_space (generalized_boolean_algebra (has_neg name)) := sorry --non-trivial
lemma new_lemma_2805 (h0 : group (measurable_space (has_norm empty))) : normalizer_condition (measurable_space (has_norm empty)) := sorry --non-trivial
lemma new_lemma_2806 (h0 : functor.add_const (topological_space (has_zero (has_add linarith.comp))) Type) : @loc_path_connected_space.{0} (has_zero.{0} (has_add.{0} linarith.comp)) (@functor.add_const.run.{0 1} (topological_space.{0} (has_zero.{0} (has_add.{0} linarith.comp))) Type h0)  := sorry --non-trivial
lemma new_lemma_2807 (h0 : not (add_group (semiring linarith.ineq) -> false)) : @is_add_cyclic.{0} (semiring.{0} linarith.ineq) (@classical.by_contradiction'.{1} (add_group.{0} (semiring.{0} linarith.ineq)) h0)  := sorry --non-trivial
lemma new_lemma_2808 (h0 : topological_space (semigroup (finset unsigned))) : discrete_topology (semigroup (finset unsigned)) := sorry --non-trivial
lemma new_lemma_2809 (h0 : fin has_zero.zero) : @totally_disconnected_space.{1} (has_bot.{1} Type) (@matrix.vec_empty.{1} (topological_space.{1} (has_bot.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_2810 (h0 : has_mem.mem (random_gen linarith.comp) has_emptyc.emptyc) : @group.fg.{0} (random_gen.{0} linarith.comp) (@finset.pi.empty.{1 0} Type group.{0} (random_gen.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_2811 (h0 : not (ring (div_inv_monoid to_additive.value_type) -> false)) : @strong_rank_condition.{0} (div_inv_monoid.{0} to_additive.value_type) (@classical.by_contradiction'.{1} (ring.{0} (div_inv_monoid.{0} to_additive.value_type)) h0)  := sorry --non-trivial
lemma new_lemma_2812 (h0 : function.extfun Type semiring) : @is_noetherian_ring.{0} (boolean_algebra.{0} pos) (@function.extfun_app.{2 1} Type semiring.{0} h0 (boolean_algebra.{0} pos))  := sorry --non-trivial
lemma new_lemma_2813 (h0 : topological_space (id (linear_ordered_semiring (linear_ordered_semiring unsigned)))) : t0_space (id (linear_ordered_semiring (linear_ordered_semiring unsigned))) := sorry --non-trivial
lemma new_lemma_2814 (h0 : function.extfun Type topological_space) : @topological_space.separable_space.{0} (ring.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (ring.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_2815 (h0 : topological_space (mul_one_class (finset Type))) : preirreducible_space (mul_one_class (finset Type)) := sorry --non-trivial
lemma new_lemma_2816 (h0 : functor.add_const (topological_space (has_zero Type)) (finset linarith.comp)) : @sequential_space.{1} (has_zero.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (has_zero.{1} Type)) (finset.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_2817 (h0 : functor.add_const Prop (ordered_cancel_add_comm_monoid unsigned)) : functor.add_const.run h0 := sorry --non-trivial
lemma new_lemma_2818 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @irreducible_space.{0} (has_inv.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_inv.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_2819 (h0 : topological_space (is_R_or_C (option (option empty)))) : irreducible_space (is_R_or_C (option (option empty))) := sorry --non-trivial
lemma new_lemma_2820 (h1 : has_lt (nondiscrete_normed_field (add_comm_semigroup linarith.ineq))) : no_max_order (nondiscrete_normed_field (add_comm_semigroup linarith.ineq)) := sorry --non-trivial
lemma new_lemma_2821 (h0 : function.extfun Type topological_space) : @locally_compact_space.{0} (has_to_string.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_to_string.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_2822 (h0 : not (function.extfun Type topological_space -> false)) : t0_space empty := sorry --non-trivial
lemma new_lemma_2823 (h0 : functor.add_const (topological_space (finset ennreal)) name) : @preconnected_space.{0} (finset.{0} ennreal) (@functor.add_const.run.{0 0} (topological_space.{0} (finset.{0} ennreal)) name h0)  := sorry --non-trivial
lemma new_lemma_2824 (h0 : topological_space (has_zero (ring Type))) : normal_space (has_zero (ring Type)) := sorry --non-trivial
lemma new_lemma_2825 (h0 : not (function.extfun Type topological_space -> false)) : @irreducible_space.{0} (linear_ordered_semiring.{0} fun_info) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (linear_ordered_semiring.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_2826 (h0 : group (has_nndist (option ennreal))) : is_cyclic (has_nndist (option ennreal)) := sorry --non-trivial
lemma new_lemma_2827 (h0 : ring (with_bot (random_gen (random_gen string_imp)))) : rank_condition (with_bot (random_gen (random_gen string_imp))) := sorry --non-trivial
lemma new_lemma_2828 (h0 : preorder (has_norm string_imp)) (h1 : topological_space (has_norm string_imp)) : Inf_convergence_class (has_norm string_imp) := sorry --non-trivial
lemma new_lemma_2829 (h0 : functor.add_const (functor.comp group cancel_monoid name) pos) : @is_cyclic.{0} (cancel_monoid.{0} name) (@functor.comp.run.{0 0 0} group.{0} cancel_monoid.{0} name (@functor.add_const.run.{0 0} (functor.comp.{0 0 0} group.{0} cancel_monoid.{0} name) pos h0))  := sorry --non-trivial
lemma new_lemma_2830 (h0 h1 : multiset (nondiscrete_normed_field (mul_one_class (mul_one_class (normed_field string.iterator_imp))))) : multiset.disjoint h0 h1 := sorry --non-trivial
lemma new_lemma_2831 (h0 : functor.add_const (ring (ordered_comm_monoid name)) (has_neg (ring (has_neg Type)))) : @is_principal_ideal_ring.{0} (ordered_comm_monoid.{0} name) (@functor.add_const.run.{0 1} (ring.{0} (ordered_comm_monoid.{0} name)) (has_neg.{1} (ring.{1} (has_neg.{1} Type))) h0)  := sorry --non-trivial
lemma new_lemma_2832 (h0 : functor.comp topological_space canonically_ordered_comm_semiring ennreal) : @locally_compact_space.{0} (canonically_ordered_comm_semiring.{0} ennreal) (@functor.comp.run.{0 0 0} topological_space.{0} canonically_ordered_comm_semiring.{0} ennreal h0)  := sorry --non-trivial
lemma new_lemma_2833 (h0 : topological_space (simple_graph (boolean_algebra.core (has_Inf (has_Inf Type))))) : topological_space.separable_space (simple_graph (boolean_algebra.core (has_Inf (has_Inf Type)))) := sorry --non-trivial
lemma new_lemma_2834 (h0 : function.extfun Type topological_space) : @irreducible_space.{0} (mul_zero_class.{0} ennreal) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (mul_zero_class.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_2835 (h0 : function.extfun Type topological_space) : @preirreducible_space.{0} (has_one.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_one.{0} empty))  := sorry --non-trivial
lemma new_lemma_2836 (h0 : functor.add_const (list (canonically_ordered_comm_semiring pos)) pos) : palindrome (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_2837 (h0 : has_mem.mem (has_one linarith.comp) has_emptyc.emptyc) : @locally_compact_space.{0} (has_one.{0} linarith.comp) (@finset.pi.empty.{1 0} Type topological_space.{0} (has_one.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_2838 (h0 : complete_lattice (div_inv_monoid (semi_normed_ring (with_one linarith.ineq)))) : complete_lattice.is_Sup_finite_compact (div_inv_monoid (semi_normed_ring (with_one linarith.ineq))) := sorry --non-trivial
lemma new_lemma_2839 (h0 : ring (has_append (has_nnnorm (has_nnnorm (has_nnnorm linarith.ineq))))) : strong_rank_condition (has_append (has_nnnorm (has_nnnorm (has_nnnorm linarith.ineq)))) := sorry --non-trivial
lemma new_lemma_2840 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @path_connected_space.{0} name (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) name)  := sorry --non-trivial
lemma new_lemma_2841 (h0 : topological_space (linear_ordered_field (has_dist (option unsigned)))) : t1_space (linear_ordered_field (has_dist (option unsigned))) := sorry --non-trivial
lemma new_lemma_2842 (h0 : topological_space (has_union (linear_ordered_semiring congr_arg_kind))) : irreducible_space (has_union (linear_ordered_semiring congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_2843 (h0 : functor.add_const (complete_lattice (boolean_algebra unsigned)) pos) : @complete_lattice.is_Sup_finite_compact.{0} (boolean_algebra.{0} unsigned) (@functor.add_const.run.{0 0} (complete_lattice.{0} (boolean_algebra.{0} unsigned)) pos h0)  := sorry --non-trivial
lemma new_lemma_2844 (h0 : function.extfun Type (functor.add_const (topological_space znum))) : @totally_separated_space.{0} znum (@functor.add_const.run.{0 0} (topological_space.{0} znum) empty (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (topological_space.{0} znum)) h0 empty))  := sorry --non-trivial
lemma new_lemma_2845 (h0 : topological_space (add_comm_monoid (finset name))) : preirreducible_space (add_comm_monoid (finset name)) := sorry --non-trivial
lemma new_lemma_2846 (h0 : function.extfun Type monoid) : @monoid.fg.{0} (linear_order.{0} empty) (@function.extfun_app.{2 1} Type monoid.{0} h0 (linear_order.{0} empty))  := sorry --non-trivial
lemma new_lemma_2847 (h2 : group (has_nnnorm char)) : is_cyclic (has_nnnorm char) := sorry --non-trivial
lemma new_lemma_2848 (h0 : topological_space (add_comm_monoid real)) : irreducible_space (add_comm_monoid real) := sorry --non-trivial
lemma new_lemma_2849 (h0 : function.extfun Type topological_space) : @t1_space.{0} (sub_neg_monoid.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (sub_neg_monoid.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_2850 (h0 : functor.add_const (topological_space (ordered_comm_ring unsigned)) congr_arg_kind) : @path_connected_space.{0} (ordered_comm_ring.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (ordered_comm_ring.{0} unsigned)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_2851 (h0 : functor.add_const (function.extfun Type ordered_comm_monoid) pos) : @has_exists_mul_of_le.{0} (has_zero.{0} linarith.comp) (@function.extfun_app.{2 1} Type ordered_comm_monoid.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type ordered_comm_monoid.{0}) pos h0) (has_zero.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_2852 (h0 : topological_space (uniform_space string.iterator_imp)) : totally_disconnected_space (uniform_space string.iterator_imp) := sorry --non-trivial
lemma new_lemma_2853 (h0 : functor.add_const (group (complete_distrib_lattice unsigned)) unsigned) : @is_cyclic.{0} (complete_distrib_lattice.{0} unsigned) (@functor.add_const.run.{0 0} (group.{0} (complete_distrib_lattice.{0} unsigned)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_2854 (h0 : functor.add_const (ordered_add_comm_monoid (boolean_algebra environment.implicit_infer_kind)) linarith.comp) : @archimedean.{0} (boolean_algebra.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (ordered_add_comm_monoid.{0} (boolean_algebra.{0} environment.implicit_infer_kind)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_2855 (h0 : functor.add_const (function.extfun Type topological_space) linarith.comp) : @loc_path_connected_space.{0} (add_cancel_monoid.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) linarith.comp h0) (add_cancel_monoid.{0} pos))  := sorry --non-trivial
lemma new_lemma_2856 (h0 : cancel_comm_monoid_with_zero (measurable_space empty)) : unique_factorization_monoid (measurable_space empty) := sorry --non-trivial
lemma new_lemma_2857 (h0 : functor.add_const (uniform_space (free_add_monoid empty)) empty) : @complete_space.{0} (free_add_monoid.{0} empty) (@functor.add_const.run.{0 0} (uniform_space.{0} (free_add_monoid.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_2858 (h0 : ring (boolean_algebra (has_Inf name))) : strong_rank_condition (boolean_algebra (has_Inf name)) := sorry --non-trivial
lemma new_lemma_2859 (h0 : functor.add_const (topological_space (left_cancel_monoid congr_arg_kind)) empty) : @loc_path_connected_space.{0} (left_cancel_monoid.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (left_cancel_monoid.{0} congr_arg_kind)) empty h0)  := sorry --non-trivial
lemma new_lemma_2860 (h1 : ring (topological_space linarith.comp_source)) : rank_condition (topological_space linarith.comp_source) := sorry --non-trivial
lemma new_lemma_2861 (h0 : set (semi_normed_ring string.iterator_imp)) (h1 : semi_normed_ring string.iterator_imp) : set.compl h0 h1 := sorry --non-trivial
lemma new_lemma_2862 (h0 : list (semigroup (has_neg (has_to_string num)))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_2863 (h0 : topological_space (left_cancel_monoid (semiring (semiring empty)))) : normal_space (left_cancel_monoid (semiring (semiring empty))) := sorry --non-trivial
lemma new_lemma_2864 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : finset.nonempty (function.extfun_app (function.extfun_app h0 finset) pos) := sorry --non-trivial
lemma new_lemma_2865 (h0 : functor.add_const (topological_space (has_neg ennreal)) ennreal) : @t1_space.{0} (has_neg.{0} ennreal) (@functor.add_const.run.{0 0} (topological_space.{0} (has_neg.{0} ennreal)) ennreal h0)  := sorry --non-trivial
lemma new_lemma_2866 (h0 : group (comm_group name)) : is_simple_group (comm_group name) := sorry --non-trivial
lemma new_lemma_2867 (h5 : add_group (denumerable (random_gen to_additive.value_type))) : is_add_cyclic (denumerable (random_gen to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_2868 (h0 : complete_lattice (mul_one_class (mul_one_class environment.projection_info))) : complete_lattice.is_Sup_finite_compact (mul_one_class (mul_one_class environment.projection_info)) := sorry --non-trivial
lemma new_lemma_2869 (h0 : not (ring (distrib_lattice linarith.ineq) -> false)) : @is_domain.{0} (distrib_lattice.{0} linarith.ineq) (@classical.by_contradiction'.{1} (ring.{0} (distrib_lattice.{0} linarith.ineq)) h0)  := sorry --non-trivial
lemma new_lemma_2870 (h0 : ring (has_norm (has_top (random_gen to_additive.value_type)))) : is_domain (has_norm (has_top (random_gen to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_2871 (h0 : function.extfun (finset (Type -> Type)) (has_mem.mem ring)) : @strong_rank_condition.{0} (linear_ordered_add_comm_group.{0} num) (@function.extfun_app.{2 1} Type ring.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) ring.{0} (@function.extfun_app.{2 0} (finset.{1} (Type → Type)) (@has_mem.mem.{1 1} (Type → Type) (finset.{1} (Type → Type)) (@finset.has_mem.{1} (Type → Type)) ring.{0}) h0 (@has_emptyc.emptyc.{1} (finset.{1} (Type → Type)) (@finset.has_emptyc.{1} (Type → Type))))) (linear_ordered_add_comm_group.{0} num))  := sorry --non-trivial
lemma new_lemma_2872 (h0 : uniform_space (add_left_cancel_monoid (has_inv (has_nnnorm (has_nnnorm char))))) : complete_space (add_left_cancel_monoid (has_inv (has_nnnorm (has_nnnorm char)))) := sorry --non-trivial
lemma new_lemma_2873 (h0 : add_group (normed_group (has_inv (has_inv to_additive.value_type)))) : is_add_cyclic (normed_group (has_inv (has_inv to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_2874 (h0 : functor.add_const (group (complete_distrib_lattice empty)) (option (option empty))) : @group.fg.{0} (complete_distrib_lattice.{0} empty) (@functor.add_const.run.{0 0} (group.{0} (complete_distrib_lattice.{0} empty)) (option.{0} (option.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_2875 (h0 : functor.add_const (function.extfun Type ordered_add_comm_monoid) pos) : @archimedean.{0} (has_add.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type ordered_add_comm_monoid.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type ordered_add_comm_monoid.{0}) pos h0) (has_add.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_2876 (h0 : ulower pnat) (h1 : thunk (ulower pnat)) : pnat.coprime (@ulower.up.{0} pnat encodable.pnat h0) (@ulower.up.{0} pnat encodable.pnat (@trace_call_stack.{0} (@ulower.{0} pnat encodable.pnat) h1))  := sorry --non-trivial
lemma new_lemma_2877 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @rank_condition.{0} (has_edist.{0} empty) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (has_edist.{0} empty))  := sorry --non-trivial
lemma new_lemma_2878 (h0 : topological_space (has_top (has_norm (has_top linarith.comp_source)))) : totally_disconnected_space (has_top (has_norm (has_top linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_2879 (h0 : group (random_gen (random_gen (random_gen congr_arg_kind)))) : normalizer_condition (random_gen (random_gen (random_gen congr_arg_kind))) := sorry --non-trivial
lemma new_lemma_2880 (h0 : topological_space (generalized_boolean_algebra (has_Inf (sub_neg_monoid real)))) : path_connected_space (generalized_boolean_algebra (has_Inf (sub_neg_monoid real))) := sorry --non-trivial
lemma new_lemma_2881 (h0 : group (simple_graph empty)) : is_cyclic (simple_graph empty) := sorry --non-trivial
lemma new_lemma_2882 (h0 : function.extfun Type topological_space) : @irreducible_space.{0} (has_dist.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_dist.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_2883 (h0 : functor.add_const (function.extfun Type finset) (has_add linarith.comp)) : finset.nonempty (function.extfun_app (functor.add_const.run h0) (add_cancel_monoid linarith.comp)) := sorry --non-trivial
lemma new_lemma_2884 (h0 : semiring (has_one (linear_ordered_semiring empty))) : is_noetherian_ring (has_one (linear_ordered_semiring empty)) := sorry --non-trivial
lemma new_lemma_2885 (h0 : group (linear_ordered_add_comm_group (has_nnnorm fun_info))) : group.fg (linear_ordered_add_comm_group (has_nnnorm fun_info)) := sorry --non-trivial
lemma new_lemma_2886 (h0 : add_group (linear_ordered_semiring (has_top linarith.comp))) : is_add_cyclic (linear_ordered_semiring (has_top linarith.comp)) := sorry --non-trivial
lemma new_lemma_2887 (h1 : has_mem.mem (with_bot linarith.ineq) has_emptyc.emptyc) : @irreducible_space.{0} (with_bot.{0} linarith.ineq) (@finset.pi.empty.{1 0} Type topological_space.{0} (with_bot.{0} linarith.ineq) h1)  := sorry --non-trivial
lemma new_lemma_2888 (h0 : functor.add_const (monoid (ring environment.implicit_infer_kind)) Type) : @monoid.fg.{0} (ring.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 1} (monoid.{0} (ring.{0} environment.implicit_infer_kind)) Type h0)  := sorry --non-trivial
lemma new_lemma_2889 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @complete_space.{0} (@id.{2} Type linarith.ineq) (@function.extfun_app.{2 1} Type uniform_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 uniform_space.{0}) (@id.{2} Type linarith.ineq))  := sorry --non-trivial
lemma new_lemma_2890 (h0 : topological_space (with_bot (has_inv fun_info))) : locally_compact_space (with_bot (has_inv fun_info)) := sorry --non-trivial
lemma new_lemma_2891 (h0 : functor.add_const (topological_space (boolean_algebra name)) pos) : @locally_compact_space.{0} (boolean_algebra.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (boolean_algebra.{0} name)) pos h0)  := sorry --non-trivial
lemma new_lemma_2892 (h0 : topological_space (with_bot num)) : irreducible_space (with_bot num) := sorry --non-trivial
lemma new_lemma_2893 (h0 : functor.add_const (add_group ennreal) ennreal) : @is_add_cyclic.{0} ennreal (@functor.add_const.run.{0 0} (add_group.{0} ennreal) ennreal h0)  := sorry --non-trivial
lemma new_lemma_2894 (h0 : topological_space (monoid unsigned)) : t0_space (monoid unsigned) := sorry --non-trivial
lemma new_lemma_2895 (h0 : functor.add_const (group (ordered_comm_group unsigned)) unsigned) : @normalizer_condition.{0} (ordered_comm_group.{0} unsigned) (@functor.add_const.run.{0 0} (group.{0} (ordered_comm_group.{0} unsigned)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_2896 (h0 : functor.add_const (ordered_comm_monoid (boolean_algebra.core Type)) (finset (mul_zero_class Type))) : @has_exists_mul_of_le.{1} (boolean_algebra.core.{1} Type) (@functor.add_const.run.{1 1} (ordered_comm_monoid.{1} (boolean_algebra.core.{1} Type)) (finset.{1} (mul_zero_class.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_2897 (h0 : monoid (partial_order unsigned)) : monoid.fg (partial_order unsigned) := sorry --non-trivial
lemma new_lemma_2898 (h0 : complete_lattice (finset Type)) : complete_lattice.is_Sup_finite_compact (finset Type) := sorry --non-trivial
lemma new_lemma_2899 (h0 : has_coe (nondiscrete_normed_field linarith.ineq) Prop) (h1 : nondiscrete_normed_field linarith.ineq) : @coe_b.{1 1} (nondiscrete_normed_field.{0} linarith.ineq) Prop h0 h1  := sorry --non-trivial
lemma new_lemma_2900 (h0 : functor.add_const (topological_space (canonically_ordered_comm_semiring Type)) (comm_group Type)) : @loc_path_connected_space.{1} (canonically_ordered_comm_semiring.{1} Type) (@functor.add_const.run.{1 1} (topological_space.{1} (canonically_ordered_comm_semiring.{1} Type)) (comm_group.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_2901 (h0 : filter (comm_ring (random_gen (has_ssubset linarith.ineq)))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_2902 (h0 : topological_space (with_bot (semiring (semiring unsigned)))) : discrete_topology (with_bot (semiring (semiring unsigned))) := sorry --non-trivial
lemma new_lemma_2903 (h0 : uniform_space (preorder empty)) : separated_space (preorder empty) := sorry --non-trivial
lemma new_lemma_2904 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @sequential_space.{0} (complete_distrib_lattice.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (complete_distrib_lattice.{0} name))  := sorry --non-trivial
lemma new_lemma_2905 (h0 : not (filter (normed_group num) -> false)) : filter.ne_bot (classical.by_contradiction' h0) := sorry --non-trivial
lemma new_lemma_2906 (h0 : ring (boolean_algebra (sub_neg_monoid (sub_neg_monoid real)))) : rank_condition (boolean_algebra (sub_neg_monoid (sub_neg_monoid real))) := sorry --non-trivial
lemma new_lemma_2907 (h0 : not (cancel_comm_monoid_with_zero (id congr_arg_kind) -> false)) : @unique_factorization_monoid.{0} (@id.{2} Type congr_arg_kind) (@classical.by_contradiction'.{1} (cancel_comm_monoid_with_zero.{0} (@id.{2} Type congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_2908 (h0 : add_group (sub_neg_monoid (finset pos))) : is_add_cyclic (sub_neg_monoid (finset pos)) := sorry --non-trivial
lemma new_lemma_2909 (h0 : topological_space (finset (canonically_linear_ordered_monoid (option ennreal)))) : normal_space (finset (canonically_linear_ordered_monoid (option ennreal))) := sorry --non-trivial
lemma new_lemma_2910 (h0 : function.extfun Type (functor.comp finset normed_comm_ring)) : finset.nonempty (functor.comp.run (function.extfun_app h0 name)) := sorry --non-trivial
lemma new_lemma_2911 (h0 : functor.add_const (topological_space (has_add pos)) name) : @regular_space.{0} (has_add.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (has_add.{0} pos)) name h0)  := sorry --non-trivial
lemma new_lemma_2912 (h0 : function.extfun Type list) : palindrome (function.extfun_app h0 (linear_ordered_comm_monoid_with_zero num)) := sorry --non-trivial
lemma new_lemma_2913 (h0 : topological_space (linear_ordered_semiring (has_norm empty))) : totally_separated_space (linear_ordered_semiring (has_norm empty)) := sorry --non-trivial
lemma new_lemma_2914 (h0 : function.extfun Type list) : list.nodup (function.extfun_app h0 (monoid unsigned)) := sorry --non-trivial
lemma new_lemma_2915 (h0 : not (topological_space (pfun (has_nnnorm char) fun_info) -> false)) : @totally_disconnected_space.{0} (pfun.{0 0} (has_nnnorm.{0} char) fun_info) (@classical.by_contradiction'.{1} (topological_space.{0} (pfun.{0 0} (has_nnnorm.{0} char) fun_info)) h0)  := sorry --non-trivial
lemma new_lemma_2916 (h0 : group (linear_ordered_field to_additive.value_type)) : is_cyclic (linear_ordered_field to_additive.value_type) := sorry --non-trivial
lemma new_lemma_2917 (h0 : functor.add_const (topological_space (has_zero name)) environment.implicit_infer_kind) : @t1_space.{0} (has_zero.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (has_zero.{0} name)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_2918 (h0 : uniform_space (linear_ordered_comm_group_with_zero linarith.ineq)) : complete_space (linear_ordered_comm_group_with_zero linarith.ineq) := sorry --non-trivial
lemma new_lemma_2919 (h0 : group (comm_monoid (comm_group pos))) : group.fg (comm_monoid (comm_group pos)) := sorry --non-trivial
lemma new_lemma_2920 (h0 : topological_space (comm_group pos)) : totally_separated_space (comm_group pos) := sorry --non-trivial
lemma new_lemma_2921 (h0 : list (finset (has_neg linarith.comp))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_2922 (h0 : list (ring (semi_normed_ring linarith.comp_source))) (h1 : ne h0 list.nil) : @is_domain.{0} (semi_normed_ring.{0} linarith.comp_source) (@list.last.{0} (ring.{0} (semi_normed_ring.{0} linarith.comp_source)) h0 h1)  := sorry --non-trivial
lemma new_lemma_2923 (h0 : not (ring (set linarith.comp_source) -> false)) : @is_domain.{0} (set.{0} linarith.comp_source) (@classical.by_contradiction'.{1} (ring.{0} (set.{0} linarith.comp_source)) h0)  := sorry --non-trivial
lemma new_lemma_2924 (h0 : functor.add_const (topological_space (has_zero Type)) name) : @totally_disconnected_space.{1} (has_zero.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (has_zero.{1} Type)) name h0)  := sorry --non-trivial
lemma new_lemma_2925 (h0 : functor.add_const (topological_space (has_neg unsigned)) Type) : @topological_space.separable_space.{0} (has_neg.{0} unsigned) (@functor.add_const.run.{0 1} (topological_space.{0} (has_neg.{0} unsigned)) Type h0)  := sorry --non-trivial
lemma new_lemma_2926 (h0 : function.extfun Type topological_space) : @locally_compact_space.{0} (denumerable.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (denumerable.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_2927 (h0 : functor.add_const (complete_lattice (ring Type)) Type) : @is_compactly_generated.{1} (ring.{1} Type) (@functor.add_const.run.{1 1} (complete_lattice.{1} (ring.{1} Type)) Type h0)  := sorry --non-trivial
lemma new_lemma_2928 (h0 : functor.add_const (topological_space (add_cancel_monoid Type)) (finset pos)) : @sequential_space.{1} (add_cancel_monoid.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (add_cancel_monoid.{1} Type)) (finset.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_2929 (h0 : function.extfun Type group) : @normalizer_condition.{0} (distrib_lattice.{0} string_imp) (@function.extfun_app.{2 1} Type group.{0} h0 (distrib_lattice.{0} string_imp))  := sorry --non-trivial
lemma new_lemma_2930 (h0 : ring (semigroup (has_nndist Type))) : is_domain (semigroup (has_nndist Type)) := sorry --non-trivial
lemma new_lemma_2931 (h0 : group (has_emptyc (semiring linarith.comp_source))) : group.fg (has_emptyc (semiring linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_2932 (h0 : topological_space (ring (ring linarith.comp))) : discrete_topology (ring (ring linarith.comp)) := sorry --non-trivial
lemma new_lemma_2933 (h0 : group (has_neg (finset environment.implicit_infer_kind))) : is_cyclic (has_neg (finset environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_2934 (h0 : functor.add_const (function.extfun Type semiring) linarith.comp) : @is_noetherian_ring.{0} (has_add.{0} name) (@function.extfun_app.{2 1} Type semiring.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type semiring.{0}) linarith.comp h0) (has_add.{0} name))  := sorry --non-trivial
lemma new_lemma_2935 (h0 : topological_space (has_one (has_norm empty))) : normal_space (has_one (has_norm empty)) := sorry --non-trivial
lemma new_lemma_2936 (h0 : functor.add_const (topological_space (finset pos)) (has_Inf Type)) : @regular_space.{0} (finset.{0} pos) (@functor.add_const.run.{0 1} (topological_space.{0} (finset.{0} pos)) (has_Inf.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_2937 (h1 : measurable_space (add_comm_semigroup (add_comm_semigroup enat))) (h2 : filter (add_comm_semigroup (add_comm_semigroup enat))) : filter.is_measurably_generated h2 := sorry --non-trivial
lemma new_lemma_2938 (h0 : ring (with_bot congr_arg_kind)) : is_domain (with_bot congr_arg_kind) := sorry --non-trivial
lemma new_lemma_2939 (h0 : complete_lattice (mul_zero_class unsigned)) : complete_lattice.is_Sup_finite_compact (mul_zero_class unsigned) := sorry --non-trivial
lemma new_lemma_2940 (h0 : ring (mul_one_class linarith.comp_source)) : is_domain (mul_one_class linarith.comp_source) := sorry --non-trivial
lemma new_lemma_2941 (h0 : function.extfun Type topological_space) : @totally_separated_space.{0} (has_Sup.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_Sup.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_2942 (h0 : topological_space (cancel_monoid (boolean_algebra.core name))) : totally_disconnected_space (cancel_monoid (boolean_algebra.core name)) := sorry --non-trivial
lemma new_lemma_2943 (h0 : group (plift (left_cancel_semigroup num))) : is_cyclic (plift (left_cancel_semigroup num)) := sorry --non-trivial
lemma new_lemma_2944 (h0 : function.extfun (finset Type) (has_mem.mem (random_gen num))) : @irreducible_space.{0} (random_gen.{0} num) (@finset.pi.empty.{1 0} Type topological_space.{0} (random_gen.{0} num) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (random_gen.{0} num)) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_2945 (h0 : function.extfun Type uniform_space) : @complete_space.{0} (simple_graph.{0} name) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (simple_graph.{0} name))  := sorry --non-trivial
lemma new_lemma_2946 (h0 : filter (measurable_space (semiring num))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_2947 (h0 : add_monoid (has_neg_part (has_add environment.implicit_infer_kind))) : add_monoid.fg (has_neg_part (has_add environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_2948 (h0 : uniform_space (has_add (finset (finset Type)))) : separated_space (has_add (finset (finset Type))) := sorry --non-trivial
lemma new_lemma_2949 (h0 : topological_space (normed_group (random_gen linarith.comp))) : path_connected_space (normed_group (random_gen linarith.comp)) := sorry --non-trivial
lemma new_lemma_2950 (h0 : functor.add_const (topological_space (ordered_comm_group unsigned)) empty) : @normal_space.{0} (ordered_comm_group.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (ordered_comm_group.{0} unsigned)) empty h0)  := sorry --non-trivial
lemma new_lemma_2951 (h0 : not (ring (with_one linarith.comp_source) -> false)) : @strong_rank_condition.{0} (with_one.{0} linarith.comp_source) (@classical.by_contradiction'.{1} (ring.{0} (with_one.{0} linarith.comp_source)) h0)  := sorry --non-trivial
lemma new_lemma_2952 (h0 : add_monoid (add_cancel_monoid (has_to_string (finset (ring linarith.comp))))) : add_monoid.fg (add_cancel_monoid (has_to_string (finset (ring linarith.comp)))) := sorry --non-trivial
lemma new_lemma_2953 (h0 : ring (boolean_algebra.core (has_to_string name))) : is_principal_ideal_ring (boolean_algebra.core (has_to_string name)) := sorry --non-trivial
lemma new_lemma_2954 (h0 : function.extfun Type ring) : @rank_condition.{0} (semigroup.{0} ennreal) (@function.extfun_app.{2 1} Type ring.{0} h0 (semigroup.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_2955 (h0 : group (topological_space (random_gen (random_gen (random_gen linarith.ineq))))) : group.fg (topological_space (random_gen (random_gen (random_gen linarith.ineq)))) := sorry --non-trivial
lemma new_lemma_2956 (h4 : topological_space (distrib linarith.comp_source)) : t0_space (distrib linarith.comp_source) := sorry --non-trivial
lemma new_lemma_2957 (h0 : functor.add_const (function.extfun Type group) linarith.comp) : @is_simple_group.{0} (has_zero.{0} pos) (@function.extfun_app.{2 1} Type group.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type group.{0}) linarith.comp h0) (has_zero.{0} pos))  := sorry --non-trivial
lemma new_lemma_2958 (h1 : add_group (linear_ordered_add_comm_group (has_ssubset string_imp))) : is_add_cyclic (linear_ordered_add_comm_group (has_ssubset string_imp)) := sorry --non-trivial
lemma new_lemma_2959 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : list.nodup (function.extfun_app (function.extfun_app h0 list) (linear_ordered_field congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_2960 (h0 : ordered_add_comm_monoid (ordered_comm_ring (has_add name))) : archimedean (ordered_comm_ring (has_add name)) := sorry --non-trivial
lemma new_lemma_2961 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @unique_factorization_monoid.{0} (complete_distrib_lattice.{0} pos) (@function.extfun_app.{2 1} Type cancel_comm_monoid_with_zero.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 cancel_comm_monoid_with_zero.{0}) (complete_distrib_lattice.{0} pos))  := sorry --non-trivial
lemma new_lemma_2962 (h0 : set char) (h1 : char -> char -> Prop) : set.well_founded_on h0 h1 := sorry --non-trivial
lemma new_lemma_2963 (h0 : ring (mul_zero_class (semiring (semiring num)))) : is_domain (mul_zero_class (semiring (semiring num))) := sorry --non-trivial
lemma new_lemma_2964 (h0 : topological_space (id (semiring (semiring empty)))) : path_connected_space (id (semiring (semiring empty))) := sorry --non-trivial
lemma new_lemma_2965 (h0 : fin has_zero.zero) : @is_noetherian_ring.{0} (add_comm_monoid.{0} real) (@matrix.vec_empty.{0} (semiring.{0} (add_comm_monoid.{0} real)) h0)  := sorry --non-trivial
lemma new_lemma_2966 (h0 : function.extfun (Type 1) (functor.add_const (topological_space Type))) : @path_connected_space.{1} Type (@functor.add_const.run.{1 1} (topological_space.{1} Type) Type (@function.extfun_app.{3 2} (Type 1) (functor.add_const.{1 1} (topological_space.{1} Type)) h0 Type))  := sorry --non-trivial
lemma new_lemma_2967 (h0 : functor.add_const (filter (has_to_string pos)) pos) : filter.ne_bot (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_2968 (h0 : topological_space (linear_ordered_comm_group (option (option ennreal)))) : preirreducible_space (linear_ordered_comm_group (option (option ennreal))) := sorry --non-trivial
lemma new_lemma_2969 (h0 : topological_space (add_comm_monoid Type)) : discrete_topology (add_comm_monoid Type) := sorry --non-trivial
lemma new_lemma_2970 (h0 : fin has_zero.zero) : @totally_separated_space.{1} (normed_lattice_add_comm_group.{1} Type) (@matrix.vec_empty.{1} (topological_space.{1} (normed_lattice_add_comm_group.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_2971 (h0 : function.extfun Type add_group) : @is_add_cyclic.{0} (has_norm.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type add_group.{0} h0 (has_norm.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_2972 (h0 : monoid (add_comm_monoid (has_to_string name))) : monoid.fg (add_comm_monoid (has_to_string name)) := sorry --non-trivial
lemma new_lemma_2973 (h0 : function.extfun Type topological_space) : @path_connected_space.{0} (ordered_cancel_add_comm_monoid.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (ordered_cancel_add_comm_monoid.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_2974 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @preirreducible_space.{0} (has_bot.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_bot.{0} name))  := sorry --non-trivial
lemma new_lemma_2975 (h0 : function.extfun Type add_group) : @is_add_cyclic.{0} (random_gen.{0} fun_info) (@function.extfun_app.{2 1} Type add_group.{0} h0 (random_gen.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_2976 (h0 : topological_space (has_top (random_gen (random_gen fun_info)))) : totally_separated_space (has_top (random_gen (random_gen fun_info))) := sorry --non-trivial
lemma new_lemma_2977 (h0 : uniform_space (with_one (semiring (semiring congr_arg_kind)))) : complete_space (with_one (semiring (semiring congr_arg_kind))) := sorry --non-trivial
lemma new_lemma_2978 (h1 : ring (with_one string_imp)) : rank_condition (with_one string_imp) := sorry --non-trivial
lemma new_lemma_2979 (h0 : group (semigroup (has_add name))) : normalizer_condition (semigroup (has_add name)) := sorry --non-trivial
lemma new_lemma_2980 (h0 : function.extfun Type ring) : @rank_condition.{0} (complete_semilattice_Sup.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type ring.{0} h0 (complete_semilattice_Sup.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_2981 (h0 : functor.add_const (topological_space (has_edist num)) empty) : @discrete_topology.{0} (has_edist.{0} num) (@functor.add_const.run.{0 0} (topological_space.{0} (has_edist.{0} num)) empty h0)  := sorry --non-trivial
lemma new_lemma_2982 (h0 : list (normed_comm_ring (has_add linarith.comp))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_2983 (h0 : topological_space (option (semiring num))) : totally_disconnected_space (option (semiring num)) := sorry --non-trivial
lemma new_lemma_2984 (h0 : functor.add_const (functor.comp cancel_comm_monoid_with_zero has_add int) environment.implicit_infer_kind) : @unique_factorization_monoid.{0} (has_add.{0} int) (@functor.comp.run.{0 0 0} cancel_comm_monoid_with_zero.{0} has_add.{0} int (@functor.add_const.run.{0 0} (functor.comp.{0 0 0} cancel_comm_monoid_with_zero.{0} has_add.{0} int) environment.implicit_infer_kind h0))  := sorry --non-trivial
lemma new_lemma_2985 (h1 : topological_space (fintype linarith.comp_source)) : totally_disconnected_space (fintype linarith.comp_source) := sorry --non-trivial
lemma new_lemma_2986 (h0 : functor.add_const (ring (has_neg_part pos)) (has_neg linarith.comp)) : @rank_condition.{0} (has_neg_part.{0} pos) (@functor.add_const.run.{0 0} (ring.{0} (has_neg_part.{0} pos)) (has_neg.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_2987 (h0 : functor.add_const (function.extfun Type topological_space) linarith.comp) : @topological_space.separable_space.{0} (has_add.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) linarith.comp h0) (has_add.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_2988 (h0 : topological_space (comm_semigroup (has_bot (sub_neg_monoid name)))) : locally_compact_space (comm_semigroup (has_bot (sub_neg_monoid name))) := sorry --non-trivial
lemma new_lemma_2989 (h0 : ring (has_union (semiring (semiring (semiring congr_arg_kind))))) : is_domain (has_union (semiring (semiring (semiring congr_arg_kind)))) := sorry --non-trivial
lemma new_lemma_2990 (h0 : topological_space (normed_group (semiring empty))) : normal_space (normed_group (semiring empty)) := sorry --non-trivial
lemma new_lemma_2991 (h0 : ring (normed_group (semiring (semiring congr_arg_kind)))) : strong_rank_condition (normed_group (semiring (semiring congr_arg_kind))) := sorry --non-trivial
lemma new_lemma_2992 (h0 : function.extfun Type complete_lattice) : @complete_lattice.is_Sup_finite_compact.{0} (linear_ordered_comm_group.{0} (option.{0} ennreal)) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (linear_ordered_comm_group.{0} (option.{0} ennreal)))  := sorry --non-trivial
lemma new_lemma_2993 (h0 : list (comm_group name)) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_2994 (h0 : topological_space (canonically_ordered_monoid (ordered_comm_monoid (ordered_comm_monoid linarith.comp)))) : regular_space (canonically_ordered_monoid (ordered_comm_monoid (ordered_comm_monoid linarith.comp))) := sorry --non-trivial
lemma new_lemma_2995 (h0 : not (topological_space (measurable_space empty) -> false)) : @totally_separated_space.{0} (measurable_space.{0} empty) (@classical.by_contradiction'.{1} (topological_space.{0} (measurable_space.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_2996 (h0 : not (complete_lattice (add_cancel_monoid linarith.comp_source) -> false)) : @complete_lattice.is_Sup_finite_compact.{0} (add_cancel_monoid.{0} linarith.comp_source) (@classical.by_contradiction'.{1} (complete_lattice.{0} (add_cancel_monoid.{0} linarith.comp_source)) h0)  := sorry --non-trivial
lemma new_lemma_2997 (h0 : list (ring unsigned)) : palindrome h0 := sorry --non-trivial
lemma new_lemma_2998 (h0 : function.extfun Type topological_space) : @path_connected_space.{0} num (@function.extfun_app.{2 1} Type topological_space.{0} h0 num)  := sorry --non-trivial
lemma new_lemma_2999 (h0 : uniform_space (has_top (has_top (has_top congr_arg_kind)))) : separated_space (has_top (has_top (has_top congr_arg_kind))) := sorry --non-trivial
lemma new_lemma_3000 (h1 h2 : multiset (nondiscrete_normed_field (normed_field (normed_field reducibility_hints)))) : multiset.subset h1 h2 := sorry --non-trivial
lemma new_lemma_3001 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @strong_rank_condition.{0} (option.{0} empty) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (option.{0} empty))  := sorry --non-trivial
lemma new_lemma_3002 (h1 : function.extfun Type topological_space) : @locally_compact_space.{0} (has_emptyc.{0} fun_info) (@function.extfun_app.{2 1} Type topological_space.{0} h1 (has_emptyc.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_3003 (h0 : function.extfun Type (functor.comp topological_space complete_distrib_lattice)) : @locally_compact_space.{0} (complete_distrib_lattice.{0} unsigned) (@functor.comp.run.{0 0 0} topological_space.{0} complete_distrib_lattice.{0} unsigned (@function.extfun_app.{2 1} Type (functor.comp.{0 0 0} topological_space.{0} complete_distrib_lattice.{0}) h0 unsigned))  := sorry --non-trivial
lemma new_lemma_3004 (h0 : topological_space (has_zero (has_nndist (has_add name)))) : preirreducible_space (has_zero (has_nndist (has_add name))) := sorry --non-trivial
lemma new_lemma_3005 (h0 : list (linear_ordered_comm_group empty)) : palindrome h0 := sorry --non-trivial
lemma new_lemma_3006 (h0 : group (pseudo_metric_space (option empty))) : group.fg (pseudo_metric_space (option empty)) := sorry --non-trivial
lemma new_lemma_3007 (h0 : ring (add_comm_monoid name)) : rank_condition (add_comm_monoid name) := sorry --non-trivial
lemma new_lemma_3008 (h1 : list (with_one (random_gen num))) : list.nodup h1 := sorry --non-trivial
lemma new_lemma_3009 (h0 : topological_space (topological_space fun_info)) : totally_disconnected_space (topological_space fun_info) := sorry --non-trivial
lemma new_lemma_3010 (h0 : uniform_space (nondiscrete_normed_field ereal)) : complete_space (nondiscrete_normed_field ereal) := sorry --non-trivial
lemma new_lemma_3011 (h0 : filter (group_with_zero congr_arg_kind)) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_3012 (h0 : option (topological_space (with_one empty))) (h1 : topological_space (with_one empty)) : preirreducible_space (with_one empty) := sorry --non-trivial
lemma new_lemma_3013 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @complete_space.{0} (has_pos_part.{0} name) (@function.extfun_app.{2 1} Type uniform_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 uniform_space.{0}) (has_pos_part.{0} name))  := sorry --non-trivial
lemma new_lemma_3014 (h0 : functor.add_const (function.extfun (Type 1) topological_space) pos) : @totally_separated_space.{1} (ring.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) topological_space.{1}) pos h0) (ring.{1} Type))  := sorry --non-trivial
lemma new_lemma_3015 (h0 : functor.add_const (uniform_space (add_comm_monoid name)) linarith.comp) : @separated_space.{0} (add_comm_monoid.{0} name) (@functor.add_const.run.{0 0} (uniform_space.{0} (add_comm_monoid.{0} name)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_3016 (h0 : not (uniform_space (has_div reducibility_hints) -> false)) : @complete_space.{0} (has_div.{0} reducibility_hints) (@classical.by_contradiction'.{1} (uniform_space.{0} (has_div.{0} reducibility_hints)) h0)  := sorry --non-trivial
lemma new_lemma_3017 (h0 : functor.add_const (uniform_space (linear_order empty)) (semiring (semiring (semiring (semiring empty))))) : @separated_space.{0} (linear_order.{0} empty) (@functor.add_const.run.{0 0} (uniform_space.{0} (linear_order.{0} empty)) (semiring.{0} (semiring.{0} (semiring.{0} (semiring.{0} empty)))) h0)  := sorry --non-trivial
lemma new_lemma_3018 (h0 : cancel_comm_monoid_with_zero (has_inter congr_arg_kind)) : unique_factorization_monoid (has_inter congr_arg_kind) := sorry --non-trivial
lemma new_lemma_3019 (h0 : filter (has_inter unsigned)) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_3020 (h0 : functor.add_const (topological_space (complete_distrib_lattice pos)) (has_add Type)) : @totally_separated_space.{0} (complete_distrib_lattice.{0} pos) (@functor.add_const.run.{0 1} (topological_space.{0} (complete_distrib_lattice.{0} pos)) (has_add.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_3021 (h0 : function.extfun nat fin) (h1 : function.extfun Type has_mul) : @has_measurable_mul₂.{0} (ordered_comm_monoid.{0} name) (@matrix.vec_empty.{0} (measurable_space.{0} (ordered_comm_monoid.{0} name)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero))) (@function.extfun_app.{2 1} Type has_mul.{0} h1 (ordered_comm_monoid.{0} name))  := sorry --non-trivial
lemma new_lemma_3022 (h0 : uniform_space (has_sub empty)) : complete_space (has_sub empty) := sorry --non-trivial
lemma new_lemma_3023 (h0 : complete_lattice (has_dist unsigned)) : is_compactly_generated (has_dist unsigned) := sorry --non-trivial
lemma new_lemma_3024 (h0 : function.extfun nat fin) : @complete_lattice.is_Sup_finite_compact.{0} (add_group.{0} linarith.comp) (@matrix.vec_empty.{0} (complete_lattice.{0} (add_group.{0} linarith.comp)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_3025 (h0 : functor.add_const (ordered_add_comm_monoid (has_to_string ennreal)) (option pos)) : @archimedean.{0} (has_to_string.{0} ennreal) (@functor.add_const.run.{0 0} (ordered_add_comm_monoid.{0} (has_to_string.{0} ennreal)) (option.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_3026 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @preirreducible_space.{0} (add_cancel_monoid.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (add_cancel_monoid.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_3027 (h0 : ring (linear_ordered_comm_group unsigned)) : is_domain (linear_ordered_comm_group unsigned) := sorry --non-trivial
lemma new_lemma_3028 (h0 : set (environment.projection_info -> mul_one_class string.iterator_imp)) : set.separates_points h0 := sorry --non-trivial
lemma new_lemma_3029 (h0 : list (pseudo_metric_space (has_add name))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_3030 (h0 : prod (add_right_cancel_monoid unsigned) (add_right_cancel_monoid unsigned)) : id_rel h0 := sorry --non-trivial
lemma new_lemma_3031 (h0 : not (topological_space (has_div string.iterator_imp) -> false)) : @t0_space.{0} (has_div.{0} string.iterator_imp) (@classical.by_contradiction'.{1} (topological_space.{0} (has_div.{0} string.iterator_imp)) h0)  := sorry --non-trivial
lemma new_lemma_3032 (h0 : function.extfun Type complete_lattice) : @is_compactly_generated.{0} (semigroup.{0} (option.{0} (option.{0} empty))) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (semigroup.{0} (option.{0} (option.{0} empty))))  := sorry --non-trivial
lemma new_lemma_3033 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @group.fg.{1} (has_Inf.{1} Type) (@function.extfun_app.{3 2} (Type 1) group.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 group.{1}) (has_Inf.{1} Type))  := sorry --non-trivial
lemma new_lemma_3034 (h0 : topological_space (complete_distrib_lattice environment.implicit_infer_kind)) : totally_separated_space (complete_distrib_lattice environment.implicit_infer_kind) := sorry --non-trivial
lemma new_lemma_3035 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_compactly_generated.{0} (has_nndist.{0} pos) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (has_nndist.{0} pos))  := sorry --non-trivial
lemma new_lemma_3036 (h0 : complete_lattice (distrib enat)) : is_compactly_generated (distrib enat) := sorry --non-trivial
lemma new_lemma_3037 (h0 : uniform_space (with_one (has_inv (has_top linarith.comp_source)))) : complete_space (with_one (has_inv (has_top linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_3038 (h0 : function.extfun Type group) : @is_cyclic.{0} (ordered_comm_monoid.{0} name) (@function.extfun_app.{2 1} Type group.{0} h0 (ordered_comm_monoid.{0} name))  := sorry --non-trivial
lemma new_lemma_3039 (h0 : functor.add_const (filter (has_to_string linarith.comp)) Type) : countable_Inter_filter (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_3040 (h0 : functor.add_const (group (normed_comm_ring linarith.comp)) linarith.comp) : @group.fg.{0} (normed_comm_ring.{0} linarith.comp) (@functor.add_const.run.{0 0} (group.{0} (normed_comm_ring.{0} linarith.comp)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_3041 (h0 : complete_lattice (mul_zero_class (semiring (semiring (semiring empty))))) : complete_lattice.is_Sup_finite_compact (mul_zero_class (semiring (semiring (semiring empty)))) := sorry --non-trivial
lemma new_lemma_3042 (h0 : topological_space (denumerable (random_gen (random_gen fun_info)))) : totally_disconnected_space (denumerable (random_gen (random_gen fun_info))) := sorry --non-trivial
lemma new_lemma_3043 (h0 : topological_space (linear_ordered_comm_group empty)) : normal_space (linear_ordered_comm_group empty) := sorry --non-trivial
lemma new_lemma_3044 (h0 : function.extfun Type topological_space) : @discrete_topology.{0} (has_to_string.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_to_string.{0} empty))  := sorry --non-trivial
lemma new_lemma_3045 (h0 : semiring (has_Inf (has_Inf linarith.comp))) : is_noetherian_ring (has_Inf (has_Inf linarith.comp)) := sorry --non-trivial
lemma new_lemma_3046 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_domain.{0} (@id.{2} Type to_additive.value_type) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (@id.{2} Type to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_3047 (h0 : function.extfun Type semiring) : @is_noetherian_ring.{0} environment.implicit_infer_kind (@function.extfun_app.{2 1} Type semiring.{0} h0 environment.implicit_infer_kind)  := sorry --non-trivial
lemma new_lemma_3048 (h0 : monoid (has_top (has_one (metric_space (has_norm (with_bot num)))))) : monoid.fg (has_top (has_one (metric_space (has_norm (with_bot num))))) := sorry --non-trivial
lemma new_lemma_3049 (h0 : functor.add_const (group (boolean_algebra Type)) Type) : @group.fg.{1} (boolean_algebra.{1} Type) (@functor.add_const.run.{1 1} (group.{1} (boolean_algebra.{1} Type)) Type h0)  := sorry --non-trivial
lemma new_lemma_3050 (h2 : topological_space (normed_field linarith.comp_source)) : path_connected_space (normed_field linarith.comp_source) := sorry --non-trivial
lemma new_lemma_3051 (h2 : uniform_space (fintype linarith.comp_source)) : complete_space (fintype linarith.comp_source) := sorry --non-trivial
lemma new_lemma_3052 (h0 : functor.add_const (topological_space (ordered_comm_group empty)) congr_arg_kind) : @t0_space.{0} (ordered_comm_group.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (ordered_comm_group.{0} empty)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_3053 (h0 : ring (has_union (has_union congr_arg_kind))) : strong_rank_condition (has_union (has_union congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_3054 (h0 : ordered_semiring (normed_comm_ring empty)) (h1 : list (floor_semiring (normed_comm_ring empty))) : palindrome h1 := sorry --non-trivial
lemma new_lemma_3055 (h0 : topological_space (complete_linear_order (semiring congr_arg_kind))) : discrete_topology (complete_linear_order (semiring congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_3056 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @totally_disconnected_space.{0} (linear_ordered_add_comm_group.{0} linarith.ineq) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (linear_ordered_add_comm_group.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_3057 (h0 : functor.add_const (functor.add_const Prop (has_neg_part name)) name) : functor.add_const.run (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_3058 (h0 : monoid (complete_semilattice_Sup (random_gen (has_top (has_inv to_additive.value_type))))) : monoid.fg (complete_semilattice_Sup (random_gen (has_top (has_inv to_additive.value_type)))) := sorry --non-trivial
lemma new_lemma_3059 (h0 : complete_lattice (bin_tree (semiring num))) : is_atomistic (bin_tree (semiring num)) := sorry --non-trivial
lemma new_lemma_3060 (h0 : pnat) (h1 : thunk pnat) : pnat.coprime h0 (@id.{1} pnat (@id.{1} pnat (@trace_call_stack.{0} pnat h1)))  := sorry --non-trivial
lemma new_lemma_3061 (h0 : not (topological_space (left_cancel_semigroup empty) -> false)) : @normal_space.{0} (left_cancel_semigroup.{0} empty) (@classical.by_contradiction'.{1} (topological_space.{0} (left_cancel_semigroup.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_3062 (h0 : ring (normed_comm_ring (has_add name))) : is_principal_ideal_ring (normed_comm_ring (has_add name)) := sorry --non-trivial
lemma new_lemma_3063 (h0 : list (has_add (ring name))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_3064 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @group.fg.{0} (has_Inf.{0} linarith.comp) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (has_Inf.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_3065 (h0 : topological_space (add_left_cancel_monoid string.iterator_imp)) : totally_disconnected_space (add_left_cancel_monoid string.iterator_imp) := sorry --non-trivial
lemma new_lemma_3066 (h0 : topological_space (mul_one_class (mul_one_class char))) (h1 : set (mul_one_class (mul_one_class char))) : is_path_connected h1 := sorry --non-trivial
lemma new_lemma_3067 (h0 : not (topological_space (non_assoc_semiring congr_arg_kind) -> false)) : @path_connected_space.{0} (non_assoc_semiring.{0} congr_arg_kind) (@classical.by_contradiction'.{1} (topological_space.{0} (non_assoc_semiring.{0} congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_3068 (h0 : functor.add_const (group (finset Type)) name) : @is_simple_group.{1} (finset.{1} Type) (@functor.add_const.run.{1 0} (group.{1} (finset.{1} Type)) name h0)  := sorry --non-trivial
lemma new_lemma_3069 (h0 : functor.add_const (group (with_bot linarith.comp_source)) linarith.ineq) : @is_cyclic.{0} (with_bot.{0} linarith.comp_source) (@functor.add_const.run.{0 0} (group.{0} (with_bot.{0} linarith.comp_source)) linarith.ineq h0)  := sorry --non-trivial
lemma new_lemma_3070 (h0 : function.extfun Type group) : @group.fg.{0} (semi_normed_comm_ring.{0} fun_info) (@function.extfun_app.{2 1} Type group.{0} h0 (semi_normed_comm_ring.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_3071 (h0 : group char) (h1 : subgroup char) : subgroup.saturated h1 := sorry --non-trivial
lemma new_lemma_3072 (h0 : function.extfun Type topological_space) : @t0_space.{0} (metric_space.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (metric_space.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_3073 (h0 : function.extfun Type uniform_space) : @complete_space.{0} (@id.{2} Type congr_arg_kind) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (@id.{2} Type congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_3074 (h0 : topological_space (has_neg (has_nndist Type))) : regular_space (has_neg (has_nndist Type)) := sorry --non-trivial
lemma new_lemma_3075 (h0 : topological_space (option name)) : t1_space (option name) := sorry --non-trivial
lemma new_lemma_3076 (h0 : function.extfun Type filter) : countable_Inter_filter (function.extfun_app h0 (has_Inf real)) := sorry --non-trivial
lemma new_lemma_3077 (h0 : ring (with_bot (semiring unsigned))) : is_domain (with_bot (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_3078 (h0 : complete_lattice (boolean_algebra (comm_semigroup (comm_semigroup (comm_semigroup real))))) : is_compactly_generated (boolean_algebra (comm_semigroup (comm_semigroup (comm_semigroup real)))) := sorry --non-trivial
lemma new_lemma_3079 (h0 : ring (metric_space string_imp)) : strong_rank_condition (metric_space string_imp) := sorry --non-trivial
lemma new_lemma_3080 (h0 : prod (has_nndist (finset environment.implicit_infer_kind)) (has_nndist (finset environment.implicit_infer_kind))) : id_rel h0 := sorry --non-trivial
lemma new_lemma_3081 (h0 : functor.add_const (topological_space (has_to_string name)) linarith.comp) : @sequential_space.{0} (has_to_string.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (has_to_string.{0} name)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_3082 (h0 : semiring (boolean_algebra (has_pos_part (has_pos_part (has_Inf linarith.comp))))) : is_noetherian_ring (boolean_algebra (has_pos_part (has_pos_part (has_Inf linarith.comp)))) := sorry --non-trivial
lemma new_lemma_3083 (h0 : cancel_comm_monoid_with_zero (conditionally_complete_linear_order unsigned)) : unique_factorization_monoid (conditionally_complete_linear_order unsigned) := sorry --non-trivial
lemma new_lemma_3084 (h0 : function.extfun Type (functor.add_const Prop)) : functor.add_const.run (function.extfun_app h0 (has_norm (has_norm linarith.comp))) := sorry --non-trivial
lemma new_lemma_3085 (h0 : ring (boolean_algebra (finset linarith.comp))) : is_domain (boolean_algebra (finset linarith.comp)) := sorry --non-trivial
lemma new_lemma_3086 (h0 : group (comm_group (add_cancel_monoid (add_cancel_monoid environment.implicit_infer_kind)))) : group.fg (comm_group (add_cancel_monoid (add_cancel_monoid environment.implicit_infer_kind))) := sorry --non-trivial
lemma new_lemma_3087 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @add_monoid.fg.{0} (canonically_linear_ordered_monoid.{0} ennreal) (@function.extfun_app.{2 1} Type add_monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 add_monoid.{0}) (canonically_linear_ordered_monoid.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_3088 (h0 : ordered_add_comm_monoid (ordered_comm_ring (semigroup (finset name)))) : archimedean (ordered_comm_ring (semigroup (finset name))) := sorry --non-trivial
lemma new_lemma_3089 (h0 : list (linear_ordered_add_comm_group (has_norm (has_ssubset (random_gen (has_norm fun_info)))))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_3090 (h0 : fin has_zero.zero) : @strong_rank_condition.{0} (has_add.{0} pos) (@matrix.vec_empty.{0} (ring.{0} (has_add.{0} pos)) h0)  := sorry --non-trivial
lemma new_lemma_3091 (h0 : not (complete_lattice (linear_ordered_comm_ring congr_arg_kind) -> false)) : @complete_lattice.is_Sup_finite_compact.{0} (linear_ordered_comm_ring.{0} congr_arg_kind) (@classical.by_contradiction'.{1} (complete_lattice.{0} (linear_ordered_comm_ring.{0} congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_3092 (h0 : group (has_top (comm_ring (with_bot (comm_ring linarith.ineq))))) : group.fg (has_top (comm_ring (with_bot (comm_ring linarith.ineq)))) := sorry --non-trivial
lemma new_lemma_3093 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @t0_space.{0} (is_R_or_C.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (is_R_or_C.{0} unsigned)) (option.{0} (option.{0} (option.{0} empty))) (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (topological_space.{0} (is_R_or_C.{0} unsigned))) (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 (functor.add_const.{0 0} (topological_space.{0} (is_R_or_C.{0} unsigned)))) (option.{0} (option.{0} (option.{0} empty)))))  := sorry --non-trivial
lemma new_lemma_3094 (h0 : add_monoid (ring empty)) : add_monoid.fg (ring empty) := sorry --non-trivial
lemma new_lemma_3095 (h0 : add_monoid (boolean_algebra Type)) : add_monoid.fg (boolean_algebra Type) := sorry --non-trivial
lemma new_lemma_3096 (h0 : complete_lattice (complete_distrib_lattice (option (option unsigned)))) : is_compactly_generated (complete_distrib_lattice (option (option unsigned))) := sorry --non-trivial
lemma new_lemma_3097 (h0 : functor.add_const (topological_space (ring linarith.comp)) name) : @preirreducible_space.{0} (ring.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (ring.{0} linarith.comp)) name h0)  := sorry --non-trivial
lemma new_lemma_3098 (h0 : group (add_group (semiring (semiring unsigned)))) : normalizer_condition (add_group (semiring (semiring unsigned))) := sorry --non-trivial
lemma new_lemma_3099 (h0 : not (function.extfun Type add_monoid -> false)) : @add_monoid.fg.{0} congr_arg_kind (@function.extfun_app.{2 1} Type add_monoid.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type add_monoid.{0}) h0) congr_arg_kind)  := sorry --non-trivial
lemma new_lemma_3100 (h0 : group (comm_group linarith.comp)) : is_cyclic (comm_group linarith.comp) := sorry --non-trivial
lemma new_lemma_3101 (h0 : functor.add_const (group (boolean_algebra linarith.comp)) (has_to_string (has_to_string linarith.comp))) : @normalizer_condition.{0} (boolean_algebra.{0} linarith.comp) (@functor.add_const.run.{0 0} (group.{0} (boolean_algebra.{0} linarith.comp)) (has_to_string.{0} (has_to_string.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_3102 (h0 : complete_lattice (non_assoc_semiring (option unsigned))) : is_compactly_generated (non_assoc_semiring (option unsigned)) := sorry --non-trivial
lemma new_lemma_3103 (h0 : functor.add_const (topological_space (boolean_algebra linarith.comp)) pos) : @locally_compact_space.{0} (boolean_algebra.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (boolean_algebra.{0} linarith.comp)) pos h0)  := sorry --non-trivial
lemma new_lemma_3104 (h0 : has_mul (add_cancel_comm_monoid unsigned)) (h1 : monoid (con (add_cancel_comm_monoid unsigned))) : monoid.fg (con (add_cancel_comm_monoid unsigned)) := sorry --non-trivial
lemma new_lemma_3105 (h2 : group (id (has_top linarith.comp_source))) : normalizer_condition (id (has_top linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_3106 (h0 : functor.add_const (ordered_comm_monoid (ring pos)) (has_Inf (finset linarith.comp))) : @has_exists_mul_of_le.{0} (ring.{0} pos) (@functor.add_const.run.{0 0} (ordered_comm_monoid.{0} (ring.{0} pos)) (has_Inf.{0} (finset.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_3107 (h0 : finset (has_add ennreal)) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_3108 (h0 : not (topological_space (has_lt linarith.ineq) -> false)) : @totally_disconnected_space.{0} (has_lt.{0} linarith.ineq) (@classical.by_contradiction'.{1} (topological_space.{0} (has_lt.{0} linarith.ineq)) h0)  := sorry --non-trivial
lemma new_lemma_3109 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @is_domain.{1} (has_to_string.{1} Type) (@function.extfun_app.{3 2} (Type 1) ring.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 ring.{1}) (has_to_string.{1} Type))  := sorry --non-trivial
lemma new_lemma_3110 (h0 : ordered_comm_monoid (complete_distrib_lattice environment.implicit_infer_kind)) : has_exists_mul_of_le (complete_distrib_lattice environment.implicit_infer_kind) := sorry --non-trivial
lemma new_lemma_3111 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @rank_condition.{0} linarith.ineq (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) linarith.ineq)  := sorry --non-trivial
lemma new_lemma_3112 (h0 : topological_space (with_one (semiring empty))) : normal_space (with_one (semiring empty)) := sorry --non-trivial
lemma new_lemma_3113 (h2 : ring (has_inv char)) : rank_condition (has_inv char) := sorry --non-trivial
lemma new_lemma_3114 (h0 : topological_space (omega_complete_partial_order (option (option unsigned)))) : locally_compact_space (omega_complete_partial_order (option (option unsigned))) := sorry --non-trivial
lemma new_lemma_3115 (h0 : complete_lattice (parse_result (semiring empty))) : is_compactly_generated (parse_result (semiring empty)) := sorry --non-trivial
lemma new_lemma_3116 (h0 : fin has_zero.zero) : @is_principal_ideal_ring.{0} (ordered_comm_ring.{0} pos) (@matrix.vec_empty.{0} (ring.{0} (ordered_comm_ring.{0} pos)) h0)  := sorry --non-trivial
lemma new_lemma_3117 (h1 : add_group (add_left_cancel_monoid (has_nnnorm char))) : is_add_cyclic (add_left_cancel_monoid (has_nnnorm char)) := sorry --non-trivial
lemma new_lemma_3118 (h0 : not (topological_space (mul_zero_class congr_arg_kind) -> false)) : @discrete_topology.{0} (mul_zero_class.{0} congr_arg_kind) (@classical.by_contradiction'.{1} (topological_space.{0} (mul_zero_class.{0} congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_3119 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @discrete_topology.{0} (comm_monoid.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (comm_monoid.{0} empty))  := sorry --non-trivial
lemma new_lemma_3120 (h0 : topological_space (simple_graph (has_add linarith.comp))) : regular_space (simple_graph (has_add linarith.comp)) := sorry --non-trivial
lemma new_lemma_3121 (h0 : not (ring (has_ssubset to_additive.value_type) -> false)) : @strong_rank_condition.{0} (has_ssubset.{0} to_additive.value_type) (@classical.by_contradiction'.{1} (ring.{0} (has_ssubset.{0} to_additive.value_type)) h0)  := sorry --non-trivial
lemma new_lemma_3122 (h2 : topological_space (comm_ring (random_gen char))) : t0_space (comm_ring (random_gen char)) := sorry --non-trivial
lemma new_lemma_3123 (h0 : group (has_neg (has_to_string unsigned))) : group.fg (has_neg (has_to_string unsigned)) := sorry --non-trivial
lemma new_lemma_3124 (h0 : topological_space (has_union (semiring empty))) : path_connected_space (has_union (semiring empty)) := sorry --non-trivial
lemma new_lemma_3125 (h0 : functor.add_const (uniform_space (boolean_algebra.core linarith.comp)) pos) : @separated_space.{0} (boolean_algebra.core.{0} linarith.comp) (@functor.add_const.run.{0 0} (uniform_space.{0} (boolean_algebra.core.{0} linarith.comp)) pos h0)  := sorry --non-trivial
lemma new_lemma_3126 (h0 : functor.add_const (uniform_space (semigroup pos)) pos) : @complete_space.{0} (semigroup.{0} pos) (@functor.add_const.run.{0 0} (uniform_space.{0} (semigroup.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_3127 (h0 : topological_space (has_add (has_neg linarith.comp))) : loc_path_connected_space (has_add (has_neg linarith.comp)) := sorry --non-trivial
lemma new_lemma_3128 (h0 : list (has_norm (has_ssubset linarith.comp_source))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_3129 (h0 : functor.add_const (topological_space (has_neg ennreal)) num) : @totally_separated_space.{0} (has_neg.{0} ennreal) (@functor.add_const.run.{0 0} (topological_space.{0} (has_neg.{0} ennreal)) num h0)  := sorry --non-trivial
lemma new_lemma_3130 (h0 : topological_space (semiring (id num))) : t0_space (semiring (id num)) := sorry --non-trivial
lemma new_lemma_3131 (h0 : topological_space (distrib (metric_space linarith.comp_source))) : t0_space (distrib (metric_space linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_3132 (h0 : complete_lattice (has_star (semiring (semiring (semiring unsigned))))) : complete_lattice.is_Sup_finite_compact (has_star (semiring (semiring (semiring unsigned)))) := sorry --non-trivial
lemma new_lemma_3133 (h0 : group (ring (has_Inf Type))) : is_simple_group (ring (has_Inf Type)) := sorry --non-trivial
lemma new_lemma_3134 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_atomistic.{0} (semigroup.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (semigroup.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_3135 (h0 : functor.add_const (function.extfun Type uniform_space) environment.implicit_infer_kind) : @separated_space.{0} (normed_comm_ring.{0} linarith.comp) (@function.extfun_app.{2 1} Type uniform_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type uniform_space.{0}) environment.implicit_infer_kind h0) (normed_comm_ring.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_3136 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @complete_space.{0} (finset.{0} linarith.comp) (@function.extfun_app.{2 1} Type uniform_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 uniform_space.{0}) (finset.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_3137 (h0 : function.extfun Type ring) : @is_domain.{0} (denumerable.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type ring.{0} h0 (denumerable.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_3138 (h0 : function.extfun Type topological_space) : @irreducible_space.{0} (partial_order.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (partial_order.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_3139 (h0 : functor.add_const (add_monoid (has_neg_part pos)) pos) : @add_monoid.fg.{0} (has_neg_part.{0} pos) (@functor.add_const.run.{0 0} (add_monoid.{0} (has_neg_part.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_3140 (h0 : topological_space (with_one (with_bot (id (has_one linarith.comp))))) : normal_space (with_one (with_bot (id (has_one linarith.comp)))) := sorry --non-trivial
lemma new_lemma_3141 (h0 : functor.comp filter canonically_ordered_comm_semiring name) : countable_Inter_filter (functor.comp.run h0) := sorry --non-trivial
lemma new_lemma_3142 (h0 : congr_arg_kind -> congr_arg_kind -> Prop) : well_founded h0 := sorry --non-trivial
lemma new_lemma_3143 (h0 : functor.add_const (ordered_add_comm_monoid (add_cancel_monoid Type)) (ring pos)) : @archimedean.{1} (add_cancel_monoid.{1} Type) (@functor.add_const.run.{1 0} (ordered_add_comm_monoid.{1} (add_cancel_monoid.{1} Type)) (ring.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_3144 (h0 : topological_space (has_inv (measurable_space (has_top linarith.ineq)))) : locally_compact_space (has_inv (measurable_space (has_top linarith.ineq))) := sorry --non-trivial
lemma new_lemma_3145 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_compactly_generated.{0} (has_pos_part.{0} linarith.comp) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (has_pos_part.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_3146 (h1 : function.extfun Type complete_lattice) : @complete_lattice.is_Sup_finite_compact.{0} (filter.countable_filter_basis.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type complete_lattice.{0} h1 (filter.countable_filter_basis.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_3147 (h0 : topological_space (has_add (option (option (option pos))))) : locally_compact_space (has_add (option (option (option pos)))) := sorry --non-trivial
lemma new_lemma_3148 (h0 : group (finset (has_neg linarith.comp))) : is_simple_group (finset (has_neg linarith.comp)) := sorry --non-trivial
lemma new_lemma_3149 (h0 : ring (linear_ordered_semiring (random_gen (random_gen num)))) : strong_rank_condition (linear_ordered_semiring (random_gen (random_gen num))) := sorry --non-trivial
lemma new_lemma_3150 (h0 : ring (has_emptyc linarith.ineq)) : strong_rank_condition (has_emptyc linarith.ineq) := sorry --non-trivial
lemma new_lemma_3151 (h0 : functor.add_const (topological_space (semigroup linarith.comp)) (has_pos_part linarith.comp)) : @irreducible_space.{0} (semigroup.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (semigroup.{0} linarith.comp)) (has_pos_part.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_3152 (h0 : function.extfun (finset Type) (has_mem.mem (random_gen fun_info))) : @irreducible_space.{0} (random_gen.{0} fun_info) (@finset.pi.empty.{1 0} Type topological_space.{0} (random_gen.{0} fun_info) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (random_gen.{0} fun_info)) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_3153 (h0 : group (metric_space (semiring empty))) : normalizer_condition (metric_space (semiring empty)) := sorry --non-trivial
lemma new_lemma_3154 (h0 : uniform_space (complete_linear_order empty) -> Prop) : @separated_space.{0} (complete_linear_order.{0} empty) (@classical.epsilon.{1} (uniform_space.{0} (complete_linear_order.{0} empty)) (@nonempty_of_inhabited.{1} (uniform_space.{0} (complete_linear_order.{0} empty)) (@inhabited_uniform_space.{0} (complete_linear_order.{0} empty))) h0)  := sorry --non-trivial
lemma new_lemma_3155 (h0 : functor.add_const (function.extfun Type topological_space) (ring Type)) : @loc_path_connected_space.{0} (has_add.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type topological_space.{0}) (ring.{1} Type) h0) (has_add.{0} pos))  := sorry --non-trivial
lemma new_lemma_3156 (h0 : not (ring (distrib fun_info) -> false)) : @rank_condition.{0} (distrib.{0} fun_info) (@classical.by_contradiction'.{1} (ring.{0} (distrib.{0} fun_info)) h0)  := sorry --non-trivial
lemma new_lemma_3157 (h0 : function.extfun Type complete_lattice) : complete_lattice.is_Sup_finite_compact (measurable_space empty) := sorry --non-trivial
lemma new_lemma_3158 (h0 : function.extfun Type ring) : @rank_condition.{0} (semigroup.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type ring.{0} h0 (semigroup.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_3159 (h0 : functor.add_const (filter (ring name)) (has_add Type)) : filter.ne_bot (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_3160 (h0 : list (add_comm_monoid Type)) : palindrome h0 := sorry --non-trivial
lemma new_lemma_3161 (h0 : functor.add_const (complete_lattice (semigroup linarith.comp)) pos) : @is_compactly_generated.{0} (semigroup.{0} linarith.comp) (@functor.add_const.run.{0 0} (complete_lattice.{0} (semigroup.{0} linarith.comp)) pos h0)  := sorry --non-trivial
lemma new_lemma_3162 (h0 : complete_lattice (canonically_ordered_comm_semiring pos)) : complete_lattice.is_Sup_finite_compact (canonically_ordered_comm_semiring pos) := sorry --non-trivial
lemma new_lemma_3163 (h0 : group (add_cancel_monoid (has_add name))) : group.fg (add_cancel_monoid (has_add name)) := sorry --non-trivial
lemma new_lemma_3164 (h0 : function.extfun Type complete_lattice) : @is_compactly_generated.{0} (ordered_comm_monoid.{0} real) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (ordered_comm_monoid.{0} real))  := sorry --non-trivial
lemma new_lemma_3165 (h0 : functor.add_const (topological_space (measurable_space.dynkin_system empty)) empty) : @totally_disconnected_space.{0} (measurable_space.dynkin_system.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (measurable_space.dynkin_system.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_3166 (h0 : function.extfun Type ordered_add_comm_monoid) : @archimedean.{0} (option.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type ordered_add_comm_monoid.{0} h0 (option.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_3167 (h0 : function.extfun Type ring) : @is_domain.{0} (semigroup.{0} unsigned) (@function.extfun_app.{2 1} Type ring.{0} h0 (semigroup.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_3168 (h0 : topological_space (add_cancel_monoid (has_Inf name))) : discrete_topology (add_cancel_monoid (has_Inf name)) := sorry --non-trivial
lemma new_lemma_3169 (h0 : function.extfun Type (functor.add_const (prod znum znum))) : id_rel (functor.add_const.run (function.extfun_app h0 ennreal)) := sorry --non-trivial
lemma new_lemma_3170 (h0 : functor.add_const (topological_space (has_pos_part pos)) (has_neg (has_add (has_neg (ring (has_neg name)))))) : @t1_space.{0} (has_pos_part.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (has_pos_part.{0} pos)) (has_neg.{0} (has_add.{0} (has_neg.{0} (ring.{0} (has_neg.{0} name))))) h0)  := sorry --non-trivial
lemma new_lemma_3171 (h0 : function.extfun Type topological_space) : @preconnected_space.{0} (has_add.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_add.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_3172 (h0 : topological_space (has_inter congr_arg_kind)) : discrete_topology (has_inter congr_arg_kind) := sorry --non-trivial
lemma new_lemma_3173 (h0 : functor.comp topological_space cancel_monoid name) : @preirreducible_space.{0} (cancel_monoid.{0} name) (@functor.comp.run.{0 0 0} topological_space.{0} cancel_monoid.{0} name h0)  := sorry --non-trivial
lemma new_lemma_3174 (h0 : functor.add_const (uniform_space (boolean_algebra name)) name) : @separated_space.{0} (boolean_algebra.{0} name) (@functor.add_const.run.{0 0} (uniform_space.{0} (boolean_algebra.{0} name)) name h0)  := sorry --non-trivial
lemma new_lemma_3175 (h0 : functor.add_const Prop (has_top empty)) : functor.add_const.run h0 := sorry --non-trivial
lemma new_lemma_3176 (h0 : topological_space (with_zero (has_nnnorm linarith.ineq))) : path_connected_space (with_zero (has_nnnorm linarith.ineq)) := sorry --non-trivial
lemma new_lemma_3177 (h0 : functor.add_const (ring (normed_linear_ordered_group unsigned)) unsigned) : @rank_condition.{0} (normed_linear_ordered_group.{0} unsigned) (@functor.add_const.run.{0 0} (ring.{0} (normed_linear_ordered_group.{0} unsigned)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_3178 (h0 : function.extfun Type ring) : @strong_rank_condition.{0} (linear_ordered_comm_monoid_with_zero.{0} unsigned) (@function.extfun_app.{2 1} Type ring.{0} h0 (linear_ordered_comm_monoid_with_zero.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_3179 (h0 : functor.add_const (topological_space (add_cancel_monoid pos)) environment.implicit_infer_kind) : @preirreducible_space.{0} (add_cancel_monoid.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (add_cancel_monoid.{0} pos)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_3180 (h0 : group (random_gen (has_top linarith.comp_source))) : is_cyclic (random_gen (has_top linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_3181 (h0 : group (has_append (has_nnnorm linarith.comp_source))) : is_cyclic (has_append (has_nnnorm linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_3182 (h0 : not (has_mem.mem add_group has_emptyc.emptyc -> false)) : @is_add_cyclic.{0} (semiring.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type add_group.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) add_group.{0} (@classical.by_contradiction'.{0} (@has_mem.mem.{1 1} (Type → Type) (finset.{1} (Type → Type)) (@finset.has_mem.{1} (Type → Type)) add_group.{0} (@has_emptyc.emptyc.{1} (finset.{1} (Type → Type)) (@finset.has_emptyc.{1} (Type → Type)))) h0)) (semiring.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_3183 (h0 : topological_space (comm_group (has_to_string Type))) : t0_space (comm_group (has_to_string Type)) := sorry --non-trivial
lemma new_lemma_3184 (h0 : topological_space (has_nndist (has_pos_part pos))) : locally_compact_space (has_nndist (has_pos_part pos)) := sorry --non-trivial
lemma new_lemma_3185 (h0 : function.extfun Type topological_space) : @path_connected_space.{0} (has_one.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_one.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_3186 (h0 : add_monoid (ordered_comm_monoid (boolean_algebra.core (has_add (has_add pos))))) : add_monoid.fg (ordered_comm_monoid (boolean_algebra.core (has_add (has_add pos)))) := sorry --non-trivial
lemma new_lemma_3187 (h0 : topological_space (has_pos_part (has_add pos))) : preconnected_space (has_pos_part (has_add pos)) := sorry --non-trivial
lemma new_lemma_3188 (h0 : topological_space (has_to_string (has_add linarith.comp))) : path_connected_space (has_to_string (has_add linarith.comp)) := sorry --non-trivial
lemma new_lemma_3189 (h0 : function.extfun Type uniform_space) : @complete_space.{0} (has_Inf.{0} name) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (has_Inf.{0} name))  := sorry --non-trivial
lemma new_lemma_3190 (h0 : uniform_space (non_assoc_semiring (semiring num))) : complete_space (non_assoc_semiring (semiring num)) := sorry --non-trivial
lemma new_lemma_3191 (h0 : uniform_space (comm_group (has_neg_part linarith.comp))) : complete_space (comm_group (has_neg_part linarith.comp)) := sorry --non-trivial
lemma new_lemma_3192 (h0 : function.extfun Type topological_space) : @path_connected_space.{0} (has_norm.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_norm.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_3193 (h0 : filter (comm_group (comm_group environment.implicit_infer_kind))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_3194 (h0 : ring (ordered_comm_monoid (has_Inf (has_add linarith.comp)))) : is_domain (ordered_comm_monoid (has_Inf (has_add linarith.comp))) := sorry --non-trivial
lemma new_lemma_3195 (h0 : topological_space (has_nndist (has_to_string pos))) : loc_path_connected_space (has_nndist (has_to_string pos)) := sorry --non-trivial
lemma new_lemma_3196 (h0 : ring (has_append (has_compl char))) : is_domain (has_append (has_compl char)) := sorry --non-trivial
lemma new_lemma_3197 (h0 : filter (add_left_cancel_semigroup congr_arg_kind)) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_3198 (h0 : functor.add_const (topological_space (add_comm_monoid linarith.comp)) pos) : @sequential_space.{0} (add_comm_monoid.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (add_comm_monoid.{0} linarith.comp)) pos h0)  := sorry --non-trivial
lemma new_lemma_3199 (h0 : topological_space (uniform_space enat)) (h1 : preorder (uniform_space enat)) : order_topology (uniform_space enat) := sorry --non-trivial
lemma new_lemma_3200 (h0 : topological_space (random_gen (random_gen linarith.ineq))) : t0_space (random_gen (random_gen linarith.ineq)) := sorry --non-trivial
lemma new_lemma_3201 (h0 : complete_lattice (plift (has_top (has_top (has_top (semiring empty)))))) : is_compactly_generated (plift (has_top (has_top (has_top (semiring empty))))) := sorry --non-trivial
lemma new_lemma_3202 (h0 : function.extfun Type topological_space) : @locally_compact_space.{0} (linear_ordered_comm_group.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (linear_ordered_comm_group.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_3203 (h0 : functor.add_const (topological_space (canonically_linear_ordered_monoid pos)) pos) : @normal_space.{0} (canonically_linear_ordered_monoid.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (canonically_linear_ordered_monoid.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_3204 (h0 : functor.comp group cancel_monoid Type) : @normalizer_condition.{1} (cancel_monoid.{1} Type) (@functor.comp.run.{1 1 1} group.{1} cancel_monoid.{1} Type h0)  := sorry --non-trivial
lemma new_lemma_3205 (h1 : topological_space (with_one to_additive.value_type)) : path_connected_space (with_one to_additive.value_type) := sorry --non-trivial
lemma new_lemma_3206 (h0 : function.extfun Type group) : @is_simple_group.{0} (normed_comm_ring.{0} ennreal) (@function.extfun_app.{2 1} Type group.{0} h0 (normed_comm_ring.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_3207 (h0 : complete_lattice (normed_lattice_add_comm_group (has_bot (has_bot real)))) : is_atomistic (normed_lattice_add_comm_group (has_bot (has_bot real))) := sorry --non-trivial
lemma new_lemma_3208 (h0 : functor.add_const (list (has_inter empty)) num) : palindrome (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_3209 (h1 : complete_lattice (complete_semilattice_Sup linarith.comp_source)) : complete_lattice.is_Sup_finite_compact (complete_semilattice_Sup linarith.comp_source) := sorry --non-trivial
lemma new_lemma_3210 (h0 : functor.add_const (semiring (has_Sup congr_arg_kind)) congr_arg_kind) : @is_noetherian_ring.{0} (has_Sup.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (semiring.{0} (has_Sup.{0} congr_arg_kind)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_3211 (h0 : function.extfun nat fin) : @is_noetherian_ring.{0} (ordered_comm_monoid.{0} pos) (@matrix.vec_empty.{0} (semiring.{0} (ordered_comm_monoid.{0} pos)) (@matrix.vec_empty.{0} (fin (@has_zero.zero.{0} nat nat.has_zero)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero))))  := sorry --non-trivial
lemma new_lemma_3212 (h0 : has_mem.mem (complete_semilattice_Sup linarith.comp) has_emptyc.emptyc) : @is_add_cyclic.{0} (complete_semilattice_Sup.{0} linarith.comp) (@finset.pi.empty.{1 0} Type add_group.{0} (complete_semilattice_Sup.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_3213 (h1 : ring (has_nnnorm linarith.ineq)) : strong_rank_condition (has_nnnorm linarith.ineq) := sorry --non-trivial
lemma new_lemma_3214 (h0 : functor.add_const (topological_space (left_cancel_semigroup (option num))) empty) : @topological_space.separable_space.{0} (left_cancel_semigroup.{0} (option.{0} num)) (@functor.add_const.run.{0 0} (topological_space.{0} (left_cancel_semigroup.{0} (option.{0} num))) empty h0)  := sorry --non-trivial
lemma new_lemma_3215 (h0 : ring (has_nndist (has_to_string (comm_group unsigned)))) : is_principal_ideal_ring (has_nndist (has_to_string (comm_group unsigned))) := sorry --non-trivial
lemma new_lemma_3216 (h1 : topological_space (random_gen (has_nnnorm linarith.comp_source))) : t0_space (random_gen (has_nnnorm linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_3217 (h0 : monoid (generalized_boolean_algebra (has_pos_part linarith.comp))) : monoid.fg (generalized_boolean_algebra (has_pos_part linarith.comp)) := sorry --non-trivial
lemma new_lemma_3218 (h0 : topological_space (id (metric_space linarith.comp))) : totally_disconnected_space (id (metric_space linarith.comp)) := sorry --non-trivial
lemma new_lemma_3219 (h0 : group (boolean_algebra.core (option empty))) : normalizer_condition (boolean_algebra.core (option empty)) := sorry --non-trivial
lemma new_lemma_3220 (h0 : functor.add_const (semiring (has_add name)) Type) : @is_noetherian_ring.{0} (has_add.{0} name) (@functor.add_const.run.{0 1} (semiring.{0} (has_add.{0} name)) Type h0)  := sorry --non-trivial
lemma new_lemma_3221 (h0 : topological_space (ordered_cancel_add_comm_monoid (option ennreal))) : t1_space (ordered_cancel_add_comm_monoid (option ennreal)) := sorry --non-trivial
lemma new_lemma_3222 (h0 : functor.add_const (complete_lattice (ring pos)) environment.implicit_infer_kind) : @complete_lattice.is_Sup_finite_compact.{0} (ring.{0} pos) (@functor.add_const.run.{0 0} (complete_lattice.{0} (ring.{0} pos)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_3223 (h0 : topological_space (semigroup congr_arg_kind)) : path_connected_space (semigroup congr_arg_kind) := sorry --non-trivial
lemma new_lemma_3224 (h1 : topological_space (nondiscrete_normed_field linarith.ineq)) (h2 : preorder (nondiscrete_normed_field linarith.ineq)) : order_topology (nondiscrete_normed_field linarith.ineq) := sorry --non-trivial
lemma new_lemma_3225 (h0 : not (topological_space (plift unsigned) -> false)) : @t1_space.{1} (plift.{1} unsigned) (@classical.by_contradiction'.{2} (topological_space.{1} (plift.{1} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_3226 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : list.nodup (function.extfun_app (function.extfun_app h0 list) (simple_graph unsigned)) := sorry --non-trivial
lemma new_lemma_3227 (h0 : ring (has_neg_part (option (option pos)))) : is_domain (has_neg_part (option (option pos))) := sorry --non-trivial
lemma new_lemma_3228 (h0 : topological_space (has_union (semiring unsigned))) : normal_space (has_union (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_3229 (h1 : topological_space (has_ssubset (has_inv fun_info))) : path_connected_space (has_ssubset (has_inv fun_info)) := sorry --non-trivial
lemma new_lemma_3230 (h0 : functor.add_const (function.extfun Type finset) name) : finset.nonempty (function.extfun_app (functor.add_const.run h0) (add_cancel_monoid pos)) := sorry --non-trivial
lemma new_lemma_3231 (h0 : not (function.extfun Type topological_space -> false)) : @normal_space.{0} (metric_space.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (metric_space.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_3232 (h0 : boolean_algebra.core (finset pos) -> boolean_algebra.core (finset pos) -> Prop) : is_symm (boolean_algebra.core (finset pos)) h0 := sorry --non-trivial
lemma new_lemma_3233 (h0 : not (ring (distrib (mul_one_class (mul_one_class (random_gen (random_gen char))))) -> false)) : @strong_rank_condition.{0} (distrib.{0} (mul_one_class.{0} (mul_one_class.{0} (random_gen.{0} (random_gen.{0} char))))) (@classical.by_contradiction'.{1} (ring.{0} (distrib.{0} (mul_one_class.{0} (mul_one_class.{0} (random_gen.{0} (random_gen.{0} char)))))) h0)  := sorry --non-trivial
lemma new_lemma_3234 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @strong_rank_condition.{0} (normed_lattice_add_comm_group.{0} real) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (normed_lattice_add_comm_group.{0} real))  := sorry --non-trivial
lemma new_lemma_3235 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @discrete_topology.{0} (monoid.{0} ennreal) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (monoid.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_3236 (h0 : group (ordered_cancel_add_comm_monoid pos)) : is_cyclic (ordered_cancel_add_comm_monoid pos) := sorry --non-trivial
lemma new_lemma_3237 (h0 : complete_lattice (semiring (has_norm to_additive.value_type))) : is_atomistic (semiring (has_norm to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_3238 (h0 : has_mem.mem monoid has_emptyc.emptyc) : @monoid.fg.{0} linarith.comp (@function.extfun_app.{2 1} Type monoid.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) monoid.{0} h0) linarith.comp)  := sorry --non-trivial
lemma new_lemma_3239 (h1 : complete_lattice (has_append string_imp)) : complete_lattice.is_Sup_finite_compact (has_append string_imp) := sorry --non-trivial
lemma new_lemma_3240 (h0 : group (has_norm (random_gen (has_top to_additive.value_type)))) : group.fg (has_norm (random_gen (has_top to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_3241 (h0 : function.extfun Type (functor.add_const (topological_space ennreal))) : preirreducible_space ennreal := sorry --non-trivial
lemma new_lemma_3242 (h0 : complete_lattice (has_ssubset environment.projection_info)) : complete_lattice.is_Sup_finite_compact (has_ssubset environment.projection_info) := sorry --non-trivial
lemma new_lemma_3243 (h0 : ring (add_group (semiring num))) : is_principal_ideal_ring (add_group (semiring num)) := sorry --non-trivial
lemma new_lemma_3244 (h0 : function.extfun Type topological_space) : @normal_space.{0} (complete_distrib_lattice.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (complete_distrib_lattice.{0} pos))  := sorry --non-trivial
lemma new_lemma_3245 (h0 : functor.add_const (list (has_nndist Type)) (mul_zero_class Type)) : palindrome (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_3246 (h0 h1 : multiset (add_comm_semigroup (add_comm_semigroup linarith.ineq))) : multiset.subset h0 h1 := sorry --non-trivial
lemma new_lemma_3247 (h0 : function.extfun Type topological_space) : @preconnected_space.{0} (has_inter.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_inter.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_3248 (h0 : has_lt (normed_field (normed_field char))) : no_max_order (normed_field (normed_field char)) := sorry --non-trivial
lemma new_lemma_3249 (h0 : filter (metric_space (semiring (has_top num)))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_3250 (h0 : functor.add_const (complete_lattice (add_comm_monoid num)) unsigned) : @is_compactly_generated.{0} (add_comm_monoid.{0} num) (@functor.add_const.run.{0 0} (complete_lattice.{0} (add_comm_monoid.{0} num)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_3251 (h0 : function.extfun Type complete_lattice) : @is_atomistic.{0} (@id.{2} Type num) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (@id.{2} Type num))  := sorry --non-trivial
lemma new_lemma_3252 (h0 : topological_space (has_norm unsigned)) : totally_separated_space (has_norm unsigned) := sorry --non-trivial
lemma new_lemma_3253 (h0 : function.extfun Type topological_space) : @topological_space.separable_space.{0} (mul_zero_class.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (mul_zero_class.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_3254 (h0 : topological_space (group_with_zero num)) : topological_space.separable_space (group_with_zero num) := sorry --non-trivial
lemma new_lemma_3255 (h0 : functor.add_const (group (add_cancel_monoid pos)) name) : @normalizer_condition.{0} (add_cancel_monoid.{0} pos) (@functor.add_const.run.{0 0} (group.{0} (add_cancel_monoid.{0} pos)) name h0)  := sorry --non-trivial
lemma new_lemma_3256 (h0 : topological_space (pseudo_metric_space num)) : preconnected_space (pseudo_metric_space num) := sorry --non-trivial
lemma new_lemma_3257 (h0 : ring (distrib_lattice (random_gen linarith.ineq))) : rank_condition (distrib_lattice (random_gen linarith.ineq)) := sorry --non-trivial
lemma new_lemma_3258 (h0 : ring (has_zero (ring Type))) : is_domain (has_zero (ring Type)) := sorry --non-trivial
lemma new_lemma_3259 (h0 : filter (denumerable (random_gen char))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_3260 (h0 : topological_space (canonically_ordered_monoid (has_add name))) : loc_path_connected_space (canonically_ordered_monoid (has_add name)) := sorry --non-trivial
lemma new_lemma_3261 (h0 : uniform_space (normed_comm_ring environment.implicit_infer_kind)) : complete_space (normed_comm_ring environment.implicit_infer_kind) := sorry --non-trivial
lemma new_lemma_3262 (h0 : function.extfun Type (functor.add_const (topological_space (has_add linarith.comp)))) : @path_connected_space.{0} (has_add.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (has_add.{0} linarith.comp)) pos (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (topological_space.{0} (has_add.{0} linarith.comp))) h0 pos))  := sorry --non-trivial
lemma new_lemma_3263 (h0 : functor.add_const (topological_space (cancel_monoid empty)) ennreal) : @discrete_topology.{0} (cancel_monoid.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (cancel_monoid.{0} empty)) ennreal h0)  := sorry --non-trivial
lemma new_lemma_3264 (h0 : uniform_space (pseudo_metric_space (option (option (option (option (option unsigned))))))) : complete_space (pseudo_metric_space (option (option (option (option (option unsigned)))))) := sorry --non-trivial
lemma new_lemma_3265 (h0 : not (function.extfun (Type 1) topological_space -> false)) : @t0_space.{1} (has_well_founded.{1} to_additive.value_type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@classical.by_contradiction'.{3} (function.extfun.{3 2} (Type 1) topological_space.{1}) h0) (has_well_founded.{1} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_3266 (h0 : add_group (boolean_algebra.core (semigroup name))) : is_add_cyclic (boolean_algebra.core (semigroup name)) := sorry --non-trivial
lemma new_lemma_3267 (h0 : function.extfun Type topological_space) : @sequential_space.{0} (sub_neg_monoid.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (sub_neg_monoid.{0} pos))  := sorry --non-trivial
lemma new_lemma_3268 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @filter.Liminf.{0} Prop (@complete_lattice.to_conditionally_complete_lattice.{0} Prop Prop.complete_lattice) (@function.extfun_app.{2 1} Type filter.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 filter.{0}) Prop)  := sorry --non-trivial
lemma new_lemma_3269 (h0 : uniform_space (random_gen (has_norm (has_norm (has_norm fun_info))))) : complete_space (random_gen (has_norm (has_norm (has_norm fun_info)))) := sorry --non-trivial
lemma new_lemma_3270 (h0 : topological_space (semigroup ennreal)) : path_connected_space (semigroup ennreal) := sorry --non-trivial
lemma new_lemma_3271 (h0 : group (finset (has_to_string pos))) : is_cyclic (finset (has_to_string pos)) := sorry --non-trivial
lemma new_lemma_3272 (h0 : group (has_add (has_nnnorm char))) : is_cyclic (has_add (has_nnnorm char)) := sorry --non-trivial
lemma new_lemma_3273 (h0 : functor.add_const (topological_space (finset Type)) (has_neg pos)) : @loc_path_connected_space.{1} (finset.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (finset.{1} Type)) (has_neg.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_3274 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_compactly_generated.{0} (has_top.{0} fun_info) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (has_top.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_3275 (h0 : functor.add_const (function.extfun (Type 1) group) Type) : @normalizer_condition.{1} (has_pos_part.{1} Type) (@function.extfun_app.{3 2} (Type 1) group.{1} (@functor.add_const.run.{2 1} (function.extfun.{3 2} (Type 1) group.{1}) Type h0) (has_pos_part.{1} Type))  := sorry --non-trivial
lemma new_lemma_3276 (h0 : not (function.extfun Type complete_lattice -> false)) : @is_atomistic.{0} (semiring.{0} unsigned) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type complete_lattice.{0}) h0) (semiring.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_3277 (h0 : functor.add_const (group (monoid unsigned)) num) : @normalizer_condition.{0} (monoid.{0} unsigned) (@functor.add_const.run.{0 0} (group.{0} (monoid.{0} unsigned)) num h0)  := sorry --non-trivial
lemma new_lemma_3278 (h0 : add_monoid (has_nndist (semigroup (comm_group name)))) : add_monoid.fg (has_nndist (semigroup (comm_group name))) := sorry --non-trivial
lemma new_lemma_3279 (h0 : group name) : normalizer_condition name := sorry --non-trivial
lemma new_lemma_3280 (h0 : prod (option (semiring congr_arg_kind)) (option (semiring congr_arg_kind))) : id_rel h0 := sorry --non-trivial
lemma new_lemma_3281 (h0 : topological_space (mul_zero_class ennreal)) : path_connected_space (mul_zero_class ennreal) := sorry --non-trivial
lemma new_lemma_3282 (h0 : uniform_space (nondiscrete_normed_field linarith.ineq)) : complete_space (nondiscrete_normed_field linarith.ineq) := sorry --non-trivial
lemma new_lemma_3283 (h0 : functor.add_const (topological_space (linear_order unsigned)) (option empty)) : @irreducible_space.{0} (linear_order.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (linear_order.{0} unsigned)) (option.{0} empty) h0)  := sorry --non-trivial
lemma new_lemma_3284 (h0 : finset (monoid_with_zero unsigned)) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_3285 (h0 : semiring (has_Inf (finset (has_pos_part (finset linarith.comp))))) : is_noetherian_ring (has_Inf (finset (has_pos_part (finset linarith.comp)))) := sorry --non-trivial
lemma new_lemma_3286 (h0 : not (semiring (random_gen num) -> false)) : @is_noetherian_ring.{0} (random_gen.{0} num) (@classical.by_contradiction'.{1} (semiring.{0} (random_gen.{0} num)) h0)  := sorry --non-trivial
lemma new_lemma_3287 (h0 : prod (boolean_algebra.core empty) (boolean_algebra.core empty)) : id_rel h0 := sorry --non-trivial
lemma new_lemma_3288 (h0 : not (uniform_space (normed_group (random_gen linarith.comp_source)) -> false)) : @complete_space.{0} (normed_group.{0} (random_gen.{0} linarith.comp_source)) (@classical.by_contradiction'.{1} (uniform_space.{0} (normed_group.{0} (random_gen.{0} linarith.comp_source))) h0)  := sorry --non-trivial
lemma new_lemma_3289 (h0 : ring (normed_group (has_top to_additive.value_type))) : rank_condition (normed_group (has_top to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_3290 (h0 : topological_space (comm_group name)) : t0_space (comm_group name) := sorry --non-trivial
lemma new_lemma_3291 (h0 : topological_space (has_nndist ennreal)) : regular_space (has_nndist ennreal) := sorry --non-trivial
lemma new_lemma_3292 (h0 : topological_space (has_div linarith.comp_source)) : path_connected_space (has_div linarith.comp_source) := sorry --non-trivial
lemma new_lemma_3293 (h0 : functor.add_const (finset (finset real)) name) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_3294 (h0 : function.extfun Type (functor.comp topological_space cancel_monoid)) : @preirreducible_space.{0} (cancel_monoid.{0} pos) (@functor.comp.run.{0 0 0} topological_space.{0} cancel_monoid.{0} pos (@function.extfun_app.{2 1} Type (functor.comp.{0 0 0} topological_space.{0} cancel_monoid.{0}) h0 pos))  := sorry --non-trivial
lemma new_lemma_3295 (h0 : functor.add_const (finset (mul_zero_class name)) (mul_zero_class Type)) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_3296 (h0 : topological_space (metric_space (semiring (semiring (semiring (semiring empty)))))) : totally_separated_space (metric_space (semiring (semiring (semiring (semiring empty))))) := sorry --non-trivial
lemma new_lemma_3297 (h0 : uniform_space (has_norm (has_inv (has_inv (has_inv linarith.ineq))))) : complete_space (has_norm (has_inv (has_inv (has_inv linarith.ineq)))) := sorry --non-trivial
lemma new_lemma_3298 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @normalizer_condition.{0} (complete_semilattice_Sup.{0} unsigned) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (complete_semilattice_Sup.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_3299 (h0 : function.extfun Type topological_space) : @totally_separated_space.{0} (add_comm_monoid.{0} (option.{0} ennreal)) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (add_comm_monoid.{0} (option.{0} ennreal)))  := sorry --non-trivial
lemma new_lemma_3300 (h0 : functor.add_const (group (boolean_algebra.core pos)) Type) : @is_cyclic.{0} (boolean_algebra.core.{0} pos) (@functor.add_const.run.{0 1} (group.{0} (boolean_algebra.core.{0} pos)) Type h0)  := sorry --non-trivial
lemma new_lemma_3301 (h0 : topological_space (complete_distrib_lattice linarith.comp)) : preirreducible_space (complete_distrib_lattice linarith.comp) := sorry --non-trivial
lemma new_lemma_3302 (h0 : list (linear_ordered_field unsigned)) : palindrome h0 := sorry --non-trivial
lemma new_lemma_3303 (h0 : functor.add_const (topological_space (boolean_algebra name)) (cancel_monoid name)) : @preirreducible_space.{0} (boolean_algebra.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (boolean_algebra.{0} name)) (cancel_monoid.{0} name) h0)  := sorry --non-trivial
lemma new_lemma_3304 (h0 : function.extfun Type (functor.comp group has_nndist)) : @is_simple_group.{0} (has_nndist.{0} pos) (@functor.comp.run.{0 0 0} group.{0} has_nndist.{0} pos (@function.extfun_app.{2 1} Type (functor.comp.{0 0 0} group.{0} has_nndist.{0}) h0 pos))  := sorry --non-trivial
lemma new_lemma_3305 (h0 : functor.add_const (group (ordered_comm_ring Type)) Type) : @is_cyclic.{1} (ordered_comm_ring.{1} Type) (@functor.add_const.run.{1 1} (group.{1} (ordered_comm_ring.{1} Type)) Type h0)  := sorry --non-trivial
lemma new_lemma_3306 (h0 : semiring (has_edist (option (option (option empty))))) : is_noetherian_ring (has_edist (option (option (option empty)))) := sorry --non-trivial
lemma new_lemma_3307 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @topological_space.separable_space.{0} (normed_comm_ring.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (normed_comm_ring.{0} pos))  := sorry --non-trivial
lemma new_lemma_3308 (h0 : ring (metric_space (semiring (has_norm linarith.comp)))) : is_domain (metric_space (semiring (has_norm linarith.comp))) := sorry --non-trivial
lemma new_lemma_3309 (h0 : function.extfun Type group) : @group.fg.{0} (has_one.{0} (semiring.{0} (semiring.{0} num))) (@function.extfun_app.{2 1} Type group.{0} h0 (has_one.{0} (semiring.{0} (semiring.{0} num))))  := sorry --non-trivial
lemma new_lemma_3310 (h0 : group (has_ssubset (has_nnnorm char))) : is_cyclic (has_ssubset (has_nnnorm char)) := sorry --non-trivial
lemma new_lemma_3311 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @loc_path_connected_space.{0} (simple_graph.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (simple_graph.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_3312 (h1 : string_imp -> string_imp -> Prop) : is_trans string_imp h1 := sorry --non-trivial
lemma new_lemma_3313 (h0 : add_group (left_cancel_semigroup (semiring (semiring (semiring num))))) : is_add_cyclic (left_cancel_semigroup (semiring (semiring (semiring num)))) := sorry --non-trivial
lemma new_lemma_3314 (h0 : monoid (normed_group (semiring (semiring (semiring unsigned))))) : monoid.fg (normed_group (semiring (semiring (semiring unsigned)))) := sorry --non-trivial
lemma new_lemma_3315 (h0 : topological_space (linear_ordered_comm_group (option ennreal))) : t1_space (linear_ordered_comm_group (option ennreal)) := sorry --non-trivial
lemma new_lemma_3316 (h0 : functor.add_const (ring (has_add name)) (has_neg Type)) : @strong_rank_condition.{0} (has_add.{0} name) (@functor.add_const.run.{0 1} (ring.{0} (has_add.{0} name)) (has_neg.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_3317 (h0 : monoid (complete_distrib_lattice (has_sub environment.implicit_infer_kind))) : monoid.fg (complete_distrib_lattice (has_sub environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_3318 (h3 : set (char -> char)) : set.separates_points h3 := sorry --non-trivial
lemma new_lemma_3319 (h0 : has_lt (semi_normed_comm_ring environment.projection_info)) : no_max_order (semi_normed_comm_ring environment.projection_info) := sorry --non-trivial
lemma new_lemma_3320 (h3 : topological_space (semi_normed_comm_ring string.iterator_imp)) : totally_disconnected_space (semi_normed_comm_ring string.iterator_imp) := sorry --non-trivial
lemma new_lemma_3321 (h0 : not (uniform_space (add_group complex) -> false)) : @complete_space.{0} (add_group.{0} complex) (@classical.by_contradiction'.{1} (uniform_space.{0} (add_group.{0} complex)) h0)  := sorry --non-trivial
lemma new_lemma_3322 (h0 : topological_space (comm_group (add_cancel_monoid linarith.comp))) : t0_space (comm_group (add_cancel_monoid linarith.comp)) := sorry --non-trivial
lemma new_lemma_3323 (h0 : function.extfun Type uniform_space) : @complete_space.{0} (has_edist.{0} (option.{0} empty)) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (has_edist.{0} (option.{0} empty)))  := sorry --non-trivial
lemma new_lemma_3324 (h0 : function.extfun Type add_group) : @is_add_cyclic.{0} (has_pos_part.{0} name) (@function.extfun_app.{2 1} Type add_group.{0} h0 (has_pos_part.{0} name))  := sorry --non-trivial
lemma new_lemma_3325 (h0 : group (id string_imp)) : group.fg (id string_imp) := sorry --non-trivial
lemma new_lemma_3326 (h0 : functor.add_const (topological_space (mul_zero_class congr_arg_kind)) empty) : @locally_compact_space.{0} (mul_zero_class.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (mul_zero_class.{0} congr_arg_kind)) empty h0)  := sorry --non-trivial
lemma new_lemma_3327 (h0 : function.extfun Type topological_space) : @totally_disconnected_space.{0} (has_emptyc.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_emptyc.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_3328 (h0 : has_neg (mul_one_class linarith.comp_source)) (h1 : measurable_space (mul_one_class linarith.comp_source)) : has_measurable_neg (mul_one_class linarith.comp_source) := sorry --non-trivial
lemma new_lemma_3329 (h0 : add_monoid (has_pos_part (has_Inf linarith.comp))) : add_monoid.fg (has_pos_part (has_Inf linarith.comp)) := sorry --non-trivial
lemma new_lemma_3330 (h0 : topological_space (random_gen (random_gen (random_gen congr_arg_kind)))) : irreducible_space (random_gen (random_gen (random_gen congr_arg_kind))) := sorry --non-trivial
lemma new_lemma_3331 (h0 : topological_space (finset (has_add (finset (has_add linarith.comp))))) : locally_compact_space (finset (has_add (finset (has_add linarith.comp)))) := sorry --non-trivial
lemma new_lemma_3332 (h0 : functor.add_const (ring environment.implicit_infer_kind) environment.implicit_infer_kind) : @is_domain.{0} environment.implicit_infer_kind (@functor.add_const.run.{0 0} (ring.{0} environment.implicit_infer_kind) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_3333 (h0 : ring auto.case_option) : is_domain auto.case_option := sorry --non-trivial
lemma new_lemma_3334 (h0 : function.extfun (Type 1) group) : @is_cyclic.{1} (has_add.{1} Type) (@function.extfun_app.{3 2} (Type 1) group.{1} h0 (has_add.{1} Type))  := sorry --non-trivial
lemma new_lemma_3335 (h1 : topological_space (non_unital_non_assoc_semiring linarith.comp_source)) : path_connected_space (non_unital_non_assoc_semiring linarith.comp_source) := sorry --non-trivial
lemma new_lemma_3336 (h0 : not (group (semiring linarith.ineq) -> false)) : @group.fg.{0} (semiring.{0} linarith.ineq) (@classical.by_contradiction'.{1} (group.{0} (semiring.{0} linarith.ineq)) h0)  := sorry --non-trivial
lemma new_lemma_3337 (h0 : function.extfun Type uniform_space) : @complete_space.{0} (cancel_monoid.{0} linarith.comp) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (cancel_monoid.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_3338 (h1 : topological_space (has_top to_additive.value_type)) : t0_space (has_top to_additive.value_type) := sorry --non-trivial
lemma new_lemma_3339 (h0 : functor.comp topological_space has_to_string pos) : @sequential_space.{0} (has_to_string.{0} pos) (@functor.comp.run.{0 0 0} topological_space.{0} has_to_string.{0} pos (@functor.comp.run.{0 0 0} topological_space.{0} has_to_string.{0} pos (@functor.comp.run.{0 0 0} topological_space.{0} has_to_string.{0} pos (@functor.comp.run.{0 0 0} topological_space.{0} has_to_string.{0} pos (@functor.comp.run.{0 0 0} topological_space.{0} has_to_string.{0} pos (@functor.comp.run.{0 0 0} topological_space.{0} has_to_string.{0} pos (@functor.comp.run.{0 0 0} topological_space.{0} has_to_string.{0} pos (@functor.comp.run.{0 0 0} topological_space.{0} has_to_string.{0} pos (@functor.comp.run.{0 0 0} topological_space.{0} has_to_string.{0} pos (@functor.comp.run.{0 0 0} topological_space.{0} has_to_string.{0} pos (@functor.comp.run.{0 0 0} topological_space.{0} has_to_string.{0} pos (@functor.comp.run.{0 0 0} topological_space.{0} has_to_string.{0} pos (@functor.comp.run.{0 0 0} topological_space.{0} has_to_string.{0} pos (@functor.comp.run.{0 0 0} topological_space.{0} has_to_string.{0} pos (@functor.comp.run.{0 0 0} topological_space.{0} has_to_string.{0} pos h0)))))))))))))))  := sorry --non-trivial
lemma new_lemma_3340 (h0 : not (list (mul_zero_class unsigned) -> false)) : list.nodup (classical.by_contradiction' h0) := sorry --non-trivial
lemma new_lemma_3341 (h0 : fin has_zero.zero) : @normalizer_condition.{0} (normed_lattice_add_comm_group.{0} real) (@function.extfun_app.{2 1} Type group.{0} (@matrix.vec_empty.{1} (function.extfun.{2 1} Type group.{0}) h0) (normed_lattice_add_comm_group.{0} real))  := sorry --non-trivial
lemma new_lemma_3342 (h0 : topological_space (has_zero Type)) : totally_separated_space (has_zero Type) := sorry --non-trivial
lemma new_lemma_3343 (h0 : has_inter (monoid_with_zero congr_arg_kind) -> has_inter (monoid_with_zero congr_arg_kind) -> Prop) : is_symm (has_inter (monoid_with_zero congr_arg_kind)) h0 := sorry --non-trivial
lemma new_lemma_3344 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_cyclic.{0} (linear_ordered_add_comm_group.{0} num) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (linear_ordered_add_comm_group.{0} num))  := sorry --non-trivial
lemma new_lemma_3345 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @normalizer_condition.{0} (denumerable.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (denumerable.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_3346 (h0 : has_mem.mem (with_bot num) has_emptyc.emptyc) : @totally_disconnected_space.{0} (with_bot.{0} num) (@finset.pi.empty.{1 0} Type topological_space.{0} (with_bot.{0} num) h0)  := sorry --non-trivial
lemma new_lemma_3347 (h0 : function.extfun Type uniform_space) : @separated_space.{0} (measurable_space.{0} linarith.comp) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (measurable_space.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_3348 (h0 : group (add_group (has_norm num))) : is_cyclic (add_group (has_norm num)) := sorry --non-trivial
lemma new_lemma_3349 (h2 : complete_lattice (has_append linarith.comp_source)) : complete_lattice.is_Sup_finite_compact (has_append linarith.comp_source) := sorry --non-trivial
lemma new_lemma_3350 (h0 : uniform_space (simple_graph unsigned)) : complete_space (simple_graph unsigned) := sorry --non-trivial
lemma new_lemma_3351 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @sequential_space.{0} (ordered_comm_monoid.{0} real) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (ordered_comm_monoid.{0} real))  := sorry --non-trivial
lemma new_lemma_3352 (h0 : functor.add_const (cancel_comm_monoid_with_zero (has_add Type)) pos) : @unique_factorization_monoid.{1} (has_add.{1} Type) (@functor.add_const.run.{1 0} (cancel_comm_monoid_with_zero.{1} (has_add.{1} Type)) pos h0)  := sorry --non-trivial
lemma new_lemma_3353 (h0 : has_mem.mem topological_space has_emptyc.emptyc) : @totally_separated_space.{0} (with_one.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) topological_space.{0} h0) (with_one.{0} empty))  := sorry --non-trivial
lemma new_lemma_3354 (h0 : complete_lattice (has_norm (with_bot string_imp))) : complete_lattice.is_Sup_finite_compact (has_norm (with_bot string_imp)) := sorry --non-trivial
lemma new_lemma_3355 (h0 : function.extfun Type group) : @is_cyclic.{0} (comm_monoid.{0} unsigned) (@function.extfun_app.{2 1} Type group.{0} h0 (comm_monoid.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_3356 (h0 : topological_space (add_group (semiring linarith.comp))) : normal_space (add_group (semiring linarith.comp)) := sorry --non-trivial
lemma new_lemma_3357 (h0 : functor.add_const (topological_space (comm_group pos)) name) : @topological_space.separable_space.{0} (comm_group.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (comm_group.{0} pos)) name h0)  := sorry --non-trivial
lemma new_lemma_3358 (h0 : function.extfun Type topological_space) : @irreducible_space.{0} (canonically_ordered_comm_semiring.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (canonically_ordered_comm_semiring.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_3359 (h0 : has_mem.mem fin has_emptyc.emptyc) : @normalizer_condition.{0} (complete_semilattice_Sup.{0} num) (@matrix.vec_empty.{0} (group.{0} (complete_semilattice_Sup.{0} num)) (@function.extfun_app.{1 1} nat fin (@finset.pi.empty.{1 0} (nat → Type) (function.extfun.{1 1} nat) fin h0) (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_3360 (h0 : group (has_inter congr_arg_kind)) : is_simple_group (has_inter congr_arg_kind) := sorry --non-trivial
lemma new_lemma_3361 (h0 : measurable_space (has_compl enat)) (h1 : filter (has_compl enat)) : filter.is_measurably_generated h1 := sorry --non-trivial
lemma new_lemma_3362 (h0 : list (semi_normed_comm_ring (random_gen (has_ssubset fun_info)))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_3363 (h0 : functor.add_const (add_monoid (semiring unsigned)) unsigned) : @add_monoid.fg.{0} (semiring.{0} unsigned) (@functor.add_const.run.{0 0} (add_monoid.{0} (semiring.{0} unsigned)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_3364 (h0 : function.extfun (Type 1) topological_space) : @normal_space.{1} (semigroup.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} h0 (semigroup.{1} Type))  := sorry --non-trivial
lemma new_lemma_3365 (h0 : topological_space (dlist (has_top linarith.ineq))) : t0_space (dlist (has_top linarith.ineq)) := sorry --non-trivial
lemma new_lemma_3366 (h0 : add_group (has_Inf (ordered_ring pos))) : is_add_cyclic (has_Inf (ordered_ring pos)) := sorry --non-trivial
lemma new_lemma_3367 (h0 : function.extfun Type group) : @group.fg.{0} (boolean_algebra.{0} name) (@function.extfun_app.{2 1} Type group.{0} h0 (boolean_algebra.{0} name))  := sorry --non-trivial
lemma new_lemma_3368 (h0 : functor.add_const (topological_space (mul_zero_class ennreal)) Type) : @normal_space.{0} (mul_zero_class.{0} ennreal) (@functor.add_const.run.{0 1} (topological_space.{0} (mul_zero_class.{0} ennreal)) Type h0)  := sorry --non-trivial
lemma new_lemma_3369 (h0 : ordered_add_comm_monoid (ordered_comm_ring (has_add (has_Inf Type)))) : archimedean (ordered_comm_ring (has_add (has_Inf Type))) := sorry --non-trivial
lemma new_lemma_3370 (h0 : functor.add_const (uniform_space (semigroup pos)) environment.implicit_infer_kind) : @complete_space.{0} (semigroup.{0} pos) (@functor.add_const.run.{0 0} (uniform_space.{0} (semigroup.{0} pos)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_3371 (h0 : topological_space (linear_ordered_comm_monoid_with_zero (option (option unsigned)))) : totally_separated_space (linear_ordered_comm_monoid_with_zero (option (option unsigned))) := sorry --non-trivial
lemma new_lemma_3372 (h0 : topological_space (add_cancel_monoid (has_neg_part name))) : t1_space (add_cancel_monoid (has_neg_part name)) := sorry --non-trivial
lemma new_lemma_3373 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @irreducible_space.{0} (has_mul.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_mul.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_3374 (h0 : topological_space (cancel_monoid (semiring (semiring unsigned)))) : discrete_topology (cancel_monoid (semiring (semiring unsigned))) := sorry --non-trivial
lemma new_lemma_3375 (h0 : function.extfun Type (functor.add_const (cancel_comm_monoid_with_zero linarith.comp))) : @unique_factorization_monoid.{0} linarith.comp (@functor.add_const.run.{0 0} (cancel_comm_monoid_with_zero.{0} linarith.comp) linarith.comp (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (cancel_comm_monoid_with_zero.{0} linarith.comp)) h0 linarith.comp))  := sorry --non-trivial
lemma new_lemma_3376 (h0 : group (add_cancel_monoid (add_comm_monoid environment.implicit_infer_kind))) : group.fg (add_cancel_monoid (add_comm_monoid environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_3377 (h0 : filter (mul_zero_class (finset Type))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_3378 (h0 : ordered_comm_monoid (mul_zero_class (finset Type))) : has_exists_mul_of_le (mul_zero_class (finset Type)) := sorry --non-trivial
lemma new_lemma_3379 (h0 : topological_space (omega_complete_partial_order (option empty))) : totally_disconnected_space (omega_complete_partial_order (option empty)) := sorry --non-trivial
lemma new_lemma_3380 (h0 : monoid (has_top fun_info)) : monoid.fg (has_top fun_info) := sorry --non-trivial
lemma new_lemma_3381 (h0 : function.extfun nat fin) : @is_simple_group.{1} (semigroup.{1} Type) (@matrix.vec_empty.{1} (group.{1} (semigroup.{1} Type)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_3382 (h0 : function.extfun Type topological_space) : @normal_space.{0} (generalized_boolean_algebra.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (generalized_boolean_algebra.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_3383 (h0 : not (complete_lattice (random_gen linarith.comp_source) -> false)) : @complete_lattice.is_Sup_finite_compact.{0} (random_gen.{0} linarith.comp_source) (@classical.by_contradiction'.{1} (complete_lattice.{0} (random_gen.{0} linarith.comp_source)) h0)  := sorry --non-trivial
lemma new_lemma_3384 (h0 : uniform_space (add_cancel_monoid (finset (has_add linarith.comp)))) : complete_space (add_cancel_monoid (finset (has_add linarith.comp))) := sorry --non-trivial
lemma new_lemma_3385 (h0 : function.extfun Type topological_space) : @normal_space.{0} (ordered_cancel_add_comm_monoid.{0} ennreal) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (ordered_cancel_add_comm_monoid.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_3386 (h0 : functor.add_const (uniform_space (ordered_comm_ring pos)) name) : @complete_space.{0} (ordered_comm_ring.{0} pos) (@functor.add_const.run.{0 0} (uniform_space.{0} (ordered_comm_ring.{0} pos)) name h0)  := sorry --non-trivial
lemma new_lemma_3387 (h0 : functor.add_const (ordered_comm_monoid (ring Type)) (finset pos)) : @has_exists_mul_of_le.{1} (ring.{1} Type) (@functor.add_const.run.{1 0} (ordered_comm_monoid.{1} (ring.{1} Type)) (finset.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_3388 (h0 : functor.add_const (function.extfun Type group) pos) : @normalizer_condition.{0} (has_zero.{0} pos) (@function.extfun_app.{2 1} Type group.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type group.{0}) pos h0) (has_zero.{0} pos))  := sorry --non-trivial
lemma new_lemma_3389 (h0 : function.extfun Type topological_space) : @preirreducible_space.{0} linarith.comp (@function.extfun_app.{2 1} Type topological_space.{0} h0 linarith.comp)  := sorry --non-trivial
lemma new_lemma_3390 (h0 : functor.add_const (ring (add_comm_monoid linarith.comp)) environment.implicit_infer_kind) : @rank_condition.{0} (add_comm_monoid.{0} linarith.comp) (@functor.add_const.run.{0 0} (ring.{0} (add_comm_monoid.{0} linarith.comp)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_3391 (h0 : functor.add_const (topological_space (has_pos_part linarith.comp)) name) : @preirreducible_space.{0} (has_pos_part.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (has_pos_part.{0} linarith.comp)) name h0)  := sorry --non-trivial
lemma new_lemma_3392 (h0 : topological_space (ring (has_pos_part (has_pos_part linarith.comp)))) : discrete_topology (ring (has_pos_part (has_pos_part linarith.comp))) := sorry --non-trivial
lemma new_lemma_3393 (h1 : topological_space (fintype (random_gen (random_gen char)))) : path_connected_space (fintype (random_gen (random_gen char))) := sorry --non-trivial
lemma new_lemma_3394 (h0 : function.extfun Type filter) : filter.ne_bot (function.extfun_app h0 (linear_ordered_semiring unsigned)) := sorry --non-trivial
lemma new_lemma_3395 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_add_cyclic.{0} (complete_semilattice_Sup.{0} unsigned) (@function.extfun_app.{2 1} Type add_group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 add_group.{0}) (complete_semilattice_Sup.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_3396 (h0 : functor.comp complete_lattice comm_group ennreal) : @is_atomistic.{0} (comm_group.{0} ennreal) (@functor.add_const.run.{0 0} (complete_lattice.{0} (comm_group.{0} ennreal)) unsigned (@functor.comp.run.{0 0 0} complete_lattice.{0} comm_group.{0} ennreal h0))  := sorry --non-trivial
lemma new_lemma_3397 (h0 : function.extfun Type topological_space) : @path_connected_space.{0} (bin_tree.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (bin_tree.{0} num))  := sorry --non-trivial
lemma new_lemma_3398 (h0 : function.extfun Type (functor.add_const (function.extfun Type uniform_space))) : @separated_space.{0} (semigroup.{0} (finset.{0} linarith.comp)) (@function.extfun_app.{2 1} Type uniform_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type uniform_space.{0}) linarith.comp (@function.extfun_app.{2 2} Type (functor.add_const.{1 0} (function.extfun.{2 1} Type uniform_space.{0})) h0 linarith.comp)) (semigroup.{0} (finset.{0} linarith.comp)))  := sorry --non-trivial
lemma new_lemma_3399 (h0 : function.extfun Type (functor.add_const Prop)) : functor.add_const.run (function.extfun_app h0 (has_norm empty)) := sorry --non-trivial
lemma new_lemma_3400 (h0 : list (add_cancel_comm_monoid congr_arg_kind)) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_3401 (h0 : group (has_one linarith.comp)) : normalizer_condition (has_one linarith.comp) := sorry --non-trivial
lemma new_lemma_3402 (h0 : functor.add_const (topological_space (normed_comm_ring ennreal)) num) : @normal_space.{0} (normed_comm_ring.{0} ennreal) (@functor.add_const.run.{0 0} (topological_space.{0} (normed_comm_ring.{0} ennreal)) num h0)  := sorry --non-trivial
lemma new_lemma_3403 (h0 : group (add_comm_monoid (has_neg name))) : normalizer_condition (add_comm_monoid (has_neg name)) := sorry --non-trivial
lemma new_lemma_3404 (h0 : list (distrib_lattice (random_gen linarith.ineq))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_3405 (h0 : has_pos_part (has_add real) -> has_pos_part (has_add real) -> Prop) : transitive h0 := sorry --non-trivial
lemma new_lemma_3406 (h0 : topological_space (canonically_ordered_monoid (has_Inf real))) : irreducible_space (canonically_ordered_monoid (has_Inf real)) := sorry --non-trivial
lemma new_lemma_3407 (h0 : ordered_add_comm_monoid (ordered_comm_group unsigned)) : archimedean (ordered_comm_group unsigned) := sorry --non-trivial
lemma new_lemma_3408 (h0 : topological_space (group_with_zero (option (option ennreal)))) : t1_space (group_with_zero (option (option ennreal))) := sorry --non-trivial
lemma new_lemma_3409 (h0 : add_monoid (semiring linarith.comp)) : add_monoid.fg (semiring linarith.comp) := sorry --non-trivial
lemma new_lemma_3410 (h0 : uniform_space (has_one (has_top (semiring fun_info)))) : separated_space (has_one (has_top (semiring fun_info))) := sorry --non-trivial
lemma new_lemma_3411 (h0 : ring (cancel_monoid (has_to_string num))) : is_domain (cancel_monoid (has_to_string num)) := sorry --non-trivial
lemma new_lemma_3412 (h0 : filter (option congr_arg_kind)) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_3413 (h0 : functor.add_const (topological_space (ordered_ring unsigned)) congr_arg_kind) : @preirreducible_space.{0} (ordered_ring.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (ordered_ring.{0} unsigned)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_3414 (h0 : function.extfun Type topological_space) : @preirreducible_space.{0} (has_bot.{0} real) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_bot.{0} real))  := sorry --non-trivial
lemma new_lemma_3415 (h1 : group (measurable_space (random_gen linarith.ineq))) : group.fg (measurable_space (random_gen linarith.ineq)) := sorry --non-trivial
lemma new_lemma_3416 (h0 : not (topological_space (plift num) -> false)) : @totally_disconnected_space.{1} (plift.{1} num) (@classical.by_contradiction'.{2} (topological_space.{1} (plift.{1} num)) h0)  := sorry --non-trivial
lemma new_lemma_3417 (h0 : complete_lattice (measure_theory.measure_space empty)) : is_atomistic (measure_theory.measure_space empty) := sorry --non-trivial
lemma new_lemma_3418 (h0 : functor.add_const (complete_lattice (canonically_ordered_comm_semiring unsigned)) Type) : @is_compactly_generated.{0} (canonically_ordered_comm_semiring.{0} unsigned) (@functor.add_const.run.{0 1} (complete_lattice.{0} (canonically_ordered_comm_semiring.{0} unsigned)) Type h0)  := sorry --non-trivial
lemma new_lemma_3419 (h0 : not (ring (with_one unsigned) -> false)) : @strong_rank_condition.{0} (with_one.{0} unsigned) (@classical.by_contradiction'.{1} (ring.{0} (with_one.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_3420 (h0 : fin has_zero.zero) : @t1_space.{0} (has_add.{0} real) (@matrix.vec_empty.{0} (topological_space.{0} (has_add.{0} real)) h0)  := sorry --non-trivial
lemma new_lemma_3421 (h0 : functor.add_const (topological_space (has_neg_part environment.implicit_infer_kind)) name) : @loc_path_connected_space.{0} (has_neg_part.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (has_neg_part.{0} environment.implicit_infer_kind)) name h0)  := sorry --non-trivial
lemma new_lemma_3422 (h0 : function.extfun Type topological_space) : @preirreducible_space.{0} (semigroup.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (semigroup.{0} name))  := sorry --non-trivial
lemma new_lemma_3423 (h0 : list (semigroup (semiring (semiring (semiring unsigned))))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_3424 (h0 : complete_lattice (linear_ordered_field (option (option (option ennreal))))) : is_compactly_generated (linear_ordered_field (option (option (option ennreal)))) := sorry --non-trivial
lemma new_lemma_3425 (h0 : topological_space (has_add (has_to_string name))) : loc_path_connected_space (has_add (has_to_string name)) := sorry --non-trivial
lemma new_lemma_3426 (h2 : function.extfun (finset Type) (has_mem.mem (measurable_space linarith.comp_source))) : @path_connected_space.{0} (measurable_space.{0} linarith.comp_source) (@finset.pi.empty.{1 0} Type topological_space.{0} (measurable_space.{0} linarith.comp_source) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (measurable_space.{0} linarith.comp_source)) h2 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_3427 (h0 : functor.add_const (topological_space (has_nndist linarith.comp)) (ring (ring Type))) : @topological_space.separable_space.{0} (has_nndist.{0} linarith.comp) (@functor.add_const.run.{0 1} (topological_space.{0} (has_nndist.{0} linarith.comp)) (ring.{1} (ring.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_3428 (h1 : not (ring (has_emptyc congr_arg_kind) -> false)) : @is_domain.{0} (has_emptyc.{0} congr_arg_kind) (@classical.by_contradiction'.{1} (ring.{0} (has_emptyc.{0} congr_arg_kind)) h1)  := sorry --non-trivial
lemma new_lemma_3429 (h0 : group (denumerable (has_inv (has_inv fun_info)))) : is_cyclic (denumerable (has_inv (has_inv fun_info))) := sorry --non-trivial
lemma new_lemma_3430 (h0 : uniform_space (with_zero (has_inv linarith.ineq))) : complete_space (with_zero (has_inv linarith.ineq)) := sorry --non-trivial
lemma new_lemma_3431 (h0 : functor.add_const (function.extfun Type topological_space) name) : @topological_space.separable_space.{0} (ordered_comm_monoid.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) name h0) (ordered_comm_monoid.{0} pos))  := sorry --non-trivial
lemma new_lemma_3432 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @add_monoid.fg.{0} (sub_neg_monoid.{0} real) (@function.extfun_app.{2 1} Type add_monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 add_monoid.{0}) (sub_neg_monoid.{0} real))  := sorry --non-trivial
lemma new_lemma_3433 (h0 : topological_space (distrib string_imp)) : path_connected_space (distrib string_imp) := sorry --non-trivial
lemma new_lemma_3434 (h0 : functor.add_const (topological_space (boolean_algebra environment.implicit_infer_kind)) name) : @t1_space.{0} (boolean_algebra.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (boolean_algebra.{0} environment.implicit_infer_kind)) name h0)  := sorry --non-trivial
lemma new_lemma_3435 (h0 : complete_lattice (free_add_monoid (option unsigned))) : is_compactly_generated (free_add_monoid (option unsigned)) := sorry --non-trivial
lemma new_lemma_3436 (h0 : functor.add_const (ring auto.case_option) (option (option (option num)))) : @is_domain.{0} auto.case_option (@functor.add_const.run.{0 0} (ring.{0} auto.case_option) (option.{0} (option.{0} (option.{0} num))) h0)  := sorry --non-trivial
lemma new_lemma_3437 (h0 : ring (simple_graph rat)) : strong_rank_condition (simple_graph rat) := sorry --non-trivial
lemma new_lemma_3438 (h0 : topological_space (mul_zero_class (with_zero name))) : path_connected_space (mul_zero_class (with_zero name)) := sorry --non-trivial
lemma new_lemma_3439 (h0 : function.extfun Type (functor.add_const (topological_space znum))) : @irreducible_space.{0} znum (@functor.add_const.run.{0 0} (topological_space.{0} znum) num (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (topological_space.{0} znum)) h0 num))  := sorry --non-trivial
lemma new_lemma_3440 (h0 : topological_space (comm_group (has_add name))) : discrete_topology (comm_group (has_add name)) := sorry --non-trivial
lemma new_lemma_3441 (h1 : set (mul_one_class std_gen)) : set.finite h1 := sorry --non-trivial
lemma new_lemma_3442 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @locally_compact_space.{0} (has_add.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_add.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_3443 (h2 : ring (distrib reducibility_hints)) : strong_rank_condition (distrib reducibility_hints) := sorry --non-trivial
lemma new_lemma_3444 (h0 : functor.add_const (function.extfun (Type 1) ring) linarith.comp) : @is_principal_ideal_ring.{1} (boolean_algebra.{1} Type) (@function.extfun_app.{3 2} (Type 1) ring.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) ring.{1}) linarith.comp h0) (boolean_algebra.{1} Type))  := sorry --non-trivial
lemma new_lemma_3445 (h0 : topological_space (canonically_ordered_comm_semiring (has_Inf linarith.comp))) : path_connected_space (canonically_ordered_comm_semiring (has_Inf linarith.comp)) := sorry --non-trivial
lemma new_lemma_3446 (h0 : uniform_space (has_le environment.projection_info)) : complete_space (has_le environment.projection_info) := sorry --non-trivial
lemma new_lemma_3447 (h0 : not (function.extfun Type group -> false)) : @group.fg.{0} (with_one.{0} fun_info) (@function.extfun_app.{2 1} Type group.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type group.{0}) h0) (with_one.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_3448 (h0 : not (group (measurable_space congr_arg_kind) -> false)) : @is_cyclic.{0} (measurable_space.{0} congr_arg_kind) (@classical.by_contradiction'.{1} (group.{0} (measurable_space.{0} congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_3449 (h0 : has_mem.mem (has_top (semiring empty)) has_emptyc.emptyc) : @normal_space.{0} (has_top.{0} (semiring.{0} empty)) (@finset.pi.empty.{1 0} Type topological_space.{0} (has_top.{0} (semiring.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_3450 (h0 : functor.add_const (topological_space (simple_graph linarith.comp)) pos) : @regular_space.{0} (simple_graph.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (simple_graph.{0} linarith.comp)) pos h0)  := sorry --non-trivial
lemma new_lemma_3451 (h2 : add_comm_group (normed_group (has_ssubset to_additive.value_type))) (h3 : has_norm (normed_group (has_ssubset to_additive.value_type))) : semi_normed_group.core (normed_group (has_ssubset to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_3452 (h0 : ring (linear_ordered_comm_ring unsigned)) : is_domain (linear_ordered_comm_ring unsigned) := sorry --non-trivial
lemma new_lemma_3453 (h0 : group (with_bot (random_gen to_additive.value_type))) : group.fg (with_bot (random_gen to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_3454 (h0 : topological_space (has_nndist (option unsigned))) : path_connected_space (has_nndist (option unsigned)) := sorry --non-trivial
lemma new_lemma_3455 (h0 : std_gen -> std_gen -> bool) : is_dec_refl h0 := sorry --non-trivial
lemma new_lemma_3456 (h0 : topological_space (boolean_algebra.core (has_add (has_add name)))) : locally_compact_space (boolean_algebra.core (has_add (has_add name))) := sorry --non-trivial
lemma new_lemma_3457 (h0 : complete_lattice (ordered_comm_ring (option (option congr_arg_kind)))) : is_atomistic (ordered_comm_ring (option (option congr_arg_kind))) := sorry --non-trivial
lemma new_lemma_3458 (h0 : functor.add_const (topological_space (has_pos_part real)) (has_add Type)) : @preconnected_space.{0} (has_pos_part.{0} real) (@functor.add_const.run.{0 1} (topological_space.{0} (has_pos_part.{0} real)) (has_add.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_3459 (h0 : function.extfun Type topological_space) : @locally_compact_space.{0} (simple_graph.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (simple_graph.{0} empty))  := sorry --non-trivial
lemma new_lemma_3460 (h0 : functor.add_const (topological_space (option unsigned)) empty) : @discrete_topology.{0} (option.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (option.{0} unsigned)) empty h0)  := sorry --non-trivial
lemma new_lemma_3461 (h0 : list (dlist (has_ssubset string_imp))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_3462 (h0 : functor.add_const (topological_space (has_add Type)) name) : @locally_compact_space.{1} (has_add.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (has_add.{1} Type)) name h0)  := sorry --non-trivial
lemma new_lemma_3463 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @monoid.fg.{0} (random_gen.{0} linarith.ineq) (@function.extfun_app.{2 1} Type monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 monoid.{0}) (random_gen.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_3464 (h0 : functor.add_const (topological_space (normed_comm_ring name)) environment.implicit_infer_kind) : @locally_compact_space.{0} (normed_comm_ring.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (normed_comm_ring.{0} name)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_3465 (h0 : function.extfun Type (functor.add_const (topological_space (has_star empty)))) : @totally_disconnected_space.{0} (has_star.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (has_star.{0} empty)) empty (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (topological_space.{0} (has_star.{0} empty))) h0 empty))  := sorry --non-trivial
lemma new_lemma_3466 (h0 : functor.add_const (ring (complete_distrib_lattice pos)) name) : @strong_rank_condition.{0} (complete_distrib_lattice.{0} pos) (@functor.add_const.run.{0 0} (ring.{0} (complete_distrib_lattice.{0} pos)) name h0)  := sorry --non-trivial
lemma new_lemma_3467 (h0 : functor.add_const (ring (has_neg_part name)) name) : @rank_condition.{0} (has_neg_part.{0} name) (@functor.add_const.run.{0 0} (ring.{0} (has_neg_part.{0} name)) name h0)  := sorry --non-trivial
lemma new_lemma_3468 (h0 : complete_lattice (has_nndist (has_to_string name))) : is_atomistic (has_nndist (has_to_string name)) := sorry --non-trivial
lemma new_lemma_3469 (h0 : not (complete_lattice (complete_semilattice_Sup empty) -> false)) : @is_compactly_generated.{0} (complete_semilattice_Sup.{0} empty) (@classical.by_contradiction'.{1} (complete_lattice.{0} (complete_semilattice_Sup.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_3470 (h0 : not (group (semi_normed_comm_ring char) -> false)) : @is_cyclic.{0} (semi_normed_comm_ring.{0} char) (@classical.by_contradiction'.{1} (group.{0} (semi_normed_comm_ring.{0} char)) h0)  := sorry --non-trivial
lemma new_lemma_3471 (h0 : functor.add_const (ring (mul_zero_class congr_arg_kind)) num) : @rank_condition.{0} (mul_zero_class.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (ring.{0} (mul_zero_class.{0} congr_arg_kind)) num h0)  := sorry --non-trivial
lemma new_lemma_3472 (h0 : function.extfun (finset ((Type -> Type) -> Type 1)) (has_mem.mem (function.extfun Type))) : @locally_compact_space.{0} (with_one.{0} fun_info) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) (@finset.pi.empty.{2 1} ((Type → Type) → Type 1) (function.extfun.{2 2} (Type → Type)) (function.extfun.{2 1} Type) (@function.extfun_app.{3 0} (finset.{2} ((Type → Type) → Type 1)) (@has_mem.mem.{2 2} ((Type → Type) → Type 1) (finset.{2} ((Type → Type) → Type 1)) (@finset.has_mem.{2} ((Type → Type) → Type 1)) (function.extfun.{2 1} Type)) h0 (@has_emptyc.emptyc.{2} (finset.{2} ((Type → Type) → Type 1)) (@finset.has_emptyc.{2} ((Type → Type) → Type 1))))) topological_space.{0}) (with_one.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_3473 (h0 : complete_lattice (random_gen (mul_one_class linarith.ineq))) : is_compactly_generated (random_gen (mul_one_class linarith.ineq)) := sorry --non-trivial
lemma new_lemma_3474 (h0 : add_monoid (complete_distrib_lattice (option empty))) : add_monoid.fg (complete_distrib_lattice (option empty)) := sorry --non-trivial
lemma new_lemma_3475 (h0 : add_group (has_Sup (option (option (option (option empty)))))) : is_add_cyclic (has_Sup (option (option (option (option empty))))) := sorry --non-trivial
lemma new_lemma_3476 (h0 : functor.add_const (uniform_space (add_comm_monoid environment.implicit_infer_kind)) Type) : @separated_space.{0} (add_comm_monoid.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 1} (uniform_space.{0} (add_comm_monoid.{0} environment.implicit_infer_kind)) Type h0)  := sorry --non-trivial
lemma new_lemma_3477 (h0 : topological_space (complete_linear_order ennreal)) : loc_path_connected_space (complete_linear_order ennreal) := sorry --non-trivial
lemma new_lemma_3478 (h0 : filter (boolean_algebra (has_to_string name))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_3479 (h0 : filter (boolean_algebra (comm_group unsigned))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_3480 (h0 : ordered_comm_monoid (has_nndist environment.implicit_infer_kind)) : has_exists_mul_of_le (has_nndist environment.implicit_infer_kind) := sorry --non-trivial
lemma new_lemma_3481 (h0 : topological_space (add_cancel_monoid (comm_group Type))) : t1_space (add_cancel_monoid (comm_group Type)) := sorry --non-trivial
lemma new_lemma_3482 (h0 : functor.add_const (function.extfun (Type 1) uniform_space) pos) : @separated_space.{1} (has_neg.{1} Type) (@function.extfun_app.{3 2} (Type 1) uniform_space.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) uniform_space.{1}) pos h0) (has_neg.{1} Type))  := sorry --non-trivial
lemma new_lemma_3483 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @add_monoid.fg.{0} (finset.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type add_monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 add_monoid.{0}) (finset.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_3484 (h1 : not (uniform_space (random_gen string_imp) -> false)) : @complete_space.{0} (random_gen.{0} string_imp) (@classical.by_contradiction'.{1} (uniform_space.{0} (random_gen.{0} string_imp)) h1)  := sorry --non-trivial
lemma new_lemma_3485 (h0 : not (ring (plift num) -> false)) : @strong_rank_condition.{1} (plift.{1} num) (@classical.by_contradiction'.{2} (ring.{1} (plift.{1} num)) h0)  := sorry --non-trivial
lemma new_lemma_3486 (h0 : group (complete_distrib_lattice pos)) : is_cyclic (complete_distrib_lattice pos) := sorry --non-trivial
lemma new_lemma_3487 (h1 : topological_space (comm_ring string_imp)) : totally_disconnected_space (comm_ring string_imp) := sorry --non-trivial
lemma new_lemma_3488 (h0 : functor.add_const (ordered_comm_monoid (order_dual linarith.comp)) Type) : @has_exists_mul_of_le.{0} (order_dual.{0} linarith.comp) (@functor.add_const.run.{0 1} (ordered_comm_monoid.{0} (order_dual.{0} linarith.comp)) Type h0)  := sorry --non-trivial
lemma new_lemma_3489 (h0 : topological_space (normed_comm_ring (has_to_string num))) : loc_path_connected_space (normed_comm_ring (has_to_string num)) := sorry --non-trivial
lemma new_lemma_3490 (h0 : function.extfun Type add_group) : @is_add_cyclic.{0} (has_nnnorm.{0} linarith.ineq) (@function.extfun_app.{2 1} Type add_group.{0} h0 (has_nnnorm.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_3491 (h0 : function.extfun Type ring) : @is_principal_ideal_ring.{0} (linear_ordered_cancel_comm_monoid.{0} unsigned) (@function.extfun_app.{2 1} Type ring.{0} h0 (linear_ordered_cancel_comm_monoid.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_3492 (h0 : monoid (ordered_comm_monoid (has_Inf real))) : monoid.fg (ordered_comm_monoid (has_Inf real)) := sorry --non-trivial
lemma new_lemma_3493 (h0 : topological_space (has_top (with_bot (with_bot (with_bot (with_bot string_imp)))))) : totally_separated_space (has_top (with_bot (with_bot (with_bot (with_bot string_imp))))) := sorry --non-trivial
lemma new_lemma_3494 (h0 : filter (id (id congr_arg_kind))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_3495 (h0 : topological_space (has_add (has_Inf (has_add Type)))) : preconnected_space (has_add (has_Inf (has_add Type))) := sorry --non-trivial
lemma new_lemma_3496 (h0 : group (has_nndist (option name))) : normalizer_condition (has_nndist (option name)) := sorry --non-trivial
lemma new_lemma_3497 (h0 : topological_space (has_top char)) : locally_compact_space (has_top char) := sorry --non-trivial
lemma new_lemma_3498 (h0 : functor.add_const (filter (has_add pos)) pos) : countable_Inter_filter (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_3499 (h0 : add_group (with_bot (has_top congr_arg_kind))) : is_add_cyclic (with_bot (has_top congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_3500 (h0 : topological_space (preorder (option (option empty)))) : topological_space.separable_space (preorder (option (option empty))) := sorry --non-trivial
lemma new_lemma_3501 (h0 : complete_lattice (semiring (has_norm (has_norm linarith.comp)))) : is_atomistic (semiring (has_norm (has_norm linarith.comp))) := sorry --non-trivial
lemma new_lemma_3502 (h0 : topological_space (with_bot (dlist fun_info))) : irreducible_space (with_bot (dlist fun_info)) := sorry --non-trivial
lemma new_lemma_3503 (h0 : topological_space (boolean_algebra (has_neg environment.implicit_infer_kind))) : irreducible_space (boolean_algebra (has_neg environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_3504 (h0 : topological_space (add_cancel_monoid (semigroup (has_to_string environment.implicit_infer_kind)))) : path_connected_space (add_cancel_monoid (semigroup (has_to_string environment.implicit_infer_kind))) := sorry --non-trivial
lemma new_lemma_3505 (h0 : complete_lattice (has_sub unsigned)) : is_atomistic (has_sub unsigned) := sorry --non-trivial
lemma new_lemma_3506 (h0 : functor.comp ring boolean_algebra name) : @is_principal_ideal_ring.{0} (boolean_algebra.{0} name) (@functor.comp.run.{0 0 0} ring.{0} boolean_algebra.{0} name h0)  := sorry --non-trivial
lemma new_lemma_3507 (h0 : functor.add_const (group (has_to_string Type)) environment.implicit_infer_kind) : @is_cyclic.{1} (has_to_string.{1} Type) (@functor.add_const.run.{1 0} (group.{1} (has_to_string.{1} Type)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_3508 (h0 : topological_space (has_top to_additive.value_type)) : irreducible_space (has_top to_additive.value_type) := sorry --non-trivial
lemma new_lemma_3509 (h0 : topological_space (has_inv (random_gen to_additive.value_type))) : t0_space (has_inv (random_gen to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_3510 (h0 : function.extfun (Type 1) topological_space) : @regular_space.{1} (simple_graph.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} h0 (simple_graph.{1} Type))  := sorry --non-trivial
lemma new_lemma_3511 (h0 : function.extfun Type group) : @group.fg.{0} (comm_ring.{0} (has_nnnorm.{0} linarith.comp_source)) (@function.extfun_app.{2 1} Type group.{0} h0 (comm_ring.{0} (has_nnnorm.{0} linarith.comp_source)))  := sorry --non-trivial
lemma new_lemma_3512 (h0 : complete_lattice (has_union num)) : complete_lattice.is_Sup_finite_compact (has_union num) := sorry --non-trivial
lemma new_lemma_3513 (h0 : ring (add_cancel_monoid (comm_group name))) : strong_rank_condition (add_cancel_monoid (comm_group name)) := sorry --non-trivial
lemma new_lemma_3514 (h0 : functor.add_const (monoid (add_comm_monoid Type)) Type) : @monoid.fg.{1} (add_comm_monoid.{1} Type) (@functor.add_const.run.{1 1} (monoid.{1} (add_comm_monoid.{1} Type)) Type h0)  := sorry --non-trivial
lemma new_lemma_3515 (h0 : functor.add_const (topological_space (has_nndist Type)) environment.implicit_infer_kind) : @totally_separated_space.{1} (has_nndist.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (has_nndist.{1} Type)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_3516 (h0 : complete_lattice (normed_comm_ring (has_add (finset linarith.comp)))) : complete_lattice.is_Sup_finite_compact (normed_comm_ring (has_add (finset linarith.comp))) := sorry --non-trivial
lemma new_lemma_3517 (h0 : functor.add_const (topological_space (has_star congr_arg_kind)) (semiring empty)) : @locally_compact_space.{0} (has_star.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (has_star.{0} congr_arg_kind)) (semiring.{0} empty) h0)  := sorry --non-trivial
lemma new_lemma_3518 (h0 : functor.add_const (topological_space (boolean_algebra Type)) pos) (h1 : set (boolean_algebra Type)) : @is_seq_compact.{1} (boolean_algebra.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (boolean_algebra.{1} Type)) pos h0) h1  := sorry --non-trivial
lemma new_lemma_3519 (h0 : topological_space (option (option (option (option (option (option ennreal))))))) : preirreducible_space (option (option (option (option (option (option ennreal)))))) := sorry --non-trivial
lemma new_lemma_3520 (h0 : topological_space (is_R_or_C empty)) : loc_path_connected_space (is_R_or_C empty) := sorry --non-trivial
lemma new_lemma_3521 (h0 : topological_space (canonically_ordered_monoid (has_Inf Type))) : sequential_space (canonically_ordered_monoid (has_Inf Type)) := sorry --non-trivial
lemma new_lemma_3522 (h0 : function.extfun Type topological_space) : @locally_compact_space.{0} (cancel_monoid.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (cancel_monoid.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_3523 (h0 : ring (has_append (has_ssubset linarith.comp_source))) : is_domain (has_append (has_ssubset linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_3524 (h0 : topological_space (has_inner empty (option unsigned))) : locally_compact_space (has_inner empty (option unsigned)) := sorry --non-trivial
lemma new_lemma_3525 (h0 : functor.add_const (function.extfun Type cancel_comm_monoid_with_zero) linarith.comp) : @unique_factorization_monoid.{0} (has_pos_part.{0} linarith.comp) (@function.extfun_app.{2 1} Type cancel_comm_monoid_with_zero.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type cancel_comm_monoid_with_zero.{0}) linarith.comp h0) (has_pos_part.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_3526 (h0 : group (encodable (has_nnnorm (random_gen (random_gen (random_gen (has_inv string_imp))))))) : group.fg (encodable (has_nnnorm (random_gen (random_gen (random_gen (has_inv string_imp)))))) := sorry --non-trivial
lemma new_lemma_3527 (h0 : list (ring (finset Type))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_3528 (h0 : functor.add_const (topological_space (has_nndist name)) name) : @t1_space.{0} (has_nndist.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (has_nndist.{0} name)) name h0)  := sorry --non-trivial
lemma new_lemma_3529 (h0 : add_group (boolean_algebra (has_neg linarith.comp))) : is_add_cyclic (boolean_algebra (has_neg linarith.comp)) := sorry --non-trivial
lemma new_lemma_3530 (h0 : topological_space (semigroup (has_neg linarith.comp))) : regular_space (semigroup (has_neg linarith.comp)) := sorry --non-trivial
lemma new_lemma_3531 (h0 : complete_lattice (has_to_string (comm_group (comm_group (comm_group (comm_group unsigned)))))) : is_compactly_generated (has_to_string (comm_group (comm_group (comm_group (comm_group unsigned))))) := sorry --non-trivial
lemma new_lemma_3532 (h0 : functor.add_const (ring (is_R_or_C empty)) empty) : @rank_condition.{0} (is_R_or_C.{0} empty) (@functor.add_const.run.{0 0} (ring.{0} (is_R_or_C.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_3533 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_principal_ideal_ring.{0} (ring.{0} name) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (ring.{0} name))  := sorry --non-trivial
lemma new_lemma_3534 (h0 : topological_space (group_with_zero (option (option num)))) : path_connected_space (group_with_zero (option (option num))) := sorry --non-trivial
lemma new_lemma_3535 (h0 : functor.add_const (list (complete_distrib_lattice linarith.comp)) (has_add (has_add name))) : list.nodup (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_3536 (h0 : group (has_add Type)) : is_simple_group (has_add Type) := sorry --non-trivial
lemma new_lemma_3537 (h0 : topological_space (has_neg (has_add Type))) : topological_space.separable_space (has_neg (has_add Type)) := sorry --non-trivial
lemma new_lemma_3538 (h0 : functor.add_const (topological_space (boolean_algebra pos)) (has_neg linarith.comp)) : @discrete_topology.{0} (boolean_algebra.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (boolean_algebra.{0} pos)) (has_neg.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_3539 (h0 : ring (with_one (semiring congr_arg_kind))) : is_domain (with_one (semiring congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_3540 (h0 : topological_space (has_nndist (boolean_algebra name))) : t1_space (has_nndist (boolean_algebra name)) := sorry --non-trivial
lemma new_lemma_3541 (h0 : topological_space (boolean_algebra.core (has_nndist ennreal))) : totally_separated_space (boolean_algebra.core (has_nndist ennreal)) := sorry --non-trivial
lemma new_lemma_3542 (h0 : topological_space (boolean_algebra.core (mul_zero_class unsigned))) : sequential_space (boolean_algebra.core (mul_zero_class unsigned)) := sorry --non-trivial
lemma new_lemma_3543 (h0 : ring (add_cancel_monoid (has_neg_part pos))) : is_domain (add_cancel_monoid (has_neg_part pos)) := sorry --non-trivial
lemma new_lemma_3544 (h0 : topological_space (has_add environment.implicit_infer_kind)) : regular_space (has_add environment.implicit_infer_kind) := sorry --non-trivial
lemma new_lemma_3545 (h0 : functor.add_const (ring (has_nndist pos)) linarith.comp) : @strong_rank_condition.{0} (has_nndist.{0} pos) (@functor.add_const.run.{0 0} (ring.{0} (has_nndist.{0} pos)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_3546 (h0 : topological_space (mul_zero_class (has_add name))) : path_connected_space (mul_zero_class (has_add name)) := sorry --non-trivial
lemma new_lemma_3547 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @preirreducible_space.{0} (canonically_ordered_comm_semiring.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (canonically_ordered_comm_semiring.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_3548 (h0 : uniform_space (topological_space reducibility_hints)) : complete_space (topological_space reducibility_hints) := sorry --non-trivial
lemma new_lemma_3549 (h0 : topological_space (has_nndist (finset name))) : totally_disconnected_space (has_nndist (finset name)) := sorry --non-trivial
lemma new_lemma_3550 (h0 : functor.add_const (topological_space (cancel_monoid Type)) environment.implicit_infer_kind) : @regular_space.{1} (cancel_monoid.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (cancel_monoid.{1} Type)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_3551 (h0 : group (add_cancel_monoid (linear_ordered_add_comm_monoid_with_top linarith.comp))) : normalizer_condition (add_cancel_monoid (linear_ordered_add_comm_monoid_with_top linarith.comp)) := sorry --non-trivial
lemma new_lemma_3552 (h0 : ring (has_add (option (option (option ennreal))))) : is_domain (has_add (option (option (option ennreal)))) := sorry --non-trivial
lemma new_lemma_3553 (h0 : uniform_space (complete_semilattice_Sup (has_inv linarith.comp_source))) : complete_space (complete_semilattice_Sup (has_inv linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_3554 (h0 : topological_space (has_norm (has_top (random_gen (has_top linarith.comp_source))))) : irreducible_space (has_norm (has_top (random_gen (has_top linarith.comp_source)))) := sorry --non-trivial
lemma new_lemma_3555 (h0 : list (cancel_monoid empty)) : palindrome h0 := sorry --non-trivial
lemma new_lemma_3556 (h0 : topological_space (has_top (has_norm (random_gen num)))) : discrete_topology (has_top (has_norm (random_gen num))) := sorry --non-trivial
lemma new_lemma_3557 (h0 : filter (has_add (comm_group unsigned))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_3558 (h0 : finset (generalized_boolean_algebra (ring name))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_3559 (h0 : list (finset (finset (finset (finset pos))))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_3560 (h0 : function.extfun Type ring) : @strong_rank_condition.{0} (has_ssubset.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type ring.{0} h0 (has_ssubset.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_3561 (h0 : not (uniform_space (has_compl linarith.ineq) -> false)) : @complete_space.{0} (has_compl.{0} linarith.ineq) (@classical.by_contradiction'.{1} (uniform_space.{0} (has_compl.{0} linarith.ineq)) h0)  := sorry --non-trivial
lemma new_lemma_3562 (h0 : function.extfun (finset Type) (has_mem.mem (ordered_comm_semiring fun_info))) : @strong_rank_condition.{0} (ordered_comm_semiring.{0} fun_info) (@finset.pi.empty.{1 0} Type ring.{0} (ordered_comm_semiring.{0} fun_info) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (ordered_comm_semiring.{0} fun_info)) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_3563 (h0 : not (topological_space (metric_space congr_arg_kind) -> false)) : @preirreducible_space.{0} (metric_space.{0} congr_arg_kind) (@classical.by_contradiction'.{1} (topological_space.{0} (metric_space.{0} congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_3564 (h0 : uniform_space (has_neg (has_pos_part Type))) : separated_space (has_neg (has_pos_part Type)) := sorry --non-trivial
lemma new_lemma_3565 (h0 : uniform_space (monoid_with_zero (option congr_arg_kind))) : complete_space (monoid_with_zero (option congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_3566 (h0 : unit -> unit) : @trace_call_stack.{0} Prop (@function.fixed_points.{0} unit h0)  := sorry --non-trivial
lemma new_lemma_3567 (h1 : topological_space (with_one linarith.comp_source)) : locally_compact_space (with_one linarith.comp_source) := sorry --non-trivial
lemma new_lemma_3568 (h0 : topological_space (non_unital_non_assoc_semiring char)) : totally_disconnected_space (non_unital_non_assoc_semiring char) := sorry --non-trivial
lemma new_lemma_3569 (h0 : ring (add_cancel_monoid (has_pos_part (has_neg (semigroup linarith.comp))))) : rank_condition (add_cancel_monoid (has_pos_part (has_neg (semigroup linarith.comp)))) := sorry --non-trivial
lemma new_lemma_3570 (h0 : functor.add_const (add_monoid (has_to_string unsigned)) pos) : @add_monoid.fg.{0} (has_to_string.{0} unsigned) (@functor.add_const.run.{0 0} (add_monoid.{0} (has_to_string.{0} unsigned)) pos h0)  := sorry --non-trivial
lemma new_lemma_3571 (h0 : functor.add_const (topological_space name) num) : @locally_compact_space.{0} name (@functor.add_const.run.{0 0} (topological_space.{0} name) num h0)  := sorry --non-trivial
lemma new_lemma_3572 (h0 : function.extfun Type topological_space) : @irreducible_space.{0} (normed_group.{0} fun_info) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (normed_group.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_3573 (h0 : filter (sub_neg_monoid (has_pos_part pos))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_3574 (h0 : topological_space (boolean_algebra (finset pos))) : loc_path_connected_space (boolean_algebra (finset pos)) := sorry --non-trivial
lemma new_lemma_3575 (h0 : functor.add_const (complete_lattice (left_cancel_monoid unsigned)) unsigned) : @is_atomistic.{0} (left_cancel_monoid.{0} unsigned) (@functor.add_const.run.{0 0} (complete_lattice.{0} (left_cancel_monoid.{0} unsigned)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_3576 (h0 : ring (has_zero (option (option ennreal)))) : strong_rank_condition (has_zero (option (option ennreal))) := sorry --non-trivial
lemma new_lemma_3577 (h1 : group (has_nnnorm (has_ssubset reducibility_hints))) : is_cyclic (has_nnnorm (has_ssubset reducibility_hints)) := sorry --non-trivial
lemma new_lemma_3578 (h0 : functor.add_const (group (canonically_ordered_monoid Type)) linarith.comp) : @is_simple_group.{1} (canonically_ordered_monoid.{1} Type) (@functor.add_const.run.{1 0} (group.{1} (canonically_ordered_monoid.{1} Type)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_3579 (h0 : group (ordered_cancel_add_comm_monoid unsigned)) : is_simple_group (ordered_cancel_add_comm_monoid unsigned) := sorry --non-trivial
lemma new_lemma_3580 (h0 : list (has_to_string (option pos))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_3581 (h0 : function.extfun Type list) : list.nodup (function.extfun_app h0 (sub_neg_monoid real)) := sorry --non-trivial
lemma new_lemma_3582 (h0 : functor.add_const (topological_space (boolean_algebra environment.implicit_infer_kind)) pos) : @irreducible_space.{0} (boolean_algebra.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (boolean_algebra.{0} environment.implicit_infer_kind)) pos h0)  := sorry --non-trivial
lemma new_lemma_3583 (h0 : ring (complete_distrib_lattice (has_bot real))) : strong_rank_condition (complete_distrib_lattice (has_bot real)) := sorry --non-trivial
lemma new_lemma_3584 (h0 : add_group (has_add (has_add (has_add ennreal)))) : is_add_cyclic (has_add (has_add (has_add ennreal))) := sorry --non-trivial
lemma new_lemma_3585 (h0 : list (comm_group (finset (finset Type)))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_3586 (h0 : topological_space (semiring (has_norm (has_norm empty)))) : t0_space (semiring (has_norm (has_norm empty))) := sorry --non-trivial
lemma new_lemma_3587 (h1 : add_group (has_nnnorm (has_top string_imp))) : is_add_cyclic (has_nnnorm (has_top string_imp)) := sorry --non-trivial
lemma new_lemma_3588 (h0 : topological_space (ordered_comm_monoid (sub_neg_monoid Type))) : locally_compact_space (ordered_comm_monoid (sub_neg_monoid Type)) := sorry --non-trivial
lemma new_lemma_3589 (h0 : function.extfun Type topological_space) : @totally_separated_space.{0} (linear_ordered_comm_ring.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (linear_ordered_comm_ring.{0} empty))  := sorry --non-trivial
lemma new_lemma_3590 (h0 : ring (encodable to_additive.value_type)) : is_domain (encodable to_additive.value_type) := sorry --non-trivial
lemma new_lemma_3591 (h0 : function.extfun ((finset (Type -> Type) -> Prop) -> Prop) (function.extfun (finset (Type -> Type) -> Prop))) : @is_atomistic.{0} (has_top.{0} fun_info) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) complete_lattice.{0} (@function.extfun_app.{2 0} (finset.{1} (Type → Type)) (@has_mem.mem.{1 1} (Type → Type) (finset.{1} (Type → Type)) (@finset.has_mem.{1} (Type → Type)) complete_lattice.{0}) (@function.extfun_app.{2 0} (finset.{1} (Type → Type) → Prop) (function.extfun.{2 0} (finset.{1} (Type → Type))) (@function.extfun_app.{2 0} ((finset.{1} (Type → Type) → Prop) → Prop) (function.extfun.{2 0} (finset.{1} (Type → Type) → Prop)) h0 (function.extfun.{2 0} (finset.{1} (Type → Type)))) (@has_mem.mem.{1 1} (Type → Type) (finset.{1} (Type → Type)) (@finset.has_mem.{1} (Type → Type)) complete_lattice.{0})) (@has_emptyc.emptyc.{1} (finset.{1} (Type → Type)) (@finset.has_emptyc.{1} (Type → Type))))) (has_top.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_3592 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @t0_space.{0} (linear_ordered_field.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (linear_ordered_field.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_3593 (h0 : topological_space (has_zero (finset linarith.comp))) : regular_space (has_zero (finset linarith.comp)) := sorry --non-trivial
lemma new_lemma_3594 (h0 : not (ring (semiring to_additive.value_type) -> false)) : @strong_rank_condition.{0} (semiring.{0} to_additive.value_type) (@classical.by_contradiction'.{1} (ring.{0} (semiring.{0} to_additive.value_type)) h0)  := sorry --non-trivial
lemma new_lemma_3595 (h0 : semiring (has_add (has_add (has_add (has_add name))))) : is_noetherian_ring (has_add (has_add (has_add (has_add name)))) := sorry --non-trivial
lemma new_lemma_3596 (h0 : filter (has_neg_part environment.implicit_infer_kind)) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_3597 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @loc_path_connected_space.{0} (has_zero.{0} ennreal) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_zero.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_3598 (h0 : function.extfun Type topological_space) : @locally_compact_space.{0} (ordered_cancel_add_comm_monoid.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (ordered_cancel_add_comm_monoid.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_3599 (h0 : topological_space (fintype (random_gen linarith.ineq))) : path_connected_space (fintype (random_gen linarith.ineq)) := sorry --non-trivial
lemma new_lemma_3600 (h1 : not (ring (fintype to_additive.value_type) -> false)) : @strong_rank_condition.{0} (fintype.{0} to_additive.value_type) (@classical.by_contradiction'.{1} (ring.{0} (fintype.{0} to_additive.value_type)) h1)  := sorry --non-trivial
lemma new_lemma_3601 (h0 : ring (with_bot (semiring (semiring empty)))) : strong_rank_condition (with_bot (semiring (semiring empty))) := sorry --non-trivial
lemma new_lemma_3602 (h0 : uniform_space (has_star num)) : complete_space (has_star num) := sorry --non-trivial
lemma new_lemma_3603 (h0 : add_group (comm_group (boolean_algebra name))) : is_add_cyclic (comm_group (boolean_algebra name)) := sorry --non-trivial
lemma new_lemma_3604 (h0 : functor.add_const (fin has_zero.zero) Type) : @rank_condition.{0} (has_bot.{0} real) (@function.extfun_app.{2 1} Type ring.{0} (@matrix.vec_empty.{1} (function.extfun.{2 1} Type ring.{0}) (@functor.add_const.run.{0 1} (fin (@has_zero.zero.{0} nat nat.has_zero)) Type h0)) (has_bot.{0} real))  := sorry --non-trivial
lemma new_lemma_3605 (h0 : topological_space (boolean_algebra (has_add (has_add Type)))) : t0_space (boolean_algebra (has_add (has_add Type))) := sorry --non-trivial
lemma new_lemma_3606 (h1 : ring (distrib (random_gen char))) : is_domain (distrib (random_gen char)) := sorry --non-trivial
lemma new_lemma_3607 (h2 : add_group (has_lt (metric_space linarith.comp_source))) : is_add_cyclic (has_lt (metric_space linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_3608 (h0 : uniform_space (has_inter (option num))) : separated_space (has_inter (option num)) := sorry --non-trivial
lemma new_lemma_3609 (h0 : not (filter (denumerable char) -> false)) : filter.ne_bot (classical.by_contradiction' h0) := sorry --non-trivial
lemma new_lemma_3610 (h0 : functor.add_const (function.extfun (Type 1) monoid) linarith.comp) : @monoid.fg.{1} (has_to_string.{1} Type) (@function.extfun_app.{3 2} (Type 1) monoid.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) monoid.{1}) linarith.comp h0) (has_to_string.{1} Type))  := sorry --non-trivial
lemma new_lemma_3611 (h0 : group (comm_ring reducibility_hints)) : is_cyclic (comm_ring reducibility_hints) := sorry --non-trivial
lemma new_lemma_3612 (h0 : function.extfun Type ring) : @strong_rank_condition.{0} (complete_distrib_lattice.{0} num) (@function.extfun_app.{2 1} Type ring.{0} h0 (complete_distrib_lattice.{0} num))  := sorry --non-trivial
lemma new_lemma_3613 (h0 : complete_lattice (add_group (semiring (semiring (semiring num))))) : complete_lattice.is_Sup_finite_compact (add_group (semiring (semiring (semiring num)))) := sorry --non-trivial
lemma new_lemma_3614 (h0 : ordered_comm_monoid (has_nndist ennreal)) : has_exists_mul_of_le (has_nndist ennreal) := sorry --non-trivial
lemma new_lemma_3615 (h0 : ring (with_one char)) : strong_rank_condition (with_one char) := sorry --non-trivial
lemma new_lemma_3616 (h0 : add_group (has_star (option (semiring unsigned)))) : is_add_cyclic (has_star (option (semiring unsigned))) := sorry --non-trivial
lemma new_lemma_3617 (h0 : functor.add_const (complete_lattice (normed_comm_ring Type)) (has_neg_part (has_neg_part (has_neg_part Type)))) : @is_compactly_generated.{1} (normed_comm_ring.{1} Type) (@functor.add_const.run.{1 1} (complete_lattice.{1} (normed_comm_ring.{1} Type)) (has_neg_part.{1} (has_neg_part.{1} (has_neg_part.{1} Type))) h0)  := sorry --non-trivial
lemma new_lemma_3618 (h0 : uniform_space (linear_ordered_comm_ring (semiring num))) : separated_space (linear_ordered_comm_ring (semiring num)) := sorry --non-trivial
lemma new_lemma_3619 (h0 : fin has_zero.zero) : @is_compactly_generated.{0} (complete_distrib_lattice.{0} pos) (@matrix.vec_empty.{0} (complete_lattice.{0} (complete_distrib_lattice.{0} pos)) h0)  := sorry --non-trivial
lemma new_lemma_3620 (h0 : has_add enat) (h1 : set (add_comm_semigroup (add_con enat))) : set.finite h1 := sorry --non-trivial
lemma new_lemma_3621 (h0 : function.extfun Type topological_space) : @discrete_topology.{0} (option.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (option.{0} empty))  := sorry --non-trivial
lemma new_lemma_3622 (h0 : topological_space (normed_lattice_add_comm_group Type)) : normal_space (normed_lattice_add_comm_group Type) := sorry --non-trivial
lemma new_lemma_3623 (h0 : topological_space (semigroup (ring (mul_zero_class (has_neg (add_comm_monoid (normed_comm_ring Type))))))) : t0_space (semigroup (ring (mul_zero_class (has_neg (add_comm_monoid (normed_comm_ring Type)))))) := sorry --non-trivial
lemma new_lemma_3624 (h0 : ring (has_add unsigned)) : strong_rank_condition (has_add unsigned) := sorry --non-trivial
lemma new_lemma_3625 (h0 : list (measurable_space (has_inv (random_gen (has_top linarith.ineq))))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_3626 (h0 : finset (pseudo_metric_space empty)) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_3627 (h0 : topological_space (random_gen (has_inv (has_inv to_additive.value_type)))) : totally_separated_space (random_gen (has_inv (has_inv to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_3628 (h0 : functor.add_const (monoid (has_to_string environment.implicit_infer_kind)) Type) : @monoid.fg.{0} (has_to_string.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 1} (monoid.{0} (has_to_string.{0} environment.implicit_infer_kind)) Type h0)  := sorry --non-trivial
lemma new_lemma_3629 (h0 : add_group (distrib (has_nnnorm (linear_ordered_comm_monoid_with_zero (random_gen char))))) : is_add_cyclic (distrib (has_nnnorm (linear_ordered_comm_monoid_with_zero (random_gen char)))) := sorry --non-trivial
lemma new_lemma_3630 (h0 : topological_space (ring (ring Type))) : regular_space (ring (ring Type)) := sorry --non-trivial
lemma new_lemma_3631 (h1 : preorder (add_comm_semigroup char)) (h2 : set (add_comm_semigroup char)) : set.is_pwo h2 := sorry --non-trivial
lemma new_lemma_3632 (h0 : has_mem.mem (semigroup environment.implicit_infer_kind) has_emptyc.emptyc) : palindrome (finset.pi.empty list (semigroup environment.implicit_infer_kind) h0) := sorry --non-trivial
lemma new_lemma_3633 (h0 : functor.add_const (function.extfun Type topological_space) Type) : @discrete_topology.{0} (finset.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type topological_space.{0}) Type h0) (finset.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_3634 (h0 : functor.add_const (topological_space (comm_group pos)) name) : @preirreducible_space.{0} (comm_group.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (comm_group.{0} pos)) name h0)  := sorry --non-trivial
lemma new_lemma_3635 (h0 : not (uniform_space (random_gen string_imp) -> false)) : @complete_space.{0} (random_gen.{0} string_imp) (@classical.by_contradiction'.{1} (uniform_space.{0} (random_gen.{0} string_imp)) h0)  := sorry --non-trivial
lemma new_lemma_3636 (h0 : function.extfun Type filter) : filter.ne_bot (function.extfun_app h0 (id num)) := sorry --non-trivial
lemma new_lemma_3637 (h0 : ordered_comm_monoid (complete_distrib_lattice real)) : has_exists_mul_of_le (complete_distrib_lattice real) := sorry --non-trivial
lemma new_lemma_3638 (h0 : function.extfun Type group) : @normalizer_condition.{0} (has_inter.{0} unsigned) (@function.extfun_app.{2 1} Type group.{0} h0 (has_inter.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_3639 (h0 : function.extfun Type group) : @is_cyclic.{0} (sub_neg_monoid.{0} name) (@function.extfun_app.{2 1} Type group.{0} h0 (sub_neg_monoid.{0} name))  := sorry --non-trivial
lemma new_lemma_3640 (h0 : not (topological_space (add_left_cancel_monoid linarith.comp_source) -> false)) : @totally_disconnected_space.{0} (add_left_cancel_monoid.{0} linarith.comp_source) (@classical.by_contradiction'.{1} (topological_space.{0} (add_left_cancel_monoid.{0} linarith.comp_source)) h0)  := sorry --non-trivial
lemma new_lemma_3641 (h0 : functor.add_const (complete_lattice (finset ennreal)) ennreal) : @is_compactly_generated.{0} (finset.{0} ennreal) (@functor.add_const.run.{0 0} (complete_lattice.{0} (finset.{0} ennreal)) ennreal h0)  := sorry --non-trivial
lemma new_lemma_3642 (h1 : group (uniform_space to_additive.value_type)) : is_cyclic (uniform_space to_additive.value_type) := sorry --non-trivial
lemma new_lemma_3643 (h1 : complete_lattice (has_append char)) : is_compactly_generated (has_append char) := sorry --non-trivial
lemma new_lemma_3644 (h0 : ring (has_bot (has_Inf (boolean_algebra (has_add linarith.comp))))) : strong_rank_condition (has_bot (has_Inf (boolean_algebra (has_add linarith.comp)))) := sorry --non-trivial
lemma new_lemma_3645 (h0 : functor.add_const (topological_space (mul_zero_class empty)) congr_arg_kind) : @totally_separated_space.{0} (mul_zero_class.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (mul_zero_class.{0} empty)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_3646 (h0 : topological_space znum) : t1_space znum := sorry --non-trivial
lemma new_lemma_3647 (h0 : functor.add_const (ring (finset pos)) name) : @strong_rank_condition.{0} (finset.{0} pos) (@functor.add_const.run.{0 0} (ring.{0} (finset.{0} pos)) name h0)  := sorry --non-trivial
lemma new_lemma_3648 (h0 : functor.add_const (monoid (comm_group linarith.comp)) (comm_group (comm_group name))) : @monoid.fg.{0} (comm_group.{0} linarith.comp) (@functor.add_const.run.{0 0} (monoid.{0} (comm_group.{0} linarith.comp)) (comm_group.{0} (comm_group.{0} name)) h0)  := sorry --non-trivial
lemma new_lemma_3649 (h1 : topological_space (add_comm_semigroup char)) : topological_space.first_countable_topology (add_comm_semigroup char) := sorry --non-trivial
lemma new_lemma_3650 (h1 : uniform_space (add_comm_semigroup reducibility_hints)) : complete_space (add_comm_semigroup reducibility_hints) := sorry --non-trivial
lemma new_lemma_3651 (h0 : function.extfun Type ordered_comm_monoid) : @has_exists_mul_of_le.{0} (boolean_algebra.core.{0} ennreal) (@function.extfun_app.{2 1} Type ordered_comm_monoid.{0} h0 (boolean_algebra.core.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_3652 (h0 : list (boolean_algebra (finset pos))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_3653 (h0 : topological_space (has_nndist (has_pos_part Type))) : path_connected_space (has_nndist (has_pos_part Type)) := sorry --non-trivial
lemma new_lemma_3654 (h0 : functor.add_const (add_group (has_zero environment.implicit_infer_kind)) linarith.comp) : @is_add_cyclic.{0} (has_zero.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (add_group.{0} (has_zero.{0} environment.implicit_infer_kind)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_3655 (h0 : functor.add_const (topological_space (has_neg pos)) pos) : @totally_disconnected_space.{0} (has_neg.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (has_neg.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_3656 (h0 : function.extfun Type topological_space) : @totally_separated_space.{0} (has_Inf.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_Inf.{0} pos))  := sorry --non-trivial
lemma new_lemma_3657 (h0 : topological_space (monoid_with_zero ennreal)) : topological_space.separable_space (monoid_with_zero ennreal) := sorry --non-trivial
lemma new_lemma_3658 (h0 : ordered_comm_monoid (has_to_string (has_pos_part name))) : has_exists_mul_of_le (has_to_string (has_pos_part name)) := sorry --non-trivial
lemma new_lemma_3659 (h0 : functor.add_const (topological_space (boolean_algebra.core pos)) (has_add (boolean_algebra name))) : @normal_space.{0} (boolean_algebra.core.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (boolean_algebra.core.{0} pos)) (has_add.{0} (boolean_algebra.{0} name)) h0)  := sorry --non-trivial
lemma new_lemma_3660 (h0 : not (function.extfun Type ring -> false)) : @rank_condition.{0} (with_bot.{0} empty) (@function.extfun_app.{2 1} Type ring.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type ring.{0}) h0) (with_bot.{0} empty))  := sorry --non-trivial
lemma new_lemma_3661 (h0 : ring (comm_group (boolean_algebra.core (has_add Type)))) : strong_rank_condition (comm_group (boolean_algebra.core (has_add Type))) := sorry --non-trivial
lemma new_lemma_3662 (h0 : functor.add_const (function.extfun (Type 1) list) Type) : palindrome (function.extfun_app (functor.add_const.run h0) (complete_distrib_lattice Type)) := sorry --non-trivial
lemma new_lemma_3663 (h0 : uniform_space (semi_normed_comm_ring (has_ssubset fun_info))) : complete_space (semi_normed_comm_ring (has_ssubset fun_info)) := sorry --non-trivial
lemma new_lemma_3664 (h0 : topological_space (add_cancel_monoid (boolean_algebra.core Type))) : regular_space (add_cancel_monoid (boolean_algebra.core Type)) := sorry --non-trivial
lemma new_lemma_3665 (h0 : topological_space (has_add (has_to_string (has_to_string environment.implicit_infer_kind)))) : t1_space (has_add (has_to_string (has_to_string environment.implicit_infer_kind))) := sorry --non-trivial
lemma new_lemma_3666 (h1 : ring (normed_field reducibility_hints)) : is_domain (normed_field reducibility_hints) := sorry --non-trivial
lemma new_lemma_3667 (h0 : topological_space (monoid (option unsigned))) : irreducible_space (monoid (option unsigned)) := sorry --non-trivial
lemma new_lemma_3668 (h0 : functor.add_const (topological_space (ordered_ring empty)) empty) : @path_connected_space.{0} (ordered_ring.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (ordered_ring.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_3669 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @archimedean.{0} (add_cancel_monoid.{0} name) (@function.extfun_app.{2 1} Type ordered_add_comm_monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ordered_add_comm_monoid.{0}) (add_cancel_monoid.{0} name))  := sorry --non-trivial
lemma new_lemma_3670 (h0 : topological_space (has_ssubset (has_norm to_additive.value_type))) : totally_disconnected_space (has_ssubset (has_norm to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_3671 (h0 : complete_lattice (canonically_ordered_comm_semiring (has_to_string name))) : complete_lattice.is_Sup_finite_compact (canonically_ordered_comm_semiring (has_to_string name)) := sorry --non-trivial
lemma new_lemma_3672 (h1 : function.extfun Type topological_space) : totally_disconnected_space empty := sorry --non-trivial
lemma new_lemma_3673 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @complete_lattice.is_Sup_finite_compact.{0} (complete_semilattice_Sup.{0} fun_info) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (complete_semilattice_Sup.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_3674 (h0 : topological_space (simple_graph (boolean_algebra.core Type))) : normal_space (simple_graph (boolean_algebra.core Type)) := sorry --non-trivial
lemma new_lemma_3675 (h0 : not (function.extfun Type topological_space -> false)) : @path_connected_space.{0} (has_top.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (has_top.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_3676 (h0 : not (ring (measurable_space.dynkin_system num) -> false)) : @is_domain.{0} (measurable_space.dynkin_system.{0} num) (@classical.by_contradiction'.{1} (ring.{0} (measurable_space.dynkin_system.{0} num)) h0)  := sorry --non-trivial
lemma new_lemma_3677 (h0 : functor.add_const (ring (has_Sup unsigned)) num) : @is_principal_ideal_ring.{0} (has_Sup.{0} unsigned) (@functor.add_const.run.{0 0} (ring.{0} (has_Sup.{0} unsigned)) num h0)  := sorry --non-trivial
lemma new_lemma_3678 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @monoid.fg.{0} (has_neg.{0} pos) (@function.extfun_app.{2 1} Type monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 monoid.{0}) (has_neg.{0} pos))  := sorry --non-trivial
lemma new_lemma_3679 (h0 : group (add_comm_monoid (finset (finset pos)))) : is_simple_group (add_comm_monoid (finset (finset pos))) := sorry --non-trivial
lemma new_lemma_3680 (h0 : functor.add_const (topological_space (has_zero linarith.comp)) Type) : @preirreducible_space.{0} (has_zero.{0} linarith.comp) (@functor.add_const.run.{0 1} (topological_space.{0} (has_zero.{0} linarith.comp)) Type h0)  := sorry --non-trivial
lemma new_lemma_3681 (h0 : functor.add_const (group (has_to_string environment.implicit_infer_kind)) environment.implicit_infer_kind) : @is_simple_group.{0} (has_to_string.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (group.{0} (has_to_string.{0} environment.implicit_infer_kind)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_3682 (h0 : complete_lattice (has_nndist ennreal)) : is_compactly_generated (has_nndist ennreal) := sorry --non-trivial
lemma new_lemma_3683 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @loc_path_connected_space.{0} (ordered_ring.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (ordered_ring.{0} empty))  := sorry --non-trivial
lemma new_lemma_3684 (h0 : group (id (random_gen (random_gen (random_gen to_additive.value_type))))) : is_cyclic (id (random_gen (random_gen (random_gen to_additive.value_type)))) := sorry --non-trivial
lemma new_lemma_3685 (h0 : functor.add_const (topological_space (has_neg_part Type)) linarith.comp) : @totally_separated_space.{1} (has_neg_part.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (has_neg_part.{1} Type)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_3686 (h0 : functor.add_const (function.extfun Type topological_space) Type) : @irreducible_space.{0} (has_nndist.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type topological_space.{0}) Type h0) (has_nndist.{0} pos))  := sorry --non-trivial
lemma new_lemma_3687 (h2 : topological_space (has_ssubset char)) : locally_compact_space (has_ssubset char) := sorry --non-trivial
lemma new_lemma_3688 (h0 : group (has_norm (complete_semilattice_Sup empty))) : normalizer_condition (has_norm (complete_semilattice_Sup empty)) := sorry --non-trivial
lemma new_lemma_3689 (h0 : function.extfun Type topological_space) : @preirreducible_space.{0} (measurable_space.dynkin_system.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (measurable_space.dynkin_system.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_3690 (h0 : functor.add_const (ring (has_to_string pos)) (has_nndist (has_add (ordered_ring Type)))) : @is_domain.{0} (has_to_string.{0} pos) (@functor.add_const.run.{0 1} (ring.{0} (has_to_string.{0} pos)) (has_nndist.{1} (has_add.{1} (ordered_ring.{1} Type))) h0)  := sorry --non-trivial
lemma new_lemma_3691 (h0 : finset (boolean_algebra linarith.comp)) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_3692 (h1 : add_group (comm_ring (has_inv string_imp))) : is_add_cyclic (comm_ring (has_inv string_imp)) := sorry --non-trivial
lemma new_lemma_3693 (h0 : ring (has_ssubset complex)) : rank_condition (has_ssubset complex) := sorry --non-trivial
lemma new_lemma_3694 (h0 : topological_space (has_add (normed_comm_ring (finset unsigned)))) : regular_space (has_add (normed_comm_ring (finset unsigned))) := sorry --non-trivial
lemma new_lemma_3695 (h0 : topological_space (comm_semigroup (has_pos_part linarith.comp))) : t1_space (comm_semigroup (has_pos_part linarith.comp)) := sorry --non-trivial
lemma new_lemma_3696 (h0 : monoid (semiring (has_top unsigned))) : monoid.fg (semiring (has_top unsigned)) := sorry --non-trivial
lemma new_lemma_3697 (h0 : ring (metric_space (linear_ordered_semiring unsigned))) : rank_condition (metric_space (linear_ordered_semiring unsigned)) := sorry --non-trivial
lemma new_lemma_3698 (h0 : measurable_space (linear_ordered_comm_group_with_zero environment.projection_info)) (h1 : filter (linear_ordered_comm_group_with_zero environment.projection_info)) : filter.is_measurably_generated h1 := sorry --non-trivial
lemma new_lemma_3699 (h0 : topological_space (simple_graph std_gen)) : t0_space (simple_graph std_gen) := sorry --non-trivial
lemma new_lemma_3700 (h0 : fin has_zero.zero) : @totally_disconnected_space.{0} (has_bot.{0} real) (@function.extfun_app.{2 1} Type topological_space.{0} (@matrix.vec_empty.{1} (function.extfun.{2 1} Type topological_space.{0}) h0) (has_bot.{0} real))  := sorry --non-trivial
lemma new_lemma_3701 (h0 : has_mem.mem (normed_group linarith.comp) has_emptyc.emptyc) : @is_atomistic.{0} (normed_group.{0} linarith.comp) (@finset.pi.empty.{1 0} Type complete_lattice.{0} (normed_group.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_3702 (h0 : fin has_zero.zero) : @sequential_space.{1} (comm_semigroup.{1} Type) (@matrix.vec_empty.{1} (topological_space.{1} (comm_semigroup.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_3703 (h0 : functor.add_const (topological_space (generalized_boolean_algebra pos)) (has_Inf name)) : @regular_space.{0} (generalized_boolean_algebra.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (generalized_boolean_algebra.{0} pos)) (has_Inf.{0} name) h0)  := sorry --non-trivial
lemma new_lemma_3704 (h0 : functor.add_const (list (has_zero Type)) pos) : list.nodup (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_3705 (h0 : topological_space (has_inter ennreal)) : totally_separated_space (has_inter ennreal) := sorry --non-trivial
lemma new_lemma_3706 (h0 : finset (canonically_ordered_comm_semiring empty)) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_3707 (h0 : has_add Type -> Prop) : zzz_forall h0 := sorry --non-trivial
lemma new_lemma_3708 (h0 : add_monoid (plift (has_top empty))) : add_monoid.fg (plift (has_top empty)) := sorry --non-trivial
lemma new_lemma_3709 (h0 : add_group (has_norm (has_norm (has_norm linarith.comp_source)))) : is_add_cyclic (has_norm (has_norm (has_norm linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_3710 (h0 : function.extfun Type group) : @is_simple_group.{0} (has_Inf.{0} real) (@function.extfun_app.{2 1} Type group.{0} h0 (has_Inf.{0} real))  := sorry --non-trivial
lemma new_lemma_3711 (h0 : topological_space (canonically_linear_ordered_monoid (option (option ennreal)))) : loc_path_connected_space (canonically_linear_ordered_monoid (option (option ennreal))) := sorry --non-trivial
lemma new_lemma_3712 (h1 : ring (with_one string_imp)) : is_domain (with_one string_imp) := sorry --non-trivial
lemma new_lemma_3713 (h0 : measurable_space (omega_complete_partial_order (option (option (option unsigned))))) (h1 : measure_theory.measure (omega_complete_partial_order (option (option (option unsigned))))) : measure_theory.measure.is_complete h1 := sorry --non-trivial
lemma new_lemma_3714 (h0 : functor.add_const (topological_space (comm_group environment.implicit_infer_kind)) linarith.comp) : @path_connected_space.{0} (comm_group.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (comm_group.{0} environment.implicit_infer_kind)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_3715 (h0 : not (topological_space empty -> false)) : totally_separated_space empty := sorry --non-trivial
lemma new_lemma_3716 (h1 : ring (linear_ordered_add_comm_group (has_nnnorm (has_nnnorm linarith.ineq)))) : rank_condition (linear_ordered_add_comm_group (has_nnnorm (has_nnnorm linarith.ineq))) := sorry --non-trivial
lemma new_lemma_3717 (h0 : prod (semiring (semiring (semiring (semiring num)))) (semiring (semiring (semiring (semiring num))))) : id_rel h0 := sorry --non-trivial
lemma new_lemma_3718 (h0 : topological_space (has_bot (has_bot (sub_neg_monoid Type)))) : topological_space.separable_space (has_bot (has_bot (sub_neg_monoid Type))) := sorry --non-trivial
lemma new_lemma_3719 (h0 : ring (comm_ring (random_gen linarith.comp_source))) : strong_rank_condition (comm_ring (random_gen linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_3720 (h0 : has_mem.mem (semiring congr_arg_kind) has_emptyc.emptyc) : @is_atomistic.{0} (semiring.{0} congr_arg_kind) (@finset.pi.empty.{1 0} Type complete_lattice.{0} (semiring.{0} congr_arg_kind) h0)  := sorry --non-trivial
lemma new_lemma_3721 (h0 : measurable_space (has_nndist Type)) (h1 : has_add (has_nndist Type)) : has_measurable_add (has_nndist Type) := sorry --non-trivial
lemma new_lemma_3722 (h0 : functor.add_const (topological_space (add_comm_monoid linarith.comp)) pos) : @normal_space.{0} (add_comm_monoid.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (add_comm_monoid.{0} linarith.comp)) pos h0)  := sorry --non-trivial
lemma new_lemma_3723 (h0 : group (boolean_algebra.core name)) : is_cyclic (boolean_algebra.core name) := sorry --non-trivial
lemma new_lemma_3724 (h2 : ring (normed_field to_additive.value_type)) : is_domain (normed_field to_additive.value_type) := sorry --non-trivial
lemma new_lemma_3725 (h0 : function.extfun Type complete_lattice) : @is_compactly_generated.{0} (canonically_ordered_comm_semiring.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (canonically_ordered_comm_semiring.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_3726 (h0 : functor.add_const (group (cancel_monoid name)) real) : @group.fg.{0} (cancel_monoid.{0} name) (@functor.add_const.run.{0 0} (group.{0} (cancel_monoid.{0} name)) real h0)  := sorry --non-trivial
lemma new_lemma_3727 (h0 : function.extfun Type list) : list.nodup (function.extfun_app h0 (with_bot linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_3728 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @normalizer_condition.{0} (has_norm.{0} linarith.comp) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (has_norm.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_3729 (h2 : has_mem.mem num has_emptyc.emptyc) : @rank_condition.{0} num (@finset.pi.empty.{1 0} Type ring.{0} num h2)  := sorry --non-trivial
lemma new_lemma_3730 (h0 : topological_space (ordered_comm_ring (has_neg (has_add name)))) : t0_space (ordered_comm_ring (has_neg (has_add name))) := sorry --non-trivial
lemma new_lemma_3731 (h0 : function.extfun Type topological_space) : @locally_compact_space.{0} (complete_semilattice_Sup.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (complete_semilattice_Sup.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_3732 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @t0_space.{0} (normed_lattice_add_comm_group.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (normed_lattice_add_comm_group.{0} name))  := sorry --non-trivial
lemma new_lemma_3733 (h0 : add_monoid (ring (has_add (has_add (has_add (has_add Type)))))) : add_monoid.fg (ring (has_add (has_add (has_add (has_add Type))))) := sorry --non-trivial
lemma new_lemma_3734 (h0 : topological_space (add_left_cancel_monoid (has_ssubset linarith.comp_source))) : path_connected_space (add_left_cancel_monoid (has_ssubset linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_3735 (h0 : function.extfun Type topological_space) : @loc_path_connected_space.{0} (add_cancel_monoid.{0} (option.{0} empty)) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (add_cancel_monoid.{0} (option.{0} empty)))  := sorry --non-trivial
lemma new_lemma_3736 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_domain.{0} linarith.comp_source (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) linarith.comp_source)  := sorry --non-trivial
lemma new_lemma_3737 (h0 : not (uniform_space (mul_zero_class congr_arg_kind) -> false)) : @separated_space.{0} (mul_zero_class.{0} congr_arg_kind) (@classical.by_contradiction'.{1} (uniform_space.{0} (mul_zero_class.{0} congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_3738 (h0 : not (group (option unsigned) -> false)) : @is_cyclic.{0} (option.{0} unsigned) (@classical.by_contradiction'.{1} (group.{0} (option.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_3739 (h0 : ring (complete_semilattice_Sup linarith.comp_source)) : strong_rank_condition (complete_semilattice_Sup linarith.comp_source) := sorry --non-trivial
lemma new_lemma_3740 (h0 : option empty -> option empty -> Prop) : irreflexive h0 := sorry --non-trivial
lemma new_lemma_3741 (h0 : not (topological_space (has_ssubset to_additive.value_type) -> false)) : @totally_disconnected_space.{0} (has_ssubset.{0} to_additive.value_type) (@classical.by_contradiction'.{1} (topological_space.{0} (has_ssubset.{0} to_additive.value_type)) h0)  := sorry --non-trivial
lemma new_lemma_3742 (h0 : list (has_nndist (finset name))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_3743 (h0 : functor.add_const (finset (free_add_monoid congr_arg_kind)) num) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_3744 (h0 : group (comm_semigroup (has_add Type))) : is_cyclic (comm_semigroup (has_add Type)) := sorry --non-trivial
lemma new_lemma_3745 (h0 : function.extfun Type (functor.comp ring boolean_algebra)) : @is_principal_ideal_ring.{0} (boolean_algebra.{0} name) (@functor.comp.run.{0 0 0} ring.{0} boolean_algebra.{0} name (@function.extfun_app.{2 1} Type (functor.comp.{0 0 0} ring.{0} boolean_algebra.{0}) h0 name))  := sorry --non-trivial
lemma new_lemma_3746 (h0 : functor.add_const (function.extfun Type topological_space) (has_add pos)) : @t0_space.{0} (semigroup.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) (has_add.{0} pos) h0) (semigroup.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_3747 (h0 : topological_space (has_top (has_inv (has_nnnorm char)))) : locally_compact_space (has_top (has_inv (has_nnnorm char))) := sorry --non-trivial
lemma new_lemma_3748 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_domain.{0} (sub_neg_monoid.{0} name) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (sub_neg_monoid.{0} name))  := sorry --non-trivial
lemma new_lemma_3749 (h1 : topological_space (simple_graph reducibility_hints)) : t0_space (simple_graph reducibility_hints) := sorry --non-trivial
lemma new_lemma_3750 (h0 : fin has_zero.zero) : @is_cyclic.{1} (normed_lattice_add_comm_group.{1} Type) (@matrix.vec_empty.{1} (group.{1} (normed_lattice_add_comm_group.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_3751 (h0 : ordered_add_comm_monoid (ordered_comm_ring (has_neg name))) : archimedean (ordered_comm_ring (has_neg name)) := sorry --non-trivial
lemma new_lemma_3752 (h0 : ring (normed_group (comm_ring (random_gen (random_gen fun_info))))) : rank_condition (normed_group (comm_ring (random_gen (random_gen fun_info)))) := sorry --non-trivial
lemma new_lemma_3753 (h0 : function.extfun (finset (Type -> Type)) (has_mem.mem uniform_space)) : @complete_space.{0} (with_bot.{0} linarith.ineq) (@function.extfun_app.{2 1} Type uniform_space.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) uniform_space.{0} (@function.extfun_app.{2 0} (finset.{1} (Type → Type)) (@has_mem.mem.{1 1} (Type → Type) (finset.{1} (Type → Type)) (@finset.has_mem.{1} (Type → Type)) uniform_space.{0}) h0 (@has_emptyc.emptyc.{1} (finset.{1} (Type → Type)) (@finset.has_emptyc.{1} (Type → Type))))) (with_bot.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_3754 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_atomistic.{0} (has_inter.{0} num) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (has_inter.{0} num))  := sorry --non-trivial
lemma new_lemma_3755 (h0 : uniform_space (simple_graph (has_add (boolean_algebra.core (has_add Type))))) : separated_space (simple_graph (has_add (boolean_algebra.core (has_add Type)))) := sorry --non-trivial
lemma new_lemma_3756 (h0 : fin has_zero.zero) : @t0_space.{1} (ring.{1} Type) (@matrix.vec_empty.{1} (topological_space.{1} (ring.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_3757 (h0 : function.extfun Type cancel_comm_monoid_with_zero) : @unique_factorization_monoid.{0} (normed_lattice_add_comm_group.{0} name) (@function.extfun_app.{2 1} Type cancel_comm_monoid_with_zero.{0} h0 (normed_lattice_add_comm_group.{0} name))  := sorry --non-trivial
lemma new_lemma_3758 (h0 : group (normed_group (denumerable (denumerable (has_top fun_info))))) : group.fg (normed_group (denumerable (denumerable (has_top fun_info)))) := sorry --non-trivial
lemma new_lemma_3759 (h0 : Type) (h1 : eq Prop h0) (h2 : fin has_zero.zero) : eq.mpr h1 (matrix.vec_empty (matrix.vec_empty h2)) := sorry --non-trivial
lemma new_lemma_3760 (h0 : topological_space (generalized_boolean_algebra (has_Inf (has_nndist (has_Inf Type))))) : totally_separated_space (generalized_boolean_algebra (has_Inf (has_nndist (has_Inf Type)))) := sorry --non-trivial
lemma new_lemma_3761 (h0 : topological_space (with_one string_imp)) : path_connected_space (with_one string_imp) := sorry --non-trivial
lemma new_lemma_3762 (h0 : functor.add_const (topological_space (add_group num)) congr_arg_kind) : @totally_disconnected_space.{0} (add_group.{0} num) (@functor.add_const.run.{0 0} (topological_space.{0} (add_group.{0} num)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_3763 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @irreducible_space.{0} (canonically_ordered_comm_semiring.{0} ennreal) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (canonically_ordered_comm_semiring.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_3764 (h0 : functor.add_const (functor.add_const (topological_space name) empty) (option empty)) : @t1_space.{0} name (@functor.add_const.run.{0 0} (topological_space.{0} name) empty (@functor.add_const.run.{0 0} (functor.add_const.{0 0} (topological_space.{0} name) empty) (option.{0} empty) h0))  := sorry --non-trivial
lemma new_lemma_3765 (h0 : functor.add_const (function.extfun Type ring) unsigned) : @is_domain.{0} (left_cancel_semigroup.{0} unsigned) (@function.extfun_app.{2 1} Type ring.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type ring.{0}) unsigned h0) (left_cancel_semigroup.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_3766 (h0 : topological_space (sub_neg_monoid (has_Inf real))) : totally_disconnected_space (sub_neg_monoid (has_Inf real)) := sorry --non-trivial
lemma new_lemma_3767 (h0 : function.extfun Type topological_space) : @preirreducible_space.{0} (monoid.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (monoid.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_3768 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @add_monoid.fg.{0} (has_to_string.{0} empty) (@function.extfun_app.{2 1} Type add_monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 add_monoid.{0}) (has_to_string.{0} empty))  := sorry --non-trivial
lemma new_lemma_3769 (h0 : ring (canonically_ordered_comm_semiring (finset (finset name)))) : rank_condition (canonically_ordered_comm_semiring (finset (finset name))) := sorry --non-trivial
lemma new_lemma_3770 (h0 : not (function.extfun Type group -> false)) : @is_cyclic.{0} (normed_group.{0} linarith.comp) (@function.extfun_app.{2 1} Type group.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type group.{0}) h0) (normed_group.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_3771 (h1 : group (dlist char)) : is_cyclic (dlist char) := sorry --non-trivial
lemma new_lemma_3772 (h0 : monoid (with_one (random_gen fun_info))) : monoid.fg (with_one (random_gen fun_info)) := sorry --non-trivial
lemma new_lemma_3773 (h0 : complete_lattice (canonically_ordered_monoid (has_Inf (has_add name)))) : is_compactly_generated (canonically_ordered_monoid (has_Inf (has_add name))) := sorry --non-trivial
lemma new_lemma_3774 (h0 : functor.add_const (add_monoid (comm_group environment.implicit_infer_kind)) pos) : @add_monoid.fg.{0} (comm_group.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (add_monoid.{0} (comm_group.{0} environment.implicit_infer_kind)) pos h0)  := sorry --non-trivial
lemma new_lemma_3775 (h0 : functor.add_const (monoid (has_pos_part linarith.comp)) (has_nndist name)) : @monoid.fg.{0} (has_pos_part.{0} linarith.comp) (@functor.add_const.run.{0 0} (monoid.{0} (has_pos_part.{0} linarith.comp)) (has_nndist.{0} name) h0)  := sorry --non-trivial
lemma new_lemma_3776 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @preirreducible_space.{0} (ring.{0} (option.{0} empty)) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (ring.{0} (option.{0} empty)))  := sorry --non-trivial
lemma new_lemma_3777 (h0 : functor.add_const (group (add_cancel_monoid Type)) (has_neg (has_neg linarith.comp))) : @group.fg.{1} (add_cancel_monoid.{1} Type) (@functor.add_const.run.{1 0} (group.{1} (add_cancel_monoid.{1} Type)) (has_neg.{0} (has_neg.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_3778 (h0 : function.extfun Type topological_space) : @discrete_topology.{0} (canonically_ordered_monoid.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (canonically_ordered_monoid.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_3779 (h0 : group (boolean_algebra (ring (has_Inf linarith.comp)))) : group.fg (boolean_algebra (ring (has_Inf linarith.comp))) := sorry --non-trivial
lemma new_lemma_3780 (h0 : functor.add_const (group (normed_comm_ring Type)) linarith.comp) : @is_simple_group.{1} (normed_comm_ring.{1} Type) (@functor.add_const.run.{1 0} (group.{1} (normed_comm_ring.{1} Type)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_3781 (h0 : function.extfun (Type 1) topological_space) : @preconnected_space.{1} (semigroup.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} h0 (semigroup.{1} Type))  := sorry --non-trivial
lemma new_lemma_3782 (h0 : functor.add_const (ordered_comm_monoid (has_to_string (ring linarith.comp))) linarith.comp) : @has_exists_mul_of_le.{0} (has_to_string.{0} (ring.{0} linarith.comp)) (@functor.add_const.run.{0 0} (ordered_comm_monoid.{0} (has_to_string.{0} (ring.{0} linarith.comp))) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_3783 (h0 : group (add_group empty)) : group.fg (add_group empty) := sorry --non-trivial
lemma new_lemma_3784 (h0 : topological_space (pseudo_metric_space name)) : path_connected_space (pseudo_metric_space name) := sorry --non-trivial
lemma new_lemma_3785 (h0 : topological_space (simple_graph (mul_one_class linarith.comp_source))) : totally_disconnected_space (simple_graph (mul_one_class linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_3786 (h0 : topological_space (has_neg (option (has_neg (has_neg (has_neg (has_neg unsigned))))))) : t1_space (has_neg (option (has_neg (has_neg (has_neg (has_neg unsigned)))))) := sorry --non-trivial
lemma new_lemma_3787 (h0 : topological_space (complete_semilattice_Sup linarith.comp)) : discrete_topology (complete_semilattice_Sup linarith.comp) := sorry --non-trivial
lemma new_lemma_3788 (h2 : not (topological_space (normed_field string_imp) -> false)) : @path_connected_space.{0} (normed_field.{0} string_imp) (@classical.by_contradiction'.{1} (topological_space.{0} (normed_field.{0} string_imp)) h2)  := sorry --non-trivial
lemma new_lemma_3789 (h0 : add_group (with_bot congr_arg_kind)) : is_add_cyclic (with_bot congr_arg_kind) := sorry --non-trivial
lemma new_lemma_3790 (h0 : functor.add_const (topological_space (has_to_string unsigned)) (option pos)) : @normal_space.{0} (has_to_string.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (has_to_string.{0} unsigned)) (option.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_3791 (h0 : list (has_to_string (has_neg_part name))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_3792 (h0 : topological_space (non_assoc_semiring num)) : t1_space (non_assoc_semiring num) := sorry --non-trivial
lemma new_lemma_3793 (h0 : functor.add_const (ring znum) unsigned) : @is_domain.{0} znum (@functor.add_const.run.{0 0} (ring.{0} znum) unsigned h0)  := sorry --non-trivial
lemma new_lemma_3794 (h1 : complete_lattice (semi_normed_ring linarith.comp_source)) : is_compactly_generated (semi_normed_ring linarith.comp_source) := sorry --non-trivial
lemma new_lemma_3795 (h0 : topological_space (has_dist (option (option (option (option (option congr_arg_kind))))))) : totally_disconnected_space (has_dist (option (option (option (option (option congr_arg_kind)))))) := sorry --non-trivial
lemma new_lemma_3796 (h0 : not (multiset reducibility_hints -> false)) (h1 : multiset reducibility_hints) : multiset.subset (classical.by_contradiction' h0) h1 := sorry --non-trivial
lemma new_lemma_3797 (h0 : topological_space (linear_ordered_field (has_to_string num))) : irreducible_space (linear_ordered_field (has_to_string num)) := sorry --non-trivial
lemma new_lemma_3798 (h0 : group (measurable_space (with_bot linarith.comp_source))) : is_cyclic (measurable_space (with_bot linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_3799 (h0 : functor.add_const (cancel_comm_monoid_with_zero (preorder congr_arg_kind)) unsigned) : @unique_factorization_monoid.{0} (preorder.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (cancel_comm_monoid_with_zero.{0} (preorder.{0} congr_arg_kind)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_3800 (h0 : has_mem.mem (with_bot num) has_emptyc.emptyc) : @path_connected_space.{0} (with_bot.{0} num) (@finset.pi.empty.{1 0} Type topological_space.{0} (with_bot.{0} num) h0)  := sorry --non-trivial
lemma new_lemma_3801 (h2 : ring (denumerable (comm_ring fun_info))) : strong_rank_condition (denumerable (comm_ring fun_info)) := sorry --non-trivial
lemma new_lemma_3802 (h0 : topological_space (has_neg_part unsigned)) : t0_space (has_neg_part unsigned) := sorry --non-trivial
lemma new_lemma_3803 (h0 : cancel_comm_monoid_with_zero (add_comm_semigroup enat)) (h1 : has_lt (gcd_monoid (add_comm_semigroup enat))) : no_max_order (gcd_monoid (add_comm_semigroup enat)) := sorry --non-trivial
lemma new_lemma_3804 (h0 : function.extfun Type monoid) : @monoid.fg.{0} (add_cancel_monoid.{0} empty) (@function.extfun_app.{2 1} Type monoid.{0} h0 (add_cancel_monoid.{0} empty))  := sorry --non-trivial
lemma new_lemma_3805 (h0 : group (add_comm_monoid (semigroup pos))) : is_simple_group (add_comm_monoid (semigroup pos)) := sorry --non-trivial
lemma new_lemma_3806 (h0 : topological_space (has_pos_part (has_add pos))) : regular_space (has_pos_part (has_add pos)) := sorry --non-trivial
lemma new_lemma_3807 (h0 : fin has_zero.zero) : @is_cyclic.{1} (complete_distrib_lattice.{1} Type) (@matrix.vec_empty.{1} (group.{1} (complete_distrib_lattice.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_3808 (h0 : functor.add_const (finset (boolean_algebra.core pos)) Type) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_3809 (h0 : semiring (semi_normed_comm_ring linarith.comp_source)) (h1 : ideal (semi_normed_comm_ring linarith.comp_source)) : ideal.fg h1 := sorry --non-trivial
lemma new_lemma_3810 (h0 : group (ring (has_neg (ring (has_zero linarith.comp))))) : is_cyclic (ring (has_neg (ring (has_zero linarith.comp)))) := sorry --non-trivial
lemma new_lemma_3811 (h0 : finset (boolean_algebra pos)) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_3812 (h2 : prod string.iterator_imp string.iterator_imp) : set.diagonal string.iterator_imp h2 := sorry --non-trivial
lemma new_lemma_3813 (h0 : topological_space (comm_group (option name))) : totally_disconnected_space (comm_group (option name)) := sorry --non-trivial
lemma new_lemma_3814 (h2 : ring (has_append (has_nnnorm to_additive.value_type))) : strong_rank_condition (has_append (has_nnnorm to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_3815 (h0 : fin has_zero.zero) : @is_add_cyclic.{1} (complete_distrib_lattice.{1} Type) (@matrix.vec_empty.{1} (add_group.{1} (complete_distrib_lattice.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_3816 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_noetherian_ring.{0} (has_add.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type semiring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 semiring.{0}) (has_add.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_3817 (h0 : ring (random_gen (has_norm (has_norm empty)))) : rank_condition (random_gen (has_norm (has_norm empty))) := sorry --non-trivial
lemma new_lemma_3818 (h0 : ring (has_nndist real)) : rank_condition (has_nndist real) := sorry --non-trivial
lemma new_lemma_3819 (h0 : topological_space (ring (option ennreal))) : normal_space (ring (option ennreal)) := sorry --non-trivial
lemma new_lemma_3820 (h0 : complete_lattice (cancel_monoid (has_add unsigned))) : is_compactly_generated (cancel_monoid (has_add unsigned)) := sorry --non-trivial
lemma new_lemma_3821 (h0 : function.extfun Type topological_space) : @totally_separated_space.{0} (add_cancel_monoid.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (add_cancel_monoid.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_3822 (h0 : topological_space (semigroup (has_add Type))) : topological_space.separable_space (semigroup (has_add Type)) := sorry --non-trivial
lemma new_lemma_3823 (h0 : topological_space (topological_space int)) : t0_space (topological_space int) := sorry --non-trivial
lemma new_lemma_3824 (h0 : has_mem.mem (has_norm congr_arg_kind) has_emptyc.emptyc) : @is_compactly_generated.{0} (has_norm.{0} congr_arg_kind) (@finset.pi.empty.{1 0} Type complete_lattice.{0} (has_norm.{0} congr_arg_kind) h0)  := sorry --non-trivial
lemma new_lemma_3825 (h0 : topological_space (has_neg congr_arg_kind)) : locally_compact_space (has_neg congr_arg_kind) := sorry --non-trivial
lemma new_lemma_3826 (h0 : functor.add_const (topological_space (has_nndist linarith.comp)) Type) : @preirreducible_space.{0} (has_nndist.{0} linarith.comp) (@functor.add_const.run.{0 1} (topological_space.{0} (has_nndist.{0} linarith.comp)) Type h0)  := sorry --non-trivial
lemma new_lemma_3827 (h0 : functor.add_const (topological_space ennreal) unsigned) : path_connected_space ennreal := sorry --non-trivial
lemma new_lemma_3828 (h0 : has_lt (mul_one_class (normed_field std_gen))) : no_max_order (mul_one_class (normed_field std_gen)) := sorry --non-trivial
lemma new_lemma_3829 (h0 : ordered_add_comm_monoid (boolean_algebra (has_pos_part (has_pos_part linarith.comp)))) : archimedean (boolean_algebra (has_pos_part (has_pos_part linarith.comp))) := sorry --non-trivial
lemma new_lemma_3830 (h0 : function.extfun Type finset) : finset.nonempty (function.extfun_app h0 (has_to_string name)) := sorry --non-trivial
lemma new_lemma_3831 (h0 : functor.add_const (complete_lattice (has_nndist unsigned)) (finset linarith.comp)) : @is_atomistic.{0} (has_nndist.{0} unsigned) (@functor.add_const.run.{0 0} (complete_lattice.{0} (has_nndist.{0} unsigned)) (finset.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_3832 (h0 : functor.comp group add_comm_monoid environment.implicit_infer_kind) : @group.fg.{0} (add_comm_monoid.{0} environment.implicit_infer_kind) (@functor.comp.run.{0 0 0} group.{0} add_comm_monoid.{0} environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_3833 (h0 : ring (add_cancel_monoid (boolean_algebra (has_add pos)))) : is_domain (add_cancel_monoid (boolean_algebra (has_add pos))) := sorry --non-trivial
lemma new_lemma_3834 (h0 : topological_space (has_emptyc num)) : path_connected_space (has_emptyc num) := sorry --non-trivial
lemma new_lemma_3835 (h0 : topological_space (has_neg (has_to_string Type))) : discrete_topology (has_neg (has_to_string Type)) := sorry --non-trivial
lemma new_lemma_3836 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @add_monoid.fg.{0} (pseudo_metric_space.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type add_monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 add_monoid.{0}) (pseudo_metric_space.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_3837 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_domain.{0} (has_nndist.{0} linarith.comp) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (has_nndist.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_3838 (h0 : functor.add_const (group (left_cancel_monoid num)) num) : @normalizer_condition.{0} (left_cancel_monoid.{0} num) (@functor.add_const.run.{0 0} (group.{0} (left_cancel_monoid.{0} num)) num h0)  := sorry --non-trivial
lemma new_lemma_3839 (h0 : function.extfun linarith.comp_source (fun (x : linarith.comp_source), Prop)) (h1 : filter linarith.comp_source) : filter.frequently (function.extfun_app h0) h1 := sorry --non-trivial
lemma new_lemma_3840 (h0 : functor.add_const (finset (has_nndist linarith.comp)) linarith.comp) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_3841 (h0 : prod (has_sub empty) (has_sub empty)) : id_rel h0 := sorry --non-trivial
lemma new_lemma_3842 (h0 : nat) (h1 : heq h0 has_zero.zero) (h2 : fin h0) : matrix.vec_empty (heq.elim h1 h2) := sorry --non-trivial
lemma new_lemma_3843 (h0 : functor.add_const (topological_space (boolean_algebra Type)) pos) : @irreducible_space.{1} (boolean_algebra.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (boolean_algebra.{1} Type)) pos h0)  := sorry --non-trivial
lemma new_lemma_3844 (h0 : not (topological_space (has_nnnorm fun_info) -> false)) : @totally_disconnected_space.{0} (has_nnnorm.{0} fun_info) (@classical.by_contradiction'.{1} (topological_space.{0} (has_nnnorm.{0} fun_info)) h0)  := sorry --non-trivial
lemma new_lemma_3845 (h0 : add_group (has_to_string (add_comm_monoid Type))) : is_add_cyclic (has_to_string (add_comm_monoid Type)) := sorry --non-trivial
lemma new_lemma_3846 (h0 : ring (has_bot (has_Inf (has_Inf (has_Inf Type))))) : strong_rank_condition (has_bot (has_Inf (has_Inf (has_Inf Type)))) := sorry --non-trivial
lemma new_lemma_3847 (h0 : topological_space (has_emptyc string_imp)) : path_connected_space (has_emptyc string_imp) := sorry --non-trivial
lemma new_lemma_3848 (h0 : filter (semiring (semiring (has_norm linarith.comp)))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_3849 (h0 : uniform_space (has_union (semiring num))) : separated_space (has_union (semiring num)) := sorry --non-trivial
lemma new_lemma_3850 (h0 : function.extfun Type group) : @is_simple_group.{0} (has_zero.{0} (option.{0} pos)) (@function.extfun_app.{2 1} Type group.{0} h0 (has_zero.{0} (option.{0} pos)))  := sorry --non-trivial
lemma new_lemma_3851 (h0 : topological_space (has_neg (has_Inf (ring (boolean_algebra.core Type))))) : regular_space (has_neg (has_Inf (ring (boolean_algebra.core Type)))) := sorry --non-trivial
lemma new_lemma_3852 (h0 : not (topological_space fun_info -> false)) : @irreducible_space.{0} fun_info (@classical.by_contradiction'.{1} (topological_space.{0} fun_info) h0)  := sorry --non-trivial
lemma new_lemma_3853 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_noetherian_ring.{0} (comm_group.{0} unsigned) (@function.extfun_app.{2 1} Type semiring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 semiring.{0}) (comm_group.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_3854 (h0 : complete_lattice (normed_group (random_gen (has_inv linarith.comp_source)))) : is_compactly_generated (normed_group (random_gen (has_inv linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_3855 (h0 : topological_space (has_zero (finset linarith.comp))) : t0_space (has_zero (finset linarith.comp)) := sorry --non-trivial
lemma new_lemma_3856 (h0 : topological_space (has_norm (random_gen (random_gen linarith.ineq)))) : t0_space (has_norm (random_gen (random_gen linarith.ineq))) := sorry --non-trivial
lemma new_lemma_3857 (h0 : function.extfun Type topological_space) : @preconnected_space.{0} (canonically_ordered_comm_semiring.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (canonically_ordered_comm_semiring.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_3858 (h0 : function.extfun (Type 1) topological_space) : @topological_space.separable_space.{1} (comm_semigroup.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} h0 (comm_semigroup.{1} Type))  := sorry --non-trivial
lemma new_lemma_3859 (h0 : ring occurrences) : is_domain occurrences := sorry --non-trivial
lemma new_lemma_3860 (h0 : topological_space (non_unital_non_assoc_semiring fun_info)) : t0_space (non_unital_non_assoc_semiring fun_info) := sorry --non-trivial
lemma new_lemma_3861 (h0 : list (has_nndist (finset linarith.comp))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_3862 (h0 : mul_zero_class (has_top unsigned) -> mul_zero_class (has_top unsigned) -> Prop) : is_strict_order (mul_zero_class (has_top unsigned)) h0 := sorry --non-trivial
lemma new_lemma_3863 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @monoid.fg.{0} (ring.{0} (option.{0} num)) (@function.extfun_app.{2 1} Type monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 monoid.{0}) (ring.{0} (option.{0} num)))  := sorry --non-trivial
lemma new_lemma_3864 (h0 : topological_space (has_Inf (has_Inf real))) : preirreducible_space (has_Inf (has_Inf real)) := sorry --non-trivial
lemma new_lemma_3865 (h0 : topological_space (boolean_algebra (finset Type))) : sequential_space (boolean_algebra (finset Type)) := sorry --non-trivial
lemma new_lemma_3866 (h0 : complete_lattice (ordered_cancel_add_comm_monoid (option (option (option (option ennreal)))))) : is_compactly_generated (ordered_cancel_add_comm_monoid (option (option (option (option ennreal))))) := sorry --non-trivial
lemma new_lemma_3867 (h0 : topological_space (add_comm_monoid (option (option ennreal)))) : preirreducible_space (add_comm_monoid (option (option ennreal))) := sorry --non-trivial
lemma new_lemma_3868 (h0 : functor.add_const (topological_space (semiring congr_arg_kind)) num) : @path_connected_space.{0} (semiring.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (semiring.{0} congr_arg_kind)) num h0)  := sorry --non-trivial
lemma new_lemma_3869 (h0 : function.extfun Type add_group) : @is_add_cyclic.{0} (with_one.{0} num) (@function.extfun_app.{2 1} Type add_group.{0} h0 (with_one.{0} num))  := sorry --non-trivial
lemma new_lemma_3870 (h0 : cancel_comm_monoid_with_zero (plift (has_edist empty))) : unique_factorization_monoid (plift (has_edist empty)) := sorry --non-trivial
lemma new_lemma_3871 (h1 : topological_space (encodable to_additive.value_type)) : t0_space (encodable to_additive.value_type) := sorry --non-trivial
lemma new_lemma_3872 (h0 : semiring (has_add (has_neg linarith.comp))) : is_noetherian_ring (has_add (has_neg linarith.comp)) := sorry --non-trivial
lemma new_lemma_3873 (h0 : list (has_star (semiring (semiring congr_arg_kind)))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_3874 (h0 : complete_lattice (linear_ordered_comm_group empty)) : complete_lattice.is_Sup_finite_compact (linear_ordered_comm_group empty) := sorry --non-trivial
lemma new_lemma_3875 (h0 : list (finset (ring pos))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_3876 (h0 : topological_space (option pos)) : t0_space (option pos) := sorry --non-trivial
lemma new_lemma_3877 (h0 : monoid (add_left_cancel_semigroup (semiring empty))) : monoid.fg (add_left_cancel_semigroup (semiring empty)) := sorry --non-trivial
lemma new_lemma_3878 (h0 : ring (has_one (has_norm empty))) : rank_condition (has_one (has_norm empty)) := sorry --non-trivial
lemma new_lemma_3879 (h0 : topological_space (dlist (has_ssubset fun_info))) : t0_space (dlist (has_ssubset fun_info)) := sorry --non-trivial
lemma new_lemma_3880 (h0 : topological_space (has_neg Type)) : loc_path_connected_space (has_neg Type) := sorry --non-trivial
lemma new_lemma_3881 (h0 : function.extfun nat fin) : @regular_space.{0} (has_bot.{0} pos) (@matrix.vec_empty.{0} (topological_space.{0} (has_bot.{0} pos)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_3882 (h0 : function.extfun Type semiring) : @is_noetherian_ring.{0} (linear_ordered_comm_ring.{0} num) (@function.extfun_app.{2 1} Type semiring.{0} h0 (linear_ordered_comm_ring.{0} num))  := sorry --non-trivial
lemma new_lemma_3883 (h0 : ring (pseudo_metric_space (option (option (option pos))))) : is_domain (pseudo_metric_space (option (option (option pos)))) := sorry --non-trivial
lemma new_lemma_3884 (h0 : filter (random_gen (semiring unsigned))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_3885 (h0 : function.extfun Type (functor.add_const (topological_space (linear_ordered_comm_monoid_with_zero unsigned)))) : @locally_compact_space.{0} (linear_ordered_comm_monoid_with_zero.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (linear_ordered_comm_monoid_with_zero.{0} unsigned)) empty (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (topological_space.{0} (linear_ordered_comm_monoid_with_zero.{0} unsigned))) h0 empty))  := sorry --non-trivial
lemma new_lemma_3886 (h0 : functor.add_const (monoid (has_pos_part Type)) Type) : @monoid.fg.{1} (has_pos_part.{1} Type) (@functor.add_const.run.{1 1} (monoid.{1} (has_pos_part.{1} Type)) Type h0)  := sorry --non-trivial
lemma new_lemma_3887 (h3 h4 : multiset (add_comm_semigroup (mul_one_class ereal))) : multiset.disjoint h3 h4 := sorry --non-trivial
lemma new_lemma_3888 (h0 : functor.comp add_monoid ring name) : @add_monoid.fg.{0} (ring.{0} name) (@functor.comp.run.{0 0 0} add_monoid.{0} ring.{0} name h0)  := sorry --non-trivial
lemma new_lemma_3889 (h0 : topological_space (comm_semigroup (has_bot pos))) : topological_space.separable_space (comm_semigroup (has_bot pos)) := sorry --non-trivial
lemma new_lemma_3890 (h0 : functor.add_const (function.extfun (Type 1) ring) Type) : @rank_condition.{1} (add_cancel_monoid.{1} Type) (@function.extfun_app.{3 2} (Type 1) ring.{1} (@functor.add_const.run.{2 1} (function.extfun.{3 2} (Type 1) ring.{1}) Type h0) (add_cancel_monoid.{1} Type))  := sorry --non-trivial
lemma new_lemma_3891 (h0 : group (linear_ordered_field num)) : is_simple_group (linear_ordered_field num) := sorry --non-trivial
lemma new_lemma_3892 (h0 : complete_lattice (semigroup (semiring (semiring (semiring (semiring unsigned)))))) : is_atomistic (semigroup (semiring (semiring (semiring (semiring unsigned))))) := sorry --non-trivial
lemma new_lemma_3893 (h0 : ordered_comm_monoid (mul_zero_class (mul_zero_class unsigned))) : has_exists_mul_of_le (mul_zero_class (mul_zero_class unsigned)) := sorry --non-trivial
lemma new_lemma_3894 (h0 : group (measurable_space (has_norm (semiring num)))) : is_cyclic (measurable_space (has_norm (semiring num))) := sorry --non-trivial
lemma new_lemma_3895 (h0 : heq (has_inter linarith.comp_source) (denumerable (comm_ring reducibility_hints))) (h1 : not (topological_space (has_inter linarith.comp_source) -> false)) : @t0_space.{0} (denumerable.{0} (comm_ring.{0} reducibility_hints)) (@heq.elim.{2 1} Type (has_inter.{0} linarith.comp_source) topological_space.{0} (denumerable.{0} (comm_ring.{0} reducibility_hints)) h0 (@classical.by_contradiction'.{1} (topological_space.{0} (has_inter.{0} linarith.comp_source)) h1))  := sorry --non-trivial
lemma new_lemma_3896 (h0 : group (boolean_algebra (has_to_string (ring (has_add linarith.comp))))) : is_cyclic (boolean_algebra (has_to_string (ring (has_add linarith.comp)))) := sorry --non-trivial
lemma new_lemma_3897 (h0 : group (add_cancel_comm_monoid (has_nnnorm (has_nnnorm linarith.ineq)))) : is_cyclic (add_cancel_comm_monoid (has_nnnorm (has_nnnorm linarith.ineq))) := sorry --non-trivial
lemma new_lemma_3898 (h0 : finset (has_pos_part pos)) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_3899 (h0 : cancel_comm_monoid_with_zero (has_neg (finset (has_neg (has_add linarith.comp))))) : unique_factorization_monoid (has_neg (finset (has_neg (has_add linarith.comp)))) := sorry --non-trivial
lemma new_lemma_3900 (h0 : complete_lattice (random_gen (random_gen to_additive.value_type))) : is_compactly_generated (random_gen (random_gen to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_3901 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @complete_space.{0} (normed_group.{0} num) (@function.extfun_app.{2 1} Type uniform_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 uniform_space.{0}) (normed_group.{0} num))  := sorry --non-trivial
lemma new_lemma_3902 (h0 : functor.add_const (ordered_add_comm_monoid (add_cancel_monoid name)) (has_neg pos)) : @archimedean.{0} (add_cancel_monoid.{0} name) (@functor.add_const.run.{0 0} (ordered_add_comm_monoid.{0} (add_cancel_monoid.{0} name)) (has_neg.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_3903 (h0 : topological_space (semiring (has_norm empty))) : locally_compact_space (semiring (has_norm empty)) := sorry --non-trivial
lemma new_lemma_3904 (h0 : semiring ereal) (h1 : ereal) : odd h1 := sorry --non-trivial
lemma new_lemma_3905 (h0 : functor.add_const (topological_space (has_add Type)) (has_neg pos)) : @discrete_topology.{1} (has_add.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (has_add.{1} Type)) (has_neg.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_3906 (h0 : topological_space (has_neg (boolean_algebra pos))) : discrete_topology (has_neg (boolean_algebra pos)) := sorry --non-trivial
lemma new_lemma_3907 (h0 : complete_lattice (has_nndist environment.implicit_infer_kind)) : complete_lattice.is_Sup_finite_compact (has_nndist environment.implicit_infer_kind) := sorry --non-trivial
lemma new_lemma_3908 (h1 : not (complete_lattice (denumerable to_additive.value_type) -> false)) : @complete_lattice.is_Sup_finite_compact.{0} (denumerable.{0} to_additive.value_type) (@classical.by_contradiction'.{1} (complete_lattice.{0} (denumerable.{0} to_additive.value_type)) h1)  := sorry --non-trivial
lemma new_lemma_3909 (h0 : topological_space (dlist linarith.ineq)) : totally_separated_space (dlist linarith.ineq) := sorry --non-trivial
lemma new_lemma_3910 (h0 : uniform_space (add_right_cancel_monoid (semiring unsigned))) : separated_space (add_right_cancel_monoid (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_3911 (h0 : ordered_comm_monoid (boolean_algebra.core (complete_distrib_lattice Type))) : has_exists_mul_of_le (boolean_algebra.core (complete_distrib_lattice Type)) := sorry --non-trivial
lemma new_lemma_3912 (h0 : not (has_mem.mem (random_gen congr_arg_kind) has_emptyc.emptyc -> false)) : @separated_space.{0} (random_gen.{0} congr_arg_kind) (@finset.pi.empty.{1 0} Type uniform_space.{0} (random_gen.{0} congr_arg_kind) (@classical.by_contradiction'.{0} (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (random_gen.{0} congr_arg_kind) (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))) h0))  := sorry --non-trivial
lemma new_lemma_3913 (h0 : topological_space (nondiscrete_normed_field (add_comm_semigroup (add_comm_semigroup fun_info)))) : t0_space (nondiscrete_normed_field (add_comm_semigroup (add_comm_semigroup fun_info))) := sorry --non-trivial
lemma new_lemma_3914 (h2 : group linarith.comp_source) : is_cyclic linarith.comp_source := sorry --non-trivial
lemma new_lemma_3915 (h0 : functor.add_const (semiring (has_nndist ennreal)) empty) : @is_noetherian_ring.{0} (has_nndist.{0} ennreal) (@functor.add_const.run.{0 0} (semiring.{0} (has_nndist.{0} ennreal)) empty h0)  := sorry --non-trivial
lemma new_lemma_3916 (h0 : function.extfun Type complete_lattice) : @complete_lattice.is_Sup_finite_compact.{0} (has_Inf.{0} name) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (has_Inf.{0} name))  := sorry --non-trivial
lemma new_lemma_3917 (h0 : functor.add_const (topological_space (boolean_algebra.core name)) pos) : @regular_space.{0} (boolean_algebra.core.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (boolean_algebra.core.{0} name)) pos h0)  := sorry --non-trivial
lemma new_lemma_3918 (h0 : functor.add_const (topological_space (has_pos_part linarith.comp)) name) : @preconnected_space.{0} (has_pos_part.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (has_pos_part.{0} linarith.comp)) name h0)  := sorry --non-trivial
lemma new_lemma_3919 (h0 : list (pseudo_metric_space (add_comm_monoid (option (option ennreal))))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_3920 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_principal_ideal_ring.{0} (boolean_algebra.{0} unsigned) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (boolean_algebra.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_3921 (h1 : complete_lattice (add_left_cancel_monoid (random_gen to_additive.value_type))) : complete_lattice.is_Sup_finite_compact (add_left_cancel_monoid (random_gen to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_3922 (h0 : function.extfun (uniform_space (id empty) -> false) (fun (x : uniform_space (id empty) -> false), false)) : @complete_space.{0} (@id.{2} Type empty) (@classical.by_contradiction'.{1} (uniform_space.{0} (@id.{2} Type empty)) (@function.extfun_app.{0 0} (uniform_space.{0} (@id.{2} Type empty) → false) (λ (x : uniform_space.{0} (@id.{2} Type empty) → false), false) h0))  := sorry --non-trivial
lemma new_lemma_3923 (h0 : ring (has_zero (finset pos))) : strong_rank_condition (has_zero (finset pos)) := sorry --non-trivial
lemma new_lemma_3924 (h1 : topological_space (has_lt linarith.ineq)) : t0_space (has_lt linarith.ineq) := sorry --non-trivial
lemma new_lemma_3925 (h0 : monoid (has_add (has_neg name))) : monoid.fg (has_add (has_neg name)) := sorry --non-trivial
lemma new_lemma_3926 (h0 : topological_space (ordered_comm_monoid (sub_neg_monoid name))) : loc_path_connected_space (ordered_comm_monoid (sub_neg_monoid name)) := sorry --non-trivial
lemma new_lemma_3927 (h0 : uniform_space (group_with_zero (option (option num)))) : complete_space (group_with_zero (option (option num))) := sorry --non-trivial
lemma new_lemma_3928 (h0 : topological_space (canonically_ordered_monoid (has_neg real))) : t0_space (canonically_ordered_monoid (has_neg real)) := sorry --non-trivial
lemma new_lemma_3929 (h0 : group (mul_zero_class (add_cancel_monoid (finset environment.implicit_infer_kind)))) : normalizer_condition (mul_zero_class (add_cancel_monoid (finset environment.implicit_infer_kind))) := sorry --non-trivial
lemma new_lemma_3930 (h0 : topological_space (linear_ordered_add_comm_monoid_with_top (option empty))) : totally_disconnected_space (linear_ordered_add_comm_monoid_with_top (option empty)) := sorry --non-trivial
lemma new_lemma_3931 (h0 : has_mem.mem complete_lattice has_emptyc.emptyc) : @is_atomistic.{0} (has_top.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) complete_lattice.{0} h0) (has_top.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_3932 (h0 : topological_space (mul_zero_class (finset (finset (finset pos))))) : totally_separated_space (mul_zero_class (finset (finset (finset pos)))) := sorry --non-trivial
lemma new_lemma_3933 (h0 : function.extfun Type topological_space) : @normal_space.{0} (free_add_monoid.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (free_add_monoid.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_3934 (h0 : ring (boolean_algebra (ring name))) : is_principal_ideal_ring (boolean_algebra (ring name)) := sorry --non-trivial
lemma new_lemma_3935 (h0 : add_group (denumerable (has_top fun_info))) : is_add_cyclic (denumerable (has_top fun_info)) := sorry --non-trivial
lemma new_lemma_3936 (h0 : complete_lattice (semiring (has_one num))) : is_atomistic (semiring (has_one num)) := sorry --non-trivial
lemma new_lemma_3937 (h0 : complete_lattice (add_comm_monoid unsigned)) : is_atomistic (add_comm_monoid unsigned) := sorry --non-trivial
lemma new_lemma_3938 (h0 : complete_lattice (random_gen string_imp)) : is_compactly_generated (random_gen string_imp) := sorry --non-trivial
lemma new_lemma_3939 (h0 : not (has_mem.mem fun_info has_emptyc.emptyc -> false)) : @is_compactly_generated.{0} fun_info (@finset.pi.empty.{1 0} Type complete_lattice.{0} fun_info (@classical.by_contradiction'.{0} (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) fun_info (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))) h0))  := sorry --non-trivial
lemma new_lemma_3940 (h0 : functor.add_const (functor.add_const (uniform_space environment.implicit_infer_kind) linarith.comp) (has_add Type)) : @separated_space.{0} environment.implicit_infer_kind (@functor.add_const.run.{0 0} (uniform_space.{0} environment.implicit_infer_kind) linarith.comp (@functor.add_const.run.{0 1} (functor.add_const.{0 0} (uniform_space.{0} environment.implicit_infer_kind) linarith.comp) (has_add.{1} Type) h0))  := sorry --non-trivial
lemma new_lemma_3941 (h0 : functor.add_const (topological_space (semigroup Type)) Type) : @t1_space.{1} (semigroup.{1} Type) (@functor.add_const.run.{1 1} (topological_space.{1} (semigroup.{1} Type)) Type h0)  := sorry --non-trivial
lemma new_lemma_3942 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @discrete_topology.{0} (linear_ordered_comm_ring.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (linear_ordered_comm_ring.{0} empty))  := sorry --non-trivial
lemma new_lemma_3943 (h0 : functor.add_const Prop (canonically_ordered_monoid real)) : functor.add_const.run h0 := sorry --non-trivial
lemma new_lemma_3944 (h0 : ring (finset (finset (has_add Type)))) : is_principal_ideal_ring (finset (finset (has_add Type))) := sorry --non-trivial
lemma new_lemma_3945 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : irreducible_space nnreal := sorry --non-trivial
lemma new_lemma_3946 (h0 : functor.add_const (topological_space (has_add linarith.comp)) Type) : @t1_space.{0} (has_add.{0} linarith.comp) (@functor.add_const.run.{0 1} (topological_space.{0} (has_add.{0} linarith.comp)) Type h0)  := sorry --non-trivial
lemma new_lemma_3947 (h1 : topological_space (add_monoid linarith.comp_source)) : path_connected_space (add_monoid linarith.comp_source) := sorry --non-trivial
lemma new_lemma_3948 (h0 : group (add_cancel_comm_monoid (random_gen (has_nnnorm linarith.ineq)))) : is_cyclic (add_cancel_comm_monoid (random_gen (has_nnnorm linarith.ineq))) := sorry --non-trivial
lemma new_lemma_3949 (h0 : topological_space (add_cancel_monoid (has_add Type))) : totally_disconnected_space (add_cancel_monoid (has_add Type)) := sorry --non-trivial
lemma new_lemma_3950 (h0 : not (has_mem.mem (semiring fun_info) has_emptyc.emptyc -> false)) : @path_connected_space.{0} (semiring.{0} fun_info) (@finset.pi.empty.{1 0} Type topological_space.{0} (semiring.{0} fun_info) (@classical.by_contradiction'.{0} (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (semiring.{0} fun_info) (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))) h0))  := sorry --non-trivial
lemma new_lemma_3951 (h0 : complete_lattice (measurable_space (random_gen (random_gen (random_gen linarith.ineq))))) : is_atomistic (measurable_space (random_gen (random_gen (random_gen linarith.ineq)))) := sorry --non-trivial
lemma new_lemma_3952 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_add_cyclic.{0} (has_star.{0} num) (@function.extfun_app.{2 1} Type add_group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 add_group.{0}) (has_star.{0} num))  := sorry --non-trivial
lemma new_lemma_3953 (h0 : filter (canonically_ordered_comm_semiring (has_add (finset ennreal)))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_3954 (h0 : ring (semigroup (comm_group name))) : strong_rank_condition (semigroup (comm_group name)) := sorry --non-trivial
lemma new_lemma_3955 (h0 : complete_lattice (pseudo_metric_space (option unsigned))) : complete_lattice.is_Sup_finite_compact (pseudo_metric_space (option unsigned)) := sorry --non-trivial
lemma new_lemma_3956 (h0 : functor.add_const (ordered_comm_monoid (ordered_comm_ring pos)) (has_Inf name)) : @has_exists_mul_of_le.{0} (ordered_comm_ring.{0} pos) (@functor.add_const.run.{0 0} (ordered_comm_monoid.{0} (ordered_comm_ring.{0} pos)) (has_Inf.{0} name) h0)  := sorry --non-trivial
lemma new_lemma_3957 (h0 : topological_space (has_neg_part unsigned)) : normal_space (has_neg_part unsigned) := sorry --non-trivial
lemma new_lemma_3958 (h0 : enat -> enat -> Prop) : equivalence h0 := sorry --non-trivial
lemma new_lemma_3959 (h1 : topological_space (distrib to_additive.value_type)) : path_connected_space (distrib to_additive.value_type) := sorry --non-trivial
lemma new_lemma_3960 (h0 : group (normed_group (has_nnnorm (has_nnnorm to_additive.value_type)))) : group.fg (normed_group (has_nnnorm (has_nnnorm to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_3961 (h0 : uniform_space (complete_distrib_lattice (has_neg name))) : complete_space (complete_distrib_lattice (has_neg name)) := sorry --non-trivial
lemma new_lemma_3962 (h0 : not (topological_space (measurable_space.dynkin_system unsigned) -> false)) : @path_connected_space.{0} (measurable_space.dynkin_system.{0} unsigned) (@classical.by_contradiction'.{1} (topological_space.{0} (measurable_space.dynkin_system.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_3963 (h0 : complete_lattice (has_pos_part (has_Inf real))) : is_compactly_generated (has_pos_part (has_Inf real)) := sorry --non-trivial
lemma new_lemma_3964 (h0 : topological_space (ordered_comm_monoid (ring Type))) : regular_space (ordered_comm_monoid (ring Type)) := sorry --non-trivial
lemma new_lemma_3965 (h0 : topological_space (metric_space linarith.comp)) : t0_space (metric_space linarith.comp) := sorry --non-trivial
lemma new_lemma_3966 (h0 : has_lt (has_lt (mul_one_class (mul_one_class char)))) : no_max_order (has_lt (mul_one_class (mul_one_class char))) := sorry --non-trivial
lemma new_lemma_3967 (h0 : functor.add_const (complete_lattice (has_dist unsigned)) congr_arg_kind) : @is_atomistic.{0} (has_dist.{0} unsigned) (@functor.add_const.run.{0 0} (complete_lattice.{0} (has_dist.{0} unsigned)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_3968 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @archimedean.{0} (has_to_string.{0} unsigned) (@function.extfun_app.{2 1} Type ordered_add_comm_monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ordered_add_comm_monoid.{0}) (has_to_string.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_3969 (h1 : function.extfun (finset Type) (has_mem.mem num)) : @separated_space.{0} num (@finset.pi.empty.{1 0} Type uniform_space.{0} num (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) num) h1 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_3970 (h0 : list (boolean_algebra (comm_group Type))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_3971 (h0 : ring (normed_linear_ordered_group empty)) : is_domain (normed_linear_ordered_group empty) := sorry --non-trivial
lemma new_lemma_3972 (h0 : function.extfun Type (functor.add_const Prop)) : functor.add_const.run (function.extfun_app h0 (has_neg ennreal)) := sorry --non-trivial
lemma new_lemma_3973 (h0 : group (ring (add_comm_monoid environment.implicit_infer_kind))) : normalizer_condition (ring (add_comm_monoid environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_3974 (h2 : measurable_space fun_info) (h3 : measure_theory.measure fun_info) : measure_theory.is_finite_measure h3 := sorry --non-trivial
lemma new_lemma_3975 (h0 : functor.add_const (topological_space (ring pos)) (normed_linear_ordered_group environment.implicit_infer_kind)) : @t1_space.{0} (ring.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (ring.{0} pos)) (normed_linear_ordered_group.{0} environment.implicit_infer_kind) h0)  := sorry --non-trivial
lemma new_lemma_3976 (h0 : uniform_space (with_zero linarith.ineq)) : complete_space (with_zero linarith.ineq) := sorry --non-trivial
lemma new_lemma_3977 (h0 : topological_space (normed_group (with_bot (with_bot to_additive.value_type)))) : path_connected_space (normed_group (with_bot (with_bot to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_3978 (h0 : functor.add_const (topological_space (measurable_space.dynkin_system unsigned)) congr_arg_kind) : @t1_space.{0} (measurable_space.dynkin_system.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (measurable_space.dynkin_system.{0} unsigned)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_3979 (h0 : group (cancel_monoid pos)) : is_simple_group (cancel_monoid pos) := sorry --non-trivial
lemma new_lemma_3980 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @monoid.fg.{0} (denumerable.{0} string_imp) (@function.extfun_app.{2 1} Type monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 monoid.{0}) (denumerable.{0} string_imp))  := sorry --non-trivial
lemma new_lemma_3981 (h1 : not (group Type -> false)) : @group.fg.{1} Type (@classical.by_contradiction'.{2} (group.{1} Type) h1)  := sorry --non-trivial
lemma new_lemma_3982 (h2 : function.extfun Type topological_space) : @locally_compact_space.{0} (with_one.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type topological_space.{0} h2 (with_one.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_3983 (h0 : function.extfun Type semiring) : @is_noetherian_ring.{0} (normed_lattice_add_comm_group.{0} pos) (@function.extfun_app.{2 1} Type semiring.{0} h0 (normed_lattice_add_comm_group.{0} pos))  := sorry --non-trivial
lemma new_lemma_3984 (h0 : functor.add_const (function.extfun (Type 1) group) (has_add (has_neg_part Type))) : @group.fg.{1} (has_zero.{1} Type) (@function.extfun_app.{3 2} (Type 1) group.{1} (@functor.add_const.run.{2 1} (function.extfun.{3 2} (Type 1) group.{1}) (has_add.{1} (has_neg_part.{1} Type)) h0) (has_zero.{1} Type))  := sorry --non-trivial
lemma new_lemma_3985 (h0 : not (function.extfun Type monoid -> false)) : @monoid.fg.{0} (semiring.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type monoid.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type monoid.{0}) h0) (semiring.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_3986 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @t1_space.{0} (linear_ordered_comm_monoid_with_zero.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (linear_ordered_comm_monoid_with_zero.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_3987 (h0 : topological_space (add_comm_monoid (finset Type))) : topological_space.separable_space (add_comm_monoid (finset Type)) := sorry --non-trivial
lemma new_lemma_3988 (h0 : uniform_space (has_neg Type)) : separated_space (has_neg Type) := sorry --non-trivial
lemma new_lemma_3989 (h0 : group (fintype (has_nnnorm (random_gen linarith.ineq)))) : group.fg (fintype (has_nnnorm (random_gen linarith.ineq))) := sorry --non-trivial
lemma new_lemma_3990 (h0 : not (ring (pseudo_emetric_space congr_arg_kind) -> false)) : @strong_rank_condition.{0} (pseudo_emetric_space.{0} congr_arg_kind) (@classical.by_contradiction'.{1} (ring.{0} (pseudo_emetric_space.{0} congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_3991 (h0 : functor.comp ring normed_comm_ring Type) : @strong_rank_condition.{1} (normed_comm_ring.{1} Type) (@functor.comp.run.{1 1 1} ring.{1} normed_comm_ring.{1} Type h0)  := sorry --non-trivial
lemma new_lemma_3992 (h0 : group (has_ssubset (comm_ring (metric_space reducibility_hints)))) : is_cyclic (has_ssubset (comm_ring (metric_space reducibility_hints))) := sorry --non-trivial
lemma new_lemma_3993 (h0 : topological_space (denumerable (random_gen to_additive.value_type))) : path_connected_space (denumerable (random_gen to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_3994 (h0 : uniform_space (with_one (random_gen linarith.comp_source))) : complete_space (with_one (random_gen linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_3995 (h0 : ring (ring (finset (finset linarith.comp)))) : is_domain (ring (finset (finset linarith.comp))) := sorry --non-trivial
lemma new_lemma_3996 (h0 : boolean_algebra.core (has_zero congr_arg_kind) -> boolean_algebra.core (has_zero congr_arg_kind) -> Prop) : is_symm (boolean_algebra.core (has_zero congr_arg_kind)) h0 := sorry --non-trivial
lemma new_lemma_3997 (h0 : function.extfun Type topological_space) : @preirreducible_space.{0} (linear_ordered_field.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (linear_ordered_field.{0} name))  := sorry --non-trivial
lemma new_lemma_3998 (h0 : not (add_monoid (linear_ordered_semiring linarith.ineq) -> false)) : @add_monoid.fg.{0} (linear_ordered_semiring.{0} linarith.ineq) (@classical.by_contradiction'.{1} (add_monoid.{0} (linear_ordered_semiring.{0} linarith.ineq)) h0)  := sorry --non-trivial
lemma new_lemma_3999 (h0 : ring (comm_group (finset environment.implicit_infer_kind))) : strong_rank_condition (comm_group (finset environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_4000 (h0 : functor.add_const (topological_space (add_comm_monoid Type)) name) : @totally_separated_space.{1} (add_comm_monoid.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (add_comm_monoid.{1} Type)) name h0)  := sorry --non-trivial
lemma new_lemma_4001 (h0 : topological_space (ordered_comm_group (option (option unsigned)))) : totally_disconnected_space (ordered_comm_group (option (option unsigned))) := sorry --non-trivial
lemma new_lemma_4002 (h0 : topological_space (uniform_space enat)) (h1 : not (preorder (uniform_space enat) -> false)) : order_topology (uniform_space enat) := sorry --non-trivial
lemma new_lemma_4003 (h0 : function.extfun Type group) : @group.fg.{0} (ordered_cancel_add_comm_monoid.{0} unsigned) (@function.extfun_app.{2 1} Type group.{0} h0 (ordered_cancel_add_comm_monoid.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_4004 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_simple_group.{0} real (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) real)  := sorry --non-trivial
lemma new_lemma_4005 (h1 : function.extfun Type uniform_space) : @complete_space.{0} (with_one.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type uniform_space.{0} h1 (with_one.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_4006 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @path_connected_space.{0} (pseudo_metric_space.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (pseudo_metric_space.{0} num))  := sorry --non-trivial
lemma new_lemma_4007 (h0 : functor.add_const (list (has_nndist pos)) unsigned) : list.nodup (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_4008 (h1 : filter (with_one linarith.comp_source)) : filter.ne_bot h1 := sorry --non-trivial
lemma new_lemma_4009 (h0 : ring (has_top (has_top (has_top num)))) : rank_condition (has_top (has_top (has_top num))) := sorry --non-trivial
lemma new_lemma_4010 (h0 : cancel_comm_monoid_with_zero (finset (boolean_algebra pos))) : unique_factorization_monoid (finset (boolean_algebra pos)) := sorry --non-trivial
lemma new_lemma_4011 (h0 : functor.add_const (topological_space name) empty) : @normal_space.{0} name (@functor.add_const.run.{0 0} (topological_space.{0} name) empty h0)  := sorry --non-trivial
lemma new_lemma_4012 (h0 : function.extfun Type complete_lattice) : @complete_lattice.is_Sup_finite_compact.{0} linarith.ineq (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 linarith.ineq)  := sorry --non-trivial
lemma new_lemma_4013 (h0 : ring (has_neg linarith.comp_source)) : is_domain (has_neg linarith.comp_source) := sorry --non-trivial
lemma new_lemma_4014 (h0 : functor.add_const (group (has_zero Type)) Type) : @group.fg.{1} (has_zero.{1} Type) (@functor.add_const.run.{1 1} (group.{1} (has_zero.{1} Type)) Type h0)  := sorry --non-trivial
lemma new_lemma_4015 (h1 : topological_space (random_gen (random_gen linarith.ineq))) : locally_compact_space (random_gen (random_gen linarith.ineq)) := sorry --non-trivial
lemma new_lemma_4016 (h0 : not (has_mem.mem (complete_semilattice_Sup linarith.ineq) has_emptyc.emptyc -> false)) : @is_domain.{0} (complete_semilattice_Sup.{0} linarith.ineq) (@finset.pi.empty.{1 0} Type ring.{0} (complete_semilattice_Sup.{0} linarith.ineq) (@classical.by_contradiction'.{0} (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (complete_semilattice_Sup.{0} linarith.ineq) (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))) h0))  := sorry --non-trivial
lemma new_lemma_4017 (h0 : function.extfun Type complete_lattice) : @is_atomistic.{0} (linear_ordered_field.{0} empty) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (linear_ordered_field.{0} empty))  := sorry --non-trivial
lemma new_lemma_4018 (h0 : not (topological_space (dlist (has_nnnorm fun_info)) -> false)) : @totally_disconnected_space.{0} (dlist.{0} (has_nnnorm.{0} fun_info)) (@classical.by_contradiction'.{1} (topological_space.{0} (dlist.{0} (has_nnnorm.{0} fun_info))) h0)  := sorry --non-trivial
lemma new_lemma_4019 (h0 : cancel_comm_monoid_with_zero (measure_theory.measure_space unsigned)) : unique_factorization_monoid (measure_theory.measure_space unsigned) := sorry --non-trivial
lemma new_lemma_4020 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @monoid.fg.{0} (comm_group.{0} unsigned) (@function.extfun_app.{2 1} Type monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 monoid.{0}) (comm_group.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_4021 (h0 : ring (canonically_ordered_comm_semiring ennreal)) : strong_rank_condition (canonically_ordered_comm_semiring ennreal) := sorry --non-trivial
lemma new_lemma_4022 (h0 : prod (add_comm_monoid pos) (add_comm_monoid pos)) : id_rel h0 := sorry --non-trivial
lemma new_lemma_4023 (h0 : functor.add_const (ordered_add_comm_monoid (has_add pos)) (has_neg_part (has_zero Type))) : @archimedean.{0} (has_add.{0} pos) (@functor.add_const.run.{0 1} (ordered_add_comm_monoid.{0} (has_add.{0} pos)) (has_neg_part.{1} (has_zero.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_4024 (h0 : functor.add_const (topological_space (has_add environment.implicit_infer_kind)) environment.implicit_infer_kind) : @sequential_space.{0} (has_add.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (has_add.{0} environment.implicit_infer_kind)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_4025 (h0 : fin has_zero.zero) : @discrete_topology.{0} (has_add.{0} linarith.comp) (@matrix.vec_empty.{0} (topological_space.{0} (has_add.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_4026 (h0 : functor.add_const (finset (has_add name)) (has_add Type)) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_4027 (h0 : fin has_zero.zero) : @preconnected_space.{0} (add_comm_monoid.{0} linarith.comp) (@matrix.vec_empty.{0} (topological_space.{0} (add_comm_monoid.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_4028 (h0 : ring (add_cancel_monoid (semigroup (semigroup (semigroup Type))))) : is_domain (add_cancel_monoid (semigroup (semigroup (semigroup Type)))) := sorry --non-trivial
lemma new_lemma_4029 (h0 : functor.add_const (function.extfun Type ring) (finset (has_to_string Type))) : @is_principal_ideal_ring.{0} (has_nndist.{0} linarith.comp) (@function.extfun_app.{2 1} Type ring.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type ring.{0}) (finset.{1} (has_to_string.{1} Type)) h0) (has_nndist.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_4030 (h0 : topological_space (ordered_comm_monoid (ring (has_Inf (ring Type))))) : totally_separated_space (ordered_comm_monoid (ring (has_Inf (ring Type)))) := sorry --non-trivial
lemma new_lemma_4031 (h0 : topological_space (semi_normed_ring (mul_one_class (has_lt string_imp)))) : path_connected_space (semi_normed_ring (mul_one_class (has_lt string_imp))) := sorry --non-trivial
lemma new_lemma_4032 (h0 : topological_space (as_linear_order congr_arg_kind)) : irreducible_space (as_linear_order congr_arg_kind) := sorry --non-trivial
lemma new_lemma_4033 (h0 : functor.add_const (topological_space (has_nndist unsigned)) (option empty)) : @t0_space.{0} (has_nndist.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (has_nndist.{0} unsigned)) (option.{0} empty) h0)  := sorry --non-trivial
lemma new_lemma_4034 (h0 : function.extfun Type topological_space) : @totally_disconnected_space.{0} (boolean_algebra.core.{0} ennreal) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (boolean_algebra.core.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_4035 (h0 : uniform_space (has_norm (semiring (semiring (random_gen congr_arg_kind))))) : separated_space (has_norm (semiring (semiring (random_gen congr_arg_kind)))) := sorry --non-trivial
lemma new_lemma_4036 (h0 : ordered_comm_monoid (boolean_algebra (comm_group name))) : has_exists_mul_of_le (boolean_algebra (comm_group name)) := sorry --non-trivial
lemma new_lemma_4037 (h0 : functor.add_const (topological_space (has_Sup empty)) empty) : @path_connected_space.{0} (has_Sup.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (has_Sup.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_4038 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @normal_space.{0} (linear_ordered_comm_group.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (linear_ordered_comm_group.{0} empty))  := sorry --non-trivial
lemma new_lemma_4039 (h0 : ring (comm_ring (random_gen string_imp))) : is_domain (comm_ring (random_gen string_imp)) := sorry --non-trivial
lemma new_lemma_4040 (h0 : functor.add_const Prop (boolean_algebra linarith.comp)) : functor.add_const.run h0 := sorry --non-trivial
lemma new_lemma_4041 (h0 : complete_lattice (has_top (has_ssubset (has_norm (has_ssubset fun_info))))) : complete_lattice.is_Sup_finite_compact (has_top (has_ssubset (has_norm (has_ssubset fun_info)))) := sorry --non-trivial
lemma new_lemma_4042 (h0 : not (topological_space (complete_linear_order unsigned) -> false)) : @t1_space.{0} (complete_linear_order.{0} unsigned) (@classical.by_contradiction'.{1} (topological_space.{0} (complete_linear_order.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_4043 (h1 : uniform_space (distrib_lattice char)) : complete_space (distrib_lattice char) := sorry --non-trivial
lemma new_lemma_4044 (h0 : topological_space (has_norm (semiring (semiring empty)))) : irreducible_space (has_norm (semiring (semiring empty))) := sorry --non-trivial
lemma new_lemma_4045 (h0 : monoid (with_one (semiring linarith.comp))) : monoid.fg (with_one (semiring linarith.comp)) := sorry --non-trivial
lemma new_lemma_4046 (h0 : function.extfun (finset (Type -> Type)) (has_mem.mem topological_space)) : @totally_disconnected_space.{0} linarith.comp_source (@function.extfun_app.{2 1} Type topological_space.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) topological_space.{0} (@function.extfun_app.{2 0} (finset.{1} (Type → Type)) (@has_mem.mem.{1 1} (Type → Type) (finset.{1} (Type → Type)) (@finset.has_mem.{1} (Type → Type)) topological_space.{0}) h0 (@has_emptyc.emptyc.{1} (finset.{1} (Type → Type)) (@finset.has_emptyc.{1} (Type → Type))))) linarith.comp_source)  := sorry --non-trivial
lemma new_lemma_4047 (h0 : function.extfun Type (functor.comp topological_space add_cancel_monoid)) : @path_connected_space.{0} (add_cancel_monoid.{0} name) (@functor.comp.run.{0 0 0} topological_space.{0} add_cancel_monoid.{0} name (@function.extfun_app.{2 1} Type (functor.comp.{0 0 0} topological_space.{0} add_cancel_monoid.{0}) h0 name))  := sorry --non-trivial
lemma new_lemma_4048 (h0 : uniform_space (linear_ordered_add_comm_group (has_inv to_additive.value_type))) : complete_space (linear_ordered_add_comm_group (has_inv to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_4049 (h3 : complete_lattice (denumerable to_additive.value_type)) : is_compactly_generated (denumerable to_additive.value_type) := sorry --non-trivial
lemma new_lemma_4050 (h0 : group (measurable_space (has_norm (has_norm (has_norm linarith.ineq))))) : is_cyclic (measurable_space (has_norm (has_norm (has_norm linarith.ineq)))) := sorry --non-trivial
lemma new_lemma_4051 (h0 : topological_space (ordered_comm_monoid (has_Inf (has_nndist Type)))) : normal_space (ordered_comm_monoid (has_Inf (has_nndist Type))) := sorry --non-trivial
lemma new_lemma_4052 (h0 : filter (has_top (random_gen (random_gen fun_info)))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_4053 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_add_cyclic.{0} (cancel_monoid.{0} ennreal) (@function.extfun_app.{2 1} Type add_group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 add_group.{0}) (cancel_monoid.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_4054 (h0 : filter (has_top linarith.comp_source)) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_4055 (h0 : ring (denumerable (has_norm (random_gen to_additive.value_type)))) : is_domain (denumerable (has_norm (random_gen to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_4056 (h0 : function.extfun Type topological_space) : @preconnected_space.{0} (linear_ordered_field.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (linear_ordered_field.{0} pos))  := sorry --non-trivial
lemma new_lemma_4057 (h1 : has_mem.mem (has_emptyc linarith.comp) has_emptyc.emptyc) : @is_domain.{0} (has_emptyc.{0} linarith.comp) (@finset.pi.empty.{1 0} Type ring.{0} (has_emptyc.{0} linarith.comp) h1)  := sorry --non-trivial
lemma new_lemma_4058 (h0 : topological_space (has_div linarith.comp_source)) (h1 : add_group (has_div linarith.comp_source)) : topological_add_group (has_div linarith.comp_source) := sorry --non-trivial
lemma new_lemma_4059 (h0 : group (linear_ordered_comm_monoid_with_zero num)) : is_cyclic (linear_ordered_comm_monoid_with_zero num) := sorry --non-trivial
lemma new_lemma_4060 (h0 : function.extfun Type group) : @group.fg.{0} (has_emptyc.{0} string_imp) (@function.extfun_app.{2 1} Type group.{0} h0 (has_emptyc.{0} string_imp))  := sorry --non-trivial
lemma new_lemma_4061 (h0 : topological_space (monoid (option (option (option ennreal))))) : loc_path_connected_space (monoid (option (option (option ennreal)))) := sorry --non-trivial
lemma new_lemma_4062 (h0 : filter (as_linear_order unsigned)) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_4063 (h0 : ring (boolean_algebra (comm_group (comm_group (comm_group Type))))) : rank_condition (boolean_algebra (comm_group (comm_group (comm_group Type)))) := sorry --non-trivial
lemma new_lemma_4064 (h0 : ring (with_one (random_gen (has_ssubset (random_gen (random_gen to_additive.value_type)))))) : is_domain (with_one (random_gen (has_ssubset (random_gen (random_gen to_additive.value_type))))) := sorry --non-trivial
lemma new_lemma_4065 (h0 : group (has_top (random_gen (random_gen to_additive.value_type)))) : is_cyclic (has_top (random_gen (random_gen to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_4066 (h0 : functor.add_const (add_group (semigroup pos)) (has_add (has_add unsigned))) : @is_add_cyclic.{0} (semigroup.{0} pos) (@functor.add_const.run.{0 0} (add_group.{0} (semigroup.{0} pos)) (has_add.{0} (has_add.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_4067 (h0 : topological_space (has_zero environment.implicit_infer_kind)) : sequential_space (has_zero environment.implicit_infer_kind) := sorry --non-trivial
lemma new_lemma_4068 (h0 : not (topological_space (has_repr linarith.ineq) -> false)) : @totally_disconnected_space.{0} (has_repr.{0} linarith.ineq) (@classical.by_contradiction'.{1} (topological_space.{0} (has_repr.{0} linarith.ineq)) h0)  := sorry --non-trivial
lemma new_lemma_4069 (h1 : topological_space (with_one char)) : totally_disconnected_space (with_one char) := sorry --non-trivial
lemma new_lemma_4070 (h0 : filter (ordered_comm_ring (ring pos))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_4071 (h0 : not (ring (comm_ring linarith.ineq) -> false)) : @strong_rank_condition.{0} (comm_ring.{0} linarith.ineq) (@classical.by_contradiction'.{1} (ring.{0} (comm_ring.{0} linarith.ineq)) h0)  := sorry --non-trivial
lemma new_lemma_4072 (h0 : functor.add_const (group (has_zero Type)) linarith.comp) : @is_simple_group.{1} (has_zero.{1} Type) (@functor.add_const.run.{1 0} (group.{1} (has_zero.{1} Type)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_4073 (h0 : ring (add_cancel_monoid (has_add (has_add pos)))) : is_domain (add_cancel_monoid (has_add (has_add pos))) := sorry --non-trivial
lemma new_lemma_4074 (h0 : not (function.extfun Type list -> false)) : list.nodup (function.extfun_app (classical.by_contradiction' h0) (dlist fun_info)) := sorry --non-trivial
lemma new_lemma_4075 (h0 : not (filter (has_union empty) -> false)) : filter.ne_bot (classical.by_contradiction' h0) := sorry --non-trivial
lemma new_lemma_4076 (h0 : function.extfun Type complete_lattice) : @is_compactly_generated.{0} (normed_linear_ordered_group.{0} empty) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (normed_linear_ordered_group.{0} empty))  := sorry --non-trivial
lemma new_lemma_4077 (h0 : fin has_zero.zero) : @is_compactly_generated.{0} (ordered_comm_ring.{0} linarith.comp) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@matrix.vec_empty.{1} (function.extfun.{2 1} Type complete_lattice.{0}) h0) (ordered_comm_ring.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_4078 (h0 : filter (canonically_ordered_comm_semiring num)) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_4079 (h0 : not (complete_lattice (encodable linarith.ineq) -> false)) : @is_compactly_generated.{0} (encodable.{0} linarith.ineq) (@classical.by_contradiction'.{1} (complete_lattice.{0} (encodable.{0} linarith.ineq)) h0)  := sorry --non-trivial
lemma new_lemma_4080 (h0 : fin has_zero.zero) : @is_principal_ideal_ring.{1} (ordered_comm_monoid.{1} Type) (@matrix.vec_empty.{1} (ring.{1} (ordered_comm_monoid.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_4081 (h0 : topological_space (add_cancel_monoid (has_to_string (has_to_string (has_to_string pos))))) : totally_separated_space (add_cancel_monoid (has_to_string (has_to_string (has_to_string pos)))) := sorry --non-trivial
lemma new_lemma_4082 (h0 : filter (add_comm_monoid (normed_lattice_add_comm_group name))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_4083 (h0 : add_monoid (linear_ordered_field (option (option pos)))) : add_monoid.fg (linear_ordered_field (option (option pos))) := sorry --non-trivial
lemma new_lemma_4084 (h0 : topological_space (measurable_space.dynkin_system empty)) : totally_separated_space (measurable_space.dynkin_system empty) := sorry --non-trivial
lemma new_lemma_4085 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @archimedean.{0} (canonically_ordered_comm_semiring.{0} name) (@function.extfun_app.{2 1} Type ordered_add_comm_monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ordered_add_comm_monoid.{0}) (canonically_ordered_comm_semiring.{0} name))  := sorry --non-trivial
lemma new_lemma_4086 (h1 : topological_space (with_one num)) : t0_space (with_one num) := sorry --non-trivial
lemma new_lemma_4087 (h0 : function.extfun Type topological_space) : @loc_path_connected_space.{0} (add_cancel_monoid.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (add_cancel_monoid.{0} num))  := sorry --non-trivial
lemma new_lemma_4088 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_atomistic.{0} (normed_comm_ring.{0} name) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (normed_comm_ring.{0} name))  := sorry --non-trivial
lemma new_lemma_4089 (h0 : not (function.extfun Type ring -> false)) : @rank_condition.{0} (has_norm.{0} fun_info) (@function.extfun_app.{2 1} Type ring.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type ring.{0}) h0) (has_norm.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_4090 (h0 : functor.const Prop string_imp) : functor.const.run h0 := sorry --non-trivial
lemma new_lemma_4091 (h0 : function.extfun (Type 1) topological_space) : @topological_space.separable_space.{1} (has_pos_part.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} h0 (has_pos_part.{1} Type))  := sorry --non-trivial
lemma new_lemma_4092 (h0 : functor.add_const (ring (add_comm_monoid linarith.comp)) (ring linarith.comp)) : @rank_condition.{0} (add_comm_monoid.{0} linarith.comp) (@functor.add_const.run.{0 0} (ring.{0} (add_comm_monoid.{0} linarith.comp)) (ring.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_4093 (h0 : functor.add_const (list (linear_order empty)) (semiring empty)) : list.nodup (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_4094 (h0 : function.extfun Type cancel_comm_monoid_with_zero) : @unique_factorization_monoid.{0} (ring.{0} ennreal) (@function.extfun_app.{2 1} Type cancel_comm_monoid_with_zero.{0} h0 (ring.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_4095 (h0 : finset (canonically_ordered_comm_semiring ennreal)) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_4096 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @complete_space.{0} (measurable_space.{0} linarith.ineq) (@function.extfun_app.{2 1} Type uniform_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 uniform_space.{0}) (measurable_space.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_4097 (h0 : complete_lattice (comm_group (has_neg_part unsigned))) : is_compactly_generated (comm_group (has_neg_part unsigned)) := sorry --non-trivial
lemma new_lemma_4098 (h0 : functor.add_const (topological_space (has_nndist name)) linarith.comp) : @regular_space.{0} (has_nndist.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (has_nndist.{0} name)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_4099 (h0 : functor.add_const (filter (has_nndist unsigned)) Type) : filter.ne_bot (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_4100 (h0 : fin has_zero.zero) : @is_cyclic.{0} (has_Inf.{0} real) (@function.extfun_app.{2 1} Type group.{0} (@matrix.vec_empty.{1} (function.extfun.{2 1} Type group.{0}) h0) (has_Inf.{0} real))  := sorry --non-trivial
lemma new_lemma_4101 (h0 : topological_space (ordered_comm_group num)) : totally_disconnected_space (ordered_comm_group num) := sorry --non-trivial
lemma new_lemma_4102 (h0 : not (uniform_space (ordered_comm_semiring linarith.ineq) -> false)) : @complete_space.{0} (ordered_comm_semiring.{0} linarith.ineq) (@classical.by_contradiction'.{1} (uniform_space.{0} (ordered_comm_semiring.{0} linarith.ineq)) h0)  := sorry --non-trivial
lemma new_lemma_4103 (h0 : ordered_comm_monoid (has_pos_part (has_add (has_add (has_pos_part pos))))) : has_exists_mul_of_le (has_pos_part (has_add (has_add (has_pos_part pos)))) := sorry --non-trivial
lemma new_lemma_4104 (h0 : group (has_neg environment.implicit_infer_kind)) : group.fg (has_neg environment.implicit_infer_kind) := sorry --non-trivial
lemma new_lemma_4105 (h0 : prod (has_neg (option pos)) (has_neg (option pos))) : id_rel h0 := sorry --non-trivial
lemma new_lemma_4106 (h0 : topological_space (complete_distrib_lattice (boolean_algebra name))) : t0_space (complete_distrib_lattice (boolean_algebra name)) := sorry --non-trivial
lemma new_lemma_4107 (h0 : function.extfun Type (functor.add_const (monoid auto.case_option))) : @monoid.fg.{0} auto.case_option (@functor.add_const.run.{0 0} (monoid.{0} auto.case_option) unsigned (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (monoid.{0} auto.case_option)) h0 unsigned))  := sorry --non-trivial
lemma new_lemma_4108 (h0 : topological_space (linear_ordered_semiring (has_norm (has_norm fun_info)))) : irreducible_space (linear_ordered_semiring (has_norm (has_norm fun_info))) := sorry --non-trivial
lemma new_lemma_4109 (h0 : functor.add_const (topological_space (ordered_comm_ring linarith.comp)) linarith.comp) : @discrete_topology.{0} (ordered_comm_ring.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (ordered_comm_ring.{0} linarith.comp)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_4110 (h0 : function.extfun Type topological_space) : @locally_compact_space.{0} (linear_order.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (linear_order.{0} empty))  := sorry --non-trivial
lemma new_lemma_4111 (h0 : function.extfun Type topological_space) : @topological_space.separable_space.{0} (has_nndist.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_nndist.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_4112 (h0 : topological_space (option name)) : irreducible_space (option name) := sorry --non-trivial
lemma new_lemma_4113 (h0 : functor.add_const (filter (cancel_monoid Type)) name) : countable_Inter_filter (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_4114 (h1 : function.extfun Type topological_space) : @locally_compact_space.{0} (random_gen.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type topological_space.{0} h1 (random_gen.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_4115 (h0 : functor.add_const (functor.add_const (list (add_comm_monoid linarith.comp)) linarith.comp) linarith.comp) : palindrome (functor.add_const.run (functor.add_const.run h0)) := sorry --non-trivial
lemma new_lemma_4116 (h0 : topological_space (has_norm (has_norm empty))) : normal_space (has_norm (has_norm empty)) := sorry --non-trivial
lemma new_lemma_4117 (h0 : functor.add_const (list (add_cancel_monoid Type)) (finset pos)) : list.nodup (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_4118 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @strong_rank_condition.{0} (pseudo_metric_space.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (pseudo_metric_space.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_4119 (h0 : group (boolean_algebra (has_to_string unsigned))) : group.fg (boolean_algebra (has_to_string unsigned)) := sorry --non-trivial
lemma new_lemma_4120 (h0 : list (boolean_algebra.core name)) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_4121 (h0 : topological_space (add_comm_monoid (has_bot (comm_semigroup (sub_neg_monoid (has_add real)))))) : normal_space (add_comm_monoid (has_bot (comm_semigroup (sub_neg_monoid (has_add real))))) := sorry --non-trivial
lemma new_lemma_4122 (h0 : functor.add_const (group (cancel_monoid Type)) environment.implicit_infer_kind) : @group.fg.{1} (cancel_monoid.{1} Type) (@functor.add_const.run.{1 0} (group.{1} (cancel_monoid.{1} Type)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_4123 (h0 : filter (has_ssubset fun_info)) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_4124 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_cyclic.{0} (fintype.{0} linarith.ineq) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (fintype.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_4125 (h0 : ring (fintype name)) : is_domain (fintype name) := sorry --non-trivial
lemma new_lemma_4126 (h0 : topological_space (measurable_space.dynkin_system (add_cancel_monoid (semiring linarith.comp)))) : normal_space (measurable_space.dynkin_system (add_cancel_monoid (semiring linarith.comp))) := sorry --non-trivial
lemma new_lemma_4127 (h0 : cancel_comm_monoid_with_zero (add_cancel_monoid (has_add (finset pos)))) : unique_factorization_monoid (add_cancel_monoid (has_add (finset pos))) := sorry --non-trivial
lemma new_lemma_4128 (h0 : function.extfun Type (prod (has_dist empty))) : id_rel (function.extfun_app h0 (has_dist empty)) := sorry --non-trivial
lemma new_lemma_4129 (h0 : topological_space (has_Inf pos)) : sequential_space (has_Inf pos) := sorry --non-trivial
lemma new_lemma_4130 (h0 : not (ring (fintype char) -> false)) : @rank_condition.{0} (fintype.{0} char) (@classical.by_contradiction'.{1} (ring.{0} (fintype.{0} char)) h0)  := sorry --non-trivial
lemma new_lemma_4131 (h0 : topological_space (has_Inf (has_Inf real))) : path_connected_space (has_Inf (has_Inf real)) := sorry --non-trivial
lemma new_lemma_4132 (h3 : topological_space string.iterator_imp) (h4 : set string.iterator_imp) : is_path_connected h4 := sorry --non-trivial
lemma new_lemma_4133 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @t1_space.{1} (generalized_boolean_algebra.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 topological_space.{1}) (generalized_boolean_algebra.{1} Type))  := sorry --non-trivial
lemma new_lemma_4134 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_compactly_generated.{0} (normed_group.{0} linarith.ineq) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (normed_group.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_4135 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @complete_space.{0} (monoid.{0} num) (@function.extfun_app.{2 1} Type uniform_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 uniform_space.{0}) (monoid.{0} num))  := sorry --non-trivial
lemma new_lemma_4136 (h0 : topological_space (non_assoc_semiring (semiring congr_arg_kind))) : t0_space (non_assoc_semiring (semiring congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_4137 (h0 : function.extfun Type monoid) : @monoid.fg.{0} (ordered_comm_monoid.{0} linarith.comp) (@function.extfun_app.{2 1} Type monoid.{0} h0 (ordered_comm_monoid.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_4138 (h0 : functor.add_const (filter (add_comm_monoid name)) Type) : countable_Inter_filter (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_4139 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @rank_condition.{0} (with_one.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (with_one.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_4140 (h0 : topological_space (ordered_ring empty)) : totally_disconnected_space (ordered_ring empty) := sorry --non-trivial
lemma new_lemma_4141 (h0 : complete_lattice (comm_ring linarith.comp_source)) : is_compactly_generated (comm_ring linarith.comp_source) := sorry --non-trivial
lemma new_lemma_4142 (h0 : topological_space (has_one (semiring (semiring empty)))) : irreducible_space (has_one (semiring (semiring empty))) := sorry --non-trivial
lemma new_lemma_4143 (h0 : add_group (semiring (semiring (semiring congr_arg_kind)))) : is_add_cyclic (semiring (semiring (semiring congr_arg_kind))) := sorry --non-trivial
lemma new_lemma_4144 (h0 : prod (mul_zero_class (option unsigned)) (mul_zero_class (option unsigned))) : id_rel h0 := sorry --non-trivial
lemma new_lemma_4145 (h0 : topological_space (semigroup (semiring unsigned))) : t1_space (semigroup (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_4146 (h0 : fin has_zero.zero) : @is_simple_group.{0} (ordered_comm_monoid.{0} name) (@function.extfun_app.{2 1} Type group.{0} (@matrix.vec_empty.{1} (function.extfun.{2 1} Type group.{0}) h0) (ordered_comm_monoid.{0} name))  := sorry --non-trivial
lemma new_lemma_4147 (h0 : topological_space (ordered_comm_ring (has_Inf (has_Inf Type)))) : locally_compact_space (ordered_comm_ring (has_Inf (has_Inf Type))) := sorry --non-trivial
lemma new_lemma_4148 (h0 : functor.comp topological_space boolean_algebra name) : @totally_disconnected_space.{0} (boolean_algebra.{0} name) (@functor.comp.run.{0 0 0} topological_space.{0} boolean_algebra.{0} name h0)  := sorry --non-trivial
lemma new_lemma_4149 (h0 : uniform_space (comm_group (boolean_algebra Type))) : complete_space (comm_group (boolean_algebra Type)) := sorry --non-trivial
lemma new_lemma_4150 (h0 : add_group (has_union (linear_ordered_semiring linarith.comp))) : is_add_cyclic (has_union (linear_ordered_semiring linarith.comp)) := sorry --non-trivial
lemma new_lemma_4151 (h0 : not (topological_space (bin_tree congr_arg_kind) -> false)) : @irreducible_space.{0} (bin_tree.{0} congr_arg_kind) (@classical.by_contradiction'.{1} (topological_space.{0} (bin_tree.{0} congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_4152 (h0 : topological_space (semi_normed_ring (linear_order to_additive.value_type))) : t0_space (semi_normed_ring (linear_order to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_4153 (h0 : topological_space (has_add (has_add (ring (has_add linarith.comp))))) : loc_path_connected_space (has_add (has_add (ring (has_add linarith.comp)))) := sorry --non-trivial
lemma new_lemma_4154 (h0 : group (normed_group (has_top fun_info))) : group.fg (normed_group (has_top fun_info)) := sorry --non-trivial
lemma new_lemma_4155 (h0 : function.extfun nat fin) : @t1_space.{0} (ordered_comm_monoid.{0} linarith.comp) (@matrix.vec_empty.{0} (topological_space.{0} (ordered_comm_monoid.{0} linarith.comp)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_4156 (h0 : group (id (semiring (semiring num)))) : normalizer_condition (id (semiring (semiring num))) := sorry --non-trivial
lemma new_lemma_4157 (h0 : group (denumerable (add_right_cancel_monoid (random_gen string_imp)))) : is_cyclic (denumerable (add_right_cancel_monoid (random_gen string_imp))) := sorry --non-trivial
lemma new_lemma_4158 (h0 : functor.add_const (topological_space (has_nndist unsigned)) pos) : @preconnected_space.{0} (has_nndist.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (has_nndist.{0} unsigned)) pos h0)  := sorry --non-trivial
lemma new_lemma_4159 (h0 : group (canonically_ordered_monoid (sub_neg_monoid real))) : group.fg (canonically_ordered_monoid (sub_neg_monoid real)) := sorry --non-trivial
lemma new_lemma_4160 (h0 : functor.add_const (topological_space (has_nndist unsigned)) Type) : @locally_compact_space.{0} (has_nndist.{0} unsigned) (@functor.add_const.run.{0 1} (topological_space.{0} (has_nndist.{0} unsigned)) Type h0)  := sorry --non-trivial
lemma new_lemma_4161 (h0 : has_mem.mem (id fun_info) has_emptyc.emptyc) : @is_add_cyclic.{0} (@id.{2} Type fun_info) (@finset.pi.empty.{1 0} Type add_group.{0} (@id.{2} Type fun_info) h0)  := sorry --non-trivial
lemma new_lemma_4162 (h0 : uniform_space (linear_ordered_add_comm_group (with_bot linarith.ineq))) : complete_space (linear_ordered_add_comm_group (with_bot linarith.ineq)) := sorry --non-trivial
lemma new_lemma_4163 (h3 : has_lt (has_nnnorm reducibility_hints)) : no_max_order (has_nnnorm reducibility_hints) := sorry --non-trivial
lemma new_lemma_4164 (h0 : function.extfun Type monoid) : @monoid.fg.{0} (normed_group.{0} linarith.ineq) (@function.extfun_app.{2 1} Type monoid.{0} h0 (normed_group.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_4165 (h0 : topological_space (semigroup (has_neg Type))) : t1_space (semigroup (has_neg Type)) := sorry --non-trivial
lemma new_lemma_4166 (h0 : uniform_space (add_cancel_monoid unsigned)) : separated_space (add_cancel_monoid unsigned) := sorry --non-trivial
lemma new_lemma_4167 (h0 : functor.add_const (function.extfun Type ordered_comm_monoid) Type) : @has_exists_mul_of_le.{0} (boolean_algebra.{0} name) (@function.extfun_app.{2 1} Type ordered_comm_monoid.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type ordered_comm_monoid.{0}) Type h0) (boolean_algebra.{0} name))  := sorry --non-trivial
lemma new_lemma_4168 (h0 : group (with_bot (has_norm empty))) : is_cyclic (with_bot (has_norm empty)) := sorry --non-trivial
lemma new_lemma_4169 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @normal_space.{0} (semigroup.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (semigroup.{0} pos))  := sorry --non-trivial
lemma new_lemma_4170 (h0 : functor.add_const (function.extfun Type group) linarith.comp) : @group.fg.{0} (has_neg.{0} unsigned) (@function.extfun_app.{2 1} Type group.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type group.{0}) linarith.comp h0) (has_neg.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_4171 (h0 h1 : multiset (add_comm_semigroup fun_info)) : multiset.disjoint h0 h1 := sorry --non-trivial
lemma new_lemma_4172 (h0 : function.extfun (Type 1) uniform_space) : @complete_space.{1} (ordered_comm_monoid.{1} Type) (@function.extfun_app.{3 2} (Type 1) uniform_space.{1} h0 (ordered_comm_monoid.{1} Type))  := sorry --non-trivial
lemma new_lemma_4173 (h0 : not (function.extfun Type add_group -> false)) : @is_add_cyclic.{0} (semiring.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type add_group.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type add_group.{0}) h0) (semiring.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_4174 (h0 : functor.add_const (functor.add_const (group pos) linarith.comp) linarith.comp) : @is_cyclic.{0} pos (@functor.add_const.run.{0 0} (group.{0} pos) linarith.comp (@functor.add_const.run.{0 0} (functor.add_const.{0 0} (group.{0} pos) linarith.comp) linarith.comp h0))  := sorry --non-trivial
lemma new_lemma_4175 (h0 : functor.add_const (function.extfun Type complete_lattice) pos) : @is_compactly_generated.{0} (finset.{0} linarith.comp) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type complete_lattice.{0}) pos h0) (finset.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_4176 (h0 : group (comm_semigroup (has_add Type))) : group.fg (comm_semigroup (has_add Type)) := sorry --non-trivial
lemma new_lemma_4177 (h0 : topological_space (cancel_monoid (boolean_algebra.core Type))) : locally_compact_space (cancel_monoid (boolean_algebra.core Type)) := sorry --non-trivial
lemma new_lemma_4178 (h0 : not (add_group (complete_linear_order empty) -> false)) : @is_add_cyclic.{0} (complete_linear_order.{0} empty) (@classical.by_contradiction'.{1} (add_group.{0} (complete_linear_order.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_4179 (h0 : ring (comm_ring (random_gen linarith.ineq))) : rank_condition (comm_ring (random_gen linarith.ineq)) := sorry --non-trivial
lemma new_lemma_4180 (h0 : topological_space (finset empty)) : totally_separated_space (finset empty) := sorry --non-trivial
lemma new_lemma_4181 (h1 : set (enat -> ereal)) : set.separates_points h1 := sorry --non-trivial
lemma new_lemma_4182 (h0 : topological_space (add_cancel_monoid (option empty))) : t1_space (add_cancel_monoid (option empty)) := sorry --non-trivial
lemma new_lemma_4183 (h0 : functor.add_const (ordered_comm_monoid (add_comm_monoid Type)) name) : @has_exists_mul_of_le.{1} (add_comm_monoid.{1} Type) (@functor.add_const.run.{1 0} (ordered_comm_monoid.{1} (add_comm_monoid.{1} Type)) name h0)  := sorry --non-trivial
lemma new_lemma_4184 (h0 : functor.comp topological_space has_nndist name) : @preirreducible_space.{0} (has_nndist.{0} name) (@functor.comp.run.{0 0 0} topological_space.{0} has_nndist.{0} name (@functor.comp.run.{0 0 0} topological_space.{0} has_nndist.{0} name h0))  := sorry --non-trivial
lemma new_lemma_4185 (h0 h1 : multiset (has_ssubset congr_arg_kind)) : multiset.subset h0 h1 := sorry --non-trivial
lemma new_lemma_4186 (h0 : not (uniform_space (has_sub unsigned) -> false)) : @separated_space.{0} (has_sub.{0} unsigned) (@classical.by_contradiction'.{1} (uniform_space.{0} (has_sub.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_4187 (h0 : functor.add_const (ordered_comm_monoid (has_zero linarith.comp)) linarith.comp) : @has_exists_mul_of_le.{0} (has_zero.{0} linarith.comp) (@functor.add_const.run.{0 0} (ordered_comm_monoid.{0} (has_zero.{0} linarith.comp)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_4188 (h0 : ring (semi_normed_ring linarith.ineq)) : strong_rank_condition (semi_normed_ring linarith.ineq) := sorry --non-trivial
lemma new_lemma_4189 (h0 : not (function.extfun Type monoid -> false)) : @monoid.fg.{0} (has_emptyc.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type monoid.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type monoid.{0}) h0) (has_emptyc.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_4190 (h0 : ring (normed_group (has_nnnorm fun_info))) : rank_condition (normed_group (has_nnnorm fun_info)) := sorry --non-trivial
lemma new_lemma_4191 (h0 : topological_space (with_bot (has_inv (comm_ring string_imp)))) : totally_disconnected_space (with_bot (has_inv (comm_ring string_imp))) := sorry --non-trivial
lemma new_lemma_4192 (h0 : topological_space (linear_ordered_comm_monoid_with_zero (option (option (option empty))))) : locally_compact_space (linear_ordered_comm_monoid_with_zero (option (option (option empty)))) := sorry --non-trivial
lemma new_lemma_4193 (h0 : function.extfun Type uniform_space) : @separated_space.{0} auto.case_option (@function.extfun_app.{2 1} Type uniform_space.{0} h0 auto.case_option)  := sorry --non-trivial
lemma new_lemma_4194 (h0 : ring (add_right_cancel_monoid unsigned)) : rank_condition (add_right_cancel_monoid unsigned) := sorry --non-trivial
lemma new_lemma_4195 (h0 : topological_space (boolean_algebra (has_pos_part (finset (ring Type))))) : t1_space (boolean_algebra (has_pos_part (finset (ring Type)))) := sorry --non-trivial
lemma new_lemma_4196 (h0 : ordered_add_comm_monoid (has_pos_part (has_neg linarith.comp))) : archimedean (has_pos_part (has_neg linarith.comp)) := sorry --non-trivial
lemma new_lemma_4197 (h0 : function.extfun Type group) : @normalizer_condition.{0} (is_R_or_C.{0} empty) (@function.extfun_app.{2 1} Type group.{0} h0 (is_R_or_C.{0} empty))  := sorry --non-trivial
lemma new_lemma_4198 (h0 : function.extfun Type group) : @is_simple_group.{0} (linear_ordered_field.{0} name) (@function.extfun_app.{2 1} Type group.{0} h0 (linear_ordered_field.{0} name))  := sorry --non-trivial
lemma new_lemma_4199 (h0 : add_monoid (has_neg (boolean_algebra.core (boolean_algebra.core Type)))) : add_monoid.fg (has_neg (boolean_algebra.core (boolean_algebra.core Type))) := sorry --non-trivial
lemma new_lemma_4200 (h0 : group (id (has_norm num))) : group.fg (id (has_norm num)) := sorry --non-trivial
lemma new_lemma_4201 (h0 : not (add_group (semiring to_additive.value_type) -> false)) : @is_add_cyclic.{0} (semiring.{0} to_additive.value_type) (@classical.by_contradiction'.{1} (add_group.{0} (semiring.{0} to_additive.value_type)) h0)  := sorry --non-trivial
lemma new_lemma_4202 (h0 : functor.add_const (topological_space (semigroup environment.implicit_infer_kind)) (has_neg Type)) : @loc_path_connected_space.{0} (semigroup.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 1} (topological_space.{0} (semigroup.{0} environment.implicit_infer_kind)) (has_neg.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_4203 (h1 : topological_space (measurable_space linarith.comp)) : totally_separated_space (measurable_space linarith.comp) := sorry --non-trivial
lemma new_lemma_4204 (h0 : functor.add_const (ring (semigroup environment.implicit_infer_kind)) linarith.comp) : @is_principal_ideal_ring.{0} (semigroup.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (ring.{0} (semigroup.{0} environment.implicit_infer_kind)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_4205 (h0 : ordered_add_comm_monoid (boolean_algebra (has_pos_part linarith.comp))) : archimedean (boolean_algebra (has_pos_part linarith.comp)) := sorry --non-trivial
lemma new_lemma_4206 (h0 : finset (has_inter empty)) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_4207 (h0 : has_mem.mem (normed_group linarith.ineq) has_emptyc.emptyc) : @is_atomistic.{0} (normed_group.{0} linarith.ineq) (@finset.pi.empty.{1 0} Type complete_lattice.{0} (normed_group.{0} linarith.ineq) h0)  := sorry --non-trivial
lemma new_lemma_4208 (h1 : set (string.iterator_imp -> enat)) : set.separates_points h1 := sorry --non-trivial
lemma new_lemma_4209 (h0 : ring (plift (semiring (semiring (semiring empty))))) : strong_rank_condition (plift (semiring (semiring (semiring empty)))) := sorry --non-trivial
lemma new_lemma_4210 (h0 : function.extfun Type group) : @is_cyclic.{0} (canonically_linear_ordered_monoid.{0} (option.{0} ennreal)) (@function.extfun_app.{2 1} Type group.{0} h0 (canonically_linear_ordered_monoid.{0} (option.{0} ennreal)))  := sorry --non-trivial
lemma new_lemma_4211 (h0 : add_group (normed_comm_ring (option empty))) : is_add_cyclic (normed_comm_ring (option empty)) := sorry --non-trivial
lemma new_lemma_4212 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @complete_lattice.is_Sup_finite_compact.{0} (group_with_zero.{0} ennreal) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (group_with_zero.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_4213 (h0 : function.extfun Type ring) : @strong_rank_condition.{0} (normed_linear_ordered_group.{0} unsigned) (@function.extfun_app.{2 1} Type ring.{0} h0 (normed_linear_ordered_group.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_4214 (h0 : monoid (ordered_comm_ring (has_pos_part linarith.comp))) : monoid.fg (ordered_comm_ring (has_pos_part linarith.comp)) := sorry --non-trivial
lemma new_lemma_4215 (h1 : add_group (distrib_lattice to_additive.value_type)) : is_add_cyclic (distrib_lattice to_additive.value_type) := sorry --non-trivial
lemma new_lemma_4216 (h0 : not (topological_space (normed_group linarith.comp_source) -> false)) : @totally_disconnected_space.{0} (normed_group.{0} linarith.comp_source) (@classical.by_contradiction'.{1} (topological_space.{0} (normed_group.{0} linarith.comp_source)) h0)  := sorry --non-trivial
lemma new_lemma_4217 (h0 : ordered_comm_monoid (boolean_algebra (has_bot (sub_neg_monoid real)))) : has_exists_mul_of_le (boolean_algebra (has_bot (sub_neg_monoid real))) := sorry --non-trivial
lemma new_lemma_4218 (h0 : not (semiring (has_star unsigned) -> false)) : @is_noetherian_ring.{0} (has_star.{0} unsigned) (@classical.by_contradiction'.{1} (semiring.{0} (has_star.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_4219 (h0 : add_monoid (simple_graph (ring (has_pos_part (simple_graph Type))))) : add_monoid.fg (simple_graph (ring (has_pos_part (simple_graph Type)))) := sorry --non-trivial
lemma new_lemma_4220 (h0 : topological_space (ring (finset environment.implicit_infer_kind))) : irreducible_space (ring (finset environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_4221 (h0 : topological_space (has_pos_part (has_add real))) : irreducible_space (has_pos_part (has_add real)) := sorry --non-trivial
lemma new_lemma_4222 (h0 : add_group (comm_ring (has_nnnorm (has_nnnorm (has_nnnorm (has_nnnorm to_additive.value_type)))))) : is_add_cyclic (comm_ring (has_nnnorm (has_nnnorm (has_nnnorm (has_nnnorm to_additive.value_type))))) := sorry --non-trivial
lemma new_lemma_4223 (h0 : monoid (has_zero (finset (normed_comm_ring (semigroup name))))) : monoid.fg (has_zero (finset (normed_comm_ring (semigroup name)))) := sorry --non-trivial
lemma new_lemma_4224 (h0 : topological_space (ordered_comm_group (option (option (option empty))))) : totally_separated_space (ordered_comm_group (option (option (option empty)))) := sorry --non-trivial
lemma new_lemma_4225 (h0 : complete_lattice (linear_ordered_comm_group unsigned)) : is_atomistic (linear_ordered_comm_group unsigned) := sorry --non-trivial
lemma new_lemma_4226 (h0 : random_gen (with_one linarith.comp_source) -> Prop) : zzz_forall h0 := sorry --non-trivial
lemma new_lemma_4227 (h0 : function.extfun Type complete_lattice) : @is_atomistic.{0} (linear_ordered_comm_group.{0} (option.{0} empty)) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (linear_ordered_comm_group.{0} (option.{0} empty)))  := sorry --non-trivial
lemma new_lemma_4228 (h1 : ring (mul_one_class (add_comm_semigroup char))) : strong_rank_condition (mul_one_class (add_comm_semigroup char)) := sorry --non-trivial
lemma new_lemma_4229 (h0 : semiring (has_nndist (option ennreal))) : is_noetherian_ring (has_nndist (option ennreal)) := sorry --non-trivial
lemma new_lemma_4230 (h0 : function.extfun Type ordered_comm_monoid) : @has_exists_mul_of_le.{0} (has_zero.{0} pos) (@function.extfun_app.{2 1} Type ordered_comm_monoid.{0} h0 (has_zero.{0} pos))  := sorry --non-trivial
lemma new_lemma_4231 (h0 : function.extfun Type topological_space) : @t1_space.{0} (simple_graph.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (simple_graph.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_4232 (h0 : function.extfun Type topological_space) : @normal_space.{0} (ordered_ring.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (ordered_ring.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_4233 (h0 : topological_space (ring (has_pos_part linarith.comp))) : t1_space (ring (has_pos_part linarith.comp)) := sorry --non-trivial
lemma new_lemma_4234 (h0 : functor.add_const (monoid (has_to_string name)) (has_neg_part Type)) : @monoid.fg.{0} (has_to_string.{0} name) (@functor.add_const.run.{0 1} (monoid.{0} (has_to_string.{0} name)) (has_neg_part.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_4235 (h0 : uniform_space (complete_distrib_lattice (has_add name))) : separated_space (complete_distrib_lattice (has_add name)) := sorry --non-trivial
lemma new_lemma_4236 (h0 : not (function.extfun Type topological_space -> false)) : @totally_separated_space.{0} (linear_ordered_semiring.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (linear_ordered_semiring.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_4237 (h0 : list (comm_group environment.implicit_infer_kind)) : palindrome h0 := sorry --non-trivial
lemma new_lemma_4238 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @strong_rank_condition.{0} (is_R_or_C.{0} unsigned) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (is_R_or_C.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_4239 (h0 : topological_space (has_to_string ennreal)) : totally_disconnected_space (has_to_string ennreal) := sorry --non-trivial
lemma new_lemma_4240 (h0 : topological_space (plift empty)) : totally_separated_space (plift empty) := sorry --non-trivial
lemma new_lemma_4241 (h0 : ordered_add_comm_monoid (add_group congr_arg_kind)) : archimedean (add_group congr_arg_kind) := sorry --non-trivial
lemma new_lemma_4242 (h0 : topological_space (has_top (random_gen num))) : path_connected_space (has_top (random_gen num)) := sorry --non-trivial
lemma new_lemma_4243 (h0 : topological_space (add_group (semiring (has_norm empty)))) : path_connected_space (add_group (semiring (has_norm empty))) := sorry --non-trivial
lemma new_lemma_4244 (h0 : functor.add_const (topological_space (simple_graph Type)) pos) : @totally_separated_space.{1} (simple_graph.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (simple_graph.{1} Type)) pos h0)  := sorry --non-trivial
lemma new_lemma_4245 (h0 : uniform_space (has_to_string name)) : complete_space (has_to_string name) := sorry --non-trivial
lemma new_lemma_4246 (h0 : topological_space (comm_ring fun_info)) : t0_space (comm_ring fun_info) := sorry --non-trivial
lemma new_lemma_4247 (h0 : complete_lattice (canonically_ordered_comm_semiring (option (option unsigned)))) : is_compactly_generated (canonically_ordered_comm_semiring (option (option unsigned))) := sorry --non-trivial
lemma new_lemma_4248 (h0 : semiring (generalized_boolean_algebra name)) : is_noetherian_ring (generalized_boolean_algebra name) := sorry --non-trivial
lemma new_lemma_4249 (h0 : functor.add_const (topological_space (comm_group pos)) linarith.comp) : @irreducible_space.{0} (comm_group.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (comm_group.{0} pos)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_4250 (h0 : functor.add_const (finset (add_cancel_monoid environment.implicit_infer_kind)) pos) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_4251 (h0 : topological_space (with_one (random_gen (random_gen to_additive.value_type)))) : locally_compact_space (with_one (random_gen (random_gen to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_4252 (h0 : complete_lattice (has_lt (metric_space reducibility_hints))) : complete_lattice.is_Sup_finite_compact (has_lt (metric_space reducibility_hints)) := sorry --non-trivial
lemma new_lemma_4253 (h0 : complete_lattice (has_neg (has_pos_part (ring pos)))) : is_compactly_generated (has_neg (has_pos_part (ring pos))) := sorry --non-trivial
lemma new_lemma_4254 (h0 : functor.add_const (function.extfun Type ordered_add_comm_monoid) (ring (ring linarith.comp))) : @archimedean.{0} (generalized_boolean_algebra.{0} linarith.comp) (@function.extfun_app.{2 1} Type ordered_add_comm_monoid.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type ordered_add_comm_monoid.{0}) (ring.{0} (ring.{0} linarith.comp)) h0) (generalized_boolean_algebra.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_4255 (h0 : topological_space (generalized_boolean_algebra (has_Inf (has_Inf (has_Inf Type))))) : discrete_topology (generalized_boolean_algebra (has_Inf (has_Inf (has_Inf Type)))) := sorry --non-trivial
lemma new_lemma_4256 (h1 : has_mem.mem uniform_space has_emptyc.emptyc) : @complete_space.{0} (with_bot.{0} linarith.comp) (@function.extfun_app.{2 1} Type uniform_space.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) uniform_space.{0} h1) (with_bot.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_4257 (h0 : not (function.extfun Type complete_lattice -> false)) : @is_compactly_generated.{0} (has_norm.{0} linarith.ineq) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type complete_lattice.{0}) h0) (has_norm.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_4258 (h0 : list (cancel_monoid (cancel_monoid (boolean_algebra name)))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_4259 (h0 : functor.add_const (ring (left_cancel_monoid congr_arg_kind)) unsigned) : @rank_condition.{0} (left_cancel_monoid.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (ring.{0} (left_cancel_monoid.{0} congr_arg_kind)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_4260 (h0 : not (ring (add_monoid linarith.comp_source) -> false)) : @strong_rank_condition.{0} (add_monoid.{0} linarith.comp_source) (@classical.by_contradiction'.{1} (ring.{0} (add_monoid.{0} linarith.comp_source)) h0)  := sorry --non-trivial
lemma new_lemma_4261 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @complete_space.{0} (has_bot.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type uniform_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 uniform_space.{0}) (has_bot.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_4262 (h1 : topological_space (distrib_lattice (has_norm to_additive.value_type))) : t0_space (distrib_lattice (has_norm to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_4263 (h0 : topological_space (uniform_space (mul_one_class (mul_one_class fun_info)))) : totally_disconnected_space (uniform_space (mul_one_class (mul_one_class fun_info))) := sorry --non-trivial
lemma new_lemma_4264 (h0 : uniform_space (pseudo_metric_space num)) : complete_space (pseudo_metric_space num) := sorry --non-trivial
lemma new_lemma_4265 (h0 : function.extfun (finset Type) (has_mem.mem (random_gen empty))) : @t0_space.{0} (random_gen.{0} empty) (@finset.pi.empty.{1 0} Type topological_space.{0} (random_gen.{0} empty) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (random_gen.{0} empty)) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_4266 (h0 : function.extfun Type (functor.add_const (topological_space pos))) : @discrete_topology.{0} pos (@functor.add_const.run.{0 0} (topological_space.{0} pos) linarith.comp (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (topological_space.{0} pos)) h0 linarith.comp))  := sorry --non-trivial
lemma new_lemma_4267 (h0 : functor.add_const (topological_space (has_Inf linarith.comp)) (has_neg Type)) : @preirreducible_space.{0} (has_Inf.{0} linarith.comp) (@functor.add_const.run.{0 1} (topological_space.{0} (has_Inf.{0} linarith.comp)) (has_neg.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_4268 (h0 : functor.add_const (function.extfun Type list) (ring environment.implicit_infer_kind)) : palindrome (function.extfun_app (functor.add_const.run h0) (boolean_algebra linarith.comp)) := sorry --non-trivial
lemma new_lemma_4269 (h0 : uniform_space (normed_comm_ring (boolean_algebra.core Type))) : separated_space (normed_comm_ring (boolean_algebra.core Type)) := sorry --non-trivial
lemma new_lemma_4270 (h0 : ring (has_add (has_add (has_add linarith.comp)))) : rank_condition (has_add (has_add (has_add linarith.comp))) := sorry --non-trivial
lemma new_lemma_4271 (h1 : function.extfun (Type -> Type) (function.extfun Type)) : @monoid.fg.{0} (random_gen.{0} linarith.ineq) (@function.extfun_app.{2 1} Type monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h1 monoid.{0}) (random_gen.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_4272 (h2 : not (topological_space (has_add char) -> false)) : @totally_disconnected_space.{0} (has_add.{0} char) (@classical.by_contradiction'.{1} (topological_space.{0} (has_add.{0} char)) h2)  := sorry --non-trivial
lemma new_lemma_4273 (h0 : complete_lattice (semiring (semiring (semiring (semiring num))))) : is_atomistic (semiring (semiring (semiring (semiring num)))) := sorry --non-trivial
lemma new_lemma_4274 (h0 : complete_lattice (with_one (random_gen (random_gen (random_gen linarith.comp_source))))) : is_atomistic (with_one (random_gen (random_gen (random_gen linarith.comp_source)))) := sorry --non-trivial
lemma new_lemma_4275 (h0 : functor.add_const (function.extfun (Type 1) topological_space) name) : @preconnected_space.{1} (has_add.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) topological_space.{1}) name h0) (has_add.{1} Type))  := sorry --non-trivial
lemma new_lemma_4276 (h0 : functor.add_const (list (linear_ordered_field num)) unsigned) : palindrome (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_4277 (h0 : functor.add_const (finset (has_neg Type)) Type) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_4278 (h0 : topological_space (canonically_ordered_comm_semiring (has_nndist (finset name)))) : totally_separated_space (canonically_ordered_comm_semiring (has_nndist (finset name))) := sorry --non-trivial
lemma new_lemma_4279 (h0 : functor.add_const (complete_lattice (has_add Type)) Type) : @complete_lattice.is_Sup_finite_compact.{1} (has_add.{1} Type) (@functor.add_const.run.{1 1} (complete_lattice.{1} (has_add.{1} Type)) Type h0)  := sorry --non-trivial
lemma new_lemma_4280 (h0 : topological_space (has_nnnorm enat)) : totally_disconnected_space (has_nnnorm enat) := sorry --non-trivial
lemma new_lemma_4281 (h0 : functor.add_const (topological_space (finset Type)) linarith.comp) : @t1_space.{1} (finset.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (finset.{1} Type)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_4282 (h0 : ordered_comm_monoid (add_comm_monoid (has_neg_part (has_neg_part (has_add Type))))) : has_exists_mul_of_le (add_comm_monoid (has_neg_part (has_neg_part (has_add Type)))) := sorry --non-trivial
lemma new_lemma_4283 (h1 : topological_space (topological_space char)) : path_connected_space (topological_space char) := sorry --non-trivial
lemma new_lemma_4284 (h0 : ordered_comm_monoid (comm_group (option (option unsigned)))) : has_exists_mul_of_le (comm_group (option (option unsigned))) := sorry --non-trivial
lemma new_lemma_4285 (h0 : list (boolean_algebra.core (has_add (has_add name)))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_4286 (h0 : filter (complete_distrib_lattice (option (option empty)))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_4287 (h0 : functor.add_const (complete_lattice (has_pos_part real)) pos) : @is_atomistic.{0} (has_pos_part.{0} real) (@functor.add_const.run.{0 0} (complete_lattice.{0} (has_pos_part.{0} real)) pos h0)  := sorry --non-trivial
lemma new_lemma_4288 (h0 : ring (normed_lattice_add_comm_group (has_neg name))) : strong_rank_condition (normed_lattice_add_comm_group (has_neg name)) := sorry --non-trivial
lemma new_lemma_4289 (h0 : topological_space std_gen) (h2 : Prop) : is_closed (id (fun (h1 : std_gen), h2)) := sorry --non-trivial
lemma new_lemma_4290 (h1 : ring (add_monoid (random_gen (random_gen (random_gen (random_gen (denumerable char))))))) : is_domain (add_monoid (random_gen (random_gen (random_gen (random_gen (denumerable char)))))) := sorry --non-trivial
lemma new_lemma_4291 (h0 : topological_space (add_cancel_monoid (option congr_arg_kind))) : normal_space (add_cancel_monoid (option congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_4292 (h0 : functor.add_const (topological_space (measure_theory.measure_space congr_arg_kind)) empty) : @normal_space.{0} (measure_theory.measure_space.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (measure_theory.measure_space.{0} congr_arg_kind)) empty h0)  := sorry --non-trivial
lemma new_lemma_4293 (h0 : topological_space (dlist (random_gen string_imp))) : irreducible_space (dlist (random_gen string_imp)) := sorry --non-trivial
lemma new_lemma_4294 (h0 : function.extfun (finset (Type -> Type) -> Prop) (function.extfun (finset (Type -> Type)))) : @is_domain.{0} (semiring.{0} fun_info) (@function.extfun_app.{2 1} Type ring.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) ring.{0} (@function.extfun_app.{2 0} (finset.{1} (Type → Type)) (@has_mem.mem.{1 1} (Type → Type) (finset.{1} (Type → Type)) (@finset.has_mem.{1} (Type → Type)) ring.{0}) (@function.extfun_app.{2 0} (finset.{1} (Type → Type) → Prop) (function.extfun.{2 0} (finset.{1} (Type → Type))) h0 (@has_mem.mem.{1 1} (Type → Type) (finset.{1} (Type → Type)) (@finset.has_mem.{1} (Type → Type)) ring.{0})) (@has_emptyc.emptyc.{1} (finset.{1} (Type → Type)) (@finset.has_emptyc.{1} (Type → Type))))) (semiring.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_4295 (h0 : topological_space (ordered_ring (semiring unsigned))) : preirreducible_space (ordered_ring (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_4296 (h0 : topological_space (canonically_ordered_comm_semiring (has_add environment.implicit_infer_kind))) : normal_space (canonically_ordered_comm_semiring (has_add environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_4297 (h0 : finset (canonically_linear_ordered_monoid ennreal)) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_4298 (h0 : function.extfun Type monoid) : @monoid.fg.{0} (add_cancel_comm_monoid.{0} empty) (@function.extfun_app.{2 1} Type monoid.{0} h0 (add_cancel_comm_monoid.{0} empty))  := sorry --non-trivial
lemma new_lemma_4299 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : palindrome (function.extfun_app (function.extfun_app h0 list) (mul_zero_class (finset ennreal))) := sorry --non-trivial
lemma new_lemma_4300 (h0 : function.extfun Type filter) : countable_Inter_filter (function.extfun_app h0 real) := sorry --non-trivial
lemma new_lemma_4301 (h0 : uniform_space (monoid num)) : complete_space (monoid num) := sorry --non-trivial
lemma new_lemma_4302 (h0 : fin has_zero.zero) : @totally_separated_space.{1} (has_nndist.{1} (has_Inf.{1} (has_Inf.{1} (has_add.{1} (has_Inf.{1} (has_Inf.{1} Type)))))) (@matrix.vec_empty.{1} (topological_space.{1} (has_nndist.{1} (has_Inf.{1} (has_Inf.{1} (has_add.{1} (has_Inf.{1} (has_Inf.{1} Type))))))) h0)  := sorry --non-trivial
lemma new_lemma_4303 (h0 : group (has_nndist (has_neg name))) : is_simple_group (has_nndist (has_neg name)) := sorry --non-trivial
lemma new_lemma_4304 (h0 : group (has_zero (has_add Type))) : group.fg (has_zero (has_add Type)) := sorry --non-trivial
lemma new_lemma_4305 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @regular_space.{0} (has_zero.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_zero.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_4306 (h0 : uniform_space (uniform_space (mul_one_class (mul_one_class char)))) : complete_space (uniform_space (mul_one_class (mul_one_class char))) := sorry --non-trivial
lemma new_lemma_4307 (h0 : group (finset name)) : group.fg (finset name) := sorry --non-trivial
lemma new_lemma_4308 (h0 : topological_space (add_left_cancel_semigroup (bin_tree empty))) : t0_space (add_left_cancel_semigroup (bin_tree empty)) := sorry --non-trivial
lemma new_lemma_4309 (h0 : not (filter (mul_zero_class congr_arg_kind) -> false)) : filter.ne_bot (classical.by_contradiction' h0) := sorry --non-trivial
lemma new_lemma_4310 (h0 : not (ring (has_lt reducibility_hints) -> false)) : @strong_rank_condition.{0} (has_lt.{0} reducibility_hints) (@classical.by_contradiction'.{1} (ring.{0} (has_lt.{0} reducibility_hints)) h0)  := sorry --non-trivial
lemma new_lemma_4311 (h0 : function.extfun Type group) : @group.fg.{0} (simple_graph.{0} unsigned) (@function.extfun_app.{2 1} Type group.{0} h0 (simple_graph.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_4312 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @normal_space.{0} (has_zero.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_zero.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_4313 (h0 : list (has_neg_part (mul_zero_class (mul_zero_class name)))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_4314 (h1 : not (topological_space (simple_graph string_imp) -> false)) : @path_connected_space.{0} (simple_graph.{0} string_imp) (@classical.by_contradiction'.{1} (topological_space.{0} (simple_graph.{0} string_imp)) h1)  := sorry --non-trivial
lemma new_lemma_4315 (h0 : functor.add_const (function.extfun (Type 1) ordered_comm_monoid) (has_neg environment.implicit_infer_kind)) : @has_exists_mul_of_le.{1} (has_add.{1} Type) (@function.extfun_app.{3 2} (Type 1) ordered_comm_monoid.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) ordered_comm_monoid.{1}) (has_neg.{0} environment.implicit_infer_kind) h0) (has_add.{1} Type))  := sorry --non-trivial
lemma new_lemma_4316 (h0 : functor.add_const (topological_space (has_neg_part pos)) linarith.comp) : @preconnected_space.{0} (has_neg_part.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (has_neg_part.{0} pos)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_4317 (h0 : not (topological_space (has_union linarith.comp) -> false)) : @totally_separated_space.{0} (has_union.{0} linarith.comp) (@classical.by_contradiction'.{1} (topological_space.{0} (has_union.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_4318 (h0 : topological_space (with_bot congr_arg_kind)) : preirreducible_space (with_bot congr_arg_kind) := sorry --non-trivial
lemma new_lemma_4319 (h0 : functor.add_const (ordered_add_comm_monoid (ordered_comm_ring linarith.comp)) (has_neg pos)) : @archimedean.{0} (ordered_comm_ring.{0} linarith.comp) (@functor.add_const.run.{0 0} (ordered_add_comm_monoid.{0} (ordered_comm_ring.{0} linarith.comp)) (has_neg.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_4320 (h1 : complete_lattice (has_inv to_additive.value_type)) : complete_lattice.is_Sup_finite_compact (has_inv to_additive.value_type) := sorry --non-trivial
lemma new_lemma_4321 (h0 : functor.add_const (monoid (pseudo_metric_space empty)) empty) : @monoid.fg.{0} (pseudo_metric_space.{0} empty) (@functor.add_const.run.{0 0} (monoid.{0} (pseudo_metric_space.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_4322 (h0 : not (ring (measurable_space.dynkin_system empty) -> false)) : @rank_condition.{0} (measurable_space.dynkin_system.{0} empty) (@classical.by_contradiction'.{1} (ring.{0} (measurable_space.dynkin_system.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_4323 (h3 : list (add_monoid char)) : list.nodup h3 := sorry --non-trivial
lemma new_lemma_4324 (h0 : topological_space (has_union (has_top (has_top to_additive.value_type)))) : path_connected_space (has_union (has_top (has_top to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_4325 (h0 : not (has_mem.mem (has_norm linarith.comp_source) has_emptyc.emptyc -> false)) : @locally_compact_space.{0} (has_norm.{0} linarith.comp_source) (@finset.pi.empty.{1 0} Type topological_space.{0} (has_norm.{0} linarith.comp_source) (@classical.by_contradiction'.{0} (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (has_norm.{0} linarith.comp_source) (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))) h0))  := sorry --non-trivial
lemma new_lemma_4326 (h0 : add_monoid (comm_semigroup (ordered_comm_monoid (has_pos_part (sub_neg_monoid pos))))) : add_monoid.fg (comm_semigroup (ordered_comm_monoid (has_pos_part (sub_neg_monoid pos)))) := sorry --non-trivial
lemma new_lemma_4327 (h0 : functor.add_const (cancel_comm_monoid_with_zero (finset pos)) pos) : @unique_factorization_monoid.{0} (finset.{0} pos) (@functor.add_const.run.{0 0} (cancel_comm_monoid_with_zero.{0} (finset.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_4328 (h0 : group (monoid_with_zero ennreal)) : is_cyclic (monoid_with_zero ennreal) := sorry --non-trivial
lemma new_lemma_4329 (h0 : topological_space (semigroup (finset name))) : t1_space (semigroup (finset name)) := sorry --non-trivial
lemma new_lemma_4330 (h0 : topological_space (canonically_ordered_monoid (has_Inf name))) : regular_space (canonically_ordered_monoid (has_Inf name)) := sorry --non-trivial
lemma new_lemma_4331 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @t1_space.{0} (has_neg.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_neg.{0} pos))  := sorry --non-trivial
lemma new_lemma_4332 (h0 : add_group (ring pos)) : is_add_cyclic (ring pos) := sorry --non-trivial
lemma new_lemma_4333 (h0 : topological_space (add_cancel_monoid (boolean_algebra.core environment.implicit_infer_kind))) : t0_space (add_cancel_monoid (boolean_algebra.core environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_4334 (h0 : topological_space (id (linear_ordered_semiring (has_norm (semiring unsigned))))) : irreducible_space (id (linear_ordered_semiring (has_norm (semiring unsigned)))) := sorry --non-trivial
lemma new_lemma_4335 (h0 : function.extfun Type (functor.add_const (function.extfun Type semiring))) : @is_noetherian_ring.{0} (linear_ordered_comm_group.{0} ennreal) (@function.extfun_app.{2 1} Type semiring.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type semiring.{0}) (option.{0} (option.{0} (option.{0} (option.{0} (option.{0} (option.{0} (option.{0} (option.{0} empty)))))))) (@function.extfun_app.{2 2} Type (functor.add_const.{1 0} (function.extfun.{2 1} Type semiring.{0})) h0 (option.{0} (option.{0} (option.{0} (option.{0} (option.{0} (option.{0} (option.{0} (option.{0} empty)))))))))) (linear_ordered_comm_group.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_4336 (h0 : functor.add_const (topological_space (complete_distrib_lattice Type)) pos) : @discrete_topology.{1} (complete_distrib_lattice.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (complete_distrib_lattice.{1} Type)) pos h0)  := sorry --non-trivial
lemma new_lemma_4337 (h0 : uniform_space (has_Inf (has_Inf real))) : separated_space (has_Inf (has_Inf real)) := sorry --non-trivial
lemma new_lemma_4338 (h0 : topological_space (canonically_ordered_monoid (has_Inf real))) : preconnected_space (canonically_ordered_monoid (has_Inf real)) := sorry --non-trivial
lemma new_lemma_4339 (h0 : has_mem.mem (semiring fun_info) has_emptyc.emptyc) : @is_cyclic.{0} (semiring.{0} fun_info) (@finset.pi.empty.{1 0} Type group.{0} (semiring.{0} fun_info) h0)  := sorry --non-trivial
lemma new_lemma_4340 (h0 : add_group (has_neg_part (option name))) : is_add_cyclic (has_neg_part (option name)) := sorry --non-trivial
lemma new_lemma_4341 (h0 : ordered_add_comm_monoid (has_add (ring linarith.comp))) : archimedean (has_add (ring linarith.comp)) := sorry --non-trivial
lemma new_lemma_4342 (h0 : topological_space (ordered_comm_ring (sub_neg_monoid Type))) : totally_separated_space (ordered_comm_ring (sub_neg_monoid Type)) := sorry --non-trivial
lemma new_lemma_4343 (h0 : group (normed_linear_ordered_group (random_gen char))) : group.fg (normed_linear_ordered_group (random_gen char)) := sorry --non-trivial
lemma new_lemma_4344 (h0 : group (sub_neg_monoid linarith.comp)) : is_simple_group (sub_neg_monoid linarith.comp) := sorry --non-trivial
lemma new_lemma_4345 (h0 : ring (complete_distrib_lattice environment.implicit_infer_kind)) : is_domain (complete_distrib_lattice environment.implicit_infer_kind) := sorry --non-trivial
lemma new_lemma_4346 (h0 : functor.add_const (cancel_comm_monoid_with_zero (has_to_string pos)) (finset linarith.comp)) : @unique_factorization_monoid.{0} (has_to_string.{0} pos) (@functor.add_const.run.{0 0} (cancel_comm_monoid_with_zero.{0} (has_to_string.{0} pos)) (finset.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_4347 (h0 : ring (semigroup (finset pos))) : rank_condition (semigroup (finset pos)) := sorry --non-trivial
lemma new_lemma_4348 (h0 : add_group (semigroup (finset ennreal))) : is_add_cyclic (semigroup (finset ennreal)) := sorry --non-trivial
lemma new_lemma_4349 (h0 : topological_space (has_top num)) : topological_space.separable_space (has_top num) := sorry --non-trivial
lemma new_lemma_4350 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @strong_rank_condition.{0} (has_nndist.{0} name) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (has_nndist.{0} name))  := sorry --non-trivial
lemma new_lemma_4351 (h0 : finset (normed_lattice_add_comm_group (has_add (has_pos_part Type)))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_4352 (h0 : complete_lattice (has_Sup (random_gen num))) : complete_lattice.is_Sup_finite_compact (has_Sup (random_gen num)) := sorry --non-trivial
lemma new_lemma_4353 (h0 : group (has_neg Type)) : group.fg (has_neg Type) := sorry --non-trivial
lemma new_lemma_4354 (h0 : topological_space (linear_ordered_field (option pos))) : path_connected_space (linear_ordered_field (option pos)) := sorry --non-trivial
lemma new_lemma_4355 (h0 : functor.add_const (topological_space (finset linarith.comp)) linarith.comp) : @path_connected_space.{0} (finset.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (finset.{0} linarith.comp)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_4356 (h0 : complete_lattice (normed_lattice_add_comm_group (has_Inf Type))) : complete_lattice.is_Sup_finite_compact (normed_lattice_add_comm_group (has_Inf Type)) := sorry --non-trivial
lemma new_lemma_4357 (h0 : not (function.extfun Type topological_space -> false)) : @locally_compact_space.{0} (has_ssubset.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (has_ssubset.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_4358 (h0 : topological_space (has_to_string (finset linarith.comp))) : discrete_topology (has_to_string (finset linarith.comp)) := sorry --non-trivial
lemma new_lemma_4359 (h0 : complete_lattice (comm_semigroup (has_pos_part (has_Inf real)))) : is_compactly_generated (comm_semigroup (has_pos_part (has_Inf real))) := sorry --non-trivial
lemma new_lemma_4360 (h1 : topological_space (has_emptyc (has_norm linarith.comp))) : totally_disconnected_space (has_emptyc (has_norm linarith.comp)) := sorry --non-trivial
lemma new_lemma_4361 (h0 : topological_space (canonically_ordered_comm_semiring (option num))) : topological_space.separable_space (canonically_ordered_comm_semiring (option num)) := sorry --non-trivial
lemma new_lemma_4362 (h0 : topological_space (emetric_space (semiring (semiring (semiring empty))))) : t0_space (emetric_space (semiring (semiring (semiring empty)))) := sorry --non-trivial
lemma new_lemma_4363 (h0 : ordered_add_comm_monoid (semigroup (option (option congr_arg_kind)))) : archimedean (semigroup (option (option congr_arg_kind))) := sorry --non-trivial
lemma new_lemma_4364 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @complete_space.{0} (comm_group.{0} name) (@function.extfun_app.{2 1} Type uniform_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 uniform_space.{0}) (comm_group.{0} name))  := sorry --non-trivial
lemma new_lemma_4365 (h0 : functor.add_const (uniform_space (has_to_string unsigned)) (option num)) : @complete_space.{0} (has_to_string.{0} unsigned) (@functor.add_const.run.{0 0} (uniform_space.{0} (has_to_string.{0} unsigned)) (option.{0} num) h0)  := sorry --non-trivial
lemma new_lemma_4366 (h0 : function.extfun Type topological_space) : @path_connected_space.{0} (canonically_linear_ordered_monoid.{0} real) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (canonically_linear_ordered_monoid.{0} real))  := sorry --non-trivial
lemma new_lemma_4367 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @separated_space.{0} (measurable_space.dynkin_system.{0} num) (@function.extfun_app.{2 1} Type uniform_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 uniform_space.{0}) (measurable_space.dynkin_system.{0} num))  := sorry --non-trivial
lemma new_lemma_4368 (h0 : topological_space (ring (has_neg_part Type))) : normal_space (ring (has_neg_part Type)) := sorry --non-trivial
lemma new_lemma_4369 (h0 : group (has_zero (has_add (has_add pos)))) : normalizer_condition (has_zero (has_add (has_add pos))) := sorry --non-trivial
lemma new_lemma_4370 (h0 : fin has_zero.zero) : @sequential_space.{0} (ordered_comm_monoid.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} (@matrix.vec_empty.{1} (function.extfun.{2 1} Type topological_space.{0}) (@matrix.vec_empty.{0} (fin (@has_zero.zero.{0} nat nat.has_zero)) (@matrix.vec_empty.{0} (fin (@has_zero.zero.{0} nat nat.has_zero)) h0))) (ordered_comm_monoid.{0} name))  := sorry --non-trivial
lemma new_lemma_4371 (h0 : ring (mul_one_class (mul_one_class char))) : strong_rank_condition (mul_one_class (mul_one_class char)) := sorry --non-trivial
lemma new_lemma_4372 (h0 : topological_space (has_nndist (finset linarith.comp))) : discrete_topology (has_nndist (finset linarith.comp)) := sorry --non-trivial
lemma new_lemma_4373 (h0 : linarith.comp -> linarith.comp -> Prop) (h1 : function.extfun linarith.comp (fun (x : linarith.comp), Prop)) : directed_on h0 (function.extfun_app h1) := sorry --non-trivial
lemma new_lemma_4374 (h0 : topological_space (parser ereal)) : path_connected_space (parser ereal) := sorry --non-trivial
lemma new_lemma_4375 (h1 : uniform_space (comm_group string.iterator_imp)) : complete_space (comm_group string.iterator_imp) := sorry --non-trivial
lemma new_lemma_4376 (h0 : function.extfun Type ring) : @strong_rank_condition.{0} (add_cancel_monoid.{0} num) (@function.extfun_app.{2 1} Type ring.{0} h0 (add_cancel_monoid.{0} num))  := sorry --non-trivial
lemma new_lemma_4377 (h0 : functor.add_const (function.extfun Type topological_space) name) : @sequential_space.{0} (has_pos_part.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) name h0) (has_pos_part.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_4378 (h0 : functor.add_const (monoid (normed_comm_ring (ring linarith.comp))) linarith.comp) : @monoid.fg.{0} (normed_comm_ring.{0} (ring.{0} linarith.comp)) (@functor.add_const.run.{0 0} (monoid.{0} (normed_comm_ring.{0} (ring.{0} linarith.comp))) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_4379 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @monoid.fg.{0} (ordered_cancel_add_comm_monoid.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 monoid.{0}) (ordered_cancel_add_comm_monoid.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_4380 (h0 : function.extfun Type filter) : filter.ne_bot (function.extfun_app h0 (add_group unsigned)) := sorry --non-trivial
lemma new_lemma_4381 (h0 : functor.add_const (add_group (semigroup pos)) name) : @is_add_cyclic.{0} (semigroup.{0} pos) (@functor.add_const.run.{0 0} (add_group.{0} (semigroup.{0} pos)) name h0)  := sorry --non-trivial
lemma new_lemma_4382 (h0 : filter (has_nndist (has_to_string name))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_4383 (h0 : topological_space (mul_zero_class (has_add (has_nndist unsigned)))) : totally_disconnected_space (mul_zero_class (has_add (has_nndist unsigned))) := sorry --non-trivial
lemma new_lemma_4384 (h0 : function.extfun Type uniform_space) : @separated_space.{0} (has_emptyc.{0} fun_info) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (has_emptyc.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_4385 (h0 : function.extfun Type topological_space) : @topological_space.separable_space.{0} (ring.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (ring.{0} empty))  := sorry --non-trivial
lemma new_lemma_4386 (h0 : function.extfun Type (functor.add_const (ordered_add_comm_monoid (has_bot empty)))) : @archimedean.{0} (has_bot.{0} empty) (@functor.add_const.run.{0 0} (ordered_add_comm_monoid.{0} (has_bot.{0} empty)) empty (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (ordered_add_comm_monoid.{0} (has_bot.{0} empty))) h0 empty))  := sorry --non-trivial
lemma new_lemma_4387 (h0 : function.extfun Type topological_space) : @preirreducible_space.{0} (ordered_ring.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (ordered_ring.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_4388 (h0 : not (ring (add_cancel_comm_monoid linarith.comp_source) -> false)) : @strong_rank_condition.{0} (add_cancel_comm_monoid.{0} linarith.comp_source) (@classical.by_contradiction'.{1} (ring.{0} (add_cancel_comm_monoid.{0} linarith.comp_source)) h0)  := sorry --non-trivial
lemma new_lemma_4389 (h0 : functor.add_const (uniform_space (bin_tree num)) empty) : @separated_space.{0} (bin_tree.{0} num) (@functor.add_const.run.{0 0} (uniform_space.{0} (bin_tree.{0} num)) empty h0)  := sorry --non-trivial
lemma new_lemma_4390 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @totally_separated_space.{0} (sub_neg_monoid.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (sub_neg_monoid.{0} pos))  := sorry --non-trivial
lemma new_lemma_4391 (h0 : not (topological_space (random_gen char) -> false)) : @totally_disconnected_space.{0} (random_gen.{0} char) (@classical.by_contradiction'.{1} (topological_space.{0} (random_gen.{0} char)) h0)  := sorry --non-trivial
lemma new_lemma_4392 (h0 : ring (boolean_algebra.core (finset pos))) : is_principal_ideal_ring (boolean_algebra.core (finset pos)) := sorry --non-trivial
lemma new_lemma_4393 (h0 : has_mem.mem (measurable_space (random_gen linarith.comp)) has_emptyc.emptyc) : @preirreducible_space.{0} (measurable_space.{0} (random_gen.{0} linarith.comp)) (@finset.pi.empty.{1 0} Type topological_space.{0} (measurable_space.{0} (random_gen.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_4394 (h0 : topological_space (has_emptyc (has_norm congr_arg_kind))) : locally_compact_space (has_emptyc (has_norm congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_4395 (h0 : list (complete_distrib_lattice (boolean_algebra environment.implicit_infer_kind))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_4396 (h0 : topological_space (sub_neg_monoid (finset (finset pos)))) : t0_space (sub_neg_monoid (finset (finset pos))) := sorry --non-trivial
lemma new_lemma_4397 (h0 : pos -> pos -> pos) : left_commutative h0 := sorry --non-trivial
lemma new_lemma_4398 (h0 : ring (ordered_comm_ring (has_pos_part (has_add pos)))) : rank_condition (ordered_comm_ring (has_pos_part (has_add pos))) := sorry --non-trivial
lemma new_lemma_4399 (h0 : add_group (normed_field (has_nnnorm linarith.comp_source))) : is_add_cyclic (normed_field (has_nnnorm linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_4400 (h0 : ring (measurable_space (has_top empty))) : rank_condition (measurable_space (has_top empty)) := sorry --non-trivial
lemma new_lemma_4401 (h0 : has_mem.mem to_additive.value_type has_emptyc.emptyc) : @irreducible_space.{0} to_additive.value_type (@finset.pi.empty.{1 0} Type topological_space.{0} to_additive.value_type h0)  := sorry --non-trivial
lemma new_lemma_4402 (h0 : ordered_comm_monoid (normed_lattice_add_comm_group (has_neg linarith.comp))) : has_exists_mul_of_le (normed_lattice_add_comm_group (has_neg linarith.comp)) := sorry --non-trivial
lemma new_lemma_4403 (h0 : list (has_zero (comm_monoid (boolean_algebra.core ennreal)))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_4404 (h0 : topological_space (finset (has_pos_part pos))) : loc_path_connected_space (finset (has_pos_part pos)) := sorry --non-trivial
lemma new_lemma_4405 (h0 : topological_space (has_emptyc (has_norm (has_norm num)))) (h1 : measurable_space (has_emptyc (has_norm (has_norm num)))) : opens_measurable_space (has_emptyc (has_norm (has_norm num))) := sorry --non-trivial
lemma new_lemma_4406 (h0 : topological_space (has_bot real)) : t1_space (has_bot real) := sorry --non-trivial
lemma new_lemma_4407 (h0 : function.extfun Type topological_space) : @t0_space.{0} (has_Inf.{0} real) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_Inf.{0} real))  := sorry --non-trivial
lemma new_lemma_4408 (h0 : functor.add_const (functor.add_const (add_cancel_monoid Type) linarith.comp) Type) : list.nodup (list.ret (functor.add_const.run (functor.add_const.run h0))) := sorry --non-trivial
lemma new_lemma_4409 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @complete_lattice.is_Sup_finite_compact.{0} (canonically_linear_ordered_monoid.{0} pos) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (canonically_linear_ordered_monoid.{0} pos))  := sorry --non-trivial
lemma new_lemma_4410 (h0 : functor.add_const (function.extfun Type ring) empty) : @strong_rank_condition.{0} (free_add_monoid.{0} empty) (@function.extfun_app.{2 1} Type ring.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type ring.{0}) empty h0) (free_add_monoid.{0} empty))  := sorry --non-trivial
lemma new_lemma_4411 (h0 : function.extfun (nat -> Type) (function.extfun nat)) : @complete_lattice.is_Sup_finite_compact.{0} (has_pos_part.{0} real) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@matrix.vec_empty.{1} (function.extfun.{2 1} Type complete_lattice.{0}) (@function.extfun_app.{1 1} nat fin (@function.extfun_app.{2 1} (nat → Type) (function.extfun.{1 1} nat) h0 fin) (@has_zero.zero.{0} nat nat.has_zero))) (has_pos_part.{0} real))  := sorry --non-trivial
lemma new_lemma_4412 (h1 : topological_space (normed_group linarith.comp)) : path_connected_space (normed_group linarith.comp) := sorry --non-trivial
lemma new_lemma_4413 (h0 : group (comm_group (cancel_monoid (has_add Type)))) : group.fg (comm_group (cancel_monoid (has_add Type))) := sorry --non-trivial
lemma new_lemma_4414 (h0 : topological_space (add_comm_monoid (comm_semigroup pos))) : path_connected_space (add_comm_monoid (comm_semigroup pos)) := sorry --non-trivial
lemma new_lemma_4415 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @irreducible_space.{0} (measurable_space.dynkin_system.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (measurable_space.dynkin_system.{0} empty))  := sorry --non-trivial
lemma new_lemma_4416 (h1 : topological_space fun_info) (h2 : add_group fun_info) : topological_add_group fun_info := sorry --non-trivial
lemma new_lemma_4417 (h0 : topological_space (add_cancel_monoid (ring (has_add name)))) : regular_space (add_cancel_monoid (ring (has_add name))) := sorry --non-trivial
lemma new_lemma_4418 (h0 h1 : set (prod linarith.comp_source linarith.comp_source)) (h2 : prod linarith.comp_source linarith.comp_source) : comp_rel h0 h1 h2 := sorry --non-trivial
lemma new_lemma_4419 (h0 : functor.add_const (cancel_comm_monoid_with_zero (has_to_string pos)) (ring Type)) : @unique_factorization_monoid.{0} (has_to_string.{0} pos) (@functor.add_const.run.{0 1} (cancel_comm_monoid_with_zero.{0} (has_to_string.{0} pos)) (ring.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_4420 (h0 : function.extfun Type list) : list.nodup (function.extfun_app h0 (pseudo_metric_space name)) := sorry --non-trivial
lemma new_lemma_4421 (h1 : ring (semiring (has_norm linarith.ineq))) : is_domain (semiring (has_norm linarith.ineq)) := sorry --non-trivial
lemma new_lemma_4422 (h0 : functor.add_const (uniform_space (comm_group linarith.comp)) (finset Type)) : @complete_space.{0} (comm_group.{0} linarith.comp) (@functor.add_const.run.{0 1} (uniform_space.{0} (comm_group.{0} linarith.comp)) (finset.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_4423 (h0 : functor.add_const (topological_space (plift congr_arg_kind)) num) : @irreducible_space.{1} (plift.{1} congr_arg_kind) (@functor.add_const.run.{1 0} (topological_space.{1} (plift.{1} congr_arg_kind)) num h0)  := sorry --non-trivial
lemma new_lemma_4424 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @totally_disconnected_space.{0} (add_cancel_monoid.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (add_cancel_monoid.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_4425 (h0 : topological_space (normed_lattice_add_comm_group (has_bot (sub_neg_monoid (boolean_algebra real))))) : normal_space (normed_lattice_add_comm_group (has_bot (sub_neg_monoid (boolean_algebra real)))) := sorry --non-trivial
lemma new_lemma_4426 (h0 : complete_lattice (has_one (has_top (has_top congr_arg_kind)))) : is_compactly_generated (has_one (has_top (has_top congr_arg_kind))) := sorry --non-trivial
lemma new_lemma_4427 (h0 : add_group (has_pos_part (has_bot name))) : is_add_cyclic (has_pos_part (has_bot name)) := sorry --non-trivial
lemma new_lemma_4428 (h0 : functor.add_const (complete_lattice pos) Type) : @is_compactly_generated.{0} pos (@functor.add_const.run.{0 1} (complete_lattice.{0} pos) Type h0)  := sorry --non-trivial
lemma new_lemma_4429 (h0 : monoid (ordered_comm_group unsigned)) : monoid.fg (ordered_comm_group unsigned) := sorry --non-trivial
lemma new_lemma_4430 (h0 : functor.add_const (function.extfun Type add_group) pos) : @is_add_cyclic.{0} (ordered_comm_ring.{0} name) (@function.extfun_app.{2 1} Type add_group.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type add_group.{0}) pos h0) (ordered_comm_ring.{0} name))  := sorry --non-trivial
lemma new_lemma_4431 (h0 : ring (has_zero (has_neg (mul_one_class Type)))) : is_principal_ideal_ring (has_zero (has_neg (mul_one_class Type))) := sorry --non-trivial
lemma new_lemma_4432 (h0 : not (function.extfun Type topological_space -> false)) : @path_connected_space.{0} (add_group.{0} (semiring.{0} (semiring.{0} (semiring.{0} (semiring.{0} empty))))) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (add_group.{0} (semiring.{0} (semiring.{0} (semiring.{0} (semiring.{0} empty))))))  := sorry --non-trivial
lemma new_lemma_4433 (h0 : functor.add_const (function.extfun Type topological_space) linarith.comp) : @regular_space.{0} (add_cancel_monoid.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) linarith.comp h0) (add_cancel_monoid.{0} pos))  := sorry --non-trivial
lemma new_lemma_4434 (h0 : ring (sub_neg_monoid (has_Inf (has_neg name)))) : is_domain (sub_neg_monoid (has_Inf (has_neg name))) := sorry --non-trivial
lemma new_lemma_4435 (h5 : topological_space (has_norm linarith.ineq)) : path_connected_space (has_norm linarith.ineq) := sorry --non-trivial
lemma new_lemma_4436 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @topological_space.separable_space.{0} (semigroup.{0} ennreal) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (semigroup.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_4437 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @totally_separated_space.{0} (has_emptyc.{0} linarith.ineq) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_emptyc.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_4438 (h0 : group (ordered_cancel_add_comm_monoid (has_to_string pos))) : is_cyclic (ordered_cancel_add_comm_monoid (has_to_string pos)) := sorry --non-trivial
lemma new_lemma_4439 (h0 : complete_lattice (generalized_boolean_algebra pos)) : complete_lattice.is_Sup_finite_compact (generalized_boolean_algebra pos) := sorry --non-trivial
lemma new_lemma_4440 (h0 : functor.add_const (topological_space (has_neg Type)) linarith.comp) : @topological_space.separable_space.{1} (has_neg.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (has_neg.{1} Type)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_4441 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @totally_disconnected_space.{0} (has_norm.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_norm.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_4442 (h0 : functor.add_const (function.extfun Type group) pos) : @group.fg.{0} (has_zero.{0} linarith.comp) (@function.extfun_app.{2 1} Type group.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type group.{0}) pos h0) (has_zero.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_4443 (h0 : functor.add_const (topological_space (has_zero environment.implicit_infer_kind)) name) : @regular_space.{0} (has_zero.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (has_zero.{0} environment.implicit_infer_kind)) name h0)  := sorry --non-trivial
lemma new_lemma_4444 (h0 : topological_space (has_nndist num)) : irreducible_space (has_nndist num) := sorry --non-trivial
lemma new_lemma_4445 (h0 : function.extfun Type topological_space) : @locally_compact_space.{0} (add_left_cancel_semigroup.{0} (option.{0} unsigned)) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (add_left_cancel_semigroup.{0} (option.{0} unsigned)))  := sorry --non-trivial
lemma new_lemma_4446 (h0 : cancel_comm_monoid_with_zero (left_cancel_monoid congr_arg_kind)) : unique_factorization_monoid (left_cancel_monoid congr_arg_kind) := sorry --non-trivial
lemma new_lemma_4447 (h0 : ordered_comm_monoid (boolean_algebra.core (cancel_monoid environment.implicit_infer_kind))) : has_exists_mul_of_le (boolean_algebra.core (cancel_monoid environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_4448 (h0 : functor.comp list add_cancel_monoid Type) : list.nodup (functor.comp.run h0) := sorry --non-trivial
lemma new_lemma_4449 (h0 : topological_space (random_gen (random_gen linarith.ineq))) : totally_disconnected_space (random_gen (random_gen linarith.ineq)) := sorry --non-trivial
lemma new_lemma_4450 (h0 : function.extfun Type complete_lattice) : @is_compactly_generated.{0} (canonically_ordered_comm_semiring.{0} pos) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (canonically_ordered_comm_semiring.{0} pos))  := sorry --non-trivial
lemma new_lemma_4451 (h0 : uniform_space (filter congr_arg_kind)) : complete_space (filter congr_arg_kind) := sorry --non-trivial
lemma new_lemma_4452 (h0 : add_group (has_inv (has_nnnorm (random_gen to_additive.value_type)))) : is_add_cyclic (has_inv (has_nnnorm (random_gen to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_4453 (h0 : functor.add_const (ordered_comm_monoid (add_cancel_monoid pos)) linarith.comp) : @has_exists_mul_of_le.{0} (add_cancel_monoid.{0} pos) (@functor.add_const.run.{0 0} (ordered_comm_monoid.{0} (add_cancel_monoid.{0} pos)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_4454 (h0 : ring (metric_space linarith.comp)) : rank_condition (metric_space linarith.comp) := sorry --non-trivial
lemma new_lemma_4455 (h0 : add_monoid fun_info) (h1 : add_submonoid fun_info) : add_submonoid.fg h1 := sorry --non-trivial
lemma new_lemma_4456 (h0 : filter (finset congr_arg_kind)) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_4457 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @monoid.fg.{0} (with_one.{0} string_imp) (@function.extfun_app.{2 1} Type monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 monoid.{0}) (with_one.{0} string_imp))  := sorry --non-trivial
lemma new_lemma_4458 (h0 : list (complete_distrib_lattice (finset (ring pos)))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_4459 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : totally_disconnected_space real := sorry --non-trivial
lemma new_lemma_4460 (h0 : not (topological_space (semiring (has_top linarith.comp_source)) -> false)) : @totally_disconnected_space.{0} (semiring.{0} (has_top.{0} linarith.comp_source)) (@classical.by_contradiction'.{1} (topological_space.{0} (semiring.{0} (has_top.{0} linarith.comp_source))) h0)  := sorry --non-trivial
lemma new_lemma_4461 (h0 : topological_space (dlist to_additive.value_type)) : path_connected_space (dlist to_additive.value_type) := sorry --non-trivial
lemma new_lemma_4462 (h0 : functor.add_const (group (add_cancel_monoid Type)) name) : @group.fg.{1} (add_cancel_monoid.{1} Type) (@functor.add_const.run.{1 0} (group.{1} (add_cancel_monoid.{1} Type)) name h0)  := sorry --non-trivial
lemma new_lemma_4463 (h0 : complete_lattice (complete_distrib_lattice unsigned)) : is_atomistic (complete_distrib_lattice unsigned) := sorry --non-trivial
lemma new_lemma_4464 (h0 : topological_space (has_top (has_top (has_top to_additive.value_type)))) : discrete_topology (has_top (has_top (has_top to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_4465 (h0 : list (ring (has_to_string name))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_4466 (h0 : functor.add_const (list (left_cancel_monoid empty)) empty) : palindrome (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_4467 (h0 : not (group (mul_zero_class empty) -> false)) : @is_cyclic.{0} (mul_zero_class.{0} empty) (@classical.by_contradiction'.{1} (group.{0} (mul_zero_class.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_4468 (h0 : function.extfun Type ring) : @is_principal_ideal_ring.{0} (finset.{0} empty) (@function.extfun_app.{2 1} Type ring.{0} h0 (finset.{0} empty))  := sorry --non-trivial
lemma new_lemma_4469 (h0 : functor.add_const (functor.add_const (function.extfun Type ring) pos) linarith.comp) : @strong_rank_condition.{0} (has_nndist.{0} linarith.comp) (@function.extfun_app.{2 1} Type ring.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type ring.{0}) pos (@functor.add_const.run.{1 0} (functor.add_const.{1 0} (function.extfun.{2 1} Type ring.{0}) pos) linarith.comp h0)) (has_nndist.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_4470 (h0 : group (ordered_comm_ring (has_pos_part pos))) : normalizer_condition (ordered_comm_ring (has_pos_part pos)) := sorry --non-trivial
lemma new_lemma_4471 (h0 : add_group (has_to_string (comm_group Type))) : is_add_cyclic (has_to_string (comm_group Type)) := sorry --non-trivial
lemma new_lemma_4472 (h9 : add_group (random_gen fun_info)) : is_add_cyclic (random_gen fun_info) := sorry --non-trivial
lemma new_lemma_4473 (h0 : ring (comm_group (has_to_string name))) : strong_rank_condition (comm_group (has_to_string name)) := sorry --non-trivial
lemma new_lemma_4474 (h0 : topological_space (add_semigroup congr_arg_kind)) : t0_space (add_semigroup congr_arg_kind) := sorry --non-trivial
lemma new_lemma_4475 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @preirreducible_space.{0} (canonically_ordered_add_monoid.{0} (complete_distrib_lattice.{0} empty)) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (canonically_ordered_add_monoid.{0} (complete_distrib_lattice.{0} empty)))  := sorry --non-trivial
lemma new_lemma_4476 (h0 : group (has_norm (semiring (random_gen linarith.comp)))) : group.fg (has_norm (semiring (random_gen linarith.comp))) := sorry --non-trivial
lemma new_lemma_4477 (h0 : filter (complete_semilattice_Sup (semiring empty))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_4478 (h0 : topological_space (has_union (linear_ordered_semiring empty))) : preirreducible_space (has_union (linear_ordered_semiring empty)) := sorry --non-trivial
lemma new_lemma_4479 (h0 : functor.add_const (topological_space (has_zero pos)) environment.implicit_infer_kind) : @preirreducible_space.{0} (has_zero.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (has_zero.{0} pos)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_4480 (h0 : topological_space (free_add_monoid (semiring num))) : loc_path_connected_space (free_add_monoid (semiring num)) := sorry --non-trivial
lemma new_lemma_4481 (h0 : topological_space (linear_ordered_comm_group (option ennreal))) : t0_space (linear_ordered_comm_group (option ennreal)) := sorry --non-trivial
lemma new_lemma_4482 (h0 : complete_lattice (has_bot (has_pos_part pos))) : complete_lattice.is_Sup_finite_compact (has_bot (has_pos_part pos)) := sorry --non-trivial
lemma new_lemma_4483 (h0 : topological_space (has_norm (has_norm fun_info))) : totally_disconnected_space (has_norm (has_norm fun_info)) := sorry --non-trivial
lemma new_lemma_4484 (h1 : not (complete_lattice (linear_ordered_comm_group_with_zero linarith.comp_source) -> false)) : @complete_lattice.is_Sup_finite_compact.{0} (linear_ordered_comm_group_with_zero.{0} linarith.comp_source) (@classical.by_contradiction'.{1} (complete_lattice.{0} (linear_ordered_comm_group_with_zero.{0} linarith.comp_source)) h1)  := sorry --non-trivial
lemma new_lemma_4485 (h0 : functor.add_const (group (canonically_ordered_add_monoid empty)) unsigned) : @is_cyclic.{0} (canonically_ordered_add_monoid.{0} empty) (@functor.add_const.run.{0 0} (group.{0} (canonically_ordered_add_monoid.{0} empty)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_4486 (h0 : not (function.extfun Type group -> false)) : @is_cyclic.{0} linarith.comp_source (@function.extfun_app.{2 1} Type group.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type group.{0}) h0) linarith.comp_source)  := sorry --non-trivial
lemma new_lemma_4487 (h0 : not (topological_space (has_star empty) -> false)) : @irreducible_space.{0} (has_star.{0} empty) (@classical.by_contradiction'.{1} (topological_space.{0} (has_star.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_4488 (h0 : function.extfun Type topological_space) : @preconnected_space.{0} (linear_ordered_comm_group.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (linear_ordered_comm_group.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_4489 (h0 : measurable_space (has_ssubset char)) (h1 : filter (has_ssubset char)) : filter.is_measurably_generated h1 := sorry --non-trivial
lemma new_lemma_4490 (h0 : complete_lattice (normed_group (random_gen (distrib_lattice linarith.ineq)))) : is_compactly_generated (normed_group (random_gen (distrib_lattice linarith.ineq))) := sorry --non-trivial
lemma new_lemma_4491 (h0 : function.extfun Type (functor.add_const (ring (has_Sup empty)))) : @is_domain.{0} (has_Sup.{0} empty) (@functor.add_const.run.{0 0} (ring.{0} (has_Sup.{0} empty)) empty (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (ring.{0} (has_Sup.{0} empty))) h0 empty))  := sorry --non-trivial
lemma new_lemma_4492 (h0 : functor.add_const (group (add_left_cancel_semigroup empty)) (option unsigned)) : @is_cyclic.{0} (add_left_cancel_semigroup.{0} empty) (@functor.add_const.run.{0 0} (group.{0} (add_left_cancel_semigroup.{0} empty)) (option.{0} unsigned) h0)  := sorry --non-trivial
lemma new_lemma_4493 (h0 : functor.add_const (topological_space (add_semigroup empty)) empty) : @topological_space.separable_space.{0} (add_semigroup.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (add_semigroup.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_4494 (h0 : not (topological_space Type -> false)) : @t0_space.{1} Type (@classical.by_contradiction'.{2} (topological_space.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_4495 (h0 : function.extfun Type topological_space) : @totally_disconnected_space.{0} (has_append.{0} (comm_ring.{0} fun_info)) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_append.{0} (comm_ring.{0} fun_info)))  := sorry --non-trivial
lemma new_lemma_4496 (h0 : functor.add_const (topological_space (generalized_boolean_algebra linarith.comp)) pos) : @t0_space.{0} (generalized_boolean_algebra.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (generalized_boolean_algebra.{0} linarith.comp)) pos h0)  := sorry --non-trivial
lemma new_lemma_4497 (h0 : functor.add_const (ring (has_neg linarith.comp)) name) : @is_principal_ideal_ring.{0} (has_neg.{0} linarith.comp) (@functor.add_const.run.{0 0} (ring.{0} (has_neg.{0} linarith.comp)) name h0)  := sorry --non-trivial
lemma new_lemma_4498 (h0 : topological_space (semiring (random_gen fun_info))) : irreducible_space (semiring (random_gen fun_info)) := sorry --non-trivial
lemma new_lemma_4499 (h0 : function.extfun nat fin) : @is_add_cyclic.{0} (comm_semigroup.{0} pos) (@matrix.vec_empty.{0} (add_group.{0} (comm_semigroup.{0} pos)) (@matrix.vec_empty.{0} (fin (@has_zero.zero.{0} nat nat.has_zero)) (@matrix.vec_empty.{0} (fin (@has_zero.zero.{0} nat nat.has_zero)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))))  := sorry --non-trivial
lemma new_lemma_4500 (h0 : functor.add_const (ordered_comm_monoid (canonically_ordered_comm_semiring Type)) name) : @has_exists_mul_of_le.{1} (canonically_ordered_comm_semiring.{1} Type) (@functor.add_const.run.{1 0} (ordered_comm_monoid.{1} (canonically_ordered_comm_semiring.{1} Type)) name h0)  := sorry --non-trivial
lemma new_lemma_4501 (h1 : topological_space (comm_ring (has_nnnorm linarith.ineq))) : totally_disconnected_space (comm_ring (has_nnnorm linarith.ineq)) := sorry --non-trivial
lemma new_lemma_4502 (h0 : functor.add_const (group (has_to_string environment.implicit_infer_kind)) linarith.comp) : @group.fg.{0} (has_to_string.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (group.{0} (has_to_string.{0} environment.implicit_infer_kind)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_4503 (h0 : topological_space (semi_normed_comm_ring char)) : locally_compact_space (semi_normed_comm_ring char) := sorry --non-trivial
lemma new_lemma_4504 (h0 : set (has_abs char -> fun_info)) : set.separates_points h0 := sorry --non-trivial
lemma new_lemma_4505 (h1 : complete_lattice (complete_semilattice_Sup (random_gen num))) : complete_lattice.is_Sup_finite_compact (complete_semilattice_Sup (random_gen num)) := sorry --non-trivial
lemma new_lemma_4506 (h0 : not (function.extfun Type group -> false)) : @normalizer_condition.{0} (complete_linear_order.{0} empty) (@function.extfun_app.{2 1} Type group.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type group.{0}) h0) (complete_linear_order.{0} empty))  := sorry --non-trivial
lemma new_lemma_4507 (h0 : add_group (has_lt std_gen)) : is_add_cyclic (has_lt std_gen) := sorry --non-trivial
lemma new_lemma_4508 (h0 : functor.add_const (topological_space (finset linarith.comp)) Type) : @t1_space.{0} (finset.{0} linarith.comp) (@functor.add_const.run.{0 1} (topological_space.{0} (finset.{0} linarith.comp)) Type h0)  := sorry --non-trivial
lemma new_lemma_4509 (h0 : set (comm_ring string_imp)) : set.finite h0 := sorry --non-trivial
lemma new_lemma_4510 (h0 : has_mem.mem (measurable_space num) has_emptyc.emptyc) : @discrete_topology.{0} (measurable_space.{0} num) (@finset.pi.empty.{1 0} Type topological_space.{0} (measurable_space.{0} num) h0)  := sorry --non-trivial
lemma new_lemma_4511 (h0 : add_group (has_lt (mul_one_class string.iterator_imp))) : is_add_cyclic (has_lt (mul_one_class string.iterator_imp)) := sorry --non-trivial
lemma new_lemma_4512 (h0 : function.extfun Type topological_space) : @totally_disconnected_space.{0} (comm_monoid.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (comm_monoid.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_4513 (h0 : ring (canonically_ordered_comm_semiring (option unsigned))) : is_principal_ideal_ring (canonically_ordered_comm_semiring (option unsigned)) := sorry --non-trivial
lemma new_lemma_4514 (h0 : uniform_space (has_union (has_top empty))) : complete_space (has_union (has_top empty)) := sorry --non-trivial
lemma new_lemma_4515 (h0 : ring (has_Inf Type)) : strong_rank_condition (has_Inf Type) := sorry --non-trivial
lemma new_lemma_4516 (h0 : complete_lattice (has_norm (has_inv (has_inv (random_gen (has_inv (has_inv linarith.comp_source))))))) : is_atomistic (has_norm (has_inv (has_inv (random_gen (has_inv (has_inv linarith.comp_source)))))) := sorry --non-trivial
lemma new_lemma_4517 (h0 : topological_space (left_cancel_semigroup (semiring unsigned))) : locally_compact_space (left_cancel_semigroup (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_4518 (h0 : functor.add_const (function.extfun (Type 1) ordered_add_comm_monoid) linarith.comp) : @archimedean.{1} (has_Inf.{1} Type) (@function.extfun_app.{3 2} (Type 1) ordered_add_comm_monoid.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) ordered_add_comm_monoid.{1}) linarith.comp h0) (has_Inf.{1} Type))  := sorry --non-trivial
lemma new_lemma_4519 (h0 : function.extfun Type topological_space) : @totally_disconnected_space.{0} (add_cancel_monoid.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (add_cancel_monoid.{0} pos))  := sorry --non-trivial
lemma new_lemma_4520 (h0 : ring (has_compl (mul_one_class linarith.comp_source))) : rank_condition (has_compl (mul_one_class linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_4521 (h0 : list (measurable_space (has_inv to_additive.value_type))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_4522 (h0 : finset (has_zero (has_neg (finset linarith.comp)))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_4523 (h0 : not (ring (normed_field (mul_one_class char)) -> false)) : @is_domain.{0} (normed_field.{0} (mul_one_class.{0} char)) (@classical.by_contradiction'.{1} (ring.{0} (normed_field.{0} (mul_one_class.{0} char))) h0)  := sorry --non-trivial
lemma new_lemma_4524 (h0 : ring (ordered_comm_monoid pos)) : is_principal_ideal_ring (ordered_comm_monoid pos) := sorry --non-trivial
lemma new_lemma_4525 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @t1_space.{0} (as_linear_order.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (as_linear_order.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_4526 (h0 : function.extfun nat fin) : @preirreducible_space.{1} (ordered_comm_monoid.{1} Type) (@matrix.vec_empty.{1} (topological_space.{1} (ordered_comm_monoid.{1} Type)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_4527 (h0 : finset (measurable_space.dynkin_system num)) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_4528 (h0 : functor.add_const (list (finset Type)) (has_neg (has_Inf linarith.comp))) : palindrome (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_4529 (h0 : topological_space (add_right_cancel_monoid (semiring (semiring congr_arg_kind)))) : preirreducible_space (add_right_cancel_monoid (semiring (semiring congr_arg_kind))) := sorry --non-trivial
lemma new_lemma_4530 (h0 : add_group (has_pos_part real)) : is_add_cyclic (has_pos_part real) := sorry --non-trivial
lemma new_lemma_4531 (h0 : topological_space (with_bot (random_gen to_additive.value_type))) : totally_separated_space (with_bot (random_gen to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_4532 (h0 : functor.add_const (topological_space (has_to_string environment.implicit_infer_kind)) pos) : @discrete_topology.{0} (has_to_string.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (has_to_string.{0} environment.implicit_infer_kind)) pos h0)  := sorry --non-trivial
lemma new_lemma_4533 (h0 : semiring (linear_ordered_comm_ring (has_top empty))) : is_noetherian_ring (linear_ordered_comm_ring (has_top empty)) := sorry --non-trivial
lemma new_lemma_4534 (h0 : complete_lattice (linear_ordered_comm_ring (semiring congr_arg_kind))) : is_atomistic (linear_ordered_comm_ring (semiring congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_4535 (h0 : preorder (add_comm_semigroup (add_comm_semigroup (nondiscrete_normed_field ereal)))) (h1 : set (add_comm_semigroup (add_comm_semigroup (nondiscrete_normed_field ereal)))) : set.is_pwo h1 := sorry --non-trivial
lemma new_lemma_4536 (h0 : group (has_bot (option (option empty)))) : is_cyclic (has_bot (option (option empty))) := sorry --non-trivial
lemma new_lemma_4537 (h0 : topological_space (semigroup (ring linarith.comp))) : discrete_topology (semigroup (ring linarith.comp)) := sorry --non-trivial
lemma new_lemma_4538 (h0 : topological_space (finset (has_to_string linarith.comp))) : discrete_topology (finset (has_to_string linarith.comp)) := sorry --non-trivial
lemma new_lemma_4539 (h0 : topological_space (has_top (semiring (semiring (semiring unsigned))))) : totally_disconnected_space (has_top (semiring (semiring (semiring unsigned)))) := sorry --non-trivial
lemma new_lemma_4540 (h0 : group (with_bot (random_gen linarith.ineq))) : normalizer_condition (with_bot (random_gen linarith.ineq)) := sorry --non-trivial
lemma new_lemma_4541 (h0 : topological_space (semigroup (semigroup unsigned))) : topological_space.separable_space (semigroup (semigroup unsigned)) := sorry --non-trivial
lemma new_lemma_4542 (h0 : functor.add_const (topological_space (generalized_boolean_algebra linarith.comp)) (add_cancel_monoid name)) : @preirreducible_space.{0} (generalized_boolean_algebra.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (generalized_boolean_algebra.{0} linarith.comp)) (add_cancel_monoid.{0} name) h0)  := sorry --non-trivial
lemma new_lemma_4543 (h0 : functor.add_const (topological_space (has_to_string unsigned)) Type) : @preirreducible_space.{0} (has_to_string.{0} unsigned) (@functor.add_const.run.{0 1} (topological_space.{0} (has_to_string.{0} unsigned)) Type h0)  := sorry --non-trivial
lemma new_lemma_4544 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_noetherian_ring.{0} (non_assoc_semiring.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type semiring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 semiring.{0}) (non_assoc_semiring.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_4545 (h0 : ring (has_div enat)) : strong_rank_condition (has_div enat) := sorry --non-trivial
lemma new_lemma_4546 (h0 : functor.add_const (functor.add_const (add_group (normed_comm_ring pos)) pos) (normed_comm_ring Type)) : @is_add_cyclic.{0} (normed_comm_ring.{0} pos) (@functor.add_const.run.{0 0} (add_group.{0} (normed_comm_ring.{0} pos)) pos (@functor.add_const.run.{0 1} (functor.add_const.{0 0} (add_group.{0} (normed_comm_ring.{0} pos)) pos) (normed_comm_ring.{1} Type) h0))  := sorry --non-trivial
lemma new_lemma_4547 (h0 : topological_space (has_emptyc (random_gen (semiring linarith.comp_source)))) : t0_space (has_emptyc (random_gen (semiring linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_4548 (h0 : has_mem.mem (has_norm linarith.comp) has_emptyc.emptyc) : @is_atomistic.{0} (has_norm.{0} linarith.comp) (@finset.pi.empty.{1 0} Type complete_lattice.{0} (has_norm.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_4549 (h0 : topological_space (boolean_algebra unsigned)) : preirreducible_space (boolean_algebra unsigned) := sorry --non-trivial
lemma new_lemma_4550 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @locally_compact_space.{0} (comm_ring.{0} linarith.ineq) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (comm_ring.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_4551 (h0 : topological_space (add_group (semiring empty))) : preirreducible_space (add_group (semiring empty)) := sorry --non-trivial
lemma new_lemma_4552 (h0 : functor.add_const (topological_space (canonically_linear_ordered_monoid name)) unsigned) : @regular_space.{0} (canonically_linear_ordered_monoid.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (canonically_linear_ordered_monoid.{0} name)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_4553 (h0 : function.extfun Type topological_space) : @path_connected_space.{0} (normed_group.{0} (has_inv.{0} (has_ssubset.{0} (has_ssubset.{0} fun_info)))) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (normed_group.{0} (has_inv.{0} (has_ssubset.{0} (has_ssubset.{0} fun_info)))))  := sorry --non-trivial
lemma new_lemma_4554 (h0 : cancel_comm_monoid_with_zero (semigroup (option ennreal))) : unique_factorization_monoid (semigroup (option ennreal)) := sorry --non-trivial
lemma new_lemma_4555 (h0 : topological_space (boolean_algebra (has_neg Type))) : totally_separated_space (boolean_algebra (has_neg Type)) := sorry --non-trivial
lemma new_lemma_4556 (h0 : topological_space (finset (add_comm_monoid Type))) : locally_compact_space (finset (add_comm_monoid Type)) := sorry --non-trivial
lemma new_lemma_4557 (h0 : complete_lattice (partial_order (has_norm empty))) : is_compactly_generated (partial_order (has_norm empty)) := sorry --non-trivial
lemma new_lemma_4558 (h0 : ring (boolean_algebra.core (option (option unsigned)))) : strong_rank_condition (boolean_algebra.core (option (option unsigned))) := sorry --non-trivial
lemma new_lemma_4559 (h0 : topological_space (ring linarith.comp)) : preirreducible_space (ring linarith.comp) := sorry --non-trivial
lemma new_lemma_4560 (h0 : group (has_compl string_imp)) : is_cyclic (has_compl string_imp) := sorry --non-trivial
lemma new_lemma_4561 (h0 : not (complete_lattice (has_compl string_imp) -> false)) : @is_compactly_generated.{0} (has_compl.{0} string_imp) (@classical.by_contradiction'.{1} (complete_lattice.{0} (has_compl.{0} string_imp)) h0)  := sorry --non-trivial
lemma new_lemma_4562 (h0 : functor.add_const (complete_lattice (has_sdiff name)) unsigned) : @complete_lattice.is_Sup_finite_compact.{0} (has_sdiff.{0} name) (@functor.add_const.run.{0 0} (complete_lattice.{0} (has_sdiff.{0} name)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_4563 (h0 : functor.add_const (topological_space pos) name) : @locally_compact_space.{0} pos (@functor.add_const.run.{0 0} (topological_space.{0} pos) name h0)  := sorry --non-trivial
lemma new_lemma_4564 (h0 : functor.add_const (function.extfun (Type 1) finset) linarith.comp) : finset.nonempty (function.extfun_app (functor.add_const.run h0) (normed_comm_ring Type)) := sorry --non-trivial
lemma new_lemma_4565 (h0 : functor.add_const (monoid (has_nndist pos)) Type) : @monoid.fg.{0} (has_nndist.{0} pos) (@functor.add_const.run.{0 1} (monoid.{0} (has_nndist.{0} pos)) Type h0)  := sorry --non-trivial
lemma new_lemma_4566 (h0 : topological_space (simple_graph (has_Inf (has_add linarith.comp)))) : t1_space (simple_graph (has_Inf (has_add linarith.comp))) := sorry --non-trivial
lemma new_lemma_4567 (h0 : filter (complete_distrib_lattice (linear_ordered_field ennreal))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_4568 (h0 : topological_space (simple_graph (has_add linarith.comp))) : preconnected_space (simple_graph (has_add linarith.comp)) := sorry --non-trivial
lemma new_lemma_4569 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @regular_space.{0} (has_Inf.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_Inf.{0} pos))  := sorry --non-trivial
lemma new_lemma_4570 (h0 : not (function.extfun Type monoid -> false)) : @monoid.fg.{0} (with_bot.{0} empty) (@function.extfun_app.{2 1} Type monoid.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type monoid.{0}) h0) (with_bot.{0} empty))  := sorry --non-trivial
lemma new_lemma_4571 (h0 : fin has_zero.zero) : @complete_lattice.is_Sup_finite_compact.{0} (has_pos_part.{0} linarith.comp) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@matrix.vec_empty.{1} (function.extfun.{2 1} Type complete_lattice.{0}) h0) (has_pos_part.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_4572 (h0 : functor.add_const (function.extfun (Type 1) uniform_space) linarith.comp) : @separated_space.{1} (add_cancel_monoid.{1} Type) (@function.extfun_app.{3 2} (Type 1) uniform_space.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) uniform_space.{1}) linarith.comp h0) (add_cancel_monoid.{1} Type))  := sorry --non-trivial
lemma new_lemma_4573 (h0 : functor.add_const (topological_space (has_Inf Type)) pos) : @discrete_topology.{1} (has_Inf.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (has_Inf.{1} Type)) pos h0)  := sorry --non-trivial
lemma new_lemma_4574 (h0 : uniform_space (uniform_space (has_ssubset string.iterator_imp))) : complete_space (uniform_space (has_ssubset string.iterator_imp)) := sorry --non-trivial
lemma new_lemma_4575 (h0 : function.extfun Type topological_space) : @topological_space.separable_space.{0} (has_star.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_star.{0} empty))  := sorry --non-trivial
lemma new_lemma_4576 (h0 : functor.add_const (function.extfun Type list) Type) : list.nodup (function.extfun_app (functor.add_const.run h0) (ring linarith.comp)) := sorry --non-trivial
lemma new_lemma_4577 (h0 : topological_space (has_union (has_norm linarith.comp))) : path_connected_space (has_union (has_norm linarith.comp)) := sorry --non-trivial
lemma new_lemma_4578 (h0 : group (id (has_top unsigned))) : group.fg (id (has_top unsigned)) := sorry --non-trivial
lemma new_lemma_4579 (h0 : functor.add_const (topological_space (semigroup Type)) (has_neg (has_zero Type))) : @path_connected_space.{1} (semigroup.{1} Type) (@functor.add_const.run.{1 1} (topological_space.{1} (semigroup.{1} Type)) (has_neg.{1} (has_zero.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_4580 (h0 : add_group (linear_ordered_semiring (has_top to_additive.value_type))) : is_add_cyclic (linear_ordered_semiring (has_top to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_4581 (h0 : finset (has_neg_part (has_nndist ennreal))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_4582 (h0 : functor.add_const (list (ordered_ring congr_arg_kind)) unsigned) : list.nodup (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_4583 (h0 : functor.add_const (complete_lattice (finset ennreal)) name) : @is_atomistic.{0} (finset.{0} ennreal) (@functor.add_const.run.{0 0} (complete_lattice.{0} (finset.{0} ennreal)) name h0)  := sorry --non-trivial
lemma new_lemma_4584 (h0 : functor.add_const (complete_lattice (has_nndist linarith.comp)) (finset Type)) : @complete_lattice.is_Sup_finite_compact.{0} (has_nndist.{0} linarith.comp) (@functor.add_const.run.{0 1} (complete_lattice.{0} (has_nndist.{0} linarith.comp)) (finset.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_4585 (h3 : ring (has_ssubset (has_ssubset (random_gen fun_info)))) : strong_rank_condition (has_ssubset (has_ssubset (random_gen fun_info))) := sorry --non-trivial
lemma new_lemma_4586 (h0 : uniform_space (has_bot (has_Inf pos))) : separated_space (has_bot (has_Inf pos)) := sorry --non-trivial
lemma new_lemma_4587 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_simple_group.{0} (canonically_linear_ordered_monoid.{0} pos) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (canonically_linear_ordered_monoid.{0} pos))  := sorry --non-trivial
lemma new_lemma_4588 (h0 : ring (mul_one_class (add_comm_semigroup (mul_one_class (mul_one_class enat))))) : strong_rank_condition (mul_one_class (add_comm_semigroup (mul_one_class (mul_one_class enat)))) := sorry --non-trivial
lemma new_lemma_4589 (h0 : ring (cancel_monoid congr_arg_kind)) : is_principal_ideal_ring (cancel_monoid congr_arg_kind) := sorry --non-trivial
lemma new_lemma_4590 (h0 : function.extfun (finset (Type -> Type) -> Prop) (function.extfun (finset (Type -> Type)))) : @totally_disconnected_space.{0} (@id.{2} Type empty) (@function.extfun_app.{2 1} Type topological_space.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) topological_space.{0} (@function.extfun_app.{2 0} (finset.{1} (Type → Type)) (@has_mem.mem.{1 1} (Type → Type) (finset.{1} (Type → Type)) (@finset.has_mem.{1} (Type → Type)) topological_space.{0}) (@function.extfun_app.{2 0} (finset.{1} (Type → Type) → Prop) (function.extfun.{2 0} (finset.{1} (Type → Type))) h0 (@has_mem.mem.{1 1} (Type → Type) (finset.{1} (Type → Type)) (@finset.has_mem.{1} (Type → Type)) topological_space.{0})) (@has_emptyc.emptyc.{1} (finset.{1} (Type → Type)) (@finset.has_emptyc.{1} (Type → Type))))) (@id.{2} Type empty))  := sorry --non-trivial
lemma new_lemma_4591 (h0 : uniform_space (semigroup (comm_group (has_neg_part (has_to_string Type))))) : complete_space (semigroup (comm_group (has_neg_part (has_to_string Type)))) := sorry --non-trivial
lemma new_lemma_4592 (h0 : complete_lattice (linear_ordered_cancel_comm_monoid empty)) : is_atomistic (linear_ordered_cancel_comm_monoid empty) := sorry --non-trivial
lemma new_lemma_4593 (h0 : function.extfun nat fin) : @complete_space.{1} (canonically_linear_ordered_monoid.{1} Type) (@matrix.vec_empty.{1} (uniform_space.{1} (canonically_linear_ordered_monoid.{1} Type)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_4594 (h0 : functor.add_const (topological_space (has_neg Type)) (has_neg linarith.comp)) : @t1_space.{1} (has_neg.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (has_neg.{1} Type)) (has_neg.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_4595 (h0 : functor.add_const (uniform_space (ordered_ring num)) num) : @separated_space.{0} (ordered_ring.{0} num) (@functor.add_const.run.{0 0} (uniform_space.{0} (ordered_ring.{0} num)) num h0)  := sorry --non-trivial
lemma new_lemma_4596 (h0 : functor.add_const (function.extfun Type complete_lattice) (has_to_string Type)) : @is_compactly_generated.{0} (normed_comm_ring.{0} name) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type complete_lattice.{0}) (has_to_string.{1} Type) h0) (normed_comm_ring.{0} name))  := sorry --non-trivial
lemma new_lemma_4597 (h0 : has_mem.mem monoid has_emptyc.emptyc) : @monoid.fg.{0} (normed_group.{0} num) (@function.extfun_app.{2 1} Type monoid.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) monoid.{0} h0) (normed_group.{0} num))  := sorry --non-trivial
lemma new_lemma_4598 (h0 : function.extfun Type ring) : @strong_rank_condition.{0} (has_Inf.{0} real) (@function.extfun_app.{2 1} Type ring.{0} h0 (has_Inf.{0} real))  := sorry --non-trivial
lemma new_lemma_4599 (h0 : function.extfun Type (functor.add_const (topological_space (has_edist empty)))) : @locally_compact_space.{0} (has_edist.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (has_edist.{0} empty)) empty (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (topological_space.{0} (has_edist.{0} empty))) h0 empty))  := sorry --non-trivial
lemma new_lemma_4600 (h1 : topological_space (random_gen reducibility_hints)) (h2 : preorder (random_gen reducibility_hints)) : order_topology (random_gen reducibility_hints) := sorry --non-trivial
lemma new_lemma_4601 (h0 : functor.add_const (add_group (add_cancel_monoid linarith.comp)) Type) : @is_add_cyclic.{0} (add_cancel_monoid.{0} linarith.comp) (@functor.add_const.run.{0 1} (add_group.{0} (add_cancel_monoid.{0} linarith.comp)) Type h0)  := sorry --non-trivial
lemma new_lemma_4602 (h0 : functor.add_const (topological_space (has_zero unsigned)) Type) : @topological_space.separable_space.{0} (has_zero.{0} unsigned) (@functor.add_const.run.{0 1} (topological_space.{0} (has_zero.{0} unsigned)) Type h0)  := sorry --non-trivial
lemma new_lemma_4603 (h0 : not (group (topological_space to_additive.value_type) -> false)) : @group.fg.{0} (topological_space.{0} to_additive.value_type) (@classical.by_contradiction'.{1} (group.{0} (topological_space.{0} to_additive.value_type)) h0)  := sorry --non-trivial
lemma new_lemma_4604 (h0 : ring (finset (has_neg_part environment.implicit_infer_kind))) : is_principal_ideal_ring (finset (has_neg_part environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_4605 (h0 : list (has_nndist (has_nndist num))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_4606 (h0 : ring (has_neg_part (has_add Type))) : is_principal_ideal_ring (has_neg_part (has_add Type)) := sorry --non-trivial
lemma new_lemma_4607 (h0 : not (ring (has_ssubset reducibility_hints) -> false)) : @rank_condition.{0} (has_ssubset.{0} reducibility_hints) (@classical.by_contradiction'.{1} (ring.{0} (has_ssubset.{0} reducibility_hints)) h0)  := sorry --non-trivial
lemma new_lemma_4608 (h2 : filter char) : filter.ne_bot h2 := sorry --non-trivial
lemma new_lemma_4609 (h0 : topological_space (has_zero (has_to_string name))) : t1_space (has_zero (has_to_string name)) := sorry --non-trivial
lemma new_lemma_4610 (h0 : ring (with_one (semiring linarith.comp))) : is_domain (with_one (semiring linarith.comp)) := sorry --non-trivial
lemma new_lemma_4611 (h0 : group (dlist (linear_ordered_add_comm_group fun_info))) : group.fg (dlist (linear_ordered_add_comm_group fun_info)) := sorry --non-trivial
lemma new_lemma_4612 (h0 : functor.add_const (complete_lattice empty) congr_arg_kind) : @is_compactly_generated.{0} empty (@functor.add_const.run.{0 0} (complete_lattice.{0} empty) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_4613 (h0 : group (semigroup (has_neg environment.implicit_infer_kind))) : normalizer_condition (semigroup (has_neg environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_4614 (h0 : finset (left_cancel_semigroup empty)) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_4615 (h0 : function.extfun Type monoid) : @monoid.fg.{0} (mul_zero_class.{0} empty) (@function.extfun_app.{2 1} Type monoid.{0} h0 (mul_zero_class.{0} empty))  := sorry --non-trivial
lemma new_lemma_4616 (h1 : has_mem.mem complete_lattice has_emptyc.emptyc) : @complete_lattice.is_Sup_finite_compact.{0} (semiring.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) complete_lattice.{0} h1) (semiring.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_4617 (h0 : function.extfun Type group) : @is_cyclic.{0} (complete_distrib_lattice.{0} linarith.comp) (@function.extfun_app.{2 1} Type group.{0} h0 (complete_distrib_lattice.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_4618 (h0 : function.extfun Type topological_space) : @regular_space.{0} (add_comm_monoid.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (add_comm_monoid.{0} name))  := sorry --non-trivial
lemma new_lemma_4619 (h0 : functor.add_const (topological_space (has_dist unsigned)) empty) : @totally_separated_space.{0} (has_dist.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (has_dist.{0} unsigned)) empty h0)  := sorry --non-trivial
lemma new_lemma_4620 (h0 : has_mem.mem (with_bot linarith.comp_source) has_emptyc.emptyc) : @locally_compact_space.{0} (with_bot.{0} linarith.comp_source) (@finset.pi.empty.{1 0} Type topological_space.{0} (with_bot.{0} linarith.comp_source) h0)  := sorry --non-trivial
lemma new_lemma_4621 (h0 : topological_space (ring (has_neg (finset (has_neg linarith.comp))))) : normal_space (ring (has_neg (finset (has_neg linarith.comp)))) := sorry --non-trivial
lemma new_lemma_4622 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @irreducible_space.{0} (has_edist.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_edist.{0} empty))  := sorry --non-trivial
lemma new_lemma_4623 (h0 : functor.comp group linear_ordered_field (option unsigned)) : @group.fg.{0} (linear_ordered_field.{0} (option.{0} unsigned)) (@functor.comp.run.{0 0 0} group.{0} linear_ordered_field.{0} (option.{0} unsigned) h0)  := sorry --non-trivial
lemma new_lemma_4624 (h0 : functor.add_const (filter (has_add environment.implicit_infer_kind)) Type) : countable_Inter_filter (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_4625 (h0 : complete_lattice (has_top (has_norm linarith.ineq))) : complete_lattice.is_Sup_finite_compact (has_top (has_norm linarith.ineq)) := sorry --non-trivial
lemma new_lemma_4626 (h0 : topological_space (has_inv linarith.comp_source)) : path_connected_space (has_inv linarith.comp_source) := sorry --non-trivial
lemma new_lemma_4627 (h1 : topological_space (topological_space (random_gen (random_gen linarith.ineq)))) : locally_compact_space (topological_space (random_gen (random_gen linarith.ineq))) := sorry --non-trivial
lemma new_lemma_4628 (h0 : not (topological_space (distrib_lattice fun_info) -> false)) (h1 : preorder (distrib_lattice fun_info)) : @order_topology.{0} (distrib_lattice.{0} fun_info) (@classical.by_contradiction'.{1} (topological_space.{0} (distrib_lattice.{0} fun_info)) h0) h1  := sorry --non-trivial
lemma new_lemma_4629 (h0 : functor.add_const (topological_space (complete_distrib_lattice Type)) environment.implicit_infer_kind) : @sequential_space.{1} (complete_distrib_lattice.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (complete_distrib_lattice.{1} Type)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_4630 (h0 : topological_space (filter (semiring (semiring empty)))) : t1_space (filter (semiring (semiring empty))) := sorry --non-trivial
lemma new_lemma_4631 (h0 : function.extfun Type ring) : @rank_condition.{0} (has_norm.{0} linarith.comp) (@function.extfun_app.{2 1} Type ring.{0} h0 (has_norm.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_4632 (h0 : filter (normed_comm_ring (option name))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_4633 (h0 : function.extfun (finset Type) (has_mem.mem (complete_semilattice_Sup empty))) : @complete_lattice.is_Sup_finite_compact.{0} (complete_semilattice_Sup.{0} empty) (@finset.pi.empty.{1 0} Type complete_lattice.{0} (complete_semilattice_Sup.{0} empty) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (complete_semilattice_Sup.{0} empty)) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_4634 (h0 : functor.add_const (ring (complete_distrib_lattice Type)) pos) : @is_principal_ideal_ring.{1} (complete_distrib_lattice.{1} Type) (@functor.add_const.run.{1 0} (ring.{1} (complete_distrib_lattice.{1} Type)) pos h0)  := sorry --non-trivial
lemma new_lemma_4635 (h0 : function.extfun Type uniform_space) : @complete_space.{0} (monoid.{0} empty) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (monoid.{0} empty))  := sorry --non-trivial
lemma new_lemma_4636 (h0 : topological_space (linear_ordered_field congr_arg_kind)) : normal_space (linear_ordered_field congr_arg_kind) := sorry --non-trivial
lemma new_lemma_4637 (h0 : topological_space (linear_ordered_field (option pos))) : sequential_space (linear_ordered_field (option pos)) := sorry --non-trivial
lemma new_lemma_4638 (h0 : ring (distrib (mul_one_class (comm_ring (has_nnnorm char))))) : rank_condition (distrib (mul_one_class (comm_ring (has_nnnorm char)))) := sorry --non-trivial
lemma new_lemma_4639 (h0 : functor.add_const (group (cancel_monoid pos)) name) : @normalizer_condition.{0} (cancel_monoid.{0} pos) (@functor.add_const.run.{0 0} (group.{0} (cancel_monoid.{0} pos)) name h0)  := sorry --non-trivial
lemma new_lemma_4640 (h1 : not (add_group (random_gen char) -> false)) : @is_add_cyclic.{0} (random_gen.{0} char) (@classical.by_contradiction'.{1} (add_group.{0} (random_gen.{0} char)) h1)  := sorry --non-trivial
lemma new_lemma_4641 (h0 : function.extfun Type complete_lattice) : @is_compactly_generated.{0} (group_with_zero.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (group_with_zero.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_4642 (h0 : not (topological_space (uniform_space (mul_one_class fun_info)) -> false)) : @totally_disconnected_space.{0} (uniform_space.{0} (mul_one_class.{0} fun_info)) (@classical.by_contradiction'.{1} (topological_space.{0} (uniform_space.{0} (mul_one_class.{0} fun_info))) h0)  := sorry --non-trivial
lemma new_lemma_4643 (h0 : uniform_space (simple_graph unsigned)) : separated_space (simple_graph unsigned) := sorry --non-trivial
lemma new_lemma_4644 (h0 : complete_lattice (distrib_lattice linarith.ineq)) : is_atomistic (distrib_lattice linarith.ineq) := sorry --non-trivial
lemma new_lemma_4645 (h0 : uniform_space (has_bot linarith.comp)) : separated_space (has_bot linarith.comp) := sorry --non-trivial
lemma new_lemma_4646 (h0 : functor.add_const (complete_lattice (ring pos)) name) : @is_atomistic.{0} (ring.{0} pos) (@functor.add_const.run.{0 0} (complete_lattice.{0} (ring.{0} pos)) name h0)  := sorry --non-trivial
lemma new_lemma_4647 (h0 : not (function.extfun Type semiring -> false)) : @is_noetherian_ring.{0} (has_one.{0} unsigned) (@function.extfun_app.{2 1} Type semiring.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type semiring.{0}) h0) (has_one.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_4648 (h0 : ring (distrib (has_nnnorm linarith.ineq))) : strong_rank_condition (distrib (has_nnnorm linarith.ineq)) := sorry --non-trivial
lemma new_lemma_4649 (h0 : monoid (boolean_algebra (ring linarith.comp))) : monoid.fg (boolean_algebra (ring linarith.comp)) := sorry --non-trivial
lemma new_lemma_4650 (h0 : add_group (has_compl (has_ssubset (has_ssubset char)))) : is_add_cyclic (has_compl (has_ssubset (has_ssubset char))) := sorry --non-trivial
lemma new_lemma_4651 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : list.nodup (function.extfun_app (function.extfun_app h0 list) (has_top to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_4652 (h0 : topological_space (normed_field fun_info)) (h1 : preorder (normed_field fun_info)) : order_topology (normed_field fun_info) := sorry --non-trivial
lemma new_lemma_4653 (h0 : list (topological_space (has_le environment.projection_info))) (h1 : nat) (h2 : has_lt.lt h1 (list.length h0)) : @path_connected_space.{0} (has_le.{0} environment.projection_info) (@list.nth_le.{0} (topological_space.{0} (has_le.{0} environment.projection_info)) h0 h1 h2)  := sorry --non-trivial
lemma new_lemma_4654 (h0 : uniform_space (has_to_string ennreal)) : complete_space (has_to_string ennreal) := sorry --non-trivial
lemma new_lemma_4655 (h0 : ring (measurable_space.dynkin_system (semiring (semiring empty)))) : strong_rank_condition (measurable_space.dynkin_system (semiring (semiring empty))) := sorry --non-trivial
lemma new_lemma_4656 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_cyclic.{0} (has_top.{0} fun_info) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (has_top.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_4657 (h0 : function.extfun Type filter) : filter.ne_bot (function.extfun_app h0 (has_neg_part pos)) := sorry --non-trivial
lemma new_lemma_4658 (h0 : ring (has_add (has_Inf (has_Inf real)))) : rank_condition (has_add (has_Inf (has_Inf real))) := sorry --non-trivial
lemma new_lemma_4659 (h0 : topological_space (has_add (sub_neg_monoid Type))) : discrete_topology (has_add (sub_neg_monoid Type)) := sorry --non-trivial
lemma new_lemma_4660 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @complete_space.{0} (linear_ordered_field.{0} ennreal) (@function.extfun_app.{2 1} Type uniform_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 uniform_space.{0}) (linear_ordered_field.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_4661 (h0 : topological_space (has_nndist (has_nndist unsigned))) : discrete_topology (has_nndist (has_nndist unsigned)) := sorry --non-trivial
lemma new_lemma_4662 (h0 : functor.add_const (complete_lattice Type) (has_pos_part linarith.comp)) : @is_compactly_generated.{1} Type (@functor.add_const.run.{1 0} (complete_lattice.{1} Type) (has_pos_part.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_4663 (h0 : ordered_add_comm_monoid (boolean_algebra (ring linarith.comp))) : archimedean (boolean_algebra (ring linarith.comp)) := sorry --non-trivial
lemma new_lemma_4664 (h0 : not (function.extfun Type topological_space -> false)) : @totally_separated_space.{0} (metric_space.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (metric_space.{0} empty))  := sorry --non-trivial
lemma new_lemma_4665 (h0 : ring (generalized_boolean_algebra (has_neg linarith.comp))) : strong_rank_condition (generalized_boolean_algebra (has_neg linarith.comp)) := sorry --non-trivial
lemma new_lemma_4666 (h0 : comm_ring (linear_ordered_add_comm_group string_imp)) (h1 : polynomial (linear_ordered_add_comm_group string_imp)) (h2 : ring (adjoin_root h1)) : is_domain (adjoin_root h1) := sorry --non-trivial
lemma new_lemma_4667 (h0 : list (linear_ordered_field (option (has_nndist (finset (cancel_monoid ennreal)))))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_4668 (h0 : not (add_group (fintype linarith.ineq) -> false)) : @is_add_cyclic.{0} (fintype.{0} linarith.ineq) (@classical.by_contradiction'.{1} (add_group.{0} (fintype.{0} linarith.ineq)) h0)  := sorry --non-trivial
lemma new_lemma_4669 (h0 : add_monoid (comm_semigroup pos)) : add_monoid.fg (comm_semigroup pos) := sorry --non-trivial
lemma new_lemma_4670 (h0 : ring (has_Sup (option (option empty)))) : is_principal_ideal_ring (has_Sup (option (option empty))) := sorry --non-trivial
lemma new_lemma_4671 (h0 : function.extfun Type (functor.comp uniform_space ring)) : @separated_space.{0} (ring.{0} name) (@functor.comp.run.{0 0 0} uniform_space.{0} ring.{0} name (@function.extfun_app.{2 1} Type (functor.comp.{0 0 0} uniform_space.{0} ring.{0}) h0 name))  := sorry --non-trivial
lemma new_lemma_4672 (h0 : function.extfun Type topological_space) : @locally_compact_space.{0} (complete_semilattice_Sup.{0} fun_info) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (complete_semilattice_Sup.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_4673 (h0 : add_group (non_unital_non_assoc_semiring (uniform_space (mul_one_class reducibility_hints)))) : is_add_cyclic (non_unital_non_assoc_semiring (uniform_space (mul_one_class reducibility_hints))) := sorry --non-trivial
lemma new_lemma_4674 (h0 : has_mem.mem (has_norm congr_arg_kind) has_emptyc.emptyc) : @totally_disconnected_space.{0} (has_norm.{0} congr_arg_kind) (@finset.pi.empty.{1 0} Type topological_space.{0} (has_norm.{0} congr_arg_kind) h0)  := sorry --non-trivial
lemma new_lemma_4675 (h0 : list (linear_ordered_comm_ring (semiring num))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_4676 (h0 : topological_space (has_zero (has_add pos))) : t1_space (has_zero (has_add pos)) := sorry --non-trivial
lemma new_lemma_4677 (h0 : functor.add_const (topological_space (has_to_string linarith.comp)) pos) : @sequential_space.{0} (has_to_string.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (has_to_string.{0} linarith.comp)) pos h0)  := sorry --non-trivial
lemma new_lemma_4678 (h0 : ordered_comm_monoid (has_neg (finset ennreal))) : has_exists_mul_of_le (has_neg (finset ennreal)) := sorry --non-trivial
lemma new_lemma_4679 (h0 : complete_lattice (add_right_cancel_monoid reducibility_hints)) : complete_lattice.is_Sup_finite_compact (add_right_cancel_monoid reducibility_hints) := sorry --non-trivial
lemma new_lemma_4680 (h0 : functor.add_const (ring (semigroup linarith.comp)) (has_add name)) : @strong_rank_condition.{0} (semigroup.{0} linarith.comp) (@functor.add_const.run.{0 0} (ring.{0} (semigroup.{0} linarith.comp)) (has_add.{0} name) h0)  := sorry --non-trivial
lemma new_lemma_4681 (h0 : ordered_add_comm_monoid (has_neg name)) : archimedean (has_neg name) := sorry --non-trivial
lemma new_lemma_4682 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @unique_factorization_monoid.{1} (canonically_ordered_comm_semiring.{1} (has_add.{1} Type)) (@function.extfun_app.{3 2} (Type 1) cancel_comm_monoid_with_zero.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 cancel_comm_monoid_with_zero.{1}) (canonically_ordered_comm_semiring.{1} (has_add.{1} Type)))  := sorry --non-trivial
lemma new_lemma_4683 (h0 : functor.add_const (group (linear_order num)) (option (option unsigned))) : @is_cyclic.{0} (linear_order.{0} num) (@functor.add_const.run.{0 0} (group.{0} (linear_order.{0} num)) (option.{0} (option.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_4684 (h0 : has_mem.mem (has_emptyc linarith.comp) has_emptyc.emptyc) : @complete_space.{0} (has_emptyc.{0} linarith.comp) (@finset.pi.empty.{1 0} Type uniform_space.{0} (has_emptyc.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_4685 (h0 : functor.add_const (topological_space (ring linarith.comp)) (ring Type)) : @totally_disconnected_space.{0} (ring.{0} linarith.comp) (@functor.add_const.run.{0 1} (topological_space.{0} (ring.{0} linarith.comp)) (ring.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_4686 (h0 : functor.add_const (complete_lattice (boolean_algebra Type)) environment.implicit_infer_kind) : @is_atomistic.{1} (boolean_algebra.{1} Type) (@functor.add_const.run.{1 0} (complete_lattice.{1} (boolean_algebra.{1} Type)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_4687 (h0 : functor.add_const (ring real.angle) congr_arg_kind) : @rank_condition.{0} real.angle (@functor.add_const.run.{0 0} (ring.{0} real.angle) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_4688 (h0 : not (group (complete_semilattice_Sup congr_arg_kind) -> false)) : @normalizer_condition.{0} (complete_semilattice_Sup.{0} congr_arg_kind) (@classical.by_contradiction'.{1} (group.{0} (complete_semilattice_Sup.{0} congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_4689 (h0 : ordered_add_comm_monoid (finset Type)) : archimedean (finset Type) := sorry --non-trivial
lemma new_lemma_4690 (h0 : uniform_space (semigroup (mul_zero_class unsigned))) : complete_space (semigroup (mul_zero_class unsigned)) := sorry --non-trivial
lemma new_lemma_4691 (h0 : topological_space (has_Inf (has_neg (has_add name)))) : sequential_space (has_Inf (has_neg (has_add name))) := sorry --non-trivial
lemma new_lemma_4692 (h0 : has_mem.mem topological_space has_emptyc.emptyc) : @irreducible_space.{0} (has_top.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) topological_space.{0} h0) (has_top.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_4693 (h0 : filter (linear_ordered_comm_ring (semiring num))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_4694 (h0 : function.extfun Type monoid) : @monoid.fg.{0} (has_norm.{0} linarith.comp) (@function.extfun_app.{2 1} Type monoid.{0} h0 (has_norm.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_4695 (h0 : group (has_sub num)) : normalizer_condition (has_sub num) := sorry --non-trivial
lemma new_lemma_4696 (h0 : function.extfun Type monoid) : @monoid.fg.{0} (with_bot.{0} string_imp) (@function.extfun_app.{2 1} Type monoid.{0} h0 (with_bot.{0} string_imp))  := sorry --non-trivial
lemma new_lemma_4697 (h0 : functor.add_const (finset (boolean_algebra linarith.comp)) (has_Inf Type)) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_4698 (h0 : functor.add_const (topological_space (ring name)) name) : @locally_compact_space.{0} (ring.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (ring.{0} name)) name h0)  := sorry --non-trivial
lemma new_lemma_4699 (h2 : topological_space (dlist char)) : path_connected_space (dlist char) := sorry --non-trivial
lemma new_lemma_4700 (h0 : topological_space (has_norm (semiring linarith.comp))) : totally_separated_space (has_norm (semiring linarith.comp)) := sorry --non-trivial
lemma new_lemma_4701 (h0 : functor.add_const (uniform_space (has_to_string Type)) (has_pos_part pos)) : @complete_space.{1} (has_to_string.{1} Type) (@functor.add_const.run.{1 0} (uniform_space.{1} (has_to_string.{1} Type)) (has_pos_part.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_4702 (h0 : functor.add_const (topological_space (linear_ordered_comm_monoid_with_zero unsigned)) num) : @normal_space.{0} (linear_ordered_comm_monoid_with_zero.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (linear_ordered_comm_monoid_with_zero.{0} unsigned)) num h0)  := sorry --non-trivial
lemma new_lemma_4703 (h0 : topological_space stieltjes_function) : normal_space stieltjes_function := sorry --non-trivial
lemma new_lemma_4704 (h1 : topological_space (complete_semilattice_Sup congr_arg_kind)) : totally_disconnected_space (complete_semilattice_Sup congr_arg_kind) := sorry --non-trivial
lemma new_lemma_4705 (h0 : topological_space (has_zero Type)) : discrete_topology (has_zero Type) := sorry --non-trivial
lemma new_lemma_4706 (h0 : fin has_zero.zero) : @add_monoid.fg.{0} (has_pos_part.{0} real) (@matrix.vec_empty.{0} (add_monoid.{0} (has_pos_part.{0} real)) (@matrix.vec_empty.{0} (fin (@has_zero.zero.{0} nat nat.has_zero)) (@matrix.vec_empty.{0} (fin (@has_zero.zero.{0} nat nat.has_zero)) (@matrix.vec_empty.{0} (fin (@has_zero.zero.{0} nat nat.has_zero)) (@matrix.vec_empty.{0} (fin (@has_zero.zero.{0} nat nat.has_zero)) (@matrix.vec_empty.{0} (fin (@has_zero.zero.{0} nat nat.has_zero)) (@matrix.vec_empty.{0} (fin (@has_zero.zero.{0} nat nat.has_zero)) (@matrix.vec_empty.{0} (fin (@has_zero.zero.{0} nat nat.has_zero)) (@matrix.vec_empty.{0} (fin (@has_zero.zero.{0} nat nat.has_zero)) (@matrix.vec_empty.{0} (fin (@has_zero.zero.{0} nat nat.has_zero)) (@matrix.vec_empty.{0} (fin (@has_zero.zero.{0} nat nat.has_zero)) (@matrix.vec_empty.{0} (fin (@has_zero.zero.{0} nat nat.has_zero)) (@matrix.vec_empty.{0} (fin (@has_zero.zero.{0} nat nat.has_zero)) (@matrix.vec_empty.{0} (fin (@has_zero.zero.{0} nat nat.has_zero)) h0))))))))))))))  := sorry --non-trivial
lemma new_lemma_4707 (h1 : ring (has_inv linarith.comp_source)) : is_domain (has_inv linarith.comp_source) := sorry --non-trivial
lemma new_lemma_4708 (h0 : topological_space (semi_normed_comm_ring (has_nnnorm to_additive.value_type))) : path_connected_space (semi_normed_comm_ring (has_nnnorm to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_4709 (h0 : topological_space (complete_distrib_lattice empty) -> Prop) (h1 : Exists (fun (x : topological_space (complete_distrib_lattice empty)), h0 x)) : @loc_path_connected_space.{0} (complete_distrib_lattice.{0} empty) (@classical.some.{1} (topological_space.{0} (complete_distrib_lattice.{0} empty)) h0 h1)  := sorry --non-trivial
lemma new_lemma_4710 (h1 : uniform_space (has_ssubset to_additive.value_type)) : complete_space (has_ssubset to_additive.value_type) := sorry --non-trivial
lemma new_lemma_4711 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @separated_space.{0} (has_zero.{0} linarith.comp) (@function.extfun_app.{2 1} Type uniform_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 uniform_space.{0}) (has_zero.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_4712 (h0 : add_group (with_one linarith.comp)) : is_add_cyclic (with_one linarith.comp) := sorry --non-trivial
lemma new_lemma_4713 (h0 : topological_space (canonically_ordered_comm_semiring (has_nndist linarith.comp))) : path_connected_space (canonically_ordered_comm_semiring (has_nndist linarith.comp)) := sorry --non-trivial
lemma new_lemma_4714 (h0 : functor.add_const (functor.comp add_group semigroup name) pos) : @is_add_cyclic.{0} (semigroup.{0} name) (@functor.comp.run.{0 0 0} add_group.{0} semigroup.{0} name (@functor.add_const.run.{0 0} (functor.comp.{0 0 0} add_group.{0} semigroup.{0} name) pos h0))  := sorry --non-trivial
lemma new_lemma_4715 (h0 : topological_space (has_Inf (has_Inf Type))) : irreducible_space (has_Inf (has_Inf Type)) := sorry --non-trivial
lemma new_lemma_4716 (h1 : function.extfun Type topological_space) : @irreducible_space.{0} (with_bot.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h1 (with_bot.{0} empty))  := sorry --non-trivial
lemma new_lemma_4717 (h0 : complete_lattice (with_one (measurable_space num))) : is_compactly_generated (with_one (measurable_space num)) := sorry --non-trivial
lemma new_lemma_4718 (h0 : functor.add_const (uniform_space (add_cancel_monoid unsigned)) congr_arg_kind) : @complete_space.{0} (add_cancel_monoid.{0} unsigned) (@functor.add_const.run.{0 0} (uniform_space.{0} (add_cancel_monoid.{0} unsigned)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_4719 (h1 : add_group (random_gen string_imp)) : is_add_cyclic (random_gen string_imp) := sorry --non-trivial
lemma new_lemma_4720 (h0 : topological_space (complete_distrib_lattice (ring (has_add (boolean_algebra Type))))) : preconnected_space (complete_distrib_lattice (ring (has_add (boolean_algebra Type)))) := sorry --non-trivial
lemma new_lemma_4721 (h0 : function.extfun (Type 1) topological_space) : @irreducible_space.{1} Type (@function.extfun_app.{3 2} (Type 1) topological_space.{1} h0 Type)  := sorry --non-trivial
lemma new_lemma_4722 (h0 : topological_space (complete_distrib_lattice ennreal)) : sequential_space (complete_distrib_lattice ennreal) := sorry --non-trivial
lemma new_lemma_4723 (h1 : complete_lattice (has_lt char)) : is_compactly_generated (has_lt char) := sorry --non-trivial
lemma new_lemma_4724 (h0 : complete_lattice (comm_ring (has_nnnorm fun_info))) : is_compactly_generated (comm_ring (has_nnnorm fun_info)) := sorry --non-trivial
lemma new_lemma_4725 (h0 : topological_space (with_bot (has_top num))) : totally_separated_space (with_bot (has_top num)) := sorry --non-trivial
lemma new_lemma_4726 (h0 : function.extfun (Type 1) ring) : @is_domain.{1} (plift.{1} empty) (@function.extfun_app.{3 2} (Type 1) ring.{1} h0 (plift.{1} empty))  := sorry --non-trivial
lemma new_lemma_4727 (h1 : topological_space (has_top to_additive.value_type)) : irreducible_space (has_top to_additive.value_type) := sorry --non-trivial
lemma new_lemma_4728 (h0 : group (distrib_lattice (random_gen to_additive.value_type))) : group.fg (distrib_lattice (random_gen to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_4729 (h0 : function.extfun Type topological_space) : @preconnected_space.{0} (canonically_ordered_comm_semiring.{0} ennreal) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (canonically_ordered_comm_semiring.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_4730 (h0 : group (has_Inf (finset pos))) : normalizer_condition (has_Inf (finset pos)) := sorry --non-trivial
lemma new_lemma_4731 (h1 : complete_lattice (comm_ring (random_gen string_imp))) : is_compactly_generated (comm_ring (random_gen string_imp)) := sorry --non-trivial
lemma new_lemma_4732 (h0 : functor.add_const (topological_space (cancel_monoid congr_arg_kind)) num) : @loc_path_connected_space.{0} (cancel_monoid.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (cancel_monoid.{0} congr_arg_kind)) num h0)  := sorry --non-trivial
lemma new_lemma_4733 (h0 : topological_space (distrib_lattice char)) : path_connected_space (distrib_lattice char) := sorry --non-trivial
lemma new_lemma_4734 (h0 : function.extfun (finset (Type -> Type)) (has_mem.mem group)) : @normalizer_condition.{0} (semiring.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type group.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) group.{0} (@function.extfun_app.{2 0} (finset.{1} (Type → Type)) (@has_mem.mem.{1 1} (Type → Type) (finset.{1} (Type → Type)) (@finset.has_mem.{1} (Type → Type)) group.{0}) h0 (@has_emptyc.emptyc.{1} (finset.{1} (Type → Type)) (@finset.has_emptyc.{1} (Type → Type))))) (semiring.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_4735 (h0 : functor.add_const (topological_space (boolean_algebra.core environment.implicit_infer_kind)) name) : @preirreducible_space.{0} (boolean_algebra.core.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (boolean_algebra.core.{0} environment.implicit_infer_kind)) name h0)  := sorry --non-trivial
lemma new_lemma_4736 (h0 : prod (boolean_algebra.core name) (boolean_algebra.core name)) : id_rel h0 := sorry --non-trivial
lemma new_lemma_4737 (h0 : functor.add_const (topological_space (has_zero unsigned)) environment.implicit_infer_kind) : @totally_separated_space.{0} (has_zero.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (has_zero.{0} unsigned)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_4738 (h0 : topological_space (has_to_string (has_pos_part Type))) : discrete_topology (has_to_string (has_pos_part Type)) := sorry --non-trivial
lemma new_lemma_4739 (h0 : not (function.extfun (Type -> Type) (function.extfun Type) -> false)) : @strong_rank_condition.{0} (@id.{2} Type empty) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) (@classical.by_contradiction'.{2} (function.extfun.{2 2} (Type → Type) (function.extfun.{2 1} Type)) h0) ring.{0}) (@id.{2} Type empty))  := sorry --non-trivial
lemma new_lemma_4740 (h0 : topological_space (simple_graph (has_Inf (has_pos_part linarith.comp)))) : t1_space (simple_graph (has_Inf (has_pos_part linarith.comp))) := sorry --non-trivial
lemma new_lemma_4741 (h0 : functor.add_const (function.extfun Type topological_space) Type) : @totally_disconnected_space.{0} (has_to_string.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type topological_space.{0}) Type h0) (has_to_string.{0} name))  := sorry --non-trivial
lemma new_lemma_4742 (h0 : function.extfun Type monoid) : @monoid.fg.{0} (has_sub.{0} unsigned) (@function.extfun_app.{2 1} Type monoid.{0} h0 (has_sub.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_4743 (h0 : group (sub_neg_monoid (finset (finset linarith.comp)))) : normalizer_condition (sub_neg_monoid (finset (finset linarith.comp))) := sorry --non-trivial
lemma new_lemma_4744 (h0 : topological_space (semigroup (complete_distrib_lattice unsigned))) : totally_disconnected_space (semigroup (complete_distrib_lattice unsigned)) := sorry --non-trivial
lemma new_lemma_4745 (h1 : ring (has_norm (has_top linarith.comp))) : rank_condition (has_norm (has_top linarith.comp)) := sorry --non-trivial
lemma new_lemma_4746 (h0 : ring (semi_normed_comm_ring (has_nnnorm (topological_space reducibility_hints)))) : is_domain (semi_normed_comm_ring (has_nnnorm (topological_space reducibility_hints))) := sorry --non-trivial
lemma new_lemma_4747 (h0 : group (canonically_ordered_comm_semiring (has_Inf (has_Inf Type)))) : is_cyclic (canonically_ordered_comm_semiring (has_Inf (has_Inf Type))) := sorry --non-trivial
lemma new_lemma_4748 (h0 : topological_space (has_zero (ring name))) : t1_space (has_zero (ring name)) := sorry --non-trivial
lemma new_lemma_4749 (h0 : functor.add_const (group (semigroup linarith.comp)) environment.implicit_infer_kind) : @is_cyclic.{0} (semigroup.{0} linarith.comp) (@functor.add_const.run.{0 0} (group.{0} (semigroup.{0} linarith.comp)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_4750 (h0 : topological_space (monoid (option pos))) : sequential_space (monoid (option pos)) := sorry --non-trivial
lemma new_lemma_4751 (h0 : functor.add_const (function.extfun Type group) pos) : @is_cyclic.{0} (finset.{0} (ring.{0} linarith.comp)) (@function.extfun_app.{2 1} Type group.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type group.{0}) pos h0) (finset.{0} (ring.{0} linarith.comp)))  := sorry --non-trivial
lemma new_lemma_4752 (h0 : functor.add_const (function.extfun Type monoid) pos) : @monoid.fg.{0} (simple_graph.{0} linarith.comp) (@function.extfun_app.{2 1} Type monoid.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type monoid.{0}) pos h0) (simple_graph.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_4753 (h0 : functor.comp ring add_cancel_monoid name) : @is_principal_ideal_ring.{0} (add_cancel_monoid.{0} name) (@functor.comp.run.{0 0 0} ring.{0} add_cancel_monoid.{0} name h0)  := sorry --non-trivial
lemma new_lemma_4754 (h0 : functor.add_const (topological_space (boolean_algebra.core Type)) name) : @sequential_space.{1} (boolean_algebra.core.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (boolean_algebra.core.{1} Type)) name h0)  := sorry --non-trivial
lemma new_lemma_4755 (h0 : not (topological_space (linear_ordered_semiring linarith.comp) -> false)) : @locally_compact_space.{0} (linear_ordered_semiring.{0} linarith.comp) (@classical.by_contradiction'.{1} (topological_space.{0} (linear_ordered_semiring.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_4756 (h0 : ring (topological_space reducibility_hints)) : is_domain (topological_space reducibility_hints) := sorry --non-trivial
lemma new_lemma_4757 (h0 : topological_space (ordered_ring (option empty))) : totally_separated_space (ordered_ring (option empty)) := sorry --non-trivial
lemma new_lemma_4758 (h1 : add_group (nondiscrete_normed_field (mul_one_class std_gen))) : is_add_cyclic (nondiscrete_normed_field (mul_one_class std_gen)) := sorry --non-trivial
lemma new_lemma_4759 (h0 : functor.add_const (ordered_comm_monoid (add_comm_monoid Type)) Type) : @has_exists_mul_of_le.{1} (add_comm_monoid.{1} Type) (@functor.add_const.run.{1 1} (ordered_comm_monoid.{1} (add_comm_monoid.{1} Type)) Type h0)  := sorry --non-trivial
lemma new_lemma_4760 (h0 : functor.add_const (monoid (has_Inf linarith.comp)) (has_nndist (has_add Type))) : @monoid.fg.{0} (has_Inf.{0} linarith.comp) (@functor.add_const.run.{0 1} (monoid.{0} (has_Inf.{0} linarith.comp)) (has_nndist.{1} (has_add.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_4761 (h0 : topological_space (finset (option (option unsigned)))) : locally_compact_space (finset (option (option unsigned))) := sorry --non-trivial
lemma new_lemma_4762 (h0 : topological_space (has_to_string (finset Type))) : t1_space (has_to_string (finset Type)) := sorry --non-trivial
lemma new_lemma_4763 (h0 : function.extfun nat fin) : @complete_lattice.is_Sup_finite_compact.{0} (normed_lattice_add_comm_group.{0} name) (@matrix.vec_empty.{0} (complete_lattice.{0} (normed_lattice_add_comm_group.{0} name)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_4764 (h0 : functor.add_const (ordered_comm_monoid (has_pos_part Type)) name) : @has_exists_mul_of_le.{1} (has_pos_part.{1} Type) (@functor.add_const.run.{1 0} (ordered_comm_monoid.{1} (has_pos_part.{1} Type)) name h0)  := sorry --non-trivial
lemma new_lemma_4765 (h1 : group (denumerable string_imp)) : is_cyclic (denumerable string_imp) := sorry --non-trivial
lemma new_lemma_4766 (h0 : function.extfun Type group) : @is_cyclic.{0} (comm_ring.{0} string_imp) (@function.extfun_app.{2 1} Type group.{0} h0 (comm_ring.{0} string_imp))  := sorry --non-trivial
lemma new_lemma_4767 (h0 : functor.comp topological_space semigroup name) : @preconnected_space.{0} (semigroup.{0} name) (@functor.comp.run.{0 0 0} topological_space.{0} semigroup.{0} name h0)  := sorry --non-trivial
lemma new_lemma_4768 (h0 : topological_space (left_cancel_monoid (semiring congr_arg_kind))) : irreducible_space (left_cancel_monoid (semiring congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_4769 (h0 : topological_space (comm_monoid unsigned)) : irreducible_space (comm_monoid unsigned) := sorry --non-trivial
lemma new_lemma_4770 (h0 : topological_space (with_one (random_gen empty))) : normal_space (with_one (random_gen empty)) := sorry --non-trivial
lemma new_lemma_4771 (h0 : ring (complete_semilattice_Sup empty)) : is_domain (complete_semilattice_Sup empty) := sorry --non-trivial
lemma new_lemma_4772 (h0 : function.extfun Type topological_space) : @totally_disconnected_space.{0} (topological_space.{0} char) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (topological_space.{0} char))  := sorry --non-trivial
lemma new_lemma_4773 (h0 : functor.add_const (topological_space (normed_comm_ring Type)) (has_neg Type)) : @totally_disconnected_space.{1} (normed_comm_ring.{1} Type) (@functor.add_const.run.{1 1} (topological_space.{1} (normed_comm_ring.{1} Type)) (has_neg.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_4774 (h0 : functor.add_const (ordered_add_comm_monoid (generalized_boolean_algebra Type)) (ordered_ring (ring Type))) : @archimedean.{1} (generalized_boolean_algebra.{1} Type) (@functor.add_const.run.{1 1} (ordered_add_comm_monoid.{1} (generalized_boolean_algebra.{1} Type)) (ordered_ring.{1} (ring.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_4775 (h0 : semiring (semigroup environment.implicit_infer_kind)) : is_noetherian_ring (semigroup environment.implicit_infer_kind) := sorry --non-trivial
lemma new_lemma_4776 (h0 : topological_space (add_left_cancel_semigroup (comm_monoid unsigned))) : loc_path_connected_space (add_left_cancel_semigroup (comm_monoid unsigned)) := sorry --non-trivial
lemma new_lemma_4777 (h0 : add_group (finset (ordered_ring pos))) : is_add_cyclic (finset (ordered_ring pos)) := sorry --non-trivial
lemma new_lemma_4778 (h0 : filter (complete_linear_order (semiring (semiring num)))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_4779 (h0 : functor.comp cancel_comm_monoid_with_zero comm_group name) : @unique_factorization_monoid.{0} (comm_group.{0} name) (@functor.comp.run.{0 0 0} cancel_comm_monoid_with_zero.{0} comm_group.{0} name h0)  := sorry --non-trivial
lemma new_lemma_4780 (h0 : functor.add_const (monoid (boolean_algebra.core unsigned)) (has_neg_part Type)) : @monoid.fg.{0} (boolean_algebra.core.{0} unsigned) (@functor.add_const.run.{0 1} (monoid.{0} (boolean_algebra.core.{0} unsigned)) (has_neg_part.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_4781 (h0 : function.extfun Type group) : @normalizer_condition.{0} (pseudo_metric_space.{0} num) (@function.extfun_app.{2 1} Type group.{0} h0 (pseudo_metric_space.{0} num))  := sorry --non-trivial
lemma new_lemma_4782 (h0 : functor.comp topological_space ring pos) : @t0_space.{0} (ring.{0} pos) (@functor.comp.run.{0 0 0} topological_space.{0} ring.{0} pos h0)  := sorry --non-trivial
lemma new_lemma_4783 (h0 : add_group (ordered_cancel_comm_monoid (random_gen (random_gen char)))) : is_add_cyclic (ordered_cancel_comm_monoid (random_gen (random_gen char))) := sorry --non-trivial
lemma new_lemma_4784 (h0 : complete_lattice (has_top (random_gen linarith.ineq))) : is_compactly_generated (has_top (random_gen linarith.ineq)) := sorry --non-trivial
lemma new_lemma_4785 (h0 : function.extfun Type ring) : @strong_rank_condition.{0} (pseudo_metric_space.{0} empty) (@function.extfun_app.{2 1} Type ring.{0} h0 (pseudo_metric_space.{0} empty))  := sorry --non-trivial
lemma new_lemma_4786 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @sequential_space.{1} (has_to_string.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 topological_space.{1}) (has_to_string.{1} Type))  := sorry --non-trivial
lemma new_lemma_4787 (h0 : not (function.extfun Type uniform_space -> false)) : @separated_space.{0} unsigned (@function.extfun_app.{2 1} Type uniform_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type uniform_space.{0}) h0) unsigned)  := sorry --non-trivial
lemma new_lemma_4788 (h0 : topological_space (has_zero (semiring (semiring unsigned)))) : locally_compact_space (has_zero (semiring (semiring unsigned))) := sorry --non-trivial
lemma new_lemma_4789 (h0 : topological_space (has_nndist (ring Type))) : irreducible_space (has_nndist (ring Type)) := sorry --non-trivial
lemma new_lemma_4790 (h0 : function.extfun Type topological_space) : @discrete_topology.{0} (complete_semilattice_Sup.{0} fun_info) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (complete_semilattice_Sup.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_4791 (h0 : topological_space (sub_neg_monoid (has_add linarith.comp))) : totally_disconnected_space (sub_neg_monoid (has_add linarith.comp)) := sorry --non-trivial
lemma new_lemma_4792 (h0 : function.extfun Type topological_space) : @sequential_space.{0} (add_comm_monoid.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (add_comm_monoid.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_4793 (h0 : function.extfun Type ring) : @strong_rank_condition.{0} (left_cancel_semigroup.{0} unsigned) (@function.extfun_app.{2 1} Type ring.{0} h0 (left_cancel_semigroup.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_4794 (h1 : not (topological_space (has_compl to_additive.value_type) -> false)) : @t0_space.{0} (has_compl.{0} to_additive.value_type) (@classical.by_contradiction'.{1} (topological_space.{0} (has_compl.{0} to_additive.value_type)) h1)  := sorry --non-trivial
lemma new_lemma_4795 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_noetherian_ring.{0} (has_to_string.{0} pos) (@function.extfun_app.{2 1} Type semiring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 semiring.{0}) (has_to_string.{0} pos))  := sorry --non-trivial
lemma new_lemma_4796 (h0 : not (complete_lattice (semi_normed_ring reducibility_hints) -> false)) : @is_compactly_generated.{0} (semi_normed_ring.{0} reducibility_hints) (@classical.by_contradiction'.{1} (complete_lattice.{0} (semi_normed_ring.{0} reducibility_hints)) h0)  := sorry --non-trivial
lemma new_lemma_4797 (h0 : functor.add_const (finset (comm_group environment.implicit_infer_kind)) Type) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_4798 (h0 : has_mem.mem (with_one linarith.comp) has_emptyc.emptyc) : @normalizer_condition.{0} (with_one.{0} linarith.comp) (@finset.pi.empty.{1 0} Type group.{0} (with_one.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_4799 (h0 : functor.add_const (ring (complete_linear_order unsigned)) num) : @strong_rank_condition.{0} (complete_linear_order.{0} unsigned) (@functor.add_const.run.{0 0} (ring.{0} (complete_linear_order.{0} unsigned)) num h0)  := sorry --non-trivial
lemma new_lemma_4800 (h0 : list (semiring (semiring empty))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_4801 (h0 : topological_space (has_bot (boolean_algebra.core (sub_neg_monoid linarith.comp)))) : loc_path_connected_space (has_bot (boolean_algebra.core (sub_neg_monoid linarith.comp))) := sorry --non-trivial
lemma new_lemma_4802 (h0 : complete_lattice (simple_graph name)) : is_compactly_generated (simple_graph name) := sorry --non-trivial
lemma new_lemma_4803 (h0 : topological_space (has_emptyc (has_norm linarith.ineq))) : discrete_topology (has_emptyc (has_norm linarith.ineq)) := sorry --non-trivial
lemma new_lemma_4804 (h1 : ring (has_compl (has_ssubset string_imp))) : strong_rank_condition (has_compl (has_ssubset string_imp)) := sorry --non-trivial
lemma new_lemma_4805 (h0 : topological_space (mul_zero_class ennreal)) : preconnected_space (mul_zero_class ennreal) := sorry --non-trivial
lemma new_lemma_4806 (h0 : uniform_space (has_Inf (has_add linarith.comp))) : complete_space (has_Inf (has_add linarith.comp)) := sorry --non-trivial
lemma new_lemma_4807 (h0 : not (function.extfun Type complete_lattice -> false)) : @is_compactly_generated.{0} (has_top.{0} num) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type complete_lattice.{0}) h0) (has_top.{0} num))  := sorry --non-trivial
lemma new_lemma_4808 (h0 : not (function.extfun Type topological_space -> false)) : @locally_compact_space.{0} (has_star.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (has_star.{0} num))  := sorry --non-trivial
lemma new_lemma_4809 (h0 : topological_space (add_cancel_monoid (finset (finset linarith.comp)))) : path_connected_space (add_cancel_monoid (finset (finset linarith.comp))) := sorry --non-trivial
lemma new_lemma_4810 (h0 : functor.add_const (topological_space (has_neg unsigned)) name) : @path_connected_space.{0} (has_neg.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (has_neg.{0} unsigned)) name h0)  := sorry --non-trivial
lemma new_lemma_4811 (h0 : topological_space (dlist (has_ssubset linarith.ineq))) : irreducible_space (dlist (has_ssubset linarith.ineq)) := sorry --non-trivial
lemma new_lemma_4812 (h0 : functor.add_const (group (boolean_algebra environment.implicit_infer_kind)) name) : @normalizer_condition.{0} (boolean_algebra.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (group.{0} (boolean_algebra.{0} environment.implicit_infer_kind)) name h0)  := sorry --non-trivial
lemma new_lemma_4813 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : finset.nonempty (function.extfun_app (function.extfun_app h0 finset) (boolean_algebra.core pos)) := sorry --non-trivial
lemma new_lemma_4814 (h1 : complete_lattice (has_emptyc linarith.ineq)) : is_atomistic (has_emptyc linarith.ineq) := sorry --non-trivial
lemma new_lemma_4815 (h0 : functor.add_const (topological_space (add_cancel_monoid environment.implicit_infer_kind)) name) : @preconnected_space.{0} (add_cancel_monoid.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (add_cancel_monoid.{0} environment.implicit_infer_kind)) name h0)  := sorry --non-trivial
lemma new_lemma_4816 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : list.nodup (function.extfun_app (function.extfun_app h0 list) (semi_normed_comm_ring fun_info)) := sorry --non-trivial
lemma new_lemma_4817 (h0 : not (topological_space (semi_normed_ring linarith.comp_source) -> false)) : @path_connected_space.{0} (semi_normed_ring.{0} linarith.comp_source) (@classical.by_contradiction'.{1} (topological_space.{0} (semi_normed_ring.{0} linarith.comp_source)) h0)  := sorry --non-trivial
lemma new_lemma_4818 (h0 : fin has_zero.zero) : @is_atomistic.{0} (normed_lattice_add_comm_group.{0} real) (@matrix.vec_empty.{0} (complete_lattice.{0} (normed_lattice_add_comm_group.{0} real)) h0)  := sorry --non-trivial
lemma new_lemma_4819 (h0 : functor.add_const (uniform_space (finset Type)) Type) : @separated_space.{1} (finset.{1} Type) (@functor.add_const.run.{1 1} (uniform_space.{1} (finset.{1} Type)) Type h0)  := sorry --non-trivial
lemma new_lemma_4820 (h0 : ordered_comm_monoid (ordered_comm_ring (has_neg name))) : has_exists_mul_of_le (ordered_comm_ring (has_neg name)) := sorry --non-trivial
lemma new_lemma_4821 (h0 : functor.add_const (add_group (ordered_ring congr_arg_kind)) num) : @is_add_cyclic.{0} (ordered_ring.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (add_group.{0} (ordered_ring.{0} congr_arg_kind)) num h0)  := sorry --non-trivial
lemma new_lemma_4822 (h0 : ring (topological_space (has_ssubset char))) : rank_condition (topological_space (has_ssubset char)) := sorry --non-trivial
lemma new_lemma_4823 (h0 : functor.add_const (topological_space (add_semigroup empty)) empty) : @totally_disconnected_space.{0} (add_semigroup.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (add_semigroup.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_4824 (h0 : function.extfun Type topological_space) : @loc_path_connected_space.{0} (canonically_ordered_monoid.{0} real) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (canonically_ordered_monoid.{0} real))  := sorry --non-trivial
lemma new_lemma_4825 (h0 : topological_space (simple_graph Type)) : locally_compact_space (simple_graph Type) := sorry --non-trivial
lemma new_lemma_4826 (h0 : topological_space (has_Inf (ordered_ring name))) : path_connected_space (has_Inf (ordered_ring name)) := sorry --non-trivial
lemma new_lemma_4827 (h0 : function.extfun Type group) : @is_cyclic.{0} (add_cancel_monoid.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type group.{0} h0 (add_cancel_monoid.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_4828 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_atomistic.{0} (has_zero.{0} linarith.comp) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (has_zero.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_4829 (h0 : ring (comm_ring string_imp)) : rank_condition (comm_ring string_imp) := sorry --non-trivial
lemma new_lemma_4830 (h0 : complete_lattice (has_neg (has_neg linarith.comp))) : is_compactly_generated (has_neg (has_neg linarith.comp)) := sorry --non-trivial
lemma new_lemma_4831 (h0 : complete_lattice (add_comm_monoid environment.implicit_infer_kind)) : is_atomistic (add_comm_monoid environment.implicit_infer_kind) := sorry --non-trivial
lemma new_lemma_4832 (h0 : functor.add_const (function.extfun (Type 1) topological_space) linarith.comp) : @t0_space.{1} (has_Inf.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) topological_space.{1}) linarith.comp h0) (has_Inf.{1} Type))  := sorry --non-trivial
lemma new_lemma_4833 (h0 : not (topological_space (has_top (semiring linarith.comp_source)) -> false)) : @discrete_topology.{0} (has_top.{0} (semiring.{0} linarith.comp_source)) (@classical.by_contradiction'.{1} (topological_space.{0} (has_top.{0} (semiring.{0} linarith.comp_source))) h0)  := sorry --non-trivial
lemma new_lemma_4834 (h0 : set (random_gen num)) : set.subsingleton h0 := sorry --non-trivial
lemma new_lemma_4835 (h0 : group (has_one num)) : normalizer_condition (has_one num) := sorry --non-trivial
lemma new_lemma_4836 (h0 : function.extfun Type filter) : filter.ne_bot (function.extfun_app h0 (canonically_linear_ordered_monoid pos)) := sorry --non-trivial
lemma new_lemma_4837 (h0 : not (ring (random_gen (mul_one_class linarith.comp_source)) -> false)) : @rank_condition.{0} (random_gen.{0} (mul_one_class.{0} linarith.comp_source)) (@classical.by_contradiction'.{1} (ring.{0} (random_gen.{0} (mul_one_class.{0} linarith.comp_source))) h0)  := sorry --non-trivial
lemma new_lemma_4838 (h0 : monoid (linear_ordered_semiring to_additive.value_type)) : monoid.fg (linear_ordered_semiring to_additive.value_type) := sorry --non-trivial
lemma new_lemma_4839 (h0 : cancel_comm_monoid_with_zero (finset (has_bot (has_bot (comm_semigroup real))))) : unique_factorization_monoid (finset (has_bot (has_bot (comm_semigroup real)))) := sorry --non-trivial
lemma new_lemma_4840 (h0 : topological_space (pseudo_metric_space (option congr_arg_kind))) : totally_disconnected_space (pseudo_metric_space (option congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_4841 (h0 : topological_space (finset (has_to_string unsigned))) : locally_compact_space (finset (has_to_string unsigned)) := sorry --non-trivial
lemma new_lemma_4842 (h0 : topological_space (normed_lattice_add_comm_group (sub_neg_monoid real))) : topological_space.separable_space (normed_lattice_add_comm_group (sub_neg_monoid real)) := sorry --non-trivial
lemma new_lemma_4843 (h0 : ring (partial_order (semiring (ordered_cancel_comm_monoid (semiring empty))))) : strong_rank_condition (partial_order (semiring (ordered_cancel_comm_monoid (semiring empty)))) := sorry --non-trivial
lemma new_lemma_4844 (h0 : functor.add_const (function.extfun (Type 1) add_monoid) pos) : @add_monoid.fg.{1} (finset.{1} Type) (@function.extfun_app.{3 2} (Type 1) add_monoid.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) add_monoid.{1}) pos h0) (finset.{1} Type))  := sorry --non-trivial
lemma new_lemma_4845 (h0 : function.extfun Type uniform_space) : @complete_space.{0} num (@function.extfun_app.{2 1} Type uniform_space.{0} h0 num)  := sorry --non-trivial
lemma new_lemma_4846 (h0 : ring (has_emptyc (semiring linarith.comp_source))) : is_domain (has_emptyc (semiring linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_4847 (h0 : ring (generalized_boolean_algebra name)) : rank_condition (generalized_boolean_algebra name) := sorry --non-trivial
lemma new_lemma_4848 (h0 : function.extfun Type topological_space) : @totally_separated_space.{0} (filter.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (filter.{0} num))  := sorry --non-trivial
lemma new_lemma_4849 (h0 : topological_space (add_cancel_monoid (comm_group (comm_group Type)))) : t0_space (add_cancel_monoid (comm_group (comm_group Type))) := sorry --non-trivial
lemma new_lemma_4850 (h0 : ring (semigroup (ordered_cancel_add_comm_monoid (option pos)))) : strong_rank_condition (semigroup (ordered_cancel_add_comm_monoid (option pos))) := sorry --non-trivial
lemma new_lemma_4851 (h0 : function.extfun Type topological_space) : @t0_space.{0} (has_top.{0} linarith.ineq) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_top.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_4852 (h0 : topological_space (with_bot empty)) : regular_space (with_bot empty) := sorry --non-trivial
lemma new_lemma_4853 (h0 : has_mem.mem group has_emptyc.emptyc) : @is_cyclic.{0} (@id.{2} Type num) (@function.extfun_app.{2 1} Type group.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) group.{0} h0) (@id.{2} Type num))  := sorry --non-trivial
lemma new_lemma_4854 (h0 : complete_lattice (linear_ordered_semiring (semiring empty))) : complete_lattice.is_Sup_finite_compact (linear_ordered_semiring (semiring empty)) := sorry --non-trivial
lemma new_lemma_4855 (h0 : ordered_add_comm_monoid (has_neg_part (mul_zero_class unsigned))) : archimedean (has_neg_part (mul_zero_class unsigned)) := sorry --non-trivial
lemma new_lemma_4856 (h0 : add_group (non_unital_non_assoc_semiring linarith.comp_source)) : is_add_cyclic (non_unital_non_assoc_semiring linarith.comp_source) := sorry --non-trivial
lemma new_lemma_4857 (h0 : fin has_zero.zero) : @t1_space.{0} (comm_semigroup.{0} linarith.comp) (@matrix.vec_empty.{0} (topological_space.{0} (comm_semigroup.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_4858 (h0 : uniform_space (linear_ordered_comm_ring (semiring (semiring (semiring (semiring congr_arg_kind)))))) : complete_space (linear_ordered_comm_ring (semiring (semiring (semiring (semiring congr_arg_kind))))) := sorry --non-trivial
lemma new_lemma_4859 (h0 : functor.add_const (topological_space (has_nndist name)) (comm_group Type)) : @totally_disconnected_space.{0} (has_nndist.{0} name) (@functor.add_const.run.{0 1} (topological_space.{0} (has_nndist.{0} name)) (comm_group.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_4860 (h0 : function.extfun Type topological_space) : @t0_space.{0} (add_comm_monoid.{0} ennreal) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (add_comm_monoid.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_4861 (h0 : not (uniform_space (semiring num) -> false)) : @complete_space.{0} (semiring.{0} num) (@classical.by_contradiction'.{1} (uniform_space.{0} (semiring.{0} num)) h0)  := sorry --non-trivial
lemma new_lemma_4862 (h0 : semiring (is_R_or_C (option unsigned))) : is_noetherian_ring (is_R_or_C (option unsigned)) := sorry --non-trivial
lemma new_lemma_4863 (h0 : group (semigroup (option empty))) : normalizer_condition (semigroup (option empty)) := sorry --non-trivial
lemma new_lemma_4864 (h1 : complete_lattice (has_ssubset enat)) : complete_lattice.is_Sup_finite_compact (has_ssubset enat) := sorry --non-trivial
lemma new_lemma_4865 (h0 : measurable_space (has_add linarith.ineq)) (h1 : not (has_sup (has_add linarith.ineq) -> false)) : @has_measurable_sup.{0} (has_add.{0} linarith.ineq) h0 (@classical.by_contradiction'.{1} (has_sup.{0} (has_add.{0} linarith.ineq)) h1)  := sorry --non-trivial
lemma new_lemma_4866 (h0 : add_group (comm_semigroup (random_gen char))) : is_add_cyclic (comm_semigroup (random_gen char)) := sorry --non-trivial
lemma new_lemma_4867 (h0 : monoid (pseudo_metric_space empty)) : monoid.fg (pseudo_metric_space empty) := sorry --non-trivial
lemma new_lemma_4868 (h0 : uniform_space (has_ssubset linarith.ineq)) : complete_space (has_ssubset linarith.ineq) := sorry --non-trivial
lemma new_lemma_4869 (h0 : topological_space (semigroup name)) : t0_space (semigroup name) := sorry --non-trivial
lemma new_lemma_4870 (h0 : topological_space (canonically_ordered_monoid (ordered_comm_monoid (ordered_comm_monoid Type)))) : path_connected_space (canonically_ordered_monoid (ordered_comm_monoid (ordered_comm_monoid Type))) := sorry --non-trivial
lemma new_lemma_4871 (h0 : add_group (canonically_ordered_monoid (has_pos_part (has_pos_part pos)))) : is_add_cyclic (canonically_ordered_monoid (has_pos_part (has_pos_part pos))) := sorry --non-trivial
lemma new_lemma_4872 (h0 : ring (linear_ordered_add_comm_group (random_gen string_imp))) : rank_condition (linear_ordered_add_comm_group (random_gen string_imp)) := sorry --non-trivial
lemma new_lemma_4873 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @normalizer_condition.{0} (has_neg_part.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (has_neg_part.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_4874 (h0 : has_mem.mem (metric_space empty) has_emptyc.emptyc) : @preirreducible_space.{0} (metric_space.{0} empty) (@finset.pi.empty.{1 0} Type topological_space.{0} (metric_space.{0} empty) h0)  := sorry --non-trivial
lemma new_lemma_4875 (h0 : cancel_comm_monoid_with_zero (has_nndist (comm_group (comm_group (comm_group Type))))) : unique_factorization_monoid (has_nndist (comm_group (comm_group (comm_group Type)))) := sorry --non-trivial
lemma new_lemma_4876 (h0 : ring (has_nndist (comm_group environment.implicit_infer_kind))) : is_domain (has_nndist (comm_group environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_4877 (h0 : ring (has_add (finset linarith.comp))) : rank_condition (has_add (finset linarith.comp)) := sorry --non-trivial
lemma new_lemma_4878 (h0 : ring (normed_comm_ring congr_arg_kind)) : is_principal_ideal_ring (normed_comm_ring congr_arg_kind) := sorry --non-trivial
lemma new_lemma_4879 (h0 : not (ring (has_star empty) -> false)) : @is_principal_ideal_ring.{0} (has_star.{0} empty) (@classical.by_contradiction'.{1} (ring.{0} (has_star.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_4880 (h0 : group (partial_order unsigned)) : normalizer_condition (partial_order unsigned) := sorry --non-trivial
lemma new_lemma_4881 (h0 : topological_space (add_comm_semigroup (mul_one_class ereal))) : totally_disconnected_space (add_comm_semigroup (mul_one_class ereal)) := sorry --non-trivial
lemma new_lemma_4882 (h0 : list (comm_group (has_add (option (canonically_linear_ordered_monoid (option pos)))))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_4883 (h0 : option (ring (has_sub congr_arg_kind))) (h1 : ring (has_sub congr_arg_kind)) : strong_rank_condition (has_sub congr_arg_kind) := sorry --non-trivial
lemma new_lemma_4884 (h0 : list (linear_ordered_add_comm_group (has_ssubset (random_gen fun_info)))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_4885 (h0 : not (function.extfun Type topological_space -> false)) : @irreducible_space.{0} (random_gen.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (random_gen.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_4886 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @t0_space.{0} (has_neg.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_neg.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_4887 (h0 : add_group (cancel_monoid linarith.comp)) : is_add_cyclic (cancel_monoid linarith.comp) := sorry --non-trivial
lemma new_lemma_4888 (h0 : functor.add_const (topological_space (add_cancel_monoid pos)) linarith.comp) : @preirreducible_space.{0} (add_cancel_monoid.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (add_cancel_monoid.{0} pos)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_4889 (h0 : add_monoid (semigroup (metric_space Type))) : add_monoid.fg (semigroup (metric_space Type)) := sorry --non-trivial
lemma new_lemma_4890 (h1 : ring (normed_field ereal)) : is_domain (normed_field ereal) := sorry --non-trivial
lemma new_lemma_4891 (h0 : function.extfun Type topological_space) : @totally_separated_space.{0} (add_semigroup.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (add_semigroup.{0} empty))  := sorry --non-trivial
lemma new_lemma_4892 (h0 : functor.add_const (function.extfun Type topological_space) pos) : @topological_space.separable_space.{0} (has_to_string.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) pos h0) (has_to_string.{0} pos))  := sorry --non-trivial
lemma new_lemma_4893 (h0 : complete_lattice (mul_zero_class (has_add (has_nndist (has_add (has_add ennreal)))))) : is_compactly_generated (mul_zero_class (has_add (has_nndist (has_add (has_add ennreal))))) := sorry --non-trivial
lemma new_lemma_4894 (h0 : topological_space (ordered_comm_monoid (has_neg linarith.comp))) : totally_disconnected_space (ordered_comm_monoid (has_neg linarith.comp)) := sorry --non-trivial
lemma new_lemma_4895 (h0 : group (has_zero (has_to_string (has_add Type)))) : normalizer_condition (has_zero (has_to_string (has_add Type))) := sorry --non-trivial
lemma new_lemma_4896 (h0 : function.extfun Type ordered_comm_monoid) : @has_exists_mul_of_le.{0} (cancel_monoid.{0} linarith.comp) (@function.extfun_app.{2 1} Type ordered_comm_monoid.{0} h0 (cancel_monoid.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_4897 (h0 : add_group (with_bot (random_gen (distrib_lattice linarith.ineq)))) : is_add_cyclic (with_bot (random_gen (distrib_lattice linarith.ineq))) := sorry --non-trivial
lemma new_lemma_4898 (h0 : ring (simple_graph (mul_one_class (mul_one_class string.iterator_imp)))) : rank_condition (simple_graph (mul_one_class (mul_one_class string.iterator_imp))) := sorry --non-trivial
lemma new_lemma_4899 (h0 : topological_space (normed_lattice_add_comm_group unsigned)) : totally_separated_space (normed_lattice_add_comm_group unsigned) := sorry --non-trivial
lemma new_lemma_4900 (h0 : functor.add_const (uniform_space (add_comm_monoid name)) pos) : @complete_space.{0} (add_comm_monoid.{0} name) (@functor.add_const.run.{0 0} (uniform_space.{0} (add_comm_monoid.{0} name)) pos h0)  := sorry --non-trivial
lemma new_lemma_4901 (h0 : function.extfun Type topological_space) : @preconnected_space.{0} (finset.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (finset.{0} num))  := sorry --non-trivial
lemma new_lemma_4902 (h0 : topological_space (has_append (random_gen reducibility_hints))) : preconnected_space (has_append (random_gen reducibility_hints)) := sorry --non-trivial
lemma new_lemma_4903 (h0 : complete_lattice (has_add (has_Inf linarith.comp))) : complete_lattice.is_Sup_finite_compact (has_add (has_Inf linarith.comp)) := sorry --non-trivial
lemma new_lemma_4904 (h0 : functor.add_const (group (normed_comm_ring environment.implicit_infer_kind)) environment.implicit_infer_kind) : @normalizer_condition.{0} (normed_comm_ring.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (group.{0} (normed_comm_ring.{0} environment.implicit_infer_kind)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_4905 (h0 : complete_lattice (add_comm_semigroup (add_comm_semigroup reducibility_hints))) : complete_lattice.is_Sup_finite_compact (add_comm_semigroup (add_comm_semigroup reducibility_hints)) := sorry --non-trivial
lemma new_lemma_4906 (h0 : function.extfun Type topological_space) : @t1_space.{0} (left_cancel_monoid.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (left_cancel_monoid.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_4907 (h0 : not (uniform_space (denumerable fun_info) -> false)) : @complete_space.{0} (denumerable.{0} fun_info) (@classical.by_contradiction'.{1} (uniform_space.{0} (denumerable.{0} fun_info)) h0)  := sorry --non-trivial
lemma new_lemma_4908 (h0 : group (topological_space (has_nnnorm (random_gen reducibility_hints)))) : is_cyclic (topological_space (has_nnnorm (random_gen reducibility_hints))) := sorry --non-trivial
lemma new_lemma_4909 (h0 : function.extfun (finset (Type -> Type)) (has_mem.mem topological_space)) : @t0_space.{0} (linear_ordered_add_comm_group.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) topological_space.{0} (@function.extfun_app.{2 0} (finset.{1} (Type → Type)) (@has_mem.mem.{1 1} (Type → Type) (finset.{1} (Type → Type)) (@finset.has_mem.{1} (Type → Type)) topological_space.{0}) h0 (@has_emptyc.emptyc.{1} (finset.{1} (Type → Type)) (@finset.has_emptyc.{1} (Type → Type))))) (linear_ordered_add_comm_group.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_4910 (h0 : function.extfun Type complete_lattice) : @complete_lattice.is_Sup_finite_compact.{0} (linear_ordered_comm_group.{0} ennreal) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (linear_ordered_comm_group.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_4911 (h0 : function.extfun Type topological_space) : @normal_space.{0} (semigroup.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (semigroup.{0} name))  := sorry --non-trivial
lemma new_lemma_4912 (h0 : topological_space (has_add (mul_one_class Type))) : normal_space (has_add (mul_one_class Type)) := sorry --non-trivial
lemma new_lemma_4913 (h0 : function.extfun Type ring) : @rank_condition.{0} (add_comm_monoid.{0} name) (@function.extfun_app.{2 1} Type ring.{0} h0 (add_comm_monoid.{0} name))  := sorry --non-trivial
lemma new_lemma_4914 (h0 : filter (dlist (has_nnnorm (has_inv linarith.ineq)))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_4915 (h0 : topological_space (has_zero (mul_one_class linarith.comp))) : t0_space (has_zero (mul_one_class linarith.comp)) := sorry --non-trivial
lemma new_lemma_4916 (h0 : not (complete_lattice (random_gen num) -> false)) : @is_compactly_generated.{0} (random_gen.{0} num) (@classical.by_contradiction'.{1} (complete_lattice.{0} (random_gen.{0} num)) h0)  := sorry --non-trivial
lemma new_lemma_4917 (h0 : functor.add_const (complete_lattice (has_pos_part name)) (has_add (has_add pos))) : @is_compactly_generated.{0} (has_pos_part.{0} name) (@functor.add_const.run.{0 0} (complete_lattice.{0} (has_pos_part.{0} name)) (has_add.{0} (has_add.{0} pos)) h0)  := sorry --non-trivial
lemma new_lemma_4918 (h0 : group (add_comm_monoid (add_comm_monoid (semigroup environment.implicit_infer_kind)))) : is_simple_group (add_comm_monoid (add_comm_monoid (semigroup environment.implicit_infer_kind))) := sorry --non-trivial
lemma new_lemma_4919 (h0 : topological_space (ring empty)) : loc_path_connected_space (ring empty) := sorry --non-trivial
lemma new_lemma_4920 (h0 : topological_space (add_cancel_monoid (comm_group (comm_group unsigned)))) : discrete_topology (add_cancel_monoid (comm_group (comm_group unsigned))) := sorry --non-trivial
lemma new_lemma_4921 (h0 : uniform_space (has_Sup (option (ordered_ring (partial_order empty))))) : separated_space (has_Sup (option (ordered_ring (partial_order empty)))) := sorry --non-trivial
lemma new_lemma_4922 (h0 : function.extfun Type ring) : @is_domain.{0} (linear_order.{0} num) (@function.extfun_app.{2 1} Type ring.{0} h0 (linear_order.{0} num))  := sorry --non-trivial
lemma new_lemma_4923 (h0 : functor.add_const (ring (has_bot pos)) name) : @rank_condition.{0} (has_bot.{0} pos) (@functor.add_const.run.{0 0} (ring.{0} (has_bot.{0} pos)) name h0)  := sorry --non-trivial
lemma new_lemma_4924 (h0 : functor.add_const (complete_lattice (semigroup name)) (comm_group (has_neg_part (has_neg_part Type)))) : @is_atomistic.{0} (semigroup.{0} name) (@functor.add_const.run.{0 1} (complete_lattice.{0} (semigroup.{0} name)) (comm_group.{1} (has_neg_part.{1} (has_neg_part.{1} Type))) h0)  := sorry --non-trivial
lemma new_lemma_4925 (h0 : topological_space (has_pos_part (has_pos_part (generalized_boolean_algebra linarith.comp)))) : path_connected_space (has_pos_part (has_pos_part (generalized_boolean_algebra linarith.comp))) := sorry --non-trivial
lemma new_lemma_4926 (h0 : functor.add_const (group (preorder unsigned)) unsigned) : @group.fg.{0} (preorder.{0} unsigned) (@functor.add_const.run.{0 0} (group.{0} (preorder.{0} unsigned)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_4927 (h0 : topological_space (boolean_algebra.core environment.implicit_infer_kind)) : t0_space (boolean_algebra.core environment.implicit_infer_kind) := sorry --non-trivial
lemma new_lemma_4928 (h0 : functor.add_const (topological_space (as_linear_order empty)) (option (option empty))) : @t0_space.{0} (as_linear_order.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (as_linear_order.{0} empty)) (option.{0} (option.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_4929 (h0 : topological_space (has_neg (finset (finset linarith.comp)))) : topological_space.separable_space (has_neg (finset (finset linarith.comp))) := sorry --non-trivial
lemma new_lemma_4930 (h0 : set (mul_one_class (add_comm_semigroup enat) -> environment.implicit_infer_kind)) : set.separates_points h0 := sorry --non-trivial
lemma new_lemma_4931 (h0 : monoid (has_add (normed_comm_ring pos))) : monoid.fg (has_add (normed_comm_ring pos)) := sorry --non-trivial
lemma new_lemma_4932 (h0 : prod (has_neg unsigned) (has_neg unsigned)) : id_rel h0 := sorry --non-trivial
lemma new_lemma_4933 (h0 : topological_space (has_Inf (ring (ordered_ring pos)))) : preconnected_space (has_Inf (ring (ordered_ring pos))) := sorry --non-trivial
lemma new_lemma_4934 (h0 : ring (has_nndist (finset (has_neg name)))) : strong_rank_condition (has_nndist (finset (has_neg name))) := sorry --non-trivial
lemma new_lemma_4935 (h0 : topological_space linarith.comp) (h1 : topological_space (connected_components linarith.comp)) : totally_disconnected_space (connected_components linarith.comp) := sorry --non-trivial
lemma new_lemma_4936 (h0 : not (group (semiring unsigned) -> false)) : @normalizer_condition.{0} (semiring.{0} unsigned) (@classical.by_contradiction'.{1} (group.{0} (semiring.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_4937 (h0 : topological_space (plift (has_top unsigned))) : topological_space.separable_space (plift (has_top unsigned)) := sorry --non-trivial
lemma new_lemma_4938 (h0 : add_monoid (add_cancel_monoid (has_neg name))) : add_monoid.fg (add_cancel_monoid (has_neg name)) := sorry --non-trivial
lemma new_lemma_4939 (h0 : topological_space (has_neg_part pos)) : totally_disconnected_space (has_neg_part pos) := sorry --non-trivial
lemma new_lemma_4940 (h0 : group (dlist (random_gen (comm_ring linarith.ineq)))) : group.fg (dlist (random_gen (comm_ring linarith.ineq))) := sorry --non-trivial
lemma new_lemma_4941 (h0 : fin has_zero.zero) : @discrete_topology.{0} (add_comm_monoid.{0} linarith.comp) (@matrix.vec_empty.{0} (topological_space.{0} (add_comm_monoid.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_4942 (h0 : prod pos pos) : id_rel h0 := sorry --non-trivial
lemma new_lemma_4943 (h0 : functor.add_const (topological_space (boolean_algebra.core Type)) (ring (has_neg name))) : @totally_separated_space.{1} (boolean_algebra.core.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (boolean_algebra.core.{1} Type)) (ring.{0} (has_neg.{0} name)) h0)  := sorry --non-trivial
lemma new_lemma_4944 (h0 : group (normed_group linarith.comp)) : is_cyclic (normed_group linarith.comp) := sorry --non-trivial
lemma new_lemma_4945 (h0 : group (measurable_space (semiring (has_norm num)))) : group.fg (measurable_space (semiring (has_norm num))) := sorry --non-trivial
lemma new_lemma_4946 (h1 : function.extfun Type group) : @normalizer_condition.{0} (with_one.{0} string_imp) (@function.extfun_app.{2 1} Type group.{0} h1 (with_one.{0} string_imp))  := sorry --non-trivial
lemma new_lemma_4947 (h0 : function.extfun Type (functor.add_const (add_group (linear_ordered_comm_monoid_with_zero unsigned)))) : @is_add_cyclic.{0} (linear_ordered_comm_monoid_with_zero.{0} unsigned) (@functor.add_const.run.{0 0} (add_group.{0} (linear_ordered_comm_monoid_with_zero.{0} unsigned)) empty (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (add_group.{0} (linear_ordered_comm_monoid_with_zero.{0} unsigned))) h0 empty))  := sorry --non-trivial
lemma new_lemma_4948 (h0 : function.extfun Type topological_space) : @loc_path_connected_space.{0} (has_nndist.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_nndist.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_4949 (h0 : uniform_space (canonically_ordered_monoid (has_Inf real))) : complete_space (canonically_ordered_monoid (has_Inf real)) := sorry --non-trivial
lemma new_lemma_4950 (h0 : topological_space (has_top (random_gen (has_nnnorm linarith.comp_source)))) : path_connected_space (has_top (random_gen (has_nnnorm linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_4951 (h0 : functor.add_const (topological_space (boolean_algebra environment.implicit_infer_kind)) Type) : @totally_disconnected_space.{0} (boolean_algebra.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 1} (topological_space.{0} (boolean_algebra.{0} environment.implicit_infer_kind)) Type h0)  := sorry --non-trivial
lemma new_lemma_4952 (h0 : not (ring (has_top to_additive.value_type) -> false)) : @rank_condition.{0} (has_top.{0} to_additive.value_type) (@classical.by_contradiction'.{1} (ring.{0} (has_top.{0} to_additive.value_type)) h0)  := sorry --non-trivial
lemma new_lemma_4953 (h0 : topological_space (has_zero (has_nndist Type))) : topological_space.separable_space (has_zero (has_nndist Type)) := sorry --non-trivial
lemma new_lemma_4954 (h0 : topological_space (add_cancel_comm_monoid (semiring empty))) : t0_space (add_cancel_comm_monoid (semiring empty)) := sorry --non-trivial
lemma new_lemma_4955 (h0 : functor.add_const (group (boolean_algebra name)) (comm_group linarith.comp)) : @is_simple_group.{0} (boolean_algebra.{0} name) (@functor.add_const.run.{0 0} (group.{0} (boolean_algebra.{0} name)) (comm_group.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_4956 (h1 : topological_space (complete_semilattice_Sup linarith.ineq)) : locally_compact_space (complete_semilattice_Sup linarith.ineq) := sorry --non-trivial
lemma new_lemma_4957 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_compactly_generated.{0} (has_norm.{0} linarith.comp) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (has_norm.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_4958 (h0 : topological_space (normed_comm_ring (has_pos_part (has_neg Type)))) : t1_space (normed_comm_ring (has_pos_part (has_neg Type))) := sorry --non-trivial
lemma new_lemma_4959 (h0 : has_lt (has_nnnorm (mul_one_class enat))) : no_max_order (has_nnnorm (mul_one_class enat)) := sorry --non-trivial
lemma new_lemma_4960 (h0 : functor.add_const (ring (finset linarith.comp)) (ring pos)) : @rank_condition.{0} (finset.{0} linarith.comp) (@functor.add_const.run.{0 0} (ring.{0} (finset.{0} linarith.comp)) (ring.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_4961 (h0 : function.extfun Type topological_space) : @irreducible_space.{0} (linear_ordered_comm_group.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (linear_ordered_comm_group.{0} empty))  := sorry --non-trivial
lemma new_lemma_4962 (h0 : group (boolean_algebra.core (sub_neg_monoid unsigned))) : is_cyclic (boolean_algebra.core (sub_neg_monoid unsigned)) := sorry --non-trivial
lemma new_lemma_4963 (h0 : add_group (normed_comm_ring environment.implicit_infer_kind)) : is_add_cyclic (normed_comm_ring environment.implicit_infer_kind) := sorry --non-trivial
lemma new_lemma_4964 (h0 : complete_lattice (has_ssubset (mul_one_class reducibility_hints))) : complete_lattice.is_Sup_finite_compact (has_ssubset (mul_one_class reducibility_hints)) := sorry --non-trivial
lemma new_lemma_4965 (h0 : function.extfun Type topological_space) : @t1_space.{0} (ordered_ring.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (ordered_ring.{0} empty))  := sorry --non-trivial
lemma new_lemma_4966 (h0 : fin has_zero.zero) : @discrete_topology.{0} (generalized_boolean_algebra.{0} pos) (@matrix.vec_empty.{0} (topological_space.{0} (generalized_boolean_algebra.{0} pos)) h0)  := sorry --non-trivial
lemma new_lemma_4967 (h0 : monoid (has_sub (semiring unsigned))) : monoid.fg (has_sub (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_4968 (h0 : fin has_zero.zero) : @rank_condition.{0} (has_pos_part.{0} real) (@matrix.vec_empty.{0} (ring.{0} (has_pos_part.{0} real)) h0)  := sorry --non-trivial
lemma new_lemma_4969 (h0 : function.extfun ((Type -> Type) -> Type 1) (function.extfun (Type -> Type))) : @t0_space.{0} (has_one.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) (@function.extfun_app.{3 2} ((Type → Type) → Type 1) (function.extfun.{2 2} (Type → Type)) h0 (function.extfun.{2 1} Type)) topological_space.{0}) (has_one.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_4970 (h0 : functor.add_const (topological_space (has_to_string Type)) Type) : @t0_space.{1} (has_to_string.{1} Type) (@functor.add_const.run.{1 1} (topological_space.{1} (has_to_string.{1} Type)) Type h0)  := sorry --non-trivial
lemma new_lemma_4971 (h0 : topological_space (comm_semigroup (has_bot linarith.comp))) : path_connected_space (comm_semigroup (has_bot linarith.comp)) := sorry --non-trivial
lemma new_lemma_4972 (h0 : function.extfun Type group) : @group.fg.{0} (has_edist.{0} empty) (@function.extfun_app.{2 1} Type group.{0} h0 (has_edist.{0} empty))  := sorry --non-trivial
lemma new_lemma_4973 (h0 : functor.add_const (topological_space (finset Type)) pos) : @topological_space.separable_space.{1} (finset.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (finset.{1} Type)) pos h0)  := sorry --non-trivial
lemma new_lemma_4974 (h0 : topological_space (div_inv_monoid to_additive.value_type)) : path_connected_space (div_inv_monoid to_additive.value_type) := sorry --non-trivial
lemma new_lemma_4975 (h0 : function.extfun (finset (Type -> Type)) (has_mem.mem topological_space)) : @locally_compact_space.{0} (with_one.{0} linarith.ineq) (@function.extfun_app.{2 1} Type topological_space.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) topological_space.{0} (@function.extfun_app.{2 0} (finset.{1} (Type → Type)) (@has_mem.mem.{1 1} (Type → Type) (finset.{1} (Type → Type)) (@finset.has_mem.{1} (Type → Type)) topological_space.{0}) h0 (@has_emptyc.emptyc.{1} (finset.{1} (Type → Type)) (@finset.has_emptyc.{1} (Type → Type))))) (with_one.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_4976 (h0 : functor.add_const (function.extfun Type ring) (finset pos)) : @strong_rank_condition.{0} (has_pos_part.{0} linarith.comp) (@function.extfun_app.{2 1} Type ring.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type ring.{0}) (finset.{0} pos) h0) (has_pos_part.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_4977 (h0 : complete_lattice (random_gen (mul_one_class char))) : complete_lattice.is_Sup_finite_compact (random_gen (mul_one_class char)) := sorry --non-trivial
lemma new_lemma_4978 (h0 : filter (has_compl (has_inv fun_info))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_4979 (h0 : ring (is_R_or_C num)) : rank_condition (is_R_or_C num) := sorry --non-trivial
lemma new_lemma_4980 (h0 : functor.add_const (topological_space (has_nndist Type)) Type) : @normal_space.{1} (has_nndist.{1} Type) (@functor.add_const.run.{1 1} (topological_space.{1} (has_nndist.{1} Type)) Type h0)  := sorry --non-trivial
lemma new_lemma_4981 (h0 : set (set to_additive.value_type)) (h1 : to_additive.value_type) (h2 : function.extfun Type option) : set.sInter h0 (option.lhoare h1 (function.extfun_app h2 to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_4982 (h0 : uniform_space (has_to_string num)) : complete_space (has_to_string num) := sorry --non-trivial
lemma new_lemma_4983 (h0 : functor.add_const (ordered_add_comm_monoid (linear_ordered_cancel_comm_monoid empty)) empty) : @archimedean.{0} (linear_ordered_cancel_comm_monoid.{0} empty) (@functor.add_const.run.{0 0} (ordered_add_comm_monoid.{0} (linear_ordered_cancel_comm_monoid.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_4984 (h0 : ring (add_right_cancel_monoid (semiring congr_arg_kind))) : strong_rank_condition (add_right_cancel_monoid (semiring congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_4985 (h0 : list (add_cancel_monoid linarith.comp)) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_4986 (h0 : set ereal) : set.finite h0 := sorry --non-trivial
lemma new_lemma_4987 (h0 : functor.add_const (topological_space (mul_zero_class pos)) Type) : @regular_space.{0} (mul_zero_class.{0} pos) (@functor.add_const.run.{0 1} (topological_space.{0} (mul_zero_class.{0} pos)) Type h0)  := sorry --non-trivial
lemma new_lemma_4988 (h0 : uniform_space (simple_graph (has_add Type))) : complete_space (simple_graph (has_add Type)) := sorry --non-trivial
lemma new_lemma_4989 (h0 : not (uniform_space (with_one congr_arg_kind) -> false)) : @complete_space.{0} (with_one.{0} congr_arg_kind) (@classical.by_contradiction'.{1} (uniform_space.{0} (with_one.{0} congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_4990 (h0 : topological_space (semigroup (finset pos))) : t0_space (semigroup (finset pos)) := sorry --non-trivial
lemma new_lemma_4991 (h3 : complete_lattice (distrib (random_gen to_additive.value_type))) : is_compactly_generated (distrib (random_gen to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_4992 (h0 : not (group (id empty) -> false)) : @normalizer_condition.{0} (@id.{2} Type empty) (@classical.by_contradiction'.{1} (group.{0} (@id.{2} Type empty)) h0)  := sorry --non-trivial
lemma new_lemma_4993 (h0 : cancel_comm_monoid_with_zero (finset (option unsigned))) : unique_factorization_monoid (finset (option unsigned)) := sorry --non-trivial
lemma new_lemma_4994 (h0 : function.extfun Type filter) : filter.ne_bot (function.extfun_app h0 (normed_linear_ordered_group num)) := sorry --non-trivial
lemma new_lemma_4995 (h0 : function.extfun Type topological_space) : @loc_path_connected_space.{0} (has_add.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_add.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_4996 (h0 : not (complete_lattice (comm_ring (distrib linarith.comp_source)) -> false)) : @complete_lattice.is_Sup_finite_compact.{0} (comm_ring.{0} (distrib.{0} linarith.comp_source)) (@classical.by_contradiction'.{1} (complete_lattice.{0} (comm_ring.{0} (distrib.{0} linarith.comp_source))) h0)  := sorry --non-trivial
lemma new_lemma_4997 (h0 : not (group (normed_field (has_nnnorm char)) -> false)) : @is_cyclic.{0} (normed_field.{0} (has_nnnorm.{0} char)) (@classical.by_contradiction'.{1} (group.{0} (normed_field.{0} (has_nnnorm.{0} char))) h0)  := sorry --non-trivial
lemma new_lemma_4998 (h0 : cancel_comm_monoid_with_zero (semiring unsigned)) : unique_factorization_monoid (semiring unsigned) := sorry --non-trivial
lemma new_lemma_4999 (h0 : complete_lattice (has_top (semiring unsigned))) : is_atomistic (has_top (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_5000 (h0 : not (function.extfun Type ring -> false)) : @is_domain.{0} (random_gen.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type ring.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type ring.{0}) h0) (random_gen.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_5001 (h0 : functor.add_const (ordered_add_comm_monoid (ordered_comm_monoid linarith.comp)) environment.implicit_infer_kind) : @archimedean.{0} (ordered_comm_monoid.{0} linarith.comp) (@functor.add_const.run.{0 0} (ordered_add_comm_monoid.{0} (ordered_comm_monoid.{0} linarith.comp)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_5002 (h0 : functor.add_const (ring (boolean_algebra unsigned)) (normed_comm_ring name)) : @is_principal_ideal_ring.{0} (boolean_algebra.{0} unsigned) (@functor.add_const.run.{0 0} (ring.{0} (boolean_algebra.{0} unsigned)) (normed_comm_ring.{0} name) h0)  := sorry --non-trivial
lemma new_lemma_5003 (h0 : function.extfun Type group) : @group.fg.{0} (has_neg.{0} pos) (@function.extfun_app.{2 1} Type group.{0} h0 (has_neg.{0} pos))  := sorry --non-trivial
lemma new_lemma_5004 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @monoid.fg.{0} (pseudo_metric_space.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 monoid.{0}) (pseudo_metric_space.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_5005 (h0 : ring (denumerable (has_ssubset (pseudo_metric_space to_additive.value_type)))) : is_domain (denumerable (has_ssubset (pseudo_metric_space to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_5006 (h0 : functor.add_const (cancel_comm_monoid_with_zero name) unsigned) : @unique_factorization_monoid.{0} name (@functor.add_const.run.{0 0} (cancel_comm_monoid_with_zero.{0} name) unsigned h0)  := sorry --non-trivial
lemma new_lemma_5007 (h0 : ring (mul_one_class string.iterator_imp)) : is_domain (mul_one_class string.iterator_imp) := sorry --non-trivial
lemma new_lemma_5008 (h0 : not (topological_space (complete_semilattice_Sup unsigned) -> false)) : @irreducible_space.{0} (complete_semilattice_Sup.{0} unsigned) (@classical.by_contradiction'.{1} (topological_space.{0} (complete_semilattice_Sup.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_5009 (h0 : function.extfun Type add_monoid) : @add_monoid.fg.{0} (has_neg.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type add_monoid.{0} h0 (has_neg.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_5010 (h0 : filter (add_cancel_monoid (has_to_string Type))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_5011 (h0 : uniform_space (semiring (random_gen (random_gen (random_gen linarith.ineq))))) : separated_space (semiring (random_gen (random_gen (random_gen linarith.ineq)))) := sorry --non-trivial
lemma new_lemma_5012 (h0 : functor.add_const (function.extfun Type topological_space) environment.implicit_infer_kind) : @preconnected_space.{0} (ring.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) environment.implicit_infer_kind h0) (ring.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_5013 (h0 : complete_lattice (id linarith.ineq)) : is_compactly_generated (id linarith.ineq) := sorry --non-trivial
lemma new_lemma_5014 (h0 : add_monoid (simple_graph (finset pos))) : add_monoid.fg (simple_graph (finset pos)) := sorry --non-trivial
lemma new_lemma_5015 (h0 : functor.add_const (functor.comp complete_lattice comm_group unsigned) ennreal) : @is_compactly_generated.{0} (comm_group.{0} unsigned) (@functor.add_const.run.{0 0} (complete_lattice.{0} (comm_group.{0} unsigned)) unsigned (@functor.comp.run.{0 0 0} complete_lattice.{0} comm_group.{0} unsigned (@functor.add_const.run.{0 0} (functor.comp.{0 0 0} complete_lattice.{0} comm_group.{0} unsigned) ennreal h0)))  := sorry --non-trivial
lemma new_lemma_5016 (h0 : topological_space (semigroup (finset (has_to_string environment.implicit_infer_kind)))) : sequential_space (semigroup (finset (has_to_string environment.implicit_infer_kind))) := sorry --non-trivial
lemma new_lemma_5017 (h0 : topological_space (topological_space (has_nnnorm (comm_ring (random_gen linarith.comp_source))))) : t0_space (topological_space (has_nnnorm (comm_ring (random_gen linarith.comp_source)))) := sorry --non-trivial
lemma new_lemma_5018 (h0 : semiring (non_assoc_semiring (semiring congr_arg_kind))) : is_noetherian_ring (non_assoc_semiring (semiring congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_5019 (h0 : function.extfun Type topological_space) : @locally_compact_space.{0} (non_assoc_semiring.{0} (semiring.{0} congr_arg_kind)) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (non_assoc_semiring.{0} (semiring.{0} congr_arg_kind)))  := sorry --non-trivial
lemma new_lemma_5020 (h0 : topological_space (semi_normed_comm_ring (has_norm (denumerable fun_info)))) : path_connected_space (semi_normed_comm_ring (has_norm (denumerable fun_info))) := sorry --non-trivial
lemma new_lemma_5021 (h0 : function.extfun Type group) : @group.fg.{0} (with_one.{0} num) (@function.extfun_app.{2 1} Type group.{0} h0 (with_one.{0} num))  := sorry --non-trivial
lemma new_lemma_5022 (h0 : list (add_cancel_monoid (option empty))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_5023 (h0 : ring (has_compl (mul_one_class (mul_one_class fun_info)))) : strong_rank_condition (has_compl (mul_one_class (mul_one_class fun_info))) := sorry --non-trivial
lemma new_lemma_5024 (h0 : uniform_space (normed_field std_gen)) : complete_space (normed_field std_gen) := sorry --non-trivial
lemma new_lemma_5025 (h0 : functor.add_const (topological_space (boolean_algebra Type)) (finset environment.implicit_infer_kind)) : @normal_space.{1} (boolean_algebra.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (boolean_algebra.{1} Type)) (finset.{0} environment.implicit_infer_kind) h0)  := sorry --non-trivial
lemma new_lemma_5026 (h0 : functor.add_const (add_monoid (add_cancel_monoid linarith.comp)) name) : @add_monoid.fg.{0} (add_cancel_monoid.{0} linarith.comp) (@functor.add_const.run.{0 0} (add_monoid.{0} (add_cancel_monoid.{0} linarith.comp)) name h0)  := sorry --non-trivial
lemma new_lemma_5027 (h0 : topological_space (has_add (option (option (option (option ennreal)))))) : path_connected_space (has_add (option (option (option (option ennreal))))) := sorry --non-trivial
lemma new_lemma_5028 (h0 : complete_lattice (has_nndist (option name))) : is_compactly_generated (has_nndist (option name)) := sorry --non-trivial
lemma new_lemma_5029 (h1 : topological_space (normed_field (normed_field reducibility_hints))) : path_connected_space (normed_field (normed_field reducibility_hints)) := sorry --non-trivial
lemma new_lemma_5030 (h0 : topological_space (normed_lattice_add_comm_group (has_Inf linarith.comp))) : t0_space (normed_lattice_add_comm_group (has_Inf linarith.comp)) := sorry --non-trivial
lemma new_lemma_5031 (h1 : option (uniform_space (has_div string_imp))) (h2 : coe_sort (option.is_some h1)) : @complete_space.{0} (has_div.{0} string_imp) (@option.get.{0} (uniform_space.{0} (has_div.{0} string_imp)) h1 h2)  := sorry --non-trivial
lemma new_lemma_5032 (h0 : functor.add_const (ordered_comm_monoid (add_cancel_monoid pos)) (has_add pos)) : @has_exists_mul_of_le.{0} (add_cancel_monoid.{0} pos) (@functor.add_const.run.{0 0} (ordered_comm_monoid.{0} (add_cancel_monoid.{0} pos)) (has_add.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_5033 (h0 : topological_space (normed_lattice_add_comm_group (has_pos_part (has_pos_part (has_Inf Type))))) : regular_space (normed_lattice_add_comm_group (has_pos_part (has_pos_part (has_Inf Type)))) := sorry --non-trivial
lemma new_lemma_5034 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @locally_compact_space.{0} (ring.{0} ennreal) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (ring.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_5035 (h0 : add_monoid (mul_zero_class (mul_zero_class unsigned))) : add_monoid.fg (mul_zero_class (mul_zero_class unsigned)) := sorry --non-trivial
lemma new_lemma_5036 (h0 : list (simple_graph (comm_monoid congr_arg_kind))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_5037 (h0 : group (ordered_comm_monoid (has_Inf pos))) : group.fg (ordered_comm_monoid (has_Inf pos)) := sorry --non-trivial
lemma new_lemma_5038 (h0 : monoid (left_cancel_monoid (option unsigned))) : monoid.fg (left_cancel_monoid (option unsigned)) := sorry --non-trivial
lemma new_lemma_5039 (h0 : add_group (normed_group (has_top empty))) : is_add_cyclic (normed_group (has_top empty)) := sorry --non-trivial
lemma new_lemma_5040 (h0 : ring (complete_distrib_lattice (sub_neg_monoid Type))) : rank_condition (complete_distrib_lattice (sub_neg_monoid Type)) := sorry --non-trivial
lemma new_lemma_5041 (h0 : semiring (has_neg (finset (has_Inf (has_neg pos))))) : is_noetherian_ring (has_neg (finset (has_Inf (has_neg pos)))) := sorry --non-trivial
lemma new_lemma_5042 (h0 : complete_lattice (random_gen (has_top fun_info))) : is_compactly_generated (random_gen (has_top fun_info)) := sorry --non-trivial
lemma new_lemma_5043 (h0 : function.extfun Type monoid) : @monoid.fg.{0} (with_bot.{0} (has_top.{0} (has_top.{0} (has_top.{0} (has_top.{0} (has_top.{0} (has_top.{0} congr_arg_kind))))))) (@function.extfun_app.{2 1} Type monoid.{0} h0 (with_bot.{0} (has_top.{0} (has_top.{0} (has_top.{0} (has_top.{0} (has_top.{0} (has_top.{0} congr_arg_kind))))))))  := sorry --non-trivial
lemma new_lemma_5044 (h0 : function.extfun Type list) : palindrome (function.extfun_app h0 (add_group num)) := sorry --non-trivial
lemma new_lemma_5045 (h0 : topological_space (id (semiring unsigned))) : normal_space (id (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_5046 (h1 : topological_space string.iterator_imp) (h2 : set string.iterator_imp) : is_path_connected h2 := sorry --non-trivial
lemma new_lemma_5047 (h0 : function.extfun Type ring) : @strong_rank_condition.{0} unsigned (@function.extfun_app.{2 1} Type ring.{0} h0 unsigned)  := sorry --non-trivial
lemma new_lemma_5048 (h0 : list (dlist char)) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_5049 (h0 : topological_space (with_bot fun_info)) : t0_space (with_bot fun_info) := sorry --non-trivial
lemma new_lemma_5050 (h0 : monoid (has_Inf (has_nndist Type))) : monoid.fg (has_Inf (has_nndist Type)) := sorry --non-trivial
lemma new_lemma_5051 (h0 : complete_lattice (left_cancel_monoid (semiring unsigned))) : is_atomistic (left_cancel_monoid (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_5052 (h0 : functor.add_const (ring (add_comm_monoid name)) pos) : @strong_rank_condition.{0} (add_comm_monoid.{0} name) (@functor.add_const.run.{0 0} (ring.{0} (add_comm_monoid.{0} name)) pos h0)  := sorry --non-trivial
lemma new_lemma_5053 (h0 : fin has_zero.zero) : @group.fg.{1} (simple_graph.{1} Type) (@matrix.vec_empty.{1} (group.{1} (simple_graph.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_5054 (h1 : topological_space (has_ssubset (random_gen linarith.ineq))) : t0_space (has_ssubset (random_gen linarith.ineq)) := sorry --non-trivial
lemma new_lemma_5055 (h0 : has_mem.mem ring has_emptyc.emptyc) : @rank_condition.{0} (with_one.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type ring.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) ring.{0} h0) (with_one.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_5056 (h0 : function.extfun Type ring) : @is_principal_ideal_ring.{0} (has_to_string.{0} pos) (@function.extfun_app.{2 1} Type ring.{0} h0 (has_to_string.{0} pos))  := sorry --non-trivial
lemma new_lemma_5057 (h0 : functor.add_const (function.extfun Type topological_space) name) : @irreducible_space.{0} (has_Inf.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) name h0) (has_Inf.{0} pos))  := sorry --non-trivial
lemma new_lemma_5058 (h0 : add_monoid (monoid ennreal)) : add_monoid.fg (monoid ennreal) := sorry --non-trivial
lemma new_lemma_5059 (h0 : not (function.extfun Type complete_lattice -> false)) : @is_atomistic.{0} (with_bot.{0} empty) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type complete_lattice.{0}) h0) (with_bot.{0} empty))  := sorry --non-trivial
lemma new_lemma_5060 (h0 : filter (has_neg ennreal)) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_5061 (h0 : ordered_add_comm_monoid (normed_comm_ring (finset environment.implicit_infer_kind))) : archimedean (normed_comm_ring (finset environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_5062 (h0 : add_group (has_compl std_gen)) : is_add_cyclic (has_compl std_gen) := sorry --non-trivial
lemma new_lemma_5063 (h0 : not (function.extfun (Type 1) ring -> false)) : @is_domain.{1} (plift.{1} num) (@function.extfun_app.{3 2} (Type 1) ring.{1} (@classical.by_contradiction'.{3} (function.extfun.{3 2} (Type 1) ring.{1}) h0) (plift.{1} num))  := sorry --non-trivial
lemma new_lemma_5064 (h0 : topological_space (boolean_algebra (comm_group (ring (comm_group Type))))) : t1_space (boolean_algebra (comm_group (ring (comm_group Type)))) := sorry --non-trivial
lemma new_lemma_5065 (h0 : cancel_comm_monoid_with_zero (has_to_string ennreal)) : unique_factorization_monoid (has_to_string ennreal) := sorry --non-trivial
lemma new_lemma_5066 (h0 : function.extfun Type (functor.add_const (finset (has_nndist empty)))) : finset.nonempty (functor.add_const.run (function.extfun_app h0 empty)) := sorry --non-trivial
lemma new_lemma_5067 (h0 : not (topological_space (has_lt linarith.comp_source) -> false)) : @totally_disconnected_space.{0} (has_lt.{0} linarith.comp_source) (@classical.by_contradiction'.{1} (topological_space.{0} (has_lt.{0} linarith.comp_source)) h0)  := sorry --non-trivial
lemma new_lemma_5068 (h0 : topological_space (distrib (has_nnnorm to_additive.value_type))) : t0_space (distrib (has_nnnorm to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_5069 (h0 : function.extfun Type ring) : @is_principal_ideal_ring.{0} (ordered_ring.{0} unsigned) (@function.extfun_app.{2 1} Type ring.{0} h0 (ordered_ring.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_5070 (h0 : function.extfun Type group) : @is_simple_group.{0} (boolean_algebra.core.{0} ennreal) (@function.extfun_app.{2 1} Type group.{0} h0 (boolean_algebra.core.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_5071 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @group.fg.{0} (dlist.{0} fun_info) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (dlist.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_5072 (h0 : ordered_comm_monoid (ring (has_add Type))) : has_exists_mul_of_le (ring (has_add Type)) := sorry --non-trivial
lemma new_lemma_5073 (h0 : topological_space (has_nndist (comm_group (comm_group (comm_group (comm_group pos)))))) : path_connected_space (has_nndist (comm_group (comm_group (comm_group (comm_group pos))))) := sorry --non-trivial
lemma new_lemma_5074 (h0 : ring (has_pos_part (has_pos_part real))) : rank_condition (has_pos_part (has_pos_part real)) := sorry --non-trivial
lemma new_lemma_5075 (h0 : topological_space (has_nndist (has_to_string (has_add name)))) : preconnected_space (has_nndist (has_to_string (has_add name))) := sorry --non-trivial
lemma new_lemma_5076 (h0 : group (normed_group empty)) : normalizer_condition (normed_group empty) := sorry --non-trivial
lemma new_lemma_5077 (h1 : measurable_space (mul_one_class (normed_field (mul_one_class char)))) (h2 : filter (mul_one_class (normed_field (mul_one_class char)))) : filter.is_measurably_generated h2 := sorry --non-trivial
lemma new_lemma_5078 (h0 : topological_space (mul_one_class (boolean_algebra.core char))) (h1 : preorder (mul_one_class (boolean_algebra.core char))) : order_closed_topology (mul_one_class (boolean_algebra.core char)) := sorry --non-trivial
lemma new_lemma_5079 (h0 : finset (has_inter (option ennreal))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_5080 (h0 : not (topological_space (add_left_cancel_monoid linarith.comp_source) -> false)) : @path_connected_space.{0} (add_left_cancel_monoid.{0} linarith.comp_source) (@classical.by_contradiction'.{1} (topological_space.{0} (add_left_cancel_monoid.{0} linarith.comp_source)) h0)  := sorry --non-trivial
lemma new_lemma_5081 (h0 : preorder (linear_ordered_add_comm_group char)) (h1 : set (linear_ordered_add_comm_group char)) : bdd_above h1 := sorry --non-trivial
lemma new_lemma_5082 (h0 : has_mem.mem complete_lattice has_emptyc.emptyc) : @is_compactly_generated.{0} (complete_semilattice_Sup.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) complete_lattice.{0} h0) (complete_semilattice_Sup.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_5083 (h0 : functor.add_const (topological_space (linear_order unsigned)) (option empty)) : @normal_space.{0} (linear_order.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (linear_order.{0} unsigned)) (option.{0} empty) h0)  := sorry --non-trivial
lemma new_lemma_5084 (h0 : fin has_zero.zero) : @t1_space.{0} (has_bot.{0} real) (@matrix.vec_empty.{0} (topological_space.{0} (has_bot.{0} real)) (@matrix.vec_empty.{0} (fin (@has_zero.zero.{0} nat nat.has_zero)) h0))  := sorry --non-trivial
lemma new_lemma_5085 (h0 : topological_space (add_comm_monoid (normed_comm_ring Type))) : totally_disconnected_space (add_comm_monoid (normed_comm_ring Type)) := sorry --non-trivial
lemma new_lemma_5086 (h0 : ring (linear_order congr_arg_kind)) : rank_condition (linear_order congr_arg_kind) := sorry --non-trivial
lemma new_lemma_5087 (h0 : topological_space (semigroup (ordered_comm_ring (has_neg Type)))) : sequential_space (semigroup (ordered_comm_ring (has_neg Type))) := sorry --non-trivial
lemma new_lemma_5088 (h0 : uniform_space (topological_space (distrib (random_gen linarith.ineq)))) : complete_space (topological_space (distrib (random_gen linarith.ineq))) := sorry --non-trivial
lemma new_lemma_5089 (h0 : topological_space (has_neg (add_comm_monoid pos))) : preirreducible_space (has_neg (add_comm_monoid pos)) := sorry --non-trivial
lemma new_lemma_5090 (h1 : add_group (topological_space (random_gen char))) : is_add_cyclic (topological_space (random_gen char)) := sorry --non-trivial
lemma new_lemma_5091 (h0 : functor.add_const (topological_space (finset Type)) (has_neg (has_neg name))) : @preirreducible_space.{1} (finset.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (finset.{1} Type)) (has_neg.{0} (has_neg.{0} name)) h0)  := sorry --non-trivial
lemma new_lemma_5092 (h0 : ring (has_le linarith.comp_source)) (h1 : option (ring (has_le linarith.comp_source))) : rank_condition (has_le linarith.comp_source) := sorry --non-trivial
lemma new_lemma_5093 (h0 : function.extfun Type ring) : @rank_condition.{0} (has_norm.{0} (random_gen.{0} fun_info)) (@function.extfun_app.{2 1} Type ring.{0} h0 (has_norm.{0} (random_gen.{0} fun_info)))  := sorry --non-trivial
lemma new_lemma_5094 (h0 : group (add_cancel_comm_monoid linarith.comp_source)) : is_cyclic (add_cancel_comm_monoid linarith.comp_source) := sorry --non-trivial
lemma new_lemma_5095 (h0 : list (has_to_string name)) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_5096 (h0 : uniform_space (has_to_string (mul_one_class linarith.comp))) : complete_space (has_to_string (mul_one_class linarith.comp)) := sorry --non-trivial
lemma new_lemma_5097 (h0 : topological_space (add_comm_monoid pos)) : sequential_space (add_comm_monoid pos) := sorry --non-trivial
lemma new_lemma_5098 (h0 : ring (group fun_info)) : strong_rank_condition (group fun_info) := sorry --non-trivial
lemma new_lemma_5099 (h0 : ordered_add_comm_monoid (option (option unsigned))) : archimedean (option (option unsigned)) := sorry --non-trivial
lemma new_lemma_5100 (h0 : topological_space (encodable (has_nnnorm (has_nnnorm linarith.comp_source)))) : t0_space (encodable (has_nnnorm (has_nnnorm linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_5101 (h0 : function.extfun Type (functor.add_const (functor.comp uniform_space semigroup unsigned))) : @complete_space.{0} (semigroup.{0} unsigned) (@functor.add_const.run.{0 0} (uniform_space.{0} (semigroup.{0} unsigned)) name (@functor.comp.run.{0 0 0} uniform_space.{0} semigroup.{0} unsigned (@functor.add_const.run.{0 0} (functor.comp.{0 0 0} uniform_space.{0} semigroup.{0} unsigned) pos (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (functor.comp.{0 0 0} uniform_space.{0} semigroup.{0} unsigned)) h0 pos))))  := sorry --non-trivial
lemma new_lemma_5102 (h0 : topological_space (has_norm (semiring num))) : totally_separated_space (has_norm (semiring num)) := sorry --non-trivial
lemma new_lemma_5103 (h0 : set (has_div char)) : set.subsingleton h0 := sorry --non-trivial
lemma new_lemma_5104 (h0 : function.extfun (finset Type -> Prop) (function.extfun (finset Type))) : @add_monoid.fg.{0} (normed_group.{0} (has_norm.{0} (has_norm.{0} (semiring.{0} (has_norm.{0} empty))))) (@finset.pi.empty.{1 0} Type add_monoid.{0} (normed_group.{0} (has_norm.{0} (has_norm.{0} (semiring.{0} (has_norm.{0} empty))))) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (normed_group.{0} (has_norm.{0} (has_norm.{0} (semiring.{0} (has_norm.{0} empty)))))) (@function.extfun_app.{2 0} (finset.{1} Type → Prop) (function.extfun.{2 0} (finset.{1} Type)) h0 (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (normed_group.{0} (has_norm.{0} (has_norm.{0} (semiring.{0} (has_norm.{0} empty))))))) (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_5105 (h0 : not (ring environment.implicit_infer_kind -> false)) : @is_domain.{0} environment.implicit_infer_kind (@classical.by_contradiction'.{1} (ring.{0} environment.implicit_infer_kind) h0)  := sorry --non-trivial
lemma new_lemma_5106 (h0 : monoid (linear_ordered_semiring (has_top congr_arg_kind))) : monoid.fg (linear_ordered_semiring (has_top congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_5107 (h0 : ring (has_top (id congr_arg_kind))) : strong_rank_condition (has_top (id congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_5108 (h0 : has_mem.mem (normed_group (has_norm empty)) has_emptyc.emptyc) : @locally_compact_space.{0} (normed_group.{0} (has_norm.{0} empty)) (@finset.pi.empty.{1 0} Type topological_space.{0} (normed_group.{0} (has_norm.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_5109 (h0 : ring (pseudo_metric_space ennreal)) : rank_condition (pseudo_metric_space ennreal) := sorry --non-trivial
lemma new_lemma_5110 (h0 : topological_space (linear_order (option (option (option unsigned))))) : totally_disconnected_space (linear_order (option (option (option unsigned)))) := sorry --non-trivial
lemma new_lemma_5111 (h0 : functor.add_const (topological_space (has_neg pos)) name) : @loc_path_connected_space.{0} (has_neg.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (has_neg.{0} pos)) name h0)  := sorry --non-trivial
lemma new_lemma_5112 (h0 : topological_space (complete_distrib_lattice Type)) : sequential_space (complete_distrib_lattice Type) := sorry --non-trivial
lemma new_lemma_5113 (h0 : functor.add_const (topological_space (comm_semigroup pos)) (has_bot Type)) : @preirreducible_space.{0} (comm_semigroup.{0} pos) (@functor.add_const.run.{0 1} (topological_space.{0} (comm_semigroup.{0} pos)) (has_bot.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_5114 (h0 : functor.add_const (topological_space (has_edist unsigned)) unsigned) : @locally_compact_space.{0} (has_edist.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (has_edist.{0} unsigned)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_5115 (h0 : prod (left_cancel_semigroup (semiring empty)) (left_cancel_semigroup (semiring empty))) : id_rel h0 := sorry --non-trivial
lemma new_lemma_5116 (h0 : not (ring (linear_ordered_comm_group_with_zero linarith.ineq) -> false)) : @strong_rank_condition.{0} (linear_ordered_comm_group_with_zero.{0} linarith.ineq) (@classical.by_contradiction'.{1} (ring.{0} (linear_ordered_comm_group_with_zero.{0} linarith.ineq)) h0)  := sorry --non-trivial
lemma new_lemma_5117 (h0 : function.extfun Type topological_space) : @t0_space.{0} (complete_semilattice_Sup.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (complete_semilattice_Sup.{0} num))  := sorry --non-trivial
lemma new_lemma_5118 (h0 : group (linear_ordered_add_comm_group congr_arg_kind)) : is_cyclic (linear_ordered_add_comm_group congr_arg_kind) := sorry --non-trivial
lemma new_lemma_5119 (h0 : function.extfun Type ring) : @rank_condition.{0} (has_bot.{0} (option.{0} unsigned)) (@function.extfun_app.{2 1} Type ring.{0} h0 (has_bot.{0} (option.{0} unsigned)))  := sorry --non-trivial
lemma new_lemma_5120 (h0 : functor.add_const (ordered_add_comm_monoid (has_pos_part pos)) (ring linarith.comp)) : @archimedean.{0} (has_pos_part.{0} pos) (@functor.add_const.run.{0 0} (ordered_add_comm_monoid.{0} (has_pos_part.{0} pos)) (ring.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_5121 (h0 : finset (linear_ordered_comm_group empty)) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_5122 (h0 : functor.add_const (topological_space (add_group num)) congr_arg_kind) : @preirreducible_space.{0} (add_group.{0} num) (@functor.add_const.run.{0 0} (topological_space.{0} (add_group.{0} num)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_5123 (h0 : function.extfun Type topological_space) : @sequential_space.{0} (simple_graph.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (simple_graph.{0} name))  := sorry --non-trivial
lemma new_lemma_5124 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : palindrome (function.extfun_app (function.extfun_app h0 list) (has_add unsigned)) := sorry --non-trivial
lemma new_lemma_5125 (h1 : topological_space (has_ssubset std_gen)) : totally_disconnected_space (has_ssubset std_gen) := sorry --non-trivial
lemma new_lemma_5126 (h0 : function.extfun Type (functor.add_const (semiring (partial_order unsigned)))) : @is_noetherian_ring.{0} (partial_order.{0} unsigned) (@functor.add_const.run.{0 0} (semiring.{0} (partial_order.{0} unsigned)) unsigned (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (semiring.{0} (partial_order.{0} unsigned))) h0 unsigned))  := sorry --non-trivial
lemma new_lemma_5127 (h0 : uniform_space (semiring linarith.comp)) : complete_space (semiring linarith.comp) := sorry --non-trivial
lemma new_lemma_5128 (h1 : uniform_space (has_top char)) : complete_space (has_top char) := sorry --non-trivial
lemma new_lemma_5129 (h0 : function.extfun Type complete_lattice) : @complete_lattice.is_Sup_finite_compact.{0} (pseudo_metric_space.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (pseudo_metric_space.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_5130 (h0 : topological_space (has_neg (has_to_string (has_to_string pos)))) : t1_space (has_neg (has_to_string (has_to_string pos))) := sorry --non-trivial
lemma new_lemma_5131 (h0 : monoid (has_one (semiring (semiring unsigned)))) : monoid.fg (has_one (semiring (semiring unsigned))) := sorry --non-trivial
lemma new_lemma_5132 (h0 : functor.add_const (list (left_cancel_monoid unsigned)) empty) : list.nodup (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_5133 (h0 : function.extfun Type measurable_space) (h1 : function.extfun Type has_div) : @has_measurable_div₂.{0} linarith.comp_source (@function.extfun_app.{2 1} Type measurable_space.{0} h0 linarith.comp_source) (@function.extfun_app.{2 1} Type has_div.{0} h1 linarith.comp_source)  := sorry --non-trivial
lemma new_lemma_5134 (h0 : add_group (has_append (has_ssubset (random_gen linarith.comp_source)))) : is_add_cyclic (has_append (has_ssubset (random_gen linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_5135 (h0 : monoid (finset (has_Inf pos))) : monoid.fg (finset (has_Inf pos)) := sorry --non-trivial
lemma new_lemma_5136 (h0 : not (group string_imp -> false)) : @normalizer_condition.{0} string_imp (@classical.by_contradiction'.{1} (group.{0} string_imp) h0)  := sorry --non-trivial
lemma new_lemma_5137 (h0 : functor.add_const (function.extfun (Type 1) topological_space) pos) : @t0_space.{1} (has_to_string.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) topological_space.{1}) pos h0) (has_to_string.{1} Type))  := sorry --non-trivial
lemma new_lemma_5138 (h0 : ring (measurable_space (semiring (semiring congr_arg_kind)))) : is_domain (measurable_space (semiring (semiring congr_arg_kind))) := sorry --non-trivial
lemma new_lemma_5139 (h0 : functor.add_const (function.extfun Type topological_space) linarith.comp) : @t0_space.{0} (add_comm_monoid.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) linarith.comp h0) (add_comm_monoid.{0} name))  := sorry --non-trivial
lemma new_lemma_5140 (h0 : function.extfun Type topological_space) : @locally_compact_space.{0} (has_bot.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_bot.{0} name))  := sorry --non-trivial
lemma new_lemma_5141 (h0 : list (ring (option pos))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_5142 (h0 : topological_space (add_cancel_monoid ennreal)) : preirreducible_space (add_cancel_monoid ennreal) := sorry --non-trivial
lemma new_lemma_5143 (h0 : monoid (has_add (has_add unsigned))) : monoid.fg (has_add (has_add unsigned)) := sorry --non-trivial
lemma new_lemma_5144 (h0 : not (function.extfun Type ring -> false)) : @is_domain.{0} (with_one.{0} num) (@function.extfun_app.{2 1} Type ring.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type ring.{0}) h0) (with_one.{0} num))  := sorry --non-trivial
lemma new_lemma_5145 (h0 : not (group (metric_space linarith.comp) -> false)) : @group.fg.{0} (metric_space.{0} linarith.comp) (@classical.by_contradiction'.{1} (group.{0} (metric_space.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_5146 (h0 : topological_space (normed_group (has_norm linarith.comp_source))) : totally_separated_space (normed_group (has_norm linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_5147 (h0 : function.extfun Type ordered_add_comm_monoid) : @archimedean.{0} (canonically_linear_ordered_monoid.{0} name) (@function.extfun_app.{2 1} Type ordered_add_comm_monoid.{0} h0 (canonically_linear_ordered_monoid.{0} name))  := sorry --non-trivial
lemma new_lemma_5148 (h0 : functor.add_const (topological_space (has_zero pos)) (comm_group Type)) : @preirreducible_space.{0} (has_zero.{0} pos) (@functor.add_const.run.{0 1} (topological_space.{0} (has_zero.{0} pos)) (comm_group.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_5149 (h1 : not (uniform_space (distrib reducibility_hints) -> false)) : @complete_space.{0} (distrib.{0} reducibility_hints) (@classical.by_contradiction'.{1} (uniform_space.{0} (distrib.{0} reducibility_hints)) h1)  := sorry --non-trivial
lemma new_lemma_5150 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_principal_ideal_ring.{0} (complete_distrib_lattice.{0} name) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (complete_distrib_lattice.{0} name))  := sorry --non-trivial
lemma new_lemma_5151 (h0 : topological_space (bin_tree congr_arg_kind)) : loc_path_connected_space (bin_tree congr_arg_kind) := sorry --non-trivial
lemma new_lemma_5152 (h0 : function.extfun Type (functor.add_const (uniform_space (bin_tree unsigned)))) : @separated_space.{0} (bin_tree.{0} unsigned) (@functor.add_const.run.{0 0} (uniform_space.{0} (bin_tree.{0} unsigned)) empty (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (uniform_space.{0} (bin_tree.{0} unsigned))) h0 empty))  := sorry --non-trivial
lemma new_lemma_5153 (h0 : uniform_space (linear_ordered_comm_group_with_zero string_imp)) : complete_space (linear_ordered_comm_group_with_zero string_imp) := sorry --non-trivial
lemma new_lemma_5154 (h0 : uniform_space (measurable_space (has_top num))) : separated_space (measurable_space (has_top num)) := sorry --non-trivial
lemma new_lemma_5155 (h0 : topological_space (semigroup (comm_group (has_add Type)))) : path_connected_space (semigroup (comm_group (has_add Type))) := sorry --non-trivial
lemma new_lemma_5156 (h0 : add_monoid (measurable_space (has_union (has_union num)))) : add_monoid.fg (measurable_space (has_union (has_union num))) := sorry --non-trivial
lemma new_lemma_5157 (h0 : ring (with_bot (random_gen (random_gen linarith.comp_source)))) : is_domain (with_bot (random_gen (random_gen linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_5158 (h0 : function.extfun Type list) : palindrome (function.extfun_app h0 (add_group unsigned)) := sorry --non-trivial
lemma new_lemma_5159 (h0 : set (set to_additive.value_type)) (h1 : function.extfun to_additive.value_type (fun (x : to_additive.value_type), Prop)) : measurable_space.generate_measurable h0 (function.extfun_app h1) := sorry --non-trivial
lemma new_lemma_5160 (h0 : topological_space (linear_ordered_add_comm_group (has_nnnorm (has_nnnorm (has_nnnorm fun_info))))) : t0_space (linear_ordered_add_comm_group (has_nnnorm (has_nnnorm (has_nnnorm fun_info)))) := sorry --non-trivial
lemma new_lemma_5161 (h0 : function.extfun Type topological_space) : @irreducible_space.{0} (comm_monoid.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (comm_monoid.{0} empty))  := sorry --non-trivial
lemma new_lemma_5162 (h0 : functor.add_const (ordered_comm_monoid (has_nndist environment.implicit_infer_kind)) Type) : @has_exists_mul_of_le.{0} (has_nndist.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 1} (ordered_comm_monoid.{0} (has_nndist.{0} environment.implicit_infer_kind)) Type h0)  := sorry --non-trivial
lemma new_lemma_5163 (h0 : has_nnnorm std_gen) (h1 : filter (has_nnnorm std_gen)) : @totally_disconnected_space.{0} (has_nnnorm.{0} std_gen) (@nhds_adjoint.{0} (has_nnnorm.{0} std_gen) h0 h1)  := sorry --non-trivial
lemma new_lemma_5164 (h0 : function.extfun Type group) : @is_cyclic.{0} (linear_ordered_add_comm_group.{0} (random_gen.{0} linarith.comp_source)) (@function.extfun_app.{2 1} Type group.{0} h0 (linear_ordered_add_comm_group.{0} (random_gen.{0} linarith.comp_source)))  := sorry --non-trivial
lemma new_lemma_5165 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @irreducible_space.{1} (has_neg_part.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 topological_space.{1}) (has_neg_part.{1} Type))  := sorry --non-trivial
lemma new_lemma_5166 (h0 : functor.add_const (group (has_zero (ring (has_neg linarith.comp)))) (has_to_string Type)) : @normalizer_condition.{0} (has_zero.{0} (ring.{0} (has_neg.{0} linarith.comp))) (@functor.add_const.run.{0 1} (group.{0} (has_zero.{0} (ring.{0} (has_neg.{0} linarith.comp)))) (has_to_string.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_5167 (h0 : complete_lattice (linear_ordered_field (option (option ennreal)))) : is_atomistic (linear_ordered_field (option (option ennreal))) := sorry --non-trivial
lemma new_lemma_5168 (h0 : function.extfun Type topological_space) : @locally_compact_space.{0} (linear_ordered_field.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (linear_ordered_field.{0} pos))  := sorry --non-trivial
lemma new_lemma_5169 (h0 : group (ring (ring linarith.comp))) : normalizer_condition (ring (ring linarith.comp)) := sorry --non-trivial
lemma new_lemma_5170 (h0 : uniform_space (with_bot (random_gen (has_inv (has_inv linarith.comp_source))))) : complete_space (with_bot (random_gen (has_inv (has_inv linarith.comp_source)))) := sorry --non-trivial
lemma new_lemma_5171 (h0 : not (function.extfun Type topological_space -> false)) : @t0_space.{0} (has_union.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (has_union.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_5172 (h0 : function.extfun Type topological_space) : @path_connected_space.{0} (ring.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (ring.{0} name))  := sorry --non-trivial
lemma new_lemma_5173 (h0 : functor.add_const (topological_space (finset environment.implicit_infer_kind)) environment.implicit_infer_kind) : @normal_space.{0} (finset.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (finset.{0} environment.implicit_infer_kind)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_5174 (h0 : add_group (mul_one_class (mul_one_class char))) : is_add_cyclic (mul_one_class (mul_one_class char)) := sorry --non-trivial
lemma new_lemma_5175 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @unique_factorization_monoid.{0} (add_semigroup.{0} unsigned) (@function.extfun_app.{2 1} Type cancel_comm_monoid_with_zero.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 cancel_comm_monoid_with_zero.{0}) (add_semigroup.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_5176 (h0 : functor.add_const (ordered_add_comm_monoid (omega_complete_partial_order unsigned)) unsigned) : @archimedean.{0} (omega_complete_partial_order.{0} unsigned) (@functor.add_const.run.{0 0} (ordered_add_comm_monoid.{0} (omega_complete_partial_order.{0} unsigned)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_5177 (h0 : complete_lattice (has_nndist name)) : complete_lattice.is_Sup_finite_compact (has_nndist name) := sorry --non-trivial
lemma new_lemma_5178 (h0 : filter (has_inter (has_to_string congr_arg_kind))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_5179 (h0 : ordered_add_comm_monoid (add_left_cancel_semigroup congr_arg_kind)) : archimedean (add_left_cancel_semigroup congr_arg_kind) := sorry --non-trivial
lemma new_lemma_5180 (h0 : not (ring (encodable to_additive.value_type) -> false)) : @rank_condition.{0} (encodable.{0} to_additive.value_type) (@classical.by_contradiction'.{1} (ring.{0} (encodable.{0} to_additive.value_type)) h0)  := sorry --non-trivial
lemma new_lemma_5181 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @path_connected_space.{0} (cancel_monoid.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (cancel_monoid.{0} empty))  := sorry --non-trivial
lemma new_lemma_5182 (h0 : add_group (has_add (add_comm_monoid Type))) : is_add_cyclic (has_add (add_comm_monoid Type)) := sorry --non-trivial
lemma new_lemma_5183 (h0 : function.extfun ((Type -> Type) -> Type 1) (function.extfun (Type -> Type))) : @is_domain.{0} (measurable_space.{0} empty) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) (@function.extfun_app.{3 2} ((Type → Type) → Type 1) (function.extfun.{2 2} (Type → Type)) h0 (function.extfun.{2 1} Type)) ring.{0}) (measurable_space.{0} empty))  := sorry --non-trivial
lemma new_lemma_5184 (h0 : uniform_space (cancel_monoid (comm_group ennreal))) : separated_space (cancel_monoid (comm_group ennreal)) := sorry --non-trivial
lemma new_lemma_5185 (h0 : function.extfun Type finset) : finset.nonempty (function.extfun_app h0 (mul_zero_class congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_5186 (h0 : complete_lattice (normed_comm_ring congr_arg_kind)) : is_atomistic (normed_comm_ring congr_arg_kind) := sorry --non-trivial
lemma new_lemma_5187 (h0 : add_group (semigroup (mul_one_class (mul_one_class pos)))) : is_add_cyclic (semigroup (mul_one_class (mul_one_class pos))) := sorry --non-trivial
lemma new_lemma_5188 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @preirreducible_space.{0} (linear_ordered_comm_group.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (linear_ordered_comm_group.{0} pos))  := sorry --non-trivial
lemma new_lemma_5189 (h3 : uniform_space (normed_group to_additive.value_type)) : complete_space (normed_group to_additive.value_type) := sorry --non-trivial
lemma new_lemma_5190 (h1 : complete_lattice (semi_normed_comm_ring linarith.ineq)) : is_compactly_generated (semi_normed_comm_ring linarith.ineq) := sorry --non-trivial
lemma new_lemma_5191 (h0 : prod (has_add (mul_zero_class name)) (has_add (mul_zero_class name))) : id_rel h0 := sorry --non-trivial
lemma new_lemma_5192 (h0 : functor.add_const (group (has_Inf pos)) Type) : @is_cyclic.{0} (has_Inf.{0} pos) (@functor.add_const.run.{0 1} (group.{0} (has_Inf.{0} pos)) Type h0)  := sorry --non-trivial
lemma new_lemma_5193 (h0 : function.extfun Type ring) : @rank_condition.{0} (measurable_space.{0} linarith.comp) (@function.extfun_app.{2 1} Type ring.{0} h0 (measurable_space.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_5194 (h0 : functor.add_const (monoid (generalized_boolean_algebra name)) name) : @monoid.fg.{0} (generalized_boolean_algebra.{0} name) (@functor.add_const.run.{0 0} (monoid.{0} (generalized_boolean_algebra.{0} name)) name h0)  := sorry --non-trivial
lemma new_lemma_5195 (h0 : functor.add_const (cancel_comm_monoid_with_zero (preorder congr_arg_kind)) num) : @unique_factorization_monoid.{0} (preorder.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (cancel_comm_monoid_with_zero.{0} (preorder.{0} congr_arg_kind)) num h0)  := sorry --non-trivial
lemma new_lemma_5196 (h0 : function.extfun Type group) : @normalizer_condition.{0} (add_cancel_monoid.{0} pos) (@function.extfun_app.{2 1} Type group.{0} h0 (add_cancel_monoid.{0} pos))  := sorry --non-trivial
lemma new_lemma_5197 (h0 : functor.add_const (semiring (bin_tree empty)) unsigned) : @is_noetherian_ring.{0} (bin_tree.{0} empty) (@functor.add_const.run.{0 0} (semiring.{0} (bin_tree.{0} empty)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_5198 (h0 : functor.add_const (filter (boolean_algebra Type)) name) : countable_Inter_filter (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_5199 (h0 : function.extfun Type (functor.add_const (ring pos))) : @is_domain.{0} pos (@functor.add_const.run.{0 0} (ring.{0} pos) pos (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (ring.{0} pos)) h0 pos))  := sorry --non-trivial
lemma new_lemma_5200 (h0 : complete_lattice (ordered_comm_ring (sub_neg_monoid Type))) : is_compactly_generated (ordered_comm_ring (sub_neg_monoid Type)) := sorry --non-trivial
lemma new_lemma_5201 (h0 : ring (has_lt (mul_one_class (mul_one_class environment.projection_info)))) : rank_condition (has_lt (mul_one_class (mul_one_class environment.projection_info))) := sorry --non-trivial
lemma new_lemma_5202 (h0 : function.extfun Type measurable_space) (h1 : has_div linarith.ineq) : @has_measurable_div₂.{0} linarith.ineq (@function.extfun_app.{2 1} Type measurable_space.{0} h0 linarith.ineq) h1  := sorry --non-trivial
lemma new_lemma_5203 (h2 : topological_space linarith.ineq) : totally_disconnected_space linarith.ineq := sorry --non-trivial
lemma new_lemma_5204 (h2 : complete_lattice linarith.comp_source) : complete_lattice.is_Sup_finite_compact linarith.comp_source := sorry --non-trivial
lemma new_lemma_5205 (h0 : function.extfun fun_info (fun (x : fun_info), Prop)) : zzz_forall (function.extfun_app h0) := sorry --non-trivial
lemma new_lemma_5206 (h0 : functor.add_const (topological_space (complete_distrib_lattice name)) environment.implicit_infer_kind) : @preconnected_space.{0} (complete_distrib_lattice.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (complete_distrib_lattice.{0} name)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_5207 (h0 : add_group (has_ssubset (add_comm_semigroup string.iterator))) : is_add_cyclic (has_ssubset (add_comm_semigroup string.iterator)) := sorry --non-trivial
lemma new_lemma_5208 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @loc_path_connected_space.{0} (group_with_zero.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (group_with_zero.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_5209 (h0 : topological_space (ordered_comm_group congr_arg_kind)) : totally_separated_space (ordered_comm_group congr_arg_kind) := sorry --non-trivial
lemma new_lemma_5210 (h0 : ring (has_nndist (boolean_algebra.core environment.implicit_infer_kind))) : rank_condition (has_nndist (boolean_algebra.core environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_5211 (h0 : has_mem.mem topological_space has_emptyc.emptyc) : @discrete_topology.{0} (metric_space.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) topological_space.{0} h0) (metric_space.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_5212 (h0 : functor.comp group boolean_algebra.core environment.implicit_infer_kind) : @normalizer_condition.{0} (boolean_algebra.core.{0} environment.implicit_infer_kind) (@functor.comp.run.{0 0 0} group.{0} boolean_algebra.core.{0} environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_5213 (h0 : topological_space (semigroup (add_comm_monoid (has_neg_part pos)))) : totally_disconnected_space (semigroup (add_comm_monoid (has_neg_part pos))) := sorry --non-trivial
lemma new_lemma_5214 (h0 : not (topological_space (normed_field char) -> false)) : @path_connected_space.{0} (normed_field.{0} char) (@classical.by_contradiction'.{1} (topological_space.{0} (normed_field.{0} char)) h0)  := sorry --non-trivial
lemma new_lemma_5215 (h0 : topological_space (with_one unsigned)) : t0_space (with_one unsigned) := sorry --non-trivial
lemma new_lemma_5216 (h0 : finset (has_to_string (finset linarith.comp))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_5217 (h0 : ordered_add_comm_monoid (ordered_comm_ring (ring (ring Type)))) : archimedean (ordered_comm_ring (ring (ring Type))) := sorry --non-trivial
lemma new_lemma_5218 (h0 : group (has_Inf (ring (has_nndist (ring (has_add (finset pos))))))) : group.fg (has_Inf (ring (has_nndist (ring (has_add (finset pos)))))) := sorry --non-trivial
lemma new_lemma_5219 (h0 : topological_space (canonically_ordered_monoid (has_bot real))) : normal_space (canonically_ordered_monoid (has_bot real)) := sorry --non-trivial
lemma new_lemma_5220 (h0 : function.extfun Type ring) : @strong_rank_condition.{0} (ordered_comm_group.{0} unsigned) (@function.extfun_app.{2 1} Type ring.{0} h0 (ordered_comm_group.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_5221 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @strong_rank_condition.{0} (has_edist.{0} unsigned) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (has_edist.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_5222 (h0 : ordered_add_comm_monoid (normed_linear_ordered_group (semiring congr_arg_kind))) : archimedean (normed_linear_ordered_group (semiring congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_5223 (h0 : ring (has_append (comm_ring char))) : is_domain (has_append (comm_ring char)) := sorry --non-trivial
lemma new_lemma_5224 (h0 : function.extfun Type group) : @group.fg.{0} (with_bot.{0} linarith.ineq) (@function.extfun_app.{2 1} Type group.{0} h0 (with_bot.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_5225 (h0 : ordered_comm_monoid (monoid_with_zero ennreal)) : has_exists_mul_of_le (monoid_with_zero ennreal) := sorry --non-trivial
lemma new_lemma_5226 (h0 : complete_lattice (random_gen linarith.comp)) : is_compactly_generated (random_gen linarith.comp) := sorry --non-trivial
lemma new_lemma_5227 (h0 : filter (fintype fun_info)) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_5228 (h0 : fin has_zero.zero) : @totally_disconnected_space.{0} (canonically_ordered_monoid.{0} real) (@matrix.vec_empty.{0} (topological_space.{0} (canonically_ordered_monoid.{0} real)) (@matrix.vec_empty.{0} (fin (@has_zero.zero.{0} nat nat.has_zero)) (@matrix.vec_empty.{0} (fin (@has_zero.zero.{0} nat nat.has_zero)) h0)))  := sorry --non-trivial
lemma new_lemma_5229 (h0 : group (complete_linear_order (semiring (semiring (semiring unsigned))))) : group.fg (complete_linear_order (semiring (semiring (semiring unsigned)))) := sorry --non-trivial
lemma new_lemma_5230 (h0 : functor.add_const (ring (boolean_algebra unsigned)) Type) : @is_domain.{0} (boolean_algebra.{0} unsigned) (@functor.add_const.run.{0 1} (ring.{0} (boolean_algebra.{0} unsigned)) Type h0)  := sorry --non-trivial
lemma new_lemma_5231 (h0 : list (encodable linarith.comp_source)) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_5232 (h0 : ring (distrib (add_cancel_comm_monoid char))) : strong_rank_condition (distrib (add_cancel_comm_monoid char)) := sorry --non-trivial
lemma new_lemma_5233 (h0 : topological_space (ordered_comm_ring (has_nndist (ring Type)))) : path_connected_space (ordered_comm_ring (has_nndist (ring Type))) := sorry --non-trivial
lemma new_lemma_5234 (h0 : ring (has_emptyc (has_top fun_info))) : rank_condition (has_emptyc (has_top fun_info)) := sorry --non-trivial
lemma new_lemma_5235 (h1 : ring (distrib_lattice to_additive.value_type)) : rank_condition (distrib_lattice to_additive.value_type) := sorry --non-trivial
lemma new_lemma_5236 (h0 : uniform_space (complete_linear_order num)) : complete_space (complete_linear_order num) := sorry --non-trivial
lemma new_lemma_5237 (h0 : add_group (normed_linear_ordered_group (has_neg linarith.comp))) : is_add_cyclic (normed_linear_ordered_group (has_neg linarith.comp)) := sorry --non-trivial
lemma new_lemma_5238 (h0 : topological_space (semigroup (finset pos))) : normal_space (semigroup (finset pos)) := sorry --non-trivial
lemma new_lemma_5239 (h0 : functor.comp uniform_space cancel_monoid name) : @separated_space.{0} (cancel_monoid.{0} name) (@functor.comp.run.{0 0 0} uniform_space.{0} cancel_monoid.{0} name h0)  := sorry --non-trivial
lemma new_lemma_5240 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @group.fg.{0} (semigroup.{0} pos) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (semigroup.{0} pos))  := sorry --non-trivial
lemma new_lemma_5241 (h0 : group (generalized_boolean_algebra (has_Inf (finset Type)))) : is_cyclic (generalized_boolean_algebra (has_Inf (finset Type))) := sorry --non-trivial
lemma new_lemma_5242 (h0 : topological_space name) : path_connected_space name := sorry --non-trivial
lemma new_lemma_5243 (h0 : functor.add_const (function.extfun Type ring) (finset pos)) : @is_domain.{0} (has_neg.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type ring.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type ring.{0}) (finset.{0} pos) h0) (has_neg.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_5244 (h0 : functor.add_const (complete_lattice (free_add_monoid congr_arg_kind)) unsigned) : @is_compactly_generated.{0} (free_add_monoid.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (complete_lattice.{0} (free_add_monoid.{0} congr_arg_kind)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_5245 (h0 : topological_space (ring (has_Inf (canonically_linear_ordered_monoid linarith.comp)))) : totally_disconnected_space (ring (has_Inf (canonically_linear_ordered_monoid linarith.comp))) := sorry --non-trivial
lemma new_lemma_5246 (h1 : topological_space (normed_group char)) : path_connected_space (normed_group char) := sorry --non-trivial
lemma new_lemma_5247 (h0 : function.extfun Type monoid) : @monoid.fg.{0} (add_left_cancel_semigroup.{0} unsigned) (@function.extfun_app.{2 1} Type monoid.{0} h0 (add_left_cancel_semigroup.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_5248 (h1 : ring (has_top to_additive.value_type)) : is_domain (has_top to_additive.value_type) := sorry --non-trivial
lemma new_lemma_5249 (h0 : not (has_mem.mem (semiring linarith.ineq) has_emptyc.emptyc -> false)) : @is_add_cyclic.{0} (semiring.{0} linarith.ineq) (@finset.pi.empty.{1 0} Type add_group.{0} (semiring.{0} linarith.ineq) (@classical.by_contradiction'.{0} (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (semiring.{0} linarith.ineq) (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))) h0))  := sorry --non-trivial
lemma new_lemma_5250 (h0 : topological_space (has_neg unsigned)) : t0_space (has_neg unsigned) := sorry --non-trivial
lemma new_lemma_5251 (h0 : group (has_zero (option (option name)))) : group.fg (has_zero (option (option name))) := sorry --non-trivial
lemma new_lemma_5252 (h0 : function.extfun Type ring) : @strong_rank_condition.{0} (ring.{0} name) (@function.extfun_app.{2 1} Type ring.{0} h0 (ring.{0} name))  := sorry --non-trivial
lemma new_lemma_5253 (h0 : group (comm_group (has_neg (has_add linarith.comp)))) : group.fg (comm_group (has_neg (has_add linarith.comp))) := sorry --non-trivial
lemma new_lemma_5254 (h0 h1 : multiset (simple_graph (mul_one_class (mul_one_class linarith.comp_source)))) : multiset.disjoint h0 h1 := sorry --non-trivial
lemma new_lemma_5255 (h0 : functor.add_const (function.extfun Type ring) name) : @strong_rank_condition.{0} (add_comm_monoid.{0} unsigned) (@function.extfun_app.{2 1} Type ring.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type ring.{0}) name h0) (add_comm_monoid.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_5256 (h0 : uniform_space (id linarith.comp)) : complete_space (id linarith.comp) := sorry --non-trivial
lemma new_lemma_5257 (h0 : functor.add_const (group (canonically_ordered_comm_semiring name)) name) : @is_simple_group.{0} (canonically_ordered_comm_semiring.{0} name) (@functor.add_const.run.{0 0} (group.{0} (canonically_ordered_comm_semiring.{0} name)) name h0)  := sorry --non-trivial
lemma new_lemma_5258 (h0 : topological_space (cancel_monoid (boolean_algebra.core (boolean_algebra.core (has_add name))))) : preconnected_space (cancel_monoid (boolean_algebra.core (boolean_algebra.core (has_add name)))) := sorry --non-trivial
lemma new_lemma_5259 : nonempty std_gen := sorry --non-trivial
lemma new_lemma_5260 (h0 : function.extfun Type cancel_comm_monoid_with_zero) : @unique_factorization_monoid.{0} (has_to_string.{0} name) (@function.extfun_app.{2 1} Type cancel_comm_monoid_with_zero.{0} h0 (has_to_string.{0} name))  := sorry --non-trivial
lemma new_lemma_5261 (h0 : functor.add_const (ring (add_cancel_monoid Type)) (finset (finset linarith.comp))) : @rank_condition.{1} (add_cancel_monoid.{1} Type) (@functor.add_const.run.{1 0} (ring.{1} (add_cancel_monoid.{1} Type)) (finset.{0} (finset.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_5262 (h0 : has_mem.mem (measurable_space to_additive.value_type) has_emptyc.emptyc) : @totally_disconnected_space.{0} (measurable_space.{0} to_additive.value_type) (@finset.pi.empty.{1 0} Type topological_space.{0} (measurable_space.{0} to_additive.value_type) h0)  := sorry --non-trivial
lemma new_lemma_5263 (h1 : complete_lattice (mul_one_class fun_info)) : complete_lattice.is_Sup_finite_compact (mul_one_class fun_info) := sorry --non-trivial
lemma new_lemma_5264 (h0 : function.extfun nat fin) : @rank_condition.{0} (has_pos_part.{0} linarith.comp) (@matrix.vec_empty.{0} (ring.{0} (has_pos_part.{0} linarith.comp)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_5265 (h0 : not (topological_space empty -> false)) : path_connected_space empty := sorry --non-trivial
lemma new_lemma_5266 (h0 : fin has_zero.zero) : matrix.vec_empty (id (id (matrix.vec_empty (id h0)))) := sorry --non-trivial
lemma new_lemma_5267 (h0 : list (list Prop)) : list.head (list.head h0) := sorry --non-trivial
lemma new_lemma_5268 (h0 : functor.add_const (functor.add_const (ordered_add_comm_monoid pos) unsigned) name) : @archimedean.{0} pos (@functor.add_const.run.{0 0} (ordered_add_comm_monoid.{0} pos) unsigned (@functor.add_const.run.{0 0} (functor.add_const.{0 0} (ordered_add_comm_monoid.{0} pos) unsigned) name h0))  := sorry --non-trivial
lemma new_lemma_5269 (h0 : ordered_comm_monoid (mul_zero_class (finset (has_nndist name)))) : has_exists_mul_of_le (mul_zero_class (finset (has_nndist name))) := sorry --non-trivial
lemma new_lemma_5270 (h0 : topological_space (has_zero (has_add (cancel_monoid (has_to_string unsigned))))) : normal_space (has_zero (has_add (cancel_monoid (has_to_string unsigned)))) := sorry --non-trivial
lemma new_lemma_5271 (h0 : list (option unsigned)) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_5272 (h0 : complete_lattice (has_add (has_to_string (has_to_string num)))) : is_compactly_generated (has_add (has_to_string (has_to_string num))) := sorry --non-trivial
lemma new_lemma_5273 (h0 h1 : multiset (semi_normed_ring to_additive.value_type)) : multiset.disjoint h0 h1 := sorry --non-trivial
lemma new_lemma_5274 (h0 : function.extfun Type topological_space) : @preirreducible_space.{0} (has_neg_part.{0} (has_add.{0} name)) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_neg_part.{0} (has_add.{0} name)))  := sorry --non-trivial
lemma new_lemma_5275 (h0 : ring (has_neg name)) : rank_condition (has_neg name) := sorry --non-trivial
lemma new_lemma_5276 (h0 : monoid (linear_ordered_field (option num))) : monoid.fg (linear_ordered_field (option num)) := sorry --non-trivial
lemma new_lemma_5277 (h0 : ring (cancel_monoid (has_add name))) : is_domain (cancel_monoid (has_add name)) := sorry --non-trivial
lemma new_lemma_5278 (h0 : not (function.extfun Type semiring -> false)) : @is_noetherian_ring.{0} (partial_order.{0} num) (@function.extfun_app.{2 1} Type semiring.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type semiring.{0}) h0) (partial_order.{0} num))  := sorry --non-trivial
lemma new_lemma_5279 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @discrete_topology.{1} (ring.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 topological_space.{1}) (ring.{1} Type))  := sorry --non-trivial
lemma new_lemma_5280 (h0 : list (with_one (with_bot congr_arg_kind))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_5281 (h0 : group (denumerable (random_gen (random_gen string_imp)))) : is_cyclic (denumerable (random_gen (random_gen string_imp))) := sorry --non-trivial
lemma new_lemma_5282 (h0 : group (boolean_algebra (has_add pos))) : is_cyclic (boolean_algebra (has_add pos)) := sorry --non-trivial
lemma new_lemma_5283 (h0 : functor.add_const (filter (boolean_algebra.core name)) environment.implicit_infer_kind) : countable_Inter_filter (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_5284 (h0 : topological_space (complete_linear_order (semiring empty))) : t1_space (complete_linear_order (semiring empty)) := sorry --non-trivial
lemma new_lemma_5285 (h0 : functor.comp topological_space complete_distrib_lattice pos) : @regular_space.{0} (complete_distrib_lattice.{0} pos) (@functor.comp.run.{0 0 0} topological_space.{0} complete_distrib_lattice.{0} pos (@functor.comp.run.{0 0 0} topological_space.{0} complete_distrib_lattice.{0} pos h0))  := sorry --non-trivial
lemma new_lemma_5286 (h0 : not (topological_space (has_norm linarith.comp_source) -> false)) : @irreducible_space.{0} (has_norm.{0} linarith.comp_source) (@classical.by_contradiction'.{1} (topological_space.{0} (has_norm.{0} linarith.comp_source)) h0)  := sorry --non-trivial
lemma new_lemma_5287 (h0 : has_mem.mem (random_gen to_additive.value_type) has_emptyc.emptyc) : @is_domain.{0} (random_gen.{0} to_additive.value_type) (@finset.pi.empty.{1 0} Type ring.{0} (random_gen.{0} to_additive.value_type) h0)  := sorry --non-trivial
lemma new_lemma_5288 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : palindrome (function.extfun_app (function.extfun_app h0 list) (has_norm to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_5289 (h0 : ring (random_gen (semiring linarith.comp_source))) : strong_rank_condition (random_gen (semiring linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_5290 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @normal_space.{0} (measurable_space.dynkin_system.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (measurable_space.dynkin_system.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_5291 (h0 : topological_space (non_assoc_semiring empty)) : path_connected_space (non_assoc_semiring empty) := sorry --non-trivial
lemma new_lemma_5292 (h0 : functor.add_const (ring (boolean_algebra linarith.comp)) linarith.comp) : @strong_rank_condition.{0} (boolean_algebra.{0} linarith.comp) (@functor.add_const.run.{0 0} (ring.{0} (boolean_algebra.{0} linarith.comp)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_5293 (h0 : ring (semiring (has_norm (has_top (has_top linarith.comp_source))))) : is_domain (semiring (has_norm (has_top (has_top linarith.comp_source)))) := sorry --non-trivial
lemma new_lemma_5294 (h0 : ring (with_one (has_nnnorm (has_nnnorm (has_nnnorm char))))) : strong_rank_condition (with_one (has_nnnorm (has_nnnorm (has_nnnorm char)))) := sorry --non-trivial
lemma new_lemma_5295 (h0 : add_group (omega_complete_partial_order fun_info)) : is_add_cyclic (omega_complete_partial_order fun_info) := sorry --non-trivial
lemma new_lemma_5296 (h0 : complete_lattice (has_to_string (option unsigned))) : is_atomistic (has_to_string (option unsigned)) := sorry --non-trivial
lemma new_lemma_5297 (h0 : ring (add_comm_monoid ennreal) -> ring (add_comm_monoid ennreal) -> Prop) : is_symm (ring (add_comm_monoid ennreal)) h0 := sorry --non-trivial
lemma new_lemma_5298 (h0 : function.extfun Type topological_space) : @loc_path_connected_space.{0} (as_linear_order.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (as_linear_order.{0} empty))  := sorry --non-trivial
lemma new_lemma_5299 (h0 : not (group (with_one linarith.comp) -> false)) : @group.fg.{0} (with_one.{0} linarith.comp) (@classical.by_contradiction'.{1} (group.{0} (with_one.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_5300 (h0 : not (complete_lattice (add_cancel_comm_monoid reducibility_hints) -> false)) : @is_compactly_generated.{0} (add_cancel_comm_monoid.{0} reducibility_hints) (@classical.by_contradiction'.{1} (complete_lattice.{0} (add_cancel_comm_monoid.{0} reducibility_hints)) h0)  := sorry --non-trivial
lemma new_lemma_5301 (h0 : functor.add_const (topological_space (normed_comm_ring linarith.comp)) (has_zero name)) : @sequential_space.{0} (normed_comm_ring.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (normed_comm_ring.{0} linarith.comp)) (has_zero.{0} name) h0)  := sorry --non-trivial
lemma new_lemma_5302 (h0 : group (has_nndist (has_add (has_neg linarith.comp)))) : normalizer_condition (has_nndist (has_add (has_neg linarith.comp))) := sorry --non-trivial
lemma new_lemma_5303 (h0 : functor.add_const (group (cancel_monoid name)) name) : @normalizer_condition.{0} (cancel_monoid.{0} name) (@functor.add_const.run.{0 0} (group.{0} (cancel_monoid.{0} name)) name h0)  := sorry --non-trivial
lemma new_lemma_5304 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_compactly_generated.{0} (has_add.{0} name) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (has_add.{0} name))  := sorry --non-trivial
lemma new_lemma_5305 (h0 : topological_space (canonically_linear_ordered_monoid (has_add real))) : loc_path_connected_space (canonically_linear_ordered_monoid (has_add real)) := sorry --non-trivial
lemma new_lemma_5306 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_atomistic.{0} (linear_ordered_semiring.{0} empty) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (linear_ordered_semiring.{0} empty))  := sorry --non-trivial
lemma new_lemma_5307 (h0 : functor.add_const (ordered_comm_monoid (ring unsigned)) (has_to_string name)) : @has_exists_mul_of_le.{0} (ring.{0} unsigned) (@functor.add_const.run.{0 0} (ordered_comm_monoid.{0} (ring.{0} unsigned)) (has_to_string.{0} name) h0)  := sorry --non-trivial
lemma new_lemma_5308 (h0 : ring (measurable_space.dynkin_system (semiring num))) : strong_rank_condition (measurable_space.dynkin_system (semiring num)) := sorry --non-trivial
lemma new_lemma_5309 (h0 : ordered_comm_monoid (ring (has_add linarith.comp))) : has_exists_mul_of_le (ring (has_add linarith.comp)) := sorry --non-trivial
lemma new_lemma_5310 (h0 : functor.add_const (group (ring linarith.comp)) (has_neg linarith.comp)) : @is_simple_group.{0} (ring.{0} linarith.comp) (@functor.add_const.run.{0 0} (group.{0} (ring.{0} linarith.comp)) (has_neg.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_5311 (h0 : topological_space (has_nndist (has_neg name))) : totally_disconnected_space (has_nndist (has_neg name)) := sorry --non-trivial
lemma new_lemma_5312 (h0 : uniform_space (linear_ordered_semiring (semiring empty))) : separated_space (linear_ordered_semiring (semiring empty)) := sorry --non-trivial
lemma new_lemma_5313 (h0 : functor.add_const (function.extfun Type topological_space) linarith.comp) : @irreducible_space.{0} (has_add.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) linarith.comp h0) (has_add.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_5314 (h0 : not (filter (pseudo_emetric_space linarith.comp_source) -> false)) : filter.ne_bot (classical.by_contradiction' h0) := sorry --non-trivial
lemma new_lemma_5315 (h0 : complete_lattice (has_nndist (cancel_monoid pos))) : is_compactly_generated (has_nndist (cancel_monoid pos)) := sorry --non-trivial
lemma new_lemma_5316 (h0 : uniform_space (has_bot empty)) : complete_space (has_bot empty) := sorry --non-trivial
lemma new_lemma_5317 (h0 : complete_lattice (has_neg (ring Type))) : complete_lattice.is_Sup_finite_compact (has_neg (ring Type)) := sorry --non-trivial
lemma new_lemma_5318 (h0 : has_mem.mem (has_emptyc (random_gen linarith.ineq)) has_emptyc.emptyc) : @is_domain.{0} (has_emptyc.{0} (random_gen.{0} linarith.ineq)) (@finset.pi.empty.{1 0} Type ring.{0} (has_emptyc.{0} (random_gen.{0} linarith.ineq)) h0)  := sorry --non-trivial
lemma new_lemma_5319 (h0 : ring (topological_space (normed_field char))) : rank_condition (topological_space (normed_field char)) := sorry --non-trivial
lemma new_lemma_5320 (h0 : functor.add_const (add_group (has_Sup empty)) (semiring empty)) : @is_add_cyclic.{0} (has_Sup.{0} empty) (@functor.add_const.run.{0 0} (add_group.{0} (has_Sup.{0} empty)) (semiring.{0} empty) h0)  := sorry --non-trivial
lemma new_lemma_5321 (h0 : topological_space (has_emptyc (has_norm congr_arg_kind))) : discrete_topology (has_emptyc (has_norm congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_5322 (h0 : functor.add_const (ring (ordered_ring pos)) linarith.comp) : @is_domain.{0} (ordered_ring.{0} pos) (@functor.add_const.run.{0 0} (ring.{0} (ordered_ring.{0} pos)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_5323 (h0 : not (function.extfun Type ring -> false)) : @is_domain.{0} (has_nnnorm.{0} fun_info) (@function.extfun_app.{2 1} Type ring.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type ring.{0}) h0) (has_nnnorm.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_5324 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @totally_separated_space.{0} (semigroup.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (semigroup.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_5325 (h0 : topological_space (normed_comm_ring (has_add linarith.comp))) : totally_separated_space (normed_comm_ring (has_add linarith.comp)) := sorry --non-trivial
lemma new_lemma_5326 (h0 : ring (add_cancel_monoid (has_add (comm_group (has_add linarith.comp))))) : rank_condition (add_cancel_monoid (has_add (comm_group (has_add linarith.comp)))) := sorry --non-trivial
lemma new_lemma_5327 (h0 : uniform_space (has_nndist (option ennreal))) : complete_space (has_nndist (option ennreal)) := sorry --non-trivial
lemma new_lemma_5328 (h0 : topological_space (add_semigroup (option empty))) : loc_path_connected_space (add_semigroup (option empty)) := sorry --non-trivial
lemma new_lemma_5329 (h0 : fin has_zero.zero) : @loc_path_connected_space.{0} (complete_distrib_lattice.{0} linarith.comp) (@matrix.vec_empty.{0} (topological_space.{0} (complete_distrib_lattice.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_5330 (h0 : ring (generalized_boolean_algebra (has_scalar Type real))) : rank_condition (generalized_boolean_algebra (has_scalar Type real)) := sorry --non-trivial
lemma new_lemma_5331 (h0 : ring (has_neg environment.implicit_infer_kind)) : strong_rank_condition (has_neg environment.implicit_infer_kind) := sorry --non-trivial
lemma new_lemma_5332 (h1 : ring (with_one congr_arg_kind)) : strong_rank_condition (with_one congr_arg_kind) := sorry --non-trivial
lemma new_lemma_5333 (h0 h1 : multiset (has_nnnorm char)) : multiset.subset h0 h1 := sorry --non-trivial
lemma new_lemma_5334 (h0 : function.extfun (finset (Type -> Type)) (has_mem.mem ring)) : @is_principal_ideal_ring.{0} (semiring.{0} linarith.ineq) (@function.extfun_app.{2 1} Type ring.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) ring.{0} (@function.extfun_app.{2 0} (finset.{1} (Type → Type)) (@has_mem.mem.{1 1} (Type → Type) (finset.{1} (Type → Type)) (@finset.has_mem.{1} (Type → Type)) ring.{0}) h0 (@has_emptyc.emptyc.{1} (finset.{1} (Type → Type)) (@finset.has_emptyc.{1} (Type → Type))))) (semiring.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_5335 (h0 : topological_space (has_pos_part (generalized_boolean_algebra pos))) : totally_disconnected_space (has_pos_part (generalized_boolean_algebra pos)) := sorry --non-trivial
lemma new_lemma_5336 (h0 : fin has_zero.zero) : @irreducible_space.{0} (boolean_algebra.core.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@matrix.vec_empty.{1} (function.extfun.{2 1} Type topological_space.{0}) h0) (boolean_algebra.core.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_5337 (h0 : topological_space (canonically_ordered_monoid (has_add (has_Inf linarith.comp)))) : preconnected_space (canonically_ordered_monoid (has_add (has_Inf linarith.comp))) := sorry --non-trivial
lemma new_lemma_5338 (h0 : function.extfun (Type 1) topological_space) : @loc_path_connected_space.{1} (add_comm_monoid.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} h0 (add_comm_monoid.{1} Type))  := sorry --non-trivial
lemma new_lemma_5339 (h0 : ring (normed_comm_ring (option (option ennreal)))) : is_domain (normed_comm_ring (option (option ennreal))) := sorry --non-trivial
lemma new_lemma_5340 (h0 : preorder (nondiscrete_normed_field string.iterator_imp)) (h1 : set (nondiscrete_normed_field string.iterator_imp)) : bdd_above h1 := sorry --non-trivial
lemma new_lemma_5341 (h0 : topological_space (has_neg_part (has_neg_part (has_neg_part pos)))) : loc_path_connected_space (has_neg_part (has_neg_part (has_neg_part pos))) := sorry --non-trivial
lemma new_lemma_5342 (h0 : ring (plift (semiring (semiring empty)))) : strong_rank_condition (plift (semiring (semiring empty))) := sorry --non-trivial
lemma new_lemma_5343 (h0 : cancel_comm_monoid_with_zero (comm_group environment.implicit_infer_kind)) : unique_factorization_monoid (comm_group environment.implicit_infer_kind) := sorry --non-trivial
lemma new_lemma_5344 (h0 : not (topological_space (has_sub num) -> false)) : @t0_space.{0} (has_sub.{0} num) (@classical.by_contradiction'.{1} (topological_space.{0} (has_sub.{0} num)) h0)  := sorry --non-trivial
lemma new_lemma_5345 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @normal_space.{0} (@id.{2} Type linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (@id.{2} Type linarith.comp))  := sorry --non-trivial
lemma new_lemma_5346 (h0 : add_group (measurable_space.dynkin_system linarith.comp)) : is_add_cyclic (measurable_space.dynkin_system linarith.comp) := sorry --non-trivial
lemma new_lemma_5347 (h0 : not (group (with_one to_additive.value_type) -> false)) : @is_cyclic.{0} (with_one.{0} to_additive.value_type) (@classical.by_contradiction'.{1} (group.{0} (with_one.{0} to_additive.value_type)) h0)  := sorry --non-trivial
lemma new_lemma_5348 (h0 : function.extfun Type monoid) : @monoid.fg.{0} (linear_ordered_semiring.{0} (has_top.{0} (has_top.{0} (has_top.{0} (has_top.{0} (has_top.{0} num)))))) (@function.extfun_app.{2 1} Type monoid.{0} h0 (linear_ordered_semiring.{0} (has_top.{0} (has_top.{0} (has_top.{0} (has_top.{0} (has_top.{0} num)))))))  := sorry --non-trivial
lemma new_lemma_5349 (h0 : uniform_space (generalized_boolean_algebra (has_add name))) : complete_space (generalized_boolean_algebra (has_add name)) := sorry --non-trivial
lemma new_lemma_5350 (h0 : topological_space (has_add (has_to_string (has_add pos)))) : normal_space (has_add (has_to_string (has_add pos))) := sorry --non-trivial
lemma new_lemma_5351 (h0 : topological_space (complete_distrib_lattice (option empty))) : topological_space.separable_space (complete_distrib_lattice (option empty)) := sorry --non-trivial
lemma new_lemma_5352 (h0 : function.extfun Type topological_space) : @t0_space.{0} (comm_monoid.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (comm_monoid.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_5353 (h0 : functor.add_const (complete_lattice (has_neg_part name)) (option ennreal)) : @is_atomistic.{0} (has_neg_part.{0} name) (@functor.add_const.run.{0 0} (complete_lattice.{0} (has_neg_part.{0} name)) (option.{0} ennreal) h0)  := sorry --non-trivial
lemma new_lemma_5354 (h0 : function.extfun Type topological_space) : @normal_space.{0} (has_Inf.{0} real) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_Inf.{0} real))  := sorry --non-trivial
lemma new_lemma_5355 (h0 : functor.add_const (topological_space (has_neg unsigned)) name) : @t1_space.{0} (has_neg.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (has_neg.{0} unsigned)) name h0)  := sorry --non-trivial
lemma new_lemma_5356 (h0 : add_group (has_union (semiring unsigned))) : is_add_cyclic (has_union (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_5357 (h0 : set (nondiscrete_normed_field (nondiscrete_normed_field environment.projection_info))) : set.finite h0 := sorry --non-trivial
lemma new_lemma_5358 (h0 : group (generalized_boolean_algebra (has_Inf (finset Type)))) : is_simple_group (generalized_boolean_algebra (has_Inf (finset Type))) := sorry --non-trivial
lemma new_lemma_5359 (h0 : semiring (has_union unsigned)) : is_noetherian_ring (has_union unsigned) := sorry --non-trivial
lemma new_lemma_5360 (h1 : function.extfun Type group) : @normalizer_condition.{0} (with_one.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type group.{0} h1 (with_one.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_5361 (h0 : group (ring (has_pos_part Type))) : group.fg (ring (has_pos_part Type)) := sorry --non-trivial
lemma new_lemma_5362 (h0 : semiring (add_cancel_monoid (has_nndist linarith.comp))) : is_noetherian_ring (add_cancel_monoid (has_nndist linarith.comp)) := sorry --non-trivial
lemma new_lemma_5363 (h0 : function.extfun nat fin) : @has_exists_mul_of_le.{0} (canonically_linear_ordered_monoid.{0} real) (@matrix.vec_empty.{0} (ordered_comm_monoid.{0} (canonically_linear_ordered_monoid.{0} real)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_5364 (h0 : functor.add_const (ring (has_nndist linarith.comp)) (ring environment.implicit_infer_kind)) : @is_domain.{0} (has_nndist.{0} linarith.comp) (@functor.add_const.run.{0 0} (ring.{0} (has_nndist.{0} linarith.comp)) (ring.{0} environment.implicit_infer_kind) h0)  := sorry --non-trivial
lemma new_lemma_5365 (h0 : monoid (measurable_space.dynkin_system (semiring (semiring congr_arg_kind)))) : monoid.fg (measurable_space.dynkin_system (semiring (semiring congr_arg_kind))) := sorry --non-trivial
lemma new_lemma_5366 (h0 : not (function.extfun Type ring -> false)) : @rank_condition.{0} (measurable_space.{0} linarith.comp) (@function.extfun_app.{2 1} Type ring.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type ring.{0}) h0) (measurable_space.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_5367 (h0 : uniform_space (has_to_string (has_add Type))) : separated_space (has_to_string (has_add Type)) := sorry --non-trivial
lemma new_lemma_5368 (h0 : functor.add_const (topological_space (has_pos_part pos)) pos) : @discrete_topology.{0} (has_pos_part.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (has_pos_part.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_5369 (h1 : complete_lattice linarith.comp_source) : is_atomistic linarith.comp_source := sorry --non-trivial
lemma new_lemma_5370 (h0 : functor.add_const (topological_space int) congr_arg_kind) : preirreducible_space int := sorry --non-trivial
lemma new_lemma_5371 (h2 : add_group (has_compl (has_nnnorm char))) : is_add_cyclic (has_compl (has_nnnorm char)) := sorry --non-trivial
lemma new_lemma_5372 (h0 : group (has_neg (has_neg pos))) : normalizer_condition (has_neg (has_neg pos)) := sorry --non-trivial
lemma new_lemma_5373 (h0 : group (normed_group (has_top (random_gen num)))) : is_cyclic (normed_group (has_top (random_gen num))) := sorry --non-trivial
lemma new_lemma_5374 (h0 : add_group (linear_ordered_semiring (has_top fun_info))) : is_add_cyclic (linear_ordered_semiring (has_top fun_info)) := sorry --non-trivial
lemma new_lemma_5375 (h0 : not (ring (normed_group linarith.ineq) -> false)) : @strong_rank_condition.{0} (normed_group.{0} linarith.ineq) (@classical.by_contradiction'.{1} (ring.{0} (normed_group.{0} linarith.ineq)) h0)  := sorry --non-trivial
lemma new_lemma_5376 (h0 : uniform_space (has_add (boolean_algebra.core pos))) : separated_space (has_add (boolean_algebra.core pos)) := sorry --non-trivial
lemma new_lemma_5377 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @totally_disconnected_space.{1} (comm_group.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 topological_space.{1}) (comm_group.{1} Type))  := sorry --non-trivial
lemma new_lemma_5378 (h0 : list (add_cancel_monoid (finset environment.implicit_infer_kind))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_5379 (h0 : not (complete_lattice (preorder empty) -> false)) : @complete_lattice.is_Sup_finite_compact.{0} (preorder.{0} empty) (@classical.by_contradiction'.{1} (complete_lattice.{0} (preorder.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_5380 (h0 : topological_space (normed_comm_ring (has_add Type))) : preirreducible_space (normed_comm_ring (has_add Type)) := sorry --non-trivial
lemma new_lemma_5381 (h0 : group (has_one (semiring congr_arg_kind))) : is_cyclic (has_one (semiring congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_5382 (h0 : cancel_comm_monoid_with_zero (has_edist (option empty))) : unique_factorization_monoid (has_edist (option empty)) := sorry --non-trivial
lemma new_lemma_5383 (h0 : ring (ring num)) : rank_condition (ring num) := sorry --non-trivial
lemma new_lemma_5384 (h0 : functor.add_const (topological_space (omega_complete_partial_order empty)) empty) : @totally_separated_space.{0} (omega_complete_partial_order.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (omega_complete_partial_order.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_5385 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @add_monoid.fg.{0} (generalized_boolean_algebra.{0} pos) (@function.extfun_app.{2 1} Type add_monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 add_monoid.{0}) (generalized_boolean_algebra.{0} pos))  := sorry --non-trivial
lemma new_lemma_5386 (h0 : function.extfun Type (functor.comp uniform_space has_nndist)) : @complete_space.{0} (has_nndist.{0} pos) (@functor.comp.run.{0 0 0} uniform_space.{0} has_nndist.{0} pos (@function.extfun_app.{2 1} Type (functor.comp.{0 0 0} uniform_space.{0} has_nndist.{0}) h0 pos))  := sorry --non-trivial
lemma new_lemma_5387 (h0 : ordered_comm_monoid (add_cancel_monoid (comm_group (has_add Type)))) : has_exists_mul_of_le (add_cancel_monoid (comm_group (has_add Type))) := sorry --non-trivial
lemma new_lemma_5388 (h1 : function.extfun (Type -> Type) (function.extfun Type)) : @locally_compact_space.{0} linarith.comp_source (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h1 topological_space.{0}) linarith.comp_source)  := sorry --non-trivial
lemma new_lemma_5389 (h0 : topological_space (has_neg (semigroup Type))) : topological_space.separable_space (has_neg (semigroup Type)) := sorry --non-trivial
lemma new_lemma_5390 (h0 : not (function.extfun Type add_group -> false)) : @is_add_cyclic.{0} (add_group.{0} empty) (@function.extfun_app.{2 1} Type add_group.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type add_group.{0}) h0) (add_group.{0} empty))  := sorry --non-trivial
lemma new_lemma_5391 (h0 : function.extfun Type group) : @normalizer_condition.{0} (normed_group.{0} (semiring.{0} (semiring.{0} (has_emptyc.{0} (has_norm.{0} num))))) (@function.extfun_app.{2 1} Type group.{0} h0 (normed_group.{0} (semiring.{0} (semiring.{0} (has_emptyc.{0} (has_norm.{0} num))))))  := sorry --non-trivial
lemma new_lemma_5392 (h0 : list (has_add Type)) : palindrome h0 := sorry --non-trivial
lemma new_lemma_5393 (h0 : functor.comp topological_space has_nndist real) : @irreducible_space.{0} (has_nndist.{0} real) (@functor.comp.run.{0 0 0} topological_space.{0} has_nndist.{0} real h0)  := sorry --non-trivial
lemma new_lemma_5394 (h0 : functor.add_const (cancel_comm_monoid_with_zero (finset unsigned)) num) : @unique_factorization_monoid.{0} (finset.{0} unsigned) (@functor.add_const.run.{0 0} (cancel_comm_monoid_with_zero.{0} (finset.{0} unsigned)) num h0)  := sorry --non-trivial
lemma new_lemma_5395 (h0 : topological_space (has_to_string (ring Type))) : irreducible_space (has_to_string (ring Type)) := sorry --non-trivial
lemma new_lemma_5396 (h0 : functor.add_const (monoid (ordered_comm_ring real)) name) : @monoid.fg.{0} (ordered_comm_ring.{0} real) (@functor.add_const.run.{0 0} (monoid.{0} (ordered_comm_ring.{0} real)) name h0)  := sorry --non-trivial
lemma new_lemma_5397 (h0 : has_mem.mem (random_gen num) has_emptyc.emptyc) : @locally_compact_space.{0} (random_gen.{0} num) (@finset.pi.empty.{1 0} Type topological_space.{0} (random_gen.{0} num) h0)  := sorry --non-trivial
lemma new_lemma_5398 (h0 : add_monoid (semigroup (has_add ennreal))) : add_monoid.fg (semigroup (has_add ennreal)) := sorry --non-trivial
lemma new_lemma_5399 (h0 : group (left_cancel_monoid empty)) : normalizer_condition (left_cancel_monoid empty) := sorry --non-trivial
lemma new_lemma_5400 (h0 : ring (ordered_ring unsigned)) : is_domain (ordered_ring unsigned) := sorry --non-trivial
lemma new_lemma_5401 (h0 : functor.add_const (function.extfun Type (functor.add_const Prop)) name) : functor.add_const.run (function.extfun_app (functor.add_const.run h0) pos) := sorry --non-trivial
lemma new_lemma_5402 (h0 : filter (complete_semilattice_Sup (has_norm empty))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_5403 (h0 : topological_space (metric_space (comm_ring to_additive.value_type))) : t0_space (metric_space (comm_ring to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_5404 (h0 : functor.add_const (cancel_comm_monoid_with_zero (canonically_linear_ordered_monoid Type)) (option name)) : @unique_factorization_monoid.{1} (canonically_linear_ordered_monoid.{1} Type) (@functor.add_const.run.{1 0} (cancel_comm_monoid_with_zero.{1} (canonically_linear_ordered_monoid.{1} Type)) (option.{0} name) h0)  := sorry --non-trivial
lemma new_lemma_5405 (h0 : group (has_Inf (has_add (has_add real)))) : normalizer_condition (has_Inf (has_add (has_add real))) := sorry --non-trivial
lemma new_lemma_5406 (h0 : ordered_add_comm_monoid (linear_ordered_field (option empty))) : archimedean (linear_ordered_field (option empty)) := sorry --non-trivial
lemma new_lemma_5407 (h0 : functor.add_const (semiring (left_cancel_semigroup congr_arg_kind)) unsigned) : @is_noetherian_ring.{0} (left_cancel_semigroup.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (semiring.{0} (left_cancel_semigroup.{0} congr_arg_kind)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_5408 (h0 : topological_space znum) : totally_separated_space znum := sorry --non-trivial
lemma new_lemma_5409 (h0 : with_bot linarith.comp_source -> Prop) : Exists h0 := sorry --non-trivial
lemma new_lemma_5410 (h0 : functor.add_const (topological_space (has_to_string pos)) Type) : @totally_disconnected_space.{0} (has_to_string.{0} pos) (@functor.add_const.run.{0 1} (topological_space.{0} (has_to_string.{0} pos)) Type h0)  := sorry --non-trivial
lemma new_lemma_5411 (h0 : topological_space (linear_ordered_cancel_comm_monoid (semiring empty))) : discrete_topology (linear_ordered_cancel_comm_monoid (semiring empty)) := sorry --non-trivial
lemma new_lemma_5412 (h0 : functor.add_const (topological_space (has_nndist Type)) pos) : @preconnected_space.{1} (has_nndist.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (has_nndist.{1} Type)) pos h0)  := sorry --non-trivial
lemma new_lemma_5413 (h0 : group (comm_group unsigned)) : is_simple_group (comm_group unsigned) := sorry --non-trivial
lemma new_lemma_5414 (h0 : functor.add_const (group (normed_linear_ordered_group unsigned)) empty) : @is_cyclic.{0} (normed_linear_ordered_group.{0} unsigned) (@functor.add_const.run.{0 0} (group.{0} (normed_linear_ordered_group.{0} unsigned)) empty h0)  := sorry --non-trivial
lemma new_lemma_5415 (h0 : ring (add_cancel_monoid (has_zero (has_neg (finset (normed_comm_ring Type)))))) : rank_condition (add_cancel_monoid (has_zero (has_neg (finset (normed_comm_ring Type))))) := sorry --non-trivial
lemma new_lemma_5416 (h0 : functor.add_const (topological_space (add_cancel_monoid linarith.comp)) name) : @path_connected_space.{0} (add_cancel_monoid.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (add_cancel_monoid.{0} linarith.comp)) name h0)  := sorry --non-trivial
lemma new_lemma_5417 (h0 : topological_space (has_emptyc (has_norm empty))) : locally_compact_space (has_emptyc (has_norm empty)) := sorry --non-trivial
lemma new_lemma_5418 (h0 : functor.add_const (function.extfun Type ring) pos) : @strong_rank_condition.{0} (ring.{0} linarith.comp) (@function.extfun_app.{2 1} Type ring.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type ring.{0}) pos h0) (ring.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_5419 (h0 : function.extfun Type topological_space) : @discrete_topology.{0} num (@function.extfun_app.{2 1} Type topological_space.{0} h0 num)  := sorry --non-trivial
lemma new_lemma_5420 (h0 : order_hom nat (topological_space (canonically_ordered_add_monoid empty))) : @t0_space.{0} (canonically_ordered_add_monoid.{0} empty) (@monotonic_sequence_limit.{0} (topological_space.{0} (canonically_ordered_add_monoid.{0} empty)) (@topological_space.partial_order.{0} (canonically_ordered_add_monoid.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_5421 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @discrete_topology.{0} (has_pos_part.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_pos_part.{0} name))  := sorry --non-trivial
lemma new_lemma_5422 (h0 : functor.add_const (topological_space (has_pos_part linarith.comp)) Type) : @normal_space.{0} (has_pos_part.{0} linarith.comp) (@functor.add_const.run.{0 1} (topological_space.{0} (has_pos_part.{0} linarith.comp)) Type h0)  := sorry --non-trivial
lemma new_lemma_5423 (h0 h4 : multiset char) : multiset.le h0 h4 := sorry --non-trivial
lemma new_lemma_5424 (h0 : topological_space (complete_semilattice_Sup string_imp)) : totally_separated_space (complete_semilattice_Sup string_imp) := sorry --non-trivial
lemma new_lemma_5425 (h0 : not (function.extfun Type topological_space -> false)) : @locally_compact_space.{0} (semiring.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (semiring.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_5426 (h0 : topological_space (canonically_ordered_monoid (has_add linarith.comp))) : t1_space (canonically_ordered_monoid (has_add linarith.comp)) := sorry --non-trivial
lemma new_lemma_5427 (h3 : not (uniform_space to_additive.value_type -> false)) : @complete_space.{0} to_additive.value_type (@classical.by_contradiction'.{1} (uniform_space.{0} to_additive.value_type) h3)  := sorry --non-trivial
lemma new_lemma_5428 (h0 : has_mem.mem (measurable_space fun_info) has_emptyc.emptyc) : @normalizer_condition.{0} (measurable_space.{0} fun_info) (@finset.pi.empty.{1 0} Type group.{0} (measurable_space.{0} fun_info) h0)  := sorry --non-trivial
lemma new_lemma_5429 (h0 : functor.add_const (ring (mul_zero_class unsigned)) Type) : @strong_rank_condition.{0} (mul_zero_class.{0} unsigned) (@functor.add_const.run.{0 1} (ring.{0} (mul_zero_class.{0} unsigned)) Type h0)  := sorry --non-trivial
lemma new_lemma_5430 (h0 : ring (div_inv_monoid string_imp)) : rank_condition (div_inv_monoid string_imp) := sorry --non-trivial
lemma new_lemma_5431 (h0 : filter (with_one (random_gen linarith.comp_source))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_5432 (h0 : ring (has_sub num)) : is_principal_ideal_ring (has_sub num) := sorry --non-trivial
lemma new_lemma_5433 (h0 : complete_lattice (sub_neg_monoid Type)) : is_compactly_generated (sub_neg_monoid Type) := sorry --non-trivial
lemma new_lemma_5434 (h0 : uniform_space (has_norm (has_norm to_additive.value_type))) : separated_space (has_norm (has_norm to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_5435 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @loc_path_connected_space.{0} (complete_distrib_lattice.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (complete_distrib_lattice.{0} name))  := sorry --non-trivial
lemma new_lemma_5436 (h0 : topological_space (has_Inf (ring (finset (has_neg pos))))) : t0_space (has_Inf (ring (finset (has_neg pos)))) := sorry --non-trivial
lemma new_lemma_5437 (h0 : functor.add_const (topological_space (ordered_comm_ring linarith.comp)) (finset pos)) : @preirreducible_space.{0} (ordered_comm_ring.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (ordered_comm_ring.{0} linarith.comp)) (finset.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_5438 (h0 : function.extfun Type topological_space) : @sequential_space.{0} (generalized_boolean_algebra.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (generalized_boolean_algebra.{0} name))  := sorry --non-trivial
lemma new_lemma_5439 (h0 : topological_space (finset (has_nndist ennreal))) : preconnected_space (finset (has_nndist ennreal)) := sorry --non-trivial
lemma new_lemma_5440 (h0 : functor.add_const (complete_lattice (has_nndist linarith.comp)) Type) : @is_compactly_generated.{0} (has_nndist.{0} linarith.comp) (@functor.add_const.run.{0 1} (complete_lattice.{0} (has_nndist.{0} linarith.comp)) Type h0)  := sorry --non-trivial
lemma new_lemma_5441 (h0 : function.extfun Type topological_space) : @sequential_space.{0} (add_comm_monoid.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (add_comm_monoid.{0} pos))  := sorry --non-trivial
lemma new_lemma_5442 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_noetherian_ring.{0} (boolean_algebra.core.{0} name) (@function.extfun_app.{2 1} Type semiring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 semiring.{0}) (boolean_algebra.core.{0} name))  := sorry --non-trivial
lemma new_lemma_5443 (h0 : uniform_space (uniform_space (mul_one_class to_additive.value_type))) : complete_space (uniform_space (mul_one_class to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_5444 (h2 : topological_space (random_gen linarith.comp_source)) : locally_compact_space (random_gen linarith.comp_source) := sorry --non-trivial
lemma new_lemma_5445 (h0 : function.extfun Type ordered_comm_monoid) : @has_exists_mul_of_le.{0} (boolean_algebra.core.{0} linarith.comp) (@function.extfun_app.{2 1} Type ordered_comm_monoid.{0} h0 (boolean_algebra.core.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_5446 (h0 : fin has_zero.zero) : @rank_condition.{0} (comm_semigroup.{0} real) (@matrix.vec_empty.{0} (ring.{0} (comm_semigroup.{0} real)) h0)  := sorry --non-trivial
lemma new_lemma_5447 (h0 : not (group (comm_ring (has_nnnorm char)) -> false)) : @is_cyclic.{0} (comm_ring.{0} (has_nnnorm.{0} char)) (@classical.by_contradiction'.{1} (group.{0} (comm_ring.{0} (has_nnnorm.{0} char))) h0)  := sorry --non-trivial
lemma new_lemma_5448 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @locally_compact_space.{0} (linear_ordered_semiring.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (linear_ordered_semiring.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_5449 (h0 : functor.add_const (topological_space (comm_group ennreal)) (mul_zero_class unsigned)) : @irreducible_space.{0} (comm_group.{0} ennreal) (@functor.add_const.run.{0 0} (topological_space.{0} (comm_group.{0} ennreal)) (mul_zero_class.{0} unsigned) h0)  := sorry --non-trivial
lemma new_lemma_5450 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @discrete_topology.{0} (normed_comm_ring.{0} ennreal) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (normed_comm_ring.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_5451 (h1 : topological_space (complete_semilattice_Sup to_additive.value_type)) : irreducible_space (complete_semilattice_Sup to_additive.value_type) := sorry --non-trivial
lemma new_lemma_5452 (h0 : has_mem.mem (linear_ordered_semiring empty) has_emptyc.emptyc) : @normal_space.{0} (linear_ordered_semiring.{0} empty) (@finset.pi.empty.{1 0} Type topological_space.{0} (linear_ordered_semiring.{0} empty) h0)  := sorry --non-trivial
lemma new_lemma_5453 (h0 : add_monoid (complete_semilattice_Sup (has_norm linarith.comp))) : add_monoid.fg (complete_semilattice_Sup (has_norm linarith.comp)) := sorry --non-trivial
lemma new_lemma_5454 (h0 : function.extfun linarith.comp_source (fun (x : linarith.comp_source), Prop)) (h1 : filter linarith.comp_source) : filter.eventually (function.extfun_app h0) h1 := sorry --non-trivial
lemma new_lemma_5455 (h0 : filter (has_star (semiring congr_arg_kind))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_5456 (h0 : uniform_space (denumerable (comm_semigroup linarith.ineq))) : complete_space (denumerable (comm_semigroup linarith.ineq)) := sorry --non-trivial
lemma new_lemma_5457 (h0 : complete_lattice (has_inner unsigned (semiring empty))) : complete_lattice.is_Sup_finite_compact (has_inner unsigned (semiring empty)) := sorry --non-trivial
lemma new_lemma_5458 (h0 : function.extfun nat fin) : @unique_factorization_monoid.{0} (comm_semigroup.{0} real) (@matrix.vec_empty.{0} (cancel_comm_monoid_with_zero.{0} (comm_semigroup.{0} real)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_5459 (h0 : functor.add_const (uniform_space (omega_complete_partial_order unsigned)) empty) : @separated_space.{0} (omega_complete_partial_order.{0} unsigned) (@functor.add_const.run.{0 0} (uniform_space.{0} (omega_complete_partial_order.{0} unsigned)) empty h0)  := sorry --non-trivial
lemma new_lemma_5460 (h0 : functor.add_const (function.extfun Type filter) environment.implicit_infer_kind) : filter.ne_bot (function.extfun_app (functor.add_const.run h0) (semigroup linarith.comp)) := sorry --non-trivial
lemma new_lemma_5461 (h0 : topological_space (generalized_boolean_algebra (has_neg name))) : totally_disconnected_space (generalized_boolean_algebra (has_neg name)) := sorry --non-trivial
lemma new_lemma_5462 (h0 : not (function.extfun Type complete_lattice -> false)) : @complete_lattice.is_Sup_finite_compact.{0} num (@function.extfun_app.{2 1} Type complete_lattice.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type complete_lattice.{0}) h0) num)  := sorry --non-trivial
lemma new_lemma_5463 (h0 h1 : list linarith.comp_source) : list.disjoint h0 h1 := sorry --non-trivial
lemma new_lemma_5464 (h0 : function.extfun Type (functor.add_const (group (complete_distrib_lattice empty)))) : @is_cyclic.{0} (complete_distrib_lattice.{0} empty) (@functor.add_const.run.{0 0} (group.{0} (complete_distrib_lattice.{0} empty)) empty (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (group.{0} (complete_distrib_lattice.{0} empty))) h0 empty))  := sorry --non-trivial
lemma new_lemma_5465 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_add_cyclic.{0} (has_zero.{0} linarith.comp) (@function.extfun_app.{2 1} Type add_group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 add_group.{0}) (has_zero.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_5466 (h0 : topological_space (boolean_algebra (has_neg (has_Inf name)))) : irreducible_space (boolean_algebra (has_neg (has_Inf name))) := sorry --non-trivial
lemma new_lemma_5467 (h0 : add_monoid (ring (option ennreal))) : add_monoid.fg (ring (option ennreal)) := sorry --non-trivial
lemma new_lemma_5468 (h0 : functor.add_const (function.extfun Type cancel_comm_monoid_with_zero) name) : @unique_factorization_monoid.{0} (has_neg.{0} name) (@function.extfun_app.{2 1} Type cancel_comm_monoid_with_zero.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type cancel_comm_monoid_with_zero.{0}) name h0) (has_neg.{0} name))  := sorry --non-trivial
lemma new_lemma_5469 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @group.fg.{0} (with_bot.{0} linarith.ineq) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (with_bot.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_5470 (h0 : group (has_Inf (has_Inf (has_Inf real)))) : group.fg (has_Inf (has_Inf (has_Inf real))) := sorry --non-trivial
lemma new_lemma_5471 (h0 : fin has_zero.zero) : @locally_compact_space.{1} (add_comm_monoid.{1} Type) (@matrix.vec_empty.{1} (topological_space.{1} (add_comm_monoid.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_5472 (h0 : functor.add_const (topological_space (has_pos_part pos)) (has_neg (has_neg pos))) : @totally_disconnected_space.{0} (has_pos_part.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (has_pos_part.{0} pos)) (has_neg.{0} (has_neg.{0} pos)) h0)  := sorry --non-trivial
lemma new_lemma_5473 (h0 : topological_space (normed_field (mul_one_class char))) : t0_space (normed_field (mul_one_class char)) := sorry --non-trivial
lemma new_lemma_5474 (h0 : not (function.extfun Type list -> false)) : list.nodup (function.extfun_app (classical.by_contradiction' h0) (measure_theory.measure_space num)) := sorry --non-trivial
lemma new_lemma_5475 (h0 : list (with_one (has_nnnorm fun_info))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_5476 (h0 : topological_space (mul_one_class (mul_one_class std_gen))) (h1 : preorder (mul_one_class (mul_one_class std_gen))) : order_topology (mul_one_class (mul_one_class std_gen)) := sorry --non-trivial
lemma new_lemma_5477 (h0 : functor.add_const (monoid (has_nndist empty)) (option (option (option empty)))) : @monoid.fg.{0} (has_nndist.{0} empty) (@functor.add_const.run.{0 0} (monoid.{0} (has_nndist.{0} empty)) (option.{0} (option.{0} (option.{0} empty))) h0)  := sorry --non-trivial
lemma new_lemma_5478 (h0 : functor.add_const (function.extfun Type complete_lattice) environment.implicit_infer_kind) : @complete_lattice.is_Sup_finite_compact.{0} (normed_comm_ring.{0} linarith.comp) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type complete_lattice.{0}) environment.implicit_infer_kind h0) (normed_comm_ring.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_5479 (h3 : ring (has_append reducibility_hints)) : is_domain (has_append reducibility_hints) := sorry --non-trivial
lemma new_lemma_5480 (h0 : filter (group_with_zero ennreal)) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_5481 (h0 : functor.add_const (topological_space (has_zero name)) environment.implicit_infer_kind) : @preirreducible_space.{0} (has_zero.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (has_zero.{0} name)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_5482 (h0 : add_monoid (has_neg (finset Type))) : add_monoid.fg (has_neg (finset Type)) := sorry --non-trivial
lemma new_lemma_5483 (h0 : functor.add_const Prop (ring Type)) : functor.add_const.run h0 := sorry --non-trivial
lemma new_lemma_5484 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @archimedean.{0} (cancel_monoid.{0} empty) (@function.extfun_app.{2 1} Type ordered_add_comm_monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ordered_add_comm_monoid.{0}) (cancel_monoid.{0} empty))  := sorry --non-trivial
lemma new_lemma_5485 (h0 : group (complete_distrib_lattice congr_arg_kind)) : is_simple_group (complete_distrib_lattice congr_arg_kind) := sorry --non-trivial
lemma new_lemma_5486 (h0 : group (random_gen (random_gen (random_gen (random_gen (has_nnnorm fun_info)))))) : group.fg (random_gen (random_gen (random_gen (random_gen (has_nnnorm fun_info))))) := sorry --non-trivial
lemma new_lemma_5487 (h0 : topological_space (add_cancel_monoid (has_neg pos))) : totally_separated_space (add_cancel_monoid (has_neg pos)) := sorry --non-trivial
lemma new_lemma_5488 (h0 : finset (left_cancel_monoid (boolean_algebra congr_arg_kind))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_5489 (h0 : topological_space (ordered_comm_monoid linarith.comp)) : irreducible_space (ordered_comm_monoid linarith.comp) := sorry --non-trivial
lemma new_lemma_5490 (h1 : topological_space (distrib char)) : t0_space (distrib char) := sorry --non-trivial
lemma new_lemma_5491 (h0 : topological_space (simple_graph (boolean_algebra.core Type))) : t0_space (simple_graph (boolean_algebra.core Type)) := sorry --non-trivial
lemma new_lemma_5492 (h1 : topological_space (distrib (comm_ring to_additive.value_type))) : t0_space (distrib (comm_ring to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_5493 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_noetherian_ring.{0} (has_zero.{0} linarith.comp) (@function.extfun_app.{2 1} Type semiring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 semiring.{0}) (has_zero.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_5494 (h0 : functor.add_const (ring (normed_comm_ring pos)) unsigned) : @is_principal_ideal_ring.{0} (normed_comm_ring.{0} pos) (@functor.add_const.run.{0 0} (ring.{0} (normed_comm_ring.{0} pos)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_5495 (h0 : functor.add_const (topological_space (preorder unsigned)) empty) : @irreducible_space.{0} (preorder.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (preorder.{0} unsigned)) empty h0)  := sorry --non-trivial
lemma new_lemma_5496 (h0 : topological_space (distrib_lattice (has_nnnorm (linear_ordered_add_comm_group char)))) : t0_space (distrib_lattice (has_nnnorm (linear_ordered_add_comm_group char))) := sorry --non-trivial
lemma new_lemma_5497 (h0 : function.extfun Type uniform_space) : @separated_space.{0} (add_group.{0} unsigned) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (add_group.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_5498 (h0 : function.extfun Type (functor.add_const (finset pos))) : finset.nonempty (functor.add_const.run (function.extfun_app h0 pos)) := sorry --non-trivial
lemma new_lemma_5499 (h0 : topological_space (semi_normed_comm_ring to_additive.value_type)) : t0_space (semi_normed_comm_ring to_additive.value_type) := sorry --non-trivial
lemma new_lemma_5500 (h1 : topological_space (semiring (has_top fun_info))) : irreducible_space (semiring (has_top fun_info)) := sorry --non-trivial
lemma new_lemma_5501 (h0 : topological_space (boolean_algebra (has_Inf (has_pos_part linarith.comp)))) : regular_space (boolean_algebra (has_Inf (has_pos_part linarith.comp))) := sorry --non-trivial
lemma new_lemma_5502 (h0 : filter (complete_semilattice_Sup (has_nnnorm (has_nnnorm (has_nnnorm (has_nnnorm fun_info)))))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_5503 (h0 : functor.add_const (list (has_nndist pos)) pos) : list.nodup (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_5504 (h0 : functor.add_const (semiring (boolean_algebra.core pos)) pos) : @is_noetherian_ring.{0} (boolean_algebra.core.{0} pos) (@functor.add_const.run.{0 0} (semiring.{0} (boolean_algebra.core.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_5505 (h0 : functor.add_const (function.extfun Type ring) pos) : @is_principal_ideal_ring.{0} (ordered_comm_ring.{0} (has_Inf.{0} pos)) (@function.extfun_app.{2 1} Type ring.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type ring.{0}) pos h0) (ordered_comm_ring.{0} (has_Inf.{0} pos)))  := sorry --non-trivial
lemma new_lemma_5506 (h0 : topological_space (random_gen (has_norm (has_norm empty)))) : locally_compact_space (random_gen (has_norm (has_norm empty))) := sorry --non-trivial
lemma new_lemma_5507 (h0 : functor.add_const (topological_space (has_Inf Type)) (has_neg (has_neg name))) : @preconnected_space.{1} (has_Inf.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (has_Inf.{1} Type)) (has_neg.{0} (has_neg.{0} name)) h0)  := sorry --non-trivial
lemma new_lemma_5508 (h1 : measurable_space (nondiscrete_normed_field fun_info)) (h2 : filter (nondiscrete_normed_field fun_info)) : filter.is_measurably_generated h2 := sorry --non-trivial
lemma new_lemma_5509 (h0 : topological_space (has_nndist (finset (has_nndist Type)))) : regular_space (has_nndist (finset (has_nndist Type))) := sorry --non-trivial
lemma new_lemma_5510 (h0 : fin has_zero.zero) : @locally_compact_space.{0} (complete_distrib_lattice.{0} pos) (@matrix.vec_empty.{0} (topological_space.{0} (complete_distrib_lattice.{0} pos)) h0)  := sorry --non-trivial
lemma new_lemma_5511 (h0 : functor.add_const (group (comm_group name)) pos) : @group.fg.{0} (comm_group.{0} name) (@functor.add_const.run.{0 0} (group.{0} (comm_group.{0} name)) pos h0)  := sorry --non-trivial
lemma new_lemma_5512 (h0 : monoid (add_comm_monoid (ordered_comm_monoid pos))) : monoid.fg (add_comm_monoid (ordered_comm_monoid pos)) := sorry --non-trivial
lemma new_lemma_5513 (h0 : functor.add_const (ring (ordered_comm_ring linarith.comp)) (has_add pos)) : @rank_condition.{0} (ordered_comm_ring.{0} linarith.comp) (@functor.add_const.run.{0 0} (ring.{0} (ordered_comm_ring.{0} linarith.comp)) (has_add.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_5514 (h0 : complete_lattice int) : is_compactly_generated int := sorry --non-trivial
lemma new_lemma_5515 (h0 : ring (has_inv empty)) : strong_rank_condition (has_inv empty) := sorry --non-trivial
lemma new_lemma_5516 (h0 : functor.add_const (monoid (has_neg environment.implicit_infer_kind)) unsigned) : @monoid.fg.{0} (has_neg.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (monoid.{0} (has_neg.{0} environment.implicit_infer_kind)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_5517 (h0 : not (function.extfun Type topological_space -> false)) : @totally_disconnected_space.{0} (denumerable.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (denumerable.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_5518 (h1 : complete_lattice (id linarith.comp)) : complete_lattice.is_Sup_finite_compact (id linarith.comp) := sorry --non-trivial
lemma new_lemma_5519 (h0 : finset (add_right_cancel_monoid num)) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_5520 (h0 : function.extfun Type topological_space) : @t0_space.{0} (with_bot.{0} string_imp) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (with_bot.{0} string_imp))  := sorry --non-trivial
lemma new_lemma_5521 (h0 : ordered_comm_monoid (has_sdiff (has_add (has_add (has_Inf (has_Inf (has_neg Type))))))) : has_exists_mul_of_le (has_sdiff (has_add (has_add (has_Inf (has_Inf (has_neg Type)))))) := sorry --non-trivial
lemma new_lemma_5522 (h0 : add_group (normed_field (has_nnnorm (has_nnnorm (has_nnnorm char))))) : is_add_cyclic (normed_field (has_nnnorm (has_nnnorm (has_nnnorm char)))) := sorry --non-trivial
lemma new_lemma_5523 (h0 : not (group (has_emptyc empty) -> false)) : @normalizer_condition.{0} (has_emptyc.{0} empty) (@classical.by_contradiction'.{1} (group.{0} (has_emptyc.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_5524 (h0 : semiring (semigroup (option unsigned))) : is_noetherian_ring (semigroup (option unsigned)) := sorry --non-trivial
lemma new_lemma_5525 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @strong_rank_condition.{0} (canonically_linear_ordered_monoid.{0} ennreal) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (canonically_linear_ordered_monoid.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_5526 (h0 : functor.add_const (ring (has_Inf real)) real) : @is_domain.{0} (has_Inf.{0} real) (@functor.add_const.run.{0 0} (ring.{0} (has_Inf.{0} real)) real h0)  := sorry --non-trivial
lemma new_lemma_5527 (h0 : functor.add_const (group (has_nndist Type)) (has_neg Type)) : @is_cyclic.{1} (has_nndist.{1} Type) (@functor.add_const.run.{1 1} (group.{1} (has_nndist.{1} Type)) (has_neg.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_5528 (h0 : ring (normed_group (has_top linarith.ineq))) : is_domain (normed_group (has_top linarith.ineq)) := sorry --non-trivial
lemma new_lemma_5529 (h0 : finset (free_add_monoid (option (option unsigned)))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_5530 (h0 : function.extfun (Type 1) (functor.add_const (function.extfun Type topological_space))) : @totally_separated_space.{0} (boolean_algebra.{0} (ring.{0} unsigned)) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type topological_space.{0}) Type (@function.extfun_app.{3 2} (Type 1) (functor.add_const.{1 1} (function.extfun.{2 1} Type topological_space.{0})) h0 Type)) (boolean_algebra.{0} (ring.{0} unsigned)))  := sorry --non-trivial
lemma new_lemma_5531 (h0 : topological_space (metric_space (semiring (semiring linarith.comp)))) : preirreducible_space (metric_space (semiring (semiring linarith.comp))) := sorry --non-trivial
lemma new_lemma_5532 (h0 : ring (has_ssubset enat)) : is_domain (has_ssubset enat) := sorry --non-trivial
lemma new_lemma_5533 (h0 : ring (ordered_ring congr_arg_kind)) : is_principal_ideal_ring (ordered_ring congr_arg_kind) := sorry --non-trivial
lemma new_lemma_5534 (h0 : complete_lattice (preorder (semiring (semiring (semiring (semiring unsigned)))))) : is_compactly_generated (preorder (semiring (semiring (semiring (semiring unsigned))))) := sorry --non-trivial
lemma new_lemma_5535 (h0 : functor.add_const (add_group (semigroup pos)) (has_add pos)) : @is_add_cyclic.{0} (semigroup.{0} pos) (@functor.add_const.run.{0 0} (add_group.{0} (semigroup.{0} pos)) (has_add.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_5536 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @normalizer_condition.{0} (normed_comm_ring.{0} linarith.comp) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (normed_comm_ring.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_5537 (h0 : topological_space (has_inter (option empty))) : t1_space (has_inter (option empty)) := sorry --non-trivial
lemma new_lemma_5538 (h0 : topological_space (add_left_cancel_semigroup empty)) : t0_space (add_left_cancel_semigroup empty) := sorry --non-trivial
lemma new_lemma_5539 (h2 : add_group (add_comm_semigroup enat)) : is_add_cyclic (add_comm_semigroup enat) := sorry --non-trivial
lemma new_lemma_5540 (h0 : has_mem.mem (id fun_info) has_emptyc.emptyc) : @rank_condition.{0} (@id.{2} Type fun_info) (@finset.pi.empty.{1 0} Type ring.{0} (@id.{2} Type fun_info) h0)  := sorry --non-trivial
lemma new_lemma_5541 (h0 : cancel_comm_monoid_with_zero (linear_ordered_cancel_comm_monoid (option (option empty)))) : unique_factorization_monoid (linear_ordered_cancel_comm_monoid (option (option empty))) := sorry --non-trivial
lemma new_lemma_5542 (h0 : function.extfun (Type 1) semiring) : @is_noetherian_ring.{1} (plift.{1} empty) (@function.extfun_app.{3 2} (Type 1) semiring.{1} h0 (plift.{1} empty))  := sorry --non-trivial
lemma new_lemma_5543 (h0 : function.extfun Type filter) : filter.ne_bot (function.extfun_app h0 auto.case_option) := sorry --non-trivial
lemma new_lemma_5544 (h0 : function.extfun Type group) : @is_simple_group.{0} (add_comm_monoid.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type group.{0} h0 (add_comm_monoid.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_5545 (h1 : set (string.iterator_imp -> ereal)) : set.separates_points h1 := sorry --non-trivial
lemma new_lemma_5546 (h0 : topological_space (has_norm (has_norm (has_norm linarith.ineq)))) : t0_space (has_norm (has_norm (has_norm linarith.ineq))) := sorry --non-trivial
lemma new_lemma_5547 (h0 : function.extfun Type group) : @is_cyclic.{0} (has_neg_part.{0} pos) (@function.extfun_app.{2 1} Type group.{0} h0 (has_neg_part.{0} pos))  := sorry --non-trivial
lemma new_lemma_5548 (h0 : functor.comp group has_nndist ennreal) : @is_simple_group.{0} (has_nndist.{0} ennreal) (@functor.comp.run.{0 0 0} group.{0} has_nndist.{0} ennreal h0)  := sorry --non-trivial
lemma new_lemma_5549 (h0 : functor.add_const (function.extfun (Type 1) group) (ring (has_add Type))) : @group.fg.{1} (ordered_comm_ring.{1} Type) (@function.extfun_app.{3 2} (Type 1) group.{1} (@functor.add_const.run.{2 1} (function.extfun.{3 2} (Type 1) group.{1}) (ring.{1} (has_add.{1} Type)) h0) (ordered_comm_ring.{1} Type))  := sorry --non-trivial
lemma new_lemma_5550 (h0 : functor.add_const (function.extfun Type topological_space) name) : @topological_space.separable_space.{0} (has_pos_part.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) name h0) (has_pos_part.{0} name))  := sorry --non-trivial
lemma new_lemma_5551 (h0 : topological_space (ring (has_add (has_add pos)))) : t1_space (ring (has_add (has_add pos))) := sorry --non-trivial
lemma new_lemma_5552 (h0 : functor.comp topological_space has_neg environment.implicit_infer_kind) : @totally_disconnected_space.{0} (has_neg.{0} environment.implicit_infer_kind) (@functor.comp.run.{0 0 0} topological_space.{0} has_neg.{0} environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_5553 (h0 : group (canonically_ordered_monoid (has_Inf (has_add Type)))) : is_cyclic (canonically_ordered_monoid (has_Inf (has_add Type))) := sorry --non-trivial
lemma new_lemma_5554 (h0 : topological_space (semigroup (has_neg pos))) : locally_compact_space (semigroup (has_neg pos)) := sorry --non-trivial
lemma new_lemma_5555 (h0 : functor.add_const (ordered_comm_monoid (normed_comm_ring unsigned)) Type) : @has_exists_mul_of_le.{0} (normed_comm_ring.{0} unsigned) (@functor.add_const.run.{0 1} (ordered_comm_monoid.{0} (normed_comm_ring.{0} unsigned)) Type h0)  := sorry --non-trivial
lemma new_lemma_5556 (h0 : monoid (comm_group environment.implicit_infer_kind)) : monoid.fg (comm_group environment.implicit_infer_kind) := sorry --non-trivial
lemma new_lemma_5557 (h1 : not (complete_lattice (with_one num) -> false)) : @is_compactly_generated.{0} (with_one.{0} num) (@classical.by_contradiction'.{1} (complete_lattice.{0} (with_one.{0} num)) h1)  := sorry --non-trivial
lemma new_lemma_5558 (h0 : cancel_comm_monoid_with_zero (boolean_algebra (has_add name))) : unique_factorization_monoid (boolean_algebra (has_add name)) := sorry --non-trivial
lemma new_lemma_5559 (h0 : add_monoid (finset (finset (mul_one_class Type)))) : add_monoid.fg (finset (finset (mul_one_class Type))) := sorry --non-trivial
lemma new_lemma_5560 (h0 : functor.add_const (topological_space (add_cancel_monoid empty)) (option (option empty))) : @normal_space.{0} (add_cancel_monoid.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (add_cancel_monoid.{0} empty)) (option.{0} (option.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_5561 (h0 : is_empty (has_top linarith.comp_source)) (h1 : function.extfun Type has_top) : is_empty.elim' h0 (function.extfun_app h1 linarith.comp_source) := sorry --non-trivial
lemma new_lemma_5562 (h2 : prod fun_info fun_info) : set.diagonal fun_info h2 := sorry --non-trivial
lemma new_lemma_5563 (h0 : fin has_zero.zero) : @unique_factorization_monoid.{0} (add_comm_monoid.{0} linarith.comp) (@matrix.vec_empty.{0} (cancel_comm_monoid_with_zero.{0} (add_comm_monoid.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_5564 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @separated_space.{1} (normed_lattice_add_comm_group.{1} Type) (@function.extfun_app.{3 2} (Type 1) uniform_space.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 uniform_space.{1}) (normed_lattice_add_comm_group.{1} Type))  := sorry --non-trivial
lemma new_lemma_5565 (h0 : topological_space (finset (finset environment.implicit_infer_kind))) : regular_space (finset (finset environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_5566 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @t0_space.{0} (pseudo_metric_space.{0} ennreal) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (pseudo_metric_space.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_5567 (h0 : complete_lattice (add_cancel_monoid (has_add name))) : is_atomistic (add_cancel_monoid (has_add name)) := sorry --non-trivial
lemma new_lemma_5568 (h0 : functor.add_const (complete_lattice (sub_neg_monoid name)) name) : @is_atomistic.{0} (sub_neg_monoid.{0} name) (@functor.add_const.run.{0 0} (complete_lattice.{0} (sub_neg_monoid.{0} name)) name h0)  := sorry --non-trivial
lemma new_lemma_5569 (h0 : topological_space (measure_theory.measure_space unsigned)) : t1_space (measure_theory.measure_space unsigned) := sorry --non-trivial
lemma new_lemma_5570 (h0 : complete_lattice (plift (semiring congr_arg_kind))) : is_atomistic (plift (semiring congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_5571 (h0 : ring (boolean_algebra (ordered_comm_ring (has_add (has_neg (has_neg Type)))))) : strong_rank_condition (boolean_algebra (ordered_comm_ring (has_add (has_neg (has_neg Type))))) := sorry --non-trivial
lemma new_lemma_5572 (h0 : ring (has_emptyc linarith.ineq)) : is_domain (has_emptyc linarith.ineq) := sorry --non-trivial
lemma new_lemma_5573 (h1 : set (enat -> char)) : set.separates_points h1 := sorry --non-trivial
lemma new_lemma_5574 (h0 : not (function.extfun Type topological_space -> false)) : @path_connected_space.{0} (has_top.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (has_top.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_5575 (h0 : functor.add_const (topological_space (semigroup unsigned)) linarith.comp) : @t0_space.{0} (semigroup.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (semigroup.{0} unsigned)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_5576 (h0 : functor.add_const (topological_space (has_pos_part Type)) Type) : @preirreducible_space.{1} (has_pos_part.{1} Type) (@functor.add_const.run.{1 1} (topological_space.{1} (has_pos_part.{1} Type)) Type h0)  := sorry --non-trivial
lemma new_lemma_5577 (h0 : filter (semigroup (cancel_monoid name))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_5578 (h0 : filter (topological_space (random_gen (random_gen to_additive.value_type)))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_5579 (h0 : function.extfun Type ring) : @strong_rank_condition.{0} (ordered_cancel_add_comm_monoid.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type ring.{0} h0 (ordered_cancel_add_comm_monoid.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_5580 (h0 : function.extfun Type complete_lattice) : is_compactly_generated ennreal := sorry --non-trivial
lemma new_lemma_5581 (h0 : functor.add_const (topological_space (has_Sup congr_arg_kind)) unsigned) : @loc_path_connected_space.{0} (has_Sup.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (has_Sup.{0} congr_arg_kind)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_5582 (h0 : filter (linear_ordered_field (has_inter unsigned))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_5583 (h1 : has_neg (has_lt std_gen)) (h2 : measurable_space (has_lt std_gen)) : has_measurable_neg (has_lt std_gen) := sorry --non-trivial
lemma new_lemma_5584 (h1 : topological_space (with_zero linarith.ineq)) : t0_space (with_zero linarith.ineq) := sorry --non-trivial
lemma new_lemma_5585 (h0 : functor.add_const (topological_space (comm_semigroup pos)) (has_neg Type)) : @sequential_space.{0} (comm_semigroup.{0} pos) (@functor.add_const.run.{0 1} (topological_space.{0} (comm_semigroup.{0} pos)) (has_neg.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_5586 (h0 : topological_space (linear_order num)) : t0_space (linear_order num) := sorry --non-trivial
lemma new_lemma_5587 (h0 : function.extfun Type topological_space) : @loc_path_connected_space.{0} (cancel_monoid.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (cancel_monoid.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_5588 (h0 : add_group (has_lt to_additive.value_type)) : is_add_cyclic (has_lt to_additive.value_type) := sorry --non-trivial
lemma new_lemma_5589 (h0 : semiring (canonically_ordered_comm_semiring (boolean_algebra.core Type))) : is_noetherian_ring (canonically_ordered_comm_semiring (boolean_algebra.core Type)) := sorry --non-trivial
lemma new_lemma_5590 (h0 : has_mem.mem (has_norm fun_info) has_emptyc.emptyc) : @complete_space.{0} (has_norm.{0} fun_info) (@finset.pi.empty.{1 0} Type uniform_space.{0} (has_norm.{0} fun_info) h0)  := sorry --non-trivial
lemma new_lemma_5591 (h0 : topological_space (canonically_ordered_comm_semiring (has_Inf pos))) : sequential_space (canonically_ordered_comm_semiring (has_Inf pos)) := sorry --non-trivial
lemma new_lemma_5592 (h0 : function.extfun Type topological_space) : @locally_compact_space.{0} (canonically_linear_ordered_monoid.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (canonically_linear_ordered_monoid.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_5593 (h0 : not (topological_space (bin_tree unsigned) -> false)) : @path_connected_space.{0} (bin_tree.{0} unsigned) (@classical.by_contradiction'.{1} (topological_space.{0} (bin_tree.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_5594 (h0 : add_group (has_ssubset ennreal)) : is_add_cyclic (has_ssubset ennreal) := sorry --non-trivial
lemma new_lemma_5595 (h0 : functor.add_const (add_group (has_zero name)) (has_nndist pos)) : @is_add_cyclic.{0} (has_zero.{0} name) (@functor.add_const.run.{0 0} (add_group.{0} (has_zero.{0} name)) (has_nndist.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_5596 (h0 : complete_lattice (has_to_string linarith.comp)) : is_compactly_generated (has_to_string linarith.comp) := sorry --non-trivial
lemma new_lemma_5597 (h0 : ring (has_nndist (option num))) : is_domain (has_nndist (option num)) := sorry --non-trivial
lemma new_lemma_5598 (h0 : functor.add_const (topological_space (has_dist unsigned)) empty) : @t0_space.{0} (has_dist.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (has_dist.{0} unsigned)) empty h0)  := sorry --non-trivial
lemma new_lemma_5599 (h0 : group (with_one (semiring (semiring linarith.comp)))) : group.fg (with_one (semiring (semiring linarith.comp))) := sorry --non-trivial
lemma new_lemma_5600 (h0 : topological_space (cancel_monoid (boolean_algebra Type))) : preirreducible_space (cancel_monoid (boolean_algebra Type)) := sorry --non-trivial
lemma new_lemma_5601 (h0 : add_group (has_neg (normed_comm_ring name))) : is_add_cyclic (has_neg (normed_comm_ring name)) := sorry --non-trivial
lemma new_lemma_5602 (h0 : functor.add_const (topological_space (is_R_or_C empty)) empty) : @path_connected_space.{0} (is_R_or_C.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (is_R_or_C.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_5603 (h0 : semiring (has_to_string (finset pos))) : is_noetherian_ring (has_to_string (finset pos)) := sorry --non-trivial
lemma new_lemma_5604 (h0 : ring (has_dist (option unsigned))) : strong_rank_condition (has_dist (option unsigned)) := sorry --non-trivial
lemma new_lemma_5605 (h0 : ring (has_ssubset (has_ssubset (has_ssubset (has_ssubset (has_ssubset fun_info)))))) : is_domain (has_ssubset (has_ssubset (has_ssubset (has_ssubset (has_ssubset fun_info))))) := sorry --non-trivial
lemma new_lemma_5606 (h0 : not (function.extfun (Type -> Type) (function.extfun Type) -> false)) : @group.fg.{0} (semiring.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) (@classical.by_contradiction'.{2} (function.extfun.{2 2} (Type → Type) (function.extfun.{2 1} Type)) h0) group.{0}) (semiring.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_5607 (h0 : functor.add_const (group (boolean_algebra environment.implicit_infer_kind)) linarith.comp) : @group.fg.{0} (boolean_algebra.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (group.{0} (boolean_algebra.{0} environment.implicit_infer_kind)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_5608 (h0 : monoid (measure_theory.measure_space empty)) : monoid.fg (measure_theory.measure_space empty) := sorry --non-trivial
lemma new_lemma_5609 (h0 : topological_space (linear_ordered_comm_group_with_zero (mul_one_class enat))) : t0_space (linear_ordered_comm_group_with_zero (mul_one_class enat)) := sorry --non-trivial
lemma new_lemma_5610 (h0 : cancel_comm_monoid_with_zero (boolean_algebra (has_add (has_add (has_add real))))) : unique_factorization_monoid (boolean_algebra (has_add (has_add (has_add real)))) := sorry --non-trivial
lemma new_lemma_5611 (h0 : complete_lattice (has_star (semiring (semiring (semiring unsigned))))) : is_atomistic (has_star (semiring (semiring (semiring unsigned)))) := sorry --non-trivial
lemma new_lemma_5612 (h0 : functor.add_const (add_group (canonically_ordered_comm_semiring pos)) pos) : @is_add_cyclic.{0} (canonically_ordered_comm_semiring.{0} pos) (@functor.add_const.run.{0 0} (add_group.{0} (canonically_ordered_comm_semiring.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_5613 (h1 : topological_space (complete_semilattice_Sup (has_nnnorm (has_nnnorm linarith.comp_source)))) : totally_disconnected_space (complete_semilattice_Sup (has_nnnorm (has_nnnorm linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_5614 (h1 : function.extfun (Type -> Type) (function.extfun Type)) : @is_cyclic.{0} (random_gen.{0} fun_info) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h1 group.{0}) (random_gen.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_5615 (h0 : topological_space (denumerable (random_gen (random_gen (random_gen int))))) : t0_space (denumerable (random_gen (random_gen (random_gen int)))) := sorry --non-trivial
lemma new_lemma_5616 (h0 : function.extfun Type add_monoid) : @add_monoid.fg.{0} (boolean_algebra.{0} pos) (@function.extfun_app.{2 1} Type add_monoid.{0} h0 (boolean_algebra.{0} pos))  := sorry --non-trivial
lemma new_lemma_5617 (h0 : not (ring (distrib (has_nnnorm (fintype fun_info))) -> false)) : @is_domain.{0} (distrib.{0} (has_nnnorm.{0} (fintype.{0} fun_info))) (@classical.by_contradiction'.{1} (ring.{0} (distrib.{0} (has_nnnorm.{0} (fintype.{0} fun_info)))) h0)  := sorry --non-trivial
lemma new_lemma_5618 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : list.nodup (function.extfun_app (function.extfun_app h0 list) (has_top linarith.ineq)) := sorry --non-trivial
lemma new_lemma_5619 (h0 : add_group (div_inv_monoid (has_nnnorm linarith.ineq))) : is_add_cyclic (div_inv_monoid (has_nnnorm linarith.ineq)) := sorry --non-trivial
lemma new_lemma_5620 (h0 : function.extfun Type (functor.comp topological_space semigroup)) : @irreducible_space.{0} (semigroup.{0} pos) (@functor.comp.run.{0 0 0} topological_space.{0} semigroup.{0} pos (@function.extfun_app.{2 1} Type (functor.comp.{0 0 0} topological_space.{0} semigroup.{0}) h0 pos))  := sorry --non-trivial
lemma new_lemma_5621 (h0 : group (has_zero (has_add unsigned))) : group.fg (has_zero (has_add unsigned)) := sorry --non-trivial
lemma new_lemma_5622 (h0 : monoid (linear_ordered_semiring (random_gen fun_info))) : monoid.fg (linear_ordered_semiring (random_gen fun_info)) := sorry --non-trivial
lemma new_lemma_5623 (h0 : ring (boolean_algebra (comm_group unsigned))) : is_domain (boolean_algebra (comm_group unsigned)) := sorry --non-trivial
lemma new_lemma_5624 (h0 : uniform_space (cancel_monoid (has_add name))) : separated_space (cancel_monoid (has_add name)) := sorry --non-trivial
lemma new_lemma_5625 (h0 : preorder (mul_zero_class ennreal)) (h1 : topological_space (mul_zero_class ennreal)) : Inf_convergence_class (mul_zero_class ennreal) := sorry --non-trivial
lemma new_lemma_5626 (h0 : has_mem.mem (linear_ordered_semiring fun_info) has_emptyc.emptyc) : @is_cyclic.{0} (linear_ordered_semiring.{0} fun_info) (@finset.pi.empty.{1 0} Type group.{0} (linear_ordered_semiring.{0} fun_info) h0)  := sorry --non-trivial
lemma new_lemma_5627 (h0 : group (has_to_string (option ennreal))) : normalizer_condition (has_to_string (option ennreal)) := sorry --non-trivial
lemma new_lemma_5628 (h0 : function.extfun Type ring) : @rank_condition.{0} (encodable.{0} char) (@function.extfun_app.{2 1} Type ring.{0} h0 (encodable.{0} char))  := sorry --non-trivial
lemma new_lemma_5629 (h0 : not (topological_space (distrib_lattice num) -> false)) : @totally_disconnected_space.{0} (distrib_lattice.{0} num) (@classical.by_contradiction'.{1} (topological_space.{0} (distrib_lattice.{0} num)) h0)  := sorry --non-trivial
lemma new_lemma_5630 (h2 : topological_space (fintype linarith.ineq)) : totally_disconnected_space (fintype linarith.ineq) := sorry --non-trivial
lemma new_lemma_5631 (h0 : functor.add_const (topological_space (partial_order congr_arg_kind)) congr_arg_kind) : @t1_space.{0} (partial_order.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (partial_order.{0} congr_arg_kind)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_5632 (h0 : prod (ordered_cancel_add_comm_monoid unsigned) (ordered_cancel_add_comm_monoid unsigned)) : id_rel h0 := sorry --non-trivial
lemma new_lemma_5633 (h0 : group (add_comm_monoid (option (option unsigned)))) : group.fg (add_comm_monoid (option (option unsigned))) := sorry --non-trivial
lemma new_lemma_5634 (h0 : function.extfun Type topological_space) : @loc_path_connected_space.{0} (comm_semigroup.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (comm_semigroup.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_5635 (h0 : function.extfun Type ring) : @rank_condition.{0} (boolean_algebra.core.{0} linarith.comp) (@function.extfun_app.{2 1} Type ring.{0} h0 (boolean_algebra.core.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_5636 (h0 : function.extfun Type topological_space) : @path_connected_space.{0} (add_comm_monoid.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (add_comm_monoid.{0} pos))  := sorry --non-trivial
lemma new_lemma_5637 (h0 : filter (has_Inf (has_add linarith.comp))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_5638 (h0 : functor.add_const (complete_lattice (ring pos)) linarith.comp) : @is_compactly_generated.{0} (ring.{0} pos) (@functor.add_const.run.{0 0} (complete_lattice.{0} (ring.{0} pos)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_5639 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @locally_compact_space.{0} (has_top.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_top.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_5640 (h0 : topological_space (sub_neg_monoid real)) : totally_separated_space (sub_neg_monoid real) := sorry --non-trivial
lemma new_lemma_5641 (h1 : monoid (with_bot (random_gen to_additive.value_type))) : monoid.fg (with_bot (random_gen to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_5642 (h0 : functor.add_const (functor.add_const Prop empty) (option empty)) : functor.add_const.run (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_5643 (h0 : function.extfun (finset (Type -> Type)) (has_mem.mem topological_space)) : @totally_disconnected_space.{0} (semiring.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type topological_space.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) topological_space.{0} (@function.extfun_app.{2 0} (finset.{1} (Type → Type)) (@has_mem.mem.{1 1} (Type → Type) (finset.{1} (Type → Type)) (@finset.has_mem.{1} (Type → Type)) topological_space.{0}) h0 (@has_emptyc.emptyc.{1} (finset.{1} (Type → Type)) (@finset.has_emptyc.{1} (Type → Type))))) (semiring.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_5644 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @totally_disconnected_space.{0} (measurable_space.{0} linarith.ineq) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (measurable_space.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_5645 (h0 : monoid (generalized_boolean_algebra (has_neg (has_add name)))) : monoid.fg (generalized_boolean_algebra (has_neg (has_add name))) := sorry --non-trivial
lemma new_lemma_5646 (h0 : has_mul (non_unital_non_assoc_semiring string.iterator_imp)) (h1 : has_zero (non_unital_non_assoc_semiring string.iterator_imp)) : no_zero_divisors (non_unital_non_assoc_semiring string.iterator_imp) := sorry --non-trivial
lemma new_lemma_5647 (h0 : add_group (comm_ring (metric_space (metric_space to_additive.value_type)))) : is_add_cyclic (comm_ring (metric_space (metric_space to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_5648 (h0 : ring (with_one (has_ssubset linarith.ineq))) : rank_condition (with_one (has_ssubset linarith.ineq)) := sorry --non-trivial
lemma new_lemma_5649 (h0 : function.extfun Type monoid) : @monoid.fg.{0} (measurable_space.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type monoid.{0} h0 (measurable_space.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_5650 (h0 : topological_space (ring (finset (has_add znum)))) : irreducible_space (ring (finset (has_add znum))) := sorry --non-trivial
lemma new_lemma_5651 (h0 : functor.add_const (functor.add_const (ordered_comm_monoid linarith.comp) Type) pos) : @has_exists_mul_of_le.{0} linarith.comp (@functor.add_const.run.{0 1} (ordered_comm_monoid.{0} linarith.comp) Type (@functor.add_const.run.{0 0} (functor.add_const.{0 1} (ordered_comm_monoid.{0} linarith.comp) Type) pos h0))  := sorry --non-trivial
lemma new_lemma_5652 (h0 : functor.add_const (topological_space pos) Type) : @preconnected_space.{0} pos (@functor.add_const.run.{0 1} (topological_space.{0} pos) Type h0)  := sorry --non-trivial
lemma new_lemma_5653 (h0 : functor.add_const (topological_space (complete_distrib_lattice Type)) (has_add pos)) : @regular_space.{1} (complete_distrib_lattice.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (complete_distrib_lattice.{1} Type)) (has_add.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_5654 (h0 : function.extfun Type semiring) : @is_noetherian_ring.{0} (add_right_cancel_monoid.{0} num) (@function.extfun_app.{2 1} Type semiring.{0} h0 (add_right_cancel_monoid.{0} num))  := sorry --non-trivial
lemma new_lemma_5655 (h2 : add_group (has_compl char)) : is_add_cyclic (has_compl char) := sorry --non-trivial
lemma new_lemma_5656 (h0 : list (ring (ring linarith.comp))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_5657 (h0 : functor.add_const (topological_space (add_left_cancel_semigroup unsigned)) empty) : @topological_space.separable_space.{0} (add_left_cancel_semigroup.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (add_left_cancel_semigroup.{0} unsigned)) empty h0)  := sorry --non-trivial
lemma new_lemma_5658 (h0 : not (topological_space (measurable_space.dynkin_system empty) -> false)) : @preirreducible_space.{0} (measurable_space.dynkin_system.{0} empty) (@classical.by_contradiction'.{1} (topological_space.{0} (measurable_space.dynkin_system.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_5659 (h0 : functor.add_const (complete_lattice (has_nndist environment.implicit_infer_kind)) Type) : @complete_lattice.is_Sup_finite_compact.{0} (has_nndist.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 1} (complete_lattice.{0} (has_nndist.{0} environment.implicit_infer_kind)) Type h0)  := sorry --non-trivial
lemma new_lemma_5660 (h0 : not (has_mem.mem (has_emptyc linarith.comp_source) has_emptyc.emptyc -> false)) : @is_domain.{0} (has_emptyc.{0} linarith.comp_source) (@finset.pi.empty.{1 0} Type ring.{0} (has_emptyc.{0} linarith.comp_source) (@classical.by_contradiction'.{0} (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (has_emptyc.{0} linarith.comp_source) (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))) h0))  := sorry --non-trivial
lemma new_lemma_5661 (h0 : group (pseudo_metric_space unsigned)) : is_cyclic (pseudo_metric_space unsigned) := sorry --non-trivial
lemma new_lemma_5662 (h0 : functor.add_const (ring (has_neg pos)) (ring (has_neg Type))) : @is_domain.{0} (has_neg.{0} pos) (@functor.add_const.run.{0 1} (ring.{0} (has_neg.{0} pos)) (ring.{1} (has_neg.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_5663 (h1 : topological_space (random_gen (random_gen char))) : totally_disconnected_space (random_gen (random_gen char)) := sorry --non-trivial
lemma new_lemma_5664 (h0 : add_group (has_add (option ennreal))) : is_add_cyclic (has_add (option ennreal)) := sorry --non-trivial
lemma new_lemma_5665 (h0 : functor.add_const (semiring (comm_group pos)) environment.implicit_infer_kind) : @is_noetherian_ring.{0} (comm_group.{0} pos) (@functor.add_const.run.{0 0} (semiring.{0} (comm_group.{0} pos)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_5666 (h0 : function.extfun (Type 1) add_group) : @is_add_cyclic.{1} (simple_graph.{1} Type) (@function.extfun_app.{3 2} (Type 1) add_group.{1} h0 (simple_graph.{1} Type))  := sorry --non-trivial
lemma new_lemma_5667 (h0 : group (with_bot (has_inv linarith.ineq))) : group.fg (with_bot (has_inv linarith.ineq)) := sorry --non-trivial
lemma new_lemma_5668 (h0 : not (topological_space (mul_zero_class unsigned) -> false)) : @t1_space.{0} (mul_zero_class.{0} unsigned) (@classical.by_contradiction'.{1} (topological_space.{0} (mul_zero_class.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_5669 (h0 : group (has_Inf (has_neg real))) : is_simple_group (has_Inf (has_neg real)) := sorry --non-trivial
lemma new_lemma_5670 (h0 : not (function.extfun Type ring -> false)) : @is_domain.{0} (@id.{2} Type (has_norm.{0} unsigned)) (@function.extfun_app.{2 1} Type ring.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type ring.{0}) h0) (@id.{2} Type (has_norm.{0} unsigned)))  := sorry --non-trivial
lemma new_lemma_5671 (h0 : functor.add_const (group (boolean_algebra pos)) (finset pos)) : @is_simple_group.{0} (boolean_algebra.{0} pos) (@functor.add_const.run.{0 0} (group.{0} (boolean_algebra.{0} pos)) (finset.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_5672 (h0 : add_monoid (semigroup (add_cancel_monoid linarith.comp))) : add_monoid.fg (semigroup (add_cancel_monoid linarith.comp)) := sorry --non-trivial
lemma new_lemma_5673 (h0 : not (topological_space (linear_ordered_comm_ring congr_arg_kind) -> false)) : @totally_disconnected_space.{0} (linear_ordered_comm_ring.{0} congr_arg_kind) (@classical.by_contradiction'.{1} (topological_space.{0} (linear_ordered_comm_ring.{0} congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_5674 (h0 : ring (linear_ordered_field num)) : rank_condition (linear_ordered_field num) := sorry --non-trivial
lemma new_lemma_5675 (h0 : functor.comp group has_zero name) : @group.fg.{0} (has_zero.{0} name) (@functor.comp.run.{0 0 0} group.{0} has_zero.{0} name h0)  := sorry --non-trivial
lemma new_lemma_5676 (h0 : topological_space (has_to_string (finset name))) : t0_space (has_to_string (finset name)) := sorry --non-trivial
lemma new_lemma_5677 (h0 : uniform_space (canonically_linear_ordered_monoid name)) : separated_space (canonically_linear_ordered_monoid name) := sorry --non-trivial
lemma new_lemma_5678 (h0 : not (function.extfun Type complete_lattice -> false)) : @is_atomistic.{0} (linear_ordered_semiring.{0} empty) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type complete_lattice.{0}) h0) (linear_ordered_semiring.{0} empty))  := sorry --non-trivial
lemma new_lemma_5679 (h0 : topological_space (left_cancel_monoid empty)) : normal_space (left_cancel_monoid empty) := sorry --non-trivial
lemma new_lemma_5680 (h0 : functor.add_const (ring (has_to_string pos)) pos) : @is_principal_ideal_ring.{0} (has_to_string.{0} pos) (@functor.add_const.run.{0 0} (ring.{0} (has_to_string.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_5681 (h0 : functor.add_const (topological_space (mul_zero_class pos)) pos) : @regular_space.{0} (mul_zero_class.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (mul_zero_class.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_5682 (h0 : function.extfun nat fin) : @has_exists_mul_of_le.{1} (comm_semigroup.{1} Type) (@matrix.vec_empty.{1} (ordered_comm_monoid.{1} (comm_semigroup.{1} Type)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_5683 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @locally_compact_space.{0} (with_one.{0} fun_info) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (with_one.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_5684 (h0 : group (preorder empty)) : normalizer_condition (preorder empty) := sorry --non-trivial
lemma new_lemma_5685 (h0 : functor.add_const (topological_space (ordered_comm_monoid pos)) linarith.comp) : @irreducible_space.{0} (ordered_comm_monoid.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (ordered_comm_monoid.{0} pos)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_5686 (h0 : functor.add_const (uniform_space (option empty)) (semiring (semiring empty))) : @complete_space.{0} (option.{0} empty) (@functor.add_const.run.{0 0} (uniform_space.{0} (option.{0} empty)) (semiring.{0} (semiring.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_5687 (h0 : functor.add_const (function.extfun (Type 1) topological_space) (finset pos)) : @regular_space.{1} (has_Inf.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) topological_space.{1}) (finset.{0} pos) h0) (has_Inf.{1} Type))  := sorry --non-trivial
lemma new_lemma_5688 (h0 : topological_space (semi_normed_ring (has_div string.iterator_imp))) : path_connected_space (semi_normed_ring (has_div string.iterator_imp)) := sorry --non-trivial
lemma new_lemma_5689 (h0 : functor.add_const (list (boolean_algebra.core linarith.comp)) linarith.comp) : palindrome (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_5690 (h0 : add_monoid (has_add (has_to_string (has_to_string (has_add (has_star linarith.comp)))))) : add_monoid.fg (has_add (has_to_string (has_to_string (has_add (has_star linarith.comp))))) := sorry --non-trivial
lemma new_lemma_5691 (h0 : topological_space (has_Inf (has_add (ring (has_add (finset linarith.comp)))))) : totally_disconnected_space (has_Inf (has_add (ring (has_add (finset linarith.comp))))) := sorry --non-trivial
lemma new_lemma_5692 (h0 : Prop) (h1 : punit) : category_theory.hom_of_element (id h0) h1 := sorry --non-trivial
lemma new_lemma_5693 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @path_connected_space.{0} (add_cancel_monoid.{0} ennreal) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (add_cancel_monoid.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_5694 (h1 : topological_space (distrib (random_gen (random_gen fun_info)))) : totally_disconnected_space (distrib (random_gen (random_gen fun_info))) := sorry --non-trivial
lemma new_lemma_5695 (h0 : complete_lattice (preorder empty)) : is_atomistic (preorder empty) := sorry --non-trivial
lemma new_lemma_5696 (h0 : ring (mul_zero_class environment.implicit_infer_kind)) : strong_rank_condition (mul_zero_class environment.implicit_infer_kind) := sorry --non-trivial
lemma new_lemma_5697 (h0 : functor.add_const (function.extfun Type add_monoid) (has_neg environment.implicit_infer_kind)) : @add_monoid.fg.{0} (has_add.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type add_monoid.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type add_monoid.{0}) (has_neg.{0} environment.implicit_infer_kind) h0) (has_add.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_5698 (h0 : function.extfun (Type 1) topological_space) : @topological_space.separable_space.{1} (canonically_ordered_monoid.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} h0 (canonically_ordered_monoid.{1} Type))  := sorry --non-trivial
lemma new_lemma_5699 (h1 : monoid (has_norm empty)) : monoid.fg (has_norm empty) := sorry --non-trivial
lemma new_lemma_5700 (h0 : functor.add_const (topological_space (left_cancel_monoid empty)) congr_arg_kind) : @preirreducible_space.{0} (left_cancel_monoid.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (left_cancel_monoid.{0} empty)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_5701 (h0 : add_group (ordered_comm_group (option empty))) : is_add_cyclic (ordered_comm_group (option empty)) := sorry --non-trivial
lemma new_lemma_5702 (h0 : fin has_zero.zero) : @rank_condition.{0} (ordered_comm_monoid.{0} pos) (@matrix.vec_empty.{0} (ring.{0} (ordered_comm_monoid.{0} pos)) h0)  := sorry --non-trivial
lemma new_lemma_5703 (h0 : finset (option (option (option unsigned)))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_5704 (h0 : function.extfun Type add_group) : @is_add_cyclic.{0} (finset.{0} linarith.comp) (@function.extfun_app.{2 1} Type add_group.{0} h0 (finset.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_5705 (h0 : group (random_gen num)) : group.fg (random_gen num) := sorry --non-trivial
lemma new_lemma_5706 (h0 : char -> char) (h1 : char -> fun_info) (h3 : coe_sort (set.range h1)) : function.is_fixed_pt h0 (set.range_splitting h1 h3) := sorry --non-trivial
lemma new_lemma_5707 (h0 : not (ring (has_neg to_additive.value_type) -> false)) : @is_domain.{0} (has_neg.{0} to_additive.value_type) (@classical.by_contradiction'.{1} (ring.{0} (has_neg.{0} to_additive.value_type)) h0)  := sorry --non-trivial
lemma new_lemma_5708 (h0 : filter (comm_ring (has_nnnorm to_additive.value_type))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_5709 (h0 : ring std_gen) : is_field std_gen := sorry --non-trivial
lemma new_lemma_5710 (h0 : not (group (has_append fun_info) -> false)) : @is_cyclic.{0} (has_append.{0} fun_info) (@classical.by_contradiction'.{1} (group.{0} (has_append.{0} fun_info)) h0)  := sorry --non-trivial
lemma new_lemma_5711 (h0 : ring (has_add (has_neg (finset linarith.comp)))) : is_principal_ideal_ring (has_add (has_neg (finset linarith.comp))) := sorry --non-trivial
lemma new_lemma_5712 (h0 : topological_space (canonically_ordered_comm_semiring (option pos))) : sequential_space (canonically_ordered_comm_semiring (option pos)) := sorry --non-trivial
lemma new_lemma_5713 (h0 : has_mem.mem (has_emptyc to_additive.value_type) has_emptyc.emptyc) : @is_domain.{0} (has_emptyc.{0} to_additive.value_type) (@finset.pi.empty.{1 0} Type ring.{0} (has_emptyc.{0} to_additive.value_type) h0)  := sorry --non-trivial
lemma new_lemma_5714 (h0 : not (function.extfun Type topological_space -> false)) : @path_connected_space.{0} (has_top.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (has_top.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_5715 (h0 : topological_space (has_ssubset (metric_space (has_lt linarith.comp_source)))) : t0_space (has_ssubset (metric_space (has_lt linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_5716 (h0 : uniform_space (add_right_cancel_monoid (semiring (semiring empty)))) : separated_space (add_right_cancel_monoid (semiring (semiring empty))) := sorry --non-trivial
lemma new_lemma_5717 (h0 : add_group (cancel_monoid (has_to_string num))) : is_add_cyclic (cancel_monoid (has_to_string num)) := sorry --non-trivial
lemma new_lemma_5718 (h0 : has_neg (simple_graph linarith.ineq)) (h1 : measurable_space (simple_graph linarith.ineq)) : has_measurable_neg (simple_graph linarith.ineq) := sorry --non-trivial
lemma new_lemma_5719 (h0 : topological_space (with_bot empty)) (h1 : Prop) : or (irreducible_space (with_bot empty)) h1 := sorry --non-trivial
lemma new_lemma_5720 (h0 : not (has_mem.mem (random_gen fun_info) has_emptyc.emptyc -> false)) : @t0_space.{0} (random_gen.{0} fun_info) (@finset.pi.empty.{1 0} Type topological_space.{0} (random_gen.{0} fun_info) (@classical.by_contradiction'.{0} (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (random_gen.{0} fun_info) (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))) h0))  := sorry --non-trivial
lemma new_lemma_5721 (h0 : complete_lattice (add_cancel_monoid name)) : is_compactly_generated (add_cancel_monoid name) := sorry --non-trivial
lemma new_lemma_5722 (h0 : functor.add_const (function.extfun (Type 1) ordered_add_comm_monoid) pos) : @archimedean.{1} (normed_comm_ring.{1} Type) (@function.extfun_app.{3 2} (Type 1) ordered_add_comm_monoid.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) ordered_add_comm_monoid.{1}) pos h0) (normed_comm_ring.{1} Type))  := sorry --non-trivial
lemma new_lemma_5723 (h0 : topological_space (has_neg_part (has_add environment.implicit_infer_kind))) : preconnected_space (has_neg_part (has_add environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_5724 (h2 h3 : multiset (mul_one_class enat)) : multiset.disjoint h2 h3 := sorry --non-trivial
lemma new_lemma_5725 (h1 : semiring (mul_one_class std_gen)) (h2 : ideal (mul_one_class std_gen)) : ideal.is_prime h2 := sorry --non-trivial
lemma new_lemma_5726 (h0 : uniform_space (complete_linear_order empty)) : separated_space (complete_linear_order empty) := sorry --non-trivial
lemma new_lemma_5727 (h0 : add_monoid (normed_comm_ring ennreal)) : add_monoid.fg (normed_comm_ring ennreal) := sorry --non-trivial
lemma new_lemma_5728 (h0 : group (has_add pos)) : is_simple_group (has_add pos) := sorry --non-trivial
lemma new_lemma_5729 (h0 : list (comm_ring (denumerable linarith.ineq))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_5730 (h0 : uniform_space (with_one (random_gen to_additive.value_type))) : complete_space (with_one (random_gen to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_5731 (h0 : topological_space (has_edist empty)) : locally_compact_space (has_edist empty) := sorry --non-trivial
lemma new_lemma_5732 (h0 : not (function.extfun (Type -> Type) (function.extfun Type) -> false)) : @add_monoid.fg.{0} (has_star.{0} unsigned) (@function.extfun_app.{2 1} Type add_monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) (@classical.by_contradiction'.{2} (function.extfun.{2 2} (Type → Type) (function.extfun.{2 1} Type)) h0) add_monoid.{0}) (has_star.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_5733 (h0 : functor.add_const (topological_space (has_neg linarith.comp)) (finset environment.implicit_infer_kind)) : @locally_compact_space.{0} (has_neg.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (has_neg.{0} linarith.comp)) (finset.{0} environment.implicit_infer_kind) h0)  := sorry --non-trivial
lemma new_lemma_5734 (h1 : function.extfun (Type -> Type) (function.extfun Type)) : @is_domain.{0} (with_one.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h1 ring.{0}) (with_one.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_5735 (h0 : functor.add_const (topological_space (has_zero linarith.comp)) linarith.comp) : @discrete_topology.{0} (has_zero.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (has_zero.{0} linarith.comp)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_5736 (h0 : not (monoid (semiring empty) -> false)) : @monoid.fg.{0} (semiring.{0} empty) (@classical.by_contradiction'.{1} (monoid.{0} (semiring.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_5737 (h0 : ring (canonically_ordered_add_monoid empty)) : is_principal_ideal_ring (canonically_ordered_add_monoid empty) := sorry --non-trivial
lemma new_lemma_5738 (h0 : not (topological_space (fintype to_additive.value_type) -> false)) : @totally_disconnected_space.{0} (fintype.{0} to_additive.value_type) (@classical.by_contradiction'.{1} (topological_space.{0} (fintype.{0} to_additive.value_type)) h0)  := sorry --non-trivial
lemma new_lemma_5739 (h0 : not (has_mem.mem (with_one fun_info) has_emptyc.emptyc -> false)) : @totally_separated_space.{0} (with_one.{0} fun_info) (@finset.pi.empty.{1 0} Type topological_space.{0} (with_one.{0} fun_info) (@classical.by_contradiction'.{0} (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (with_one.{0} fun_info) (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))) h0))  := sorry --non-trivial
lemma new_lemma_5740 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @complete_space.{0} auto.case_option (@function.extfun_app.{2 1} Type uniform_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 uniform_space.{0}) auto.case_option)  := sorry --non-trivial
lemma new_lemma_5741 (h0 : not (topological_space (semiring empty) -> false)) : @normal_space.{0} (semiring.{0} empty) (@classical.by_contradiction'.{1} (topological_space.{0} (semiring.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_5742 (h0 : function.extfun Type group) : @normalizer_condition.{0} (normed_group.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type group.{0} h0 (normed_group.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_5743 (h0 : add_monoid (ordered_comm_ring pos)) : add_monoid.fg (ordered_comm_ring pos) := sorry --non-trivial
lemma new_lemma_5744 (h0 : function.extfun Type ring) : @is_domain.{0} (simple_graph.{0} linarith.comp) (@function.extfun_app.{2 1} Type ring.{0} h0 (simple_graph.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_5745 (h0 : functor.add_const (add_group (has_neg_part Type)) ennreal) : @is_add_cyclic.{1} (has_neg_part.{1} Type) (@functor.add_const.run.{1 0} (add_group.{1} (has_neg_part.{1} Type)) ennreal h0)  := sorry --non-trivial
lemma new_lemma_5746 (h0 : functor.add_const (semiring (ordered_ring unsigned)) unsigned) : @is_noetherian_ring.{0} (ordered_ring.{0} unsigned) (@functor.add_const.run.{0 0} (semiring.{0} (ordered_ring.{0} unsigned)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_5747 (h0 : topological_space (semigroup (mul_one_class pos))) : totally_disconnected_space (semigroup (mul_one_class pos)) := sorry --non-trivial
lemma new_lemma_5748 (h0 : ring (has_compl (has_lt enat))) : is_domain (has_compl (has_lt enat)) := sorry --non-trivial
lemma new_lemma_5749 (h0 : function.extfun Type topological_space) : @irreducible_space.{0} (complete_linear_order.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (complete_linear_order.{0} empty))  := sorry --non-trivial
lemma new_lemma_5750 (h0 : group (add_cancel_comm_monoid empty)) : is_cyclic (add_cancel_comm_monoid empty) := sorry --non-trivial
lemma new_lemma_5751 (h0 : filter (random_gen (semiring (has_union linarith.comp)))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_5752 (h0 : semiring (with_bot fun_info)) : is_noetherian_ring (with_bot fun_info) := sorry --non-trivial
lemma new_lemma_5753 (h0 : function.extfun Type semiring) : @is_noetherian_ring.{0} (finset.{0} (has_nndist.{0} pos)) (@function.extfun_app.{2 1} Type semiring.{0} h0 (finset.{0} (has_nndist.{0} pos)))  := sorry --non-trivial
lemma new_lemma_5754 (h1 : topological_space (div_inv_monoid fun_info)) : path_connected_space (div_inv_monoid fun_info) := sorry --non-trivial
lemma new_lemma_5755 (h3 : group (linear_ordered_add_comm_group char)) : is_cyclic (linear_ordered_add_comm_group char) := sorry --non-trivial
lemma new_lemma_5756 (h0 : topological_space (has_zero pos)) : loc_path_connected_space (has_zero pos) := sorry --non-trivial
lemma new_lemma_5757 (h0 : topological_space (cancel_monoid (finset environment.implicit_infer_kind))) : irreducible_space (cancel_monoid (finset environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_5758 (h0 : monoid (linear_ordered_field (option (option (option (option (option (option ennreal)))))))) : monoid.fg (linear_ordered_field (option (option (option (option (option (option ennreal))))))) := sorry --non-trivial
lemma new_lemma_5759 (h0 : ring (semiring (random_gen linarith.comp_source))) : rank_condition (semiring (random_gen linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_5760 (h0 : functor.add_const (ring (pseudo_metric_space num)) ennreal) : @rank_condition.{0} (pseudo_metric_space.{0} num) (@functor.add_const.run.{0 0} (ring.{0} (pseudo_metric_space.{0} num)) ennreal h0)  := sorry --non-trivial
lemma new_lemma_5761 (h0 : ordered_add_comm_monoid (normed_lattice_add_comm_group (has_Inf (has_Inf name)))) : archimedean (normed_lattice_add_comm_group (has_Inf (has_Inf name))) := sorry --non-trivial
lemma new_lemma_5762 (h0 : group (has_Inf (ordered_comm_monoid linarith.comp))) : is_cyclic (has_Inf (ordered_comm_monoid linarith.comp)) := sorry --non-trivial
lemma new_lemma_5763 (h0 : function.extfun Type add_group) : @is_add_cyclic.{0} (pseudo_metric_space.{0} empty) (@function.extfun_app.{2 1} Type add_group.{0} h0 (pseudo_metric_space.{0} empty))  := sorry --non-trivial
lemma new_lemma_5764 (h0 : group (comm_semigroup (has_neg (sub_neg_monoid (has_bot name))))) : normalizer_condition (comm_semigroup (has_neg (sub_neg_monoid (has_bot name)))) := sorry --non-trivial
lemma new_lemma_5765 (h0 : functor.add_const (topological_space (has_star empty)) (semiring empty)) : @t0_space.{0} (has_star.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (has_star.{0} empty)) (semiring.{0} empty) h0)  := sorry --non-trivial
lemma new_lemma_5766 (h0 : function.extfun Type topological_space) : @discrete_topology.{0} (add_cancel_monoid.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (add_cancel_monoid.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_5767 (h0 : functor.add_const (group (has_zero name)) linarith.comp) : @is_cyclic.{0} (has_zero.{0} name) (@functor.add_const.run.{0 0} (group.{0} (has_zero.{0} name)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_5768 (h0 : functor.add_const (topological_space (ring unsigned)) linarith.comp) : @normal_space.{0} (ring.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (ring.{0} unsigned)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_5769 (h0 : list (partial_order (has_inter unsigned))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_5770 (h0 : functor.add_const (ring (add_cancel_monoid name)) ennreal) : @rank_condition.{0} (add_cancel_monoid.{0} name) (@functor.add_const.run.{0 0} (ring.{0} (add_cancel_monoid.{0} name)) ennreal h0)  := sorry --non-trivial
lemma new_lemma_5771 (h0 : ordered_comm_monoid (ring linarith.comp)) : has_exists_mul_of_le (ring linarith.comp) := sorry --non-trivial
lemma new_lemma_5772 (h0 : topological_space (semigroup (has_neg_part (boolean_algebra linarith.comp)))) : sequential_space (semigroup (has_neg_part (boolean_algebra linarith.comp))) := sorry --non-trivial
lemma new_lemma_5773 (h0 : function.extfun Type topological_space) : @normal_space.{0} (boolean_algebra.core.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (boolean_algebra.core.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_5774 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @normalizer_condition.{0} (with_bot.{0} num) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (with_bot.{0} num))  := sorry --non-trivial
lemma new_lemma_5775 (h0 : function.extfun Type topological_space) : @t1_space.{0} (normed_linear_ordered_group.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (normed_linear_ordered_group.{0} empty))  := sorry --non-trivial
lemma new_lemma_5776 (h0 : ring (complete_semilattice_Sup (random_gen (has_inv linarith.ineq)))) : strong_rank_condition (complete_semilattice_Sup (random_gen (has_inv linarith.ineq))) := sorry --non-trivial
lemma new_lemma_5777 (h0 : ring (complete_semilattice_Sup (semiring unsigned))) : rank_condition (complete_semilattice_Sup (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_5778 (h1 : topological_space (comm_ring (has_nnnorm (random_gen (random_gen linarith.ineq))))) : t0_space (comm_ring (has_nnnorm (random_gen (random_gen linarith.ineq)))) := sorry --non-trivial
lemma new_lemma_5779 (h0 : complete_lattice (comm_group (option (option pos)))) : is_compactly_generated (comm_group (option (option pos))) := sorry --non-trivial
lemma new_lemma_5780 (h0 : topological_space (ordered_comm_monoid linarith.comp)) : totally_separated_space (ordered_comm_monoid linarith.comp) := sorry --non-trivial
lemma new_lemma_5781 (h0 : function.extfun Type (functor.add_const (topological_space (preorder empty)))) : @discrete_topology.{0} (preorder.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (preorder.{0} empty)) empty (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (topological_space.{0} (preorder.{0} empty))) h0 empty))  := sorry --non-trivial
lemma new_lemma_5782 (h0 : function.extfun (finset Type) (has_mem.mem (linear_ordered_semiring fun_info))) : @is_add_cyclic.{0} (linear_ordered_semiring.{0} fun_info) (@finset.pi.empty.{1 0} Type add_group.{0} (linear_ordered_semiring.{0} fun_info) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (linear_ordered_semiring.{0} fun_info)) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_5783 (h0 : functor.add_const (ordered_add_comm_monoid (ordered_ring empty)) unsigned) : @archimedean.{0} (ordered_ring.{0} empty) (@functor.add_const.run.{0 0} (ordered_add_comm_monoid.{0} (ordered_ring.{0} empty)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_5784 (h0 : functor.add_const Prop (has_neg congr_arg_kind)) : functor.add_const.run h0 := sorry --non-trivial
lemma new_lemma_5785 (h0 : has_lt (normed_field reducibility_hints)) : no_max_order (normed_field reducibility_hints) := sorry --non-trivial
lemma new_lemma_5786 (h0 : ring (normed_linear_ordered_group (semiring unsigned))) : strong_rank_condition (normed_linear_ordered_group (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_5787 (h0 : functor.add_const (topological_space (boolean_algebra.core name)) Type) : @t1_space.{0} (boolean_algebra.core.{0} name) (@functor.add_const.run.{0 1} (topological_space.{0} (boolean_algebra.core.{0} name)) Type h0)  := sorry --non-trivial
lemma new_lemma_5788 (h0 : ring (has_union linarith.comp)) : strong_rank_condition (has_union linarith.comp) := sorry --non-trivial
lemma new_lemma_5789 (h0 : complete_lattice (has_to_string (finset ennreal))) : complete_lattice.is_Sup_finite_compact (has_to_string (finset ennreal)) := sorry --non-trivial
lemma new_lemma_5790 (h0 : function.extfun Type group) : @is_cyclic.{0} (normed_lattice_add_comm_group.{0} pos) (@function.extfun_app.{2 1} Type group.{0} h0 (normed_lattice_add_comm_group.{0} pos))  := sorry --non-trivial
lemma new_lemma_5791 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : palindrome (function.extfun_app (function.extfun_app h0 list) (cancel_monoid ennreal)) := sorry --non-trivial
lemma new_lemma_5792 (h0 : functor.add_const (function.extfun Type topological_space) Type) : @t0_space.{0} (has_add.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type topological_space.{0}) Type h0) (has_add.{0} pos))  := sorry --non-trivial
lemma new_lemma_5793 (h0 : finset (has_add (option (option pos)))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_5794 (h0 : functor.add_const (complete_lattice (has_neg_part name)) ennreal) : @is_compactly_generated.{0} (has_neg_part.{0} name) (@functor.add_const.run.{0 0} (complete_lattice.{0} (has_neg_part.{0} name)) ennreal h0)  := sorry --non-trivial
lemma new_lemma_5795 (h0 : ring (has_ssubset (has_nnnorm linarith.ineq))) : strong_rank_condition (has_ssubset (has_nnnorm linarith.ineq)) := sorry --non-trivial
lemma new_lemma_5796 (h0 : has_mem.mem linarith.comp_source has_emptyc.emptyc) : @is_compactly_generated.{0} linarith.comp_source (@finset.pi.empty.{1 0} Type complete_lattice.{0} linarith.comp_source h0)  := sorry --non-trivial
lemma new_lemma_5797 (h0 : functor.add_const (topological_space (ordered_ring unsigned)) congr_arg_kind) : @t0_space.{0} (ordered_ring.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (ordered_ring.{0} unsigned)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_5798 (h0 : finset (measure_theory.measure_space (semiring empty))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_5799 (h0 : ordered_comm_monoid (pseudo_metric_space (option (option unsigned)))) : has_exists_mul_of_le (pseudo_metric_space (option (option unsigned))) := sorry --non-trivial
lemma new_lemma_5800 (h1 : topological_space (semi_normed_ring to_additive.value_type)) : totally_disconnected_space (semi_normed_ring to_additive.value_type) := sorry --non-trivial
lemma new_lemma_5801 (h0 : function.extfun (Type 1) topological_space) : @totally_disconnected_space.{1} (normed_lattice_add_comm_group.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} h0 (normed_lattice_add_comm_group.{1} Type))  := sorry --non-trivial
lemma new_lemma_5802 (h0 : uniform_space (has_top (has_inv (random_gen (with_bot (with_bot linarith.comp_source)))))) : complete_space (has_top (has_inv (random_gen (with_bot (with_bot linarith.comp_source))))) := sorry --non-trivial
lemma new_lemma_5803 (h0 : prod (cancel_monoid (option (option empty))) (cancel_monoid (option (option empty)))) : id_rel h0 := sorry --non-trivial
lemma new_lemma_5804 (h0 : function.extfun Type topological_space) : @t0_space.{0} (has_norm.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_norm.{0} num))  := sorry --non-trivial
lemma new_lemma_5805 (h0 : topological_space (emetric_space (mul_one_class (add_comm_semigroup ereal)))) (h1 : set (emetric_space (mul_one_class (add_comm_semigroup ereal)))) : is_path_connected h1 := sorry --non-trivial
lemma new_lemma_5806 (h0 : topological_space (distrib (uniform_space linarith.ineq))) : path_connected_space (distrib (uniform_space linarith.ineq)) := sorry --non-trivial
lemma new_lemma_5807 (h0 : group (linear_ordered_field (option unsigned))) : is_simple_group (linear_ordered_field (option unsigned)) := sorry --non-trivial
lemma new_lemma_5808 (h0 : topological_space (linear_ordered_comm_monoid_with_zero empty)) : t0_space (linear_ordered_comm_monoid_with_zero empty) := sorry --non-trivial
lemma new_lemma_5809 (h0 : monoid (has_union (semiring linarith.comp))) : monoid.fg (has_union (semiring linarith.comp)) := sorry --non-trivial
lemma new_lemma_5810 (h0 : ring (has_add to_additive.value_type)) : is_domain (has_add to_additive.value_type) := sorry --non-trivial
lemma new_lemma_5811 (h1 : topological_space (with_bot congr_arg_kind)) : locally_compact_space (with_bot congr_arg_kind) := sorry --non-trivial
lemma new_lemma_5812 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @add_monoid.fg.{0} (canonically_ordered_comm_semiring.{0} pos) (@function.extfun_app.{2 1} Type add_monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 add_monoid.{0}) (canonically_ordered_comm_semiring.{0} pos))  := sorry --non-trivial
lemma new_lemma_5813 (h0 : monoid (ordered_cancel_add_comm_monoid (option empty))) : monoid.fg (ordered_cancel_add_comm_monoid (option empty)) := sorry --non-trivial
lemma new_lemma_5814 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @path_connected_space.{0} (semigroup.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (semigroup.{0} empty))  := sorry --non-trivial
lemma new_lemma_5815 (h0 : functor.add_const (topological_space (cancel_monoid Type)) linarith.comp) : @path_connected_space.{1} (cancel_monoid.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (cancel_monoid.{1} Type)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_5816 (h3 : ring enat) : rank_condition enat := sorry --non-trivial
lemma new_lemma_5817 (h0 : topological_space (complete_semilattice_Sup (semiring congr_arg_kind))) : locally_compact_space (complete_semilattice_Sup (semiring congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_5818 (h0 : topological_space Type) (h1 : set Type) : frontier h1 char := sorry --non-trivial
lemma new_lemma_5819 (h0 : function.extfun Type finset) : finset.nonempty (function.extfun_app h0 (filter empty)) := sorry --non-trivial
lemma new_lemma_5820 (h0 : monoid (cancel_monoid (cancel_monoid (add_comm_monoid (boolean_algebra Type))))) : monoid.fg (cancel_monoid (cancel_monoid (add_comm_monoid (boolean_algebra Type)))) := sorry --non-trivial
lemma new_lemma_5821 (h0 : topological_space (has_union (semiring unsigned))) : t0_space (has_union (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_5822 (h0 : functor.add_const (function.extfun Type topological_space) Type) : @t1_space.{0} (boolean_algebra.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type topological_space.{0}) Type h0) (boolean_algebra.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_5823 (h0 : functor.add_const (add_group (is_R_or_C unsigned)) (semiring num)) : @is_add_cyclic.{0} (is_R_or_C.{0} unsigned) (@functor.add_const.run.{0 0} (add_group.{0} (is_R_or_C.{0} unsigned)) (semiring.{0} num) h0)  := sorry --non-trivial
lemma new_lemma_5824 (h0 : function.extfun Type (functor.add_const (add_group (semiring unsigned)))) : @is_add_cyclic.{0} (semiring.{0} unsigned) (@functor.add_const.run.{0 0} (add_group.{0} (semiring.{0} unsigned)) empty (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (add_group.{0} (semiring.{0} unsigned))) h0 empty))  := sorry --non-trivial
lemma new_lemma_5825 (h0 : uniform_space (boolean_algebra (comm_group (comm_group (comm_group Type))))) : complete_space (boolean_algebra (comm_group (comm_group (comm_group Type)))) := sorry --non-trivial
lemma new_lemma_5826 (h0 : has_zero (option name) -> has_zero (option name) -> Prop) : is_symm (has_zero (option name)) h0 := sorry --non-trivial
lemma new_lemma_5827 (h0 : functor.add_const (function.extfun Type ring) pos) : @is_principal_ideal_ring.{0} (has_add.{0} pos) (@function.extfun_app.{2 1} Type ring.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type ring.{0}) pos h0) (has_add.{0} pos))  := sorry --non-trivial
lemma new_lemma_5828 (h0 : ring (has_nndist (has_add unsigned))) : rank_condition (has_nndist (has_add unsigned)) := sorry --non-trivial
lemma new_lemma_5829 (h0 : ring (ordered_comm_monoid (has_neg Type))) : rank_condition (ordered_comm_monoid (has_neg Type)) := sorry --non-trivial
lemma new_lemma_5830 (h0 : monoid (ordered_comm_semiring (semiring (semiring (semiring to_additive.value_type))))) : monoid.fg (ordered_comm_semiring (semiring (semiring (semiring to_additive.value_type)))) := sorry --non-trivial
lemma new_lemma_5831 (h0 : not (function.extfun Type uniform_space -> false)) : @complete_space.{0} (metric_space.{0} unsigned) (@function.extfun_app.{2 1} Type uniform_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type uniform_space.{0}) h0) (metric_space.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_5832 (h0 : semiring (with_one (semiring (semiring (has_union linarith.comp))))) : is_noetherian_ring (with_one (semiring (semiring (has_union linarith.comp)))) := sorry --non-trivial
lemma new_lemma_5833 (h0 : ring (has_neg (has_add Type))) : is_domain (has_neg (has_add Type)) := sorry --non-trivial
lemma new_lemma_5834 (h0 : not (topological_space (measurable_space.dynkin_system unsigned) -> false)) : @normal_space.{0} (measurable_space.dynkin_system.{0} unsigned) (@classical.by_contradiction'.{1} (topological_space.{0} (measurable_space.dynkin_system.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_5835 (h1 : complete_lattice (random_gen fun_info)) : is_compactly_generated (random_gen fun_info) := sorry --non-trivial
lemma new_lemma_5836 (h0 : functor.add_const (topological_space (has_dist empty)) num) : @path_connected_space.{0} (has_dist.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (has_dist.{0} empty)) num h0)  := sorry --non-trivial
lemma new_lemma_5837 (h0 : function.extfun Type topological_space) : @locally_compact_space.{0} (add_right_cancel_monoid.{0} (semiring.{0} empty)) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (add_right_cancel_monoid.{0} (semiring.{0} empty)))  := sorry --non-trivial
lemma new_lemma_5838 (h0 : group (distrib_lattice (linear_ordered_comm_ring string_imp))) : is_cyclic (distrib_lattice (linear_ordered_comm_ring string_imp)) := sorry --non-trivial
lemma new_lemma_5839 (h0 : functor.add_const (topological_space (boolean_algebra Type)) name) : @regular_space.{1} (boolean_algebra.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (boolean_algebra.{1} Type)) name h0)  := sorry --non-trivial
lemma new_lemma_5840 (h0 : functor.add_const (group (add_cancel_monoid pos)) pos) : @normalizer_condition.{0} (add_cancel_monoid.{0} pos) (@functor.add_const.run.{0 0} (group.{0} (add_cancel_monoid.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_5841 (h0 : functor.add_const (functor.add_const (filter pos) Type) (has_neg (has_neg pos))) : countable_Inter_filter (functor.add_const.run (functor.add_const.run h0)) := sorry --non-trivial
lemma new_lemma_5842 (h0 : functor.add_const (finset (add_semigroup empty)) (option (option empty))) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_5843 (h1 : ring (random_gen (random_gen (random_gen (random_gen (random_gen (random_gen char))))))) : rank_condition (random_gen (random_gen (random_gen (random_gen (random_gen (random_gen char)))))) := sorry --non-trivial
lemma new_lemma_5844 (h0 : topological_space (ordered_ring (semiring (semiring empty)))) : totally_separated_space (ordered_ring (semiring (semiring empty))) := sorry --non-trivial
lemma new_lemma_5845 (h0 : ring (has_neg (option pos))) : is_principal_ideal_ring (has_neg (option pos)) := sorry --non-trivial
lemma new_lemma_5846 (h0 : functor.add_const (add_monoid (has_star num)) num) : @add_monoid.fg.{0} (has_star.{0} num) (@functor.add_const.run.{0 0} (add_monoid.{0} (has_star.{0} num)) num h0)  := sorry --non-trivial
lemma new_lemma_5847 (h0 : has_mem.mem (normed_group empty) has_emptyc.emptyc) : @complete_space.{0} (normed_group.{0} empty) (@finset.pi.empty.{1 0} Type uniform_space.{0} (normed_group.{0} empty) h0)  := sorry --non-trivial
lemma new_lemma_5848 (h0 : ring (random_gen linarith.comp_source)) : is_domain (random_gen linarith.comp_source) := sorry --non-trivial
lemma new_lemma_5849 (h0 : complete_lattice (has_neg_part (finset pos))) : is_atomistic (has_neg_part (finset pos)) := sorry --non-trivial
lemma new_lemma_5850 (h0 : functor.add_const (function.extfun Type topological_space) Type) : @regular_space.{0} linarith.comp (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type topological_space.{0}) Type h0) linarith.comp)  := sorry --non-trivial
lemma new_lemma_5851 (h0 : topological_space (has_Sup num)) : locally_compact_space (has_Sup num) := sorry --non-trivial
lemma new_lemma_5852 (h0 : semiring (complete_linear_order (semiring (semiring empty)))) : is_noetherian_ring (complete_linear_order (semiring (semiring empty))) := sorry --non-trivial
lemma new_lemma_5853 (h0 : topological_space (pseudo_metric_space (option num))) : totally_separated_space (pseudo_metric_space (option num)) := sorry --non-trivial
lemma new_lemma_5854 (h0 : ring (partial_order congr_arg_kind)) : strong_rank_condition (partial_order congr_arg_kind) := sorry --non-trivial
lemma new_lemma_5855 (h0 : ordered_add_comm_monoid (pseudo_emetric_space empty)) : archimedean (pseudo_emetric_space empty) := sorry --non-trivial
lemma new_lemma_5856 (h0 : function.extfun Type ring) : @rank_condition.{0} to_additive.value_type (@function.extfun_app.{2 1} Type ring.{0} h0 to_additive.value_type)  := sorry --non-trivial
lemma new_lemma_5857 (h1 : group (measurable_space to_additive.value_type)) : normalizer_condition (measurable_space to_additive.value_type) := sorry --non-trivial
lemma new_lemma_5858 (h0 : function.extfun Type add_group) : @is_add_cyclic.{0} (complete_semilattice_Sup.{0} num) (@function.extfun_app.{2 1} Type add_group.{0} h0 (complete_semilattice_Sup.{0} num))  := sorry --non-trivial
lemma new_lemma_5859 (h0 : topological_space (canonically_ordered_comm_semiring (finset Type))) : discrete_topology (canonically_ordered_comm_semiring (finset Type)) := sorry --non-trivial
lemma new_lemma_5860 (h0 : topological_space (complete_distrib_lattice (has_add linarith.comp))) : loc_path_connected_space (complete_distrib_lattice (has_add linarith.comp)) := sorry --non-trivial
lemma new_lemma_5861 (h0 : ring (measurable_space (random_gen linarith.ineq))) : rank_condition (measurable_space (random_gen linarith.ineq)) := sorry --non-trivial
lemma new_lemma_5862 (h0 : topological_space (has_top (semiring (semiring congr_arg_kind)))) : irreducible_space (has_top (semiring (semiring congr_arg_kind))) := sorry --non-trivial
lemma new_lemma_5863 (h0 : functor.add_const (complete_lattice (finset Type)) Type) : @complete_lattice.is_Sup_finite_compact.{1} (finset.{1} Type) (@functor.add_const.run.{1 1} (complete_lattice.{1} (finset.{1} Type)) Type h0)  := sorry --non-trivial
lemma new_lemma_5864 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : finset.nonempty (function.extfun_app (function.extfun_app h0 finset) (has_neg_part unsigned)) := sorry --non-trivial
lemma new_lemma_5865 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : palindrome (function.extfun_app (function.extfun_app h0 list) (has_nndist pos)) := sorry --non-trivial
lemma new_lemma_5866 (h0 : functor.add_const (functor.add_const (topological_space name) congr_arg_kind) congr_arg_kind) : @t1_space.{0} name (@functor.add_const.run.{0 0} (topological_space.{0} name) congr_arg_kind (@functor.add_const.run.{0 0} (functor.add_const.{0 0} (topological_space.{0} name) congr_arg_kind) congr_arg_kind h0))  := sorry --non-trivial
lemma new_lemma_5867 (h0 : functor.add_const (function.extfun Type group) name) : @normalizer_condition.{0} (has_to_string.{0} linarith.comp) (@function.extfun_app.{2 1} Type group.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type group.{0}) name h0) (has_to_string.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_5868 (h0 : function.extfun Type uniform_space) : @complete_space.{0} (add_right_cancel_monoid.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (add_right_cancel_monoid.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_5869 (h0 : topological_space (nondiscrete_normed_field linarith.ineq)) (h1 : add_group (nondiscrete_normed_field linarith.ineq)) : topological_add_group (nondiscrete_normed_field linarith.ineq) := sorry --non-trivial
lemma new_lemma_5870 (h0 : empty -> measure_theory.measure_space num -> Prop) : relator.right_total h0 := sorry --non-trivial
lemma new_lemma_5871 (h0 : not (topological_space (uniform_space (has_compl (has_lt (has_lt string_imp)))) -> false)) : @t0_space.{0} (uniform_space.{0} (has_compl.{0} (has_lt.{0} (has_lt.{0} string_imp)))) (@classical.by_contradiction'.{1} (topological_space.{0} (uniform_space.{0} (has_compl.{0} (has_lt.{0} (has_lt.{0} string_imp))))) h0)  := sorry --non-trivial
lemma new_lemma_5872 (h0 : add_monoid (random_gen (has_norm (semiring num)))) : add_monoid.fg (random_gen (has_norm (semiring num))) := sorry --non-trivial
lemma new_lemma_5873 (h0 : prod (has_inner (option empty) congr_arg_kind) (has_inner (option empty) congr_arg_kind)) : id_rel h0 := sorry --non-trivial
lemma new_lemma_5874 (h0 : group (has_zero (has_neg (ring (ring (has_add (has_neg linarith.comp))))))) : is_cyclic (has_zero (has_neg (ring (ring (has_add (has_neg linarith.comp)))))) := sorry --non-trivial
lemma new_lemma_5875 (h0 : ring (distrib_lattice (has_nnnorm (has_nnnorm linarith.comp_source)))) : is_domain (distrib_lattice (has_nnnorm (has_nnnorm linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_5876 (h0 : functor.add_const (functor.add_const (finset pos) Type) (finset linarith.comp)) : finset.nonempty (functor.add_const.run (functor.add_const.run h0)) := sorry --non-trivial
lemma new_lemma_5877 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_simple_group.{0} (canonically_ordered_comm_semiring.{0} name) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (canonically_ordered_comm_semiring.{0} name))  := sorry --non-trivial
lemma new_lemma_5878 (h0 : functor.add_const (ring (has_nndist name)) Type) : @is_principal_ideal_ring.{0} (has_nndist.{0} name) (@functor.add_const.run.{0 1} (ring.{0} (has_nndist.{0} name)) Type h0)  := sorry --non-trivial
lemma new_lemma_5879 (h0 : monoid (has_add (boolean_algebra Type))) : monoid.fg (has_add (boolean_algebra Type)) := sorry --non-trivial
lemma new_lemma_5880 (h0 : add_group (denumerable string_imp)) : is_add_cyclic (denumerable string_imp) := sorry --non-trivial
lemma new_lemma_5881 (h0 : semiring (semiring (option (semiring empty)))) : is_noetherian_ring (semiring (option (semiring empty))) := sorry --non-trivial
lemma new_lemma_5882 (h0 : topological_space (measurable_space.dynkin_system (with_bot unsigned))) : normal_space (measurable_space.dynkin_system (with_bot unsigned)) := sorry --non-trivial
lemma new_lemma_5883 (h0 : topological_space (semi_normed_ring linarith.ineq)) : totally_disconnected_space (semi_normed_ring linarith.ineq) := sorry --non-trivial
lemma new_lemma_5884 (h0 : topological_space (linear_ordered_comm_group (option ennreal))) : preirreducible_space (linear_ordered_comm_group (option ennreal)) := sorry --non-trivial
lemma new_lemma_5885 (h1 : ring ereal) : is_field ereal := sorry --non-trivial
lemma new_lemma_5886 (h0 : ring (has_bot (has_Inf (has_Inf pos)))) : strong_rank_condition (has_bot (has_Inf (has_Inf pos))) := sorry --non-trivial
lemma new_lemma_5887 (h0 : functor.add_const (cancel_comm_monoid_with_zero (boolean_algebra pos)) pos) : @unique_factorization_monoid.{0} (boolean_algebra.{0} pos) (@functor.add_const.run.{0 0} (cancel_comm_monoid_with_zero.{0} (boolean_algebra.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_5888 (h0 : topological_space (has_nndist Type)) : preconnected_space (has_nndist Type) := sorry --non-trivial
lemma new_lemma_5889 (h0 : functor.add_const (complete_lattice (boolean_algebra.core pos)) (option (mul_zero_class pos))) : @is_compactly_generated.{0} (boolean_algebra.core.{0} pos) (@functor.add_const.run.{0 0} (complete_lattice.{0} (boolean_algebra.core.{0} pos)) (option.{0} (mul_zero_class.{0} pos)) h0)  := sorry --non-trivial
lemma new_lemma_5890 (h0 : group (has_ssubset (random_gen char))) : is_cyclic (has_ssubset (random_gen char)) := sorry --non-trivial
lemma new_lemma_5891 (h0 : functor.add_const (complete_lattice (normed_lattice_add_comm_group real)) pos) : @is_compactly_generated.{0} (normed_lattice_add_comm_group.{0} real) (@functor.add_const.run.{0 0} (complete_lattice.{0} (normed_lattice_add_comm_group.{0} real)) pos h0)  := sorry --non-trivial
lemma new_lemma_5892 (h0 : functor.add_const (topological_space (has_nndist pos)) (ring (has_nndist pos))) : @regular_space.{0} (has_nndist.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (has_nndist.{0} pos)) (ring.{0} (has_nndist.{0} pos)) h0)  := sorry --non-trivial
lemma new_lemma_5893 (h0 : semiring (boolean_algebra.core (boolean_algebra Type))) : is_noetherian_ring (boolean_algebra.core (boolean_algebra Type)) := sorry --non-trivial
lemma new_lemma_5894 (h0 : ring (boolean_algebra (has_Inf Type))) : rank_condition (boolean_algebra (has_Inf Type)) := sorry --non-trivial
lemma new_lemma_5895 (h0 : not (topological_space (measure_theory.measure_space num) -> false)) : @t0_space.{0} (measure_theory.measure_space.{0} num) (@classical.by_contradiction'.{1} (topological_space.{0} (measure_theory.measure_space.{0} num)) h0)  := sorry --non-trivial
lemma new_lemma_5896 (h0 : topological_space (denumerable (has_nnnorm linarith.ineq))) : path_connected_space (denumerable (has_nnnorm linarith.ineq)) := sorry --non-trivial
lemma new_lemma_5897 (h0 : topological_space (normed_comm_ring (comm_group pos))) : totally_separated_space (normed_comm_ring (comm_group pos)) := sorry --non-trivial
lemma new_lemma_5898 (h0 : functor.add_const (topological_space (add_left_cancel_semigroup unsigned)) unsigned) : @totally_disconnected_space.{0} (add_left_cancel_semigroup.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (add_left_cancel_semigroup.{0} unsigned)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_5899 (h0 : functor.add_const (list (normed_linear_ordered_group empty)) (semiring (semiring (semiring (semiring empty))))) : palindrome (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_5900 (h0 : pfun (measure_theory.measure_space (ordered_add_comm_monoid char)) char) (h1 : filter (measure_theory.measure_space (ordered_add_comm_monoid char))) (h2 : filter char) : filter.ptendsto' h0 h1 h2 := sorry --non-trivial
lemma new_lemma_5901 (h0 : not (ring (semi_normed_ring char) -> false)) : @rank_condition.{0} (semi_normed_ring.{0} char) (@classical.by_contradiction'.{1} (ring.{0} (semi_normed_ring.{0} char)) h0)  := sorry --non-trivial
lemma new_lemma_5902 (h0 : functor.add_const (group (semigroup linarith.comp)) linarith.comp) : @is_cyclic.{0} (semigroup.{0} linarith.comp) (@functor.add_const.run.{0 0} (group.{0} (semigroup.{0} linarith.comp)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_5903 (h0 : not (filter (left_cancel_semigroup congr_arg_kind) -> false)) : filter.ne_bot (classical.by_contradiction' h0) := sorry --non-trivial
lemma new_lemma_5904 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @preirreducible_space.{0} (boolean_algebra.core.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (boolean_algebra.core.{0} pos))  := sorry --non-trivial
lemma new_lemma_5905 (h0 : topological_space (has_neg_part (add_comm_monoid ennreal))) : preconnected_space (has_neg_part (add_comm_monoid ennreal)) := sorry --non-trivial
lemma new_lemma_5906 (h0 : ring (comm_ring (linear_ordered_add_comm_group to_additive.value_type))) : strong_rank_condition (comm_ring (linear_ordered_add_comm_group to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_5907 (h0 : topological_space (option (option pos))) : discrete_topology (option (option pos)) := sorry --non-trivial
lemma new_lemma_5908 (h1 : topological_space (has_lt string_imp)) : totally_disconnected_space (has_lt string_imp) := sorry --non-trivial
lemma new_lemma_5909 (h0 : ordered_add_comm_monoid (semigroup empty)) : archimedean (semigroup empty) := sorry --non-trivial
lemma new_lemma_5910 (h0 : topological_space (id (semiring unsigned))) : path_connected_space (id (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_5911 (h0 : not (ring (measurable_space.dynkin_system num) -> false)) : @strong_rank_condition.{0} (measurable_space.dynkin_system.{0} num) (@classical.by_contradiction'.{1} (ring.{0} (measurable_space.dynkin_system.{0} num)) h0)  := sorry --non-trivial
lemma new_lemma_5912 (h0 : functor.add_const (topological_space (has_to_string environment.implicit_infer_kind)) pos) : @preconnected_space.{0} (has_to_string.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (has_to_string.{0} environment.implicit_infer_kind)) pos h0)  := sorry --non-trivial
lemma new_lemma_5913 (h0 : group (has_Inf (ring pos))) : group.fg (has_Inf (ring pos)) := sorry --non-trivial
lemma new_lemma_5914 (h0 : has_lt (has_ssubset (mul_one_class ereal))) : no_max_order (has_ssubset (mul_one_class ereal)) := sorry --non-trivial
lemma new_lemma_5915 (h0 : function.extfun Type group) : @normalizer_condition.{0} (has_union.{0} linarith.comp) (@function.extfun_app.{2 1} Type group.{0} h0 (has_union.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_5916 (h0 : topological_space (dlist (has_inv fun_info))) : totally_disconnected_space (dlist (has_inv fun_info)) := sorry --non-trivial
lemma new_lemma_5917 (h0 : function.extfun Type filter) : countable_Inter_filter (function.extfun_app h0 (has_to_string congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_5918 (h0 : ring (random_gen (has_top to_additive.value_type))) : strong_rank_condition (random_gen (has_top to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_5919 (h0 : function.extfun Type topological_space) : @t0_space.{0} (generalized_boolean_algebra.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (generalized_boolean_algebra.{0} name))  := sorry --non-trivial
lemma new_lemma_5920 (h0 : add_monoid (has_nndist (has_Inf environment.implicit_infer_kind))) : add_monoid.fg (has_nndist (has_Inf environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_5921 (h0 : filter (topological_space (has_norm congr_arg_kind))) : @locally_compact_space.{0} (has_norm.{0} congr_arg_kind) (@filter.Limsup.{0} (topological_space.{0} (has_norm.{0} congr_arg_kind)) (@complete_lattice.to_conditionally_complete_lattice.{0} (topological_space.{0} (has_norm.{0} congr_arg_kind)) (@topological_space.complete_lattice.{0} (has_norm.{0} congr_arg_kind))) h0)  := sorry --non-trivial
lemma new_lemma_5922 (h0 : function.extfun Type topological_space) : @totally_disconnected_space.{0} (has_top.{0} fun_info) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_top.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_5923 (h0 : function.extfun Type topological_space) : @locally_compact_space.{0} (canonically_ordered_comm_semiring.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (canonically_ordered_comm_semiring.{0} name))  := sorry --non-trivial
lemma new_lemma_5924 (h0 : function.extfun nat fin) : @add_monoid.fg.{0} (sub_neg_monoid.{0} pos) (@matrix.vec_empty.{0} (add_monoid.{0} (sub_neg_monoid.{0} pos)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_5925 (h0 : ereal -> ereal -> Prop) : is_total ereal (tc h0) := sorry --non-trivial
lemma new_lemma_5926 (h0 : complete_lattice (mul_zero_class (has_add ennreal))) : complete_lattice.is_Sup_finite_compact (mul_zero_class (has_add ennreal)) := sorry --non-trivial
lemma new_lemma_5927 (h0 : complete_lattice (linear_ordered_semiring (semiring unsigned))) : complete_lattice.is_Sup_finite_compact (linear_ordered_semiring (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_5928 (h1 h2 : multiset (has_norm num)) : multiset.subset h1 h2 := sorry --non-trivial
lemma new_lemma_5929 (h1 : ring (uniform_space char)) : rank_condition (uniform_space char) := sorry --non-trivial
lemma new_lemma_5930 (h0 : ring (with_one (has_top (has_norm (has_norm linarith.comp))))) : rank_condition (with_one (has_top (has_norm (has_norm linarith.comp)))) := sorry --non-trivial
lemma new_lemma_5931 (h0 : function.extfun Type filter) : countable_Inter_filter (function.extfun_app h0 (semigroup name)) := sorry --non-trivial
lemma new_lemma_5932 (h1 : ring (ring enat)) : is_domain (ring enat) := sorry --non-trivial
lemma new_lemma_5933 (h0 : not (function.extfun Type ring -> false)) : @strong_rank_condition.{0} (measurable_space.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type ring.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type ring.{0}) h0) (measurable_space.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_5934 (h1 : topological_space (add_monoid fun_info)) : t0_space (add_monoid fun_info) := sorry --non-trivial
lemma new_lemma_5935 (h0 : functor.add_const (semiring (linear_ordered_comm_monoid_with_zero unsigned)) unsigned) : @is_noetherian_ring.{0} (linear_ordered_comm_monoid_with_zero.{0} unsigned) (@functor.add_const.run.{0 0} (semiring.{0} (linear_ordered_comm_monoid_with_zero.{0} unsigned)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_5936 (h0 : complete_lattice (id (has_norm (has_norm (has_top (has_norm (has_norm congr_arg_kind))))))) : is_compactly_generated (id (has_norm (has_norm (has_top (has_norm (has_norm congr_arg_kind)))))) := sorry --non-trivial
lemma new_lemma_5937 (h0 : functor.add_const (topological_space (complete_distrib_lattice Type)) Type) : @normal_space.{1} (complete_distrib_lattice.{1} Type) (@functor.add_const.run.{1 1} (topological_space.{1} (complete_distrib_lattice.{1} Type)) Type h0)  := sorry --non-trivial
lemma new_lemma_5938 (h0 : has_star num -> has_star num -> Prop) : is_strict_order (has_star num) h0 := sorry --non-trivial
lemma new_lemma_5939 (h0 : ring (has_top (random_gen char))) : rank_condition (has_top (random_gen char)) := sorry --non-trivial
lemma new_lemma_5940 (h0 : not (function.extfun Type group -> false)) : @normalizer_condition.{0} (semiring.{0} empty) (@function.extfun_app.{2 1} Type group.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type group.{0}) h0) (semiring.{0} empty))  := sorry --non-trivial
lemma new_lemma_5941 (h0 : function.extfun Type group) : @normalizer_condition.{0} (as_linear_order.{0} empty) (@function.extfun_app.{2 1} Type group.{0} h0 (as_linear_order.{0} empty))  := sorry --non-trivial
lemma new_lemma_5942 (h0 : topological_space (ordered_comm_monoid (canonically_linear_ordered_monoid pos))) : t1_space (ordered_comm_monoid (canonically_linear_ordered_monoid pos)) := sorry --non-trivial
lemma new_lemma_5943 (h0 : functor.add_const (topological_space (comm_group pos)) environment.implicit_infer_kind) : @preconnected_space.{0} (comm_group.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (comm_group.{0} pos)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_5944 (h0 : semiring (has_zero (semigroup environment.implicit_infer_kind))) : is_noetherian_ring (has_zero (semigroup environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_5945 (h0 : not (group (has_star empty) -> false)) : @group.fg.{0} (has_star.{0} empty) (@classical.by_contradiction'.{1} (group.{0} (has_star.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_5946 (h0 : monoid (canonically_ordered_monoid (finset pos))) : monoid.fg (canonically_ordered_monoid (finset pos)) := sorry --non-trivial
lemma new_lemma_5947 (h0 : add_group (has_neg unsigned)) : is_add_cyclic (has_neg unsigned) := sorry --non-trivial
lemma new_lemma_5948 (h0 : function.extfun Type group) : @group.fg.{0} (is_R_or_C.{0} unsigned) (@function.extfun_app.{2 1} Type group.{0} h0 (is_R_or_C.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_5949 (h0 : functor.add_const (group (comm_group Type)) (finset pos)) : @group.fg.{1} (comm_group.{1} Type) (@functor.add_const.run.{1 0} (group.{1} (comm_group.{1} Type)) (finset.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_5950 (h0 : complete_lattice (div_inv_monoid (has_nnnorm linarith.comp_source))) : complete_lattice.is_Sup_finite_compact (div_inv_monoid (has_nnnorm linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_5951 (h0 : ring (cancel_monoid pos)) : is_domain (cancel_monoid pos) := sorry --non-trivial
lemma new_lemma_5952 (h0 : fin has_zero.zero) : @is_compactly_generated.{0} (has_pos_part.{0} name) (@matrix.vec_empty.{0} (complete_lattice.{0} (has_pos_part.{0} name)) h0)  := sorry --non-trivial
lemma new_lemma_5953 (h0 : list (has_norm (has_nnnorm fun_info))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_5954 (h0 : functor.add_const (topological_space (boolean_algebra pos)) linarith.comp) : @loc_path_connected_space.{0} (boolean_algebra.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (boolean_algebra.{0} pos)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_5955 (h0 : group (has_add environment.implicit_infer_kind)) : group.fg (has_add environment.implicit_infer_kind) := sorry --non-trivial
lemma new_lemma_5956 (h0 : group (canonically_ordered_comm_semiring (has_add pos))) : is_cyclic (canonically_ordered_comm_semiring (has_add pos)) := sorry --non-trivial
lemma new_lemma_5957 (h0 : monoid (linear_ordered_comm_group empty)) : monoid.fg (linear_ordered_comm_group empty) := sorry --non-trivial
lemma new_lemma_5958 (h0 : functor.comp semiring canonically_ordered_comm_semiring pos) : @is_noetherian_ring.{0} (canonically_ordered_comm_semiring.{0} pos) (@functor.comp.run.{0 0 0} semiring.{0} canonically_ordered_comm_semiring.{0} pos h0)  := sorry --non-trivial
lemma new_lemma_5959 (h0 : complete_lattice (filter (option unsigned))) : is_atomistic (filter (option unsigned)) := sorry --non-trivial
lemma new_lemma_5960 (h0 : add_group (finset (option empty))) : is_add_cyclic (finset (option empty)) := sorry --non-trivial
lemma new_lemma_5961 (h0 : ring (linear_ordered_field congr_arg_kind)) : is_domain (linear_ordered_field congr_arg_kind) := sorry --non-trivial
lemma new_lemma_5962 (h0 : topological_space (generalized_boolean_algebra pos)) : t1_space (generalized_boolean_algebra pos) := sorry --non-trivial
lemma new_lemma_5963 (h0 : topological_space (has_Inf (has_Inf linarith.comp))) : preconnected_space (has_Inf (has_Inf linarith.comp)) := sorry --non-trivial
lemma new_lemma_5964 (h0 : topological_space (linear_ordered_semiring (semiring unsigned))) : preirreducible_space (linear_ordered_semiring (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_5965 (h0 : functor.add_const (add_monoid znum) empty) : @add_monoid.fg.{0} znum (@functor.add_const.run.{0 0} (add_monoid.{0} znum) empty h0)  := sorry --non-trivial
lemma new_lemma_5966 (h0 : filter (normed_comm_ring (finset Type))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_5967 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @totally_disconnected_space.{0} (has_Inf.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_Inf.{0} pos))  := sorry --non-trivial
lemma new_lemma_5968 (h0 : topological_space (ring congr_arg_kind)) : path_connected_space (ring congr_arg_kind) := sorry --non-trivial
lemma new_lemma_5969 (h0 : complete_lattice (has_add (has_neg environment.implicit_infer_kind))) : complete_lattice.is_Sup_finite_compact (has_add (has_neg environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_5970 (h0 : monoid (semiring (has_norm (has_top linarith.comp_source)))) : monoid.fg (semiring (has_norm (has_top linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_5971 (h0 : not (uniform_space (normed_group linarith.comp_source) -> false)) : @complete_space.{0} (normed_group.{0} linarith.comp_source) (@classical.by_contradiction'.{1} (uniform_space.{0} (normed_group.{0} linarith.comp_source)) h0)  := sorry --non-trivial
lemma new_lemma_5972 (h1 : complete_lattice (has_top to_additive.value_type)) : is_atomistic (has_top to_additive.value_type) := sorry --non-trivial
lemma new_lemma_5973 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @totally_separated_space.{0} (has_to_string.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_to_string.{0} empty))  := sorry --non-trivial
lemma new_lemma_5974 (h0 : linarith.comp_source -> Prop) : @infi.{0 1} Prop (@conditionally_complete_lattice.to_has_Inf.{0} Prop (@complete_lattice.to_conditionally_complete_lattice.{0} Prop Prop.complete_lattice)) linarith.comp_source h0  := sorry --non-trivial
lemma new_lemma_5975 (h0 : group (has_add (has_neg congr_arg_kind))) : group.fg (has_add (has_neg congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_5976 (h0 : not (cancel_comm_monoid_with_zero (non_assoc_semiring congr_arg_kind) -> false)) : @unique_factorization_monoid.{0} (non_assoc_semiring.{0} congr_arg_kind) (@classical.by_contradiction'.{1} (cancel_comm_monoid_with_zero.{0} (non_assoc_semiring.{0} congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_5977 (h1 : set (add_comm_semigroup (add_comm_semigroup (mul_one_class std_gen)))) : set.finite h1 := sorry --non-trivial
lemma new_lemma_5978 (h0 : uniform_space (has_lt linarith.comp_source)) : complete_space (has_lt linarith.comp_source) := sorry --non-trivial
lemma new_lemma_5979 (h0 : topological_space (with_one (linear_ordered_semiring empty))) : normal_space (with_one (linear_ordered_semiring empty)) := sorry --non-trivial
lemma new_lemma_5980 (h0 : functor.add_const (add_group (has_add linarith.comp)) Type) : @is_add_cyclic.{0} (has_add.{0} linarith.comp) (@functor.add_const.run.{0 1} (add_group.{0} (has_add.{0} linarith.comp)) Type h0)  := sorry --non-trivial
lemma new_lemma_5981 (h0 : functor.add_const (add_monoid (has_neg unsigned)) (finset Type)) : @add_monoid.fg.{0} (has_neg.{0} unsigned) (@functor.add_const.run.{0 1} (add_monoid.{0} (has_neg.{0} unsigned)) (finset.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_5982 (h0 : topological_space (canonically_ordered_comm_semiring (has_add (has_to_string (comm_group name))))) : t0_space (canonically_ordered_comm_semiring (has_add (has_to_string (comm_group name)))) := sorry --non-trivial
lemma new_lemma_5983 (h0 : functor.add_const (list (add_left_cancel_semigroup empty)) (option empty)) : list.nodup (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_5984 (h0 : functor.add_const (filter (add_cancel_monoid Type)) environment.implicit_infer_kind) : countable_Inter_filter (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_5985 (h0 : function.extfun Type topological_space) : @preirreducible_space.{0} (complete_distrib_lattice.{0} ennreal) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (complete_distrib_lattice.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_5986 (h0 : topological_space (free_add_monoid num)) : preirreducible_space (free_add_monoid num) := sorry --non-trivial
lemma new_lemma_5987 (h0 : function.extfun Type ring) : @is_domain.{0} (denumerable.{0} linarith.ineq) (@function.extfun_app.{2 1} Type ring.{0} h0 (denumerable.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_5988 (h1 : topological_space (mul_one_class (mul_one_class linarith.ineq))) : path_connected_space (mul_one_class (mul_one_class linarith.ineq)) := sorry --non-trivial
lemma new_lemma_5989 (h0 : complete_lattice (normed_linear_ordered_group (option (option unsigned)))) : complete_lattice.is_Sup_finite_compact (normed_linear_ordered_group (option (option unsigned))) := sorry --non-trivial
lemma new_lemma_5990 (h1 : complete_lattice (has_nnnorm (random_gen (has_nnnorm string_imp)))) : is_compactly_generated (has_nnnorm (random_gen (has_nnnorm string_imp))) := sorry --non-trivial
lemma new_lemma_5991 (h0 : topological_space (linear_ordered_comm_group (option (option (option (option ennreal)))))) : preconnected_space (linear_ordered_comm_group (option (option (option (option ennreal))))) := sorry --non-trivial
lemma new_lemma_5992 (h4 : has_lt (nondiscrete_normed_field environment.projection_info)) : no_max_order (nondiscrete_normed_field environment.projection_info) := sorry --non-trivial
lemma new_lemma_5993 (h0 : group (has_inv (denumerable fun_info))) : group.fg (has_inv (denumerable fun_info)) := sorry --non-trivial
lemma new_lemma_5994 (h0 : topological_space (has_neg pos)) : totally_separated_space (has_neg pos) := sorry --non-trivial
lemma new_lemma_5995 (h0 : uniform_space (finset (finset pos))) : complete_space (finset (finset pos)) := sorry --non-trivial
lemma new_lemma_5996 (h0 : functor.add_const (function.extfun Type group) pos) : @is_simple_group.{0} (has_add.{0} linarith.comp) (@function.extfun_app.{2 1} Type group.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type group.{0}) pos h0) (has_add.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_5997 (h0 : semiring (ordered_comm_ring (sub_neg_monoid pos))) : is_noetherian_ring (ordered_comm_ring (sub_neg_monoid pos)) := sorry --non-trivial
lemma new_lemma_5998 (h0 : add_group (option (semiring (semiring (semiring unsigned))))) : is_add_cyclic (option (semiring (semiring (semiring unsigned)))) := sorry --non-trivial
lemma new_lemma_5999 (h0 : add_group (has_top to_additive.value_type)) : is_add_cyclic (has_top to_additive.value_type) := sorry --non-trivial
lemma new_lemma_6000 (h0 : add_group (mul_zero_class (semiring empty))) : is_add_cyclic (mul_zero_class (semiring empty)) := sorry --non-trivial
lemma new_lemma_6001 (h0 : ring (random_gen (has_lt (has_zero (has_nnnorm (mul_one_class (random_gen char))))))) : is_domain (random_gen (has_lt (has_zero (has_nnnorm (mul_one_class (random_gen char)))))) := sorry --non-trivial
lemma new_lemma_6002 (h0 : topological_space (ring (has_add (boolean_algebra (has_add pos))))) : preirreducible_space (ring (has_add (boolean_algebra (has_add pos)))) := sorry --non-trivial
lemma new_lemma_6003 (h0 : topological_space (has_nndist (ring name))) : preirreducible_space (has_nndist (ring name)) := sorry --non-trivial
lemma new_lemma_6004 (h0 : functor.add_const (function.extfun Type topological_space) pos) : @t0_space.{0} (complete_distrib_lattice.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) pos h0) (complete_distrib_lattice.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_6005 (h2 : has_lt (nondiscrete_normed_field enat)) : no_max_order (nondiscrete_normed_field enat) := sorry --non-trivial
lemma new_lemma_6006 (h0 : add_group (has_neg (has_add pos))) : is_add_cyclic (has_neg (has_add pos)) := sorry --non-trivial
lemma new_lemma_6007 (h0 : functor.add_const (functor.add_const (topological_space nnreal) num) unsigned) : normal_space nnreal := sorry --non-trivial
lemma new_lemma_6008 (h0 : filter (cancel_monoid (finset (finset ennreal)))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_6009 (h0 : topological_space (complete_distrib_lattice num)) : path_connected_space (complete_distrib_lattice num) := sorry --non-trivial
lemma new_lemma_6010 (h1 : complete_lattice (has_append reducibility_hints)) : complete_lattice.is_Sup_finite_compact (has_append reducibility_hints) := sorry --non-trivial
lemma new_lemma_6011 (h0 : group (has_Inf (has_add pos))) : is_simple_group (has_Inf (has_add pos)) := sorry --non-trivial
lemma new_lemma_6012 (h0 : monoid (ring ennreal)) : monoid.fg (ring ennreal) := sorry --non-trivial
lemma new_lemma_6013 (h0 : functor.add_const (topological_space (left_cancel_semigroup num)) (semiring (semiring empty))) : @locally_compact_space.{0} (left_cancel_semigroup.{0} num) (@functor.add_const.run.{0 0} (topological_space.{0} (left_cancel_semigroup.{0} num)) (semiring.{0} (semiring.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_6014 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : palindrome (function.extfun_app (function.extfun_app h0 list) (complete_distrib_lattice pos)) := sorry --non-trivial
lemma new_lemma_6015 (h1 : topological_space (has_nnnorm to_additive.value_type)) : t0_space (has_nnnorm to_additive.value_type) := sorry --non-trivial
lemma new_lemma_6016 (h0 : functor.add_const (function.extfun (Type 1) ring) linarith.comp) : @strong_rank_condition.{1} (add_cancel_monoid.{1} Type) (@function.extfun_app.{3 2} (Type 1) ring.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) ring.{1}) linarith.comp h0) (add_cancel_monoid.{1} Type))  := sorry --non-trivial
lemma new_lemma_6017 (h0 : topological_space (plift (add_cancel_monoid unsigned))) : t0_space (plift (add_cancel_monoid unsigned)) := sorry --non-trivial
lemma new_lemma_6018 (h0 : topological_space (add_comm_monoid (has_nndist linarith.comp))) : totally_disconnected_space (add_comm_monoid (has_nndist linarith.comp)) := sorry --non-trivial
lemma new_lemma_6019 (h0 : prod (uniform_space num) (uniform_space num)) : id_rel h0 := sorry --non-trivial
lemma new_lemma_6020 (h0 : topological_space (canonically_ordered_monoid (has_Inf (has_Inf pos)))) : path_connected_space (canonically_ordered_monoid (has_Inf (has_Inf pos))) := sorry --non-trivial
lemma new_lemma_6021 (h1 h2 : multiset (nondiscrete_normed_field std_gen)) : multiset.subset h1 h2 := sorry --non-trivial
lemma new_lemma_6022 (h0 : cancel_comm_monoid_with_zero (preorder (semiring num))) : unique_factorization_monoid (preorder (semiring num)) := sorry --non-trivial
lemma new_lemma_6023 (h0 : add_comm_monoid (option unsigned) -> add_comm_monoid (option unsigned) -> Prop) : is_symm (add_comm_monoid (option unsigned)) h0 := sorry --non-trivial
lemma new_lemma_6024 (h0 : topological_space (comm_group (finset (finset environment.implicit_infer_kind)))) : totally_disconnected_space (comm_group (finset (finset environment.implicit_infer_kind))) := sorry --non-trivial
lemma new_lemma_6025 (h0 : function.extfun Type group) : @is_cyclic.{0} (cancel_monoid.{0} ennreal) (@function.extfun_app.{2 1} Type group.{0} h0 (cancel_monoid.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_6026 (h0 : topological_space (has_neg_part (ring name))) : preirreducible_space (has_neg_part (ring name)) := sorry --non-trivial
lemma new_lemma_6027 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @totally_separated_space.{0} (linear_ordered_add_comm_group.{0} linarith.ineq) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (linear_ordered_add_comm_group.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_6028 (h1 : has_mem.mem (semiring to_additive.value_type) has_emptyc.emptyc) : @is_add_cyclic.{0} (semiring.{0} to_additive.value_type) (@finset.pi.empty.{1 0} Type add_group.{0} (semiring.{0} to_additive.value_type) h1)  := sorry --non-trivial
lemma new_lemma_6029 (h0 : uniform_space (measurable_space (semiring fun_info))) : complete_space (measurable_space (semiring fun_info)) := sorry --non-trivial
lemma new_lemma_6030 (h0 : function.extfun (finset (Type -> Type)) (has_mem.mem topological_space)) : @irreducible_space.{0} (complete_semilattice_Sup.{0} fun_info) (@function.extfun_app.{2 1} Type topological_space.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) topological_space.{0} (@function.extfun_app.{2 0} (finset.{1} (Type → Type)) (@has_mem.mem.{1 1} (Type → Type) (finset.{1} (Type → Type)) (@finset.has_mem.{1} (Type → Type)) topological_space.{0}) h0 (@has_emptyc.emptyc.{1} (finset.{1} (Type → Type)) (@finset.has_emptyc.{1} (Type → Type))))) (complete_semilattice_Sup.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_6031 (h0 : has_mem.mem topological_space has_emptyc.emptyc) : @t0_space.{0} (has_emptyc.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type topological_space.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) topological_space.{0} h0) (has_emptyc.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_6032 (h0 : function.extfun Type topological_space) : @irreducible_space.{0} (complete_linear_order.{0} (semiring.{0} (semiring.{0} (semiring.{0} (semiring.{0} empty))))) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (complete_linear_order.{0} (semiring.{0} (semiring.{0} (semiring.{0} (semiring.{0} empty))))))  := sorry --non-trivial
lemma new_lemma_6033 (h0 : has_mem.mem add_monoid has_emptyc.emptyc) : @add_monoid.fg.{0} (has_emptyc.{0} num) (@function.extfun_app.{2 1} Type add_monoid.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) add_monoid.{0} h0) (has_emptyc.{0} num))  := sorry --non-trivial
lemma new_lemma_6034 (h0 : has_mem.mem (with_one to_additive.value_type) has_emptyc.emptyc) : @monoid.fg.{0} (with_one.{0} to_additive.value_type) (@finset.pi.empty.{1 0} Type monoid.{0} (with_one.{0} to_additive.value_type) h0)  := sorry --non-trivial
lemma new_lemma_6035 (h0 : functor.add_const (function.extfun Type ring) name) : @is_domain.{0} (has_neg.{0} name) (@function.extfun_app.{2 1} Type ring.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type ring.{0}) name h0) (has_neg.{0} name))  := sorry --non-trivial
lemma new_lemma_6036 (h0 : functor.add_const (topological_space (has_neg environment.implicit_infer_kind)) name) : @t0_space.{0} (has_neg.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (has_neg.{0} environment.implicit_infer_kind)) name h0)  := sorry --non-trivial
lemma new_lemma_6037 (h1 : set (ereal -> mul_one_class enat)) : set.separates_points h1 := sorry --non-trivial
lemma new_lemma_6038 (h0 h1 : fin has_zero.zero) : @filter.Limsup.{0} Prop (@complete_lattice.to_conditionally_complete_lattice.{0} Prop Prop.complete_lattice) (@matrix.vec_empty.{0} (filter.{0} Prop) (@left_add.{0} (fin (@has_zero.zero.{0} nat nat.has_zero)) (@fin.has_add (@has_zero.zero.{0} nat nat.has_zero)) (@id.{1} (fin (@has_zero.zero.{0} nat nat.has_zero)) h0) h1))  := sorry --non-trivial
lemma new_lemma_6039 (h0 : topological_space (has_nndist (option pos))) : regular_space (has_nndist (option pos)) := sorry --non-trivial
lemma new_lemma_6040 (h0 : functor.add_const (complete_lattice (has_neg_part ennreal)) unsigned) : @is_atomistic.{0} (has_neg_part.{0} ennreal) (@functor.add_const.run.{0 0} (complete_lattice.{0} (has_neg_part.{0} ennreal)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_6041 (h0 : group (semigroup (linear_ordered_add_comm_group_with_top name))) : group.fg (semigroup (linear_ordered_add_comm_group_with_top name)) := sorry --non-trivial
lemma new_lemma_6042 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @locally_compact_space.{0} (@id.{2} Type empty) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (@id.{2} Type empty))  := sorry --non-trivial
lemma new_lemma_6043 (h0 : topological_space (monoid ennreal)) : locally_compact_space (monoid ennreal) := sorry --non-trivial
lemma new_lemma_6044 (h0 : functor.add_const (ring (ordered_comm_ring linarith.comp)) (ring linarith.comp)) : @is_domain.{0} (ordered_comm_ring.{0} linarith.comp) (@functor.add_const.run.{0 0} (ring.{0} (ordered_comm_ring.{0} linarith.comp)) (ring.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_6045 (h0 : topological_space (canonically_ordered_comm_semiring (cancel_monoid (has_neg_part pos)))) : preirreducible_space (canonically_ordered_comm_semiring (cancel_monoid (has_neg_part pos))) := sorry --non-trivial
lemma new_lemma_6046 (h0 : function.extfun Type group) : @normalizer_condition.{0} (normed_group.{0} num) (@function.extfun_app.{2 1} Type group.{0} h0 (normed_group.{0} num))  := sorry --non-trivial
lemma new_lemma_6047 (h0 : list (has_nndist (option empty))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_6048 (h0 : complete_lattice (add_cancel_monoid (has_nndist pos))) : is_compactly_generated (add_cancel_monoid (has_nndist pos)) := sorry --non-trivial
lemma new_lemma_6049 (h0 : add_monoid (has_bot name)) : add_monoid.fg (has_bot name) := sorry --non-trivial
lemma new_lemma_6050 (h0 : functor.add_const (ordered_add_comm_monoid (as_linear_order unsigned)) unsigned) : @archimedean.{0} (as_linear_order.{0} unsigned) (@functor.add_const.run.{0 0} (ordered_add_comm_monoid.{0} (as_linear_order.{0} unsigned)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_6051 (h0 : topological_space (linear_ordered_add_comm_group (random_gen (has_top linarith.comp_source)))) : irreducible_space (linear_ordered_add_comm_group (random_gen (has_top linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_6052 (h0 : uniform_space (add_cancel_monoid (has_add linarith.comp))) : separated_space (add_cancel_monoid (has_add linarith.comp)) := sorry --non-trivial
lemma new_lemma_6053 (h0 : fin has_zero.zero) : @normal_space.{0} (has_add.{0} real) (@matrix.vec_empty.{0} (topological_space.{0} (has_add.{0} real)) (@matrix.vec_empty.{0} (fin (@has_zero.zero.{0} nat nat.has_zero)) h0))  := sorry --non-trivial
lemma new_lemma_6054 (h0 : topological_space (linear_ordered_field (normed_comm_ring (boolean_algebra name)))) : locally_compact_space (linear_ordered_field (normed_comm_ring (boolean_algebra name))) := sorry --non-trivial
lemma new_lemma_6055 (h0 : functor.add_const (topological_space (has_neg pos)) (has_neg Type)) : @discrete_topology.{0} (has_neg.{0} pos) (@functor.add_const.run.{0 1} (topological_space.{0} (has_neg.{0} pos)) (has_neg.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_6056 (h0 : topological_space (has_bot pos)) : t0_space (has_bot pos) := sorry --non-trivial
lemma new_lemma_6057 (h0 : function.extfun (Type 1) topological_space) : @irreducible_space.{1} (plift.{1} unsigned) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} h0 (plift.{1} unsigned))  := sorry --non-trivial
lemma new_lemma_6058 (h0 : uniform_space (has_sub (semiring congr_arg_kind))) : complete_space (has_sub (semiring congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_6059 (h0 : complete_linear_order num -> complete_linear_order num -> Prop) : is_strict_order (complete_linear_order num) h0 := sorry --non-trivial
lemma new_lemma_6060 (h2 : topological_space (add_comm_semigroup linarith.ineq)) (h3 : add_group (add_comm_semigroup linarith.ineq)) : topological_add_group (add_comm_semigroup linarith.ineq) := sorry --non-trivial
lemma new_lemma_6061 (h0 : topological_space (boolean_algebra (ordered_comm_monoid (sub_neg_monoid (has_Inf (has_Inf Type)))))) : preconnected_space (boolean_algebra (ordered_comm_monoid (sub_neg_monoid (has_Inf (has_Inf Type))))) := sorry --non-trivial
lemma new_lemma_6062 (h0 : functor.add_const (topological_space (has_add environment.implicit_infer_kind)) linarith.comp) : @t0_space.{0} (has_add.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (has_add.{0} environment.implicit_infer_kind)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_6063 (h0 : complete_lattice (has_neg (comm_group Type))) : is_compactly_generated (has_neg (comm_group Type)) := sorry --non-trivial
lemma new_lemma_6064 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @separated_space.{0} (ordered_cancel_add_comm_monoid.{0} pos) (@function.extfun_app.{2 1} Type uniform_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 uniform_space.{0}) (ordered_cancel_add_comm_monoid.{0} pos))  := sorry --non-trivial
lemma new_lemma_6065 (h0 : uniform_space (add_comm_monoid (normed_comm_ring (normed_comm_ring unsigned)))) : separated_space (add_comm_monoid (normed_comm_ring (normed_comm_ring unsigned))) := sorry --non-trivial
lemma new_lemma_6066 (h0 : functor.add_const (list (has_add Type)) pos) : list.nodup (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_6067 (h0 : topological_space (generalized_boolean_algebra pos)) : sequential_space (generalized_boolean_algebra pos) := sorry --non-trivial
lemma new_lemma_6068 (h0 : function.extfun Type complete_lattice) : @complete_lattice.is_Sup_finite_compact.{0} (non_assoc_semiring.{0} num) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (non_assoc_semiring.{0} num))  := sorry --non-trivial
lemma new_lemma_6069 (h0 : ring (has_Inf (normed_comm_ring pos))) : rank_condition (has_Inf (normed_comm_ring pos)) := sorry --non-trivial
lemma new_lemma_6070 (h0 : topological_space (complete_distrib_lattice (add_comm_monoid environment.implicit_infer_kind))) : regular_space (complete_distrib_lattice (add_comm_monoid environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_6071 (h0 : not (has_mem.mem (with_bot empty) has_emptyc.emptyc -> false)) : @rank_condition.{0} (with_bot.{0} empty) (@finset.pi.empty.{1 0} Type ring.{0} (with_bot.{0} empty) (@classical.by_contradiction'.{0} (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (with_bot.{0} empty) (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))) h0))  := sorry --non-trivial
lemma new_lemma_6072 (h0 : topological_space (has_Inf (has_add linarith.comp))) : preconnected_space (has_Inf (has_add linarith.comp)) := sorry --non-trivial
lemma new_lemma_6073 (h0 : functor.add_const (topological_space (has_neg Type)) Type) : @locally_compact_space.{1} (has_neg.{1} Type) (@functor.add_const.run.{1 1} (topological_space.{1} (has_neg.{1} Type)) Type h0)  := sorry --non-trivial
lemma new_lemma_6074 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_compactly_generated.{0} (semiring.{0} num) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (semiring.{0} num))  := sorry --non-trivial
lemma new_lemma_6075 (h0 : topological_space (add_cancel_monoid (ring Type))) : irreducible_space (add_cancel_monoid (ring Type)) := sorry --non-trivial
lemma new_lemma_6076 (h0 : group (has_to_string (comm_group name))) : is_cyclic (has_to_string (comm_group name)) := sorry --non-trivial
lemma new_lemma_6077 (h0 : has_coe (add_comm_semigroup std_gen) Prop) (h1 : add_comm_semigroup std_gen) : @coe_b.{1 1} (add_comm_semigroup.{0} std_gen) Prop h0 h1  := sorry --non-trivial
lemma new_lemma_6078 (h0 : finset (add_right_cancel_monoid congr_arg_kind)) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_6079 (h0 : topological_space (canonically_ordered_comm_semiring (finset (finset name)))) : t1_space (canonically_ordered_comm_semiring (finset (finset name))) := sorry --non-trivial
lemma new_lemma_6080 (h0 : set (ereal -> add_comm_semigroup string.iterator_imp)) : set.separates_points h0 := sorry --non-trivial
lemma new_lemma_6081 (h0 : ring (plift (option unsigned))) : is_domain (plift (option unsigned)) := sorry --non-trivial
lemma new_lemma_6082 (h0 : group (has_ssubset (mul_one_class linarith.comp_source))) : is_cyclic (has_ssubset (mul_one_class linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_6083 (h0 : topological_space (mul_zero_class (has_add Type))) : path_connected_space (mul_zero_class (has_add Type)) := sorry --non-trivial
lemma new_lemma_6084 (h0 : topological_space (has_Sup congr_arg_kind)) : locally_compact_space (has_Sup congr_arg_kind) := sorry --non-trivial
lemma new_lemma_6085 (h0 : not (topological_space (metric_space congr_arg_kind) -> false)) : @discrete_topology.{0} (metric_space.{0} congr_arg_kind) (@classical.by_contradiction'.{1} (topological_space.{0} (metric_space.{0} congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_6086 (h0 : topological_space (mul_zero_class (has_add name))) : normal_space (mul_zero_class (has_add name)) := sorry --non-trivial
lemma new_lemma_6087 (h0 : functor.add_const (list (has_neg_part Type)) unsigned) : list.nodup (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_6088 (h0 : add_group (topological_space (random_gen (boolean_algebra.core (random_gen char))))) : is_add_cyclic (topological_space (random_gen (boolean_algebra.core (random_gen char)))) := sorry --non-trivial
lemma new_lemma_6089 (h0 : functor.add_const (function.extfun (Type 1) group) Type) : @is_simple_group.{1} (canonically_ordered_comm_semiring.{1} Type) (@function.extfun_app.{3 2} (Type 1) group.{1} (@functor.add_const.run.{2 1} (function.extfun.{3 2} (Type 1) group.{1}) Type h0) (canonically_ordered_comm_semiring.{1} Type))  := sorry --non-trivial
lemma new_lemma_6090 (h0 : ordered_add_comm_monoid (has_inner (linear_order (add_left_cancel_semigroup empty)) num)) : archimedean (has_inner (linear_order (add_left_cancel_semigroup empty)) num) := sorry --non-trivial
lemma new_lemma_6091 (h0 : topological_space (has_Inf (ring pos))) : preirreducible_space (has_Inf (ring pos)) := sorry --non-trivial
lemma new_lemma_6092 (h0 : functor.add_const (topological_space (complete_distrib_lattice pos)) (has_neg (has_neg linarith.comp))) : @locally_compact_space.{0} (complete_distrib_lattice.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (complete_distrib_lattice.{0} pos)) (has_neg.{0} (has_neg.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_6093 (h0 : topological_space (with_one (has_inv linarith.ineq))) : totally_separated_space (with_one (has_inv linarith.ineq)) := sorry --non-trivial
lemma new_lemma_6094 (h0 : function.extfun Type add_group) : @is_add_cyclic.{0} (omega_complete_partial_order.{0} unsigned) (@function.extfun_app.{2 1} Type add_group.{0} h0 (omega_complete_partial_order.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_6095 (h0 : add_group (ordered_comm_ring pos)) : is_add_cyclic (ordered_comm_ring pos) := sorry --non-trivial
lemma new_lemma_6096 (h0 : functor.add_const (filter (has_neg_part Type)) name) : filter.ne_bot (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_6097 (h0 : topological_space (omega_complete_partial_order unsigned)) : path_connected_space (omega_complete_partial_order unsigned) := sorry --non-trivial
lemma new_lemma_6098 (h0 : topological_space (has_to_string (has_pos_part (ring (finset linarith.comp))))) : preconnected_space (has_to_string (has_pos_part (ring (finset linarith.comp)))) := sorry --non-trivial
lemma new_lemma_6099 (h0 : list (has_zero (finset (has_add Type)))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_6100 (h0 : topological_space (has_zero (ring (uniform_space pos)))) : t1_space (has_zero (ring (uniform_space pos))) := sorry --non-trivial
lemma new_lemma_6101 (h0 : add_monoid (has_add (has_add (has_add pos)))) : add_monoid.fg (has_add (has_add (has_add pos))) := sorry --non-trivial
lemma new_lemma_6102 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @t0_space.{0} (has_top.{0} linarith.ineq) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_top.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_6103 (h0 : has_mem.mem topological_space has_emptyc.emptyc) : @irreducible_space.{0} (has_norm.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type topological_space.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) topological_space.{0} h0) (has_norm.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_6104 (h0 : functor.add_const (topological_space (ordered_comm_ring name)) linarith.comp) : @normal_space.{0} (ordered_comm_ring.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (ordered_comm_ring.{0} name)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_6105 (h0 : group (add_group (semiring empty))) : is_cyclic (add_group (semiring empty)) := sorry --non-trivial
lemma new_lemma_6106 (h0 : fin has_zero.zero) : @has_exists_mul_of_le.{0} (sub_neg_monoid.{0} name) (@matrix.vec_empty.{0} (ordered_comm_monoid.{0} (sub_neg_monoid.{0} name)) h0)  := sorry --non-trivial
lemma new_lemma_6107 (h0 : functor.add_const (function.extfun Type finset) pos) : finset.nonempty (function.extfun_app (functor.add_const.run h0) (semigroup pos)) := sorry --non-trivial
lemma new_lemma_6108 (h0 : functor.add_const (function.extfun Type uniform_space) (finset Type)) : @separated_space.{0} (has_neg.{0} pos) (@function.extfun_app.{2 1} Type uniform_space.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type uniform_space.{0}) (finset.{1} Type) h0) (has_neg.{0} pos))  := sorry --non-trivial
lemma new_lemma_6109 (h0 : complete_lattice (semiring (random_gen (random_gen linarith.comp_source)))) : complete_lattice.is_Sup_finite_compact (semiring (random_gen (random_gen linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_6110 (h0 : not (ring (has_one reducibility_hints) -> false)) : @is_domain.{0} (has_one.{0} reducibility_hints) (@classical.by_contradiction'.{1} (ring.{0} (has_one.{0} reducibility_hints)) h0)  := sorry --non-trivial
lemma new_lemma_6111 (h0 : topological_space (linear_ordered_semiring linarith.comp)) : t0_space (linear_ordered_semiring linarith.comp) := sorry --non-trivial
lemma new_lemma_6112 (h0 : group (group_with_zero ennreal)) : is_simple_group (group_with_zero ennreal) := sorry --non-trivial
lemma new_lemma_6113 (h0 : functor.add_const (list (boolean_algebra name)) (has_neg name)) : palindrome (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_6114 (h2 : topological_space (simple_graph to_additive.value_type)) : t0_space (simple_graph to_additive.value_type) := sorry --non-trivial
lemma new_lemma_6115 (h0 : function.extfun nat fin) : @loc_path_connected_space.{0} (boolean_algebra.{0} pos) (@matrix.vec_empty.{0} (topological_space.{0} (boolean_algebra.{0} pos)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_6116 (h1 : not (topological_space (has_ssubset string_imp) -> false)) : @path_connected_space.{0} (has_ssubset.{0} string_imp) (@classical.by_contradiction'.{1} (topological_space.{0} (has_ssubset.{0} string_imp)) h1)  := sorry --non-trivial
lemma new_lemma_6117 (h0 : finset (has_emptyc (random_gen to_additive.value_type))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_6118 (h0 : monoid (generalized_boolean_algebra Type)) : monoid.fg (generalized_boolean_algebra Type) := sorry --non-trivial
lemma new_lemma_6119 (h0 : fin has_zero.zero) : @has_exists_mul_of_le.{0} (canonically_linear_ordered_monoid.{0} pos) (@matrix.vec_empty.{0} (ordered_comm_monoid.{0} (canonically_linear_ordered_monoid.{0} pos)) h0)  := sorry --non-trivial
lemma new_lemma_6120 (h0 : add_monoid (has_nndist (normed_comm_ring (ring (finset (finset Type)))))) : add_monoid.fg (has_nndist (normed_comm_ring (ring (finset (finset Type))))) := sorry --non-trivial
lemma new_lemma_6121 (h0 : function.extfun Type group) : @normalizer_condition.{0} (add_cancel_monoid.{0} name) (@function.extfun_app.{2 1} Type group.{0} h0 (add_cancel_monoid.{0} name))  := sorry --non-trivial
lemma new_lemma_6122 (h0 : group (complete_distrib_lattice (comm_group (comm_group Type)))) : is_simple_group (complete_distrib_lattice (comm_group (comm_group Type))) := sorry --non-trivial
lemma new_lemma_6123 (h0 : topological_space (has_nndist (add_cancel_monoid (add_cancel_monoid name)))) : normal_space (has_nndist (add_cancel_monoid (add_cancel_monoid name))) := sorry --non-trivial
lemma new_lemma_6124 (h0 : has_mem.mem group has_emptyc.emptyc) : @is_cyclic.{0} (has_norm.{0} num) (@function.extfun_app.{2 1} Type group.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) group.{0} h0) (has_norm.{0} num))  := sorry --non-trivial
lemma new_lemma_6125 (h0 : function.extfun Type uniform_space) : @complete_space.{0} (has_one.{0} empty) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (has_one.{0} empty))  := sorry --non-trivial
lemma new_lemma_6126 (h0 : topological_space (has_neg pos)) : path_connected_space (has_neg pos) := sorry --non-trivial
lemma new_lemma_6127 (h0 : function.extfun Type (functor.add_const (cancel_comm_monoid_with_zero (add_semigroup unsigned)))) : @unique_factorization_monoid.{0} (add_semigroup.{0} unsigned) (@functor.add_const.run.{0 0} (cancel_comm_monoid_with_zero.{0} (add_semigroup.{0} unsigned)) empty (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (cancel_comm_monoid_with_zero.{0} (add_semigroup.{0} unsigned))) h0 empty))  := sorry --non-trivial
lemma new_lemma_6128 (h0 : finset (boolean_algebra.core (finset Type))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_6129 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @loc_path_connected_space.{0} (has_inter.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_inter.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_6130 (h0 : complete_lattice (finset (has_neg pos))) : is_atomistic (finset (has_neg pos)) := sorry --non-trivial
lemma new_lemma_6131 (h0 : function.extfun Type topological_space) : @sequential_space.{0} (has_neg_part.{0} ennreal) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_neg_part.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_6132 (h0 : topological_space (has_neg (semigroup environment.implicit_infer_kind))) : preconnected_space (has_neg (semigroup environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_6133 (h0 : functor.add_const (function.extfun Type group) environment.implicit_infer_kind) : @is_cyclic.{0} (ring.{0} linarith.comp) (@function.extfun_app.{2 1} Type group.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type group.{0}) environment.implicit_infer_kind h0) (ring.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_6134 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @path_connected_space.{0} (has_Inf.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_Inf.{0} pos))  := sorry --non-trivial
lemma new_lemma_6135 (h3 : Prop) (h4 : char -> char -> Prop) : set.partially_well_ordered_on (id (fun (h1 : char), h3)) h4 := sorry --non-trivial
lemma new_lemma_6136 (h0 : fun_info -> fun_info -> Prop) (h1 : filter fun_info) : filter.is_cobounded h0 h1 := sorry --non-trivial
lemma new_lemma_6137 (h0 : functor.add_const (group (cancel_monoid Type)) (has_add Type)) : @group.fg.{1} (cancel_monoid.{1} Type) (@functor.add_const.run.{1 1} (group.{1} (cancel_monoid.{1} Type)) (has_add.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_6138 (h0 : topological_space (canonically_ordered_monoid (has_Inf pos))) : normal_space (canonically_ordered_monoid (has_Inf pos)) := sorry --non-trivial
lemma new_lemma_6139 (h0 : functor.add_const (topological_space (cancel_monoid environment.implicit_infer_kind)) (boolean_algebra name)) : @preconnected_space.{0} (cancel_monoid.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (cancel_monoid.{0} environment.implicit_infer_kind)) (boolean_algebra.{0} name) h0)  := sorry --non-trivial
lemma new_lemma_6140 (h1 : function.extfun Type group) : @normalizer_condition.{0} (@id.{2} Type num) (@function.extfun_app.{2 1} Type group.{0} h1 (@id.{2} Type num))  := sorry --non-trivial
lemma new_lemma_6141 (h0 : complete_lattice (with_one (has_top (has_top fun_info)))) : is_compactly_generated (with_one (has_top (has_top fun_info))) := sorry --non-trivial
lemma new_lemma_6142 (h0 : functor.add_const (ordered_comm_monoid (boolean_algebra.core pos)) Type) : @has_exists_mul_of_le.{0} (boolean_algebra.core.{0} pos) (@functor.add_const.run.{0 1} (ordered_comm_monoid.{0} (boolean_algebra.core.{0} pos)) Type h0)  := sorry --non-trivial
lemma new_lemma_6143 (h0 : complete_lattice (boolean_algebra (comm_group (comm_group (comm_group (comm_group unsigned)))))) : is_atomistic (boolean_algebra (comm_group (comm_group (comm_group (comm_group unsigned))))) := sorry --non-trivial
lemma new_lemma_6144 (h0 : functor.add_const (complete_lattice (has_neg pos)) environment.implicit_infer_kind) : @is_atomistic.{0} (has_neg.{0} pos) (@functor.add_const.run.{0 0} (complete_lattice.{0} (has_neg.{0} pos)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_6145 (h0 : functor.add_const (topological_space (ordered_cancel_add_comm_monoid ennreal)) ennreal) : @loc_path_connected_space.{0} (ordered_cancel_add_comm_monoid.{0} ennreal) (@functor.add_const.run.{0 0} (topological_space.{0} (ordered_cancel_add_comm_monoid.{0} ennreal)) ennreal h0)  := sorry --non-trivial
lemma new_lemma_6146 (h0 : functor.add_const (semiring (boolean_algebra.core name)) Type) : @is_noetherian_ring.{0} (boolean_algebra.core.{0} name) (@functor.add_const.run.{0 1} (semiring.{0} (boolean_algebra.core.{0} name)) Type h0)  := sorry --non-trivial
lemma new_lemma_6147 (h1 : monoid (has_norm (random_gen to_additive.value_type))) : monoid.fg (has_norm (random_gen to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_6148 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @group.fg.{0} (distrib_lattice.{0} fun_info) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (distrib_lattice.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_6149 (h0 : function.extfun Type (functor.add_const (topological_space (has_bot empty)))) : @totally_separated_space.{0} (has_bot.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (has_bot.{0} empty)) empty (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (topological_space.{0} (has_bot.{0} empty))) h0 empty))  := sorry --non-trivial
lemma new_lemma_6150 (h0 : functor.add_const (complete_lattice (has_neg linarith.comp)) Type) : @complete_lattice.is_Sup_finite_compact.{0} (has_neg.{0} linarith.comp) (@functor.add_const.run.{0 1} (complete_lattice.{0} (has_neg.{0} linarith.comp)) Type h0)  := sorry --non-trivial
lemma new_lemma_6151 (h0 : ring (semigroup (has_pos_part (has_pos_part linarith.comp)))) : is_domain (semigroup (has_pos_part (has_pos_part linarith.comp))) := sorry --non-trivial
lemma new_lemma_6152 (h0 : topological_space (non_unital_non_assoc_semiring fun_info)) (h1 : preorder (non_unital_non_assoc_semiring fun_info)) : order_closed_topology (non_unital_non_assoc_semiring fun_info) := sorry --non-trivial
lemma new_lemma_6153 (h0 : topological_space (has_neg_part (has_to_string ennreal))) : irreducible_space (has_neg_part (has_to_string ennreal)) := sorry --non-trivial
lemma new_lemma_6154 (h0 : functor.add_const (topological_space (add_cancel_monoid Type)) linarith.comp) : @irreducible_space.{1} (add_cancel_monoid.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (add_cancel_monoid.{1} Type)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_6155 (h0 : topological_space (div_inv_monoid (fintype linarith.ineq))) : t0_space (div_inv_monoid (fintype linarith.ineq)) := sorry --non-trivial
lemma new_lemma_6156 (h0 : add_monoid (sub_neg_monoid (has_neg name))) : add_monoid.fg (sub_neg_monoid (has_neg name)) := sorry --non-trivial
lemma new_lemma_6157 (h0 : filter (cancel_monoid (add_cancel_monoid unsigned))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_6158 (h0 : uniform_space (has_norm (random_gen (random_gen (random_gen fun_info))))) : complete_space (has_norm (random_gen (random_gen (random_gen fun_info)))) := sorry --non-trivial
lemma new_lemma_6159 (h1 : add_group to_additive.value_type) : is_add_cyclic to_additive.value_type := sorry --non-trivial
lemma new_lemma_6160 (h0 : functor.add_const (topological_space (has_neg name)) environment.implicit_infer_kind) : @path_connected_space.{0} (has_neg.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (has_neg.{0} name)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_6161 (h0 : ring (has_inv (has_inv fun_info))) : is_domain (has_inv (has_inv fun_info)) := sorry --non-trivial
lemma new_lemma_6162 (h0 : function.extfun (finset Type) (has_mem.mem (normed_group num))) : @is_domain.{0} (normed_group.{0} num) (@finset.pi.empty.{1 0} Type ring.{0} (normed_group.{0} num) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (normed_group.{0} num)) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_6163 (h0 : list (ordered_comm_group congr_arg_kind)) : palindrome h0 := sorry --non-trivial
lemma new_lemma_6164 (h0 : not (topological_space (complete_semilattice_Sup num) -> false)) : @totally_separated_space.{0} (complete_semilattice_Sup.{0} num) (@classical.by_contradiction'.{1} (topological_space.{0} (complete_semilattice_Sup.{0} num)) h0)  := sorry --non-trivial
lemma new_lemma_6165 (h0 : cancel_comm_monoid_with_zero (left_cancel_monoid unsigned)) : unique_factorization_monoid (left_cancel_monoid unsigned) := sorry --non-trivial
lemma new_lemma_6166 (h0 : topological_space (boolean_algebra (add_cancel_monoid name))) : loc_path_connected_space (boolean_algebra (add_cancel_monoid name)) := sorry --non-trivial
lemma new_lemma_6167 (h0 : topological_space (generalized_boolean_algebra (finset pos))) : totally_disconnected_space (generalized_boolean_algebra (finset pos)) := sorry --non-trivial
lemma new_lemma_6168 (h0 : function.extfun Type topological_space) : @discrete_topology.{0} (normed_comm_ring.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (normed_comm_ring.{0} empty))  := sorry --non-trivial
lemma new_lemma_6169 (h0 : function.extfun Type ring) : @rank_condition.{0} (boolean_algebra.core.{0} empty) (@function.extfun_app.{2 1} Type ring.{0} h0 (boolean_algebra.core.{0} empty))  := sorry --non-trivial
lemma new_lemma_6170 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : palindrome (function.extfun_app (function.extfun_app h0 list) (has_pos_part pos)) := sorry --non-trivial
lemma new_lemma_6171 (h0 : not (function.extfun Type monoid -> false)) : @monoid.fg.{0} (has_union.{0} linarith.comp) (@function.extfun_app.{2 1} Type monoid.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type monoid.{0}) h0) (has_union.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_6172 (h0 : ring (ordered_comm_group (option empty))) : rank_condition (ordered_comm_group (option empty)) := sorry --non-trivial
lemma new_lemma_6173 (h0 : semiring (linear_ordered_field ennreal)) : is_noetherian_ring (linear_ordered_field ennreal) := sorry --non-trivial
lemma new_lemma_6174 (h0 : topological_space (ring (has_zero (has_zero (has_zero Type))))) : totally_disconnected_space (ring (has_zero (has_zero (has_zero Type)))) := sorry --non-trivial
lemma new_lemma_6175 (h0 : ring (has_star (semiring unsigned))) : strong_rank_condition (has_star (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_6176 (h0 : functor.add_const (topological_space (ring name)) (has_pos_part linarith.comp)) : @irreducible_space.{0} (ring.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (ring.{0} name)) (has_pos_part.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_6177 (h0 : filter (has_add (uniform_space (has_add pos)))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_6178 (h1 : topological_space (nondiscrete_normed_field char)) : t0_space (nondiscrete_normed_field char) := sorry --non-trivial
lemma new_lemma_6179 (h1 : topological_space (normed_group linarith.comp)) : irreducible_space (normed_group linarith.comp) := sorry --non-trivial
lemma new_lemma_6180 (h0 : topological_space (linear_ordered_comm_group_with_zero ereal)) : totally_disconnected_space (linear_ordered_comm_group_with_zero ereal) := sorry --non-trivial
lemma new_lemma_6181 (h0 : function.extfun Type group) : @is_cyclic.{0} (comm_ring.{0} linarith.ineq) (@function.extfun_app.{2 1} Type group.{0} h0 (comm_ring.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_6182 (h0 : group (comm_ring (has_nnnorm fun_info))) : is_cyclic (comm_ring (has_nnnorm fun_info)) := sorry --non-trivial
lemma new_lemma_6183 (h0 : topological_space (ordered_cancel_add_comm_monoid pos)) : locally_compact_space (ordered_cancel_add_comm_monoid pos) := sorry --non-trivial
lemma new_lemma_6184 (h0 : ordered_add_comm_monoid (sub_neg_monoid (has_Inf real))) : archimedean (sub_neg_monoid (has_Inf real)) := sorry --non-trivial
lemma new_lemma_6185 (h0 : topological_space (has_pos_part (has_to_string (ring linarith.comp)))) : irreducible_space (has_pos_part (has_to_string (ring linarith.comp))) := sorry --non-trivial
lemma new_lemma_6186 (h2 : ring (add_left_cancel_monoid to_additive.value_type)) : is_domain (add_left_cancel_monoid to_additive.value_type) := sorry --non-trivial
lemma new_lemma_6187 (h0 : complete_lattice (with_bot string_imp)) : is_compactly_generated (with_bot string_imp) := sorry --non-trivial
lemma new_lemma_6188 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @normal_space.{0} (@id.{2} Type empty) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (@id.{2} Type empty))  := sorry --non-trivial
lemma new_lemma_6189 (h0 : complete_lattice (with_bot fun_info)) : is_compactly_generated (with_bot fun_info) := sorry --non-trivial
lemma new_lemma_6190 (h0 : topological_space (add_comm_monoid environment.implicit_infer_kind)) : irreducible_space (add_comm_monoid environment.implicit_infer_kind) := sorry --non-trivial
lemma new_lemma_6191 (h0 : functor.add_const (ring (finset Type)) (has_Inf name)) : @is_principal_ideal_ring.{1} (finset.{1} Type) (@functor.add_const.run.{1 0} (ring.{1} (finset.{1} Type)) (has_Inf.{0} name) h0)  := sorry --non-trivial
lemma new_lemma_6192 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_cyclic.{0} (normed_group.{0} fun_info) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (normed_group.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_6193 (h0 : complete_lattice (filter unsigned)) : is_atomistic (filter unsigned) := sorry --non-trivial
lemma new_lemma_6194 (h0 : functor.add_const (complete_lattice rat) empty) : @complete_lattice.is_Sup_finite_compact.{0} rat (@functor.add_const.run.{0 0} (complete_lattice.{0} rat) empty h0)  := sorry --non-trivial
lemma new_lemma_6195 (h0 : functor.add_const (function.extfun (Type 1) complete_lattice) environment.implicit_infer_kind) : @complete_lattice.is_Sup_finite_compact.{1} (has_nndist.{1} Type) (@function.extfun_app.{3 2} (Type 1) complete_lattice.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) complete_lattice.{1}) environment.implicit_infer_kind h0) (has_nndist.{1} Type))  := sorry --non-trivial
lemma new_lemma_6196 (h0 : ring (normed_group (has_norm (semiring congr_arg_kind)))) : rank_condition (normed_group (has_norm (semiring congr_arg_kind))) := sorry --non-trivial
lemma new_lemma_6197 (h0 : function.extfun Type ring) : @is_domain.{0} (has_union.{0} empty) (@function.extfun_app.{2 1} Type ring.{0} h0 (has_union.{0} empty))  := sorry --non-trivial
lemma new_lemma_6198 (h0 : add_monoid (canonically_ordered_monoid (normed_lattice_add_comm_group Type))) : add_monoid.fg (canonically_ordered_monoid (normed_lattice_add_comm_group Type)) := sorry --non-trivial
lemma new_lemma_6199 (h0 : functor.add_const (ring (has_nndist name)) environment.implicit_infer_kind) : @rank_condition.{0} (has_nndist.{0} name) (@functor.add_const.run.{0 0} (ring.{0} (has_nndist.{0} name)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_6200 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @unique_factorization_monoid.{0} (add_cancel_monoid.{0} name) (@function.extfun_app.{2 1} Type cancel_comm_monoid_with_zero.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 cancel_comm_monoid_with_zero.{0}) (add_cancel_monoid.{0} name))  := sorry --non-trivial
lemma new_lemma_6201 (h0 : function.extfun Type group) : @group.fg.{0} (measurable_space.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type group.{0} h0 (measurable_space.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_6202 (h0 : function.extfun Type uniform_space) : @complete_space.{0} (measurable_space.{0} fun_info) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (measurable_space.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_6203 (h0 h1 : multiset (normed_field enat)) : multiset.disjoint h0 h1 := sorry --non-trivial
lemma new_lemma_6204 (h0 : functor.add_const (topological_space (ring empty)) num) : @topological_space.separable_space.{0} (ring.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (ring.{0} empty)) num h0)  := sorry --non-trivial
lemma new_lemma_6205 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @monoid.fg.{0} (complete_semilattice_Sup.{0} empty) (@function.extfun_app.{2 1} Type monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 monoid.{0}) (complete_semilattice_Sup.{0} empty))  := sorry --non-trivial
lemma new_lemma_6206 (h0 : function.extfun Type complete_lattice) : @is_compactly_generated.{0} (finset.{0} unsigned) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (finset.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_6207 (h0 : topological_space (normed_lattice_add_comm_group (has_Inf pos))) : loc_path_connected_space (normed_lattice_add_comm_group (has_Inf pos)) := sorry --non-trivial
lemma new_lemma_6208 (h1 : filter (dlist to_additive.value_type)) : filter.ne_bot h1 := sorry --non-trivial
lemma new_lemma_6209 (h0 : uniform_space (canonically_ordered_monoid (has_Inf linarith.comp))) : separated_space (canonically_ordered_monoid (has_Inf linarith.comp)) := sorry --non-trivial
lemma new_lemma_6210 (h0 : function.extfun Type (functor.add_const (add_monoid znum))) : @add_monoid.fg.{0} znum (@functor.add_const.run.{0 0} (add_monoid.{0} znum) num (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (add_monoid.{0} znum)) h0 num))  := sorry --non-trivial
lemma new_lemma_6211 (h0 : ring (right_cancel_semigroup reducibility_hints)) : is_domain (right_cancel_semigroup reducibility_hints) := sorry --non-trivial
lemma new_lemma_6212 (h0 : not (topological_space (complete_linear_order unsigned) -> false)) : @locally_compact_space.{0} (complete_linear_order.{0} unsigned) (@classical.by_contradiction'.{1} (topological_space.{0} (complete_linear_order.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_6213 (h0 : topological_space char) (h1 : preorder char) : order_closed_topology char := sorry --non-trivial
lemma new_lemma_6214 (h0 : complete_lattice (with_zero linarith.ineq)) : is_compactly_generated (with_zero linarith.ineq) := sorry --non-trivial
lemma new_lemma_6215 (h0 : topological_space (semigroup (semiring congr_arg_kind))) : totally_disconnected_space (semigroup (semiring congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_6216 (h0 : ordered_comm_monoid (boolean_algebra (semigroup name))) : has_exists_mul_of_le (boolean_algebra (semigroup name)) := sorry --non-trivial
lemma new_lemma_6217 (h0 : topological_space (ring (has_to_string Type))) : topological_space.separable_space (ring (has_to_string Type)) := sorry --non-trivial
lemma new_lemma_6218 (h0 : finset (add_comm_monoid (comm_group (has_to_string environment.implicit_infer_kind)))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_6219 (h0 : functor.add_const (monoid Type) Type) : @monoid.fg.{1} Type (@functor.add_const.run.{1 1} (monoid.{1} Type) Type h0)  := sorry --non-trivial
lemma new_lemma_6220 (h0 : uniform_space (has_top (metric_space empty))) : complete_space (has_top (metric_space empty)) := sorry --non-trivial
lemma new_lemma_6221 (h0 : topological_space (has_union (has_norm (semiring unsigned)))) : path_connected_space (has_union (has_norm (semiring unsigned))) := sorry --non-trivial
lemma new_lemma_6222 (h0 : complete_lattice (linear_ordered_semiring (semiring empty))) : is_compactly_generated (linear_ordered_semiring (semiring empty)) := sorry --non-trivial
lemma new_lemma_6223 (h0 : topological_space (left_cancel_monoid (semiring congr_arg_kind))) : loc_path_connected_space (left_cancel_monoid (semiring congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_6224 (h0 : topological_space (with_bot (comm_ring (random_gen linarith.comp_source)))) : irreducible_space (with_bot (comm_ring (random_gen linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_6225 (h0 : functor.add_const (group (has_Sup empty)) congr_arg_kind) : @is_cyclic.{0} (has_Sup.{0} empty) (@functor.add_const.run.{0 0} (group.{0} (has_Sup.{0} empty)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_6226 (h0 : group (normed_group (has_inv (has_inv (random_gen linarith.comp_source))))) : normalizer_condition (normed_group (has_inv (has_inv (random_gen linarith.comp_source)))) := sorry --non-trivial
lemma new_lemma_6227 (h0 : complete_lattice (has_inner empty unsigned)) : is_compactly_generated (has_inner empty unsigned) := sorry --non-trivial
lemma new_lemma_6228 (h0 : monoid (has_add (boolean_algebra (finset Type)))) : monoid.fg (has_add (boolean_algebra (finset Type))) := sorry --non-trivial
lemma new_lemma_6229 (h0 : ring (linear_ordered_add_comm_group linarith.comp_source)) : is_domain (linear_ordered_add_comm_group linarith.comp_source) := sorry --non-trivial
lemma new_lemma_6230 (h0 : function.extfun Type topological_space) : @path_connected_space.{0} (has_add.{0} ennreal) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_add.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_6231 (h0 : cancel_comm_monoid_with_zero (filter (option unsigned))) : unique_factorization_monoid (filter (option unsigned)) := sorry --non-trivial
lemma new_lemma_6232 (h0 : functor.add_const (topological_space (boolean_algebra.core environment.implicit_infer_kind)) Type) : @discrete_topology.{0} (boolean_algebra.core.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 1} (topological_space.{0} (boolean_algebra.core.{0} environment.implicit_infer_kind)) Type h0)  := sorry --non-trivial
lemma new_lemma_6233 (h0 : fin has_zero.zero) : matrix.vec_empty (id (id (id (matrix.vec_empty (id h0))))) := sorry --non-trivial
lemma new_lemma_6234 (h0 : ordered_ring (ordered_ring empty) -> ordered_ring (ordered_ring empty) -> ordered_ring (ordered_ring empty)) : is_idempotent (ordered_ring (ordered_ring empty)) h0 := sorry --non-trivial
lemma new_lemma_6235 (h0 : function.extfun Type complete_lattice) : @is_atomistic.{0} (ordered_ring.{0} (semiring.{0} empty)) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (ordered_ring.{0} (semiring.{0} empty)))  := sorry --non-trivial
lemma new_lemma_6236 (h0 : not (fin has_zero.zero -> false)) : matrix.vec_empty (classical.by_contradiction' h0) := sorry --non-trivial
lemma new_lemma_6237 (h0 : group (normed_group (has_top (has_top (has_top (random_gen linarith.ineq)))))) : group.fg (normed_group (has_top (has_top (has_top (random_gen linarith.ineq))))) := sorry --non-trivial
lemma new_lemma_6238 (h0 : function.extfun Type uniform_space) : @complete_space.{0} (has_edist.{0} empty) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (has_edist.{0} empty))  := sorry --non-trivial
lemma new_lemma_6239 (h0 : functor.add_const (finset (has_add name)) pos) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_6240 (h0 : topological_space (fintype char)) : topological_space.separable_space (fintype char) := sorry --non-trivial
lemma new_lemma_6241 (h0 : semiring (partial_order (semiring (semiring unsigned)))) : is_noetherian_ring (partial_order (semiring (semiring unsigned))) := sorry --non-trivial
lemma new_lemma_6242 (h0 : complete_lattice ennreal) : complete_lattice.is_Sup_finite_compact ennreal := sorry --non-trivial
lemma new_lemma_6243 (h1 : topological_space (has_append to_additive.value_type)) : t0_space (has_append to_additive.value_type) := sorry --non-trivial
lemma new_lemma_6244 (h0 : semiring (linear_ordered_ring num)) : is_noetherian_ring (linear_ordered_ring num) := sorry --non-trivial
lemma new_lemma_6245 (h0 : add_group (linear_ordered_cancel_comm_monoid (option (option empty)))) : is_add_cyclic (linear_ordered_cancel_comm_monoid (option (option empty))) := sorry --non-trivial
lemma new_lemma_6246 (h0 : ring (linear_ordered_comm_group_with_zero (mul_one_class string.iterator_imp))) : is_domain (linear_ordered_comm_group_with_zero (mul_one_class string.iterator_imp)) := sorry --non-trivial
lemma new_lemma_6247 (h0 : has_mem.mem (semiring to_additive.value_type) has_emptyc.emptyc) : @is_domain.{0} (semiring.{0} to_additive.value_type) (@finset.pi.empty.{1 0} Type ring.{0} (semiring.{0} to_additive.value_type) h0)  := sorry --non-trivial
lemma new_lemma_6248 (h0 : function.extfun Type topological_space) : @irreducible_space.{0} (bin_tree.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (bin_tree.{0} empty))  := sorry --non-trivial
lemma new_lemma_6249 (h0 : semiring (complete_linear_order (semiring empty))) : is_noetherian_ring (complete_linear_order (semiring empty)) := sorry --non-trivial
lemma new_lemma_6250 (h0 : group (semi_normed_ring (has_nnnorm (has_nnnorm to_additive.value_type)))) : is_cyclic (semi_normed_ring (has_nnnorm (has_nnnorm to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_6251 (h0 : ring (semi_normed_comm_ring (non_unital_non_assoc_semiring linarith.comp_source))) : rank_condition (semi_normed_comm_ring (non_unital_non_assoc_semiring linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_6252 (h0 : not (function.extfun (Type 1) group -> false)) : @group.fg.{1} (plift.{1} num) (@function.extfun_app.{3 2} (Type 1) group.{1} (@classical.by_contradiction'.{3} (function.extfun.{3 2} (Type 1) group.{1}) h0) (plift.{1} num))  := sorry --non-trivial
lemma new_lemma_6253 (h0 : measurable_space (has_nnnorm reducibility_hints)) (h1 : filter (has_nnnorm reducibility_hints)) : filter.is_measurably_generated h1 := sorry --non-trivial
lemma new_lemma_6254 (h0 : topological_space (pseudo_metric_space (option empty))) : preconnected_space (pseudo_metric_space (option empty)) := sorry --non-trivial
lemma new_lemma_6255 (h0 : functor.add_const (cancel_comm_monoid_with_zero (normed_comm_ring linarith.comp)) linarith.comp) : @unique_factorization_monoid.{0} (normed_comm_ring.{0} linarith.comp) (@functor.add_const.run.{0 0} (cancel_comm_monoid_with_zero.{0} (normed_comm_ring.{0} linarith.comp)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_6256 (h2 : complete_lattice (linear_ordered_add_comm_group linarith.comp_source)) : is_atomistic (linear_ordered_add_comm_group linarith.comp_source) := sorry --non-trivial
lemma new_lemma_6257 (h0 : uniform_space (non_assoc_semiring (semiring (semiring empty)))) : complete_space (non_assoc_semiring (semiring (semiring empty))) := sorry --non-trivial
lemma new_lemma_6258 (h0 : list (ring (finset (finset (has_to_string (finset (finset (has_neg environment.implicit_infer_kind)))))))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_6259 (h0 : function.extfun Type topological_space) : @locally_compact_space.{0} (measure_theory.measure_space.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (measure_theory.measure_space.{0} empty))  := sorry --non-trivial
lemma new_lemma_6260 (h0 : functor.add_const (group (ring environment.implicit_infer_kind)) linarith.comp) : @is_cyclic.{0} (ring.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (group.{0} (ring.{0} environment.implicit_infer_kind)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_6261 (h0 : ring (normed_field (has_lt (has_lt char)))) : strong_rank_condition (normed_field (has_lt (has_lt char))) := sorry --non-trivial
lemma new_lemma_6262 (h0 : function.extfun Type topological_space) : @locally_compact_space.{0} (random_gen.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (random_gen.{0} num))  := sorry --non-trivial
lemma new_lemma_6263 (h0 : function.extfun Type topological_space) : @totally_separated_space.{0} (bin_tree.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (bin_tree.{0} empty))  := sorry --non-trivial
lemma new_lemma_6264 (h0 : group (ring linarith.comp)) : group.fg (ring linarith.comp) := sorry --non-trivial
lemma new_lemma_6265 (h0 : functor.add_const (topological_space (cancel_monoid unsigned)) environment.implicit_infer_kind) : @sequential_space.{0} (cancel_monoid.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (cancel_monoid.{0} unsigned)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_6266 (h0 : complete_lattice (has_div (uniform_space string.iterator_imp))) : complete_lattice.is_Sup_finite_compact (has_div (uniform_space string.iterator_imp)) := sorry --non-trivial
lemma new_lemma_6267 (h0 : ordered_add_comm_monoid (id unsigned)) : archimedean (id unsigned) := sorry --non-trivial
lemma new_lemma_6268 (h0 : not (topological_space (has_nnnorm (random_gen linarith.comp_source)) -> false)) : @locally_compact_space.{0} (has_nnnorm.{0} (random_gen.{0} linarith.comp_source)) (@classical.by_contradiction'.{1} (topological_space.{0} (has_nnnorm.{0} (random_gen.{0} linarith.comp_source))) h0)  := sorry --non-trivial
lemma new_lemma_6269 (h0 : set (has_compl linarith.ineq)) : set.finite h0 := sorry --non-trivial
lemma new_lemma_6270 (h0 : cancel_comm_monoid_with_zero (simple_graph (boolean_algebra.core pos))) : unique_factorization_monoid (simple_graph (boolean_algebra.core pos)) := sorry --non-trivial
lemma new_lemma_6271 (h0 : ring (option (mul_zero_class ennreal))) : strong_rank_condition (option (mul_zero_class ennreal)) := sorry --non-trivial
lemma new_lemma_6272 (h0 : functor.add_const (topological_space (semigroup num)) empty) : @t1_space.{0} (semigroup.{0} num) (@functor.add_const.run.{0 0} (topological_space.{0} (semigroup.{0} num)) empty h0)  := sorry --non-trivial
lemma new_lemma_6273 (h0 : fin has_zero.zero) : @preconnected_space.{0} (boolean_algebra.{0} real) (@function.extfun_app.{2 1} Type topological_space.{0} (@matrix.vec_empty.{1} (function.extfun.{2 1} Type topological_space.{0}) h0) (boolean_algebra.{0} real))  := sorry --non-trivial
lemma new_lemma_6274 (h0 : finset (add_cancel_monoid (has_nndist (normed_comm_ring (has_neg_part Type))))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_6275 (h0 : topological_space (random_gen (random_gen linarith.ineq))) : path_connected_space (random_gen (random_gen linarith.ineq)) := sorry --non-trivial
lemma new_lemma_6276 (h0 : filter (with_bot (has_inv to_additive.value_type))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_6277 (h1 : add_group (normed_group fun_info)) : is_add_cyclic (normed_group fun_info) := sorry --non-trivial
lemma new_lemma_6278 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @has_exists_mul_of_le.{0} (has_Inf.{0} (has_Inf.{0} linarith.comp)) (@function.extfun_app.{2 1} Type ordered_comm_monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ordered_comm_monoid.{0}) (has_Inf.{0} (has_Inf.{0} linarith.comp)))  := sorry --non-trivial
lemma new_lemma_6279 (h0 : uniform_space (complete_distrib_lattice pos)) : complete_space (complete_distrib_lattice pos) := sorry --non-trivial
lemma new_lemma_6280 (h0 : topological_space (linear_ordered_cancel_comm_monoid empty)) : totally_separated_space (linear_ordered_cancel_comm_monoid empty) := sorry --non-trivial
lemma new_lemma_6281 (h0 : filter (distrib (has_to_string linarith.comp_source))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_6282 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @monoid.fg.{0} (sub_neg_monoid.{0} real) (@function.extfun_app.{2 1} Type monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 monoid.{0}) (sub_neg_monoid.{0} real))  := sorry --non-trivial
lemma new_lemma_6283 (h0 : ordered_add_comm_monoid (boolean_algebra.core linarith.comp)) : archimedean (boolean_algebra.core linarith.comp) := sorry --non-trivial
lemma new_lemma_6284 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @regular_space.{0} (comm_group.{0} ennreal) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (comm_group.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_6285 (h1 : not (function.extfun (Type -> Type) (function.extfun Type) -> false)) : @is_atomistic.{0} (random_gen.{0} fun_info) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) (@classical.by_contradiction'.{2} (function.extfun.{2 2} (Type → Type) (function.extfun.{2 1} Type)) h1) complete_lattice.{0}) (random_gen.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_6286 (h0 : ring (measurable_space (has_norm empty))) : strong_rank_condition (measurable_space (has_norm empty)) := sorry --non-trivial
lemma new_lemma_6287 (h0 : functor.add_const (topological_space pos) unsigned) : @normal_space.{0} pos (@functor.add_const.run.{0 0} (topological_space.{0} pos) unsigned h0)  := sorry --non-trivial
lemma new_lemma_6288 (h0 : fin has_zero.zero) : @complete_space.{0} (sub_neg_monoid.{0} linarith.comp) (@matrix.vec_empty.{0} (uniform_space.{0} (sub_neg_monoid.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_6289 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_domain.{0} (linear_ordered_semiring.{0} fun_info) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (linear_ordered_semiring.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_6290 (h0 : function.extfun Type group) : @group.fg.{0} (normed_linear_ordered_group.{0} empty) (@function.extfun_app.{2 1} Type group.{0} h0 (normed_linear_ordered_group.{0} empty))  := sorry --non-trivial
lemma new_lemma_6291 (h0 : not (prod (measure_theory.measure_space unsigned) (measure_theory.measure_space unsigned) -> false)) : id_rel (classical.by_contradiction' h0) := sorry --non-trivial
lemma new_lemma_6292 (h0 : topological_space (add_cancel_monoid pos)) : t1_space (add_cancel_monoid pos) := sorry --non-trivial
lemma new_lemma_6293 (h1 : ring (has_norm to_additive.value_type)) : is_domain (has_norm to_additive.value_type) := sorry --non-trivial
lemma new_lemma_6294 (h0 : not (complete_lattice (uniform_space char) -> false)) : complete_lattice.is_Sup_finite_compact (uniform_space char) := sorry --non-trivial
lemma new_lemma_6295 (h0 : function.extfun Type group) : @group.fg.{0} (dlist.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type group.{0} h0 (dlist.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_6296 (h0 : functor.add_const (topological_space (measurable_space.dynkin_system congr_arg_kind)) num) : @normal_space.{0} (measurable_space.dynkin_system.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (measurable_space.dynkin_system.{0} congr_arg_kind)) num h0)  := sorry --non-trivial
lemma new_lemma_6297 (h0 : topological_space (distrib (has_nnnorm char))) : path_connected_space (distrib (has_nnnorm char)) := sorry --non-trivial
lemma new_lemma_6298 (h0 : topological_space (comm_group name)) : totally_disconnected_space (comm_group name) := sorry --non-trivial
lemma new_lemma_6299 (h0 : functor.add_const (add_group (has_neg unsigned)) pos) : @is_add_cyclic.{0} (has_neg.{0} unsigned) (@functor.add_const.run.{0 0} (add_group.{0} (has_neg.{0} unsigned)) pos h0)  := sorry --non-trivial
lemma new_lemma_6300 (h0 : has_mem.mem ring has_emptyc.emptyc) : @strong_rank_condition.{0} congr_arg_kind (@function.extfun_app.{2 1} Type ring.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) ring.{0} h0) congr_arg_kind)  := sorry --non-trivial
lemma new_lemma_6301 (h0 : function.extfun Type complete_lattice) : @complete_lattice.is_Sup_finite_compact.{0} (normed_comm_ring.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (normed_comm_ring.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_6302 (h2 : nat) (h3 : set (zmod h2)) : set.finite h3 := sorry --non-trivial
lemma new_lemma_6303 (h0 : complete_lattice (random_gen (has_norm (has_norm num)))) : complete_lattice.is_Sup_finite_compact (random_gen (has_norm (has_norm num))) := sorry --non-trivial
lemma new_lemma_6304 (h0 : set (num -> mul_one_class fun_info)) : set.separates_points h0 := sorry --non-trivial
lemma new_lemma_6305 (h1 : topological_space (nondiscrete_normed_field (normed_field char))) (h2 : set (nondiscrete_normed_field (normed_field char))) : is_path_connected h2 := sorry --non-trivial
lemma new_lemma_6306 (h0 : function.extfun Type add_group) : @is_add_cyclic.{0} (sub_neg_monoid.{0} real) (@function.extfun_app.{2 1} Type add_group.{0} h0 (sub_neg_monoid.{0} real))  := sorry --non-trivial
lemma new_lemma_6307 (h2 : topological_space (nondiscrete_normed_field char)) (h3 : add_group (nondiscrete_normed_field char)) : topological_add_group (nondiscrete_normed_field char) := sorry --non-trivial
lemma new_lemma_6308 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @add_monoid.fg.{0} (complete_distrib_lattice.{0} empty) (@function.extfun_app.{2 1} Type add_monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 add_monoid.{0}) (complete_distrib_lattice.{0} empty))  := sorry --non-trivial
lemma new_lemma_6309 (h0 : function.extfun Type group) : @group.fg.{0} (complete_semilattice_Sup.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type group.{0} h0 (complete_semilattice_Sup.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_6310 (h0 : not (has_mem.mem (with_bot linarith.comp_source) has_emptyc.emptyc -> false)) : @complete_space.{0} (with_bot.{0} linarith.comp_source) (@finset.pi.empty.{1 0} Type uniform_space.{0} (with_bot.{0} linarith.comp_source) (@classical.by_contradiction'.{0} (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (with_bot.{0} linarith.comp_source) (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))) h0))  := sorry --non-trivial
lemma new_lemma_6311 (h0 : uniform_space (linear_order unsigned)) : separated_space (linear_order unsigned) := sorry --non-trivial
lemma new_lemma_6312 (h0 : topological_space (has_emptyc Type)) : locally_compact_space (has_emptyc Type) := sorry --non-trivial
lemma new_lemma_6313 (h0 : functor.add_const (ordered_comm_monoid (ordered_comm_ring pos)) (has_neg pos)) : @has_exists_mul_of_le.{0} (ordered_comm_ring.{0} pos) (@functor.add_const.run.{0 0} (ordered_comm_monoid.{0} (ordered_comm_ring.{0} pos)) (has_neg.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_6314 (h0 : functor.add_const (topological_space (free_add_monoid congr_arg_kind)) congr_arg_kind) : @discrete_topology.{0} (free_add_monoid.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (free_add_monoid.{0} congr_arg_kind)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_6315 (h0 : function.extfun Type ordered_add_comm_monoid) : @archimedean.{0} (has_sdiff.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type ordered_add_comm_monoid.{0} h0 (has_sdiff.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_6316 (h0 : not (group (has_ssubset fun_info) -> false)) : @group.fg.{0} (has_ssubset.{0} fun_info) (@classical.by_contradiction'.{1} (group.{0} (has_ssubset.{0} fun_info)) h0)  := sorry --non-trivial
lemma new_lemma_6317 (h0 : functor.add_const (filter (has_to_string pos)) unsigned) : countable_Inter_filter (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_6318 (h0 : ring (linear_ordered_comm_group_with_zero std_gen)) : rank_condition (linear_ordered_comm_group_with_zero std_gen) := sorry --non-trivial
lemma new_lemma_6319 (h0 : fin has_zero.zero) : @totally_separated_space.{0} (has_pos_part.{0} linarith.comp) (@matrix.vec_empty.{0} (topological_space.{0} (has_pos_part.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_6320 (h0 : uniform_space (add_comm_monoid (option (option ennreal)))) : separated_space (add_comm_monoid (option (option ennreal))) := sorry --non-trivial
lemma new_lemma_6321 (h0 : filter (boolean_algebra (finset (finset (finset (finset pos)))))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_6322 (h0 : list (normed_group (has_top (has_top linarith.ineq)))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_6323 (h0 : ring (complete_distrib_lattice (option num))) : strong_rank_condition (complete_distrib_lattice (option num)) := sorry --non-trivial
lemma new_lemma_6324 (h0 : topological_space (ordered_comm_ring (has_Inf (ring (ring pos))))) : preirreducible_space (ordered_comm_ring (has_Inf (ring (ring pos)))) := sorry --non-trivial
lemma new_lemma_6325 (h0 : uniform_space (mul_zero_class (finset (has_add (add_comm_monoid name))))) : complete_space (mul_zero_class (finset (has_add (add_comm_monoid name)))) := sorry --non-trivial
lemma new_lemma_6326 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @is_domain.{1} (ordered_comm_ring.{1} Type) (@function.extfun_app.{3 2} (Type 1) ring.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 ring.{1}) (ordered_comm_ring.{1} Type))  := sorry --non-trivial
lemma new_lemma_6327 (h0 : function.extfun Type (functor.comp topological_space semigroup)) : @normal_space.{0} (semigroup.{0} name) (@functor.comp.run.{0 0 0} topological_space.{0} semigroup.{0} name (@function.extfun_app.{2 1} Type (functor.comp.{0 0 0} topological_space.{0} semigroup.{0}) h0 name))  := sorry --non-trivial
lemma new_lemma_6328 (h0 : functor.add_const (ring (cancel_monoid name)) environment.implicit_infer_kind) : @is_domain.{0} (cancel_monoid.{0} name) (@functor.add_const.run.{0 0} (ring.{0} (cancel_monoid.{0} name)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_6329 (h0 : functor.add_const (group (ordered_comm_monoid linarith.comp)) pos) : @group.fg.{0} (ordered_comm_monoid.{0} linarith.comp) (@functor.add_const.run.{0 0} (group.{0} (ordered_comm_monoid.{0} linarith.comp)) pos h0)  := sorry --non-trivial
lemma new_lemma_6330 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_principal_ideal_ring.{0} (simple_graph.{0} linarith.comp) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (simple_graph.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_6331 (h0 : group (complete_semilattice_Sup (has_top (has_top fun_info)))) : normalizer_condition (complete_semilattice_Sup (has_top (has_top fun_info))) := sorry --non-trivial
lemma new_lemma_6332 (h0 : function.extfun Type uniform_space) : @complete_space.{0} (filter.{0} empty) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (filter.{0} empty))  := sorry --non-trivial
lemma new_lemma_6333 (h0 : finset (mul_zero_class (semiring unsigned))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_6334 (h0 : function.extfun (finset Type) (has_mem.mem empty)) : t0_space empty := sorry --non-trivial
lemma new_lemma_6335 (h0 : not (function.extfun Type add_group -> false)) : @is_add_cyclic.{0} (has_one.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type add_group.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type add_group.{0}) h0) (has_one.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_6336 (h0 : filter (div_inv_monoid (option unsigned))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_6337 (h0 : functor.add_const (topological_space (simple_graph linarith.comp)) linarith.comp) : @normal_space.{0} (simple_graph.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (simple_graph.{0} linarith.comp)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_6338 (h0 : add_group (finset (finset (finset linarith.comp)))) : is_add_cyclic (finset (finset (finset linarith.comp))) := sorry --non-trivial
lemma new_lemma_6339 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @path_connected_space.{0} (canonically_ordered_monoid.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (canonically_ordered_monoid.{0} name))  := sorry --non-trivial
lemma new_lemma_6340 (h0 : group (semigroup pos)) : normalizer_condition (semigroup pos) := sorry --non-trivial
lemma new_lemma_6341 (h0 : uniform_space (ordered_comm_monoid (finset Type))) : complete_space (ordered_comm_monoid (finset Type)) := sorry --non-trivial
lemma new_lemma_6342 (h0 : semiring char) : is_noetherian_ring char := sorry --non-trivial
lemma new_lemma_6343 (h1 : complete_lattice (semi_normed_comm_ring (has_ssubset (has_ssubset char)))) : is_compactly_generated (semi_normed_comm_ring (has_ssubset (has_ssubset char))) := sorry --non-trivial
lemma new_lemma_6344 (h0 : topological_space (ring name)) : topological_space.separable_space (ring name) := sorry --non-trivial
lemma new_lemma_6345 (h0 : functor.add_const (topological_space (ring environment.implicit_infer_kind)) pos) : @totally_disconnected_space.{0} (ring.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (ring.{0} environment.implicit_infer_kind)) pos h0)  := sorry --non-trivial
lemma new_lemma_6346 (h0 : functor.add_const (functor.add_const (monoid environment.implicit_infer_kind) pos) pos) : @monoid.fg.{0} environment.implicit_infer_kind (@functor.add_const.run.{0 0} (monoid.{0} environment.implicit_infer_kind) pos (@functor.add_const.run.{0 0} (functor.add_const.{0 0} (monoid.{0} environment.implicit_infer_kind) pos) pos h0))  := sorry --non-trivial
lemma new_lemma_6347 (h0 : add_group (boolean_algebra (has_Inf real))) : is_add_cyclic (boolean_algebra (has_Inf real)) := sorry --non-trivial
lemma new_lemma_6348 (h0 : functor.add_const (uniform_space (ordered_ring unsigned)) congr_arg_kind) : @complete_space.{0} (ordered_ring.{0} unsigned) (@functor.add_const.run.{0 0} (uniform_space.{0} (ordered_ring.{0} unsigned)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_6349 (h0 : functor.add_const (function.extfun Type complete_lattice) (mul_one_class pos)) : @complete_lattice.is_Sup_finite_compact.{0} (semigroup.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type complete_lattice.{0}) (mul_one_class.{0} pos) h0) (semigroup.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_6350 (h0 : topological_space (has_zero (finset linarith.comp))) : topological_space.separable_space (has_zero (finset linarith.comp)) := sorry --non-trivial
lemma new_lemma_6351 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @rank_condition.{0} (dlist.{0} fun_info) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (dlist.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_6352 (h0 : functor.add_const (ring (boolean_algebra pos)) (has_pos_part linarith.comp)) : @is_principal_ideal_ring.{0} (boolean_algebra.{0} pos) (@functor.add_const.run.{0 0} (ring.{0} (boolean_algebra.{0} pos)) (has_pos_part.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_6353 (h0 : filter (mul_zero_class Type)) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_6354 (h0 : monoid (with_one (random_gen num))) : monoid.fg (with_one (random_gen num)) := sorry --non-trivial
lemma new_lemma_6355 (h0 : topological_space (with_zero (has_inv to_additive.value_type))) : path_connected_space (with_zero (has_inv to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_6356 (h0 : ring (generalized_boolean_algebra (has_pos_part (has_neg (has_neg Type))))) : is_domain (generalized_boolean_algebra (has_pos_part (has_neg (has_neg Type)))) := sorry --non-trivial
lemma new_lemma_6357 (h0 : group (distrib_lattice (has_inv (random_gen (has_inv linarith.comp_source))))) : normalizer_condition (distrib_lattice (has_inv (random_gen (has_inv linarith.comp_source)))) := sorry --non-trivial
lemma new_lemma_6358 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : list.nodup (function.extfun_app (function.extfun_app h0 list) (has_to_string num)) := sorry --non-trivial
lemma new_lemma_6359 (h0 : group (simple_graph pos)) : normalizer_condition (simple_graph pos) := sorry --non-trivial
lemma new_lemma_6360 (h0 : list (ring (has_le string.iterator_imp))) (h1 : nat) (h2 : has_lt.lt h1 (list.length h0)) : @rank_condition.{0} (has_le.{0} string.iterator_imp) (@list.nth_le.{0} (ring.{0} (has_le.{0} string.iterator_imp)) h0 h1 h2)  := sorry --non-trivial
lemma new_lemma_6361 (h0 : list (has_Sup (comm_monoid unsigned))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_6362 (h0 : has_mem.mem (with_one linarith.comp) has_emptyc.emptyc) : filter.ne_bot (finset.pi.empty filter (with_one linarith.comp) h0) := sorry --non-trivial
lemma new_lemma_6363 (h0 : group (distrib (has_nnnorm char))) : is_cyclic (distrib (has_nnnorm char)) := sorry --non-trivial
lemma new_lemma_6364 (h0 : not (has_mem.mem (has_top congr_arg_kind) has_emptyc.emptyc -> false)) : @path_connected_space.{0} (has_top.{0} congr_arg_kind) (@finset.pi.empty.{1 0} Type topological_space.{0} (has_top.{0} congr_arg_kind) (@classical.by_contradiction'.{0} (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (has_top.{0} congr_arg_kind) (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))) h0))  := sorry --non-trivial
lemma new_lemma_6365 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @totally_separated_space.{0} (complete_linear_order.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (complete_linear_order.{0} num))  := sorry --non-trivial
lemma new_lemma_6366 (h0 : topological_space (semigroup environment.implicit_infer_kind)) : totally_disconnected_space (semigroup environment.implicit_infer_kind) := sorry --non-trivial
lemma new_lemma_6367 (h0 : measurable_space (parse_result std_gen)) (h1 : measure_theory.measure (parse_result std_gen)) : measure_theory.is_finite_measure h1 := sorry --non-trivial
lemma new_lemma_6368 (h0 : not (complete_lattice name -> false)) : @is_compactly_generated.{0} name (@classical.by_contradiction'.{1} (complete_lattice.{0} name) h0)  := sorry --non-trivial
lemma new_lemma_6369 (h0 : topological_space (canonically_linear_ordered_monoid (has_Inf Type))) : regular_space (canonically_linear_ordered_monoid (has_Inf Type)) := sorry --non-trivial
lemma new_lemma_6370 (h2 : function.extfun Type group) : @normalizer_condition.{0} (with_one.{0} string_imp) (@function.extfun_app.{2 1} Type group.{0} h2 (with_one.{0} string_imp))  := sorry --non-trivial
lemma new_lemma_6371 (h0 : topological_space (has_to_string congr_arg_kind)) : totally_disconnected_space (has_to_string congr_arg_kind) := sorry --non-trivial
lemma new_lemma_6372 (h0 : group (has_add name)) : normalizer_condition (has_add name) := sorry --non-trivial
lemma new_lemma_6373 (h0 : uniform_space (has_inner empty (semiring unsigned))) : separated_space (has_inner empty (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_6374 (h0 : function.extfun Type complete_lattice) : @complete_lattice.is_Sup_finite_compact.{0} (has_one.{0} linarith.comp) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (has_one.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_6375 (h0 : topological_space (monoid (option (option (option (option empty)))))) : topological_space.separable_space (monoid (option (option (option (option empty))))) := sorry --non-trivial
lemma new_lemma_6376 (h0 : complete_lattice (nondiscrete_normed_field reducibility_hints)) : complete_lattice.is_Sup_finite_compact (nondiscrete_normed_field reducibility_hints) := sorry --non-trivial
lemma new_lemma_6377 (h0 : functor.add_const (complete_lattice (add_cancel_monoid name)) Type) : @complete_lattice.is_Sup_finite_compact.{0} (add_cancel_monoid.{0} name) (@functor.add_const.run.{0 1} (complete_lattice.{0} (add_cancel_monoid.{0} name)) Type h0)  := sorry --non-trivial
lemma new_lemma_6378 (h0 : fin has_zero.zero) : @archimedean.{1} (has_Inf.{1} Type) (@matrix.vec_empty.{1} (ordered_add_comm_monoid.{1} (has_Inf.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_6379 (h0 : function.extfun Type ring) : @rank_condition.{0} (has_to_string.{0} unsigned) (@function.extfun_app.{2 1} Type ring.{0} h0 (has_to_string.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_6380 (h0 : topological_space (ordered_comm_ring (ring (has_Inf pos)))) : irreducible_space (ordered_comm_ring (ring (has_Inf pos))) := sorry --non-trivial
lemma new_lemma_6381 (h0 : function.extfun (finset Type) (has_mem.mem (semiring num))) : @totally_separated_space.{0} (semiring.{0} num) (@finset.pi.empty.{1 0} Type topological_space.{0} (semiring.{0} num) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (semiring.{0} num)) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_6382 (h0 : function.extfun Type uniform_space) : @separated_space.{0} (complete_distrib_lattice.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (complete_distrib_lattice.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_6383 (h0 : topological_space (comm_semigroup (has_add (has_Inf pos)))) : t1_space (comm_semigroup (has_add (has_Inf pos))) := sorry --non-trivial
lemma new_lemma_6384 (h0 : ring (ring (has_neg pos))) : is_domain (ring (has_neg pos)) := sorry --non-trivial
lemma new_lemma_6385 (h0 : functor.add_const (ring (mul_zero_class congr_arg_kind)) unsigned) : @strong_rank_condition.{0} (mul_zero_class.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (ring.{0} (mul_zero_class.{0} congr_arg_kind)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_6386 (h1 : add_group (topological_space (has_nnnorm char))) : is_add_cyclic (topological_space (has_nnnorm char)) := sorry --non-trivial
lemma new_lemma_6387 (h0 : topological_space (canonically_ordered_monoid linarith.comp)) : totally_disconnected_space (canonically_ordered_monoid linarith.comp) := sorry --non-trivial
lemma new_lemma_6388 (h0 : has_mem.mem group has_emptyc.emptyc) : @is_cyclic.{0} (normed_group.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type group.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) group.{0} h0) (normed_group.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_6389 (h0 : filter (add_group (has_union (semiring linarith.comp)))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_6390 (h0 : functor.add_const (list (comm_group name)) pos) : palindrome (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_6391 (h0 : cancel_comm_monoid_with_zero (option (semiring empty))) : unique_factorization_monoid (option (semiring empty)) := sorry --non-trivial
lemma new_lemma_6392 (h0 : topological_space (monoid empty)) : irreducible_space (monoid empty) := sorry --non-trivial
lemma new_lemma_6393 (h0 : functor.add_const (topological_space (finset Type)) pos) : @preirreducible_space.{1} (finset.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (finset.{1} Type)) pos h0)  := sorry --non-trivial
lemma new_lemma_6394 (h0 : uniform_space (comm_ring (add_cancel_comm_monoid linarith.comp_source))) : complete_space (comm_ring (add_cancel_comm_monoid linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_6395 (h0 : not (topological_space (non_assoc_semiring congr_arg_kind) -> false)) : @t1_space.{0} (non_assoc_semiring.{0} congr_arg_kind) (@classical.by_contradiction'.{1} (topological_space.{0} (non_assoc_semiring.{0} congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_6396 (h0 : list (boolean_algebra unsigned)) : palindrome h0 := sorry --non-trivial
lemma new_lemma_6397 (h0 : function.extfun Type group) : @is_cyclic.{0} (add_comm_monoid.{0} pos) (@function.extfun_app.{2 1} Type group.{0} h0 (add_comm_monoid.{0} pos))  := sorry --non-trivial
lemma new_lemma_6398 (h0 : functor.add_const (topological_space (has_neg_part name)) linarith.comp) : @t1_space.{0} (has_neg_part.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (has_neg_part.{0} name)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_6399 (h0 : filter (has_inv char)) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_6400 (h0 : ring (semigroup (has_add (has_nndist name)))) : rank_condition (semigroup (has_add (has_nndist name))) := sorry --non-trivial
lemma new_lemma_6401 (h0 : finset (semigroup pos)) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_6402 (h0 : topological_space (linear_ordered_comm_ring empty)) : locally_compact_space (linear_ordered_comm_ring empty) := sorry --non-trivial
lemma new_lemma_6403 (h0 : function.extfun Type topological_space) : @totally_separated_space.{0} (@id.{2} Type unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (@id.{2} Type unsigned))  := sorry --non-trivial
lemma new_lemma_6404 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @unique_factorization_monoid.{0} (linear_ordered_field.{0} pos) (@function.extfun_app.{2 1} Type cancel_comm_monoid_with_zero.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 cancel_comm_monoid_with_zero.{0}) (linear_ordered_field.{0} pos))  := sorry --non-trivial
lemma new_lemma_6405 (h0 : filter (add_comm_monoid (option (option unsigned)))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_6406 (h0 : ring (topological_space (has_ssubset (has_nnnorm char)))) : rank_condition (topological_space (has_ssubset (has_nnnorm char))) := sorry --non-trivial
lemma new_lemma_6407 (h0 : list (mul_zero_class name)) : palindrome h0 := sorry --non-trivial
lemma new_lemma_6408 (h0 : not (topological_space (linear_ordered_semiring congr_arg_kind) -> false)) : @path_connected_space.{0} (linear_ordered_semiring.{0} congr_arg_kind) (@classical.by_contradiction'.{1} (topological_space.{0} (linear_ordered_semiring.{0} congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_6409 (h0 : ordered_comm_monoid (has_pos_part (has_add linarith.comp))) : has_exists_mul_of_le (has_pos_part (has_add linarith.comp)) := sorry --non-trivial
lemma new_lemma_6410 (h0 : not (has_mem.mem (with_bot linarith.ineq) has_emptyc.emptyc -> false)) : @is_atomistic.{0} (with_bot.{0} linarith.ineq) (@finset.pi.empty.{1 0} Type complete_lattice.{0} (with_bot.{0} linarith.ineq) (@classical.by_contradiction'.{0} (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (with_bot.{0} linarith.ineq) (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))) h0))  := sorry --non-trivial
lemma new_lemma_6411 (h0 : functor.add_const (function.extfun Type semiring) linarith.comp) : @is_noetherian_ring.{0} (has_Inf.{0} pos) (@function.extfun_app.{2 1} Type semiring.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type semiring.{0}) linarith.comp h0) (has_Inf.{0} pos))  := sorry --non-trivial
lemma new_lemma_6412 (h0 : topological_space (filter num)) : t1_space (filter num) := sorry --non-trivial
lemma new_lemma_6413 (h0 : uniform_space (as_linear_order unsigned)) : complete_space (as_linear_order unsigned) := sorry --non-trivial
lemma new_lemma_6414 (h0 : has_mem.mem (has_top to_additive.value_type) has_emptyc.emptyc) : @is_add_cyclic.{0} (has_top.{0} to_additive.value_type) (@finset.pi.empty.{1 0} Type add_group.{0} (has_top.{0} to_additive.value_type) h0)  := sorry --non-trivial
lemma new_lemma_6415 (h0 : topological_space (add_comm_semigroup char)) (h2 : preorder (add_comm_semigroup char)) : order_closed_topology (add_comm_semigroup char) := sorry --non-trivial
lemma new_lemma_6416 (h0 : topological_space (has_neg_part (has_add name))) : preirreducible_space (has_neg_part (has_add name)) := sorry --non-trivial
lemma new_lemma_6417 (h0 : group (canonically_linear_ordered_monoid (option unsigned))) : is_cyclic (canonically_linear_ordered_monoid (option unsigned)) := sorry --non-trivial
lemma new_lemma_6418 (h0 : topological_space (ring (has_pos_part (has_Inf (has_add (ring Type)))))) : sequential_space (ring (has_pos_part (has_Inf (has_add (ring Type))))) := sorry --non-trivial
lemma new_lemma_6419 (h0 : functor.add_const (cancel_comm_monoid_with_zero (cancel_monoid num)) (option (option (option congr_arg_kind)))) : @unique_factorization_monoid.{0} (cancel_monoid.{0} num) (@functor.add_const.run.{0 0} (cancel_comm_monoid_with_zero.{0} (cancel_monoid.{0} num)) (option.{0} (option.{0} (option.{0} congr_arg_kind))) h0)  := sorry --non-trivial
lemma new_lemma_6420 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_domain.{0} (ring.{0} empty) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (ring.{0} empty))  := sorry --non-trivial
lemma new_lemma_6421 (h0 : functor.add_const (ring (preorder (option unsigned))) empty) : @rank_condition.{0} (preorder.{0} (option.{0} unsigned)) (@functor.add_const.run.{0 0} (ring.{0} (preorder.{0} (option.{0} unsigned))) empty h0)  := sorry --non-trivial
lemma new_lemma_6422 (h1 : not (group (with_one num) -> false)) : @group.fg.{0} (with_one.{0} num) (@classical.by_contradiction'.{1} (group.{0} (with_one.{0} num)) h1)  := sorry --non-trivial
lemma new_lemma_6423 (h0 : topological_space Type) (h1 : Type) : indistinguishable h1 unsigned := sorry --non-trivial
lemma new_lemma_6424 (h0 : functor.comp complete_lattice has_nndist ennreal) : @is_atomistic.{0} (has_nndist.{0} ennreal) (@functor.comp.run.{0 0 0} complete_lattice.{0} has_nndist.{0} ennreal h0)  := sorry --non-trivial
lemma new_lemma_6425 (h0 : uniform_space (canonically_ordered_comm_semiring (has_to_string (has_pos_part linarith.comp)))) : complete_space (canonically_ordered_comm_semiring (has_to_string (has_pos_part linarith.comp))) := sorry --non-trivial
lemma new_lemma_6426 (h0 : complete_lattice (normed_linear_ordered_group (semiring empty))) : complete_lattice.is_Sup_finite_compact (normed_linear_ordered_group (semiring empty)) := sorry --non-trivial
lemma new_lemma_6427 (h0 : ring (has_edist congr_arg_kind)) : rank_condition (has_edist congr_arg_kind) := sorry --non-trivial
lemma new_lemma_6428 (h0 : functor.add_const (cancel_comm_monoid_with_zero auto.case_option) unsigned) : @unique_factorization_monoid.{0} auto.case_option (@functor.add_const.run.{0 0} (cancel_comm_monoid_with_zero.{0} auto.case_option) unsigned h0)  := sorry --non-trivial
lemma new_lemma_6429 (h0 : functor.add_const (topological_space (linear_ordered_cancel_comm_monoid empty)) empty) : @preirreducible_space.{0} (linear_ordered_cancel_comm_monoid.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (linear_ordered_cancel_comm_monoid.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_6430 (h0 : has_mem.mem topological_space has_emptyc.emptyc) : @totally_separated_space.{0} (measurable_space.{0} fun_info) (@function.extfun_app.{2 1} Type topological_space.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) topological_space.{0} h0) (measurable_space.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_6431 (h0 : topological_space (has_nndist (mul_zero_class name))) : irreducible_space (has_nndist (mul_zero_class name)) := sorry --non-trivial
lemma new_lemma_6432 (h1 : has_coe (nondiscrete_normed_field (nondiscrete_normed_field (linear_ordered_add_comm_group ereal))) Prop) (h2 : nondiscrete_normed_field (nondiscrete_normed_field (linear_ordered_add_comm_group ereal))) : @coe_b.{1 1} (nondiscrete_normed_field.{0} (nondiscrete_normed_field.{0} (linear_ordered_add_comm_group.{0} ereal))) Prop h1 h2  := sorry --non-trivial
lemma new_lemma_6433 (h0 : topological_space (add_comm_monoid (has_neg_part Type))) : totally_separated_space (add_comm_monoid (has_neg_part Type)) := sorry --non-trivial
lemma new_lemma_6434 (h0 : functor.add_const (uniform_space (has_nndist linarith.comp)) (finset Type)) : @separated_space.{0} (has_nndist.{0} linarith.comp) (@functor.add_const.run.{0 1} (uniform_space.{0} (has_nndist.{0} linarith.comp)) (finset.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_6435 (h0 : functor.comp topological_space has_zero ennreal) : @normal_space.{0} (has_zero.{0} ennreal) (@functor.comp.run.{0 0 0} topological_space.{0} has_zero.{0} ennreal h0)  := sorry --non-trivial
lemma new_lemma_6436 (h0 : functor.add_const (topological_space (normed_comm_ring linarith.comp)) (finset linarith.comp)) : @loc_path_connected_space.{0} (normed_comm_ring.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (normed_comm_ring.{0} linarith.comp)) (finset.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_6437 (h0 : function.extfun Type (functor.add_const (ring linarith.comp))) : @rank_condition.{0} linarith.comp (@functor.add_const.run.{0 0} (ring.{0} linarith.comp) environment.implicit_infer_kind (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (ring.{0} linarith.comp)) h0 environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_6438 (h0 : functor.add_const (topological_space (plift congr_arg_kind)) num) : @topological_space.separable_space.{1} (plift.{1} congr_arg_kind) (@functor.add_const.run.{1 0} (topological_space.{1} (plift.{1} congr_arg_kind)) num h0)  := sorry --non-trivial
lemma new_lemma_6439 (h0 : topological_space (has_neg_part Type)) : t1_space (has_neg_part Type) := sorry --non-trivial
lemma new_lemma_6440 (h0 : functor.add_const (function.extfun Type topological_space) environment.implicit_infer_kind) : @t0_space.{0} (boolean_algebra.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) environment.implicit_infer_kind h0) (boolean_algebra.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_6441 (h0 : function.extfun Type topological_space) : @normal_space.{0} (metric_space.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (metric_space.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_6442 (h0 : topological_space (has_div (has_compl fun_info))) : t0_space (has_div (has_compl fun_info)) := sorry --non-trivial
lemma new_lemma_6443 (h0 : function.extfun Type (functor.add_const (complete_lattice (has_to_string pos)))) : @is_compactly_generated.{0} (has_to_string.{0} pos) (@functor.add_const.run.{0 0} (complete_lattice.{0} (has_to_string.{0} pos)) pos (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (complete_lattice.{0} (has_to_string.{0} pos))) h0 pos))  := sorry --non-trivial
lemma new_lemma_6444 (h1 : topological_space (fintype string_imp)) : totally_disconnected_space (fintype string_imp) := sorry --non-trivial
lemma new_lemma_6445 (h0 : ring (has_neg (has_add (has_add name)))) : is_principal_ideal_ring (has_neg (has_add (has_add name))) := sorry --non-trivial
lemma new_lemma_6446 (h0 : functor.add_const (ring (generalized_boolean_algebra pos)) (has_neg name)) : @strong_rank_condition.{0} (generalized_boolean_algebra.{0} pos) (@functor.add_const.run.{0 0} (ring.{0} (generalized_boolean_algebra.{0} pos)) (has_neg.{0} name) h0)  := sorry --non-trivial
lemma new_lemma_6447 (h0 : functor.add_const (filter (has_add Type)) name) : filter.ne_bot (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_6448 (h2 : prod char char) : set.diagonal char h2 := sorry --non-trivial
lemma new_lemma_6449 (h0 : function.extfun nat fin) : @preconnected_space.{0} (boolean_algebra.{0} pos) (@matrix.vec_empty.{0} (topological_space.{0} (boolean_algebra.{0} pos)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_6450 (h0 : function.extfun Type ring) : @is_domain.{0} (has_inv.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type ring.{0} h0 (has_inv.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_6451 (h0 : functor.add_const (list (preorder empty)) (semiring empty)) : list.nodup (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_6452 (h0 : functor.add_const (topological_space (option num)) num) : @t1_space.{0} (option.{0} num) (@functor.add_const.run.{0 0} (topological_space.{0} (option.{0} num)) num h0)  := sorry --non-trivial
lemma new_lemma_6453 (h0 : ordered_add_comm_monoid (generalized_boolean_algebra (has_neg pos))) : archimedean (generalized_boolean_algebra (has_neg pos)) := sorry --non-trivial
lemma new_lemma_6454 (h0 : option (topological_space (as_linear_order (option empty)))) (h1 : topological_space (as_linear_order (option empty))) : discrete_topology (as_linear_order (option empty)) := sorry --non-trivial
lemma new_lemma_6455 (h0 : functor.add_const (topological_space (has_neg Type)) Type) : @totally_disconnected_space.{1} (has_neg.{1} Type) (@functor.add_const.run.{1 1} (topological_space.{1} (has_neg.{1} Type)) Type h0)  := sorry --non-trivial
lemma new_lemma_6456 (h0 : function.extfun nat fin) : @has_exists_mul_of_le.{0} (has_Inf.{0} linarith.comp) (@function.extfun_app.{2 1} Type ordered_comm_monoid.{0} (@matrix.vec_empty.{1} (function.extfun.{2 1} Type ordered_comm_monoid.{0}) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero))) (has_Inf.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_6457 (h0 : functor.add_const (topological_space (metric_space congr_arg_kind)) unsigned) : @t0_space.{0} (metric_space.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (metric_space.{0} congr_arg_kind)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_6458 (h0 : group (boolean_algebra linarith.comp)) : normalizer_condition (boolean_algebra linarith.comp) := sorry --non-trivial
lemma new_lemma_6459 (h0 : topological_space (has_edist (option (option unsigned)))) : totally_separated_space (has_edist (option (option unsigned))) := sorry --non-trivial
lemma new_lemma_6460 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @add_monoid.fg.{0} (linear_ordered_field.{0} empty) (@function.extfun_app.{2 1} Type add_monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 add_monoid.{0}) (linear_ordered_field.{0} empty))  := sorry --non-trivial
lemma new_lemma_6461 (h0 : functor.add_const (function.extfun Type topological_space) (has_neg environment.implicit_infer_kind)) : @discrete_topology.{0} (boolean_algebra.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) (has_neg.{0} environment.implicit_infer_kind) h0) (boolean_algebra.{0} pos))  := sorry --non-trivial
lemma new_lemma_6462 (h0 : ring (boolean_algebra (finset linarith.comp))) : rank_condition (boolean_algebra (finset linarith.comp)) := sorry --non-trivial
lemma new_lemma_6463 (h0 : functor.add_const (group (has_add pos)) (has_to_string (has_to_string (ring (has_to_string Type))))) : @is_simple_group.{0} (has_add.{0} pos) (@functor.add_const.run.{0 1} (group.{0} (has_add.{0} pos)) (has_to_string.{1} (has_to_string.{1} (ring.{1} (has_to_string.{1} Type)))) h0)  := sorry --non-trivial
lemma new_lemma_6464 (h0 : not (topological_space (fintype (has_ssubset to_additive.value_type)) -> false)) : @path_connected_space.{0} (fintype.{0} (has_ssubset.{0} to_additive.value_type)) (@classical.by_contradiction'.{1} (topological_space.{0} (fintype.{0} (has_ssubset.{0} to_additive.value_type))) h0)  := sorry --non-trivial
lemma new_lemma_6465 (h0 : topological_space (has_neg (has_neg linarith.comp))) : loc_path_connected_space (has_neg (has_neg linarith.comp)) := sorry --non-trivial
lemma new_lemma_6466 (h0 : functor.add_const (add_group (linear_ordered_cancel_comm_monoid unsigned)) empty) : @is_add_cyclic.{0} (linear_ordered_cancel_comm_monoid.{0} unsigned) (@functor.add_const.run.{0 0} (add_group.{0} (linear_ordered_cancel_comm_monoid.{0} unsigned)) empty h0)  := sorry --non-trivial
lemma new_lemma_6467 (h0 : functor.add_const (group (has_to_string Type)) name) : @is_simple_group.{1} (has_to_string.{1} Type) (@functor.add_const.run.{1 0} (group.{1} (has_to_string.{1} Type)) name h0)  := sorry --non-trivial
lemma new_lemma_6468 (h0 : functor.add_const (uniform_space (has_norm num)) (semiring empty)) : @complete_space.{0} (has_norm.{0} num) (@functor.add_const.run.{0 0} (uniform_space.{0} (has_norm.{0} num)) (semiring.{0} empty) h0)  := sorry --non-trivial
lemma new_lemma_6469 (h0 : functor.add_const (group (generalized_boolean_algebra Type)) Type) : @normalizer_condition.{1} (generalized_boolean_algebra.{1} Type) (@functor.add_const.run.{1 1} (group.{1} (generalized_boolean_algebra.{1} Type)) Type h0)  := sorry --non-trivial
lemma new_lemma_6470 (h0 : ring (linear_ordered_comm_group (option ennreal))) : strong_rank_condition (linear_ordered_comm_group (option ennreal)) := sorry --non-trivial
lemma new_lemma_6471 (h0 : function.extfun Type group) : @normalizer_condition.{0} (with_bot.{0} empty) (@function.extfun_app.{2 1} Type group.{0} h0 (with_bot.{0} empty))  := sorry --non-trivial
lemma new_lemma_6472 (h0 : functor.comp topological_space complete_distrib_lattice environment.implicit_infer_kind) : @irreducible_space.{0} (complete_distrib_lattice.{0} environment.implicit_infer_kind) (@functor.comp.run.{0 0 0} topological_space.{0} complete_distrib_lattice.{0} environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_6473 (h0 : topological_space (preorder (semiring empty))) : discrete_topology (preorder (semiring empty)) := sorry --non-trivial
lemma new_lemma_6474 (h0 : function.extfun (Type 1) ring) : @is_principal_ideal_ring.{1} (finset.{1} Type) (@function.extfun_app.{3 2} (Type 1) ring.{1} h0 (finset.{1} Type))  := sorry --non-trivial
lemma new_lemma_6475 (h0 : ring (has_neg (has_Inf (finset (ring (has_neg linarith.comp)))))) : rank_condition (has_neg (has_Inf (finset (ring (has_neg linarith.comp))))) := sorry --non-trivial
lemma new_lemma_6476 (h0 : function.extfun (finset (Type -> Type)) (has_mem.mem complete_lattice)) : @is_atomistic.{0} (complete_semilattice_Sup.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) complete_lattice.{0} (@function.extfun_app.{2 0} (finset.{1} (Type → Type)) (@has_mem.mem.{1 1} (Type → Type) (finset.{1} (Type → Type)) (@finset.has_mem.{1} (Type → Type)) complete_lattice.{0}) h0 (@has_emptyc.emptyc.{1} (finset.{1} (Type → Type)) (@finset.has_emptyc.{1} (Type → Type))))) (complete_semilattice_Sup.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_6477 (h0 : function.extfun Type topological_space) : @totally_separated_space.{0} (is_R_or_C.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (is_R_or_C.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_6478 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @group.fg.{0} (canonically_ordered_comm_semiring.{0} linarith.comp) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (canonically_ordered_comm_semiring.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_6479 (h0 : topological_space (semi_normed_ring (has_nnnorm linarith.comp_source))) : t0_space (semi_normed_ring (has_nnnorm linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_6480 (h0 : filter (has_union (ordered_cancel_add_comm_monoid (order_dual empty)))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_6481 (h0 : topological_space (cancel_monoid (cancel_monoid (ring pos)))) : t1_space (cancel_monoid (cancel_monoid (ring pos))) := sorry --non-trivial
lemma new_lemma_6482 (h1 : linarith.comp_source -> linarith.comp_source -> Prop) (h2 : linarith.comp_source) (h3 : rbtree linarith.comp_source h1) : rbtree.mem h2 h3 := sorry --non-trivial
lemma new_lemma_6483 (h0 : not (add_group (with_one fun_info) -> false)) : @is_add_cyclic.{0} (with_one.{0} fun_info) (@classical.by_contradiction'.{1} (add_group.{0} (with_one.{0} fun_info)) h0)  := sorry --non-trivial
lemma new_lemma_6484 (h0 : functor.add_const (ring (has_pos_part linarith.comp)) pos) : @is_principal_ideal_ring.{0} (has_pos_part.{0} linarith.comp) (@functor.add_const.run.{0 0} (ring.{0} (has_pos_part.{0} linarith.comp)) pos h0)  := sorry --non-trivial
lemma new_lemma_6485 (h0 : not (topological_space (left_cancel_monoid congr_arg_kind) -> false)) : @t1_space.{0} (left_cancel_monoid.{0} congr_arg_kind) (@classical.by_contradiction'.{1} (topological_space.{0} (left_cancel_monoid.{0} congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_6486 (h0 : function.extfun Type semiring) : @is_noetherian_ring.{0} (ordered_comm_monoid.{0} name) (@function.extfun_app.{2 1} Type semiring.{0} h0 (ordered_comm_monoid.{0} name))  := sorry --non-trivial
lemma new_lemma_6487 (h0 : functor.add_const (list (option num)) empty) : list.nodup (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_6488 (h0 : not (function.extfun Type group -> false)) : @normalizer_condition.{0} (has_norm.{0} fun_info) (@function.extfun_app.{2 1} Type group.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type group.{0}) h0) (has_norm.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_6489 (h0 : set (semi_normed_comm_ring enat)) : set.finite h0 := sorry --non-trivial
lemma new_lemma_6490 (h0 : finset (normed_comm_ring Type)) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_6491 (h0 : functor.add_const (list (boolean_algebra.core name)) pos) : palindrome (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_6492 (h0 : filter (has_neg (finset (finset (finset (finset (finset linarith.comp))))))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_6493 (h0 : functor.add_const (function.extfun (Type 1) group) Type) : @is_cyclic.{1} Type (@function.extfun_app.{3 2} (Type 1) group.{1} (@functor.add_const.run.{2 1} (function.extfun.{3 2} (Type 1) group.{1}) Type h0) Type)  := sorry --non-trivial
lemma new_lemma_6494 (h1 : not (complete_lattice (random_gen linarith.comp_source) -> false)) : @complete_lattice.is_Sup_finite_compact.{0} (random_gen.{0} linarith.comp_source) (@classical.by_contradiction'.{1} (complete_lattice.{0} (random_gen.{0} linarith.comp_source)) h1)  := sorry --non-trivial
lemma new_lemma_6495 (h0 : topological_space (cancel_monoid (option unsigned))) : preconnected_space (cancel_monoid (option unsigned)) := sorry --non-trivial
lemma new_lemma_6496 (h0 : function.extfun (Type 1) topological_space) : @topological_space.separable_space.{1} (has_add.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} h0 (has_add.{1} Type))  := sorry --non-trivial
lemma new_lemma_6497 (h0 : set (has_compl string.iterator_imp)) : set.finite h0 := sorry --non-trivial
lemma new_lemma_6498 (h0 : functor.add_const (function.extfun Type topological_space) (has_neg (has_add (has_neg pos)))) : @locally_compact_space.{0} (finset.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) (has_neg.{0} (has_add.{0} (has_neg.{0} pos))) h0) (finset.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_6499 (h0 : monoid (add_comm_monoid (finset Type))) : monoid.fg (add_comm_monoid (finset Type)) := sorry --non-trivial
lemma new_lemma_6500 (h0 : function.extfun Type ordered_add_comm_monoid) : @archimedean.{0} (ordered_cancel_add_comm_monoid.{0} unsigned) (@function.extfun_app.{2 1} Type ordered_add_comm_monoid.{0} h0 (ordered_cancel_add_comm_monoid.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_6501 (h0 : ring (has_nnnorm enat) -> Prop) (h1 : Exists (fun (x : ring (has_nnnorm enat)), h0 x)) : @strong_rank_condition.{0} (has_nnnorm.{0} enat) (@classical.some.{1} (ring.{0} (has_nnnorm.{0} enat)) h0 h1)  := sorry --non-trivial
lemma new_lemma_6502 (h0 : topological_space (has_neg_part (option ennreal))) : preirreducible_space (has_neg_part (option ennreal)) := sorry --non-trivial
lemma new_lemma_6503 (h0 : uniform_space (add_cancel_monoid (boolean_algebra linarith.comp))) : separated_space (add_cancel_monoid (boolean_algebra linarith.comp)) := sorry --non-trivial
lemma new_lemma_6504 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @irreducible_space.{0} (add_cancel_monoid.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (add_cancel_monoid.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_6505 (h0 : fin has_zero.zero) : @is_noetherian_ring.{0} (has_bot.{0} name) (@matrix.vec_empty.{0} (semiring.{0} (has_bot.{0} name)) h0)  := sorry --non-trivial
lemma new_lemma_6506 (h0 : functor.add_const (topological_space (simple_graph pos)) pos) : @sequential_space.{0} (simple_graph.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (simple_graph.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_6507 (h0 : not (ring (plift unsigned) -> false)) : @rank_condition.{1} (plift.{1} unsigned) (@classical.by_contradiction'.{2} (ring.{1} (plift.{1} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_6508 (h0 : function.extfun Type list) : list.nodup (function.extfun_app h0 (add_cancel_monoid name)) := sorry --non-trivial
lemma new_lemma_6509 (h0 : topological_space (random_gen (denumerable fun_info))) : t0_space (random_gen (denumerable fun_info)) := sorry --non-trivial
lemma new_lemma_6510 (h0 : ordered_comm_monoid (semigroup environment.implicit_infer_kind)) : has_exists_mul_of_le (semigroup environment.implicit_infer_kind) := sorry --non-trivial
lemma new_lemma_6511 (h0 : topological_space (semiring (random_gen (random_gen (has_norm num))))) : path_connected_space (semiring (random_gen (random_gen (has_norm num)))) := sorry --non-trivial
lemma new_lemma_6512 (h0 : topological_space (canonically_ordered_comm_semiring (has_Inf pos))) : discrete_topology (canonically_ordered_comm_semiring (has_Inf pos)) := sorry --non-trivial
lemma new_lemma_6513 (h0 : not (add_group (add_monoid to_additive.value_type) -> false)) : @is_add_cyclic.{0} (add_monoid.{0} to_additive.value_type) (@classical.by_contradiction'.{1} (add_group.{0} (add_monoid.{0} to_additive.value_type)) h0)  := sorry --non-trivial
lemma new_lemma_6514 (h0 : functor.add_const (ring (finset unsigned)) empty) : @rank_condition.{0} (finset.{0} unsigned) (@functor.add_const.run.{0 0} (ring.{0} (finset.{0} unsigned)) empty h0)  := sorry --non-trivial
lemma new_lemma_6515 (h0 : has_mem.mem ring has_emptyc.emptyc) : @rank_condition.{0} (with_one.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type ring.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) ring.{0} h0) (with_one.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_6516 (h0 : topological_space (mul_one_class to_additive.value_type)) : totally_disconnected_space (mul_one_class to_additive.value_type) := sorry --non-trivial
lemma new_lemma_6517 (h0 : function.extfun Type topological_space) : @t1_space.{0} (canonically_ordered_comm_semiring.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (canonically_ordered_comm_semiring.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_6518 (h0 : function.extfun (Type 1) uniform_space) : @separated_space.{1} (canonically_ordered_monoid.{1} Type) (@function.extfun_app.{3 2} (Type 1) uniform_space.{1} h0 (canonically_ordered_monoid.{1} Type))  := sorry --non-trivial
lemma new_lemma_6519 (h0 : complete_lattice (with_bot linarith.comp_source)) : is_atomistic (with_bot linarith.comp_source) := sorry --non-trivial
lemma new_lemma_6520 (h0 : topological_space (ring (option ennreal))) : t0_space (ring (option ennreal)) := sorry --non-trivial
lemma new_lemma_6521 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @preirreducible_space.{0} (canonically_ordered_comm_semiring.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (canonically_ordered_comm_semiring.{0} num))  := sorry --non-trivial
lemma new_lemma_6522 (h0 : function.extfun Type (functor.add_const (group auto.case_option))) : @group.fg.{0} auto.case_option (@functor.add_const.run.{0 0} (group.{0} auto.case_option) num (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (group.{0} auto.case_option)) h0 num))  := sorry --non-trivial
lemma new_lemma_6523 (h0 : filter (with_bot to_additive.value_type)) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_6524 (h0 : function.extfun (finset Type) (has_mem.mem (has_top linarith.comp_source))) (h1 : function.extfun (has_top linarith.comp_source) (fun (x : has_top linarith.comp_source), Prop)) : @euclidean_geometry.cospherical.{0} (has_top.{0} linarith.comp_source) (@finset.pi.empty.{1 0} Type metric_space.{0} (has_top.{0} linarith.comp_source) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (has_top.{0} linarith.comp_source)) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type)))) (@function.extfun_app.{1 1} (has_top.{0} linarith.comp_source) (λ (x : has_top.{0} linarith.comp_source), Prop) h1)  := sorry --non-trivial
lemma new_lemma_6525 (h0 : topological_space (has_to_string unsigned)) : t1_space (has_to_string unsigned) := sorry --non-trivial
lemma new_lemma_6526 (h0 : functor.add_const (list (has_Inf linarith.comp)) (finset Type)) : palindrome (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_6527 (h1 : complete_lattice (has_ssubset linarith.ineq)) : complete_lattice.is_Sup_finite_compact (has_ssubset linarith.ineq) := sorry --non-trivial
lemma new_lemma_6528 (h0 : set (mul_one_class (mul_one_class (add_comm_semigroup linarith.ineq)) -> string.iterator_imp)) : set.separates_points h0 := sorry --non-trivial
lemma new_lemma_6529 (h2 : topological_space (has_compl linarith.comp_source)) : totally_disconnected_space (has_compl linarith.comp_source) := sorry --non-trivial
lemma new_lemma_6530 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @group.fg.{0} (has_add.{0} ennreal) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (has_add.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_6531 (h0 : functor.add_const (group (complete_distrib_lattice linarith.comp)) linarith.comp) : @group.fg.{0} (complete_distrib_lattice.{0} linarith.comp) (@functor.add_const.run.{0 0} (group.{0} (complete_distrib_lattice.{0} linarith.comp)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_6532 (h0 : ring (linear_ordered_add_comm_group (has_lt (has_nnnorm linarith.ineq)))) : is_domain (linear_ordered_add_comm_group (has_lt (has_nnnorm linarith.ineq))) := sorry --non-trivial
lemma new_lemma_6533 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_simple_group.{0} (has_to_string.{0} pos) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (has_to_string.{0} pos))  := sorry --non-trivial
lemma new_lemma_6534 (h0 : uniform_space (has_Inf (has_neg (has_neg name)))) : separated_space (has_Inf (has_neg (has_neg name))) := sorry --non-trivial
lemma new_lemma_6535 (h0 : functor.add_const (list (complete_distrib_lattice pos)) environment.implicit_infer_kind) : list.nodup (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_6536 (h0 : functor.add_const (function.extfun Type topological_space) linarith.comp) : @irreducible_space.{0} (boolean_algebra.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) linarith.comp h0) (boolean_algebra.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_6537 (h0 : list (boolean_algebra (ring pos))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_6538 (h0 : group (encodable (random_gen fun_info))) : is_cyclic (encodable (random_gen fun_info)) := sorry --non-trivial
lemma new_lemma_6539 (h0 : topological_space (comm_group (has_neg_part unsigned))) : t0_space (comm_group (has_neg_part unsigned)) := sorry --non-trivial
lemma new_lemma_6540 (h0 : ordered_comm_monoid (has_neg (finset (has_add pos)))) : has_exists_mul_of_le (has_neg (finset (has_add pos))) := sorry --non-trivial
lemma new_lemma_6541 (h0 : topological_space (has_norm (random_gen (random_gen linarith.ineq)))) : locally_compact_space (has_norm (random_gen (random_gen linarith.ineq))) := sorry --non-trivial
lemma new_lemma_6542 (h0 : add_group (canonically_ordered_comm_semiring (has_Inf (has_pos_part pos)))) : is_add_cyclic (canonically_ordered_comm_semiring (has_Inf (has_pos_part pos))) := sorry --non-trivial
lemma new_lemma_6543 (h0 : monoid (has_to_string (has_add (add_comm_monoid environment.implicit_infer_kind)))) : monoid.fg (has_to_string (has_add (add_comm_monoid environment.implicit_infer_kind))) := sorry --non-trivial
lemma new_lemma_6544 (h0 : ring (sub_neg_monoid (has_add linarith.comp))) : is_principal_ideal_ring (sub_neg_monoid (has_add linarith.comp)) := sorry --non-trivial
lemma new_lemma_6545 (h0 : ring (normed_linear_ordered_group unsigned)) : is_principal_ideal_ring (normed_linear_ordered_group unsigned) := sorry --non-trivial
lemma new_lemma_6546 (h0 : uniform_space (has_add real)) : complete_space (has_add real) := sorry --non-trivial
lemma new_lemma_6547 (h0 : list (has_norm (random_gen (has_nnnorm to_additive.value_type)))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_6548 (h1 : ring (non_unital_non_assoc_semiring (mul_one_class (has_lt string_imp)))) : rank_condition (non_unital_non_assoc_semiring (mul_one_class (has_lt string_imp))) := sorry --non-trivial
lemma new_lemma_6549 (h0 : ring (normed_field (random_gen reducibility_hints))) : rank_condition (normed_field (random_gen reducibility_hints)) := sorry --non-trivial
lemma new_lemma_6550 (h2 : complete_lattice (distrib (has_nnnorm reducibility_hints))) : is_compactly_generated (distrib (has_nnnorm reducibility_hints)) := sorry --non-trivial
lemma new_lemma_6551 (h0 : set (random_gen linarith.ineq)) : set.finite h0 := sorry --non-trivial
lemma new_lemma_6552 (h0 : topological_space (boolean_algebra.core (has_add (has_add pos)))) : topological_space.separable_space (boolean_algebra.core (has_add (has_add pos))) := sorry --non-trivial
lemma new_lemma_6553 (h0 : uniform_space (has_sub (has_top unsigned))) : separated_space (has_sub (has_top unsigned)) := sorry --non-trivial
lemma new_lemma_6554 (h0 : functor.add_const (complete_lattice (normed_comm_ring linarith.comp)) linarith.comp) : @complete_lattice.is_Sup_finite_compact.{0} (normed_comm_ring.{0} linarith.comp) (@functor.add_const.run.{0 0} (complete_lattice.{0} (normed_comm_ring.{0} linarith.comp)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_6555 (h0 : function.extfun Type group) : @normalizer_condition.{0} (add_comm_monoid.{0} pos) (@function.extfun_app.{2 1} Type group.{0} h0 (add_comm_monoid.{0} pos))  := sorry --non-trivial
lemma new_lemma_6556 (h0 : group (has_norm char)) : group.fg (has_norm char) := sorry --non-trivial
lemma new_lemma_6557 (h0 : ring (ring (has_add (has_add linarith.comp)))) : strong_rank_condition (ring (has_add (has_add linarith.comp))) := sorry --non-trivial
lemma new_lemma_6558 (h0 : functor.add_const (topological_space (normed_comm_ring Type)) linarith.comp) : @topological_space.separable_space.{1} (normed_comm_ring.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (normed_comm_ring.{1} Type)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_6559 (h0 : group (canonically_ordered_comm_semiring (canonically_linear_ordered_monoid name))) : normalizer_condition (canonically_ordered_comm_semiring (canonically_linear_ordered_monoid name)) := sorry --non-trivial
lemma new_lemma_6560 (h0 : functor.add_const (topological_space (boolean_algebra.core environment.implicit_infer_kind)) name) : @topological_space.separable_space.{0} (boolean_algebra.core.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (boolean_algebra.core.{0} environment.implicit_infer_kind)) name h0)  := sorry --non-trivial
lemma new_lemma_6561 (h0 : complete_lattice (has_add (has_add congr_arg_kind))) : is_compactly_generated (has_add (has_add congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_6562 (h0 : topological_space (add_cancel_monoid (has_add linarith.comp))) : locally_compact_space (add_cancel_monoid (has_add linarith.comp)) := sorry --non-trivial
lemma new_lemma_6563 (h0 : topological_space (has_lt (mul_one_class (mul_one_class fun_info)))) : path_connected_space (has_lt (mul_one_class (mul_one_class fun_info))) := sorry --non-trivial
lemma new_lemma_6564 (h0 : functor.add_const (function.extfun Type uniform_space) num) : @complete_space.{0} (linear_ordered_field.{0} empty) (@function.extfun_app.{2 1} Type uniform_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type uniform_space.{0}) num h0) (linear_ordered_field.{0} empty))  := sorry --non-trivial
lemma new_lemma_6565 (h0 : topological_space (sub_neg_monoid (has_Inf Type))) : discrete_topology (sub_neg_monoid (has_Inf Type)) := sorry --non-trivial
lemma new_lemma_6566 (h0 : topological_space (comm_group Type)) : irreducible_space (comm_group Type) := sorry --non-trivial
lemma new_lemma_6567 (h0 : group (mul_zero_class environment.implicit_infer_kind)) : normalizer_condition (mul_zero_class environment.implicit_infer_kind) := sorry --non-trivial
lemma new_lemma_6568 (h0 : cancel_comm_monoid_with_zero (add_cancel_monoid (finset name))) : unique_factorization_monoid (add_cancel_monoid (finset name)) := sorry --non-trivial
lemma new_lemma_6569 (h0 : ring (has_compl (mul_one_class char))) : strong_rank_condition (has_compl (mul_one_class char)) := sorry --non-trivial
lemma new_lemma_6570 (h0 : topological_space (generalized_boolean_algebra (has_pos_part real))) : topological_space.separable_space (generalized_boolean_algebra (has_pos_part real)) := sorry --non-trivial
lemma new_lemma_6571 (h0 : function.extfun (finset Type) (has_mem.mem (has_top to_additive.value_type))) : @totally_disconnected_space.{0} (has_top.{0} to_additive.value_type) (@finset.pi.empty.{1 0} Type topological_space.{0} (has_top.{0} to_additive.value_type) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (has_top.{0} to_additive.value_type)) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_6572 (h0 : ring (has_ssubset to_additive.value_type)) : strong_rank_condition (has_ssubset to_additive.value_type) := sorry --non-trivial
lemma new_lemma_6573 (h0 : functor.add_const (function.extfun Type ring) linarith.comp) : @rank_condition.{0} (has_pos_part.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type ring.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type ring.{0}) linarith.comp h0) (has_pos_part.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_6574 (h0 : function.extfun Type complete_lattice) : @is_compactly_generated.{0} (with_one.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (with_one.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_6575 (h0 : topological_space (has_neg num)) : t0_space (has_neg num) := sorry --non-trivial
lemma new_lemma_6576 (h0 : has_mem.mem topological_space has_emptyc.emptyc) : @irreducible_space.{0} (linear_ordered_add_comm_group.{0} fun_info) (@function.extfun_app.{2 1} Type topological_space.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) topological_space.{0} h0) (linear_ordered_add_comm_group.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_6577 (h0 : functor.add_const (topological_space (ring Type)) pos) : @topological_space.separable_space.{1} (ring.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (ring.{1} Type)) pos h0)  := sorry --non-trivial
lemma new_lemma_6578 (h0 : function.extfun Type (functor.comp uniform_space add_comm_monoid)) : @separated_space.{0} (add_comm_monoid.{0} environment.implicit_infer_kind) (@functor.comp.run.{0 0 0} uniform_space.{0} add_comm_monoid.{0} environment.implicit_infer_kind (@function.extfun_app.{2 1} Type (functor.comp.{0 0 0} uniform_space.{0} add_comm_monoid.{0}) h0 environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_6579 (h0 : functor.add_const (function.extfun Type monoid) pos) : @monoid.fg.{0} (has_add.{0} linarith.comp) (@function.extfun_app.{2 1} Type monoid.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type monoid.{0}) pos h0) (has_add.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_6580 (h0 : functor.add_const (topological_space (has_neg Type)) Type) : @t1_space.{1} (has_neg.{1} Type) (@functor.add_const.run.{1 1} (topological_space.{1} (has_neg.{1} Type)) Type h0)  := sorry --non-trivial
lemma new_lemma_6581 (h0 : topological_space (has_to_string (finset (has_add Type)))) : t0_space (has_to_string (finset (has_add Type))) := sorry --non-trivial
lemma new_lemma_6582 (h0 : group (has_emptyc (complete_semilattice_Sup linarith.comp))) : normalizer_condition (has_emptyc (complete_semilattice_Sup linarith.comp)) := sorry --non-trivial
lemma new_lemma_6583 (h0 : group (boolean_algebra Type)) : is_simple_group (boolean_algebra Type) := sorry --non-trivial
lemma new_lemma_6584 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @complete_lattice.is_Sup_finite_compact.{0} (linear_ordered_semiring.{0} empty) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (linear_ordered_semiring.{0} empty))  := sorry --non-trivial
lemma new_lemma_6585 (h0 : function.extfun Type ordered_comm_monoid) : @has_exists_mul_of_le.{0} (normed_comm_ring.{0} linarith.comp) (@function.extfun_app.{2 1} Type ordered_comm_monoid.{0} h0 (normed_comm_ring.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_6586 (h0 : semiring (has_pos_part (has_Inf (has_Inf real)))) : is_noetherian_ring (has_pos_part (has_Inf (has_Inf real))) := sorry --non-trivial
lemma new_lemma_6587 (h0 : uniform_space (boolean_algebra (comm_group name))) : separated_space (boolean_algebra (comm_group name)) := sorry --non-trivial
lemma new_lemma_6588 (h0 : not (group (encodable char) -> false)) : @group.fg.{0} (encodable.{0} char) (@classical.by_contradiction'.{1} (group.{0} (encodable.{0} char)) h0)  := sorry --non-trivial
lemma new_lemma_6589 (h0 : fin has_zero.zero) : @add_monoid.fg.{0} (boolean_algebra.core.{0} (has_neg.{0} name)) (@matrix.vec_empty.{0} (add_monoid.{0} (boolean_algebra.core.{0} (has_neg.{0} name))) h0)  := sorry --non-trivial
lemma new_lemma_6590 (h0 : topological_space (has_one (has_norm (semiring num)))) : t0_space (has_one (has_norm (semiring num))) := sorry --non-trivial
lemma new_lemma_6591 (h0 : uniform_space (canonically_ordered_monoid real)) : separated_space (canonically_ordered_monoid real) := sorry --non-trivial
lemma new_lemma_6592 (h0 : topological_space (has_nndist (has_to_string (comm_group linarith.comp)))) : regular_space (has_nndist (has_to_string (comm_group linarith.comp))) := sorry --non-trivial
lemma new_lemma_6593 (h0 : group (free_add_monoid congr_arg_kind)) : normalizer_condition (free_add_monoid congr_arg_kind) := sorry --non-trivial
lemma new_lemma_6594 (h0 : uniform_space (add_cancel_monoid (option (option empty)))) : separated_space (add_cancel_monoid (option (option empty))) := sorry --non-trivial
lemma new_lemma_6595 (h0 : function.extfun Type topological_space) : t0_space empty := sorry --non-trivial
lemma new_lemma_6596 (h0 : list (has_Sup (add_cancel_comm_monoid empty))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_6597 (h0 : topological_space (has_add (has_Inf Type))) : normal_space (has_add (has_Inf Type)) := sorry --non-trivial
lemma new_lemma_6598 (h0 : topological_space (boolean_algebra.core (has_Inf linarith.comp))) : loc_path_connected_space (boolean_algebra.core (has_Inf linarith.comp)) := sorry --non-trivial
lemma new_lemma_6599 (h1 : has_neg (mul_one_class (add_comm_semigroup environment.projection_info))) (h2 : measurable_space (mul_one_class (add_comm_semigroup environment.projection_info))) : has_measurable_neg (mul_one_class (add_comm_semigroup environment.projection_info)) := sorry --non-trivial
lemma new_lemma_6600 (h0 : functor.add_const (monoid (semigroup name)) (has_add pos)) : @monoid.fg.{0} (semigroup.{0} name) (@functor.add_const.run.{0 0} (monoid.{0} (semigroup.{0} name)) (has_add.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_6601 (h0 : not (ring (div_inv_monoid to_additive.value_type) -> false)) : @rank_condition.{0} (div_inv_monoid.{0} to_additive.value_type) (@classical.by_contradiction'.{1} (ring.{0} (div_inv_monoid.{0} to_additive.value_type)) h0)  := sorry --non-trivial
lemma new_lemma_6602 (h0 : functor.add_const (list (has_zero Type)) environment.implicit_infer_kind) : palindrome (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_6603 (h0 : ordered_add_comm_monoid (semigroup (finset environment.implicit_infer_kind))) : archimedean (semigroup (finset environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_6604 (h0 : group (has_zero (has_add (comm_group (has_add (has_add pos)))))) : group.fg (has_zero (has_add (comm_group (has_add (has_add pos))))) := sorry --non-trivial
lemma new_lemma_6605 (h1 : ring (simple_graph reducibility_hints)) : strong_rank_condition (simple_graph reducibility_hints) := sorry --non-trivial
lemma new_lemma_6606 (h0 : uniform_space (topological_space (has_nnnorm linarith.ineq))) : complete_space (topological_space (has_nnnorm linarith.ineq)) := sorry --non-trivial
lemma new_lemma_6607 (h0 : function.extfun nat fin) : @is_atomistic.{0} (ordered_comm_ring.{0} real) (@matrix.vec_empty.{0} (complete_lattice.{0} (ordered_comm_ring.{0} real)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_6608 (h0 : functor.add_const (add_monoid (has_zero pos)) environment.implicit_infer_kind) : @add_monoid.fg.{0} (has_zero.{0} pos) (@functor.add_const.run.{0 0} (add_monoid.{0} (has_zero.{0} pos)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_6609 (h0 : ring (ordered_comm_ring (finset (ring (finset Type))))) : is_principal_ideal_ring (ordered_comm_ring (finset (ring (finset Type)))) := sorry --non-trivial
lemma new_lemma_6610 (h0 : functor.add_const (filter (normed_comm_ring unsigned)) environment.implicit_infer_kind) : countable_Inter_filter (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_6611 (h0 : topological_space (has_to_string (normed_comm_ring linarith.comp))) : totally_separated_space (has_to_string (normed_comm_ring linarith.comp)) := sorry --non-trivial
lemma new_lemma_6612 (h0 : functor.add_const (topological_space (boolean_algebra.core Type)) name) : @totally_disconnected_space.{1} (boolean_algebra.core.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (boolean_algebra.core.{1} Type)) name h0)  := sorry --non-trivial
lemma new_lemma_6613 (h0 : add_monoid (add_cancel_monoid (linear_ordered_comm_ring linarith.comp))) : add_monoid.fg (add_cancel_monoid (linear_ordered_comm_ring linarith.comp)) := sorry --non-trivial
lemma new_lemma_6614 (h0 : function.extfun Type complete_lattice) : @is_compactly_generated.{0} (has_Inf.{0} real) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (has_Inf.{0} real))  := sorry --non-trivial
lemma new_lemma_6615 (h0 : filter (with_zero (has_top (has_inv (has_add (has_ssubset to_additive.value_type)))))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_6616 (h0 : function.extfun Type topological_space) : @t0_space.{0} (linear_ordered_field.{0} ennreal) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (linear_ordered_field.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_6617 (h0 : function.extfun Type topological_space) : @t1_space.{0} (has_dist.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_dist.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_6618 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_domain.{0} (has_bot.{0} name) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (has_bot.{0} name))  := sorry --non-trivial
lemma new_lemma_6619 (h0 : uniform_space (semigroup (mul_one_class linarith.comp))) : separated_space (semigroup (mul_one_class linarith.comp)) := sorry --non-trivial
lemma new_lemma_6620 (h0 : functor.add_const (function.extfun Type uniform_space) ennreal) : @complete_space.{0} (has_zero.{0} name) (@function.extfun_app.{2 1} Type uniform_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type uniform_space.{0}) ennreal h0) (has_zero.{0} name))  := sorry --non-trivial
lemma new_lemma_6621 (h0 : function.extfun Type add_monoid) : @add_monoid.fg.{0} (has_edist.{0} unsigned) (@function.extfun_app.{2 1} Type add_monoid.{0} h0 (has_edist.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_6622 (h0 : function.extfun Type group) : @group.fg.{0} (has_edist.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type group.{0} h0 (has_edist.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_6623 (h0 : topological_space (has_nnnorm (random_gen linarith.comp_source))) : locally_compact_space (has_nnnorm (random_gen linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_6624 (h0 : function.extfun Type topological_space) : @totally_separated_space.{0} (boolean_algebra.core.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (boolean_algebra.core.{0} empty))  := sorry --non-trivial
lemma new_lemma_6625 (h0 : topological_space (mul_zero_class ennreal)) : discrete_topology (mul_zero_class ennreal) := sorry --non-trivial
lemma new_lemma_6626 (h0 : functor.add_const (ring (measure_theory.measure_space unsigned)) congr_arg_kind) : @rank_condition.{0} (measure_theory.measure_space.{0} unsigned) (@functor.add_const.run.{0 0} (ring.{0} (measure_theory.measure_space.{0} unsigned)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_6627 (h0 : function.extfun Type topological_space) : @preirreducible_space.{0} (has_nndist.{0} (has_add.{0} name)) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_nndist.{0} (has_add.{0} name)))  := sorry --non-trivial
lemma new_lemma_6628 (h0 : not (function.extfun Type cancel_comm_monoid_with_zero -> false)) : @unique_factorization_monoid.{0} (semiring.{0} empty) (@function.extfun_app.{2 1} Type cancel_comm_monoid_with_zero.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type cancel_comm_monoid_with_zero.{0}) h0) (semiring.{0} empty))  := sorry --non-trivial
lemma new_lemma_6629 (h0 : functor.add_const (filter (boolean_algebra environment.implicit_infer_kind)) linarith.comp) : filter.ne_bot (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_6630 (h0 : group (topological_space (has_nnnorm linarith.ineq))) : group.fg (topological_space (has_nnnorm linarith.ineq)) := sorry --non-trivial
lemma new_lemma_6631 (h0 : topological_space (omega_complete_partial_order congr_arg_kind)) : loc_path_connected_space (omega_complete_partial_order congr_arg_kind) := sorry --non-trivial
lemma new_lemma_6632 (h0 : topological_space (has_neg unsigned)) : normal_space (has_neg unsigned) := sorry --non-trivial
lemma new_lemma_6633 (h0 : ordered_comm_monoid (sub_neg_monoid real)) : has_exists_mul_of_le (sub_neg_monoid real) := sorry --non-trivial
lemma new_lemma_6634 (h0 : add_group (has_edist unsigned)) : is_add_cyclic (has_edist unsigned) := sorry --non-trivial
lemma new_lemma_6635 (h0 : not (function.extfun Type topological_space -> false)) : @path_connected_space.{0} to_additive.value_type (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) to_additive.value_type)  := sorry --non-trivial
lemma new_lemma_6636 (h2 : topological_space (has_div linarith.ineq)) : totally_disconnected_space (has_div linarith.ineq) := sorry --non-trivial
lemma new_lemma_6637 (h0 : functor.add_const (function.extfun Type semiring) (has_add (ring (has_add linarith.comp)))) : @is_noetherian_ring.{0} (normed_comm_ring.{0} linarith.comp) (@function.extfun_app.{2 1} Type semiring.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type semiring.{0}) (has_add.{0} (ring.{0} (has_add.{0} linarith.comp))) h0) (normed_comm_ring.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_6638 (h0 : functor.comp ring semigroup name) : @rank_condition.{0} (semigroup.{0} name) (@functor.comp.run.{0 0 0} ring.{0} semigroup.{0} name h0)  := sorry --non-trivial
lemma new_lemma_6639 (h0 : topological_space (ordered_comm_monoid (has_neg pos))) : t1_space (ordered_comm_monoid (has_neg pos)) := sorry --non-trivial
lemma new_lemma_6640 (h0 : functor.add_const (topological_space (has_zero Type)) pos) : @sequential_space.{1} (has_zero.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (has_zero.{1} Type)) pos h0)  := sorry --non-trivial
lemma new_lemma_6641 (h0 : ring (has_inter (option (option empty)))) : rank_condition (has_inter (option (option empty))) := sorry --non-trivial
lemma new_lemma_6642 (h0 : functor.add_const (ordered_add_comm_monoid (add_cancel_monoid environment.implicit_infer_kind)) pos) : @archimedean.{0} (add_cancel_monoid.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (ordered_add_comm_monoid.{0} (add_cancel_monoid.{0} environment.implicit_infer_kind)) pos h0)  := sorry --non-trivial
lemma new_lemma_6643 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @totally_disconnected_space.{0} (has_emptyc.{0} linarith.ineq) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_emptyc.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_6644 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @monoid.fg.{1} (plift.{1} congr_arg_kind) (@function.extfun_app.{3 2} (Type 1) monoid.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 monoid.{1}) (plift.{1} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_6645 (h0 : functor.add_const (list auto.case_option) num) : list.nodup (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_6646 (h0 : complete_lattice (preorder (semiring empty))) : is_atomistic (preorder (semiring empty)) := sorry --non-trivial
lemma new_lemma_6647 (h0 : has_mem.mem uniform_space has_emptyc.emptyc) : @complete_space.{0} (has_norm.{0} linarith.comp) (@function.extfun_app.{2 1} Type uniform_space.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) uniform_space.{0} h0) (has_norm.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_6648 (h0 : topological_space (complete_distrib_lattice (has_add environment.implicit_infer_kind))) : discrete_topology (complete_distrib_lattice (has_add environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_6649 (h0 : not (topological_space (add_right_cancel_monoid congr_arg_kind) -> false)) : @preirreducible_space.{0} (add_right_cancel_monoid.{0} congr_arg_kind) (@classical.by_contradiction'.{1} (topological_space.{0} (add_right_cancel_monoid.{0} congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_6650 (h0 : topological_space (linear_ordered_comm_ring num)) : path_connected_space (linear_ordered_comm_ring num) := sorry --non-trivial
lemma new_lemma_6651 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @unique_factorization_monoid.{1} (plift.{1} unsigned) (@function.extfun_app.{3 2} (Type 1) cancel_comm_monoid_with_zero.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 cancel_comm_monoid_with_zero.{1}) (plift.{1} unsigned))  := sorry --non-trivial
lemma new_lemma_6652 (h0 : function.extfun Type ring) : @rank_condition.{0} (semiring.{0} (semiring.{0} empty)) (@function.extfun_app.{2 1} Type ring.{0} h0 (semiring.{0} (semiring.{0} empty)))  := sorry --non-trivial
lemma new_lemma_6653 (h0 : functor.add_const (function.extfun Type topological_space) pos) : @sequential_space.{0} (has_to_string.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) pos h0) (has_to_string.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_6654 (h0 : group (semi_normed_ring (has_nnnorm reducibility_hints))) : is_cyclic (semi_normed_ring (has_nnnorm reducibility_hints)) := sorry --non-trivial
lemma new_lemma_6655 (h0 : complete_lattice (normed_group (has_top fun_info))) : is_compactly_generated (normed_group (has_top fun_info)) := sorry --non-trivial
lemma new_lemma_6656 (h0 : function.extfun Type ring) : @is_principal_ideal_ring.{0} (simple_graph.{0} name) (@function.extfun_app.{2 1} Type ring.{0} h0 (simple_graph.{0} name))  := sorry --non-trivial
lemma new_lemma_6657 (h0 : prod (normed_comm_ring (has_nndist ennreal)) (normed_comm_ring (has_nndist ennreal))) : id_rel h0 := sorry --non-trivial
lemma new_lemma_6658 (h0 : uniform_space (ring (finset linarith.comp))) : separated_space (ring (finset linarith.comp)) := sorry --non-trivial
lemma new_lemma_6659 (h0 : function.extfun Type ring) : @rank_condition.{0} (with_one.{0} empty) (@function.extfun_app.{2 1} Type ring.{0} h0 (with_one.{0} empty))  := sorry --non-trivial
lemma new_lemma_6660 (h0 : functor.add_const (ring (has_zero linarith.comp)) (has_add pos)) : @is_domain.{0} (has_zero.{0} linarith.comp) (@functor.add_const.run.{0 0} (ring.{0} (has_zero.{0} linarith.comp)) (has_add.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_6661 (h1 : topological_space (measurable_space linarith.ineq)) : locally_compact_space (measurable_space linarith.ineq) := sorry --non-trivial
lemma new_lemma_6662 (h0 : function.extfun Type ring) : @strong_rank_condition.{0} (comm_group.{0} name) (@function.extfun_app.{2 1} Type ring.{0} h0 (comm_group.{0} name))  := sorry --non-trivial
lemma new_lemma_6663 (h0 : functor.add_const (topological_space (add_cancel_monoid environment.implicit_infer_kind)) name) : @sequential_space.{0} (add_cancel_monoid.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (add_cancel_monoid.{0} environment.implicit_infer_kind)) name h0)  := sorry --non-trivial
lemma new_lemma_6664 (h0 : ring (denumerable (comm_ring (random_gen (random_gen to_additive.value_type))))) : strong_rank_condition (denumerable (comm_ring (random_gen (random_gen to_additive.value_type)))) := sorry --non-trivial
lemma new_lemma_6665 (h0 : function.extfun Type group) : @normalizer_condition.{0} (has_edist.{0} empty) (@function.extfun_app.{2 1} Type group.{0} h0 (has_edist.{0} empty))  := sorry --non-trivial
lemma new_lemma_6666 (h0 : functor.add_const (topological_space (has_add pos)) (has_to_string Type)) : @topological_space.separable_space.{0} (has_add.{0} pos) (@functor.add_const.run.{0 1} (topological_space.{0} (has_add.{0} pos)) (has_to_string.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_6667 (h0 : measurable_space Type) (h1 : has_add Type) : has_measurable_add Type := sorry --non-trivial
lemma new_lemma_6668 (h0 : not (complete_lattice (with_zero char) -> false)) : @complete_lattice.is_Sup_finite_compact.{0} (with_zero.{0} char) (@classical.by_contradiction'.{1} (complete_lattice.{0} (with_zero.{0} char)) h0)  := sorry --non-trivial
lemma new_lemma_6669 (h0 : has_mul znum) (h1 : znum) : is_regular h1 := sorry --non-trivial
lemma new_lemma_6670 (h0 : not (add_group (has_nnnorm (mul_one_class (mul_one_class (mul_one_class linarith.ineq)))) -> false)) : @is_add_cyclic.{0} (has_nnnorm.{0} (mul_one_class.{0} (mul_one_class.{0} (mul_one_class.{0} linarith.ineq)))) (@classical.by_contradiction'.{1} (add_group.{0} (has_nnnorm.{0} (mul_one_class.{0} (mul_one_class.{0} (mul_one_class.{0} linarith.ineq))))) h0)  := sorry --non-trivial
lemma new_lemma_6671 (h0 : linarith.ineq -> linarith.ineq -> bool) : is_dec_refl h0 := sorry --non-trivial
lemma new_lemma_6672 (h2 : topological_space (has_nnnorm char)) (h3 : preorder (has_nnnorm char)) : order_closed_topology (has_nnnorm char) := sorry --non-trivial
lemma new_lemma_6673 (h0 : topological_space (has_top (semiring unsigned))) : path_connected_space (has_top (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_6674 (h0 : functor.add_const (ordered_comm_monoid (boolean_algebra Type)) (boolean_algebra pos)) : @has_exists_mul_of_le.{1} (boolean_algebra.{1} Type) (@functor.add_const.run.{1 0} (ordered_comm_monoid.{1} (boolean_algebra.{1} Type)) (boolean_algebra.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_6675 (h1 : topological_space (complete_semilattice_Sup linarith.comp_source)) : path_connected_space (complete_semilattice_Sup linarith.comp_source) := sorry --non-trivial
lemma new_lemma_6676 (h0 : not (complete_lattice num -> false)) : @complete_lattice.is_Sup_finite_compact.{0} num (@classical.by_contradiction'.{1} (complete_lattice.{0} num) h0)  := sorry --non-trivial
lemma new_lemma_6677 (h0 : function.extfun Type ordered_add_comm_monoid) : @archimedean.{0} (has_to_string.{0} name) (@function.extfun_app.{2 1} Type ordered_add_comm_monoid.{0} h0 (has_to_string.{0} name))  := sorry --non-trivial
lemma new_lemma_6678 (h0 : uniform_space (add_comm_monoid (boolean_algebra Type))) : separated_space (add_comm_monoid (boolean_algebra Type)) := sorry --non-trivial
lemma new_lemma_6679 (h0 : simple_graph (normed_group unsigned)) (h1 : normed_group unsigned) (h2 : function.extfun Type normed_group) : simple_graph.neighbor_set h0 h1 (function.extfun_app h2 unsigned) := sorry --non-trivial
lemma new_lemma_6680 (h0 : ring (add_cancel_monoid (option empty))) : is_domain (add_cancel_monoid (option empty)) := sorry --non-trivial
lemma new_lemma_6681 (h0 : monoid (normed_comm_ring (has_neg_part Type))) : monoid.fg (normed_comm_ring (has_neg_part Type)) := sorry --non-trivial
lemma new_lemma_6682 (h0 : has_ssubset (random_gen (random_gen linarith.ineq)) -> has_ssubset (random_gen (random_gen linarith.ineq)) -> bool) : is_dec_refl h0 := sorry --non-trivial
lemma new_lemma_6683 (h2 : topological_space (semi_normed_comm_ring string.iterator_imp)) : totally_disconnected_space (semi_normed_comm_ring string.iterator_imp) := sorry --non-trivial
lemma new_lemma_6684 (h0 : complete_lattice (has_norm (has_top (has_inv fun_info)))) : is_atomistic (has_norm (has_top (has_inv fun_info))) := sorry --non-trivial
lemma new_lemma_6685 (h0 : complete_lattice (has_star (option (option empty)))) : complete_lattice.is_Sup_finite_compact (has_star (option (option empty))) := sorry --non-trivial
lemma new_lemma_6686 (h0 : function.extfun Type topological_space) : @t1_space.{0} (has_neg.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_neg.{0} pos))  := sorry --non-trivial
lemma new_lemma_6687 (h0 : set (distrib (mul_one_class char))) : set.subsingleton h0 := sorry --non-trivial
lemma new_lemma_6688 (h0 : ring (has_append (has_nnnorm (has_nnnorm (has_nnnorm (has_nnnorm fun_info)))))) : rank_condition (has_append (has_nnnorm (has_nnnorm (has_nnnorm (has_nnnorm fun_info))))) := sorry --non-trivial
lemma new_lemma_6689 (h0 : function.extfun Type complete_lattice) : @is_atomistic.{0} (pseudo_metric_space.{0} unsigned) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (pseudo_metric_space.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_6690 (h0 : add_monoid (ring (normed_linear_ordered_group linarith.comp))) : add_monoid.fg (ring (normed_linear_ordered_group linarith.comp)) := sorry --non-trivial
lemma new_lemma_6691 (h0 : functor.add_const (add_monoid (ordered_ring num)) empty) : @add_monoid.fg.{0} (ordered_ring.{0} num) (@functor.add_const.run.{0 0} (add_monoid.{0} (ordered_ring.{0} num)) empty h0)  := sorry --non-trivial
lemma new_lemma_6692 (h0 : topological_space (comm_group (boolean_algebra pos))) : preconnected_space (comm_group (boolean_algebra pos)) := sorry --non-trivial
lemma new_lemma_6693 (h0 : filter (has_compl (has_nnnorm fun_info))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_6694 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @discrete_topology.{0} (canonically_ordered_comm_semiring.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (canonically_ordered_comm_semiring.{0} empty))  := sorry --non-trivial
lemma new_lemma_6695 (h0 : complete_lattice (boolean_algebra.core environment.implicit_infer_kind)) : is_compactly_generated (boolean_algebra.core environment.implicit_infer_kind) := sorry --non-trivial
lemma new_lemma_6696 (h0 : functor.add_const (group (normed_comm_ring environment.implicit_infer_kind)) name) : @group.fg.{0} (normed_comm_ring.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (group.{0} (normed_comm_ring.{0} environment.implicit_infer_kind)) name h0)  := sorry --non-trivial
lemma new_lemma_6697 (h0 : functor.add_const (topological_space (has_pos_part linarith.comp)) pos) : @t0_space.{0} (has_pos_part.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (has_pos_part.{0} linarith.comp)) pos h0)  := sorry --non-trivial
lemma new_lemma_6698 (h0 : ring (semigroup (has_pos_part (finset (finset pos))))) : is_principal_ideal_ring (semigroup (has_pos_part (finset (finset pos)))) := sorry --non-trivial
lemma new_lemma_6699 (h0 : topological_space (has_to_string (has_neg linarith.comp))) : t0_space (has_to_string (has_neg linarith.comp)) := sorry --non-trivial
lemma new_lemma_6700 (h0 : function.extfun Type uniform_space) : @complete_space.{0} environment.implicit_infer_kind (@function.extfun_app.{2 1} Type uniform_space.{0} h0 environment.implicit_infer_kind)  := sorry --non-trivial
lemma new_lemma_6701 (h0 : ring (is_R_or_C empty)) : strong_rank_condition (is_R_or_C empty) := sorry --non-trivial
lemma new_lemma_6702 (h0 : function.extfun Type ring) : @rank_condition.{0} (comm_semigroup.{0} pos) (@function.extfun_app.{2 1} Type ring.{0} h0 (comm_semigroup.{0} pos))  := sorry --non-trivial
lemma new_lemma_6703 (h0 : ring (denumerable (has_nnnorm linarith.ineq))) : is_domain (denumerable (has_nnnorm linarith.ineq)) := sorry --non-trivial
lemma new_lemma_6704 (h0 : functor.add_const (add_monoid (finset Type)) pos) : @add_monoid.fg.{1} (finset.{1} Type) (@functor.add_const.run.{1 0} (add_monoid.{1} (finset.{1} Type)) pos h0)  := sorry --non-trivial
lemma new_lemma_6705 (h0 : not (topological_space (normed_field reducibility_hints) -> false)) : @irreducible_space.{0} (normed_field.{0} reducibility_hints) (@classical.by_contradiction'.{1} (topological_space.{0} (normed_field.{0} reducibility_hints)) h0)  := sorry --non-trivial
lemma new_lemma_6706 (h0 : topological_space (non_unital_non_assoc_semiring enat)) : totally_disconnected_space (non_unital_non_assoc_semiring enat) := sorry --non-trivial
lemma new_lemma_6707 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @strong_rank_condition.{0} (has_top.{0} fun_info) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (has_top.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_6708 (h0 : functor.add_const (complete_lattice (add_cancel_monoid environment.implicit_infer_kind)) Type) : @is_compactly_generated.{0} (add_cancel_monoid.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 1} (complete_lattice.{0} (add_cancel_monoid.{0} environment.implicit_infer_kind)) Type h0)  := sorry --non-trivial
lemma new_lemma_6709 (h0 : topological_space (pseudo_metric_space num)) : normal_space (pseudo_metric_space num) := sorry --non-trivial
lemma new_lemma_6710 (h0 : list (has_pos_part (has_add Type))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_6711 (h0 : function.extfun Type cancel_comm_monoid_with_zero) : @unique_factorization_monoid.{0} (ordered_ring.{0} empty) (@function.extfun_app.{2 1} Type cancel_comm_monoid_with_zero.{0} h0 (ordered_ring.{0} empty))  := sorry --non-trivial
lemma new_lemma_6712 (h0 : finset (has_inter (option (option ennreal)))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_6713 (h0 : topological_space (normed_comm_ring name)) : sequential_space (normed_comm_ring name) := sorry --non-trivial
lemma new_lemma_6714 (h0 : topological_space (has_emptyc (has_norm num))) : discrete_topology (has_emptyc (has_norm num)) := sorry --non-trivial
lemma new_lemma_6715 (h0 : topological_space (has_star (semiring (add_group (semiring (option unsigned)))))) : discrete_topology (has_star (semiring (add_group (semiring (option unsigned))))) := sorry --non-trivial
lemma new_lemma_6716 (h0 : function.extfun (finset Type) (has_mem.mem (has_top linarith.comp_source))) : @complete_lattice.is_Sup_finite_compact.{0} (has_top.{0} linarith.comp_source) (@finset.pi.empty.{1 0} Type complete_lattice.{0} (has_top.{0} linarith.comp_source) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (has_top.{0} linarith.comp_source)) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_6717 (h0 : topological_space (left_cancel_semigroup (semiring (semiring num)))) : t1_space (left_cancel_semigroup (semiring (semiring num))) := sorry --non-trivial
lemma new_lemma_6718 (h0 : uniform_space (div_inv_monoid unsigned)) : separated_space (div_inv_monoid unsigned) := sorry --non-trivial
lemma new_lemma_6719 (h1 : topological_space (has_top string_imp)) : locally_compact_space (has_top string_imp) := sorry --non-trivial
lemma new_lemma_6720 (h0 : function.extfun Type uniform_space) : @complete_space.{0} (has_norm.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (has_norm.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_6721 (h0 : topological_space (semi_normed_comm_ring (mul_one_class char))) : path_connected_space (semi_normed_comm_ring (mul_one_class char)) := sorry --non-trivial
lemma new_lemma_6722 (h0 : group (normed_comm_ring (complete_distrib_lattice pos))) : group.fg (normed_comm_ring (complete_distrib_lattice pos)) := sorry --non-trivial
lemma new_lemma_6723 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @rank_condition.{0} (left_cancel_monoid.{0} empty) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (left_cancel_monoid.{0} empty))  := sorry --non-trivial
lemma new_lemma_6724 (h0 : topological_space (ordered_comm_ring (has_Inf pos))) : loc_path_connected_space (ordered_comm_ring (has_Inf pos)) := sorry --non-trivial
lemma new_lemma_6725 (h0 : functor.add_const (ordered_comm_monoid (add_comm_monoid Type)) (ring (finset environment.implicit_infer_kind))) : @has_exists_mul_of_le.{1} (add_comm_monoid.{1} Type) (@functor.add_const.run.{1 0} (ordered_comm_monoid.{1} (add_comm_monoid.{1} Type)) (ring.{0} (finset.{0} environment.implicit_infer_kind)) h0)  := sorry --non-trivial
lemma new_lemma_6726 (h0 : functor.add_const (topological_space (has_nndist unsigned)) environment.implicit_infer_kind) : @irreducible_space.{0} (has_nndist.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (has_nndist.{0} unsigned)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_6727 (h0 : function.extfun Type group) : @normalizer_condition.{0} (distrib_lattice.{0} (has_inv.{0} linarith.comp_source)) (@function.extfun_app.{2 1} Type group.{0} h0 (distrib_lattice.{0} (has_inv.{0} linarith.comp_source)))  := sorry --non-trivial
lemma new_lemma_6728 (h0 : topological_space (add_cancel_monoid (ordered_ring (has_neg Type)))) : locally_compact_space (add_cancel_monoid (ordered_ring (has_neg Type))) := sorry --non-trivial
lemma new_lemma_6729 (h0 : uniform_space (monoid ennreal)) : complete_space (monoid ennreal) := sorry --non-trivial
lemma new_lemma_6730 (h0 : group (has_zero (finset Type))) : is_simple_group (has_zero (finset Type)) := sorry --non-trivial
lemma new_lemma_6731 (h0 : function.extfun Type add_group) : @is_add_cyclic.{0} (complete_distrib_lattice.{0} real) (@function.extfun_app.{2 1} Type add_group.{0} h0 (complete_distrib_lattice.{0} real))  := sorry --non-trivial
lemma new_lemma_6732 (h0 : functor.add_const (topological_space (preorder unsigned)) unsigned) : @discrete_topology.{0} (preorder.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (preorder.{0} unsigned)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_6733 (h0 : functor.add_const (uniform_space (has_add pos)) (has_Inf linarith.comp)) : @complete_space.{0} (has_add.{0} pos) (@functor.add_const.run.{0 0} (uniform_space.{0} (has_add.{0} pos)) (has_Inf.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_6734 (h0 : topological_space (has_zero (has_to_string linarith.comp))) : locally_compact_space (has_zero (has_to_string linarith.comp)) := sorry --non-trivial
lemma new_lemma_6735 (h0 : list (linear_ordered_comm_ring ennreal)) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_6736 (h0 : ring (div_inv_monoid linarith.comp_source)) : is_domain (div_inv_monoid linarith.comp_source) := sorry --non-trivial
lemma new_lemma_6737 (h0 : topological_space (canonically_ordered_monoid (has_neg Type))) : irreducible_space (canonically_ordered_monoid (has_neg Type)) := sorry --non-trivial
lemma new_lemma_6738 (h0 : group (has_nndist name)) : group.fg (has_nndist name) := sorry --non-trivial
lemma new_lemma_6739 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @unique_factorization_monoid.{0} (has_add.{0} name) (@function.extfun_app.{2 1} Type cancel_comm_monoid_with_zero.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 cancel_comm_monoid_with_zero.{0}) (has_add.{0} name))  := sorry --non-trivial
lemma new_lemma_6740 (h0 : ulower (ulower Prop)) (h1 : list Prop) : @list.ilast'.{0} Prop (@ulower.up.{0} Prop encodable.Prop (@ulower.up.{0} (@ulower.{0} Prop encodable.Prop) (@ulower.encodable.{0} Prop encodable.Prop) h0)) h1  := sorry --non-trivial
lemma new_lemma_6741 (h0 : topological_space (lattice std_gen)) : path_connected_space (lattice std_gen) := sorry --non-trivial
lemma new_lemma_6742 (h0 : functor.add_const (topological_space (has_pos_part pos)) linarith.comp) : @t1_space.{0} (has_pos_part.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (has_pos_part.{0} pos)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_6743 (h0 : topological_space (add_comm_monoid (has_neg linarith.comp))) : totally_disconnected_space (add_comm_monoid (has_neg linarith.comp)) := sorry --non-trivial
lemma new_lemma_6744 (h0 : function.extfun Type complete_lattice) : is_atomistic (filter num) := sorry --non-trivial
lemma new_lemma_6745 (h0 : add_group (non_unital_non_assoc_semiring (mul_one_class string_imp))) : is_add_cyclic (non_unital_non_assoc_semiring (mul_one_class string_imp)) := sorry --non-trivial
lemma new_lemma_6746 (h0 : group (ordered_ring empty)) : normalizer_condition (ordered_ring empty) := sorry --non-trivial
lemma new_lemma_6747 (h0 : function.extfun Type topological_space) : @loc_path_connected_space.{0} (mul_zero_class.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (mul_zero_class.{0} num))  := sorry --non-trivial
lemma new_lemma_6748 (h0 : functor.add_const (ordered_add_comm_monoid (sub_neg_monoid real)) real) : @archimedean.{0} (sub_neg_monoid.{0} real) (@functor.add_const.run.{0 0} (ordered_add_comm_monoid.{0} (sub_neg_monoid.{0} real)) real h0)  := sorry --non-trivial
lemma new_lemma_6749 (h0 : functor.add_const (finset (preorder empty)) num) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_6750 (h0 : ordered_add_comm_monoid (add_comm_monoid (has_bot pos))) : archimedean (add_comm_monoid (has_bot pos)) := sorry --non-trivial
lemma new_lemma_6751 (h1 : ring (mul_one_class (mul_one_class enat))) : strong_rank_condition (mul_one_class (mul_one_class enat)) := sorry --non-trivial
lemma new_lemma_6752 (h0 : function.extfun Type group) : @is_cyclic.{0} (with_bot.{0} fun_info) (@function.extfun_app.{2 1} Type group.{0} h0 (with_bot.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_6753 (h0 : topological_space (complete_linear_order num)) : preirreducible_space (complete_linear_order num) := sorry --non-trivial
lemma new_lemma_6754 (h1 : complete_lattice (mul_one_class string.iterator_imp)) : complete_lattice.is_Sup_finite_compact (mul_one_class string.iterator_imp) := sorry --non-trivial
lemma new_lemma_6755 (h0 : finset (partial_order (semiring num))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_6756 (h0 : function.extfun Type group) : @normalizer_condition.{0} (random_gen.{0} unsigned) (@function.extfun_app.{2 1} Type group.{0} h0 (random_gen.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_6757 (h0 : functor.add_const (group (has_add linarith.comp)) (has_add name)) : @group.fg.{0} (has_add.{0} linarith.comp) (@functor.add_const.run.{0 0} (group.{0} (has_add.{0} linarith.comp)) (has_add.{0} name) h0)  := sorry --non-trivial
lemma new_lemma_6758 (h0 : filter (has_zero (has_to_string (comm_group (has_to_string (has_add Type)))))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_6759 (h0 : uniform_space (left_cancel_semigroup (semiring (semiring unsigned)))) : separated_space (left_cancel_semigroup (semiring (semiring unsigned))) := sorry --non-trivial
lemma new_lemma_6760 (h0 : topological_space (add_group empty)) : preirreducible_space (add_group empty) := sorry --non-trivial
lemma new_lemma_6761 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : filter.ne_bot (function.extfun_app (function.extfun_app h0 filter) (boolean_algebra.core ennreal)) := sorry --non-trivial
lemma new_lemma_6762 (h0 : ring (has_compl (has_add to_additive.value_type))) : is_domain (has_compl (has_add to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_6763 (h0 : function.extfun Type topological_space) : @preconnected_space.{0} (monoid.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (monoid.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_6764 (h0 : ring (has_Inf (has_add linarith.comp))) : is_domain (has_Inf (has_add linarith.comp)) := sorry --non-trivial
lemma new_lemma_6765 (h0 : uniform_space (has_compl (random_gen fun_info))) : complete_space (has_compl (random_gen fun_info)) := sorry --non-trivial
lemma new_lemma_6766 (h0 : topological_space (finset (boolean_algebra pos))) : t0_space (finset (boolean_algebra pos)) := sorry --non-trivial
lemma new_lemma_6767 (h0 : ring (has_edist (option empty))) : is_domain (has_edist (option empty)) := sorry --non-trivial
lemma new_lemma_6768 (h0 : topological_space (preorder (option (option (option (option (option empty))))))) : t1_space (preorder (option (option (option (option (option empty)))))) := sorry --non-trivial
lemma new_lemma_6769 (h0 : topological_space (finset (option (option empty)))) : preirreducible_space (finset (option (option empty))) := sorry --non-trivial
lemma new_lemma_6770 (h0 : function.extfun Type (functor.add_const (topological_space znum))) : @t1_space.{0} znum (@functor.add_const.run.{0 0} (topological_space.{0} znum) num (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (topological_space.{0} znum)) h0 num))  := sorry --non-trivial
lemma new_lemma_6771 (h0 : add_group (finset (has_to_string (has_to_string congr_arg_kind)))) : is_add_cyclic (finset (has_to_string (has_to_string congr_arg_kind))) := sorry --non-trivial
lemma new_lemma_6772 (h0 : ring (has_norm (has_norm num))) : strong_rank_condition (has_norm (has_norm num)) := sorry --non-trivial
lemma new_lemma_6773 (h0 : complete_lattice (canonically_ordered_monoid (has_Inf (has_bot pos)))) : is_compactly_generated (canonically_ordered_monoid (has_Inf (has_bot pos))) := sorry --non-trivial
lemma new_lemma_6774 (h0 : not (uniform_space (add_cancel_comm_monoid to_additive.value_type) -> false)) : @complete_space.{0} (add_cancel_comm_monoid.{0} to_additive.value_type) (@classical.by_contradiction'.{1} (uniform_space.{0} (add_cancel_comm_monoid.{0} to_additive.value_type)) h0)  := sorry --non-trivial
lemma new_lemma_6775 (h0 : group (topological_space (random_gen (random_gen (random_gen (random_gen char)))))) : is_cyclic (topological_space (random_gen (random_gen (random_gen (random_gen char))))) := sorry --non-trivial
lemma new_lemma_6776 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @has_exists_mul_of_le.{0} (semigroup.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type ordered_comm_monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ordered_comm_monoid.{0}) (semigroup.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_6777 (h0 : topological_space (has_zero (finset pos))) : path_connected_space (has_zero (finset pos)) := sorry --non-trivial
lemma new_lemma_6778 (h0 : functor.add_const (ring (has_add linarith.comp)) pos) : @is_principal_ideal_ring.{0} (has_add.{0} linarith.comp) (@functor.add_const.run.{0 0} (ring.{0} (has_add.{0} linarith.comp)) pos h0)  := sorry --non-trivial
lemma new_lemma_6779 (h0 : ring (semiring fun_info)) : rank_condition (semiring fun_info) := sorry --non-trivial
lemma new_lemma_6780 (h0 : uniform_space (add_left_cancel_monoid (has_nnnorm fun_info))) : complete_space (add_left_cancel_monoid (has_nnnorm fun_info)) := sorry --non-trivial
lemma new_lemma_6781 (h0 : not (complete_lattice (has_norm empty) -> false)) : @is_compactly_generated.{0} (has_norm.{0} empty) (@classical.by_contradiction'.{1} (complete_lattice.{0} (has_norm.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_6782 (h0 : topological_space (finset (ordered_comm_monoid real))) : preconnected_space (finset (ordered_comm_monoid real)) := sorry --non-trivial
lemma new_lemma_6783 (h0 : topological_space (has_Inf (has_add (has_Inf (has_Inf pos))))) : loc_path_connected_space (has_Inf (has_add (has_Inf (has_Inf pos)))) := sorry --non-trivial
lemma new_lemma_6784 (h0 : has_mem.mem (id empty) has_emptyc.emptyc) : @is_cyclic.{0} (@id.{2} Type empty) (@finset.pi.empty.{1 0} Type group.{0} (@id.{2} Type empty) h0)  := sorry --non-trivial
lemma new_lemma_6785 (h0 : ring (finset linarith.comp)) : is_domain (finset linarith.comp) := sorry --non-trivial
lemma new_lemma_6786 (h0 : finset (bin_tree unsigned)) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_6787 (h0 : functor.add_const (ring (has_pos_part environment.implicit_infer_kind)) linarith.comp) : @rank_condition.{0} (has_pos_part.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (ring.{0} (has_pos_part.{0} environment.implicit_infer_kind)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_6788 (h0 : functor.add_const (function.extfun (Type 1) ring) environment.implicit_infer_kind) : @strong_rank_condition.{1} (boolean_algebra.{1} Type) (@function.extfun_app.{3 2} (Type 1) ring.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) ring.{1}) environment.implicit_infer_kind h0) (boolean_algebra.{1} Type))  := sorry --non-trivial
lemma new_lemma_6789 (h0 : functor.add_const (topological_space (comm_group unsigned)) (option unsigned)) : @sequential_space.{0} (comm_group.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (comm_group.{0} unsigned)) (option.{0} unsigned) h0)  := sorry --non-trivial
lemma new_lemma_6790 (h1 : ring ordering) : strong_rank_condition ordering := sorry --non-trivial
lemma new_lemma_6791 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_noetherian_ring.{0} (option.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type semiring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 semiring.{0}) (option.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_6792 (h0 : ring (linear_ordered_add_comm_group (has_norm (has_top (has_norm fun_info))))) : is_domain (linear_ordered_add_comm_group (has_norm (has_top (has_norm fun_info)))) := sorry --non-trivial
lemma new_lemma_6793 (h0 : topological_space (has_Inf (ordered_comm_monoid (ordered_comm_monoid real)))) : loc_path_connected_space (has_Inf (ordered_comm_monoid (ordered_comm_monoid real))) := sorry --non-trivial
lemma new_lemma_6794 (h0 : function.extfun Type topological_space) : @locally_compact_space.{0} (add_cancel_monoid.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (add_cancel_monoid.{0} name))  := sorry --non-trivial
lemma new_lemma_6795 (h0 : ring (random_gen (semiring (semiring empty)))) : rank_condition (random_gen (semiring (semiring empty))) := sorry --non-trivial
lemma new_lemma_6796 (h0 : functor.add_const (complete_lattice (non_assoc_semiring empty)) unsigned) : @is_compactly_generated.{0} (non_assoc_semiring.{0} empty) (@functor.add_const.run.{0 0} (complete_lattice.{0} (non_assoc_semiring.{0} empty)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_6797 (h0 : functor.add_const (group (ordered_comm_ring Type)) Type) : @group.fg.{1} (ordered_comm_ring.{1} Type) (@functor.add_const.run.{1 1} (group.{1} (ordered_comm_ring.{1} Type)) Type h0)  := sorry --non-trivial
lemma new_lemma_6798 (h0 : group (option (semiring (semiring (semiring num))))) : normalizer_condition (option (semiring (semiring (semiring num)))) := sorry --non-trivial
lemma new_lemma_6799 (h1 : filter char) : filter.ne_bot h1 := sorry --non-trivial
lemma new_lemma_6800 (h0 : group (canonically_ordered_comm_semiring (has_pos_part Type))) : is_cyclic (canonically_ordered_comm_semiring (has_pos_part Type)) := sorry --non-trivial
lemma new_lemma_6801 (h0 : monoid (has_top (semiring (semiring (semiring unsigned))))) : monoid.fg (has_top (semiring (semiring (semiring unsigned)))) := sorry --non-trivial
lemma new_lemma_6802 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @strong_rank_condition.{0} (partial_order.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (partial_order.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_6803 (h0 : ring (add_comm_monoid (has_nndist (has_add (has_add Type))))) : is_domain (add_comm_monoid (has_nndist (has_add (has_add Type)))) := sorry --non-trivial
lemma new_lemma_6804 (h0 : monoid (with_one (random_gen (random_gen num)))) : monoid.fg (with_one (random_gen (random_gen num))) := sorry --non-trivial
lemma new_lemma_6805 (h0 : ring (has_ssubset (random_gen linarith.ineq))) : is_domain (has_ssubset (random_gen linarith.ineq)) := sorry --non-trivial
lemma new_lemma_6806 (h0 : topological_space (has_nnnorm (has_top linarith.ineq))) : t0_space (has_nnnorm (has_top linarith.ineq)) := sorry --non-trivial
lemma new_lemma_6807 (h0 : group (filter (semiring (semiring empty)))) : normalizer_condition (filter (semiring (semiring empty))) := sorry --non-trivial
lemma new_lemma_6808 (h0 : functor.comp topological_space finset pos) : @irreducible_space.{0} (finset.{0} pos) (@functor.comp.run.{0 0 0} topological_space.{0} finset.{0} pos h0)  := sorry --non-trivial
lemma new_lemma_6809 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : finset.nonempty (function.extfun_app (function.extfun_app h0 finset) (has_star empty)) := sorry --non-trivial
lemma new_lemma_6810 (h0 : function.extfun Type topological_space) : @path_connected_space.{0} (with_one.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (with_one.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_6811 (h0 : function.extfun Type ordered_comm_monoid) : @has_exists_mul_of_le.{0} (has_neg.{0} unsigned) (@function.extfun_app.{2 1} Type ordered_comm_monoid.{0} h0 (has_neg.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_6812 (h0 : functor.add_const (topological_space (ring linarith.comp)) linarith.comp) : @totally_separated_space.{0} (ring.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (ring.{0} linarith.comp)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_6813 (h0 : function.extfun Type monoid) : @monoid.fg.{0} (has_top.{0} fun_info) (@function.extfun_app.{2 1} Type monoid.{0} h0 (has_top.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_6814 (h0 : add_group (add_cancel_monoid (option unsigned))) : is_add_cyclic (add_cancel_monoid (option unsigned)) := sorry --non-trivial
lemma new_lemma_6815 (h0 : function.extfun Type ring) : @rank_condition.{0} (canonically_linear_ordered_monoid.{0} pos) (@function.extfun_app.{2 1} Type ring.{0} h0 (canonically_linear_ordered_monoid.{0} pos))  := sorry --non-trivial
lemma new_lemma_6816 (h0 : functor.add_const (topological_space (complete_distrib_lattice linarith.comp)) name) : @topological_space.separable_space.{0} (complete_distrib_lattice.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (complete_distrib_lattice.{0} linarith.comp)) name h0)  := sorry --non-trivial
lemma new_lemma_6817 (h0 : functor.add_const (topological_space (has_add name)) name) : @locally_compact_space.{0} (has_add.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (has_add.{0} name)) name h0)  := sorry --non-trivial
lemma new_lemma_6818 (h0 : list (semiring empty)) : palindrome h0 := sorry --non-trivial
lemma new_lemma_6819 (h0 : functor.add_const (list (has_zero name)) environment.implicit_infer_kind) : list.nodup (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_6820 (h0 : group (complete_semilattice_Sup (has_top fun_info))) : is_cyclic (complete_semilattice_Sup (has_top fun_info)) := sorry --non-trivial
lemma new_lemma_6821 (h0 : function.extfun Type ring) : @is_domain.{0} (linear_ordered_semiring.{0} num) (@function.extfun_app.{2 1} Type ring.{0} h0 (linear_ordered_semiring.{0} num))  := sorry --non-trivial
lemma new_lemma_6822 (h0 : add_monoid (has_union (semiring empty))) : add_monoid.fg (has_union (semiring empty)) := sorry --non-trivial
lemma new_lemma_6823 (h0 : uniform_space (uniform_space (random_gen char))) : complete_space (uniform_space (random_gen char)) := sorry --non-trivial
lemma new_lemma_6824 (h0 : monoid (measurable_space (random_gen (random_gen (random_gen num))))) : monoid.fg (measurable_space (random_gen (random_gen (random_gen num)))) := sorry --non-trivial
lemma new_lemma_6825 (h0 : group (has_add real)) : is_cyclic (has_add real) := sorry --non-trivial
lemma new_lemma_6826 (h0 : functor.add_const (semiring (has_Sup unsigned)) (option unsigned)) : @is_noetherian_ring.{0} (has_Sup.{0} unsigned) (@functor.add_const.run.{0 0} (semiring.{0} (has_Sup.{0} unsigned)) (option.{0} unsigned) h0)  := sorry --non-trivial
lemma new_lemma_6827 (h0 : functor.add_const (topological_space (has_neg_part environment.implicit_infer_kind)) linarith.comp) : @normal_space.{0} (has_neg_part.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (has_neg_part.{0} environment.implicit_infer_kind)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_6828 (h0 : group (preorder (semiring (semiring empty)))) : normalizer_condition (preorder (semiring (semiring empty))) := sorry --non-trivial
lemma new_lemma_6829 (h1 : add_group (has_ssubset to_additive.value_type)) : is_add_cyclic (has_ssubset to_additive.value_type) := sorry --non-trivial
lemma new_lemma_6830 (h0 : functor.add_const (uniform_space (has_neg_part Type)) environment.implicit_infer_kind) : @separated_space.{1} (has_neg_part.{1} Type) (@functor.add_const.run.{1 0} (uniform_space.{1} (has_neg_part.{1} Type)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_6831 (h0 : topological_space (ring (option empty))) : normal_space (ring (option empty)) := sorry --non-trivial
lemma new_lemma_6832 (h0 : ring (add_cancel_monoid (has_add (has_add linarith.comp)))) : is_domain (add_cancel_monoid (has_add (has_add linarith.comp))) := sorry --non-trivial
lemma new_lemma_6833 (h0 : topological_space (semigroup (mul_one_class environment.implicit_infer_kind))) : locally_compact_space (semigroup (mul_one_class environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_6834 (h0 : function.extfun Type pseudo_metric_space) : @proper_space.{0} (with_one.{0} linarith.ineq) (@function.extfun_app.{2 1} Type pseudo_metric_space.{0} h0 (with_one.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_6835 (h0 : functor.add_const (complete_lattice (boolean_algebra linarith.comp)) (boolean_algebra linarith.comp)) : @is_compactly_generated.{0} (boolean_algebra.{0} linarith.comp) (@functor.add_const.run.{0 0} (complete_lattice.{0} (boolean_algebra.{0} linarith.comp)) (boolean_algebra.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_6836 (h0 : uniform_space (generalized_boolean_algebra (has_add (has_Inf pos)))) : separated_space (generalized_boolean_algebra (has_add (has_Inf pos))) := sorry --non-trivial
lemma new_lemma_6837 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @separated_space.{0} (has_neg_part.{0} pos) (@function.extfun_app.{2 1} Type uniform_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 uniform_space.{0}) (has_neg_part.{0} pos))  := sorry --non-trivial
lemma new_lemma_6838 (h0 : fin has_zero.zero) : @is_noetherian_ring.{0} (normed_lattice_add_comm_group.{0} real) (@matrix.vec_empty.{0} (semiring.{0} (normed_lattice_add_comm_group.{0} real)) h0)  := sorry --non-trivial
lemma new_lemma_6839 (h0 : function.extfun Type add_monoid) : @add_monoid.fg.{0} (complete_linear_order.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type add_monoid.{0} h0 (complete_linear_order.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_6840 (h0 : cancel_comm_monoid_with_zero (id (semiring unsigned))) : unique_factorization_monoid (id (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_6841 (h1 : function.extfun Type uniform_space) : @complete_space.{0} (has_norm.{0} string_imp) (@function.extfun_app.{2 1} Type uniform_space.{0} h1 (has_norm.{0} string_imp))  := sorry --non-trivial
lemma new_lemma_6842 (h0 : not (cancel_comm_monoid_with_zero (option congr_arg_kind) -> false)) : @unique_factorization_monoid.{0} (option.{0} congr_arg_kind) (@classical.by_contradiction'.{1} (cancel_comm_monoid_with_zero.{0} (option.{0} congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_6843 (h0 : complete_lattice (has_ssubset (has_lt reducibility_hints))) : is_compactly_generated (has_ssubset (has_lt reducibility_hints)) := sorry --non-trivial
lemma new_lemma_6844 (h0 : group (has_bot (has_Inf (has_Inf pos)))) : is_simple_group (has_bot (has_Inf (has_Inf pos))) := sorry --non-trivial
lemma new_lemma_6845 (h0 : function.extfun Type list) : palindrome (function.extfun_app h0 (ordered_cancel_add_comm_monoid unsigned)) := sorry --non-trivial
lemma new_lemma_6846 (h0 : topological_space (has_nndist (finset (finset (finset pos))))) : loc_path_connected_space (has_nndist (finset (finset (finset pos)))) := sorry --non-trivial
lemma new_lemma_6847 (h0 : functor.add_const (topological_space (boolean_algebra.core Type)) (has_neg (has_add name))) : @t0_space.{1} (boolean_algebra.core.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (boolean_algebra.core.{1} Type)) (has_neg.{0} (has_add.{0} name)) h0)  := sorry --non-trivial
lemma new_lemma_6848 (h0 : topological_space (fintype linarith.ineq)) : path_connected_space (fintype linarith.ineq) := sorry --non-trivial
lemma new_lemma_6849 (h0 : topological_space (linear_ordered_field (finset Type))) : totally_disconnected_space (linear_ordered_field (finset Type)) := sorry --non-trivial
lemma new_lemma_6850 (h0 : semiring (has_dist congr_arg_kind)) : is_noetherian_ring (has_dist congr_arg_kind) := sorry --non-trivial
lemma new_lemma_6851 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_add_cyclic.{0} (preorder.{0} num) (@function.extfun_app.{2 1} Type add_group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 add_group.{0}) (preorder.{0} num))  := sorry --non-trivial
lemma new_lemma_6852 (h0 : functor.add_const (ordered_add_comm_monoid (left_cancel_monoid unsigned)) empty) : @archimedean.{0} (left_cancel_monoid.{0} unsigned) (@functor.add_const.run.{0 0} (ordered_add_comm_monoid.{0} (left_cancel_monoid.{0} unsigned)) empty h0)  := sorry --non-trivial
lemma new_lemma_6853 (h0 : uniform_space (encodable linarith.ineq)) : complete_space (encodable linarith.ineq) := sorry --non-trivial
lemma new_lemma_6854 (h0 : fin has_zero.zero) : @is_noetherian_ring.{0} (add_comm_monoid.{0} linarith.comp) (@matrix.vec_empty.{0} (semiring.{0} (add_comm_monoid.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_6855 (h0 : function.extfun Type filter) : filter.ne_bot (function.extfun_app h0 (ring name)) := sorry --non-trivial
lemma new_lemma_6856 (h0 : functor.add_const (topological_space (boolean_algebra Type)) pos) : @topological_space.separable_space.{1} (boolean_algebra.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (boolean_algebra.{1} Type)) pos h0)  := sorry --non-trivial
lemma new_lemma_6857 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_add_cyclic.{0} (with_one.{0} fun_info) (@function.extfun_app.{2 1} Type add_group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 add_group.{0}) (with_one.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_6858 (h0 : topological_space (complete_distrib_lattice (option empty))) : path_connected_space (complete_distrib_lattice (option empty)) := sorry --non-trivial
lemma new_lemma_6859 (h0 : function.extfun Type ring) : @is_domain.{0} (filter.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type ring.{0} h0 (filter.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_6860 (h0 : functor.add_const (list pos) unsigned) : palindrome (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_6861 (h0 : ring (has_append (has_repr to_additive.value_type))) : rank_condition (has_append (has_repr to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_6862 (h0 : group (has_zero (normed_comm_ring pos))) : is_simple_group (has_zero (normed_comm_ring pos)) := sorry --non-trivial
lemma new_lemma_6863 (h1 : function.extfun Type topological_space) : @path_connected_space.{0} (random_gen.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type topological_space.{0} h1 (random_gen.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_6864 (h0 : ordered_comm_monoid (has_pos_part linarith.comp)) : has_exists_mul_of_le (has_pos_part linarith.comp) := sorry --non-trivial
lemma new_lemma_6865 (h0 : not (add_monoid (id unsigned) -> false)) : @add_monoid.fg.{0} (@id.{2} Type unsigned) (@classical.by_contradiction'.{1} (add_monoid.{0} (@id.{2} Type unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_6866 (h0 : filter (topological_space string_imp)) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_6867 (h0 : ring (has_top (random_gen (random_gen linarith.comp_source)))) : is_domain (has_top (random_gen (random_gen linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_6868 (h0 : has_le (denumerable string_imp)) (h1 : group (complete_semilattice_Sup (order_bot (denumerable string_imp)))) : group.fg (complete_semilattice_Sup (order_bot (denumerable string_imp))) := sorry --non-trivial
lemma new_lemma_6869 (h0 : group (semigroup num)) : group.fg (semigroup num) := sorry --non-trivial
lemma new_lemma_6870 (h0 : functor.add_const (ordered_add_comm_monoid (has_zero Type)) pos) : @archimedean.{1} (has_zero.{1} Type) (@functor.add_const.run.{1 0} (ordered_add_comm_monoid.{1} (has_zero.{1} Type)) pos h0)  := sorry --non-trivial
lemma new_lemma_6871 (h0 : ordered_comm_monoid (normed_comm_ring name)) : has_exists_mul_of_le (normed_comm_ring name) := sorry --non-trivial
lemma new_lemma_6872 (h1 : function.extfun (Type 1) option) (h2 : topological_space (option.lhoare linarith.comp_source (function.extfun_app h1 Type))) : locally_compact_space (option.lhoare linarith.comp_source (function.extfun_app h1 Type)) := sorry --non-trivial
lemma new_lemma_6873 (h0 : functor.add_const (topological_space (has_nndist environment.implicit_infer_kind)) Type) : @totally_disconnected_space.{0} (has_nndist.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 1} (topological_space.{0} (has_nndist.{0} environment.implicit_infer_kind)) Type h0)  := sorry --non-trivial
lemma new_lemma_6874 (h0 : functor.add_const (topological_space (finset linarith.comp)) environment.implicit_infer_kind) : @regular_space.{0} (finset.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (finset.{0} linarith.comp)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_6875 (h0 : functor.add_const (monoid (finset real)) real) : @monoid.fg.{0} (finset.{0} real) (@functor.add_const.run.{0 0} (monoid.{0} (finset.{0} real)) real h0)  := sorry --non-trivial
lemma new_lemma_6876 (h0 : has_mem.mem linarith.comp_source has_emptyc.emptyc) : @path_connected_space.{0} linarith.comp_source (@finset.pi.empty.{1 0} Type topological_space.{0} linarith.comp_source h0)  := sorry --non-trivial
lemma new_lemma_6877 (h0 : topological_space (comm_group Type)) : regular_space (comm_group Type) := sorry --non-trivial
lemma new_lemma_6878 (h0 : function.extfun Type group) : @group.fg.{0} (has_nnnorm.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type group.{0} h0 (has_nnnorm.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_6879 (h0 : function.extfun Type complete_lattice) : @complete_lattice.is_Sup_finite_compact.{0} (ordered_comm_ring.{0} name) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (ordered_comm_ring.{0} name))  := sorry --non-trivial
lemma new_lemma_6880 (h0 : functor.add_const (ordered_comm_monoid (has_neg_part name)) linarith.comp) : @has_exists_mul_of_le.{0} (has_neg_part.{0} name) (@functor.add_const.run.{0 0} (ordered_comm_monoid.{0} (has_neg_part.{0} name)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_6881 (h0 : uniform_space (functor.const linarith.comp linarith.comp)) : separated_space (functor.const linarith.comp linarith.comp) := sorry --non-trivial
lemma new_lemma_6882 (h0 : not (complete_lattice (div_inv_monoid fun_info) -> false)) : @complete_lattice.is_Sup_finite_compact.{0} (div_inv_monoid.{0} fun_info) (@classical.by_contradiction'.{1} (complete_lattice.{0} (div_inv_monoid.{0} fun_info)) h0)  := sorry --non-trivial
lemma new_lemma_6883 (h0 : complete_lattice (has_to_string linarith.comp)) : complete_lattice.is_Sup_finite_compact (has_to_string linarith.comp) := sorry --non-trivial
lemma new_lemma_6884 (h0 : ring (normed_field (comm_ring reducibility_hints))) : rank_condition (normed_field (comm_ring reducibility_hints)) := sorry --non-trivial
lemma new_lemma_6885 (h0 : function.extfun Type (functor.add_const (add_group auto.case_option))) : @is_add_cyclic.{0} auto.case_option (@functor.add_const.run.{0 0} (add_group.{0} auto.case_option) (option.{0} unsigned) (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (add_group.{0} auto.case_option)) h0 (option.{0} unsigned)))  := sorry --non-trivial
lemma new_lemma_6886 (h0 : functor.add_const (functor.add_const (uniform_space (add_cancel_monoid empty)) empty) (semiring (semiring empty))) : @complete_space.{0} (add_cancel_monoid.{0} empty) (@functor.add_const.run.{0 0} (uniform_space.{0} (add_cancel_monoid.{0} empty)) empty (@functor.add_const.run.{0 0} (functor.add_const.{0 0} (uniform_space.{0} (add_cancel_monoid.{0} empty)) empty) (semiring.{0} (semiring.{0} empty)) h0))  := sorry --non-trivial
lemma new_lemma_6887 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @irreducible_space.{0} (@id.{2} Type linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (@id.{2} Type linarith.comp))  := sorry --non-trivial
lemma new_lemma_6888 (h0 : functor.add_const (functor.add_const (topological_space znum) empty) empty) : @totally_disconnected_space.{0} znum (@functor.add_const.run.{0 0} (topological_space.{0} znum) empty (@functor.add_const.run.{0 0} (functor.add_const.{0 0} (topological_space.{0} znum) empty) empty h0))  := sorry --non-trivial
lemma new_lemma_6889 (h0 : has_mem.mem (random_gen fun_info) has_emptyc.emptyc) : @is_cyclic.{0} (random_gen.{0} fun_info) (@finset.pi.empty.{1 0} Type group.{0} (random_gen.{0} fun_info) h0)  := sorry --non-trivial
lemma new_lemma_6890 (h0 : function.extfun Type topological_space) : @totally_disconnected_space.{0} (metric_space.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (metric_space.{0} num))  := sorry --non-trivial
lemma new_lemma_6891 (h0 : functor.add_const (topological_space (ordered_comm_ring Type)) Type) : @irreducible_space.{1} (ordered_comm_ring.{1} Type) (@functor.add_const.run.{1 1} (topological_space.{1} (ordered_comm_ring.{1} Type)) Type h0)  := sorry --non-trivial
lemma new_lemma_6892 (h0 : finset (ordered_comm_monoid (finset Type))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_6893 (h1 : complete_lattice (simple_graph fun_info)) : complete_lattice.is_Sup_finite_compact (simple_graph fun_info) := sorry --non-trivial
lemma new_lemma_6894 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @separated_space.{0} (has_to_string.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type uniform_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 uniform_space.{0}) (has_to_string.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_6895 (h0 : functor.add_const (complete_lattice (add_comm_monoid unsigned)) unsigned) : @complete_lattice.is_Sup_finite_compact.{0} (add_comm_monoid.{0} unsigned) (@functor.add_const.run.{0 0} (complete_lattice.{0} (add_comm_monoid.{0} unsigned)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_6896 (h0 : topological_space (add_group empty)) : totally_separated_space (add_group empty) := sorry --non-trivial
lemma new_lemma_6897 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @loc_path_connected_space.{0} (has_dist.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_dist.{0} empty))  := sorry --non-trivial
lemma new_lemma_6898 (h0 : functor.comp list has_nndist Type) : palindrome (functor.comp.run h0) := sorry --non-trivial
lemma new_lemma_6899 (h0 : complete_lattice (has_top (semiring (semiring (semiring empty))))) : complete_lattice.is_Sup_finite_compact (has_top (semiring (semiring (semiring empty)))) := sorry --non-trivial
lemma new_lemma_6900 (h0 : functor.add_const (list (has_Inf pos)) linarith.comp) : palindrome (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_6901 (h1 : measurable_space (add_comm_semigroup fun_info)) (h2 : set (add_comm_semigroup fun_info)) : measurable_set h2 := sorry --non-trivial
lemma new_lemma_6902 (h0 : topological_space (has_Inf real)) : sequential_space (has_Inf real) := sorry --non-trivial
lemma new_lemma_6903 (h0 : functor.add_const (add_monoid (ring name)) linarith.comp) : @add_monoid.fg.{0} (ring.{0} name) (@functor.add_const.run.{0 0} (add_monoid.{0} (ring.{0} name)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_6904 (h0 : function.extfun Type topological_space) : @discrete_topology.{0} (ring.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (ring.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_6905 (h0 : has_mem.mem (metric_space linarith.comp) has_emptyc.emptyc) : @normal_space.{0} (metric_space.{0} linarith.comp) (@finset.pi.empty.{1 0} Type topological_space.{0} (metric_space.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_6906 (h0 : topological_space (with_one (linear_ordered_semiring unsigned))) : discrete_topology (with_one (linear_ordered_semiring unsigned)) := sorry --non-trivial
lemma new_lemma_6907 (h0 : functor.add_const (topological_space (has_add linarith.comp)) name) : @loc_path_connected_space.{0} (has_add.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (has_add.{0} linarith.comp)) name h0)  := sorry --non-trivial
lemma new_lemma_6908 (h0 : complete_lattice (has_pos_part (has_bot real))) : complete_lattice.is_Sup_finite_compact (has_pos_part (has_bot real)) := sorry --non-trivial
lemma new_lemma_6909 (h0 : functor.add_const (add_group (partial_order congr_arg_kind)) empty) : @is_add_cyclic.{0} (partial_order.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (add_group.{0} (partial_order.{0} congr_arg_kind)) empty h0)  := sorry --non-trivial
lemma new_lemma_6910 (h0 : filter (semigroup (option empty))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_6911 (h0 : functor.add_const (group (boolean_algebra.core pos)) (option name)) : @is_cyclic.{0} (boolean_algebra.core.{0} pos) (@functor.add_const.run.{0 0} (group.{0} (boolean_algebra.core.{0} pos)) (option.{0} name) h0)  := sorry --non-trivial
lemma new_lemma_6912 (h0 : topological_space (linear_ordered_field (option (option (option unsigned))))) : totally_separated_space (linear_ordered_field (option (option (option unsigned)))) := sorry --non-trivial
lemma new_lemma_6913 (h0 : topological_space (boolean_algebra (has_neg (has_neg linarith.comp)))) : loc_path_connected_space (boolean_algebra (has_neg (has_neg linarith.comp))) := sorry --non-trivial
lemma new_lemma_6914 (h0 : functor.add_const (filter (comm_group linarith.comp)) name) : filter.ne_bot (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_6915 (h0 : add_monoid (sub_neg_monoid linarith.comp)) : add_monoid.fg (sub_neg_monoid linarith.comp) := sorry --non-trivial
lemma new_lemma_6916 (h0 : functor.add_const (ring (has_add name)) name) : @is_principal_ideal_ring.{0} (has_add.{0} name) (@functor.add_const.run.{0 0} (ring.{0} (has_add.{0} name)) name h0)  := sorry --non-trivial
lemma new_lemma_6917 (h0 : not (complete_lattice (non_unital_non_assoc_semiring to_additive.value_type) -> false)) : @is_compactly_generated.{0} (non_unital_non_assoc_semiring.{0} to_additive.value_type) (@classical.by_contradiction'.{1} (complete_lattice.{0} (non_unital_non_assoc_semiring.{0} to_additive.value_type)) h0)  := sorry --non-trivial
lemma new_lemma_6918 (h0 : non_assoc_semiring (ordered_ring empty) -> non_assoc_semiring (ordered_ring empty) -> Prop) : is_refl (non_assoc_semiring (ordered_ring empty)) h0 := sorry --non-trivial
lemma new_lemma_6919 (h0 : function.extfun Type group) : @normalizer_condition.{0} (normed_comm_ring.{0} ennreal) (@function.extfun_app.{2 1} Type group.{0} h0 (normed_comm_ring.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_6920 (h0 : monoid (with_bot (has_top (has_top linarith.comp_source)))) : monoid.fg (with_bot (has_top (has_top linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_6921 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @discrete_topology.{0} (has_add.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_add.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_6922 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @path_connected_space.{0} (has_nndist.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_nndist.{0} empty))  := sorry --non-trivial
lemma new_lemma_6923 (h0 : not (has_mem.mem (has_norm num) has_emptyc.emptyc -> false)) : @is_cyclic.{0} (has_norm.{0} num) (@finset.pi.empty.{1 0} Type group.{0} (has_norm.{0} num) (@classical.by_contradiction'.{0} (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (has_norm.{0} num) (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))) h0))  := sorry --non-trivial
lemma new_lemma_6924 (h0 : function.extfun Type cancel_comm_monoid_with_zero) : @unique_factorization_monoid.{0} (sub_neg_monoid.{0} real) (@function.extfun_app.{2 1} Type cancel_comm_monoid_with_zero.{0} h0 (sub_neg_monoid.{0} real))  := sorry --non-trivial
lemma new_lemma_6925 (h0 : not (add_group (linear_ordered_semiring fun_info) -> false)) : @is_add_cyclic.{0} (linear_ordered_semiring.{0} fun_info) (@classical.by_contradiction'.{1} (add_group.{0} (linear_ordered_semiring.{0} fun_info)) h0)  := sorry --non-trivial
lemma new_lemma_6926 (h0 : functor.add_const (topological_space (ordered_cancel_add_comm_monoid empty)) unsigned) : @totally_separated_space.{0} (ordered_cancel_add_comm_monoid.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (ordered_cancel_add_comm_monoid.{0} empty)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_6927 (h0 : not (ring (random_gen num) -> false)) : @is_domain.{0} (random_gen.{0} num) (@classical.by_contradiction'.{1} (ring.{0} (random_gen.{0} num)) h0)  := sorry --non-trivial
lemma new_lemma_6928 (h0 : function.extfun Type (functor.comp topological_space semigroup)) : @normal_space.{0} (semigroup.{0} pos) (@functor.comp.run.{0 0 0} topological_space.{0} semigroup.{0} pos (@function.extfun_app.{2 1} Type (functor.comp.{0 0 0} topological_space.{0} semigroup.{0}) h0 pos))  := sorry --non-trivial
lemma new_lemma_6929 (h0 : ring (non_assoc_semiring (semiring empty))) : is_principal_ideal_ring (non_assoc_semiring (semiring empty)) := sorry --non-trivial
lemma new_lemma_6930 (h1 : complete_lattice (mul_one_class to_additive.value_type)) : complete_lattice.is_Sup_finite_compact (mul_one_class to_additive.value_type) := sorry --non-trivial
lemma new_lemma_6931 (h0 : topological_space (metric_space (has_norm num))) : t0_space (metric_space (has_norm num)) := sorry --non-trivial
lemma new_lemma_6932 (h0 : topological_space (complete_distrib_lattice (ring Type))) : irreducible_space (complete_distrib_lattice (ring Type)) := sorry --non-trivial
lemma new_lemma_6933 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @irreducible_space.{0} (with_one.{0} linarith.ineq) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (with_one.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_6934 (h0 : group (semigroup (semiring empty))) : is_cyclic (semigroup (semiring empty)) := sorry --non-trivial
lemma new_lemma_6935 (h0 : functor.add_const (complete_lattice (has_nndist environment.implicit_infer_kind)) environment.implicit_infer_kind) : @is_compactly_generated.{0} (has_nndist.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (complete_lattice.{0} (has_nndist.{0} environment.implicit_infer_kind)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_6936 (h0 : function.extfun Type ring) : @is_principal_ideal_ring.{0} (has_bot.{0} unsigned) (@function.extfun_app.{2 1} Type ring.{0} h0 (has_bot.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_6937 (h0 : functor.add_const (ring (free_add_monoid congr_arg_kind)) unsigned) : @is_domain.{0} (free_add_monoid.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (ring.{0} (free_add_monoid.{0} congr_arg_kind)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_6938 (h0 : ring (nondiscrete_normed_field (normed_field (normed_field char)))) : strong_rank_condition (nondiscrete_normed_field (normed_field (normed_field char))) := sorry --non-trivial
lemma new_lemma_6939 (h0 : topological_space (boolean_algebra (comm_group (comm_group Type)))) : sequential_space (boolean_algebra (comm_group (comm_group Type))) := sorry --non-trivial
lemma new_lemma_6940 (h0 : topological_space (has_neg (finset (finset pos)))) : regular_space (has_neg (finset (finset pos))) := sorry --non-trivial
lemma new_lemma_6941 (h8 : not (uniform_space (topological_space reducibility_hints) -> false)) : @complete_space.{0} (topological_space.{0} reducibility_hints) (@classical.by_contradiction'.{1} (uniform_space.{0} (topological_space.{0} reducibility_hints)) h8)  := sorry --non-trivial
lemma new_lemma_6942 (h0 : topological_space (semi_normed_comm_ring (has_inv fun_info))) : t0_space (semi_normed_comm_ring (has_inv fun_info)) := sorry --non-trivial
lemma new_lemma_6943 (h0 : filter (comm_group (option pos))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_6944 (h0 : topological_space (has_add (has_add real))) : regular_space (has_add (has_add real)) := sorry --non-trivial
lemma new_lemma_6945 (h0 : has_star empty -> has_star empty -> Prop) : is_strict_order (has_star empty) h0 := sorry --non-trivial
lemma new_lemma_6946 (h0 : not (group (left_cancel_semigroup congr_arg_kind) -> false)) : @is_cyclic.{0} (left_cancel_semigroup.{0} congr_arg_kind) (@classical.by_contradiction'.{1} (group.{0} (left_cancel_semigroup.{0} congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_6947 (h0 : not (function.extfun Type complete_lattice -> false)) : @is_atomistic.{0} (measurable_space.dynkin_system.{0} unsigned) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type complete_lattice.{0}) h0) (measurable_space.dynkin_system.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_6948 (h0 : ring (has_neg (boolean_algebra.core linarith.comp))) : rank_condition (has_neg (boolean_algebra.core linarith.comp)) := sorry --non-trivial
lemma new_lemma_6949 (h0 : ring (semiring (random_gen fun_info))) : strong_rank_condition (semiring (random_gen fun_info)) := sorry --non-trivial
lemma new_lemma_6950 (h0 : topological_space (add_cancel_monoid (has_to_string name))) : topological_space.separable_space (add_cancel_monoid (has_to_string name)) := sorry --non-trivial
lemma new_lemma_6951 (h1 : topological_space (has_ssubset std_gen)) (h2 : add_group (has_ssubset std_gen)) : topological_add_group (has_ssubset std_gen) := sorry --non-trivial
lemma new_lemma_6952 (h0 : functor.add_const (topological_space (ordered_comm_monoid Type)) name) : @preconnected_space.{1} (ordered_comm_monoid.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (ordered_comm_monoid.{1} Type)) name h0)  := sorry --non-trivial
lemma new_lemma_6953 (h0 : add_group (has_emptyc linarith.comp_source)) : is_add_cyclic (has_emptyc linarith.comp_source) := sorry --non-trivial
lemma new_lemma_6954 (h0 : topological_space (comm_semigroup pos)) : sequential_space (comm_semigroup pos) := sorry --non-trivial
lemma new_lemma_6955 (h0 : functor.add_const (topological_space (has_add environment.implicit_infer_kind)) linarith.comp) : @preirreducible_space.{0} (has_add.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (has_add.{0} environment.implicit_infer_kind)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_6956 (h0 : functor.add_const (group (semigroup Type)) (has_add environment.implicit_infer_kind)) : @group.fg.{1} (semigroup.{1} Type) (@functor.add_const.run.{1 0} (group.{1} (semigroup.{1} Type)) (has_add.{0} environment.implicit_infer_kind) h0)  := sorry --non-trivial
lemma new_lemma_6957 (h1 : not (add_group (add_monoid to_additive.value_type) -> false)) : @is_add_cyclic.{0} (add_monoid.{0} to_additive.value_type) (@classical.by_contradiction'.{1} (add_group.{0} (add_monoid.{0} to_additive.value_type)) h1)  := sorry --non-trivial
lemma new_lemma_6958 (h0 : finset (semigroup unsigned)) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_6959 (h0 : topological_space (measurable_space string_imp)) : totally_separated_space (measurable_space string_imp) := sorry --non-trivial
lemma new_lemma_6960 (h0 : not (function.extfun Type complete_lattice -> false)) : is_atomistic (measurable_space congr_arg_kind) := sorry --non-trivial
lemma new_lemma_6961 (h0 : monoid (canonically_linear_ordered_monoid (has_bot (has_bot (has_Inf Type))))) : monoid.fg (canonically_linear_ordered_monoid (has_bot (has_bot (has_Inf Type)))) := sorry --non-trivial
lemma new_lemma_6962 (h0 : topological_space (measurable_space (random_gen congr_arg_kind))) : discrete_topology (measurable_space (random_gen congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_6963 (h0 : functor.add_const (uniform_space (canonically_ordered_comm_semiring linarith.comp)) Type) : @complete_space.{0} (canonically_ordered_comm_semiring.{0} linarith.comp) (@functor.add_const.run.{0 1} (uniform_space.{0} (canonically_ordered_comm_semiring.{0} linarith.comp)) Type h0)  := sorry --non-trivial
lemma new_lemma_6964 (h0 : uniform_space (finset (has_Inf Type))) : complete_space (finset (has_Inf Type)) := sorry --non-trivial
lemma new_lemma_6965 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : loc_path_connected_space real := sorry --non-trivial
lemma new_lemma_6966 (h0 : complete_lattice (ordered_comm_ring (has_add (has_Inf linarith.comp)))) : is_compactly_generated (ordered_comm_ring (has_add (has_Inf linarith.comp))) := sorry --non-trivial
lemma new_lemma_6967 (h0 : not (function.extfun Type topological_space -> false)) : @totally_disconnected_space.{0} (left_cancel_semigroup.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (left_cancel_semigroup.{0} num))  := sorry --non-trivial
lemma new_lemma_6968 (h0 : functor.add_const (topological_space (has_add pos)) pos) : @path_connected_space.{0} (has_add.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (has_add.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_6969 (h0 : group (has_nnnorm (uniform_space string_imp))) : is_cyclic (has_nnnorm (uniform_space string_imp)) := sorry --non-trivial
lemma new_lemma_6970 (h0 : ring (canonically_linear_ordered_monoid (option (option ennreal)))) : strong_rank_condition (canonically_linear_ordered_monoid (option (option ennreal))) := sorry --non-trivial
lemma new_lemma_6971 (h0 : topological_space (finset (finset pos))) : discrete_topology (finset (finset pos)) := sorry --non-trivial
lemma new_lemma_6972 (h0 : fin has_zero.zero) : @group.fg.{0} (normed_lattice_add_comm_group.{0} pos) (@matrix.vec_empty.{0} (group.{0} (normed_lattice_add_comm_group.{0} pos)) (@matrix.vec_empty.{0} (fin (@has_zero.zero.{0} nat nat.has_zero)) h0))  := sorry --non-trivial
lemma new_lemma_6973 (h0 : filter (has_nndist (finset (finset (finset linarith.comp))))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_6974 (h0 : functor.add_const (topological_space (boolean_algebra.core name)) name) : @discrete_topology.{0} (boolean_algebra.core.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (boolean_algebra.core.{0} name)) name h0)  := sorry --non-trivial
lemma new_lemma_6975 (h0 : function.extfun Type group) : @is_cyclic.{0} (comm_ring.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type group.{0} h0 (comm_ring.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_6976 (h0 : topological_space (has_neg_part (has_add name))) : irreducible_space (has_neg_part (has_add name)) := sorry --non-trivial
lemma new_lemma_6977 (h0 : functor.comp complete_lattice has_neg environment.implicit_infer_kind) : @is_compactly_generated.{0} (has_neg.{0} environment.implicit_infer_kind) (@functor.comp.run.{0 0 0} complete_lattice.{0} has_neg.{0} environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_6978 (h1 : topological_space (div_inv_monoid linarith.ineq)) : totally_disconnected_space (div_inv_monoid linarith.ineq) := sorry --non-trivial
lemma new_lemma_6979 (h0 : function.extfun Type filter) : countable_Inter_filter (function.extfun_app h0 (has_to_string pos)) := sorry --non-trivial
lemma new_lemma_6980 (h0 : group reducibility_hints) : is_cyclic reducibility_hints := sorry --non-trivial
lemma new_lemma_6981 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @group.fg.{0} (@id.{2} Type empty) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (@id.{2} Type empty))  := sorry --non-trivial
lemma new_lemma_6982 (h0 : topological_space (canonically_linear_ordered_monoid ennreal)) : totally_separated_space (canonically_linear_ordered_monoid ennreal) := sorry --non-trivial
lemma new_lemma_6983 (h0 : topological_space (linear_ordered_comm_monoid_with_zero congr_arg_kind)) : totally_disconnected_space (linear_ordered_comm_monoid_with_zero congr_arg_kind) := sorry --non-trivial
lemma new_lemma_6984 (h0 : function.extfun Type topological_space) : @irreducible_space.{0} (encodable.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (encodable.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_6985 (h0 : topological_space (distrib linarith.ineq)) : totally_disconnected_space (distrib linarith.ineq) := sorry --non-trivial
lemma new_lemma_6986 (h0 : list (complete_distrib_lattice (option unsigned))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_6987 (h0 : functor.add_const (filter (has_neg_part name)) pos) : countable_Inter_filter (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_6988 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @has_exists_mul_of_le.{0} (normed_lattice_add_comm_group.{0} name) (@function.extfun_app.{2 1} Type ordered_comm_monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ordered_comm_monoid.{0}) (normed_lattice_add_comm_group.{0} name))  := sorry --non-trivial
lemma new_lemma_6989 (h0 : function.extfun Type (functor.add_const (ring auto.case_option))) : @rank_condition.{0} auto.case_option (@functor.add_const.run.{0 0} (ring.{0} auto.case_option) empty (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (ring.{0} auto.case_option)) h0 empty))  := sorry --non-trivial
lemma new_lemma_6990 (h0 : fin has_zero.zero) : @preconnected_space.{0} (comm_semigroup.{0} pos) (@matrix.vec_empty.{0} (topological_space.{0} (comm_semigroup.{0} pos)) h0)  := sorry --non-trivial
lemma new_lemma_6991 (h0 : topological_space (add_cancel_monoid (option ennreal))) : t1_space (add_cancel_monoid (option ennreal)) := sorry --non-trivial
lemma new_lemma_6992 (h0 : functor.add_const (topological_space (add_comm_monoid name)) linarith.comp) : @discrete_topology.{0} (add_comm_monoid.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (add_comm_monoid.{0} name)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_6993 (h0 : topological_space (cancel_monoid (comm_group Type))) : locally_compact_space (cancel_monoid (comm_group Type)) := sorry --non-trivial
lemma new_lemma_6994 (h0 : uniform_space (nondiscrete_normed_field fun_info)) : complete_space (nondiscrete_normed_field fun_info) := sorry --non-trivial
lemma new_lemma_6995 (h0 : functor.add_const (function.extfun Type complete_lattice) (option pos)) : @is_compactly_generated.{0} (finset.{0} (canonically_linear_ordered_monoid.{0} unsigned)) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type complete_lattice.{0}) (option.{0} pos) h0) (finset.{0} (canonically_linear_ordered_monoid.{0} unsigned)))  := sorry --non-trivial
lemma new_lemma_6996 (h0 : topological_space (has_nnnorm (has_nnnorm (has_compl string.iterator_imp)))) : t0_space (has_nnnorm (has_nnnorm (has_compl string.iterator_imp))) := sorry --non-trivial
lemma new_lemma_6997 (h1 : uniform_space (normed_field (non_unital_non_assoc_semiring char))) : complete_space (normed_field (non_unital_non_assoc_semiring char)) := sorry --non-trivial
lemma new_lemma_6998 (h0 : complete_lattice (has_nndist unsigned)) : complete_lattice.is_Sup_finite_compact (has_nndist unsigned) := sorry --non-trivial
lemma new_lemma_6999 (h0 : function.extfun Type topological_space) : @discrete_topology.{0} (complete_semilattice_Sup.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (complete_semilattice_Sup.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_7000 (h0 : functor.add_const (topological_space (has_neg environment.implicit_infer_kind)) name) : @locally_compact_space.{0} (has_neg.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (has_neg.{0} environment.implicit_infer_kind)) name h0)  := sorry --non-trivial
lemma new_lemma_7001 (h0 : not (topological_space (has_add linarith.comp_source) -> false)) : @path_connected_space.{0} (has_add.{0} linarith.comp_source) (@classical.by_contradiction'.{1} (topological_space.{0} (has_add.{0} linarith.comp_source)) h0)  := sorry --non-trivial
lemma new_lemma_7002 (h0 : filter (random_gen fun_info)) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_7003 (h0 : not (function.extfun Type topological_space -> false)) : @locally_compact_space.{0} (encodable.{0} fun_info) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (encodable.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_7004 (h0 : not (topological_space (complete_linear_order empty) -> false)) : @irreducible_space.{0} (complete_linear_order.{0} empty) (@classical.by_contradiction'.{1} (topological_space.{0} (complete_linear_order.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_7005 (h0 : function.extfun (finset (Type -> Type)) (has_mem.mem group)) : @is_cyclic.{0} (semiring.{0} linarith.ineq) (@function.extfun_app.{2 1} Type group.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) group.{0} (@function.extfun_app.{2 0} (finset.{1} (Type → Type)) (@has_mem.mem.{1 1} (Type → Type) (finset.{1} (Type → Type)) (@finset.has_mem.{1} (Type → Type)) group.{0}) h0 (@has_emptyc.emptyc.{1} (finset.{1} (Type → Type)) (@finset.has_emptyc.{1} (Type → Type))))) (semiring.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_7006 (h0 : ring (semigroup congr_arg_kind)) : is_principal_ideal_ring (semigroup congr_arg_kind) := sorry --non-trivial
lemma new_lemma_7007 (h0 : functor.comp filter mul_zero_class Type) : countable_Inter_filter (functor.comp.run h0) := sorry --non-trivial
lemma new_lemma_7008 (h1 : not (topological_space (has_norm fun_info) -> false)) : @locally_compact_space.{0} (has_norm.{0} fun_info) (@classical.by_contradiction'.{1} (topological_space.{0} (has_norm.{0} fun_info)) h1)  := sorry --non-trivial
lemma new_lemma_7009 (h0 : complete_lattice (div_inv_monoid linarith.ineq)) : complete_lattice.is_Sup_finite_compact (div_inv_monoid linarith.ineq) := sorry --non-trivial
lemma new_lemma_7010 (h0 : ring (as_linear_order empty)) : rank_condition (as_linear_order empty) := sorry --non-trivial
lemma new_lemma_7011 (h0 : functor.add_const (group (ring pos)) (has_to_string (has_to_string name))) : @normalizer_condition.{0} (ring.{0} pos) (@functor.add_const.run.{0 0} (group.{0} (ring.{0} pos)) (has_to_string.{0} (has_to_string.{0} name)) h0)  := sorry --non-trivial
lemma new_lemma_7012 (h0 : list (ordered_cancel_add_comm_monoid (ring pos))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_7013 (h0 : ordered_comm_monoid (simple_graph (finset linarith.comp))) : has_exists_mul_of_le (simple_graph (finset linarith.comp)) := sorry --non-trivial
lemma new_lemma_7014 (h0 : ring (ring (option empty))) : is_principal_ideal_ring (ring (option empty)) := sorry --non-trivial
lemma new_lemma_7015 (h0 : topological_space (ring (has_add environment.implicit_infer_kind))) : topological_space.separable_space (ring (has_add environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_7016 (h0 : topological_space (ring (has_add environment.implicit_infer_kind))) : t1_space (ring (has_add environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_7017 (h0 : topological_space (linear_ordered_semiring num)) : t0_space (linear_ordered_semiring num) := sorry --non-trivial
lemma new_lemma_7018 (h0 : complete_lattice (semiring (semiring (semiring unsigned)))) : is_atomistic (semiring (semiring (semiring unsigned))) := sorry --non-trivial
lemma new_lemma_7019 (h0 : complete_lattice (has_Sup linarith.ineq)) : complete_lattice.is_Sup_finite_compact (has_Sup linarith.ineq) := sorry --non-trivial
lemma new_lemma_7020 (h0 : topological_space (random_gen (has_top num))) : path_connected_space (random_gen (has_top num)) := sorry --non-trivial
lemma new_lemma_7021 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @unique_factorization_monoid.{1} (boolean_algebra.{1} Type) (@function.extfun_app.{3 2} (Type 1) cancel_comm_monoid_with_zero.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 cancel_comm_monoid_with_zero.{1}) (boolean_algebra.{1} Type))  := sorry --non-trivial
lemma new_lemma_7022 (h0 : ring (uniform_space (mul_one_class reducibility_hints))) : rank_condition (uniform_space (mul_one_class reducibility_hints)) := sorry --non-trivial
lemma new_lemma_7023 (h0 : topological_space (canonically_ordered_comm_semiring (has_pos_part pos))) : totally_separated_space (canonically_ordered_comm_semiring (has_pos_part pos)) := sorry --non-trivial
lemma new_lemma_7024 (h0 : functor.add_const (topological_space (has_nndist Type)) (normed_comm_ring name)) : @totally_separated_space.{1} (has_nndist.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (has_nndist.{1} Type)) (normed_comm_ring.{0} name) h0)  := sorry --non-trivial
lemma new_lemma_7025 (h0 : has_mem.mem add_group has_emptyc.emptyc) : @is_add_cyclic.{0} (left_cancel_monoid.{0} linarith.comp) (@function.extfun_app.{2 1} Type add_group.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) add_group.{0} h0) (left_cancel_monoid.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_7026 (h0 : complete_lattice (has_zero (option ennreal))) : is_atomistic (has_zero (option ennreal)) := sorry --non-trivial
lemma new_lemma_7027 (h0 : function.extfun Type topological_space) : @normal_space.{0} (bin_tree.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (bin_tree.{0} empty))  := sorry --non-trivial
lemma new_lemma_7028 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @group.fg.{0} (has_zero.{0} unsigned) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (has_zero.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_7029 (h0 : complete_lattice (preorder (option num))) : complete_lattice.is_Sup_finite_compact (preorder (option num)) := sorry --non-trivial
lemma new_lemma_7030 (h0 : group (has_zero (has_neg_part pos))) : is_cyclic (has_zero (has_neg_part pos)) := sorry --non-trivial
lemma new_lemma_7031 (h0 : functor.add_const (ordered_add_comm_monoid (has_pos_part linarith.comp)) (has_Inf name)) : @archimedean.{0} (has_pos_part.{0} linarith.comp) (@functor.add_const.run.{0 0} (ordered_add_comm_monoid.{0} (has_pos_part.{0} linarith.comp)) (has_Inf.{0} name) h0)  := sorry --non-trivial
lemma new_lemma_7032 (h0 : prod (monoid (option (option (option ennreal)))) (monoid (option (option (option ennreal))))) : id_rel h0 := sorry --non-trivial
lemma new_lemma_7033 (h0 : function.extfun Type topological_space) : @irreducible_space.{0} (normed_comm_ring.{0} (option.{0} (option.{0} (option.{0} ennreal)))) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (normed_comm_ring.{0} (option.{0} (option.{0} (option.{0} ennreal)))))  := sorry --non-trivial
lemma new_lemma_7034 (h0 : topological_space (semigroup unsigned)) : totally_separated_space (semigroup unsigned) := sorry --non-trivial
lemma new_lemma_7035 (h0 : complete_lattice (linear_ordered_comm_group_with_zero string_imp)) : complete_lattice.is_Sup_finite_compact (linear_ordered_comm_group_with_zero string_imp) := sorry --non-trivial
lemma new_lemma_7036 (h0 : function.extfun Type complete_lattice) : @complete_lattice.is_Sup_finite_compact.{0} (has_inner.{0 0} (option.{0} (option.{0} unsigned)) num) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (has_inner.{0 0} (option.{0} (option.{0} unsigned)) num))  := sorry --non-trivial
lemma new_lemma_7037 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_compactly_generated.{0} (ordered_ring.{0} (semiring.{0} congr_arg_kind)) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (ordered_ring.{0} (semiring.{0} congr_arg_kind)))  := sorry --non-trivial
lemma new_lemma_7038 (h0 : function.extfun Type ring) : @is_domain.{0} (cancel_monoid.{0} (option.{0} empty)) (@function.extfun_app.{2 1} Type ring.{0} h0 (cancel_monoid.{0} (option.{0} empty)))  := sorry --non-trivial
lemma new_lemma_7039 (h0 : not (group (linear_ordered_add_comm_group linarith.ineq) -> false)) : @group.fg.{0} (linear_ordered_add_comm_group.{0} linarith.ineq) (@classical.by_contradiction'.{1} (group.{0} (linear_ordered_add_comm_group.{0} linarith.ineq)) h0)  := sorry --non-trivial
lemma new_lemma_7040 (h0 : functor.add_const (function.extfun Type monoid) Type) : @monoid.fg.{0} (has_Inf.{0} pos) (@function.extfun_app.{2 1} Type monoid.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type monoid.{0}) Type h0) (has_Inf.{0} pos))  := sorry --non-trivial
lemma new_lemma_7041 (h1 : filter (dlist char)) : filter.ne_bot h1 := sorry --non-trivial
lemma new_lemma_7042 (h2 : ring environment.projection_info) : is_domain environment.projection_info := sorry --non-trivial
lemma new_lemma_7043 (h0 : function.extfun (nat -> Type) (function.extfun nat)) : @normalizer_condition.{1} (sub_neg_monoid.{1} Type) (@matrix.vec_empty.{1} (group.{1} (sub_neg_monoid.{1} Type)) (@function.extfun_app.{1 1} nat fin (@function.extfun_app.{2 1} (nat → Type) (function.extfun.{1 1} nat) h0 fin) (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_7044 (h0 : filter (has_neg (has_Inf Type))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_7045 (h2 : set (string_imp -> metric_space (add_comm_semigroup (add_comm_semigroup enat)))) : set.separates_points h2 := sorry --non-trivial
lemma new_lemma_7046 (h0 : functor.add_const (function.extfun Type topological_space) pos) : @sequential_space.{0} (simple_graph.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) pos h0) (simple_graph.{0} pos))  := sorry --non-trivial
lemma new_lemma_7047 (h0 : not (add_monoid (plift unsigned) -> false)) : @add_monoid.fg.{1} (plift.{1} unsigned) (@classical.by_contradiction'.{2} (add_monoid.{1} (plift.{1} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_7048 (h0 : group (boolean_algebra.core pos)) : normalizer_condition (boolean_algebra.core pos) := sorry --non-trivial
lemma new_lemma_7049 (h0 : list (monoid (canonically_ordered_add_monoid unsigned))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_7050 (h0 : group (generalized_boolean_algebra (has_Inf linarith.comp))) : group.fg (generalized_boolean_algebra (has_Inf linarith.comp)) := sorry --non-trivial
lemma new_lemma_7051 (h0 : function.extfun Type complete_lattice) : @complete_lattice.is_Sup_finite_compact.{0} (has_ssubset.{0} linarith.ineq) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (has_ssubset.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_7052 (h0 : filter (has_Inf (canonically_linear_ordered_monoid Type))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_7053 (h0 : function.extfun Type cancel_comm_monoid_with_zero) : @unique_factorization_monoid.{0} (linear_ordered_semiring.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type cancel_comm_monoid_with_zero.{0} h0 (linear_ordered_semiring.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_7054 (h0 : functor.add_const (topological_space (has_zero pos)) (ring Type)) : @regular_space.{0} (has_zero.{0} pos) (@functor.add_const.run.{0 1} (topological_space.{0} (has_zero.{0} pos)) (ring.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_7055 (h2 : topological_space (has_inv (has_well_founded (preorder char)))) : totally_disconnected_space (has_inv (has_well_founded (preorder char))) := sorry --non-trivial
lemma new_lemma_7056 (h0 : topological_space (comm_semigroup (sub_neg_monoid real))) : locally_compact_space (comm_semigroup (sub_neg_monoid real)) := sorry --non-trivial
lemma new_lemma_7057 (h0 : not (add_group (measurable_space.dynkin_system num) -> false)) : @is_add_cyclic.{0} (measurable_space.dynkin_system.{0} num) (@classical.by_contradiction'.{1} (add_group.{0} (measurable_space.dynkin_system.{0} num)) h0)  := sorry --non-trivial
lemma new_lemma_7058 (h0 : topological_space (cancel_monoid congr_arg_kind)) : path_connected_space (cancel_monoid congr_arg_kind) := sorry --non-trivial
lemma new_lemma_7059 (h0 : ring (with_bot (comm_ring (random_gen (random_gen (random_gen linarith.ineq)))))) : is_domain (with_bot (comm_ring (random_gen (random_gen (random_gen linarith.ineq))))) := sorry --non-trivial
lemma new_lemma_7060 (h0 : function.extfun Type topological_space) : @preirreducible_space.{0} auto.case_option (@function.extfun_app.{2 1} Type topological_space.{0} h0 auto.case_option)  := sorry --non-trivial
lemma new_lemma_7061 (h0 : functor.add_const (topological_space (semigroup unsigned)) name) : @totally_disconnected_space.{0} (semigroup.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (semigroup.{0} unsigned)) name h0)  := sorry --non-trivial
lemma new_lemma_7062 (h0 : functor.add_const (ring (has_pos_part linarith.comp)) name) : @strong_rank_condition.{0} (has_pos_part.{0} linarith.comp) (@functor.add_const.run.{0 0} (ring.{0} (has_pos_part.{0} linarith.comp)) name h0)  := sorry --non-trivial
lemma new_lemma_7063 (h0 : function.extfun Type topological_space) : @normal_space.{0} (with_one.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (with_one.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_7064 (h0 : functor.add_const (ordered_add_comm_monoid (add_cancel_monoid linarith.comp)) pos) : @archimedean.{0} (add_cancel_monoid.{0} linarith.comp) (@functor.add_const.run.{0 0} (ordered_add_comm_monoid.{0} (add_cancel_monoid.{0} linarith.comp)) pos h0)  := sorry --non-trivial
lemma new_lemma_7065 (h0 : topological_space (canonically_ordered_comm_semiring (comm_group Type))) : totally_separated_space (canonically_ordered_comm_semiring (comm_group Type)) := sorry --non-trivial
lemma new_lemma_7066 (h0 : complete_lattice (plift unsigned)) : complete_lattice.is_Sup_finite_compact (plift unsigned) := sorry --non-trivial
lemma new_lemma_7067 (h1 : topological_space (with_bot (random_gen linarith.ineq))) : locally_compact_space (with_bot (random_gen linarith.ineq)) := sorry --non-trivial
lemma new_lemma_7068 (h0 : complete_lattice (metric_space (comm_ring reducibility_hints))) : is_compactly_generated (metric_space (comm_ring reducibility_hints)) := sorry --non-trivial
lemma new_lemma_7069 (h0 : function.extfun Type group) : @normalizer_condition.{0} (linear_ordered_cancel_comm_monoid.{0} (option.{0} empty)) (@function.extfun_app.{2 1} Type group.{0} h0 (linear_ordered_cancel_comm_monoid.{0} (option.{0} empty)))  := sorry --non-trivial
lemma new_lemma_7070 (h0 : topological_space (ordered_comm_ring (has_add real))) : loc_path_connected_space (ordered_comm_ring (has_add real)) := sorry --non-trivial
lemma new_lemma_7071 (h0 : list (has_top (has_top (has_ssubset linarith.ineq)))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_7072 (h0 : not (ring (uniform_space string.iterator_imp) -> false)) : @rank_condition.{0} (uniform_space.{0} string.iterator_imp) (@classical.by_contradiction'.{1} (ring.{0} (uniform_space.{0} string.iterator_imp)) h0)  := sorry --non-trivial
lemma new_lemma_7073 (h0 : topological_space (add_left_cancel_semigroup unsigned)) : locally_compact_space (add_left_cancel_semigroup unsigned) := sorry --non-trivial
lemma new_lemma_7074 (h0 : function.extfun Type topological_space) : @loc_path_connected_space.{0} (has_zero.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_zero.{0} num))  := sorry --non-trivial
lemma new_lemma_7075 (h0 : functor.add_const (ordered_add_comm_monoid (generalized_boolean_algebra linarith.comp)) Type) : @archimedean.{0} (generalized_boolean_algebra.{0} linarith.comp) (@functor.add_const.run.{0 1} (ordered_add_comm_monoid.{0} (generalized_boolean_algebra.{0} linarith.comp)) Type h0)  := sorry --non-trivial
lemma new_lemma_7076 (h0 : functor.add_const (topological_space (has_zero pos)) pos) : @normal_space.{0} (has_zero.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (has_zero.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_7077 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @add_monoid.fg.{0} (simple_graph.{0} pos) (@function.extfun_app.{2 1} Type add_monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 add_monoid.{0}) (simple_graph.{0} pos))  := sorry --non-trivial
lemma new_lemma_7078 (h0 : finset (has_zero (ring (ring Type)))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_7079 (h0 : function.extfun Type finset) : finset.nonempty (function.extfun_app h0 (add_group unsigned)) := sorry --non-trivial
lemma new_lemma_7080 (h0 : topological_space (has_one (semiring congr_arg_kind))) : totally_disconnected_space (has_one (semiring congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_7081 (h0 : fin has_zero.zero) : @preirreducible_space.{0} (has_pos_part.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@matrix.vec_empty.{1} (function.extfun.{2 1} Type topological_space.{0}) h0) (has_pos_part.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_7082 (h0 : functor.add_const (function.extfun Type topological_space) pos) : @totally_separated_space.{0} (add_comm_monoid.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) pos h0) (add_comm_monoid.{0} name))  := sorry --non-trivial
lemma new_lemma_7083 (h0 : not (function.extfun Type group -> false)) : @is_cyclic.{0} (dlist.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type group.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type group.{0}) h0) (dlist.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_7084 (h0 : list (list (filter Prop))) : @Lim.{0} Prop sierpinski_space (@nonempty_of_inhabited.{1} Prop sort.inhabited.{0}) (@list.head.{0} (filter.{0} Prop) (@filter.inhabited.{0} Prop) (@id.{1} (list.{0} (filter.{0} Prop)) (@list.head.{0} (list.{0} (filter.{0} Prop)) (list.inhabited.{0} (filter.{0} Prop)) h0)))  := sorry --non-trivial
lemma new_lemma_7085 (h0 : functor.add_const (function.extfun (Type 1) add_monoid) environment.implicit_infer_kind) : @add_monoid.fg.{1} (normed_comm_ring.{1} Type) (@function.extfun_app.{3 2} (Type 1) add_monoid.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) add_monoid.{1}) environment.implicit_infer_kind h0) (normed_comm_ring.{1} Type))  := sorry --non-trivial
lemma new_lemma_7086 (h0 : not (topological_space (has_sub num) -> false)) : @discrete_topology.{0} (has_sub.{0} num) (@classical.by_contradiction'.{1} (topological_space.{0} (has_sub.{0} num)) h0)  := sorry --non-trivial
lemma new_lemma_7087 (h0 : functor.comp ring has_nndist Type) : @rank_condition.{1} (has_nndist.{1} Type) (@functor.comp.run.{1 1 1} ring.{1} has_nndist.{1} Type h0)  := sorry --non-trivial
lemma new_lemma_7088 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @is_cyclic.{1} (finset.{1} Type) (@function.extfun_app.{3 2} (Type 1) group.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 group.{1}) (finset.{1} Type))  := sorry --non-trivial
lemma new_lemma_7089 (h0 : functor.add_const (list (semigroup name)) pos) : list.nodup (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_7090 (h0 : topological_space (has_sub (has_sub (has_sub congr_arg_kind)))) : topological_space.separable_space (has_sub (has_sub (has_sub congr_arg_kind))) := sorry --non-trivial
lemma new_lemma_7091 (h0 : list (left_cancel_monoid congr_arg_kind)) : palindrome h0 := sorry --non-trivial
lemma new_lemma_7092 (h0 : function.extfun Type list) : list.nodup (function.extfun_app h0 (ordered_comm_ring real)) := sorry --non-trivial
lemma new_lemma_7093 (h0 : set (nondiscrete_normed_field ereal -> ereal)) : set.separates_points h0 := sorry --non-trivial
lemma new_lemma_7094 (h0 : has_mem.mem ring has_emptyc.emptyc) : @is_domain.{0} linarith.comp_source (@function.extfun_app.{2 1} Type ring.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) ring.{0} h0) linarith.comp_source)  := sorry --non-trivial
lemma new_lemma_7095 (h0 : group (semiring (semiring linarith.comp))) : group.fg (semiring (semiring linarith.comp)) := sorry --non-trivial
lemma new_lemma_7096 (h0 : functor.add_const (topological_space (has_add Type)) environment.implicit_infer_kind) : @loc_path_connected_space.{1} (has_add.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (has_add.{1} Type)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_7097 (h0 : functor.add_const (ordered_comm_monoid (has_pos_part name)) name) : @has_exists_mul_of_le.{0} (has_pos_part.{0} name) (@functor.add_const.run.{0 0} (ordered_comm_monoid.{0} (has_pos_part.{0} name)) name h0)  := sorry --non-trivial
lemma new_lemma_7098 (h0 : ordered_comm_monoid (has_zero (finset (finset pos)))) : has_exists_mul_of_le (has_zero (finset (finset pos))) := sorry --non-trivial
lemma new_lemma_7099 (h0 : functor.add_const (monoid (has_Sup empty)) empty) : @monoid.fg.{0} (has_Sup.{0} empty) (@functor.add_const.run.{0 0} (monoid.{0} (has_Sup.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_7100 (h0 : functor.add_const (function.extfun Type group) linarith.comp) : @is_simple_group.{0} (has_zero.{0} linarith.comp) (@function.extfun_app.{2 1} Type group.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type group.{0}) linarith.comp h0) (has_zero.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_7101 (h0 : function.extfun Type topological_space) : @path_connected_space.{0} (with_one.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (with_one.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_7102 (h0 : topological_space (generalized_boolean_algebra Type)) : totally_disconnected_space (generalized_boolean_algebra Type) := sorry --non-trivial
lemma new_lemma_7103 (h0 : ring (normed_field (has_ssubset string_imp))) : is_domain (normed_field (has_ssubset string_imp)) := sorry --non-trivial
lemma new_lemma_7104 (h0 : function.extfun Type cancel_comm_monoid_with_zero) : @unique_factorization_monoid.{0} (add_comm_monoid.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type cancel_comm_monoid_with_zero.{0} h0 (add_comm_monoid.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_7105 (h0 : uniform_space (linear_ordered_comm_ring (semiring (semiring num)))) : complete_space (linear_ordered_comm_ring (semiring (semiring num))) := sorry --non-trivial
lemma new_lemma_7106 (h0 : functor.add_const (ordered_add_comm_monoid (mul_zero_class unsigned)) Type) : @archimedean.{0} (mul_zero_class.{0} unsigned) (@functor.add_const.run.{0 1} (ordered_add_comm_monoid.{0} (mul_zero_class.{0} unsigned)) Type h0)  := sorry --non-trivial
lemma new_lemma_7107 (h1 : not (has_mem.mem (with_one congr_arg_kind) has_emptyc.emptyc -> false)) : @is_compactly_generated.{0} (with_one.{0} congr_arg_kind) (@finset.pi.empty.{1 0} Type complete_lattice.{0} (with_one.{0} congr_arg_kind) (@classical.by_contradiction'.{0} (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (with_one.{0} congr_arg_kind) (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))) h1))  := sorry --non-trivial
lemma new_lemma_7108 (h0 : functor.add_const (topological_space (left_cancel_semigroup empty)) empty) : @locally_compact_space.{0} (left_cancel_semigroup.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (left_cancel_semigroup.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_7109 (h0 : function.extfun Type topological_space) : @t0_space.{0} (preorder.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (preorder.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_7110 (h0 : topological_space (with_zero (has_nnnorm (has_nnnorm linarith.ineq)))) : path_connected_space (with_zero (has_nnnorm (has_nnnorm linarith.ineq))) := sorry --non-trivial
lemma new_lemma_7111 (h0 : topological_space (as_linear_order unsigned)) : irreducible_space (as_linear_order unsigned) := sorry --non-trivial
lemma new_lemma_7112 (h0 : group (semiring (random_gen linarith.comp_source))) : normalizer_condition (semiring (random_gen linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_7113 (h0 : topological_space (has_nndist (has_neg_part (mul_zero_class (option pos))))) : preirreducible_space (has_nndist (has_neg_part (mul_zero_class (option pos)))) := sorry --non-trivial
lemma new_lemma_7114 (h1 : ring (with_one fun_info)) : rank_condition (with_one fun_info) := sorry --non-trivial
lemma new_lemma_7115 (h0 : topological_space (measurable_space (has_top (semiring fun_info)))) : preirreducible_space (measurable_space (has_top (semiring fun_info))) := sorry --non-trivial
lemma new_lemma_7116 (h0 : function.extfun Type topological_space) : @t1_space.{0} (ordered_cancel_add_comm_monoid.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (ordered_cancel_add_comm_monoid.{0} num))  := sorry --non-trivial
lemma new_lemma_7117 (h0 : topological_space (has_neg_part environment.implicit_infer_kind)) : irreducible_space (has_neg_part environment.implicit_infer_kind) := sorry --non-trivial
lemma new_lemma_7118 (h0 : topological_space (canonically_ordered_comm_semiring (has_add (has_add name)))) : t0_space (canonically_ordered_comm_semiring (has_add (has_add name))) := sorry --non-trivial
lemma new_lemma_7119 (h0 : function.extfun Type topological_space) : @totally_separated_space.{0} (linear_order.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (linear_order.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_7120 (h0 : has_mem.mem (has_emptyc linarith.comp_source) has_emptyc.emptyc) : @totally_disconnected_space.{0} (has_emptyc.{0} linarith.comp_source) (@finset.pi.empty.{1 0} Type topological_space.{0} (has_emptyc.{0} linarith.comp_source) h0)  := sorry --non-trivial
lemma new_lemma_7121 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_domain.{0} (normed_comm_ring.{0} unsigned) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (normed_comm_ring.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_7122 (h0 : uniform_space (has_to_string (has_nndist name))) : complete_space (has_to_string (has_nndist name)) := sorry --non-trivial
lemma new_lemma_7123 (h0 : add_monoid (add_comm_monoid linarith.comp)) : add_monoid.fg (add_comm_monoid linarith.comp) := sorry --non-trivial
lemma new_lemma_7124 (h0 : functor.add_const (function.extfun Type topological_space) environment.implicit_infer_kind) : @discrete_topology.{0} environment.implicit_infer_kind (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) environment.implicit_infer_kind h0) environment.implicit_infer_kind)  := sorry --non-trivial
lemma new_lemma_7125 (h0 : functor.add_const Prop (has_top num)) : functor.add_const.run h0 := sorry --non-trivial
lemma new_lemma_7126 (h0 : topological_space (left_cancel_monoid empty)) : t0_space (left_cancel_monoid empty) := sorry --non-trivial
lemma new_lemma_7127 (h0 : not (ring (semiring (random_gen linarith.comp_source)) -> false)) : @rank_condition.{0} (semiring.{0} (random_gen.{0} linarith.comp_source)) (@classical.by_contradiction'.{1} (ring.{0} (semiring.{0} (random_gen.{0} linarith.comp_source))) h0)  := sorry --non-trivial
lemma new_lemma_7128 (h0 : functor.add_const (topological_space (has_neg Type)) Type) : @normal_space.{1} (has_neg.{1} Type) (@functor.add_const.run.{1 1} (topological_space.{1} (has_neg.{1} Type)) Type h0)  := sorry --non-trivial
lemma new_lemma_7129 (h0 : add_monoid (has_edist (semiring empty))) : add_monoid.fg (has_edist (semiring empty)) := sorry --non-trivial
lemma new_lemma_7130 (h0 : topological_space (canonically_ordered_comm_semiring name)) : discrete_topology (canonically_ordered_comm_semiring name) := sorry --non-trivial
lemma new_lemma_7131 (h0 : function.extfun Type uniform_space) : @complete_space.{0} (linear_ordered_semiring.{0} unsigned) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (linear_ordered_semiring.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_7132 (h0 : function.extfun Type add_monoid) : @add_monoid.fg.{0} (has_nndist.{0} (has_Inf.{0} pos)) (@function.extfun_app.{2 1} Type add_monoid.{0} h0 (has_nndist.{0} (has_Inf.{0} pos)))  := sorry --non-trivial
lemma new_lemma_7133 (h0 : finset (cancel_monoid (option (option pos)))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_7134 (h1 : uniform_space (measurable_space (random_gen (random_gen linarith.ineq)))) : complete_space (measurable_space (random_gen (random_gen linarith.ineq))) := sorry --non-trivial
lemma new_lemma_7135 (h0 : topological_space (has_inner name Type)) : locally_compact_space (has_inner name Type) := sorry --non-trivial
lemma new_lemma_7136 (h0 : add_monoid (ordered_ring unsigned)) : add_monoid.fg (ordered_ring unsigned) := sorry --non-trivial
lemma new_lemma_7137 (h0 : function.extfun Type topological_space) : @locally_compact_space.{0} (has_Inf.{0} real) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_Inf.{0} real))  := sorry --non-trivial
lemma new_lemma_7138 (h0 : topological_space (has_union (semiring unsigned))) : id (irreducible_space (has_union (semiring unsigned))) := sorry --non-trivial
lemma new_lemma_7139 (h0 : functor.add_const (group auto.case_option) num) : @normalizer_condition.{0} auto.case_option (@functor.add_const.run.{0 0} (group.{0} auto.case_option) num h0)  := sorry --non-trivial
lemma new_lemma_7140 (h2 : ring string.iterator_imp) : rank_condition string.iterator_imp := sorry --non-trivial
lemma new_lemma_7141 (h0 : topological_space (has_one (has_norm (has_top linarith.comp)))) : totally_separated_space (has_one (has_norm (has_top linarith.comp))) := sorry --non-trivial
lemma new_lemma_7142 (h0 : topological_space (complete_semilattice_Sup (has_norm linarith.comp_source))) : irreducible_space (complete_semilattice_Sup (has_norm linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_7143 (h0 : not (function.extfun Type group -> false)) : @is_cyclic.{0} (non_assoc_semiring.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type group.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type group.{0}) h0) (non_assoc_semiring.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_7144 (h0 : not (has_mem.mem (with_one linarith.comp_source) has_emptyc.emptyc -> false)) : @irreducible_space.{0} (with_one.{0} linarith.comp_source) (@finset.pi.empty.{1 0} Type topological_space.{0} (with_one.{0} linarith.comp_source) (@classical.by_contradiction'.{0} (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (with_one.{0} linarith.comp_source) (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))) h0))  := sorry --non-trivial
lemma new_lemma_7145 (h0 : list (canonically_ordered_comm_semiring linarith.comp)) : palindrome h0 := sorry --non-trivial
lemma new_lemma_7146 (h0 : topological_space (dlist string.iterator_imp)) : path_connected_space (dlist string.iterator_imp) := sorry --non-trivial
lemma new_lemma_7147 (h0 : not (function.extfun Type topological_space -> false)) : @totally_separated_space.{0} (has_top.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (has_top.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_7148 (h0 : topological_space (ordered_comm_monoid (finset linarith.comp))) : irreducible_space (ordered_comm_monoid (finset linarith.comp)) := sorry --non-trivial
lemma new_lemma_7149 (h0 : list (comm_monoid (semiring unsigned))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_7150 (h0 : functor.add_const (finset (add_comm_monoid name)) linarith.comp) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_7151 (h0 : functor.add_const (function.extfun (Type 1) topological_space) pos) : @totally_disconnected_space.{1} (ordered_comm_monoid.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) topological_space.{1}) pos h0) (ordered_comm_monoid.{1} Type))  := sorry --non-trivial
lemma new_lemma_7152 (h0 : not (topological_space (normed_group reducibility_hints) -> false)) : @t0_space.{0} (normed_group.{0} reducibility_hints) (@classical.by_contradiction'.{1} (topological_space.{0} (normed_group.{0} reducibility_hints)) h0)  := sorry --non-trivial
lemma new_lemma_7153 (h0 : multiset (mul_one_class (mul_one_class std_gen))) (h1 : is_empty Type) : multiset.disjoint h0 (is_empty.elim h1 (mul_one_class (mul_one_class std_gen))) := sorry --non-trivial
lemma new_lemma_7154 (h0 : topological_space (comm_ring (linear_ordered_add_comm_group (has_inv linarith.ineq)))) : path_connected_space (comm_ring (linear_ordered_add_comm_group (has_inv linarith.ineq))) := sorry --non-trivial
lemma new_lemma_7155 (h0 : topological_space (measurable_space (has_norm linarith.comp))) : irreducible_space (measurable_space (has_norm linarith.comp)) := sorry --non-trivial
lemma new_lemma_7156 (h0 : ring (semigroup (option (has_to_string unsigned)))) : strong_rank_condition (semigroup (option (has_to_string unsigned))) := sorry --non-trivial
lemma new_lemma_7157 (h0 : add_group (comm_group (comm_group (has_to_string (has_to_string Type))))) : is_add_cyclic (comm_group (comm_group (has_to_string (has_to_string Type)))) := sorry --non-trivial
lemma new_lemma_7158 (h0 : function.extfun Type complete_lattice) : @is_compactly_generated.{0} (has_neg_part.{0} name) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (has_neg_part.{0} name))  := sorry --non-trivial
lemma new_lemma_7159 (h0 : topological_space (has_top (semiring (semiring (has_norm (semiring unsigned)))))) : normal_space (has_top (semiring (semiring (has_norm (semiring unsigned))))) := sorry --non-trivial
lemma new_lemma_7160 (h0 : functor.add_const (ring (has_add pos)) linarith.comp) : @strong_rank_condition.{0} (has_add.{0} pos) (@functor.add_const.run.{0 0} (ring.{0} (has_add.{0} pos)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_7161 (h0 : filter (non_assoc_semiring congr_arg_kind)) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_7162 (h0 : function.extfun nat fin) : @preconnected_space.{0} (simple_graph.{0} name) (@matrix.vec_empty.{0} (topological_space.{0} (simple_graph.{0} name)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_7163 (h0 : topological_space (add_cancel_monoid empty)) : normal_space (add_cancel_monoid empty) := sorry --non-trivial
lemma new_lemma_7164 (h1 : not (function.extfun Type ring -> false)) : @strong_rank_condition.{0} (complete_semilattice_Sup.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type ring.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type ring.{0}) h1) (complete_semilattice_Sup.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_7165 (h0 : complete_lattice (generalized_boolean_algebra (sub_neg_monoid (has_Inf name)))) : is_atomistic (generalized_boolean_algebra (sub_neg_monoid (has_Inf name))) := sorry --non-trivial
lemma new_lemma_7166 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : list.nodup (function.extfun_app (function.extfun_app h0 list) (cancel_monoid Type)) := sorry --non-trivial
lemma new_lemma_7167 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @archimedean.{0} (complete_distrib_lattice.{0} unsigned) (@function.extfun_app.{2 1} Type ordered_add_comm_monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ordered_add_comm_monoid.{0}) (complete_distrib_lattice.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_7168 (h0 : functor.add_const (topological_space (has_to_string linarith.comp)) linarith.comp) : @preirreducible_space.{0} (has_to_string.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (has_to_string.{0} linarith.comp)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_7169 (h0 : group (distrib (comm_ring (has_nnnorm reducibility_hints)))) : is_cyclic (distrib (comm_ring (has_nnnorm reducibility_hints))) := sorry --non-trivial
lemma new_lemma_7170 (h0 : fin has_zero.zero) : @sequential_space.{0} (add_comm_monoid.{0} pos) (@matrix.vec_empty.{0} (topological_space.{0} (add_comm_monoid.{0} pos)) (@matrix.vec_empty.{0} (fin (@has_zero.zero.{0} nat nat.has_zero)) h0))  := sorry --non-trivial
lemma new_lemma_7171 (h0 : group (ordered_comm_ring (has_add pos))) : normalizer_condition (ordered_comm_ring (has_add pos)) := sorry --non-trivial
lemma new_lemma_7172 (h0 : add_monoid (has_star (semiring (semiring (semiring (semiring (semiring empty))))))) : add_monoid.fg (has_star (semiring (semiring (semiring (semiring (semiring empty)))))) := sorry --non-trivial
lemma new_lemma_7173 (h0 : complete_lattice (measurable_space linarith.comp)) : is_atomistic (measurable_space linarith.comp) := sorry --non-trivial
lemma new_lemma_7174 (h0 : function.extfun (nat -> Type) (function.extfun nat)) : @is_noetherian_ring.{0} (boolean_algebra.core.{0} pos) (@function.extfun_app.{2 1} Type semiring.{0} (@matrix.vec_empty.{1} (function.extfun.{2 1} Type semiring.{0}) (@function.extfun_app.{1 1} nat fin (@function.extfun_app.{2 1} (nat → Type) (function.extfun.{1 1} nat) h0 fin) (@has_zero.zero.{0} nat nat.has_zero))) (boolean_algebra.core.{0} pos))  := sorry --non-trivial
lemma new_lemma_7175 (h0 : filter (has_add (option (option (option pos))))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_7176 (h0 : ordered_comm_monoid (has_neg (ring Type))) : has_exists_mul_of_le (has_neg (ring Type)) := sorry --non-trivial
lemma new_lemma_7177 (h0 : ring (simple_graph (mul_one_class ereal))) : strong_rank_condition (simple_graph (mul_one_class ereal)) := sorry --non-trivial
lemma new_lemma_7178 (h0 : topological_space (with_bot linarith.comp_source)) : totally_disconnected_space (with_bot linarith.comp_source) := sorry --non-trivial
lemma new_lemma_7179 (h0 : function.extfun Type topological_space) : @irreducible_space.{0} (measurable_space.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (measurable_space.{0} empty))  := sorry --non-trivial
lemma new_lemma_7180 (h0 : functor.add_const (topological_space (has_zero environment.implicit_infer_kind)) environment.implicit_infer_kind) : @discrete_topology.{0} (has_zero.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (has_zero.{0} environment.implicit_infer_kind)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_7181 (h0 : function.extfun Type (functor.comp group boolean_algebra.core)) : @normalizer_condition.{0} (boolean_algebra.core.{0} ennreal) (@functor.comp.run.{0 0 0} group.{0} boolean_algebra.core.{0} ennreal (@function.extfun_app.{2 1} Type (functor.comp.{0 0 0} group.{0} boolean_algebra.core.{0}) h0 ennreal))  := sorry --non-trivial
lemma new_lemma_7182 (h0 h1 : multiset (mul_one_class string.iterator_imp)) : multiset.subset h0 h1 := sorry --non-trivial
lemma new_lemma_7183 (h0 : semiring (has_norm empty)) : is_noetherian_ring (has_norm empty) := sorry --non-trivial
lemma new_lemma_7184 (h0 : topological_space (has_nnnorm string.iterator_imp)) (h1 : set (has_nnnorm string.iterator_imp)) : is_path_connected h1 := sorry --non-trivial
lemma new_lemma_7185 (h0 : ring (has_div (mul_one_class (mul_one_class string.iterator_imp)))) : rank_condition (has_div (mul_one_class (mul_one_class string.iterator_imp))) := sorry --non-trivial
lemma new_lemma_7186 (h0 : not (function.extfun Type topological_space -> false)) : @path_connected_space.{0} (has_inv.{0} fun_info) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (has_inv.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_7187 (h0 : function.extfun (nat -> Type) (function.extfun nat)) : @is_compactly_generated.{0} (sub_neg_monoid.{0} name) (@matrix.vec_empty.{0} (complete_lattice.{0} (sub_neg_monoid.{0} name)) (@function.extfun_app.{1 1} nat fin (@function.extfun_app.{2 1} (nat → Type) (function.extfun.{1 1} nat) h0 fin) (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_7188 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @discrete_topology.{0} (cancel_monoid.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (cancel_monoid.{0} name))  := sorry --non-trivial
lemma new_lemma_7189 (h0 : complete_lattice (measurable_space to_additive.value_type)) : is_atomistic (measurable_space to_additive.value_type) := sorry --non-trivial
lemma new_lemma_7190 (h0 : has_mem.mem (has_top linarith.ineq) has_emptyc.emptyc) : @locally_compact_space.{0} (has_top.{0} linarith.ineq) (@finset.pi.empty.{1 0} Type topological_space.{0} (has_top.{0} linarith.ineq) h0)  := sorry --non-trivial
lemma new_lemma_7191 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : is_compactly_generated (measurable_space linarith.ineq) := sorry --non-trivial
lemma new_lemma_7192 (h0 : topological_space (has_norm (has_norm linarith.comp))) : discrete_topology (has_norm (has_norm linarith.comp)) := sorry --non-trivial
lemma new_lemma_7193 (h0 : finset (left_cancel_monoid (semiring num))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_7194 (h0 : group (has_union (semiring (semiring num)))) : group.fg (has_union (semiring (semiring num))) := sorry --non-trivial
lemma new_lemma_7195 (h1 : topological_space (add_monoid char)) : t0_space (add_monoid char) := sorry --non-trivial
lemma new_lemma_7196 (h0 : complete_lattice (has_to_string (option (option ennreal)))) : is_compactly_generated (has_to_string (option (option ennreal))) := sorry --non-trivial
lemma new_lemma_7197 (h0 : functor.add_const (topological_space (bin_tree unsigned)) (semiring empty)) : @loc_path_connected_space.{0} (bin_tree.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (bin_tree.{0} unsigned)) (semiring.{0} empty) h0)  := sorry --non-trivial
lemma new_lemma_7198 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @archimedean.{0} (comm_group.{0} unsigned) (@function.extfun_app.{2 1} Type ordered_add_comm_monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ordered_add_comm_monoid.{0}) (comm_group.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_7199 (h1 : not (add_group (has_append string_imp) -> false)) : @is_simple_add_group.{0} (has_append.{0} string_imp) (@classical.by_contradiction'.{1} (add_group.{0} (has_append.{0} string_imp)) h1)  := sorry --non-trivial
lemma new_lemma_7200 (h0 : not (function.extfun Type topological_space -> false)) : @t0_space.{0} (comm_ring.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (comm_ring.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_7201 (h0 : functor.add_const (function.extfun Type topological_space) Type) : @locally_compact_space.{0} (comm_group.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type topological_space.{0}) Type h0) (comm_group.{0} name))  := sorry --non-trivial
lemma new_lemma_7202 (h0 : add_group (normed_lattice_add_comm_group (ordered_comm_monoid (has_Inf Type)))) : is_add_cyclic (normed_lattice_add_comm_group (ordered_comm_monoid (has_Inf Type))) := sorry --non-trivial
lemma new_lemma_7203 (h0 : prod (has_Sup (semiring empty)) (has_Sup (semiring empty))) : id_rel h0 := sorry --non-trivial
lemma new_lemma_7204 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @preirreducible_space.{0} (has_neg.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_neg.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_7205 (h0 : group (complete_distrib_lattice (ring (ring Type)))) : group.fg (complete_distrib_lattice (ring (ring Type))) := sorry --non-trivial
lemma new_lemma_7206 (h0 : function.extfun Type topological_space) : @path_connected_space.{0} (has_norm.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_norm.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_7207 (h0 : has_neg (has_ssubset (has_nnnorm char))) (h1 : measurable_space (has_ssubset (has_nnnorm char))) : has_measurable_neg (has_ssubset (has_nnnorm char)) := sorry --non-trivial
lemma new_lemma_7208 (h0 : ordered_comm_monoid (ordered_comm_ring (finset (ring linarith.comp)))) : has_exists_mul_of_le (ordered_comm_ring (finset (ring linarith.comp))) := sorry --non-trivial
lemma new_lemma_7209 (h0 : topological_space (with_bot (has_top congr_arg_kind))) : discrete_topology (with_bot (has_top congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_7210 (h0 : topological_space (has_nnnorm (mul_one_class (mul_one_class string.iterator_imp)))) : totally_disconnected_space (has_nnnorm (mul_one_class (mul_one_class string.iterator_imp))) := sorry --non-trivial
lemma new_lemma_7211 (h0 : has_neg (normed_field (mul_one_class (simple_graph linarith.comp_source)))) (h1 : measurable_space (normed_field (mul_one_class (simple_graph linarith.comp_source)))) : has_measurable_neg (normed_field (mul_one_class (simple_graph linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_7212 (h0 : ordered_comm_monoid (finset (finset linarith.comp))) : has_exists_mul_of_le (finset (finset linarith.comp)) := sorry --non-trivial
lemma new_lemma_7213 (h0 : functor.add_const Prop (has_to_string (has_to_string (has_to_string pos)))) : functor.add_const.run h0 := sorry --non-trivial
lemma new_lemma_7214 (h0 : topological_space (ordered_comm_monoid (has_Inf linarith.comp))) : preconnected_space (ordered_comm_monoid (has_Inf linarith.comp)) := sorry --non-trivial
lemma new_lemma_7215 (h0 : topological_space (mul_zero_class (semigroup unsigned))) : locally_compact_space (mul_zero_class (semigroup unsigned)) := sorry --non-trivial
lemma new_lemma_7216 (h0 : monoid (measurable_space (has_top num))) : monoid.fg (measurable_space (has_top num)) := sorry --non-trivial
lemma new_lemma_7217 (h0 : topological_space (has_to_string (finset linarith.comp))) : path_connected_space (has_to_string (finset linarith.comp)) := sorry --non-trivial
lemma new_lemma_7218 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @path_connected_space.{0} (simple_graph.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (simple_graph.{0} pos))  := sorry --non-trivial
lemma new_lemma_7219 (h0 : monoid (has_one (semiring (has_top (has_top num))))) : monoid.fg (has_one (semiring (has_top (has_top num)))) := sorry --non-trivial
lemma new_lemma_7220 (h0 : functor.add_const (uniform_space (ordered_comm_ring Type)) pos) : @complete_space.{1} (ordered_comm_ring.{1} Type) (@functor.add_const.run.{1 0} (uniform_space.{1} (ordered_comm_ring.{1} Type)) pos h0)  := sorry --non-trivial
lemma new_lemma_7221 (h0 : fin has_zero.zero) : @preirreducible_space.{1} (boolean_algebra.{1} Type) (@matrix.vec_empty.{1} (topological_space.{1} (boolean_algebra.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_7222 (h0 : not (topological_space (left_cancel_semigroup congr_arg_kind) -> false)) : @irreducible_space.{0} (left_cancel_semigroup.{0} congr_arg_kind) (@classical.by_contradiction'.{1} (topological_space.{0} (left_cancel_semigroup.{0} congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_7223 (h0 : has_mem.mem (complete_semilattice_Sup congr_arg_kind) has_emptyc.emptyc) : @totally_separated_space.{0} (complete_semilattice_Sup.{0} congr_arg_kind) (@finset.pi.empty.{1 0} Type topological_space.{0} (complete_semilattice_Sup.{0} congr_arg_kind) h0)  := sorry --non-trivial
lemma new_lemma_7224 (h0 : function.extfun (has_add pos) (fun (x : has_add pos), Prop)) : set.subsingleton (function.extfun_app h0) := sorry --non-trivial
lemma new_lemma_7225 (h0 : functor.add_const (topological_space (boolean_algebra.core Type)) (comm_group name)) : @totally_separated_space.{1} (boolean_algebra.core.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (boolean_algebra.core.{1} Type)) (comm_group.{0} name) h0)  := sorry --non-trivial
lemma new_lemma_7226 (h0 : add_monoid (cancel_monoid (boolean_algebra environment.implicit_infer_kind))) : add_monoid.fg (cancel_monoid (boolean_algebra environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_7227 (h0 : ordered_comm_monoid (ring (has_Inf (mul_one_class linarith.comp)))) : has_exists_mul_of_le (ring (has_Inf (mul_one_class linarith.comp))) := sorry --non-trivial
lemma new_lemma_7228 (h0 : function.extfun Type ordered_add_comm_monoid) : @archimedean.{0} (ring.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type ordered_add_comm_monoid.{0} h0 (ring.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_7229 (h0 : function.extfun Type filter) : filter.ne_bot (function.extfun_app h0 (ordered_cancel_add_comm_monoid unsigned)) := sorry --non-trivial
lemma new_lemma_7230 (h0 : uniform_space (measure_theory.measure_space (has_top (has_top (semiring unsigned))))) : separated_space (measure_theory.measure_space (has_top (has_top (semiring unsigned)))) := sorry --non-trivial
lemma new_lemma_7231 (h0 : functor.comp group has_zero unsigned) : @is_cyclic.{0} (has_zero.{0} unsigned) (@functor.comp.run.{0 0 0} group.{0} has_zero.{0} unsigned h0)  := sorry --non-trivial
lemma new_lemma_7232 (h0 : functor.add_const (topological_space (add_comm_monoid pos)) pos) : @path_connected_space.{0} (add_comm_monoid.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (add_comm_monoid.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_7233 (h0 : functor.add_const (topological_space (has_neg_part name)) linarith.comp) : @totally_disconnected_space.{0} (has_neg_part.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (has_neg_part.{0} name)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_7234 (h0 : functor.add_const (ordered_add_comm_monoid (has_nndist linarith.comp)) pos) : @archimedean.{0} (has_nndist.{0} linarith.comp) (@functor.add_const.run.{0 0} (ordered_add_comm_monoid.{0} (has_nndist.{0} linarith.comp)) pos h0)  := sorry --non-trivial
lemma new_lemma_7235 (h0 : has_neg (has_nnnorm (add_cancel_monoid string_imp))) (h1 : measurable_space (has_nnnorm (add_cancel_monoid string_imp))) : has_measurable_neg (has_nnnorm (add_cancel_monoid string_imp)) := sorry --non-trivial
lemma new_lemma_7236 (h0 : add_group (has_inter string_imp)) : is_add_cyclic (has_inter string_imp) := sorry --non-trivial
lemma new_lemma_7237 (h0 : add_monoid (normed_lattice_add_comm_group (has_Inf (has_neg pos)))) : add_monoid.fg (normed_lattice_add_comm_group (has_Inf (has_neg pos))) := sorry --non-trivial
lemma new_lemma_7238 (h0 : group (left_cancel_monoid (option empty))) : normalizer_condition (left_cancel_monoid (option empty)) := sorry --non-trivial
lemma new_lemma_7239 (h0 : ring (semi_normed_ring enat)) : strong_rank_condition (semi_normed_ring enat) := sorry --non-trivial
lemma new_lemma_7240 (h0 : functor.add_const (topological_space (boolean_algebra name)) environment.implicit_infer_kind) : @path_connected_space.{0} (boolean_algebra.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (boolean_algebra.{0} name)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_7241 (h0 : group (ring (finset (has_neg linarith.comp)))) : is_cyclic (ring (finset (has_neg linarith.comp))) := sorry --non-trivial
lemma new_lemma_7242 (h0 : functor.add_const (finset (normed_comm_ring environment.implicit_infer_kind)) Type) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_7243 (h0 : functor.add_const (function.extfun Type topological_space) Type) : @path_connected_space.{0} (add_cancel_monoid.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type topological_space.{0}) Type h0) (add_cancel_monoid.{0} name))  := sorry --non-trivial
lemma new_lemma_7244 (h0 : topological_space (sub_neg_monoid real)) : discrete_topology (sub_neg_monoid real) := sorry --non-trivial
lemma new_lemma_7245 (h0 : topological_space (comm_group Type)) : preirreducible_space (comm_group Type) := sorry --non-trivial
lemma new_lemma_7246 (h0 : has_lt (has_compl fun_info)) : no_max_order (has_compl fun_info) := sorry --non-trivial
lemma new_lemma_7247 (h1 : topological_space (id string_imp)) : totally_separated_space (id string_imp) := sorry --non-trivial
lemma new_lemma_7248 (h0 : function.extfun (finset (Type -> Type)) (has_mem.mem complete_lattice)) : @is_atomistic.{0} (semiring.{0} linarith.ineq) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) complete_lattice.{0} (@function.extfun_app.{2 0} (finset.{1} (Type → Type)) (@has_mem.mem.{1 1} (Type → Type) (finset.{1} (Type → Type)) (@finset.has_mem.{1} (Type → Type)) complete_lattice.{0}) h0 (@has_emptyc.emptyc.{1} (finset.{1} (Type → Type)) (@finset.has_emptyc.{1} (Type → Type))))) (semiring.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_7249 (h0 : function.extfun (finset (Type -> Type)) (has_mem.mem topological_space)) : @irreducible_space.{0} (random_gen.{0} fun_info) (@function.extfun_app.{2 1} Type topological_space.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) topological_space.{0} (@function.extfun_app.{2 0} (finset.{1} (Type → Type)) (@has_mem.mem.{1 1} (Type → Type) (finset.{1} (Type → Type)) (@finset.has_mem.{1} (Type → Type)) topological_space.{0}) h0 (@has_emptyc.emptyc.{1} (finset.{1} (Type → Type)) (@finset.has_emptyc.{1} (Type → Type))))) (random_gen.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_7250 (h0 : group (pseudo_metric_space (option (option (option (option num)))))) : normalizer_condition (pseudo_metric_space (option (option (option (option num))))) := sorry --non-trivial
lemma new_lemma_7251 (h0 : topological_space (ordered_comm_monoid (has_neg name))) : loc_path_connected_space (ordered_comm_monoid (has_neg name)) := sorry --non-trivial
lemma new_lemma_7252 (h0 : functor.add_const (uniform_space (complete_linear_order num)) empty) : @separated_space.{0} (complete_linear_order.{0} num) (@functor.add_const.run.{0 0} (uniform_space.{0} (complete_linear_order.{0} num)) empty h0)  := sorry --non-trivial
lemma new_lemma_7253 (h0 : finset (is_R_or_C congr_arg_kind)) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_7254 (h0 : functor.add_const (uniform_space (boolean_algebra environment.implicit_infer_kind)) (boolean_algebra name)) : @complete_space.{0} (boolean_algebra.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (uniform_space.{0} (boolean_algebra.{0} environment.implicit_infer_kind)) (boolean_algebra.{0} name) h0)  := sorry --non-trivial
lemma new_lemma_7255 (h0 : topological_space (has_star (semiring empty))) (h1 : option (topological_space (has_star (semiring empty)))) : discrete_topology (has_star (semiring empty)) := sorry --non-trivial
lemma new_lemma_7256 (h0 : function.extfun Type ring) : @is_domain.{0} (as_linear_order.{0} empty) (@function.extfun_app.{2 1} Type ring.{0} h0 (as_linear_order.{0} empty))  := sorry --non-trivial
lemma new_lemma_7257 (h0 : topological_space (boolean_algebra (has_Inf real))) : totally_disconnected_space (boolean_algebra (has_Inf real)) := sorry --non-trivial
lemma new_lemma_7258 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @has_exists_mul_of_le.{0} (add_comm_monoid.{0} ennreal) (@function.extfun_app.{2 1} Type ordered_comm_monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ordered_comm_monoid.{0}) (add_comm_monoid.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_7259 (h0 : functor.add_const (topological_space (has_add linarith.comp)) linarith.comp) : @t0_space.{0} (has_add.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (has_add.{0} linarith.comp)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_7260 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_simple_group.{0} (cancel_monoid.{0} pos) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (cancel_monoid.{0} pos))  := sorry --non-trivial
lemma new_lemma_7261 (h0 : filter (div_inv_monoid linarith.ineq)) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_7262 (h0 : ring (finset environment.implicit_infer_kind)) : strong_rank_condition (finset environment.implicit_infer_kind) := sorry --non-trivial
lemma new_lemma_7263 (h0 : function.extfun Type filter) : countable_Inter_filter (function.extfun_app h0 (ordered_comm_monoid linarith.comp)) := sorry --non-trivial
lemma new_lemma_7264 (h0 : function.extfun Type uniform_space) : @complete_space.{0} (add_cancel_comm_monoid.{0} unsigned) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (add_cancel_comm_monoid.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_7265 (h0 : function.extfun Type (functor.comp group has_nndist)) : @group.fg.{0} (has_nndist.{0} environment.implicit_infer_kind) (@functor.comp.run.{0 0 0} group.{0} has_nndist.{0} environment.implicit_infer_kind (@function.extfun_app.{2 1} Type (functor.comp.{0 0 0} group.{0} has_nndist.{0}) h0 environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_7266 (h0 : functor.add_const (function.extfun Type topological_space) (has_pos_part pos)) : @locally_compact_space.{0} (finset.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) (has_pos_part.{0} pos) h0) (finset.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_7267 (h0 h1 : multiset (add_comm_semigroup char)) : multiset.le h0 h1 := sorry --non-trivial
lemma new_lemma_7268 (h0 : filter (has_pos_part (has_pos_part (finset pos)))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_7269 (h0 : topological_space (has_add (sub_neg_monoid real))) : locally_compact_space (has_add (sub_neg_monoid real)) := sorry --non-trivial
lemma new_lemma_7270 (h0 : monoid (ring Type)) : monoid.fg (ring Type) := sorry --non-trivial
lemma new_lemma_7271 (h0 : functor.add_const (function.extfun Type topological_space) linarith.comp) : @locally_compact_space.{0} (boolean_algebra.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) linarith.comp h0) (boolean_algebra.{0} pos))  := sorry --non-trivial
lemma new_lemma_7272 (h0 : monoid (with_bot linarith.ineq)) (h1 : complete_lattice (star_monoid (with_bot linarith.ineq))) : is_atomistic (star_monoid (with_bot linarith.ineq)) := sorry --non-trivial
lemma new_lemma_7273 (h0 : topological_space (linear_ordered_semiring (has_one linarith.comp))) : t0_space (linear_ordered_semiring (has_one linarith.comp)) := sorry --non-trivial
lemma new_lemma_7274 (h0 : function.extfun Type complete_lattice) : @is_atomistic.{0} (has_inv.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (has_inv.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_7275 (h0 : function.extfun Type ring) : @is_domain.{0} (dlist.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type ring.{0} h0 (dlist.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_7276 (h0 : ring (canonically_ordered_comm_semiring Type)) : rank_condition (canonically_ordered_comm_semiring Type) := sorry --non-trivial
lemma new_lemma_7277 (h3 : group (random_gen to_additive.value_type)) : is_cyclic (random_gen to_additive.value_type) := sorry --non-trivial
lemma new_lemma_7278 (h1 : uniform_space fun_info) : complete_space fun_info := sorry --non-trivial
lemma new_lemma_7279 (h0 : functor.add_const (topological_space (generalized_boolean_algebra pos)) (ring linarith.comp)) : @totally_separated_space.{0} (generalized_boolean_algebra.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (generalized_boolean_algebra.{0} pos)) (ring.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_7280 (h0 : topological_space (boolean_algebra environment.implicit_infer_kind)) : preconnected_space (boolean_algebra environment.implicit_infer_kind) := sorry --non-trivial
lemma new_lemma_7281 (h0 : cancel_comm_monoid_with_zero (comm_group (has_add pos))) : unique_factorization_monoid (comm_group (has_add pos)) := sorry --non-trivial
lemma new_lemma_7282 (h0 : functor.add_const (function.extfun (Type 1) topological_space) (has_add (finset environment.implicit_infer_kind))) : @t1_space.{1} (normed_comm_ring.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) topological_space.{1}) (has_add.{0} (finset.{0} environment.implicit_infer_kind)) h0) (normed_comm_ring.{1} Type))  := sorry --non-trivial
lemma new_lemma_7283 (h0 : prod (semigroup num) (semigroup num)) : id_rel h0 := sorry --non-trivial
lemma new_lemma_7284 (h0 : ring (comm_semigroup (has_pos_part pos))) : is_domain (comm_semigroup (has_pos_part pos)) := sorry --non-trivial
lemma new_lemma_7285 (h0 : function.extfun Type add_group) : @is_add_cyclic.{0} (topological_space.{0} (random_gen.{0} to_additive.value_type)) (@function.extfun_app.{2 1} Type add_group.{0} h0 (topological_space.{0} (random_gen.{0} to_additive.value_type)))  := sorry --non-trivial
lemma new_lemma_7286 (h0 : add_monoid (has_Sup (option (option (option (option empty)))))) : add_monoid.fg (has_Sup (option (option (option (option empty))))) := sorry --non-trivial
lemma new_lemma_7287 (h0 : topological_space (has_zero (finset (finset name)))) : topological_space.separable_space (has_zero (finset (finset name))) := sorry --non-trivial
lemma new_lemma_7288 (h0 : fin has_zero.zero) : @sequential_space.{1} (has_pos_part.{1} Type) (@matrix.vec_empty.{1} (topological_space.{1} (has_pos_part.{1} Type)) (@matrix.vec_empty.{0} (fin (@has_zero.zero.{0} nat nat.has_zero)) h0))  := sorry --non-trivial
lemma new_lemma_7289 (h0 : topological_space (boolean_algebra real)) : topological_space.separable_space (boolean_algebra real) := sorry --non-trivial
lemma new_lemma_7290 (h0 : ring (measurable_space.dynkin_system (option (option (option unsigned))))) : strong_rank_condition (measurable_space.dynkin_system (option (option (option unsigned)))) := sorry --non-trivial
lemma new_lemma_7291 (h0 : functor.add_const (function.extfun Type topological_space) (has_neg pos)) : @discrete_topology.{0} (has_nndist.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) (has_neg.{0} pos) h0) (has_nndist.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_7292 (h0 : ring (comm_ring (denumerable reducibility_hints))) : is_domain (comm_ring (denumerable reducibility_hints)) := sorry --non-trivial
lemma new_lemma_7293 (h0 : topological_space (linear_ordered_semiring (has_norm congr_arg_kind))) : totally_separated_space (linear_ordered_semiring (has_norm congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_7294 (h0 : functor.add_const (ring (has_Inf linarith.comp)) linarith.comp) : @rank_condition.{0} (has_Inf.{0} linarith.comp) (@functor.add_const.run.{0 0} (ring.{0} (has_Inf.{0} linarith.comp)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_7295 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @topological_space.separable_space.{0} (option.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (option.{0} empty))  := sorry --non-trivial
lemma new_lemma_7296 (h0 : functor.add_const (prod (ordered_ring empty) (ordered_ring empty)) congr_arg_kind) : id_rel (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_7297 (h0 : functor.add_const (topological_space (finset linarith.comp)) pos) : @discrete_topology.{0} (finset.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (finset.{0} linarith.comp)) pos h0)  := sorry --non-trivial
lemma new_lemma_7298 (h0 : function.extfun Type ordered_add_comm_monoid) : @archimedean.{0} (ordered_ring.{0} empty) (@function.extfun_app.{2 1} Type ordered_add_comm_monoid.{0} h0 (ordered_ring.{0} empty))  := sorry --non-trivial
lemma new_lemma_7299 (h2 : has_mem.mem complete_lattice has_emptyc.emptyc) : @is_compactly_generated.{0} congr_arg_kind (@function.extfun_app.{2 1} Type complete_lattice.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) complete_lattice.{0} h2) congr_arg_kind)  := sorry --non-trivial
lemma new_lemma_7300 (h0 : list (linear_ordered_field (option empty))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_7301 (h0 : complete_lattice (finset (boolean_algebra name))) : is_atomistic (finset (boolean_algebra name)) := sorry --non-trivial
lemma new_lemma_7302 (h0 : topological_space (cancel_monoid congr_arg_kind)) : locally_compact_space (cancel_monoid congr_arg_kind) := sorry --non-trivial
lemma new_lemma_7303 (h0 : prod (omega_complete_partial_order congr_arg_kind) (omega_complete_partial_order congr_arg_kind)) : id_rel h0 := sorry --non-trivial
lemma new_lemma_7304 (h0 : not (ring (semiring linarith.ineq) -> false)) : @is_domain.{0} (semiring.{0} linarith.ineq) (@classical.by_contradiction'.{1} (ring.{0} (semiring.{0} linarith.ineq)) h0)  := sorry --non-trivial
lemma new_lemma_7305 (h0 : topological_space (boolean_algebra (has_add (has_to_string unsigned)))) : totally_separated_space (boolean_algebra (has_add (has_to_string unsigned))) := sorry --non-trivial
lemma new_lemma_7306 (h0 : ring (normed_comm_ring (has_add (comm_group name)))) : strong_rank_condition (normed_comm_ring (has_add (comm_group name))) := sorry --non-trivial
lemma new_lemma_7307 (h0 : list (complete_distrib_lattice name)) : palindrome h0 := sorry --non-trivial
lemma new_lemma_7308 (h0 : functor.add_const (topological_space (has_to_string pos)) environment.implicit_infer_kind) : @irreducible_space.{0} (has_to_string.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (has_to_string.{0} pos)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_7309 (h0 : function.extfun Type add_monoid) : @add_monoid.fg.{0} (has_dist.{0} ennreal) (@function.extfun_app.{2 1} Type add_monoid.{0} h0 (has_dist.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_7310 (h0 : function.extfun Type (functor.add_const (complete_lattice (semigroup unsigned)))) : @is_atomistic.{0} (semigroup.{0} unsigned) (@functor.add_const.run.{0 0} (complete_lattice.{0} (semigroup.{0} unsigned)) pos (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (complete_lattice.{0} (semigroup.{0} unsigned))) h0 pos))  := sorry --non-trivial
lemma new_lemma_7311 (h0 : topological_space (nondiscrete_normed_field fun_info)) (h1 : set (nondiscrete_normed_field fun_info)) : is_path_connected h1 := sorry --non-trivial
lemma new_lemma_7312 (h0 : not (has_mem.mem topological_space has_emptyc.emptyc -> false)) : @path_connected_space.{0} (with_bot.{0} fun_info) (@function.extfun_app.{2 1} Type topological_space.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) topological_space.{0} (@classical.by_contradiction'.{0} (@has_mem.mem.{1 1} (Type → Type) (finset.{1} (Type → Type)) (@finset.has_mem.{1} (Type → Type)) topological_space.{0} (@has_emptyc.emptyc.{1} (finset.{1} (Type → Type)) (@finset.has_emptyc.{1} (Type → Type)))) h0)) (with_bot.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_7313 (h0 : not (function.extfun Type topological_space -> false)) : @t0_space.{0} (semiring.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (semiring.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_7314 (h0 : function.extfun Type ring) : @is_domain.{0} (dlist.{0} linarith.ineq) (@function.extfun_app.{2 1} Type ring.{0} h0 (dlist.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_7315 (h0 : fin has_zero.zero) : @path_connected_space.{1} (monoid.{1} Type) (@matrix.vec_empty.{1} (topological_space.{1} (monoid.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_7316 (h0 : function.extfun Type complete_lattice) : @is_atomistic.{0} empty (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 empty)  := sorry --non-trivial
lemma new_lemma_7317 (h0 : not (uniform_space (semi_normed_comm_ring fun_info) -> false)) : @complete_space.{0} (semi_normed_comm_ring.{0} fun_info) (@classical.by_contradiction'.{1} (uniform_space.{0} (semi_normed_comm_ring.{0} fun_info)) h0)  := sorry --non-trivial
lemma new_lemma_7318 (h0 : list (has_norm (random_gen (random_gen (random_gen (random_gen fun_info)))))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_7319 (h2 : ring (has_compl string_imp)) : rank_condition (has_compl string_imp) := sorry --non-trivial
lemma new_lemma_7320 (h0 : functor.add_const (list (add_right_cancel_monoid unsigned)) empty) : list.nodup (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_7321 (h0 : topological_space (linear_ordered_comm_group (option (option empty)))) : path_connected_space (linear_ordered_comm_group (option (option empty))) := sorry --non-trivial
lemma new_lemma_7322 (h0 : functor.add_const (complete_lattice (complete_semilattice_Sup num)) num) : @is_compactly_generated.{0} (complete_semilattice_Sup.{0} num) (@functor.add_const.run.{0 0} (complete_lattice.{0} (complete_semilattice_Sup.{0} num)) num h0)  := sorry --non-trivial
lemma new_lemma_7323 (h0 : has_mem.mem (complete_semilattice_Sup congr_arg_kind) has_emptyc.emptyc) : @is_modular_lattice.{0} (complete_semilattice_Sup.{0} congr_arg_kind) (@finset.pi.empty.{1 0} Type lattice.{0} (complete_semilattice_Sup.{0} congr_arg_kind) h0)  := sorry --non-trivial
lemma new_lemma_7324 (h0 : function.extfun Type monoid) : @monoid.fg.{0} znum (@function.extfun_app.{2 1} Type monoid.{0} h0 znum)  := sorry --non-trivial
lemma new_lemma_7325 (h1 : group (id (random_gen string_imp))) : normalizer_condition (id (random_gen string_imp)) := sorry --non-trivial
lemma new_lemma_7326 (h0 : topological_space (comm_group ennreal)) : loc_path_connected_space (comm_group ennreal) := sorry --non-trivial
lemma new_lemma_7327 (h0 : filter (has_zero (option unsigned))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_7328 (h0 : function.extfun Type group) : @normalizer_condition.{0} fun_info (@function.extfun_app.{2 1} Type group.{0} h0 fun_info)  := sorry --non-trivial
lemma new_lemma_7329 (h0 : finset (option (option ennreal)) -> finset (option (option ennreal)) -> Prop) : is_symm (finset (option (option ennreal))) h0 := sorry --non-trivial
lemma new_lemma_7330 (h0 : fin has_zero.zero) : @is_simple_group.{1} (simple_graph.{1} Type) (@matrix.vec_empty.{1} (group.{1} (simple_graph.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_7331 (h0 : functor.add_const (ring (free_add_monoid empty)) unsigned) : @is_principal_ideal_ring.{0} (free_add_monoid.{0} empty) (@functor.add_const.run.{0 0} (ring.{0} (free_add_monoid.{0} empty)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_7332 (h1 : has_mem.mem fun_info has_emptyc.emptyc) : @rank_condition.{0} fun_info (@finset.pi.empty.{1 0} Type ring.{0} fun_info h1)  := sorry --non-trivial
lemma new_lemma_7333 (h0 : measurable_space (mul_one_class std_gen)) (h1 : measure_theory.measure (mul_one_class std_gen)) : measure_theory.is_finite_measure h1 := sorry --non-trivial
lemma new_lemma_7334 (h0 : topological_space (linear_ordered_comm_group num)) : locally_compact_space (linear_ordered_comm_group num) := sorry --non-trivial
lemma new_lemma_7335 (h0 : functor.add_const (topological_space (ordered_comm_monoid Type)) (has_add Type)) : @totally_disconnected_space.{1} (ordered_comm_monoid.{1} Type) (@functor.add_const.run.{1 1} (topological_space.{1} (ordered_comm_monoid.{1} Type)) (has_add.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_7336 (h0 : function.extfun Type complete_lattice) : @complete_lattice.is_Sup_finite_compact.{0} (with_zero.{0} fun_info) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (with_zero.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_7337 (h0 : functor.add_const (monoid (has_add linarith.comp)) (semigroup (ring (has_to_string linarith.comp)))) : @monoid.fg.{0} (has_add.{0} linarith.comp) (@functor.add_const.run.{0 0} (monoid.{0} (has_add.{0} linarith.comp)) (semigroup.{0} (ring.{0} (has_to_string.{0} linarith.comp))) h0)  := sorry --non-trivial
lemma new_lemma_7338 (h0 : topological_space (comm_group (has_to_string pos))) : irreducible_space (comm_group (has_to_string pos)) := sorry --non-trivial
lemma new_lemma_7339 (h0 : topological_space (has_union (id linarith.comp))) : totally_separated_space (has_union (id linarith.comp)) := sorry --non-trivial
lemma new_lemma_7340 (h0 : functor.comp topological_space normed_comm_ring ennreal) : @topological_space.separable_space.{0} (normed_comm_ring.{0} ennreal) (@functor.comp.run.{0 0 0} topological_space.{0} normed_comm_ring.{0} ennreal h0)  := sorry --non-trivial
lemma new_lemma_7341 (h0 : functor.comp ring comm_group environment.implicit_infer_kind) : @is_domain.{0} (comm_group.{0} environment.implicit_infer_kind) (@functor.comp.run.{0 0 0} ring.{0} comm_group.{0} environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_7342 (h0 : has_mem.mem (has_emptyc empty) has_emptyc.emptyc) : @totally_disconnected_space.{0} (has_emptyc.{0} empty) (@finset.pi.empty.{1 0} Type topological_space.{0} (has_emptyc.{0} empty) h0)  := sorry --non-trivial
lemma new_lemma_7343 (h1 : ring (has_nnnorm reducibility_hints)) : strong_rank_condition (has_nnnorm reducibility_hints) := sorry --non-trivial
lemma new_lemma_7344 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : filter.ne_bot (function.extfun_app (function.extfun_app h0 filter) to_additive.value_type) := sorry --non-trivial
lemma new_lemma_7345 (h0 : ring (has_nndist (option empty))) : is_principal_ideal_ring (has_nndist (option empty)) := sorry --non-trivial
lemma new_lemma_7346 (h0 : set (set (nondiscrete_normed_field std_gen))) (h1 : nondiscrete_normed_field std_gen) : set.sInter h0 h1 := sorry --non-trivial
lemma new_lemma_7347 (h0 : cancel_comm_monoid_with_zero (comm_monoid congr_arg_kind)) : unique_factorization_monoid (comm_monoid congr_arg_kind) := sorry --non-trivial
lemma new_lemma_7348 (h0 : functor.add_const (group (has_neg_part pos)) unsigned) : @group.fg.{0} (has_neg_part.{0} pos) (@functor.add_const.run.{0 0} (group.{0} (has_neg_part.{0} pos)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_7349 (h0 : ring (fintype (random_gen to_additive.value_type))) : strong_rank_condition (fintype (random_gen to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_7350 (h0 : functor.add_const (group (measurable_space.dynkin_system empty)) num) : @normalizer_condition.{0} (measurable_space.dynkin_system.{0} empty) (@functor.add_const.run.{0 0} (group.{0} (measurable_space.dynkin_system.{0} empty)) num h0)  := sorry --non-trivial
lemma new_lemma_7351 (h0 : topological_space (with_one (semiring fun_info))) : totally_disconnected_space (with_one (semiring fun_info)) := sorry --non-trivial
lemma new_lemma_7352 (h0 : not (has_mem.mem (semiring (random_gen linarith.comp_source)) has_emptyc.emptyc -> false)) : @rank_condition.{0} (semiring.{0} (random_gen.{0} linarith.comp_source)) (@finset.pi.empty.{1 0} Type ring.{0} (semiring.{0} (random_gen.{0} linarith.comp_source)) (@classical.by_contradiction'.{0} (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (semiring.{0} (random_gen.{0} linarith.comp_source)) (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))) h0))  := sorry --non-trivial
lemma new_lemma_7353 (h1 : not (group (random_gen linarith.ineq) -> false)) : @is_cyclic.{0} (random_gen.{0} linarith.ineq) (@classical.by_contradiction'.{1} (group.{0} (random_gen.{0} linarith.ineq)) h1)  := sorry --non-trivial
lemma new_lemma_7354 (h0 : function.extfun Type ring) : @strong_rank_condition.{0} (non_assoc_semiring.{0} num) (@function.extfun_app.{2 1} Type ring.{0} h0 (non_assoc_semiring.{0} num))  := sorry --non-trivial
lemma new_lemma_7355 (h1 : add_group (with_bot fun_info)) : is_add_cyclic (with_bot fun_info) := sorry --non-trivial
lemma new_lemma_7356 (h2 : list (has_emptyc (has_top fun_info))) : list.nodup h2 := sorry --non-trivial
lemma new_lemma_7357 (h0 : group (cancel_monoid num)) : group.fg (cancel_monoid num) := sorry --non-trivial
lemma new_lemma_7358 (h0 : function.extfun Type ring) : @rank_condition.{0} (with_one.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type ring.{0} h0 (with_one.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_7359 (h0 : functor.add_const (topological_space (complete_distrib_lattice name)) (ring name)) : @preirreducible_space.{0} (complete_distrib_lattice.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (complete_distrib_lattice.{0} name)) (ring.{0} name) h0)  := sorry --non-trivial
lemma new_lemma_7360 (h0 : not (topological_space (normed_group fun_info) -> false)) : @irreducible_space.{0} (normed_group.{0} fun_info) (@classical.by_contradiction'.{1} (topological_space.{0} (normed_group.{0} fun_info)) h0)  := sorry --non-trivial
lemma new_lemma_7361 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @locally_compact_space.{0} (has_nndist.{0} ennreal) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_nndist.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_7362 (h0 : not (topological_space (has_norm num) -> false)) : @discrete_topology.{0} (has_norm.{0} num) (@classical.by_contradiction'.{1} (topological_space.{0} (has_norm.{0} num)) h0)  := sorry --non-trivial
lemma new_lemma_7363 (h0 : functor.add_const (topological_space (has_bot linarith.comp)) (has_neg name)) : @regular_space.{0} (has_bot.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (has_bot.{0} linarith.comp)) (has_neg.{0} name) h0)  := sorry --non-trivial
lemma new_lemma_7364 (h0 : uniform_space (ordered_comm_ring Type)) : separated_space (ordered_comm_ring Type) := sorry --non-trivial
lemma new_lemma_7365 (h0 : ordered_add_comm_monoid (comm_group environment.implicit_infer_kind)) : archimedean (comm_group environment.implicit_infer_kind) := sorry --non-trivial
lemma new_lemma_7366 (h0 : topological_space (finset (has_neg (finset Type)))) : totally_disconnected_space (finset (has_neg (finset Type))) := sorry --non-trivial
lemma new_lemma_7367 (h0 : function.extfun Type topological_space) : @t1_space.{0} (has_zero.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_zero.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_7368 (h0 : function.extfun (Type 1) topological_space) : @totally_disconnected_space.{1} (ordered_comm_ring.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} h0 (ordered_comm_ring.{1} Type))  := sorry --non-trivial
lemma new_lemma_7369 (h0 : has_lt std_gen) : nonempty (no_min_order std_gen) := sorry --non-trivial
lemma new_lemma_7370 (h0 : functor.add_const (cancel_comm_monoid_with_zero (has_bot real)) pos) : @unique_factorization_monoid.{0} (has_bot.{0} real) (@functor.add_const.run.{0 0} (cancel_comm_monoid_with_zero.{0} (has_bot.{0} real)) pos h0)  := sorry --non-trivial
lemma new_lemma_7371 (h0 : ring (boolean_algebra (has_add (finset pos)))) : is_domain (boolean_algebra (has_add (finset pos))) := sorry --non-trivial
lemma new_lemma_7372 (h0 : functor.add_const (topological_space (preorder num)) empty) : @irreducible_space.{0} (preorder.{0} num) (@functor.add_const.run.{0 0} (topological_space.{0} (preorder.{0} num)) empty h0)  := sorry --non-trivial
lemma new_lemma_7373 (h0 : function.extfun (Type 1) ring) : @is_domain.{1} (plift.{1} congr_arg_kind) (@function.extfun_app.{3 2} (Type 1) ring.{1} h0 (plift.{1} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_7374 (h0 : function.extfun Type complete_lattice) : @complete_lattice.is_Sup_finite_compact.{0} (normed_comm_ring.{0} (option.{0} pos)) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (normed_comm_ring.{0} (option.{0} pos)))  := sorry --non-trivial
lemma new_lemma_7375 (h0 : function.extfun Type ring) : @is_domain.{0} (mul_zero_class.{0} unsigned) (@function.extfun_app.{2 1} Type ring.{0} h0 (mul_zero_class.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_7376 (h0 : topological_space (add_semigroup empty)) : totally_disconnected_space (add_semigroup empty) := sorry --non-trivial
lemma new_lemma_7377 (h0 : ring (has_append (comm_ring (topological_space (comm_ring linarith.ineq))))) : rank_condition (has_append (comm_ring (topological_space (comm_ring linarith.ineq)))) := sorry --non-trivial
lemma new_lemma_7378 (h0 : function.extfun Type topological_space) : @discrete_topology.{0} (cancel_monoid.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (cancel_monoid.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_7379 (h0 : has_mem.mem (measurable_space linarith.comp) has_emptyc.emptyc) : @strong_rank_condition.{0} (measurable_space.{0} linarith.comp) (@finset.pi.empty.{1 0} Type ring.{0} (measurable_space.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_7380 (h0 : group (add_cancel_monoid (option (option unsigned)))) : is_cyclic (add_cancel_monoid (option (option unsigned))) := sorry --non-trivial
lemma new_lemma_7381 (h0 : not (function.extfun Type topological_space -> false)) : @totally_separated_space.{0} (with_one.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (with_one.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_7382 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @normalizer_condition.{0} (add_cancel_monoid.{0} ennreal) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (add_cancel_monoid.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_7383 (h0 : topological_space (canonically_linear_ordered_monoid (option unsigned))) : totally_separated_space (canonically_linear_ordered_monoid (option unsigned)) := sorry --non-trivial
lemma new_lemma_7384 (h3 : preorder (mul_one_class ereal)) (h4 : set (mul_one_class ereal)) : set.is_pwo h4 := sorry --non-trivial
lemma new_lemma_7385 (h0 : functor.add_const (topological_space (simple_graph name)) pos) : @preirreducible_space.{0} (simple_graph.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (simple_graph.{0} name)) pos h0)  := sorry --non-trivial
lemma new_lemma_7386 (h1 : complete_lattice (non_unital_non_assoc_semiring to_additive.value_type)) : is_compactly_generated (non_unital_non_assoc_semiring to_additive.value_type) := sorry --non-trivial
lemma new_lemma_7387 (h0 : topological_space (ring ennreal)) : regular_space (ring ennreal) := sorry --non-trivial
lemma new_lemma_7388 (h2 : ring (dlist (denumerable (random_gen (denumerable linarith.ineq))))) : rank_condition (dlist (denumerable (random_gen (denumerable linarith.ineq)))) := sorry --non-trivial
lemma new_lemma_7389 (h0 : function.extfun Type topological_space) : @preirreducible_space.{0} (pseudo_metric_space.{0} ennreal) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (pseudo_metric_space.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_7390 (h0 : functor.add_const (topological_space (has_to_string pos)) (finset linarith.comp)) : @sequential_space.{0} (has_to_string.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (has_to_string.{0} pos)) (finset.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_7391 (h0 : topological_space (finset (has_add (ring (ring (has_neg pos)))))) : totally_disconnected_space (finset (has_add (ring (ring (has_neg pos))))) := sorry --non-trivial
lemma new_lemma_7392 (h0 : function.extfun Type list) : palindrome (function.extfun_app h0 (add_group empty)) := sorry --non-trivial
lemma new_lemma_7393 (h0 : functor.add_const (finset (add_cancel_monoid ennreal)) num) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_7394 (h0 : topological_space (ordered_cancel_add_comm_monoid (option (option num)))) : t0_space (ordered_cancel_add_comm_monoid (option (option num))) := sorry --non-trivial
lemma new_lemma_7395 (h0 : complete_lattice (canonically_ordered_comm_semiring Type)) : complete_lattice.is_Sup_finite_compact (canonically_ordered_comm_semiring Type) := sorry --non-trivial
lemma new_lemma_7396 (h0 : has_mem.mem uniform_space has_emptyc.emptyc) : @separated_space.{0} num (@function.extfun_app.{2 1} Type uniform_space.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) uniform_space.{0} h0) num)  := sorry --non-trivial
lemma new_lemma_7397 (h0 : function.extfun Type uniform_space) : @separated_space.{0} (boolean_algebra.core.{0} pos) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (boolean_algebra.core.{0} pos))  := sorry --non-trivial
lemma new_lemma_7398 (h0 : complete_lattice (has_compl (has_neg enat))) : is_compactly_generated (has_compl (has_neg enat)) := sorry --non-trivial
lemma new_lemma_7399 (h0 : topological_space (has_add (has_nndist Type))) : irreducible_space (has_add (has_nndist Type)) := sorry --non-trivial
lemma new_lemma_7400 (h0 : not (topological_space (linear_ordered_comm_ring unsigned) -> false)) : @totally_separated_space.{0} (linear_ordered_comm_ring.{0} unsigned) (@classical.by_contradiction'.{1} (topological_space.{0} (linear_ordered_comm_ring.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_7401 (h0 : ring (normed_group (random_gen linarith.ineq))) : strong_rank_condition (normed_group (random_gen linarith.ineq)) := sorry --non-trivial
lemma new_lemma_7402 (h0 : not (uniform_space (add_left_cancel_monoid fun_info) -> false)) : @complete_space.{0} (add_left_cancel_monoid.{0} fun_info) (@classical.by_contradiction'.{1} (uniform_space.{0} (add_left_cancel_monoid.{0} fun_info)) h0)  := sorry --non-trivial
lemma new_lemma_7403 (h0 : function.extfun nat fin) : @normalizer_condition.{0} (complete_distrib_lattice.{0} linarith.comp) (@matrix.vec_empty.{0} (group.{0} (complete_distrib_lattice.{0} linarith.comp)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_7404 (h0 : group (mul_zero_class (semiring (semiring (semiring num))))) : normalizer_condition (mul_zero_class (semiring (semiring (semiring num)))) := sorry --non-trivial
lemma new_lemma_7405 (h0 : not (ring (has_top congr_arg_kind) -> false)) : @strong_rank_condition.{0} (has_top.{0} congr_arg_kind) (@classical.by_contradiction'.{1} (ring.{0} (has_top.{0} congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_7406 (h0 : functor.add_const (uniform_space (has_pos_part linarith.comp)) name) : @complete_space.{0} (has_pos_part.{0} linarith.comp) (@functor.add_const.run.{0 0} (uniform_space.{0} (has_pos_part.{0} linarith.comp)) name h0)  := sorry --non-trivial
lemma new_lemma_7407 (h0 : functor.add_const (topological_space (has_pos_part Type)) pos) : @totally_separated_space.{1} (has_pos_part.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (has_pos_part.{1} Type)) pos h0)  := sorry --non-trivial
lemma new_lemma_7408 (h0 : semiring (linear_ordered_field (finset Type))) : is_noetherian_ring (linear_ordered_field (finset Type)) := sorry --non-trivial
lemma new_lemma_7409 (h0 : topological_space (has_nndist (finset environment.implicit_infer_kind))) : regular_space (has_nndist (finset environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_7410 (h0 : topological_space (ring congr_arg_kind)) : normal_space (ring congr_arg_kind) := sorry --non-trivial
lemma new_lemma_7411 (h0 : function.extfun Type topological_space) : @sequential_space.{0} (boolean_algebra.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (boolean_algebra.{0} name))  := sorry --non-trivial
lemma new_lemma_7412 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : list.nodup (function.extfun_app (function.extfun_app h0 list) (ring Type)) := sorry --non-trivial
lemma new_lemma_7413 (h0 : complete_lattice (has_edist congr_arg_kind)) : complete_lattice.is_Sup_finite_compact (has_edist congr_arg_kind) := sorry --non-trivial
lemma new_lemma_7414 (h0 : topological_space (normed_group (random_gen fun_info))) : locally_compact_space (normed_group (random_gen fun_info)) := sorry --non-trivial
lemma new_lemma_7415 (h0 : function.extfun Type group) : @group.fg.{0} (complete_linear_order.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type group.{0} h0 (complete_linear_order.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_7416 (h0 : function.extfun Type topological_space) : @regular_space.{0} (ordered_comm_ring.{0} real) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (ordered_comm_ring.{0} real))  := sorry --non-trivial
lemma new_lemma_7417 (h0 : topological_space (has_top (semiring linarith.comp_source))) : irreducible_space (has_top (semiring linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_7418 (h0 : not (function.extfun Type ring -> false)) : @is_domain.{0} (metric_space.{0} unsigned) (@function.extfun_app.{2 1} Type ring.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type ring.{0}) h0) (metric_space.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_7419 (h0 : functor.add_const (topological_space (boolean_algebra name)) linarith.comp) : @preconnected_space.{0} (boolean_algebra.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (boolean_algebra.{0} name)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_7420 (h0 : uniform_space (add_group (semiring (has_top (semiring (has_top unsigned)))))) : complete_space (add_group (semiring (has_top (semiring (has_top unsigned))))) := sorry --non-trivial
lemma new_lemma_7421 (h0 : functor.add_const (ordered_add_comm_monoid linarith.comp) pos) : @archimedean.{0} linarith.comp (@functor.add_const.run.{0 0} (ordered_add_comm_monoid.{0} linarith.comp) pos h0)  := sorry --non-trivial
lemma new_lemma_7422 (h0 : topological_space (metric_space (semiring congr_arg_kind))) : t0_space (metric_space (semiring congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_7423 (h0 : finset (semiring (semigroup congr_arg_kind))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_7424 (h0 : topological_space (with_bot num)) : totally_separated_space (with_bot num) := sorry --non-trivial
lemma new_lemma_7425 (h0 : list (cancel_monoid (boolean_algebra name))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_7426 (h0 : add_group (complete_semilattice_Sup empty)) : is_add_cyclic (complete_semilattice_Sup empty) := sorry --non-trivial
lemma new_lemma_7427 (h0 : functor.add_const (function.extfun Type uniform_space) pos) : @separated_space.{0} (simple_graph.{0} name) (@function.extfun_app.{2 1} Type uniform_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type uniform_space.{0}) pos h0) (simple_graph.{0} name))  := sorry --non-trivial
lemma new_lemma_7428 (h0 : functor.add_const (topological_space (mul_zero_class pos)) pos) : @t1_space.{0} (mul_zero_class.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (mul_zero_class.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_7429 (h0 : add_monoid (add_cancel_monoid (option (option unsigned)))) : add_monoid.fg (add_cancel_monoid (option (option unsigned))) := sorry --non-trivial
lemma new_lemma_7430 (h0 : ring (canonically_ordered_monoid (finset real))) : rank_condition (canonically_ordered_monoid (finset real)) := sorry --non-trivial
lemma new_lemma_7431 (h0 : function.extfun Type topological_space) : @t0_space.{0} (has_top.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_top.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_7432 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_simple_group.{0} (canonically_ordered_comm_semiring.{0} pos) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (canonically_ordered_comm_semiring.{0} pos))  := sorry --non-trivial
lemma new_lemma_7433 (h0 : not (function.extfun Type topological_space -> false)) : @totally_disconnected_space.{0} (has_ssubset.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (has_ssubset.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_7434 (h0 : uniform_space (ordered_comm_monoid (add_comm_monoid linarith.comp))) : separated_space (ordered_comm_monoid (add_comm_monoid linarith.comp)) := sorry --non-trivial
lemma new_lemma_7435 (h0 : topological_space (has_ssubset (has_nnnorm char))) : path_connected_space (has_ssubset (has_nnnorm char)) := sorry --non-trivial
lemma new_lemma_7436 (h0 : list (add_comm_monoid (option (option unsigned)))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_7437 (h0 : ring (boolean_algebra (finset linarith.comp))) : strong_rank_condition (boolean_algebra (finset linarith.comp)) := sorry --non-trivial
lemma new_lemma_7438 (h0 : functor.comp ring add_cancel_monoid pos) : @strong_rank_condition.{0} (add_cancel_monoid.{0} pos) (@functor.comp.run.{0 0 0} ring.{0} add_cancel_monoid.{0} pos (@functor.comp.run.{0 0 0} ring.{0} add_cancel_monoid.{0} pos (@functor.comp.run.{0 0 0} ring.{0} add_cancel_monoid.{0} pos (@functor.comp.run.{0 0 0} ring.{0} add_cancel_monoid.{0} pos (@functor.comp.run.{0 0 0} ring.{0} add_cancel_monoid.{0} pos (@functor.comp.run.{0 0 0} ring.{0} add_cancel_monoid.{0} pos (@functor.comp.run.{0 0 0} ring.{0} add_cancel_monoid.{0} pos (@functor.comp.run.{0 0 0} ring.{0} add_cancel_monoid.{0} pos (@functor.comp.run.{0 0 0} ring.{0} add_cancel_monoid.{0} pos (@functor.comp.run.{0 0 0} ring.{0} add_cancel_monoid.{0} pos (@functor.comp.run.{0 0 0} ring.{0} add_cancel_monoid.{0} pos (@functor.comp.run.{0 0 0} ring.{0} add_cancel_monoid.{0} pos (@functor.comp.run.{0 0 0} ring.{0} add_cancel_monoid.{0} pos (@functor.comp.run.{0 0 0} ring.{0} add_cancel_monoid.{0} pos (@functor.comp.run.{0 0 0} ring.{0} add_cancel_monoid.{0} pos (@functor.comp.run.{0 0 0} ring.{0} add_cancel_monoid.{0} pos (@functor.comp.run.{0 0 0} ring.{0} add_cancel_monoid.{0} pos (@functor.comp.run.{0 0 0} ring.{0} add_cancel_monoid.{0} pos (@functor.comp.run.{0 0 0} ring.{0} add_cancel_monoid.{0} pos (@functor.comp.run.{0 0 0} ring.{0} add_cancel_monoid.{0} pos (@functor.comp.run.{0 0 0} ring.{0} add_cancel_monoid.{0} pos (@functor.comp.run.{0 0 0} ring.{0} add_cancel_monoid.{0} pos (@functor.comp.run.{0 0 0} ring.{0} add_cancel_monoid.{0} pos (@functor.comp.run.{0 0 0} ring.{0} add_cancel_monoid.{0} pos (@functor.comp.run.{0 0 0} ring.{0} add_cancel_monoid.{0} pos h0)))))))))))))))))))))))))  := sorry --non-trivial
lemma new_lemma_7439 (h0 : topological_space (add_monoid (comm_ring (linear_ordered_add_comm_group char)))) : totally_disconnected_space (add_monoid (comm_ring (linear_ordered_add_comm_group char))) := sorry --non-trivial
lemma new_lemma_7440 (h0 : function.extfun (Type 1) topological_space) : @preirreducible_space.{1} (cancel_monoid.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} h0 (cancel_monoid.{1} Type))  := sorry --non-trivial
lemma new_lemma_7441 (h0 : cancel_comm_monoid_with_zero (simple_graph (boolean_algebra.core (has_add linarith.comp)))) : unique_factorization_monoid (simple_graph (boolean_algebra.core (has_add linarith.comp))) := sorry --non-trivial
lemma new_lemma_7442 (h0 : monoid (ordered_comm_monoid (normed_lattice_add_comm_group (sub_neg_monoid real)))) : monoid.fg (ordered_comm_monoid (normed_lattice_add_comm_group (sub_neg_monoid real))) := sorry --non-trivial
lemma new_lemma_7443 (h0 : topological_space (has_to_string (mul_one_class Type))) : discrete_topology (has_to_string (mul_one_class Type)) := sorry --non-trivial
lemma new_lemma_7444 (h0 : complete_lattice (semi_normed_comm_ring reducibility_hints)) : is_compactly_generated (semi_normed_comm_ring reducibility_hints) := sorry --non-trivial
lemma new_lemma_7445 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @totally_separated_space.{0} (with_bot.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (with_bot.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_7446 (h0 : functor.add_const (topological_space (sub_neg_monoid linarith.comp)) pos) : @preconnected_space.{0} (sub_neg_monoid.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (sub_neg_monoid.{0} linarith.comp)) pos h0)  := sorry --non-trivial
lemma new_lemma_7447 (h0 : functor.add_const (semiring (has_add Type)) linarith.comp) : @is_noetherian_ring.{1} (has_add.{1} Type) (@functor.add_const.run.{1 0} (semiring.{1} (has_add.{1} Type)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_7448 (h0 : add_group (with_bot (random_gen (has_inv (random_gen linarith.comp_source))))) : is_add_cyclic (with_bot (random_gen (has_inv (random_gen linarith.comp_source)))) := sorry --non-trivial
lemma new_lemma_7449 (h0 : group (ordered_comm_ring (generalized_boolean_algebra (has_neg Type)))) : is_cyclic (ordered_comm_ring (generalized_boolean_algebra (has_neg Type))) := sorry --non-trivial
lemma new_lemma_7450 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @archimedean.{0} (has_nndist.{0} name) (@function.extfun_app.{2 1} Type ordered_add_comm_monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ordered_add_comm_monoid.{0}) (has_nndist.{0} name))  := sorry --non-trivial
lemma new_lemma_7451 (h0 : fin has_zero.zero) : @add_monoid.fg.{1} (canonically_ordered_monoid.{1} Type) (@matrix.vec_empty.{1} (add_monoid.{1} (canonically_ordered_monoid.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_7452 (h0 : function.extfun Type topological_space) : @discrete_topology.{0} auto.case_option (@function.extfun_app.{2 1} Type topological_space.{0} h0 auto.case_option)  := sorry --non-trivial
lemma new_lemma_7453 (h0 : uniform_space (has_emptyc (has_top (has_norm linarith.comp)))) : complete_space (has_emptyc (has_top (has_norm linarith.comp))) := sorry --non-trivial
lemma new_lemma_7454 (h0 : function.extfun (finset (Type -> Type)) (has_mem.mem topological_space)) : @totally_disconnected_space.{0} (has_norm.{0} fun_info) (@function.extfun_app.{2 1} Type topological_space.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) topological_space.{0} (@function.extfun_app.{2 0} (finset.{1} (Type → Type)) (@has_mem.mem.{1 1} (Type → Type) (finset.{1} (Type → Type)) (@finset.has_mem.{1} (Type → Type)) topological_space.{0}) h0 (@has_emptyc.emptyc.{1} (finset.{1} (Type → Type)) (@finset.has_emptyc.{1} (Type → Type))))) (has_norm.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_7455 (h2 : function.extfun Type topological_space) : @t0_space.{0} (denumerable.{0} string_imp) (@function.extfun_app.{2 1} Type topological_space.{0} h2 (denumerable.{0} string_imp))  := sorry --non-trivial
lemma new_lemma_7456 (h0 : functor.add_const (add_group (free_add_monoid empty)) empty) : @is_add_cyclic.{0} (free_add_monoid.{0} empty) (@functor.add_const.run.{0 0} (add_group.{0} (free_add_monoid.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_7457 (h0 : ring (topological_space (dlist (comm_ring (comm_ring char))))) : strong_rank_condition (topological_space (dlist (comm_ring (comm_ring char)))) := sorry --non-trivial
lemma new_lemma_7458 (h0 : functor.comp complete_lattice boolean_algebra.core (has_add pos)) : @is_compactly_generated.{0} (boolean_algebra.core.{0} (has_add.{0} pos)) (@functor.comp.run.{0 0 0} complete_lattice.{0} boolean_algebra.core.{0} (has_add.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_7459 (h0 : functor.add_const (topological_space (has_pos_part linarith.comp)) Type) : @locally_compact_space.{0} (has_pos_part.{0} linarith.comp) (@functor.add_const.run.{0 1} (topological_space.{0} (has_pos_part.{0} linarith.comp)) Type h0)  := sorry --non-trivial
lemma new_lemma_7460 (h0 : functor.add_const (topological_space (has_add name)) unsigned) : @normal_space.{0} (has_add.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (has_add.{0} name)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_7461 (h0 : has_mem.mem (linear_ordered_semiring (normed_group empty)) has_emptyc.emptyc) : @group.fg.{0} (linear_ordered_semiring.{0} (normed_group.{0} empty)) (@finset.pi.empty.{1 0} Type group.{0} (linear_ordered_semiring.{0} (normed_group.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_7462 (h0 : complete_lattice (boolean_algebra (comm_group (comm_group unsigned)))) : complete_lattice.is_Sup_finite_compact (boolean_algebra (comm_group (comm_group unsigned))) := sorry --non-trivial
lemma new_lemma_7463 (h0 : cancel_comm_monoid_with_zero (ordered_comm_monoid (boolean_algebra.core (has_nndist linarith.comp)))) : unique_factorization_monoid (ordered_comm_monoid (boolean_algebra.core (has_nndist linarith.comp))) := sorry --non-trivial
lemma new_lemma_7464 (h0 : fin has_zero.zero) : @path_connected_space.{0} (add_comm_monoid.{0} pos) (@matrix.vec_empty.{0} (topological_space.{0} (add_comm_monoid.{0} pos)) h0)  := sorry --non-trivial
lemma new_lemma_7465 (h0 : functor.add_const (ring (ring unsigned)) Type) : @is_domain.{0} (ring.{0} unsigned) (@functor.add_const.run.{0 1} (ring.{0} (ring.{0} unsigned)) Type h0)  := sorry --non-trivial
lemma new_lemma_7466 (h0 : function.extfun Type monoid) : @monoid.fg.{0} (normed_group.{0} empty) (@function.extfun_app.{2 1} Type monoid.{0} h0 (normed_group.{0} empty))  := sorry --non-trivial
lemma new_lemma_7467 (h0 : not (monoid (measurable_space linarith.comp) -> false)) : @monoid.fg.{0} (measurable_space.{0} linarith.comp) (@classical.by_contradiction'.{1} (monoid.{0} (measurable_space.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_7468 (h0 : functor.add_const (function.extfun nat fin) pos) : @preirreducible_space.{0} (ordered_comm_ring.{0} real) (@matrix.vec_empty.{0} (topological_space.{0} (ordered_comm_ring.{0} real)) (@function.extfun_app.{1 1} nat fin (@functor.add_const.run.{0 0} (function.extfun.{1 1} nat fin) pos h0) (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_7469 (h0 : function.extfun (Type 1) topological_space) : @path_connected_space.{1} (semigroup.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} h0 (semigroup.{1} Type))  := sorry --non-trivial
lemma new_lemma_7470 (h0 : ring (semi_normed_comm_ring ereal)) : is_domain (semi_normed_comm_ring ereal) := sorry --non-trivial
lemma new_lemma_7471 (h0 : topological_space (canonically_linear_ordered_monoid (has_Inf (has_Inf Type)))) : t1_space (canonically_linear_ordered_monoid (has_Inf (has_Inf Type))) := sorry --non-trivial
lemma new_lemma_7472 (h0 : complete_lattice (linear_ordered_comm_group_with_zero fun_info)) : complete_lattice.is_Sup_finite_compact (linear_ordered_comm_group_with_zero fun_info) := sorry --non-trivial
lemma new_lemma_7473 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_noetherian_ring.{0} (group_with_zero.{0} ennreal) (@function.extfun_app.{2 1} Type semiring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 semiring.{0}) (group_with_zero.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_7474 (h0 : functor.add_const (add_group (ring name)) name) : @is_add_cyclic.{0} (ring.{0} name) (@functor.add_const.run.{0 0} (add_group.{0} (ring.{0} name)) name h0)  := sorry --non-trivial
lemma new_lemma_7475 (h0 : topological_space (has_nnnorm (has_nnnorm (has_nnnorm to_additive.value_type)))) : totally_disconnected_space (has_nnnorm (has_nnnorm (has_nnnorm to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_7476 (h0 : functor.add_const (topological_space (option empty)) num) : @t0_space.{0} (option.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (option.{0} empty)) num h0)  := sorry --non-trivial
lemma new_lemma_7477 (h0 : list (has_add (has_add name))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_7478 (h0 : complete_lattice (has_norm (has_inv (random_gen linarith.comp_source)))) : is_compactly_generated (has_norm (has_inv (random_gen linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_7479 (h0 : prod (complete_distrib_lattice Type) (complete_distrib_lattice Type)) : id_rel h0 := sorry --non-trivial
lemma new_lemma_7480 (h0 : filter (linear_ordered_field (option congr_arg_kind))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_7481 (h0 : topological_space (has_pos_part (has_nndist pos))) : totally_disconnected_space (has_pos_part (has_nndist pos)) := sorry --non-trivial
lemma new_lemma_7482 (h0 : function.extfun (Type 1) complete_lattice) : @complete_lattice.is_Sup_finite_compact.{1} (finset.{1} Type) (@function.extfun_app.{3 2} (Type 1) complete_lattice.{1} h0 (finset.{1} Type))  := sorry --non-trivial
lemma new_lemma_7483 (h0 : functor.add_const (topological_space (has_zero environment.implicit_infer_kind)) environment.implicit_infer_kind) : @loc_path_connected_space.{0} (has_zero.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (has_zero.{0} environment.implicit_infer_kind)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_7484 (h0 : fin has_zero.zero) : @regular_space.{0} (add_comm_monoid.{0} real) (@matrix.vec_empty.{0} (topological_space.{0} (add_comm_monoid.{0} real)) h0)  := sorry --non-trivial
lemma new_lemma_7485 (h0 : functor.add_const (functor.add_const (monoid Type) Type) name) : @monoid.fg.{1} Type (@functor.add_const.run.{1 1} (monoid.{1} Type) Type (@functor.add_const.run.{1 0} (functor.add_const.{1 1} (monoid.{1} Type) Type) name h0))  := sorry --non-trivial
lemma new_lemma_7486 (h0 : functor.add_const (group (ring pos)) (has_neg Type)) : @group.fg.{0} (ring.{0} pos) (@functor.add_const.run.{0 1} (group.{0} (ring.{0} pos)) (has_neg.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_7487 (h0 : add_group (fintype (has_nnnorm fun_info))) : is_add_cyclic (fintype (has_nnnorm fun_info)) := sorry --non-trivial
lemma new_lemma_7488 (h0 : functor.add_const (list (has_to_string pos)) linarith.comp) : list.nodup (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_7489 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @totally_disconnected_space.{0} (has_star.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_star.{0} num))  := sorry --non-trivial
lemma new_lemma_7490 (h0 : functor.add_const (ring (ring linarith.comp)) (semigroup Type)) : @is_domain.{0} (ring.{0} linarith.comp) (@functor.add_const.run.{0 1} (ring.{0} (ring.{0} linarith.comp)) (semigroup.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_7491 (h0 : filter (has_top (with_bot to_additive.value_type))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_7492 (h0 : topological_space (has_zero (has_to_string (has_neg_part pos)))) : preconnected_space (has_zero (has_to_string (has_neg_part pos))) := sorry --non-trivial
lemma new_lemma_7493 (h0 : topological_space (measurable_space.dynkin_system (has_top empty))) : locally_compact_space (measurable_space.dynkin_system (has_top empty)) := sorry --non-trivial
lemma new_lemma_7494 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @unique_factorization_monoid.{0} (add_cancel_comm_monoid.{0} unsigned) (@function.extfun_app.{2 1} Type cancel_comm_monoid_with_zero.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 cancel_comm_monoid_with_zero.{0}) (add_cancel_comm_monoid.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_7495 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_domain.{0} (semiring.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (semiring.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_7496 (h0 : pseudo_metric_space (has_Inf (has_neg (has_neg (has_neg (has_neg pos)))))) (h1 : add_monoid (has_Inf (has_neg (has_neg (has_neg (has_neg pos)))))) : has_lipschitz_add (has_Inf (has_neg (has_neg (has_neg (has_neg pos))))) := sorry --non-trivial
lemma new_lemma_7497 (h0 : not (function.extfun Type group -> false)) : @is_cyclic.{0} (has_top.{0} unsigned) (@function.extfun_app.{2 1} Type group.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type group.{0}) h0) (has_top.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_7498 (h0 : list (monoid congr_arg_kind)) : palindrome h0 := sorry --non-trivial
lemma new_lemma_7499 (h0 : add_monoid (semiring (semiring empty))) : add_monoid.fg (semiring (semiring empty)) := sorry --non-trivial
lemma new_lemma_7500 (h0 : ring (has_Inf real)) : is_principal_ideal_ring (has_Inf real) := sorry --non-trivial
lemma new_lemma_7501 (h0 : function.extfun Type topological_space) : @locally_compact_space.{0} (has_top.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_top.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_7502 (h0 : group (dlist linarith.comp_source)) : is_cyclic (dlist linarith.comp_source) := sorry --non-trivial
lemma new_lemma_7503 (h0 : filter (semigroup (finset (has_neg (ring linarith.comp))))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_7504 (h0 : topological_space (parser congr_arg_kind)) : irreducible_space (parser congr_arg_kind) := sorry --non-trivial
lemma new_lemma_7505 (h0 : topological_space (ordered_comm_monoid (ring name))) : regular_space (ordered_comm_monoid (ring name)) := sorry --non-trivial
lemma new_lemma_7506 (h0 : filter (has_zero (has_to_string linarith.comp))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_7507 (h0 : topological_space (has_one congr_arg_kind)) : totally_disconnected_space (has_one congr_arg_kind) := sorry --non-trivial
lemma new_lemma_7508 (h0 : functor.add_const (ring (semigroup pos)) linarith.comp) : @rank_condition.{0} (semigroup.{0} pos) (@functor.add_const.run.{0 0} (ring.{0} (semigroup.{0} pos)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_7509 (h0 : semiring (free_add_monoid congr_arg_kind)) : is_noetherian_ring (free_add_monoid congr_arg_kind) := sorry --non-trivial
lemma new_lemma_7510 (h0 : fin has_zero.zero) : @preirreducible_space.{0} (ordered_comm_ring.{0} linarith.comp) (@matrix.vec_empty.{0} (topological_space.{0} (ordered_comm_ring.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_7511 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @t1_space.{1} Type (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 topological_space.{1}) Type)  := sorry --non-trivial
lemma new_lemma_7512 (h0 : function.extfun Type (functor.add_const (topological_space (add_cancel_monoid empty)))) : @totally_separated_space.{0} (add_cancel_monoid.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (add_cancel_monoid.{0} empty)) (option.{0} (option.{0} empty)) (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (topological_space.{0} (add_cancel_monoid.{0} empty))) h0 (option.{0} (option.{0} empty))))  := sorry --non-trivial
lemma new_lemma_7513 (h0 : topological_space (add_cancel_monoid (has_add (has_add linarith.comp)))) : path_connected_space (add_cancel_monoid (has_add (has_add linarith.comp))) := sorry --non-trivial
lemma new_lemma_7514 (h0 : functor.add_const (topological_space (linear_ordered_cancel_comm_monoid num)) empty) : @discrete_topology.{0} (linear_ordered_cancel_comm_monoid.{0} num) (@functor.add_const.run.{0 0} (topological_space.{0} (linear_ordered_cancel_comm_monoid.{0} num)) empty h0)  := sorry --non-trivial
lemma new_lemma_7515 (h0 : complete_lattice (canonically_linear_ordered_monoid (has_add Type))) : is_compactly_generated (canonically_linear_ordered_monoid (has_add Type)) := sorry --non-trivial
lemma new_lemma_7516 (h0 : group (boolean_algebra (has_add name))) : is_simple_group (boolean_algebra (has_add name)) := sorry --non-trivial
lemma new_lemma_7517 (h0 : ring (canonically_ordered_monoid (finset Type))) : is_principal_ideal_ring (canonically_ordered_monoid (finset Type)) := sorry --non-trivial
lemma new_lemma_7518 (h1 : topological_space (has_nnnorm (denumerable (denumerable to_additive.value_type)))) : t0_space (has_nnnorm (denumerable (denumerable to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_7519 (h0 : functor.comp ring normed_comm_ring Type) : @is_domain.{1} (normed_comm_ring.{1} Type) (@functor.comp.run.{1 1 1} ring.{1} normed_comm_ring.{1} Type h0)  := sorry --non-trivial
lemma new_lemma_7520 (h0 : group (distrib_lattice unsigned)) : normalizer_condition (distrib_lattice unsigned) := sorry --non-trivial
lemma new_lemma_7521 (h1 : topological_space (div_inv_monoid (random_gen to_additive.value_type))) : path_connected_space (div_inv_monoid (random_gen to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_7522 (h0 : complete_lattice num) : complete_lattice.is_Sup_finite_compact num := sorry --non-trivial
lemma new_lemma_7523 (h0 : functor.add_const (group (normed_comm_ring ennreal)) name) : @is_simple_group.{0} (normed_comm_ring.{0} ennreal) (@functor.add_const.run.{0 0} (group.{0} (normed_comm_ring.{0} ennreal)) name h0)  := sorry --non-trivial
lemma new_lemma_7524 (h0 : topological_space (has_neg_part (comm_group Type))) : t0_space (has_neg_part (comm_group Type)) := sorry --non-trivial
lemma new_lemma_7525 (h0 : ring (has_one (semiring congr_arg_kind))) : rank_condition (has_one (semiring congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_7526 (h0 : functor.add_const (topological_space (bin_tree unsigned)) unsigned) : @loc_path_connected_space.{0} (bin_tree.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (bin_tree.{0} unsigned)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_7527 (h0 : fin has_zero.zero) : @is_domain.{0} (comm_semigroup.{0} linarith.comp) (@matrix.vec_empty.{0} (ring.{0} (comm_semigroup.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_7528 (h0 : function.extfun Type topological_space) : @t0_space.{0} (metric_space.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (metric_space.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_7529 (h0 : ring (generalized_boolean_algebra (has_add (has_add (has_add pos))))) : strong_rank_condition (generalized_boolean_algebra (has_add (has_add (has_add pos)))) := sorry --non-trivial
lemma new_lemma_7530 (h0 : topological_space (has_add (has_neg name))) : preirreducible_space (has_add (has_neg name)) := sorry --non-trivial
lemma new_lemma_7531 (h0 : functor.add_const (group (has_neg environment.implicit_infer_kind)) pos) : @is_cyclic.{0} (has_neg.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (group.{0} (has_neg.{0} environment.implicit_infer_kind)) pos h0)  := sorry --non-trivial
lemma new_lemma_7532 (h0 : function.extfun Type group) : @is_cyclic.{0} (has_nndist.{0} num) (@function.extfun_app.{2 1} Type group.{0} h0 (has_nndist.{0} num))  := sorry --non-trivial
lemma new_lemma_7533 (h0 : functor.add_const (group (finset linarith.comp)) pos) : @is_cyclic.{0} (finset.{0} linarith.comp) (@functor.add_const.run.{0 0} (group.{0} (finset.{0} linarith.comp)) pos h0)  := sorry --non-trivial
lemma new_lemma_7534 (h0 : topological_space (ring (has_add (boolean_algebra.core pos)))) : loc_path_connected_space (ring (has_add (boolean_algebra.core pos))) := sorry --non-trivial
lemma new_lemma_7535 (h0 : uniform_space (has_to_string (has_add environment.implicit_infer_kind))) : separated_space (has_to_string (has_add environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_7536 (h0 : function.extfun Type add_group) : @is_add_cyclic.{0} (add_cancel_comm_monoid.{0} unsigned) (@function.extfun_app.{2 1} Type add_group.{0} h0 (add_cancel_comm_monoid.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_7537 (h1 : list (has_top linarith.ineq)) : list.nodup h1 := sorry --non-trivial
lemma new_lemma_7538 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @locally_compact_space.{0} (add_cancel_monoid.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (add_cancel_monoid.{0} name))  := sorry --non-trivial
lemma new_lemma_7539 (h0 : add_group (comm_ring (metric_space (metric_space char)))) : is_add_cyclic (comm_ring (metric_space (metric_space char))) := sorry --non-trivial
lemma new_lemma_7540 (h0 : ring (complete_semilattice_Sup to_additive.value_type)) : strong_rank_condition (complete_semilattice_Sup to_additive.value_type) := sorry --non-trivial
lemma new_lemma_7541 (h0 : topological_space (complete_linear_order (semiring num))) : totally_separated_space (complete_linear_order (semiring num)) := sorry --non-trivial
lemma new_lemma_7542 (h0 : functor.add_const (ring (has_zero Type)) linarith.comp) : @is_domain.{1} (has_zero.{1} Type) (@functor.add_const.run.{1 0} (ring.{1} (has_zero.{1} Type)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_7543 (h0 : list (finset (has_to_string (has_to_string unsigned)))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_7544 (h0 : functor.add_const Prop (add_group (semiring (measurable_space.dynkin_system linarith.comp)))) : functor.add_const.run h0 := sorry --non-trivial
lemma new_lemma_7545 (h0 : functor.add_const (function.extfun Type semiring) Type) : @is_noetherian_ring.{0} (boolean_algebra.{0} linarith.comp) (@function.extfun_app.{2 1} Type semiring.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type semiring.{0}) Type h0) (boolean_algebra.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_7546 (h0 : topological_space (semiring (random_gen (has_top fun_info)))) : path_connected_space (semiring (random_gen (has_top fun_info))) := sorry --non-trivial
lemma new_lemma_7547 (h0 : add_group (non_unital_non_assoc_semiring linarith.ineq)) : is_add_cyclic (non_unital_non_assoc_semiring linarith.ineq) := sorry --non-trivial
lemma new_lemma_7548 (h0 : ring (has_compl (random_gen string_imp))) : rank_condition (has_compl (random_gen string_imp)) := sorry --non-trivial
lemma new_lemma_7549 (h0 : semiring (measure_theory.measure_space unsigned)) : is_noetherian_ring (measure_theory.measure_space unsigned) := sorry --non-trivial
lemma new_lemma_7550 (h0 : functor.add_const (complete_lattice (has_neg_part unsigned)) unsigned) : @is_atomistic.{0} (has_neg_part.{0} unsigned) (@functor.add_const.run.{0 0} (complete_lattice.{0} (has_neg_part.{0} unsigned)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_7551 (h0 : functor.add_const (topological_space (has_nndist Type)) (ring Type)) : @preconnected_space.{1} (has_nndist.{1} Type) (@functor.add_const.run.{1 1} (topological_space.{1} (has_nndist.{1} Type)) (ring.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_7552 (h0 : functor.add_const (semiring (canonically_ordered_comm_semiring Type)) Type) : @is_noetherian_ring.{1} (canonically_ordered_comm_semiring.{1} Type) (@functor.add_const.run.{1 1} (semiring.{1} (canonically_ordered_comm_semiring.{1} Type)) Type h0)  := sorry --non-trivial
lemma new_lemma_7553 (h0 : functor.add_const (semiring (has_zero linarith.comp)) name) : @is_noetherian_ring.{0} (has_zero.{0} linarith.comp) (@functor.add_const.run.{0 0} (semiring.{0} (has_zero.{0} linarith.comp)) name h0)  := sorry --non-trivial
lemma new_lemma_7554 (h0 : set (has_neg linarith.ineq)) : set.subsingleton h0 := sorry --non-trivial
lemma new_lemma_7555 (h0 : ring (comm_ring string_imp)) : is_domain (comm_ring string_imp) := sorry --non-trivial
lemma new_lemma_7556 (h0 : functor.add_const (ordered_comm_monoid (add_cancel_monoid name)) linarith.comp) : @has_exists_mul_of_le.{0} (add_cancel_monoid.{0} name) (@functor.add_const.run.{0 0} (ordered_comm_monoid.{0} (add_cancel_monoid.{0} name)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_7557 (h0 : functor.add_const (group (complete_distrib_lattice linarith.comp)) Type) : @is_cyclic.{0} (complete_distrib_lattice.{0} linarith.comp) (@functor.add_const.run.{0 1} (group.{0} (complete_distrib_lattice.{0} linarith.comp)) Type h0)  := sorry --non-trivial
lemma new_lemma_7558 (h0 : group (ordered_comm_ring (ring (finset linarith.comp)))) : is_cyclic (ordered_comm_ring (ring (finset linarith.comp))) := sorry --non-trivial
lemma new_lemma_7559 (h0 : semiring (normed_lattice_add_comm_group (has_neg name))) : is_noetherian_ring (normed_lattice_add_comm_group (has_neg name)) := sorry --non-trivial
lemma new_lemma_7560 (h0 : function.extfun Type topological_space) : @locally_compact_space.{0} (add_cancel_comm_monoid.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (add_cancel_comm_monoid.{0} empty))  := sorry --non-trivial
lemma new_lemma_7561 (h1 : not (topological_space (comm_ring char) -> false)) : @t0_space.{0} (comm_ring.{0} char) (@classical.by_contradiction'.{1} (topological_space.{0} (comm_ring.{0} char)) h1)  := sorry --non-trivial
lemma new_lemma_7562 (h0 : topological_space (denumerable (comm_ring (mul_one_class (comm_ring char))))) : t0_space (denumerable (comm_ring (mul_one_class (comm_ring char)))) := sorry --non-trivial
lemma new_lemma_7563 (h0 : fin has_zero.zero) : @totally_separated_space.{0} (canonically_ordered_monoid.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@matrix.vec_empty.{1} (function.extfun.{2 1} Type topological_space.{0}) h0) (canonically_ordered_monoid.{0} pos))  := sorry --non-trivial
lemma new_lemma_7564 (h0 : topological_space (has_compl (random_gen (random_gen to_additive.value_type)))) : path_connected_space (has_compl (random_gen (random_gen to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_7565 (h0 : list (has_Sup (comm_monoid unsigned))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_7566 (h0 : functor.add_const (ring (comm_group pos)) pos) : @is_principal_ideal_ring.{0} (comm_group.{0} pos) (@functor.add_const.run.{0 0} (ring.{0} (comm_group.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_7567 (h0 : functor.add_const (topological_space (has_neg linarith.comp)) (ring Type)) : @t0_space.{0} (has_neg.{0} linarith.comp) (@functor.add_const.run.{0 1} (topological_space.{0} (has_neg.{0} linarith.comp)) (ring.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_7568 (h1 : ring (add_comm_semigroup string.iterator_imp)) : strong_rank_condition (add_comm_semigroup string.iterator_imp) := sorry --non-trivial
lemma new_lemma_7569 (h0 : functor.add_const Prop (add_cancel_monoid (has_add (ring Type)))) : functor.add_const.run h0 := sorry --non-trivial
lemma new_lemma_7570 (h0 : prod (preorder unsigned) (preorder unsigned)) : id_rel h0 := sorry --non-trivial
lemma new_lemma_7571 (h0 : finset (add_comm_monoid pos)) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_7572 (h0 : topological_space (has_bot (has_neg (has_neg name)))) : totally_disconnected_space (has_bot (has_neg (has_neg name))) := sorry --non-trivial
lemma new_lemma_7573 (h0 : topological_space (canonically_ordered_monoid (has_Inf (normed_lattice_add_comm_group pos)))) : path_connected_space (canonically_ordered_monoid (has_Inf (normed_lattice_add_comm_group pos))) := sorry --non-trivial
lemma new_lemma_7574 (h0 : finset (normed_comm_ring congr_arg_kind)) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_7575 (h0 : not (semiring (linear_ordered_comm_ring empty) -> false)) : @is_noetherian_ring.{0} (linear_ordered_comm_ring.{0} empty) (@classical.by_contradiction'.{1} (semiring.{0} (linear_ordered_comm_ring.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_7576 (h0 : function.extfun Type complete_lattice) : @is_atomistic.{0} (has_norm.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (has_norm.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_7577 (h0 : Prop) : id (id (id (id h0))) := sorry --non-trivial
lemma new_lemma_7578 (h0 : not (topological_space (semiring unsigned) -> false)) : @discrete_topology.{0} (semiring.{0} unsigned) (@classical.by_contradiction'.{1} (topological_space.{0} (semiring.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_7579 (h0 : uniform_space (boolean_algebra.core pos)) : separated_space (boolean_algebra.core pos) := sorry --non-trivial
lemma new_lemma_7580 (h0 : has_lt (add_comm_semigroup string.iterator_imp)) : no_max_order (add_comm_semigroup string.iterator_imp) := sorry --non-trivial
lemma new_lemma_7581 (h0 : topological_space (add_cancel_monoid (option (option (option empty))))) : locally_compact_space (add_cancel_monoid (option (option (option empty)))) := sorry --non-trivial
lemma new_lemma_7582 (h0 : topological_space int) : path_connected_space int := sorry --non-trivial
lemma new_lemma_7583 (h0 : group (has_bot (has_add (has_Inf (has_Inf pos))))) : group.fg (has_bot (has_add (has_Inf (has_Inf pos)))) := sorry --non-trivial
lemma new_lemma_7584 (h0 : function.extfun Type ring) : @is_domain.{0} (ordered_comm_ring.{0} pos) (@function.extfun_app.{2 1} Type ring.{0} h0 (ordered_comm_ring.{0} pos))  := sorry --non-trivial
lemma new_lemma_7585 (h0 : functor.add_const (group (measure_theory.measure_space num)) (semiring num)) : @group.fg.{0} (measure_theory.measure_space.{0} num) (@functor.add_const.run.{0 0} (group.{0} (measure_theory.measure_space.{0} num)) (semiring.{0} num) h0)  := sorry --non-trivial
lemma new_lemma_7586 (h0 : ring (linear_ordered_comm_group (option empty))) : strong_rank_condition (linear_ordered_comm_group (option empty)) := sorry --non-trivial
lemma new_lemma_7587 (h0 : topological_space (generalized_boolean_algebra (has_add real))) : preconnected_space (generalized_boolean_algebra (has_add real)) := sorry --non-trivial
lemma new_lemma_7588 (h0 : uniform_space (has_neg (option (option name)))) : separated_space (has_neg (option (option name))) := sorry --non-trivial
lemma new_lemma_7589 (h0 : complete_lattice (add_comm_monoid (option (option (option (option unsigned)))))) : is_atomistic (add_comm_monoid (option (option (option (option unsigned))))) := sorry --non-trivial
lemma new_lemma_7590 (h0 : fin has_zero.zero) : @separated_space.{0} (sub_neg_monoid.{0} real) (@function.extfun_app.{2 1} Type uniform_space.{0} (@matrix.vec_empty.{1} (function.extfun.{2 1} Type uniform_space.{0}) (@matrix.vec_empty.{0} (fin (@has_zero.zero.{0} nat nat.has_zero)) h0)) (sub_neg_monoid.{0} real))  := sorry --non-trivial
lemma new_lemma_7591 (h0 : not (list (measure_theory.measure_space num) -> false)) : list.nodup (classical.by_contradiction' h0) := sorry --non-trivial
lemma new_lemma_7592 (h0 : ring (boolean_algebra.core (finset name))) : is_principal_ideal_ring (boolean_algebra.core (finset name)) := sorry --non-trivial
lemma new_lemma_7593 (h0 : ring (has_append (random_gen char))) : is_domain (has_append (random_gen char)) := sorry --non-trivial
lemma new_lemma_7594 (h0 : function.extfun Type add_group) : @is_add_cyclic.{0} (add_comm_monoid.{0} empty) (@function.extfun_app.{2 1} Type add_group.{0} h0 (add_comm_monoid.{0} empty))  := sorry --non-trivial
lemma new_lemma_7595 (h0 : ring (normed_field (random_gen (has_nnnorm linarith.comp_source)))) : rank_condition (normed_field (random_gen (has_nnnorm linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_7596 (h0 : complete_lattice (has_add congr_arg_kind)) : is_compactly_generated (has_add congr_arg_kind) := sorry --non-trivial
lemma new_lemma_7597 (h0 : group (sub_neg_monoid (has_add (has_bot Type)))) : is_cyclic (sub_neg_monoid (has_add (has_bot Type))) := sorry --non-trivial
lemma new_lemma_7598 (h0 : complete_lattice (normed_lattice_add_comm_group (has_add real))) : is_atomistic (normed_lattice_add_comm_group (has_add real)) := sorry --non-trivial
lemma new_lemma_7599 (h1 : not (ring (add_monoid fun_info) -> false)) : @is_domain.{0} (add_monoid.{0} fun_info) (@classical.by_contradiction'.{1} (ring.{0} (add_monoid.{0} fun_info)) h1)  := sorry --non-trivial
lemma new_lemma_7600 (h0 : ring (ordered_comm_ring (comm_semigroup (comm_semigroup pos)))) : rank_condition (ordered_comm_ring (comm_semigroup (comm_semigroup pos))) := sorry --non-trivial
lemma new_lemma_7601 (h0 : ring (canonically_ordered_comm_semiring (has_add Type))) : rank_condition (canonically_ordered_comm_semiring (has_add Type)) := sorry --non-trivial
lemma new_lemma_7602 (h0 : topological_space (canonically_ordered_comm_semiring name)) : preirreducible_space (canonically_ordered_comm_semiring name) := sorry --non-trivial
lemma new_lemma_7603 (h0 : ring (semiring (has_norm empty))) : strong_rank_condition (semiring (has_norm empty)) := sorry --non-trivial
lemma new_lemma_7604 (h0 : not (function.extfun Type complete_lattice -> false)) : @complete_lattice.is_Sup_finite_compact.{0} (random_gen.{0} num) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type complete_lattice.{0}) h0) (random_gen.{0} num))  := sorry --non-trivial
lemma new_lemma_7605 (h0 : topological_space (comm_semigroup (ordered_comm_monoid (ordered_comm_monoid real)))) : locally_compact_space (comm_semigroup (ordered_comm_monoid (ordered_comm_monoid real))) := sorry --non-trivial
lemma new_lemma_7606 (h0 : functor.add_const (ring (non_assoc_semiring unsigned)) congr_arg_kind) : @is_principal_ideal_ring.{0} (non_assoc_semiring.{0} unsigned) (@functor.add_const.run.{0 0} (ring.{0} (non_assoc_semiring.{0} unsigned)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_7607 (h0 : uniform_space (denumerable (denumerable reducibility_hints))) : complete_space (denumerable (denumerable reducibility_hints)) := sorry --non-trivial
lemma new_lemma_7608 (h0 : add_cancel_comm_monoid unsigned -> add_cancel_comm_monoid unsigned -> Prop) : is_trans (add_cancel_comm_monoid unsigned) h0 := sorry --non-trivial
lemma new_lemma_7609 (h0 : topological_space environment.projection_info) (h1 : set (measure_theory.content environment.projection_info)) : set.finite h1 := sorry --non-trivial
lemma new_lemma_7610 (h0 : not (uniform_space (complete_semilattice_Sup to_additive.value_type) -> false)) : @complete_space.{0} (complete_semilattice_Sup.{0} to_additive.value_type) (@classical.by_contradiction'.{1} (uniform_space.{0} (complete_semilattice_Sup.{0} to_additive.value_type)) h0)  := sorry --non-trivial
lemma new_lemma_7611 (h0 : ring (non_unital_non_assoc_semiring (mul_one_class linarith.ineq))) : is_domain (non_unital_non_assoc_semiring (mul_one_class linarith.ineq)) := sorry --non-trivial
lemma new_lemma_7612 (h0 : function.extfun Type topological_space) : @normal_space.{0} (linear_ordered_comm_monoid_with_zero.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (linear_ordered_comm_monoid_with_zero.{0} empty))  := sorry --non-trivial
lemma new_lemma_7613 (h1 : not (ring (topological_space char) -> false)) : @rank_condition.{0} (topological_space.{0} char) (@classical.by_contradiction'.{1} (ring.{0} (topological_space.{0} char)) h1)  := sorry --non-trivial
lemma new_lemma_7614 (h0 : functor.add_const (group (preorder num)) num) : @is_simple_group.{0} (preorder.{0} num) (@functor.add_const.run.{0 0} (group.{0} (preorder.{0} num)) num h0)  := sorry --non-trivial
lemma new_lemma_7615 (h0 : prod (linear_ordered_add_comm_group_with_top char) (linear_ordered_add_comm_group_with_top char)) : set.diagonal (linear_ordered_add_comm_group_with_top char) h0 := sorry --non-trivial
lemma new_lemma_7616 (h0 : group (mul_zero_class name)) : is_cyclic (mul_zero_class name) := sorry --non-trivial
lemma new_lemma_7617 (h0 : has_inv (linear_ordered_add_comm_group fun_info) -> has_inv (linear_ordered_add_comm_group fun_info) -> Prop) : is_linear_order (has_inv (linear_ordered_add_comm_group fun_info)) h0 := sorry --non-trivial
lemma new_lemma_7618 (h0 : functor.add_const (topological_space (left_cancel_monoid num)) congr_arg_kind) : @preirreducible_space.{0} (left_cancel_monoid.{0} num) (@functor.add_const.run.{0 0} (topological_space.{0} (left_cancel_monoid.{0} num)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_7619 (h0 : list (has_nndist pos)) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_7620 (h0 : complete_lattice (linear_ordered_comm_ring empty)) : is_atomistic (linear_ordered_comm_ring empty) := sorry --non-trivial
lemma new_lemma_7621 (h0 : function.extfun Type uniform_space) : @complete_space.{0} (linear_ordered_semiring.{0} linarith.comp) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (linear_ordered_semiring.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_7622 (h0 : group (normed_comm_ring ennreal)) : normalizer_condition (normed_comm_ring ennreal) := sorry --non-trivial
lemma new_lemma_7623 (h0 : topological_space (random_gen (has_top linarith.comp))) : totally_disconnected_space (random_gen (has_top linarith.comp)) := sorry --non-trivial
lemma new_lemma_7624 (h0 : functor.add_const (ordered_comm_monoid (boolean_algebra.core name)) (has_add Type)) : @has_exists_mul_of_le.{0} (boolean_algebra.core.{0} name) (@functor.add_const.run.{0 1} (ordered_comm_monoid.{0} (boolean_algebra.core.{0} name)) (has_add.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_7625 (h0 : complete_lattice (topological_space (has_nnnorm linarith.ineq))) : is_compactly_generated (topological_space (has_nnnorm linarith.ineq)) := sorry --non-trivial
lemma new_lemma_7626 (h0 : topological_space (with_bot (comm_ring linarith.ineq))) : totally_disconnected_space (with_bot (comm_ring linarith.ineq)) := sorry --non-trivial
lemma new_lemma_7627 (h0 : complete_lattice (has_neg congr_arg_kind)) : is_atomistic (has_neg congr_arg_kind) := sorry --non-trivial
lemma new_lemma_7628 (h0 : topological_space (metric_space (comm_ring (comm_ring char)))) : t0_space (metric_space (comm_ring (comm_ring char))) := sorry --non-trivial
lemma new_lemma_7629 (h0 : topological_space (has_add name)) : regular_space (has_add name) := sorry --non-trivial
lemma new_lemma_7630 (h0 : ring (has_neg (has_add environment.implicit_infer_kind))) : rank_condition (has_neg (has_add environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_7631 (h0 : topological_space (has_neg pos)) : sequential_space (has_neg pos) := sorry --non-trivial
lemma new_lemma_7632 (h0 : not (topological_space (id fun_info) -> false)) : @t0_space.{0} (@id.{2} Type fun_info) (@classical.by_contradiction'.{1} (topological_space.{0} (@id.{2} Type fun_info)) h0)  := sorry --non-trivial
lemma new_lemma_7633 (h0 : group (random_gen congr_arg_kind)) : is_simple_group (random_gen congr_arg_kind) := sorry --non-trivial
lemma new_lemma_7634 (h0 : topological_space (has_ssubset to_additive.value_type)) : totally_disconnected_space (has_ssubset to_additive.value_type) := sorry --non-trivial
lemma new_lemma_7635 (h0 : function.extfun Type ring) : @rank_condition.{0} (complete_distrib_lattice.{0} unsigned) (@function.extfun_app.{2 1} Type ring.{0} h0 (complete_distrib_lattice.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_7636 (h0 : topological_space (normed_lattice_add_comm_group (finset pos))) : sequential_space (normed_lattice_add_comm_group (finset pos)) := sorry --non-trivial
lemma new_lemma_7637 (h0 : function.extfun Type topological_space) : @totally_separated_space.{0} (add_comm_monoid.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (add_comm_monoid.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_7638 (h0 : complete_lattice (has_bot (has_Inf (has_add pos)))) : complete_lattice.is_Sup_finite_compact (has_bot (has_Inf (has_add pos))) := sorry --non-trivial
lemma new_lemma_7639 (h2 : not (functor.comp complete_lattice normed_field string_imp -> false)) : @is_compactly_generated.{0} (normed_field.{0} string_imp) (@functor.comp.run.{0 0 0} complete_lattice.{0} normed_field.{0} string_imp (@classical.by_contradiction'.{1} (functor.comp.{0 0 0} complete_lattice.{0} normed_field.{0} string_imp) h2))  := sorry --non-trivial
lemma new_lemma_7640 (h0 : znum -> znum -> Prop) : is_total znum h0 := sorry --non-trivial
lemma new_lemma_7641 (h2 : complete_lattice (distrib reducibility_hints)) : is_compactly_generated (distrib reducibility_hints) := sorry --non-trivial
lemma new_lemma_7642 (h0 : functor.add_const (topological_space (has_nndist linarith.comp)) Type) : @totally_disconnected_space.{0} (has_nndist.{0} linarith.comp) (@functor.add_const.run.{0 1} (topological_space.{0} (has_nndist.{0} linarith.comp)) Type h0)  := sorry --non-trivial
lemma new_lemma_7643 (h0 : functor.add_const (semiring (has_add name)) name) : @is_noetherian_ring.{0} (has_add.{0} name) (@functor.add_const.run.{0 0} (semiring.{0} (has_add.{0} name)) name h0)  := sorry --non-trivial
lemma new_lemma_7644 (h0 : function.extfun Type topological_space) : @normal_space.{0} (normed_group.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (normed_group.{0} empty))  := sorry --non-trivial
lemma new_lemma_7645 (h0 : complete_lattice (ordered_comm_monoid pos)) : is_compactly_generated (ordered_comm_monoid pos) := sorry --non-trivial
lemma new_lemma_7646 (h0 : functor.add_const (list (has_nndist pos)) linarith.comp) : list.nodup (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_7647 (h0 : functor.add_const (monoid (generalized_boolean_algebra Type)) (has_bot name)) : @monoid.fg.{1} (generalized_boolean_algebra.{1} Type) (@functor.add_const.run.{1 0} (monoid.{1} (generalized_boolean_algebra.{1} Type)) (has_bot.{0} name) h0)  := sorry --non-trivial
lemma new_lemma_7648 (h0 : functor.add_const (complete_lattice ennreal) pos) : is_atomistic ennreal := sorry --non-trivial
lemma new_lemma_7649 (h0 : semiring (comm_group name)) : is_noetherian_ring (comm_group name) := sorry --non-trivial
lemma new_lemma_7650 (h0 : group (has_emptyc (with_bot (with_bot (with_bot to_additive.value_type))))) : group.fg (has_emptyc (with_bot (with_bot (with_bot to_additive.value_type)))) := sorry --non-trivial
lemma new_lemma_7651 (h0 : functor.add_const (topological_space (canonically_ordered_comm_semiring pos)) name) : @discrete_topology.{0} (canonically_ordered_comm_semiring.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (canonically_ordered_comm_semiring.{0} pos)) name h0)  := sorry --non-trivial
lemma new_lemma_7652 (h0 : functor.add_const (topological_space (has_edist empty)) empty) : @preirreducible_space.{0} (has_edist.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (has_edist.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_7653 (h1 : add_group (with_zero string_imp)) : is_add_cyclic (with_zero string_imp) := sorry --non-trivial
lemma new_lemma_7654 (h0 : complete_lattice (left_cancel_semigroup (semiring empty))) : is_compactly_generated (left_cancel_semigroup (semiring empty)) := sorry --non-trivial
lemma new_lemma_7655 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @irreducible_space.{0} (has_norm.{0} fun_info) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_norm.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_7656 (h0 : monoid (has_one (semiring empty))) : monoid.fg (has_one (semiring empty)) := sorry --non-trivial
lemma new_lemma_7657 (h0 : uniform_space (id (random_gen (has_inv linarith.ineq)))) : complete_space (id (random_gen (has_inv linarith.ineq))) := sorry --non-trivial
lemma new_lemma_7658 (h0 : ring (random_gen (random_gen num))) : rank_condition (random_gen (random_gen num)) := sorry --non-trivial
lemma new_lemma_7659 (h0 : not (function.extfun Type topological_space -> false)) : @totally_disconnected_space.{0} (normed_group.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (normed_group.{0} empty))  := sorry --non-trivial
lemma new_lemma_7660 (h0 : functor.add_const (topological_space (semigroup Type)) (has_zero (has_zero (has_zero pos)))) : @regular_space.{1} (semigroup.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (semigroup.{1} Type)) (has_zero.{0} (has_zero.{0} (has_zero.{0} pos))) h0)  := sorry --non-trivial
lemma new_lemma_7661 (h0 : topological_space (canonically_linear_ordered_monoid (has_neg pos))) : t1_space (canonically_linear_ordered_monoid (has_neg pos)) := sorry --non-trivial
lemma new_lemma_7662 (h0 : function.extfun Type (functor.add_const (list Type))) : palindrome (functor.add_const.run (function.extfun_app h0 linarith.comp)) := sorry --non-trivial
lemma new_lemma_7663 (h0 : uniform_space (div_inv_monoid to_additive.value_type)) : complete_space (div_inv_monoid to_additive.value_type) := sorry --non-trivial
lemma new_lemma_7664 (h0 : group (linear_ordered_add_comm_group (has_inv (has_inv linarith.comp_source)))) : is_cyclic (linear_ordered_add_comm_group (has_inv (has_inv linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_7665 (h0 : ring (distrib_lattice (has_nnnorm (has_nnnorm fun_info)))) : strong_rank_condition (distrib_lattice (has_nnnorm (has_nnnorm fun_info))) := sorry --non-trivial
lemma new_lemma_7666 (h0 : functor.add_const (list (boolean_algebra.core Type)) environment.implicit_infer_kind) : palindrome (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_7667 (h0 : topological_space (left_cancel_semigroup (semiring num))) : totally_disconnected_space (left_cancel_semigroup (semiring num)) := sorry --non-trivial
lemma new_lemma_7668 (h0 : topological_space (comm_monoid num)) : locally_compact_space (comm_monoid num) := sorry --non-trivial
lemma new_lemma_7669 (h0 : functor.add_const (function.extfun Type add_group) environment.implicit_infer_kind) : @is_add_cyclic.{0} (finset.{0} pos) (@function.extfun_app.{2 1} Type add_group.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type add_group.{0}) environment.implicit_infer_kind h0) (finset.{0} pos))  := sorry --non-trivial
lemma new_lemma_7670 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @preirreducible_space.{0} (normed_group.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (normed_group.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_7671 (h0 : add_group (has_le linarith.comp_source)) : is_add_cyclic (has_le linarith.comp_source) := sorry --non-trivial
lemma new_lemma_7672 (h2 : complete_lattice (distrib char)) : is_compactly_generated (distrib char) := sorry --non-trivial
lemma new_lemma_7673 (h0 : ring (add_semigroup (option unsigned))) : is_domain (add_semigroup (option unsigned)) := sorry --non-trivial
lemma new_lemma_7674 (h0 : not (ring (has_top unsigned) -> false)) : @rank_condition.{0} (has_top.{0} unsigned) (@classical.by_contradiction'.{1} (ring.{0} (has_top.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_7675 (h0 : topological_space (add_right_cancel_semigroup Type)) (h1 : topological_space (connected_components (add_right_cancel_semigroup Type))) : totally_disconnected_space (connected_components (add_right_cancel_semigroup Type)) := sorry --non-trivial
lemma new_lemma_7676 (h0 : uniform_space (semilattice_inf congr_arg_kind)) : separated_space (semilattice_inf congr_arg_kind) := sorry --non-trivial
lemma new_lemma_7677 (h0 : functor.add_const (function.extfun (Type 1) topological_space) (has_add (has_neg name))) : @sequential_space.{1} (has_pos_part.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) topological_space.{1}) (has_add.{0} (has_neg.{0} name)) h0) (has_pos_part.{1} Type))  := sorry --non-trivial
lemma new_lemma_7678 (h0 : functor.comp group canonically_ordered_comm_semiring environment.implicit_infer_kind) : @normalizer_condition.{0} (canonically_ordered_comm_semiring.{0} environment.implicit_infer_kind) (@functor.comp.run.{0 0 0} group.{0} canonically_ordered_comm_semiring.{0} environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_7679 (h1 : topological_space (random_gen char)) : totally_disconnected_space (random_gen char) := sorry --non-trivial
lemma new_lemma_7680 (h0 : topological_space (complete_semilattice_Sup to_additive.value_type)) : totally_separated_space (complete_semilattice_Sup to_additive.value_type) := sorry --non-trivial
lemma new_lemma_7681 (h0 : functor.add_const (function.extfun Type group) Type) : @is_simple_group.{0} (normed_comm_ring.{0} pos) (@function.extfun_app.{2 1} Type group.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type group.{0}) Type h0) (normed_comm_ring.{0} pos))  := sorry --non-trivial
lemma new_lemma_7682 (h0 : functor.add_const (topological_space (semigroup unsigned)) Type) : @topological_space.separable_space.{0} (semigroup.{0} unsigned) (@functor.add_const.run.{0 1} (topological_space.{0} (semigroup.{0} unsigned)) Type h0)  := sorry --non-trivial
lemma new_lemma_7683 (h0 : has_mem.mem topological_space has_emptyc.emptyc) : @irreducible_space.{0} (linear_ordered_add_comm_group.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) topological_space.{0} h0) (linear_ordered_add_comm_group.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_7684 (h0 : topological_space (canonically_linear_ordered_monoid (has_neg pos))) : topological_space.separable_space (canonically_linear_ordered_monoid (has_neg pos)) := sorry --non-trivial
lemma new_lemma_7685 (h0 : functor.add_const (functor.add_const (add_group pos) environment.implicit_infer_kind) linarith.comp) : @is_add_cyclic.{0} pos (@functor.add_const.run.{0 0} (add_group.{0} pos) environment.implicit_infer_kind (@functor.add_const.run.{0 0} (functor.add_const.{0 0} (add_group.{0} pos) environment.implicit_infer_kind) linarith.comp h0))  := sorry --non-trivial
lemma new_lemma_7686 (h0 : function.extfun Type topological_space) : @topological_space.separable_space.{0} (complete_distrib_lattice.{0} real) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (complete_distrib_lattice.{0} real))  := sorry --non-trivial
lemma new_lemma_7687 (h1 : uniform_space (topological_space (comm_ring char))) : complete_space (topological_space (comm_ring char)) := sorry --non-trivial
lemma new_lemma_7688 (h0 : functor.add_const (finset (has_neg_part pos)) linarith.comp) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_7689 (h0 : function.extfun Type group) : @normalizer_condition.{0} (option.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type group.{0} h0 (option.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_7690 (h0 : function.extfun Type ring) : @is_principal_ideal_ring.{0} (metric_space.{0} unsigned) (@function.extfun_app.{2 1} Type ring.{0} h0 (metric_space.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_7691 (h0 : add_monoid (normed_comm_ring Type)) : add_monoid.fg (normed_comm_ring Type) := sorry --non-trivial
lemma new_lemma_7692 (h0 : topological_space (has_div std_gen)) : totally_disconnected_space (has_div std_gen) := sorry --non-trivial
lemma new_lemma_7693 (h0 : topological_space (option pos)) : sequential_space (option pos) := sorry --non-trivial
lemma new_lemma_7694 (h0 : group (generalized_boolean_algebra (finset linarith.comp))) : is_cyclic (generalized_boolean_algebra (finset linarith.comp)) := sorry --non-trivial
lemma new_lemma_7695 (h0 : function.extfun ((Type -> Type) -> Type 1) (function.extfun (Type -> Type))) : @complete_lattice.is_Sup_finite_compact.{0} (with_bot.{0} linarith.ineq) (@id.{1} (complete_lattice.{0} (with_bot.{0} linarith.ineq)) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) (@function.extfun_app.{3 2} ((Type → Type) → Type 1) (function.extfun.{2 2} (Type → Type)) h0 (function.extfun.{2 1} Type)) complete_lattice.{0}) (with_bot.{0} linarith.ineq)))  := sorry --non-trivial
lemma new_lemma_7696 (h0 : topological_space (uniform_space linarith.comp_source)) (h1 : preorder (uniform_space linarith.comp_source)) : order_topology (uniform_space linarith.comp_source) := sorry --non-trivial
lemma new_lemma_7697 (h0 : functor.comp uniform_space add_comm_monoid name) : @separated_space.{0} (add_comm_monoid.{0} name) (@functor.comp.run.{0 0 0} uniform_space.{0} add_comm_monoid.{0} name h0)  := sorry --non-trivial
lemma new_lemma_7698 (h0 : not (function.extfun Type group -> false)) : @normalizer_condition.{0} (with_one.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type group.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type group.{0}) h0) (with_one.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_7699 (h0 : functor.add_const (ring Type) (has_Inf pos)) : @rank_condition.{1} Type (@functor.add_const.run.{1 0} (ring.{1} Type) (has_Inf.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_7700 (h0 : topological_space (ordered_comm_monoid real)) : t0_space (ordered_comm_monoid real) := sorry --non-trivial
lemma new_lemma_7701 (h0 : topological_space (with_bot unsigned)) : irreducible_space (with_bot unsigned) := sorry --non-trivial
lemma new_lemma_7702 (h0 : fin has_zero.zero) : @strong_rank_condition.{0} (has_Inf.{0} linarith.comp) (@function.extfun_app.{2 1} Type ring.{0} (@matrix.vec_empty.{1} (function.extfun.{2 1} Type ring.{0}) (@function.extfun_app.{1 1} nat fin (@matrix.vec_empty.{0} (function.extfun.{1 1} nat fin) h0) (@has_zero.zero.{0} nat nat.has_zero))) (has_Inf.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_7703 (h0 : topological_space (normed_group (has_top (has_top congr_arg_kind)))) : locally_compact_space (normed_group (has_top (has_top congr_arg_kind))) := sorry --non-trivial
lemma new_lemma_7704 (h0 : function.extfun Type uniform_space) : @complete_space.{0} (non_assoc_semiring.{0} empty) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (non_assoc_semiring.{0} empty))  := sorry --non-trivial
lemma new_lemma_7705 (h0 : monoid (canonically_ordered_monoid Type)) : monoid.fg (canonically_ordered_monoid Type) := sorry --non-trivial
lemma new_lemma_7706 (h0 : function.extfun Type topological_space) : @t0_space.{0} (ring.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (ring.{0} num))  := sorry --non-trivial
lemma new_lemma_7707 (h0 : topological_space (option unsigned)) : totally_disconnected_space (option unsigned) := sorry --non-trivial
lemma new_lemma_7708 (h0 : functor.add_const (function.extfun Type ring) pos) : @rank_condition.{0} (has_to_string.{0} name) (@function.extfun_app.{2 1} Type ring.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type ring.{0}) pos h0) (has_to_string.{0} name))  := sorry --non-trivial
lemma new_lemma_7709 (h0 h2 : multiset to_additive.value_type) : multiset.disjoint h0 h2 := sorry --non-trivial
lemma new_lemma_7710 (h0 h1 : nat) : nat.less_than_or_equal h0 h1 := sorry --non-trivial
lemma new_lemma_7711 (h0 : group (semigroup (finset Type))) : is_simple_group (semigroup (finset Type)) := sorry --non-trivial
lemma new_lemma_7712 (h0 : add_monoid (ordered_comm_ring (ring pos))) : add_monoid.fg (ordered_comm_ring (ring pos)) := sorry --non-trivial
lemma new_lemma_7713 (h0 : monoid (complete_distrib_lattice (has_add environment.implicit_infer_kind))) : monoid.fg (complete_distrib_lattice (has_add environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_7714 (h0 : topological_space (generalized_boolean_algebra (has_neg (has_nndist linarith.comp)))) : preirreducible_space (generalized_boolean_algebra (has_neg (has_nndist linarith.comp))) := sorry --non-trivial
lemma new_lemma_7715 (h0 : not (complete_lattice (has_add linarith.comp_source) -> false)) : @complete_lattice.is_Sup_finite_compact.{0} (has_add.{0} linarith.comp_source) (@classical.by_contradiction'.{1} (complete_lattice.{0} (has_add.{0} linarith.comp_source)) h0)  := sorry --non-trivial
lemma new_lemma_7716 (h0 : uniform_space (uniform_space (random_gen string_imp))) : complete_space (uniform_space (random_gen string_imp)) := sorry --non-trivial
lemma new_lemma_7717 (h0 : topological_space (has_zero (finset (finset (finset (finset (has_add (finset pos)))))))) : t0_space (has_zero (finset (finset (finset (finset (has_add (finset pos))))))) := sorry --non-trivial
lemma new_lemma_7718 (h0 : not (group (add_group empty) -> false)) : @is_cyclic.{0} (add_group.{0} empty) (@classical.by_contradiction'.{1} (group.{0} (add_group.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_7719 (h0 : function.extfun Type topological_space) : @totally_separated_space.{0} fun_info (@function.extfun_app.{2 1} Type topological_space.{0} h0 fun_info)  := sorry --non-trivial
lemma new_lemma_7720 (h0 : function.extfun Type monoid) : @monoid.fg.{0} (ordered_cancel_add_comm_monoid.{0} empty) (@function.extfun_app.{2 1} Type monoid.{0} h0 (ordered_cancel_add_comm_monoid.{0} empty))  := sorry --non-trivial
lemma new_lemma_7721 (h0 : topological_space (add_comm_semigroup to_additive.value_type)) : t0_space (add_comm_semigroup to_additive.value_type) := sorry --non-trivial
lemma new_lemma_7722 (h0 : uniform_space (measurable_space (has_one num))) : separated_space (measurable_space (has_one num)) := sorry --non-trivial
lemma new_lemma_7723 (h0 : topological_space (canonically_linear_ordered_monoid congr_arg_kind)) : preirreducible_space (canonically_linear_ordered_monoid congr_arg_kind) := sorry --non-trivial
lemma new_lemma_7724 (h0 : function.extfun (finset (Type -> Type)) (has_mem.mem complete_lattice)) : @is_atomistic.{0} (has_top.{0} fun_info) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) complete_lattice.{0} (@function.extfun_app.{2 0} (finset.{1} (Type → Type)) (@has_mem.mem.{1 1} (Type → Type) (finset.{1} (Type → Type)) (@finset.has_mem.{1} (Type → Type)) complete_lattice.{0}) h0 (@has_emptyc.emptyc.{1} (finset.{1} (Type → Type)) (@finset.has_emptyc.{1} (Type → Type))))) (has_top.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_7725 (h0 : set (add_comm_semigroup enat -> linarith.ineq)) : set.separates_points h0 := sorry --non-trivial
lemma new_lemma_7726 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @strong_rank_condition.{0} (has_add.{0} pos) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (has_add.{0} pos))  := sorry --non-trivial
lemma new_lemma_7727 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @t1_space.{0} (generalized_boolean_algebra.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (generalized_boolean_algebra.{0} name))  := sorry --non-trivial
lemma new_lemma_7728 (h0 : topological_space (ring (finset (finset name)))) : topological_space.separable_space (ring (finset (finset name))) := sorry --non-trivial
lemma new_lemma_7729 (h0 : functor.add_const (topological_space (has_Inf pos)) (has_zero pos)) : @path_connected_space.{0} (has_Inf.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (has_Inf.{0} pos)) (has_zero.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_7730 (h1 : ring (with_one to_additive.value_type)) : is_domain (with_one to_additive.value_type) := sorry --non-trivial
lemma new_lemma_7731 (h0 : not (filter (has_inv linarith.ineq) -> false)) : filter.ne_bot (classical.by_contradiction' h0) := sorry --non-trivial
lemma new_lemma_7732 (h0 : ring (comm_group (option pos))) : is_principal_ideal_ring (comm_group (option pos)) := sorry --non-trivial
lemma new_lemma_7733 (h0 : topological_space (cancel_monoid (option ennreal))) : irreducible_space (cancel_monoid (option ennreal)) := sorry --non-trivial
lemma new_lemma_7734 (h0 : filter (with_one (random_gen (random_gen (random_gen string_imp))))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_7735 (h0 : group (has_mul linarith.comp_source)) : group.fg (has_mul linarith.comp_source) := sorry --non-trivial
lemma new_lemma_7736 (h0 : functor.add_const (topological_space (comm_monoid empty)) (semiring empty)) : @t1_space.{0} (comm_monoid.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (comm_monoid.{0} empty)) (semiring.{0} empty) h0)  := sorry --non-trivial
lemma new_lemma_7737 (h0 : functor.add_const (ring (complete_distrib_lattice pos)) name) : @is_principal_ideal_ring.{0} (complete_distrib_lattice.{0} pos) (@functor.add_const.run.{0 0} (ring.{0} (complete_distrib_lattice.{0} pos)) name h0)  := sorry --non-trivial
lemma new_lemma_7738 (h0 : function.extfun (set (with_bot to_additive.value_type)) (fun (x : set (with_bot to_additive.value_type)), Prop)) : is_countably_spanning (function.extfun_app h0) := sorry --non-trivial
lemma new_lemma_7739 (h1 : group (random_gen string_imp)) : group.fg (random_gen string_imp) := sorry --non-trivial
lemma new_lemma_7740 (h0 : ring (has_add (finset (pseudo_metric_space (pseudo_metric_space name))))) : strong_rank_condition (has_add (finset (pseudo_metric_space (pseudo_metric_space name)))) := sorry --non-trivial
lemma new_lemma_7741 (h0 : monoid (distrib_lattice (has_inv fun_info))) : monoid.fg (distrib_lattice (has_inv fun_info)) := sorry --non-trivial
lemma new_lemma_7742 (h0 : functor.add_const (topological_space (semigroup environment.implicit_infer_kind)) name) : @t1_space.{0} (semigroup.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (semigroup.{0} environment.implicit_infer_kind)) name h0)  := sorry --non-trivial
lemma new_lemma_7743 (h0 : function.extfun Type uniform_space) : @separated_space.{0} (semiring.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (semiring.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_7744 (h0 : ring (partial_order (semiring unsigned))) : rank_condition (partial_order (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_7745 (h0 : function.extfun Type topological_space) : @t0_space.{0} (complete_lattice.{0} fun_info) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (complete_lattice.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_7746 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @totally_disconnected_space.{0} (comm_ring.{0} linarith.ineq) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (comm_ring.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_7747 (h0 : not (function.extfun Type topological_space -> false)) : @locally_compact_space.{0} (partial_order.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (partial_order.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_7748 (h0 : add_group (has_neg_part (finset (finset (finset ennreal))))) : is_add_cyclic (has_neg_part (finset (finset (finset ennreal)))) := sorry --non-trivial
lemma new_lemma_7749 (h0 : topological_space (has_bot (sub_neg_monoid (has_add pos)))) : totally_disconnected_space (has_bot (sub_neg_monoid (has_add pos))) := sorry --non-trivial
lemma new_lemma_7750 (h0 : fin has_zero.zero) : @is_add_cyclic.{0} (comm_semigroup.{0} real) (@matrix.vec_empty.{0} (add_group.{0} (comm_semigroup.{0} real)) h0)  := sorry --non-trivial
lemma new_lemma_7751 (h0 : function.extfun Type filter) : filter.ne_bot (function.extfun_app h0 (random_gen string_imp)) := sorry --non-trivial
lemma new_lemma_7752 (h0 : function.extfun (finset Type) (has_mem.mem (random_gen num))) : @group.fg.{0} (random_gen.{0} num) (@finset.pi.empty.{1 0} Type group.{0} (random_gen.{0} num) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (random_gen.{0} num)) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_7753 (h0 : functor.add_const (topological_space (boolean_algebra.core environment.implicit_infer_kind)) Type) : @irreducible_space.{0} (boolean_algebra.core.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 1} (topological_space.{0} (boolean_algebra.core.{0} environment.implicit_infer_kind)) Type h0)  := sorry --non-trivial
lemma new_lemma_7754 (h0 : functor.add_const (group (comm_group pos)) name) : @is_cyclic.{0} (comm_group.{0} pos) (@functor.add_const.run.{0 0} (group.{0} (comm_group.{0} pos)) name h0)  := sorry --non-trivial
lemma new_lemma_7755 (h1 : monoid (has_norm (has_norm congr_arg_kind))) : monoid.fg (has_norm (has_norm congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_7756 (h0 : function.extfun Type add_group) : @is_add_cyclic.{0} (bin_tree.{0} unsigned) (@function.extfun_app.{2 1} Type add_group.{0} h0 (bin_tree.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_7757 (h0 : topological_space (has_compl linarith.comp_source)) : t0_space (has_compl linarith.comp_source) := sorry --non-trivial
lemma new_lemma_7758 (h1 : monoid (with_bot (random_gen (random_gen string_imp)))) : monoid.fg (with_bot (random_gen (random_gen string_imp))) := sorry --non-trivial
lemma new_lemma_7759 (h0 : functor.comp topological_space comm_group name) : @loc_path_connected_space.{0} (comm_group.{0} name) (@functor.comp.run.{0 0 0} topological_space.{0} comm_group.{0} name h0)  := sorry --non-trivial
lemma new_lemma_7760 (h0 : functor.add_const (topological_space (has_add pos)) name) : @t1_space.{0} (has_add.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (has_add.{0} pos)) name h0)  := sorry --non-trivial
lemma new_lemma_7761 (h0 : uniform_space (complete_distrib_lattice (normed_comm_ring pos))) : separated_space (complete_distrib_lattice (normed_comm_ring pos)) := sorry --non-trivial
lemma new_lemma_7762 (h0 : functor.add_const (topological_space (left_cancel_monoid unsigned)) num) : @totally_separated_space.{0} (left_cancel_monoid.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (left_cancel_monoid.{0} unsigned)) num h0)  := sorry --non-trivial
lemma new_lemma_7763 (h0 : has_mem.mem topological_space has_emptyc.emptyc) : @t0_space.{0} (has_emptyc.{0} fun_info) (@function.extfun_app.{2 1} Type topological_space.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) topological_space.{0} h0) (has_emptyc.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_7764 (h0 : functor.add_const (filter (has_neg ennreal)) unsigned) : countable_Inter_filter (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_7765 (h0 : uniform_space (random_gen (uniform_space reducibility_hints))) : complete_space (random_gen (uniform_space reducibility_hints)) := sorry --non-trivial
lemma new_lemma_7766 (h0 : topological_space (boolean_algebra.core (finset (has_add ennreal)))) : locally_compact_space (boolean_algebra.core (finset (has_add ennreal))) := sorry --non-trivial
lemma new_lemma_7767 (h1 : has_mem.mem (has_emptyc linarith.comp) has_emptyc.emptyc) : @locally_compact_space.{0} (has_emptyc.{0} linarith.comp) (@finset.pi.empty.{1 0} Type topological_space.{0} (has_emptyc.{0} linarith.comp) h1)  := sorry --non-trivial
lemma new_lemma_7768 (h0 : topological_space (has_Inf (has_Inf pos))) : path_connected_space (has_Inf (has_Inf pos)) := sorry --non-trivial
lemma new_lemma_7769 (h0 : functor.add_const (monoid (normed_comm_ring name)) pos) : @monoid.fg.{0} (normed_comm_ring.{0} name) (@functor.add_const.run.{0 0} (monoid.{0} (normed_comm_ring.{0} name)) pos h0)  := sorry --non-trivial
lemma new_lemma_7770 (h0 : not (ring (topological_space linarith.ineq) -> false)) : @is_domain.{0} (topological_space.{0} linarith.ineq) (@classical.by_contradiction'.{1} (ring.{0} (topological_space.{0} linarith.ineq)) h0)  := sorry --non-trivial
lemma new_lemma_7771 (h0 : group (has_neg_part (option pos))) : is_simple_group (has_neg_part (option pos)) := sorry --non-trivial
lemma new_lemma_7772 (h0 : topological_space (linear_ordered_semiring (semiring num))) : totally_disconnected_space (linear_ordered_semiring (semiring num)) := sorry --non-trivial
lemma new_lemma_7773 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @totally_disconnected_space.{0} (add_semigroup.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (add_semigroup.{0} empty))  := sorry --non-trivial
lemma new_lemma_7774 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @totally_separated_space.{0} (has_add.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_add.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_7775 (h0 : monoid (add_cancel_monoid unsigned)) : monoid.fg (add_cancel_monoid unsigned) := sorry --non-trivial
lemma new_lemma_7776 (h0 : functor.add_const (topological_space (normed_comm_ring Type)) environment.implicit_infer_kind) : @topological_space.separable_space.{1} (normed_comm_ring.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (normed_comm_ring.{1} Type)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_7777 (h0 : topological_space (has_neg (has_add Type))) : locally_compact_space (has_neg (has_add Type)) := sorry --non-trivial
lemma new_lemma_7778 (h0 : function.extfun Type group) : @is_cyclic.{0} (complete_semilattice_Sup.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type group.{0} h0 (complete_semilattice_Sup.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_7779 (h0 : functor.add_const (function.extfun Type list) pos) : palindrome (function.extfun_app (functor.add_const.run h0) linarith.comp) := sorry --non-trivial
lemma new_lemma_7780 (h0 : topological_space (finset (has_to_string pos))) : regular_space (finset (has_to_string pos)) := sorry --non-trivial
lemma new_lemma_7781 (h0 : add_group (mul_zero_class (semiring (semiring num)))) : is_add_cyclic (mul_zero_class (semiring (semiring num))) := sorry --non-trivial
lemma new_lemma_7782 (h1 h2 : multiset std_gen) : multiset.le h1 h2 := sorry --non-trivial
lemma new_lemma_7783 (h0 : topological_space (denumerable reducibility_hints)) : totally_disconnected_space (denumerable reducibility_hints) := sorry --non-trivial
lemma new_lemma_7784 (h0 : functor.add_const (topological_space (generalized_boolean_algebra pos)) linarith.comp) : @t1_space.{0} (generalized_boolean_algebra.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (generalized_boolean_algebra.{0} pos)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_7785 (h0 : functor.add_const (topological_space (boolean_algebra name)) pos) : @loc_path_connected_space.{0} (boolean_algebra.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (boolean_algebra.{0} name)) pos h0)  := sorry --non-trivial
lemma new_lemma_7786 (h0 : not (topological_space (linear_ordered_add_comm_group to_additive.value_type) -> false)) : @locally_compact_space.{0} (linear_ordered_add_comm_group.{0} to_additive.value_type) (@classical.by_contradiction'.{1} (topological_space.{0} (linear_ordered_add_comm_group.{0} to_additive.value_type)) h0)  := sorry --non-trivial
lemma new_lemma_7787 (h0 : function.extfun Type filter) : filter.ne_bot (function.extfun_app h0 (with_one fun_info)) := sorry --non-trivial
lemma new_lemma_7788 (h0 : functor.add_const (topological_space (has_to_string name)) name) : @topological_space.separable_space.{0} (has_to_string.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (has_to_string.{0} name)) name h0)  := sorry --non-trivial
lemma new_lemma_7789 (h0 : functor.add_const (ring (free_add_monoid empty)) num) : @strong_rank_condition.{0} (free_add_monoid.{0} empty) (@functor.add_const.run.{0 0} (ring.{0} (free_add_monoid.{0} empty)) num h0)  := sorry --non-trivial
lemma new_lemma_7790 (h0 : function.extfun Type (prod (has_bot congr_arg_kind))) : id_rel (function.extfun_app h0 (has_bot congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_7791 (h1 : monoid (comm_ring (comm_ring char))) (h2 : topological_space (conj_classes (comm_ring (comm_ring char)))) : t0_space (conj_classes (comm_ring (comm_ring char))) := sorry --non-trivial
lemma new_lemma_7792 (h0 : group (topological_space (has_nnnorm (random_gen string.iterator_imp)))) : is_cyclic (topological_space (has_nnnorm (random_gen string.iterator_imp))) := sorry --non-trivial
lemma new_lemma_7793 (h0 : topological_space (complete_distrib_lattice (boolean_algebra.core Type))) : preirreducible_space (complete_distrib_lattice (boolean_algebra.core Type)) := sorry --non-trivial
lemma new_lemma_7794 (h0 : topological_space (canonically_linear_ordered_monoid ennreal)) : preirreducible_space (canonically_linear_ordered_monoid ennreal) := sorry --non-trivial
lemma new_lemma_7795 (h0 : complete_lattice (measurable_space (has_norm (has_inv (has_norm linarith.ineq))))) : is_atomistic (measurable_space (has_norm (has_inv (has_norm linarith.ineq)))) := sorry --non-trivial
lemma new_lemma_7796 (h0 : not (group (with_one linarith.comp_source) -> false)) : @is_cyclic.{0} (with_one.{0} linarith.comp_source) (@classical.by_contradiction'.{1} (group.{0} (with_one.{0} linarith.comp_source)) h0)  := sorry --non-trivial
lemma new_lemma_7797 (h0 : functor.add_const (list (preorder num)) empty) : list.nodup (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_7798 (h0 : not (ring (distrib char) -> false)) : @strong_rank_condition.{0} (distrib.{0} char) (@classical.by_contradiction'.{1} (ring.{0} (distrib.{0} char)) h0)  := sorry --non-trivial
lemma new_lemma_7799 (h0 : complete_lattice (metric_space char)) : complete_lattice.is_Sup_finite_compact (metric_space char) := sorry --non-trivial
lemma new_lemma_7800 (h0 : topological_space (has_neg_part (ring pos))) : topological_space.separable_space (has_neg_part (ring pos)) := sorry --non-trivial
lemma new_lemma_7801 (h0 : not (function.extfun Type monoid -> false)) : @monoid.fg.{0} congr_arg_kind (@function.extfun_app.{2 1} Type monoid.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type monoid.{0}) h0) congr_arg_kind)  := sorry --non-trivial
lemma new_lemma_7802 (h0 : filter (random_gen (has_norm (semiring (has_norm num))))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_7803 (h0 : topological_space (has_Sup empty)) : discrete_topology (has_Sup empty) := sorry --non-trivial
lemma new_lemma_7804 (h0 : functor.add_const (complete_lattice (left_cancel_monoid empty)) (ordered_ring unsigned)) : @complete_lattice.is_Sup_finite_compact.{0} (left_cancel_monoid.{0} empty) (@functor.add_const.run.{0 0} (complete_lattice.{0} (left_cancel_monoid.{0} empty)) (ordered_ring.{0} unsigned) h0)  := sorry --non-trivial
lemma new_lemma_7805 (h0 : finset (comm_group (has_neg_part unsigned))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_7806 (h0 : function.extfun Type complete_lattice) : @is_atomistic.{0} (ordered_comm_monoid.{0} real) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (ordered_comm_monoid.{0} real))  := sorry --non-trivial
lemma new_lemma_7807 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @monoid.fg.{0} (has_inter.{0} num) (@function.extfun_app.{2 1} Type monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 monoid.{0}) (has_inter.{0} num))  := sorry --non-trivial
lemma new_lemma_7808 (h0 : functor.comp topological_space comm_group unsigned) : @sequential_space.{0} (comm_group.{0} unsigned) (@functor.comp.run.{0 0 0} topological_space.{0} comm_group.{0} unsigned h0)  := sorry --non-trivial
lemma new_lemma_7809 (h0 : group (semigroup (option unsigned))) : is_simple_group (semigroup (option unsigned)) := sorry --non-trivial
lemma new_lemma_7810 (h0 : function.extfun (finset Type) (has_mem.mem unsigned)) : @strong_rank_condition.{0} unsigned (@finset.pi.empty.{1 0} Type ring.{0} unsigned (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) unsigned) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_7811 (h0 : functor.add_const (topological_space (boolean_algebra.core name)) environment.implicit_infer_kind) : @preirreducible_space.{0} (boolean_algebra.core.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (boolean_algebra.core.{0} name)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_7812 (h0 : functor.add_const (ring (ring name)) linarith.comp) : @is_domain.{0} (ring.{0} name) (@functor.add_const.run.{0 0} (ring.{0} (ring.{0} name)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_7813 (h0 : function.extfun Type complete_lattice) : @is_compactly_generated.{0} (linear_ordered_semiring.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (linear_ordered_semiring.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_7814 (h0 : add_monoid (complete_linear_order (has_sub congr_arg_kind))) : add_monoid.fg (complete_linear_order (has_sub congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_7815 (h0 : function.extfun Type topological_space) : @locally_compact_space.{0} (has_neg.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_neg.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_7816 (h0 : topological_space (finset (mul_one_class pos))) : preirreducible_space (finset (mul_one_class pos)) := sorry --non-trivial
lemma new_lemma_7817 (h0 : not (ring (distrib_lattice to_additive.value_type) -> false)) : @is_domain.{0} (distrib_lattice.{0} to_additive.value_type) (@classical.by_contradiction'.{1} (ring.{0} (distrib_lattice.{0} to_additive.value_type)) h0)  := sorry --non-trivial
lemma new_lemma_7818 (h0 : functor.add_const (complete_lattice (has_nndist environment.implicit_infer_kind)) name) : @is_atomistic.{0} (has_nndist.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (complete_lattice.{0} (has_nndist.{0} environment.implicit_infer_kind)) name h0)  := sorry --non-trivial
lemma new_lemma_7819 (h0 : monoid (comm_group (comm_group (comm_group name)))) : monoid.fg (comm_group (comm_group (comm_group name))) := sorry --non-trivial
lemma new_lemma_7820 (h0 : set (mul_one_class (mul_one_class enat) -> std_gen)) : set.separates_points h0 := sorry --non-trivial
lemma new_lemma_7821 (h0 : function.extfun Type topological_space) : @irreducible_space.{0} (ordered_comm_ring.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (ordered_comm_ring.{0} name))  := sorry --non-trivial
lemma new_lemma_7822 (h0 : not (uniform_space (measurable_space.dynkin_system empty) -> false)) : @separated_space.{0} (measurable_space.dynkin_system.{0} empty) (@classical.by_contradiction'.{1} (uniform_space.{0} (measurable_space.dynkin_system.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_7823 (h0 : functor.add_const (topological_space unsigned) empty) : @t1_space.{0} unsigned (@functor.add_const.run.{0 0} (topological_space.{0} unsigned) empty h0)  := sorry --non-trivial
lemma new_lemma_7824 (h0 : topological_space (with_bot (has_norm (has_norm to_additive.value_type)))) : t0_space (with_bot (has_norm (has_norm to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_7825 (h0 : topological_space (boolean_algebra.core congr_arg_kind)) : totally_disconnected_space (boolean_algebra.core congr_arg_kind) := sorry --non-trivial
lemma new_lemma_7826 (h1 : uniform_space (complete_semilattice_Sup linarith.comp)) : separated_space (complete_semilattice_Sup linarith.comp) := sorry --non-trivial
lemma new_lemma_7827 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @unique_factorization_monoid.{0} (add_right_cancel_monoid.{0} num) (@function.extfun_app.{2 1} Type cancel_comm_monoid_with_zero.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 cancel_comm_monoid_with_zero.{0}) (add_right_cancel_monoid.{0} num))  := sorry --non-trivial
lemma new_lemma_7828 (h0 : ordered_comm_monoid (complete_distrib_lattice (ring pos))) : has_exists_mul_of_le (complete_distrib_lattice (ring pos)) := sorry --non-trivial
lemma new_lemma_7829 (h0 : functor.add_const (ring (has_nndist Type)) Type) : @rank_condition.{1} (has_nndist.{1} Type) (@functor.add_const.run.{1 1} (ring.{1} (has_nndist.{1} Type)) Type h0)  := sorry --non-trivial
lemma new_lemma_7830 (h0 : uniform_space (has_one (has_top unsigned))) : separated_space (has_one (has_top unsigned)) := sorry --non-trivial
lemma new_lemma_7831 (h0 : topological_space (normed_comm_ring (has_add unsigned))) : topological_space.separable_space (normed_comm_ring (has_add unsigned)) := sorry --non-trivial
lemma new_lemma_7832 (h0 : functor.add_const (function.extfun Type monoid) Type) : @monoid.fg.{0} (normed_comm_ring.{0} pos) (@function.extfun_app.{2 1} Type monoid.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type monoid.{0}) Type h0) (normed_comm_ring.{0} pos))  := sorry --non-trivial
lemma new_lemma_7833 (h0 : function.extfun Type ring) : @rank_condition.{0} (add_left_cancel_semigroup.{0} (semiring.{0} (semiring.{0} empty))) (@function.extfun_app.{2 1} Type ring.{0} h0 (add_left_cancel_semigroup.{0} (semiring.{0} (semiring.{0} empty))))  := sorry --non-trivial
lemma new_lemma_7834 (h0 : add_group (canonically_ordered_comm_semiring (option empty))) : is_add_cyclic (canonically_ordered_comm_semiring (option empty)) := sorry --non-trivial
lemma new_lemma_7835 (h0 : topological_space (partial_order (has_top empty))) : path_connected_space (partial_order (has_top empty)) := sorry --non-trivial
lemma new_lemma_7836 (h0 : topological_space (has_Inf (finset (has_pos_part (finset linarith.comp))))) : totally_separated_space (has_Inf (finset (has_pos_part (finset linarith.comp)))) := sorry --non-trivial
lemma new_lemma_7837 (h0 : ring (add_group (semiring congr_arg_kind))) : rank_condition (add_group (semiring congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_7838 (h0 : fin has_zero.zero) : @complete_lattice.is_Sup_finite_compact.{0} (generalized_boolean_algebra.{0} name) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@matrix.vec_empty.{1} (function.extfun.{2 1} Type complete_lattice.{0}) h0) (generalized_boolean_algebra.{0} name))  := sorry --non-trivial
lemma new_lemma_7839 (h0 : group (topological_space (has_ssubset char))) : is_cyclic (topological_space (has_ssubset char)) := sorry --non-trivial
lemma new_lemma_7840 (h0 : function.extfun Type topological_space) : @totally_separated_space.{0} (is_R_or_C.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (is_R_or_C.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_7841 (h0 : function.extfun (Type 1) topological_space) : @sequential_space.{1} (has_pos_part.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} h0 (has_pos_part.{1} Type))  := sorry --non-trivial
lemma new_lemma_7842 (h0 : functor.comp topological_space comm_group linarith.comp) : @locally_compact_space.{0} (comm_group.{0} linarith.comp) (@functor.comp.run.{0 0 0} topological_space.{0} comm_group.{0} linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_7843 (h1 : ring (semi_normed_comm_ring std_gen)) : strong_rank_condition (semi_normed_comm_ring std_gen) := sorry --non-trivial
lemma new_lemma_7844 (h0 : topological_space (has_neg_part unsigned)) : sequential_space (has_neg_part unsigned) := sorry --non-trivial
lemma new_lemma_7845 (h0 : function.extfun Type topological_space) : @discrete_topology.{0} (linear_ordered_semiring.{0} (has_union.{0} linarith.comp)) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (linear_ordered_semiring.{0} (has_union.{0} linarith.comp)))  := sorry --non-trivial
lemma new_lemma_7846 (h0 : ring (has_pos_part (finset linarith.comp))) : is_domain (has_pos_part (finset linarith.comp)) := sorry --non-trivial
lemma new_lemma_7847 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_domain.{0} (has_emptyc.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (has_emptyc.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_7848 (h0 : functor.add_const (filter (boolean_algebra pos)) Type) : filter.ne_bot (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_7849 (h0 : function.extfun (finset Type) (has_mem.mem (semiring linarith.comp_source))) : @is_atomistic.{0} (semiring.{0} linarith.comp_source) (@finset.pi.empty.{1 0} Type complete_lattice.{0} (semiring.{0} linarith.comp_source) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (semiring.{0} linarith.comp_source)) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_7850 (h0 : function.extfun Type complete_lattice) : @is_atomistic.{0} (has_neg.{0} pos) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (has_neg.{0} pos))  := sorry --non-trivial
lemma new_lemma_7851 (h0 : function.extfun Type uniform_space) : @separated_space.{0} linarith.comp_source (@function.extfun_app.{2 1} Type uniform_space.{0} h0 linarith.comp_source)  := sorry --non-trivial
lemma new_lemma_7852 (h0 : list (finset unsigned)) : palindrome h0 := sorry --non-trivial
lemma new_lemma_7853 (h0 : not (complete_lattice (normed_group linarith.comp_source) -> false)) : @complete_lattice.is_Sup_finite_compact.{0} (normed_group.{0} linarith.comp_source) (@classical.by_contradiction'.{1} (complete_lattice.{0} (normed_group.{0} linarith.comp_source)) h0)  := sorry --non-trivial
lemma new_lemma_7854 (h0 : fin has_zero.zero) : @is_domain.{1} (boolean_algebra.{1} Type) (@matrix.vec_empty.{1} (ring.{1} (boolean_algebra.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_7855 (h0 : ring (has_nnnorm fun_info)) : strong_rank_condition (has_nnnorm fun_info) := sorry --non-trivial
lemma new_lemma_7856 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @complete_space.{0} (has_neg.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type uniform_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 uniform_space.{0}) (has_neg.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_7857 (h0 : ring (ordered_comm_ring (has_bot (has_neg Type)))) : is_principal_ideal_ring (ordered_comm_ring (has_bot (has_neg Type))) := sorry --non-trivial
lemma new_lemma_7858 (h0 : topological_space (group_with_zero num)) : normal_space (group_with_zero num) := sorry --non-trivial
lemma new_lemma_7859 (h0 : function.extfun Type topological_space) : @t1_space.{0} (complete_distrib_lattice.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (complete_distrib_lattice.{0} num))  := sorry --non-trivial
lemma new_lemma_7860 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @normalizer_condition.{0} (has_top.{0} fun_info) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (has_top.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_7861 (h0 : monoid (linear_ordered_add_comm_group (has_norm fun_info))) : monoid.fg (linear_ordered_add_comm_group (has_norm fun_info)) := sorry --non-trivial
lemma new_lemma_7862 (h0 : topological_space (normed_group (random_gen (random_gen (random_gen fun_info))))) : locally_compact_space (normed_group (random_gen (random_gen (random_gen fun_info)))) := sorry --non-trivial
lemma new_lemma_7863 (h0 : complete_lattice (has_zero (has_add (has_add (boolean_algebra.core name))))) : is_atomistic (has_zero (has_add (has_add (boolean_algebra.core name)))) := sorry --non-trivial
lemma new_lemma_7864 (h0 : ring (normed_group (has_inv linarith.comp_source))) : rank_condition (normed_group (has_inv linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_7865 (h0 : topological_space (random_gen (has_norm unsigned))) : totally_separated_space (random_gen (has_norm unsigned)) := sorry --non-trivial
lemma new_lemma_7866 (h0 : complete_lattice (has_nnnorm (random_gen fun_info))) : is_compactly_generated (has_nnnorm (random_gen fun_info)) := sorry --non-trivial
lemma new_lemma_7867 (h0 : functor.add_const (topological_space (add_comm_monoid environment.implicit_infer_kind)) (finset pos)) : @totally_disconnected_space.{0} (add_comm_monoid.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (add_comm_monoid.{0} environment.implicit_infer_kind)) (finset.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_7868 (h0 : topological_space (has_compl string.iterator_imp)) (h1 : string_imp -> preorder (has_compl string.iterator_imp)) (h2 : ordinal) (h3 : has_lt.lt h2 (ordinal.type well_ordering_rel)) : @order_topology.{0} (has_compl.{0} string.iterator_imp) h0 (@ordinal.bfamily_of_family.{0 0} (preorder.{0} (has_compl.{0} string.iterator_imp)) string_imp h1 h2 h3)  := sorry --non-trivial
lemma new_lemma_7869 (h0 : functor.add_const (list (normed_linear_ordered_group congr_arg_kind)) (option unsigned)) : palindrome (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_7870 (h0 : finset (boolean_algebra.core (boolean_algebra (has_neg pos)))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_7871 (h0 : topological_space (add_cancel_monoid (finset pos))) : topological_space.separable_space (add_cancel_monoid (finset pos)) := sorry --non-trivial
lemma new_lemma_7872 (h0 : topological_space (topological_space (random_gen (random_gen char)))) : path_connected_space (topological_space (random_gen (random_gen char))) := sorry --non-trivial
lemma new_lemma_7873 (h0 : topological_space (with_bot (has_top (has_top (has_top fun_info))))) : totally_separated_space (with_bot (has_top (has_top (has_top fun_info)))) := sorry --non-trivial
lemma new_lemma_7874 (h0 : list (has_norm (random_gen linarith.ineq))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_7875 (h0 : functor.add_const (filter (finset environment.implicit_infer_kind)) linarith.comp) : filter.ne_bot (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_7876 (h0 : topological_space (distrib_lattice (random_gen linarith.ineq))) : totally_disconnected_space (distrib_lattice (random_gen linarith.ineq)) := sorry --non-trivial
lemma new_lemma_7877 (h0 : functor.add_const (topological_space (has_pos_part linarith.comp)) linarith.comp) : @totally_separated_space.{0} (has_pos_part.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (has_pos_part.{0} linarith.comp)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_7878 (h0 : fin has_zero.zero) : @path_connected_space.{0} (ordered_comm_ring.{0} real) (@matrix.vec_empty.{0} (topological_space.{0} (ordered_comm_ring.{0} real)) h0)  := sorry --non-trivial
lemma new_lemma_7879 (h0 : function.extfun (finset Type) (has_mem.mem (has_top fun_info))) : @discrete_topology.{0} (has_top.{0} fun_info) (@finset.pi.empty.{1 0} Type topological_space.{0} (has_top.{0} fun_info) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (has_top.{0} fun_info)) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_7880 (h0 : topological_space (semiring (has_top (has_top num)))) : irreducible_space (semiring (has_top (has_top num))) := sorry --non-trivial
lemma new_lemma_7881 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @preirreducible_space.{1} (has_to_string.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 topological_space.{1}) (has_to_string.{1} Type))  := sorry --non-trivial
lemma new_lemma_7882 (h0 : add_group (with_zero (has_inv to_additive.value_type))) : is_add_cyclic (with_zero (has_inv to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_7883 (h0 : functor.add_const (monoid (has_add pos)) (finset (finset linarith.comp))) : @monoid.fg.{0} (has_add.{0} pos) (@functor.add_const.run.{0 0} (monoid.{0} (has_add.{0} pos)) (finset.{0} (finset.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_7884 (h0 : cancel_comm_monoid_with_zero (monoid pos)) : unique_factorization_monoid (monoid pos) := sorry --non-trivial
lemma new_lemma_7885 (h0 : function.extfun (finset Type) (has_mem.mem (normed_group num))) : @is_add_cyclic.{0} (normed_group.{0} num) (@finset.pi.empty.{1 0} Type add_group.{0} (normed_group.{0} num) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (normed_group.{0} num)) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_7886 (h0 : function.extfun Type group) : @is_cyclic.{0} (complete_linear_order.{0} unsigned) (@function.extfun_app.{2 1} Type group.{0} h0 (complete_linear_order.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_7887 (h0 : functor.add_const (topological_space nnreal) unsigned) : topological_space.separable_space nnreal := sorry --non-trivial
lemma new_lemma_7888 (h0 : topological_space (has_pos_part (has_pos_part (finset Type)))) : normal_space (has_pos_part (has_pos_part (finset Type))) := sorry --non-trivial
lemma new_lemma_7889 (h0 : topological_space (boolean_algebra (finset (finset (has_pos_part pos))))) : preirreducible_space (boolean_algebra (finset (finset (has_pos_part pos)))) := sorry --non-trivial
lemma new_lemma_7890 (h0 : ring (measurable_space.dynkin_system (has_norm linarith.comp))) : rank_condition (measurable_space.dynkin_system (has_norm linarith.comp)) := sorry --non-trivial
lemma new_lemma_7891 (h0 : group (add_comm_monoid (sub_neg_monoid (has_Inf real)))) : is_cyclic (add_comm_monoid (sub_neg_monoid (has_Inf real))) := sorry --non-trivial
lemma new_lemma_7892 (h0 : functor.add_const (filter (normed_comm_ring Type)) linarith.comp) : countable_Inter_filter (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_7893 (h0 : function.extfun Type ring) : @strong_rank_condition.{0} (metric_space.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type ring.{0} h0 (metric_space.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_7894 (h0 : prod (has_neg (finset pos)) (has_neg (finset pos))) : id_rel h0 := sorry --non-trivial
lemma new_lemma_7895 (h0 : uniform_space (linear_ordered_comm_group_with_zero (random_gen char))) : complete_space (linear_ordered_comm_group_with_zero (random_gen char)) := sorry --non-trivial
lemma new_lemma_7896 (h0 : not (topological_space (measurable_space num) -> false)) : @t0_space.{0} (measurable_space.{0} num) (@classical.by_contradiction'.{1} (topological_space.{0} (measurable_space.{0} num)) h0)  := sorry --non-trivial
lemma new_lemma_7897 (h0 : not (function.extfun Type topological_space -> false)) : @totally_disconnected_space.{0} (dlist.{0} fun_info) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (dlist.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_7898 (h0 : function.extfun Type ordered_add_comm_monoid) : @archimedean.{0} (left_cancel_semigroup.{0} unsigned) (@function.extfun_app.{2 1} Type ordered_add_comm_monoid.{0} h0 (left_cancel_semigroup.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_7899 (h0 : complete_lattice (add_cancel_monoid (has_to_string (has_add environment.implicit_infer_kind)))) : is_atomistic (add_cancel_monoid (has_to_string (has_add environment.implicit_infer_kind))) := sorry --non-trivial
lemma new_lemma_7900 (h0 : functor.add_const (complete_lattice (has_nndist pos)) pos) : @is_compactly_generated.{0} (has_nndist.{0} pos) (@functor.add_const.run.{0 0} (complete_lattice.{0} (has_nndist.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_7901 (h0 : complete_lattice (has_bot (has_pos_part real))) : is_compactly_generated (has_bot (has_pos_part real)) := sorry --non-trivial
lemma new_lemma_7902 (h0 : topological_space (linear_ordered_semiring unsigned)) : t0_space (linear_ordered_semiring unsigned) := sorry --non-trivial
lemma new_lemma_7903 (h0 : uniform_space (measurable_space.dynkin_system (semiring (semiring unsigned)))) : complete_space (measurable_space.dynkin_system (semiring (semiring unsigned))) := sorry --non-trivial
lemma new_lemma_7904 (h0 : functor.add_const (topological_space (has_add Type)) (has_pos_part (finset (finset Type)))) : @sequential_space.{1} (has_add.{1} Type) (@functor.add_const.run.{1 1} (topological_space.{1} (has_add.{1} Type)) (has_pos_part.{1} (finset.{1} (finset.{1} Type))) h0)  := sorry --non-trivial
lemma new_lemma_7905 (h0 : functor.add_const (group (finset Type)) (has_add Type)) : @is_simple_group.{1} (finset.{1} Type) (@functor.add_const.run.{1 1} (group.{1} (finset.{1} Type)) (has_add.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_7906 (h0 : ring (semiring (semiring (semiring linarith.comp)))) : rank_condition (semiring (semiring (semiring linarith.comp))) := sorry --non-trivial
lemma new_lemma_7907 (h0 h1 : multiset (add_comm_semigroup linarith.ineq)) : multiset.subset h0 h1 := sorry --non-trivial
lemma new_lemma_7908 (h0 : not (function.extfun Type group -> false)) : @normalizer_condition.{0} (has_top.{0} unsigned) (@function.extfun_app.{2 1} Type group.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type group.{0}) h0) (has_top.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_7909 (h1 : has_mem.mem (has_norm linarith.comp) has_emptyc.emptyc) : @totally_disconnected_space.{0} (has_norm.{0} linarith.comp) (@finset.pi.empty.{1 0} Type topological_space.{0} (has_norm.{0} linarith.comp) h1)  := sorry --non-trivial
lemma new_lemma_7910 (h0 : functor.add_const (monoid (ring pos)) (ring pos)) : @monoid.fg.{0} (ring.{0} pos) (@functor.add_const.run.{0 0} (monoid.{0} (ring.{0} pos)) (ring.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_7911 (h0 : functor.add_const (add_group (boolean_algebra.core environment.implicit_infer_kind)) linarith.comp) : @is_add_cyclic.{0} (boolean_algebra.core.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (add_group.{0} (boolean_algebra.core.{0} environment.implicit_infer_kind)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_7912 (h2 : function.extfun Type group) : @normalizer_condition.{0} linarith.ineq (@function.extfun_app.{2 1} Type group.{0} h2 linarith.ineq)  := sorry --non-trivial
lemma new_lemma_7913 (h0 : topological_space (has_inner (option (option empty)) congr_arg_kind)) : totally_disconnected_space (has_inner (option (option empty)) congr_arg_kind) := sorry --non-trivial
lemma new_lemma_7914 (h0 : topological_space (add_cancel_monoid (comm_group Type))) : topological_space.separable_space (add_cancel_monoid (comm_group Type)) := sorry --non-trivial
lemma new_lemma_7915 (h0 : function.extfun Type semiring) : @is_noetherian_ring.{0} (partial_order.{0} num) (@function.extfun_app.{2 1} Type semiring.{0} h0 (partial_order.{0} num))  := sorry --non-trivial
lemma new_lemma_7916 (h0 : cancel_comm_monoid_with_zero (linear_ordered_comm_group unsigned)) : unique_factorization_monoid (linear_ordered_comm_group unsigned) := sorry --non-trivial
lemma new_lemma_7917 (h0 : add_group (monoid (option ennreal))) : is_add_cyclic (monoid (option ennreal)) := sorry --non-trivial
lemma new_lemma_7918 (h0 : uniform_space (comm_group (add_cancel_monoid name))) : complete_space (comm_group (add_cancel_monoid name)) := sorry --non-trivial
lemma new_lemma_7919 (h0 : functor.add_const (ring (has_neg unsigned)) linarith.comp) : @rank_condition.{0} (has_neg.{0} unsigned) (@functor.add_const.run.{0 0} (ring.{0} (has_neg.{0} unsigned)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_7920 (h0 : topological_space (has_neg_part (add_comm_semigroup char))) : t0_space (has_neg_part (add_comm_semigroup char)) := sorry --non-trivial
lemma new_lemma_7921 (h0 : topological_space (non_unital_non_assoc_semiring (mul_one_class environment.projection_info))) : path_connected_space (non_unital_non_assoc_semiring (mul_one_class environment.projection_info)) := sorry --non-trivial
lemma new_lemma_7922 (h2 : ring linarith.ineq) : rank_condition linarith.ineq := sorry --non-trivial
lemma new_lemma_7923 (h0 : ring (has_top (has_ssubset linarith.ineq))) : strong_rank_condition (has_top (has_ssubset linarith.ineq)) := sorry --non-trivial
lemma new_lemma_7924 (h0 : cancel_comm_monoid_with_zero (has_sub (semiring (semiring (semiring congr_arg_kind))))) : unique_factorization_monoid (has_sub (semiring (semiring (semiring congr_arg_kind)))) := sorry --non-trivial
lemma new_lemma_7925 (h0 : topological_space (complete_linear_order (semiring empty))) : topological_space.separable_space (complete_linear_order (semiring empty)) := sorry --non-trivial
lemma new_lemma_7926 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @monoid.fg.{0} (linear_ordered_semiring.{0} linarith.comp) (@function.extfun_app.{2 1} Type monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 monoid.{0}) (linear_ordered_semiring.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_7927 (h1 : ring (add_comm_semigroup string.iterator_imp)) : is_domain (add_comm_semigroup string.iterator_imp) := sorry --non-trivial
lemma new_lemma_7928 (h0 : function.extfun Type filter) : filter.ne_bot (function.extfun_app h0 (has_to_string num)) := sorry --non-trivial
lemma new_lemma_7929 (h0 : not (function.extfun Type complete_lattice -> false)) : @is_atomistic.{0} (measurable_space.dynkin_system.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type complete_lattice.{0}) h0) (measurable_space.dynkin_system.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_7930 (h0 : topological_space (has_dist empty)) : irreducible_space (has_dist empty) := sorry --non-trivial
lemma new_lemma_7931 (h0 : functor.add_const (monoid (has_star empty)) (semiring (semiring empty))) : @monoid.fg.{0} (has_star.{0} empty) (@functor.add_const.run.{0 0} (monoid.{0} (has_star.{0} empty)) (semiring.{0} (semiring.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_7932 (h0 : topological_space (generalized_boolean_algebra (ring (has_add pos)))) : t1_space (generalized_boolean_algebra (ring (has_add pos))) := sorry --non-trivial
lemma new_lemma_7933 (h0 : topological_space (boolean_algebra.core (boolean_algebra Type))) : loc_path_connected_space (boolean_algebra.core (boolean_algebra Type)) := sorry --non-trivial
lemma new_lemma_7934 (h0 : group (finset (has_neg (finset (ring Type))))) : group.fg (finset (has_neg (finset (ring Type)))) := sorry --non-trivial
lemma new_lemma_7935 (h0 : function.extfun Type ordered_add_comm_monoid) : @archimedean.{0} (monoid_with_zero.{0} pos) (@function.extfun_app.{2 1} Type ordered_add_comm_monoid.{0} h0 (monoid_with_zero.{0} pos))  := sorry --non-trivial
lemma new_lemma_7936 (h0 : ring (boolean_algebra (has_add environment.implicit_infer_kind))) : rank_condition (boolean_algebra (has_add environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_7937 (h0 : topological_space (plift congr_arg_kind)) : totally_disconnected_space (plift congr_arg_kind) := sorry --non-trivial
lemma new_lemma_7938 (h0 : add_group (normed_comm_ring (has_to_string Type))) : is_add_cyclic (normed_comm_ring (has_to_string Type)) := sorry --non-trivial
lemma new_lemma_7939 (h2 : group (normed_group (random_gen to_additive.value_type))) : is_cyclic (normed_group (random_gen to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_7940 (h0 : not (function.extfun Type add_monoid -> false)) : @add_monoid.fg.{0} (add_group.{0} empty) (@function.extfun_app.{2 1} Type add_monoid.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type add_monoid.{0}) h0) (add_group.{0} empty))  := sorry --non-trivial
lemma new_lemma_7941 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @normal_space.{0} (has_pos_part.{0} real) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_pos_part.{0} real))  := sorry --non-trivial
lemma new_lemma_7942 (h0 : functor.add_const (function.extfun Type topological_space) (has_add (has_add name))) : @irreducible_space.{0} (has_pos_part.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) (has_add.{0} (has_add.{0} name)) h0) (has_pos_part.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_7943 (h0 : function.extfun Type add_group) : @is_add_cyclic.{0} (complete_linear_order.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type add_group.{0} h0 (complete_linear_order.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_7944 (h0 : function.extfun Type topological_space) : @preconnected_space.{0} (canonically_ordered_comm_semiring.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (canonically_ordered_comm_semiring.{0} name))  := sorry --non-trivial
lemma new_lemma_7945 (h0 : topological_space (has_add Type)) : t1_space (has_add Type) := sorry --non-trivial
lemma new_lemma_7946 (h0 : uniform_space (has_add (mul_one_class Type))) : complete_space (has_add (mul_one_class Type)) := sorry --non-trivial
lemma new_lemma_7947 (h0 : functor.add_const (topological_space (is_R_or_C num)) empty) : @t1_space.{0} (is_R_or_C.{0} num) (@functor.add_const.run.{0 0} (topological_space.{0} (is_R_or_C.{0} num)) empty h0)  := sorry --non-trivial
lemma new_lemma_7948 (h0 : not (filter (id num) -> false)) : filter.ne_bot (classical.by_contradiction' h0) := sorry --non-trivial
lemma new_lemma_7949 (h0 : add_monoid (simple_graph (finset (ring (finset linarith.comp))))) : add_monoid.fg (simple_graph (finset (ring (finset linarith.comp)))) := sorry --non-trivial
lemma new_lemma_7950 (h0 : function.extfun Type cancel_comm_monoid_with_zero) : @unique_factorization_monoid.{0} (normed_comm_ring.{0} unsigned) (@function.extfun_app.{2 1} Type cancel_comm_monoid_with_zero.{0} h0 (normed_comm_ring.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_7951 (h0 : cancel_comm_monoid_with_zero (finset (cancel_monoid (finset ennreal)))) : unique_factorization_monoid (finset (cancel_monoid (finset ennreal))) := sorry --non-trivial
lemma new_lemma_7952 (h0 : add_group (has_emptyc (random_gen fun_info))) : is_add_cyclic (has_emptyc (random_gen fun_info)) := sorry --non-trivial
lemma new_lemma_7953 (h0 : add_group znum) : is_add_cyclic znum := sorry --non-trivial
lemma new_lemma_7954 (h0 : ring (ordered_comm_ring (has_nndist (has_neg Type)))) : is_domain (ordered_comm_ring (has_nndist (has_neg Type))) := sorry --non-trivial
lemma new_lemma_7955 (h0 : not (function.extfun Type ring -> false)) : @is_domain.{0} (with_bot.{0} empty) (@function.extfun_app.{2 1} Type ring.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type ring.{0}) h0) (with_bot.{0} empty))  := sorry --non-trivial
lemma new_lemma_7956 (h0 : topological_space (has_top (has_top (random_gen fun_info)))) : totally_separated_space (has_top (has_top (random_gen fun_info))) := sorry --non-trivial
lemma new_lemma_7957 (h0 : topological_space (semigroup empty)) : path_connected_space (semigroup empty) := sorry --non-trivial
lemma new_lemma_7958 (h0 : ordered_add_comm_monoid (comm_group (option ennreal))) : archimedean (comm_group (option ennreal)) := sorry --non-trivial
lemma new_lemma_7959 (h0 : topological_space (with_bot fun_info)) : locally_compact_space (with_bot fun_info) := sorry --non-trivial
lemma new_lemma_7960 (h1 : to_additive.value_type -> random_gen reducibility_hints) (h2 : random_gen reducibility_hints -> option to_additive.value_type) : function.is_partial_inv h1 h2 := sorry --non-trivial
lemma new_lemma_7961 (h1 : not (add_group string.iterator_imp -> false)) : @is_add_cyclic.{0} string.iterator_imp (@classical.by_contradiction'.{1} (add_group.{0} string.iterator_imp) h1)  := sorry --non-trivial
lemma new_lemma_7962 (h0 : not (function.extfun Type ring -> false)) : @strong_rank_condition.{0} linarith.comp (@function.extfun_app.{2 1} Type ring.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type ring.{0}) h0) linarith.comp)  := sorry --non-trivial
lemma new_lemma_7963 (h0 : group (add_right_cancel_monoid (semiring unsigned))) : is_cyclic (add_right_cancel_monoid (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_7964 (h1 : uniform_space (distrib_lattice (random_gen char))) : complete_space (distrib_lattice (random_gen char)) := sorry --non-trivial
lemma new_lemma_7965 (h0 : uniform_space (ordered_comm_ring (has_Inf (has_add (finset (has_Inf linarith.comp)))))) : separated_space (ordered_comm_ring (has_Inf (has_add (finset (has_Inf linarith.comp))))) := sorry --non-trivial
lemma new_lemma_7966 (h0 : ring (add_right_cancel_monoid (option (option (option unsigned))))) : is_principal_ideal_ring (add_right_cancel_monoid (option (option (option unsigned)))) := sorry --non-trivial
lemma new_lemma_7967 (h1 : not (has_mem.mem num has_emptyc.emptyc -> false)) : @totally_disconnected_space.{0} num (@finset.pi.empty.{1 0} Type topological_space.{0} num (@classical.by_contradiction'.{0} (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) num (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))) h1))  := sorry --non-trivial
lemma new_lemma_7968 (h0 : function.extfun Type topological_space) : @locally_compact_space.{0} (cancel_monoid.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (cancel_monoid.{0} name))  := sorry --non-trivial
lemma new_lemma_7969 (h0 : ordered_add_comm_monoid (has_to_string (add_comm_monoid (has_add (has_add (has_add pos)))))) : archimedean (has_to_string (add_comm_monoid (has_add (has_add (has_add pos))))) := sorry --non-trivial
lemma new_lemma_7970 (h0 : topological_space (boolean_algebra (finset linarith.comp))) : preirreducible_space (boolean_algebra (finset linarith.comp)) := sorry --non-trivial
lemma new_lemma_7971 (h0 : ordered_add_comm_monoid (left_cancel_monoid (option (option (option (option (option (option unsigned)))))))) : archimedean (left_cancel_monoid (option (option (option (option (option (option unsigned))))))) := sorry --non-trivial
lemma new_lemma_7972 (h0 : functor.add_const (topological_space empty) unsigned) : loc_path_connected_space empty := sorry --non-trivial
lemma new_lemma_7973 (h0 : topological_space (has_one (semiring linarith.comp))) : discrete_topology (has_one (semiring linarith.comp)) := sorry --non-trivial
lemma new_lemma_7974 (h0 : not (add_monoid (measure_theory.measure_space num) -> false)) : @add_monoid.fg.{0} (measure_theory.measure_space.{0} num) (@classical.by_contradiction'.{1} (add_monoid.{0} (measure_theory.measure_space.{0} num)) h0)  := sorry --non-trivial
lemma new_lemma_7975 (h0 : not (topological_space (with_one linarith.comp_source) -> false)) : @totally_disconnected_space.{0} (with_one.{0} linarith.comp_source) (@classical.by_contradiction'.{1} (topological_space.{0} (with_one.{0} linarith.comp_source)) h0)  := sorry --non-trivial
lemma new_lemma_7976 (h0 : topological_space (normed_group (with_bot to_additive.value_type))) : totally_disconnected_space (normed_group (with_bot to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_7977 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @totally_disconnected_space.{0} (normed_comm_ring.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (normed_comm_ring.{0} name))  := sorry --non-trivial
lemma new_lemma_7978 (h0 : functor.add_const (complete_lattice (left_cancel_monoid empty)) num) : @complete_lattice.is_Sup_finite_compact.{0} (left_cancel_monoid.{0} empty) (@functor.add_const.run.{0 0} (complete_lattice.{0} (left_cancel_monoid.{0} empty)) num h0)  := sorry --non-trivial
lemma new_lemma_7979 (h0 : uniform_space (semi_normed_ring (mul_one_class to_additive.value_type))) : complete_space (semi_normed_ring (mul_one_class to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_7980 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @strong_rank_condition.{0} (semigroup.{0} pos) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (semigroup.{0} pos))  := sorry --non-trivial
lemma new_lemma_7981 (h0 : functor.add_const (topological_space (finset pos)) pos) : @t1_space.{0} (finset.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (finset.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_7982 (h0 : functor.add_const (topological_space (finset linarith.comp)) linarith.comp) : @preirreducible_space.{0} (finset.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (finset.{0} linarith.comp)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_7983 (h0 : functor.add_const (topological_space (boolean_algebra.core unsigned)) (has_neg Type)) : @discrete_topology.{0} (boolean_algebra.core.{0} unsigned) (@functor.add_const.run.{0 1} (topological_space.{0} (boolean_algebra.core.{0} unsigned)) (has_neg.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_7984 (h0 : functor.add_const (semiring (has_add Type)) (has_add Type)) : @is_noetherian_ring.{1} (has_add.{1} Type) (@functor.add_const.run.{1 1} (semiring.{1} (has_add.{1} Type)) (has_add.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_7985 (h0 : topological_space (semigroup (finset linarith.comp))) : loc_path_connected_space (semigroup (finset linarith.comp)) := sorry --non-trivial
lemma new_lemma_7986 (h0 : group (monoid (option (option empty)))) : is_cyclic (monoid (option (option empty))) := sorry --non-trivial
lemma new_lemma_7987 (h0 : function.extfun nat fin) : @strong_rank_condition.{0} (has_bot.{0} pos) (@matrix.vec_empty.{0} (ring.{0} (has_bot.{0} pos)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_7988 (h0 : uniform_space (ring (boolean_algebra linarith.comp))) : complete_space (ring (boolean_algebra linarith.comp)) := sorry --non-trivial
lemma new_lemma_7989 (h0 : cancel_comm_monoid_with_zero (finset ennreal)) : unique_factorization_monoid (finset ennreal) := sorry --non-trivial
lemma new_lemma_7990 (h0 : topological_space (has_add (sub_neg_monoid pos))) : regular_space (has_add (sub_neg_monoid pos)) := sorry --non-trivial
lemma new_lemma_7991 (h0 : not (ring (metric_space linarith.comp_source) -> false)) : @strong_rank_condition.{0} (metric_space.{0} linarith.comp_source) (@classical.by_contradiction'.{1} (ring.{0} (metric_space.{0} linarith.comp_source)) h0)  := sorry --non-trivial
lemma new_lemma_7992 (h0 : complete_lattice (distrib (has_ssubset (distrib (has_lt (has_lt linarith.comp_source)))))) : is_compactly_generated (distrib (has_ssubset (distrib (has_lt (has_lt linarith.comp_source))))) := sorry --non-trivial
lemma new_lemma_7993 (h0 : topological_space (add_comm_monoid (option (option (option ennreal))))) : t1_space (add_comm_monoid (option (option (option ennreal)))) := sorry --non-trivial
lemma new_lemma_7994 (h0 : group (comm_group (has_to_string (has_to_string (has_to_string pos))))) : group.fg (comm_group (has_to_string (has_to_string (has_to_string pos)))) := sorry --non-trivial
lemma new_lemma_7995 (h0 : not (function.extfun Type ring -> false)) : @rank_condition.{0} (with_bot.{0} num) (@function.extfun_app.{2 1} Type ring.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type ring.{0}) h0) (with_bot.{0} num))  := sorry --non-trivial
lemma new_lemma_7996 (h0 : functor.add_const (topological_space (has_to_string linarith.comp)) environment.implicit_infer_kind) : @topological_space.separable_space.{0} (has_to_string.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (has_to_string.{0} linarith.comp)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_7997 (h0 : functor.add_const (complete_lattice (option unsigned)) unsigned) : @is_compactly_generated.{0} (option.{0} unsigned) (@functor.add_const.run.{0 0} (complete_lattice.{0} (option.{0} unsigned)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_7998 (h0 : function.extfun Type (functor.comp topological_space has_neg)) : @irreducible_space.{0} (has_neg.{0} name) (@functor.comp.run.{0 0 0} topological_space.{0} has_neg.{0} name (@functor.comp.run.{0 0 0} topological_space.{0} has_neg.{0} name (@functor.comp.run.{0 0 0} topological_space.{0} has_neg.{0} name (@functor.comp.run.{0 0 0} topological_space.{0} has_neg.{0} name (@functor.comp.run.{0 0 0} topological_space.{0} has_neg.{0} name (@functor.comp.run.{0 0 0} topological_space.{0} has_neg.{0} name (@functor.comp.run.{0 0 0} topological_space.{0} has_neg.{0} name (@functor.comp.run.{0 0 0} topological_space.{0} has_neg.{0} name (@functor.comp.run.{0 0 0} topological_space.{0} has_neg.{0} name (@functor.comp.run.{0 0 0} topological_space.{0} has_neg.{0} name (@functor.comp.run.{0 0 0} topological_space.{0} has_neg.{0} name (@functor.comp.run.{0 0 0} topological_space.{0} has_neg.{0} name (@function.extfun_app.{2 1} Type (functor.comp.{0 0 0} topological_space.{0} has_neg.{0}) h0 name)))))))))))))  := sorry --non-trivial
lemma new_lemma_7999 (h0 : topological_space (boolean_algebra (finset (has_neg linarith.comp)))) : preconnected_space (boolean_algebra (finset (has_neg linarith.comp))) := sorry --non-trivial
