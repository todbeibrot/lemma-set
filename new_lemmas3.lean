import imports
lemma new_lemma_24000 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @t0_space.{0} (canonically_ordered_monoid.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (canonically_ordered_monoid.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_24001 (h0 : topological_space (ordered_comm_monoid (has_neg pos))) : preirreducible_space (ordered_comm_monoid (has_neg pos)) := sorry --non-trivial
lemma new_lemma_24002 (h0 : topological_space (comm_semigroup (has_add (comm_semigroup real)))) : preirreducible_space (comm_semigroup (has_add (comm_semigroup real))) := sorry --non-trivial
lemma new_lemma_24003 (h0 : topological_space (semigroup (has_pos_part (finset pos)))) : t0_space (semigroup (has_pos_part (finset pos))) := sorry --non-trivial
lemma new_lemma_24004 (h0 : functor.add_const (topological_space (ordered_ring unsigned)) empty) : @normal_space.{0} (ordered_ring.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (ordered_ring.{0} unsigned)) empty h0)  := sorry --non-trivial
lemma new_lemma_24005 (h0 : ring (metric_space char)) : is_domain (metric_space char) := sorry --non-trivial
lemma new_lemma_24006 (h0 : function.extfun (finset Type) (has_mem.mem real.angle)) : @is_cyclic.{0} real.angle (@finset.pi.empty.{1 0} Type group.{0} real.angle (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) real.angle) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_24007 (h0 : not (add_monoid (has_sub congr_arg_kind) -> false)) : @add_monoid.fg.{0} (has_sub.{0} congr_arg_kind) (@classical.by_contradiction'.{1} (add_monoid.{0} (has_sub.{0} congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_24008 (h0 : topological_space (ordered_cancel_add_comm_monoid (option ennreal))) : locally_compact_space (ordered_cancel_add_comm_monoid (option ennreal)) := sorry --non-trivial
lemma new_lemma_24009 (h0 : not (topological_space (has_union num) -> false)) : @irreducible_space.{0} (has_union.{0} num) (@classical.by_contradiction'.{1} (topological_space.{0} (has_union.{0} num)) h0)  := sorry --non-trivial
lemma new_lemma_24010 (h0 : not (add_monoid (linear_ordered_semiring unsigned) -> false)) : @add_monoid.fg.{0} (linear_ordered_semiring.{0} unsigned) (@classical.by_contradiction'.{1} (add_monoid.{0} (linear_ordered_semiring.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_24011 (h0 : topological_space (add_cancel_monoid (has_sdiff Type))) : loc_path_connected_space (add_cancel_monoid (has_sdiff Type)) := sorry --non-trivial
lemma new_lemma_24012 (h0 : group (is_R_or_C (semiring empty))) : normalizer_condition (is_R_or_C (semiring empty)) := sorry --non-trivial
lemma new_lemma_24013 (h0 : topological_space (has_neg (has_neg pos))) : preconnected_space (has_neg (has_neg pos)) := sorry --non-trivial
lemma new_lemma_24014 (h0 : function.extfun Type topological_space) : @path_connected_space.{0} (has_sub.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_sub.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_24015 (h0 : has_mem.mem (has_emptyc (has_norm linarith.comp)) has_emptyc.emptyc) : @t0_space.{0} (has_emptyc.{0} (has_norm.{0} linarith.comp)) (@finset.pi.empty.{1 0} Type topological_space.{0} (has_emptyc.{0} (has_norm.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_24016 (h0 : ring (ring (finset name))) : is_principal_ideal_ring (ring (finset name)) := sorry --non-trivial
lemma new_lemma_24017 (h0 : topological_space (has_bot (option (option (option (option unsigned)))))) : preirreducible_space (has_bot (option (option (option (option unsigned))))) := sorry --non-trivial
lemma new_lemma_24018 (h0 : complete_lattice (with_one (random_gen num))) : is_compactly_generated (with_one (random_gen num)) := sorry --non-trivial
lemma new_lemma_24019 (h0 : ring (comm_ring (has_ssubset (has_ssubset (random_gen char))))) : is_domain (comm_ring (has_ssubset (has_ssubset (random_gen char)))) := sorry --non-trivial
lemma new_lemma_24020 (h0 : topological_space (semigroup unsigned)) : irreducible_space (semigroup unsigned) := sorry --non-trivial
lemma new_lemma_24021 (h0 : complete_lattice (linear_ordered_add_comm_group (random_gen fun_info))) : is_atomistic (linear_ordered_add_comm_group (random_gen fun_info)) := sorry --non-trivial
lemma new_lemma_24022 (h0 : function.extfun Type ordered_add_comm_monoid) : @archimedean.{0} (has_bot.{0} pos) (@function.extfun_app.{2 1} Type ordered_add_comm_monoid.{0} h0 (has_bot.{0} pos))  := sorry --non-trivial
lemma new_lemma_24023 (h0 : topological_space (boolean_algebra.core (has_pos_part Type))) : t1_space (boolean_algebra.core (has_pos_part Type)) := sorry --non-trivial
lemma new_lemma_24024 (h0 : topological_space (linear_ordered_field num)) : t0_space (linear_ordered_field num) := sorry --non-trivial
lemma new_lemma_24025 (h0 : functor.add_const (ring (generalized_boolean_algebra Type)) (has_nndist pos)) : @strong_rank_condition.{1} (generalized_boolean_algebra.{1} Type) (@functor.add_const.run.{1 0} (ring.{1} (generalized_boolean_algebra.{1} Type)) (has_nndist.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_24026 (h0 : topological_space (semigroup (finset name))) : totally_disconnected_space (semigroup (finset name)) := sorry --non-trivial
lemma new_lemma_24027 (h0 : list (distrib_lattice (has_inv (has_inv fun_info)))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_24028 (h0 : complete_lattice (has_sub unsigned)) : is_compactly_generated (has_sub unsigned) := sorry --non-trivial
lemma new_lemma_24029 (h0 : uniform_space (id (has_norm (semiring (semiring (semiring (semiring num))))))) : separated_space (id (has_norm (semiring (semiring (semiring (semiring num)))))) := sorry --non-trivial
lemma new_lemma_24030 (h0 : topological_space (boolean_algebra (has_to_string (finset pos)))) : irreducible_space (boolean_algebra (has_to_string (finset pos))) := sorry --non-trivial
lemma new_lemma_24031 (h0 : group (denumerable (random_gen linarith.comp_source))) : group.fg (denumerable (random_gen linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_24032 (h0 : ring (has_norm (has_norm linarith.comp))) : is_domain (has_norm (has_norm linarith.comp)) := sorry --non-trivial
lemma new_lemma_24033 (h0 : topological_space (has_top (has_nnnorm (has_nnnorm fun_info)))) : totally_disconnected_space (has_top (has_nnnorm (has_nnnorm fun_info))) := sorry --non-trivial
lemma new_lemma_24034 (h0 : functor.add_const (group (has_add pos)) name) : @is_cyclic.{0} (has_add.{0} pos) (@functor.add_const.run.{0 0} (group.{0} (has_add.{0} pos)) name h0)  := sorry --non-trivial
lemma new_lemma_24035 (h0 : ring (with_one (random_gen to_additive.value_type))) : is_domain (with_one (random_gen to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_24036 (h2 : Prop) : set.separates_points (id (fun (h1 : std_gen -> char), h2)) := sorry --non-trivial
lemma new_lemma_24037 (h0 : group (monoid_with_zero (has_to_string congr_arg_kind))) : is_simple_group (monoid_with_zero (has_to_string congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_24038 (h0 : function.extfun Type topological_space) : @totally_disconnected_space.{0} (complete_semilattice_Sup.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (complete_semilattice_Sup.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_24039 (h0 : cancel_comm_monoid_with_zero (boolean_algebra.core (finset name))) : unique_factorization_monoid (boolean_algebra.core (finset name)) := sorry --non-trivial
lemma new_lemma_24040 (h0 : functor.add_const (topological_space (has_zero Type)) environment.implicit_infer_kind) : @topological_space.separable_space.{1} (has_zero.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (has_zero.{1} Type)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_24041 (h0 : complete_lattice (fintype linarith.comp_source)) : is_compactly_generated (fintype linarith.comp_source) := sorry --non-trivial
lemma new_lemma_24042 (h0 : group (ordered_ring (option unsigned))) : normalizer_condition (ordered_ring (option unsigned)) := sorry --non-trivial
lemma new_lemma_24043 (h0 : topological_space (has_add (comm_group (has_neg_part (has_neg_part Type))))) : discrete_topology (has_add (comm_group (has_neg_part (has_neg_part Type)))) := sorry --non-trivial
lemma new_lemma_24044 (h0 : functor.add_const (group (ring Type)) Type) : @is_cyclic.{1} (ring.{1} Type) (@functor.add_const.run.{1 1} (group.{1} (ring.{1} Type)) Type h0)  := sorry --non-trivial
lemma new_lemma_24045 (h0 : ring (uniform_space (random_gen reducibility_hints))) : strong_rank_condition (uniform_space (random_gen reducibility_hints)) := sorry --non-trivial
lemma new_lemma_24046 (h0 : topological_space (cancel_monoid unsigned)) : totally_disconnected_space (cancel_monoid unsigned) := sorry --non-trivial
lemma new_lemma_24047 (h0 : list (topological_space (has_ssubset to_additive.value_type))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_24048 (h0 : function.extfun Type topological_space) : @t1_space.{0} (complete_distrib_lattice.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (complete_distrib_lattice.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_24049 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @totally_separated_space.{0} (normed_group.{0} fun_info) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (normed_group.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_24050 (h0 : not (ring (has_lt linarith.comp_source) -> false)) : @rank_condition.{0} (has_lt.{0} linarith.comp_source) (@classical.by_contradiction'.{1} (ring.{0} (has_lt.{0} linarith.comp_source)) h0)  := sorry --non-trivial
lemma new_lemma_24051 (h0 : uniform_space (semi_normed_comm_ring (comm_ring linarith.comp_source))) : complete_space (semi_normed_comm_ring (comm_ring linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_24052 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @path_connected_space.{0} (finset.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (finset.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_24053 (h0 : not (ring (metric_space congr_arg_kind) -> false)) : @strong_rank_condition.{0} (metric_space.{0} congr_arg_kind) (@classical.by_contradiction'.{1} (ring.{0} (metric_space.{0} congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_24054 (h0 : measurable_space fun_info) (h1 : function.extfun Type filter) : filter.is_measurably_generated (function.extfun_app h1 fun_info) := sorry --non-trivial
lemma new_lemma_24055 (h0 : group (linear_ordered_comm_monoid_with_zero empty)) : group.fg (linear_ordered_comm_monoid_with_zero empty) := sorry --non-trivial
lemma new_lemma_24056 (h0 : preorder std_gen) (h1 : topological_space (omega_complete_partial_order.chain std_gen)) : t0_space (omega_complete_partial_order.chain std_gen) := sorry --non-trivial
lemma new_lemma_24057 (h0 : complete_lattice (option (option (option unsigned)))) : is_compactly_generated (option (option (option unsigned))) := sorry --non-trivial
lemma new_lemma_24058 (h0 : topological_space (has_to_string (has_Inf (finset pos)))) : preconnected_space (has_to_string (has_Inf (finset pos))) := sorry --non-trivial
lemma new_lemma_24059 (h0 : topological_space (with_bot string_imp)) : irreducible_space (with_bot string_imp) := sorry --non-trivial
lemma new_lemma_24060 (h0 : measurable_space (random_gen (has_nnnorm linarith.comp_source))) (h1 : not (has_div (random_gen (has_nnnorm linarith.comp_source)) -> false)) : @has_measurable_div₂.{0} (random_gen.{0} (has_nnnorm.{0} linarith.comp_source)) h0 (@classical.by_contradiction'.{1} (has_div.{0} (random_gen.{0} (has_nnnorm.{0} linarith.comp_source))) h1)  := sorry --non-trivial
lemma new_lemma_24061 (h0 : topological_space (group_with_zero congr_arg_kind)) : t0_space (group_with_zero congr_arg_kind) := sorry --non-trivial
lemma new_lemma_24062 (h0 : fin has_zero.zero) : @normalizer_condition.{1} (sub_neg_monoid.{1} Type) (@matrix.vec_empty.{1} (group.{1} (sub_neg_monoid.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_24063 (h0 : functor.add_const (ring (bin_tree num)) unsigned) : @is_principal_ideal_ring.{0} (bin_tree.{0} num) (@functor.add_const.run.{0 0} (ring.{0} (bin_tree.{0} num)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_24064 (h0 : prod (metric_space string_imp) (metric_space string_imp)) : set.diagonal (metric_space string_imp) h0 := sorry --non-trivial
lemma new_lemma_24065 (h0 : topological_space (partial_order (semiring (semiring unsigned)))) : topological_space.separable_space (partial_order (semiring (semiring unsigned))) := sorry --non-trivial
lemma new_lemma_24066 (h0 : function.extfun Type filter) : filter.ne_bot (function.extfun_app h0 (complete_distrib_lattice pos)) := sorry --non-trivial
lemma new_lemma_24067 (h0 : measurable_space (simple_graph string_imp)) (h1 : has_sub (simple_graph string_imp)) : has_measurable_sub₂ (simple_graph string_imp) := sorry --non-trivial
lemma new_lemma_24068 (h0 : function.extfun Type ring) : @rank_condition.{0} (linear_ordered_field.{0} unsigned) (@function.extfun_app.{2 1} Type ring.{0} h0 (linear_ordered_field.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_24069 (h0 : function.extfun Type (functor.comp semiring mul_zero_class)) : @is_noetherian_ring.{0} (mul_zero_class.{0} ennreal) (@functor.comp.run.{0 0 0} semiring.{0} mul_zero_class.{0} ennreal (@function.extfun_app.{2 1} Type (functor.comp.{0 0 0} semiring.{0} mul_zero_class.{0}) h0 ennreal))  := sorry --non-trivial
lemma new_lemma_24070 (h0 : ring enat) : rank_condition enat := sorry --non-trivial
lemma new_lemma_24071 (h0 : topological_space (has_append (uniform_space string_imp))) : totally_disconnected_space (has_append (uniform_space string_imp)) := sorry --non-trivial
lemma new_lemma_24072 (h0 : has_mem.mem (has_top linarith.comp_source) has_emptyc.emptyc) : @irreducible_space.{0} (has_top.{0} linarith.comp_source) (@finset.pi.empty.{1 0} Type topological_space.{0} (has_top.{0} linarith.comp_source) h0)  := sorry --non-trivial
lemma new_lemma_24073 (h0 : cancel_comm_monoid_with_zero (has_add (has_add (finset name)))) : unique_factorization_monoid (has_add (has_add (finset name))) := sorry --non-trivial
lemma new_lemma_24074 (h1 : ring (uniform_space (normed_field linarith.comp_source))) : strong_rank_condition (uniform_space (normed_field linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_24075 (h0 : function.extfun Type (functor.comp topological_space finset)) : @normal_space.{0} (finset.{0} environment.implicit_infer_kind) (@functor.comp.run.{0 0 0} topological_space.{0} finset.{0} environment.implicit_infer_kind (@function.extfun_app.{2 1} Type (functor.comp.{0 0 0} topological_space.{0} finset.{0}) h0 environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_24076 (h0 : functor.add_const (topological_space real) unsigned) : totally_separated_space real := sorry --non-trivial
lemma new_lemma_24077 (h0 : not (group string.iterator -> false)) : @is_cyclic.{0} string.iterator (@classical.by_contradiction'.{1} (group.{0} string.iterator) h0)  := sorry --non-trivial
lemma new_lemma_24078 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : filter.ne_bot (function.extfun_app (function.extfun_app h0 filter) (finset unsigned)) := sorry --non-trivial
lemma new_lemma_24079 (h0 : ring (option (semiring (semiring (semiring num))))) : is_domain (option (semiring (semiring (semiring num)))) := sorry --non-trivial
lemma new_lemma_24080 (h1 : ring (has_add linarith.comp_source)) : is_domain (has_add linarith.comp_source) := sorry --non-trivial
lemma new_lemma_24081 (h0 : add_group (linear_ordered_comm_group (option ennreal))) : is_add_cyclic (linear_ordered_comm_group (option ennreal)) := sorry --non-trivial
lemma new_lemma_24082 (h0 : functor.comp topological_space canonically_ordered_comm_semiring pos) : @preirreducible_space.{0} (canonically_ordered_comm_semiring.{0} pos) (@functor.comp.run.{0 0 0} topological_space.{0} canonically_ordered_comm_semiring.{0} pos h0)  := sorry --non-trivial
lemma new_lemma_24083 (h1 : filter (comm_ring fun_info)) : filter.ne_bot h1 := sorry --non-trivial
lemma new_lemma_24084 (h0 : complete_lattice (free_add_monoid congr_arg_kind)) : is_compactly_generated (free_add_monoid congr_arg_kind) := sorry --non-trivial
lemma new_lemma_24085 (h0 : ring (ordered_comm_ring (has_Inf linarith.comp))) : strong_rank_condition (ordered_comm_ring (has_Inf linarith.comp)) := sorry --non-trivial
lemma new_lemma_24086 (h1 : list (has_emptyc (with_one fun_info))) : list.nodup h1 := sorry --non-trivial
lemma new_lemma_24087 (h0 : group (add_group (metric_space fun_info))) : is_cyclic (add_group (metric_space fun_info)) := sorry --non-trivial
lemma new_lemma_24088 (h0 : topological_space (ring (has_add ennreal))) : totally_separated_space (ring (has_add ennreal)) := sorry --non-trivial
lemma new_lemma_24089 (h0 : topological_space (encodable (comm_semigroup string_imp))) : path_connected_space (encodable (comm_semigroup string_imp)) := sorry --non-trivial
lemma new_lemma_24090 (h0 : functor.add_const (function.extfun Type topological_space) name) : @totally_disconnected_space.{0} (has_Inf.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) name h0) (has_Inf.{0} pos))  := sorry --non-trivial
lemma new_lemma_24091 (h0 : function.extfun Type complete_lattice) : @is_atomistic.{0} (random_gen.{0} linarith.comp) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (random_gen.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_24092 (h0 : functor.add_const (ring (ordered_comm_ring linarith.comp)) pos) : @is_principal_ideal_ring.{0} (ordered_comm_ring.{0} linarith.comp) (@functor.add_const.run.{0 0} (ring.{0} (ordered_comm_ring.{0} linarith.comp)) pos h0)  := sorry --non-trivial
lemma new_lemma_24093 (h0 h1 : set real) (h2 : with_bot complex) (h3 : ne h2 has_bot.bot) : set.re_prod_im h0 h1 (with_bot.unbot h2 h3) := sorry --non-trivial
lemma new_lemma_24094 (h0 : function.extfun Type group) : @normalizer_condition.{0} (complete_distrib_lattice.{0} real) (@function.extfun_app.{2 1} Type group.{0} h0 (complete_distrib_lattice.{0} real))  := sorry --non-trivial
lemma new_lemma_24095 (h1 h2 : multiset (semi_normed_comm_ring string_imp)) : multiset.disjoint h1 h2 := sorry --non-trivial
lemma new_lemma_24096 (h0 : function.extfun Type semiring) : @is_noetherian_ring.{0} (group_with_zero.{0} num) (@function.extfun_app.{2 1} Type semiring.{0} h0 (group_with_zero.{0} num))  := sorry --non-trivial
lemma new_lemma_24097 (h0 : topological_space (preorder (semiring num))) : totally_separated_space (preorder (semiring num)) := sorry --non-trivial
lemma new_lemma_24098 (h0 : topological_space (mul_one_class (normed_field fun_info))) : t0_space (mul_one_class (normed_field fun_info)) := sorry --non-trivial
lemma new_lemma_24099 (h1 : has_mem.mem (has_norm to_additive.value_type) has_emptyc.emptyc) : @monoid.fg.{0} (has_norm.{0} to_additive.value_type) (@finset.pi.empty.{1 0} Type monoid.{0} (has_norm.{0} to_additive.value_type) h1)  := sorry --non-trivial
lemma new_lemma_24100 (h0 : functor.add_const (ordered_add_comm_monoid (has_neg Type)) Type) : @archimedean.{1} (has_neg.{1} Type) (@functor.add_const.run.{1 1} (ordered_add_comm_monoid.{1} (has_neg.{1} Type)) Type h0)  := sorry --non-trivial
lemma new_lemma_24101 (h0 : functor.add_const (list (has_to_string Type)) pos) : list.nodup (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_24102 (h0 : topological_space (linear_ordered_cancel_comm_monoid empty)) : path_connected_space (linear_ordered_cancel_comm_monoid empty) := sorry --non-trivial
lemma new_lemma_24103 (h0 : cancel_comm_monoid_with_zero (linear_ordered_field (option empty))) : unique_factorization_monoid (linear_ordered_field (option empty)) := sorry --non-trivial
lemma new_lemma_24104 (h0 : semiring (normed_comm_ring (normed_comm_ring (has_neg linarith.comp)))) : is_noetherian_ring (normed_comm_ring (normed_comm_ring (has_neg linarith.comp))) := sorry --non-trivial
lemma new_lemma_24105 (h0 : function.extfun Type filter) : countable_Inter_filter (function.extfun_app h0 (has_neg congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_24106 (h0 : group (has_emptyc (random_gen linarith.comp_source))) : group.fg (has_emptyc (random_gen linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_24107 (h0 : functor.add_const Prop (pseudo_metric_space ennreal)) : functor.add_const.run h0 := sorry --non-trivial
lemma new_lemma_24108 (h0 : topological_space (left_cancel_semigroup (semiring congr_arg_kind))) : t0_space (left_cancel_semigroup (semiring congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_24109 (h0 : functor.add_const (topological_space (has_Inf linarith.comp)) (ring linarith.comp)) : @path_connected_space.{0} (has_Inf.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (has_Inf.{0} linarith.comp)) (ring.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_24110 (h0 : functor.add_const (topological_space (complete_distrib_lattice environment.implicit_infer_kind)) name) : @preconnected_space.{0} (complete_distrib_lattice.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (complete_distrib_lattice.{0} environment.implicit_infer_kind)) name h0)  := sorry --non-trivial
lemma new_lemma_24111 (h2 : topological_space (id (random_gen fun_info))) : t0_space (id (random_gen fun_info)) := sorry --non-trivial
lemma new_lemma_24112 (h0 : topological_space (comm_group (has_to_string (has_to_string Type)))) : preconnected_space (comm_group (has_to_string (has_to_string Type))) := sorry --non-trivial
lemma new_lemma_24113 (h0 : function.extfun Type complete_lattice) : @is_atomistic.{0} (preorder.{0} unsigned) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (preorder.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_24114 (h0 : topological_space (has_div (mul_one_class fun_info))) : t0_space (has_div (mul_one_class fun_info)) := sorry --non-trivial
lemma new_lemma_24115 (h0 : has_mem.mem topological_space has_emptyc.emptyc) : @path_connected_space.{0} (has_top.{0} fun_info) (@function.extfun_app.{2 1} Type topological_space.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) topological_space.{0} h0) (has_top.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_24116 (h0 : topological_space (add_comm_monoid (canonically_ordered_comm_semiring Type))) : preirreducible_space (add_comm_monoid (canonically_ordered_comm_semiring Type)) := sorry --non-trivial
lemma new_lemma_24117 (h0 : group (encodable (random_gen string_imp))) : is_cyclic (encodable (random_gen string_imp)) := sorry --non-trivial
lemma new_lemma_24118 (h0 : topological_space (normed_comm_ring (boolean_algebra unsigned))) : totally_disconnected_space (normed_comm_ring (boolean_algebra unsigned)) := sorry --non-trivial
lemma new_lemma_24119 (h0 : complete_lattice (has_nndist (option (has_nndist name)))) : is_atomistic (has_nndist (option (has_nndist name))) := sorry --non-trivial
lemma new_lemma_24120 (h0 : cancel_comm_monoid_with_zero (ring (has_add linarith.comp))) : unique_factorization_monoid (ring (has_add linarith.comp)) := sorry --non-trivial
lemma new_lemma_24121 (h0 : complete_lattice (boolean_algebra.core (option num))) : complete_lattice.is_Sup_finite_compact (boolean_algebra.core (option num)) := sorry --non-trivial
lemma new_lemma_24122 (h0 : group (has_to_string empty)) : normalizer_condition (has_to_string empty) := sorry --non-trivial
lemma new_lemma_24123 (h0 : add_group (with_one linarith.ineq)) : is_add_cyclic (with_one linarith.ineq) := sorry --non-trivial
lemma new_lemma_24124 (h0 : functor.add_const (function.extfun (Type 1) topological_space) linarith.comp) : @irreducible_space.{1} (generalized_boolean_algebra.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) topological_space.{1}) linarith.comp h0) (generalized_boolean_algebra.{1} Type))  := sorry --non-trivial
lemma new_lemma_24125 (h0 : functor.add_const (ring (complete_distrib_lattice linarith.comp)) pos) : @is_principal_ideal_ring.{0} (complete_distrib_lattice.{0} linarith.comp) (@functor.add_const.run.{0 0} (ring.{0} (complete_distrib_lattice.{0} linarith.comp)) pos h0)  := sorry --non-trivial
lemma new_lemma_24126 (h0 : ring (has_to_string (has_add (finset pos)))) : strong_rank_condition (has_to_string (has_add (finset pos))) := sorry --non-trivial
lemma new_lemma_24127 (h0 : group (finset (has_add pos))) : group.fg (finset (has_add pos)) := sorry --non-trivial
lemma new_lemma_24128 (h0 : cancel_comm_monoid_with_zero (finset (finset (has_add (finset (finset Type)))))) : unique_factorization_monoid (finset (finset (has_add (finset (finset Type))))) := sorry --non-trivial
lemma new_lemma_24129 (h0 : add_group (monoid_with_zero (option unsigned))) : is_add_cyclic (monoid_with_zero (option unsigned)) := sorry --non-trivial
lemma new_lemma_24130 (h0 : functor.add_const (ordered_add_comm_monoid (ring linarith.comp)) environment.implicit_infer_kind) : @archimedean.{0} (ring.{0} linarith.comp) (@functor.add_const.run.{0 0} (ordered_add_comm_monoid.{0} (ring.{0} linarith.comp)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_24131 (h0 : ring (has_norm linarith.comp)) : strong_rank_condition (has_norm linarith.comp) := sorry --non-trivial
lemma new_lemma_24132 (h0 : ordered_comm_monoid (has_Inf real)) : has_exists_mul_of_le (has_Inf real) := sorry --non-trivial
lemma new_lemma_24133 (h0 : group (ordered_ring num)) : normalizer_condition (ordered_ring num) := sorry --non-trivial
lemma new_lemma_24134 (h0 : ring (normed_group num)) : is_principal_ideal_ring (normed_group num) := sorry --non-trivial
lemma new_lemma_24135 (h0 : functor.add_const (list (has_neg Type)) (finset environment.implicit_infer_kind)) : list.nodup (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_24136 (h1 : ring (denumerable linarith.comp_source)) : strong_rank_condition (denumerable linarith.comp_source) := sorry --non-trivial
lemma new_lemma_24137 (h0 : topological_space (sub_neg_monoid Type)) : topological_space.separable_space (sub_neg_monoid Type) := sorry --non-trivial
lemma new_lemma_24138 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @t0_space.{0} to_additive.value_type (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) to_additive.value_type)  := sorry --non-trivial
lemma new_lemma_24139 (h0 : set (has_ssubset char)) : set.finite h0 := sorry --non-trivial
lemma new_lemma_24140 (h0 : complete_lattice (has_emptyc (random_gen (random_gen linarith.ineq)))) : is_compactly_generated (has_emptyc (random_gen (random_gen linarith.ineq))) := sorry --non-trivial
lemma new_lemma_24141 (h0 : ring (div_inv_monoid (has_nnnorm linarith.comp_source))) : is_domain (div_inv_monoid (has_nnnorm linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_24142 (h0 : not (group (metric_space linarith.ineq) -> false)) : @is_cyclic.{0} (metric_space.{0} linarith.ineq) (@classical.by_contradiction'.{1} (group.{0} (metric_space.{0} linarith.ineq)) h0)  := sorry --non-trivial
lemma new_lemma_24143 (h0 : has_mem.mem topological_space has_emptyc.emptyc) : @t0_space.{0} (normed_group.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) topological_space.{0} h0) (normed_group.{0} num))  := sorry --non-trivial
lemma new_lemma_24144 (h0 : topological_space (sub_neg_monoid (has_Inf linarith.comp))) : totally_separated_space (sub_neg_monoid (has_Inf linarith.comp)) := sorry --non-trivial
lemma new_lemma_24145 (h0 : fin has_zero.zero) : @discrete_topology.{1} (generalized_boolean_algebra.{1} Type) (@matrix.vec_empty.{1} (topological_space.{1} (generalized_boolean_algebra.{1} Type)) (@matrix.vec_empty.{0} (fin (@has_zero.zero.{0} nat nat.has_zero)) h0))  := sorry --non-trivial
lemma new_lemma_24146 (h0 : topological_space (boolean_algebra (has_add name))) : irreducible_space (boolean_algebra (has_add name)) := sorry --non-trivial
lemma new_lemma_24147 (h0 : topological_space (add_comm_monoid (has_add (has_add name)))) : irreducible_space (add_comm_monoid (has_add (has_add name))) := sorry --non-trivial
lemma new_lemma_24148 (h0 : functor.add_const (topological_space (has_nndist linarith.comp)) Type) : @sequential_space.{0} (has_nndist.{0} linarith.comp) (@functor.add_const.run.{0 1} (topological_space.{0} (has_nndist.{0} linarith.comp)) Type h0)  := sorry --non-trivial
lemma new_lemma_24149 (h0 : ring (has_emptyc (has_top (has_top fun_info)))) : is_domain (has_emptyc (has_top (has_top fun_info))) := sorry --non-trivial
lemma new_lemma_24150 (h0 : function.extfun Type topological_space) : @totally_disconnected_space.{0} (left_cancel_monoid.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (left_cancel_monoid.{0} empty))  := sorry --non-trivial
lemma new_lemma_24151 (h0 : function.extfun Type ring) : @strong_rank_condition.{0} (sub_neg_monoid.{0} (has_pos_part.{0} linarith.comp)) (@function.extfun_app.{2 1} Type ring.{0} h0 (sub_neg_monoid.{0} (has_pos_part.{0} linarith.comp)))  := sorry --non-trivial
lemma new_lemma_24152 (h0 : fin has_zero.zero) : @add_monoid.fg.{0} (complete_distrib_lattice.{0} real) (@matrix.vec_empty.{0} (add_monoid.{0} (complete_distrib_lattice.{0} real)) h0)  := sorry --non-trivial
lemma new_lemma_24153 (h6 : topological_space (distrib fun_info)) : t0_space (distrib fun_info) := sorry --non-trivial
lemma new_lemma_24154 (h0 : functor.add_const (uniform_space (add_cancel_monoid empty)) empty) : @complete_space.{0} (add_cancel_monoid.{0} empty) (@functor.add_const.run.{0 0} (uniform_space.{0} (add_cancel_monoid.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_24155 (h0 : monoid (linear_ordered_semiring (normed_group congr_arg_kind))) : monoid.fg (linear_ordered_semiring (normed_group congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_24156 (h0 : has_lt (distrib linarith.ineq)) : no_max_order (distrib linarith.ineq) := sorry --non-trivial
lemma new_lemma_24157 (h1 : has_neg (mul_one_class (normed_field enat))) (h2 : measurable_space (mul_one_class (normed_field enat))) : has_measurable_neg (mul_one_class (normed_field enat)) := sorry --non-trivial
lemma new_lemma_24158 (h0 : functor.add_const (group (has_to_string name)) linarith.comp) : @normalizer_condition.{0} (has_to_string.{0} name) (@functor.add_const.run.{0 0} (group.{0} (has_to_string.{0} name)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_24159 (h0 : function.extfun nat fin) : @discrete_topology.{0} (boolean_algebra.core.{0} pos) (@matrix.vec_empty.{0} (topological_space.{0} (boolean_algebra.core.{0} pos)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_24160 (h0 : group (semigroup (has_to_string (has_add (finset pos))))) : is_simple_group (semigroup (has_to_string (has_add (finset pos)))) := sorry --non-trivial
lemma new_lemma_24161 (h1 : group (with_bot (random_gen (random_gen to_additive.value_type)))) : group.fg (with_bot (random_gen (random_gen to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_24162 (h0 : std_gen -> std_gen -> Prop) : is_extensional std_gen h0 := sorry --non-trivial
lemma new_lemma_24163 (h0 : not (has_mem.mem (random_gen linarith.comp_source) has_emptyc.emptyc -> false)) : @is_compactly_generated.{0} (random_gen.{0} linarith.comp_source) (@finset.pi.empty.{1 0} Type complete_lattice.{0} (random_gen.{0} linarith.comp_source) (@classical.by_contradiction'.{0} (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (random_gen.{0} linarith.comp_source) (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))) h0))  := sorry --non-trivial
lemma new_lemma_24164 (h0 : add_monoid (mul_one_class ereal)) : add_monoid.fg (mul_one_class ereal) := sorry --non-trivial
lemma new_lemma_24165 (h0 : group (has_inv (denumerable (random_gen fun_info)))) : is_cyclic (has_inv (denumerable (random_gen fun_info))) := sorry --non-trivial
lemma new_lemma_24166 (h0 : ring (linear_ordered_comm_ring num)) : is_domain (linear_ordered_comm_ring num) := sorry --non-trivial
lemma new_lemma_24167 (h0 : complete_lattice (non_assoc_semiring (semiring (semiring empty)))) : complete_lattice.is_Sup_finite_compact (non_assoc_semiring (semiring (semiring empty))) := sorry --non-trivial
lemma new_lemma_24168 (h0 : topological_space (normed_linear_ordered_group (semiring congr_arg_kind))) : t1_space (normed_linear_ordered_group (semiring congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_24169 (h0 : not (has_mem.mem (linear_ordered_add_comm_group linarith.comp_source) has_emptyc.emptyc -> false)) : @is_domain.{0} (linear_ordered_add_comm_group.{0} linarith.comp_source) (@finset.pi.empty.{1 0} Type ring.{0} (linear_ordered_add_comm_group.{0} linarith.comp_source) (@classical.by_contradiction'.{0} (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (linear_ordered_add_comm_group.{0} linarith.comp_source) (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))) h0))  := sorry --non-trivial
lemma new_lemma_24170 (h0 : functor.add_const (ring (add_comm_monoid unsigned)) linarith.comp) : @strong_rank_condition.{0} (add_comm_monoid.{0} unsigned) (@functor.add_const.run.{0 0} (ring.{0} (add_comm_monoid.{0} unsigned)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_24171 (h0 : complete_lattice (canonically_ordered_comm_semiring (option num))) : complete_lattice.is_Sup_finite_compact (canonically_ordered_comm_semiring (option num)) := sorry --non-trivial
lemma new_lemma_24172 (h0 : semiring (linear_ordered_semiring linarith.comp)) : is_noetherian_ring (linear_ordered_semiring linarith.comp) := sorry --non-trivial
lemma new_lemma_24173 (h0 : topological_space (semigroup linarith.comp)) : irreducible_space (semigroup linarith.comp) := sorry --non-trivial
lemma new_lemma_24174 (h0 : ring (left_cancel_monoid (semiring (semiring unsigned)))) : rank_condition (left_cancel_monoid (semiring (semiring unsigned))) := sorry --non-trivial
lemma new_lemma_24175 (h0 : ring (normed_lattice_add_comm_group Type)) : strong_rank_condition (normed_lattice_add_comm_group Type) := sorry --non-trivial
lemma new_lemma_24176 (h0 : function.extfun Type topological_space) : @irreducible_space.{0} (left_cancel_semigroup.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (left_cancel_semigroup.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_24177 (h0 : ring (has_add (finset (distrib_lattice environment.implicit_infer_kind)))) : rank_condition (has_add (finset (distrib_lattice environment.implicit_infer_kind))) := sorry --non-trivial
lemma new_lemma_24178 (h0 : monoid (complete_semilattice_Sup (random_gen linarith.ineq))) : monoid.fg (complete_semilattice_Sup (random_gen linarith.ineq)) := sorry --non-trivial
lemma new_lemma_24179 (h0 : functor.add_const (topological_space (ordered_comm_ring linarith.comp)) linarith.comp) : @loc_path_connected_space.{0} (ordered_comm_ring.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (ordered_comm_ring.{0} linarith.comp)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_24180 (h0 : list (has_add (has_add linarith.comp))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_24181 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @normal_space.{0} (simple_graph.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (simple_graph.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_24182 (h0 : ordered_add_comm_monoid (ordered_comm_monoid Type)) : archimedean (ordered_comm_monoid Type) := sorry --non-trivial
lemma new_lemma_24183 (h0 : not (group (add_group unsigned) -> false)) : @is_cyclic.{0} (add_group.{0} unsigned) (@classical.by_contradiction'.{1} (group.{0} (add_group.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_24184 (h0 : monoid (normed_group (random_gen (random_gen linarith.ineq)))) : monoid.fg (normed_group (random_gen (random_gen linarith.ineq))) := sorry --non-trivial
lemma new_lemma_24185 (h0 : topological_space (has_to_string (has_bot (comm_semigroup (has_pos_part linarith.comp))))) : preirreducible_space (has_to_string (has_bot (comm_semigroup (has_pos_part linarith.comp)))) := sorry --non-trivial
lemma new_lemma_24186 (h0 : topological_space (comm_ring (random_gen to_additive.value_type))) : t0_space (comm_ring (random_gen to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_24187 (h0 : functor.add_const (topological_space (mul_zero_class empty)) (semiring num)) : @t1_space.{0} (mul_zero_class.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (mul_zero_class.{0} empty)) (semiring.{0} num) h0)  := sorry --non-trivial
lemma new_lemma_24188 (h0 : topological_space (random_gen (has_norm (has_norm linarith.comp_source)))) : irreducible_space (random_gen (has_norm (has_norm linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_24189 (h0 : topological_space (has_one (has_top (has_top empty)))) : t0_space (has_one (has_top (has_top empty))) := sorry --non-trivial
lemma new_lemma_24190 (h0 : uniform_space (finset (option (option (option empty))))) : complete_space (finset (option (option (option empty)))) := sorry --non-trivial
lemma new_lemma_24191 (h0 : ring (semigroup (has_neg (has_neg_part Type)))) : is_domain (semigroup (has_neg (has_neg_part Type))) := sorry --non-trivial
lemma new_lemma_24192 (h0 : topological_space (semiring (semiring (semiring congr_arg_kind)))) : discrete_topology (semiring (semiring (semiring congr_arg_kind))) := sorry --non-trivial
lemma new_lemma_24193 (h0 : topological_space (comm_monoid (option (option empty)))) : t0_space (comm_monoid (option (option empty))) := sorry --non-trivial
lemma new_lemma_24194 (h1 : has_coe std_gen Prop) (h2 : std_gen) : @coe_b.{1 1} std_gen Prop h1 h2  := sorry --non-trivial
lemma new_lemma_24195 (h0 : ring (mul_one_class (add_comm_semigroup (add_comm_semigroup fun_info)))) : strong_rank_condition (mul_one_class (add_comm_semigroup (add_comm_semigroup fun_info))) := sorry --non-trivial
lemma new_lemma_24196 (h0 : fin has_zero.zero) : @normalizer_condition.{0} (has_bot.{0} real) (@matrix.vec_empty.{0} (group.{0} (has_bot.{0} real)) h0)  := sorry --non-trivial
lemma new_lemma_24197 (h0 : set (semi_normed_ring fun_info)) : set.subsingleton h0 := sorry --non-trivial
lemma new_lemma_24198 (h0 : set (enat -> normed_field enat)) : set.separates_points h0 := sorry --non-trivial
lemma new_lemma_24199 (h0 : topological_space (boolean_algebra (finset (boolean_algebra (ring linarith.comp))))) : totally_disconnected_space (boolean_algebra (finset (boolean_algebra (ring linarith.comp)))) := sorry --non-trivial
lemma new_lemma_24200 (h0 : ordered_add_comm_monoid (has_neg_part pos)) : archimedean (has_neg_part pos) := sorry --non-trivial
lemma new_lemma_24201 (h0 : function.extfun Type ring) : @is_principal_ideal_ring.{0} (finset.{0} name) (@function.extfun_app.{2 1} Type ring.{0} h0 (finset.{0} name))  := sorry --non-trivial
lemma new_lemma_24202 (h0 : ordered_comm_monoid (has_neg_part (has_add (normed_comm_ring Type)))) : has_exists_mul_of_le (has_neg_part (has_add (normed_comm_ring Type))) := sorry --non-trivial
lemma new_lemma_24203 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @monoid.fg.{0} (has_zero.{0} name) (@function.extfun_app.{2 1} Type monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 monoid.{0}) (has_zero.{0} name))  := sorry --non-trivial
lemma new_lemma_24204 (h0 : topological_space (has_norm fun_info)) : discrete_topology (has_norm fun_info) := sorry --non-trivial
lemma new_lemma_24205 (h0 : function.extfun Type (functor.comp topological_space has_add)) : @sequential_space.{0} (has_add.{0} pos) (@functor.comp.run.{0 0 0} topological_space.{0} has_add.{0} pos (@function.extfun_app.{2 1} Type (functor.comp.{0 0 0} topological_space.{0} has_add.{0}) h0 pos))  := sorry --non-trivial
lemma new_lemma_24206 (h0 : topological_space (topological_space string_imp)) : t0_space (topological_space string_imp) := sorry --non-trivial
lemma new_lemma_24207 (h0 : ring (has_edist unsigned)) : is_domain (has_edist unsigned) := sorry --non-trivial
lemma new_lemma_24208 (h0 : list (bin_tree unsigned)) : palindrome h0 := sorry --non-trivial
lemma new_lemma_24209 (h0 : functor.add_const (topological_space (has_nndist linarith.comp)) Type) : @normal_space.{0} (has_nndist.{0} linarith.comp) (@functor.add_const.run.{0 1} (topological_space.{0} (has_nndist.{0} linarith.comp)) Type h0)  := sorry --non-trivial
lemma new_lemma_24210 (h0 : functor.add_const (topological_space (semigroup unsigned)) linarith.comp) : @t1_space.{0} (semigroup.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (semigroup.{0} unsigned)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_24211 (h0 : function.extfun Type topological_space) : @normal_space.{0} (left_cancel_monoid.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (left_cancel_monoid.{0} num))  := sorry --non-trivial
lemma new_lemma_24212 (h0 : function.extfun Type topological_space) : @totally_disconnected_space.{0} (dlist.{0} linarith.ineq) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (dlist.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_24213 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : list.nodup (function.extfun_app (function.extfun_app h0 list) (linear_ordered_field name)) := sorry --non-trivial
lemma new_lemma_24214 (h0 : topological_space (has_nnnorm (mul_one_class linarith.ineq))) : t0_space (has_nnnorm (mul_one_class linarith.ineq)) := sorry --non-trivial
lemma new_lemma_24215 (h0 : functor.add_const (group (semigroup name)) linarith.comp) : @group.fg.{0} (semigroup.{0} name) (@functor.add_const.run.{0 0} (group.{0} (semigroup.{0} name)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_24216 (h0 : group (pseudo_metric_space (option ennreal))) : normalizer_condition (pseudo_metric_space (option ennreal)) := sorry --non-trivial
lemma new_lemma_24217 (h0 : functor.add_const (function.extfun Type add_monoid) pos) : @add_monoid.fg.{0} (ring.{0} linarith.comp) (@function.extfun_app.{2 1} Type add_monoid.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type add_monoid.{0}) pos h0) (ring.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_24218 (h0 : functor.add_const (finset (semigroup Type)) linarith.comp) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_24219 (h0 : semiring (generalized_boolean_algebra (has_add Type))) : is_noetherian_ring (generalized_boolean_algebra (has_add Type)) := sorry --non-trivial
lemma new_lemma_24220 (h0 : fin has_zero.zero) : @rank_condition.{1} (ordered_comm_monoid.{1} Type) (@matrix.vec_empty.{1} (ring.{1} (ordered_comm_monoid.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_24221 (h0 : complete_lattice (normed_lattice_add_comm_group (has_Inf real))) : complete_lattice.is_Sup_finite_compact (normed_lattice_add_comm_group (has_Inf real)) := sorry --non-trivial
lemma new_lemma_24222 (h0 : topological_space (linear_ordered_comm_ring (semiring empty))) : locally_compact_space (linear_ordered_comm_ring (semiring empty)) := sorry --non-trivial
lemma new_lemma_24223 (h0 : functor.add_const (semiring (semigroup Type)) (normed_comm_ring (has_neg linarith.comp))) : @is_noetherian_ring.{1} (semigroup.{1} Type) (@functor.add_const.run.{1 0} (semiring.{1} (semigroup.{1} Type)) (normed_comm_ring.{0} (has_neg.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_24224 (h0 : list (has_norm (has_ssubset (has_ssubset to_additive.value_type)))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_24225 (h0 : function.extfun Type cancel_comm_monoid_with_zero) : @unique_factorization_monoid.{0} (add_cancel_monoid.{0} unsigned) (@function.extfun_app.{2 1} Type cancel_comm_monoid_with_zero.{0} h0 (add_cancel_monoid.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_24226 (h1 : complete_lattice (dlist (has_nnnorm (random_gen string_imp)))) : is_compactly_generated (dlist (has_nnnorm (random_gen string_imp))) := sorry --non-trivial
lemma new_lemma_24227 (h0 : linear_ordered_field empty) (h1 : cau_seq empty has_abs.abs) : cau_seq.pos h1 := sorry --non-trivial
lemma new_lemma_24228 (h1 : topological_space (id linarith.comp)) : irreducible_space (id linarith.comp) := sorry --non-trivial
lemma new_lemma_24229 (h0 : topological_space (semigroup (finset Type))) : regular_space (semigroup (finset Type)) := sorry --non-trivial
lemma new_lemma_24230 (h0 : topological_space (has_div (mul_one_class linarith.ineq))) (h1 : not (preorder (has_div (mul_one_class linarith.ineq)) -> false)) : @order_topology.{0} (has_div.{0} (mul_one_class.{0} linarith.ineq)) h0 (@classical.by_contradiction'.{1} (preorder.{0} (has_div.{0} (mul_one_class.{0} linarith.ineq))) h1)  := sorry --non-trivial
lemma new_lemma_24231 (h0 : filter (plift (semiring num))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_24232 (h0 : topological_space (partial_order num)) : topological_space.separable_space (partial_order num) := sorry --non-trivial
lemma new_lemma_24233 (h0 : topological_space (with_one (has_norm (has_norm (has_norm (random_gen linarith.comp)))))) : totally_disconnected_space (with_one (has_norm (has_norm (has_norm (random_gen linarith.comp))))) := sorry --non-trivial
lemma new_lemma_24234 (h0 : group (monoid_with_zero (option unsigned))) : is_simple_group (monoid_with_zero (option unsigned)) := sorry --non-trivial
lemma new_lemma_24235 (h0 : function.extfun Type (functor.add_const (list (linear_order unsigned)))) : palindrome (functor.add_const.run (function.extfun_app h0 empty)) := sorry --non-trivial
lemma new_lemma_24236 (h0 : preorder fun_info) (h1 : fun_info) : set.is_pwo (is_distinct fun_info h1) := sorry --non-trivial
lemma new_lemma_24237 (h0 : not (topological_space (linear_ordered_semiring empty) -> false)) : @topological_space.separable_space.{0} (linear_ordered_semiring.{0} empty) (@classical.by_contradiction'.{1} (topological_space.{0} (linear_ordered_semiring.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_24238 (h0 : functor.add_const (function.extfun Type complete_lattice) (finset pos)) : @is_compactly_generated.{0} (semigroup.{0} pos) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type complete_lattice.{0}) (finset.{0} pos) h0) (semigroup.{0} pos))  := sorry --non-trivial
lemma new_lemma_24239 (h0 : list (complete_distrib_lattice (normed_comm_ring (has_add name)))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_24240 (h0 : function.extfun Type semiring) : @is_noetherian_ring.{0} (add_cancel_monoid.{0} ennreal) (@function.extfun_app.{2 1} Type semiring.{0} h0 (add_cancel_monoid.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_24241 (h0 : function.extfun (finset Type) (has_mem.mem (random_gen complex))) : @is_cyclic.{0} (random_gen.{0} complex) (@finset.pi.empty.{1 0} Type group.{0} (random_gen.{0} complex) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (random_gen.{0} complex)) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_24242 (h0 : topological_space (boolean_algebra (has_to_string pos))) : preconnected_space (boolean_algebra (has_to_string pos)) := sorry --non-trivial
lemma new_lemma_24243 (h0 : ring (simple_graph pos)) : is_domain (simple_graph pos) := sorry --non-trivial
lemma new_lemma_24244 (h0 : complete_lattice (has_one (has_top congr_arg_kind))) : is_atomistic (has_one (has_top congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_24245 (h0 : functor.add_const (cancel_comm_monoid_with_zero (boolean_algebra.core pos)) name) : @unique_factorization_monoid.{0} (boolean_algebra.core.{0} pos) (@functor.add_const.run.{0 0} (cancel_comm_monoid_with_zero.{0} (boolean_algebra.core.{0} pos)) name h0)  := sorry --non-trivial
lemma new_lemma_24246 (h0 : topological_space (add_comm_semigroup enat)) : totally_disconnected_space (add_comm_semigroup enat) := sorry --non-trivial
lemma new_lemma_24247 (h1 : not (topological_space (linear_ordered_semiring to_additive.value_type) -> false)) : @discrete_topology.{0} (linear_ordered_semiring.{0} to_additive.value_type) (@classical.by_contradiction'.{1} (topological_space.{0} (linear_ordered_semiring.{0} to_additive.value_type)) h1)  := sorry --non-trivial
lemma new_lemma_24248 (h0 : functor.add_const (complete_lattice (ordered_comm_group unsigned)) empty) : @complete_lattice.is_Sup_finite_compact.{0} (ordered_comm_group.{0} unsigned) (@functor.add_const.run.{0 0} (complete_lattice.{0} (ordered_comm_group.{0} unsigned)) empty h0)  := sorry --non-trivial
lemma new_lemma_24249 (h0 : not (function.extfun (finset (Type -> Type)) (has_mem.mem group) -> false)) : @normalizer_condition.{0} congr_arg_kind (@function.extfun_app.{2 1} Type group.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) group.{0} (@function.extfun_app.{2 0} (finset.{1} (Type → Type)) (@has_mem.mem.{1 1} (Type → Type) (finset.{1} (Type → Type)) (@finset.has_mem.{1} (Type → Type)) group.{0}) (@classical.by_contradiction'.{0} (function.extfun.{2 0} (finset.{1} (Type → Type)) (@has_mem.mem.{1 1} (Type → Type) (finset.{1} (Type → Type)) (@finset.has_mem.{1} (Type → Type)) group.{0})) h0) (@has_emptyc.emptyc.{1} (finset.{1} (Type → Type)) (@finset.has_emptyc.{1} (Type → Type))))) congr_arg_kind)  := sorry --non-trivial
lemma new_lemma_24250 (h0 : functor.add_const (function.extfun Type topological_space) (has_Inf Type)) : @preconnected_space.{0} (finset.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type topological_space.{0}) (has_Inf.{1} Type) h0) (finset.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_24251 (h0 : not (finset (left_cancel_monoid num) -> false)) : finset.nonempty (classical.by_contradiction' h0) := sorry --non-trivial
lemma new_lemma_24252 (h0 : semiring (has_pos_part Type)) : is_noetherian_ring (has_pos_part Type) := sorry --non-trivial
lemma new_lemma_24253 (h0 : monoid (linear_ordered_add_comm_group (has_inv (random_gen to_additive.value_type)))) : monoid.fg (linear_ordered_add_comm_group (has_inv (random_gen to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_24254 (h0 : topological_space (finset (option pos))) : normal_space (finset (option pos)) := sorry --non-trivial
lemma new_lemma_24255 (h1 : ring (has_append (has_nnnorm (has_nnnorm linarith.comp_source)))) : rank_condition (has_append (has_nnnorm (has_nnnorm linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_24256 (h0 : functor.add_const (topological_space (complete_distrib_lattice Type)) linarith.comp) : @locally_compact_space.{1} (complete_distrib_lattice.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (complete_distrib_lattice.{1} Type)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_24257 (h2 : preorder (non_unital_non_assoc_semiring linarith.comp_source)) (h3 : succ_order (non_unital_non_assoc_semiring linarith.comp_source)) : is_succ_archimedean (non_unital_non_assoc_semiring linarith.comp_source) := sorry --non-trivial
lemma new_lemma_24258 (h1 : function.extfun (Type -> Type) (function.extfun Type)) : @complete_space.{0} (with_bot.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type uniform_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h1 uniform_space.{0}) (with_bot.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_24259 (h0 : group (filter unsigned)) : is_cyclic (filter unsigned) := sorry --non-trivial
lemma new_lemma_24260 (h0 : functor.add_const (function.extfun Type add_monoid) (finset pos)) : @add_monoid.fg.{0} (ring.{0} linarith.comp) (@function.extfun_app.{2 1} Type add_monoid.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type add_monoid.{0}) (finset.{0} pos) h0) (ring.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_24261 (h0 : group (denumerable (random_gen string.iterator_imp))) : is_cyclic (denumerable (random_gen string.iterator_imp)) := sorry --non-trivial
lemma new_lemma_24262 (h0 : ring (topological_space (denumerable linarith.comp_source))) : is_domain (topological_space (denumerable linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_24263 (h1 : set (has_one std_gen)) : set.subsingleton h1 := sorry --non-trivial
lemma new_lemma_24264 (h0 : functor.comp topological_space has_nndist name) : @path_connected_space.{0} (has_nndist.{0} name) (@functor.comp.run.{0 0 0} topological_space.{0} has_nndist.{0} name h0)  := sorry --non-trivial
lemma new_lemma_24265 (h0 : ring (dlist fun_info)) : strong_rank_condition (dlist fun_info) := sorry --non-trivial
lemma new_lemma_24266 (h0 : topological_space (option (option (semiring empty)))) : totally_separated_space (option (option (semiring empty))) := sorry --non-trivial
lemma new_lemma_24267 (h0 : not (topological_space (has_norm to_additive.value_type) -> false)) : @t0_space.{0} (has_norm.{0} to_additive.value_type) (@classical.by_contradiction'.{1} (topological_space.{0} (has_norm.{0} to_additive.value_type)) h0)  := sorry --non-trivial
lemma new_lemma_24268 (h0 : functor.add_const (topological_space (canonically_ordered_comm_semiring environment.implicit_infer_kind)) pos) : @irreducible_space.{0} (canonically_ordered_comm_semiring.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (canonically_ordered_comm_semiring.{0} environment.implicit_infer_kind)) pos h0)  := sorry --non-trivial
lemma new_lemma_24269 (h0 : topological_space (boolean_algebra (boolean_algebra pos))) : sequential_space (boolean_algebra (boolean_algebra pos)) := sorry --non-trivial
lemma new_lemma_24270 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : countable_Inter_filter (function.extfun_app (function.extfun_app h0 filter) (mul_zero_class pos)) := sorry --non-trivial
lemma new_lemma_24271 (h0 : fin has_zero.zero) : @sequential_space.{0} (comm_semigroup.{0} pos) (@matrix.vec_empty.{0} (topological_space.{0} (comm_semigroup.{0} pos)) h0)  := sorry --non-trivial
lemma new_lemma_24272 (h0 : topological_space (has_ssubset (random_gen (has_nnnorm (has_nnnorm linarith.comp_source))))) : locally_compact_space (has_ssubset (random_gen (has_nnnorm (has_nnnorm linarith.comp_source)))) := sorry --non-trivial
lemma new_lemma_24273 (h0 : ordered_comm_monoid (add_comm_monoid (has_neg_part pos))) : has_exists_mul_of_le (add_comm_monoid (has_neg_part pos)) := sorry --non-trivial
lemma new_lemma_24274 (h0 : functor.add_const Prop (has_dist congr_arg_kind)) : functor.add_const.run h0 := sorry --non-trivial
lemma new_lemma_24275 (h0 : ring (complete_distrib_lattice (boolean_algebra.core ennreal))) : is_principal_ideal_ring (complete_distrib_lattice (boolean_algebra.core ennreal)) := sorry --non-trivial
lemma new_lemma_24276 (h0 : add_group (linear_ordered_semiring (semiring (has_top congr_arg_kind)))) : is_add_cyclic (linear_ordered_semiring (semiring (has_top congr_arg_kind))) := sorry --non-trivial
lemma new_lemma_24277 (h0 : topological_space (cancel_monoid environment.implicit_infer_kind)) : sequential_space (cancel_monoid environment.implicit_infer_kind) := sorry --non-trivial
lemma new_lemma_24278 (h0 : functor.add_const (fin has_zero.zero) real) : @is_add_cyclic.{1} (comm_semigroup.{1} Type) (@matrix.vec_empty.{1} (add_group.{1} (comm_semigroup.{1} Type)) (@functor.add_const.run.{0 0} (fin (@has_zero.zero.{0} nat nat.has_zero)) real h0))  := sorry --non-trivial
lemma new_lemma_24279 (h0 : topological_space (boolean_algebra pos)) : preconnected_space (boolean_algebra pos) := sorry --non-trivial
lemma new_lemma_24280 (h0 : function.extfun Type filter) : countable_Inter_filter (function.extfun_app h0 (has_nndist ennreal)) := sorry --non-trivial
lemma new_lemma_24281 (h0 : functor.add_const (topological_space (has_add unsigned)) pos) : @loc_path_connected_space.{0} (has_add.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (has_add.{0} unsigned)) pos h0)  := sorry --non-trivial
lemma new_lemma_24282 (h0 : group (has_emptyc (random_gen linarith.comp))) : is_cyclic (has_emptyc (random_gen linarith.comp)) := sorry --non-trivial
lemma new_lemma_24283 (h0 : group (linear_ordered_add_comm_group (comm_ring (random_gen linarith.ineq)))) : is_cyclic (linear_ordered_add_comm_group (comm_ring (random_gen linarith.ineq))) := sorry --non-trivial
lemma new_lemma_24284 (h0 : topological_space (generalized_boolean_algebra (has_add pos))) : totally_disconnected_space (generalized_boolean_algebra (has_add pos)) := sorry --non-trivial
lemma new_lemma_24285 (h0 : ring (add_comm_monoid num)) : strong_rank_condition (add_comm_monoid num) := sorry --non-trivial
lemma new_lemma_24286 (h0 : uniform_space (comm_group Type)) : complete_space (comm_group Type) := sorry --non-trivial
lemma new_lemma_24287 (h0 : filter (complete_distrib_lattice (comm_group pos))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_24288 (h0 : function.extfun Type topological_space) : @path_connected_space.{0} (has_edist.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_edist.{0} empty))  := sorry --non-trivial
lemma new_lemma_24289 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_noetherian_ring.{0} (canonically_ordered_comm_semiring.{0} num) (@function.extfun_app.{2 1} Type semiring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 semiring.{0}) (canonically_ordered_comm_semiring.{0} num))  := sorry --non-trivial
lemma new_lemma_24290 (h0 : ring (ordered_comm_group (comm_monoid unsigned))) : rank_condition (ordered_comm_group (comm_monoid unsigned)) := sorry --non-trivial
lemma new_lemma_24291 (h0 : ring (boolean_algebra.core (option pos))) : strong_rank_condition (boolean_algebra.core (option pos)) := sorry --non-trivial
lemma new_lemma_24292 (h0 : has_mem.mem to_additive.value_type has_emptyc.emptyc) : @is_atomistic.{0} to_additive.value_type (@finset.pi.empty.{1 0} Type complete_lattice.{0} to_additive.value_type h0)  := sorry --non-trivial
lemma new_lemma_24293 (h0 : not (group (has_top num) -> false)) : @is_cyclic.{0} (has_top.{0} num) (@classical.by_contradiction'.{1} (group.{0} (has_top.{0} num)) h0)  := sorry --non-trivial
lemma new_lemma_24294 (h0 : function.extfun Type topological_space) : @discrete_topology.{0} (has_inner.{0 0} unsigned unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_inner.{0 0} unsigned unsigned))  := sorry --non-trivial
lemma new_lemma_24295 (h0 : complete_lattice (has_norm (semiring linarith.comp))) : is_atomistic (has_norm (semiring linarith.comp)) := sorry --non-trivial
lemma new_lemma_24296 (h0 : topological_space (complete_semilattice_Sup congr_arg_kind)) : locally_compact_space (complete_semilattice_Sup congr_arg_kind) := sorry --non-trivial
lemma new_lemma_24297 (h0 : ring (with_bot (distrib_lattice to_additive.value_type))) : rank_condition (with_bot (distrib_lattice to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_24298 (h0 : function.extfun Type topological_space) : @normal_space.{0} (has_bot.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_bot.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_24299 (h0 : ring (boolean_algebra (canonically_linear_ordered_monoid real))) : strong_rank_condition (boolean_algebra (canonically_linear_ordered_monoid real)) := sorry --non-trivial
lemma new_lemma_24300 (h0 : function.extfun Type topological_space) : @locally_compact_space.{0} (linear_ordered_add_comm_group.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (linear_ordered_add_comm_group.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_24301 (h0 : complete_lattice (comm_semigroup (sub_neg_monoid name))) : complete_lattice.is_Sup_finite_compact (comm_semigroup (sub_neg_monoid name)) := sorry --non-trivial
lemma new_lemma_24302 (h0 : functor.add_const (topological_space (has_to_string pos)) pos) : @sequential_space.{0} (has_to_string.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (has_to_string.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_24303 (h0 : group (ordered_comm_ring (has_Inf (has_neg (has_neg linarith.comp))))) : normalizer_condition (ordered_comm_ring (has_Inf (has_neg (has_neg linarith.comp)))) := sorry --non-trivial
lemma new_lemma_24304 (h0 : group (comm_group (measurable_space.dynkin_system name))) : is_cyclic (comm_group (measurable_space.dynkin_system name)) := sorry --non-trivial
lemma new_lemma_24305 (h0 : not (ring (linear_ordered_semiring num) -> false)) : @strong_rank_condition.{0} (linear_ordered_semiring.{0} num) (@classical.by_contradiction'.{1} (ring.{0} (linear_ordered_semiring.{0} num)) h0)  := sorry --non-trivial
lemma new_lemma_24306 (h0 : function.extfun Type complete_lattice) : is_atomistic (measurable_space string_imp) := sorry --non-trivial
lemma new_lemma_24307 (h0 : not (filter (id empty) -> false)) : filter.ne_bot (classical.by_contradiction' h0) := sorry --non-trivial
lemma new_lemma_24308 (h0 : not (complete_lattice (normed_group empty) -> false)) : @complete_lattice.is_Sup_finite_compact.{0} (normed_group.{0} empty) (@classical.by_contradiction'.{1} (complete_lattice.{0} (normed_group.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_24309 (h0 : ring (has_union (semiring empty))) : rank_condition (has_union (semiring empty)) := sorry --non-trivial
lemma new_lemma_24310 (h0 : topological_space (has_bot empty)) : path_connected_space (has_bot empty) := sorry --non-trivial
lemma new_lemma_24311 (h0 : add_group (add_comm_monoid (option name))) : is_add_cyclic (add_comm_monoid (option name)) := sorry --non-trivial
lemma new_lemma_24312 (h0 : ring (has_nnnorm to_additive.value_type)) : rank_condition (has_nnnorm to_additive.value_type) := sorry --non-trivial
lemma new_lemma_24313 (h0 : has_scalar num (plift congr_arg_kind)) : has_faithful_scalar num (plift congr_arg_kind) := sorry --non-trivial
lemma new_lemma_24314 (h0 : has_mem.mem (linear_ordered_semiring num) has_emptyc.emptyc) : @is_domain.{0} (linear_ordered_semiring.{0} num) (@finset.pi.empty.{1 0} Type ring.{0} (linear_ordered_semiring.{0} num) h0)  := sorry --non-trivial
lemma new_lemma_24315 (h0 : group (has_bot (option empty))) : group.fg (has_bot (option empty)) := sorry --non-trivial
lemma new_lemma_24316 (h0 : function.extfun Type group) : @group.fg.{0} (canonically_ordered_comm_semiring.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type group.{0} h0 (canonically_ordered_comm_semiring.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_24317 (h0 : fin has_zero.zero) : @complete_space.{0} (ordered_comm_ring.{0} name) (@matrix.vec_empty.{0} (uniform_space.{0} (ordered_comm_ring.{0} name)) h0)  := sorry --non-trivial
lemma new_lemma_24318 (h0 : functor.comp complete_lattice has_neg name) : @is_atomistic.{0} (has_neg.{0} name) (@functor.comp.run.{0 0 0} complete_lattice.{0} has_neg.{0} name h0)  := sorry --non-trivial
lemma new_lemma_24319 (h0 : complete_lattice (has_ssubset (random_gen (has_nnnorm to_additive.value_type)))) : is_compactly_generated (has_ssubset (random_gen (has_nnnorm to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_24320 (h0 : ordered_add_comm_monoid (mul_zero_class (finset (finset (finset environment.implicit_infer_kind))))) : archimedean (mul_zero_class (finset (finset (finset environment.implicit_infer_kind)))) := sorry --non-trivial
lemma new_lemma_24321 (h0 : ring (complete_distrib_lattice linarith.comp)) : strong_rank_condition (complete_distrib_lattice linarith.comp) := sorry --non-trivial
lemma new_lemma_24322 (h2 : uniform_space (random_gen (has_nnnorm fun_info))) : complete_space (random_gen (has_nnnorm fun_info)) := sorry --non-trivial
lemma new_lemma_24323 (h0 : topological_space (has_Inf (ordered_ring linarith.comp))) : preconnected_space (has_Inf (ordered_ring linarith.comp)) := sorry --non-trivial
lemma new_lemma_24324 (h0 : ring (boolean_algebra.core (finset linarith.comp))) : is_domain (boolean_algebra.core (finset linarith.comp)) := sorry --non-trivial
lemma new_lemma_24325 (h0 : set (has_sdiff linarith.ineq)) : set.subsingleton h0 := sorry --non-trivial
lemma new_lemma_24326 (h0 : functor.add_const (function.extfun Type topological_space) name) : @regular_space.{0} (add_cancel_monoid.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) name h0) (add_cancel_monoid.{0} name))  := sorry --non-trivial
lemma new_lemma_24327 (h0 : semiring (option (semiring (semiring (semiring (semiring empty)))))) : is_noetherian_ring (option (semiring (semiring (semiring (semiring empty))))) := sorry --non-trivial
lemma new_lemma_24328 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @separated_space.{0} (semigroup.{0} unsigned) (@function.extfun_app.{2 1} Type uniform_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 uniform_space.{0}) (semigroup.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_24329 (h0 : ring (has_dist num)) : strong_rank_condition (has_dist num) := sorry --non-trivial
lemma new_lemma_24330 (h0 : ring (has_add (has_neg pos))) : is_domain (has_add (has_neg pos)) := sorry --non-trivial
lemma new_lemma_24331 (h0 : group (semiring (semiring (semiring unsigned)))) : is_cyclic (semiring (semiring (semiring unsigned))) := sorry --non-trivial
lemma new_lemma_24332 (h0 : functor.add_const (topological_space (semigroup num)) empty) : @loc_path_connected_space.{0} (semigroup.{0} num) (@functor.add_const.run.{0 0} (topological_space.{0} (semigroup.{0} num)) empty h0)  := sorry --non-trivial
lemma new_lemma_24333 (h0 : function.extfun Type complete_lattice) : @complete_lattice.is_Sup_finite_compact.{0} (boolean_algebra.{0} real) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (boolean_algebra.{0} real))  := sorry --non-trivial
lemma new_lemma_24334 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @discrete_topology.{0} (metric_space.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (metric_space.{0} empty))  := sorry --non-trivial
lemma new_lemma_24335 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @totally_separated_space.{0} (ordered_comm_monoid.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (ordered_comm_monoid.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_24336 (h0 : group (comm_group environment.implicit_infer_kind)) : is_simple_group (comm_group environment.implicit_infer_kind) := sorry --non-trivial
lemma new_lemma_24337 (h0 : list (add_cancel_monoid (normed_comm_ring name))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_24338 (h0 : list (semi_normed_comm_ring (has_ssubset (random_gen linarith.ineq)))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_24339 (h0 : not (list (comm_ring fun_info) -> false)) : list.nodup (classical.by_contradiction' h0) := sorry --non-trivial
lemma new_lemma_24340 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @preconnected_space.{0} (has_neg_part.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_neg_part.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_24341 (h0 : group auto.case_option) : is_cyclic auto.case_option := sorry --non-trivial
lemma new_lemma_24342 (h0 : topological_space (ring (has_add unsigned))) : discrete_topology (ring (has_add unsigned)) := sorry --non-trivial
lemma new_lemma_24343 (h0 : topological_space (boolean_algebra unsigned)) : totally_disconnected_space (boolean_algebra unsigned) := sorry --non-trivial
lemma new_lemma_24344 (h0 : uniform_space (random_gen (has_inv (has_inv fun_info)))) : complete_space (random_gen (has_inv (has_inv fun_info))) := sorry --non-trivial
lemma new_lemma_24345 (h0 : functor.add_const (ordered_add_comm_monoid (semiring num)) (option (option empty))) : @archimedean.{0} (semiring.{0} num) (@functor.add_const.run.{0 0} (ordered_add_comm_monoid.{0} (semiring.{0} num)) (option.{0} (option.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_24346 (h0 : topological_space (ordered_comm_ring (has_add Type))) : path_connected_space (ordered_comm_ring (has_add Type)) := sorry --non-trivial
lemma new_lemma_24347 (h2 : complete_lattice (distrib char)) : complete_lattice.is_Sup_finite_compact (distrib char) := sorry --non-trivial
lemma new_lemma_24348 (h0 : topological_space (has_ssubset (has_ssubset (random_gen linarith.comp_source)))) : totally_disconnected_space (has_ssubset (has_ssubset (random_gen linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_24349 (h0 : topological_space (generalized_boolean_algebra (has_Inf real))) : discrete_topology (generalized_boolean_algebra (has_Inf real)) := sorry --non-trivial
lemma new_lemma_24350 (h0 : ring (add_cancel_monoid congr_arg_kind)) : strong_rank_condition (add_cancel_monoid congr_arg_kind) := sorry --non-trivial
lemma new_lemma_24351 (h1 : not (topological_space (add_group to_additive.value_type) -> false)) : @totally_disconnected_space.{0} (add_group.{0} to_additive.value_type) (@classical.by_contradiction'.{1} (topological_space.{0} (add_group.{0} to_additive.value_type)) h1)  := sorry --non-trivial
lemma new_lemma_24352 (h0 : functor.add_const (ring (has_nndist Type)) name) : @rank_condition.{1} (has_nndist.{1} Type) (@functor.add_const.run.{1 0} (ring.{1} (has_nndist.{1} Type)) name h0)  := sorry --non-trivial
lemma new_lemma_24353 (h0 : topological_space (id linarith.ineq)) : t0_space (id linarith.ineq) := sorry --non-trivial
lemma new_lemma_24354 (h0 : not (add_monoid (has_star congr_arg_kind) -> false)) : @add_monoid.fg.{0} (has_star.{0} congr_arg_kind) (@classical.by_contradiction'.{1} (add_monoid.{0} (has_star.{0} congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_24355 (h0 : group (has_union empty)) : is_cyclic (has_union empty) := sorry --non-trivial
lemma new_lemma_24356 (h0 : topological_space (add_comm_monoid (option (option pos)))) : preirreducible_space (add_comm_monoid (option (option pos))) := sorry --non-trivial
lemma new_lemma_24357 (h0 : functor.add_const (topological_space (boolean_algebra linarith.comp)) pos) : @totally_disconnected_space.{0} (boolean_algebra.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (boolean_algebra.{0} linarith.comp)) pos h0)  := sorry --non-trivial
lemma new_lemma_24358 (h0 : function.extfun Type group) : @group.fg.{0} (semigroup.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type group.{0} h0 (semigroup.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_24359 (h0 : not (group (has_emptyc num) -> false)) : @is_simple_group.{0} (has_emptyc.{0} num) (@classical.by_contradiction'.{1} (group.{0} (has_emptyc.{0} num)) h0)  := sorry --non-trivial
lemma new_lemma_24360 (h1 : not (function.extfun Type topological_space -> false)) : @totally_disconnected_space.{0} (has_emptyc.{0} fun_info) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h1) (has_emptyc.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_24361 (h0 : function.extfun Type (functor.comp group cancel_monoid)) : @normalizer_condition.{0} (cancel_monoid.{0} environment.implicit_infer_kind) (@functor.comp.run.{0 0 0} group.{0} cancel_monoid.{0} environment.implicit_infer_kind (@function.extfun_app.{2 1} Type (functor.comp.{0 0 0} group.{0} cancel_monoid.{0}) h0 environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_24362 (h0 : not (ring (add_group empty) -> false)) : @is_domain.{0} (add_group.{0} empty) (@classical.by_contradiction'.{1} (ring.{0} (add_group.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_24363 (h0 : topological_space (with_bot (has_top (has_top fun_info)))) : irreducible_space (with_bot (has_top (has_top fun_info))) := sorry --non-trivial
lemma new_lemma_24364 (h0 : fin has_zero.zero) : @unique_factorization_monoid.{0} (complete_distrib_lattice.{0} real) (@matrix.vec_empty.{0} (cancel_comm_monoid_with_zero.{0} (complete_distrib_lattice.{0} real)) h0)  := sorry --non-trivial
lemma new_lemma_24365 (h0 : uniform_space (has_neg (has_add (comm_group name)))) : separated_space (has_neg (has_add (comm_group name))) := sorry --non-trivial
lemma new_lemma_24366 (h0 : topological_space (has_top (random_gen fun_info))) : t0_space (has_top (random_gen fun_info)) := sorry --non-trivial
lemma new_lemma_24367 (h0 : topological_space (has_to_string name)) : sequential_space (has_to_string name) := sorry --non-trivial
lemma new_lemma_24368 (h0 : ring (uniform_space (metric_space to_additive.value_type))) : is_domain (uniform_space (metric_space to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_24369 (h0 : group (random_gen (has_top (random_gen fun_info)))) : is_cyclic (random_gen (has_top (random_gen fun_info))) := sorry --non-trivial
lemma new_lemma_24370 (h0 : topological_space (complete_distrib_lattice (has_pos_part (ring pos)))) : totally_separated_space (complete_distrib_lattice (has_pos_part (ring pos))) := sorry --non-trivial
lemma new_lemma_24371 (h0 : topological_space (boolean_algebra (has_add Type))) : regular_space (boolean_algebra (has_add Type)) := sorry --non-trivial
lemma new_lemma_24372 (h0 : monoid (linear_ordered_comm_monoid_with_zero unsigned)) : monoid.fg (linear_ordered_comm_monoid_with_zero unsigned) := sorry --non-trivial
lemma new_lemma_24373 (h0 : functor.add_const (filter (semigroup Type)) unsigned) : countable_Inter_filter (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_24374 (h0 : uniform_space (mul_one_class (mul_one_class string_imp))) : complete_space (mul_one_class (mul_one_class string_imp)) := sorry --non-trivial
lemma new_lemma_24375 (h0 : function.extfun Type (functor.add_const (list (left_cancel_semigroup empty)))) : palindrome (functor.add_const.run (function.extfun_app h0 empty)) := sorry --non-trivial
lemma new_lemma_24376 (h0 : has_lt (has_lt (mul_one_class linarith.comp_source))) : no_max_order (has_lt (mul_one_class linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_24377 (h0 : complete_lattice (has_zero (option unsigned))) : complete_lattice.is_Sup_finite_compact (has_zero (option unsigned)) := sorry --non-trivial
lemma new_lemma_24378 (h0 : filter (measurable_space congr_arg_kind)) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_24379 (h0 : functor.add_const (ring (has_dist empty)) empty) : @is_domain.{0} (has_dist.{0} empty) (@functor.add_const.run.{0 0} (ring.{0} (has_dist.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_24380 (h0 : ring (linear_ordered_semiring (semiring (semiring (semiring congr_arg_kind))))) : rank_condition (linear_ordered_semiring (semiring (semiring (semiring congr_arg_kind)))) := sorry --non-trivial
lemma new_lemma_24381 (h0 : function.extfun Type topological_space) : @topological_space.separable_space.{0} (group_with_zero.{0} ennreal) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (group_with_zero.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_24382 (h0 : functor.add_const (topological_space (normed_comm_ring pos)) (has_to_string linarith.comp)) : @totally_disconnected_space.{0} (normed_comm_ring.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (normed_comm_ring.{0} pos)) (has_to_string.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_24383 (h0 : ring congr_arg_kind) : strong_rank_condition congr_arg_kind := sorry --non-trivial
lemma new_lemma_24384 (h0 : topological_space (has_neg_part unsigned)) : path_connected_space (has_neg_part unsigned) := sorry --non-trivial
lemma new_lemma_24385 (h0 : uniform_space (non_unital_non_assoc_semiring enat)) : complete_space (non_unital_non_assoc_semiring enat) := sorry --non-trivial
lemma new_lemma_24386 (h0 : uniform_space (has_nndist (has_add name))) : separated_space (has_nndist (has_add name)) := sorry --non-trivial
lemma new_lemma_24387 (h0 : group (boolean_algebra.core (finset pos))) : is_cyclic (boolean_algebra.core (finset pos)) := sorry --non-trivial
lemma new_lemma_24388 (h0 : ordered_comm_monoid (has_zero (ring environment.implicit_infer_kind))) : has_exists_mul_of_le (has_zero (ring environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_24389 (h2 : has_lt (mul_one_class (mul_one_class fun_info))) : no_max_order (mul_one_class (mul_one_class fun_info)) := sorry --non-trivial
lemma new_lemma_24390 (h0 : functor.add_const (add_monoid (ring pos)) environment.implicit_infer_kind) : @add_monoid.fg.{0} (ring.{0} pos) (@functor.add_const.run.{0 0} (add_monoid.{0} (ring.{0} pos)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_24391 (h0 : not (complete_lattice (random_gen linarith.comp_source) -> false)) : @is_compactly_generated.{0} (random_gen.{0} linarith.comp_source) (@classical.by_contradiction'.{1} (complete_lattice.{0} (random_gen.{0} linarith.comp_source)) h0)  := sorry --non-trivial
lemma new_lemma_24392 (h0 : topological_space (mul_one_class (add_comm_semigroup ereal))) : t0_space (mul_one_class (add_comm_semigroup ereal)) := sorry --non-trivial
lemma new_lemma_24393 (h0 : topological_space (add_comm_monoid (has_neg (add_comm_monoid pos)))) : sequential_space (add_comm_monoid (has_neg (add_comm_monoid pos))) := sorry --non-trivial
lemma new_lemma_24394 (h0 : complete_lattice (has_top (random_gen num))) : complete_lattice.is_Sup_finite_compact (has_top (random_gen num)) := sorry --non-trivial
lemma new_lemma_24395 (h0 : functor.add_const (add_monoid (has_to_string name)) Type) : @add_monoid.fg.{0} (has_to_string.{0} name) (@functor.add_const.run.{0 1} (add_monoid.{0} (has_to_string.{0} name)) Type h0)  := sorry --non-trivial
lemma new_lemma_24396 (h0 : ring (semi_normed_ring (comm_ring char))) : rank_condition (semi_normed_ring (comm_ring char)) := sorry --non-trivial
lemma new_lemma_24397 (h0 : function.extfun Type topological_space) : @preirreducible_space.{0} (has_inner.{0 0} unsigned unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_inner.{0 0} unsigned unsigned))  := sorry --non-trivial
lemma new_lemma_24398 (h0 : topological_space (non_assoc_semiring (semiring (semiring congr_arg_kind)))) : normal_space (non_assoc_semiring (semiring (semiring congr_arg_kind))) := sorry --non-trivial
lemma new_lemma_24399 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @unique_factorization_monoid.{1} (has_pos_part.{1} Type) (@function.extfun_app.{3 2} (Type 1) cancel_comm_monoid_with_zero.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 cancel_comm_monoid_with_zero.{1}) (has_pos_part.{1} Type))  := sorry --non-trivial
lemma new_lemma_24400 (h0 : complete_lattice (add_cancel_monoid (has_add linarith.comp))) : is_compactly_generated (add_cancel_monoid (has_add linarith.comp)) := sorry --non-trivial
lemma new_lemma_24401 (h0 : topological_space (has_nndist (option ennreal))) : totally_disconnected_space (has_nndist (option ennreal)) := sorry --non-trivial
lemma new_lemma_24402 (h0 : functor.add_const (list (has_neg pos)) linarith.comp) : palindrome (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_24403 (h0 : filter subsingleton_info) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_24404 (h0 : list (has_nndist (has_pos_part (has_pos_part linarith.comp)))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_24405 (h0 : topological_space (finset (has_add real))) : loc_path_connected_space (finset (has_add real)) := sorry --non-trivial
lemma new_lemma_24406 (h0 : function.extfun Type add_monoid) : @add_monoid.fg.{0} (add_right_cancel_monoid.{0} unsigned) (@function.extfun_app.{2 1} Type add_monoid.{0} h0 (add_right_cancel_monoid.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_24407 (h0 : linarith.ineq -> linarith.ineq -> Prop) : is_strict_total_order' linarith.ineq h0 := sorry --non-trivial
lemma new_lemma_24408 (h0 : complete_lattice (uniform_space string.iterator_imp)) : complete_lattice.is_Sup_finite_compact (uniform_space string.iterator_imp) := sorry --non-trivial
lemma new_lemma_24409 (h0 : not (topological_space empty -> false)) : t1_space empty := sorry --non-trivial
lemma new_lemma_24410 (h0 : topological_space (ring (boolean_algebra linarith.comp))) : totally_separated_space (ring (boolean_algebra linarith.comp)) := sorry --non-trivial
lemma new_lemma_24411 (h0 : functor.add_const (topological_space (semigroup pos)) Type) : @totally_disconnected_space.{0} (semigroup.{0} pos) (@functor.add_const.run.{0 1} (topological_space.{0} (semigroup.{0} pos)) Type h0)  := sorry --non-trivial
lemma new_lemma_24412 (h0 : functor.add_const (function.extfun Type topological_space) linarith.comp) : @sequential_space.{0} (has_add.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) linarith.comp h0) (has_add.{0} pos))  := sorry --non-trivial
lemma new_lemma_24413 (h0 : function.extfun Type ring) : @rank_condition.{0} (partial_order.{0} (semiring.{0} (has_top.{0} (semiring.{0} (semiring.{0} (semiring.{0} unsigned)))))) (@function.extfun_app.{2 1} Type ring.{0} h0 (partial_order.{0} (semiring.{0} (has_top.{0} (semiring.{0} (semiring.{0} (semiring.{0} unsigned)))))))  := sorry --non-trivial
lemma new_lemma_24414 (h0 : topological_space (add_comm_monoid (add_cancel_monoid name))) : t0_space (add_comm_monoid (add_cancel_monoid name)) := sorry --non-trivial
lemma new_lemma_24415 (h1 : function.extfun Type topological_space) : @totally_separated_space.{0} (normed_group.{0} string_imp) (@function.extfun_app.{2 1} Type topological_space.{0} h1 (normed_group.{0} string_imp))  := sorry --non-trivial
lemma new_lemma_24416 (h0 : uniform_space (has_nndist (option pos))) : complete_space (has_nndist (option pos)) := sorry --non-trivial
lemma new_lemma_24417 (h0 : group (has_zero num)) : is_cyclic (has_zero num) := sorry --non-trivial
lemma new_lemma_24418 (h0 : topological_space (has_neg (option pos))) : t1_space (has_neg (option pos)) := sorry --non-trivial
lemma new_lemma_24419 (h0 : function.extfun Type (functor.add_const (ring (linear_ordered_comm_monoid_with_zero unsigned)))) : @is_domain.{0} (linear_ordered_comm_monoid_with_zero.{0} unsigned) (@functor.add_const.run.{0 0} (ring.{0} (linear_ordered_comm_monoid_with_zero.{0} unsigned)) empty (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (ring.{0} (linear_ordered_comm_monoid_with_zero.{0} unsigned))) h0 empty))  := sorry --non-trivial
lemma new_lemma_24420 (h0 : group (has_inv (random_gen string_imp))) : is_cyclic (has_inv (random_gen string_imp)) := sorry --non-trivial
lemma new_lemma_24421 (h0 : topological_space (has_add (ring (mul_one_class Type)))) : normal_space (has_add (ring (mul_one_class Type))) := sorry --non-trivial
lemma new_lemma_24422 (h0 : add_group (cancel_monoid name)) : is_add_cyclic (cancel_monoid name) := sorry --non-trivial
lemma new_lemma_24423 (h0 : functor.add_const (topological_space (generalized_boolean_algebra pos)) real) : @t0_space.{0} (generalized_boolean_algebra.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (generalized_boolean_algebra.{0} pos)) real h0)  := sorry --non-trivial
lemma new_lemma_24424 (h0 : group (has_to_string (option (monoid_with_zero (option pos))))) : is_cyclic (has_to_string (option (monoid_with_zero (option pos)))) := sorry --non-trivial
lemma new_lemma_24425 (h0 : ring (has_pos_part (finset (finset (has_nndist linarith.comp))))) : rank_condition (has_pos_part (finset (finset (has_nndist linarith.comp)))) := sorry --non-trivial
lemma new_lemma_24426 (h0 : uniform_space (cancel_monoid name)) : complete_space (cancel_monoid name) := sorry --non-trivial
lemma new_lemma_24427 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @topological_space.separable_space.{1} (normed_comm_ring.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 topological_space.{1}) (normed_comm_ring.{1} Type))  := sorry --non-trivial
lemma new_lemma_24428 (h0 : monoid (with_bot (random_gen (random_gen fun_info)))) : monoid.fg (with_bot (random_gen (random_gen fun_info))) := sorry --non-trivial
lemma new_lemma_24429 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @normal_space.{0} (monoid.{0} ennreal) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (monoid.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_24430 (h1 : function.extfun (Type -> Type) (function.extfun Type)) : @totally_disconnected_space.{0} (has_top.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h1 topological_space.{0}) (has_top.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_24431 (h0 : functor.add_const (complete_lattice (preorder ennreal)) unsigned) : @is_atomistic.{0} (preorder.{0} ennreal) (@functor.add_const.run.{0 0} (complete_lattice.{0} (preorder.{0} ennreal)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_24432 (h0 : topological_space (has_bot (has_Inf (ordered_comm_monoid (has_bot real))))) : preconnected_space (has_bot (has_Inf (ordered_comm_monoid (has_bot real)))) := sorry --non-trivial
lemma new_lemma_24433 (h0 : group (add_cancel_comm_monoid unsigned)) : is_cyclic (add_cancel_comm_monoid unsigned) := sorry --non-trivial
lemma new_lemma_24434 (h0 : function.extfun Type topological_space) : @topological_space.separable_space.{0} (ordered_comm_ring.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (ordered_comm_ring.{0} name))  := sorry --non-trivial
lemma new_lemma_24435 (h0 : complete_lattice (has_emptyc (has_norm num))) : is_atomistic (has_emptyc (has_norm num)) := sorry --non-trivial
lemma new_lemma_24436 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @monoid.fg.{0} (distrib_lattice.{0} linarith.ineq) (@function.extfun_app.{2 1} Type monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 monoid.{0}) (distrib_lattice.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_24437 (h0 : functor.add_const (topological_space (has_pos_part linarith.comp)) name) : @normal_space.{0} (has_pos_part.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (has_pos_part.{0} linarith.comp)) name h0)  := sorry --non-trivial
lemma new_lemma_24438 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @preconnected_space.{0} (complete_distrib_lattice.{0} ennreal) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (complete_distrib_lattice.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_24439 (h0 : functor.add_const (topological_space (comm_group linarith.comp)) name) : @normal_space.{0} (comm_group.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (comm_group.{0} linarith.comp)) name h0)  := sorry --non-trivial
lemma new_lemma_24440 (h0 : topological_space (has_neg_part (has_nndist name))) : regular_space (has_neg_part (has_nndist name)) := sorry --non-trivial
lemma new_lemma_24441 (h0 : complete_lattice (has_add (has_ssubset to_additive.value_type))) : is_compactly_generated (has_add (has_ssubset to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_24442 (h0 : functor.add_const (filter (has_nndist unsigned)) environment.implicit_infer_kind) : filter.ne_bot (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_24443 (h0 : functor.add_const (topological_space (mul_zero_class empty)) congr_arg_kind) : @totally_disconnected_space.{0} (mul_zero_class.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (mul_zero_class.{0} empty)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_24444 (h0 : complete_lattice (has_div (omega_complete_partial_order string_imp))) : complete_lattice.is_Sup_finite_compact (has_div (omega_complete_partial_order string_imp)) := sorry --non-trivial
lemma new_lemma_24445 (h0 : fin has_zero.zero) : @separated_space.{0} (ordered_comm_ring.{0} pos) (@matrix.vec_empty.{0} (uniform_space.{0} (ordered_comm_ring.{0} pos)) h0)  := sorry --non-trivial
lemma new_lemma_24446 (h0 : ring (semigroup (mul_one_class linarith.comp))) : is_principal_ideal_ring (semigroup (mul_one_class linarith.comp)) := sorry --non-trivial
lemma new_lemma_24447 (h0 : not (group (semiring unsigned) -> false)) : @group.fg.{0} (semiring.{0} unsigned) (@classical.by_contradiction'.{1} (group.{0} (semiring.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_24448 (h0 : fin has_zero.zero) : @sequential_space.{0} (canonically_ordered_monoid.{0} real) (@function.extfun_app.{2 1} Type topological_space.{0} (@matrix.vec_empty.{1} (function.extfun.{2 1} Type topological_space.{0}) h0) (canonically_ordered_monoid.{0} real))  := sorry --non-trivial
lemma new_lemma_24449 (h0 : has_mem.mem topological_space has_emptyc.emptyc) : @discrete_topology.{0} (random_gen.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) topological_space.{0} h0) (random_gen.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_24450 (h0 : complete_lattice (linear_ordered_semiring (has_norm linarith.comp_source))) : is_compactly_generated (linear_ordered_semiring (has_norm linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_24451 (h0 : function.extfun Type topological_space) : @preirreducible_space.{0} (ordered_comm_group.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (ordered_comm_group.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_24452 (h0 : set (normed_field to_additive.value_type)) : set.finite h0 := sorry --non-trivial
lemma new_lemma_24453 (h0 : topological_space (add_cancel_monoid (has_Inf Type))) : discrete_topology (add_cancel_monoid (has_Inf Type)) := sorry --non-trivial
lemma new_lemma_24454 (h0 : uniform_space (has_to_string (finset (finset ennreal)))) : complete_space (has_to_string (finset (finset ennreal))) := sorry --non-trivial
lemma new_lemma_24455 (h0 : semiring (finset (option ennreal))) : is_noetherian_ring (finset (option ennreal)) := sorry --non-trivial
lemma new_lemma_24456 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @regular_space.{0} (has_nndist.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_nndist.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_24457 (h0 : ring (has_add ennreal)) : is_principal_ideal_ring (has_add ennreal) := sorry --non-trivial
lemma new_lemma_24458 (h0 : filter (ring (finset name))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_24459 (h0 : uniform_space (has_sub linarith.comp)) : complete_space (has_sub linarith.comp) := sorry --non-trivial
lemma new_lemma_24460 (h0 : function.extfun Type list) : list.nodup (function.extfun_app h0 (add_cancel_monoid pos)) := sorry --non-trivial
lemma new_lemma_24461 (h0 : topological_space (non_unital_non_assoc_semiring reducibility_hints)) : totally_disconnected_space (non_unital_non_assoc_semiring reducibility_hints) := sorry --non-trivial
lemma new_lemma_24462 (h0 : fin has_zero.zero) : @is_simple_group.{0} (has_pos_part.{0} pos) (@matrix.vec_empty.{0} (group.{0} (has_pos_part.{0} pos)) h0)  := sorry --non-trivial
lemma new_lemma_24463 (h0 : functor.add_const (complete_lattice (comm_group name)) linarith.comp) : @is_compactly_generated.{0} (comm_group.{0} name) (@functor.add_const.run.{0 0} (complete_lattice.{0} (comm_group.{0} name)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_24464 (h0 : not (ring (add_group congr_arg_kind) -> false)) : @is_principal_ideal_ring.{0} (add_group.{0} congr_arg_kind) (@classical.by_contradiction'.{1} (ring.{0} (add_group.{0} congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_24465 (h0 : topological_space (has_zero (add_comm_monoid (boolean_algebra.core Type)))) : locally_compact_space (has_zero (add_comm_monoid (boolean_algebra.core Type))) := sorry --non-trivial
lemma new_lemma_24466 (h0 : ring (distrib_lattice char)) : is_domain (distrib_lattice char) := sorry --non-trivial
lemma new_lemma_24467 (h0 : functor.add_const (complete_lattice (has_neg_part name)) (has_nndist (ring ennreal))) : @is_atomistic.{0} (has_neg_part.{0} name) (@functor.add_const.run.{0 0} (complete_lattice.{0} (has_neg_part.{0} name)) (has_nndist.{0} (ring.{0} ennreal)) h0)  := sorry --non-trivial
lemma new_lemma_24468 (h0 : functor.add_const (function.extfun (Type 1) topological_space) pos) : @path_connected_space.{1} (boolean_algebra.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) topological_space.{1}) pos h0) (boolean_algebra.{1} Type))  := sorry --non-trivial
lemma new_lemma_24469 (h0 : topological_space (nondiscrete_normed_field enat)) : totally_disconnected_space (nondiscrete_normed_field enat) := sorry --non-trivial
lemma new_lemma_24470 (h0 : functor.comp topological_space boolean_algebra.core name) : @preconnected_space.{0} (boolean_algebra.core.{0} name) (@functor.comp.run.{0 0 0} topological_space.{0} boolean_algebra.core.{0} name h0)  := sorry --non-trivial
lemma new_lemma_24471 (h0 : functor.add_const (group (has_nndist linarith.comp)) Type) : @is_simple_group.{0} (has_nndist.{0} linarith.comp) (@functor.add_const.run.{0 1} (group.{0} (has_nndist.{0} linarith.comp)) Type h0)  := sorry --non-trivial
lemma new_lemma_24472 (h0 : function.extfun Type filter) : countable_Inter_filter (function.extfun_app h0 (boolean_algebra.core ennreal)) := sorry --non-trivial
lemma new_lemma_24473 (h0 : add_group (canonically_ordered_comm_semiring (option num))) : is_add_cyclic (canonically_ordered_comm_semiring (option num)) := sorry --non-trivial
lemma new_lemma_24474 (h0 : function.extfun Type ring) : @rank_condition.{0} (has_emptyc.{0} linarith.comp) (@function.extfun_app.{2 1} Type ring.{0} h0 (has_emptyc.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_24475 (h0 : filter (has_norm (has_inv fun_info))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_24476 (h1 : ring (has_le linarith.ineq)) : rank_condition (has_le linarith.ineq) := sorry --non-trivial
lemma new_lemma_24477 (h0 : function.extfun Type add_monoid) : @add_monoid.fg.{0} (finset.{0} real) (@function.extfun_app.{2 1} Type add_monoid.{0} h0 (finset.{0} real))  := sorry --non-trivial
lemma new_lemma_24478 (h0 : group (random_gen (has_inv (has_inv (has_inv linarith.comp_source))))) : is_cyclic (random_gen (has_inv (has_inv (has_inv linarith.comp_source)))) := sorry --non-trivial
lemma new_lemma_24479 (h0 : topological_space (boolean_algebra.core (generalized_boolean_algebra linarith.comp))) : totally_disconnected_space (boolean_algebra.core (generalized_boolean_algebra linarith.comp)) := sorry --non-trivial
lemma new_lemma_24480 (h0 : group (semigroup (has_to_string (has_to_string (has_to_string pos))))) : group.fg (semigroup (has_to_string (has_to_string (has_to_string pos)))) := sorry --non-trivial
lemma new_lemma_24481 (h0 : topological_space (monoid (option congr_arg_kind))) : preconnected_space (monoid (option congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_24482 (h0 : functor.add_const (cancel_comm_monoid_with_zero (boolean_algebra.core Type)) (has_add pos)) : @unique_factorization_monoid.{1} (boolean_algebra.core.{1} Type) (@functor.add_const.run.{1 0} (cancel_comm_monoid_with_zero.{1} (boolean_algebra.core.{1} Type)) (has_add.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_24483 (h1 : topological_space (nondiscrete_normed_field enat)) (h2 : set (nondiscrete_normed_field enat)) : is_path_connected h2 := sorry --non-trivial
lemma new_lemma_24484 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @preconnected_space.{0} (has_bot.{0} real) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_bot.{0} real))  := sorry --non-trivial
lemma new_lemma_24485 (h0 : not (complete_lattice (has_neg char) -> false)) : @is_compactly_generated.{0} (has_neg.{0} char) (@classical.by_contradiction'.{1} (complete_lattice.{0} (has_neg.{0} char)) h0)  := sorry --non-trivial
lemma new_lemma_24486 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : list.nodup (function.extfun_app (function.extfun_app h0 list) (has_neg_part unsigned)) := sorry --non-trivial
lemma new_lemma_24487 (h0 : group (has_neg linarith.comp)) : group.fg (has_neg linarith.comp) := sorry --non-trivial
lemma new_lemma_24488 (h0 : monoid (measurable_space (random_gen (random_gen linarith.comp_source)))) : monoid.fg (measurable_space (random_gen (random_gen linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_24489 (h0 : function.extfun Type finset) : finset.nonempty (function.extfun_app h0 (linear_ordered_comm_ring congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_24490 (h0 : finset (has_le enat)) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_24491 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @totally_disconnected_space.{0} (finset.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (finset.{0} name))  := sorry --non-trivial
lemma new_lemma_24492 (h0 : group (denumerable (random_gen linarith.ineq))) : group.fg (denumerable (random_gen linarith.ineq)) := sorry --non-trivial
lemma new_lemma_24493 (h0 : functor.add_const (topological_space (has_to_string name)) linarith.comp) : @normal_space.{0} (has_to_string.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (has_to_string.{0} name)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_24494 (h0 : functor.add_const (topological_space (boolean_algebra Type)) (mul_one_class Type)) : @path_connected_space.{1} (boolean_algebra.{1} Type) (@functor.add_const.run.{1 1} (topological_space.{1} (boolean_algebra.{1} Type)) (mul_one_class.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_24495 (h0 : has_mem.mem (linear_ordered_semiring (semiring congr_arg_kind)) has_emptyc.emptyc) : @is_domain.{0} (linear_ordered_semiring.{0} (semiring.{0} congr_arg_kind)) (@finset.pi.empty.{1 0} Type ring.{0} (linear_ordered_semiring.{0} (semiring.{0} congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_24496 (h0 : not (complete_lattice (random_gen fun_info) -> false)) : @is_compactly_generated.{0} (random_gen.{0} fun_info) (@classical.by_contradiction'.{1} (complete_lattice.{0} (random_gen.{0} fun_info)) h0)  := sorry --non-trivial
lemma new_lemma_24497 (h0 : function.extfun (Type 1) complete_lattice) : @is_atomistic.{1} (normed_lattice_add_comm_group.{1} Type) (@function.extfun_app.{3 2} (Type 1) complete_lattice.{1} h0 (normed_lattice_add_comm_group.{1} Type))  := sorry --non-trivial
lemma new_lemma_24498 (h0 : add_group (canonically_linear_ordered_monoid (option ennreal))) : is_add_cyclic (canonically_linear_ordered_monoid (option ennreal)) := sorry --non-trivial
lemma new_lemma_24499 (h0 : functor.add_const (ring (semigroup name)) linarith.comp) : @is_domain.{0} (semigroup.{0} name) (@functor.add_const.run.{0 0} (ring.{0} (semigroup.{0} name)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_24500 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @normal_space.{0} (ring.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (ring.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_24501 (h2 : add_group (nondiscrete_normed_field environment.projection_info)) : is_add_cyclic (nondiscrete_normed_field environment.projection_info) := sorry --non-trivial
lemma new_lemma_24502 (h0 : ring (has_bot (has_add (has_add (has_add name))))) : is_principal_ideal_ring (has_bot (has_add (has_add (has_add name)))) := sorry --non-trivial
lemma new_lemma_24503 (h1 : has_mem.mem (with_one congr_arg_kind) has_emptyc.emptyc) : @is_cyclic.{0} (with_one.{0} congr_arg_kind) (@finset.pi.empty.{1 0} Type group.{0} (with_one.{0} congr_arg_kind) h1)  := sorry --non-trivial
lemma new_lemma_24504 (h0 : group (add_group unsigned)) : group.fg (add_group unsigned) := sorry --non-trivial
lemma new_lemma_24505 (h0 : monoid (with_one string_imp)) : monoid.fg (with_one string_imp) := sorry --non-trivial
lemma new_lemma_24506 (h0 : group (pseudo_metric_space (option (finset name)))) : is_simple_group (pseudo_metric_space (option (finset name))) := sorry --non-trivial
lemma new_lemma_24507 (h0 : add_group (has_add (cancel_monoid name))) : is_add_cyclic (has_add (cancel_monoid name)) := sorry --non-trivial
lemma new_lemma_24508 (h0 : not (monoid (has_sub empty) -> false)) : @monoid.fg.{0} (has_sub.{0} empty) (@classical.by_contradiction'.{1} (monoid.{0} (has_sub.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_24509 (h0 : ring (has_union (semiring (semiring num)))) : is_domain (has_union (semiring (semiring num))) := sorry --non-trivial
lemma new_lemma_24510 (h0 : function.extfun Type (functor.add_const (ring ennreal))) : @strong_rank_condition.{0} ennreal (@functor.add_const.run.{0 0} (ring.{0} ennreal) unsigned (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (ring.{0} ennreal)) h0 unsigned))  := sorry --non-trivial
lemma new_lemma_24511 (h0 : not (ring (uniform_space linarith.ineq) -> false)) : @rank_condition.{0} (uniform_space.{0} linarith.ineq) (@classical.by_contradiction'.{1} (ring.{0} (uniform_space.{0} linarith.ineq)) h0)  := sorry --non-trivial
lemma new_lemma_24512 (h0 : functor.add_const (topological_space (has_to_string Type)) Type) : @locally_compact_space.{1} (has_to_string.{1} Type) (@functor.add_const.run.{1 1} (topological_space.{1} (has_to_string.{1} Type)) Type h0)  := sorry --non-trivial
lemma new_lemma_24513 (h0 : functor.add_const (complete_lattice (ring linarith.comp)) (has_pos_part pos)) : @is_compactly_generated.{0} (ring.{0} linarith.comp) (@functor.add_const.run.{0 0} (complete_lattice.{0} (ring.{0} linarith.comp)) (has_pos_part.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_24514 (h0 : not (function.extfun Type filter -> false)) : filter.ne_bot (function.extfun_app (classical.by_contradiction' h0) (has_norm num)) := sorry --non-trivial
lemma new_lemma_24515 (h0 : function.extfun Type filter) : filter.ne_bot (function.extfun_app h0 (boolean_algebra pos)) := sorry --non-trivial
lemma new_lemma_24516 (h0 : ring (has_top (has_inv fun_info))) : is_domain (has_top (has_inv fun_info)) := sorry --non-trivial
lemma new_lemma_24517 (h0 : function.extfun Type topological_space) : @t1_space.{0} (mul_zero_class.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (mul_zero_class.{0} num))  := sorry --non-trivial
lemma new_lemma_24518 (h1 : has_mul (denumerable (denumerable (denumerable (denumerable char))))) (h2 : not (topological_space (denumerable (con (denumerable (denumerable (denumerable (denumerable char)))))) -> false)) : @t0_space.{0} (denumerable.{0} (@con.{0} (denumerable.{0} (denumerable.{0} (denumerable.{0} (denumerable.{0} char)))) h1)) (@classical.by_contradiction'.{1} (topological_space.{0} (denumerable.{0} (@con.{0} (denumerable.{0} (denumerable.{0} (denumerable.{0} (denumerable.{0} char)))) h1))) h2)  := sorry --non-trivial
lemma new_lemma_24519 (h1 : topological_space (encodable (has_nnnorm (has_nnnorm fun_info)))) (h2 : set (encodable (has_nnnorm (has_nnnorm fun_info)))) : is_open h2 := sorry --non-trivial
lemma new_lemma_24520 (h0 : uniform_space (with_bot num)) : complete_space (with_bot num) := sorry --non-trivial
lemma new_lemma_24521 (h0 : topological_space (has_add (ordered_comm_ring Type))) : regular_space (has_add (ordered_comm_ring Type)) := sorry --non-trivial
lemma new_lemma_24522 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @discrete_topology.{0} (normed_group.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (normed_group.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_24523 (h0 : not (group (encodable string_imp) -> false)) : @group.fg.{0} (encodable.{0} string_imp) (@classical.by_contradiction'.{1} (group.{0} (encodable.{0} string_imp)) h0)  := sorry --non-trivial
lemma new_lemma_24524 (h0 : functor.add_const (ordered_add_comm_monoid (canonically_linear_ordered_monoid num)) (option ennreal)) : @archimedean.{0} (canonically_linear_ordered_monoid.{0} num) (@functor.add_const.run.{0 0} (ordered_add_comm_monoid.{0} (canonically_linear_ordered_monoid.{0} num)) (option.{0} ennreal) h0)  := sorry --non-trivial
lemma new_lemma_24525 (h0 : group (add_cancel_monoid environment.implicit_infer_kind)) : is_cyclic (add_cancel_monoid environment.implicit_infer_kind) := sorry --non-trivial
lemma new_lemma_24526 (h0 : ordered_add_comm_monoid (complete_distrib_lattice (comm_monoid unsigned))) : archimedean (complete_distrib_lattice (comm_monoid unsigned)) := sorry --non-trivial
lemma new_lemma_24527 (h0 : function.extfun nat fin) : @complete_lattice.is_Sup_finite_compact.{0} (boolean_algebra.{0} real) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@matrix.vec_empty.{1} (function.extfun.{2 1} Type complete_lattice.{0}) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero))) (boolean_algebra.{0} real))  := sorry --non-trivial
lemma new_lemma_24528 (h0 : fin has_zero.zero) : @preirreducible_space.{0} (ordered_comm_monoid.{0} linarith.comp) (@matrix.vec_empty.{0} (topological_space.{0} (ordered_comm_monoid.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_24529 (h0 : cancel_comm_monoid_with_zero (has_bot (option (option unsigned)))) : unique_factorization_monoid (has_bot (option (option unsigned))) := sorry --non-trivial
lemma new_lemma_24530 (h0 : function.extfun Type (functor.comp semiring boolean_algebra.core)) : @is_noetherian_ring.{0} (boolean_algebra.core.{0} ennreal) (@functor.comp.run.{0 0 0} semiring.{0} boolean_algebra.core.{0} ennreal (@function.extfun_app.{2 1} Type (functor.comp.{0 0 0} semiring.{0} boolean_algebra.core.{0}) h0 ennreal))  := sorry --non-trivial
lemma new_lemma_24531 (h0 : ring (linear_ordered_comm_ring (semiring congr_arg_kind))) : is_principal_ideal_ring (linear_ordered_comm_ring (semiring congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_24532 (h1 : topological_space (distrib (comm_ring char))) : path_connected_space (distrib (comm_ring char)) := sorry --non-trivial
lemma new_lemma_24533 (h0 : functor.add_const (topological_space (has_neg Type)) name) : @normal_space.{1} (has_neg.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (has_neg.{1} Type)) name h0)  := sorry --non-trivial
lemma new_lemma_24534 (h0 : functor.add_const (topological_space (generalized_boolean_algebra pos)) (ring linarith.comp)) : @t0_space.{0} (generalized_boolean_algebra.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (generalized_boolean_algebra.{0} pos)) (ring.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_24535 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @totally_disconnected_space.{0} (has_add.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_add.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_24536 (h0 : function.extfun Type (functor.add_const (functor.add_const (add_monoid auto.case_option) unsigned))) : @add_monoid.fg.{0} auto.case_option (@functor.add_const.run.{0 0} (add_monoid.{0} auto.case_option) unsigned (@functor.add_const.run.{0 0} (functor.add_const.{0 0} (add_monoid.{0} auto.case_option) unsigned) num (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (functor.add_const.{0 0} (add_monoid.{0} auto.case_option) unsigned)) h0 num)))  := sorry --non-trivial
lemma new_lemma_24537 (h0 : prod (normed_group (semiring num)) (normed_group (semiring num))) : id_rel h0 := sorry --non-trivial
lemma new_lemma_24538 (h0 : filter (with_bot empty)) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_24539 (h0 : function.extfun Type complete_lattice) : @is_atomistic.{0} (@id.{2} Type unsigned) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (@id.{2} Type unsigned))  := sorry --non-trivial
lemma new_lemma_24540 (h0 : functor.add_const (topological_space (mul_zero_class congr_arg_kind)) empty) : @totally_disconnected_space.{0} (mul_zero_class.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (mul_zero_class.{0} congr_arg_kind)) empty h0)  := sorry --non-trivial
lemma new_lemma_24541 (h0 : not (complete_lattice (add_right_cancel_monoid unsigned) -> false)) : @is_atomistic.{0} (add_right_cancel_monoid.{0} unsigned) (@classical.by_contradiction'.{1} (complete_lattice.{0} (add_right_cancel_monoid.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_24542 (h0 : function.extfun Type (functor.add_const (finset (has_star empty)))) : finset.nonempty (functor.add_const.run (function.extfun_app h0 (option empty))) := sorry --non-trivial
lemma new_lemma_24543 (h0 : function.extfun Type ring) : @is_domain.{0} (omega_complete_partial_order.{0} empty) (@function.extfun_app.{2 1} Type ring.{0} h0 (omega_complete_partial_order.{0} empty))  := sorry --non-trivial
lemma new_lemma_24544 (h0 : not (ring (has_sub num) -> false)) : @strong_rank_condition.{0} (has_sub.{0} num) (@classical.by_contradiction'.{1} (ring.{0} (has_sub.{0} num)) h0)  := sorry --non-trivial
lemma new_lemma_24545 (h0 : complete_lattice (has_dist (option (option (option empty))))) : is_compactly_generated (has_dist (option (option (option empty)))) := sorry --non-trivial
lemma new_lemma_24546 (h0 : uniform_space (has_norm (has_norm fun_info))) : complete_space (has_norm (has_norm fun_info)) := sorry --non-trivial
lemma new_lemma_24547 (h0 : not (topological_space (has_lt enat) -> false)) : @t0_space.{0} (has_lt.{0} enat) (@classical.by_contradiction'.{1} (topological_space.{0} (has_lt.{0} enat)) h0)  := sorry --non-trivial
lemma new_lemma_24548 (h0 : functor.add_const (filter (has_Inf linarith.comp)) name) : countable_Inter_filter (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_24549 (h0 : list (has_inner empty unsigned)) : palindrome h0 := sorry --non-trivial
lemma new_lemma_24550 (h0 : list (free_add_monoid empty)) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_24551 (h0 : list (finset unsigned)) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_24552 (h0 : topological_space (left_cancel_monoid congr_arg_kind)) : t0_space (left_cancel_monoid congr_arg_kind) := sorry --non-trivial
lemma new_lemma_24553 (h0 : topological_space (has_add (option (option (option (option unsigned)))))) : discrete_topology (has_add (option (option (option (option unsigned))))) := sorry --non-trivial
lemma new_lemma_24554 (h0 : add_group (has_nndist (has_neg_part (has_neg_part pos)))) : is_add_cyclic (has_nndist (has_neg_part (has_neg_part pos))) := sorry --non-trivial
lemma new_lemma_24555 (h0 : semiring (measurable_space.dynkin_system (semiring congr_arg_kind))) : is_noetherian_ring (measurable_space.dynkin_system (semiring congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_24556 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @monoid.fg.{0} (generalized_boolean_algebra.{0} real) (@function.extfun_app.{2 1} Type monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 monoid.{0}) (generalized_boolean_algebra.{0} real))  := sorry --non-trivial
lemma new_lemma_24557 (h0 : complete_lattice (boolean_algebra name)) : complete_lattice.is_Sup_finite_compact (boolean_algebra name) := sorry --non-trivial
lemma new_lemma_24558 (h0 : topological_space (mul_zero_class name)) : regular_space (mul_zero_class name) := sorry --non-trivial
lemma new_lemma_24559 (h0 : topological_space (has_le ereal)) : totally_disconnected_space (has_le ereal) := sorry --non-trivial
lemma new_lemma_24560 (h0 : function.extfun Type (functor.comp cancel_comm_monoid_with_zero semigroup)) : @unique_factorization_monoid.{0} (semigroup.{0} name) (@functor.comp.run.{0 0 0} cancel_comm_monoid_with_zero.{0} semigroup.{0} name (@function.extfun_app.{2 1} Type (functor.comp.{0 0 0} cancel_comm_monoid_with_zero.{0} semigroup.{0}) h0 name))  := sorry --non-trivial
lemma new_lemma_24561 (h0 : not (function.extfun Type uniform_space -> false)) : @complete_space.{0} (add_group.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type uniform_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type uniform_space.{0}) h0) (add_group.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_24562 (h0 : group (has_to_string (add_comm_monoid (complete_distrib_lattice (add_comm_monoid pos))))) : is_cyclic (has_to_string (add_comm_monoid (complete_distrib_lattice (add_comm_monoid pos)))) := sorry --non-trivial
lemma new_lemma_24563 (h0 : topological_space (bin_tree (option unsigned))) : t1_space (bin_tree (option unsigned)) := sorry --non-trivial
lemma new_lemma_24564 (h0 : function.extfun Type list) : list.nodup (function.extfun_app h0 (cancel_monoid name)) := sorry --non-trivial
lemma new_lemma_24565 (h0 : not (group (id linarith.comp) -> false)) : @is_cyclic.{0} (@id.{2} Type linarith.comp) (@classical.by_contradiction'.{1} (group.{0} (@id.{2} Type linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_24566 (h0 : functor.add_const (topological_space (metric_space empty)) unsigned) : @normal_space.{0} (metric_space.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (metric_space.{0} empty)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_24567 (h0 : topological_space (canonically_ordered_monoid linarith.comp)) : locally_compact_space (canonically_ordered_monoid linarith.comp) := sorry --non-trivial
lemma new_lemma_24568 (h0 : topological_space (has_add congr_arg_kind)) : irreducible_space (has_add congr_arg_kind) := sorry --non-trivial
lemma new_lemma_24569 (h0 : group (boolean_algebra.core linarith.comp)) : is_cyclic (boolean_algebra.core linarith.comp) := sorry --non-trivial
lemma new_lemma_24570 (h0 : function.extfun Type ordered_comm_monoid) : @has_exists_mul_of_le.{0} (canonically_ordered_monoid.{0} real) (@function.extfun_app.{2 1} Type ordered_comm_monoid.{0} h0 (canonically_ordered_monoid.{0} real))  := sorry --non-trivial
lemma new_lemma_24571 (h0 : function.extfun Type topological_space) : @t0_space.{0} (add_semigroup.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (add_semigroup.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_24572 (h0 : functor.comp complete_lattice ring Type) : @is_compactly_generated.{1} (ring.{1} Type) (@functor.comp.run.{1 1 1} complete_lattice.{1} ring.{1} Type h0)  := sorry --non-trivial
lemma new_lemma_24573 (h1 : set (set (normed_field linarith.ineq))) (h2 : set (normed_field linarith.ineq)) : measurable_space.dynkin_system.generate_has h1 h2 := sorry --non-trivial
lemma new_lemma_24574 (h0 : semiring (add_comm_monoid (has_neg pos))) : is_noetherian_ring (add_comm_monoid (has_neg pos)) := sorry --non-trivial
lemma new_lemma_24575 (h0 : functor.add_const (list (has_star unsigned)) empty) : list.nodup (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_24576 (h0 : function.extfun (Type 1) group) : @is_simple_group.{1} (has_add.{1} Type) (@function.extfun_app.{3 2} (Type 1) group.{1} h0 (has_add.{1} Type))  := sorry --non-trivial
lemma new_lemma_24577 (h0 : group (has_add (cancel_monoid (finset pos)))) : normalizer_condition (has_add (cancel_monoid (finset pos))) := sorry --non-trivial
lemma new_lemma_24578 (h0 : functor.add_const (topological_space (ordered_ring empty)) num) : @locally_compact_space.{0} (ordered_ring.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (ordered_ring.{0} empty)) num h0)  := sorry --non-trivial
lemma new_lemma_24579 (h1 : list (id (random_gen (random_gen (has_norm string_imp))))) : list.nodup h1 := sorry --non-trivial
lemma new_lemma_24580 (h0 : filter (has_nndist (has_add ennreal))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_24581 (h0 : not (complete_lattice (has_lt (mul_one_class string.iterator_imp)) -> false)) : @is_compactly_generated.{0} (has_lt.{0} (mul_one_class.{0} string.iterator_imp)) (@classical.by_contradiction'.{1} (complete_lattice.{0} (has_lt.{0} (mul_one_class.{0} string.iterator_imp))) h0)  := sorry --non-trivial
lemma new_lemma_24582 (h0 : functor.add_const (cancel_comm_monoid_with_zero (cancel_monoid Type)) linarith.comp) : @unique_factorization_monoid.{1} (cancel_monoid.{1} Type) (@functor.add_const.run.{1 0} (cancel_comm_monoid_with_zero.{1} (cancel_monoid.{1} Type)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_24583 (h0 : complete_lattice (add_cancel_monoid (semiring unsigned))) : is_compactly_generated (add_cancel_monoid (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_24584 (h0 : not (group (random_gen empty) -> false)) : @is_cyclic.{0} (random_gen.{0} empty) (@classical.by_contradiction'.{1} (group.{0} (random_gen.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_24585 (h0 : functor.add_const (group (has_neg Type)) environment.implicit_infer_kind) : @normalizer_condition.{1} (has_neg.{1} Type) (@functor.add_const.run.{1 0} (group.{1} (has_neg.{1} Type)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_24586 (h0 : functor.add_const (group (add_cancel_monoid ennreal)) linarith.comp) : @group.fg.{0} (add_cancel_monoid.{0} ennreal) (@functor.add_const.run.{0 0} (group.{0} (add_cancel_monoid.{0} ennreal)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_24587 (h0 : functor.add_const (ordered_add_comm_monoid (has_neg ennreal)) Type) : @archimedean.{0} (has_neg.{0} ennreal) (@functor.add_const.run.{0 1} (ordered_add_comm_monoid.{0} (has_neg.{0} ennreal)) Type h0)  := sorry --non-trivial
lemma new_lemma_24588 (h0 : filter (boolean_algebra.core name)) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_24589 (h0 : ring (linear_ordered_add_comm_group reducibility_hints)) : strong_rank_condition (linear_ordered_add_comm_group reducibility_hints) := sorry --non-trivial
lemma new_lemma_24590 (h0 : list (normed_comm_ring (has_neg_part (comm_group (has_to_string unsigned))))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_24591 (h0 : has_mem.mem ring has_emptyc.emptyc) : @rank_condition.{0} (with_one.{0} fun_info) (@function.extfun_app.{2 1} Type ring.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) ring.{0} h0) (with_one.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_24592 (h0 : function.extfun Type ring) : @rank_condition.{0} (complete_linear_order.{0} unsigned) (@function.extfun_app.{2 1} Type ring.{0} h0 (complete_linear_order.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_24593 (h0 : not (topological_space (add_cancel_comm_monoid linarith.comp_source) -> false)) : @totally_disconnected_space.{0} (add_cancel_comm_monoid.{0} linarith.comp_source) (@classical.by_contradiction'.{1} (topological_space.{0} (add_cancel_comm_monoid.{0} linarith.comp_source)) h0)  := sorry --non-trivial
lemma new_lemma_24594 (h0 : function.extfun nat fin) : @complete_lattice.is_Sup_finite_compact.{0} (has_bot.{0} real) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@matrix.vec_empty.{1} (function.extfun.{2 1} Type complete_lattice.{0}) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero))) (has_bot.{0} real))  := sorry --non-trivial
lemma new_lemma_24595 (h0 : functor.add_const (ordered_add_comm_monoid (add_cancel_monoid pos)) Type) : @archimedean.{0} (add_cancel_monoid.{0} pos) (@functor.add_const.run.{0 1} (ordered_add_comm_monoid.{0} (add_cancel_monoid.{0} pos)) Type h0)  := sorry --non-trivial
lemma new_lemma_24596 (h0 : real) : irrational h0 := sorry --non-trivial
lemma new_lemma_24597 (h0 : comm_monoid_with_zero (has_neg pos)) : wf_dvd_monoid (has_neg pos) := sorry --non-trivial
lemma new_lemma_24598 (h0 : group (normed_comm_ring (finset linarith.comp))) : normalizer_condition (normed_comm_ring (finset linarith.comp)) := sorry --non-trivial
lemma new_lemma_24599 (h0 : uniform_space (bin_tree (semiring (semiring (semiring congr_arg_kind))))) : separated_space (bin_tree (semiring (semiring (semiring congr_arg_kind)))) := sorry --non-trivial
lemma new_lemma_24600 (h0 : functor.add_const (complete_lattice nnreal) empty) : @is_atomistic.{0} nnreal (@functor.add_const.run.{0 0} (complete_lattice.{0} nnreal) empty h0)  := sorry --non-trivial
lemma new_lemma_24601 (h0 : ordered_add_comm_monoid (measurable_space.dynkin_system congr_arg_kind)) : archimedean (measurable_space.dynkin_system congr_arg_kind) := sorry --non-trivial
lemma new_lemma_24602 (h0 : has_lt (has_lt (has_lt (ordered_cancel_comm_monoid (has_ssubset (mul_one_class string_imp)))))) : no_max_order (has_lt (has_lt (ordered_cancel_comm_monoid (has_ssubset (mul_one_class string_imp))))) := sorry --non-trivial
lemma new_lemma_24603 (h0 : function.extfun Type topological_space) : @preirreducible_space.{0} (boolean_algebra.core.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (boolean_algebra.core.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_24604 (h0 : function.extfun (finset Type) (has_mem.mem (semiring linarith.comp_source))) : @rank_condition.{0} (semiring.{0} linarith.comp_source) (@finset.pi.empty.{1 0} Type ring.{0} (semiring.{0} linarith.comp_source) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (semiring.{0} linarith.comp_source)) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_24605 (h0 : function.extfun Type (functor.add_const (complete_lattice (linear_ordered_cancel_comm_monoid empty)))) : @is_compactly_generated.{0} (linear_ordered_cancel_comm_monoid.{0} empty) (@functor.add_const.run.{0 0} (complete_lattice.{0} (linear_ordered_cancel_comm_monoid.{0} empty)) empty (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (complete_lattice.{0} (linear_ordered_cancel_comm_monoid.{0} empty))) h0 empty))  := sorry --non-trivial
lemma new_lemma_24606 (h0 : fin has_zero.zero) : id (matrix.vec_empty (id h0)) := sorry --non-trivial
lemma new_lemma_24607 (h0 : functor.add_const (add_group (boolean_algebra.core name)) Type) : @is_add_cyclic.{0} (boolean_algebra.core.{0} name) (@functor.add_const.run.{0 1} (add_group.{0} (boolean_algebra.core.{0} name)) Type h0)  := sorry --non-trivial
lemma new_lemma_24608 (h0 : semiring (ordered_comm_ring (ordered_comm_monoid (ordered_comm_monoid Type)))) : is_noetherian_ring (ordered_comm_ring (ordered_comm_monoid (ordered_comm_monoid Type))) := sorry --non-trivial
lemma new_lemma_24609 (h0 : ring (has_add (sub_neg_monoid (sub_neg_monoid Type)))) : is_principal_ideal_ring (has_add (sub_neg_monoid (sub_neg_monoid Type))) := sorry --non-trivial
lemma new_lemma_24610 (h0 : functor.add_const (topological_space (has_pos_part linarith.comp)) linarith.comp) : @preirreducible_space.{0} (has_pos_part.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (has_pos_part.{0} linarith.comp)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_24611 (h0 : topological_space (normed_comm_ring (ring (has_neg environment.implicit_infer_kind)))) : path_connected_space (normed_comm_ring (ring (has_neg environment.implicit_infer_kind))) := sorry --non-trivial
lemma new_lemma_24612 (h0 : topological_space (canonically_linear_ordered_monoid (option ennreal))) : irreducible_space (canonically_linear_ordered_monoid (option ennreal)) := sorry --non-trivial
lemma new_lemma_24613 (h0 : function.extfun Type topological_space) : @irreducible_space.{0} (normed_linear_ordered_group.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (normed_linear_ordered_group.{0} num))  := sorry --non-trivial
lemma new_lemma_24614 (h0 : function.extfun Type (prod (linear_ordered_cancel_comm_monoid empty))) : id_rel (function.extfun_app h0 (linear_ordered_cancel_comm_monoid empty)) := sorry --non-trivial
lemma new_lemma_24615 (h0 : topological_space (semigroup (ring (finset (finset linarith.comp))))) : t1_space (semigroup (ring (finset (finset linarith.comp)))) := sorry --non-trivial
lemma new_lemma_24616 (h0 : topological_space (boolean_algebra.core (has_to_string Type))) : regular_space (boolean_algebra.core (has_to_string Type)) := sorry --non-trivial
lemma new_lemma_24617 (h0 : function.extfun Type ring) : @rank_condition.{0} (is_R_or_C.{0} empty) (@function.extfun_app.{2 1} Type ring.{0} h0 (is_R_or_C.{0} empty))  := sorry --non-trivial
lemma new_lemma_24618 (h0 : complete_lattice (comm_group (comm_group pos))) : is_atomistic (comm_group (comm_group pos)) := sorry --non-trivial
lemma new_lemma_24619 (h0 : function.extfun ((Type -> Type) -> Type 1) (function.extfun (Type -> Type))) : @has_exists_mul_of_le.{0} (has_neg.{0} pos) (@function.extfun_app.{2 1} Type ordered_comm_monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) (@function.extfun_app.{3 2} ((Type → Type) → Type 1) (function.extfun.{2 2} (Type → Type)) h0 (function.extfun.{2 1} Type)) ordered_comm_monoid.{0}) (has_neg.{0} pos))  := sorry --non-trivial
lemma new_lemma_24620 (h0 : functor.add_const (semiring (ordered_comm_ring Type)) Type) : @is_noetherian_ring.{1} (ordered_comm_ring.{1} Type) (@functor.add_const.run.{1 1} (semiring.{1} (ordered_comm_ring.{1} Type)) Type h0)  := sorry --non-trivial
lemma new_lemma_24621 (h0 : function.extfun Type add_group) : @is_add_cyclic.{0} (normed_group.{0} (has_top.{0} (has_top.{0} (has_norm.{0} (random_gen.{0} linarith.comp_source))))) (@function.extfun_app.{2 1} Type add_group.{0} h0 (normed_group.{0} (has_top.{0} (has_top.{0} (has_norm.{0} (random_gen.{0} linarith.comp_source))))))  := sorry --non-trivial
lemma new_lemma_24622 (h0 : function.extfun Type ring) : @strong_rank_condition.{0} (normed_linear_ordered_group.{0} empty) (@function.extfun_app.{2 1} Type ring.{0} h0 (normed_linear_ordered_group.{0} empty))  := sorry --non-trivial
lemma new_lemma_24623 (h0 : functor.add_const (topological_space (free_add_monoid unsigned)) congr_arg_kind) : @discrete_topology.{0} (free_add_monoid.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (free_add_monoid.{0} unsigned)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_24624 (h0 : complete_lattice (random_gen (has_top linarith.ineq))) : is_atomistic (random_gen (has_top linarith.ineq)) := sorry --non-trivial
lemma new_lemma_24625 (h0 : set (prod linarith.comp linarith.comp)) (h1 : functor.add_const (prod linarith.comp linarith.comp) name) : symmetrize_rel h0 (functor.add_const.run h1) := sorry --non-trivial
lemma new_lemma_24626 (h0 : functor.add_const (function.extfun Type group) linarith.comp) : @is_cyclic.{0} (has_add.{0} pos) (@function.extfun_app.{2 1} Type group.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type group.{0}) linarith.comp h0) (has_add.{0} pos))  := sorry --non-trivial
lemma new_lemma_24627 (h0 : group (random_gen congr_arg_kind)) : normalizer_condition (random_gen congr_arg_kind) := sorry --non-trivial
lemma new_lemma_24628 (h0 : nat -> nat -> Prop) : anti_symmetric h0 := sorry --non-trivial
lemma new_lemma_24629 (h0 : ring (add_cancel_comm_monoid linarith.comp_source)) : strong_rank_condition (add_cancel_comm_monoid linarith.comp_source) := sorry --non-trivial
lemma new_lemma_24630 (h0 : list (semi_normed_comm_ring (has_nnnorm linarith.ineq))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_24631 (h0 : functor.add_const (functor.add_const (complete_lattice (add_left_cancel_semigroup empty)) empty) empty) : @is_atomistic.{0} (add_left_cancel_semigroup.{0} empty) (@functor.add_const.run.{0 0} (complete_lattice.{0} (add_left_cancel_semigroup.{0} empty)) empty (@functor.add_const.run.{0 0} (functor.add_const.{0 0} (complete_lattice.{0} (add_left_cancel_semigroup.{0} empty)) empty) empty h0))  := sorry --non-trivial
lemma new_lemma_24632 (h0 : function.extfun Type topological_space) : @discrete_topology.{0} (measurable_space.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (measurable_space.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_24633 (h0 : complete_lattice (option (option pos))) : complete_lattice.is_Sup_finite_compact (option (option pos)) := sorry --non-trivial
lemma new_lemma_24634 (h0 : complete_lattice (boolean_algebra.core (semigroup (add_cancel_monoid name)))) : is_atomistic (boolean_algebra.core (semigroup (add_cancel_monoid name))) := sorry --non-trivial
lemma new_lemma_24635 (h0 : functor.add_const (topological_space (normed_comm_ring linarith.comp)) name) : @totally_separated_space.{0} (normed_comm_ring.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (normed_comm_ring.{0} linarith.comp)) name h0)  := sorry --non-trivial
lemma new_lemma_24636 (h0 : topological_space real) : irreducible_space real := sorry --non-trivial
lemma new_lemma_24637 (h0 : group (normed_group (denumerable (linear_ordered_add_comm_group (denumerable linarith.ineq))))) : is_cyclic (normed_group (denumerable (linear_ordered_add_comm_group (denumerable linarith.ineq)))) := sorry --non-trivial
lemma new_lemma_24638 (h0 : add_group (has_nnnorm (has_nnnorm char))) : is_add_cyclic (has_nnnorm (has_nnnorm char)) := sorry --non-trivial
lemma new_lemma_24639 (h0 : has_mem.mem topological_space has_emptyc.emptyc) : @totally_separated_space.{0} (complete_semilattice_Sup.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) topological_space.{0} h0) (complete_semilattice_Sup.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_24640 (h0 : filter (has_top (comm_ring linarith.ineq))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_24641 (h1 : function.extfun Type monoid) : @monoid.fg.{0} (with_bot.{0} string_imp) (@function.extfun_app.{2 1} Type monoid.{0} h1 (with_bot.{0} string_imp))  := sorry --non-trivial
lemma new_lemma_24642 (h0 : linarith.ineq -> linarith.ineq) (h3 : linarith.ineq) : function.periodic_pts h0 h3 := sorry --non-trivial
lemma new_lemma_24643 (h0 : functor.add_const (cancel_comm_monoid_with_zero (has_zero linarith.comp)) linarith.comp) : @unique_factorization_monoid.{0} (has_zero.{0} linarith.comp) (@functor.add_const.run.{0 0} (cancel_comm_monoid_with_zero.{0} (has_zero.{0} linarith.comp)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_24644 (h0 : topological_space (has_zero Type)) : sequential_space (has_zero Type) := sorry --non-trivial
lemma new_lemma_24645 (h1 : uniform_space (add_comm_semigroup ereal)) : complete_space (add_comm_semigroup ereal) := sorry --non-trivial
lemma new_lemma_24646 (h0 : functor.add_const (ring (left_cancel_monoid unsigned)) congr_arg_kind) : @rank_condition.{0} (left_cancel_monoid.{0} unsigned) (@functor.add_const.run.{0 0} (ring.{0} (left_cancel_monoid.{0} unsigned)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_24647 (h1 : complete_lattice (dlist char)) : is_compactly_generated (dlist char) := sorry --non-trivial
lemma new_lemma_24648 (h0 : add_monoid (measure_theory.measure_space (semiring unsigned))) : add_monoid.fg (measure_theory.measure_space (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_24649 (h0 : functor.add_const (topological_space (has_neg pos)) pos) : @regular_space.{0} (has_neg.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (has_neg.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_24650 (h0 : finset (left_cancel_semigroup num)) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_24651 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : filter.ne_bot (function.extfun_app (function.extfun_app h0 filter) (with_bot fun_info)) := sorry --non-trivial
lemma new_lemma_24652 (h0 : function.extfun Type monoid) : @monoid.fg.{0} (normed_group.{0} (has_top.{0} linarith.comp_source)) (@function.extfun_app.{2 1} Type monoid.{0} h0 (normed_group.{0} (has_top.{0} linarith.comp_source)))  := sorry --non-trivial
lemma new_lemma_24653 (h0 : add_group (random_gen (has_norm empty))) : is_add_cyclic (random_gen (has_norm empty)) := sorry --non-trivial
lemma new_lemma_24654 (h1 : ring (denumerable (random_gen (uniform_space char)))) : is_domain (denumerable (random_gen (uniform_space char))) := sorry --non-trivial
lemma new_lemma_24655 (h0 : ring (topological_space (has_nnnorm (has_nnnorm char)))) : is_domain (topological_space (has_nnnorm (has_nnnorm char))) := sorry --non-trivial
lemma new_lemma_24656 (h1 : uniform_space (div_inv_monoid (has_nnnorm (has_nnnorm to_additive.value_type)))) : complete_space (div_inv_monoid (has_nnnorm (has_nnnorm to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_24657 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_noetherian_ring.{0} (normed_linear_ordered_group.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type semiring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 semiring.{0}) (normed_linear_ordered_group.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_24658 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @complete_space.{0} (has_emptyc.{0} linarith.ineq) (@function.extfun_app.{2 1} Type uniform_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 uniform_space.{0}) (has_emptyc.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_24659 (h0 : topological_space (finset (ring (finset (has_add pos))))) : totally_disconnected_space (finset (ring (finset (has_add pos)))) := sorry --non-trivial
lemma new_lemma_24660 (h0 : complete_lattice (has_top string_imp)) : is_atomistic (has_top string_imp) := sorry --non-trivial
lemma new_lemma_24661 (h0 : has_mem.mem (semiring (has_top (has_top linarith.comp_source))) has_emptyc.emptyc) : @path_connected_space.{0} (semiring.{0} (has_top.{0} (has_top.{0} linarith.comp_source))) (@finset.pi.empty.{1 0} Type topological_space.{0} (semiring.{0} (has_top.{0} (has_top.{0} linarith.comp_source))) h0)  := sorry --non-trivial
lemma new_lemma_24662 (h0 : functor.comp topological_space add_comm_monoid linarith.comp) : @totally_separated_space.{0} (add_comm_monoid.{0} linarith.comp) (@functor.comp.run.{0 0 0} topological_space.{0} add_comm_monoid.{0} linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_24663 (h0 : topological_space (linear_ordered_field (has_neg_part ennreal))) : locally_compact_space (linear_ordered_field (has_neg_part ennreal)) := sorry --non-trivial
lemma new_lemma_24664 (h0 : functor.add_const (topological_space (has_zero linarith.comp)) linarith.comp) : @topological_space.separable_space.{0} (has_zero.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (has_zero.{0} linarith.comp)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_24665 (h0 : functor.add_const (topological_space (has_neg pos)) pos) : @t1_space.{0} (has_neg.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (has_neg.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_24666 (h0 : topological_space (has_append (comm_ring (has_nnnorm reducibility_hints)))) : t0_space (has_append (comm_ring (has_nnnorm reducibility_hints))) := sorry --non-trivial
lemma new_lemma_24667 (h0 : not (topological_space (normed_group int) -> false)) : @t0_space.{0} (normed_group.{0} int) (@classical.by_contradiction'.{1} (topological_space.{0} (normed_group.{0} int)) h0)  := sorry --non-trivial
lemma new_lemma_24668 (h0 : topological_space (filter empty)) : locally_compact_space (filter empty) := sorry --non-trivial
lemma new_lemma_24669 (h0 : uniform_space (ring (has_pos_part linarith.comp))) : complete_space (ring (has_pos_part linarith.comp)) := sorry --non-trivial
lemma new_lemma_24670 (h0 : uniform_space (semiring (has_union empty))) : complete_space (semiring (has_union empty)) := sorry --non-trivial
lemma new_lemma_24671 (h0 : functor.add_const (topological_space (add_cancel_monoid pos)) pos) : @regular_space.{0} (add_cancel_monoid.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (add_cancel_monoid.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_24672 (h0 : topological_space (has_nndist (option pos))) : irreducible_space (has_nndist (option pos)) := sorry --non-trivial
lemma new_lemma_24673 (h1 : topological_space (mul_one_class linarith.comp_source)) : t0_space (mul_one_class linarith.comp_source) := sorry --non-trivial
lemma new_lemma_24674 (h0 : fin has_zero.zero) : @rank_condition.{0} (canonically_ordered_monoid.{0} name) (@matrix.vec_empty.{0} (ring.{0} (canonically_ordered_monoid.{0} name)) h0)  := sorry --non-trivial
lemma new_lemma_24675 (h0 : group (has_star (semiring (semiring (semiring (semiring empty)))))) : normalizer_condition (has_star (semiring (semiring (semiring (semiring empty))))) := sorry --non-trivial
lemma new_lemma_24676 (h0 : ring (has_zero (finset linarith.comp))) : rank_condition (has_zero (finset linarith.comp)) := sorry --non-trivial
lemma new_lemma_24677 (h0 : topological_space (has_add (has_neg pos))) : totally_disconnected_space (has_add (has_neg pos)) := sorry --non-trivial
lemma new_lemma_24678 (h0 : has_mem.mem (has_top empty) has_emptyc.emptyc) : @complete_lattice.is_Sup_finite_compact.{0} (has_top.{0} empty) (@finset.pi.empty.{1 0} Type complete_lattice.{0} (has_top.{0} empty) h0)  := sorry --non-trivial
lemma new_lemma_24679 (h0 : has_mem.mem fun_info has_emptyc.emptyc) : @t0_space.{0} fun_info (@finset.pi.empty.{1 0} Type topological_space.{0} fun_info h0)  := sorry --non-trivial
lemma new_lemma_24680 (h0 : topological_space (semi_normed_comm_ring char)) : path_connected_space (semi_normed_comm_ring char) := sorry --non-trivial
lemma new_lemma_24681 (h0 : functor.add_const (add_monoid (add_cancel_monoid name)) (boolean_algebra environment.implicit_infer_kind)) : @add_monoid.fg.{0} (add_cancel_monoid.{0} name) (@functor.add_const.run.{0 0} (add_monoid.{0} (add_cancel_monoid.{0} name)) (boolean_algebra.{0} environment.implicit_infer_kind) h0)  := sorry --non-trivial
lemma new_lemma_24682 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @totally_disconnected_space.{0} (has_top.{0} string_imp) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_top.{0} string_imp))  := sorry --non-trivial
lemma new_lemma_24683 (h0 : functor.add_const (ring (boolean_algebra unsigned)) name) : @is_principal_ideal_ring.{0} (boolean_algebra.{0} unsigned) (@functor.add_const.run.{0 0} (ring.{0} (boolean_algebra.{0} unsigned)) name h0)  := sorry --non-trivial
lemma new_lemma_24684 (h0 : functor.add_const (function.extfun Type topological_space) name) : @totally_disconnected_space.{0} (add_cancel_monoid.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) name h0) (add_cancel_monoid.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_24685 (h0 : complete_lattice (has_one congr_arg_kind)) : is_atomistic (has_one congr_arg_kind) := sorry --non-trivial
lemma new_lemma_24686 (h0 : filter (boolean_algebra.core (finset pos))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_24687 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @group.fg.{0} string_imp (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) string_imp)  := sorry --non-trivial
lemma new_lemma_24688 (h0 : function.extfun Type list) : palindrome (function.extfun_app h0 (has_inter empty)) := sorry --non-trivial
lemma new_lemma_24689 (h0 : functor.add_const (list (has_zero Type)) pos) : palindrome (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_24690 (h0 : finset (ordered_comm_ring (ring linarith.comp))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_24691 (h0 : function.extfun (Type 1) topological_space) : @locally_compact_space.{1} (has_to_string.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} h0 (has_to_string.{1} Type))  := sorry --non-trivial
lemma new_lemma_24692 (h0 : topological_space (boolean_algebra (has_add pos))) : path_connected_space (boolean_algebra (has_add pos)) := sorry --non-trivial
lemma new_lemma_24693 (h0 : functor.add_const (topological_space (comm_group name)) name) : @totally_disconnected_space.{0} (comm_group.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (comm_group.{0} name)) name h0)  := sorry --non-trivial
lemma new_lemma_24694 (h0 : complete_lattice (has_compl (distrib (uniform_space enat)))) : complete_lattice.is_Sup_finite_compact (has_compl (distrib (uniform_space enat))) := sorry --non-trivial
lemma new_lemma_24695 (h0 : functor.add_const (filter (has_nndist unsigned)) unsigned) : countable_Inter_filter (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_24696 (h0 : char -> char -> Prop) : is_antisymm char h0 := sorry --non-trivial
lemma new_lemma_24697 (h0 : topological_space (mul_zero_class environment.implicit_infer_kind)) : regular_space (mul_zero_class environment.implicit_infer_kind) := sorry --non-trivial
lemma new_lemma_24698 (h0 : monoid (canonically_ordered_monoid linarith.comp)) : monoid.fg (canonically_ordered_monoid linarith.comp) := sorry --non-trivial
lemma new_lemma_24699 (h0 : finset (has_Inf (has_neg Type))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_24700 (h0 : function.extfun Type add_group) : @is_add_cyclic.{0} (simple_graph.{0} linarith.comp) (@function.extfun_app.{2 1} Type add_group.{0} h0 (simple_graph.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_24701 (h4 : complete_lattice (add_monoid (has_nnnorm to_additive.value_type))) : complete_lattice.is_Sup_finite_compact (add_monoid (has_nnnorm to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_24702 (h1 : topological_space linarith.comp) : totally_separated_space linarith.comp := sorry --non-trivial
lemma new_lemma_24703 (h0 : fin has_zero.zero) : @group.fg.{1} (ring.{1} Type) (@matrix.vec_empty.{1} (group.{1} (ring.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_24704 (h0 : complete_lattice (has_add (has_neg environment.implicit_infer_kind))) : is_compactly_generated (has_add (has_neg environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_24705 (h0 : functor.add_const (monoid (boolean_algebra unsigned)) (add_comm_monoid Type)) : @monoid.fg.{0} (boolean_algebra.{0} unsigned) (@functor.add_const.run.{0 1} (monoid.{0} (boolean_algebra.{0} unsigned)) (add_comm_monoid.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_24706 (h0 : ring (has_pos_part (has_Inf real))) : rank_condition (has_pos_part (has_Inf real)) := sorry --non-trivial
lemma new_lemma_24707 (h0 : function.extfun Type topological_space) : @loc_path_connected_space.{0} (complete_distrib_lattice.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (complete_distrib_lattice.{0} name))  := sorry --non-trivial
lemma new_lemma_24708 (h0 : functor.add_const (complete_lattice (canonically_ordered_comm_semiring Type)) Type) : @is_compactly_generated.{1} (canonically_ordered_comm_semiring.{1} Type) (@functor.add_const.run.{1 1} (complete_lattice.{1} (canonically_ordered_comm_semiring.{1} Type)) Type h0)  := sorry --non-trivial
lemma new_lemma_24709 (h0 : ordered_add_comm_monoid (ring (has_add pos))) : archimedean (ring (has_add pos)) := sorry --non-trivial
lemma new_lemma_24710 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : palindrome (function.extfun_app (function.extfun_app h0 list) (monoid_with_zero ennreal)) := sorry --non-trivial
lemma new_lemma_24711 (h0 : topological_space (with_one (has_norm empty))) : locally_compact_space (with_one (has_norm empty)) := sorry --non-trivial
lemma new_lemma_24712 (h0 : list (normed_comm_ring (has_pos_part Type))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_24713 (h0 h1 : int) : int.lt h0 h1 := sorry --non-trivial
lemma new_lemma_24714 (h0 : function.extfun (Type 1) semiring) : @is_noetherian_ring.{1} (semigroup.{1} Type) (@function.extfun_app.{3 2} (Type 1) semiring.{1} h0 (semigroup.{1} Type))  := sorry --non-trivial
lemma new_lemma_24715 (h0 : ordered_comm_monoid (semigroup (semigroup unsigned))) : has_exists_mul_of_le (semigroup (semigroup unsigned)) := sorry --non-trivial
lemma new_lemma_24716 (h0 : functor.add_const (function.extfun Type topological_space) name) : @preconnected_space.{0} (has_add.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) name h0) (has_add.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_24717 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @preirreducible_space.{0} (semiring.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (semiring.{0} empty))  := sorry --non-trivial
lemma new_lemma_24718 (h0 : topological_space (linear_ordered_semiring (has_top (has_norm to_additive.value_type)))) : totally_separated_space (linear_ordered_semiring (has_top (has_norm to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_24719 (h0 : function.extfun Type topological_space) : @locally_compact_space.{0} (normed_group.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (normed_group.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_24720 (h0 : not (ring (has_sub num) -> false)) : @is_domain.{0} (has_sub.{0} num) (@classical.by_contradiction'.{1} (ring.{0} (has_sub.{0} num)) h0)  := sorry --non-trivial
lemma new_lemma_24721 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @rank_condition.{0} (has_add.{0} (option.{0} ennreal)) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (has_add.{0} (option.{0} ennreal)))  := sorry --non-trivial
lemma new_lemma_24722 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : countable_Inter_filter (function.extfun_app (function.extfun_app h0 filter) (boolean_algebra pos)) := sorry --non-trivial
lemma new_lemma_24723 (h0 : function.extfun (Type 1) topological_space) : @preirreducible_space.{1} (canonically_ordered_monoid.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} h0 (canonically_ordered_monoid.{1} Type))  := sorry --non-trivial
lemma new_lemma_24724 (h0 : has_mem.mem group has_emptyc.emptyc) : @is_cyclic.{0} (measurable_space.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type group.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) group.{0} h0) (measurable_space.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_24725 (h0 : function.extfun Type group) : @is_cyclic.{0} (@id.{2} Type to_additive.value_type) (@function.extfun_app.{2 1} Type group.{0} h0 (@id.{2} Type to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_24726 (h0 : functor.add_const (topological_space (finset ennreal)) (has_add Type)) : @preirreducible_space.{0} (finset.{0} ennreal) (@functor.add_const.run.{0 1} (topological_space.{0} (finset.{0} ennreal)) (has_add.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_24727 (h0 : topological_space (semigroup ennreal)) : preirreducible_space (semigroup ennreal) := sorry --non-trivial
lemma new_lemma_24728 (h0 : uniform_space (has_nndist (cancel_monoid Type))) : separated_space (has_nndist (cancel_monoid Type)) := sorry --non-trivial
lemma new_lemma_24729 (h0 : not (semiring (with_one unsigned) -> false)) : @is_noetherian_ring.{0} (with_one.{0} unsigned) (@classical.by_contradiction'.{1} (semiring.{0} (with_one.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_24730 (h0 : function.extfun Type (functor.comp topological_space mul_zero_class)) : @totally_separated_space.{0} (mul_zero_class.{0} name) (@functor.comp.run.{0 0 0} topological_space.{0} mul_zero_class.{0} name (@function.extfun_app.{2 1} Type (functor.comp.{0 0 0} topological_space.{0} mul_zero_class.{0}) h0 name))  := sorry --non-trivial
lemma new_lemma_24731 (h0 : function.extfun (Type 1) group) : @is_simple_group.{1} (has_to_string.{1} Type) (@function.extfun_app.{3 2} (Type 1) group.{1} h0 (has_to_string.{1} Type))  := sorry --non-trivial
lemma new_lemma_24732 (h2 : filter (semi_normed_comm_ring to_additive.value_type)) : filter.ne_bot h2 := sorry --non-trivial
lemma new_lemma_24733 (h0 : topological_space (has_sub (semiring (semiring (semiring (semiring empty)))))) : discrete_topology (has_sub (semiring (semiring (semiring (semiring empty))))) := sorry --non-trivial
lemma new_lemma_24734 (h0 : function.extfun Type (functor.comp group ring)) : @is_cyclic.{0} (ring.{0} name) (@functor.comp.run.{0 0 0} group.{0} ring.{0} name (@function.extfun_app.{2 1} Type (functor.comp.{0 0 0} group.{0} ring.{0}) h0 name))  := sorry --non-trivial
lemma new_lemma_24735 (h0 : functor.comp ring cancel_monoid environment.implicit_infer_kind) : @strong_rank_condition.{0} (cancel_monoid.{0} environment.implicit_infer_kind) (@functor.comp.run.{0 0 0} ring.{0} cancel_monoid.{0} environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_24736 (h0 : monoid (dlist (random_gen (random_gen linarith.ineq)))) : monoid.fg (dlist (random_gen (random_gen linarith.ineq))) := sorry --non-trivial
lemma new_lemma_24737 (h1 : ring (has_ssubset char)) : is_domain (has_ssubset char) := sorry --non-trivial
lemma new_lemma_24738 (h0 : functor.add_const (monoid (has_nndist Type)) (cancel_monoid Type)) : @monoid.fg.{1} (has_nndist.{1} Type) (@functor.add_const.run.{1 1} (monoid.{1} (has_nndist.{1} Type)) (cancel_monoid.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_24739 (h0 : topological_space (semigroup (has_neg (semigroup (finset (finset linarith.comp)))))) : topological_space.separable_space (semigroup (has_neg (semigroup (finset (finset linarith.comp))))) := sorry --non-trivial
lemma new_lemma_24740 (h0 : functor.add_const (ring (complete_distrib_lattice name)) Type) : @strong_rank_condition.{0} (complete_distrib_lattice.{0} name) (@functor.add_const.run.{0 1} (ring.{0} (complete_distrib_lattice.{0} name)) Type h0)  := sorry --non-trivial
lemma new_lemma_24741 (h0 : functor.add_const (topological_space (linear_ordered_comm_group empty)) ennreal) : @preirreducible_space.{0} (linear_ordered_comm_group.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (linear_ordered_comm_group.{0} empty)) ennreal h0)  := sorry --non-trivial
lemma new_lemma_24742 (h0 : functor.add_const (ring (finset linarith.comp)) environment.implicit_infer_kind) : @is_principal_ideal_ring.{0} (finset.{0} linarith.comp) (@functor.add_const.run.{0 0} (ring.{0} (finset.{0} linarith.comp)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_24743 (h0 : functor.add_const (list (comm_group name)) environment.implicit_infer_kind) : list.nodup (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_24744 (h0 : functor.add_const (function.extfun Type monoid) environment.implicit_infer_kind) : @monoid.fg.{0} (boolean_algebra.{0} name) (@function.extfun_app.{2 1} Type monoid.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type monoid.{0}) environment.implicit_infer_kind h0) (boolean_algebra.{0} name))  := sorry --non-trivial
lemma new_lemma_24745 (h0 : functor.add_const (ring (has_zero Type)) Type) : @is_domain.{1} (has_zero.{1} Type) (@functor.add_const.run.{1 1} (ring.{1} (has_zero.{1} Type)) Type h0)  := sorry --non-trivial
lemma new_lemma_24746 (h0 : function.extfun ((Type -> Type) -> Type 1) (function.extfun (Type -> Type))) : @t0_space.{0} (has_top.{0} linarith.ineq) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) (@function.extfun_app.{3 2} ((Type → Type) → Type 1) (function.extfun.{2 2} (Type → Type)) h0 (function.extfun.{2 1} Type)) topological_space.{0}) (has_top.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_24747 (h0 : complete_lattice (complete_distrib_lattice (option unsigned))) : complete_lattice.is_Sup_finite_compact (complete_distrib_lattice (option unsigned)) := sorry --non-trivial
lemma new_lemma_24748 (h0 : semiring (has_add (add_comm_monoid (finset environment.implicit_infer_kind)))) : is_noetherian_ring (has_add (add_comm_monoid (finset environment.implicit_infer_kind))) := sorry --non-trivial
lemma new_lemma_24749 (h1 : ring std_gen) : rank_condition std_gen := sorry --non-trivial
lemma new_lemma_24750 (h0 : functor.add_const (topological_space (has_Inf Type)) name) : @t1_space.{1} (has_Inf.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (has_Inf.{1} Type)) name h0)  := sorry --non-trivial
lemma new_lemma_24751 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_principal_ideal_ring.{0} (has_add.{0} (option.{0} pos)) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (has_add.{0} (option.{0} pos)))  := sorry --non-trivial
lemma new_lemma_24752 (h0 : functor.add_const (finset (has_Sup empty)) congr_arg_kind) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_24753 (h0 : functor.comp topological_space has_nndist name) : @sequential_space.{0} (has_nndist.{0} name) (@functor.comp.run.{0 0 0} topological_space.{0} has_nndist.{0} name h0)  := sorry --non-trivial
lemma new_lemma_24754 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @discrete_topology.{0} (ordered_comm_monoid.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (ordered_comm_monoid.{0} pos))  := sorry --non-trivial
lemma new_lemma_24755 (h0 : function.extfun Type topological_space) : @totally_separated_space.{0} (has_dist.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_dist.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_24756 (h0 : topological_space (complete_distrib_lattice (has_add name))) : irreducible_space (complete_distrib_lattice (has_add name)) := sorry --non-trivial
lemma new_lemma_24757 (h0 : ordered_comm_monoid (boolean_algebra.core (has_add (has_add (ring Type))))) : has_exists_mul_of_le (boolean_algebra.core (has_add (has_add (ring Type)))) := sorry --non-trivial
lemma new_lemma_24758 (h1 : semiring (mul_one_class fun_info)) (h2 : mul_one_class fun_info) : even h2 := sorry --non-trivial
lemma new_lemma_24759 (h0 : functor.comp group has_to_string Type) : @is_simple_group.{1} (has_to_string.{1} Type) (@functor.comp.run.{1 1 1} group.{1} has_to_string.{1} Type h0)  := sorry --non-trivial
lemma new_lemma_24760 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @group.fg.{0} (has_bot.{0} pos) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (has_bot.{0} pos))  := sorry --non-trivial
lemma new_lemma_24761 (h1 : has_mem.mem (with_one linarith.comp_source) has_emptyc.emptyc) : @is_compactly_generated.{0} (with_one.{0} linarith.comp_source) (@finset.pi.empty.{1 0} Type complete_lattice.{0} (with_one.{0} linarith.comp_source) h1)  := sorry --non-trivial
lemma new_lemma_24762 (h0 : monoid (has_neg (has_add pos))) : monoid.fg (has_neg (has_add pos)) := sorry --non-trivial
lemma new_lemma_24763 (h0 : functor.add_const (function.extfun Type topological_space) Type) : @locally_compact_space.{0} (add_cancel_monoid.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type topological_space.{0}) Type h0) (add_cancel_monoid.{0} pos))  := sorry --non-trivial
lemma new_lemma_24764 (h0 : complete_lattice (monoid empty)) : is_atomistic (monoid empty) := sorry --non-trivial
lemma new_lemma_24765 (h0 : ring (boolean_algebra.core (has_add (has_add pos)))) : is_principal_ideal_ring (boolean_algebra.core (has_add (has_add pos))) := sorry --non-trivial
lemma new_lemma_24766 (h0 : function.extfun (Type 1) topological_space) : @t1_space.{1} (finset.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} h0 (finset.{1} Type))  := sorry --non-trivial
lemma new_lemma_24767 (h0 : ring (has_top (random_gen (random_gen linarith.ineq)))) : strong_rank_condition (has_top (random_gen (random_gen linarith.ineq))) := sorry --non-trivial
lemma new_lemma_24768 (h0 : topological_space (has_zero linarith.comp)) : preirreducible_space (has_zero linarith.comp) := sorry --non-trivial
lemma new_lemma_24769 (h0 : group (denumerable (has_nnnorm (has_top fun_info)))) : group.fg (denumerable (has_nnnorm (has_top fun_info))) := sorry --non-trivial
lemma new_lemma_24770 (h0 : functor.add_const (list (boolean_algebra.core name)) Type) : list.nodup (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_24771 (h0 : function.extfun Type add_group) : @is_add_cyclic.{0} num (@function.extfun_app.{2 1} Type add_group.{0} h0 num)  := sorry --non-trivial
lemma new_lemma_24772 (h0 : not (topological_space (uniform_space (mul_one_class (mul_one_class string.iterator_imp))) -> false)) : @t0_space.{0} (uniform_space.{0} (mul_one_class.{0} (mul_one_class.{0} string.iterator_imp))) (@classical.by_contradiction'.{1} (topological_space.{0} (uniform_space.{0} (mul_one_class.{0} (mul_one_class.{0} string.iterator_imp)))) h0)  := sorry --non-trivial
lemma new_lemma_24773 (h0 : not (topological_space (has_star empty) -> false)) : @t1_space.{0} (has_star.{0} empty) (@classical.by_contradiction'.{1} (topological_space.{0} (has_star.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_24774 (h0 : functor.add_const (finset (has_neg linarith.comp)) name) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_24775 (h0 : function.extfun nat fin) : @path_connected_space.{0} (has_bot.{0} real) (@matrix.vec_empty.{0} (topological_space.{0} (has_bot.{0} real)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_24776 (h0 : group (add_cancel_monoid (semiring empty))) : is_cyclic (add_cancel_monoid (semiring empty)) := sorry --non-trivial
lemma new_lemma_24777 (h0 : topological_space (generalized_boolean_algebra (sub_neg_monoid real))) : totally_separated_space (generalized_boolean_algebra (sub_neg_monoid real)) := sorry --non-trivial
lemma new_lemma_24778 (h0 : not (ring (add_group linarith.comp) -> false)) : @strong_rank_condition.{0} (add_group.{0} linarith.comp) (@classical.by_contradiction'.{1} (ring.{0} (add_group.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_24779 (h0 : function.extfun nat fin) : @strong_rank_condition.{0} (normed_lattice_add_comm_group.{0} pos) (@matrix.vec_empty.{0} (ring.{0} (normed_lattice_add_comm_group.{0} pos)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_24780 (h0 : non_assoc_semiring (has_top (has_top empty)) -> non_assoc_semiring (has_top (has_top empty)) -> Prop) : is_strict_order (non_assoc_semiring (has_top (has_top empty))) h0 := sorry --non-trivial
lemma new_lemma_24781 (h0 : topological_space (sub_neg_monoid (has_neg name))) : preirreducible_space (sub_neg_monoid (has_neg name)) := sorry --non-trivial
lemma new_lemma_24782 (h0 : function.extfun Type ring) : @is_principal_ideal_ring.{0} pos (@function.extfun_app.{2 1} Type ring.{0} h0 pos)  := sorry --non-trivial
lemma new_lemma_24783 (h0 : functor.comp uniform_space semigroup Type) : @separated_space.{1} (semigroup.{1} Type) (@functor.comp.run.{1 1 1} uniform_space.{1} semigroup.{1} Type h0)  := sorry --non-trivial
lemma new_lemma_24784 (h0 : finset (semigroup (finset pos))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_24785 (h0 : function.extfun Type topological_space) : @sequential_space.{0} (boolean_algebra.core.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (boolean_algebra.core.{0} pos))  := sorry --non-trivial
lemma new_lemma_24786 (h0 : functor.add_const (list (ordered_comm_group empty)) empty) : list.nodup (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_24787 (h0 : semiring (add_group_with_zero_nhd unsigned)) : is_noetherian_ring (add_group_with_zero_nhd unsigned) := sorry --non-trivial
lemma new_lemma_24788 (h0 : functor.add_const (group (generalized_boolean_algebra linarith.comp)) pos) : @is_cyclic.{0} (generalized_boolean_algebra.{0} linarith.comp) (@functor.add_const.run.{0 0} (group.{0} (generalized_boolean_algebra.{0} linarith.comp)) pos h0)  := sorry --non-trivial
lemma new_lemma_24789 (h0 : function.extfun Type finset) : finset.nonempty (function.extfun_app h0 (has_neg unsigned)) := sorry --non-trivial
lemma new_lemma_24790 (h0 : functor.add_const (topological_space (normed_comm_ring linarith.comp)) linarith.comp) : @loc_path_connected_space.{0} (normed_comm_ring.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (normed_comm_ring.{0} linarith.comp)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_24791 (h0 : topological_space (left_cancel_monoid (semiring num))) : path_connected_space (left_cancel_monoid (semiring num)) := sorry --non-trivial
lemma new_lemma_24792 (h0 : functor.add_const (group (has_pos_part Type)) pos) : @is_simple_group.{1} (has_pos_part.{1} Type) (@functor.add_const.run.{1 0} (group.{1} (has_pos_part.{1} Type)) pos h0)  := sorry --non-trivial
lemma new_lemma_24793 (h0 : ring (random_gen (random_gen (random_gen (random_gen fun_info))))) : rank_condition (random_gen (random_gen (random_gen (random_gen fun_info)))) := sorry --non-trivial
lemma new_lemma_24794 (h0 : topological_space (has_compl char)) : t0_space (has_compl char) := sorry --non-trivial
lemma new_lemma_24795 (h0 : complete_lattice (has_dist empty)) : is_atomistic (has_dist empty) := sorry --non-trivial
lemma new_lemma_24796 (h0 : not (topological_space (dlist char) -> false)) : @locally_compact_space.{0} (dlist.{0} char) (@classical.by_contradiction'.{1} (topological_space.{0} (dlist.{0} char)) h0)  := sorry --non-trivial
lemma new_lemma_24797 (h0 : functor.add_const (complete_lattice (has_neg_part Type)) pos) : @is_atomistic.{1} (has_neg_part.{1} Type) (@functor.add_const.run.{1 0} (complete_lattice.{1} (has_neg_part.{1} Type)) pos h0)  := sorry --non-trivial
lemma new_lemma_24798 (h0 : functor.add_const (list (has_bot unsigned)) empty) : palindrome (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_24799 (h0 : not (has_mem.mem complete_lattice has_emptyc.emptyc -> false)) : @is_compactly_generated.{0} (has_norm.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) complete_lattice.{0} (@classical.by_contradiction'.{0} (@has_mem.mem.{1 1} (Type → Type) (finset.{1} (Type → Type)) (@finset.has_mem.{1} (Type → Type)) complete_lattice.{0} (@has_emptyc.emptyc.{1} (finset.{1} (Type → Type)) (@finset.has_emptyc.{1} (Type → Type)))) h0)) (has_norm.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_24800 (h0 : functor.add_const (function.extfun (Type 1) uniform_space) linarith.comp) : @separated_space.{1} (complete_distrib_lattice.{1} Type) (@function.extfun_app.{3 2} (Type 1) uniform_space.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) uniform_space.{1}) linarith.comp h0) (complete_distrib_lattice.{1} Type))  := sorry --non-trivial
lemma new_lemma_24801 (h0 : topological_space (boolean_algebra.core empty)) : path_connected_space (boolean_algebra.core empty) := sorry --non-trivial
lemma new_lemma_24802 (h5 : topological_space linarith.ineq) : path_connected_space linarith.ineq := sorry --non-trivial
lemma new_lemma_24803 (h0 : complete_lattice (denumerable (has_nnnorm linarith.ineq))) : complete_lattice.is_Sup_finite_compact (denumerable (has_nnnorm linarith.ineq)) := sorry --non-trivial
lemma new_lemma_24804 (h0 : function.extfun Type add_monoid) : @add_monoid.fg.{0} (linear_ordered_add_comm_monoid_with_top.{0} linarith.comp) (@function.extfun_app.{2 1} Type add_monoid.{0} h0 (linear_ordered_add_comm_monoid_with_top.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_24805 (h0 : function.extfun Type complete_lattice) : @is_atomistic.{0} (random_gen.{0} (with_bot.{0} string_imp)) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (random_gen.{0} (with_bot.{0} string_imp)))  := sorry --non-trivial
lemma new_lemma_24806 (h1 : not (add_group (has_ssubset string_imp) -> false)) : @is_add_cyclic.{0} (has_ssubset.{0} string_imp) (@classical.by_contradiction'.{1} (add_group.{0} (has_ssubset.{0} string_imp)) h1)  := sorry --non-trivial
lemma new_lemma_24807 (h0 : topological_space (boolean_algebra (ring Type))) : locally_compact_space (boolean_algebra (ring Type)) := sorry --non-trivial
lemma new_lemma_24808 (h4 : topological_space (has_div environment.projection_info)) : path_connected_space (has_div environment.projection_info) := sorry --non-trivial
lemma new_lemma_24809 (h0 : has_lt (mul_one_class string_imp)) : no_max_order (mul_one_class string_imp) := sorry --non-trivial
lemma new_lemma_24810 (h0 : function.extfun Type complete_lattice) : is_compactly_generated (filter empty) := sorry --non-trivial
lemma new_lemma_24811 (h0 : uniform_space (sub_neg_monoid ennreal)) : separated_space (sub_neg_monoid ennreal) := sorry --non-trivial
lemma new_lemma_24812 (h0 : ordered_add_comm_monoid (canonically_ordered_comm_semiring (has_add pos))) : archimedean (canonically_ordered_comm_semiring (has_add pos)) := sorry --non-trivial
lemma new_lemma_24813 (h0 : linarith.ineq -> has_div linarith.ineq) (h1 : linarith.ineq) : set.subsingleton (function.graph h0 h1) := sorry --non-trivial
lemma new_lemma_24814 (h0 : list (measurable_space linarith.comp_source)) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_24815 (h0 : topological_space (has_bot (has_add (has_Inf (has_Inf linarith.comp))))) : regular_space (has_bot (has_add (has_Inf (has_Inf linarith.comp)))) := sorry --non-trivial
lemma new_lemma_24816 (h0 : group (normed_group (has_top num))) : normalizer_condition (normed_group (has_top num)) := sorry --non-trivial
lemma new_lemma_24817 (h0 h1 : multiset (has_nnnorm (has_repr linarith.ineq))) : multiset.subset h0 h1 := sorry --non-trivial
lemma new_lemma_24818 (h0 : group (normed_comm_ring (ring pos))) : group.fg (normed_comm_ring (ring pos)) := sorry --non-trivial
lemma new_lemma_24819 (h0 : group (has_star (option unsigned))) : normalizer_condition (has_star (option unsigned)) := sorry --non-trivial
lemma new_lemma_24820 (h0 : topological_space (add_comm_monoid (boolean_algebra.core pos))) : topological_space.separable_space (add_comm_monoid (boolean_algebra.core pos)) := sorry --non-trivial
lemma new_lemma_24821 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_noetherian_ring.{0} (has_zero.{0} ennreal) (@function.extfun_app.{2 1} Type semiring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 semiring.{0}) (has_zero.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_24822 (h0 : uniform_space (normed_group (semiring (semiring (semiring unsigned))))) : complete_space (normed_group (semiring (semiring (semiring unsigned)))) := sorry --non-trivial
lemma new_lemma_24823 (h0 : functor.add_const (semiring (normed_comm_ring linarith.comp)) linarith.comp) : @is_noetherian_ring.{0} (normed_comm_ring.{0} linarith.comp) (@functor.add_const.run.{0 0} (semiring.{0} (normed_comm_ring.{0} linarith.comp)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_24824 (h0 : functor.add_const (topological_space (ordered_comm_ring linarith.comp)) pos) : @irreducible_space.{0} (ordered_comm_ring.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (ordered_comm_ring.{0} linarith.comp)) pos h0)  := sorry --non-trivial
lemma new_lemma_24825 (h0 : ring (comm_semigroup (has_add real))) : is_domain (comm_semigroup (has_add real)) := sorry --non-trivial
lemma new_lemma_24826 (h0 : functor.add_const (uniform_space (has_zero ennreal)) linarith.comp) : @separated_space.{0} (has_zero.{0} ennreal) (@functor.add_const.run.{0 0} (uniform_space.{0} (has_zero.{0} ennreal)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_24827 (h0 : function.extfun nat fin) : @is_cyclic.{0} (ordered_comm_ring.{0} name) (@matrix.vec_empty.{0} (group.{0} (ordered_comm_ring.{0} name)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_24828 (h0 : function.extfun Type topological_space) : @path_connected_space.{0} (@id.{2} Type linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (@id.{2} Type linarith.comp))  := sorry --non-trivial
lemma new_lemma_24829 (h0 : not (topological_space (has_norm linarith.comp_source) -> false)) : @totally_separated_space.{0} (has_norm.{0} linarith.comp_source) (@classical.by_contradiction'.{1} (topological_space.{0} (has_norm.{0} linarith.comp_source)) h0)  := sorry --non-trivial
lemma new_lemma_24830 (h0 : topological_space (has_zero environment.implicit_infer_kind)) : locally_compact_space (has_zero environment.implicit_infer_kind) := sorry --non-trivial
lemma new_lemma_24831 (h0 : ring (finset (has_Inf (finset linarith.comp)))) : is_domain (finset (has_Inf (finset linarith.comp))) := sorry --non-trivial
lemma new_lemma_24832 (h0 : topological_space (canonically_ordered_monoid (has_neg (has_bot (has_Inf (has_Inf real)))))) : preirreducible_space (canonically_ordered_monoid (has_neg (has_bot (has_Inf (has_Inf real))))) := sorry --non-trivial
lemma new_lemma_24833 (h0 : not (topological_space (metric_space unsigned) -> false)) : @t0_space.{0} (metric_space.{0} unsigned) (@classical.by_contradiction'.{1} (topological_space.{0} (metric_space.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_24834 (h0 : topological_space (comm_group Type)) : path_connected_space (comm_group Type) := sorry --non-trivial
lemma new_lemma_24835 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @normal_space.{0} (add_cancel_monoid.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (add_cancel_monoid.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_24836 (h0 : function.extfun (Type 1) topological_space) : @totally_separated_space.{1} (has_nndist.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} h0 (has_nndist.{1} Type))  := sorry --non-trivial
lemma new_lemma_24837 (h0 : functor.add_const (monoid (has_edist empty)) empty) : @monoid.fg.{0} (has_edist.{0} empty) (@functor.add_const.run.{0 0} (monoid.{0} (has_edist.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_24838 (h0 : functor.add_const (topological_space (has_neg pos)) Type) : @discrete_topology.{0} (has_neg.{0} pos) (@functor.add_const.run.{0 1} (topological_space.{0} (has_neg.{0} pos)) Type h0)  := sorry --non-trivial
lemma new_lemma_24839 (h0 : function.extfun Type (functor.add_const (list (is_R_or_C unsigned)))) : list.nodup (functor.add_const.run (function.extfun_app h0 unsigned)) := sorry --non-trivial
lemma new_lemma_24840 (h0 : topological_space (comm_ring (has_ssubset string_imp))) : t0_space (comm_ring (has_ssubset string_imp)) := sorry --non-trivial
lemma new_lemma_24841 (h0 : function.extfun Type monoid) : @monoid.fg.{0} (has_emptyc.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type monoid.{0} h0 (has_emptyc.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_24842 (h0 : topological_space (has_norm (random_gen (random_gen num)))) : t0_space (has_norm (random_gen (random_gen num))) := sorry --non-trivial
lemma new_lemma_24843 (h0 : topological_space (linear_ordered_comm_ring (ordered_cancel_comm_monoid unsigned))) : totally_separated_space (linear_ordered_comm_ring (ordered_cancel_comm_monoid unsigned)) := sorry --non-trivial
lemma new_lemma_24844 (h0 : function.extfun nat fin) : @separated_space.{0} (canonically_ordered_monoid.{0} pos) (@matrix.vec_empty.{0} (uniform_space.{0} (canonically_ordered_monoid.{0} pos)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_24845 (h0 : uniform_space (add_cancel_monoid (option (option (option empty))))) : complete_space (add_cancel_monoid (option (option (option empty)))) := sorry --non-trivial
lemma new_lemma_24846 (h0 : fin has_zero.zero) : @complete_lattice.is_Sup_finite_compact.{0} (has_Inf.{0} pos) (@matrix.vec_empty.{0} (complete_lattice.{0} (has_Inf.{0} pos)) h0)  := sorry --non-trivial
lemma new_lemma_24847 (h0 : function.extfun (finset Type) (has_mem.mem (has_emptyc to_additive.value_type))) : @totally_disconnected_space.{0} (has_emptyc.{0} to_additive.value_type) (@finset.pi.empty.{1 0} Type topological_space.{0} (has_emptyc.{0} to_additive.value_type) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (has_emptyc.{0} to_additive.value_type)) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_24848 (h0 : filter (has_add (has_pos_part Type))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_24849 (h0 : complete_lattice (comm_ring (random_gen (random_gen linarith.ineq)))) : complete_lattice.is_Sup_finite_compact (comm_ring (random_gen (random_gen linarith.ineq))) := sorry --non-trivial
lemma new_lemma_24850 (h0 : ordered_add_comm_monoid (normed_linear_ordered_group congr_arg_kind)) : archimedean (normed_linear_ordered_group congr_arg_kind) := sorry --non-trivial
lemma new_lemma_24851 (h0 : functor.add_const (uniform_space (has_neg name)) name) : @complete_space.{0} (has_neg.{0} name) (@functor.add_const.run.{0 0} (uniform_space.{0} (has_neg.{0} name)) name h0)  := sorry --non-trivial
lemma new_lemma_24852 (h0 : not (function.extfun Type complete_lattice -> false)) : @is_compactly_generated.{0} (normed_group.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type complete_lattice.{0}) h0) (normed_group.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_24853 (h0 : group (has_zero unsigned)) : is_simple_group (has_zero unsigned) := sorry --non-trivial
lemma new_lemma_24854 (h0 : filter (normed_comm_ring (option pos))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_24855 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_add_cyclic.{0} (monoid_with_zero.{0} (option.{0} (option.{0} num))) (@function.extfun_app.{2 1} Type add_group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 add_group.{0}) (monoid_with_zero.{0} (option.{0} (option.{0} num))))  := sorry --non-trivial
lemma new_lemma_24856 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @add_monoid.fg.{0} (cancel_monoid.{0} empty) (@function.extfun_app.{2 1} Type add_monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 add_monoid.{0}) (cancel_monoid.{0} empty))  := sorry --non-trivial
lemma new_lemma_24857 (h0 : functor.add_const (group (boolean_algebra.core name)) (has_neg_part pos)) : @is_cyclic.{0} (boolean_algebra.core.{0} name) (@functor.add_const.run.{0 0} (group.{0} (boolean_algebra.core.{0} name)) (has_neg_part.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_24858 (h1 : ring (distrib_lattice string_imp)) : is_domain (distrib_lattice string_imp) := sorry --non-trivial
lemma new_lemma_24859 (h0 : functor.add_const (ring (has_inter unsigned)) ennreal) : @is_principal_ideal_ring.{0} (has_inter.{0} unsigned) (@functor.add_const.run.{0 0} (ring.{0} (has_inter.{0} unsigned)) ennreal h0)  := sorry --non-trivial
lemma new_lemma_24860 (h0 : topological_space (finset (finset (finset (finset pos))))) : normal_space (finset (finset (finset (finset pos)))) := sorry --non-trivial
lemma new_lemma_24861 (h1 : not (ring (has_ssubset string_imp) -> false)) : @strong_rank_condition.{0} (has_ssubset.{0} string_imp) (@classical.by_contradiction'.{1} (ring.{0} (has_ssubset.{0} string_imp)) h1)  := sorry --non-trivial
lemma new_lemma_24862 (h0 : functor.add_const (semiring (generalized_boolean_algebra pos)) linarith.comp) : @is_noetherian_ring.{0} (generalized_boolean_algebra.{0} pos) (@functor.add_const.run.{0 0} (semiring.{0} (generalized_boolean_algebra.{0} pos)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_24863 (h0 : functor.add_const (uniform_space (has_star empty)) num) : @complete_space.{0} (has_star.{0} empty) (@functor.add_const.run.{0 0} (uniform_space.{0} (has_star.{0} empty)) num h0)  := sorry --non-trivial
lemma new_lemma_24864 (h0 : fin has_zero.zero) : @normal_space.{0} (has_pos_part.{0} real) (@matrix.vec_empty.{0} (topological_space.{0} (has_pos_part.{0} real)) h0)  := sorry --non-trivial
lemma new_lemma_24865 (h0 : prod (complete_distrib_lattice congr_arg_kind) (complete_distrib_lattice congr_arg_kind)) : set.diagonal (complete_distrib_lattice congr_arg_kind) h0 := sorry --non-trivial
lemma new_lemma_24866 (h0 : topological_space (canonically_ordered_monoid (has_add pos))) : t0_space (canonically_ordered_monoid (has_add pos)) := sorry --non-trivial
lemma new_lemma_24867 (h0 : ordered_comm_monoid (has_neg_part (finset unsigned))) : has_exists_mul_of_le (has_neg_part (finset unsigned)) := sorry --non-trivial
lemma new_lemma_24868 (h1 : complete_lattice (non_unital_non_assoc_semiring char)) : is_compactly_generated (non_unital_non_assoc_semiring char) := sorry --non-trivial
lemma new_lemma_24869 (h0 : functor.add_const (group (has_to_string linarith.comp)) linarith.comp) : @normalizer_condition.{0} (has_to_string.{0} linarith.comp) (@functor.add_const.run.{0 0} (group.{0} (has_to_string.{0} linarith.comp)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_24870 (h0 : functor.add_const (function.extfun Type group) name) : @is_cyclic.{0} (has_neg_part.{0} ennreal) (@function.extfun_app.{2 1} Type group.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type group.{0}) name h0) (has_neg_part.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_24871 (h0 : char) (h1 : filter char) : @totally_disconnected_space.{0} char (@nhds_adjoint.{0} char h0 h1)  := sorry --non-trivial
lemma new_lemma_24872 (h1 : function.extfun Type topological_space) : @totally_separated_space.{0} (complete_semilattice_Sup.{0} string_imp) (@function.extfun_app.{2 1} Type topological_space.{0} h1 (complete_semilattice_Sup.{0} string_imp))  := sorry --non-trivial
lemma new_lemma_24873 (h0 : group (semigroup (has_nndist pos))) : normalizer_condition (semigroup (has_nndist pos)) := sorry --non-trivial
lemma new_lemma_24874 (h0 : topological_space (ring (finset Type))) : normal_space (ring (finset Type)) := sorry --non-trivial
lemma new_lemma_24875 (h0 : functor.add_const (function.extfun Type complete_lattice) linarith.comp) : @complete_lattice.is_Sup_finite_compact.{0} (semigroup.{0} linarith.comp) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type complete_lattice.{0}) linarith.comp h0) (semigroup.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_24876 (h0 : group (random_gen (has_top linarith.comp))) : normalizer_condition (random_gen (has_top linarith.comp)) := sorry --non-trivial
lemma new_lemma_24877 (h0 : topological_space (complete_distrib_lattice (semiring (option unsigned)))) : loc_path_connected_space (complete_distrib_lattice (semiring (option unsigned))) := sorry --non-trivial
lemma new_lemma_24878 (h0 : ring (comm_group (has_neg_part name))) : strong_rank_condition (comm_group (has_neg_part name)) := sorry --non-trivial
lemma new_lemma_24879 (h0 : topological_space (mul_zero_class num)) : discrete_topology (mul_zero_class num) := sorry --non-trivial
lemma new_lemma_24880 (h1 : function.extfun Type group) : @is_cyclic.{0} (semiring.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type group.{0} h1 (semiring.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_24881 (h0 : function.extfun Type topological_space) : @irreducible_space.{0} (canonically_linear_ordered_monoid.{0} ennreal) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (canonically_linear_ordered_monoid.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_24882 (h0 : function.extfun Type ring) : @rank_condition.{0} (bin_tree.{0} num) (@function.extfun_app.{2 1} Type ring.{0} h0 (bin_tree.{0} num))  := sorry --non-trivial
lemma new_lemma_24883 (h0 : topological_space (has_ssubset (has_nnnorm (comm_ring (comm_ring (mul_one_class char)))))) : t0_space (has_ssubset (has_nnnorm (comm_ring (comm_ring (mul_one_class char))))) := sorry --non-trivial
lemma new_lemma_24884 (h0 : functor.add_const (group (complete_distrib_lattice pos)) linarith.comp) : @is_cyclic.{0} (complete_distrib_lattice.{0} pos) (@functor.add_const.run.{0 0} (group.{0} (complete_distrib_lattice.{0} pos)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_24885 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @archimedean.{0} (normed_comm_ring.{0} linarith.comp) (@function.extfun_app.{2 1} Type ordered_add_comm_monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ordered_add_comm_monoid.{0}) (normed_comm_ring.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_24886 (h0 : has_mem.mem (semiring linarith.ineq) has_emptyc.emptyc) : @path_connected_space.{0} (semiring.{0} linarith.ineq) (@finset.pi.empty.{1 0} Type topological_space.{0} (semiring.{0} linarith.ineq) h0)  := sorry --non-trivial
lemma new_lemma_24887 (h0 : function.extfun Type (functor.add_const (topological_space (add_left_cancel_semigroup empty)))) : @totally_separated_space.{0} (add_left_cancel_semigroup.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (add_left_cancel_semigroup.{0} empty)) empty (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (topological_space.{0} (add_left_cancel_semigroup.{0} empty))) h0 empty))  := sorry --non-trivial
lemma new_lemma_24888 (h0 : topological_space (add_comm_monoid (comm_group (comm_group pos)))) : loc_path_connected_space (add_comm_monoid (comm_group (comm_group pos))) := sorry --non-trivial
lemma new_lemma_24889 (h0 : functor.add_const (topological_space (group_with_zero congr_arg_kind)) empty) : @preirreducible_space.{0} (group_with_zero.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (group_with_zero.{0} congr_arg_kind)) empty h0)  := sorry --non-trivial
lemma new_lemma_24890 (h0 : not (complete_lattice (simple_graph linarith.comp_source) -> false)) : @is_compactly_generated.{0} (simple_graph.{0} linarith.comp_source) (@classical.by_contradiction'.{1} (complete_lattice.{0} (simple_graph.{0} linarith.comp_source)) h0)  := sorry --non-trivial
lemma new_lemma_24891 (h0 : topological_space (ordered_comm_monoid linarith.comp)) : loc_path_connected_space (ordered_comm_monoid linarith.comp) := sorry --non-trivial
lemma new_lemma_24892 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @t1_space.{0} (canonically_linear_ordered_monoid.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (canonically_linear_ordered_monoid.{0} pos))  := sorry --non-trivial
lemma new_lemma_24893 (h0 : not (group (linear_ordered_add_comm_group linarith.comp_source) -> false)) : @group.fg.{0} (linear_ordered_add_comm_group.{0} linarith.comp_source) (@classical.by_contradiction'.{1} (group.{0} (linear_ordered_add_comm_group.{0} linarith.comp_source)) h0)  := sorry --non-trivial
lemma new_lemma_24894 (h0 : functor.add_const (list (comm_group environment.implicit_infer_kind)) Type) : palindrome (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_24895 (h3 : topological_space (uniform_space char)) : path_connected_space (uniform_space char) := sorry --non-trivial
lemma new_lemma_24896 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_cyclic.{0} (denumerable.{0} real) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (denumerable.{0} real))  := sorry --non-trivial
lemma new_lemma_24897 (h0 : ordered_add_comm_monoid (has_pos_part Type)) : archimedean (has_pos_part Type) := sorry --non-trivial
lemma new_lemma_24898 (h0 : functor.add_const (topological_space (comm_group name)) Type) : @path_connected_space.{0} (comm_group.{0} name) (@functor.add_const.run.{0 1} (topological_space.{0} (comm_group.{0} name)) Type h0)  := sorry --non-trivial
lemma new_lemma_24899 (h0 : complete_lattice (add_group (semiring (semiring unsigned)))) : is_atomistic (add_group (semiring (semiring unsigned))) := sorry --non-trivial
lemma new_lemma_24900 (h0 : function.extfun Type monoid) : @monoid.fg.{0} (measurable_space.dynkin_system.{0} empty) (@function.extfun_app.{2 1} Type monoid.{0} h0 (measurable_space.dynkin_system.{0} empty))  := sorry --non-trivial
lemma new_lemma_24901 (h0 : has_lt (has_compl environment.implicit_infer_kind)) : no_max_order (has_compl environment.implicit_infer_kind) := sorry --non-trivial
lemma new_lemma_24902 (h0 : functor.add_const (group (has_neg pos)) linarith.comp) : @group.fg.{0} (has_neg.{0} pos) (@functor.add_const.run.{0 0} (group.{0} (has_neg.{0} pos)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_24903 (h0 : complete_lattice (has_compl (has_nnnorm linarith.ineq))) : is_compactly_generated (has_compl (has_nnnorm linarith.ineq)) := sorry --non-trivial
lemma new_lemma_24904 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @archimedean.{0} (as_linear_order.{0} unsigned) (@functor.add_const.run.{0 0} (ordered_add_comm_monoid.{0} (as_linear_order.{0} unsigned)) (option.{0} (option.{0} empty)) (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (ordered_add_comm_monoid.{0} (as_linear_order.{0} unsigned))) (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 (functor.add_const.{0 0} (ordered_add_comm_monoid.{0} (as_linear_order.{0} unsigned)))) (option.{0} (option.{0} empty))))  := sorry --non-trivial
lemma new_lemma_24905 (h0 : functor.add_const (group (mul_zero_class pos)) pos) : @is_simple_group.{0} (mul_zero_class.{0} pos) (@functor.add_const.run.{0 0} (group.{0} (mul_zero_class.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_24906 (h0 : topological_space (add_right_cancel_monoid (option empty))) : t0_space (add_right_cancel_monoid (option empty)) := sorry --non-trivial
lemma new_lemma_24907 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @complete_lattice.is_Sup_finite_compact.{0} (normed_group.{0} (has_top.{0} (has_top.{0} fun_info))) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (normed_group.{0} (has_top.{0} (has_top.{0} fun_info))))  := sorry --non-trivial
lemma new_lemma_24908 (h0 : function.extfun (finset Type) (has_mem.mem (random_gen congr_arg_kind))) : @totally_disconnected_space.{0} (random_gen.{0} congr_arg_kind) (@finset.pi.empty.{1 0} Type topological_space.{0} (random_gen.{0} congr_arg_kind) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (random_gen.{0} congr_arg_kind)) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_24909 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @unique_factorization_monoid.{0} (normed_comm_ring.{0} unsigned) (@function.extfun_app.{2 1} Type cancel_comm_monoid_with_zero.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 cancel_comm_monoid_with_zero.{0}) (normed_comm_ring.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_24910 (h0 : functor.add_const (fin has_zero.zero) real) : @has_exists_mul_of_le.{0} (comm_semigroup.{0} linarith.comp) (@matrix.vec_empty.{0} (ordered_comm_monoid.{0} (comm_semigroup.{0} linarith.comp)) (@functor.add_const.run.{0 0} (fin (@has_zero.zero.{0} nat nat.has_zero)) real h0))  := sorry --non-trivial
lemma new_lemma_24911 (h0 : functor.add_const (topological_space (boolean_algebra unsigned)) Type) : @path_connected_space.{0} (boolean_algebra.{0} unsigned) (@functor.add_const.run.{0 1} (topological_space.{0} (boolean_algebra.{0} unsigned)) Type h0)  := sorry --non-trivial
lemma new_lemma_24912 (h0 : topological_space (bin_tree (semiring congr_arg_kind))) : totally_disconnected_space (bin_tree (semiring congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_24913 (h0 : ring (linear_ordered_comm_group (option (option empty)))) : is_principal_ideal_ring (linear_ordered_comm_group (option (option empty))) := sorry --non-trivial
lemma new_lemma_24914 (h0 : ordered_comm_monoid (add_cancel_monoid (finset (finset (finset pos))))) : has_exists_mul_of_le (add_cancel_monoid (finset (finset (finset pos)))) := sorry --non-trivial
lemma new_lemma_24915 (h0 : not (has_mem.mem num has_emptyc.emptyc -> false)) : @is_compactly_generated.{0} num (@finset.pi.empty.{1 0} Type complete_lattice.{0} num (@classical.by_contradiction'.{0} (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) num (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))) h0))  := sorry --non-trivial
lemma new_lemma_24916 (h0 : functor.add_const (complete_lattice (add_cancel_monoid Type)) linarith.comp) : @complete_lattice.is_Sup_finite_compact.{1} (add_cancel_monoid.{1} Type) (@functor.add_const.run.{1 0} (complete_lattice.{1} (add_cancel_monoid.{1} Type)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_24917 (h1 : topological_space (random_gen (topological_space char))) : t0_space (random_gen (topological_space char)) := sorry --non-trivial
lemma new_lemma_24918 (h0 : functor.comp group semigroup (has_add name)) : @normalizer_condition.{0} (semigroup.{0} (has_add.{0} name)) (@functor.comp.run.{0 0 0} group.{0} semigroup.{0} (has_add.{0} name) h0)  := sorry --non-trivial
lemma new_lemma_24919 (h0 : function.extfun Type ring) : @is_domain.{0} (has_inter.{0} empty) (@function.extfun_app.{2 1} Type ring.{0} h0 (has_inter.{0} empty))  := sorry --non-trivial
lemma new_lemma_24920 (h0 : filter (with_one char)) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_24921 (h0 : topological_space (ring (semigroup name))) : locally_compact_space (ring (semigroup name)) := sorry --non-trivial
lemma new_lemma_24922 (h0 : uniform_space (finset (finset Type))) : complete_space (finset (finset Type)) := sorry --non-trivial
lemma new_lemma_24923 (h0 : topological_space (simple_graph num)) : normal_space (simple_graph num) := sorry --non-trivial
lemma new_lemma_24924 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_domain.{0} (with_one.{0} empty) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (with_one.{0} empty))  := sorry --non-trivial
lemma new_lemma_24925 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @locally_compact_space.{0} (comm_ring.{0} char) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (comm_ring.{0} char))  := sorry --non-trivial
lemma new_lemma_24926 (h1 : complete_lattice (with_bot linarith.ineq)) : is_compactly_generated (with_bot linarith.ineq) := sorry --non-trivial
lemma new_lemma_24927 (h0 : list (has_neg_part (mul_zero_class name))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_24928 (h2 : uniform_space (has_ssubset to_additive.value_type)) : complete_space (has_ssubset to_additive.value_type) := sorry --non-trivial
lemma new_lemma_24929 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @path_connected_space.{0} (with_bot.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (with_bot.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_24930 (h0 : topological_space (boolean_algebra.core environment.implicit_infer_kind)) : path_connected_space (boolean_algebra.core environment.implicit_infer_kind) := sorry --non-trivial
lemma new_lemma_24931 (h0 : function.extfun Type group) : @group.fg.{0} (has_nndist.{0} pos) (@function.extfun_app.{2 1} Type group.{0} h0 (has_nndist.{0} pos))  := sorry --non-trivial
lemma new_lemma_24932 (h0 : not (uniform_space (has_nnnorm reducibility_hints) -> false)) : @complete_space.{0} (has_nnnorm.{0} reducibility_hints) (@classical.by_contradiction'.{1} (uniform_space.{0} (has_nnnorm.{0} reducibility_hints)) h0)  := sorry --non-trivial
lemma new_lemma_24933 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_add_cyclic.{0} (measurable_space.dynkin_system.{0} (option.{0} unsigned)) (@function.extfun_app.{2 1} Type add_group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 add_group.{0}) (measurable_space.dynkin_system.{0} (option.{0} unsigned)))  := sorry --non-trivial
lemma new_lemma_24934 (h0 : group (complete_distrib_lattice (has_Inf (has_add (finset (finset (has_Inf (has_add pos)))))))) : is_cyclic (complete_distrib_lattice (has_Inf (has_add (finset (finset (has_Inf (has_add pos))))))) := sorry --non-trivial
lemma new_lemma_24935 (h0 : topological_space (finset (boolean_algebra (boolean_algebra Type)))) : normal_space (finset (boolean_algebra (boolean_algebra Type))) := sorry --non-trivial
lemma new_lemma_24936 (h0 : topological_space (partial_order (semiring unsigned))) : discrete_topology (partial_order (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_24937 (h0 : topological_space (canonically_ordered_comm_semiring (has_add unsigned))) : sequential_space (canonically_ordered_comm_semiring (has_add unsigned)) := sorry --non-trivial
lemma new_lemma_24938 (h0 : topological_space (finset (has_Inf (boolean_algebra Type)))) : t1_space (finset (has_Inf (boolean_algebra Type))) := sorry --non-trivial
lemma new_lemma_24939 (h0 : topological_space (complete_distrib_lattice (has_add pos))) : normal_space (complete_distrib_lattice (has_add pos)) := sorry --non-trivial
lemma new_lemma_24940 (h0 : ring (finset (option ennreal))) : strong_rank_condition (finset (option ennreal)) := sorry --non-trivial
lemma new_lemma_24941 (h0 : filter (left_cancel_semigroup (semiring (semiring unsigned)))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_24942 (h0 : topological_space (has_norm (has_inv (random_gen fun_info)))) : irreducible_space (has_norm (has_inv (random_gen fun_info))) := sorry --non-trivial
lemma new_lemma_24943 (h0 : functor.comp topological_space has_nndist Type) : @normal_space.{1} (has_nndist.{1} Type) (@functor.comp.run.{1 1 1} topological_space.{1} has_nndist.{1} Type h0)  := sorry --non-trivial
lemma new_lemma_24944 (h0 : function.extfun Type list) : list.nodup (function.extfun_app h0 (has_to_string name)) := sorry --non-trivial
lemma new_lemma_24945 (h0 : topological_space (random_gen (has_inv (has_inv (has_inv string_imp))))) : irreducible_space (random_gen (has_inv (has_inv (has_inv string_imp)))) := sorry --non-trivial
lemma new_lemma_24946 (h0 : complete_lattice (complete_distrib_lattice (finset name))) : is_atomistic (complete_distrib_lattice (finset name)) := sorry --non-trivial
lemma new_lemma_24947 (h0 : monoid (encodable fun_info)) : monoid.exponent_exists (encodable fun_info) := sorry --non-trivial
lemma new_lemma_24948 (h0 : functor.add_const (ring (finset pos)) (has_neg Type)) : @rank_condition.{0} (finset.{0} pos) (@functor.add_const.run.{0 1} (ring.{0} (finset.{0} pos)) (has_neg.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_24949 (h0 h1 : int) : int.le h0 h1 := sorry --non-trivial
lemma new_lemma_24950 (h0 : function.extfun Type cancel_comm_monoid_with_zero) : @unique_factorization_monoid.{0} (group_with_zero.{0} num) (@function.extfun_app.{2 1} Type cancel_comm_monoid_with_zero.{0} h0 (group_with_zero.{0} num))  := sorry --non-trivial
lemma new_lemma_24951 (h0 : topological_space (linear_ordered_add_comm_group (comm_ring linarith.ineq))) : path_connected_space (linear_ordered_add_comm_group (comm_ring linarith.ineq)) := sorry --non-trivial
lemma new_lemma_24952 (h0 : functor.add_const (group (has_zero name)) Type) : @normalizer_condition.{0} (has_zero.{0} name) (@functor.add_const.run.{0 1} (group.{0} (has_zero.{0} name)) Type h0)  := sorry --non-trivial
lemma new_lemma_24953 (h0 : functor.add_const (ring (generalized_boolean_algebra pos)) linarith.comp) : @is_domain.{0} (generalized_boolean_algebra.{0} pos) (@functor.add_const.run.{0 0} (ring.{0} (generalized_boolean_algebra.{0} pos)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_24954 (h0 : functor.add_const (ring (has_neg_part name)) environment.implicit_infer_kind) : @is_domain.{0} (has_neg_part.{0} name) (@functor.add_const.run.{0 0} (ring.{0} (has_neg_part.{0} name)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_24955 (h0 : topological_space (canonically_ordered_comm_semiring congr_arg_kind)) : loc_path_connected_space (canonically_ordered_comm_semiring congr_arg_kind) := sorry --non-trivial
lemma new_lemma_24956 (h0 : functor.add_const (ordered_add_comm_monoid (has_nndist name)) linarith.comp) : @archimedean.{0} (has_nndist.{0} name) (@functor.add_const.run.{0 0} (ordered_add_comm_monoid.{0} (has_nndist.{0} name)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_24957 (h0 : topological_space (dlist (linear_ordered_add_comm_group linarith.comp_source))) : totally_disconnected_space (dlist (linear_ordered_add_comm_group linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_24958 (h0 : uniform_space (has_bot (has_add pos))) : separated_space (has_bot (has_add pos)) := sorry --non-trivial
lemma new_lemma_24959 (h0 : ring (has_Inf name)) : is_principal_ideal_ring (has_Inf name) := sorry --non-trivial
lemma new_lemma_24960 (h0 : topological_space (has_pos_part (has_Inf linarith.comp))) : normal_space (has_pos_part (has_Inf linarith.comp)) := sorry --non-trivial
lemma new_lemma_24961 (h0 : topological_space (normed_field (has_nnnorm string.iterator_imp))) : t0_space (normed_field (has_nnnorm string.iterator_imp)) := sorry --non-trivial
lemma new_lemma_24962 (h2 : ring (dlist linarith.ineq)) : rank_condition (dlist linarith.ineq) := sorry --non-trivial
lemma new_lemma_24963 (h0 : functor.add_const (topological_space (is_R_or_C unsigned)) empty) : @normal_space.{0} (is_R_or_C.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (is_R_or_C.{0} unsigned)) empty h0)  := sorry --non-trivial
lemma new_lemma_24964 (h0 : not (ring (has_append to_additive.value_type) -> false)) : @is_domain.{0} (has_append.{0} to_additive.value_type) (@classical.by_contradiction'.{1} (ring.{0} (has_append.{0} to_additive.value_type)) h0)  := sorry --non-trivial
lemma new_lemma_24965 (h0 : complete_lattice (with_one (has_norm (has_norm empty)))) : is_atomistic (with_one (has_norm (has_norm empty))) := sorry --non-trivial
lemma new_lemma_24966 (h0 : group (normed_lattice_add_comm_group (has_add Type))) : group.fg (normed_lattice_add_comm_group (has_add Type)) := sorry --non-trivial
lemma new_lemma_24967 (h0 : topological_space (has_ssubset (with_bot string_imp))) : t0_space (has_ssubset (with_bot string_imp)) := sorry --non-trivial
lemma new_lemma_24968 (h2 : topological_space (comm_ring char)) : totally_disconnected_space (comm_ring char) := sorry --non-trivial
lemma new_lemma_24969 (h0 : function.extfun Type topological_space) : @path_connected_space.{0} (distrib_lattice.{0} linarith.ineq) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (distrib_lattice.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_24970 (h0 : function.extfun Type topological_space) : @totally_disconnected_space.{0} (semigroup.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (semigroup.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_24971 (h0 : topological_space (has_norm (has_norm (has_norm (semiring (semiring linarith.comp)))))) : totally_separated_space (has_norm (has_norm (has_norm (semiring (semiring linarith.comp))))) := sorry --non-trivial
lemma new_lemma_24972 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @path_connected_space.{0} (has_add.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_add.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_24973 (h0 : fin has_zero.zero) : @separated_space.{0} (normed_lattice_add_comm_group.{0} name) (@matrix.vec_empty.{0} (uniform_space.{0} (normed_lattice_add_comm_group.{0} name)) h0)  := sorry --non-trivial
lemma new_lemma_24974 (h0 : function.extfun Type (prod (finset pos))) : id_rel (function.extfun_app h0 (finset pos)) := sorry --non-trivial
lemma new_lemma_24975 (h0 : group (has_emptyc (has_norm (random_gen linarith.comp_source)))) : is_cyclic (has_emptyc (has_norm (random_gen linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_24976 (h0 : group (topological_space (comm_ring char))) : is_cyclic (topological_space (comm_ring char)) := sorry --non-trivial
lemma new_lemma_24977 (h0 : function.extfun Type (functor.add_const (uniform_space (add_left_cancel_semigroup empty)))) : @separated_space.{0} (add_left_cancel_semigroup.{0} empty) (@functor.add_const.run.{0 0} (uniform_space.{0} (add_left_cancel_semigroup.{0} empty)) empty (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (uniform_space.{0} (add_left_cancel_semigroup.{0} empty))) h0 empty))  := sorry --non-trivial
lemma new_lemma_24978 (h0 : functor.add_const (uniform_space (has_add linarith.comp)) (finset pos)) : @separated_space.{0} (has_add.{0} linarith.comp) (@functor.add_const.run.{0 0} (uniform_space.{0} (has_add.{0} linarith.comp)) (finset.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_24979 (h0 : group (has_inv (has_nnnorm (has_nnnorm linarith.comp_source)))) : is_cyclic (has_inv (has_nnnorm (has_nnnorm linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_24980 (h0 : function.extfun (Type 1) group) : @group.fg.{1} (has_nndist.{1} Type) (@function.extfun_app.{3 2} (Type 1) group.{1} h0 (has_nndist.{1} Type))  := sorry --non-trivial
lemma new_lemma_24981 (h0 : functor.add_const (complete_lattice (has_Inf pos)) Type) : @is_compactly_generated.{0} (has_Inf.{0} pos) (@functor.add_const.run.{0 1} (complete_lattice.{0} (has_Inf.{0} pos)) Type h0)  := sorry --non-trivial
lemma new_lemma_24982 (h1 : group (distrib char)) : is_cyclic (distrib char) := sorry --non-trivial
lemma new_lemma_24983 (h0 : complete_lattice (non_unital_non_assoc_semiring (has_ssubset char))) : is_compactly_generated (non_unital_non_assoc_semiring (has_ssubset char)) := sorry --non-trivial
lemma new_lemma_24984 (h0 : functor.add_const (filter (normed_comm_ring Type)) linarith.comp) : filter.ne_bot (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_24985 (h1 : filter (complete_semilattice_Sup string_imp)) : filter.ne_bot h1 := sorry --non-trivial
lemma new_lemma_24986 (h0 : complete_lattice (normed_lattice_add_comm_group pos)) : is_atomistic (normed_lattice_add_comm_group pos) := sorry --non-trivial
lemma new_lemma_24987 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @unique_factorization_monoid.{0} (left_cancel_monoid.{0} empty) (@function.extfun_app.{2 1} Type cancel_comm_monoid_with_zero.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 cancel_comm_monoid_with_zero.{0}) (left_cancel_monoid.{0} empty))  := sorry --non-trivial
lemma new_lemma_24988 (h0 : functor.add_const (list (has_add pos)) pos) : list.nodup (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_24989 (h0 : functor.add_const (function.extfun Type ring) pos) : @strong_rank_condition.{0} (add_comm_monoid.{0} pos) (@function.extfun_app.{2 1} Type ring.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type ring.{0}) pos h0) (add_comm_monoid.{0} pos))  := sorry --non-trivial
lemma new_lemma_24990 (h0 : functor.add_const (semiring (option num)) unsigned) : @is_noetherian_ring.{0} (option.{0} num) (@functor.add_const.run.{0 0} (semiring.{0} (option.{0} num)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_24991 (h1 : not (uniform_space (non_unital_non_assoc_semiring string_imp) -> false)) : @complete_space.{0} (non_unital_non_assoc_semiring.{0} string_imp) (@classical.by_contradiction'.{1} (uniform_space.{0} (non_unital_non_assoc_semiring.{0} string_imp)) h1)  := sorry --non-trivial
lemma new_lemma_24992 (h0 : not (function.extfun Type complete_lattice -> false)) : @is_atomistic.{0} (has_norm.{0} empty) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type complete_lattice.{0}) h0) (has_norm.{0} empty))  := sorry --non-trivial
lemma new_lemma_24993 (h0 : ring (cancel_monoid (has_to_string name))) : is_domain (cancel_monoid (has_to_string name)) := sorry --non-trivial
lemma new_lemma_24994 (h0 : not (topological_space (linear_ordered_add_comm_group fun_info) -> false)) : @path_connected_space.{0} (linear_ordered_add_comm_group.{0} fun_info) (@classical.by_contradiction'.{1} (topological_space.{0} (linear_ordered_add_comm_group.{0} fun_info)) h0)  := sorry --non-trivial
lemma new_lemma_24995 (h3 : has_lt (add_comm_semigroup (add_comm_semigroup enat))) : no_max_order (add_comm_semigroup (add_comm_semigroup enat)) := sorry --non-trivial
lemma new_lemma_24996 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_principal_ideal_ring.{0} (add_cancel_monoid.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (add_cancel_monoid.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_24997 (h0 : add_group (complete_semilattice_Sup num)) : is_add_cyclic (complete_semilattice_Sup num) := sorry --non-trivial
lemma new_lemma_24998 (h0 : not (group (normed_group linarith.comp_source) -> false)) : @is_cyclic.{0} (normed_group.{0} linarith.comp_source) (@classical.by_contradiction'.{1} (group.{0} (normed_group.{0} linarith.comp_source)) h0)  := sorry --non-trivial
lemma new_lemma_24999 (h1 : function.extfun Type topological_space) : @irreducible_space.{0} (semiring.{0} string_imp) (@function.extfun_app.{2 1} Type topological_space.{0} h1 (semiring.{0} string_imp))  := sorry --non-trivial
lemma new_lemma_25000 (h0 : functor.add_const (fin has_zero.zero) (ring Type)) : @loc_path_connected_space.{1} (ordered_comm_monoid.{1} Type) (@matrix.vec_empty.{1} (topological_space.{1} (ordered_comm_monoid.{1} Type)) (@functor.add_const.run.{0 1} (fin (@has_zero.zero.{0} nat nat.has_zero)) (ring.{1} Type) h0))  := sorry --non-trivial
lemma new_lemma_25001 (h0 : has_mem.mem (linear_ordered_semiring to_additive.value_type) has_emptyc.emptyc) : @discrete_topology.{0} (linear_ordered_semiring.{0} to_additive.value_type) (@finset.pi.empty.{1 0} Type topological_space.{0} (linear_ordered_semiring.{0} to_additive.value_type) h0)  := sorry --non-trivial
lemma new_lemma_25002 (h0 : topological_space (has_zero (has_to_string (has_add unsigned)))) : preconnected_space (has_zero (has_to_string (has_add unsigned))) := sorry --non-trivial
lemma new_lemma_25003 (h0 : topological_space (has_neg (boolean_algebra Type))) : preconnected_space (has_neg (boolean_algebra Type)) := sorry --non-trivial
lemma new_lemma_25004 (h0 : topological_space (ordered_comm_monoid (has_nndist (has_to_string Type)))) : totally_disconnected_space (ordered_comm_monoid (has_nndist (has_to_string Type))) := sorry --non-trivial
lemma new_lemma_25005 (h0 : functor.add_const (function.extfun Type ordered_add_comm_monoid) Type) : @archimedean.{0} (has_zero.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type ordered_add_comm_monoid.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type ordered_add_comm_monoid.{0}) Type h0) (has_zero.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_25006 (h0 : has_mem.mem (with_bot num) has_emptyc.emptyc) : @group.fg.{0} (with_bot.{0} num) (@finset.pi.empty.{1 0} Type group.{0} (with_bot.{0} num) h0)  := sorry --non-trivial
lemma new_lemma_25007 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : path_connected_space real := sorry --non-trivial
lemma new_lemma_25008 (h0 : topological_space (add_cancel_monoid (finset linarith.comp))) : t1_space (add_cancel_monoid (finset linarith.comp)) := sorry --non-trivial
lemma new_lemma_25009 (h0 : not (group (add_group num) -> false)) : @is_cyclic.{0} (add_group.{0} num) (@classical.by_contradiction'.{1} (group.{0} (add_group.{0} num)) h0)  := sorry --non-trivial
lemma new_lemma_25010 (h0 : not (uniform_space (measurable_space congr_arg_kind) -> false)) : @complete_space.{0} (measurable_space.{0} congr_arg_kind) (@classical.by_contradiction'.{1} (uniform_space.{0} (measurable_space.{0} congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_25011 (h0 : list (cancel_monoid (option unsigned))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_25012 (h0 : ring (has_neg (has_neg_part unsigned))) : is_domain (has_neg (has_neg_part unsigned)) := sorry --non-trivial
lemma new_lemma_25013 (h1 : group (linear_ordered_add_comm_group fun_info)) : normalizer_condition (linear_ordered_add_comm_group fun_info) := sorry --non-trivial
lemma new_lemma_25014 (h0 : topological_space (ordered_comm_monoid (ring (ring (ring Type))))) : path_connected_space (ordered_comm_monoid (ring (ring (ring Type)))) := sorry --non-trivial
lemma new_lemma_25015 (h0 : group (has_pos_part pos)) : normalizer_condition (has_pos_part pos) := sorry --non-trivial
lemma new_lemma_25016 (h0 : topological_space (with_one (has_inv to_additive.value_type))) : totally_separated_space (with_one (has_inv to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_25017 (h0 : topological_space (has_neg_part (has_add (has_add (has_add Type))))) : regular_space (has_neg_part (has_add (has_add (has_add Type)))) := sorry --non-trivial
lemma new_lemma_25018 (h0 : function.extfun Type (functor.add_const (topological_space auto.case_option))) : @normal_space.{0} auto.case_option (@functor.add_const.run.{0 0} (topological_space.{0} auto.case_option) num (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (topological_space.{0} auto.case_option)) h0 num))  := sorry --non-trivial
lemma new_lemma_25019 (h0 : add_group (sub_neg_monoid (has_Inf name))) : is_add_cyclic (sub_neg_monoid (has_Inf name)) := sorry --non-trivial
lemma new_lemma_25020 (h0 : uniform_space (random_gen (random_gen (random_gen linarith.comp_source)))) : complete_space (random_gen (random_gen (random_gen linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_25021 (h0 : ring (metric_space (semiring linarith.comp))) : is_domain (metric_space (semiring linarith.comp)) := sorry --non-trivial
lemma new_lemma_25022 (h0 : cancel_comm_monoid_with_zero (ring (option (option (option pos))))) : unique_factorization_monoid (ring (option (option (option pos)))) := sorry --non-trivial
lemma new_lemma_25023 (h0 : filter (has_add (mul_one_class (mul_one_class linarith.comp)))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_25024 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @normalizer_condition.{0} (generalized_boolean_algebra.{0} pos) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (generalized_boolean_algebra.{0} pos))  := sorry --non-trivial
lemma new_lemma_25025 (h2 : complete_lattice (simple_graph std_gen)) : is_compactly_generated (simple_graph std_gen) := sorry --non-trivial
lemma new_lemma_25026 (h0 : uniform_space (linear_ordered_cancel_comm_monoid empty)) : complete_space (linear_ordered_cancel_comm_monoid empty) := sorry --non-trivial
lemma new_lemma_25027 (h0 : function.extfun Type group) : @normalizer_condition.{0} (has_sub.{0} unsigned) (@function.extfun_app.{2 1} Type group.{0} h0 (has_sub.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_25028 (h0 : fin has_zero.zero) : @separated_space.{0} (generalized_boolean_algebra.{0} real) (@function.extfun_app.{2 1} Type uniform_space.{0} (@matrix.vec_empty.{1} (function.extfun.{2 1} Type uniform_space.{0}) h0) (generalized_boolean_algebra.{0} real))  := sorry --non-trivial
lemma new_lemma_25029 (h0 : topological_space (normed_field (random_gen linarith.comp_source))) : t0_space (normed_field (random_gen linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_25030 (h0 : topological_space (cancel_monoid (option (option (option pos))))) : topological_space.separable_space (cancel_monoid (option (option (option pos)))) := sorry --non-trivial
lemma new_lemma_25031 (h0 : uniform_space (has_pos_part (finset (has_pos_part (finset (finset (finset linarith.comp))))))) : separated_space (has_pos_part (finset (has_pos_part (finset (finset (finset linarith.comp)))))) := sorry --non-trivial
lemma new_lemma_25032 (h0 : function.extfun nat fin) : @is_cyclic.{1} (canonically_ordered_monoid.{1} Type) (@matrix.vec_empty.{1} (group.{1} (canonically_ordered_monoid.{1} Type)) (@matrix.vec_empty.{0} (fin (@has_zero.zero.{0} nat nat.has_zero)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero))))  := sorry --non-trivial
lemma new_lemma_25033 (h0 : complete_lattice (comm_semigroup linarith.comp)) : is_atomistic (comm_semigroup linarith.comp) := sorry --non-trivial
lemma new_lemma_25034 (h0 : filter (ordered_ring unsigned)) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_25035 (h0 : uniform_space (plift (ordered_ring num))) : complete_space (plift (ordered_ring num)) := sorry --non-trivial
lemma new_lemma_25036 (h0 : function.extfun Type topological_space) : @preirreducible_space.{0} (has_bot.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_bot.{0} empty))  := sorry --non-trivial
lemma new_lemma_25037 (h0 : functor.add_const (finset (has_add linarith.comp)) (has_neg Type)) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_25038 (h0 : function.extfun nat fin) : @rank_condition.{0} (has_add.{0} pos) (@function.extfun_app.{2 1} Type ring.{0} (@matrix.vec_empty.{1} (function.extfun.{2 1} Type ring.{0}) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero))) (has_add.{0} pos))  := sorry --non-trivial
lemma new_lemma_25039 (h0 : functor.add_const (topological_space (add_comm_monoid pos)) pos) : @topological_space.separable_space.{0} (add_comm_monoid.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (add_comm_monoid.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_25040 (h0 : cancel_comm_monoid_with_zero (ring (has_Inf name))) : unique_factorization_monoid (ring (has_Inf name)) := sorry --non-trivial
lemma new_lemma_25041 (h0 : finset (has_pos_part name)) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_25042 (h0 : add_monoid (add_cancel_monoid unsigned)) : add_monoid.fg (add_cancel_monoid unsigned) := sorry --non-trivial
lemma new_lemma_25043 (h0 : topological_space (normed_comm_ring (has_to_string pos))) : totally_separated_space (normed_comm_ring (has_to_string pos)) := sorry --non-trivial
lemma new_lemma_25044 (h0 : functor.add_const (ring (complete_distrib_lattice empty)) empty) : @is_domain.{0} (complete_distrib_lattice.{0} empty) (@functor.add_const.run.{0 0} (ring.{0} (complete_distrib_lattice.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_25045 (h0 : topological_space (semi_normed_ring (metric_space char))) : totally_disconnected_space (semi_normed_ring (metric_space char)) := sorry --non-trivial
lemma new_lemma_25046 (h0 : functor.add_const (topological_space (ordered_comm_ring pos)) Type) : @path_connected_space.{0} (ordered_comm_ring.{0} pos) (@functor.add_const.run.{0 1} (topological_space.{0} (ordered_comm_ring.{0} pos)) Type h0)  := sorry --non-trivial
lemma new_lemma_25047 (h0 : list (non_assoc_semiring (option empty))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_25048 (h0 : functor.add_const (topological_space (cancel_monoid Type)) linarith.comp) : @normal_space.{1} (cancel_monoid.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (cancel_monoid.{1} Type)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_25049 (h0 : uniform_space (normed_lattice_add_comm_group (has_pos_part pos))) : separated_space (normed_lattice_add_comm_group (has_pos_part pos)) := sorry --non-trivial
lemma new_lemma_25050 (h0 : topological_space (with_bot to_additive.value_type)) : path_connected_space (with_bot to_additive.value_type) := sorry --non-trivial
lemma new_lemma_25051 (h0 : complete_lattice (has_zero (add_comm_monoid pos))) : is_atomistic (has_zero (add_comm_monoid pos)) := sorry --non-trivial
lemma new_lemma_25052 (h1 : topological_space (non_unital_non_assoc_semiring string_imp)) : t0_space (non_unital_non_assoc_semiring string_imp) := sorry --non-trivial
lemma new_lemma_25053 (h0 : ring (div_inv_monoid (random_gen string_imp))) : strong_rank_condition (div_inv_monoid (random_gen string_imp)) := sorry --non-trivial
lemma new_lemma_25054 (h0 : add_monoid (complete_semilattice_Sup unsigned)) : add_monoid.fg (complete_semilattice_Sup unsigned) := sorry --non-trivial
lemma new_lemma_25055 (h0 : set (has_le (mul_one_class linarith.ineq))) : set.subsingleton h0 := sorry --non-trivial
lemma new_lemma_25056 (h0 : function.extfun Type topological_space) : @t0_space.{0} (add_semigroup.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (add_semigroup.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_25057 (h0 : topological_space (normed_group (random_gen (random_gen fun_info)))) : totally_disconnected_space (normed_group (random_gen (random_gen fun_info))) := sorry --non-trivial
lemma new_lemma_25058 (h1 : list (random_gen string_imp)) : list.nodup h1 := sorry --non-trivial
lemma new_lemma_25059 (h0 : functor.add_const (topological_space (canonically_ordered_comm_semiring ennreal)) num) : @discrete_topology.{0} (canonically_ordered_comm_semiring.{0} ennreal) (@functor.add_const.run.{0 0} (topological_space.{0} (canonically_ordered_comm_semiring.{0} ennreal)) num h0)  := sorry --non-trivial
lemma new_lemma_25060 (h0 : complete_lattice (has_to_string (has_add Type))) : is_atomistic (has_to_string (has_add Type)) := sorry --non-trivial
lemma new_lemma_25061 (h0 : group (comm_group (has_to_string (has_to_string pos)))) : is_simple_group (comm_group (has_to_string (has_to_string pos))) := sorry --non-trivial
lemma new_lemma_25062 (h0 h1 : multiset (has_nnnorm environment.projection_info)) : multiset.subset h0 h1 := sorry --non-trivial
lemma new_lemma_25063 (h0 : complete_lattice (ordered_comm_ring Type)) : complete_lattice.is_Sup_finite_compact (ordered_comm_ring Type) := sorry --non-trivial
lemma new_lemma_25064 (h0 : topological_space (measurable_space (has_top linarith.comp))) : irreducible_space (measurable_space (has_top linarith.comp)) := sorry --non-trivial
lemma new_lemma_25065 (h1 : function.extfun Type list) : list.nodup (function.extfun_app h1 (has_inv string_imp)) := sorry --non-trivial
lemma new_lemma_25066 (h0 : functor.add_const (monoid (normed_comm_ring environment.implicit_infer_kind)) linarith.comp) : @monoid.fg.{0} (normed_comm_ring.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (monoid.{0} (normed_comm_ring.{0} environment.implicit_infer_kind)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_25067 (h0 : function.extfun (finset Type) (has_mem.mem (with_one congr_arg_kind))) : @totally_separated_space.{0} (with_one.{0} congr_arg_kind) (@finset.pi.empty.{1 0} Type topological_space.{0} (with_one.{0} congr_arg_kind) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (with_one.{0} congr_arg_kind)) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_25068 (h0 : not (topological_space linarith.comp -> false)) : @discrete_topology.{0} linarith.comp (@classical.by_contradiction'.{1} (topological_space.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_25069 (h0 : list (boolean_algebra (boolean_algebra.core environment.implicit_infer_kind))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_25070 (h0 : ordered_add_comm_monoid (has_edist (option empty))) : archimedean (has_edist (option empty)) := sorry --non-trivial
lemma new_lemma_25071 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_cyclic.{0} (topological_space.{0} fun_info) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (topological_space.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_25072 (h0 : nat) (h1 : bool) (h2 : not (ring (fin (padic_val_nat h0 (bool.to_nat h1))) -> false)) : @strong_rank_condition.{0} (fin (padic_val_nat h0 (bool.to_nat h1))) (@classical.by_contradiction'.{1} (ring.{0} (fin (padic_val_nat h0 (bool.to_nat h1)))) h2)  := sorry --non-trivial
lemma new_lemma_25073 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @strong_rank_condition.{0} (canonically_ordered_monoid.{0} real) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (canonically_ordered_monoid.{0} real))  := sorry --non-trivial
lemma new_lemma_25074 (h0 : ring (has_union (has_norm (semiring num)))) : is_domain (has_union (has_norm (semiring num))) := sorry --non-trivial
lemma new_lemma_25075 (h0 : topological_space (semiring (semiring linarith.comp))) : totally_separated_space (semiring (semiring linarith.comp)) := sorry --non-trivial
lemma new_lemma_25076 (h0 : group (has_Inf (has_Inf Type))) : is_simple_group (has_Inf (has_Inf Type)) := sorry --non-trivial
lemma new_lemma_25077 (h0 : group (canonically_linear_ordered_monoid (option ennreal))) : group.fg (canonically_linear_ordered_monoid (option ennreal)) := sorry --non-trivial
lemma new_lemma_25078 (h0 : functor.add_const (list (ring environment.implicit_infer_kind)) pos) : list.nodup (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_25079 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @path_connected_space.{0} (denumerable.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (denumerable.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_25080 (h0 : group (has_append (has_nnnorm char))) : is_cyclic (has_append (has_nnnorm char)) := sorry --non-trivial
lemma new_lemma_25081 (h0 : add_monoid (has_star num)) : add_monoid.fg (has_star num) := sorry --non-trivial
lemma new_lemma_25082 (h0 : filter (semigroup (finset Type))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_25083 (h0 : functor.add_const (topological_space (complete_distrib_lattice unsigned)) empty) : @loc_path_connected_space.{0} (complete_distrib_lattice.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (complete_distrib_lattice.{0} unsigned)) empty h0)  := sorry --non-trivial
lemma new_lemma_25084 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @group.fg.{0} (has_inv.{0} fun_info) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (has_inv.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_25085 (h0 : function.extfun Type topological_space) : @irreducible_space.{0} (has_inter.{0} ennreal) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_inter.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_25086 (h0 : filter (complete_linear_order (semiring (semiring (semiring (semiring (semiring num))))))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_25087 (h0 : not (semiring (has_star congr_arg_kind) -> false)) : @is_noetherian_ring.{0} (has_star.{0} congr_arg_kind) (@classical.by_contradiction'.{1} (semiring.{0} (has_star.{0} congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_25088 (h0 : topological_space (comm_ring (has_ssubset linarith.ineq))) : irreducible_space (comm_ring (has_ssubset linarith.ineq)) := sorry --non-trivial
lemma new_lemma_25089 (h0 : not (ring (mul_zero_class num) -> false)) : @is_principal_ideal_ring.{0} (mul_zero_class.{0} num) (@classical.by_contradiction'.{1} (ring.{0} (mul_zero_class.{0} num)) h0)  := sorry --non-trivial
lemma new_lemma_25090 (h1 : uniform_space (normed_field (random_gen (random_gen char))) -> has_nnnorm (has_nnnorm char)) (h2 : coe_sort (set.range h1)) : @complete_space.{0} (normed_field.{0} (random_gen.{0} (random_gen.{0} char))) (@set.range_splitting.{0 0} (uniform_space.{0} (normed_field.{0} (random_gen.{0} (random_gen.{0} char)))) (has_nnnorm.{0} (has_nnnorm.{0} char)) h1 h2)  := sorry --non-trivial
lemma new_lemma_25091 (h0 : functor.comp ring semigroup pos) : @is_domain.{0} (semigroup.{0} pos) (@functor.comp.run.{0 0 0} ring.{0} semigroup.{0} pos h0)  := sorry --non-trivial
lemma new_lemma_25092 (h0 : functor.add_const (function.extfun Type ring) linarith.comp) : @is_principal_ideal_ring.{0} (boolean_algebra.{0} linarith.comp) (@function.extfun_app.{2 1} Type ring.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type ring.{0}) linarith.comp h0) (boolean_algebra.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_25093 (h0 : function.extfun (finset Type) (has_mem.mem (has_top congr_arg_kind))) : @irreducible_space.{0} (has_top.{0} congr_arg_kind) (@finset.pi.empty.{1 0} Type topological_space.{0} (has_top.{0} congr_arg_kind) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (has_top.{0} congr_arg_kind)) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_25094 (h0 : add_monoid (finset (boolean_algebra (has_neg environment.implicit_infer_kind)))) : add_monoid.fg (finset (boolean_algebra (has_neg environment.implicit_infer_kind))) := sorry --non-trivial
lemma new_lemma_25095 (h0 : topological_space (bin_tree (semiring (semiring num)))) : locally_compact_space (bin_tree (semiring (semiring num))) := sorry --non-trivial
lemma new_lemma_25096 (h0 : topological_space (distrib (has_nnnorm (mul_one_class linarith.ineq)))) : path_connected_space (distrib (has_nnnorm (mul_one_class linarith.ineq))) := sorry --non-trivial
lemma new_lemma_25097 (h0 : function.extfun Type topological_space) : @locally_compact_space.{0} (linear_ordered_comm_group.{0} ennreal) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (linear_ordered_comm_group.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_25098 (h0 : add_group (ordered_comm_ring (has_add pos))) : is_add_cyclic (ordered_comm_ring (has_add pos)) := sorry --non-trivial
lemma new_lemma_25099 (h0 : group (random_gen (has_one (has_one (semiring num))))) : group.fg (random_gen (has_one (has_one (semiring num)))) := sorry --non-trivial
lemma new_lemma_25100 (h0 : functor.add_const (topological_space (canonically_ordered_comm_semiring pos)) name) : @topological_space.separable_space.{0} (canonically_ordered_comm_semiring.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (canonically_ordered_comm_semiring.{0} pos)) name h0)  := sorry --non-trivial
lemma new_lemma_25101 (h0 : ring (normed_comm_ring (finset linarith.comp))) : rank_condition (normed_comm_ring (finset linarith.comp)) := sorry --non-trivial
lemma new_lemma_25102 (h0 : topological_space (has_union (has_norm unsigned))) : irreducible_space (has_union (has_norm unsigned)) := sorry --non-trivial
lemma new_lemma_25103 (h0 : semiring (pseudo_metric_space ennreal)) : is_noetherian_ring (pseudo_metric_space ennreal) := sorry --non-trivial
lemma new_lemma_25104 (h0 : group (has_Inf (ordered_comm_monoid pos))) : is_simple_group (has_Inf (ordered_comm_monoid pos)) := sorry --non-trivial
lemma new_lemma_25105 (h0 : topological_space (metric_space (semiring congr_arg_kind))) : totally_separated_space (metric_space (semiring congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_25106 (h0 : function.extfun Type (functor.add_const (add_group (normed_linear_ordered_group unsigned)))) : @is_add_cyclic.{0} (normed_linear_ordered_group.{0} unsigned) (@functor.add_const.run.{0 0} (add_group.{0} (normed_linear_ordered_group.{0} unsigned)) empty (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (add_group.{0} (normed_linear_ordered_group.{0} unsigned))) h0 empty))  := sorry --non-trivial
lemma new_lemma_25107 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_add_cyclic.{0} (has_add.{0} unsigned) (@function.extfun_app.{2 1} Type add_group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 add_group.{0}) (has_add.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_25108 (h0 : topological_space (comm_group (finset (finset Type)))) : sequential_space (comm_group (finset (finset Type))) := sorry --non-trivial
lemma new_lemma_25109 (h0 : topological_space (with_bot (has_top fun_info))) : totally_disconnected_space (with_bot (has_top fun_info)) := sorry --non-trivial
lemma new_lemma_25110 (h0 : topological_space (has_norm fun_info)) : locally_compact_space (has_norm fun_info) := sorry --non-trivial
lemma new_lemma_25111 (h0 : topological_space (mul_one_class (add_comm_semigroup environment.projection_info))) : path_connected_space (mul_one_class (add_comm_semigroup environment.projection_info)) := sorry --non-trivial
lemma new_lemma_25112 (h0 : group (has_repr (random_gen empty))) : normalizer_condition (has_repr (random_gen empty)) := sorry --non-trivial
lemma new_lemma_25113 (h0 : ring (with_one (has_top to_additive.value_type))) : rank_condition (with_one (has_top to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_25114 (h0 : functor.add_const (topological_space (add_comm_monoid unsigned)) linarith.comp) : @t1_space.{0} (add_comm_monoid.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (add_comm_monoid.{0} unsigned)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_25115 (h0 : topological_space (non_assoc_semiring congr_arg_kind)) : loc_path_connected_space (non_assoc_semiring congr_arg_kind) := sorry --non-trivial
lemma new_lemma_25116 (h0 : group (id num)) : group.fg (id num) := sorry --non-trivial
lemma new_lemma_25117 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @locally_compact_space.{0} fun_info (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) fun_info)  := sorry --non-trivial
lemma new_lemma_25118 (h0 : not (complete_lattice (measure_theory.measure_space congr_arg_kind) -> false)) : @is_atomistic.{0} (measure_theory.measure_space.{0} congr_arg_kind) (@classical.by_contradiction'.{1} (complete_lattice.{0} (measure_theory.measure_space.{0} congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_25119 (h0 : uniform_space (uniform_space (comm_ring linarith.comp_source))) : complete_space (uniform_space (comm_ring linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_25120 (h0 : topological_space (has_union (has_norm congr_arg_kind))) : discrete_topology (has_union (has_norm congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_25121 (h0 : group (normed_lattice_add_comm_group name)) : is_simple_group (normed_lattice_add_comm_group name) := sorry --non-trivial
lemma new_lemma_25122 (h0 : monoid (omega_complete_partial_order num)) : monoid.fg (omega_complete_partial_order num) := sorry --non-trivial
lemma new_lemma_25123 (h0 : group (has_top (has_top to_additive.value_type))) : is_cyclic (has_top (has_top to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_25124 (h0 : topological_space (topological_space (comm_ring reducibility_hints))) : t0_space (topological_space (comm_ring reducibility_hints)) := sorry --non-trivial
lemma new_lemma_25125 (h0 : not (complete_lattice unsigned -> false)) : @complete_lattice.is_Sup_finite_compact.{0} unsigned (@classical.by_contradiction'.{1} (complete_lattice.{0} unsigned) h0)  := sorry --non-trivial
lemma new_lemma_25126 (h0 : functor.add_const (function.extfun Type ring) Type) : @is_principal_ideal_ring.{0} (boolean_algebra.{0} name) (@function.extfun_app.{2 1} Type ring.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type ring.{0}) Type h0) (boolean_algebra.{0} name))  := sorry --non-trivial
lemma new_lemma_25127 (h0 : not (function.extfun (Type -> Type) (function.extfun Type) -> false)) : @complete_lattice.is_Sup_finite_compact.{0} (complete_linear_order.{0} empty) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) (@classical.by_contradiction'.{2} (function.extfun.{2 2} (Type → Type) (function.extfun.{2 1} Type)) h0) complete_lattice.{0}) (complete_linear_order.{0} empty))  := sorry --non-trivial
lemma new_lemma_25128 (h0 : functor.add_const (ring (has_zero unsigned)) environment.implicit_infer_kind) : @is_principal_ideal_ring.{0} (has_zero.{0} unsigned) (@functor.add_const.run.{0 0} (ring.{0} (has_zero.{0} unsigned)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_25129 (h0 : ordered_add_comm_monoid (has_neg (has_to_string (has_to_string (has_add unsigned))))) : archimedean (has_neg (has_to_string (has_to_string (has_add unsigned)))) := sorry --non-trivial
lemma new_lemma_25130 (h0 : has_neg (normed_field char)) (h1 : measurable_space (normed_field char)) : has_measurable_neg (normed_field char) := sorry --non-trivial
lemma new_lemma_25131 (h0 : function.extfun Type filter) : filter.ne_bot (function.extfun_app h0 empty) := sorry --non-trivial
lemma new_lemma_25132 (h0 : ring (monoid congr_arg_kind)) : strong_rank_condition (monoid congr_arg_kind) := sorry --non-trivial
lemma new_lemma_25133 (h0 : ring (nondiscrete_normed_field (mul_one_class (mul_one_class string.iterator_imp)))) : is_domain (nondiscrete_normed_field (mul_one_class (mul_one_class string.iterator_imp))) := sorry --non-trivial
lemma new_lemma_25134 (h0 : function.extfun Type topological_space) : @totally_disconnected_space.{0} (has_bot.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_bot.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_25135 (h1 : not (filter (denumerable char) -> false)) : filter.ne_bot (classical.by_contradiction' h1) := sorry --non-trivial
lemma new_lemma_25136 (h0 : functor.add_const Prop (has_add (finset (finset (finset (finset ennreal)))))) : functor.add_const.run h0 := sorry --non-trivial
lemma new_lemma_25137 (h0 : topological_space (has_Sup (semiring empty))) : normal_space (has_Sup (semiring empty)) := sorry --non-trivial
lemma new_lemma_25138 (h0 : uniform_space (ordered_comm_ring (has_add Type))) : complete_space (ordered_comm_ring (has_add Type)) := sorry --non-trivial
lemma new_lemma_25139 (h0 : function.extfun Type ordered_add_comm_monoid) : @archimedean.{0} (ordered_cancel_add_comm_monoid.{0} pos) (@function.extfun_app.{2 1} Type ordered_add_comm_monoid.{0} h0 (ordered_cancel_add_comm_monoid.{0} pos))  := sorry --non-trivial
lemma new_lemma_25140 (h0 : filter (has_Inf (has_neg name))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_25141 (h1 : group (semiring (has_top (has_norm fun_info)))) : is_cyclic (semiring (has_top (has_norm fun_info))) := sorry --non-trivial
lemma new_lemma_25142 (h0 : function.extfun Type group) : @normalizer_condition.{0} (linear_order.{0} (option.{0} empty)) (@function.extfun_app.{2 1} Type group.{0} h0 (linear_order.{0} (option.{0} empty)))  := sorry --non-trivial
lemma new_lemma_25143 (h0 : functor.add_const (finset (free_add_monoid unsigned)) unsigned) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_25144 (h0 : add_monoid (with_bot (semiring (linear_ordered_semiring (semiring congr_arg_kind))))) : add_monoid.fg (with_bot (semiring (linear_ordered_semiring (semiring congr_arg_kind)))) := sorry --non-trivial
lemma new_lemma_25145 (h0 : ordered_add_comm_monoid (has_edist (semiring unsigned))) : archimedean (has_edist (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_25146 (h0 : functor.add_const (topological_space (complete_distrib_lattice Type)) Type) : @totally_disconnected_space.{1} (complete_distrib_lattice.{1} Type) (@functor.add_const.run.{1 1} (topological_space.{1} (complete_distrib_lattice.{1} Type)) Type h0)  := sorry --non-trivial
lemma new_lemma_25147 (h0 : group (normed_field (mul_one_class reducibility_hints))) : is_cyclic (normed_field (mul_one_class reducibility_hints)) := sorry --non-trivial
lemma new_lemma_25148 (h0 : ring (has_neg (has_add Type))) : strong_rank_condition (has_neg (has_add Type)) := sorry --non-trivial
lemma new_lemma_25149 (h0 : function.extfun Type (functor.add_const (finset ennreal))) : finset.nonempty (functor.add_const.run (function.extfun_app h0 ennreal)) := sorry --non-trivial
lemma new_lemma_25150 (h0 : not (function.extfun Type ring -> false)) : @rank_condition.{0} (complete_semilattice_Sup.{0} num) (@function.extfun_app.{2 1} Type ring.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type ring.{0}) h0) (complete_semilattice_Sup.{0} num))  := sorry --non-trivial
lemma new_lemma_25151 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @loc_path_connected_space.{1} (generalized_boolean_algebra.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 topological_space.{1}) (generalized_boolean_algebra.{1} Type))  := sorry --non-trivial
lemma new_lemma_25152 (h0 : topological_space (finset (option ennreal))) : t0_space (finset (option ennreal)) := sorry --non-trivial
lemma new_lemma_25153 (h0 : topological_space (boolean_algebra.core (finset (has_pos_part (has_add pos))))) : preirreducible_space (boolean_algebra.core (finset (has_pos_part (has_add pos)))) := sorry --non-trivial
lemma new_lemma_25154 (h0 : function.extfun Type (functor.add_const (list (free_add_monoid congr_arg_kind)))) : palindrome (functor.add_const.run (function.extfun_app h0 (semiring empty))) := sorry --non-trivial
lemma new_lemma_25155 (h1 : ring (normed_group congr_arg_kind)) : is_domain (normed_group congr_arg_kind) := sorry --non-trivial
lemma new_lemma_25156 (h0 : ring (mul_one_class (mul_one_class (mul_one_class char)))) : is_domain (mul_one_class (mul_one_class (mul_one_class char))) := sorry --non-trivial
lemma new_lemma_25157 (h0 : add_group (add_group (semiring num))) : is_add_cyclic (add_group (semiring num)) := sorry --non-trivial
lemma new_lemma_25158 (h0 : functor.add_const (add_monoid (linear_ordered_comm_monoid_with_zero empty)) unsigned) : @add_monoid.fg.{0} (linear_ordered_comm_monoid_with_zero.{0} empty) (@functor.add_const.run.{0 0} (add_monoid.{0} (linear_ordered_comm_monoid_with_zero.{0} empty)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_25159 (h0 : list (omega_complete_partial_order (option empty))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_25160 (h0 : function.extfun Type semiring) : is_noetherian_ring nnreal := sorry --non-trivial
lemma new_lemma_25161 (h0 : topological_space (sub_neg_monoid linarith.comp)) : irreducible_space (sub_neg_monoid linarith.comp) := sorry --non-trivial
lemma new_lemma_25162 (h0 : group (has_to_string (has_add name))) : is_simple_group (has_to_string (has_add name)) := sorry --non-trivial
lemma new_lemma_25163 (h0 : functor.add_const (monoid (complete_distrib_lattice environment.implicit_infer_kind)) Type) : @monoid.fg.{0} (complete_distrib_lattice.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 1} (monoid.{0} (complete_distrib_lattice.{0} environment.implicit_infer_kind)) Type h0)  := sorry --non-trivial
lemma new_lemma_25164 (h0 : topological_space (id (random_gen (with_bot string_imp)))) : totally_separated_space (id (random_gen (with_bot string_imp))) := sorry --non-trivial
lemma new_lemma_25165 (h0 : ring (topological_space reducibility_hints)) : strong_rank_condition (topological_space reducibility_hints) := sorry --non-trivial
lemma new_lemma_25166 (h0 : topological_space (has_bot (has_Inf pos))) : t0_space (has_bot (has_Inf pos)) := sorry --non-trivial
lemma new_lemma_25167 (h1 : filter (dlist linarith.comp_source)) : filter.ne_bot h1 := sorry --non-trivial
lemma new_lemma_25168 (h0 : topological_space (has_neg_part (has_neg_part Type))) : loc_path_connected_space (has_neg_part (has_neg_part Type)) := sorry --non-trivial
lemma new_lemma_25169 (h0 : add_group (has_nndist unsigned)) : is_add_cyclic (has_nndist unsigned) := sorry --non-trivial
lemma new_lemma_25170 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_noetherian_ring.{0} (generalized_boolean_algebra.{0} pos) (@function.extfun_app.{2 1} Type semiring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 semiring.{0}) (generalized_boolean_algebra.{0} pos))  := sorry --non-trivial
lemma new_lemma_25171 (h0 : topological_space (random_gen to_additive.value_type)) : path_connected_space (random_gen to_additive.value_type) := sorry --non-trivial
lemma new_lemma_25172 (h0 : functor.add_const (filter (canonically_linear_ordered_monoid name)) name) : countable_Inter_filter (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_25173 (h0 : function.extfun Type topological_space) : @t0_space.{0} (ordered_cancel_add_comm_monoid.{0} (option.{0} congr_arg_kind)) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (ordered_cancel_add_comm_monoid.{0} (option.{0} congr_arg_kind)))  := sorry --non-trivial
lemma new_lemma_25174 (h0 : monoid (ordered_comm_ring (has_add real))) : monoid.fg (ordered_comm_ring (has_add real)) := sorry --non-trivial
lemma new_lemma_25175 (h0 : add_group (random_gen (with_bot (with_bot to_additive.value_type)))) : is_add_cyclic (random_gen (with_bot (with_bot to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_25176 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_noetherian_ring.{0} (add_cancel_monoid.{0} name) (@function.extfun_app.{2 1} Type semiring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 semiring.{0}) (add_cancel_monoid.{0} name))  := sorry --non-trivial
lemma new_lemma_25177 (h0 : topological_space (boolean_algebra (finset (finset (finset linarith.comp))))) : preconnected_space (boolean_algebra (finset (finset (finset linarith.comp)))) := sorry --non-trivial
lemma new_lemma_25178 (h0 : topological_space (group_with_zero unsigned)) : locally_compact_space (group_with_zero unsigned) := sorry --non-trivial
lemma new_lemma_25179 (h0 : filter (complete_distrib_lattice (has_pos_part (finset (finset pos))))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_25180 (h0 : topological_space (canonically_linear_ordered_monoid num)) : path_connected_space (canonically_linear_ordered_monoid num) := sorry --non-trivial
lemma new_lemma_25181 (h0 : functor.comp topological_space add_comm_monoid name) : @loc_path_connected_space.{0} (add_comm_monoid.{0} name) (@functor.comp.run.{0 0 0} topological_space.{0} add_comm_monoid.{0} name h0)  := sorry --non-trivial
lemma new_lemma_25182 (h0 : functor.add_const (topological_space (has_star num)) empty) : @t1_space.{0} (has_star.{0} num) (@functor.add_const.run.{0 0} (topological_space.{0} (has_star.{0} num)) empty h0)  := sorry --non-trivial
lemma new_lemma_25183 (h0 : group (distrib (mul_one_class fun_info))) : is_cyclic (distrib (mul_one_class fun_info)) := sorry --non-trivial
lemma new_lemma_25184 (h0 : pseudo_metric_space (option unsigned)) (h1 : functor.add_const (monoid (option unsigned)) congr_arg_kind) : @has_lipschitz_mul.{0} (option.{0} unsigned) h0 (@functor.add_const.run.{0 0} (monoid.{0} (option.{0} unsigned)) congr_arg_kind h1)  := sorry --non-trivial
lemma new_lemma_25185 (h0 : not (topological_space (semiring fun_info) -> false)) : @locally_compact_space.{0} (semiring.{0} fun_info) (@classical.by_contradiction'.{1} (topological_space.{0} (semiring.{0} fun_info)) h0)  := sorry --non-trivial
lemma new_lemma_25186 (h0 : complete_lattice (fintype (has_nnnorm fun_info))) : complete_lattice.is_Sup_finite_compact (fintype (has_nnnorm fun_info)) := sorry --non-trivial
lemma new_lemma_25187 (h0 : topological_space (cancel_monoid (comm_group Type))) : discrete_topology (cancel_monoid (comm_group Type)) := sorry --non-trivial
lemma new_lemma_25188 (h0 : fin has_zero.zero) : matrix.vec_empty h0 := sorry --non-trivial
lemma new_lemma_25189 (h0 : topological_space (linear_order unsigned)) : totally_separated_space (linear_order unsigned) := sorry --non-trivial
lemma new_lemma_25190 (h0 : function.extfun Type (functor.add_const (add_monoid pos))) : @add_monoid.fg.{0} pos (@functor.add_const.run.{0 0} (add_monoid.{0} pos) name (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (add_monoid.{0} pos)) h0 name))  := sorry --non-trivial
lemma new_lemma_25191 (h0 : ring (has_neg (has_nndist name))) : strong_rank_condition (has_neg (has_nndist name)) := sorry --non-trivial
lemma new_lemma_25192 (h1 : filter (mv_power_series (random_gen char) char)) : filter.ne_bot h1 := sorry --non-trivial
lemma new_lemma_25193 (h0 : functor.add_const (complete_lattice (has_Sup unsigned)) num) : @complete_lattice.is_Sup_finite_compact.{0} (has_Sup.{0} unsigned) (@functor.add_const.run.{0 0} (complete_lattice.{0} (has_Sup.{0} unsigned)) num h0)  := sorry --non-trivial
lemma new_lemma_25194 (h0 : list (ordered_comm_group (option (option (option (option empty)))))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_25195 (h0 : topological_space (add_comm_semigroup char)) (h1 : preorder (add_comm_semigroup char)) : order_closed_topology (add_comm_semigroup char) := sorry --non-trivial
lemma new_lemma_25196 (h0 : functor.add_const (topological_space (boolean_algebra linarith.comp)) (finset (has_zero (has_zero linarith.comp)))) : @sequential_space.{0} (boolean_algebra.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (boolean_algebra.{0} linarith.comp)) (finset.{0} (has_zero.{0} (has_zero.{0} linarith.comp))) h0)  := sorry --non-trivial
lemma new_lemma_25197 (h0 : complete_lattice (complete_semilattice_Sup (has_inv linarith.comp_source))) : is_atomistic (complete_semilattice_Sup (has_inv linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_25198 (h0 : topological_space (has_bot (sub_neg_monoid real))) : loc_path_connected_space (has_bot (sub_neg_monoid real)) := sorry --non-trivial
lemma new_lemma_25199 (h0 : topological_space (has_pos_part (canonically_ordered_monoid (has_Inf (has_add (has_add real)))))) : preconnected_space (has_pos_part (canonically_ordered_monoid (has_Inf (has_add (has_add real))))) := sorry --non-trivial
lemma new_lemma_25200 (h0 : topological_space (has_to_string (ring (mul_one_class (ring linarith.comp))))) : t1_space (has_to_string (ring (mul_one_class (ring linarith.comp)))) := sorry --non-trivial
lemma new_lemma_25201 (h0 : function.extfun Type (functor.add_const (ordered_add_comm_monoid (free_add_monoid congr_arg_kind)))) : @archimedean.{0} (free_add_monoid.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (ordered_add_comm_monoid.{0} (free_add_monoid.{0} congr_arg_kind)) empty (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (ordered_add_comm_monoid.{0} (free_add_monoid.{0} congr_arg_kind))) h0 empty))  := sorry --non-trivial
lemma new_lemma_25202 (h0 : topological_space (has_nndist (option ennreal))) : loc_path_connected_space (has_nndist (option ennreal)) := sorry --non-trivial
lemma new_lemma_25203 (h0 : finset (has_neg (option congr_arg_kind))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_25204 (h0 : function.extfun Type add_group) : @is_add_cyclic.{0} (canonically_linear_ordered_monoid.{0} name) (@function.extfun_app.{2 1} Type add_group.{0} h0 (canonically_linear_ordered_monoid.{0} name))  := sorry --non-trivial
lemma new_lemma_25205 (h0 : filter (has_neg_part Type)) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_25206 (h0 : topological_space (mul_zero_class (has_neg_part (has_nndist (pseudo_metric_space name))))) : preirreducible_space (mul_zero_class (has_neg_part (has_nndist (pseudo_metric_space name)))) := sorry --non-trivial
lemma new_lemma_25207 (h0 : topological_space (semigroup (ring linarith.comp))) : loc_path_connected_space (semigroup (ring linarith.comp)) := sorry --non-trivial
lemma new_lemma_25208 (h0 : group (boolean_algebra (finset environment.implicit_infer_kind))) : is_simple_group (boolean_algebra (finset environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_25209 (h1 : function.extfun Type topological_space) : @path_connected_space.{0} (semiring.{0} string_imp) (@function.extfun_app.{2 1} Type topological_space.{0} h1 (semiring.{0} string_imp))  := sorry --non-trivial
lemma new_lemma_25210 (h0 : functor.add_const (ordered_add_comm_monoid (ordered_comm_ring Type)) linarith.comp) : @archimedean.{1} (ordered_comm_ring.{1} Type) (@functor.add_const.run.{1 0} (ordered_add_comm_monoid.{1} (ordered_comm_ring.{1} Type)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_25211 (h0 : topological_space (left_cancel_monoid (semiring (semiring (semiring empty))))) : path_connected_space (left_cancel_monoid (semiring (semiring (semiring empty)))) := sorry --non-trivial
lemma new_lemma_25212 (h0 : topological_space (generalized_boolean_algebra (ring pos))) : loc_path_connected_space (generalized_boolean_algebra (ring pos)) := sorry --non-trivial
lemma new_lemma_25213 (h0 : functor.add_const (ring (comm_group linarith.comp)) pos) : @strong_rank_condition.{0} (comm_group.{0} linarith.comp) (@functor.add_const.run.{0 0} (ring.{0} (comm_group.{0} linarith.comp)) pos h0)  := sorry --non-trivial
lemma new_lemma_25214 (h0 : function.extfun Type list) : palindrome (function.extfun_app h0 (has_to_string pos)) := sorry --non-trivial
lemma new_lemma_25215 (h0 : topological_space (boolean_algebra.core (has_add pos))) : irreducible_space (boolean_algebra.core (has_add pos)) := sorry --non-trivial
lemma new_lemma_25216 (h0 : functor.add_const (monoid (has_add pos)) name) : @monoid.fg.{0} (has_add.{0} pos) (@functor.add_const.run.{0 0} (monoid.{0} (has_add.{0} pos)) name h0)  := sorry --non-trivial
lemma new_lemma_25217 (h0 : topological_space (has_emptyc (random_gen linarith.ineq))) : t0_space (has_emptyc (random_gen linarith.ineq)) := sorry --non-trivial
lemma new_lemma_25218 (h0 : not (topological_space (metric_space unsigned) -> false)) : @discrete_topology.{0} (metric_space.{0} unsigned) (@classical.by_contradiction'.{1} (topological_space.{0} (metric_space.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_25219 (h0 : has_mem.mem (has_norm fun_info) has_emptyc.emptyc) : @irreducible_space.{0} (has_norm.{0} fun_info) (@finset.pi.empty.{1 0} Type topological_space.{0} (has_norm.{0} fun_info) h0)  := sorry --non-trivial
lemma new_lemma_25220 (h0 : add_group (comm_group unsigned)) : is_add_cyclic (comm_group unsigned) := sorry --non-trivial
lemma new_lemma_25221 (h0 : topological_space (normed_lattice_add_comm_group Type)) : path_connected_space (normed_lattice_add_comm_group Type) := sorry --non-trivial
lemma new_lemma_25222 (h0 : not (function.extfun Type complete_lattice -> false)) : @is_atomistic.{0} (linear_ordered_semiring.{0} fun_info) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type complete_lattice.{0}) h0) (linear_ordered_semiring.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_25223 (h0 : add_group (preorder (option (option unsigned)))) : is_add_cyclic (preorder (option (option unsigned))) := sorry --non-trivial
lemma new_lemma_25224 (h0 : group (semigroup (comm_group (comm_group pos)))) : normalizer_condition (semigroup (comm_group (comm_group pos))) := sorry --non-trivial
lemma new_lemma_25225 (h1 : function.extfun linarith.ineq (fun (x : linarith.ineq), Prop)) : @infi.{0 1} Prop (@conditionally_complete_lattice.to_has_Inf.{0} Prop (@complete_lattice.to_conditionally_complete_lattice.{0} Prop Prop.complete_lattice)) linarith.ineq (@function.extfun_app.{1 1} linarith.ineq (λ (x : linarith.ineq), Prop) h1)  := sorry --non-trivial
lemma new_lemma_25226 (h0 : uniform_space (has_emptyc (has_inv (with_bot congr_arg_kind)))) : complete_space (has_emptyc (has_inv (with_bot congr_arg_kind))) := sorry --non-trivial
lemma new_lemma_25227 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @monoid.fg.{0} (has_neg.{0} ennreal) (@function.extfun_app.{2 1} Type monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 monoid.{0}) (has_neg.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_25228 (h0 : function.extfun Type topological_space) : @t1_space.{0} (cancel_monoid.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (cancel_monoid.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_25229 (h1 h2 : multiset (mul_one_class char)) : multiset.disjoint h1 h2 := sorry --non-trivial
lemma new_lemma_25230 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_domain.{0} (add_cancel_monoid.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (add_cancel_monoid.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_25231 (h0 : fin has_zero.zero) : @normalizer_condition.{1} (has_pos_part.{1} Type) (@matrix.vec_empty.{1} (group.{1} (has_pos_part.{1} Type)) (@function.extfun_app.{1 1} nat fin (@matrix.vec_empty.{0} (function.extfun.{1 1} nat fin) h0) (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_25232 (h0 : function.extfun Type topological_space) : @t1_space.{0} (pseudo_metric_space.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (pseudo_metric_space.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_25233 (h0 : topological_space (generalized_boolean_algebra real)) : preirreducible_space (generalized_boolean_algebra real) := sorry --non-trivial
lemma new_lemma_25234 (h0 : functor.add_const (function.extfun Type cancel_comm_monoid_with_zero) name) : @unique_factorization_monoid.{0} (comm_group.{0} pos) (@function.extfun_app.{2 1} Type cancel_comm_monoid_with_zero.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type cancel_comm_monoid_with_zero.{0}) name h0) (comm_group.{0} pos))  := sorry --non-trivial
lemma new_lemma_25235 (h0 : add_cancel_monoid pos -> add_cancel_monoid pos -> Prop) : transitive h0 := sorry --non-trivial
lemma new_lemma_25236 (h0 : ring (add_comm_semigroup (add_comm_semigroup reducibility_hints))) : is_domain (add_comm_semigroup (add_comm_semigroup reducibility_hints)) := sorry --non-trivial
lemma new_lemma_25237 (h0 : topological_space (has_nndist pos)) : path_connected_space (has_nndist pos) := sorry --non-trivial
lemma new_lemma_25238 (h0 : function.extfun Type topological_space) : @normal_space.{0} (ordered_cancel_comm_monoid.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (ordered_cancel_comm_monoid.{0} empty))  := sorry --non-trivial
lemma new_lemma_25239 (h0 : group (dlist (random_gen (random_gen (random_gen string_imp))))) : is_cyclic (dlist (random_gen (random_gen (random_gen string_imp)))) := sorry --non-trivial
lemma new_lemma_25240 (h0 : uniform_space (linear_ordered_comm_group unsigned)) : separated_space (linear_ordered_comm_group unsigned) := sorry --non-trivial
lemma new_lemma_25241 (h0 : function.extfun Type topological_space) : @totally_disconnected_space.{0} (monoid.{0} ennreal) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (monoid.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_25242 (h0 : ring (measurable_space (has_top fun_info))) : is_domain (measurable_space (has_top fun_info)) := sorry --non-trivial
lemma new_lemma_25243 (h0 : functor.add_const (add_monoid (semigroup unsigned)) linarith.comp) : @add_monoid.fg.{0} (semigroup.{0} unsigned) (@functor.add_const.run.{0 0} (add_monoid.{0} (semigroup.{0} unsigned)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_25244 (h1 : ring (has_append to_additive.value_type)) : is_domain (has_append to_additive.value_type) := sorry --non-trivial
lemma new_lemma_25245 (h0 : not (function.extfun Type topological_space -> false)) : @irreducible_space.{0} num (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) num)  := sorry --non-trivial
lemma new_lemma_25246 (h0 : list (has_ssubset (comm_ring (comm_ring linarith.ineq)))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_25247 (h0 : semiring (boolean_algebra (has_to_string Type))) : is_noetherian_ring (boolean_algebra (has_to_string Type)) := sorry --non-trivial
lemma new_lemma_25248 (h0 : not (function.extfun (Type -> Type) (function.extfun Type) -> false)) : @rank_condition.{0} (has_top.{0} fun_info) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) (@classical.by_contradiction'.{2} (function.extfun.{2 2} (Type → Type) (function.extfun.{2 1} Type)) h0) ring.{0}) (has_top.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_25249 (h0 : not (ring (random_gen (has_ssubset linarith.comp_source)) -> false)) : @is_domain.{0} (random_gen.{0} (has_ssubset.{0} linarith.comp_source)) (@classical.by_contradiction'.{1} (ring.{0} (random_gen.{0} (has_ssubset.{0} linarith.comp_source))) h0)  := sorry --non-trivial
lemma new_lemma_25250 (h0 : add_group (with_one (semiring (semiring (has_top (semiring (semiring unsigned))))))) : is_add_cyclic (with_one (semiring (semiring (has_top (semiring (semiring unsigned)))))) := sorry --non-trivial
lemma new_lemma_25251 (h0 : complete_lattice (has_nndist (finset ordering))) : complete_lattice.is_Sup_finite_compact (has_nndist (finset ordering)) := sorry --non-trivial
lemma new_lemma_25252 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_domain.{0} num (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) num)  := sorry --non-trivial
lemma new_lemma_25253 (h0 : ring (mul_one_class reducibility_hints)) : is_domain (mul_one_class reducibility_hints) := sorry --non-trivial
lemma new_lemma_25254 (h0 : topological_space (free_add_monoid num)) : t0_space (free_add_monoid num) := sorry --non-trivial
lemma new_lemma_25255 (h0 : functor.add_const (fin has_zero.zero) Type) : @is_add_cyclic.{0} (canonically_ordered_monoid.{0} pos) (@matrix.vec_empty.{0} (add_group.{0} (canonically_ordered_monoid.{0} pos)) (@functor.add_const.run.{0 1} (fin (@has_zero.zero.{0} nat nat.has_zero)) Type h0))  := sorry --non-trivial
lemma new_lemma_25256 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @preconnected_space.{0} (linear_ordered_field.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (linear_ordered_field.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_25257 (h0 : ring (ring (add_comm_monoid environment.implicit_infer_kind))) : strong_rank_condition (ring (add_comm_monoid environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_25258 (h0 : ring (add_cancel_monoid empty)) : strong_rank_condition (add_cancel_monoid empty) := sorry --non-trivial
lemma new_lemma_25259 (h0 : topological_space (complete_distrib_lattice linarith.comp)) : locally_compact_space (complete_distrib_lattice linarith.comp) := sorry --non-trivial
lemma new_lemma_25260 (h0 : topological_space (nondiscrete_normed_field fun_info)) (h1 : preorder (nondiscrete_normed_field fun_info)) : order_topology (nondiscrete_normed_field fun_info) := sorry --non-trivial
lemma new_lemma_25261 (h0 : function.extfun Type (functor.add_const (ordered_add_comm_monoid (complete_linear_order empty)))) : @archimedean.{0} (complete_linear_order.{0} empty) (@functor.add_const.run.{0 0} (ordered_add_comm_monoid.{0} (complete_linear_order.{0} empty)) congr_arg_kind (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (ordered_add_comm_monoid.{0} (complete_linear_order.{0} empty))) h0 congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_25262 (h1 : topological_space (has_norm (has_top to_additive.value_type))) : totally_separated_space (has_norm (has_top to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_25263 (h0 : has_mem.mem topological_space has_emptyc.emptyc) : @totally_disconnected_space.{0} (has_emptyc.{0} fun_info) (@function.extfun_app.{2 1} Type topological_space.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) topological_space.{0} h0) (has_emptyc.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_25264 (h0 : functor.add_const (function.extfun Type list) (finset pos)) : palindrome (function.extfun_app (functor.add_const.run h0) (finset pos)) := sorry --non-trivial
lemma new_lemma_25265 (h0 : function.extfun Type topological_space) : @discrete_topology.{0} (has_one.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_one.{0} empty))  := sorry --non-trivial
lemma new_lemma_25266 (h0 : functor.add_const (function.extfun (Type 1) topological_space) linarith.comp) : @preconnected_space.{1} (has_nndist.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) topological_space.{1}) linarith.comp h0) (has_nndist.{1} Type))  := sorry --non-trivial
lemma new_lemma_25267 (h0 : monoid (comm_semigroup (sub_neg_monoid (has_Inf (has_Inf (has_add (ordered_comm_monoid Type))))))) : monoid.fg (comm_semigroup (sub_neg_monoid (has_Inf (has_Inf (has_add (ordered_comm_monoid Type)))))) := sorry --non-trivial
lemma new_lemma_25268 (h0 : topological_space (comm_monoid unsigned)) : topological_space.separable_space (comm_monoid unsigned) := sorry --non-trivial
lemma new_lemma_25269 (h0 : functor.add_const (topological_space (has_Inf pos)) name) : @topological_space.separable_space.{0} (has_Inf.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (has_Inf.{0} pos)) name h0)  := sorry --non-trivial
lemma new_lemma_25270 (h0 : group (has_add (measurable_space.dynkin_system unsigned))) : normalizer_condition (has_add (measurable_space.dynkin_system unsigned)) := sorry --non-trivial
lemma new_lemma_25271 (h0 : not (uniform_space (random_gen linarith.ineq) -> false)) : @complete_space.{0} (random_gen.{0} linarith.ineq) (@classical.by_contradiction'.{1} (uniform_space.{0} (random_gen.{0} linarith.ineq)) h0)  := sorry --non-trivial
lemma new_lemma_25272 (h0 : not (function.extfun Type semiring -> false)) : @is_noetherian_ring.{0} (measure_theory.measure_space.{0} unsigned) (@function.extfun_app.{2 1} Type semiring.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type semiring.{0}) h0) (measure_theory.measure_space.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_25273 (h0 : set (add_comm_semigroup (has_nnnorm enat) -> enat)) : set.separates_points h0 := sorry --non-trivial
lemma new_lemma_25274 (h0 : finset (ring (has_pos_part linarith.comp))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_25275 (h1 : uniform_space string.iterator_imp) : complete_space string.iterator_imp := sorry --non-trivial
lemma new_lemma_25276 (h0 : functor.add_const (function.extfun (Type 1) ordered_comm_monoid) name) : @has_exists_mul_of_le.{1} (ring.{1} Type) (@function.extfun_app.{3 2} (Type 1) ordered_comm_monoid.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) ordered_comm_monoid.{1}) name h0) (ring.{1} Type))  := sorry --non-trivial
lemma new_lemma_25277 (h0 : topological_space (with_one (random_gen fun_info))) : locally_compact_space (with_one (random_gen fun_info)) := sorry --non-trivial
lemma new_lemma_25278 (h0 : complete_lattice (option (has_to_string pos))) : complete_lattice.is_Sup_finite_compact (option (has_to_string pos)) := sorry --non-trivial
lemma new_lemma_25279 (h0 : filter (normed_comm_ring (has_add (boolean_algebra.core unsigned)))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_25280 (h0 : topological_space (normed_linear_ordered_group std_gen)) : path_connected_space (normed_linear_ordered_group std_gen) := sorry --non-trivial
lemma new_lemma_25281 (h0 : function.extfun (finset Type) (has_mem.mem (measurable_space fun_info))) : @strong_rank_condition.{0} (measurable_space.{0} fun_info) (@finset.pi.empty.{1 0} Type ring.{0} (measurable_space.{0} fun_info) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (measurable_space.{0} fun_info)) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_25282 (h0 : function.extfun (finset Type) (has_mem.mem (has_norm linarith.comp_source))) : @is_compactly_generated.{0} (has_norm.{0} linarith.comp_source) (@finset.pi.empty.{1 0} Type complete_lattice.{0} (has_norm.{0} linarith.comp_source) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (has_norm.{0} linarith.comp_source)) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_25283 (h0 : functor.comp ring cancel_monoid name) : @strong_rank_condition.{0} (cancel_monoid.{0} name) (@functor.comp.run.{0 0 0} ring.{0} cancel_monoid.{0} name h0)  := sorry --non-trivial
lemma new_lemma_25284 (h0 : ring (linear_ordered_cancel_comm_monoid empty)) : rank_condition (linear_ordered_cancel_comm_monoid empty) := sorry --non-trivial
lemma new_lemma_25285 (h0 : not (function.extfun (finset Type) (has_mem.mem fun_info) -> false)) : @is_atomistic.{0} fun_info (@finset.pi.empty.{1 0} Type complete_lattice.{0} fun_info (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) fun_info) (@classical.by_contradiction'.{0} (function.extfun.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) fun_info)) h0) (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_25286 (h0 : add_comm_semigroup fun_info -> add_comm_semigroup fun_info -> Prop) : is_total (add_comm_semigroup fun_info) h0 := sorry --non-trivial
lemma new_lemma_25287 (h0 : functor.add_const (uniform_space (option num)) num) : @separated_space.{0} (option.{0} num) (@functor.add_const.run.{0 0} (uniform_space.{0} (option.{0} num)) num h0)  := sorry --non-trivial
lemma new_lemma_25288 (h0 : functor.add_const (uniform_space (ring pos)) linarith.comp) : @complete_space.{0} (ring.{0} pos) (@functor.add_const.run.{0 0} (uniform_space.{0} (ring.{0} pos)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_25289 (h0 : ring (sub_neg_monoid linarith.comp)) : is_domain (sub_neg_monoid linarith.comp) := sorry --non-trivial
lemma new_lemma_25290 (h0 : filter (has_nndist (option name))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_25291 (h0 : function.extfun Type (functor.add_const (function.extfun Type group))) : @normalizer_condition.{0} (add_comm_monoid.{0} linarith.comp) (@function.extfun_app.{2 1} Type group.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type group.{0}) environment.implicit_infer_kind (@function.extfun_app.{2 2} Type (functor.add_const.{1 0} (function.extfun.{2 1} Type group.{0})) h0 environment.implicit_infer_kind)) (add_comm_monoid.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_25292 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_noetherian_ring.{0} (linear_ordered_comm_group.{0} pos) (@function.extfun_app.{2 1} Type semiring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 semiring.{0}) (linear_ordered_comm_group.{0} pos))  := sorry --non-trivial
lemma new_lemma_25293 (h0 : functor.add_const (topological_space (complete_distrib_lattice environment.implicit_infer_kind)) Type) : @preirreducible_space.{0} (complete_distrib_lattice.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 1} (topological_space.{0} (complete_distrib_lattice.{0} environment.implicit_infer_kind)) Type h0)  := sorry --non-trivial
lemma new_lemma_25294 (h0 : function.extfun (finset (Type -> Type)) (has_mem.mem uniform_space)) : @complete_space.{0} linarith.comp (@function.extfun_app.{2 1} Type uniform_space.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) uniform_space.{0} (@function.extfun_app.{2 0} (finset.{1} (Type → Type)) (@has_mem.mem.{1 1} (Type → Type) (finset.{1} (Type → Type)) (@finset.has_mem.{1} (Type → Type)) uniform_space.{0}) h0 (@has_emptyc.emptyc.{1} (finset.{1} (Type → Type)) (@finset.has_emptyc.{1} (Type → Type))))) linarith.comp)  := sorry --non-trivial
lemma new_lemma_25295 (h0 : topological_space (canonically_linear_ordered_monoid (has_bot (has_Inf Type)))) : irreducible_space (canonically_linear_ordered_monoid (has_bot (has_Inf Type))) := sorry --non-trivial
lemma new_lemma_25296 (h0 : complete_lattice (with_bot (has_emptyc linarith.comp_source))) : is_atomistic (with_bot (has_emptyc linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_25297 (h0 : functor.add_const (functor.add_const (group Type) pos) pos) : @is_cyclic.{1} Type (@functor.add_const.run.{1 0} (group.{1} Type) pos (@functor.add_const.run.{1 0} (functor.add_const.{1 0} (group.{1} Type) pos) pos h0))  := sorry --non-trivial
lemma new_lemma_25298 (h0 : topological_space (finset (has_neg_part (has_add Type)))) : sequential_space (finset (has_neg_part (has_add Type))) := sorry --non-trivial
lemma new_lemma_25299 (h0 : functor.add_const (topological_space (boolean_algebra unsigned)) linarith.comp) : @irreducible_space.{0} (boolean_algebra.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (boolean_algebra.{0} unsigned)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_25300 (h0 : functor.add_const (function.extfun Type semiring) Type) : @is_noetherian_ring.{0} (ring.{0} pos) (@function.extfun_app.{2 1} Type semiring.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type semiring.{0}) Type h0) (ring.{0} pos))  := sorry --non-trivial
lemma new_lemma_25301 (h0 : ring (mul_one_class congr_arg_kind)) : is_domain (mul_one_class congr_arg_kind) := sorry --non-trivial
lemma new_lemma_25302 (h0 : topological_space (has_Inf (finset pos))) : totally_disconnected_space (has_Inf (finset pos)) := sorry --non-trivial
lemma new_lemma_25303 (h0 : function.extfun Type monoid) : @monoid.fg.{0} (semigroup.{0} unsigned) (@function.extfun_app.{2 1} Type monoid.{0} h0 (semigroup.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_25304 (h0 : uniform_space (has_top (random_gen (has_norm (semiring linarith.comp_source))))) : separated_space (has_top (random_gen (has_norm (semiring linarith.comp_source)))) := sorry --non-trivial
lemma new_lemma_25305 (h0 : function.extfun Type list) : list.nodup (function.extfun_app h0 (has_emptyc to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_25306 (h0 : not (topological_space (id linarith.comp) -> false)) : @discrete_topology.{0} (@id.{2} Type linarith.comp) (@classical.by_contradiction'.{1} (topological_space.{0} (@id.{2} Type linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_25307 (h0 : functor.add_const (topological_space (has_Inf Type)) linarith.comp) : @locally_compact_space.{1} (has_Inf.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (has_Inf.{1} Type)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_25308 (h0 : functor.comp topological_space has_add environment.implicit_infer_kind) : @t1_space.{0} (has_add.{0} environment.implicit_infer_kind) (@functor.comp.run.{0 0 0} topological_space.{0} has_add.{0} environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_25309 (h0 : ring (add_comm_semigroup (mul_one_class enat))) : strong_rank_condition (add_comm_semigroup (mul_one_class enat)) := sorry --non-trivial
lemma new_lemma_25310 (h0 : complete_lattice (partial_order (semiring (semiring (semiring (semiring unsigned)))))) : is_atomistic (partial_order (semiring (semiring (semiring (semiring unsigned))))) := sorry --non-trivial
lemma new_lemma_25311 (h0 : functor.add_const (function.extfun Type uniform_space) linarith.comp) : @separated_space.{0} (normed_comm_ring.{0} pos) (@function.extfun_app.{2 1} Type uniform_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type uniform_space.{0}) linarith.comp h0) (normed_comm_ring.{0} pos))  := sorry --non-trivial
lemma new_lemma_25312 (h1 : topological_space (nondiscrete_normed_field (mul_one_class ereal))) : path_connected_space (nondiscrete_normed_field (mul_one_class ereal)) := sorry --non-trivial
lemma new_lemma_25313 (h0 : function.extfun Type topological_space) : @totally_disconnected_space.{0} (has_top.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_top.{0} empty))  := sorry --non-trivial
lemma new_lemma_25314 (h0 : functor.add_const (list (has_neg ennreal)) name) : palindrome (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_25315 (h0 : functor.add_const (ring (has_nndist congr_arg_kind)) unsigned) : @rank_condition.{0} (has_nndist.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (ring.{0} (has_nndist.{0} congr_arg_kind)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_25316 (h0 : topological_space (has_to_string (ring linarith.comp))) : regular_space (has_to_string (ring linarith.comp)) := sorry --non-trivial
lemma new_lemma_25317 (h0 : ordered_add_comm_monoid (ordered_comm_group (option empty))) : archimedean (ordered_comm_group (option empty)) := sorry --non-trivial
lemma new_lemma_25318 (h0 : function.extfun Type uniform_space) : @complete_space.{0} (group_with_zero.{0} unsigned) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (group_with_zero.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_25319 (h0 : functor.add_const (topological_space (free_add_monoid empty)) (semiring empty)) : @locally_compact_space.{0} (free_add_monoid.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (free_add_monoid.{0} empty)) (semiring.{0} empty) h0)  := sorry --non-trivial
lemma new_lemma_25320 (h0 : uniform_space (measure_theory.measure_space num)) : separated_space (measure_theory.measure_space num) := sorry --non-trivial
lemma new_lemma_25321 (h0 : not (function.extfun Type topological_space -> false)) : @locally_compact_space.{0} (topological_space.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (topological_space.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_25322 (h0 : group (with_one (has_inv (has_inv fun_info)))) : normalizer_condition (with_one (has_inv (has_inv fun_info))) := sorry --non-trivial
lemma new_lemma_25323 (h0 : functor.add_const (function.extfun Type list) (has_neg name)) : palindrome (function.extfun_app (functor.add_const.run h0) (has_add pos)) := sorry --non-trivial
lemma new_lemma_25324 (h0 : functor.comp topological_space ring name) : @discrete_topology.{0} (ring.{0} name) (@functor.comp.run.{0 0 0} topological_space.{0} ring.{0} name h0)  := sorry --non-trivial
lemma new_lemma_25325 (h0 : ring (has_pos_part (has_add linarith.comp))) : strong_rank_condition (has_pos_part (has_add linarith.comp)) := sorry --non-trivial
lemma new_lemma_25326 (h0 : fin has_zero.zero) : @totally_disconnected_space.{0} (ordered_comm_ring.{0} real) (@function.extfun_app.{2 1} Type topological_space.{0} (@matrix.vec_empty.{1} (function.extfun.{2 1} Type topological_space.{0}) h0) (ordered_comm_ring.{0} real))  := sorry --non-trivial
lemma new_lemma_25327 (h0 : functor.add_const (semiring (complete_distrib_lattice pos)) (finset linarith.comp)) : @is_noetherian_ring.{0} (complete_distrib_lattice.{0} pos) (@functor.add_const.run.{0 0} (semiring.{0} (complete_distrib_lattice.{0} pos)) (finset.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_25328 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_cyclic.{0} (with_bot.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (with_bot.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_25329 (h0 : function.extfun Type group) : @normalizer_condition.{0} (has_emptyc.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type group.{0} h0 (has_emptyc.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_25330 (h0 : ordered_add_comm_monoid (left_cancel_monoid (semiring unsigned))) : archimedean (left_cancel_monoid (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_25331 (h0 : ordered_add_comm_monoid (ordered_cancel_add_comm_monoid (option empty))) : archimedean (ordered_cancel_add_comm_monoid (option empty)) := sorry --non-trivial
lemma new_lemma_25332 (h0 : functor.add_const (topological_space (boolean_algebra Type)) pos) : @regular_space.{1} (boolean_algebra.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (boolean_algebra.{1} Type)) pos h0)  := sorry --non-trivial
lemma new_lemma_25333 (h0 : topological_space (has_add (add_cancel_monoid (has_zero (add_cancel_monoid name))))) : regular_space (has_add (add_cancel_monoid (has_zero (add_cancel_monoid name)))) := sorry --non-trivial
lemma new_lemma_25334 (h0 : ring (canonically_ordered_comm_semiring unsigned)) : strong_rank_condition (canonically_ordered_comm_semiring unsigned) := sorry --non-trivial
lemma new_lemma_25335 (h0 : topological_space (boolean_algebra (has_add (has_add name)))) : totally_separated_space (boolean_algebra (has_add (has_add name))) := sorry --non-trivial
lemma new_lemma_25336 (h0 : functor.add_const (list (normed_linear_ordered_group congr_arg_kind)) unsigned) : palindrome (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_25337 (h0 : function.extfun Type topological_space) : @totally_disconnected_space.{0} (linear_ordered_field.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (linear_ordered_field.{0} pos))  := sorry --non-trivial
lemma new_lemma_25338 (h0 : ring (uniform_space (has_well_founded string_imp))) : is_domain (uniform_space (has_well_founded string_imp)) := sorry --non-trivial
lemma new_lemma_25339 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : finset.nonempty (function.extfun_app (function.extfun_app h0 finset) (has_neg pos)) := sorry --non-trivial
lemma new_lemma_25340 (h0 : topological_space (ordered_cancel_add_comm_monoid congr_arg_kind)) : preconnected_space (ordered_cancel_add_comm_monoid congr_arg_kind) := sorry --non-trivial
lemma new_lemma_25341 (h0 : complete_lattice (has_neg (finset (add_comm_monoid (has_add environment.implicit_infer_kind))))) : is_atomistic (has_neg (finset (add_comm_monoid (has_add environment.implicit_infer_kind)))) := sorry --non-trivial
lemma new_lemma_25342 (h0 : not (function.extfun (Type 1) topological_space -> false)) : @t1_space.{1} (plift.{1} unsigned) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@classical.by_contradiction'.{3} (function.extfun.{3 2} (Type 1) topological_space.{1}) h0) (plift.{1} unsigned))  := sorry --non-trivial
lemma new_lemma_25343 (h0 : topological_space (semiring linarith.ineq)) : totally_separated_space (semiring linarith.ineq) := sorry --non-trivial
lemma new_lemma_25344 (h0 : ordered_add_comm_monoid (complete_distrib_lattice num)) : archimedean (complete_distrib_lattice num) := sorry --non-trivial
lemma new_lemma_25345 (h1 : uniform_space (distrib reducibility_hints)) : complete_space (distrib reducibility_hints) := sorry --non-trivial
lemma new_lemma_25346 (h0 : group (measurable_space (has_norm (has_norm empty)))) : group.fg (measurable_space (has_norm (has_norm empty))) := sorry --non-trivial
lemma new_lemma_25347 (h0 : ring (has_zero (finset (finset (finset (finset linarith.comp)))))) : strong_rank_condition (has_zero (finset (finset (finset (finset linarith.comp))))) := sorry --non-trivial
lemma new_lemma_25348 (h0 : not (ring (has_ssubset char) -> false)) : @strong_rank_condition.{0} (has_ssubset.{0} char) (@classical.by_contradiction'.{1} (ring.{0} (has_ssubset.{0} char)) h0)  := sorry --non-trivial
lemma new_lemma_25349 (h0 : functor.add_const (function.extfun Type ordered_comm_monoid) name) : @has_exists_mul_of_le.{0} (has_zero.{0} name) (@function.extfun_app.{2 1} Type ordered_comm_monoid.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type ordered_comm_monoid.{0}) name h0) (has_zero.{0} name))  := sorry --non-trivial
lemma new_lemma_25350 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_cyclic.{0} (semiring.{0} empty) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (semiring.{0} empty))  := sorry --non-trivial
lemma new_lemma_25351 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @group.fg.{0} (normed_comm_ring.{0} empty) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (normed_comm_ring.{0} empty))  := sorry --non-trivial
lemma new_lemma_25352 (h0 : functor.add_const (topological_space (semigroup empty)) empty) : @preirreducible_space.{0} (semigroup.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (semigroup.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_25353 (h0 : function.extfun Type group) : @normalizer_condition.{0} (complete_distrib_lattice.{0} pos) (@function.extfun_app.{2 1} Type group.{0} h0 (complete_distrib_lattice.{0} pos))  := sorry --non-trivial
lemma new_lemma_25354 (h0 : measurable_space (add_comm_semigroup char)) (h1 : filter (add_comm_semigroup char)) : filter.is_measurably_generated h1 := sorry --non-trivial
lemma new_lemma_25355 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @add_monoid.fg.{0} (normed_comm_ring.{0} linarith.comp) (@function.extfun_app.{2 1} Type add_monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 add_monoid.{0}) (normed_comm_ring.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_25356 (h1 : topological_space (denumerable (has_nnnorm char))) : t0_space (denumerable (has_nnnorm char)) := sorry --non-trivial
lemma new_lemma_25357 (h0 : functor.add_const (semiring (comm_group pos)) Type) : @is_noetherian_ring.{0} (comm_group.{0} pos) (@functor.add_const.run.{0 1} (semiring.{0} (comm_group.{0} pos)) Type h0)  := sorry --non-trivial
lemma new_lemma_25358 (h0 : function.extfun Type topological_space) : @preirreducible_space.{0} (add_cancel_monoid.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (add_cancel_monoid.{0} name))  := sorry --non-trivial
lemma new_lemma_25359 (h0 : list (add_cancel_monoid (option (option (option (option (option (option empty)))))))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_25360 (h0 : option Type) (h1 : not (function.extfun (Type -> Type) (function.extfun Type) -> false)) : @irreducible_space.{0} (@option.get_or_else.{1} Type h0 (semiring.{0} unsigned)) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) (@classical.by_contradiction'.{2} (function.extfun.{2 2} (Type → Type) (function.extfun.{2 1} Type)) h1) topological_space.{0}) (@option.get_or_else.{1} Type h0 (semiring.{0} unsigned)))  := sorry --non-trivial
lemma new_lemma_25361 (h0 : function.extfun Type topological_space) : @t1_space.{0} (add_cancel_monoid.{0} (option.{0} num)) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (add_cancel_monoid.{0} (option.{0} num)))  := sorry --non-trivial
lemma new_lemma_25362 (h0 : topological_space (has_nndist (has_to_string linarith.comp))) : regular_space (has_nndist (has_to_string linarith.comp)) := sorry --non-trivial
lemma new_lemma_25363 (h0 : function.extfun Type complete_lattice) : @is_compactly_generated.{0} (boolean_algebra.{0} linarith.comp) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (boolean_algebra.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_25364 (h0 : ring (normed_comm_ring (finset name))) : is_domain (normed_comm_ring (finset name)) := sorry --non-trivial
lemma new_lemma_25365 (h0 : function.extfun (finset Type) (has_mem.mem string_imp)) : @totally_disconnected_space.{0} string_imp (@finset.pi.empty.{1 0} Type topological_space.{0} string_imp (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) string_imp) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_25366 (h0 : ring (has_le (mul_one_class (mul_one_class std_gen)))) : strong_rank_condition (has_le (mul_one_class (mul_one_class std_gen))) := sorry --non-trivial
lemma new_lemma_25367 (h0 : topological_space (has_one (semiring empty))) : totally_disconnected_space (has_one (semiring empty)) := sorry --non-trivial
lemma new_lemma_25368 (h0 : topological_space (as_linear_order (option (option (option empty))))) : totally_separated_space (as_linear_order (option (option (option empty)))) := sorry --non-trivial
lemma new_lemma_25369 (h0 : ring (has_norm (random_gen (comm_ring (comm_ring linarith.ineq))))) : rank_condition (has_norm (random_gen (comm_ring (comm_ring linarith.ineq)))) := sorry --non-trivial
lemma new_lemma_25370 (h0 : topological_space (ordered_comm_monoid real)) : preconnected_space (ordered_comm_monoid real) := sorry --non-trivial
lemma new_lemma_25371 (h0 : topological_space (semigroup unsigned)) : normal_space (semigroup unsigned) := sorry --non-trivial
lemma new_lemma_25372 (h0 : topological_space (has_add (mul_one_class linarith.comp))) : preconnected_space (has_add (mul_one_class linarith.comp)) := sorry --non-trivial
lemma new_lemma_25373 (h0 : function.extfun Type ring) : @strong_rank_condition.{0} (has_append.{0} (random_gen.{0} char)) (@function.extfun_app.{2 1} Type ring.{0} h0 (has_append.{0} (random_gen.{0} char)))  := sorry --non-trivial
lemma new_lemma_25374 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @path_connected_space.{0} (monoid_with_zero.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (monoid_with_zero.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_25375 (h0 : filter (finset (add_comm_monoid pos))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_25376 (h0 : functor.comp topological_space has_neg_part name) : @irreducible_space.{0} (has_neg_part.{0} name) (@functor.comp.run.{0 0 0} topological_space.{0} has_neg_part.{0} name h0)  := sorry --non-trivial
lemma new_lemma_25377 (h0 : cancel_comm_monoid_with_zero (normed_lattice_add_comm_group (comm_semigroup Type))) : unique_factorization_monoid (normed_lattice_add_comm_group (comm_semigroup Type)) := sorry --non-trivial
lemma new_lemma_25378 (h0 : functor.add_const (topological_space pos) (option (option pos))) : @t0_space.{0} pos (@functor.add_const.run.{0 0} (topological_space.{0} pos) (option.{0} (option.{0} pos)) h0)  := sorry --non-trivial
lemma new_lemma_25379 (h0 : topological_space (option congr_arg_kind)) : loc_path_connected_space (option congr_arg_kind) := sorry --non-trivial
lemma new_lemma_25380 (h0 : functor.add_const (function.extfun Type complete_lattice) pos) : @is_atomistic.{0} (semigroup.{0} pos) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type complete_lattice.{0}) pos h0) (semigroup.{0} pos))  := sorry --non-trivial
lemma new_lemma_25381 (h0 : functor.add_const (topological_space (has_to_string name)) unsigned) : @totally_disconnected_space.{0} (has_to_string.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (has_to_string.{0} name)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_25382 (h0 : functor.add_const (ordered_comm_monoid (add_comm_monoid pos)) name) : @has_exists_mul_of_le.{0} (add_comm_monoid.{0} pos) (@functor.add_const.run.{0 0} (ordered_comm_monoid.{0} (add_comm_monoid.{0} pos)) name h0)  := sorry --non-trivial
lemma new_lemma_25383 (h0 : functor.add_const (ring (finset linarith.comp)) (ring Type)) : @is_principal_ideal_ring.{0} (finset.{0} linarith.comp) (@functor.add_const.run.{0 1} (ring.{0} (finset.{0} linarith.comp)) (ring.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_25384 (h0 : topological_space (boolean_algebra.core Type)) : t1_space (boolean_algebra.core Type) := sorry --non-trivial
lemma new_lemma_25385 (h0 : pnat) (h1 : ulower (list (ulower pnat))) : pnat.coprime h0 (ulower.up (list.head (ulower.up h1))) := sorry --non-trivial
lemma new_lemma_25386 (h0 : topological_space (has_norm (random_gen (random_gen linarith.comp_source)))) : irreducible_space (has_norm (random_gen (random_gen linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_25387 (h0 : functor.add_const (semiring (sub_neg_monoid pos)) name) : @is_noetherian_ring.{0} (sub_neg_monoid.{0} pos) (@functor.add_const.run.{0 0} (semiring.{0} (sub_neg_monoid.{0} pos)) name h0)  := sorry --non-trivial
lemma new_lemma_25388 (h0 : group (ring (finset (ring (has_neg pos))))) : is_simple_group (ring (finset (ring (has_neg pos)))) := sorry --non-trivial
lemma new_lemma_25389 (h0 : ordered_comm_monoid (has_to_string (ring environment.implicit_infer_kind))) : has_exists_mul_of_le (has_to_string (ring environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_25390 (h0 : function.extfun (finset Type) (has_mem.mem (has_norm linarith.comp_source))) : @irreducible_space.{0} (has_norm.{0} linarith.comp_source) (@finset.pi.empty.{1 0} Type topological_space.{0} (has_norm.{0} linarith.comp_source) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (has_norm.{0} linarith.comp_source)) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_25391 (h0 : ring (monoid ennreal)) : rank_condition (monoid ennreal) := sorry --non-trivial
lemma new_lemma_25392 (h0 : topological_space (normed_lattice_add_comm_group char)) : locally_compact_space (normed_lattice_add_comm_group char) := sorry --non-trivial
lemma new_lemma_25393 (h0 : fin has_zero.zero) : @totally_separated_space.{0} (complete_distrib_lattice.{0} linarith.comp) (@matrix.vec_empty.{0} (topological_space.{0} (complete_distrib_lattice.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_25394 (h0 : function.extfun Type add_monoid) : @add_monoid.fg.{0} (metric_space.{0} num) (@function.extfun_app.{2 1} Type add_monoid.{0} h0 (metric_space.{0} num))  := sorry --non-trivial
lemma new_lemma_25395 (h0 : functor.add_const (ring (ordered_comm_ring name)) (has_add pos)) : @is_domain.{0} (ordered_comm_ring.{0} name) (@functor.add_const.run.{0 0} (ring.{0} (ordered_comm_ring.{0} name)) (has_add.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_25396 (h0 : functor.add_const (topological_space (ring unsigned)) name) : @loc_path_connected_space.{0} (ring.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (ring.{0} unsigned)) name h0)  := sorry --non-trivial
lemma new_lemma_25397 (h1 : topological_space (nondiscrete_normed_field environment.projection_info)) : t0_space (nondiscrete_normed_field environment.projection_info) := sorry --non-trivial
lemma new_lemma_25398 (h0 : not (function.extfun Type ring -> false)) : @is_principal_ideal_ring.{0} (left_cancel_semigroup.{0} empty) (@function.extfun_app.{2 1} Type ring.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type ring.{0}) h0) (left_cancel_semigroup.{0} empty))  := sorry --non-trivial
lemma new_lemma_25399 (h0 : function.extfun Type topological_space) : @t0_space.{0} (linear_ordered_add_comm_group.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (linear_ordered_add_comm_group.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_25400 (h0 : uniform_space (add_semigroup num)) : complete_space (add_semigroup num) := sorry --non-trivial
lemma new_lemma_25401 (h0 : prod (finset unsigned) (finset unsigned)) : id_rel h0 := sorry --non-trivial
lemma new_lemma_25402 (h0 : topological_space (has_zero (boolean_algebra.core (ring unsigned)))) : loc_path_connected_space (has_zero (boolean_algebra.core (ring unsigned))) := sorry --non-trivial
lemma new_lemma_25403 (h0 : semiring (mul_zero_class (has_to_string (has_add Type)))) : is_noetherian_ring (mul_zero_class (has_to_string (has_add Type))) := sorry --non-trivial
lemma new_lemma_25404 (h0 : functor.add_const (function.extfun Type ring) pos) : @rank_condition.{0} (finset.{0} pos) (@function.extfun_app.{2 1} Type ring.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type ring.{0}) pos h0) (finset.{0} pos))  := sorry --non-trivial
lemma new_lemma_25405 (h0 : function.extfun (Type 1) (functor.comp cancel_comm_monoid_with_zero semigroup)) : @unique_factorization_monoid.{1} (semigroup.{1} Type) (@functor.comp.run.{1 1 1} cancel_comm_monoid_with_zero.{1} semigroup.{1} Type (@function.extfun_app.{3 2} (Type 1) (functor.comp.{1 1 1} cancel_comm_monoid_with_zero.{1} semigroup.{1}) h0 Type))  := sorry --non-trivial
lemma new_lemma_25406 (h0 : filter (denumerable (random_gen linarith.comp_source))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_25407 (h0 : function.extfun Type topological_space) : @locally_compact_space.{0} (has_neg_part.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_neg_part.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_25408 (h1 : ring (normed_field (metric_space linarith.ineq))) : strong_rank_condition (normed_field (metric_space linarith.ineq)) := sorry --non-trivial
lemma new_lemma_25409 (h0 : group (has_bot Type)) : is_cyclic (has_bot Type) := sorry --non-trivial
lemma new_lemma_25410 (h0 : functor.add_const (function.extfun Type complete_lattice) (has_neg pos)) : @is_atomistic.{0} (ring.{0} pos) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type complete_lattice.{0}) (has_neg.{0} pos) h0) (ring.{0} pos))  := sorry --non-trivial
lemma new_lemma_25411 (h0 : functor.add_const (topological_space (has_to_string environment.implicit_infer_kind)) linarith.comp) : @loc_path_connected_space.{0} (has_to_string.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (has_to_string.{0} environment.implicit_infer_kind)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_25412 (h0 : add_monoid (canonically_linear_ordered_monoid (has_Inf real))) : add_monoid.fg (canonically_linear_ordered_monoid (has_Inf real)) := sorry --non-trivial
lemma new_lemma_25413 (h0 : semiring linarith.ineq) (h2 : ideal linarith.ineq) : ideal.is_prime h2 := sorry --non-trivial
lemma new_lemma_25414 (h0 : filter (boolean_algebra (finset (finset (has_add linarith.comp))))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_25415 (h0 : topological_space (complete_distrib_lattice (has_add (has_add environment.implicit_infer_kind)))) : irreducible_space (complete_distrib_lattice (has_add (has_add environment.implicit_infer_kind))) := sorry --non-trivial
lemma new_lemma_25416 (h0 : topological_space (has_top num)) : preirreducible_space (has_top num) := sorry --non-trivial
lemma new_lemma_25417 (h0 : decidable_eq char) (h1 : add_comm_monoid std_gen) (h2 : char -> add_submonoid std_gen) : direct_sum.add_submonoid_is_internal h2 := sorry --non-trivial
lemma new_lemma_25418 (h0 : functor.add_const (topological_space (boolean_algebra unsigned)) environment.implicit_infer_kind) : @totally_disconnected_space.{0} (boolean_algebra.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (boolean_algebra.{0} unsigned)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_25419 (h0 : function.extfun Type topological_space) : @t0_space.{0} (has_nndist.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_nndist.{0} empty))  := sorry --non-trivial
lemma new_lemma_25420 (h0 : functor.add_const (filter (has_zero name)) name) : filter.ne_bot (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_25421 (h0 : functor.add_const (monoid (has_neg_part pos)) Type) : @monoid.fg.{0} (has_neg_part.{0} pos) (@functor.add_const.run.{0 1} (monoid.{0} (has_neg_part.{0} pos)) Type h0)  := sorry --non-trivial
lemma new_lemma_25422 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @preirreducible_space.{0} (@id.{2} Type linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (@id.{2} Type linarith.comp))  := sorry --non-trivial
lemma new_lemma_25423 (h0 : nat) (h1 : preorder (prod int int)) (h2 : preorder nat) (h3 : prod int int -> nat) : galois_connection h3 (nat.xgcd h0) := sorry --non-trivial
lemma new_lemma_25424 (h0 : not (add_group (has_ssubset linarith.ineq) -> false)) : @is_add_cyclic.{0} (has_ssubset.{0} linarith.ineq) (@classical.by_contradiction'.{1} (add_group.{0} (has_ssubset.{0} linarith.ineq)) h0)  := sorry --non-trivial
lemma new_lemma_25425 (h0 : functor.add_const (list (normed_comm_ring unsigned)) empty) : palindrome (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_25426 (h1 : set (set string_imp)) (h2 : string_imp) : set.sInter h1 h2 := sorry --non-trivial
lemma new_lemma_25427 (h0 : function.extfun Type cancel_comm_monoid_with_zero) : @unique_factorization_monoid.{0} (finset.{0} name) (@function.extfun_app.{2 1} Type cancel_comm_monoid_with_zero.{0} h0 (finset.{0} name))  := sorry --non-trivial
lemma new_lemma_25428 (h0 : functor.comp topological_space has_add pos) : @topological_space.separable_space.{0} (has_add.{0} pos) (@functor.comp.run.{0 0 0} topological_space.{0} has_add.{0} pos h0)  := sorry --non-trivial
lemma new_lemma_25429 (h0 : functor.add_const (topological_space (add_comm_monoid Type)) (boolean_algebra pos)) : @preconnected_space.{1} (add_comm_monoid.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (add_comm_monoid.{1} Type)) (boolean_algebra.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_25430 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @group.fg.{0} (measurable_space.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (measurable_space.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_25431 (h0 : functor.add_const Prop (finset real)) : functor.add_const.run h0 := sorry --non-trivial
lemma new_lemma_25432 (h1 : not (ring (comm_ring to_additive.value_type) -> false)) : @is_domain.{0} (comm_ring.{0} to_additive.value_type) (@classical.by_contradiction'.{1} (ring.{0} (comm_ring.{0} to_additive.value_type)) h1)  := sorry --non-trivial
lemma new_lemma_25433 (h0 : functor.add_const (function.extfun (Type 1) topological_space) (ring environment.implicit_infer_kind)) : @preconnected_space.{1} (has_to_string.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) topological_space.{1}) (ring.{0} environment.implicit_infer_kind) h0) (has_to_string.{1} Type))  := sorry --non-trivial
lemma new_lemma_25434 (h0 : ordered_add_comm_monoid (has_to_string pos)) : archimedean (has_to_string pos) := sorry --non-trivial
lemma new_lemma_25435 (h0 : function.extfun Type filter) : filter.ne_bot (function.extfun_app h0 (boolean_algebra.core empty)) := sorry --non-trivial
lemma new_lemma_25436 (h0 : complete_lattice (has_zero (comm_group unsigned))) : complete_lattice.is_Sup_finite_compact (has_zero (comm_group unsigned)) := sorry --non-trivial
lemma new_lemma_25437 (h0 : function.extfun Type group) : @is_cyclic.{0} (simple_graph.{0} linarith.comp) (@function.extfun_app.{2 1} Type group.{0} h0 (simple_graph.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_25438 (h1 : function.extfun Type topological_space) : @locally_compact_space.{0} (measurable_space.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} h1 (measurable_space.{0} num))  := sorry --non-trivial
lemma new_lemma_25439 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : finset.nonempty (function.extfun_app (function.extfun_app h0 finset) (linear_ordered_field ennreal)) := sorry --non-trivial
lemma new_lemma_25440 (h0 : topological_space (left_cancel_monoid congr_arg_kind)) : totally_disconnected_space (left_cancel_monoid congr_arg_kind) := sorry --non-trivial
lemma new_lemma_25441 (h0 : not (topological_space (complete_semilattice_Sup num) -> false)) : @preirreducible_space.{0} (complete_semilattice_Sup.{0} num) (@classical.by_contradiction'.{1} (topological_space.{0} (complete_semilattice_Sup.{0} num)) h0)  := sorry --non-trivial
lemma new_lemma_25442 (h0 : functor.add_const (monoid (has_nndist environment.implicit_infer_kind)) Type) : @monoid.fg.{0} (has_nndist.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 1} (monoid.{0} (has_nndist.{0} environment.implicit_infer_kind)) Type h0)  := sorry --non-trivial
lemma new_lemma_25443 (h0 : filter (simple_graph unsigned)) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_25444 (h0 : topological_space (normed_comm_ring (boolean_algebra environment.implicit_infer_kind))) : preconnected_space (normed_comm_ring (boolean_algebra environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_25445 (h0 : group (with_zero (random_gen (random_gen string_imp)))) : is_cyclic (with_zero (random_gen (random_gen string_imp))) := sorry --non-trivial
lemma new_lemma_25446 (h1 : not (ring (has_add char) -> false)) : @strong_rank_condition.{0} (has_add.{0} char) (@classical.by_contradiction'.{1} (ring.{0} (has_add.{0} char)) h1)  := sorry --non-trivial
lemma new_lemma_25447 (h0 : ring (has_norm (random_gen (semiring (has_norm (semiring linarith.comp)))))) : strong_rank_condition (has_norm (random_gen (semiring (has_norm (semiring linarith.comp))))) := sorry --non-trivial
lemma new_lemma_25448 (h0 : group (comm_group (has_add (has_add (has_add Type))))) : normalizer_condition (comm_group (has_add (has_add (has_add Type)))) := sorry --non-trivial
lemma new_lemma_25449 (h1 : function.extfun (Type -> Type) (function.extfun Type)) : @add_monoid.fg.{0} (complete_semilattice_Sup.{0} linarith.comp) (@function.extfun_app.{2 1} Type add_monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h1 add_monoid.{0}) (complete_semilattice_Sup.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_25450 (h0 : not (topological_space (topological_space (has_ssubset to_additive.value_type)) -> false)) : @t0_space.{0} (topological_space.{0} (has_ssubset.{0} to_additive.value_type)) (@classical.by_contradiction'.{1} (topological_space.{0} (topological_space.{0} (has_ssubset.{0} to_additive.value_type))) h0)  := sorry --non-trivial
lemma new_lemma_25451 (h0 : functor.add_const (complete_lattice (monoid empty)) empty) : @is_atomistic.{0} (monoid.{0} empty) (@functor.add_const.run.{0 0} (complete_lattice.{0} (monoid.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_25452 (h0 : function.extfun (Type 1) topological_space) : @regular_space.{1} (add_cancel_monoid.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} h0 (add_cancel_monoid.{1} Type))  := sorry --non-trivial
lemma new_lemma_25453 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : palindrome (function.extfun_app (function.extfun_app h0 list) (add_cancel_monoid (finset pos))) := sorry --non-trivial
lemma new_lemma_25454 (h0 : functor.add_const (topological_space (ordered_comm_ring linarith.comp)) name) : @totally_disconnected_space.{0} (ordered_comm_ring.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (ordered_comm_ring.{0} linarith.comp)) name h0)  := sorry --non-trivial
lemma new_lemma_25455 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @add_monoid.fg.{0} (normed_group.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type add_monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 add_monoid.{0}) (normed_group.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_25456 (h0 : functor.add_const (topological_space (has_to_string name)) pos) : @irreducible_space.{0} (has_to_string.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (has_to_string.{0} name)) pos h0)  := sorry --non-trivial
lemma new_lemma_25457 (h0 : functor.add_const (ring (has_add pos)) Type) : @rank_condition.{0} (has_add.{0} pos) (@functor.add_const.run.{0 1} (ring.{0} (has_add.{0} pos)) Type h0)  := sorry --non-trivial
lemma new_lemma_25458 (h0 : functor.add_const (topological_space pos) unsigned) : @sequential_space.{0} pos (@functor.add_const.run.{0 0} (topological_space.{0} pos) unsigned h0)  := sorry --non-trivial
lemma new_lemma_25459 (h1 : has_mem.mem (normed_group linarith.comp_source) has_emptyc.emptyc) : @complete_lattice.is_Sup_finite_compact.{0} (normed_group.{0} linarith.comp_source) (@finset.pi.empty.{1 0} Type complete_lattice.{0} (normed_group.{0} linarith.comp_source) h1)  := sorry --non-trivial
lemma new_lemma_25460 (h0 : not (topological_space (option congr_arg_kind) -> false)) : @t0_space.{0} (option.{0} congr_arg_kind) (@classical.by_contradiction'.{1} (topological_space.{0} (option.{0} congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_25461 (h0 : ring (uniform_space (random_gen (distrib linarith.comp_source)))) : is_domain (uniform_space (random_gen (distrib linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_25462 (h0 : linarith.comp_source -> linarith.comp_source -> Prop) (h1 h2 : linarith.comp_source) : relation.join h0 h1 h2 := sorry --non-trivial
lemma new_lemma_25463 (h0 : functor.add_const (topological_space (has_zero pos)) name) : @irreducible_space.{0} (has_zero.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (has_zero.{0} pos)) name h0)  := sorry --non-trivial
lemma new_lemma_25464 (h0 : topological_space (semigroup (has_add (has_add pos)))) : loc_path_connected_space (semigroup (has_add (has_add pos))) := sorry --non-trivial
lemma new_lemma_25465 (h1 : function.extfun Type monoid) : @monoid.fg.{0} (has_emptyc.{0} linarith.ineq) (@function.extfun_app.{2 1} Type monoid.{0} h1 (has_emptyc.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_25466 (h0 : not (ring (semiring num) -> false)) : @is_domain.{0} (semiring.{0} num) (@classical.by_contradiction'.{1} (ring.{0} (semiring.{0} num)) h0)  := sorry --non-trivial
lemma new_lemma_25467 (h0 : ring (fintype (random_gen (random_gen (random_gen to_additive.value_type))))) : rank_condition (fintype (random_gen (random_gen (random_gen to_additive.value_type)))) := sorry --non-trivial
lemma new_lemma_25468 (h1 : complete_lattice (with_one (random_gen (random_gen string_imp)))) : is_compactly_generated (with_one (random_gen (random_gen string_imp))) := sorry --non-trivial
lemma new_lemma_25469 (h0 : complete_lattice (add_comm_semigroup std_gen)) : complete_lattice.is_Sup_finite_compact (add_comm_semigroup std_gen) := sorry --non-trivial
lemma new_lemma_25470 (h0 : not (topological_space (has_append char) -> false)) : @t0_space.{0} (has_append.{0} char) (@classical.by_contradiction'.{1} (topological_space.{0} (has_append.{0} char)) h0)  := sorry --non-trivial
lemma new_lemma_25471 (h0 : function.extfun Type complete_lattice) : @is_compactly_generated.{0} (has_neg.{0} empty) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (has_neg.{0} empty))  := sorry --non-trivial
lemma new_lemma_25472 (h1 : add_group (has_lt (metric_space (metric_space to_additive.value_type)))) : is_add_cyclic (has_lt (metric_space (metric_space to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_25473 (h0 : ring (non_unital_non_assoc_semiring (mul_one_class reducibility_hints))) : rank_condition (non_unital_non_assoc_semiring (mul_one_class reducibility_hints)) := sorry --non-trivial
lemma new_lemma_25474 (h0 : uniform_space (ordered_comm_semiring (has_nnnorm linarith.ineq))) : complete_space (ordered_comm_semiring (has_nnnorm linarith.ineq)) := sorry --non-trivial
lemma new_lemma_25475 (h1 : function.extfun Type list) : list.nodup (function.extfun_app h1 fun_info) := sorry --non-trivial
lemma new_lemma_25476 (h0 : add_group (has_emptyc (random_gen num))) : is_add_cyclic (has_emptyc (random_gen num)) := sorry --non-trivial
lemma new_lemma_25477 (h0 : group (semiring (semiring (semiring (semiring (semiring empty)))))) : is_cyclic (semiring (semiring (semiring (semiring (semiring empty))))) := sorry --non-trivial
lemma new_lemma_25478 (h0 : topological_space (has_star (semiring (semiring empty)))) : totally_disconnected_space (has_star (semiring (semiring empty))) := sorry --non-trivial
lemma new_lemma_25479 (h0 : complete_lattice (non_unital_non_assoc_semiring string_imp)) : is_compactly_generated (non_unital_non_assoc_semiring string_imp) := sorry --non-trivial
lemma new_lemma_25480 (h0 : ring (semi_normed_comm_ring (uniform_space char))) : rank_condition (semi_normed_comm_ring (uniform_space char)) := sorry --non-trivial
lemma new_lemma_25481 (h0 : functor.add_const (function.extfun Type topological_space) (has_add name)) : @regular_space.{0} (finset.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) (has_add.{0} name) h0) (finset.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_25482 (h0 : topological_space (has_neg (has_neg linarith.comp))) : totally_disconnected_space (has_neg (has_neg linarith.comp)) := sorry --non-trivial
lemma new_lemma_25483 (h1 : function.extfun Type ring) : @is_domain.{0} (distrib_lattice.{0} linarith.ineq) (@function.extfun_app.{2 1} Type ring.{0} h1 (distrib_lattice.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_25484 (h0 : group (comm_group (has_neg_part ennreal))) : group.fg (comm_group (has_neg_part ennreal)) := sorry --non-trivial
lemma new_lemma_25485 (h0 : topological_space (finset pos)) : discrete_topology (finset pos) := sorry --non-trivial
lemma new_lemma_25486 (h0 : function.extfun Type uniform_space) : @complete_space.{0} (comm_monoid.{0} (option.{0} empty)) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (comm_monoid.{0} (option.{0} empty)))  := sorry --non-trivial
lemma new_lemma_25487 (h0 : ring (add_cancel_monoid (finset Type))) : strong_rank_condition (add_cancel_monoid (finset Type)) := sorry --non-trivial
lemma new_lemma_25488 (h0 : group (add_left_cancel_semigroup (semiring unsigned))) : is_cyclic (add_left_cancel_semigroup (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_25489 (h0 : ordered_add_comm_monoid (add_cancel_monoid (has_neg linarith.comp))) : archimedean (add_cancel_monoid (has_neg linarith.comp)) := sorry --non-trivial
lemma new_lemma_25490 (h1 : filter (with_bot empty)) : filter.ne_bot h1 := sorry --non-trivial
lemma new_lemma_25491 (h0 : function.extfun Type ring) : @rank_condition.{0} (comm_group.{0} pos) (@function.extfun_app.{2 1} Type ring.{0} h0 (comm_group.{0} pos))  := sorry --non-trivial
lemma new_lemma_25492 (h0 : function.extfun Type list) : list.nodup (function.extfun_app h0 (finset unsigned)) := sorry --non-trivial
lemma new_lemma_25493 (h0 : complete_lattice (has_ssubset (add_comm_semigroup std_gen))) : complete_lattice.is_Sup_finite_compact (has_ssubset (add_comm_semigroup std_gen)) := sorry --non-trivial
lemma new_lemma_25494 (h0 : add_group (canonically_ordered_monoid (has_Inf (has_Inf (has_Inf (has_Inf (has_Inf Type))))))) : is_add_cyclic (canonically_ordered_monoid (has_Inf (has_Inf (has_Inf (has_Inf (has_Inf Type)))))) := sorry --non-trivial
lemma new_lemma_25495 (h0 : topological_space (has_add (has_nnnorm linarith.comp_source))) : t0_space (has_add (has_nnnorm linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_25496 (h0 : fin has_zero.zero) : @is_add_cyclic.{0} (canonically_linear_ordered_monoid.{0} linarith.comp) (@matrix.vec_empty.{0} (add_group.{0} (canonically_linear_ordered_monoid.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_25497 (h1 : set (fun_info -> ereal)) : set.separates_points h1 := sorry --non-trivial
lemma new_lemma_25498 (h0 : functor.add_const (function.extfun Type ring) Type) : @is_principal_ideal_ring.{0} (normed_comm_ring.{0} pos) (@function.extfun_app.{2 1} Type ring.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type ring.{0}) Type h0) (normed_comm_ring.{0} pos))  := sorry --non-trivial
lemma new_lemma_25499 (h0 : monoid (random_gen (with_bot string_imp))) : monoid.fg (random_gen (with_bot string_imp)) := sorry --non-trivial
lemma new_lemma_25500 (h0 : filter (normed_comm_ring (has_add (has_add Type)))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_25501 (h0 : function.extfun Type filter) : filter.ne_bot (function.extfun_app h0 (has_nndist environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_25502 (h0 : topological_space (semigroup (has_add pos))) : sequential_space (semigroup (has_add pos)) := sorry --non-trivial
lemma new_lemma_25503 (h0 : not (topological_space (right_cancel_semigroup char) -> false)) : @totally_disconnected_space.{0} (right_cancel_semigroup.{0} char) (@classical.by_contradiction'.{1} (topological_space.{0} (right_cancel_semigroup.{0} char)) h0)  := sorry --non-trivial
lemma new_lemma_25504 (h0 : add_group (has_emptyc (has_norm empty))) : is_add_cyclic (has_emptyc (has_norm empty)) := sorry --non-trivial
lemma new_lemma_25505 (h0 : uniform_space (boolean_algebra (has_Inf real))) : separated_space (boolean_algebra (has_Inf real)) := sorry --non-trivial
lemma new_lemma_25506 (h0 : functor.add_const (add_group (comm_group pos)) (comm_group Type)) : @is_add_cyclic.{0} (comm_group.{0} pos) (@functor.add_const.run.{0 1} (add_group.{0} (comm_group.{0} pos)) (comm_group.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_25507 (h0 : has_mem.mem (with_bot empty) has_emptyc.emptyc) : @totally_separated_space.{0} (with_bot.{0} empty) (@finset.pi.empty.{1 0} Type topological_space.{0} (with_bot.{0} empty) h0)  := sorry --non-trivial
lemma new_lemma_25508 (h4 : measurable_space (uniform_space linarith.ineq)) (h5 : measure_theory.measure (uniform_space linarith.ineq)) : measure_theory.is_probability_measure h5 := sorry --non-trivial
lemma new_lemma_25509 (h0 : set (random_gen reducibility_hints)) : set.finite h0 := sorry --non-trivial
lemma new_lemma_25510 (h0 : functor.comp topological_space semigroup Type) : @topological_space.separable_space.{1} (semigroup.{1} Type) (@functor.comp.run.{1 1 1} topological_space.{1} semigroup.{1} Type h0)  := sorry --non-trivial
lemma new_lemma_25511 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_domain.{0} (add_cancel_monoid.{0} (has_add.{0} environment.implicit_infer_kind)) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (add_cancel_monoid.{0} (has_add.{0} environment.implicit_infer_kind)))  := sorry --non-trivial
lemma new_lemma_25512 (h0 : group (has_sub congr_arg_kind)) : normalizer_condition (has_sub congr_arg_kind) := sorry --non-trivial
lemma new_lemma_25513 (h0 : function.extfun nat fin) : @totally_separated_space.{0} (has_pos_part.{0} pos) (@matrix.vec_empty.{0} (topological_space.{0} (has_pos_part.{0} pos)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_25514 (h0 : has_mem.mem topological_space has_emptyc.emptyc) : @path_connected_space.{0} (semiring.{0} linarith.ineq) (@function.extfun_app.{2 1} Type topological_space.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) topological_space.{0} h0) (semiring.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_25515 (h0 : functor.add_const (ring (canonically_linear_ordered_monoid ennreal)) ennreal) : @rank_condition.{0} (canonically_linear_ordered_monoid.{0} ennreal) (@functor.add_const.run.{0 0} (ring.{0} (canonically_linear_ordered_monoid.{0} ennreal)) ennreal h0)  := sorry --non-trivial
lemma new_lemma_25516 (h0 : filter (finset (finset (finset (canonically_linear_ordered_monoid ennreal))))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_25517 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @unique_factorization_monoid.{0} (add_cancel_monoid.{0} empty) (@function.extfun_app.{2 1} Type cancel_comm_monoid_with_zero.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 cancel_comm_monoid_with_zero.{0}) (add_cancel_monoid.{0} empty))  := sorry --non-trivial
lemma new_lemma_25518 (h0 : semiring (comm_semigroup Type)) : is_noetherian_ring (comm_semigroup Type) := sorry --non-trivial
lemma new_lemma_25519 (h0 : functor.comp list has_zero name) : list.nodup (functor.comp.run h0) := sorry --non-trivial
lemma new_lemma_25520 (h0 : topological_space (linear_ordered_add_comm_monoid_with_top ennreal)) : normal_space (linear_ordered_add_comm_monoid_with_top ennreal) := sorry --non-trivial
lemma new_lemma_25521 (h0 : ring (canonically_ordered_comm_semiring congr_arg_kind)) : is_domain (canonically_ordered_comm_semiring congr_arg_kind) := sorry --non-trivial
lemma new_lemma_25522 (h0 : function.extfun Type monoid) : @monoid.fg.{0} (free_add_monoid.{0} empty) (@function.extfun_app.{2 1} Type monoid.{0} h0 (free_add_monoid.{0} empty))  := sorry --non-trivial
lemma new_lemma_25523 (h0 : functor.comp topological_space semigroup ennreal) : @totally_disconnected_space.{0} (semigroup.{0} ennreal) (@functor.comp.run.{0 0 0} topological_space.{0} semigroup.{0} ennreal h0)  := sorry --non-trivial
lemma new_lemma_25524 (h0 : topological_space (simple_graph linarith.comp_source)) : t0_space (simple_graph linarith.comp_source) := sorry --non-trivial
lemma new_lemma_25525 (h0 : list (has_nnnorm char)) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_25526 (h0 : has_lt (add_comm_semigroup (mul_one_class (mul_one_class string.iterator_imp)))) : no_max_order (add_comm_semigroup (mul_one_class (mul_one_class string.iterator_imp))) := sorry --non-trivial
lemma new_lemma_25527 (h0 : not (complete_lattice (has_sub num) -> false)) : @is_compactly_generated.{0} (has_sub.{0} num) (@classical.by_contradiction'.{1} (complete_lattice.{0} (has_sub.{0} num)) h0)  := sorry --non-trivial
lemma new_lemma_25528 (h0 : topological_space (ordered_comm_monoid (ring (ring (ring (has_to_string pos)))))) : normal_space (ordered_comm_monoid (ring (ring (ring (has_to_string pos))))) := sorry --non-trivial
lemma new_lemma_25529 (h0 : functor.comp topological_space add_comm_monoid name) : @t0_space.{0} (add_comm_monoid.{0} name) (@functor.comp.run.{0 0 0} topological_space.{0} add_comm_monoid.{0} name h0)  := sorry --non-trivial
lemma new_lemma_25530 (h0 : topological_space (has_neg_part (add_comm_monoid ennreal))) : totally_separated_space (has_neg_part (add_comm_monoid ennreal)) := sorry --non-trivial
lemma new_lemma_25531 (h0 : functor.add_const (semiring (sub_neg_monoid linarith.comp)) linarith.comp) : @is_noetherian_ring.{0} (sub_neg_monoid.{0} linarith.comp) (@functor.add_const.run.{0 0} (semiring.{0} (sub_neg_monoid.{0} linarith.comp)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_25532 (h0 : not (function.extfun Type topological_space -> false)) : @totally_separated_space.{0} (has_one.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (has_one.{0} empty))  := sorry --non-trivial
lemma new_lemma_25533 (h0 : function.extfun Type list) : palindrome (function.extfun_app h0 (has_neg linarith.comp)) := sorry --non-trivial
lemma new_lemma_25534 (h0 : functor.add_const (topological_space (cancel_monoid Type)) (boolean_algebra (cancel_monoid pos))) : @irreducible_space.{1} (cancel_monoid.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (cancel_monoid.{1} Type)) (boolean_algebra.{0} (cancel_monoid.{0} pos)) h0)  := sorry --non-trivial
lemma new_lemma_25535 (h0 : topological_space (has_ssubset (has_inv to_additive.value_type))) : totally_separated_space (has_ssubset (has_inv to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_25536 (h0 : function.extfun Type complete_lattice) : @complete_lattice.is_Sup_finite_compact.{0} (has_norm.{0} empty) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (has_norm.{0} empty))  := sorry --non-trivial
lemma new_lemma_25537 (h0 : function.extfun Type complete_lattice) : @is_atomistic.{0} (ring.{0} real) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (ring.{0} real))  := sorry --non-trivial
lemma new_lemma_25538 (h1 : list (denumerable string_imp)) : list.nodup h1 := sorry --non-trivial
lemma new_lemma_25539 (h0 : functor.add_const (topological_space (comm_group pos)) pos) : @totally_separated_space.{0} (comm_group.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (comm_group.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_25540 (h0 : has_mul (semi_normed_ring (has_nnnorm fun_info))) (h1 : not (has_zero (semi_normed_ring (has_nnnorm fun_info)) -> false)) : @no_zero_divisors.{0} (semi_normed_ring.{0} (has_nnnorm.{0} fun_info)) h0 (@classical.by_contradiction'.{1} (has_zero.{0} (semi_normed_ring.{0} (has_nnnorm.{0} fun_info))) h1)  := sorry --non-trivial
lemma new_lemma_25541 (h0 : function.extfun Type topological_space) : @path_connected_space.{0} auto.case_option (@function.extfun_app.{2 1} Type topological_space.{0} h0 auto.case_option)  := sorry --non-trivial
lemma new_lemma_25542 (h0 : function.extfun Type complete_lattice) : @complete_lattice.is_Sup_finite_compact.{0} (has_add.{0} ennreal) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (has_add.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_25543 (h0 : functor.add_const (fin has_zero.zero) Type) : @rank_condition.{0} (has_add.{0} real) (@function.extfun_app.{2 1} Type ring.{0} (@matrix.vec_empty.{1} (function.extfun.{2 1} Type ring.{0}) (@functor.add_const.run.{0 0} (fin (@has_zero.zero.{0} nat nat.has_zero)) pos (@matrix.vec_empty.{0} (functor.add_const.{0 0} (fin (@has_zero.zero.{0} nat nat.has_zero)) pos) (@functor.add_const.run.{0 1} (fin (@has_zero.zero.{0} nat nat.has_zero)) Type h0)))) (has_add.{0} real))  := sorry --non-trivial
lemma new_lemma_25544 (h0 : functor.add_const (topological_space (has_add name)) pos) : @preirreducible_space.{0} (has_add.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (has_add.{0} name)) pos h0)  := sorry --non-trivial
lemma new_lemma_25545 (h0 : functor.add_const (group (normed_comm_ring linarith.comp)) (has_pos_part linarith.comp)) : @group.fg.{0} (normed_comm_ring.{0} linarith.comp) (@functor.add_const.run.{0 0} (group.{0} (normed_comm_ring.{0} linarith.comp)) (has_pos_part.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_25546 (h0 : not (group (fintype linarith.comp_source) -> false)) : @group.fg.{0} (fintype.{0} linarith.comp_source) (@classical.by_contradiction'.{1} (group.{0} (fintype.{0} linarith.comp_source)) h0)  := sorry --non-trivial
lemma new_lemma_25547 (h0 : not (function.extfun Type complete_lattice -> false)) : @is_atomistic.{0} (random_gen.{0} num) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type complete_lattice.{0}) h0) (random_gen.{0} num))  := sorry --non-trivial
lemma new_lemma_25548 (h0 : group (semigroup ennreal)) : is_simple_group (semigroup ennreal) := sorry --non-trivial
lemma new_lemma_25549 (h0 : topological_space (boolean_algebra (has_add pos))) : topological_space.separable_space (boolean_algebra (has_add pos)) := sorry --non-trivial
lemma new_lemma_25550 (h0 : topological_space (monoid_with_zero ennreal)) : t0_space (monoid_with_zero ennreal) := sorry --non-trivial
lemma new_lemma_25551 (h0 : function.extfun Type (functor.add_const (topological_space (linear_ordered_field empty)))) : @t0_space.{0} (linear_ordered_field.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (linear_ordered_field.{0} empty)) num (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (topological_space.{0} (linear_ordered_field.{0} empty))) h0 num))  := sorry --non-trivial
lemma new_lemma_25552 (h0 : uniform_space (ring (has_neg Type))) : complete_space (ring (has_neg Type)) := sorry --non-trivial
lemma new_lemma_25553 (h0 : topological_space (complete_distrib_lattice (has_add Type))) : t0_space (complete_distrib_lattice (has_add Type)) := sorry --non-trivial
lemma new_lemma_25554 (h0 : functor.add_const (ordered_comm_monoid (generalized_boolean_algebra linarith.comp)) pos) : @has_exists_mul_of_le.{0} (generalized_boolean_algebra.{0} linarith.comp) (@functor.add_const.run.{0 0} (ordered_comm_monoid.{0} (generalized_boolean_algebra.{0} linarith.comp)) pos h0)  := sorry --non-trivial
lemma new_lemma_25555 (h0 : function.extfun Type (functor.add_const (semiring (has_Sup empty)))) : @is_noetherian_ring.{0} (has_Sup.{0} empty) (@functor.add_const.run.{0 0} (semiring.{0} (has_Sup.{0} empty)) unsigned (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (semiring.{0} (has_Sup.{0} empty))) h0 unsigned))  := sorry --non-trivial
lemma new_lemma_25556 (h0 : topological_space (generalized_boolean_algebra (sub_neg_monoid (has_Inf real)))) : path_connected_space (generalized_boolean_algebra (sub_neg_monoid (has_Inf real))) := sorry --non-trivial
lemma new_lemma_25557 (h0 : complete_lattice (group_with_zero num)) : is_atomistic (group_with_zero num) := sorry --non-trivial
lemma new_lemma_25558 (h0 : nat) (h1 : fin (nat.succ h0) -> fin has_zero.zero) (h2 : fin h0) : @ulower.up.{0} Prop encodable.Prop (@matrix.vec_empty.{0} (@ulower.{0} Prop encodable.Prop) (@matrix.vec_tail.{0} (fin (@has_zero.zero.{0} nat nat.has_zero)) h0 h1 h2))  := sorry --non-trivial
lemma new_lemma_25559 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @t0_space.{0} (has_star.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_star.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_25560 (h0 : topological_space (boolean_algebra.core (has_neg linarith.comp))) : totally_separated_space (boolean_algebra.core (has_neg linarith.comp)) := sorry --non-trivial
lemma new_lemma_25561 (h0 : add_monoid (cancel_monoid (canonically_ordered_comm_semiring (division_ring Type)))) : add_monoid.fg (cancel_monoid (canonically_ordered_comm_semiring (division_ring Type))) := sorry --non-trivial
lemma new_lemma_25562 (h4 : comm_semiring (comm_ring (has_nnnorm to_additive.value_type))) (h5 : polynomial (comm_ring (has_nnnorm to_additive.value_type))) : polynomial.is_primitive h5 := sorry --non-trivial
lemma new_lemma_25563 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_atomistic.{0} (has_one.{0} unsigned) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (has_one.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_25564 (h0 : topological_space (has_neg (add_comm_monoid Type))) : t0_space (has_neg (add_comm_monoid Type)) := sorry --non-trivial
lemma new_lemma_25565 (h0 : functor.add_const (function.extfun (Type 1) ordered_add_comm_monoid) Type) : @archimedean.{1} (has_to_string.{1} Type) (@function.extfun_app.{3 2} (Type 1) ordered_add_comm_monoid.{1} (@functor.add_const.run.{2 1} (function.extfun.{3 2} (Type 1) ordered_add_comm_monoid.{1}) Type h0) (has_to_string.{1} Type))  := sorry --non-trivial
lemma new_lemma_25566 (h0 : topological_space (boolean_algebra (semigroup (has_add environment.implicit_infer_kind)))) : normal_space (boolean_algebra (semigroup (has_add environment.implicit_infer_kind))) := sorry --non-trivial
lemma new_lemma_25567 (h0 : functor.add_const (ring (non_assoc_semiring unsigned)) unsigned) : @rank_condition.{0} (non_assoc_semiring.{0} unsigned) (@functor.add_const.run.{0 0} (ring.{0} (non_assoc_semiring.{0} unsigned)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_25568 (h0 : complete_lattice (comm_group (has_add (has_add (has_add Type))))) : is_atomistic (comm_group (has_add (has_add (has_add Type)))) := sorry --non-trivial
lemma new_lemma_25569 (h0 : group (comm_ring (has_compl (has_compl (has_compl (mul_one_class reducibility_hints)))))) : is_cyclic (comm_ring (has_compl (has_compl (has_compl (mul_one_class reducibility_hints))))) := sorry --non-trivial
lemma new_lemma_25570 (h0 : ring (has_Inf (has_add pos))) : rank_condition (has_Inf (has_add pos)) := sorry --non-trivial
lemma new_lemma_25571 (h0 : functor.add_const (functor.add_const (ring nnreal) num) num) : @is_principal_ideal_ring.{0} nnreal (@functor.add_const.run.{0 0} (ring.{0} nnreal) num (@functor.add_const.run.{0 0} (functor.add_const.{0 0} (ring.{0} nnreal) num) num h0))  := sorry --non-trivial
lemma new_lemma_25572 (h0 : topological_space (ordered_comm_monoid name)) : t1_space (ordered_comm_monoid name) := sorry --non-trivial
lemma new_lemma_25573 (h0 : ring (fintype char)) : is_domain (fintype char) := sorry --non-trivial
lemma new_lemma_25574 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @preirreducible_space.{0} (with_bot.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (with_bot.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_25575 (h0 : functor.add_const (topological_space (has_nndist Type)) linarith.comp) : @regular_space.{1} (has_nndist.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (has_nndist.{1} Type)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_25576 (h0 : ring (non_unital_non_assoc_semiring (mul_one_class char))) : strong_rank_condition (non_unital_non_assoc_semiring (mul_one_class char)) := sorry --non-trivial
lemma new_lemma_25577 (h0 : list (simple_graph unsigned)) : palindrome h0 := sorry --non-trivial
lemma new_lemma_25578 (h0 : functor.add_const (complete_lattice (has_neg_part environment.implicit_infer_kind)) name) : @is_atomistic.{0} (has_neg_part.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (complete_lattice.{0} (has_neg_part.{0} environment.implicit_infer_kind)) name h0)  := sorry --non-trivial
lemma new_lemma_25579 (h0 : group (has_nndist congr_arg_kind)) : normalizer_condition (has_nndist congr_arg_kind) := sorry --non-trivial
lemma new_lemma_25580 (h0 : function.extfun Type ring) : @is_domain.{0} (complete_distrib_lattice.{0} (option.{0} (option.{0} empty))) (@function.extfun_app.{2 1} Type ring.{0} h0 (complete_distrib_lattice.{0} (option.{0} (option.{0} empty))))  := sorry --non-trivial
lemma new_lemma_25581 (h0 : functor.add_const (topological_space (add_comm_monoid pos)) pos) : @totally_disconnected_space.{0} (add_comm_monoid.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (add_comm_monoid.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_25582 (h0 : not (ring (semi_normed_comm_ring (has_nnnorm fun_info)) -> false)) : @strong_rank_condition.{0} (semi_normed_comm_ring.{0} (has_nnnorm.{0} fun_info)) (@classical.by_contradiction'.{1} (ring.{0} (semi_normed_comm_ring.{0} (has_nnnorm.{0} fun_info))) h0)  := sorry --non-trivial
lemma new_lemma_25583 (h0 : functor.add_const (ordered_add_comm_monoid (semigroup Type)) unsigned) : @archimedean.{1} (semigroup.{1} Type) (@functor.add_const.run.{1 0} (ordered_add_comm_monoid.{1} (semigroup.{1} Type)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_25584 (h0 : not (function.extfun Type topological_space -> false)) : @preirreducible_space.{0} (has_union.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (has_union.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_25585 (h0 : function.extfun Type complete_lattice) : @complete_lattice.is_Sup_finite_compact.{0} (sub_neg_monoid.{0} pos) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (sub_neg_monoid.{0} pos))  := sorry --non-trivial
lemma new_lemma_25586 (h0 : function.extfun Type complete_lattice) : @is_compactly_generated.{0} linarith.comp (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 linarith.comp)  := sorry --non-trivial
lemma new_lemma_25587 (h0 : functor.add_const (ordered_comm_monoid (has_neg_part ennreal)) name) : @has_exists_mul_of_le.{0} (has_neg_part.{0} ennreal) (@functor.add_const.run.{0 0} (ordered_comm_monoid.{0} (has_neg_part.{0} ennreal)) name h0)  := sorry --non-trivial
lemma new_lemma_25588 (h0 : functor.add_const (topological_space (canonically_ordered_comm_semiring unsigned)) Type) : @loc_path_connected_space.{0} (canonically_ordered_comm_semiring.{0} unsigned) (@functor.add_const.run.{0 1} (topological_space.{0} (canonically_ordered_comm_semiring.{0} unsigned)) Type h0)  := sorry --non-trivial
lemma new_lemma_25589 (h0 : functor.add_const (topological_space (linear_ordered_field ennreal)) unsigned) : @totally_separated_space.{0} (linear_ordered_field.{0} ennreal) (@functor.add_const.run.{0 0} (topological_space.{0} (linear_ordered_field.{0} ennreal)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_25590 (h0 : topological_space (canonically_linear_ordered_monoid (has_pos_part real))) : sequential_space (canonically_linear_ordered_monoid (has_pos_part real)) := sorry --non-trivial
lemma new_lemma_25591 (h1 : set (simple_graph reducibility_hints)) : set.subsingleton h1 := sorry --non-trivial
lemma new_lemma_25592 (h0 : functor.add_const (cancel_comm_monoid_with_zero (plift empty)) empty) : @unique_factorization_monoid.{1} (plift.{1} empty) (@functor.add_const.run.{1 0} (cancel_comm_monoid_with_zero.{1} (plift.{1} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_25593 (h0 : group (normed_group (has_norm fun_info))) : normalizer_condition (normed_group (has_norm fun_info)) := sorry --non-trivial
lemma new_lemma_25594 (h0 : ring std_gen) : strong_rank_condition std_gen := sorry --non-trivial
lemma new_lemma_25595 (h0 : set (simple_graph ereal)) : set.finite h0 := sorry --non-trivial
lemma new_lemma_25596 (h0 : add_group (has_bot (canonically_linear_ordered_monoid name))) : is_add_cyclic (has_bot (canonically_linear_ordered_monoid name)) := sorry --non-trivial
lemma new_lemma_25597 (h0 : filter (boolean_algebra (ring (ring (ordered_ring (has_pos_part (ordered_ring (has_pos_part (has_neg pos))))))))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_25598 (h0 : finset (complete_distrib_lattice (has_neg_part (has_add unsigned)))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_25599 (h0 : functor.add_const (function.extfun Type ordered_add_comm_monoid) environment.implicit_infer_kind) : @archimedean.{0} (has_nndist.{0} pos) (@function.extfun_app.{2 1} Type ordered_add_comm_monoid.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type ordered_add_comm_monoid.{0}) environment.implicit_infer_kind h0) (has_nndist.{0} pos))  := sorry --non-trivial
lemma new_lemma_25600 (h0 : complete_lattice (complete_semilattice_Sup char)) : complete_lattice.is_Sup_finite_compact (complete_semilattice_Sup char) := sorry --non-trivial
lemma new_lemma_25601 (h0 : not (function.extfun Type uniform_space -> false)) : @complete_space.{0} (measurable_space.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type uniform_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type uniform_space.{0}) h0) (measurable_space.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_25602 (h0 : ring (has_compl (normed_ring to_additive.value_type))) : strong_rank_condition (has_compl (normed_ring to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_25603 (h0 : monoid (with_bot (random_gen string_imp))) : monoid.fg (with_bot (random_gen string_imp)) := sorry --non-trivial
lemma new_lemma_25604 (h0 : not (function.extfun Type topological_space -> false)) : @locally_compact_space.{0} (semiring.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (semiring.{0} num))  := sorry --non-trivial
lemma new_lemma_25605 (h0 : function.extfun Type complete_lattice) : @is_compactly_generated.{0} (add_right_cancel_monoid.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (add_right_cancel_monoid.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_25606 (h0 : not (monoid (cancel_monoid unsigned) -> false)) : @monoid.fg.{0} (cancel_monoid.{0} unsigned) (@classical.by_contradiction'.{1} (monoid.{0} (cancel_monoid.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_25607 (h0 : functor.add_const (topological_space (simple_graph linarith.comp)) pos) : @preconnected_space.{0} (simple_graph.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (simple_graph.{0} linarith.comp)) pos h0)  := sorry --non-trivial
lemma new_lemma_25608 (h0 : function.extfun Type topological_space) : @preirreducible_space.{0} (has_add.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_add.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_25609 (h0 : ring (topological_space (random_gen char))) : is_domain (topological_space (random_gen char)) := sorry --non-trivial
lemma new_lemma_25610 (h0 : function.extfun Type list) : palindrome (function.extfun_app h0 (has_nndist linarith.comp)) := sorry --non-trivial
lemma new_lemma_25611 (h0 : ring (boolean_algebra real)) : strong_rank_condition (boolean_algebra real) := sorry --non-trivial
lemma new_lemma_25612 (h0 : semiring (has_bot (has_Inf linarith.comp))) : is_noetherian_ring (has_bot (has_Inf linarith.comp)) := sorry --non-trivial
lemma new_lemma_25613 (h0 : ring (has_le (has_le string.iterator_imp))) : strong_rank_condition (has_le (has_le string.iterator_imp)) := sorry --non-trivial
lemma new_lemma_25614 (h0 : functor.add_const (topological_space (option num)) empty) : @discrete_topology.{0} (option.{0} num) (@functor.add_const.run.{0 0} (topological_space.{0} (option.{0} num)) empty h0)  := sorry --non-trivial
lemma new_lemma_25615 (h5 : ring (non_unital_non_assoc_semiring to_additive.value_type)) : strong_rank_condition (non_unital_non_assoc_semiring to_additive.value_type) := sorry --non-trivial
lemma new_lemma_25616 (h0 : function.extfun Type list) : list.nodup (function.extfun_app h0 fun_info) := sorry --non-trivial
lemma new_lemma_25617 (h0 : fin has_zero.zero) : @rank_condition.{0} (has_Inf.{0} real) (@matrix.vec_empty.{0} (ring.{0} (has_Inf.{0} real)) (@matrix.vec_empty.{0} (fin (@has_zero.zero.{0} nat nat.has_zero)) h0))  := sorry --non-trivial
lemma new_lemma_25618 (h0 : function.extfun Type topological_space) : @locally_compact_space.{0} (topological_space.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (topological_space.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_25619 (h0 : filter Prop) : @Lim.{0} Prop sierpinski_space (@nonempty_of_inhabited.{1} Prop sort.inhabited.{0}) (@id.{1} (filter.{0} Prop) h0)  := sorry --non-trivial
lemma new_lemma_25620 (h0 : ring (uniform_space (distrib linarith.ineq))) : is_domain (uniform_space (distrib linarith.ineq)) := sorry --non-trivial
lemma new_lemma_25621 (h0 : topological_space (nondiscrete_normed_field string.iterator_imp)) : path_connected_space (nondiscrete_normed_field string.iterator_imp) := sorry --non-trivial
lemma new_lemma_25622 (h0 : complete_lattice (measurable_space linarith.ineq)) : is_compactly_generated (measurable_space linarith.ineq) := sorry --non-trivial
lemma new_lemma_25623 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : list.nodup (function.extfun_app (function.extfun_app h0 list) (normed_comm_ring ennreal)) := sorry --non-trivial
lemma new_lemma_25624 (h0 : function.extfun Type (functor.add_const (list Type))) : list.nodup (functor.add_const.run (function.extfun_app h0 name)) := sorry --non-trivial
lemma new_lemma_25625 (h0 : functor.add_const (uniform_space (finset (ring (ring pos)))) name) : @complete_space.{0} (finset.{0} (ring.{0} (ring.{0} pos))) (@functor.add_const.run.{0 0} (uniform_space.{0} (finset.{0} (ring.{0} (ring.{0} pos)))) name h0)  := sorry --non-trivial
lemma new_lemma_25626 (h0 : topological_space (normed_comm_ring name)) : totally_separated_space (normed_comm_ring name) := sorry --non-trivial
lemma new_lemma_25627 (h0 : functor.add_const (topological_space (boolean_algebra.core Type)) linarith.comp) : @sequential_space.{1} (boolean_algebra.core.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (boolean_algebra.core.{1} Type)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_25628 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_compactly_generated.{0} (has_zero.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (has_zero.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_25629 (h0 : finset (finset (mul_zero_class (mul_zero_class (option pos))))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_25630 (h0 : filter (normed_group (comm_ring linarith.ineq))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_25631 (h0 : ring (id (has_norm congr_arg_kind))) : is_domain (id (has_norm congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_25632 (h0 : functor.add_const (ordered_comm_monoid (has_pos_part Type)) (ring linarith.comp)) : @has_exists_mul_of_le.{1} (has_pos_part.{1} Type) (@functor.add_const.run.{1 0} (ordered_comm_monoid.{1} (has_pos_part.{1} Type)) (ring.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_25633 (h0 : functor.add_const (ring ennreal) unsigned) : @rank_condition.{0} ennreal (@functor.add_const.run.{0 0} (ring.{0} ennreal) unsigned h0)  := sorry --non-trivial
lemma new_lemma_25634 (h0 : functor.add_const (complete_lattice (ring linarith.comp)) (has_neg Type)) : @complete_lattice.is_Sup_finite_compact.{0} (ring.{0} linarith.comp) (@functor.add_const.run.{0 1} (complete_lattice.{0} (ring.{0} linarith.comp)) (has_neg.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_25635 (h0 : function.extfun Type topological_space) : @t1_space.{0} (comm_monoid.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (comm_monoid.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_25636 (h0 : group (id (random_gen (has_top linarith.comp_source)))) : group.fg (id (random_gen (has_top linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_25637 (h0 : ring (has_inv (has_ssubset fun_info))) : is_domain (has_inv (has_ssubset fun_info)) := sorry --non-trivial
lemma new_lemma_25638 (h0 : functor.add_const (topological_space (pseudo_metric_space ennreal)) pos) : @topological_space.separable_space.{0} (pseudo_metric_space.{0} ennreal) (@functor.add_const.run.{0 0} (topological_space.{0} (pseudo_metric_space.{0} ennreal)) pos h0)  := sorry --non-trivial
lemma new_lemma_25639 (h0 : add_monoid (partial_order empty)) : add_monoid.fg (partial_order empty) := sorry --non-trivial
lemma new_lemma_25640 (h1 : complete_lattice (has_nnnorm (random_gen (random_gen (random_gen to_additive.value_type))))) : is_compactly_generated (has_nnnorm (random_gen (random_gen (random_gen to_additive.value_type)))) := sorry --non-trivial
lemma new_lemma_25641 (h0 : functor.add_const (add_group (mul_zero_class ennreal)) unsigned) : @is_add_cyclic.{0} (mul_zero_class.{0} ennreal) (@functor.add_const.run.{0 0} (add_group.{0} (mul_zero_class.{0} ennreal)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_25642 (h0 : topological_space (linear_ordered_add_comm_monoid_with_top num)) : normal_space (linear_ordered_add_comm_monoid_with_top num) := sorry --non-trivial
lemma new_lemma_25643 (h0 : topological_space (canonically_ordered_comm_semiring (option empty))) : t1_space (canonically_ordered_comm_semiring (option empty)) := sorry --non-trivial
lemma new_lemma_25644 (h0 : functor.add_const (semiring (has_to_string unsigned)) unsigned) : @is_noetherian_ring.{0} (has_to_string.{0} unsigned) (@functor.add_const.run.{0 0} (semiring.{0} (has_to_string.{0} unsigned)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_25645 (h0 : complete_lattice (add_semigroup (option unsigned))) : is_compactly_generated (add_semigroup (option unsigned)) := sorry --non-trivial
lemma new_lemma_25646 (h0 : function.extfun Type topological_space) : @path_connected_space.{0} (semigroup.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (semigroup.{0} name))  := sorry --non-trivial
lemma new_lemma_25647 (h0 : functor.add_const (ring (has_to_string Type)) unsigned) : @rank_condition.{1} (has_to_string.{1} Type) (@functor.add_const.run.{1 0} (ring.{1} (has_to_string.{1} Type)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_25648 (h0 : group (linear_ordered_add_comm_group (with_bot string_imp))) : is_cyclic (linear_ordered_add_comm_group (with_bot string_imp)) := sorry --non-trivial
lemma new_lemma_25649 (h0 : topological_space (ring (mul_one_class (has_neg (has_pos_part (finset (mul_one_class Type))))))) : preconnected_space (ring (mul_one_class (has_neg (has_pos_part (finset (mul_one_class Type)))))) := sorry --non-trivial
lemma new_lemma_25650 (h0 : monoid (add_right_cancel_monoid (semiring (semiring (semiring unsigned))))) : monoid.fg (add_right_cancel_monoid (semiring (semiring (semiring unsigned)))) := sorry --non-trivial
lemma new_lemma_25651 (h0 : function.extfun (finset (Type -> Type)) (has_mem.mem topological_space)) : @discrete_topology.{0} (normed_group.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) topological_space.{0} (@function.extfun_app.{2 0} (finset.{1} (Type → Type)) (@has_mem.mem.{1 1} (Type → Type) (finset.{1} (Type → Type)) (@finset.has_mem.{1} (Type → Type)) topological_space.{0}) h0 (@has_emptyc.emptyc.{1} (finset.{1} (Type → Type)) (@finset.has_emptyc.{1} (Type → Type))))) (normed_group.{0} num))  := sorry --non-trivial
lemma new_lemma_25652 (h0 : functor.add_const (functor.comp complete_lattice has_nndist ennreal) pos) : @is_atomistic.{0} (has_nndist.{0} ennreal) (@functor.comp.run.{0 0 0} complete_lattice.{0} has_nndist.{0} ennreal (@functor.add_const.run.{0 0} (functor.comp.{0 0 0} complete_lattice.{0} has_nndist.{0} ennreal) pos h0))  := sorry --non-trivial
lemma new_lemma_25653 (h0 : functor.add_const (complete_lattice (has_nndist unsigned)) pos) : @is_compactly_generated.{0} (has_nndist.{0} unsigned) (@functor.add_const.run.{0 0} (complete_lattice.{0} (has_nndist.{0} unsigned)) pos h0)  := sorry --non-trivial
lemma new_lemma_25654 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @rank_condition.{0} (finset.{0} ennreal) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (finset.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_25655 (h0 : not (uniform_space (option empty) -> false)) : @complete_space.{0} (option.{0} empty) (@classical.by_contradiction'.{1} (uniform_space.{0} (option.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_25656 (h0 : group (has_top (has_top (has_top fun_info)))) : normalizer_condition (has_top (has_top (has_top fun_info))) := sorry --non-trivial
lemma new_lemma_25657 (h0 : topological_space (linear_ordered_comm_group (option empty))) : totally_separated_space (linear_ordered_comm_group (option empty)) := sorry --non-trivial
lemma new_lemma_25658 (h0 : function.extfun Type ring) : @strong_rank_condition.{0} (has_neg.{0} name) (@function.extfun_app.{2 1} Type ring.{0} h0 (has_neg.{0} name))  := sorry --non-trivial
lemma new_lemma_25659 (h0 : ring (left_cancel_monoid (option unsigned))) : rank_condition (left_cancel_monoid (option unsigned)) := sorry --non-trivial
lemma new_lemma_25660 (h0 : topological_space (pseudo_metric_space (has_neg_part pos))) : sequential_space (pseudo_metric_space (has_neg_part pos)) := sorry --non-trivial
lemma new_lemma_25661 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @rank_condition.{0} (mul_zero_class.{0} num) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (mul_zero_class.{0} num))  := sorry --non-trivial
lemma new_lemma_25662 (h0 : topological_space (simple_graph (has_neg (has_add name)))) : path_connected_space (simple_graph (has_neg (has_add name))) := sorry --non-trivial
lemma new_lemma_25663 (h0 : topological_space (normed_comm_ring (has_neg (ring (has_add Type))))) : path_connected_space (normed_comm_ring (has_neg (ring (has_add Type)))) := sorry --non-trivial
lemma new_lemma_25664 (h0 : topological_space (normed_comm_ring (comm_group Type))) : totally_disconnected_space (normed_comm_ring (comm_group Type)) := sorry --non-trivial
lemma new_lemma_25665 (h0 : function.extfun (((Type -> Type) -> Type 1) -> Type 1) (function.extfun ((Type -> Type) -> Type 1))) : @locally_compact_space.{0} (has_one.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) (@function.extfun_app.{3 2} ((Type → Type) → Type 1) (function.extfun.{2 2} (Type → Type)) (@function.extfun_app.{3 3} (((Type → Type) → Type 1) → Type 1) (function.extfun.{3 2} ((Type → Type) → Type 1)) h0 (function.extfun.{2 2} (Type → Type))) (function.extfun.{2 1} Type)) topological_space.{0}) (has_one.{0} empty))  := sorry --non-trivial
lemma new_lemma_25666 (h0 : function.extfun Type topological_space) : @totally_separated_space.{0} (add_comm_monoid.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (add_comm_monoid.{0} pos))  := sorry --non-trivial
lemma new_lemma_25667 (h0 : topological_space (cancel_monoid unsigned)) : t1_space (cancel_monoid unsigned) := sorry --non-trivial
lemma new_lemma_25668 (h0 : add_group (has_compl (has_nnnorm reducibility_hints))) : is_add_cyclic (has_compl (has_nnnorm reducibility_hints)) := sorry --non-trivial
lemma new_lemma_25669 (h0 : ordered_semiring (sub_neg_monoid (sub_neg_monoid Type))) (h1 : topological_space (floor_semiring (sub_neg_monoid (sub_neg_monoid Type)))) : normal_space (floor_semiring (sub_neg_monoid (sub_neg_monoid Type))) := sorry --non-trivial
lemma new_lemma_25670 (h0 : ring (uniform_space (uniform_space (semi_normed_ring reducibility_hints)))) : rank_condition (uniform_space (uniform_space (semi_normed_ring reducibility_hints))) := sorry --non-trivial
lemma new_lemma_25671 (h0 : monoid (boolean_algebra (mul_one_class (normed_comm_ring (mul_one_class linarith.comp))))) : monoid.fg (boolean_algebra (mul_one_class (normed_comm_ring (mul_one_class linarith.comp)))) := sorry --non-trivial
lemma new_lemma_25672 (h0 : not (group (comm_ring fun_info) -> false)) : @is_cyclic.{0} (comm_ring.{0} fun_info) (@classical.by_contradiction'.{1} (group.{0} (comm_ring.{0} fun_info)) h0)  := sorry --non-trivial
lemma new_lemma_25673 (h0 : functor.comp complete_lattice semi_normed_ring reducibility_hints) : @complete_lattice.is_Sup_finite_compact.{0} (semi_normed_ring.{0} reducibility_hints) (@functor.comp.run.{0 0 0} complete_lattice.{0} semi_normed_ring.{0} reducibility_hints h0)  := sorry --non-trivial
lemma new_lemma_25674 (h0 : group (has_to_string congr_arg_kind)) : is_simple_group (has_to_string congr_arg_kind) := sorry --non-trivial
lemma new_lemma_25675 (h0 : filter (has_neg_part (option (has_add pos)))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_25676 (h0 : function.extfun Type filter) : filter.ne_bot (function.extfun_app h0 (is_R_or_C unsigned)) := sorry --non-trivial
lemma new_lemma_25677 (h0 : functor.add_const (topological_space (finset pos)) linarith.comp) : @topological_space.separable_space.{0} (finset.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (finset.{0} pos)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_25678 (h0 : complete_lattice (has_norm (random_gen string_imp))) : is_compactly_generated (has_norm (random_gen string_imp)) := sorry --non-trivial
lemma new_lemma_25679 (h0 : topological_space (linear_ordered_add_comm_group (has_top linarith.comp_source))) : locally_compact_space (linear_ordered_add_comm_group (has_top linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_25680 (h0 : functor.add_const (function.extfun (Type 1) topological_space) Type) : @path_connected_space.{1} (comm_group.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@functor.add_const.run.{2 1} (function.extfun.{3 2} (Type 1) topological_space.{1}) Type h0) (comm_group.{1} Type))  := sorry --non-trivial
lemma new_lemma_25681 (h0 : topological_space (id (semiring (has_norm empty)))) : irreducible_space (id (semiring (has_norm empty))) := sorry --non-trivial
lemma new_lemma_25682 (h0 : functor.add_const (topological_space (has_to_string unsigned)) pos) : @preirreducible_space.{0} (has_to_string.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (has_to_string.{0} unsigned)) pos h0)  := sorry --non-trivial
lemma new_lemma_25683 (h1 : uniform_space linarith.comp) : separated_space linarith.comp := sorry --non-trivial
lemma new_lemma_25684 (h0 : topological_space (ordered_comm_ring (has_add Type))) : t1_space (ordered_comm_ring (has_add Type)) := sorry --non-trivial
lemma new_lemma_25685 (h0 : topological_space (complete_linear_order (semiring congr_arg_kind))) : irreducible_space (complete_linear_order (semiring congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_25686 (h0 : ring (has_emptyc (has_norm (has_norm fun_info)))) : rank_condition (has_emptyc (has_norm (has_norm fun_info))) := sorry --non-trivial
lemma new_lemma_25687 (h0 : complete_lattice (has_ssubset string_imp)) : complete_lattice.is_Sup_finite_compact (has_ssubset string_imp) := sorry --non-trivial
lemma new_lemma_25688 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @archimedean.{0} (linear_ordered_comm_group.{0} num) (@function.extfun_app.{2 1} Type ordered_add_comm_monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ordered_add_comm_monoid.{0}) (linear_ordered_comm_group.{0} num))  := sorry --non-trivial
lemma new_lemma_25689 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @complete_space.{0} (has_add.{0} unsigned) (@function.extfun_app.{2 1} Type uniform_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 uniform_space.{0}) (has_add.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_25690 (h0 : functor.add_const (finset (ring name)) pos) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_25691 (h0 : function.extfun Type topological_space) : @totally_separated_space.{0} (boolean_algebra.core.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (boolean_algebra.core.{0} name))  := sorry --non-trivial
lemma new_lemma_25692 (h1 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) (h2 : coe_sort (option.is_some (function.extfun_app (function.extfun_app h1 option) (function.extfun Type group)))) : @normalizer_condition.{0} (has_emptyc.{0} linarith.ineq) (@function.extfun_app.{2 1} Type group.{0} (@option.get.{1} (function.extfun.{2 1} Type group.{0}) (@function.extfun_app.{3 2} (Type 1) option.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h1 option.{1}) (function.extfun.{2 1} Type group.{0})) h2) (has_emptyc.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_25693 (h0 : complete_lattice (add_comm_monoid (comm_group (comm_group (has_add Type))))) : is_compactly_generated (add_comm_monoid (comm_group (comm_group (has_add Type)))) := sorry --non-trivial
lemma new_lemma_25694 (h0 : topological_space (non_assoc_semiring (semiring num))) : irreducible_space (non_assoc_semiring (semiring num)) := sorry --non-trivial
lemma new_lemma_25695 (h0 : add_group (encodable to_additive.value_type)) : is_add_cyclic (encodable to_additive.value_type) := sorry --non-trivial
lemma new_lemma_25696 (h0 : functor.add_const (semiring (simple_graph linarith.comp)) linarith.comp) : @is_noetherian_ring.{0} (simple_graph.{0} linarith.comp) (@functor.add_const.run.{0 0} (semiring.{0} (simple_graph.{0} linarith.comp)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_25697 (h0 : functor.add_const (ring (ring pos)) pos) : @is_principal_ideal_ring.{0} (ring.{0} pos) (@functor.add_const.run.{0 0} (ring.{0} (ring.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_25698 (h1 : complete_lattice linarith.comp) : is_atomistic linarith.comp := sorry --non-trivial
lemma new_lemma_25699 (h0 : function.extfun Type topological_space) : @regular_space.{0} (has_nndist.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_nndist.{0} pos))  := sorry --non-trivial
lemma new_lemma_25700 (h0 : function.extfun Type topological_space) : @t1_space.{0} (filter.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (filter.{0} empty))  := sorry --non-trivial
lemma new_lemma_25701 (h0 : group (has_neg (comm_group Type))) : is_cyclic (has_neg (comm_group Type)) := sorry --non-trivial
lemma new_lemma_25702 (h0 : topological_space (ordered_comm_ring (has_neg (has_neg (has_neg (has_neg name)))))) : preirreducible_space (ordered_comm_ring (has_neg (has_neg (has_neg (has_neg name))))) := sorry --non-trivial
lemma new_lemma_25703 (h0 : topological_space (normed_comm_ring (measurable_space unsigned))) : totally_separated_space (normed_comm_ring (measurable_space unsigned)) := sorry --non-trivial
lemma new_lemma_25704 (h0 : topological_space (left_cancel_monoid num)) : t0_space (left_cancel_monoid num) := sorry --non-trivial
lemma new_lemma_25705 (h0 : functor.add_const (topological_space (boolean_algebra linarith.comp)) environment.implicit_infer_kind) : @t0_space.{0} (boolean_algebra.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (boolean_algebra.{0} linarith.comp)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_25706 (h0 : finset (has_zero (finset pos))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_25707 (h0 : ordered_comm_monoid (has_zero (normed_comm_ring linarith.comp))) : has_exists_mul_of_le (has_zero (normed_comm_ring linarith.comp)) := sorry --non-trivial
lemma new_lemma_25708 (h0 : functor.add_const (topological_space (partial_order congr_arg_kind)) unsigned) : @totally_separated_space.{0} (partial_order.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (partial_order.{0} congr_arg_kind)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_25709 (h0 : ordered_add_comm_monoid (has_nndist (finset (finset Type)))) : archimedean (has_nndist (finset (finset Type))) := sorry --non-trivial
lemma new_lemma_25710 (h0 : ring (complete_linear_order (semiring (semiring empty)))) : is_domain (complete_linear_order (semiring (semiring empty))) := sorry --non-trivial
lemma new_lemma_25711 (h0 : topological_space (nondiscrete_normed_field fun_info)) : totally_disconnected_space (nondiscrete_normed_field fun_info) := sorry --non-trivial
lemma new_lemma_25712 (h0 : ring (has_pos_part (has_pos_part (ordered_comm_ring (has_add real))))) : is_domain (has_pos_part (has_pos_part (ordered_comm_ring (has_add real)))) := sorry --non-trivial
lemma new_lemma_25713 (h0 : functor.add_const (topological_space (finset ennreal)) unsigned) : @irreducible_space.{0} (finset.{0} ennreal) (@functor.add_const.run.{0 0} (topological_space.{0} (finset.{0} ennreal)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_25714 (h0 : topological_space (comm_semigroup (has_add real))) : preirreducible_space (comm_semigroup (has_add real)) := sorry --non-trivial
lemma new_lemma_25715 (h0 : complete_lattice subsingleton_info) : is_compactly_generated subsingleton_info := sorry --non-trivial
lemma new_lemma_25716 (h0 : function.extfun Type topological_space) : @t0_space.{0} (add_cancel_monoid.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (add_cancel_monoid.{0} empty))  := sorry --non-trivial
lemma new_lemma_25717 (h0 : complete_lattice (semiring linarith.comp_source)) : complete_lattice.is_Sup_finite_compact (semiring linarith.comp_source) := sorry --non-trivial
lemma new_lemma_25718 (h0 : function.extfun Type topological_space) : @discrete_topology.{0} (measurable_space.dynkin_system.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (measurable_space.dynkin_system.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_25719 (h1 : preorder enat) (h2 : set enat) : set.is_pwo h2 := sorry --non-trivial
lemma new_lemma_25720 (h0 : topological_space (normed_group (has_norm empty))) : discrete_topology (normed_group (has_norm empty)) := sorry --non-trivial
lemma new_lemma_25721 (h0 : function.extfun Type complete_lattice) : @is_atomistic.{0} (has_sub.{0} unsigned) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (has_sub.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_25722 (h0 : function.extfun Type add_monoid) : @add_monoid.fg.{0} (measure_theory.measure_space.{0} empty) (@function.extfun_app.{2 1} Type add_monoid.{0} h0 (measure_theory.measure_space.{0} empty))  := sorry --non-trivial
lemma new_lemma_25723 (h0 : ring (id (semiring (semiring num)))) : strong_rank_condition (id (semiring (semiring num))) := sorry --non-trivial
lemma new_lemma_25724 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @add_monoid.fg.{0} (add_comm_monoid.{0} unsigned) (@function.extfun_app.{2 1} Type add_monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 add_monoid.{0}) (add_comm_monoid.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_25725 (h0 : topological_space (canonically_ordered_monoid (has_Inf (has_Inf linarith.comp)))) : preconnected_space (canonically_ordered_monoid (has_Inf (has_Inf linarith.comp))) := sorry --non-trivial
lemma new_lemma_25726 (h0 : set (prod real real)) (h1 : prod real real) : symmetrize_rel h0 h1 := sorry --non-trivial
lemma new_lemma_25727 (h0 : filter (has_ssubset (has_top (has_top linarith.ineq)))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_25728 (h0 : list (add_cancel_comm_monoid (option (option empty)))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_25729 (h1 : complete_lattice (mul_one_class (mul_one_class (mul_one_class char)))) : complete_lattice.is_Sup_finite_compact (mul_one_class (mul_one_class (mul_one_class char))) := sorry --non-trivial
lemma new_lemma_25730 (h0 : filter (denumerable (random_gen fun_info))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_25731 (h0 : add_monoid (add_cancel_monoid (option num))) : add_monoid.fg (add_cancel_monoid (option num)) := sorry --non-trivial
lemma new_lemma_25732 (h0 : functor.add_const (ring (ring name)) unsigned) : @is_domain.{0} (ring.{0} name) (@functor.add_const.run.{0 0} (ring.{0} (ring.{0} name)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_25733 (h0 : topological_space (group_with_zero (option ennreal))) : locally_compact_space (group_with_zero (option ennreal)) := sorry --non-trivial
lemma new_lemma_25734 (h0 : functor.add_const (ring (complete_distrib_lattice linarith.comp)) linarith.comp) : @is_principal_ideal_ring.{0} (complete_distrib_lattice.{0} linarith.comp) (@functor.add_const.run.{0 0} (ring.{0} (complete_distrib_lattice.{0} linarith.comp)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_25735 (h0 : not (cancel_comm_monoid_with_zero (has_sub num) -> false)) : @unique_factorization_monoid.{0} (has_sub.{0} num) (@classical.by_contradiction'.{1} (cancel_comm_monoid_with_zero.{0} (has_sub.{0} num)) h0)  := sorry --non-trivial
lemma new_lemma_25736 (h0 : functor.add_const (topological_space (normed_comm_ring linarith.comp)) environment.implicit_infer_kind) : @t1_space.{0} (normed_comm_ring.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (normed_comm_ring.{0} linarith.comp)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_25737 (h0 : not (add_monoid (add_group num) -> false)) : @add_monoid.fg.{0} (add_group.{0} num) (@classical.by_contradiction'.{1} (add_monoid.{0} (add_group.{0} num)) h0)  := sorry --non-trivial
lemma new_lemma_25738 (h0 : function.extfun Type semiring) : @is_noetherian_ring.{0} (ordered_cancel_add_comm_monoid.{0} num) (@function.extfun_app.{2 1} Type semiring.{0} h0 (ordered_cancel_add_comm_monoid.{0} num))  := sorry --non-trivial
lemma new_lemma_25739 (h0 : not (list (denumerable char) -> false)) (h1 : list (denumerable char)) : list.subperm (classical.by_contradiction' h0) h1 := sorry --non-trivial
lemma new_lemma_25740 (h0 : ring (cancel_monoid (has_neg_part unsigned))) : strong_rank_condition (cancel_monoid (has_neg_part unsigned)) := sorry --non-trivial
lemma new_lemma_25741 (h0 : add_comm_group std_gen) (h1 : has_norm std_gen) : semi_normed_group.core std_gen := sorry --non-trivial
lemma new_lemma_25742 (h0 : topological_space (ring (option empty))) : totally_disconnected_space (ring (option empty)) := sorry --non-trivial
lemma new_lemma_25743 (h0 : not (ring (add_group linarith.comp) -> false)) : @is_domain.{0} (add_group.{0} linarith.comp) (@classical.by_contradiction'.{1} (ring.{0} (add_group.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_25744 (h0 : group (has_neg_part (has_nndist name))) : group.fg (has_neg_part (has_nndist name)) := sorry --non-trivial
lemma new_lemma_25745 (h0 : topological_space (has_neg_part pos)) : discrete_topology (has_neg_part pos) := sorry --non-trivial
lemma new_lemma_25746 (h0 : topological_space char) (h1 : set char) : is_seq_compact h1 := sorry --non-trivial
lemma new_lemma_25747 (h0 : topological_space (with_bot (semiring (has_one linarith.comp)))) : totally_disconnected_space (with_bot (semiring (has_one linarith.comp))) := sorry --non-trivial
lemma new_lemma_25748 (h0 : not (equiv.perm fun_info -> false)) (h1 h2 : fun_info) : equiv.perm.same_cycle (classical.by_contradiction' h0) h1 h2 := sorry --non-trivial
lemma new_lemma_25749 (h0 : add_group (has_to_string reducibility_hints)) : is_add_cyclic (has_to_string reducibility_hints) := sorry --non-trivial
lemma new_lemma_25750 (h0 : function.extfun Type ordered_add_comm_monoid) : @archimedean.{0} (normed_group.{0} (semiring.{0} empty)) (@function.extfun_app.{2 1} Type ordered_add_comm_monoid.{0} h0 (normed_group.{0} (semiring.{0} empty)))  := sorry --non-trivial
lemma new_lemma_25751 (h0 : topological_space (has_pos_part (has_add (ring pos)))) : t0_space (has_pos_part (has_add (ring pos))) := sorry --non-trivial
lemma new_lemma_25752 (h0 : ring (has_neg (finset Type))) : rank_condition (has_neg (finset Type)) := sorry --non-trivial
lemma new_lemma_25753 (h0 : ring (has_inv (random_gen string_imp))) : strong_rank_condition (has_inv (random_gen string_imp)) := sorry --non-trivial
lemma new_lemma_25754 (h0 : function.extfun Type topological_space) : @t0_space.{0} (semigroup.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (semigroup.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_25755 (h0 : topological_space (has_nndist congr_arg_kind)) : loc_path_connected_space (has_nndist congr_arg_kind) := sorry --non-trivial
lemma new_lemma_25756 (h0 : topological_space (linear_ordered_field (option (option (option (option empty)))))) : topological_space.separable_space (linear_ordered_field (option (option (option (option empty))))) := sorry --non-trivial
lemma new_lemma_25757 (h1 : function.extfun (Type -> Type) (function.extfun Type)) : @normalizer_condition.{0} (with_bot.{0} linarith.ineq) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h1 group.{0}) (with_bot.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_25758 (h0 : not (group (has_ssubset (has_nnnorm linarith.ineq)) -> false)) : @is_cyclic.{0} (has_ssubset.{0} (has_nnnorm.{0} linarith.ineq)) (@classical.by_contradiction'.{1} (group.{0} (has_ssubset.{0} (has_nnnorm.{0} linarith.ineq))) h0)  := sorry --non-trivial
lemma new_lemma_25759 (h0 : function.extfun Type list) : palindrome (function.extfun_app h0 (semiring congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_25760 (h0 : ring (ordered_ring linarith.ineq)) : strong_rank_condition (ordered_ring linarith.ineq) := sorry --non-trivial
lemma new_lemma_25761 (h0 : cancel_comm_monoid_with_zero (linear_ordered_comm_ring unsigned)) : unique_factorization_monoid (linear_ordered_comm_ring unsigned) := sorry --non-trivial
lemma new_lemma_25762 (h0 : topological_space (has_to_string (ring Type))) : loc_path_connected_space (has_to_string (ring Type)) := sorry --non-trivial
lemma new_lemma_25763 (h0 : with_bot (with_bot Prop)) (h1 : ne h0 has_bot.bot) (h2 : ne (with_bot.unbot h0 h1) has_bot.bot) : with_bot.unbot (with_bot.unbot h0 h1) h2 := sorry --non-trivial
lemma new_lemma_25764 (h0 : list (complete_distrib_lattice (has_neg Type))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_25765 (h0 : group (with_bot (random_gen (has_inv linarith.comp_source)))) : normalizer_condition (with_bot (random_gen (has_inv linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_25766 (h0 : topological_space (ordered_comm_ring (has_add Type))) : t0_space (ordered_comm_ring (has_add Type)) := sorry --non-trivial
lemma new_lemma_25767 (h0 : add_group (add_comm_semigroup (mul_one_class (mul_one_class ereal)))) : is_add_cyclic (add_comm_semigroup (mul_one_class (mul_one_class ereal))) := sorry --non-trivial
lemma new_lemma_25768 (h1 : add_group (ordered_cancel_add_comm_monoid (has_nnnorm char))) : is_add_cyclic (ordered_cancel_add_comm_monoid (has_nnnorm char)) := sorry --non-trivial
lemma new_lemma_25769 (h0 : list (has_top (has_nnnorm (has_nnnorm fun_info)))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_25770 (h0 : has_lt (has_inter fun_info)) : no_max_order (has_inter fun_info) := sorry --non-trivial
lemma new_lemma_25771 (h0 : functor.add_const (function.extfun Type cancel_comm_monoid_with_zero) name) : @unique_factorization_monoid.{0} (has_to_string.{0} linarith.comp) (@function.extfun_app.{2 1} Type cancel_comm_monoid_with_zero.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type cancel_comm_monoid_with_zero.{0}) name h0) (has_to_string.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_25772 (h0 : fin has_zero.zero) : @monoid.fg.{0} (normed_lattice_add_comm_group.{0} pos) (@matrix.vec_empty.{0} (monoid.{0} (normed_lattice_add_comm_group.{0} pos)) h0)  := sorry --non-trivial
lemma new_lemma_25773 (h0 : function.extfun Type add_group) : @is_add_cyclic.{0} (has_neg.{0} pos) (@function.extfun_app.{2 1} Type add_group.{0} h0 (has_neg.{0} pos))  := sorry --non-trivial
lemma new_lemma_25774 (h0 : topological_space (ring (semigroup name))) : totally_disconnected_space (ring (semigroup name)) := sorry --non-trivial
lemma new_lemma_25775 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_principal_ideal_ring.{0} environment.implicit_infer_kind (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) environment.implicit_infer_kind)  := sorry --non-trivial
lemma new_lemma_25776 (h0 : functor.add_const (topological_space (boolean_algebra environment.implicit_infer_kind)) name) : @sequential_space.{0} (boolean_algebra.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (boolean_algebra.{0} environment.implicit_infer_kind)) name h0)  := sorry --non-trivial
lemma new_lemma_25777 (h0 : functor.add_const (ordered_comm_monoid (complete_distrib_lattice pos)) name) : @has_exists_mul_of_le.{0} (complete_distrib_lattice.{0} pos) (@functor.add_const.run.{0 0} (ordered_comm_monoid.{0} (complete_distrib_lattice.{0} pos)) name h0)  := sorry --non-trivial
lemma new_lemma_25778 (h0 : add_monoid (mul_zero_class name)) : add_monoid.fg (mul_zero_class name) := sorry --non-trivial
lemma new_lemma_25779 (h0 : functor.add_const (uniform_space (partial_order num)) num) : @separated_space.{0} (partial_order.{0} num) (@functor.add_const.run.{0 0} (uniform_space.{0} (partial_order.{0} num)) num h0)  := sorry --non-trivial
lemma new_lemma_25780 (h0 : function.extfun Type topological_space) : @discrete_topology.{0} (with_bot.{0} (has_norm.{0} (has_norm.{0} (has_norm.{0} (has_norm.{0} (random_gen.{0} (has_norm.{0} num))))))) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (with_bot.{0} (has_norm.{0} (has_norm.{0} (has_norm.{0} (has_norm.{0} (random_gen.{0} (has_norm.{0} num))))))))  := sorry --non-trivial
lemma new_lemma_25781 (h0 : complete_lattice (semigroup (ring linarith.comp))) : is_compactly_generated (semigroup (ring linarith.comp)) := sorry --non-trivial
lemma new_lemma_25782 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @add_monoid.fg.{0} linarith.comp (@function.extfun_app.{2 1} Type add_monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 add_monoid.{0}) linarith.comp)  := sorry --non-trivial
lemma new_lemma_25783 (h0 : functor.add_const (group (boolean_algebra.core Type)) unsigned) : @is_simple_group.{1} (boolean_algebra.core.{1} Type) (@functor.add_const.run.{1 0} (group.{1} (boolean_algebra.core.{1} Type)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_25784 (h0 : topological_space (normed_comm_ring linarith.comp)) : sequential_space (normed_comm_ring linarith.comp) := sorry --non-trivial
lemma new_lemma_25785 (h0 : ring (has_bot (has_neg (has_neg pos)))) : strong_rank_condition (has_bot (has_neg (has_neg pos))) := sorry --non-trivial
lemma new_lemma_25786 (h0 : has_mem.mem topological_space has_emptyc.emptyc) : @path_connected_space.{0} to_additive.value_type (@function.extfun_app.{2 1} Type topological_space.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) topological_space.{0} h0) to_additive.value_type)  := sorry --non-trivial
lemma new_lemma_25787 (h0 : ring (semigroup (ring (ring Type)))) : is_domain (semigroup (ring (ring Type))) := sorry --non-trivial
lemma new_lemma_25788 (h0 : functor.add_const (topological_space (complete_distrib_lattice linarith.comp)) (semigroup Type)) : @sequential_space.{0} (complete_distrib_lattice.{0} linarith.comp) (@functor.add_const.run.{0 1} (topological_space.{0} (complete_distrib_lattice.{0} linarith.comp)) (semigroup.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_25789 (h0 : semiring (ordered_comm_ring (ring linarith.comp))) : is_noetherian_ring (ordered_comm_ring (ring linarith.comp)) := sorry --non-trivial
lemma new_lemma_25790 (h1 : topological_space linarith.ineq) : topological_space.first_countable_topology linarith.ineq := sorry --non-trivial
lemma new_lemma_25791 (h0 : uniform_space (cancel_monoid (comm_group name))) : complete_space (cancel_monoid (comm_group name)) := sorry --non-trivial
lemma new_lemma_25792 (h0 : topological_space (complete_distrib_lattice name)) : totally_separated_space (complete_distrib_lattice name) := sorry --non-trivial
lemma new_lemma_25793 (h0 : topological_space (has_neg (finset Type))) : irreducible_space (has_neg (finset Type)) := sorry --non-trivial
lemma new_lemma_25794 (h0 : functor.add_const (uniform_space (has_zero Type)) Type) : @separated_space.{1} (has_zero.{1} Type) (@functor.add_const.run.{1 1} (uniform_space.{1} (has_zero.{1} Type)) Type h0)  := sorry --non-trivial
lemma new_lemma_25795 (h0 : function.extfun Type topological_space) : @loc_path_connected_space.{0} (has_nndist.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_nndist.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_25796 (h0 : topological_space (pseudo_metric_space (option (option (option empty))))) : t0_space (pseudo_metric_space (option (option (option empty)))) := sorry --non-trivial
lemma new_lemma_25797 (h1 : topological_space (uniform_space linarith.ineq)) : t0_space (uniform_space linarith.ineq) := sorry --non-trivial
lemma new_lemma_25798 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @t0_space.{0} (normed_comm_ring.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (normed_comm_ring.{0} empty))  := sorry --non-trivial
lemma new_lemma_25799 (h0 : group (add_comm_monoid (has_neg_part (has_neg Type)))) : group.fg (add_comm_monoid (has_neg_part (has_neg Type))) := sorry --non-trivial
lemma new_lemma_25800 (h0 : functor.add_const (ring (finset linarith.comp)) pos) : @is_principal_ideal_ring.{0} (finset.{0} linarith.comp) (@functor.add_const.run.{0 0} (ring.{0} (finset.{0} linarith.comp)) pos h0)  := sorry --non-trivial
lemma new_lemma_25801 (h0 : group (has_zero (has_neg (finset (has_neg pos))))) : is_cyclic (has_zero (has_neg (finset (has_neg pos)))) := sorry --non-trivial
lemma new_lemma_25802 (h0 : complete_lattice (linear_ordered_add_comm_group (has_top fun_info))) : is_atomistic (linear_ordered_add_comm_group (has_top fun_info)) := sorry --non-trivial
lemma new_lemma_25803 (h0 : functor.add_const (function.extfun Type topological_space) linarith.comp) : @locally_compact_space.{0} (has_to_string.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) linarith.comp h0) (has_to_string.{0} pos))  := sorry --non-trivial
lemma new_lemma_25804 (h0 : monoid (cancel_monoid unsigned) -> monoid (cancel_monoid unsigned) -> Prop) : is_symm (monoid (cancel_monoid unsigned)) h0 := sorry --non-trivial
lemma new_lemma_25805 (h0 : topological_space (normed_comm_ring (has_add (has_add pos)))) : normal_space (normed_comm_ring (has_add (has_add pos))) := sorry --non-trivial
lemma new_lemma_25806 (h0 : functor.add_const (ring (free_add_monoid empty)) (semiring (semiring congr_arg_kind))) : @rank_condition.{0} (free_add_monoid.{0} empty) (@functor.add_const.run.{0 0} (ring.{0} (free_add_monoid.{0} empty)) (semiring.{0} (semiring.{0} congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_25807 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @group.fg.{0} (has_ssubset.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (has_ssubset.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_25808 (h0 : functor.add_const (filter (has_Sup empty)) congr_arg_kind) : filter.ne_bot (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_25809 (h0 : topological_space (order_dual linarith.comp_source)) : totally_disconnected_space (order_dual linarith.comp_source) := sorry --non-trivial
lemma new_lemma_25810 (h2 : group (with_one (with_bot (random_gen (with_bot (with_bot string_imp)))))) : normalizer_condition (with_one (with_bot (random_gen (with_bot (with_bot string_imp))))) := sorry --non-trivial
lemma new_lemma_25811 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @sequential_space.{1} (normed_comm_ring.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 topological_space.{1}) (normed_comm_ring.{1} Type))  := sorry --non-trivial
lemma new_lemma_25812 (h0 : group (with_one (has_top (has_nnnorm (has_top linarith.ineq))))) : is_cyclic (with_one (has_top (has_nnnorm (has_top linarith.ineq)))) := sorry --non-trivial
lemma new_lemma_25813 (h0 : function.extfun Type finset) : finset.nonempty (function.extfun_app h0 (ordered_comm_group congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_25814 (h0 : functor.add_const (ring (has_pos_part Type)) (has_nndist Type)) : @is_domain.{1} (has_pos_part.{1} Type) (@functor.add_const.run.{1 1} (ring.{1} (has_pos_part.{1} Type)) (has_nndist.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_25815 (h0 : group (encodable linarith.ineq)) : is_cyclic (encodable linarith.ineq) := sorry --non-trivial
lemma new_lemma_25816 (h0 : group (canonically_ordered_monoid (has_neg name))) : group.fg (canonically_ordered_monoid (has_neg name)) := sorry --non-trivial
lemma new_lemma_25817 (h0 : complete_lattice (has_edist (option unsigned))) : complete_lattice.is_Sup_finite_compact (has_edist (option unsigned)) := sorry --non-trivial
lemma new_lemma_25818 (h0 : not (topological_space (free_add_monoid congr_arg_kind) -> false)) : @irreducible_space.{0} (free_add_monoid.{0} congr_arg_kind) (@classical.by_contradiction'.{1} (topological_space.{0} (free_add_monoid.{0} congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_25819 (h0 : topological_space (omega_complete_partial_order congr_arg_kind)) : t1_space (omega_complete_partial_order congr_arg_kind) := sorry --non-trivial
lemma new_lemma_25820 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @totally_separated_space.{0} (group_with_zero.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (group_with_zero.{0} num))  := sorry --non-trivial
lemma new_lemma_25821 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @group.fg.{0} (denumerable.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (denumerable.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_25822 (h0 : topological_space (add_comm_semigroup string.iterator_imp)) : totally_disconnected_space (add_comm_semigroup string.iterator_imp) := sorry --non-trivial
lemma new_lemma_25823 (h1 : complete_lattice (with_one fun_info)) : complete_lattice.is_Sup_finite_compact (with_one fun_info) := sorry --non-trivial
lemma new_lemma_25824 (h0 : ordered_add_comm_monoid (linear_order empty)) : archimedean (linear_order empty) := sorry --non-trivial
lemma new_lemma_25825 (h0 h1 : multiset (random_gen (random_gen string_imp))) : multiset.disjoint h0 h1 := sorry --non-trivial
lemma new_lemma_25826 (h0 : topological_space (add_right_cancel_monoid (semiring (semiring empty)))) : topological_space.separable_space (add_right_cancel_monoid (semiring (semiring empty))) := sorry --non-trivial
lemma new_lemma_25827 (h0 : list (add_comm_monoid (has_add name))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_25828 (h0 : functor.add_const (group (boolean_algebra.core name)) pos) : @group.fg.{0} (boolean_algebra.core.{0} name) (@functor.add_const.run.{0 0} (group.{0} (boolean_algebra.core.{0} name)) pos h0)  := sorry --non-trivial
lemma new_lemma_25829 (h0 : add_group (add_left_cancel_monoid char)) : is_add_cyclic (add_left_cancel_monoid char) := sorry --non-trivial
lemma new_lemma_25830 (h0 : functor.add_const (function.extfun (Type 1) topological_space) linarith.comp) : @totally_disconnected_space.{1} (boolean_algebra.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) topological_space.{1}) linarith.comp h0) (boolean_algebra.{1} Type))  := sorry --non-trivial
lemma new_lemma_25831 (h0 : ring (ordered_ring empty)) : is_domain (ordered_ring empty) := sorry --non-trivial
lemma new_lemma_25832 (h0 : topological_space (has_neg_part (mul_zero_class (mul_zero_class name)))) : t1_space (has_neg_part (mul_zero_class (mul_zero_class name))) := sorry --non-trivial
lemma new_lemma_25833 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : list.nodup (function.extfun_app (function.extfun_app h0 list) (has_zero ennreal)) := sorry --non-trivial
lemma new_lemma_25834 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @rank_condition.{0} (has_zero.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (has_zero.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_25835 (h1 : add_group (with_one (has_norm (has_norm (has_norm (has_norm fun_info)))))) : is_add_cyclic (with_one (has_norm (has_norm (has_norm (has_norm fun_info))))) := sorry --non-trivial
lemma new_lemma_25836 (h0 : function.extfun Type ring) : @rank_condition.{0} (linear_ordered_add_comm_group.{0} fun_info) (@function.extfun_app.{2 1} Type ring.{0} h0 (linear_ordered_add_comm_group.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_25837 (h0 : topological_space (has_nnnorm fun_info)) : t0_space (has_nnnorm fun_info) := sorry --non-trivial
lemma new_lemma_25838 (h0 : topological_space (normed_lattice_add_comm_group (has_Inf name))) : normal_space (normed_lattice_add_comm_group (has_Inf name)) := sorry --non-trivial
lemma new_lemma_25839 (h0 : functor.add_const (function.extfun (Type 1) topological_space) Type) : @locally_compact_space.{1} (has_Inf.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@functor.add_const.run.{2 1} (function.extfun.{3 2} (Type 1) topological_space.{1}) Type h0) (has_Inf.{1} Type))  := sorry --non-trivial
lemma new_lemma_25840 (h0 : function.extfun Type semiring) : @is_noetherian_ring.{0} (has_to_string.{0} name) (@function.extfun_app.{2 1} Type semiring.{0} h0 (has_to_string.{0} name))  := sorry --non-trivial
lemma new_lemma_25841 (h0 : topological_space (comm_semigroup (sub_neg_monoid Type))) : topological_space.separable_space (comm_semigroup (sub_neg_monoid Type)) := sorry --non-trivial
lemma new_lemma_25842 (h0 : list (has_to_string pos)) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_25843 (h0 : function.extfun Type ring) : @strong_rank_condition.{0} (canonically_ordered_monoid.{0} pos) (@function.extfun_app.{2 1} Type ring.{0} h0 (canonically_ordered_monoid.{0} pos))  := sorry --non-trivial
lemma new_lemma_25844 (h0 : monoid (left_cancel_semigroup (semiring (semiring congr_arg_kind)))) : monoid.fg (left_cancel_semigroup (semiring (semiring congr_arg_kind))) := sorry --non-trivial
lemma new_lemma_25845 (h0 : group (comm_group (option pos))) : is_simple_group (comm_group (option pos)) := sorry --non-trivial
lemma new_lemma_25846 (h0 : topological_space (semigroup (has_nndist ennreal))) : locally_compact_space (semigroup (has_nndist ennreal)) := sorry --non-trivial
lemma new_lemma_25847 (h0 : ring (add_cancel_comm_monoid unsigned)) : is_domain (add_cancel_comm_monoid unsigned) := sorry --non-trivial
lemma new_lemma_25848 (h0 : functor.add_const (ring (boolean_algebra pos)) linarith.comp) : @is_principal_ideal_ring.{0} (boolean_algebra.{0} pos) (@functor.add_const.run.{0 0} (ring.{0} (boolean_algebra.{0} pos)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_25849 (h0 : complete_lattice (canonically_ordered_comm_semiring name)) : complete_lattice.is_Sup_finite_compact (canonically_ordered_comm_semiring name) := sorry --non-trivial
lemma new_lemma_25850 (h0 : not (complete_lattice (normed_group linarith.ineq) -> false)) : @is_compactly_generated.{0} (normed_group.{0} linarith.ineq) (@classical.by_contradiction'.{1} (complete_lattice.{0} (normed_group.{0} linarith.ineq)) h0)  := sorry --non-trivial
lemma new_lemma_25851 (h0 : functor.add_const (functor.add_const (complete_lattice environment.implicit_infer_kind) Type) linarith.comp) : @is_compactly_generated.{0} environment.implicit_infer_kind (@functor.add_const.run.{0 1} (complete_lattice.{0} environment.implicit_infer_kind) Type (@functor.add_const.run.{0 0} (functor.add_const.{0 1} (complete_lattice.{0} environment.implicit_infer_kind) Type) linarith.comp h0))  := sorry --non-trivial
lemma new_lemma_25852 (h0 : topological_space (div_inv_monoid (random_gen fun_info))) : t0_space (div_inv_monoid (random_gen fun_info)) := sorry --non-trivial
lemma new_lemma_25853 (h0 : topological_space (add_comm_monoid (normed_comm_ring (normed_comm_ring Type)))) : irreducible_space (add_comm_monoid (normed_comm_ring (normed_comm_ring Type))) := sorry --non-trivial
lemma new_lemma_25854 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @rank_condition.{0} (has_norm.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (has_norm.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_25855 (h0 : topological_space (has_compl (random_gen to_additive.value_type))) : path_connected_space (has_compl (random_gen to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_25856 (h0 : topological_space (normed_field (has_nnnorm (has_nnnorm (random_gen (random_gen char)))))) : t0_space (normed_field (has_nnnorm (has_nnnorm (random_gen (random_gen char))))) := sorry --non-trivial
lemma new_lemma_25857 (h0 : topological_space (ring (has_neg_part (has_neg name)))) : t1_space (ring (has_neg_part (has_neg name))) := sorry --non-trivial
lemma new_lemma_25858 (h0 : functor.add_const (uniform_space (partial_order unsigned)) num) : @complete_space.{0} (partial_order.{0} unsigned) (@functor.add_const.run.{0 0} (uniform_space.{0} (partial_order.{0} unsigned)) num h0)  := sorry --non-trivial
lemma new_lemma_25859 (h0 : functor.add_const (list (add_cancel_monoid environment.implicit_infer_kind)) Type) : list.nodup (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_25860 (h0 : group (preorder congr_arg_kind)) : normalizer_condition (preorder congr_arg_kind) := sorry --non-trivial
lemma new_lemma_25861 (h0 : functor.add_const (complete_lattice (has_nndist pos)) Type) : @is_atomistic.{0} (has_nndist.{0} pos) (@functor.add_const.run.{0 1} (complete_lattice.{0} (has_nndist.{0} pos)) Type h0)  := sorry --non-trivial
lemma new_lemma_25862 (h0 : function.extfun nat fin) : @separated_space.{0} (canonically_ordered_monoid.{0} linarith.comp) (@matrix.vec_empty.{0} (uniform_space.{0} (canonically_ordered_monoid.{0} linarith.comp)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_25863 (h0 : functor.add_const (ordered_add_comm_monoid (ordered_ring empty)) empty) : @archimedean.{0} (ordered_ring.{0} empty) (@functor.add_const.run.{0 0} (ordered_add_comm_monoid.{0} (ordered_ring.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_25864 (h0 : ring (random_gen (has_nnnorm reducibility_hints))) : is_domain (random_gen (has_nnnorm reducibility_hints)) := sorry --non-trivial
lemma new_lemma_25865 (h0 : function.extfun Type semiring) : @is_noetherian_ring.{0} (has_Sup.{0} num) (@function.extfun_app.{2 1} Type semiring.{0} h0 (has_Sup.{0} num))  := sorry --non-trivial
lemma new_lemma_25866 (h0 : uniform_space (ordered_comm_ring (has_add linarith.comp))) : complete_space (ordered_comm_ring (has_add linarith.comp)) := sorry --non-trivial
lemma new_lemma_25867 (h0 : functor.add_const (function.extfun Type list) (ring linarith.comp)) : palindrome (function.extfun_app (functor.add_const.run h0) (add_cancel_monoid pos)) := sorry --non-trivial
lemma new_lemma_25868 (h0 : not (complete_lattice (linear_ordered_add_comm_group to_additive.value_type) -> false)) : @is_compactly_generated.{0} (linear_ordered_add_comm_group.{0} to_additive.value_type) (@classical.by_contradiction'.{1} (complete_lattice.{0} (linear_ordered_add_comm_group.{0} to_additive.value_type)) h0)  := sorry --non-trivial
lemma new_lemma_25869 (h0 : topological_space (plift (semiring (semiring (semiring (semiring (semiring congr_arg_kind))))))) : t0_space (plift (semiring (semiring (semiring (semiring (semiring congr_arg_kind)))))) := sorry --non-trivial
lemma new_lemma_25870 (h0 : functor.add_const (topological_space (simple_graph pos)) Type) : @totally_separated_space.{0} (simple_graph.{0} pos) (@functor.add_const.run.{0 1} (topological_space.{0} (simple_graph.{0} pos)) Type h0)  := sorry --non-trivial
lemma new_lemma_25871 (h0 : not (topological_space (preorder reducibility_hints) -> false)) : @totally_disconnected_space.{0} (preorder.{0} reducibility_hints) (@classical.by_contradiction'.{1} (topological_space.{0} (preorder.{0} reducibility_hints)) h0)  := sorry --non-trivial
lemma new_lemma_25872 (h0 : functor.comp topological_space ring Type) : @sequential_space.{1} (ring.{1} Type) (@functor.comp.run.{1 1 1} topological_space.{1} ring.{1} Type h0)  := sorry --non-trivial
lemma new_lemma_25873 (h0 : functor.add_const (topological_space (has_nndist Type)) name) : @preirreducible_space.{1} (has_nndist.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (has_nndist.{1} Type)) name h0)  := sorry --non-trivial
lemma new_lemma_25874 (h0 : group (with_one (has_top (has_norm linarith.comp)))) : normalizer_condition (with_one (has_top (has_norm linarith.comp))) := sorry --non-trivial
lemma new_lemma_25875 (h0 : function.extfun (nat -> Type) (function.extfun nat)) : @is_simple_group.{0} (comm_semigroup.{0} linarith.comp) (@matrix.vec_empty.{0} (group.{0} (comm_semigroup.{0} linarith.comp)) (@function.extfun_app.{1 1} nat fin (@function.extfun_app.{2 1} (nat → Type) (function.extfun.{1 1} nat) h0 fin) (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_25876 (h0 : group (dlist (random_gen (random_gen linarith.comp_source)))) : group.fg (dlist (random_gen (random_gen linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_25877 (h0 : cancel_comm_monoid_with_zero (has_neg pos)) : unique_factorization_monoid (has_neg pos) := sorry --non-trivial
lemma new_lemma_25878 (h0 : complete_lattice (has_union (semiring empty))) : is_compactly_generated (has_union (semiring empty)) := sorry --non-trivial
lemma new_lemma_25879 (h0 : functor.add_const (topological_space (boolean_algebra.core pos)) Type) : @totally_disconnected_space.{0} (boolean_algebra.core.{0} pos) (@functor.add_const.run.{0 1} (topological_space.{0} (boolean_algebra.core.{0} pos)) Type h0)  := sorry --non-trivial
lemma new_lemma_25880 (h0 : topological_space (complete_linear_order (semiring num))) : path_connected_space (complete_linear_order (semiring num)) := sorry --non-trivial
lemma new_lemma_25881 (h0 : function.extfun Type semiring) : @is_noetherian_ring.{0} (normed_lattice_add_comm_group.{0} linarith.comp) (@function.extfun_app.{2 1} Type semiring.{0} h0 (normed_lattice_add_comm_group.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_25882 (h0 : function.extfun Type topological_space) : @totally_disconnected_space.{0} (generalized_boolean_algebra.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (generalized_boolean_algebra.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_25883 (h0 : ring (uniform_space (metric_space (denumerable char)))) : is_domain (uniform_space (metric_space (denumerable char))) := sorry --non-trivial
lemma new_lemma_25884 (h0 : ordered_comm_monoid (has_pos_part (has_pos_part (has_nndist linarith.comp)))) : has_exists_mul_of_le (has_pos_part (has_pos_part (has_nndist linarith.comp))) := sorry --non-trivial
lemma new_lemma_25885 (h0 : topological_space (ordered_comm_monoid (has_add Type))) : totally_disconnected_space (ordered_comm_monoid (has_add Type)) := sorry --non-trivial
lemma new_lemma_25886 (h0 : topological_space (has_emptyc (random_gen string_imp))) : t0_space (has_emptyc (random_gen string_imp)) := sorry --non-trivial
lemma new_lemma_25887 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @complete_space.{0} (distrib_lattice.{0} linarith.ineq) (@function.extfun_app.{2 1} Type uniform_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 uniform_space.{0}) (distrib_lattice.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_25888 (h0 : ordered_cancel_add_comm_monoid unsigned -> ordered_cancel_add_comm_monoid unsigned -> Prop) : total h0 := sorry --non-trivial
lemma new_lemma_25889 (h0 : monoid (normed_comm_ring (has_add (has_add (has_add Type))))) : monoid.fg (normed_comm_ring (has_add (has_add (has_add Type)))) := sorry --non-trivial
lemma new_lemma_25890 (h0 : group (random_gen (has_nnnorm (has_nnnorm (has_nnnorm linarith.comp_source))))) : group.fg (random_gen (has_nnnorm (has_nnnorm (has_nnnorm linarith.comp_source)))) := sorry --non-trivial
lemma new_lemma_25891 (h0 : function.extfun Type ring) : @is_domain.{0} (has_zero.{0} pos) (@function.extfun_app.{2 1} Type ring.{0} h0 (has_zero.{0} pos))  := sorry --non-trivial
lemma new_lemma_25892 (h1 : function.extfun Type topological_space) : @discrete_topology.{0} (complete_semilattice_Sup.{0} fun_info) (@function.extfun_app.{2 1} Type topological_space.{0} h1 (complete_semilattice_Sup.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_25893 (h0 : int) (h1 : fin (nat.succ (int.nat_abs h0)) -> Prop) (h2 : fin (int.nat_abs h0)) : matrix.vec_tail h1 h2 := sorry --non-trivial
lemma new_lemma_25894 (h0 : function.extfun nat fin) : @irreducible_space.{1} (canonically_linear_ordered_monoid.{1} Type) (@matrix.vec_empty.{1} (topological_space.{1} (canonically_linear_ordered_monoid.{1} Type)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_25895 (h0 : monoid (measurable_space (semiring (semiring empty)))) : monoid.fg (measurable_space (semiring (semiring empty))) := sorry --non-trivial
lemma new_lemma_25896 (h0 : functor.add_const (topological_space (boolean_algebra linarith.comp)) name) : @path_connected_space.{0} (boolean_algebra.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (boolean_algebra.{0} linarith.comp)) name h0)  := sorry --non-trivial
lemma new_lemma_25897 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @is_simple_group.{1} (has_neg_part.{1} Type) (@function.extfun_app.{3 2} (Type 1) group.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 group.{1}) (has_neg_part.{1} Type))  := sorry --non-trivial
lemma new_lemma_25898 (h0 : topological_space (boolean_algebra.core environment.implicit_infer_kind)) : preconnected_space (boolean_algebra.core environment.implicit_infer_kind) := sorry --non-trivial
lemma new_lemma_25899 (h0 : filter (finset linarith.comp)) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_25900 (h0 : complete_lattice (measurable_space (has_norm (has_norm (has_norm num))))) : complete_lattice.is_Sup_finite_compact (measurable_space (has_norm (has_norm (has_norm num)))) := sorry --non-trivial
lemma new_lemma_25901 (h0 : topological_space (complete_distrib_lattice (has_nnnorm linarith.comp_source))) : path_connected_space (complete_distrib_lattice (has_nnnorm linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_25902 (h0 : functor.add_const (function.extfun Type group) (has_pos_part pos)) : @is_cyclic.{0} (has_pos_part.{0} linarith.comp) (@function.extfun_app.{2 1} Type group.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type group.{0}) (has_pos_part.{0} pos) h0) (has_pos_part.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_25903 (h0 : complete_lattice (normed_linear_ordered_group empty)) : is_atomistic (normed_linear_ordered_group empty) := sorry --non-trivial
lemma new_lemma_25904 (h0 : ring (has_to_string environment.implicit_infer_kind)) : is_principal_ideal_ring (has_to_string environment.implicit_infer_kind) := sorry --non-trivial
lemma new_lemma_25905 (h1 : semiring linarith.comp_source) (h2 : ideal linarith.comp_source) : ideal.is_prime h2 := sorry --non-trivial
lemma new_lemma_25906 (h0 : group (ordered_comm_monoid Type)) : is_simple_group (ordered_comm_monoid Type) := sorry --non-trivial
lemma new_lemma_25907 (h0 : monoid (has_one (has_norm (semiring (semiring empty))))) : monoid.fg (has_one (has_norm (semiring (semiring empty)))) := sorry --non-trivial
lemma new_lemma_25908 (h0 : function.extfun Type uniform_space) : @separated_space.{0} (left_cancel_semigroup.{0} unsigned) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (left_cancel_semigroup.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_25909 (h0 : topological_space (has_to_string (option name))) : locally_compact_space (has_to_string (option name)) := sorry --non-trivial
lemma new_lemma_25910 (h0 : ring (comm_semigroup (sub_neg_monoid pos))) : is_principal_ideal_ring (comm_semigroup (sub_neg_monoid pos)) := sorry --non-trivial
lemma new_lemma_25911 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @loc_path_connected_space.{0} (generalized_boolean_algebra.{0} real) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (generalized_boolean_algebra.{0} real))  := sorry --non-trivial
lemma new_lemma_25912 (h0 : topological_space (ordered_comm_monoid (ordered_comm_monoid pos))) : preconnected_space (ordered_comm_monoid (ordered_comm_monoid pos)) := sorry --non-trivial
lemma new_lemma_25913 (h0 : group (has_to_string (has_pos_part (has_neg (has_neg pos))))) : is_cyclic (has_to_string (has_pos_part (has_neg (has_neg pos)))) := sorry --non-trivial
lemma new_lemma_25914 (h0 : not (topological_space (semi_normed_comm_ring char) -> false)) : @path_connected_space.{0} (semi_normed_comm_ring.{0} char) (@classical.by_contradiction'.{1} (topological_space.{0} (semi_normed_comm_ring.{0} char)) h0)  := sorry --non-trivial
lemma new_lemma_25915 (h0 h1 : multiset (nondiscrete_normed_field linarith.ineq)) : multiset.disjoint h0 h1 := sorry --non-trivial
lemma new_lemma_25916 (h0 : complete_lattice (boolean_algebra linarith.comp)) : complete_lattice.is_Sup_finite_compact (boolean_algebra linarith.comp) := sorry --non-trivial
lemma new_lemma_25917 (h0 : add_group (has_norm (has_top (has_top (has_top linarith.comp_source))))) : is_add_cyclic (has_norm (has_top (has_top (has_top linarith.comp_source)))) := sorry --non-trivial
lemma new_lemma_25918 (h0 : add_monoid (normed_lattice_add_comm_group (has_Inf real))) : add_monoid.fg (normed_lattice_add_comm_group (has_Inf real)) := sorry --non-trivial
lemma new_lemma_25919 (h0 : char -> nat) (h1 h2 : char) : measure h0 h1 h2 := sorry --non-trivial
lemma new_lemma_25920 (h0 : has_lt (has_div (distrib fun_info))) : no_max_order (has_div (distrib fun_info)) := sorry --non-trivial
lemma new_lemma_25921 (h0 : topological_space (boolean_algebra.core Type)) : totally_disconnected_space (boolean_algebra.core Type) := sorry --non-trivial
lemma new_lemma_25922 (h0 : functor.add_const (topological_space (has_neg ennreal)) environment.implicit_infer_kind) : @regular_space.{0} (has_neg.{0} ennreal) (@functor.add_const.run.{0 0} (topological_space.{0} (has_neg.{0} ennreal)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_25923 (h0 : topological_space (normed_lattice_add_comm_group (has_Inf (has_Inf Type)))) : discrete_topology (normed_lattice_add_comm_group (has_Inf (has_Inf Type))) := sorry --non-trivial
lemma new_lemma_25924 (h0 : functor.add_const (list (ordered_comm_monoid linarith.comp)) Type) : list.nodup (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_25925 (h0 : functor.add_const (complete_lattice (semigroup empty)) (option unsigned)) : @is_compactly_generated.{0} (semigroup.{0} empty) (@functor.add_const.run.{0 0} (complete_lattice.{0} (semigroup.{0} empty)) (option.{0} unsigned) h0)  := sorry --non-trivial
lemma new_lemma_25926 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_add_cyclic.{0} (ring.{0} ennreal) (@function.extfun_app.{2 1} Type add_group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 add_group.{0}) (ring.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_25927 (h1 : group (has_top (random_gen string_imp))) : group.fg (has_top (random_gen string_imp)) := sorry --non-trivial
lemma new_lemma_25928 (h0 : topological_space (with_bot (has_inv (comm_ring (has_inv (comm_ring linarith.ineq)))))) : irreducible_space (with_bot (has_inv (comm_ring (has_inv (comm_ring linarith.ineq))))) := sorry --non-trivial
lemma new_lemma_25929 (h0 : topological_space (add_cancel_monoid (finset pos))) : preconnected_space (add_cancel_monoid (finset pos)) := sorry --non-trivial
lemma new_lemma_25930 (h0 : ring (has_star (semiring (semiring (semiring empty))))) : is_domain (has_star (semiring (semiring (semiring empty)))) := sorry --non-trivial
lemma new_lemma_25931 (h0 : topological_space (ordered_comm_ring (ordered_comm_monoid (has_add name)))) : loc_path_connected_space (ordered_comm_ring (ordered_comm_monoid (has_add name))) := sorry --non-trivial
lemma new_lemma_25932 (h0 : topological_space (simple_graph (has_Inf linarith.comp))) : sequential_space (simple_graph (has_Inf linarith.comp)) := sorry --non-trivial
lemma new_lemma_25933 (h0 : ring (has_add real)) : is_principal_ideal_ring (has_add real) := sorry --non-trivial
lemma new_lemma_25934 (h0 : ring (has_lt string.iterator_imp)) : rank_condition (has_lt string.iterator_imp) := sorry --non-trivial
lemma new_lemma_25935 (h0 : complete_lattice (group_with_zero congr_arg_kind)) : is_compactly_generated (group_with_zero congr_arg_kind) := sorry --non-trivial
lemma new_lemma_25936 (h0 : functor.add_const (ring (normed_comm_ring pos)) (boolean_algebra (finset Type))) : @strong_rank_condition.{0} (normed_comm_ring.{0} pos) (@functor.add_const.run.{0 1} (ring.{0} (normed_comm_ring.{0} pos)) (boolean_algebra.{1} (finset.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_25937 (h0 : uniform_space (nondiscrete_normed_field (add_comm_semigroup linarith.ineq))) : complete_space (nondiscrete_normed_field (add_comm_semigroup linarith.ineq)) := sorry --non-trivial
lemma new_lemma_25938 (h0 : ordered_add_comm_monoid (canonically_ordered_monoid (has_neg pos))) : archimedean (canonically_ordered_monoid (has_neg pos)) := sorry --non-trivial
lemma new_lemma_25939 (h0 : topological_space (distrib_lattice (random_gen to_additive.value_type))) : irreducible_space (distrib_lattice (random_gen to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_25940 (h1 : has_mem.mem uniform_space has_emptyc.emptyc) : @complete_space.{0} (semiring.{0} fun_info) (@function.extfun_app.{2 1} Type uniform_space.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) uniform_space.{0} h1) (semiring.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_25941 (h0 : topological_space (add_cancel_monoid (add_comm_monoid unsigned))) : locally_compact_space (add_cancel_monoid (add_comm_monoid unsigned)) := sorry --non-trivial
lemma new_lemma_25942 (h0 : function.extfun Type topological_space) : @path_connected_space.{0} (add_comm_monoid.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (add_comm_monoid.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_25943 (h0 : fin has_zero.zero) : @group.fg.{0} (canonically_ordered_monoid.{0} real) (@matrix.vec_empty.{0} (group.{0} (canonically_ordered_monoid.{0} real)) h0)  := sorry --non-trivial
lemma new_lemma_25944 (h1 : ring (denumerable string_imp)) : rank_condition (denumerable string_imp) := sorry --non-trivial
lemma new_lemma_25945 (h0 : functor.add_const (function.extfun Type finset) pos) : finset.nonempty (function.extfun_app (functor.add_const.run h0) (comm_group pos)) := sorry --non-trivial
lemma new_lemma_25946 (h0 : topological_space (with_bot (semiring num))) : preirreducible_space (with_bot (semiring num)) := sorry --non-trivial
lemma new_lemma_25947 (h0 : topological_space (has_norm linarith.ineq)) : totally_separated_space (has_norm linarith.ineq) := sorry --non-trivial
lemma new_lemma_25948 (h0 : not (ring (has_compl string_imp) -> false)) : @is_domain.{0} (has_compl.{0} string_imp) (@classical.by_contradiction'.{1} (ring.{0} (has_compl.{0} string_imp)) h0)  := sorry --non-trivial
lemma new_lemma_25949 (h0 : topological_space (semigroup (finset Type))) : t1_space (semigroup (finset Type)) := sorry --non-trivial
lemma new_lemma_25950 (h0 : semiring (semiring (semiring unsigned))) : is_noetherian_ring (semiring (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_25951 (h0 : functor.comp ring complete_distrib_lattice unsigned) : @strong_rank_condition.{0} (complete_distrib_lattice.{0} unsigned) (@functor.comp.run.{0 0 0} ring.{0} complete_distrib_lattice.{0} unsigned h0)  := sorry --non-trivial
lemma new_lemma_25952 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : list.nodup (function.extfun_app (function.extfun_app h0 list) linarith.comp_source) := sorry --non-trivial
lemma new_lemma_25953 (h0 : ring (uniform_space (random_gen char))) : strong_rank_condition (uniform_space (random_gen char)) := sorry --non-trivial
lemma new_lemma_25954 (h0 : ring (simple_graph (mul_one_class environment.projection_info))) : is_domain (simple_graph (mul_one_class environment.projection_info)) := sorry --non-trivial
lemma new_lemma_25955 (h0 : function.extfun Type ring) : @is_domain.{0} (has_ssubset.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type ring.{0} h0 (has_ssubset.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_25956 (h0 : ring (complete_linear_order (semiring unsigned))) : is_principal_ideal_ring (complete_linear_order (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_25957 (h0 : add_group (distrib fun_info)) : is_add_cyclic (distrib fun_info) := sorry --non-trivial
lemma new_lemma_25958 (h0 : function.extfun Type topological_space) : @loc_path_connected_space.{0} (canonically_linear_ordered_monoid.{0} (option.{0} ennreal)) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (canonically_linear_ordered_monoid.{0} (option.{0} ennreal)))  := sorry --non-trivial
lemma new_lemma_25959 (h0 : function.extfun nat fin) : @complete_space.{1} (has_bot.{1} Type) (@matrix.vec_empty.{1} (uniform_space.{1} (has_bot.{1} Type)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_25960 (h0 : topological_space (ring (has_add Type))) : loc_path_connected_space (ring (has_add Type)) := sorry --non-trivial
lemma new_lemma_25961 (h0 : complete_lattice (has_top (random_gen (has_nnnorm linarith.ineq)))) : complete_lattice.is_Sup_finite_compact (has_top (random_gen (has_nnnorm linarith.ineq))) := sorry --non-trivial
lemma new_lemma_25962 (h0 : filter (preorder (semiring (semiring num)))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_25963 (h0 : ordered_comm_monoid (add_comm_monoid (has_neg linarith.comp))) : has_exists_mul_of_le (add_comm_monoid (has_neg linarith.comp)) := sorry --non-trivial
lemma new_lemma_25964 (h0 : functor.add_const (function.extfun Type add_group) Type) : @is_add_cyclic.{0} (simple_graph.{0} pos) (@function.extfun_app.{2 1} Type add_group.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type add_group.{0}) Type h0) (simple_graph.{0} pos))  := sorry --non-trivial
lemma new_lemma_25965 (h0 : topological_space (random_gen (has_ssubset char))) : path_connected_space (random_gen (has_ssubset char)) := sorry --non-trivial
lemma new_lemma_25966 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_principal_ideal_ring.{0} (ordered_comm_monoid.{0} name) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (ordered_comm_monoid.{0} name))  := sorry --non-trivial
lemma new_lemma_25967 (h0 : functor.comp list has_neg name) : palindrome (functor.comp.run h0) := sorry --non-trivial
lemma new_lemma_25968 (h0 : functor.add_const (filter (ring linarith.comp)) Type) : countable_Inter_filter (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_25969 (h0 : topological_space (cancel_monoid (has_add environment.implicit_infer_kind))) : discrete_topology (cancel_monoid (has_add environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_25970 (h0 : fin has_zero.zero) : @archimedean.{0} (canonically_ordered_monoid.{0} pos) (@matrix.vec_empty.{0} (ordered_add_comm_monoid.{0} (canonically_ordered_monoid.{0} pos)) h0)  := sorry --non-trivial
lemma new_lemma_25971 (h0 : uniform_space (generalized_boolean_algebra (has_add Type))) : separated_space (generalized_boolean_algebra (has_add Type)) := sorry --non-trivial
lemma new_lemma_25972 (h0 : semiring (generalized_boolean_algebra (has_add linarith.comp))) : is_noetherian_ring (generalized_boolean_algebra (has_add linarith.comp)) := sorry --non-trivial
lemma new_lemma_25973 (h0 h1 : multiset string.iterator_imp) : multiset.disjoint h0 h1 := sorry --non-trivial
lemma new_lemma_25974 (h0 : ring (boolean_algebra.core environment.implicit_infer_kind)) : is_domain (boolean_algebra.core environment.implicit_infer_kind) := sorry --non-trivial
lemma new_lemma_25975 (h0 : function.extfun Type group) : @is_cyclic.{0} (random_gen.{0} empty) (@function.extfun_app.{2 1} Type group.{0} h0 (random_gen.{0} empty))  := sorry --non-trivial
lemma new_lemma_25976 (h1 : ring (has_emptyc (has_norm to_additive.value_type))) : strong_rank_condition (has_emptyc (has_norm to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_25977 (h0 : filter (has_neg_part (finset pos))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_25978 (h0 : not (topological_space (has_div to_additive.value_type) -> false)) : @path_connected_space.{0} (has_div.{0} to_additive.value_type) (@classical.by_contradiction'.{1} (topological_space.{0} (has_div.{0} to_additive.value_type)) h0)  := sorry --non-trivial
lemma new_lemma_25979 (h0 : function.extfun Type group) : @normalizer_condition.{0} (has_top.{0} unsigned) (@function.extfun_app.{2 1} Type group.{0} h0 (has_top.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_25980 (h0 : add_group (normed_field char)) : is_add_cyclic (normed_field char) := sorry --non-trivial
lemma new_lemma_25981 (h0 : monoid (finset (option (option unsigned)))) : monoid.fg (finset (option (option unsigned))) := sorry --non-trivial
lemma new_lemma_25982 (h0 : function.extfun Type topological_space) : @locally_compact_space.{0} (semi_normed_comm_ring.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (semi_normed_comm_ring.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_25983 (h0 : ring (add_right_cancel_monoid unsigned)) : strong_rank_condition (add_right_cancel_monoid unsigned) := sorry --non-trivial
lemma new_lemma_25984 (h0 : topological_space (linear_ordered_semiring (semiring num))) : preirreducible_space (linear_ordered_semiring (semiring num)) := sorry --non-trivial
lemma new_lemma_25985 (h0 : ring (has_nnnorm (denumerable linarith.ineq))) : rank_condition (has_nnnorm (denumerable linarith.ineq)) := sorry --non-trivial
lemma new_lemma_25986 (h0 : functor.add_const (functor.add_const (ring nnreal) num) congr_arg_kind) : @is_domain.{0} nnreal (@functor.add_const.run.{0 0} (ring.{0} nnreal) num (@functor.add_const.run.{0 0} (functor.add_const.{0 0} (ring.{0} nnreal) num) congr_arg_kind h0))  := sorry --non-trivial
lemma new_lemma_25987 (h0 : function.extfun Type add_monoid) : @add_monoid.fg.{0} (has_star.{0} unsigned) (@function.extfun_app.{2 1} Type add_monoid.{0} h0 (has_star.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_25988 (h0 : topological_space (ordered_comm_ring Type)) : path_connected_space (ordered_comm_ring Type) := sorry --non-trivial
lemma new_lemma_25989 (h0 : functor.add_const (ordered_comm_monoid (has_add name)) (ring name)) : @has_exists_mul_of_le.{0} (has_add.{0} name) (@functor.add_const.run.{0 0} (ordered_comm_monoid.{0} (has_add.{0} name)) (ring.{0} name) h0)  := sorry --non-trivial
lemma new_lemma_25990 (h0 : function.extfun Type cancel_comm_monoid_with_zero) : @unique_factorization_monoid.{0} (canonically_linear_ordered_monoid.{0} real) (@function.extfun_app.{2 1} Type cancel_comm_monoid_with_zero.{0} h0 (canonically_linear_ordered_monoid.{0} real))  := sorry --non-trivial
lemma new_lemma_25991 (h0 : topological_space (distrib char)) : t0_space (distrib char) := sorry --non-trivial
lemma new_lemma_25992 (h0 : topological_space (has_Inf linarith.comp)) : totally_separated_space (has_Inf linarith.comp) := sorry --non-trivial
lemma new_lemma_25993 (h0 : topological_space (ordered_comm_monoid (has_nndist (finset Type)))) : t1_space (ordered_comm_monoid (has_nndist (finset Type))) := sorry --non-trivial
lemma new_lemma_25994 (h0 : topological_space (has_star (option unsigned))) : topological_space.separable_space (has_star (option unsigned)) := sorry --non-trivial
lemma new_lemma_25995 (h0 : semiring (ordered_comm_monoid (has_add Type))) : is_noetherian_ring (ordered_comm_monoid (has_add Type)) := sorry --non-trivial
lemma new_lemma_25996 (h0 : functor.add_const (group (finset name)) Type) : @group.fg.{0} (finset.{0} name) (@functor.add_const.run.{0 1} (group.{0} (finset.{0} name)) Type h0)  := sorry --non-trivial
lemma new_lemma_25997 (h1 : not (complete_lattice (has_lt string_imp) -> false)) : @is_compactly_generated.{0} (has_lt.{0} string_imp) (@classical.by_contradiction'.{1} (complete_lattice.{0} (has_lt.{0} string_imp)) h1)  := sorry --non-trivial
lemma new_lemma_25998 (h0 : not (topological_space (option congr_arg_kind) -> false)) : @normal_space.{0} (option.{0} congr_arg_kind) (@classical.by_contradiction'.{1} (topological_space.{0} (option.{0} congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_25999 (h1 : filter (denumerable (random_gen (random_gen string_imp)))) : filter.ne_bot h1 := sorry --non-trivial
lemma new_lemma_26000 (h0 : ring (uniform_space (metric_space char))) : strong_rank_condition (uniform_space (metric_space char)) := sorry --non-trivial
lemma new_lemma_26001 (h0 : function.extfun Type (functor.comp group ring)) : @group.fg.{0} (ring.{0} pos) (@functor.comp.run.{0 0 0} group.{0} ring.{0} pos (@function.extfun_app.{2 1} Type (functor.comp.{0 0 0} group.{0} ring.{0}) h0 pos))  := sorry --non-trivial
lemma new_lemma_26002 (h0 : functor.add_const (topological_space (bin_tree num)) empty) : @locally_compact_space.{0} (bin_tree.{0} num) (@functor.add_const.run.{0 0} (topological_space.{0} (bin_tree.{0} num)) empty h0)  := sorry --non-trivial
lemma new_lemma_26003 (h0 : uniform_space (measure_theory.measure_space (semiring num))) : complete_space (measure_theory.measure_space (semiring num)) := sorry --non-trivial
lemma new_lemma_26004 (h0 : list (cancel_monoid environment.implicit_infer_kind)) : palindrome h0 := sorry --non-trivial
lemma new_lemma_26005 (h0 : topological_space (has_nndist (has_nndist pos))) : path_connected_space (has_nndist (has_nndist pos)) := sorry --non-trivial
lemma new_lemma_26006 (h0 : functor.add_const (topological_space (bin_tree num)) unsigned) : @preirreducible_space.{0} (bin_tree.{0} num) (@functor.add_const.run.{0 0} (topological_space.{0} (bin_tree.{0} num)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_26007 (h0 : complete_lattice (has_edist (semiring unsigned))) : complete_lattice.is_Sup_finite_compact (has_edist (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_26008 (h0 : set (set (random_gen (has_inv (random_gen linarith.ineq))))) : is_countably_spanning h0 := sorry --non-trivial
lemma new_lemma_26009 (h0 : functor.add_const (ordered_add_comm_monoid (has_neg ennreal)) (option (option unsigned))) : @archimedean.{0} (has_neg.{0} ennreal) (@functor.add_const.run.{0 0} (ordered_add_comm_monoid.{0} (has_neg.{0} ennreal)) (option.{0} (option.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_26010 (h0 : functor.add_const (finset (has_to_string Type)) (has_neg pos)) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_26011 (h0 : not (function.extfun (finset Type) (has_mem.mem (has_one unsigned)) -> false)) : @irreducible_space.{0} (has_one.{0} unsigned) (@finset.pi.empty.{1 0} Type topological_space.{0} (has_one.{0} unsigned) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (has_one.{0} unsigned)) (@classical.by_contradiction'.{0} (function.extfun.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (has_one.{0} unsigned))) h0) (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_26012 (h0 : not (ring (has_norm to_additive.value_type) -> false)) : @rank_condition.{0} (has_norm.{0} to_additive.value_type) (@classical.by_contradiction'.{1} (ring.{0} (has_norm.{0} to_additive.value_type)) h0)  := sorry --non-trivial
lemma new_lemma_26013 (h0 : functor.add_const (ring (normed_comm_ring pos)) name) : @strong_rank_condition.{0} (normed_comm_ring.{0} pos) (@functor.add_const.run.{0 0} (ring.{0} (normed_comm_ring.{0} pos)) name h0)  := sorry --non-trivial
lemma new_lemma_26014 (h0 : functor.add_const (function.extfun Type uniform_space) unsigned) : @complete_space.{0} (ordered_cancel_add_comm_monoid.{0} unsigned) (@function.extfun_app.{2 1} Type uniform_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type uniform_space.{0}) unsigned h0) (ordered_cancel_add_comm_monoid.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_26015 (h0 : not (add_group (semi_normed_ring fun_info) -> false)) : @is_add_cyclic.{0} (semi_normed_ring.{0} fun_info) (@classical.by_contradiction'.{1} (add_group.{0} (semi_normed_ring.{0} fun_info)) h0)  := sorry --non-trivial
lemma new_lemma_26016 (h0 : ring (has_add (has_Inf (finset pos)))) : rank_condition (has_add (has_Inf (finset pos))) := sorry --non-trivial
lemma new_lemma_26017 (h0 : has_mem.mem (with_bot congr_arg_kind) has_emptyc.emptyc) : @totally_disconnected_space.{0} (with_bot.{0} congr_arg_kind) (@finset.pi.empty.{1 0} Type topological_space.{0} (with_bot.{0} congr_arg_kind) h0)  := sorry --non-trivial
lemma new_lemma_26018 (h0 : topological_space (measure_theory.measure_space num)) : t0_space (measure_theory.measure_space num) := sorry --non-trivial
lemma new_lemma_26019 (h0 : ring (with_bot linarith.comp)) : rank_condition (with_bot linarith.comp) := sorry --non-trivial
lemma new_lemma_26020 (h0 : measurable_space fun_info) (h1 : set fun_info) : measurable_set h1 := sorry --non-trivial
lemma new_lemma_26021 (h1 : has_mem.mem ring has_emptyc.emptyc) : @rank_condition.{0} (semiring.{0} fun_info) (@function.extfun_app.{2 1} Type ring.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) ring.{0} h1) (semiring.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_26022 (h2 : monoid (random_gen num)) : monoid.fg (random_gen num) := sorry --non-trivial
lemma new_lemma_26023 (h0 : topological_space (add_comm_monoid pos)) : preirreducible_space (add_comm_monoid pos) := sorry --non-trivial
lemma new_lemma_26024 (h0 : function.extfun Type group) : @is_simple_group.{0} (normed_comm_ring.{0} pos) (@function.extfun_app.{2 1} Type group.{0} h0 (normed_comm_ring.{0} pos))  := sorry --non-trivial
lemma new_lemma_26025 (h0 : topological_space (simple_graph (option num))) : t0_space (simple_graph (option num)) := sorry --non-trivial
lemma new_lemma_26026 (h0 : functor.add_const (ordered_comm_monoid (has_Inf name)) pos) : @has_exists_mul_of_le.{0} (has_Inf.{0} name) (@functor.add_const.run.{0 0} (ordered_comm_monoid.{0} (has_Inf.{0} name)) pos h0)  := sorry --non-trivial
lemma new_lemma_26027 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_cyclic.{0} (normed_linear_ordered_group.{0} empty) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (normed_linear_ordered_group.{0} empty))  := sorry --non-trivial
lemma new_lemma_26028 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @has_exists_mul_of_le.{0} (canonically_ordered_comm_semiring.{0} linarith.comp) (@function.extfun_app.{2 1} Type ordered_comm_monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ordered_comm_monoid.{0}) (canonically_ordered_comm_semiring.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_26029 (h0 : add_group (measurable_space (semiring fun_info))) : is_add_cyclic (measurable_space (semiring fun_info)) := sorry --non-trivial
lemma new_lemma_26030 (h0 : topological_space (measurable_space.dynkin_system (normed_linear_ordered_group unsigned))) : t1_space (measurable_space.dynkin_system (normed_linear_ordered_group unsigned)) := sorry --non-trivial
lemma new_lemma_26031 (h0 : topological_space (has_add ennreal)) : locally_compact_space (has_add ennreal) := sorry --non-trivial
lemma new_lemma_26032 (h0 : group (random_gen (has_top (has_top (has_top linarith.comp_source))))) : normalizer_condition (random_gen (has_top (has_top (has_top linarith.comp_source)))) := sorry --non-trivial
lemma new_lemma_26033 (h0 : topological_space (with_bot num)) : path_connected_space (with_bot num) := sorry --non-trivial
lemma new_lemma_26034 (h0 : function.extfun Type add_monoid) : @add_monoid.fg.{0} (has_bot.{0} (option.{0} unsigned)) (@function.extfun_app.{2 1} Type add_monoid.{0} h0 (has_bot.{0} (option.{0} unsigned)))  := sorry --non-trivial
lemma new_lemma_26035 (h0 : topological_space (group_with_zero congr_arg_kind)) : totally_separated_space (group_with_zero congr_arg_kind) := sorry --non-trivial
lemma new_lemma_26036 (h0 : function.extfun (Type 1) topological_space) : @sequential_space.{1} (boolean_algebra.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} h0 (boolean_algebra.{1} Type))  := sorry --non-trivial
lemma new_lemma_26037 (h0 : functor.add_const (topological_space (boolean_algebra pos)) pos) : @discrete_topology.{0} (boolean_algebra.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (boolean_algebra.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_26038 (h0 : functor.add_const (function.extfun Type list) Type) : list.nodup (function.extfun_app (functor.add_const.run h0) (has_neg pos)) := sorry --non-trivial
lemma new_lemma_26039 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @group.fg.{0} (boolean_algebra.core.{0} name) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (boolean_algebra.core.{0} name))  := sorry --non-trivial
lemma new_lemma_26040 (h0 : topological_space (semigroup (finset name))) : locally_compact_space (semigroup (finset name)) := sorry --non-trivial
lemma new_lemma_26041 (h0 : complete_lattice (has_union (semiring empty))) : complete_lattice.is_Sup_finite_compact (has_union (semiring empty)) := sorry --non-trivial
lemma new_lemma_26042 (h0 : complete_lattice (canonically_linear_ordered_monoid ennreal)) : is_compactly_generated (canonically_linear_ordered_monoid ennreal) := sorry --non-trivial
lemma new_lemma_26043 (h0 : fin has_zero.zero) : @t0_space.{1} (has_pos_part.{1} Type) (@matrix.vec_empty.{1} (topological_space.{1} (has_pos_part.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_26044 (h0 : functor.add_const (topological_space (has_to_string unsigned)) environment.implicit_infer_kind) : @loc_path_connected_space.{0} (has_to_string.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (has_to_string.{0} unsigned)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_26045 (h1 : ring (has_top linarith.ineq)) : is_domain (has_top linarith.ineq) := sorry --non-trivial
lemma new_lemma_26046 (h0 : topological_space (comm_ring (has_top linarith.ineq))) : path_connected_space (comm_ring (has_top linarith.ineq)) := sorry --non-trivial
lemma new_lemma_26047 (h0 : topological_space (add_cancel_monoid (option ennreal))) : loc_path_connected_space (add_cancel_monoid (option ennreal)) := sorry --non-trivial
lemma new_lemma_26048 (h0 : topological_space (complete_distrib_lattice (measurable_space.dynkin_system unsigned))) : loc_path_connected_space (complete_distrib_lattice (measurable_space.dynkin_system unsigned)) := sorry --non-trivial
lemma new_lemma_26049 (h0 : functor.add_const (uniform_space (ordered_comm_ring pos)) (has_nndist (ring pos))) : @separated_space.{0} (ordered_comm_ring.{0} pos) (@functor.add_const.run.{0 0} (uniform_space.{0} (ordered_comm_ring.{0} pos)) (has_nndist.{0} (ring.{0} pos)) h0)  := sorry --non-trivial
lemma new_lemma_26050 (h0 : cancel_comm_monoid_with_zero (has_neg_part (has_nndist environment.implicit_infer_kind))) : unique_factorization_monoid (has_neg_part (has_nndist environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_26051 (h0 : function.extfun Type list) : list.nodup (function.extfun_app h0 (semigroup unsigned)) := sorry --non-trivial
lemma new_lemma_26052 (h0 : complete_lattice (with_one (semiring fun_info))) : is_atomistic (with_one (semiring fun_info)) := sorry --non-trivial
lemma new_lemma_26053 (h0 : semiring (boolean_algebra name)) : is_noetherian_ring (boolean_algebra name) := sorry --non-trivial
lemma new_lemma_26054 (h0 : ring (distrib_lattice (has_nnnorm linarith.comp_source))) : strong_rank_condition (distrib_lattice (has_nnnorm linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_26055 (h1 : ring (semi_normed_comm_ring (metric_space to_additive.value_type))) : rank_condition (semi_normed_comm_ring (metric_space to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_26056 (h0 : not (ring (add_right_cancel_monoid (semiring (semiring (semiring (semiring (semiring empty)))))) -> false)) : @is_domain.{0} (add_right_cancel_monoid.{0} (semiring.{0} (semiring.{0} (semiring.{0} (semiring.{0} (semiring.{0} empty)))))) (@classical.by_contradiction'.{1} (ring.{0} (add_right_cancel_monoid.{0} (semiring.{0} (semiring.{0} (semiring.{0} (semiring.{0} (semiring.{0} empty))))))) h0)  := sorry --non-trivial
lemma new_lemma_26057 (h0 : topological_space (linear_ordered_comm_group num)) : normal_space (linear_ordered_comm_group num) := sorry --non-trivial
lemma new_lemma_26058 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : list.nodup (function.extfun_app (function.extfun_app h0 list) (normed_comm_ring pos)) := sorry --non-trivial
lemma new_lemma_26059 (h0 : functor.add_const (complete_lattice (add_comm_monoid unsigned)) empty) : @is_compactly_generated.{0} (add_comm_monoid.{0} unsigned) (@functor.add_const.run.{0 0} (complete_lattice.{0} (add_comm_monoid.{0} unsigned)) empty h0)  := sorry --non-trivial
lemma new_lemma_26060 (h0 : topological_space (canonically_ordered_monoid (has_add (has_Inf linarith.comp)))) : loc_path_connected_space (canonically_ordered_monoid (has_add (has_Inf linarith.comp))) := sorry --non-trivial
lemma new_lemma_26061 (h0 : topological_space (canonically_linear_ordered_monoid (has_add (has_add (has_add ennreal))))) : normal_space (canonically_linear_ordered_monoid (has_add (has_add (has_add ennreal)))) := sorry --non-trivial
lemma new_lemma_26062 (h0 : topological_space (has_le (normed_field reducibility_hints))) : totally_disconnected_space (has_le (normed_field reducibility_hints)) := sorry --non-trivial
lemma new_lemma_26063 (h0 : group (boolean_algebra (has_add real))) : group.fg (boolean_algebra (has_add real)) := sorry --non-trivial
lemma new_lemma_26064 (h0 : functor.comp ring has_zero environment.implicit_infer_kind) : @strong_rank_condition.{0} (has_zero.{0} environment.implicit_infer_kind) (@functor.comp.run.{0 0 0} ring.{0} has_zero.{0} environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_26065 (h0 : not (function.extfun Type topological_space -> false)) : @totally_separated_space.{0} (has_emptyc.{0} fun_info) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (has_emptyc.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_26066 (h0 : fin has_zero.zero) : @is_principal_ideal_ring.{1} (sub_neg_monoid.{1} Type) (@matrix.vec_empty.{1} (ring.{1} (sub_neg_monoid.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_26067 (h0 : functor.add_const (functor.add_const (function.extfun Type ring) pos) (has_neg (finset Type))) : @is_domain.{0} (has_nndist.{0} linarith.comp) (@function.extfun_app.{2 1} Type ring.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type ring.{0}) pos (@functor.add_const.run.{1 1} (functor.add_const.{1 0} (function.extfun.{2 1} Type ring.{0}) pos) (has_neg.{1} (finset.{1} Type)) h0)) (has_nndist.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_26068 (h0 h1 : Prop) : implies h0 (id h1) := sorry --non-trivial
lemma new_lemma_26069 (h0 : ring (has_lt (mul_one_class to_additive.value_type))) : rank_condition (has_lt (mul_one_class to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_26070 (h0 : functor.add_const (group (normed_comm_ring pos)) (ordered_ring linarith.comp)) : @normalizer_condition.{0} (normed_comm_ring.{0} pos) (@functor.add_const.run.{0 0} (group.{0} (normed_comm_ring.{0} pos)) (ordered_ring.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_26071 (h0 : topological_space (left_cancel_semigroup (semiring empty))) : locally_compact_space (left_cancel_semigroup (semiring empty)) := sorry --non-trivial
lemma new_lemma_26072 (h0 : function.extfun Type list) : palindrome (function.extfun_app h0 (add_cancel_comm_monoid unsigned)) := sorry --non-trivial
lemma new_lemma_26073 (h0 : topological_space (add_comm_monoid environment.implicit_infer_kind)) : normal_space (add_comm_monoid environment.implicit_infer_kind) := sorry --non-trivial
lemma new_lemma_26074 (h0 : topological_space (add_right_cancel_monoid (semiring unsigned))) : path_connected_space (add_right_cancel_monoid (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_26075 (h0 : functor.add_const (add_group (add_group congr_arg_kind)) empty) : @is_add_cyclic.{0} (add_group.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (add_group.{0} (add_group.{0} congr_arg_kind)) empty h0)  := sorry --non-trivial
lemma new_lemma_26076 (h2 : add_group (topological_space (random_gen to_additive.value_type))) : is_add_cyclic (topological_space (random_gen to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_26077 (h0 : add_monoid (simple_graph empty)) : add_monoid.fg (simple_graph empty) := sorry --non-trivial
lemma new_lemma_26078 (h0 : function.extfun Type semiring) : @is_noetherian_ring.{0} (left_cancel_monoid.{0} empty) (@function.extfun_app.{2 1} Type semiring.{0} h0 (left_cancel_monoid.{0} empty))  := sorry --non-trivial
lemma new_lemma_26079 (h0 : functor.add_const (topological_space (add_cancel_monoid linarith.comp)) (has_neg (has_neg Type))) : @path_connected_space.{0} (add_cancel_monoid.{0} linarith.comp) (@functor.add_const.run.{0 1} (topological_space.{0} (add_cancel_monoid.{0} linarith.comp)) (has_neg.{1} (has_neg.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_26080 (h0 : not (complete_lattice (has_add znum) -> false)) : @complete_lattice.is_Sup_finite_compact.{0} (has_add.{0} znum) (@classical.by_contradiction'.{1} (complete_lattice.{0} (has_add.{0} znum)) h0)  := sorry --non-trivial
lemma new_lemma_26081 (h0 : has_Inf (canonically_ordered_monoid Type) -> has_Inf (canonically_ordered_monoid Type) -> Prop) : is_antisymm (has_Inf (canonically_ordered_monoid Type)) h0 := sorry --non-trivial
lemma new_lemma_26082 (h0 : topological_space (canonically_ordered_add_monoid num)) : path_connected_space (canonically_ordered_add_monoid num) := sorry --non-trivial
lemma new_lemma_26083 (h0 : cancel_comm_monoid_with_zero (has_to_string (has_to_string (has_to_string (has_to_string unsigned))))) : unique_factorization_monoid (has_to_string (has_to_string (has_to_string (has_to_string unsigned)))) := sorry --non-trivial
lemma new_lemma_26084 (h0 : topological_space (has_nndist (has_add environment.implicit_infer_kind))) : preirreducible_space (has_nndist (has_add environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_26085 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_atomistic.{0} (finset.{0} pos) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (finset.{0} pos))  := sorry --non-trivial
lemma new_lemma_26086 (h0 : function.extfun Type topological_space) : @locally_compact_space.{0} (add_comm_monoid.{0} (option.{0} num)) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (add_comm_monoid.{0} (option.{0} num)))  := sorry --non-trivial
lemma new_lemma_26087 (h3 : monoid linarith.comp_source) : monoid.fg linarith.comp_source := sorry --non-trivial
lemma new_lemma_26088 (h0 : uniform_space (complete_semilattice_Sup linarith.comp_source)) : complete_space (complete_semilattice_Sup linarith.comp_source) := sorry --non-trivial
lemma new_lemma_26089 (h0 : not (topological_space (left_cancel_monoid congr_arg_kind) -> false)) : @preirreducible_space.{0} (left_cancel_monoid.{0} congr_arg_kind) (@classical.by_contradiction'.{1} (topological_space.{0} (left_cancel_monoid.{0} congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_26090 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @monoid.fg.{0} (has_nndist.{0} num) (@function.extfun_app.{2 1} Type monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 monoid.{0}) (has_nndist.{0} num))  := sorry --non-trivial
lemma new_lemma_26091 (h0 : functor.add_const (function.extfun Type topological_space) environment.implicit_infer_kind) : @discrete_topology.{0} (ring.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) environment.implicit_infer_kind h0) (ring.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_26092 (h0 : topological_space (ordered_cancel_add_comm_monoid congr_arg_kind)) : normal_space (ordered_cancel_add_comm_monoid congr_arg_kind) := sorry --non-trivial
lemma new_lemma_26093 (h0 : uniform_space (has_pos_part (has_Inf real))) : complete_space (has_pos_part (has_Inf real)) := sorry --non-trivial
lemma new_lemma_26094 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @monoid.fg.{0} (non_assoc_semiring.{0} empty) (@function.extfun_app.{2 1} Type monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 monoid.{0}) (non_assoc_semiring.{0} empty))  := sorry --non-trivial
lemma new_lemma_26095 (h0 : uniform_space (generalized_boolean_algebra (has_add (has_nndist (has_add linarith.comp))))) : separated_space (generalized_boolean_algebra (has_add (has_nndist (has_add linarith.comp)))) := sorry --non-trivial
lemma new_lemma_26096 (h0 : topological_space (linear_ordered_comm_ring (mul_zero_class num))) : topological_space.separable_space (linear_ordered_comm_ring (mul_zero_class num)) := sorry --non-trivial
lemma new_lemma_26097 (h0 : functor.add_const (topological_space (add_cancel_monoid name)) environment.implicit_infer_kind) : @path_connected_space.{0} (add_cancel_monoid.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (add_cancel_monoid.{0} name)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_26098 (h1 : topological_space (has_div std_gen)) (h2 : preorder (has_div std_gen)) : order_topology (has_div std_gen) := sorry --non-trivial
lemma new_lemma_26099 (h0 : functor.add_const (topological_space (option empty)) empty) : @topological_space.separable_space.{0} (option.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (option.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_26100 (h0 : topological_space (comm_semigroup (has_bot (ordered_comm_monoid linarith.comp)))) : preirreducible_space (comm_semigroup (has_bot (ordered_comm_monoid linarith.comp))) := sorry --non-trivial
lemma new_lemma_26101 (h0 : set (has_div string.iterator_imp)) : set.subsingleton h0 := sorry --non-trivial
lemma new_lemma_26102 (h0 : std_gen -> Prop) (h1 : unit) (h2 : std_gen) : matrix.row h0 h1 h2 := sorry --non-trivial
lemma new_lemma_26103 (h2 : ring (with_bot string_imp)) : is_domain (with_bot string_imp) := sorry --non-trivial
lemma new_lemma_26104 (h0 : topological_space (ordered_comm_ring (has_nndist (has_neg Type)))) : discrete_topology (ordered_comm_ring (has_nndist (has_neg Type))) := sorry --non-trivial
lemma new_lemma_26105 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_cyclic.{0} (with_one.{0} real) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (with_one.{0} real))  := sorry --non-trivial
lemma new_lemma_26106 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @normalizer_condition.{0} (left_cancel_monoid.{0} empty) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (left_cancel_monoid.{0} empty))  := sorry --non-trivial
lemma new_lemma_26107 (h0 : list (canonically_ordered_comm_semiring name)) : palindrome h0 := sorry --non-trivial
lemma new_lemma_26108 (h0 : functor.add_const (group (boolean_algebra.core Type)) Type) : @is_simple_group.{1} (boolean_algebra.core.{1} Type) (@functor.add_const.run.{1 1} (group.{1} (boolean_algebra.core.{1} Type)) Type h0)  := sorry --non-trivial
lemma new_lemma_26109 (h0 : measurable_space (nondiscrete_normed_field string.iterator_imp)) (h1 : filter (nondiscrete_normed_field string.iterator_imp)) : filter.is_measurably_generated h1 := sorry --non-trivial
lemma new_lemma_26110 (h0 : function.extfun Type ring) : @is_domain.{0} (linear_ordered_cancel_comm_monoid.{0} unsigned) (@function.extfun_app.{2 1} Type ring.{0} h0 (linear_ordered_cancel_comm_monoid.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_26111 (h0 : topological_space (cancel_monoid congr_arg_kind)) : irreducible_space (cancel_monoid congr_arg_kind) := sorry --non-trivial
lemma new_lemma_26112 (h0 : add_group (normed_group (has_top (has_top (has_top (has_top linarith.ineq)))))) : is_add_cyclic (normed_group (has_top (has_top (has_top (has_top linarith.ineq))))) := sorry --non-trivial
lemma new_lemma_26113 (h0 : functor.add_const (topological_space (has_to_string unsigned)) pos) : @t1_space.{0} (has_to_string.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (has_to_string.{0} unsigned)) pos h0)  := sorry --non-trivial
lemma new_lemma_26114 (h0 : has_add Type) (h1 : Type) : add_commute h1 (ultrafilter string.iterator_imp) := sorry --non-trivial
lemma new_lemma_26115 (h0 : not (uniform_space (semi_normed_comm_ring (semi_normed_ring reducibility_hints)) -> false)) : @complete_space.{0} (semi_normed_comm_ring.{0} (semi_normed_ring.{0} reducibility_hints)) (@classical.by_contradiction'.{1} (uniform_space.{0} (semi_normed_comm_ring.{0} (semi_normed_ring.{0} reducibility_hints))) h0)  := sorry --non-trivial
lemma new_lemma_26116 (h0 : not (complete_lattice (measurable_space congr_arg_kind) -> false)) : is_compactly_generated (measurable_space congr_arg_kind) := sorry --non-trivial
lemma new_lemma_26117 (h0 : functor.add_const (topological_space (has_nndist environment.implicit_infer_kind)) environment.implicit_infer_kind) : @irreducible_space.{0} (has_nndist.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (has_nndist.{0} environment.implicit_infer_kind)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_26118 (h0 : group (has_Inf (has_nndist pos))) : normalizer_condition (has_Inf (has_nndist pos)) := sorry --non-trivial
lemma new_lemma_26119 (h0 : ordered_comm_monoid (finset (ring (has_Inf (boolean_algebra (ring Type)))))) : has_exists_mul_of_le (finset (ring (has_Inf (boolean_algebra (ring Type))))) := sorry --non-trivial
lemma new_lemma_26120 (h0 : function.extfun (measurable_space congr_arg_kind) (fun (x : measurable_space congr_arg_kind), Prop)) : @infi.{0 1} Prop (@conditionally_complete_lattice.to_has_Inf.{0} Prop (@complete_lattice.to_conditionally_complete_lattice.{0} Prop Prop.complete_lattice)) (measurable_space.{0} congr_arg_kind) (@function.extfun_app.{1 1} (measurable_space.{0} congr_arg_kind) (λ (x : measurable_space.{0} congr_arg_kind), Prop) h0)  := sorry --non-trivial
lemma new_lemma_26121 (h0 h1 : set linarith.comp_source) (h2 : linarith.comp_source) : set.inter h0 h1 h2 := sorry --non-trivial
lemma new_lemma_26122 (h0 : topological_space (semigroup (option unsigned))) : normal_space (semigroup (option unsigned)) := sorry --non-trivial
lemma new_lemma_26123 (h0 : functor.add_const (complete_lattice (boolean_algebra pos)) environment.implicit_infer_kind) : @is_compactly_generated.{0} (boolean_algebra.{0} pos) (@functor.add_const.run.{0 0} (complete_lattice.{0} (boolean_algebra.{0} pos)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_26124 (h0 : ring (denumerable (random_gen (random_gen to_additive.value_type)))) : rank_condition (denumerable (random_gen (random_gen to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_26125 (h0 : functor.add_const (semiring (has_neg pos)) name) : @is_noetherian_ring.{0} (has_neg.{0} pos) (@functor.add_const.run.{0 0} (semiring.{0} (has_neg.{0} pos)) name h0)  := sorry --non-trivial
lemma new_lemma_26126 (h0 : functor.add_const (topological_space (comm_group unsigned)) unsigned) : @totally_separated_space.{0} (comm_group.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (comm_group.{0} unsigned)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_26127 (h0 : functor.add_const (group (left_cancel_monoid unsigned)) empty) : @group.fg.{0} (left_cancel_monoid.{0} unsigned) (@functor.add_const.run.{0 0} (group.{0} (left_cancel_monoid.{0} unsigned)) empty h0)  := sorry --non-trivial
lemma new_lemma_26128 (h0 : group (with_bot (has_norm (random_gen fun_info)))) : is_cyclic (with_bot (has_norm (random_gen fun_info))) := sorry --non-trivial
lemma new_lemma_26129 (h0 : function.extfun Type complete_lattice) : @complete_lattice.is_Sup_finite_compact.{0} (option.{0} unsigned) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (option.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_26130 (h0 : add_monoid (with_one (has_emptyc linarith.comp))) : add_monoid.fg (with_one (has_emptyc linarith.comp)) := sorry --non-trivial
lemma new_lemma_26131 (h0 : cancel_comm_monoid_with_zero (pseudo_metric_space num)) : unique_factorization_monoid (pseudo_metric_space num) := sorry --non-trivial
lemma new_lemma_26132 (h0 : functor.add_const (add_monoid (has_neg pos)) (ordered_ring (ordered_ring linarith.comp))) : @add_monoid.fg.{0} (has_neg.{0} pos) (@functor.add_const.run.{0 0} (add_monoid.{0} (has_neg.{0} pos)) (ordered_ring.{0} (ordered_ring.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_26133 (h0 : has_mem.mem (with_one fun_info) has_emptyc.emptyc) : @rank_condition.{0} (with_one.{0} fun_info) (@finset.pi.empty.{1 0} Type ring.{0} (with_one.{0} fun_info) h0)  := sorry --non-trivial
lemma new_lemma_26134 (h0 : function.extfun Type group) : @is_cyclic.{0} (has_Sup.{0} (semiring.{0} empty)) (@function.extfun_app.{2 1} Type group.{0} h0 (has_Sup.{0} (semiring.{0} empty)))  := sorry --non-trivial
lemma new_lemma_26135 (h0 : complete_lattice (semi_normed_ring linarith.ineq)) : complete_lattice.is_Sup_finite_compact (semi_normed_ring linarith.ineq) := sorry --non-trivial
lemma new_lemma_26136 (h0 : function.extfun Type topological_space) : @path_connected_space.{0} (has_emptyc.{0} (has_norm.{0} to_additive.value_type)) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_emptyc.{0} (has_norm.{0} to_additive.value_type)))  := sorry --non-trivial
lemma new_lemma_26137 (h0 : topological_space (has_neg_part (has_nndist name))) : t0_space (has_neg_part (has_nndist name)) := sorry --non-trivial
lemma new_lemma_26138 (h0 : function.extfun Type filter) : countable_Inter_filter (function.extfun_app h0 (boolean_algebra environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_26139 (h0 : topological_space (add_semigroup empty)) : irreducible_space (add_semigroup empty) := sorry --non-trivial
lemma new_lemma_26140 (h2 : set (add_comm_semigroup linarith.ineq -> linarith.ineq)) : set.separates_points h2 := sorry --non-trivial
lemma new_lemma_26141 (h0 : group (plift (semiring (semiring empty)))) : normalizer_condition (plift (semiring (semiring empty))) := sorry --non-trivial
lemma new_lemma_26142 (h0 : topological_space (semi_normed_comm_ring (random_gen (has_nnnorm to_additive.value_type)))) : path_connected_space (semi_normed_comm_ring (random_gen (has_nnnorm to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_26143 (h0 : topological_space (has_to_string congr_arg_kind)) : t0_space (has_to_string congr_arg_kind) := sorry --non-trivial
lemma new_lemma_26144 (h0 : complete_lattice (free_add_monoid (option (option (option unsigned))))) : complete_lattice.is_Sup_finite_compact (free_add_monoid (option (option (option unsigned)))) := sorry --non-trivial
lemma new_lemma_26145 (h0 : functor.add_const (ring (omega_complete_partial_order unsigned)) empty) : @is_domain.{0} (omega_complete_partial_order.{0} unsigned) (@functor.add_const.run.{0 0} (ring.{0} (omega_complete_partial_order.{0} unsigned)) empty h0)  := sorry --non-trivial
lemma new_lemma_26146 (h0 : not (group (preorder congr_arg_kind) -> false)) : @group.fg.{0} (preorder.{0} congr_arg_kind) (@classical.by_contradiction'.{1} (group.{0} (preorder.{0} congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_26147 (h0 : function.extfun Type topological_space) : @loc_path_connected_space.{0} (semigroup.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (semigroup.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_26148 (h0 : cancel_comm_monoid_with_zero (plift (has_top empty))) : unique_factorization_monoid (plift (has_top empty)) := sorry --non-trivial
lemma new_lemma_26149 (h0 : topological_space (linear_ordered_semiring (random_gen linarith.comp_source))) : path_connected_space (linear_ordered_semiring (random_gen linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_26150 (h0 : not (ring (linear_ordered_comm_group_with_zero string.iterator_imp) -> false)) : @strong_rank_condition.{0} (linear_ordered_comm_group_with_zero.{0} string.iterator_imp) (@classical.by_contradiction'.{1} (ring.{0} (linear_ordered_comm_group_with_zero.{0} string.iterator_imp)) h0)  := sorry --non-trivial
lemma new_lemma_26151 (h0 : functor.add_const (topological_space (has_dist unsigned)) num) : @topological_space.separable_space.{0} (has_dist.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (has_dist.{0} unsigned)) num h0)  := sorry --non-trivial
lemma new_lemma_26152 (h0 : topological_space (normed_comm_ring (has_to_string name))) : preconnected_space (normed_comm_ring (has_to_string name)) := sorry --non-trivial
lemma new_lemma_26153 (h0 : function.extfun Type topological_space) : @irreducible_space.{0} (monoid.{0} ennreal) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (monoid.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_26154 (h0 : topological_space (left_cancel_semigroup unsigned)) : totally_disconnected_space (left_cancel_semigroup unsigned) := sorry --non-trivial
lemma new_lemma_26155 (h0 : add_group (add_comm_monoid (sub_neg_monoid pos))) : is_add_cyclic (add_comm_monoid (sub_neg_monoid pos)) := sorry --non-trivial
lemma new_lemma_26156 (h0 : topological_space (has_neg pos)) : topological_space.separable_space (has_neg pos) := sorry --non-trivial
lemma new_lemma_26157 (h0 : ring (ordered_comm_monoid (ring Type))) : rank_condition (ordered_comm_monoid (ring Type)) := sorry --non-trivial
lemma new_lemma_26158 (h0 : functor.add_const Prop (has_Inf (ring (ring pos)))) : functor.add_const.run h0 := sorry --non-trivial
lemma new_lemma_26159 (h0 : not (topological_space (has_sub empty) -> false)) : @locally_compact_space.{0} (has_sub.{0} empty) (@classical.by_contradiction'.{1} (topological_space.{0} (has_sub.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_26160 (h1 : topological_space (comm_ring (add_cancel_comm_monoid (normed_field (has_append reducibility_hints))))) : t0_space (comm_ring (add_cancel_comm_monoid (normed_field (has_append reducibility_hints)))) := sorry --non-trivial
lemma new_lemma_26161 (h0 : functor.add_const (add_monoid (has_to_string pos)) (has_to_string name)) : @add_monoid.fg.{0} (has_to_string.{0} pos) (@functor.add_const.run.{0 0} (add_monoid.{0} (has_to_string.{0} pos)) (has_to_string.{0} name) h0)  := sorry --non-trivial
lemma new_lemma_26162 (h0 : functor.add_const (uniform_space (has_neg Type)) pos) : @complete_space.{1} (has_neg.{1} Type) (@functor.add_const.run.{1 0} (uniform_space.{1} (has_neg.{1} Type)) pos h0)  := sorry --non-trivial
lemma new_lemma_26163 (h0 : ring (has_add (finset environment.implicit_infer_kind))) : strong_rank_condition (has_add (finset environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_26164 (h0 : set (fun_info -> mul_one_class std_gen)) : set.separates_points h0 := sorry --non-trivial
lemma new_lemma_26165 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @strong_rank_condition.{0} (simple_graph.{0} empty) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (simple_graph.{0} empty))  := sorry --non-trivial
lemma new_lemma_26166 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_noetherian_ring.{0} (add_comm_monoid.{0} pos) (@function.extfun_app.{2 1} Type semiring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 semiring.{0}) (add_comm_monoid.{0} pos))  := sorry --non-trivial
lemma new_lemma_26167 (h0 : functor.add_const (function.extfun (Type 1) add_monoid) name) : @add_monoid.fg.{1} (has_nndist.{1} Type) (@function.extfun_app.{3 2} (Type 1) add_monoid.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) add_monoid.{1}) name h0) (has_nndist.{1} Type))  := sorry --non-trivial
lemma new_lemma_26168 (h0 : topological_space (has_inv (random_gen (has_inv (has_inv linarith.ineq))))) : totally_disconnected_space (has_inv (random_gen (has_inv (has_inv linarith.ineq)))) := sorry --non-trivial
lemma new_lemma_26169 (h0 : fin has_zero.zero) : @complete_space.{1} (boolean_algebra.core.{1} Type) (@matrix.vec_empty.{1} (uniform_space.{1} (boolean_algebra.core.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_26170 (h0 : topological_space (canonically_ordered_comm_semiring (boolean_algebra pos))) : locally_compact_space (canonically_ordered_comm_semiring (boolean_algebra pos)) := sorry --non-trivial
lemma new_lemma_26171 (h0 : functor.add_const (topological_space (metric_space congr_arg_kind)) num) : @locally_compact_space.{0} (metric_space.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (metric_space.{0} congr_arg_kind)) num h0)  := sorry --non-trivial
lemma new_lemma_26172 (h0 : group (boolean_algebra (has_to_string (has_to_string (has_to_string linarith.comp))))) : is_cyclic (boolean_algebra (has_to_string (has_to_string (has_to_string linarith.comp)))) := sorry --non-trivial
lemma new_lemma_26173 (h0 : ring (normed_group (has_norm linarith.comp))) : rank_condition (normed_group (has_norm linarith.comp)) := sorry --non-trivial
lemma new_lemma_26174 (h0 : function.extfun Type topological_space) : @loc_path_connected_space.{0} (linear_ordered_field.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (linear_ordered_field.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_26175 (h0 : complete_lattice (complete_semilattice_Sup empty)) : is_atomistic (complete_semilattice_Sup empty) := sorry --non-trivial
lemma new_lemma_26176 (h0 : topological_space (semiring (random_gen (has_norm linarith.ineq)))) : path_connected_space (semiring (random_gen (has_norm linarith.ineq))) := sorry --non-trivial
lemma new_lemma_26177 (h0 : function.extfun Type group) : @group.fg.{0} (complete_distrib_lattice.{0} empty) (@function.extfun_app.{2 1} Type group.{0} h0 (complete_distrib_lattice.{0} empty))  := sorry --non-trivial
lemma new_lemma_26178 (h0 : ulower Prop) : @id.{1} Prop (@ulower.up.{0} Prop encodable.Prop h0)  := sorry --non-trivial
lemma new_lemma_26179 (h0 : group (random_gen (has_top linarith.comp))) : group.fg (random_gen (has_top linarith.comp)) := sorry --non-trivial
lemma new_lemma_26180 (h0 : not (ring (normed_group (random_gen fun_info)) -> false)) : @rank_condition.{0} (normed_group.{0} (random_gen.{0} fun_info)) (@classical.by_contradiction'.{1} (ring.{0} (normed_group.{0} (random_gen.{0} fun_info))) h0)  := sorry --non-trivial
lemma new_lemma_26181 (h0 : functor.add_const (topological_space (ring linarith.comp)) pos) : @totally_disconnected_space.{0} (ring.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (ring.{0} linarith.comp)) pos h0)  := sorry --non-trivial
lemma new_lemma_26182 (h0 : topological_space (has_bot (has_pos_part linarith.comp))) : t0_space (has_bot (has_pos_part linarith.comp)) := sorry --non-trivial
lemma new_lemma_26183 (h3 : ring (normed_field ereal)) : rank_condition (normed_field ereal) := sorry --non-trivial
lemma new_lemma_26184 (h0 : list (mul_zero_class (semigroup pos))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_26185 (h0 : uniform_space (finset (ring pos))) : separated_space (finset (ring pos)) := sorry --non-trivial
lemma new_lemma_26186 (h0 : function.extfun (Type 1) group) : @group.fg.{1} (simple_graph.{1} Type) (@function.extfun_app.{3 2} (Type 1) group.{1} h0 (simple_graph.{1} Type))  := sorry --non-trivial
lemma new_lemma_26187 (h0 : functor.add_const (ring (cancel_monoid environment.implicit_infer_kind)) Type) : @strong_rank_condition.{0} (cancel_monoid.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 1} (ring.{0} (cancel_monoid.{0} environment.implicit_infer_kind)) Type h0)  := sorry --non-trivial
lemma new_lemma_26188 (h0 : functor.add_const (group (has_add Type)) environment.implicit_infer_kind) : @group.fg.{1} (has_add.{1} Type) (@functor.add_const.run.{1 0} (group.{1} (has_add.{1} Type)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_26189 (h0 : function.extfun Type group) : @is_simple_group.{0} (has_nndist.{0} real) (@function.extfun_app.{2 1} Type group.{0} h0 (has_nndist.{0} real))  := sorry --non-trivial
lemma new_lemma_26190 (h0 : functor.add_const (topological_space (left_cancel_monoid num)) congr_arg_kind) : @totally_disconnected_space.{0} (left_cancel_monoid.{0} num) (@functor.add_const.run.{0 0} (topological_space.{0} (left_cancel_monoid.{0} num)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_26191 (h0 : topological_space (boolean_algebra (has_Inf (has_pos_part pos)))) : discrete_topology (boolean_algebra (has_Inf (has_pos_part pos))) := sorry --non-trivial
lemma new_lemma_26192 (h0 : filter (has_neg congr_arg_kind)) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_26193 (h0 : uniform_space (canonically_linear_ordered_monoid name)) : complete_space (canonically_linear_ordered_monoid name) := sorry --non-trivial
lemma new_lemma_26194 (h0 : functor.add_const (topological_space (has_nndist environment.implicit_infer_kind)) linarith.comp) : @locally_compact_space.{0} (has_nndist.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (has_nndist.{0} environment.implicit_infer_kind)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_26195 (h0 : not (monoid (has_norm empty) -> false)) : @monoid.fg.{0} (has_norm.{0} empty) (@classical.by_contradiction'.{1} (monoid.{0} (has_norm.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_26196 (h0 : uniform_space (normed_lattice_add_comm_group (has_add (has_Inf pos)))) : separated_space (normed_lattice_add_comm_group (has_add (has_Inf pos))) := sorry --non-trivial
lemma new_lemma_26197 (h0 : function.extfun Type filter) : filter.ne_bot (function.extfun_app h0 (with_bot empty)) := sorry --non-trivial
lemma new_lemma_26198 (h0 h1 : multiset (mul_one_class reducibility_hints)) : multiset.subset h0 h1 := sorry --non-trivial
lemma new_lemma_26199 (h0 : topological_space (has_neg (option pos))) : regular_space (has_neg (option pos)) := sorry --non-trivial
lemma new_lemma_26200 (h0 : filter (semigroup (has_nndist (has_neg Type)))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_26201 (h0 : topological_space (linear_ordered_add_comm_group char)) : path_connected_space (linear_ordered_add_comm_group char) := sorry --non-trivial
lemma new_lemma_26202 (h0 : topological_space (random_gen (has_inv (has_inv (has_inv linarith.ineq))))) : locally_compact_space (random_gen (has_inv (has_inv (has_inv linarith.ineq)))) := sorry --non-trivial
lemma new_lemma_26203 (h0 : topological_space (complete_distrib_lattice linarith.comp)) : preconnected_space (complete_distrib_lattice linarith.comp) := sorry --non-trivial
lemma new_lemma_26204 (h0 : function.extfun Type ring) : @is_principal_ideal_ring.{0} (ordered_ring.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type ring.{0} h0 (ordered_ring.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_26205 (h0 : list (linear_ordered_field (option (option (option (option num)))))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_26206 (h0 : function.extfun Type topological_space) : @preirreducible_space.{0} (pseudo_metric_space.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (pseudo_metric_space.{0} name))  := sorry --non-trivial
lemma new_lemma_26207 (h0 : functor.add_const (function.extfun Type list) pos) : palindrome (function.extfun_app (functor.add_const.run h0) (has_zero linarith.comp)) := sorry --non-trivial
lemma new_lemma_26208 (h0 : not (function.extfun Type topological_space -> false)) : @totally_disconnected_space.{0} (with_one.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (with_one.{0} num))  := sorry --non-trivial
lemma new_lemma_26209 (h0 : ring (simple_graph (sub_neg_monoid name))) : is_principal_ideal_ring (simple_graph (sub_neg_monoid name)) := sorry --non-trivial
lemma new_lemma_26210 (h0 : measurable_space environment.projection_info) (h1 : measure_theory.measure environment.projection_info) : measure_theory.measure.is_complete h1 := sorry --non-trivial
lemma new_lemma_26211 (h0 : fin has_zero.zero) (h1 : not (measurable_space (metric_space empty) -> false)) : @has_measurable_neg.{0} (metric_space.{0} empty) (@matrix.vec_empty.{0} (has_neg.{0} (metric_space.{0} empty)) h0) (@classical.by_contradiction'.{1} (measurable_space.{0} (metric_space.{0} empty)) h1)  := sorry --non-trivial
lemma new_lemma_26212 (h0 : semiring (mul_one_class linarith.ineq)) (h1 : ideal (mul_one_class linarith.ineq)) : ideal.is_prime h1 := sorry --non-trivial
lemma new_lemma_26213 (h0 : monoid (partial_order num)) : monoid.fg (partial_order num) := sorry --non-trivial
lemma new_lemma_26214 (h0 : list (measurable_space (has_inv (has_inv (has_inv linarith.ineq))))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_26215 (h0 : uniform_space subsingleton_info) : complete_space subsingleton_info := sorry --non-trivial
lemma new_lemma_26216 (h0 : not (function.extfun Type topological_space -> false)) : @t0_space.{0} (complete_semilattice_Sup.{0} (random_gen.{0} linarith.comp_source)) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (complete_semilattice_Sup.{0} (random_gen.{0} linarith.comp_source)))  := sorry --non-trivial
lemma new_lemma_26217 (h0 : ring (has_neg (has_add (has_add (has_add pos))))) : rank_condition (has_neg (has_add (has_add (has_add pos)))) := sorry --non-trivial
lemma new_lemma_26218 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : finset.nonempty (function.extfun_app (function.extfun_app h0 finset) (ordered_comm_group empty)) := sorry --non-trivial
lemma new_lemma_26219 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @monoid.fg.{1} Type (@function.extfun_app.{3 2} (Type 1) monoid.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 monoid.{1}) Type)  := sorry --non-trivial
lemma new_lemma_26220 (h0 : functor.add_const (add_monoid (non_assoc_semiring num)) (semiring empty)) : @add_monoid.fg.{0} (non_assoc_semiring.{0} num) (@functor.add_const.run.{0 0} (add_monoid.{0} (non_assoc_semiring.{0} num)) (semiring.{0} empty) h0)  := sorry --non-trivial
lemma new_lemma_26221 (h0 : function.extfun Type filter) : filter.ne_bot (function.extfun_app h0 (normed_group linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_26222 (h0 : functor.add_const (cancel_comm_monoid_with_zero (boolean_algebra.core linarith.comp)) Type) : @unique_factorization_monoid.{0} (boolean_algebra.core.{0} linarith.comp) (@functor.add_const.run.{0 1} (cancel_comm_monoid_with_zero.{0} (boolean_algebra.core.{0} linarith.comp)) Type h0)  := sorry --non-trivial
lemma new_lemma_26223 (h0 : functor.comp ring has_neg_part pos) : @strong_rank_condition.{0} (has_neg_part.{0} pos) (@functor.comp.run.{0 0 0} ring.{0} has_neg_part.{0} pos h0)  := sorry --non-trivial
lemma new_lemma_26224 (h0 : filter (has_add (has_add name))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_26225 (h0 : topological_space (as_linear_order (comm_monoid unsigned))) : totally_disconnected_space (as_linear_order (comm_monoid unsigned)) := sorry --non-trivial
lemma new_lemma_26226 (h0 : complete_lattice (ring (normed_comm_ring (finset pos)))) : complete_lattice.is_Sup_finite_compact (ring (normed_comm_ring (finset pos))) := sorry --non-trivial
lemma new_lemma_26227 (h0 : function.extfun Type uniform_space) : @complete_space.{0} (linear_ordered_comm_group.{0} empty) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (linear_ordered_comm_group.{0} empty))  := sorry --non-trivial
lemma new_lemma_26228 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_atomistic.{0} (boolean_algebra.{0} pos) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (boolean_algebra.{0} pos))  := sorry --non-trivial
lemma new_lemma_26229 (h0 : topological_space (has_Inf real)) : t1_space (has_Inf real) := sorry --non-trivial
lemma new_lemma_26230 (h0 : functor.add_const (group (has_Inf name)) name) : @group.fg.{0} (has_Inf.{0} name) (@functor.add_const.run.{0 0} (group.{0} (has_Inf.{0} name)) name h0)  := sorry --non-trivial
lemma new_lemma_26231 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @preconnected_space.{0} (has_neg.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_neg.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_26232 (h0 : function.extfun Type list) : palindrome (function.extfun_app h0 (measure_theory.measure_space num)) := sorry --non-trivial
lemma new_lemma_26233 (h0 : functor.add_const (topological_space (filter unsigned)) empty) : @t0_space.{0} (filter.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (filter.{0} unsigned)) empty h0)  := sorry --non-trivial
lemma new_lemma_26234 (h0 : topological_space (has_add char)) : t0_space (has_add char) := sorry --non-trivial
lemma new_lemma_26235 (h0 : functor.add_const (filter (cancel_monoid ennreal)) linarith.comp) : filter.ne_bot (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_26236 (h0 : group (add_left_cancel_monoid fun_info)) : is_cyclic (add_left_cancel_monoid fun_info) := sorry --non-trivial
lemma new_lemma_26237 (h0 : group (has_norm (has_top (has_norm (random_gen linarith.comp_source))))) : group.fg (has_norm (has_top (has_norm (random_gen linarith.comp_source)))) := sorry --non-trivial
lemma new_lemma_26238 (h0 : add_group (ordered_comm_monoid (finset linarith.comp))) : is_add_cyclic (ordered_comm_monoid (finset linarith.comp)) := sorry --non-trivial
lemma new_lemma_26239 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_add_cyclic.{0} (complete_semilattice_Sup.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type add_group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 add_group.{0}) (complete_semilattice_Sup.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_26240 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @has_exists_mul_of_le.{0} (has_neg.{0} unsigned) (@function.extfun_app.{2 1} Type ordered_comm_monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ordered_comm_monoid.{0}) (has_neg.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_26241 (h0 : topological_space (has_inner empty congr_arg_kind)) : t0_space (has_inner empty congr_arg_kind) := sorry --non-trivial
lemma new_lemma_26242 (h0 : not (cancel_comm_monoid_with_zero name -> false)) : @unique_factorization_monoid.{0} name (@classical.by_contradiction'.{1} (cancel_comm_monoid_with_zero.{0} name) h0)  := sorry --non-trivial
lemma new_lemma_26243 (h1 : topological_space (has_emptyc linarith.comp)) : path_connected_space (has_emptyc linarith.comp) := sorry --non-trivial
lemma new_lemma_26244 (h0 : ring (comm_ring (comm_ring linarith.ineq))) : rank_condition (comm_ring (comm_ring linarith.ineq)) := sorry --non-trivial
lemma new_lemma_26245 (h0 : topological_space (has_compl (has_nnnorm string_imp))) : totally_disconnected_space (has_compl (has_nnnorm string_imp)) := sorry --non-trivial
lemma new_lemma_26246 (h0 : not (add_group (has_one num) -> false)) : @is_add_cyclic.{0} (has_one.{0} num) (@classical.by_contradiction'.{1} (add_group.{0} (has_one.{0} num)) h0)  := sorry --non-trivial
lemma new_lemma_26247 (h0 : not (topological_space (has_one empty) -> false)) : @discrete_topology.{0} (has_one.{0} empty) (@classical.by_contradiction'.{1} (topological_space.{0} (has_one.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_26248 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @strong_rank_condition.{0} (semigroup.{0} empty) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (semigroup.{0} empty))  := sorry --non-trivial
lemma new_lemma_26249 (h0 : functor.add_const (complete_lattice (has_zero unsigned)) name) : @is_atomistic.{0} (has_zero.{0} unsigned) (@functor.add_const.run.{0 0} (complete_lattice.{0} (has_zero.{0} unsigned)) name h0)  := sorry --non-trivial
lemma new_lemma_26250 (h1 : function.extfun (Type -> Type) (function.extfun Type)) : @is_atomistic.{0} (complete_semilattice_Sup.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h1 complete_lattice.{0}) (complete_semilattice_Sup.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_26251 (h0 : functor.add_const (ring (finset linarith.comp)) Type) : @rank_condition.{0} (finset.{0} linarith.comp) (@functor.add_const.run.{0 1} (ring.{0} (finset.{0} linarith.comp)) Type h0)  := sorry --non-trivial
lemma new_lemma_26252 (h0 : functor.add_const (complete_lattice (boolean_algebra name)) name) : @is_atomistic.{0} (boolean_algebra.{0} name) (@functor.add_const.run.{0 0} (complete_lattice.{0} (boolean_algebra.{0} name)) name h0)  := sorry --non-trivial
lemma new_lemma_26253 (h0 : topological_space (complete_distrib_lattice (has_add ennreal))) : locally_compact_space (complete_distrib_lattice (has_add ennreal)) := sorry --non-trivial
lemma new_lemma_26254 (h0 : set (add_comm_semigroup fun_info)) (h1 : add_comm_semigroup fun_info -> add_comm_semigroup fun_info -> Prop) : set.partially_well_ordered_on h0 h1 := sorry --non-trivial
lemma new_lemma_26255 (h0 : ring (add_comm_monoid (has_to_string (has_add (has_add pos))))) : is_principal_ideal_ring (add_comm_monoid (has_to_string (has_add (has_add pos)))) := sorry --non-trivial
lemma new_lemma_26256 (h0 : function.extfun Type topological_space) : @sequential_space.{0} (finset.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (finset.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_26257 (h1 : heq ereal (add_comm_semigroup ereal)) (h2 : ring ereal) : @strong_rank_condition.{0} (add_comm_semigroup.{0} ereal) (@heq.elim.{2 1} Type ereal ring.{0} (add_comm_semigroup.{0} ereal) h1 h2)  := sorry --non-trivial
lemma new_lemma_26258 (h0 : function.extfun Type topological_space) : @path_connected_space.{0} (semigroup.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (semigroup.{0} pos))  := sorry --non-trivial
lemma new_lemma_26259 (h1 : topological_space (comm_ring reducibility_hints)) : t0_space (comm_ring reducibility_hints) := sorry --non-trivial
lemma new_lemma_26260 (h0 : function.extfun Type topological_space) : @totally_separated_space.{0} (with_one.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (with_one.{0} empty))  := sorry --non-trivial
lemma new_lemma_26261 (h0 : filter (add_left_cancel_monoid (has_nnnorm (random_gen (has_nnnorm (has_nnnorm linarith.ineq)))))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_26262 (h0 : complete_lattice (measurable_space linarith.comp)) : is_compactly_generated (measurable_space linarith.comp) := sorry --non-trivial
lemma new_lemma_26263 (h0 : topological_space subsingleton_info) : loc_path_connected_space subsingleton_info := sorry --non-trivial
lemma new_lemma_26264 (h0 : not (function.extfun (Type 1 -> Type 1) (function.extfun (Type 1)) -> false)) : @preirreducible_space.{1} (plift.{1} empty) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) (@classical.by_contradiction'.{3} (function.extfun.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1))) h0) topological_space.{1}) (plift.{1} empty))  := sorry --non-trivial
lemma new_lemma_26265 (h0 : not (group (distrib_lattice fun_info) -> false)) : @is_cyclic.{0} (distrib_lattice.{0} fun_info) (@classical.by_contradiction'.{1} (group.{0} (distrib_lattice.{0} fun_info)) h0)  := sorry --non-trivial
lemma new_lemma_26266 (h0 : complete_distrib_lattice (has_neg ennreal) -> complete_distrib_lattice (has_neg ennreal) -> Prop) : reflexive h0 := sorry --non-trivial
lemma new_lemma_26267 (h0 : not (add_group (div_inv_monoid linarith.ineq) -> false)) : @is_add_cyclic.{0} (div_inv_monoid.{0} linarith.ineq) (@classical.by_contradiction'.{1} (add_group.{0} (div_inv_monoid.{0} linarith.ineq)) h0)  := sorry --non-trivial
lemma new_lemma_26268 (h0 : functor.add_const (add_monoid (has_neg_part environment.implicit_infer_kind)) environment.implicit_infer_kind) : @add_monoid.fg.{0} (has_neg_part.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (add_monoid.{0} (has_neg_part.{0} environment.implicit_infer_kind)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_26269 (h0 : functor.add_const (ring (has_to_string name)) num) : @strong_rank_condition.{0} (has_to_string.{0} name) (@functor.add_const.run.{0 0} (ring.{0} (has_to_string.{0} name)) num h0)  := sorry --non-trivial
lemma new_lemma_26270 (h0 : functor.add_const (group (comm_group pos)) (has_add pos)) : @is_cyclic.{0} (comm_group.{0} pos) (@functor.add_const.run.{0 0} (group.{0} (comm_group.{0} pos)) (has_add.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_26271 (h0 : function.extfun (finset (Type -> Type)) (has_mem.mem topological_space)) : @irreducible_space.{0} string_imp (@function.extfun_app.{2 1} Type topological_space.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) topological_space.{0} (@function.extfun_app.{2 0} (finset.{1} (Type → Type)) (@has_mem.mem.{1 1} (Type → Type) (finset.{1} (Type → Type)) (@finset.has_mem.{1} (Type → Type)) topological_space.{0}) h0 (@has_emptyc.emptyc.{1} (finset.{1} (Type → Type)) (@finset.has_emptyc.{1} (Type → Type))))) string_imp)  := sorry --non-trivial
lemma new_lemma_26272 (h0 : function.extfun Type group) : @is_simple_group.{0} (group_with_zero.{0} ennreal) (@function.extfun_app.{2 1} Type group.{0} h0 (group_with_zero.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_26273 (h0 : functor.add_const (ring (ring pos)) name) : @is_domain.{0} (ring.{0} pos) (@functor.add_const.run.{0 0} (ring.{0} (ring.{0} pos)) name h0)  := sorry --non-trivial
lemma new_lemma_26274 (h0 : filter (comm_ring (has_norm (random_gen string_imp)))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_26275 (h0 : topological_space (has_emptyc (has_top (has_top fun_info)))) : totally_separated_space (has_emptyc (has_top (has_top fun_info))) := sorry --non-trivial
lemma new_lemma_26276 (h0 : functor.add_const (topological_space (has_bot empty)) empty) : @totally_separated_space.{0} (has_bot.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (has_bot.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_26277 (h0 : topological_space (pseudo_metric_space ennreal)) : t1_space (pseudo_metric_space ennreal) := sorry --non-trivial
lemma new_lemma_26278 (h0 : ring (normed_field (normed_field (mul_one_class string.iterator_imp)))) : is_domain (normed_field (normed_field (mul_one_class string.iterator_imp))) := sorry --non-trivial
lemma new_lemma_26279 (h0 : ring (comm_group unsigned)) : is_domain (comm_group unsigned) := sorry --non-trivial
lemma new_lemma_26280 (h0 : add_monoid (ring congr_arg_kind)) : add_monoid.fg (ring congr_arg_kind) := sorry --non-trivial
lemma new_lemma_26281 (h0 : complete_lattice (boolean_algebra unsigned)) : complete_lattice.is_Sup_finite_compact (boolean_algebra unsigned) := sorry --non-trivial
lemma new_lemma_26282 (h0 : topological_space (metric_space num)) : totally_separated_space (metric_space num) := sorry --non-trivial
lemma new_lemma_26283 (h0 : add_group (normed_group (has_norm (has_norm fun_info)))) : is_add_cyclic (normed_group (has_norm (has_norm fun_info))) := sorry --non-trivial
lemma new_lemma_26284 (h0 : ordered_comm_monoid ereal) : has_exists_mul_of_le ereal := sorry --non-trivial
lemma new_lemma_26285 (h0 : functor.add_const (topological_space (has_add linarith.comp)) linarith.comp) : @sequential_space.{0} (has_add.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (has_add.{0} linarith.comp)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_26286 (h1 : add_group (add_comm_semigroup (ordered_add_comm_monoid linarith.ineq))) : is_add_cyclic (add_comm_semigroup (ordered_add_comm_monoid linarith.ineq)) := sorry --non-trivial
lemma new_lemma_26287 (h0 : topological_space (preorder (semiring unsigned))) : t1_space (preorder (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_26288 (h0 : topological_space (sub_neg_monoid (has_Inf (has_Inf (has_add (has_Inf (has_Inf pos))))))) : totally_disconnected_space (sub_neg_monoid (has_Inf (has_Inf (has_add (has_Inf (has_Inf pos)))))) := sorry --non-trivial
lemma new_lemma_26289 (h0 : functor.add_const (ordered_comm_monoid (boolean_algebra.core unsigned)) (comm_group name)) : @has_exists_mul_of_le.{0} (boolean_algebra.core.{0} unsigned) (@functor.add_const.run.{0 0} (ordered_comm_monoid.{0} (boolean_algebra.core.{0} unsigned)) (comm_group.{0} name) h0)  := sorry --non-trivial
lemma new_lemma_26290 (h0 : topological_space (has_le (mul_one_class (mul_one_class (mul_one_class fun_info))))) : path_connected_space (has_le (mul_one_class (mul_one_class (mul_one_class fun_info)))) := sorry --non-trivial
lemma new_lemma_26291 (h0 : functor.add_const (functor.add_const (function.extfun Type ring) pos) environment.implicit_infer_kind) : @rank_condition.{0} (has_to_string.{0} pos) (@function.extfun_app.{2 1} Type ring.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type ring.{0}) pos (@functor.add_const.run.{1 0} (functor.add_const.{1 0} (function.extfun.{2 1} Type ring.{0}) pos) environment.implicit_infer_kind h0)) (has_to_string.{0} pos))  := sorry --non-trivial
lemma new_lemma_26292 (h0 : functor.add_const (function.extfun (Type 1) group) Type) : @group.fg.{1} (semigroup.{1} Type) (@function.extfun_app.{3 2} (Type 1) group.{1} (@functor.add_const.run.{2 1} (function.extfun.{3 2} (Type 1) group.{1}) Type h0) (semigroup.{1} Type))  := sorry --non-trivial
lemma new_lemma_26293 (h0 : topological_space linarith.comp_source) : discrete_topology linarith.comp_source := sorry --non-trivial
lemma new_lemma_26294 (h3 h4 : multiset (mul_one_class linarith.ineq)) : multiset.subset h3 h4 := sorry --non-trivial
lemma new_lemma_26295 (h0 : complete_lattice (has_inv fun_info)) : is_compactly_generated (has_inv fun_info) := sorry --non-trivial
lemma new_lemma_26296 (h0 : functor.add_const (list (boolean_algebra.core environment.implicit_infer_kind)) linarith.comp) : list.nodup (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_26297 (h0 : topological_space (ordered_comm_ring (has_Inf (finset Type)))) : preirreducible_space (ordered_comm_ring (has_Inf (finset Type))) := sorry --non-trivial
lemma new_lemma_26298 (h0 : topological_space (ordered_comm_ring (has_add Type))) : preirreducible_space (ordered_comm_ring (has_add Type)) := sorry --non-trivial
lemma new_lemma_26299 (h0 : topological_space (has_top (has_norm (has_norm linarith.comp)))) : totally_disconnected_space (has_top (has_norm (has_norm linarith.comp))) := sorry --non-trivial
lemma new_lemma_26300 (h0 : topological_space (has_neg (option congr_arg_kind))) : t1_space (has_neg (option congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_26301 (h0 : ring (canonically_ordered_monoid (has_Inf (has_add Type)))) : rank_condition (canonically_ordered_monoid (has_Inf (has_add Type))) := sorry --non-trivial
lemma new_lemma_26302 (h0 : functor.add_const (topological_space (add_cancel_monoid Type)) Type) : @t1_space.{1} (add_cancel_monoid.{1} Type) (@functor.add_const.run.{1 1} (topological_space.{1} (add_cancel_monoid.{1} Type)) Type h0)  := sorry --non-trivial
lemma new_lemma_26303 (h0 : function.extfun Type ring) : @rank_condition.{0} (normed_group.{0} empty) (@function.extfun_app.{2 1} Type ring.{0} h0 (normed_group.{0} empty))  := sorry --non-trivial
lemma new_lemma_26304 (h0 : add_monoid (finset environment.implicit_infer_kind)) : add_monoid.fg (finset environment.implicit_infer_kind) := sorry --non-trivial
lemma new_lemma_26305 (h0 : has_mem.mem ring has_emptyc.emptyc) : @rank_condition.{0} to_additive.value_type (@function.extfun_app.{2 1} Type ring.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) ring.{0} h0) to_additive.value_type)  := sorry --non-trivial
lemma new_lemma_26306 (h0 : topological_space (uniform_space char)) : totally_disconnected_space (uniform_space char) := sorry --non-trivial
lemma new_lemma_26307 (h0 : add_group (canonically_ordered_comm_semiring (mul_zero_class (comm_group unsigned)))) : is_add_cyclic (canonically_ordered_comm_semiring (mul_zero_class (comm_group unsigned))) := sorry --non-trivial
lemma new_lemma_26308 (h1 : add_group (has_union empty)) : is_add_cyclic (has_union empty) := sorry --non-trivial
lemma new_lemma_26309 (h0 : ring (left_cancel_monoid unsigned)) : strong_rank_condition (left_cancel_monoid unsigned) := sorry --non-trivial
lemma new_lemma_26310 (h0 : function.extfun Type topological_space) : @totally_disconnected_space.{0} (as_linear_order.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (as_linear_order.{0} num))  := sorry --non-trivial
lemma new_lemma_26311 (h0 : functor.add_const (complete_lattice (ordered_ring congr_arg_kind)) (semiring (semiring (semiring congr_arg_kind)))) : @is_compactly_generated.{0} (ordered_ring.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (complete_lattice.{0} (ordered_ring.{0} congr_arg_kind)) (semiring.{0} (semiring.{0} (semiring.{0} congr_arg_kind))) h0)  := sorry --non-trivial
lemma new_lemma_26312 (h0 : prod (ordered_ring (option unsigned)) (ordered_ring (option unsigned))) : id_rel h0 := sorry --non-trivial
lemma new_lemma_26313 (h0 : filter (has_top linarith.comp)) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_26314 (h0 : topological_space (generalized_boolean_algebra (has_pos_part (ordered_comm_monoid real)))) : t1_space (generalized_boolean_algebra (has_pos_part (ordered_comm_monoid real))) := sorry --non-trivial
lemma new_lemma_26315 (h0 : add_group (has_neg (has_to_string (has_to_string (comm_group Type))))) : is_add_cyclic (has_neg (has_to_string (has_to_string (comm_group Type)))) := sorry --non-trivial
lemma new_lemma_26316 (h0 : functor.add_const (topological_space (non_assoc_semiring unsigned)) empty) : @loc_path_connected_space.{0} (non_assoc_semiring.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (non_assoc_semiring.{0} unsigned)) empty h0)  := sorry --non-trivial
lemma new_lemma_26317 (h0 : topological_space (simple_graph (mul_one_class string.iterator_imp))) : t0_space (simple_graph (mul_one_class string.iterator_imp)) := sorry --non-trivial
lemma new_lemma_26318 (h0 : functor.add_const (function.extfun Type topological_space) environment.implicit_infer_kind) : @t0_space.{0} (has_add.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) environment.implicit_infer_kind h0) (has_add.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_26319 (h0 : functor.add_const (topological_space (complete_distrib_lattice pos)) pos) : @t1_space.{0} (complete_distrib_lattice.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (complete_distrib_lattice.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_26320 (h0 : function.extfun Type topological_space) : @path_connected_space.{0} (has_emptyc.{0} string_imp) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_emptyc.{0} string_imp))  := sorry --non-trivial
lemma new_lemma_26321 (h0 : complete_lattice (has_zero (option pos))) : complete_lattice.is_Sup_finite_compact (has_zero (option pos)) := sorry --non-trivial
lemma new_lemma_26322 (h0 : topological_space (has_bot pos)) : totally_separated_space (has_bot pos) := sorry --non-trivial
lemma new_lemma_26323 (h0 : list (finset (option num))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_26324 (h0 : functor.add_const (topological_space (has_dist empty)) ennreal) : @locally_compact_space.{0} (has_dist.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (has_dist.{0} empty)) ennreal h0)  := sorry --non-trivial
lemma new_lemma_26325 (h0 : functor.add_const (topological_space (mul_zero_class empty)) congr_arg_kind) : @normal_space.{0} (mul_zero_class.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (mul_zero_class.{0} empty)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_26326 (h0 : functor.add_const (group (normed_comm_ring linarith.comp)) (has_to_string pos)) : @is_simple_group.{0} (normed_comm_ring.{0} linarith.comp) (@functor.add_const.run.{0 0} (group.{0} (normed_comm_ring.{0} linarith.comp)) (has_to_string.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_26327 (h0 : uniform_space (canonically_ordered_comm_semiring (has_nndist (ring (ring pos))))) : separated_space (canonically_ordered_comm_semiring (has_nndist (ring (ring pos)))) := sorry --non-trivial
lemma new_lemma_26328 (h0 : add_group (has_Inf (has_add Type))) : is_add_cyclic (has_Inf (has_add Type)) := sorry --non-trivial
lemma new_lemma_26329 (h0 : add_group (ordered_cancel_add_comm_monoid (option empty))) : is_add_cyclic (ordered_cancel_add_comm_monoid (option empty)) := sorry --non-trivial
lemma new_lemma_26330 (h0 : function.extfun Type filter) : filter.ne_bot (function.extfun_app h0 (canonically_linear_ordered_monoid ennreal)) := sorry --non-trivial
lemma new_lemma_26331 (h0 : functor.comp topological_space complete_distrib_lattice Type) : @irreducible_space.{1} (complete_distrib_lattice.{1} Type) (@functor.comp.run.{1 1 1} topological_space.{1} complete_distrib_lattice.{1} Type h0)  := sorry --non-trivial
lemma new_lemma_26332 (h0 : not (topological_space (distrib fun_info) -> false)) : @t0_space.{0} (distrib.{0} fun_info) (@classical.by_contradiction'.{1} (topological_space.{0} (distrib.{0} fun_info)) h0)  := sorry --non-trivial
lemma new_lemma_26333 (h0 : semiring (normed_lattice_add_comm_group Type)) (h1 : ring (sub_neg_monoid (polynomial (normed_lattice_add_comm_group Type)))) : is_domain (sub_neg_monoid (polynomial (normed_lattice_add_comm_group Type))) := sorry --non-trivial
lemma new_lemma_26334 (h0 : topological_space (with_bot linarith.ineq)) : locally_compact_space (with_bot linarith.ineq) := sorry --non-trivial
lemma new_lemma_26335 (h0 : functor.add_const (topological_space (pseudo_metric_space pos)) unsigned) : @topological_space.separable_space.{0} (pseudo_metric_space.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (pseudo_metric_space.{0} pos)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_26336 (h0 : topological_space (has_nndist (boolean_algebra Type))) : normal_space (has_nndist (boolean_algebra Type)) := sorry --non-trivial
lemma new_lemma_26337 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_cyclic.{0} (distrib_lattice.{0} fun_info) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (distrib_lattice.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_26338 (h0 : list (add_semigroup (option empty))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_26339 (h0 : function.extfun Type ring) : @rank_condition.{0} (linear_ordered_field.{0} ennreal) (@function.extfun_app.{2 1} Type ring.{0} h0 (linear_ordered_field.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_26340 (h0 : function.extfun Type semiring) : @is_noetherian_ring.{0} (option.{0} ennreal) (@function.extfun_app.{2 1} Type semiring.{0} h0 (option.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_26341 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : countable_Inter_filter (function.extfun_app (function.extfun_app h0 filter) (has_inter empty)) := sorry --non-trivial
lemma new_lemma_26342 (h0 : functor.add_const (topological_space (cancel_monoid environment.implicit_infer_kind)) name) : @t0_space.{0} (cancel_monoid.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (cancel_monoid.{0} environment.implicit_infer_kind)) name h0)  := sorry --non-trivial
lemma new_lemma_26343 (h0 : functor.add_const (ring (add_comm_monoid linarith.comp)) linarith.comp) : @is_domain.{0} (add_comm_monoid.{0} linarith.comp) (@functor.add_const.run.{0 0} (ring.{0} (add_comm_monoid.{0} linarith.comp)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_26344 (h0 : function.extfun Type finset) : finset.nonempty (function.extfun_app h0 (has_neg_part unsigned)) := sorry --non-trivial
lemma new_lemma_26345 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_principal_ideal_ring.{0} (complete_distrib_lattice.{0} empty) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (complete_distrib_lattice.{0} empty))  := sorry --non-trivial
lemma new_lemma_26346 (h1 : ring (has_ssubset environment.projection_info)) : rank_condition (has_ssubset environment.projection_info) := sorry --non-trivial
lemma new_lemma_26347 (h0 : ordered_comm_monoid (cancel_monoid (boolean_algebra.core environment.implicit_infer_kind))) : has_exists_mul_of_le (cancel_monoid (boolean_algebra.core environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_26348 (h0 : not (has_mem.mem (semiring linarith.ineq) has_emptyc.emptyc -> false)) : @is_domain.{0} (semiring.{0} linarith.ineq) (@finset.pi.empty.{1 0} Type ring.{0} (semiring.{0} linarith.ineq) (@classical.by_contradiction'.{0} (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (semiring.{0} linarith.ineq) (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))) h0))  := sorry --non-trivial
lemma new_lemma_26349 (h0 : ring (has_inv (boolean_algebra.core fun_info))) : is_domain (has_inv (boolean_algebra.core fun_info)) := sorry --non-trivial
lemma new_lemma_26350 (h0 : functor.add_const (ring (has_neg unsigned)) linarith.comp) : @is_domain.{0} (has_neg.{0} unsigned) (@functor.add_const.run.{0 0} (ring.{0} (has_neg.{0} unsigned)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_26351 (h0 : ring (add_left_cancel_monoid fun_info)) : rank_condition (add_left_cancel_monoid fun_info) := sorry --non-trivial
lemma new_lemma_26352 (h0 : functor.add_const (ordered_add_comm_monoid (pseudo_metric_space num)) unsigned) : @archimedean.{0} (pseudo_metric_space.{0} num) (@functor.add_const.run.{0 0} (ordered_add_comm_monoid.{0} (pseudo_metric_space.{0} num)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_26353 (h0 : ring (add_group (semiring empty))) : rank_condition (add_group (semiring empty)) := sorry --non-trivial
lemma new_lemma_26354 (h0 : filter (monoid_with_zero ennreal)) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_26355 (h0 : uniform_space (group_with_zero num)) : complete_space (group_with_zero num) := sorry --non-trivial
lemma new_lemma_26356 (h0 : ring (comm_ring string.iterator_imp)) : strong_rank_condition (comm_ring string.iterator_imp) := sorry --non-trivial
lemma new_lemma_26357 (h0 : group (has_neg unsigned)) : is_simple_group (has_neg unsigned) := sorry --non-trivial
lemma new_lemma_26358 (h0 : group (has_nnnorm (comm_ring to_additive.value_type))) : is_cyclic (has_nnnorm (comm_ring to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_26359 (h0 : functor.comp topological_space add_comm_monoid pos) : @loc_path_connected_space.{0} (add_comm_monoid.{0} pos) (@functor.comp.run.{0 0 0} topological_space.{0} add_comm_monoid.{0} pos h0)  := sorry --non-trivial
lemma new_lemma_26360 (h0 : add_group (with_one (random_gen linarith.ineq))) : is_add_cyclic (with_one (random_gen linarith.ineq)) := sorry --non-trivial
lemma new_lemma_26361 (h0 : not (topological_space (div_inv_monoid linarith.comp_source) -> false)) : @path_connected_space.{0} (div_inv_monoid.{0} linarith.comp_source) (@classical.by_contradiction'.{1} (topological_space.{0} (div_inv_monoid.{0} linarith.comp_source)) h0)  := sorry --non-trivial
lemma new_lemma_26362 (h0 : function.extfun nat fin) : @preirreducible_space.{1} (has_bot.{1} Type) (@matrix.vec_empty.{1} (topological_space.{1} (has_bot.{1} Type)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_26363 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @archimedean.{0} (generalized_boolean_algebra.{0} linarith.comp) (@function.extfun_app.{2 1} Type ordered_add_comm_monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ordered_add_comm_monoid.{0}) (generalized_boolean_algebra.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_26364 (h0 : function.extfun Type topological_space) : @discrete_topology.{0} (ordered_comm_group.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (ordered_comm_group.{0} empty))  := sorry --non-trivial
lemma new_lemma_26365 (h0 : not (semiring (has_norm congr_arg_kind) -> false)) : @is_noetherian_ring.{0} (has_norm.{0} congr_arg_kind) (@classical.by_contradiction'.{1} (semiring.{0} (has_norm.{0} congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_26366 (h0 : uniform_space (finset (option name))) : separated_space (finset (option name)) := sorry --non-trivial
lemma new_lemma_26367 (h0 : functor.add_const (function.extfun (Type 1) topological_space) environment.implicit_infer_kind) : @regular_space.{1} Type (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) topological_space.{1}) environment.implicit_infer_kind h0) Type)  := sorry --non-trivial
lemma new_lemma_26368 (h0 : ring (partial_order num)) : is_principal_ideal_ring (partial_order num) := sorry --non-trivial
lemma new_lemma_26369 (h0 : function.extfun Type (functor.comp filter normed_comm_ring)) : countable_Inter_filter (functor.comp.run (function.extfun_app h0 name)) := sorry --non-trivial
lemma new_lemma_26370 (h0 : group (complete_semilattice_Sup linarith.comp_source)) : normalizer_condition (complete_semilattice_Sup linarith.comp_source) := sorry --non-trivial
lemma new_lemma_26371 (h0 : function.extfun (Type 1) monoid) : @monoid.fg.{1} (sub_neg_monoid.{1} Type) (@function.extfun_app.{3 2} (Type 1) monoid.{1} h0 (sub_neg_monoid.{1} Type))  := sorry --non-trivial
lemma new_lemma_26372 (h0 : uniform_space (measurable_space congr_arg_kind)) : complete_space (measurable_space congr_arg_kind) := sorry --non-trivial
lemma new_lemma_26373 (h0 : filter (complete_linear_order (semiring (semiring empty)))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_26374 (h0 : ordered_add_comm_monoid (has_neg (boolean_algebra.core ennreal))) : archimedean (has_neg (boolean_algebra.core ennreal)) := sorry --non-trivial
lemma new_lemma_26375 (h0 : ring (has_nnnorm string_imp)) : rank_condition (has_nnnorm string_imp) := sorry --non-trivial
lemma new_lemma_26376 (h0 : finset (has_neg Type)) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_26377 (h0 : finset (generalized_boolean_algebra (has_nndist name))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_26378 (h0 : ring (with_bot linarith.ineq)) : strong_rank_condition (with_bot linarith.ineq) := sorry --non-trivial
lemma new_lemma_26379 (h0 : function.extfun Type cancel_comm_monoid_with_zero) : @unique_factorization_monoid.{0} (has_bot.{0} linarith.comp) (@function.extfun_app.{2 1} Type cancel_comm_monoid_with_zero.{0} h0 (has_bot.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_26380 (h0 : functor.add_const (group (boolean_algebra linarith.comp)) environment.implicit_infer_kind) : @is_simple_group.{0} (boolean_algebra.{0} linarith.comp) (@functor.add_const.run.{0 0} (group.{0} (boolean_algebra.{0} linarith.comp)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_26381 (h0 : finset (group_with_zero (option congr_arg_kind))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_26382 (h0 : function.extfun Type topological_space) : @totally_disconnected_space.{0} (add_cancel_monoid.{0} (option.{0} ennreal)) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (add_cancel_monoid.{0} (option.{0} ennreal)))  := sorry --non-trivial
lemma new_lemma_26383 (h0 : functor.add_const (topological_space (canonically_ordered_comm_semiring Type)) Type) : @totally_disconnected_space.{1} (canonically_ordered_comm_semiring.{1} Type) (@functor.add_const.run.{1 1} (topological_space.{1} (canonically_ordered_comm_semiring.{1} Type)) Type h0)  := sorry --non-trivial
lemma new_lemma_26384 (h0 : functor.add_const (add_monoid (finset pos)) pos) : @add_monoid.fg.{0} (finset.{0} pos) (@functor.add_const.run.{0 0} (add_monoid.{0} (finset.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_26385 (h0 : function.extfun Type topological_space) : @irreducible_space.{0} (has_dist.{0} ennreal) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_dist.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_26386 (h0 : functor.add_const (complete_lattice (complete_distrib_lattice Type)) linarith.comp) : @is_atomistic.{1} (complete_distrib_lattice.{1} Type) (@functor.add_const.run.{1 0} (complete_lattice.{1} (complete_distrib_lattice.{1} Type)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_26387 (h0 : topological_space (linear_ordered_comm_ring (has_bot num))) : topological_space.separable_space (linear_ordered_comm_ring (has_bot num)) := sorry --non-trivial
lemma new_lemma_26388 (h0 : list (semigroup (semigroup (cancel_monoid environment.implicit_infer_kind)))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_26389 (h0 : ring (add_comm_semigroup (add_comm_semigroup enat))) : strong_rank_condition (add_comm_semigroup (add_comm_semigroup enat)) := sorry --non-trivial
lemma new_lemma_26390 (h0 : topological_space (normed_group congr_arg_kind)) : preirreducible_space (normed_group congr_arg_kind) := sorry --non-trivial
lemma new_lemma_26391 (h0 : filter (has_norm (has_top (random_gen (random_gen fun_info))))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_26392 (h0 : not (uniform_space (has_top unsigned) -> false)) : @complete_space.{0} (has_top.{0} unsigned) (@classical.by_contradiction'.{1} (uniform_space.{0} (has_top.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_26393 (h0 : group (normed_group (random_gen to_additive.value_type))) : group.fg (normed_group (random_gen to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_26394 (h0 : functor.add_const (functor.add_const Prop Type) name) : functor.add_const.run (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_26395 (h0 : ring (with_bot (has_top (has_top (has_top linarith.ineq))))) : is_domain (with_bot (has_top (has_top (has_top linarith.ineq)))) := sorry --non-trivial
lemma new_lemma_26396 (h0 : functor.comp (functor.add_const (topological_space (has_neg_part unsigned))) option pos) : @normal_space.{0} (has_neg_part.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (has_neg_part.{0} unsigned)) (option.{0} pos) (@functor.comp.run.{0 0 0} (functor.add_const.{0 0} (topological_space.{0} (has_neg_part.{0} unsigned))) option.{0} pos h0))  := sorry --non-trivial
lemma new_lemma_26397 (h0 : functor.add_const (list nnreal) empty) : palindrome (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_26398 (h1 : topological_space (has_ssubset environment.projection_info)) : path_connected_space (has_ssubset environment.projection_info) := sorry --non-trivial
lemma new_lemma_26399 (h0 : functor.add_const (topological_space (normed_comm_ring congr_arg_kind)) empty) : @topological_space.separable_space.{0} (normed_comm_ring.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (normed_comm_ring.{0} congr_arg_kind)) empty h0)  := sorry --non-trivial
lemma new_lemma_26400 (h0 : functor.add_const (ordered_add_comm_monoid (ring environment.implicit_infer_kind)) Type) : @archimedean.{0} (ring.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 1} (ordered_add_comm_monoid.{0} (ring.{0} environment.implicit_infer_kind)) Type h0)  := sorry --non-trivial
lemma new_lemma_26401 (h0 : function.extfun Type topological_space) : @locally_compact_space.{0} (topological_space.{0} char) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (topological_space.{0} char))  := sorry --non-trivial
lemma new_lemma_26402 (h0 : complete_lattice (has_pos_part (canonically_ordered_monoid pos))) : complete_lattice.is_Sup_finite_compact (has_pos_part (canonically_ordered_monoid pos)) := sorry --non-trivial
lemma new_lemma_26403 (h0 : ring (normed_field (has_ssubset char))) : rank_condition (normed_field (has_ssubset char)) := sorry --non-trivial
lemma new_lemma_26404 (h0 : function.extfun Type uniform_space) : @complete_space.{0} (has_to_string.{0} linarith.comp) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (has_to_string.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_26405 (h0 : ring (normed_lattice_add_comm_group real)) : strong_rank_condition (normed_lattice_add_comm_group real) := sorry --non-trivial
lemma new_lemma_26406 (h0 : functor.add_const (function.extfun Type cancel_comm_monoid_with_zero) name) : @unique_factorization_monoid.{0} (semigroup.{0} linarith.comp) (@function.extfun_app.{2 1} Type cancel_comm_monoid_with_zero.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type cancel_comm_monoid_with_zero.{0}) name h0) (semigroup.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_26407 (h0 : functor.add_const (uniform_space (normed_comm_ring environment.implicit_infer_kind)) pos) : @separated_space.{0} (normed_comm_ring.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (uniform_space.{0} (normed_comm_ring.{0} environment.implicit_infer_kind)) pos h0)  := sorry --non-trivial
lemma new_lemma_26408 (h0 : ring (has_Inf (ring linarith.comp))) : is_principal_ideal_ring (has_Inf (ring linarith.comp)) := sorry --non-trivial
lemma new_lemma_26409 (h1 : not (function.extfun Type monoid -> false)) : @monoid.fg.{0} (random_gen.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type monoid.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type monoid.{0}) h1) (random_gen.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_26410 (h0 : topological_space (add_cancel_monoid (ring pos))) : locally_compact_space (add_cancel_monoid (ring pos)) := sorry --non-trivial
lemma new_lemma_26411 (h0 : topological_space (ring (option (option (option empty))))) : totally_disconnected_space (ring (option (option (option empty)))) := sorry --non-trivial
lemma new_lemma_26412 (h0 : functor.add_const (topological_space (ordered_comm_monoid pos)) linarith.comp) : @regular_space.{0} (ordered_comm_monoid.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (ordered_comm_monoid.{0} pos)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_26413 (h0 : has_mem.mem (has_union linarith.comp) has_zero.zero) : @group.fg.{0} (has_union.{0} linarith.comp) (@multiset.pi.empty.{1 0} Type group.{0} (has_union.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_26414 (h0 : has_mem.mem (emetric_space linarith.comp_source) has_emptyc.emptyc) : @totally_disconnected_space.{0} (emetric_space.{0} linarith.comp_source) (@finset.pi.empty.{1 0} Type topological_space.{0} (emetric_space.{0} linarith.comp_source) h0)  := sorry --non-trivial
lemma new_lemma_26415 (h0 : functor.add_const (ring (finset linarith.comp)) pos) : @is_domain.{0} (finset.{0} linarith.comp) (@functor.add_const.run.{0 0} (ring.{0} (finset.{0} linarith.comp)) pos h0)  := sorry --non-trivial
lemma new_lemma_26416 (h0 : ring (canonically_ordered_monoid (has_bot Type))) : is_domain (canonically_ordered_monoid (has_bot Type)) := sorry --non-trivial
lemma new_lemma_26417 (h0 : function.extfun Type topological_space) : @regular_space.{0} (generalized_boolean_algebra.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (generalized_boolean_algebra.{0} pos))  := sorry --non-trivial
lemma new_lemma_26418 (h0 : group (random_gen (random_gen fun_info))) : is_cyclic (random_gen (random_gen fun_info)) := sorry --non-trivial
lemma new_lemma_26419 (h0 : topological_space (has_add (sub_neg_monoid (sub_neg_monoid Type)))) : loc_path_connected_space (has_add (sub_neg_monoid (sub_neg_monoid Type))) := sorry --non-trivial
lemma new_lemma_26420 (h0 : function.extfun Type topological_space) : @locally_compact_space.{0} (finset.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (finset.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_26421 (h0 : functor.add_const (topological_space (has_to_string linarith.comp)) Type) : @totally_disconnected_space.{0} (has_to_string.{0} linarith.comp) (@functor.add_const.run.{0 1} (topological_space.{0} (has_to_string.{0} linarith.comp)) Type h0)  := sorry --non-trivial
lemma new_lemma_26422 (h2 : set (add_comm_semigroup linarith.ineq -> std_gen)) : set.separates_points h2 := sorry --non-trivial
lemma new_lemma_26423 (h0 : functor.add_const (topological_space (normed_linear_ordered_group empty)) empty) : @totally_disconnected_space.{0} (normed_linear_ordered_group.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (normed_linear_ordered_group.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_26424 (h0 : not (has_mem.mem (random_gen linarith.ineq) has_emptyc.emptyc -> false)) : @is_compactly_generated.{0} (random_gen.{0} linarith.ineq) (@finset.pi.empty.{1 0} Type complete_lattice.{0} (random_gen.{0} linarith.ineq) (@classical.by_contradiction'.{0} (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (random_gen.{0} linarith.ineq) (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))) h0))  := sorry --non-trivial
lemma new_lemma_26425 (h0 : add_monoid (normed_comm_ring num)) : add_monoid.fg (normed_comm_ring num) := sorry --non-trivial
lemma new_lemma_26426 (h0 : function.extfun Type topological_space) : @path_connected_space.{0} (normed_group.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (normed_group.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_26427 (h0 : topological_space (complete_distrib_lattice (semiring empty))) : t0_space (complete_distrib_lattice (semiring empty)) := sorry --non-trivial
lemma new_lemma_26428 (h0 : ordered_add_comm_monoid (finset (has_Inf (has_pos_part (has_Inf (has_add pos)))))) : archimedean (finset (has_Inf (has_pos_part (has_Inf (has_add pos))))) := sorry --non-trivial
lemma new_lemma_26429 (h0 : topological_space (has_ssubset enat)) (h1 : add_group (has_ssubset enat)) : topological_add_group (has_ssubset enat) := sorry --non-trivial
lemma new_lemma_26430 (h0 : has_mem.mem (linear_ordered_comm_group linarith.comp) has_emptyc.emptyc) : @totally_disconnected_space.{0} (linear_ordered_comm_group.{0} linarith.comp) (@finset.pi.empty.{1 0} Type topological_space.{0} (linear_ordered_comm_group.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_26431 (h0 : fin has_zero.zero) : @locally_compact_space.{0} (canonically_ordered_monoid.{0} pos) (@matrix.vec_empty.{0} (topological_space.{0} (canonically_ordered_monoid.{0} pos)) h0)  := sorry --non-trivial
lemma new_lemma_26432 (h1 : topological_space (nondiscrete_normed_field linarith.ineq)) (h2 : add_group (nondiscrete_normed_field linarith.ineq)) : topological_add_group (nondiscrete_normed_field linarith.ineq) := sorry --non-trivial
lemma new_lemma_26433 (h1 : ring (has_nnnorm to_additive.value_type)) : is_domain (has_nnnorm to_additive.value_type) := sorry --non-trivial
lemma new_lemma_26434 (h0 : complete_lattice (has_emptyc (random_gen num))) : complete_lattice.is_Sup_finite_compact (has_emptyc (random_gen num)) := sorry --non-trivial
lemma new_lemma_26435 (h0 : ring (has_Inf name)) : is_domain (has_Inf name) := sorry --non-trivial
lemma new_lemma_26436 (h1 : function.extfun (Type -> Type) (function.extfun Type)) : @is_add_cyclic.{0} (measurable_space.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type add_group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h1 add_group.{0}) (measurable_space.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_26437 (h0 : functor.comp add_group has_zero name) : @is_add_cyclic.{0} (has_zero.{0} name) (@functor.comp.run.{0 0 0} add_group.{0} has_zero.{0} name h0)  := sorry --non-trivial
lemma new_lemma_26438 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @separated_space.{0} (has_nndist.{0} linarith.comp) (@function.extfun_app.{2 1} Type uniform_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 uniform_space.{0}) (has_nndist.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_26439 (h0 : function.extfun (finset Type) (has_mem.mem (measurable_space linarith.comp_source))) : @strong_rank_condition.{0} (measurable_space.{0} linarith.comp_source) (@finset.pi.empty.{1 0} Type ring.{0} (measurable_space.{0} linarith.comp_source) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (measurable_space.{0} linarith.comp_source)) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_26440 (h0 : not (has_mem.mem (complete_semilattice_Sup num) has_emptyc.emptyc -> false)) : @is_atomistic.{0} (complete_semilattice_Sup.{0} num) (@finset.pi.empty.{1 0} Type complete_lattice.{0} (complete_semilattice_Sup.{0} num) (@classical.by_contradiction'.{0} (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (complete_semilattice_Sup.{0} num) (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))) h0))  := sorry --non-trivial
lemma new_lemma_26441 (h0 : ring (has_nndist (has_add linarith.comp))) : is_domain (has_nndist (has_add linarith.comp)) := sorry --non-trivial
lemma new_lemma_26442 (h0 : ring (boolean_algebra (finset (finset pos)))) : rank_condition (boolean_algebra (finset (finset pos))) := sorry --non-trivial
lemma new_lemma_26443 (h0 : not (topological_space (has_emptyc linarith.ineq) -> false)) : @totally_separated_space.{0} (has_emptyc.{0} linarith.ineq) (@classical.by_contradiction'.{1} (topological_space.{0} (has_emptyc.{0} linarith.ineq)) h0)  := sorry --non-trivial
lemma new_lemma_26444 (h0 : ring (has_lt (mul_one_class to_additive.value_type))) : is_domain (has_lt (mul_one_class to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_26445 (h0 : topological_space (add_cancel_monoid environment.implicit_infer_kind)) : path_connected_space (add_cancel_monoid environment.implicit_infer_kind) := sorry --non-trivial
lemma new_lemma_26446 (h0 : function.extfun Type topological_space) : @irreducible_space.{0} (complete_semilattice_Sup.{0} linarith.ineq) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (complete_semilattice_Sup.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_26447 (h0 : topological_space (semiring (has_top linarith.comp_source))) : totally_disconnected_space (semiring (has_top linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_26448 (h0 : complete_lattice (comm_ring (random_gen linarith.ineq))) : is_compactly_generated (comm_ring (random_gen linarith.ineq)) := sorry --non-trivial
lemma new_lemma_26449 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @add_monoid.fg.{0} (has_pos_part.{0} real) (@function.extfun_app.{2 1} Type add_monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 add_monoid.{0}) (has_pos_part.{0} real))  := sorry --non-trivial
lemma new_lemma_26450 (h0 : functor.add_const (filter (has_nndist Type)) environment.implicit_infer_kind) : countable_Inter_filter (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_26451 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @t1_space.{0} (has_Sup.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_Sup.{0} num))  := sorry --non-trivial
lemma new_lemma_26452 (h0 : topological_space (distrib_lattice to_additive.value_type)) : totally_separated_space (distrib_lattice to_additive.value_type) := sorry --non-trivial
lemma new_lemma_26453 (h0 : topological_space (add_comm_monoid (simple_graph unsigned))) : locally_compact_space (add_comm_monoid (simple_graph unsigned)) := sorry --non-trivial
lemma new_lemma_26454 (h0 : functor.add_const (finset (finset Type)) Type) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_26455 (h0 : add_monoid ereal) (h1 : ereal) : nonempty (is_of_fin_add_order h1) := sorry --non-trivial
lemma new_lemma_26456 (h0 : add_group (normed_field enat)) : is_add_cyclic (normed_field enat) := sorry --non-trivial
lemma new_lemma_26457 (h0 : functor.add_const (topological_space (comm_group unsigned)) pos) : @preconnected_space.{0} (comm_group.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (comm_group.{0} unsigned)) pos h0)  := sorry --non-trivial
lemma new_lemma_26458 (h0 : set (measurable_space.dynkin_system (mul_one_class string.iterator_imp))) : set.finite h0 := sorry --non-trivial
lemma new_lemma_26459 (h0 : functor.add_const (group (finset name)) name) : @is_cyclic.{0} (finset.{0} name) (@functor.add_const.run.{0 0} (group.{0} (finset.{0} name)) name h0)  := sorry --non-trivial
lemma new_lemma_26460 (h0 : functor.add_const (semiring (has_Sup unsigned)) unsigned) : @is_noetherian_ring.{0} (has_Sup.{0} unsigned) (@functor.add_const.run.{0 0} (semiring.{0} (has_Sup.{0} unsigned)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_26461 (h0 : functor.add_const (topological_space (has_Inf name)) name) : @irreducible_space.{0} (has_Inf.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (has_Inf.{0} name)) name h0)  := sorry --non-trivial
lemma new_lemma_26462 (h0 : group empty) : group.fg empty := sorry --non-trivial
lemma new_lemma_26463 (h0 : function.extfun (Type 1) topological_space) : @normal_space.{1} (add_cancel_monoid.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} h0 (add_cancel_monoid.{1} Type))  := sorry --non-trivial
lemma new_lemma_26464 (h0 : function.extfun (finset Type) (has_mem.mem (measurable_space fun_info))) : complete_lattice.is_Sup_finite_compact (measurable_space fun_info) := sorry --non-trivial
lemma new_lemma_26465 (h0 : ring (div_inv_monoid (has_ssubset (has_ssubset linarith.comp_source)))) : rank_condition (div_inv_monoid (has_ssubset (has_ssubset linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_26466 (h0 : functor.add_const (ring (semigroup linarith.comp)) (boolean_algebra Type)) : @rank_condition.{0} (semigroup.{0} linarith.comp) (@functor.add_const.run.{0 1} (ring.{0} (semigroup.{0} linarith.comp)) (boolean_algebra.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_26467 (h0 : not (complete_lattice (semi_normed_comm_ring char) -> false)) : @complete_lattice.is_Sup_finite_compact.{0} (semi_normed_comm_ring.{0} char) (@classical.by_contradiction'.{1} (complete_lattice.{0} (semi_normed_comm_ring.{0} char)) h0)  := sorry --non-trivial
lemma new_lemma_26468 (h0 : topological_space (has_sup to_additive.value_type)) : totally_disconnected_space (has_sup to_additive.value_type) := sorry --non-trivial
lemma new_lemma_26469 (h0 : fin has_zero.zero) : @monoid.fg.{0} (has_bot.{0} name) (@matrix.vec_empty.{0} (monoid.{0} (has_bot.{0} name)) h0)  := sorry --non-trivial
lemma new_lemma_26470 (h0 : function.extfun (finset (Type -> Type)) (has_mem.mem add_monoid)) : @add_monoid.fg.{0} (has_inter.{0} num) (@function.extfun_app.{2 1} Type add_monoid.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) add_monoid.{0} (@function.extfun_app.{2 0} (finset.{1} (Type → Type)) (@has_mem.mem.{1 1} (Type → Type) (finset.{1} (Type → Type)) (@finset.has_mem.{1} (Type → Type)) add_monoid.{0}) h0 (@has_emptyc.emptyc.{1} (finset.{1} (Type → Type)) (@finset.has_emptyc.{1} (Type → Type))))) (has_inter.{0} num))  := sorry --non-trivial
lemma new_lemma_26471 (h1 : topological_space (id string_imp)) : totally_disconnected_space (id string_imp) := sorry --non-trivial
lemma new_lemma_26472 (h0 : group (has_zero (has_neg linarith.comp))) : is_cyclic (has_zero (has_neg linarith.comp)) := sorry --non-trivial
lemma new_lemma_26473 (h0 : ordered_add_comm_monoid (bin_tree (option (option (option (option congr_arg_kind)))))) : archimedean (bin_tree (option (option (option (option congr_arg_kind))))) := sorry --non-trivial
lemma new_lemma_26474 (h0 : uniform_space (left_cancel_monoid unsigned)) : complete_space (left_cancel_monoid unsigned) := sorry --non-trivial
lemma new_lemma_26475 (h0 : functor.add_const (ring (has_neg_part environment.implicit_infer_kind)) (boolean_algebra name)) : @rank_condition.{0} (has_neg_part.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (ring.{0} (has_neg_part.{0} environment.implicit_infer_kind)) (boolean_algebra.{0} name) h0)  := sorry --non-trivial
lemma new_lemma_26476 (h0 : function.extfun Type (functor.add_const (semiring (has_Sup num)))) : @is_noetherian_ring.{0} (has_Sup.{0} num) (@functor.add_const.run.{0 0} (semiring.{0} (has_Sup.{0} num)) congr_arg_kind (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (semiring.{0} (has_Sup.{0} num))) h0 congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_26477 (h0 : uniform_space (has_to_string linarith.comp)) : complete_space (has_to_string linarith.comp) := sorry --non-trivial
lemma new_lemma_26478 (h0 : uniform_space (has_to_string (has_neg (finset linarith.comp)))) : complete_space (has_to_string (has_neg (finset linarith.comp))) := sorry --non-trivial
lemma new_lemma_26479 (h0 : topological_space (has_star (semiring num))) : normal_space (has_star (semiring num)) := sorry --non-trivial
lemma new_lemma_26480 (h0 : add_monoid (has_neg_part ennreal)) : add_monoid.fg (has_neg_part ennreal) := sorry --non-trivial
lemma new_lemma_26481 (h0 : complete_lattice (semiring (semiring (semiring (semiring (semiring congr_arg_kind)))))) : is_atomistic (semiring (semiring (semiring (semiring (semiring congr_arg_kind))))) := sorry --non-trivial
lemma new_lemma_26482 (h1 : group (add_cancel_comm_monoid to_additive.value_type)) : is_cyclic (add_cancel_comm_monoid to_additive.value_type) := sorry --non-trivial
lemma new_lemma_26483 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @preconnected_space.{0} (comm_group.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (comm_group.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_26484 (h0 : function.extfun Type group) : @group.fg.{0} (linear_ordered_comm_monoid_with_zero.{0} unsigned) (@function.extfun_app.{2 1} Type group.{0} h0 (linear_ordered_comm_monoid_with_zero.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_26485 (h0 : function.extfun Type topological_space) : @totally_separated_space.{0} (has_star.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_star.{0} empty))  := sorry --non-trivial
lemma new_lemma_26486 (h0 : group (semigroup (has_add pos))) : group.fg (semigroup (has_add pos)) := sorry --non-trivial
lemma new_lemma_26487 (h0 : topological_space (non_unital_non_assoc_semiring (metric_space to_additive.value_type))) : path_connected_space (non_unital_non_assoc_semiring (metric_space to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_26488 (h0 : not (function.extfun Type add_monoid -> false)) : @add_monoid.fg.{0} (measurable_space.{0} linarith.comp) (@function.extfun_app.{2 1} Type add_monoid.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type add_monoid.{0}) h0) (measurable_space.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_26489 (h0 : functor.add_const (group (normed_comm_ring pos)) linarith.comp) : @normalizer_condition.{0} (normed_comm_ring.{0} pos) (@functor.add_const.run.{0 0} (group.{0} (normed_comm_ring.{0} pos)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_26490 (h0 : ring string_imp) : rank_condition string_imp := sorry --non-trivial
lemma new_lemma_26491 (h0 : function.extfun Type topological_space) : @irreducible_space.{0} (complete_distrib_lattice.{0} (semiring.{0} empty)) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (complete_distrib_lattice.{0} (semiring.{0} empty)))  := sorry --non-trivial
lemma new_lemma_26492 (h0 : filter (has_dist (option (option (option (option (option (option unsigned)))))))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_26493 (h0 : not (cancel_comm_monoid_with_zero auto.case_option -> false)) : @unique_factorization_monoid.{0} auto.case_option (@classical.by_contradiction'.{1} (cancel_comm_monoid_with_zero.{0} auto.case_option) h0)  := sorry --non-trivial
lemma new_lemma_26494 (h0 : filter (ring (has_Inf (finset Type)))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_26495 (h0 : functor.add_const Prop (ring (option (option (option ennreal))))) : functor.add_const.run h0 := sorry --non-trivial
lemma new_lemma_26496 (h0 : function.extfun Type topological_space) : @totally_disconnected_space.{0} (option.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (option.{0} num))  := sorry --non-trivial
lemma new_lemma_26497 (h0 : fin has_zero.zero) : @is_noetherian_ring.{0} (boolean_algebra.{0} pos) (@matrix.vec_empty.{0} (semiring.{0} (boolean_algebra.{0} pos)) h0)  := sorry --non-trivial
lemma new_lemma_26498 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @totally_separated_space.{0} (ring.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (ring.{0} empty))  := sorry --non-trivial
lemma new_lemma_26499 (h0 : topological_space (normed_lattice_add_comm_group pos)) : path_connected_space (normed_lattice_add_comm_group pos) := sorry --non-trivial
lemma new_lemma_26500 (h0 : topological_space (complete_semilattice_Sup (random_gen to_additive.value_type))) : totally_disconnected_space (complete_semilattice_Sup (random_gen to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_26501 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @group.fg.{0} (add_comm_monoid.{0} name) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (add_comm_monoid.{0} name))  := sorry --non-trivial
lemma new_lemma_26502 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @preirreducible_space.{0} (ring.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (ring.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_26503 (h0 : uniform_space (measurable_space num)) : complete_space (measurable_space num) := sorry --non-trivial
lemma new_lemma_26504 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @discrete_topology.{0} (measurable_space.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (measurable_space.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_26505 (h0 : topological_space (has_to_string (finset environment.implicit_infer_kind))) : preconnected_space (has_to_string (finset environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_26506 (h0 : functor.add_const (topological_space (finset environment.implicit_infer_kind)) pos) : @locally_compact_space.{0} (finset.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (finset.{0} environment.implicit_infer_kind)) pos h0)  := sorry --non-trivial
lemma new_lemma_26507 (h0 h1 : multiset (has_div string.iterator_imp)) : multiset.disjoint h0 h1 := sorry --non-trivial
lemma new_lemma_26508 (h0 : function.extfun Type (functor.add_const (finset (measurable_space.dynkin_system unsigned)))) : finset.nonempty (functor.add_const.run (function.extfun_app h0 unsigned)) := sorry --non-trivial
lemma new_lemma_26509 (h0 : topological_space (has_to_string (has_pos_part (has_pos_part linarith.comp)))) : topological_space.separable_space (has_to_string (has_pos_part (has_pos_part linarith.comp))) := sorry --non-trivial
lemma new_lemma_26510 (h0 : measurable_space (nondiscrete_normed_field char)) (h1 : measure_theory.measure (nondiscrete_normed_field char)) : measure_theory.is_finite_measure h1 := sorry --non-trivial
lemma new_lemma_26511 (h0 : topological_space (canonically_linear_ordered_monoid (option ennreal))) : regular_space (canonically_linear_ordered_monoid (option ennreal)) := sorry --non-trivial
lemma new_lemma_26512 (h0 : topological_space (add_group (has_norm linarith.comp))) : discrete_topology (add_group (has_norm linarith.comp)) := sorry --non-trivial
lemma new_lemma_26513 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @archimedean.{0} (ordered_cancel_add_comm_monoid.{0} unsigned) (@function.extfun_app.{2 1} Type ordered_add_comm_monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ordered_add_comm_monoid.{0}) (ordered_cancel_add_comm_monoid.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_26514 (h0 : functor.add_const (ring (complete_distrib_lattice name)) linarith.comp) : @is_domain.{0} (complete_distrib_lattice.{0} name) (@functor.add_const.run.{0 0} (ring.{0} (complete_distrib_lattice.{0} name)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_26515 (h0 : ring (ordered_comm_monoid (comm_semigroup (comm_semigroup real)))) : strong_rank_condition (ordered_comm_monoid (comm_semigroup (comm_semigroup real))) := sorry --non-trivial
lemma new_lemma_26516 (h0 : function.extfun Type complete_lattice) : @is_compactly_generated.{0} (fintype.{0} char) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (fintype.{0} char))  := sorry --non-trivial
lemma new_lemma_26517 (h0 : functor.add_const (topological_space (has_pos_part pos)) real) : @irreducible_space.{0} (has_pos_part.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (has_pos_part.{0} pos)) real h0)  := sorry --non-trivial
lemma new_lemma_26518 (h0 : ring (ordered_comm_group (option (option unsigned)))) : strong_rank_condition (ordered_comm_group (option (option unsigned))) := sorry --non-trivial
lemma new_lemma_26519 (h0 : functor.add_const (cancel_comm_monoid_with_zero Type) (has_neg pos)) : @unique_factorization_monoid.{1} Type (@functor.add_const.run.{1 0} (cancel_comm_monoid_with_zero.{1} Type) (has_neg.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_26520 (h0 : functor.add_const (function.extfun Type group) (has_neg environment.implicit_infer_kind)) : @group.fg.{0} (has_to_string.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type group.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type group.{0}) (has_neg.{0} environment.implicit_infer_kind) h0) (has_to_string.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_26521 (h0 : functor.add_const (function.extfun (Type 1) topological_space) pos) : @irreducible_space.{1} (ordered_comm_ring.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) topological_space.{1}) pos h0) (ordered_comm_ring.{1} Type))  := sorry --non-trivial
lemma new_lemma_26522 (h0 : functor.add_const (uniform_space (has_nndist Type)) linarith.comp) : @complete_space.{1} (has_nndist.{1} Type) (@functor.add_const.run.{1 0} (uniform_space.{1} (has_nndist.{1} Type)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_26523 (h0 : topological_space (ordered_comm_monoid (ordered_comm_monoid real))) : preconnected_space (ordered_comm_monoid (ordered_comm_monoid real)) := sorry --non-trivial
lemma new_lemma_26524 (h0 : complete_lattice (has_add (encodable to_additive.value_type))) : is_compactly_generated (has_add (encodable to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_26525 (h0 : topological_space (normed_field (has_ssubset reducibility_hints))) : t0_space (normed_field (has_ssubset reducibility_hints)) := sorry --non-trivial
lemma new_lemma_26526 (h0 : topological_space (normed_comm_ring (has_to_string pos))) : sequential_space (normed_comm_ring (has_to_string pos)) := sorry --non-trivial
lemma new_lemma_26527 (h0 : functor.add_const (semiring (has_nndist unsigned)) (has_add Type)) : @is_noetherian_ring.{0} (has_nndist.{0} unsigned) (@functor.add_const.run.{0 1} (semiring.{0} (has_nndist.{0} unsigned)) (has_add.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_26528 (h0 : topological_space (with_one unsigned)) : locally_compact_space (with_one unsigned) := sorry --non-trivial
lemma new_lemma_26529 (h0 : function.extfun Type ring) : @is_domain.{0} (monoid.{0} unsigned) (@function.extfun_app.{2 1} Type ring.{0} h0 (monoid.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_26530 (h0 : finset (has_Inf (ordered_comm_monoid (has_Inf (has_Inf (has_Inf (has_Inf (has_neg Type)))))))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_26531 (h2 : prod (add_comm_semigroup (add_comm_semigroup enat)) (add_comm_semigroup (add_comm_semigroup enat))) : set.diagonal (add_comm_semigroup (add_comm_semigroup enat)) h2 := sorry --non-trivial
lemma new_lemma_26532 (h0 : add_group (measurable_space to_additive.value_type)) : is_add_cyclic (measurable_space to_additive.value_type) := sorry --non-trivial
lemma new_lemma_26533 (h1 : not (complete_lattice (random_gen string_imp) -> false)) : @complete_lattice.is_Sup_finite_compact.{0} (random_gen.{0} string_imp) (@classical.by_contradiction'.{1} (complete_lattice.{0} (random_gen.{0} string_imp)) h1)  := sorry --non-trivial
lemma new_lemma_26534 (h0 : function.extfun Type topological_space) : @path_connected_space.{0} (comm_ring.{0} fun_info) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (comm_ring.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_26535 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @totally_separated_space.{0} (canonically_ordered_monoid.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (canonically_ordered_monoid.{0} pos))  := sorry --non-trivial
lemma new_lemma_26536 (h0 : topological_space (normed_comm_ring (option ennreal))) : t1_space (normed_comm_ring (option ennreal)) := sorry --non-trivial
lemma new_lemma_26537 (h0 : not (monoid (plift empty) -> false)) : @monoid.fg.{1} (plift.{1} empty) (@classical.by_contradiction'.{2} (monoid.{1} (plift.{1} empty)) h0)  := sorry --non-trivial
lemma new_lemma_26538 (h0 : functor.add_const (group (add_comm_monoid name)) name) : @is_simple_group.{0} (add_comm_monoid.{0} name) (@functor.add_const.run.{0 0} (group.{0} (add_comm_monoid.{0} name)) name h0)  := sorry --non-trivial
lemma new_lemma_26539 (h0 : ring (semiring (semiring (semiring (semiring (semiring (semiring (semiring nnreal)))))))) : rank_condition (semiring (semiring (semiring (semiring (semiring (semiring (semiring nnreal))))))) := sorry --non-trivial
lemma new_lemma_26540 (h0 : topological_space (has_star (ordered_cancel_comm_monoid (option unsigned)))) : preirreducible_space (has_star (ordered_cancel_comm_monoid (option unsigned))) := sorry --non-trivial
lemma new_lemma_26541 (h0 : not (add_group (semiring (random_gen fun_info)) -> false)) : @is_add_cyclic.{0} (semiring.{0} (random_gen.{0} fun_info)) (@classical.by_contradiction'.{1} (add_group.{0} (semiring.{0} (random_gen.{0} fun_info))) h0)  := sorry --non-trivial
lemma new_lemma_26542 (h1 : topological_space (comm_ring linarith.ineq)) : totally_disconnected_space (comm_ring linarith.ineq) := sorry --non-trivial
lemma new_lemma_26543 (h0 : complete_lattice (linear_ordered_comm_ring to_additive.value_type)) : is_compactly_generated (linear_ordered_comm_ring to_additive.value_type) := sorry --non-trivial
lemma new_lemma_26544 (h0 : topological_space (ordered_comm_monoid linarith.comp)) : preconnected_space (ordered_comm_monoid linarith.comp) := sorry --non-trivial
lemma new_lemma_26545 (h0 : prod (add_cancel_monoid environment.implicit_infer_kind) (add_cancel_monoid environment.implicit_infer_kind)) : id_rel h0 := sorry --non-trivial
lemma new_lemma_26546 (h0 : complete_lattice (has_Sup (option unsigned))) : is_compactly_generated (has_Sup (option unsigned)) := sorry --non-trivial
lemma new_lemma_26547 (h0 : function.extfun ((Type -> Type) -> Type 1) (function.extfun (Type -> Type))) : @separated_space.{0} (has_zero.{0} pos) (@function.extfun_app.{2 1} Type uniform_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) (@function.extfun_app.{3 2} ((Type → Type) → Type 1) (function.extfun.{2 2} (Type → Type)) h0 (function.extfun.{2 1} Type)) uniform_space.{0}) (has_zero.{0} pos))  := sorry --non-trivial
lemma new_lemma_26548 (h0 : group (topological_space fun_info)) : is_cyclic (topological_space fun_info) := sorry --non-trivial
lemma new_lemma_26549 (h0 : add_group (distrib_lattice (random_gen (distrib_lattice (has_top fun_info))))) : is_add_cyclic (distrib_lattice (random_gen (distrib_lattice (has_top fun_info)))) := sorry --non-trivial
lemma new_lemma_26550 (h0 : functor.add_const (function.extfun Type topological_space) name) : @totally_disconnected_space.{0} (has_pos_part.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) name h0) (has_pos_part.{0} pos))  := sorry --non-trivial
lemma new_lemma_26551 (h0 : topological_space (ordered_comm_ring (has_Inf real))) : totally_separated_space (ordered_comm_ring (has_Inf real)) := sorry --non-trivial
lemma new_lemma_26552 (h0 : list (boolean_algebra.core (finset (has_pos_part linarith.comp)))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_26553 (h0 : functor.add_const (topological_space (cancel_monoid Type)) pos) : @regular_space.{1} (cancel_monoid.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (cancel_monoid.{1} Type)) pos h0)  := sorry --non-trivial
lemma new_lemma_26554 (h0 : ring (semi_normed_comm_ring (distrib enat))) : rank_condition (semi_normed_comm_ring (distrib enat)) := sorry --non-trivial
lemma new_lemma_26555 (h0 : function.extfun Type topological_space) : @topological_space.separable_space.{0} (has_neg_part.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_neg_part.{0} pos))  := sorry --non-trivial
lemma new_lemma_26556 (h0 : topological_space (has_star (option (option pos)))) : preconnected_space (has_star (option (option pos))) := sorry --non-trivial
lemma new_lemma_26557 (h1 : ring (has_ssubset (normed_field reducibility_hints))) : is_domain (has_ssubset (normed_field reducibility_hints)) := sorry --non-trivial
lemma new_lemma_26558 (h0 : function.extfun Type group) : @normalizer_condition.{0} (add_comm_monoid.{0} real) (@function.extfun_app.{2 1} Type group.{0} h0 (add_comm_monoid.{0} real))  := sorry --non-trivial
lemma new_lemma_26559 (h0 : ring (boolean_algebra.core (has_add (has_add (has_add name))))) : rank_condition (boolean_algebra.core (has_add (has_add (has_add name)))) := sorry --non-trivial
lemma new_lemma_26560 (h0 : ordered_comm_monoid (add_cancel_monoid (has_add (has_add linarith.comp)))) : has_exists_mul_of_le (add_cancel_monoid (has_add (has_add linarith.comp))) := sorry --non-trivial
lemma new_lemma_26561 (h0 : complete_lattice (non_assoc_semiring (semiring empty))) : complete_lattice.is_Sup_finite_compact (non_assoc_semiring (semiring empty)) := sorry --non-trivial
lemma new_lemma_26562 (h0 : add_group (add_semigroup to_additive.value_type)) : is_add_cyclic (add_semigroup to_additive.value_type) := sorry --non-trivial
lemma new_lemma_26563 (h0 : semiring (ring (has_neg pos))) : is_noetherian_ring (ring (has_neg pos)) := sorry --non-trivial
lemma new_lemma_26564 (h0 : function.extfun Type topological_space) : @t1_space.{0} (bin_tree.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (bin_tree.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_26565 (h0 : functor.add_const (topological_space (comm_group pos)) (finset pos)) : @discrete_topology.{0} (comm_group.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (comm_group.{0} pos)) (finset.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_26566 (h2 : set (has_ssubset linarith.ineq)) : set.finite h2 := sorry --non-trivial
lemma new_lemma_26567 (h0 : function.extfun Type (functor.comp topological_space semigroup)) : @irreducible_space.{0} (semigroup.{0} ennreal) (@functor.comp.run.{0 0 0} topological_space.{0} semigroup.{0} ennreal (@function.extfun_app.{2 1} Type (functor.comp.{0 0 0} topological_space.{0} semigroup.{0}) h0 ennreal))  := sorry --non-trivial
lemma new_lemma_26568 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @complete_lattice.is_Sup_finite_compact.{0} (denumerable.{0} real) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (denumerable.{0} real))  := sorry --non-trivial
lemma new_lemma_26569 (h0 : list (has_to_string num)) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_26570 (h0 : ring (has_le (has_ssubset linarith.ineq))) : rank_condition (has_le (has_ssubset linarith.ineq)) := sorry --non-trivial
lemma new_lemma_26571 (h0 : topological_space (random_gen (random_gen fun_info))) : totally_separated_space (random_gen (random_gen fun_info)) := sorry --non-trivial
lemma new_lemma_26572 (h0 : ring (comm_monoid unsigned)) : rank_condition (comm_monoid unsigned) := sorry --non-trivial
lemma new_lemma_26573 (h0 : filter (partial_order unsigned)) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_26574 (h0 : functor.add_const (ring (comm_group pos)) Type) : @is_principal_ideal_ring.{0} (comm_group.{0} pos) (@functor.add_const.run.{0 1} (ring.{0} (comm_group.{0} pos)) Type h0)  := sorry --non-trivial
lemma new_lemma_26575 (h0 : functor.add_const (complete_lattice (has_neg pos)) Type) : @complete_lattice.is_Sup_finite_compact.{0} (has_neg.{0} pos) (@functor.add_const.run.{0 1} (complete_lattice.{0} (has_neg.{0} pos)) Type h0)  := sorry --non-trivial
lemma new_lemma_26576 (h0 : has_mem.mem (has_norm to_additive.value_type) has_emptyc.emptyc) : @is_compactly_generated.{0} (has_norm.{0} to_additive.value_type) (@finset.pi.empty.{1 0} Type complete_lattice.{0} (has_norm.{0} to_additive.value_type) h0)  := sorry --non-trivial
lemma new_lemma_26577 (h1 : topological_space (has_compl fun_info)) : t0_space (has_compl fun_info) := sorry --non-trivial
lemma new_lemma_26578 (h0 : functor.add_const (topological_space (add_comm_monoid name)) name) : @loc_path_connected_space.{0} (add_comm_monoid.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (add_comm_monoid.{0} name)) name h0)  := sorry --non-trivial
lemma new_lemma_26579 (h0 : functor.add_const (finset (add_cancel_monoid Type)) (has_neg Type)) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_26580 (h0 : finset (finset (has_nndist linarith.comp))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_26581 (h0 : group (finset (has_add (has_add (has_Inf real))))) : normalizer_condition (finset (has_add (has_add (has_Inf real)))) := sorry --non-trivial
lemma new_lemma_26582 (h0 h1 : multiset (has_div (mul_one_class fun_info))) : multiset.disjoint h0 h1 := sorry --non-trivial
lemma new_lemma_26583 (h0 : ring (option (option (option (option unsigned))))) : strong_rank_condition (option (option (option (option unsigned)))) := sorry --non-trivial
lemma new_lemma_26584 (h0 : topological_space (boolean_algebra (has_Inf (has_Inf (finset pos))))) : path_connected_space (boolean_algebra (has_Inf (has_Inf (finset pos)))) := sorry --non-trivial
lemma new_lemma_26585 (h0 : ring (div_inv_monoid (has_inv linarith.ineq))) : strong_rank_condition (div_inv_monoid (has_inv linarith.ineq)) := sorry --non-trivial
lemma new_lemma_26586 (h0 : group (has_neg (has_to_string num))) : is_cyclic (has_neg (has_to_string num)) := sorry --non-trivial
lemma new_lemma_26587 (h0 : topological_space (has_top empty)) : t1_space (has_top empty) := sorry --non-trivial
lemma new_lemma_26588 (h0 : topological_space (has_union (has_norm (has_norm linarith.comp)))) : preirreducible_space (has_union (has_norm (has_norm linarith.comp))) := sorry --non-trivial
lemma new_lemma_26589 (h0 : functor.add_const (topological_space (normed_comm_ring pos)) pos) : @topological_space.separable_space.{0} (normed_comm_ring.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (normed_comm_ring.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_26590 (h0 : list Prop) : list.ilast (id h0) := sorry --non-trivial
lemma new_lemma_26591 (h0 : topological_space (linear_ordered_semiring (semiring empty))) : t0_space (linear_ordered_semiring (semiring empty)) := sorry --non-trivial
lemma new_lemma_26592 (h0 : set (has_compl (mul_one_class linarith.ineq))) : set.finite h0 := sorry --non-trivial
lemma new_lemma_26593 (h0 : group (has_add (has_Inf real))) : is_cyclic (has_add (has_Inf real)) := sorry --non-trivial
lemma new_lemma_26594 (h1 : set (semi_normed_comm_ring linarith.ineq)) : set.subsingleton h1 := sorry --non-trivial
lemma new_lemma_26595 (h0 : monoid (linear_ordered_semiring (random_gen (random_gen fun_info)))) : monoid.fg (linear_ordered_semiring (random_gen (random_gen fun_info))) := sorry --non-trivial
lemma new_lemma_26596 (h0 : not (topological_space (mul_zero_class empty) -> false)) : @topological_space.separable_space.{0} (mul_zero_class.{0} empty) (@classical.by_contradiction'.{1} (topological_space.{0} (mul_zero_class.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_26597 (h0 : has_mem.mem (with_one linarith.comp) has_emptyc.emptyc) : @monoid.fg.{0} (with_one.{0} linarith.comp) (@finset.pi.empty.{1 0} Type monoid.{0} (with_one.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_26598 (h0 : with_bot (filter Prop)) (h1 : ne h0 has_bot.bot) : @Lim.{0} Prop sierpinski_space (@nonempty_of_inhabited.{1} Prop sort.inhabited.{0}) (@with_bot.unbot.{0} (filter.{0} Prop) h0 h1)  := sorry --non-trivial
lemma new_lemma_26599 (h0 : not (function.extfun Type ring -> false)) : @is_domain.{0} (has_inv.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type ring.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type ring.{0}) h0) (has_inv.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_26600 (h0 : ring (has_compl (random_gen (random_gen fun_info)))) : rank_condition (has_compl (random_gen (random_gen fun_info))) := sorry --non-trivial
lemma new_lemma_26601 (h0 : topological_space (boolean_algebra.core (has_nndist (semigroup pos)))) : t1_space (boolean_algebra.core (has_nndist (semigroup pos))) := sorry --non-trivial
lemma new_lemma_26602 (h0 : functor.add_const (topological_space (has_to_string environment.implicit_infer_kind)) (has_add pos)) : @irreducible_space.{0} (has_to_string.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (has_to_string.{0} environment.implicit_infer_kind)) (has_add.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_26603 (h1 : topological_space (measurable_space (semiring linarith.comp))) : totally_separated_space (measurable_space (semiring linarith.comp)) := sorry --non-trivial
lemma new_lemma_26604 (h0 : prod (linear_ordered_comm_ring (semiring num)) (linear_ordered_comm_ring (semiring num))) : id_rel h0 := sorry --non-trivial
lemma new_lemma_26605 (h0 : not (ring (semiring linarith.comp) -> false)) : @strong_rank_condition.{0} (semiring.{0} linarith.comp) (@classical.by_contradiction'.{1} (ring.{0} (semiring.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_26606 (h0 : functor.add_const (function.extfun (Type 1) ring) Type) : @is_domain.{1} (has_zero.{1} Type) (@function.extfun_app.{3 2} (Type 1) ring.{1} (@functor.add_const.run.{2 1} (function.extfun.{3 2} (Type 1) ring.{1}) Type h0) (has_zero.{1} Type))  := sorry --non-trivial
lemma new_lemma_26607 (h0 : topological_space (has_top (with_bot linarith.comp))) : discrete_topology (has_top (with_bot linarith.comp)) := sorry --non-trivial
lemma new_lemma_26608 (h0 : function.extfun Type group) : @group.fg.{0} (has_to_string.{0} linarith.ineq) (@function.extfun_app.{2 1} Type group.{0} h0 (has_to_string.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_26609 (h0 : set (has_lt to_additive.value_type)) : set.subsingleton h0 := sorry --non-trivial
lemma new_lemma_26610 (h0 : function.extfun Type ring) : @is_domain.{0} (complete_semilattice_Sup.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type ring.{0} h0 (complete_semilattice_Sup.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_26611 (h0 : ring (comm_ring (linear_ordered_add_comm_group (has_nnnorm reducibility_hints)))) : rank_condition (comm_ring (linear_ordered_add_comm_group (has_nnnorm reducibility_hints))) := sorry --non-trivial
lemma new_lemma_26612 (h0 : ring (linear_order (option unsigned))) : is_principal_ideal_ring (linear_order (option unsigned)) := sorry --non-trivial
lemma new_lemma_26613 (h0 : has_mem.mem num has_emptyc.emptyc) : @path_connected_space.{0} num (@finset.pi.empty.{1 0} Type topological_space.{0} num h0)  := sorry --non-trivial
lemma new_lemma_26614 (h0 : uniform_space (with_bot (semiring empty))) : complete_space (with_bot (semiring empty)) := sorry --non-trivial
lemma new_lemma_26615 (h0 : functor.add_const (group (boolean_algebra unsigned)) (finset linarith.comp)) : @group.fg.{0} (boolean_algebra.{0} unsigned) (@functor.add_const.run.{0 0} (group.{0} (boolean_algebra.{0} unsigned)) (finset.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_26616 (h0 : function.extfun Type topological_space) : @path_connected_space.{0} (pseudo_metric_space.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (pseudo_metric_space.{0} pos))  := sorry --non-trivial
lemma new_lemma_26617 (h0 : ring (metric_space (semiring (semiring (has_norm (has_norm empty)))))) : rank_condition (metric_space (semiring (semiring (has_norm (has_norm empty))))) := sorry --non-trivial
lemma new_lemma_26618 (h0 : complete_lattice ordering) : complete_lattice.is_Sup_finite_compact ordering := sorry --non-trivial
lemma new_lemma_26619 (h0 : function.extfun Type topological_space) : @locally_compact_space.{0} (simple_graph.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (simple_graph.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_26620 (h0 : not (topological_space (has_norm linarith.comp_source) -> false)) : @totally_disconnected_space.{0} (has_norm.{0} linarith.comp_source) (@classical.by_contradiction'.{1} (topological_space.{0} (has_norm.{0} linarith.comp_source)) h0)  := sorry --non-trivial
lemma new_lemma_26621 (h0 : functor.add_const (topological_space (has_neg_part environment.implicit_infer_kind)) (semigroup name)) : @normal_space.{0} (has_neg_part.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (has_neg_part.{0} environment.implicit_infer_kind)) (semigroup.{0} name) h0)  := sorry --non-trivial
lemma new_lemma_26622 (h0 : topological_space (normed_group (metric_space unsigned))) : t0_space (normed_group (metric_space unsigned)) := sorry --non-trivial
lemma new_lemma_26623 (h0 : fin has_zero.zero) : @complete_space.{1} (has_bot.{1} Type) (@matrix.vec_empty.{1} (uniform_space.{1} (has_bot.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_26624 (h0 : functor.add_const (function.extfun (Type 1) monoid) Type) : @monoid.fg.{1} (finset.{1} Type) (@function.extfun_app.{3 2} (Type 1) monoid.{1} (@functor.add_const.run.{2 1} (function.extfun.{3 2} (Type 1) monoid.{1}) Type h0) (finset.{1} Type))  := sorry --non-trivial
lemma new_lemma_26625 (h0 : ordered_add_comm_monoid (add_cancel_monoid (comm_group (has_to_string linarith.comp)))) : archimedean (add_cancel_monoid (comm_group (has_to_string linarith.comp))) := sorry --non-trivial
lemma new_lemma_26626 (h3 : not (complete_lattice linarith.comp_source -> false)) : @is_compactly_generated.{0} linarith.comp_source (@classical.by_contradiction'.{1} (complete_lattice.{0} linarith.comp_source) h3)  := sorry --non-trivial
lemma new_lemma_26627 (h0 : functor.add_const (list (has_nndist linarith.comp)) environment.implicit_infer_kind) : palindrome (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_26628 (h0 : function.extfun (finset (Type -> Type)) (has_mem.mem topological_space)) : @totally_disconnected_space.{0} (measurable_space.{0} fun_info) (@function.extfun_app.{2 1} Type topological_space.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) topological_space.{0} (@function.extfun_app.{2 0} (finset.{1} (Type → Type)) (@has_mem.mem.{1 1} (Type → Type) (finset.{1} (Type → Type)) (@finset.has_mem.{1} (Type → Type)) topological_space.{0}) h0 (@has_emptyc.emptyc.{1} (finset.{1} (Type → Type)) (@finset.has_emptyc.{1} (Type → Type))))) (measurable_space.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_26629 (h1 : ring (has_ssubset ereal)) : is_domain (has_ssubset ereal) := sorry --non-trivial
lemma new_lemma_26630 (h0 : topological_space (boolean_algebra (has_neg_part pos))) : path_connected_space (boolean_algebra (has_neg_part pos)) := sorry --non-trivial
lemma new_lemma_26631 (h0 : topological_space (has_nndist (has_add (has_add (has_Inf (simple_graph (has_Inf Type))))))) : irreducible_space (has_nndist (has_add (has_add (has_Inf (simple_graph (has_Inf Type)))))) := sorry --non-trivial
lemma new_lemma_26632 (h0 : topological_space (comm_group ennreal)) : preirreducible_space (comm_group ennreal) := sorry --non-trivial
lemma new_lemma_26633 (h0 : ring (has_pos_part (has_pos_part pos))) : is_domain (has_pos_part (has_pos_part pos)) := sorry --non-trivial
lemma new_lemma_26634 (h0 : topological_space (add_comm_monoid (has_add name))) : t1_space (add_comm_monoid (has_add name)) := sorry --non-trivial
lemma new_lemma_26635 (h0 : topological_space (ordered_comm_ring (has_add (ring linarith.comp)))) : preirreducible_space (ordered_comm_ring (has_add (ring linarith.comp))) := sorry --non-trivial
lemma new_lemma_26636 (h0 : topological_space (canonically_linear_ordered_monoid (ordered_comm_monoid (has_Inf Type)))) : discrete_topology (canonically_linear_ordered_monoid (ordered_comm_monoid (has_Inf Type))) := sorry --non-trivial
lemma new_lemma_26637 (h0 : topological_space (cancel_monoid name)) : path_connected_space (cancel_monoid name) := sorry --non-trivial
lemma new_lemma_26638 (h0 : not (ring (semiring linarith.ineq) -> false)) : @strong_rank_condition.{0} (semiring.{0} linarith.ineq) (@classical.by_contradiction'.{1} (ring.{0} (semiring.{0} linarith.ineq)) h0)  := sorry --non-trivial
lemma new_lemma_26639 (h0 : has_one (measurable_space empty) -> has_one (measurable_space empty) -> Prop) : irreflexive h0 := sorry --non-trivial
lemma new_lemma_26640 (h1 : group (has_nnnorm (comm_ring to_additive.value_type))) : is_cyclic (has_nnnorm (comm_ring to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_26641 (h0 : add_group (has_ssubset (mul_one_class (has_ssubset (mul_one_class fun_info))))) : is_add_cyclic (has_ssubset (mul_one_class (has_ssubset (mul_one_class fun_info)))) := sorry --non-trivial
lemma new_lemma_26642 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @archimedean.{0} (boolean_algebra.core.{0} name) (@function.extfun_app.{2 1} Type ordered_add_comm_monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ordered_add_comm_monoid.{0}) (boolean_algebra.core.{0} name))  := sorry --non-trivial
lemma new_lemma_26643 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : list.nodup (function.extfun_app (function.extfun_app h0 list) (finset Type)) := sorry --non-trivial
lemma new_lemma_26644 (h0 : uniform_space (has_norm (has_top linarith.comp_source))) : complete_space (has_norm (has_top linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_26645 (h0 : functor.add_const (ordered_add_comm_monoid (ring linarith.comp)) linarith.comp) : @archimedean.{0} (ring.{0} linarith.comp) (@functor.add_const.run.{0 0} (ordered_add_comm_monoid.{0} (ring.{0} linarith.comp)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_26646 (h0 : functor.add_const (function.extfun Type topological_space) (finset pos)) : @totally_disconnected_space.{0} (has_add.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) (finset.{0} pos) h0) (has_add.{0} name))  := sorry --non-trivial
lemma new_lemma_26647 (h0 : functor.add_const (topological_space (left_cancel_monoid unsigned)) congr_arg_kind) : @normal_space.{0} (left_cancel_monoid.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (left_cancel_monoid.{0} unsigned)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_26648 (h0 : topological_space (has_norm (has_ssubset to_additive.value_type))) : t0_space (has_norm (has_ssubset to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_26649 (h0 : semiring (semiring (random_gen congr_arg_kind)) -> semiring (semiring (random_gen congr_arg_kind)) -> Prop) : is_per (semiring (semiring (random_gen congr_arg_kind))) h0 := sorry --non-trivial
lemma new_lemma_26650 (h0 : functor.add_const (group (ordered_ring num)) unsigned) : @is_cyclic.{0} (ordered_ring.{0} num) (@functor.add_const.run.{0 0} (group.{0} (ordered_ring.{0} num)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_26651 (h0 : ring (simple_graph enat)) : strong_rank_condition (simple_graph enat) := sorry --non-trivial
lemma new_lemma_26652 (h0 : ordered_comm_monoid (ring (ordered_ring Type))) : has_exists_mul_of_le (ring (ordered_ring Type)) := sorry --non-trivial
lemma new_lemma_26653 (h0 : topological_space (with_bot linarith.ineq)) : path_connected_space (with_bot linarith.ineq) := sorry --non-trivial
lemma new_lemma_26654 (h0 : functor.add_const (ring (generalized_boolean_algebra Type)) (has_add linarith.comp)) : @rank_condition.{1} (generalized_boolean_algebra.{1} Type) (@functor.add_const.run.{1 0} (ring.{1} (generalized_boolean_algebra.{1} Type)) (has_add.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_26655 (h0 : ordered_add_comm_monoid (has_star num)) : archimedean (has_star num) := sorry --non-trivial
lemma new_lemma_26656 (h0 : has_mem.mem complete_lattice has_emptyc.emptyc) : @is_atomistic.{0} (@id.{2} Type linarith.comp) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) complete_lattice.{0} h0) (@id.{2} Type linarith.comp))  := sorry --non-trivial
lemma new_lemma_26657 (h0 : ordered_add_comm_monoid (partial_order congr_arg_kind)) : archimedean (partial_order congr_arg_kind) := sorry --non-trivial
lemma new_lemma_26658 (h0 : uniform_space (has_neg unsigned)) : complete_space (has_neg unsigned) := sorry --non-trivial
lemma new_lemma_26659 (h0 : has_mem.mem (semiring to_additive.value_type) has_emptyc.emptyc) : filter.ne_bot (finset.pi.empty filter (semiring to_additive.value_type) h0) := sorry --non-trivial
lemma new_lemma_26660 (h0 : group (has_emptyc (has_norm congr_arg_kind))) : is_cyclic (has_emptyc (has_norm congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_26661 (h0 : filter (linear_ordered_comm_ring (semiring empty))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_26662 (h0 : functor.add_const (add_monoid (add_group num)) congr_arg_kind) : @add_monoid.fg.{0} (add_group.{0} num) (@functor.add_const.run.{0 0} (add_monoid.{0} (add_group.{0} num)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_26663 (h0 : complete_lattice (has_compl (mul_one_class (mul_one_class to_additive.value_type)))) : is_compactly_generated (has_compl (mul_one_class (mul_one_class to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_26664 (h0 : topological_space (has_pos_part (has_neg real))) : t1_space (has_pos_part (has_neg real)) := sorry --non-trivial
lemma new_lemma_26665 (h0 : uniform_space (has_pos_part (has_Inf (sub_neg_monoid (sub_neg_monoid real))))) : complete_space (has_pos_part (has_Inf (sub_neg_monoid (sub_neg_monoid real)))) := sorry --non-trivial
lemma new_lemma_26666 (h1 : complete_lattice fun_info) : complete_lattice.is_Sup_finite_compact fun_info := sorry --non-trivial
lemma new_lemma_26667 (h0 : topological_space (semiring (semiring (has_norm unsigned)))) : totally_disconnected_space (semiring (semiring (has_norm unsigned))) := sorry --non-trivial
lemma new_lemma_26668 (h0 : add_group (has_top (has_norm empty))) : is_add_cyclic (has_top (has_norm empty)) := sorry --non-trivial
lemma new_lemma_26669 (h0 : topological_space (has_union (has_norm (semiring num)))) : discrete_topology (has_union (has_norm (semiring num))) := sorry --non-trivial
lemma new_lemma_26670 (h0 : ordered_comm_monoid (has_neg_part name)) : has_exists_mul_of_le (has_neg_part name) := sorry --non-trivial
lemma new_lemma_26671 (h0 : add_group (add_cancel_comm_monoid (random_gen string_imp))) : is_add_cyclic (add_cancel_comm_monoid (random_gen string_imp)) := sorry --non-trivial
lemma new_lemma_26672 (h0 : functor.add_const (group (has_add pos)) pos) : @normalizer_condition.{0} (has_add.{0} pos) (@functor.add_const.run.{0 0} (group.{0} (has_add.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_26673 (h0 : function.extfun Type topological_space) : @t0_space.{0} (finset.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (finset.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_26674 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @normal_space.{0} (has_zero.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_zero.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_26675 (h0 : topological_space (has_norm (semiring unsigned))) : topological_space.separable_space (has_norm (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_26676 (h0 : add_monoid (has_inter ennreal)) : add_monoid.fg (has_inter ennreal) := sorry --non-trivial
lemma new_lemma_26677 (h0 : topological_space (with_bot (has_inv (with_bot linarith.ineq)))) : locally_compact_space (with_bot (has_inv (with_bot linarith.ineq))) := sorry --non-trivial
lemma new_lemma_26678 (h0 : topological_space (has_neg (finset environment.implicit_infer_kind))) : path_connected_space (has_neg (finset environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_26679 (h0 : functor.add_const (topological_space (ordered_comm_monoid Type)) pos) : @sequential_space.{1} (ordered_comm_monoid.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (ordered_comm_monoid.{1} Type)) pos h0)  := sorry --non-trivial
lemma new_lemma_26680 (h0 : function.extfun Type ordered_add_comm_monoid) : @archimedean.{0} (generalized_boolean_algebra.{0} name) (@function.extfun_app.{2 1} Type ordered_add_comm_monoid.{0} h0 (generalized_boolean_algebra.{0} name))  := sorry --non-trivial
lemma new_lemma_26681 (h0 : not (complete_lattice (topological_space (has_nnnorm (has_nnnorm (has_nnnorm fun_info)))) -> false)) : is_compactly_generated (topological_space (has_nnnorm (has_nnnorm (has_nnnorm fun_info)))) := sorry --non-trivial
lemma new_lemma_26682 (h0 : functor.add_const (topological_space (add_cancel_monoid Type)) unsigned) : @path_connected_space.{1} (add_cancel_monoid.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (add_cancel_monoid.{1} Type)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_26683 (h0 : not (function.extfun Type ring -> false)) : @is_domain.{0} (add_right_cancel_monoid.{0} unsigned) (@function.extfun_app.{2 1} Type ring.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type ring.{0}) h0) (add_right_cancel_monoid.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_26684 (h0 : functor.add_const (group (semigroup pos)) pos) : @group.fg.{0} (semigroup.{0} pos) (@functor.add_const.run.{0 0} (group.{0} (semigroup.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_26685 (h0 : group (has_neg_part (option pos))) : normalizer_condition (has_neg_part (option pos)) := sorry --non-trivial
lemma new_lemma_26686 (h0 : prod (canonically_ordered_comm_semiring empty) (canonically_ordered_comm_semiring empty)) : id_rel h0 := sorry --non-trivial
lemma new_lemma_26687 (h0 : group (normed_lattice_add_comm_group (has_add pos))) : is_simple_group (normed_lattice_add_comm_group (has_add pos)) := sorry --non-trivial
lemma new_lemma_26688 (h0 : complete_lattice (plift (complete_distrib_lattice empty))) : is_atomistic (plift (complete_distrib_lattice empty)) := sorry --non-trivial
lemma new_lemma_26689 (h0 : topological_space (ring (ring pos))) : t0_space (ring (ring pos)) := sorry --non-trivial
lemma new_lemma_26690 (h0 : topological_space (ring (option (option pos)))) : preconnected_space (ring (option (option pos))) := sorry --non-trivial
lemma new_lemma_26691 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_noetherian_ring.{0} (add_cancel_monoid.{0} linarith.comp) (@function.extfun_app.{2 1} Type semiring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 semiring.{0}) (add_cancel_monoid.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_26692 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_domain.{0} (normed_lattice_add_comm_group.{0} real) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (normed_lattice_add_comm_group.{0} real))  := sorry --non-trivial
lemma new_lemma_26693 (h3 : topological_space char) : t0_space char := sorry --non-trivial
lemma new_lemma_26694 (h0 : fin has_zero.zero) : @loc_path_connected_space.{0} (canonically_ordered_comm_semiring.{0} pos) (@matrix.vec_empty.{0} (topological_space.{0} (canonically_ordered_comm_semiring.{0} pos)) h0)  := sorry --non-trivial
lemma new_lemma_26695 (h0 : group (linear_ordered_comm_monoid_with_zero congr_arg_kind)) : group.fg (linear_ordered_comm_monoid_with_zero congr_arg_kind) := sorry --non-trivial
lemma new_lemma_26696 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @has_exists_mul_of_le.{0} linarith.comp (@function.extfun_app.{2 1} Type ordered_comm_monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ordered_comm_monoid.{0}) linarith.comp)  := sorry --non-trivial
lemma new_lemma_26697 (h0 : ring (denumerable (comm_ring (comm_ring linarith.comp_source)))) : is_domain (denumerable (comm_ring (comm_ring linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_26698 (h0 : functor.add_const (finset (has_Inf pos)) linarith.comp) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_26699 (h0 : list (comm_group (has_add (has_add environment.implicit_infer_kind)))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_26700 (h0 : function.extfun Type topological_space) : @irreducible_space.{0} (has_inv.{0} fun_info) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_inv.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_26701 (h0 : semiring (canonically_linear_ordered_monoid (has_Inf real))) : is_noetherian_ring (canonically_linear_ordered_monoid (has_Inf real)) := sorry --non-trivial
lemma new_lemma_26702 (h0 : functor.add_const (uniform_space (ring name)) Type) : @separated_space.{0} (ring.{0} name) (@functor.add_const.run.{0 1} (uniform_space.{0} (ring.{0} name)) Type h0)  := sorry --non-trivial
lemma new_lemma_26703 (h0 : functor.add_const (function.extfun Type ring) Type) : @rank_condition.{0} (comm_group.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type ring.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type ring.{0}) Type h0) (comm_group.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_26704 (h0 : semiring (has_add (has_bot name))) : is_noetherian_ring (has_add (has_bot name)) := sorry --non-trivial
lemma new_lemma_26705 (h0 : complete_lattice (random_gen fun_info)) : is_compactly_generated (random_gen fun_info) := sorry --non-trivial
lemma new_lemma_26706 (h0 : fin has_zero.zero) : @rank_condition.{0} (has_add.{0} real) (@matrix.vec_empty.{0} (ring.{0} (has_add.{0} real)) h0)  := sorry --non-trivial
lemma new_lemma_26707 (h0 : uniform_space (comm_ring (random_gen to_additive.value_type))) : complete_space (comm_ring (random_gen to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_26708 (h0 : uniform_space (has_neg (cancel_monoid linarith.comp))) : separated_space (has_neg (cancel_monoid linarith.comp)) := sorry --non-trivial
lemma new_lemma_26709 (h0 : complete_lattice (has_top (has_norm empty))) : complete_lattice.is_Sup_finite_compact (has_top (has_norm empty)) := sorry --non-trivial
lemma new_lemma_26710 (h0 : complete_lattice (with_one (has_ssubset fun_info))) : complete_lattice.is_Sup_finite_compact (with_one (has_ssubset fun_info)) := sorry --non-trivial
lemma new_lemma_26711 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @t0_space.{0} (comm_ring.{0} (has_top.{0} (with_bot.{0} (random_gen.{0} (has_top.{0} to_additive.value_type))))) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (comm_ring.{0} (has_top.{0} (with_bot.{0} (random_gen.{0} (has_top.{0} to_additive.value_type))))))  := sorry --non-trivial
lemma new_lemma_26712 (h0 : ring (has_ssubset reducibility_hints)) : rank_condition (has_ssubset reducibility_hints) := sorry --non-trivial
lemma new_lemma_26713 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @totally_disconnected_space.{0} (has_inter.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_inter.{0} empty))  := sorry --non-trivial
lemma new_lemma_26714 (h0 : function.extfun Type complete_lattice) : @is_compactly_generated.{0} (add_group.{0} unsigned) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (add_group.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_26715 (h0 : functor.add_const (topological_space (comm_group unsigned)) Type) : @locally_compact_space.{0} (comm_group.{0} unsigned) (@functor.add_const.run.{0 1} (topological_space.{0} (comm_group.{0} unsigned)) Type h0)  := sorry --non-trivial
lemma new_lemma_26716 (h0 : filter (mul_zero_class (pseudo_metric_space name))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_26717 (h0 : ring (measurable_space.dynkin_system (semiring (has_top empty)))) : is_principal_ideal_ring (measurable_space.dynkin_system (semiring (has_top empty))) := sorry --non-trivial
lemma new_lemma_26718 (h0 : finset (plift unsigned)) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_26719 (h0 : functor.add_const (add_group (option empty)) congr_arg_kind) : @is_add_cyclic.{0} (option.{0} empty) (@functor.add_const.run.{0 0} (add_group.{0} (option.{0} empty)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_26720 (h0 : ring (ring (has_to_string (has_to_string (has_to_string Type))))) : is_principal_ideal_ring (ring (has_to_string (has_to_string (has_to_string Type)))) := sorry --non-trivial
lemma new_lemma_26721 (h0 : not (function.extfun Type topological_space -> false)) : @t0_space.{0} (has_emptyc.{0} fun_info) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (has_emptyc.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_26722 (h1 : has_mem.mem (normed_group congr_arg_kind) has_emptyc.emptyc) : @monoid.fg.{0} (normed_group.{0} congr_arg_kind) (@finset.pi.empty.{1 0} Type monoid.{0} (normed_group.{0} congr_arg_kind) h1)  := sorry --non-trivial
lemma new_lemma_26723 (h0 : functor.add_const (ring (ring pos)) Type) : @is_principal_ideal_ring.{0} (ring.{0} pos) (@functor.add_const.run.{0 1} (ring.{0} (ring.{0} pos)) Type h0)  := sorry --non-trivial
lemma new_lemma_26724 (h0 : complete_lattice (has_lt (semi_normed_comm_ring linarith.comp_source))) : is_compactly_generated (has_lt (semi_normed_comm_ring linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_26725 (h0 : not (function.extfun Type monoid -> false)) : @monoid.fg.{0} (measurable_space.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type monoid.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type monoid.{0}) h0) (measurable_space.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_26726 (h0 : function.extfun Type complete_lattice) : @is_compactly_generated.{0} (comm_monoid.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (comm_monoid.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_26727 (h0 : function.extfun Type topological_space) : @path_connected_space.{0} (comm_semigroup.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (comm_semigroup.{0} pos))  := sorry --non-trivial
lemma new_lemma_26728 (h0 : topological_space (canonically_ordered_monoid real)) : path_connected_space (canonically_ordered_monoid real) := sorry --non-trivial
lemma new_lemma_26729 (h0 : functor.add_const (topological_space (ordered_ring unsigned)) empty) : @t0_space.{0} (ordered_ring.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (ordered_ring.{0} unsigned)) empty h0)  := sorry --non-trivial
lemma new_lemma_26730 (h1 : group (comm_ring linarith.comp_source)) : is_cyclic (comm_ring linarith.comp_source) := sorry --non-trivial
lemma new_lemma_26731 (h0 : ring (has_edist (option empty))) : strong_rank_condition (has_edist (option empty)) := sorry --non-trivial
lemma new_lemma_26732 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @unique_factorization_monoid.{0} (cancel_monoid.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type cancel_comm_monoid_with_zero.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 cancel_comm_monoid_with_zero.{0}) (cancel_monoid.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_26733 (h0 : not (group (has_compl to_additive.value_type) -> false)) : @is_cyclic.{0} (has_compl.{0} to_additive.value_type) (@classical.by_contradiction'.{1} (group.{0} (has_compl.{0} to_additive.value_type)) h0)  := sorry --non-trivial
lemma new_lemma_26734 (h0 : add_monoid (complete_semilattice_Sup empty)) : add_monoid.fg (complete_semilattice_Sup empty) := sorry --non-trivial
lemma new_lemma_26735 (h0 : not (function.extfun Type group -> false)) : @group.fg.{0} (dlist.{0} linarith.ineq) (@function.extfun_app.{2 1} Type group.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type group.{0}) h0) (dlist.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_26736 (h0 : ring (comm_group (has_to_string (add_cancel_monoid (has_to_string name))))) : is_principal_ideal_ring (comm_group (has_to_string (add_cancel_monoid (has_to_string name)))) := sorry --non-trivial
lemma new_lemma_26737 (h0 : ring (boolean_algebra.core (comm_group name))) : is_domain (boolean_algebra.core (comm_group name)) := sorry --non-trivial
lemma new_lemma_26738 (h0 : function.extfun Type semiring) : @is_noetherian_ring.{0} (semiring.{0} unsigned) (@function.extfun_app.{2 1} Type semiring.{0} h0 (semiring.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_26739 (h0 : ordered_comm_monoid (mul_zero_class Type)) : has_exists_mul_of_le (mul_zero_class Type) := sorry --non-trivial
lemma new_lemma_26740 (h0 : complete_lattice (has_to_string (comm_group unsigned))) : is_atomistic (has_to_string (comm_group unsigned)) := sorry --non-trivial
lemma new_lemma_26741 (h0 : function.extfun nat fin) : @normal_space.{1} (has_bot.{1} Type) (@matrix.vec_empty.{1} (topological_space.{1} (has_bot.{1} Type)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_26742 (h0 : function.extfun Type group) : @is_cyclic.{0} (random_gen.{0} (has_nnnorm.{0} linarith.comp_source)) (@function.extfun_app.{2 1} Type group.{0} h0 (random_gen.{0} (has_nnnorm.{0} linarith.comp_source)))  := sorry --non-trivial
lemma new_lemma_26743 (h0 : topological_space (has_neg (finset name))) : path_connected_space (has_neg (finset name)) := sorry --non-trivial
lemma new_lemma_26744 (h1 : topological_space (measurable_space string_imp)) : path_connected_space (measurable_space string_imp) := sorry --non-trivial
lemma new_lemma_26745 (h0 : function.extfun (finset Type) (has_mem.mem (has_top fun_info))) : @complete_lattice.is_Sup_finite_compact.{0} (has_top.{0} fun_info) (@finset.pi.empty.{1 0} Type complete_lattice.{0} (has_top.{0} fun_info) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (has_top.{0} fun_info)) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_26746 (h0 : topological_space (ordered_comm_ring (has_neg Type))) : sequential_space (ordered_comm_ring (has_neg Type)) := sorry --non-trivial
lemma new_lemma_26747 (h0 : complete_lattice (measurable_space.dynkin_system (semiring (option unsigned)))) : complete_lattice.is_Sup_finite_compact (measurable_space.dynkin_system (semiring (option unsigned))) := sorry --non-trivial
lemma new_lemma_26748 (h0 : function.extfun Type topological_space) : @path_connected_space.{0} (linear_ordered_field.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (linear_ordered_field.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_26749 (h0 : add_group (has_to_string (has_neg_part (has_neg_part name)))) : is_add_cyclic (has_to_string (has_neg_part (has_neg_part name))) := sorry --non-trivial
lemma new_lemma_26750 (h0 : complete_lattice (ordered_cancel_add_comm_monoid (option ennreal))) : is_compactly_generated (ordered_cancel_add_comm_monoid (option ennreal)) := sorry --non-trivial
lemma new_lemma_26751 (h1 : group (linear_ordered_comm_group_with_zero string_imp)) : is_cyclic (linear_ordered_comm_group_with_zero string_imp) := sorry --non-trivial
lemma new_lemma_26752 (h0 : not (finset (complete_linear_order num) -> false)) : finset.nonempty (classical.by_contradiction' h0) := sorry --non-trivial
lemma new_lemma_26753 (h0 : function.extfun Type (functor.add_const (ring (comm_monoid empty)))) : @rank_condition.{0} (comm_monoid.{0} empty) (@functor.add_const.run.{0 0} (ring.{0} (comm_monoid.{0} empty)) empty (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (ring.{0} (comm_monoid.{0} empty))) h0 empty))  := sorry --non-trivial
lemma new_lemma_26754 (h0 : topological_space (ring (has_add (finset (finset pos))))) : topological_space.separable_space (ring (has_add (finset (finset pos)))) := sorry --non-trivial
lemma new_lemma_26755 (h0 : list (distrib_lattice char)) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_26756 (h0 : function.extfun Type (functor.comp topological_space has_add)) : @totally_disconnected_space.{0} (has_add.{0} pos) (@functor.comp.run.{0 0 0} topological_space.{0} has_add.{0} pos (@function.extfun_app.{2 1} Type (functor.comp.{0 0 0} topological_space.{0} has_add.{0}) h0 pos))  := sorry --non-trivial
lemma new_lemma_26757 (h0 : list (semigroup (has_neg environment.implicit_infer_kind))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_26758 (h0 : functor.add_const (monoid (ordered_comm_ring pos)) linarith.comp) : @monoid.fg.{0} (ordered_comm_ring.{0} pos) (@functor.add_const.run.{0 0} (monoid.{0} (ordered_comm_ring.{0} pos)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_26759 (h0 : not (function.extfun Type topological_space -> false)) : @preirreducible_space.{0} (metric_space.{0} (has_norm.{0} congr_arg_kind)) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (metric_space.{0} (has_norm.{0} congr_arg_kind)))  := sorry --non-trivial
lemma new_lemma_26760 (h0 : topological_space (has_neg_part (ring (cancel_monoid (has_neg_part ennreal))))) : totally_disconnected_space (has_neg_part (ring (cancel_monoid (has_neg_part ennreal)))) := sorry --non-trivial
lemma new_lemma_26761 (h0 : fin has_zero.zero) : @add_monoid.fg.{0} (ordered_comm_monoid.{0} real) (@matrix.vec_empty.{0} (add_monoid.{0} (ordered_comm_monoid.{0} real)) (@matrix.vec_empty.{0} (fin (@has_zero.zero.{0} nat nat.has_zero)) h0))  := sorry --non-trivial
lemma new_lemma_26762 (h0 : function.extfun Type topological_space) : @discrete_topology.{0} (add_group.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (add_group.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_26763 (h0 : uniform_space (uniform_space reducibility_hints)) : complete_space (uniform_space reducibility_hints) := sorry --non-trivial
lemma new_lemma_26764 (h0 : add_monoid (has_nndist (has_add (has_add Type)))) : add_monoid.fg (has_nndist (has_add (has_add Type))) := sorry --non-trivial
lemma new_lemma_26765 (h0 : functor.add_const (group (has_neg environment.implicit_infer_kind)) name) : @group.fg.{0} (has_neg.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (group.{0} (has_neg.{0} environment.implicit_infer_kind)) name h0)  := sorry --non-trivial
lemma new_lemma_26766 (h0 : functor.add_const (ring (option pos)) ennreal) : @strong_rank_condition.{0} (option.{0} pos) (@functor.add_const.run.{0 0} (ring.{0} (option.{0} pos)) ennreal h0)  := sorry --non-trivial
lemma new_lemma_26767 (h1 : group (distrib (random_gen char))) : is_cyclic (distrib (random_gen char)) := sorry --non-trivial
lemma new_lemma_26768 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_atomistic.{0} (linear_ordered_add_comm_group.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (linear_ordered_add_comm_group.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_26769 (h0 : functor.add_const (ring (generalized_boolean_algebra Type)) pos) : @is_domain.{1} (generalized_boolean_algebra.{1} Type) (@functor.add_const.run.{1 0} (ring.{1} (generalized_boolean_algebra.{1} Type)) pos h0)  := sorry --non-trivial
lemma new_lemma_26770 (h0 : not (finset (has_star empty) -> false)) : finset.nonempty (classical.by_contradiction' h0) := sorry --non-trivial
lemma new_lemma_26771 (h0 : topological_space (comm_ring (has_inv (has_norm string_imp)))) : path_connected_space (comm_ring (has_inv (has_norm string_imp))) := sorry --non-trivial
lemma new_lemma_26772 (h0 : add_group (finset (add_comm_monoid name))) : is_add_cyclic (finset (add_comm_monoid name)) := sorry --non-trivial
lemma new_lemma_26773 (h0 : functor.add_const (topological_space (add_group num)) num) : @t0_space.{0} (add_group.{0} num) (@functor.add_const.run.{0 0} (topological_space.{0} (add_group.{0} num)) num h0)  := sorry --non-trivial
lemma new_lemma_26774 (h1 : topological_space (dlist to_additive.value_type)) : path_connected_space (dlist to_additive.value_type) := sorry --non-trivial
lemma new_lemma_26775 (h1 : complete_lattice (has_nnnorm fun_info)) : is_compactly_generated (has_nnnorm fun_info) := sorry --non-trivial
lemma new_lemma_26776 (h0 : complete_lattice (with_bot (semiring (semiring (semiring num))))) : is_atomistic (with_bot (semiring (semiring (semiring num)))) := sorry --non-trivial
lemma new_lemma_26777 (h0 : not (ring (normed_group linarith.comp) -> false)) : @rank_condition.{0} (normed_group.{0} linarith.comp) (@classical.by_contradiction'.{1} (ring.{0} (normed_group.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_26778 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_domain.{0} (simple_graph.{0} pos) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (simple_graph.{0} pos))  := sorry --non-trivial
lemma new_lemma_26779 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @loc_path_connected_space.{0} (has_inner.{0 0} empty (option.{0} empty)) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_inner.{0 0} empty (option.{0} empty)))  := sorry --non-trivial
lemma new_lemma_26780 (h0 : has_mem.mem (measurable_space congr_arg_kind) has_emptyc.emptyc) : @path_connected_space.{0} (measurable_space.{0} congr_arg_kind) (@finset.pi.empty.{1 0} Type topological_space.{0} (measurable_space.{0} congr_arg_kind) h0)  := sorry --non-trivial
lemma new_lemma_26781 (h0 : ring (with_bot (comm_ring linarith.ineq))) : is_domain (with_bot (comm_ring linarith.ineq)) := sorry --non-trivial
lemma new_lemma_26782 (h0 : function.extfun Type list) : list.nodup (function.extfun_app h0 (has_norm fun_info)) := sorry --non-trivial
lemma new_lemma_26783 (h1 : topological_space (has_union (semiring (semiring empty)))) : irreducible_space (has_union (semiring (semiring empty))) := sorry --non-trivial
lemma new_lemma_26784 (h0 : filter (ring environment.implicit_infer_kind)) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_26785 (h0 : functor.add_const (group (add_comm_monoid environment.implicit_infer_kind)) Type) : @is_simple_group.{0} (add_comm_monoid.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 1} (group.{0} (add_comm_monoid.{0} environment.implicit_infer_kind)) Type h0)  := sorry --non-trivial
lemma new_lemma_26786 (h0 : functor.add_const (ordered_comm_monoid (has_Inf linarith.comp)) (complete_distrib_lattice name)) : @has_exists_mul_of_le.{0} (has_Inf.{0} linarith.comp) (@functor.add_const.run.{0 0} (ordered_comm_monoid.{0} (has_Inf.{0} linarith.comp)) (complete_distrib_lattice.{0} name) h0)  := sorry --non-trivial
lemma new_lemma_26787 (h0 : group (boolean_algebra.core (option (option (option unsigned))))) : normalizer_condition (boolean_algebra.core (option (option (option unsigned)))) := sorry --non-trivial
lemma new_lemma_26788 (h0 : function.extfun Type topological_space) : @discrete_topology.{0} (has_zero.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_zero.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_26789 (h0 : function.extfun (Type 1) list) : list.nodup (function.extfun_app h0 (add_cancel_monoid Type)) := sorry --non-trivial
lemma new_lemma_26790 (h0 : ring (has_neg (ring linarith.comp))) : is_principal_ideal_ring (has_neg (ring linarith.comp)) := sorry --non-trivial
lemma new_lemma_26791 (h0 : function.extfun Type (prod (mul_zero_class name))) : id_rel (function.extfun_app h0 (mul_zero_class name)) := sorry --non-trivial
lemma new_lemma_26792 (h0 : functor.add_const (monoid (has_zero Type)) name) : @monoid.fg.{1} (has_zero.{1} Type) (@functor.add_const.run.{1 0} (monoid.{1} (has_zero.{1} Type)) name h0)  := sorry --non-trivial
lemma new_lemma_26793 (h0 : functor.add_const (function.extfun Type ring) name) : @is_principal_ideal_ring.{0} (ordered_comm_ring.{0} pos) (@function.extfun_app.{2 1} Type ring.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type ring.{0}) name h0) (ordered_comm_ring.{0} pos))  := sorry --non-trivial
lemma new_lemma_26794 (h0 : ring (has_pos_part (ordered_comm_monoid real))) : is_domain (has_pos_part (ordered_comm_monoid real)) := sorry --non-trivial
lemma new_lemma_26795 (h0 : function.extfun Type cancel_comm_monoid_with_zero) : @unique_factorization_monoid.{0} (measurable_space.dynkin_system.{0} num) (@function.extfun_app.{2 1} Type cancel_comm_monoid_with_zero.{0} h0 (measurable_space.dynkin_system.{0} num))  := sorry --non-trivial
lemma new_lemma_26796 (h0 : functor.add_const (topological_space (generalized_boolean_algebra pos)) (has_Inf Type)) : @preirreducible_space.{0} (generalized_boolean_algebra.{0} pos) (@functor.add_const.run.{0 1} (topological_space.{0} (generalized_boolean_algebra.{0} pos)) (has_Inf.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_26797 (h0 : uniform_space (boolean_algebra (has_add (has_add (has_bot real))))) : complete_space (boolean_algebra (has_add (has_add (has_bot real)))) := sorry --non-trivial
lemma new_lemma_26798 (h0 : function.extfun Type ring) : @is_domain.{0} (has_dist.{0} (option.{0} unsigned)) (@function.extfun_app.{2 1} Type ring.{0} h0 (has_dist.{0} (option.{0} unsigned)))  := sorry --non-trivial
lemma new_lemma_26799 (h0 : group (metric_space congr_arg_kind)) : normalizer_condition (metric_space congr_arg_kind) := sorry --non-trivial
lemma new_lemma_26800 (h0 : list (has_to_string (has_pos_part linarith.comp))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_26801 (h0 : functor.add_const (topological_space (add_cancel_monoid environment.implicit_infer_kind)) name) : @t1_space.{0} (add_cancel_monoid.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (add_cancel_monoid.{0} environment.implicit_infer_kind)) name h0)  := sorry --non-trivial
lemma new_lemma_26802 (h0 : group (random_gen (mul_one_class fun_info))) : is_cyclic (random_gen (mul_one_class fun_info)) := sorry --non-trivial
lemma new_lemma_26803 (h0 : add_group (canonically_ordered_comm_semiring Type)) : is_add_cyclic (canonically_ordered_comm_semiring Type) := sorry --non-trivial
lemma new_lemma_26804 (h0 : complete_lattice (normed_comm_ring (option empty))) : complete_lattice.is_Sup_finite_compact (normed_comm_ring (option empty)) := sorry --non-trivial
lemma new_lemma_26805 (h0 : topological_space (normed_lattice_add_comm_group linarith.comp)) : regular_space (normed_lattice_add_comm_group linarith.comp) := sorry --non-trivial
lemma new_lemma_26806 (h0 : complete_lattice (finset ennreal)) : is_atomistic (finset ennreal) := sorry --non-trivial
lemma new_lemma_26807 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @loc_path_connected_space.{0} (has_dist.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_dist.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_26808 (h0 : functor.add_const (add_group (finset real)) (has_Inf (has_Inf (has_add (has_add (has_Inf Type)))))) : @is_add_cyclic.{0} (finset.{0} real) (@functor.add_const.run.{0 1} (add_group.{0} (finset.{0} real)) (has_Inf.{1} (has_Inf.{1} (has_add.{1} (has_add.{1} (has_Inf.{1} Type))))) h0)  := sorry --non-trivial
lemma new_lemma_26809 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @normalizer_condition.{0} (linear_ordered_field.{0} unsigned) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (linear_ordered_field.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_26810 (h0 : topological_space (uniform_space (random_gen char))) : path_connected_space (uniform_space (random_gen char)) := sorry --non-trivial
lemma new_lemma_26811 (h0 : cancel_comm_monoid_with_zero (random_gen (semiring num))) : unique_factorization_monoid (random_gen (semiring num)) := sorry --non-trivial
lemma new_lemma_26812 (h0 : functor.add_const (topological_space (ordered_comm_monoid Type)) Type) : @regular_space.{1} (ordered_comm_monoid.{1} Type) (@functor.add_const.run.{1 1} (topological_space.{1} (ordered_comm_monoid.{1} Type)) Type h0)  := sorry --non-trivial
lemma new_lemma_26813 (h0 : monoid (complete_semilattice_Sup (semiring (semiring (semiring congr_arg_kind))))) : monoid.fg (complete_semilattice_Sup (semiring (semiring (semiring congr_arg_kind)))) := sorry --non-trivial
lemma new_lemma_26814 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @complete_lattice.is_Sup_finite_compact.{0} (complete_semilattice_Sup.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (complete_semilattice_Sup.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_26815 (h0 : functor.add_const (add_group (semigroup linarith.comp)) linarith.comp) : @is_add_cyclic.{0} (semigroup.{0} linarith.comp) (@functor.add_const.run.{0 0} (add_group.{0} (semigroup.{0} linarith.comp)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_26816 (h0 : group empty) : normalizer_condition empty := sorry --non-trivial
lemma new_lemma_26817 (h0 : functor.add_const (topological_space (boolean_algebra linarith.comp)) pos) : @path_connected_space.{0} (boolean_algebra.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (boolean_algebra.{0} linarith.comp)) pos h0)  := sorry --non-trivial
lemma new_lemma_26818 (h0 : not (topological_space (add_group num) -> false)) : @preirreducible_space.{0} (add_group.{0} num) (@classical.by_contradiction'.{1} (topological_space.{0} (add_group.{0} num)) h0)  := sorry --non-trivial
lemma new_lemma_26819 (h0 : fin has_zero.zero) : @totally_disconnected_space.{0} (has_to_string.{0} linarith.comp) (@matrix.vec_empty.{0} (topological_space.{0} (has_to_string.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_26820 (h0 : complete_lattice (has_Inf (has_pos_part linarith.comp))) : is_compactly_generated (has_Inf (has_pos_part linarith.comp)) := sorry --non-trivial
lemma new_lemma_26821 (h0 : uniform_space (with_one (has_nnnorm to_additive.value_type))) : complete_space (with_one (has_nnnorm to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_26822 (h0 : not (semiring (measurable_space linarith.comp) -> false)) : @is_noetherian_ring.{0} (measurable_space.{0} linarith.comp) (@classical.by_contradiction'.{1} (semiring.{0} (measurable_space.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_26823 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @locally_compact_space.{0} (has_add.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_add.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_26824 (h0 : functor.add_const (list (ordered_comm_ring name)) pos) : palindrome (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_26825 (h0 : ring (has_ssubset (has_append (denumerable (has_append reducibility_hints))))) : strong_rank_condition (has_ssubset (has_append (denumerable (has_append reducibility_hints)))) := sorry --non-trivial
lemma new_lemma_26826 (h0 : ordered_add_comm_monoid (monoid_with_zero ennreal)) : archimedean (monoid_with_zero ennreal) := sorry --non-trivial
lemma new_lemma_26827 (h0 : group (has_top (has_nnnorm linarith.ineq))) : is_cyclic (has_top (has_nnnorm linarith.ineq)) := sorry --non-trivial
lemma new_lemma_26828 (h0 : function.extfun Type topological_space) : preconnected_space ennreal := sorry --non-trivial
lemma new_lemma_26829 (h0 : functor.add_const (topological_space (finset Type)) ennreal) : @normal_space.{1} (finset.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (finset.{1} Type)) ennreal h0)  := sorry --non-trivial
lemma new_lemma_26830 (h0 : semiring (ordered_ring (option unsigned))) : is_noetherian_ring (ordered_ring (option unsigned)) := sorry --non-trivial
lemma new_lemma_26831 (h0 : ring (has_pos_part (boolean_algebra Type))) : rank_condition (has_pos_part (boolean_algebra Type)) := sorry --non-trivial
lemma new_lemma_26832 (h0 : group (boolean_algebra (ring environment.implicit_infer_kind))) : normalizer_condition (boolean_algebra (ring environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_26833 (h0 : group (boolean_algebra.core (has_neg_part pos))) : is_simple_group (boolean_algebra.core (has_neg_part pos)) := sorry --non-trivial
lemma new_lemma_26834 (h0 : functor.add_const (finset (has_edist empty)) empty) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_26835 (h0 : complete_lattice (comm_group ennreal)) : complete_lattice.is_Sup_finite_compact (comm_group ennreal) := sorry --non-trivial
lemma new_lemma_26836 (h0 : ordered_add_comm_monoid (linear_ordered_comm_monoid_with_zero (semiring num))) : archimedean (linear_ordered_comm_monoid_with_zero (semiring num)) := sorry --non-trivial
lemma new_lemma_26837 (h0 : not (finset Prop -> false)) (h1 : finset.nonempty (classical.by_contradiction' h0)) : @finset.max'.{0} Prop Prop.linear_order (@classical.by_contradiction'.{1} (finset.{0} Prop) h0) h1  := sorry --non-trivial
lemma new_lemma_26838 (h0 : functor.add_const (group (has_neg_part Type)) name) : @group.fg.{1} (has_neg_part.{1} Type) (@functor.add_const.run.{1 0} (group.{1} (has_neg_part.{1} Type)) name h0)  := sorry --non-trivial
lemma new_lemma_26839 (h0 : functor.add_const (list (ordered_comm_ring Type)) linarith.comp) : list.nodup (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_26840 (h0 : not (ring (normed_field string_imp) -> false)) : @is_domain.{0} (normed_field.{0} string_imp) (@classical.by_contradiction'.{1} (ring.{0} (normed_field.{0} string_imp)) h0)  := sorry --non-trivial
lemma new_lemma_26841 (h0 : filter (option (option (option (option (option (option (option (option ennreal))))))))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_26842 (h0 : ring (encodable fun_info)) : is_domain (encodable fun_info) := sorry --non-trivial
lemma new_lemma_26843 (h0 : functor.add_const (ring (has_add linarith.comp)) (has_Inf Type)) : @is_principal_ideal_ring.{0} (has_add.{0} linarith.comp) (@functor.add_const.run.{0 1} (ring.{0} (has_add.{0} linarith.comp)) (has_Inf.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_26844 (h1 : topological_space (normed_group fun_info)) : path_connected_space (normed_group fun_info) := sorry --non-trivial
lemma new_lemma_26845 (h4 : function.extfun Type add_group) : @is_add_cyclic.{0} (has_norm.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type add_group.{0} h4 (has_norm.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_26846 (h0 : topological_space (has_star (ordered_cancel_comm_monoid congr_arg_kind))) : totally_separated_space (has_star (ordered_cancel_comm_monoid congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_26847 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @strong_rank_condition.{0} (add_group.{0} num) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (add_group.{0} num))  := sorry --non-trivial
lemma new_lemma_26848 (h0 : group (has_add (option unsigned))) : group.fg (has_add (option unsigned)) := sorry --non-trivial
lemma new_lemma_26849 (h0 : ring (distrib_lattice (has_norm (has_norm to_additive.value_type)))) : rank_condition (distrib_lattice (has_norm (has_norm to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_26850 (h0 : function.extfun Type (functor.add_const (cancel_comm_monoid_with_zero (preorder empty)))) : @unique_factorization_monoid.{0} (preorder.{0} empty) (@functor.add_const.run.{0 0} (cancel_comm_monoid_with_zero.{0} (preorder.{0} empty)) unsigned (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (cancel_comm_monoid_with_zero.{0} (preorder.{0} empty))) h0 unsigned))  := sorry --non-trivial
lemma new_lemma_26851 (h0 : functor.add_const (topological_space (has_nndist pos)) pos) : @locally_compact_space.{0} (has_nndist.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (has_nndist.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_26852 (h1 : topological_space (id congr_arg_kind)) : path_connected_space (id congr_arg_kind) := sorry --non-trivial
lemma new_lemma_26853 (h0 : multiset (with_bot (has_top fun_info))) : multiset.nodup h0 := sorry --non-trivial
lemma new_lemma_26854 (h0 : functor.add_const (topological_space (has_nndist name)) unsigned) : @path_connected_space.{0} (has_nndist.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (has_nndist.{0} name)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_26855 (h0 : group (random_gen (denumerable (has_inv (denumerable (denumerable (has_top linarith.ineq))))))) : is_cyclic (random_gen (denumerable (has_inv (denumerable (denumerable (has_top linarith.ineq)))))) := sorry --non-trivial
lemma new_lemma_26856 (h0 : not (topological_space (has_top linarith.comp) -> false)) : @irreducible_space.{0} (has_top.{0} linarith.comp) (@classical.by_contradiction'.{1} (topological_space.{0} (has_top.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_26857 (h0 : functor.add_const (topological_space (linear_ordered_comm_group empty)) unsigned) : @path_connected_space.{0} (linear_ordered_comm_group.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (linear_ordered_comm_group.{0} empty)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_26858 (h0 : uniform_space (has_compl string_imp)) : complete_space (has_compl string_imp) := sorry --non-trivial
lemma new_lemma_26859 (h0 : topological_space (has_Inf linarith.comp)) : topological_space.separable_space (has_Inf linarith.comp) := sorry --non-trivial
lemma new_lemma_26860 (h0 : function.extfun Type ring) : @is_principal_ideal_ring.{0} (ring.{0} empty) (@function.extfun_app.{2 1} Type ring.{0} h0 (ring.{0} empty))  := sorry --non-trivial
lemma new_lemma_26861 (h0 : uniform_space (with_one (random_gen (has_top (has_top (has_norm fun_info)))))) : separated_space (with_one (random_gen (has_top (has_top (has_norm fun_info))))) := sorry --non-trivial
lemma new_lemma_26862 (h1 : has_lt (nondiscrete_normed_field fun_info)) : no_max_order (nondiscrete_normed_field fun_info) := sorry --non-trivial
lemma new_lemma_26863 (h0 : function.extfun Type topological_space) : @path_connected_space.{0} (with_bot.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (with_bot.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_26864 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @topological_space.separable_space.{0} (add_group.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (add_group.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_26865 (h0 : topological_space (is_R_or_C unsigned)) : t1_space (is_R_or_C unsigned) := sorry --non-trivial
lemma new_lemma_26866 (h0 : not (topological_space (uniform_space char) -> false)) : @t0_space.{0} (uniform_space.{0} char) (@classical.by_contradiction'.{1} (topological_space.{0} (uniform_space.{0} char)) h0)  := sorry --non-trivial
lemma new_lemma_26867 (h0 : functor.add_const (finset (add_cancel_monoid pos)) pos) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_26868 (h0 : thunk (list Prop)) : @list.head.{0} Prop sort.inhabited.{0} (@trace_call_stack.{0} (list.{0} Prop) h0)  := sorry --non-trivial
lemma new_lemma_26869 (h0 : functor.add_const (function.extfun Type topological_space) linarith.comp) : @preirreducible_space.{0} (has_add.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) linarith.comp h0) (has_add.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_26870 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @has_exists_mul_of_le.{0} (ordered_comm_monoid.{0} linarith.comp) (@function.extfun_app.{2 1} Type ordered_comm_monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ordered_comm_monoid.{0}) (ordered_comm_monoid.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_26871 (h0 : topological_space (comm_group (finset Type))) : path_connected_space (comm_group (finset Type)) := sorry --non-trivial
lemma new_lemma_26872 (h0 : complete_lattice (random_gen (has_nnnorm linarith.comp_source))) : complete_lattice.is_Sup_finite_compact (random_gen (has_nnnorm linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_26873 (h0 : uniform_space (has_sub (semiring (has_top unsigned)))) : separated_space (has_sub (semiring (has_top unsigned))) := sorry --non-trivial
lemma new_lemma_26874 (h0 : ordered_add_comm_monoid (finset name)) : archimedean (finset name) := sorry --non-trivial
lemma new_lemma_26875 (h0 : group (ordered_ring (semiring num))) : normalizer_condition (ordered_ring (semiring num)) := sorry --non-trivial
lemma new_lemma_26876 (h0 : finset (has_neg (has_add (ring (has_add linarith.comp))))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_26877 (h0 : group (cancel_monoid linarith.comp)) : group.fg (cancel_monoid linarith.comp) := sorry --non-trivial
lemma new_lemma_26878 (h0 : uniform_space (has_bot (sub_neg_monoid (has_pos_part pos)))) : separated_space (has_bot (sub_neg_monoid (has_pos_part pos))) := sorry --non-trivial
lemma new_lemma_26879 (h0 : function.extfun Type group) : @group.fg.{0} (has_neg_part.{0} pos) (@function.extfun_app.{2 1} Type group.{0} h0 (has_neg_part.{0} pos))  := sorry --non-trivial
lemma new_lemma_26880 (h0 : topological_space (has_nnnorm (mul_one_class enat))) : totally_disconnected_space (has_nnnorm (mul_one_class enat)) := sorry --non-trivial
lemma new_lemma_26881 (h0 : topological_space (nondiscrete_normed_field std_gen)) (h1 : add_group (nondiscrete_normed_field std_gen)) : topological_add_group (nondiscrete_normed_field std_gen) := sorry --non-trivial
lemma new_lemma_26882 (h0 : functor.add_const (group (finset Type)) (has_neg Type)) : @group.fg.{1} (finset.{1} Type) (@functor.add_const.run.{1 1} (group.{1} (finset.{1} Type)) (has_neg.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_26883 (h0 : topological_space (has_to_string (has_Inf (has_add Type)))) : preconnected_space (has_to_string (has_Inf (has_add Type))) := sorry --non-trivial
lemma new_lemma_26884 (h0 : not (complete_lattice (normed_group congr_arg_kind) -> false)) : @complete_lattice.is_Sup_finite_compact.{0} (normed_group.{0} congr_arg_kind) (@classical.by_contradiction'.{1} (complete_lattice.{0} (normed_group.{0} congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_26885 (h0 : functor.add_const (group (has_neg_part Type)) environment.implicit_infer_kind) : @is_cyclic.{1} (has_neg_part.{1} Type) (@functor.add_const.run.{1 0} (group.{1} (has_neg_part.{1} Type)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_26886 (h0 : functor.add_const (list (mul_zero_class name)) (has_nndist Type)) : palindrome (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_26887 (h0 : group (mul_zero_class (semiring (semiring congr_arg_kind)))) : is_cyclic (mul_zero_class (semiring (semiring congr_arg_kind))) := sorry --non-trivial
lemma new_lemma_26888 (h0 : topological_space (random_gen (semiring (semiring num)))) : preirreducible_space (random_gen (semiring (semiring num))) := sorry --non-trivial
lemma new_lemma_26889 (h0 : ring (has_norm (random_gen linarith.comp_source))) : rank_condition (has_norm (random_gen linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_26890 (h0 : uniform_space (cancel_monoid (has_neg_part (measurable_space name)))) : complete_space (cancel_monoid (has_neg_part (measurable_space name))) := sorry --non-trivial
lemma new_lemma_26891 (h0 : function.extfun Type topological_space) : @totally_separated_space.{0} (linear_ordered_semiring.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (linear_ordered_semiring.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_26892 (h0 : topological_space (ordered_comm_monoid (has_Inf pos))) : discrete_topology (ordered_comm_monoid (has_Inf pos)) := sorry --non-trivial
lemma new_lemma_26893 (h0 : monoid (has_bot congr_arg_kind)) : monoid.fg (has_bot congr_arg_kind) := sorry --non-trivial
lemma new_lemma_26894 (h0 : complete_lattice (measurable_space (has_norm congr_arg_kind))) : is_atomistic (measurable_space (has_norm congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_26895 (h0 : group (finset congr_arg_kind)) : is_cyclic (finset congr_arg_kind) := sorry --non-trivial
lemma new_lemma_26896 (h0 : functor.add_const (ring (as_linear_order unsigned)) unsigned) : @strong_rank_condition.{0} (as_linear_order.{0} unsigned) (@functor.add_const.run.{0 0} (ring.{0} (as_linear_order.{0} unsigned)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_26897 (h0 : functor.add_const (function.extfun Type topological_space) name) : @discrete_topology.{0} (has_Inf.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) name h0) (has_Inf.{0} name))  := sorry --non-trivial
lemma new_lemma_26898 (h0 : functor.add_const (topological_space (add_comm_monoid pos)) Type) : @irreducible_space.{0} (add_comm_monoid.{0} pos) (@functor.add_const.run.{0 1} (topological_space.{0} (add_comm_monoid.{0} pos)) Type h0)  := sorry --non-trivial
lemma new_lemma_26899 (h0 : functor.add_const (complete_lattice (has_add name)) pos) : @is_compactly_generated.{0} (has_add.{0} name) (@functor.add_const.run.{0 0} (complete_lattice.{0} (has_add.{0} name)) pos h0)  := sorry --non-trivial
lemma new_lemma_26900 (h0 : functor.add_const (topological_space nnreal) congr_arg_kind) : t1_space nnreal := sorry --non-trivial
lemma new_lemma_26901 (h0 : fin has_zero.zero) : @group.fg.{1} (canonically_ordered_monoid.{1} Type) (@matrix.vec_empty.{1} (group.{1} (canonically_ordered_monoid.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_26902 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @normal_space.{1} (normed_lattice_add_comm_group.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 topological_space.{1}) (normed_lattice_add_comm_group.{1} Type))  := sorry --non-trivial
lemma new_lemma_26903 (h0 : functor.add_const Prop (add_comm_monoid linarith.comp)) : functor.add_const.run h0 := sorry --non-trivial
lemma new_lemma_26904 (h0 : ring (has_nnnorm (random_gen linarith.comp_source))) : rank_condition (has_nnnorm (random_gen linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_26905 (h0 : functor.add_const (complete_lattice (ordered_ring empty)) empty) : @is_atomistic.{0} (ordered_ring.{0} empty) (@functor.add_const.run.{0 0} (complete_lattice.{0} (ordered_ring.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_26906 (h0 : functor.add_const (topological_space (comm_group linarith.comp)) linarith.comp) : @preirreducible_space.{0} (comm_group.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (comm_group.{0} linarith.comp)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_26907 (h0 : function.extfun Type topological_space) : @t1_space.{0} (has_zero.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_zero.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_26908 (h0 : not (topological_space (linear_ordered_add_comm_group fun_info) -> false)) : @totally_disconnected_space.{0} (linear_ordered_add_comm_group.{0} fun_info) (@classical.by_contradiction'.{1} (topological_space.{0} (linear_ordered_add_comm_group.{0} fun_info)) h0)  := sorry --non-trivial
lemma new_lemma_26909 (h0 : uniform_space (ordered_comm_monoid (ordered_comm_monoid real))) : complete_space (ordered_comm_monoid (ordered_comm_monoid real)) := sorry --non-trivial
lemma new_lemma_26910 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @complete_lattice.is_Sup_finite_compact.{0} (canonically_ordered_comm_semiring.{0} linarith.comp) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (canonically_ordered_comm_semiring.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_26911 (h2 : uniform_space (random_gen linarith.ineq)) : complete_space (random_gen linarith.ineq) := sorry --non-trivial
lemma new_lemma_26912 (h0 : function.extfun Type uniform_space) : @complete_space.{0} (complete_distrib_lattice.{0} ennreal) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (complete_distrib_lattice.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_26913 (h0 : topological_space (normed_field (has_nnnorm char))) : path_connected_space (normed_field (has_nnnorm char)) := sorry --non-trivial
lemma new_lemma_26914 (h0 : complete_lattice (ring name)) : is_atomistic (ring name) := sorry --non-trivial
lemma new_lemma_26915 (h0 : function.extfun Type (functor.add_const (ring ennreal))) : @strong_rank_condition.{0} ennreal (@functor.add_const.run.{0 0} (ring.{0} ennreal) congr_arg_kind (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (ring.{0} ennreal)) h0 congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_26916 (h0 : uniform_space (random_gen (comm_ring char))) : complete_space (random_gen (comm_ring char)) := sorry --non-trivial
lemma new_lemma_26917 (h0 : topological_space (uniform_space (group_with_zero linarith.ineq))) : t0_space (uniform_space (group_with_zero linarith.ineq)) := sorry --non-trivial
lemma new_lemma_26918 (h0 : ring (has_compl (has_nnnorm (partial_order linarith.ineq)))) : rank_condition (has_compl (has_nnnorm (partial_order linarith.ineq))) := sorry --non-trivial
lemma new_lemma_26919 (h0 : ordered_add_comm_monoid (canonically_ordered_comm_semiring congr_arg_kind)) : archimedean (canonically_ordered_comm_semiring congr_arg_kind) := sorry --non-trivial
lemma new_lemma_26920 (h0 : set (has_lt linarith.ineq)) : set.finite h0 := sorry --non-trivial
lemma new_lemma_26921 (h0 : functor.add_const (cancel_comm_monoid_with_zero (normed_comm_ring pos)) name) : @unique_factorization_monoid.{0} (normed_comm_ring.{0} pos) (@functor.add_const.run.{0 0} (cancel_comm_monoid_with_zero.{0} (normed_comm_ring.{0} pos)) name h0)  := sorry --non-trivial
lemma new_lemma_26922 (h0 : uniform_space (ordered_comm_monoid (canonically_linear_ordered_monoid name))) : separated_space (ordered_comm_monoid (canonically_linear_ordered_monoid name)) := sorry --non-trivial
lemma new_lemma_26923 (h0 : topological_space (left_cancel_monoid (semiring congr_arg_kind))) : t1_space (left_cancel_monoid (semiring congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_26924 (h0 : function.extfun Type monoid) : @monoid.fg.{0} (with_one.{0} num) (@function.extfun_app.{2 1} Type monoid.{0} h0 (with_one.{0} num))  := sorry --non-trivial
lemma new_lemma_26925 (h0 : functor.add_const (group (boolean_algebra.core Type)) unsigned) : @normalizer_condition.{1} (boolean_algebra.core.{1} Type) (@functor.add_const.run.{1 0} (group.{1} (boolean_algebra.core.{1} Type)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_26926 (h0 : function.extfun Type add_group) : @is_add_cyclic.{0} (measurable_space.{0} linarith.ineq) (@function.extfun_app.{2 1} Type add_group.{0} h0 (measurable_space.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_26927 (h0 : topological_space (has_sub (has_top empty))) : t0_space (has_sub (has_top empty)) := sorry --non-trivial
lemma new_lemma_26928 (h0 : filter (semigroup (add_cancel_monoid ennreal))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_26929 (h0 : function.extfun Type uniform_space) : @complete_space.{0} (cancel_monoid.{0} unsigned) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (cancel_monoid.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_26930 (h0 : topological_space (has_zero (finset environment.implicit_infer_kind))) : path_connected_space (has_zero (finset environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_26931 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @normalizer_condition.{0} (has_emptyc.{0} string_imp) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (has_emptyc.{0} string_imp))  := sorry --non-trivial
lemma new_lemma_26932 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @monoid.fg.{0} (linear_ordered_field.{0} empty) (@function.extfun_app.{2 1} Type monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 monoid.{0}) (linear_ordered_field.{0} empty))  := sorry --non-trivial
lemma new_lemma_26933 (h0 : has_mem.mem (function.extfun Type) has_emptyc.emptyc) : @complete_lattice.is_Sup_finite_compact.{0} (normed_group.{0} fun_info) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) (@finset.pi.empty.{2 1} ((Type → Type) → Type 1) (function.extfun.{2 2} (Type → Type)) (function.extfun.{2 1} Type) h0) complete_lattice.{0}) (normed_group.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_26934 (h0 : function.extfun Type group) : @is_cyclic.{0} (with_one.{0} fun_info) (@function.extfun_app.{2 1} Type group.{0} h0 (with_one.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_26935 (h0 : functor.add_const (topological_space (has_neg_part name)) name) : @path_connected_space.{0} (has_neg_part.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (has_neg_part.{0} name)) name h0)  := sorry --non-trivial
lemma new_lemma_26936 (h0 : topological_space (id empty)) : discrete_topology (id empty) := sorry --non-trivial
lemma new_lemma_26937 (h0 : functor.comp topological_space add_cancel_monoid pos) : @totally_separated_space.{0} (add_cancel_monoid.{0} pos) (@functor.comp.run.{0 0 0} topological_space.{0} add_cancel_monoid.{0} pos h0)  := sorry --non-trivial
lemma new_lemma_26938 (h0 : function.extfun Type filter) : filter.ne_bot (function.extfun_app h0 (preorder (option unsigned))) := sorry --non-trivial
lemma new_lemma_26939 (h0 : function.extfun Type topological_space) : @irreducible_space.{0} (filter.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (filter.{0} empty))  := sorry --non-trivial
lemma new_lemma_26940 (h0 : function.extfun Type ring) : @rank_condition.{0} (ordered_comm_ring.{0} linarith.comp) (@function.extfun_app.{2 1} Type ring.{0} h0 (ordered_comm_ring.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_26941 (h0 : functor.add_const (topological_space (ring pos)) pos) : @loc_path_connected_space.{0} (ring.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (ring.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_26942 (h0 : topological_space (denumerable (has_ssubset to_additive.value_type))) : locally_compact_space (denumerable (has_ssubset to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_26943 (h0 : semiring (normed_linear_ordered_group (semiring (semiring empty)))) : is_noetherian_ring (normed_linear_ordered_group (semiring (semiring empty))) := sorry --non-trivial
lemma new_lemma_26944 (h0 : function.extfun Type uniform_space) : @separated_space.{0} (group_with_zero.{0} empty) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (group_with_zero.{0} empty))  := sorry --non-trivial
lemma new_lemma_26945 (h0 : function.extfun Type topological_space) : @loc_path_connected_space.{0} (has_inf.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_inf.{0} empty))  := sorry --non-trivial
lemma new_lemma_26946 (h0 : functor.add_const (uniform_space (has_Inf name)) name) : @separated_space.{0} (has_Inf.{0} name) (@functor.add_const.run.{0 0} (uniform_space.{0} (has_Inf.{0} name)) name h0)  := sorry --non-trivial
lemma new_lemma_26947 (h0 : filter (cancel_monoid (option (option unsigned)))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_26948 (h0 : add_monoid (complete_distrib_lattice environment.implicit_infer_kind)) : add_monoid.fg (complete_distrib_lattice environment.implicit_infer_kind) := sorry --non-trivial
lemma new_lemma_26949 (h0 : group (left_cancel_semigroup (semiring empty))) : normalizer_condition (left_cancel_semigroup (semiring empty)) := sorry --non-trivial
lemma new_lemma_26950 (h1 : topological_space (add_comm_semigroup char)) : t0_space (add_comm_semigroup char) := sorry --non-trivial
lemma new_lemma_26951 (h0 : functor.add_const (topological_space (normed_comm_ring ennreal)) pos) : @topological_space.separable_space.{0} (normed_comm_ring.{0} ennreal) (@functor.add_const.run.{0 0} (topological_space.{0} (normed_comm_ring.{0} ennreal)) pos h0)  := sorry --non-trivial
lemma new_lemma_26952 (h0 : function.extfun Type (functor.comp list cancel_monoid)) : palindrome (functor.comp.run (function.extfun_app h0 environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_26953 (h0 : functor.add_const (list (comm_group unsigned)) name) : list.nodup (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_26954 (h0 : functor.add_const (topological_space (cancel_monoid environment.implicit_infer_kind)) name) : @loc_path_connected_space.{0} (cancel_monoid.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (cancel_monoid.{0} environment.implicit_infer_kind)) name h0)  := sorry --non-trivial
lemma new_lemma_26955 (h0 : functor.add_const (topological_space (mul_zero_class name)) ennreal) : @preirreducible_space.{0} (mul_zero_class.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (mul_zero_class.{0} name)) ennreal h0)  := sorry --non-trivial
lemma new_lemma_26956 (h0 : add_monoid (linear_ordered_field (has_neg ennreal))) : add_monoid.fg (linear_ordered_field (has_neg ennreal)) := sorry --non-trivial
lemma new_lemma_26957 (h0 : cancel_comm_monoid_with_zero (ordered_ring congr_arg_kind)) : unique_factorization_monoid (ordered_ring congr_arg_kind) := sorry --non-trivial
lemma new_lemma_26958 (h0 : ordered_add_comm_monoid (ordered_comm_monoid (has_add name))) : archimedean (ordered_comm_monoid (has_add name)) := sorry --non-trivial
lemma new_lemma_26959 (h0 : complete_lattice (semi_normed_ring reducibility_hints)) : complete_lattice.is_Sup_finite_compact (semi_normed_ring reducibility_hints) := sorry --non-trivial
lemma new_lemma_26960 (h0 : functor.add_const (complete_lattice (linear_order empty)) empty) : @complete_lattice.is_Sup_finite_compact.{0} (linear_order.{0} empty) (@functor.add_const.run.{0 0} (complete_lattice.{0} (linear_order.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_26961 (h0 : not (function.extfun Type semiring -> false)) : @is_noetherian_ring.{0} empty (@function.extfun_app.{2 1} Type semiring.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type semiring.{0}) h0) empty)  := sorry --non-trivial
lemma new_lemma_26962 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_add_cyclic.{0} (canonically_ordered_monoid.{0} linarith.comp) (@function.extfun_app.{2 1} Type add_group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 add_group.{0}) (canonically_ordered_monoid.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_26963 (h0 : set (has_neg to_additive.value_type)) : set.finite h0 := sorry --non-trivial
lemma new_lemma_26964 (h0 : not (add_monoid (semiring num) -> false)) : @add_monoid.fg.{0} (semiring.{0} num) (@classical.by_contradiction'.{1} (add_monoid.{0} (semiring.{0} num)) h0)  := sorry --non-trivial
lemma new_lemma_26965 (h0 : cancel_comm_monoid_with_zero (semiring congr_arg_kind)) : unique_factorization_monoid (semiring congr_arg_kind) := sorry --non-trivial
lemma new_lemma_26966 (h0 : functor.add_const (functor.add_const (finset Type) pos) (has_add Type)) : finset.nonempty (functor.add_const.run (functor.add_const.run h0)) := sorry --non-trivial
lemma new_lemma_26967 (h0 : uniform_space (has_neg_part environment.implicit_infer_kind)) : complete_space (has_neg_part environment.implicit_infer_kind) := sorry --non-trivial
lemma new_lemma_26968 (h1 : filter to_additive.value_type) : filter.ne_bot h1 := sorry --non-trivial
lemma new_lemma_26969 (h0 : functor.add_const (function.extfun Type group) linarith.comp) : @is_cyclic.{0} (comm_group.{0} linarith.comp) (@function.extfun_app.{2 1} Type group.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type group.{0}) linarith.comp h0) (comm_group.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_26970 (h0 : topological_space (cancel_monoid (option ennreal))) : totally_disconnected_space (cancel_monoid (option ennreal)) := sorry --non-trivial
lemma new_lemma_26971 (h0 : filter (semiring (semiring (semiring (semiring unsigned))))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_26972 (h0 : ring (has_neg (finset (finset Type)))) : rank_condition (has_neg (finset (finset Type))) := sorry --non-trivial
lemma new_lemma_26973 (h0 : functor.add_const (uniform_space (semigroup linarith.comp)) (has_zero Type)) : @separated_space.{0} (semigroup.{0} linarith.comp) (@functor.add_const.run.{0 1} (uniform_space.{0} (semigroup.{0} linarith.comp)) (has_zero.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_26974 (h0 : functor.add_const (complete_lattice (canonically_ordered_comm_semiring environment.implicit_infer_kind)) name) : @is_compactly_generated.{0} (canonically_ordered_comm_semiring.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (complete_lattice.{0} (canonically_ordered_comm_semiring.{0} environment.implicit_infer_kind)) name h0)  := sorry --non-trivial
lemma new_lemma_26975 (h0 : functor.add_const (topological_space (boolean_algebra.core linarith.comp)) linarith.comp) : @sequential_space.{0} (boolean_algebra.core.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (boolean_algebra.core.{0} linarith.comp)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_26976 (h0 : function.extfun (Type 1) (prod (plift num))) : id_rel (function.extfun_app h0 (plift num)) := sorry --non-trivial
lemma new_lemma_26977 (h0 : group (option (finset ennreal))) : normalizer_condition (option (finset ennreal)) := sorry --non-trivial
lemma new_lemma_26978 (h0 : function.extfun Type (prod (ordered_cancel_add_comm_monoid congr_arg_kind))) : id_rel (function.extfun_app h0 (ordered_cancel_add_comm_monoid congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_26979 (h0 : ring (has_ssubset (mul_one_class (mul_one_class reducibility_hints)))) : strong_rank_condition (has_ssubset (mul_one_class (mul_one_class reducibility_hints))) := sorry --non-trivial
lemma new_lemma_26980 (h0 : prod (linear_ordered_comm_ring congr_arg_kind) (linear_ordered_comm_ring congr_arg_kind)) : id_rel h0 := sorry --non-trivial
lemma new_lemma_26981 (h0 : add_comm_monoid (has_nndist (has_nndist string_imp))) (h1 : add_submonoid (has_nndist (has_nndist string_imp))) (h2 : complete_lattice (has_div (add_localization h1))) : is_compactly_generated (has_div (add_localization h1)) := sorry --non-trivial
lemma new_lemma_26982 (h0 : ring (has_ssubset (mul_one_class reducibility_hints))) : strong_rank_condition (has_ssubset (mul_one_class reducibility_hints)) := sorry --non-trivial
lemma new_lemma_26983 (h0 : not (has_mem.mem string_imp has_emptyc.emptyc -> false)) : @is_domain.{0} string_imp (@finset.pi.empty.{1 0} Type ring.{0} string_imp (@classical.by_contradiction'.{0} (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) string_imp (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))) h0))  := sorry --non-trivial
lemma new_lemma_26984 (h0 : filter (has_emptyc (random_gen (random_gen num)))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_26985 (h0 : functor.add_const (topological_space (has_to_string Type)) Type) : @preconnected_space.{1} (has_to_string.{1} Type) (@functor.add_const.run.{1 1} (topological_space.{1} (has_to_string.{1} Type)) Type h0)  := sorry --non-trivial
lemma new_lemma_26986 (h0 : function.extfun Type topological_space) : @irreducible_space.{0} (has_pos_part.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_pos_part.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_26987 (h0 : uniform_space (normed_field (has_nnnorm char))) : complete_space (normed_field (has_nnnorm char)) := sorry --non-trivial
lemma new_lemma_26988 (h0 : functor.add_const (topological_space (finset environment.implicit_infer_kind)) Type) : @preconnected_space.{0} (finset.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 1} (topological_space.{0} (finset.{0} environment.implicit_infer_kind)) Type h0)  := sorry --non-trivial
lemma new_lemma_26989 (h0 : topological_space (id (has_norm congr_arg_kind))) : t0_space (id (has_norm congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_26990 (h0 : topological_space linarith.ineq) (h1 : has_sub linarith.ineq) : has_continuous_sub linarith.ineq := sorry --non-trivial
lemma new_lemma_26991 (h0 : functor.add_const (topological_space (complete_distrib_lattice linarith.comp)) (has_pos_part linarith.comp)) : @totally_separated_space.{0} (complete_distrib_lattice.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (complete_distrib_lattice.{0} linarith.comp)) (has_pos_part.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_26992 (h0 : group (has_add linarith.comp)) : normalizer_condition (has_add linarith.comp) := sorry --non-trivial
lemma new_lemma_26993 (h0 : ordered_add_comm_monoid (ring (finset (has_Inf linarith.comp)))) : archimedean (ring (finset (has_Inf linarith.comp))) := sorry --non-trivial
lemma new_lemma_26994 (h0 : function.extfun Type monoid) : @monoid.fg.{0} (normed_linear_ordered_group.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type monoid.{0} h0 (normed_linear_ordered_group.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_26995 (h0 : function.extfun Type complete_lattice) : @complete_lattice.is_Sup_finite_compact.{0} (ring.{0} num) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (ring.{0} num))  := sorry --non-trivial
lemma new_lemma_26996 (h0 : functor.add_const (function.extfun (Type 1) semiring) (finset (finset Type))) : @is_noetherian_ring.{1} (has_nndist.{1} Type) (@function.extfun_app.{3 2} (Type 1) semiring.{1} (@functor.add_const.run.{2 1} (function.extfun.{3 2} (Type 1) semiring.{1}) (finset.{1} (finset.{1} Type)) h0) (has_nndist.{1} Type))  := sorry --non-trivial
lemma new_lemma_26997 (h0 : topological_space (partial_order (option congr_arg_kind))) : t1_space (partial_order (option congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_26998 (h0 : group (random_gen (has_nnnorm to_additive.value_type))) : is_cyclic (random_gen (has_nnnorm to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_26999 (h0 : ring (div_inv_monoid linarith.comp_source)) : rank_condition (div_inv_monoid linarith.comp_source) := sorry --non-trivial
lemma new_lemma_27000 (h0 : topological_space (has_norm (has_norm (random_gen congr_arg_kind)))) : discrete_topology (has_norm (has_norm (random_gen congr_arg_kind))) := sorry --non-trivial
lemma new_lemma_27001 (h0 : not (function.extfun Type topological_space -> false)) : @totally_disconnected_space.{0} (has_norm.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (has_norm.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_27002 (h0 : function.extfun Type complete_lattice) : @is_atomistic.{0} (has_add.{0} unsigned) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (has_add.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_27003 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_principal_ideal_ring.{0} (cancel_monoid.{0} name) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (cancel_monoid.{0} name))  := sorry --non-trivial
lemma new_lemma_27004 (h0 : has_le (random_gen linarith.comp_source)) : no_top_order (random_gen linarith.comp_source) := sorry --non-trivial
lemma new_lemma_27005 (h0 : topological_space (boolean_algebra (finset (has_Inf linarith.comp)))) : regular_space (boolean_algebra (finset (has_Inf linarith.comp))) := sorry --non-trivial
lemma new_lemma_27006 (h0 : topological_space (has_zero (has_add name))) : topological_space.separable_space (has_zero (has_add name)) := sorry --non-trivial
lemma new_lemma_27007 (h1 : ring (comm_ring (topological_space (random_gen (random_gen char))))) : is_domain (comm_ring (topological_space (random_gen (random_gen char)))) := sorry --non-trivial
lemma new_lemma_27008 (h0 : topological_space (has_sub (semiring num))) : path_connected_space (has_sub (semiring num)) := sorry --non-trivial
lemma new_lemma_27009 (h0 : function.extfun Type ring) : @is_principal_ideal_ring.{0} num (@function.extfun_app.{2 1} Type ring.{0} h0 num)  := sorry --non-trivial
lemma new_lemma_27010 (h0 : function.extfun Type ring) : @strong_rank_condition.{0} (free_add_monoid.{0} empty) (@function.extfun_app.{2 1} Type ring.{0} h0 (free_add_monoid.{0} empty))  := sorry --non-trivial
lemma new_lemma_27011 (h0 : group (boolean_algebra.core congr_arg_kind)) : is_cyclic (boolean_algebra.core congr_arg_kind) := sorry --non-trivial
lemma new_lemma_27012 (h0 : add_monoid (add_cancel_monoid (has_neg_part Type))) : add_monoid.fg (add_cancel_monoid (has_neg_part Type)) := sorry --non-trivial
lemma new_lemma_27013 (h0 : uniform_space (id (has_norm empty))) : complete_space (id (has_norm empty)) := sorry --non-trivial
lemma new_lemma_27014 (h0 : function.extfun Type topological_space) : @t1_space.{0} (mul_zero_class.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (mul_zero_class.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_27015 (h0 : functor.add_const (group (ring pos)) Type) : @is_cyclic.{0} (ring.{0} pos) (@functor.add_const.run.{0 1} (group.{0} (ring.{0} pos)) Type h0)  := sorry --non-trivial
lemma new_lemma_27016 (h0 : functor.add_const (ring (generalized_boolean_algebra linarith.comp)) (has_add Type)) : @strong_rank_condition.{0} (generalized_boolean_algebra.{0} linarith.comp) (@functor.add_const.run.{0 1} (ring.{0} (generalized_boolean_algebra.{0} linarith.comp)) (has_add.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_27017 (h0 : topological_space (has_ssubset (with_one (random_gen (has_inv string_imp))))) : locally_compact_space (has_ssubset (with_one (random_gen (has_inv string_imp)))) := sorry --non-trivial
lemma new_lemma_27018 (h0 : topological_space (boolean_algebra.core (finset pos))) : locally_compact_space (boolean_algebra.core (finset pos)) := sorry --non-trivial
lemma new_lemma_27019 (h0 : function.extfun Type topological_space) : @preconnected_space.{0} (semigroup.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (semigroup.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_27020 (h0 : ring (normed_lattice_add_comm_group (sub_neg_monoid Type))) : is_domain (normed_lattice_add_comm_group (sub_neg_monoid Type)) := sorry --non-trivial
lemma new_lemma_27021 (h0 : add_group (non_unital_non_assoc_semiring (mul_one_class (mul_one_class char)))) : is_add_cyclic (non_unital_non_assoc_semiring (mul_one_class (mul_one_class char))) := sorry --non-trivial
lemma new_lemma_27022 (h0 : filter (has_neg (finset ennreal))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_27023 (h1 : add_group (linear_ordered_semiring congr_arg_kind)) : is_add_cyclic (linear_ordered_semiring congr_arg_kind) := sorry --non-trivial
lemma new_lemma_27024 (h0 : semiring (has_union (with_bot (with_bot (with_bot unsigned))))) : is_noetherian_ring (has_union (with_bot (with_bot (with_bot unsigned)))) := sorry --non-trivial
lemma new_lemma_27025 (h0 : list (option (option unsigned))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_27026 (h0 : not (topological_space (with_bot fun_info) -> false)) : @irreducible_space.{0} (with_bot.{0} fun_info) (@classical.by_contradiction'.{1} (topological_space.{0} (with_bot.{0} fun_info)) h0)  := sorry --non-trivial
lemma new_lemma_27027 (h0 : function.extfun Type filter) : countable_Inter_filter (function.extfun_app h0 (has_to_string linarith.comp)) := sorry --non-trivial
lemma new_lemma_27028 (h0 : topological_space (denumerable (has_nnnorm reducibility_hints))) : t0_space (denumerable (has_nnnorm reducibility_hints)) := sorry --non-trivial
lemma new_lemma_27029 (h0 : topological_space (has_to_string (has_add name))) : t1_space (has_to_string (has_add name)) := sorry --non-trivial
lemma new_lemma_27030 (h0 : function.extfun Type ring) : @is_domain.{0} (linear_ordered_cancel_comm_monoid.{0} (option.{0} empty)) (@function.extfun_app.{2 1} Type ring.{0} h0 (linear_ordered_cancel_comm_monoid.{0} (option.{0} empty)))  := sorry --non-trivial
lemma new_lemma_27031 (h0 : list (measure_theory.measure_space empty)) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_27032 (h9 : topological_space string.iterator_imp) (h10 : set string.iterator_imp) : is_closed h10 := sorry --non-trivial
lemma new_lemma_27033 (h0 : not (function.extfun Type group -> false)) : @is_cyclic.{0} (measurable_space.{0} empty) (@function.extfun_app.{2 1} Type group.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type group.{0}) h0) (measurable_space.{0} empty))  := sorry --non-trivial
lemma new_lemma_27034 (h0 : functor.add_const (function.extfun Type ordered_add_comm_monoid) linarith.comp) : @archimedean.{0} (generalized_boolean_algebra.{0} name) (@function.extfun_app.{2 1} Type ordered_add_comm_monoid.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type ordered_add_comm_monoid.{0}) linarith.comp h0) (generalized_boolean_algebra.{0} name))  := sorry --non-trivial
lemma new_lemma_27035 (h0 : function.extfun Type add_group) : @is_add_cyclic.{0} (preorder.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type add_group.{0} h0 (preorder.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_27036 (h0 : functor.add_const (topological_space (normed_comm_ring name)) linarith.comp) : @discrete_topology.{0} (normed_comm_ring.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (normed_comm_ring.{0} name)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_27037 (h0 : ring (random_gen (linear_order char))) : rank_condition (random_gen (linear_order char)) := sorry --non-trivial
lemma new_lemma_27038 (h0 : group (linear_ordered_field (has_to_string num))) : group.fg (linear_ordered_field (has_to_string num)) := sorry --non-trivial
lemma new_lemma_27039 (h0 : functor.add_const (list (has_add Type)) linarith.comp) : palindrome (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_27040 (h1 : has_mem.mem (has_norm to_additive.value_type) has_emptyc.emptyc) : @totally_disconnected_space.{0} (has_norm.{0} to_additive.value_type) (@finset.pi.empty.{1 0} Type topological_space.{0} (has_norm.{0} to_additive.value_type) h1)  := sorry --non-trivial
lemma new_lemma_27041 (h0 : ring (random_gen (random_gen fun_info))) : strong_rank_condition (random_gen (random_gen fun_info)) := sorry --non-trivial
lemma new_lemma_27042 (h2 : uniform_space (has_compl to_additive.value_type)) : complete_space (has_compl to_additive.value_type) := sorry --non-trivial
lemma new_lemma_27043 (h0 : monoid (ordered_cancel_add_comm_monoid (option (option (option num))))) : monoid.fg (ordered_cancel_add_comm_monoid (option (option (option num)))) := sorry --non-trivial
lemma new_lemma_27044 (h0 : function.extfun (finset Type) (has_mem.mem (measurable_space empty))) : @totally_disconnected_space.{0} (measurable_space.{0} empty) (@finset.pi.empty.{1 0} Type topological_space.{0} (measurable_space.{0} empty) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (measurable_space.{0} empty)) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_27045 (h0 : function.extfun (random_gen fun_info) (fun (x : random_gen fun_info), Prop)) : Exists (function.extfun_app h0) := sorry --non-trivial
lemma new_lemma_27046 (h0 : function.extfun Type uniform_space) : @separated_space.{0} (linear_ordered_cancel_comm_monoid.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (linear_ordered_cancel_comm_monoid.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_27047 (h0 : group (topological_space (random_gen to_additive.value_type))) : group.fg (topological_space (random_gen to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_27048 (h0 : add_group (has_bot real)) : is_add_cyclic (has_bot real) := sorry --non-trivial
lemma new_lemma_27049 (h0 : function.extfun Type monoid) : @monoid.fg.{0} (canonically_ordered_add_monoid.{0} unsigned) (@function.extfun_app.{2 1} Type monoid.{0} h0 (canonically_ordered_add_monoid.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_27050 (h0 : functor.add_const Prop (has_zero environment.implicit_infer_kind)) : functor.add_const.run h0 := sorry --non-trivial
lemma new_lemma_27051 (h0 : add_monoid (semigroup linarith.comp)) : add_monoid.fg (semigroup linarith.comp) := sorry --non-trivial
lemma new_lemma_27052 (h0 : function.extfun Type topological_space) : @discrete_topology.{0} (has_one.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_one.{0} num))  := sorry --non-trivial
lemma new_lemma_27053 (h3 : topological_space (add_left_cancel_monoid (has_nnnorm fun_info))) : t0_space (add_left_cancel_monoid (has_nnnorm fun_info)) := sorry --non-trivial
lemma new_lemma_27054 (h0 : complete_lattice (random_gen char)) : complete_lattice.is_Sup_finite_compact (random_gen char) := sorry --non-trivial
lemma new_lemma_27055 (h0 : filter (cancel_monoid (option ennreal))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_27056 (h0 : group (add_comm_monoid (option ennreal))) : is_simple_group (add_comm_monoid (option ennreal)) := sorry --non-trivial
lemma new_lemma_27057 (h0 : functor.add_const (function.extfun (Type 1) group) pos) : @is_cyclic.{1} (complete_distrib_lattice.{1} Type) (@function.extfun_app.{3 2} (Type 1) group.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) group.{1}) pos h0) (complete_distrib_lattice.{1} Type))  := sorry --non-trivial
lemma new_lemma_27058 (h0 : functor.add_const (function.extfun Type uniform_space) (has_Inf linarith.comp)) : @separated_space.{0} (ring.{0} linarith.comp) (@function.extfun_app.{2 1} Type uniform_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type uniform_space.{0}) (has_Inf.{0} linarith.comp) h0) (ring.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_27059 (h0 : monoid (add_cancel_monoid environment.implicit_infer_kind)) : monoid.fg (add_cancel_monoid environment.implicit_infer_kind) := sorry --non-trivial
lemma new_lemma_27060 (h0 : not (topological_space (semi_normed_ring linarith.comp_source) -> false)) : @totally_disconnected_space.{0} (semi_normed_ring.{0} linarith.comp_source) (@classical.by_contradiction'.{1} (topological_space.{0} (semi_normed_ring.{0} linarith.comp_source)) h0)  := sorry --non-trivial
lemma new_lemma_27061 (h1 : complete_lattice (dlist (comm_ring linarith.ineq))) : complete_lattice.is_Sup_finite_compact (dlist (comm_ring linarith.ineq)) := sorry --non-trivial
lemma new_lemma_27062 (h0 : topological_space (finset (ring Type))) : preirreducible_space (finset (ring Type)) := sorry --non-trivial
lemma new_lemma_27063 (h0 : not (topological_space (has_nnnorm to_additive.value_type) -> false)) : @t0_space.{0} (has_nnnorm.{0} to_additive.value_type) (@classical.by_contradiction'.{1} (topological_space.{0} (has_nnnorm.{0} to_additive.value_type)) h0)  := sorry --non-trivial
lemma new_lemma_27064 (h0 : monoid (has_neg_part (has_add unsigned))) : monoid.fg (has_neg_part (has_add unsigned)) := sorry --non-trivial
lemma new_lemma_27065 (h0 : functor.add_const (complete_lattice (finset pos)) Type) : @is_atomistic.{0} (finset.{0} pos) (@functor.add_const.run.{0 1} (complete_lattice.{0} (finset.{0} pos)) Type h0)  := sorry --non-trivial
lemma new_lemma_27066 (h0 : function.extfun Type filter) : filter.ne_bot (function.extfun_app h0 (boolean_algebra environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_27067 (h0 : fin has_zero.zero) : @preconnected_space.{0} (ordered_comm_ring.{0} linarith.comp) (@matrix.vec_empty.{0} (topological_space.{0} (ordered_comm_ring.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_27068 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_add_cyclic.{0} (finset.{0} name) (@function.extfun_app.{2 1} Type add_group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 add_group.{0}) (finset.{0} name))  := sorry --non-trivial
lemma new_lemma_27069 (h0 : functor.comp topological_space mul_zero_class name) : @regular_space.{0} (mul_zero_class.{0} name) (@functor.comp.run.{0 0 0} topological_space.{0} mul_zero_class.{0} name h0)  := sorry --non-trivial
lemma new_lemma_27070 (h0 : ring (has_bot (canonically_linear_ordered_monoid real))) : rank_condition (has_bot (canonically_linear_ordered_monoid real)) := sorry --non-trivial
lemma new_lemma_27071 (h0 : complete_lattice (has_dist unsigned)) : complete_lattice.is_Sup_finite_compact (has_dist unsigned) := sorry --non-trivial
lemma new_lemma_27072 (h0 : monoid (has_add (add_comm_monoid pos))) : monoid.fg (has_add (add_comm_monoid pos)) := sorry --non-trivial
lemma new_lemma_27073 (h0 : functor.add_const (function.extfun Type ordered_comm_monoid) pos) : @has_exists_mul_of_le.{0} (has_add.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type ordered_comm_monoid.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type ordered_comm_monoid.{0}) pos h0) (has_add.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_27074 (h0 : function.extfun (Type 1) finset) : finset.nonempty (function.extfun_app h0 (cancel_monoid Type)) := sorry --non-trivial
lemma new_lemma_27075 (h0 : functor.add_const (group (normed_comm_ring name)) (boolean_algebra (has_neg_part environment.implicit_infer_kind))) : @is_cyclic.{0} (normed_comm_ring.{0} name) (@functor.add_const.run.{0 0} (group.{0} (normed_comm_ring.{0} name)) (boolean_algebra.{0} (has_neg_part.{0} environment.implicit_infer_kind)) h0)  := sorry --non-trivial
lemma new_lemma_27076 (h0 : function.extfun Type group) : @is_cyclic.{0} (non_assoc_semiring.{0} num) (@function.extfun_app.{2 1} Type group.{0} h0 (non_assoc_semiring.{0} num))  := sorry --non-trivial
lemma new_lemma_27077 (h0 : functor.add_const (topological_space (add_cancel_monoid Type)) linarith.comp) : @totally_separated_space.{1} (add_cancel_monoid.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (add_cancel_monoid.{1} Type)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_27078 (h0 : uniform_space (has_bot (has_neg name))) : separated_space (has_bot (has_neg name)) := sorry --non-trivial
lemma new_lemma_27079 (h0 : add_monoid (canonically_ordered_comm_semiring (ring linarith.comp))) : add_monoid.fg (canonically_ordered_comm_semiring (ring linarith.comp)) := sorry --non-trivial
lemma new_lemma_27080 (h0 : functor.add_const (topological_space (finset environment.implicit_infer_kind)) environment.implicit_infer_kind) : @locally_compact_space.{0} (finset.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (finset.{0} environment.implicit_infer_kind)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_27081 (h2 : uniform_space (with_one linarith.comp_source)) : complete_space (with_one linarith.comp_source) := sorry --non-trivial
lemma new_lemma_27082 (h0 : functor.add_const (ring (ring pos)) linarith.comp) : @rank_condition.{0} (ring.{0} pos) (@functor.add_const.run.{0 0} (ring.{0} (ring.{0} pos)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_27083 (h0 : finset (boolean_algebra.core ennreal)) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_27084 (h0 : topological_space (has_div (mul_one_class char))) : t0_space (has_div (mul_one_class char)) := sorry --non-trivial
lemma new_lemma_27085 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @t0_space.{0} (has_top.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_top.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_27086 (h0 : functor.add_const (complete_lattice (linear_ordered_comm_monoid_with_zero unsigned)) congr_arg_kind) : @is_atomistic.{0} (linear_ordered_comm_monoid_with_zero.{0} unsigned) (@functor.add_const.run.{0 0} (complete_lattice.{0} (linear_ordered_comm_monoid_with_zero.{0} unsigned)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_27087 (h0 : functor.add_const (uniform_space (boolean_algebra Type)) (has_Inf pos)) : @separated_space.{1} (boolean_algebra.{1} Type) (@functor.add_const.run.{1 0} (uniform_space.{1} (boolean_algebra.{1} Type)) (has_Inf.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_27088 (h0 : topological_space (boolean_algebra (finset (has_Inf (has_Inf (has_Inf (has_add pos))))))) : normal_space (boolean_algebra (finset (has_Inf (has_Inf (has_Inf (has_add pos)))))) := sorry --non-trivial
lemma new_lemma_27089 (h0 : group (has_top (semiring unsigned))) : normalizer_condition (has_top (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_27090 (h0 : ring (partial_order (semiring congr_arg_kind))) : strong_rank_condition (partial_order (semiring congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_27091 (h0 : function.extfun (Type 1) (functor.comp topological_space has_zero)) : @discrete_topology.{1} (has_zero.{1} Type) (@functor.comp.run.{1 1 1} topological_space.{1} has_zero.{1} Type (@function.extfun_app.{3 2} (Type 1) (functor.comp.{1 1 1} topological_space.{1} has_zero.{1}) h0 Type))  := sorry --non-trivial
lemma new_lemma_27092 (h0 : topological_space (ordered_comm_monoid (has_Inf linarith.comp))) : totally_separated_space (ordered_comm_monoid (has_Inf linarith.comp)) := sorry --non-trivial
lemma new_lemma_27093 (h0 : uniform_space (has_add (finset Type))) : separated_space (has_add (finset Type)) := sorry --non-trivial
lemma new_lemma_27094 (h0 : topological_space (measurable_space (has_inv fun_info))) : locally_compact_space (measurable_space (has_inv fun_info)) := sorry --non-trivial
lemma new_lemma_27095 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @preirreducible_space.{0} (monoid.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (monoid.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_27096 (h0 : has_mem.mem num has_emptyc.emptyc) : @strong_rank_condition.{0} num (@finset.pi.empty.{1 0} Type ring.{0} num h0)  := sorry --non-trivial
lemma new_lemma_27097 (h0 : topological_space (has_Inf (has_Inf pos))) : locally_compact_space (has_Inf (has_Inf pos)) := sorry --non-trivial
lemma new_lemma_27098 (h0 : topological_space (has_pos_part (has_add (has_add (has_pos_part pos))))) : sequential_space (has_pos_part (has_add (has_add (has_pos_part pos)))) := sorry --non-trivial
lemma new_lemma_27099 (h0 : not (group complex -> false)) : @is_cyclic.{0} complex (@classical.by_contradiction'.{1} (group.{0} complex) h0)  := sorry --non-trivial
lemma new_lemma_27100 (h0 : topological_space (add_comm_semigroup char)) (h2 : preorder (add_comm_semigroup char)) : order_topology (add_comm_semigroup char) := sorry --non-trivial
lemma new_lemma_27101 (h0 : group (mul_zero_class num)) : normalizer_condition (mul_zero_class num) := sorry --non-trivial
lemma new_lemma_27102 (h0 : topological_space (has_to_string (option (option pos)))) : irreducible_space (has_to_string (option (option pos))) := sorry --non-trivial
lemma new_lemma_27103 (h2 : ring (uniform_space to_additive.value_type)) : strong_rank_condition (uniform_space to_additive.value_type) := sorry --non-trivial
lemma new_lemma_27104 (h0 : ordered_comm_monoid (has_Inf (ordered_ring Type))) : has_exists_mul_of_le (has_Inf (ordered_ring Type)) := sorry --non-trivial
lemma new_lemma_27105 (h0 : functor.add_const (topological_space (as_linear_order num)) num) : @totally_separated_space.{0} (as_linear_order.{0} num) (@functor.add_const.run.{0 0} (topological_space.{0} (as_linear_order.{0} num)) num h0)  := sorry --non-trivial
lemma new_lemma_27106 (h0 : topological_space (linear_ordered_cancel_comm_monoid num)) : locally_compact_space (linear_ordered_cancel_comm_monoid num) := sorry --non-trivial
lemma new_lemma_27107 (h0 : topological_space (monoid (option pos))) : locally_compact_space (monoid (option pos)) := sorry --non-trivial
lemma new_lemma_27108 (h0 : monoid linarith.comp) : monoid.fg linarith.comp := sorry --non-trivial
lemma new_lemma_27109 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : palindrome (function.extfun_app (function.extfun_app h0 list) (add_semigroup empty)) := sorry --non-trivial
lemma new_lemma_27110 (h0 : group (has_dist (option (option (option unsigned))))) : normalizer_condition (has_dist (option (option (option unsigned)))) := sorry --non-trivial
lemma new_lemma_27111 (h0 : ordered_add_comm_monoid (has_bot Type)) : archimedean (has_bot Type) := sorry --non-trivial
lemma new_lemma_27112 (h0 : topological_space (normed_linear_ordered_group unsigned)) : totally_disconnected_space (normed_linear_ordered_group unsigned) := sorry --non-trivial
lemma new_lemma_27113 (h0 : functor.add_const (list (has_to_string Type)) Type) : palindrome (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_27114 (h0 : add_group (normed_group (semiring unsigned))) : is_add_cyclic (normed_group (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_27115 (h0 : functor.add_const (ring (has_nndist Type)) environment.implicit_infer_kind) : @strong_rank_condition.{1} (has_nndist.{1} Type) (@functor.add_const.run.{1 0} (ring.{1} (has_nndist.{1} Type)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_27116 (h0 : ring (has_emptyc (has_top to_additive.value_type))) : rank_condition (has_emptyc (has_top to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_27117 (h0 : topological_space (add_cancel_monoid (finset (finset linarith.comp)))) : topological_space.separable_space (add_cancel_monoid (finset (finset linarith.comp))) := sorry --non-trivial
lemma new_lemma_27118 (h0 : ordered_add_comm_monoid (generalized_boolean_algebra (ring (ring linarith.comp)))) : archimedean (generalized_boolean_algebra (ring (ring linarith.comp))) := sorry --non-trivial
lemma new_lemma_27119 (h0 : fin has_zero.zero) : matrix.vec_empty (matrix.vec_empty (matrix.vec_empty (matrix.vec_empty (matrix.vec_empty (id h0))))) := sorry --non-trivial
lemma new_lemma_27120 (h0 : topological_space (boolean_algebra.core (has_add (finset name)))) : normal_space (boolean_algebra.core (has_add (finset name))) := sorry --non-trivial
lemma new_lemma_27121 (h0 : function.extfun Type topological_space) : @normal_space.{0} (ordered_comm_ring.{0} real) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (ordered_comm_ring.{0} real))  := sorry --non-trivial
lemma new_lemma_27122 (h0 : function.extfun Type topological_space) : @totally_separated_space.{0} (canonically_ordered_comm_semiring.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (canonically_ordered_comm_semiring.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_27123 (h0 : ring (ordered_comm_monoid (has_add (finset (has_Inf linarith.comp))))) : is_domain (ordered_comm_monoid (has_add (finset (has_Inf linarith.comp)))) := sorry --non-trivial
lemma new_lemma_27124 (h0 : functor.add_const (topological_space (preorder num)) congr_arg_kind) : @t1_space.{0} (preorder.{0} num) (@functor.add_const.run.{0 0} (topological_space.{0} (preorder.{0} num)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_27125 (h0 : not (uniform_space (topological_space fun_info) -> false)) : @complete_space.{0} (topological_space.{0} fun_info) (@classical.by_contradiction'.{1} (uniform_space.{0} (topological_space.{0} fun_info)) h0)  := sorry --non-trivial
lemma new_lemma_27126 (h0 : function.extfun Type topological_space) : @loc_path_connected_space.{0} (sub_neg_monoid.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (sub_neg_monoid.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_27127 (h0 : function.extfun Type topological_space) : @t0_space.{0} (has_neg.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_neg.{0} pos))  := sorry --non-trivial
lemma new_lemma_27128 (h0 : functor.add_const (ring (has_nndist (has_neg_part pos))) name) : @is_domain.{0} (has_nndist.{0} (has_neg_part.{0} pos)) (@functor.add_const.run.{0 0} (ring.{0} (has_nndist.{0} (has_neg_part.{0} pos))) name h0)  := sorry --non-trivial
lemma new_lemma_27129 (h0 : functor.add_const (list (has_zero pos)) pos) : list.nodup (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_27130 (h0 : finset (finset empty)) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_27131 (h0 : filter (comm_group (has_to_string pos))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_27132 (h0 : add_group (topological_space (has_nnnorm (has_nnnorm (has_nnnorm string_imp))))) : is_add_cyclic (topological_space (has_nnnorm (has_nnnorm (has_nnnorm string_imp)))) := sorry --non-trivial
lemma new_lemma_27133 (h0 : functor.add_const (topological_space (semigroup congr_arg_kind)) num) : @t1_space.{0} (semigroup.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (semigroup.{0} congr_arg_kind)) num h0)  := sorry --non-trivial
lemma new_lemma_27134 (h0 : function.extfun Type add_monoid) : @add_monoid.fg.{0} (has_nndist.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type add_monoid.{0} h0 (has_nndist.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_27135 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @irreducible_space.{0} (has_inter.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_inter.{0} empty))  := sorry --non-trivial
lemma new_lemma_27136 (h0 : topological_space (has_bot (finset real))) : discrete_topology (has_bot (finset real)) := sorry --non-trivial
lemma new_lemma_27137 (h0 : functor.add_const (filter (ring pos)) linarith.comp) : countable_Inter_filter (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_27138 (h0 : functor.add_const (topological_space (finset environment.implicit_infer_kind)) Type) : @discrete_topology.{0} (finset.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 1} (topological_space.{0} (finset.{0} environment.implicit_infer_kind)) Type h0)  := sorry --non-trivial
lemma new_lemma_27139 (h0 : cancel_comm_monoid_with_zero (ring (has_to_string (has_neg_part unsigned)))) : unique_factorization_monoid (ring (has_to_string (has_neg_part unsigned))) := sorry --non-trivial
lemma new_lemma_27140 (h0 : complete_lattice (has_lt reducibility_hints)) : is_compactly_generated (has_lt reducibility_hints) := sorry --non-trivial
lemma new_lemma_27141 (h0 : uniform_space (has_top (has_norm fun_info))) : separated_space (has_top (has_norm fun_info)) := sorry --non-trivial
lemma new_lemma_27142 (h0 : function.extfun Type topological_space) : @irreducible_space.{0} (linear_ordered_semiring.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (linear_ordered_semiring.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_27143 (h0 : uniform_space (has_add name)) : complete_space (has_add name) := sorry --non-trivial
lemma new_lemma_27144 (h0 : topological_space (option pos)) : topological_space.separable_space (option pos) := sorry --non-trivial
lemma new_lemma_27145 (h0 : add_monoid (has_union (has_top congr_arg_kind))) : add_monoid.fg (has_union (has_top congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_27146 (h2 : add_group (comm_ring linarith.comp_source)) : is_add_cyclic (comm_ring linarith.comp_source) := sorry --non-trivial
lemma new_lemma_27147 (h0 : uniform_space (dlist (has_inv (has_inv (has_inv string_imp))))) : complete_space (dlist (has_inv (has_inv (has_inv string_imp)))) := sorry --non-trivial
lemma new_lemma_27148 (h0 : not (group (normed_linear_ordered_group linarith.ineq) -> false)) : @group.fg.{0} (normed_linear_ordered_group.{0} linarith.ineq) (@classical.by_contradiction'.{1} (group.{0} (normed_linear_ordered_group.{0} linarith.ineq)) h0)  := sorry --non-trivial
lemma new_lemma_27149 (h0 : functor.add_const (function.extfun Type topological_space) linarith.comp) : @loc_path_connected_space.{0} (ring.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) linarith.comp h0) (ring.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_27150 (h0 : topological_space (has_emptyc (random_gen (random_gen linarith.ineq)))) : totally_separated_space (has_emptyc (random_gen (random_gen linarith.ineq))) := sorry --non-trivial
lemma new_lemma_27151 (h0 : functor.add_const (monoid (add_cancel_monoid pos)) Type) : @monoid.fg.{0} (add_cancel_monoid.{0} pos) (@functor.add_const.run.{0 1} (monoid.{0} (add_cancel_monoid.{0} pos)) Type h0)  := sorry --non-trivial
lemma new_lemma_27152 (h0 h1 : multiset (has_compl fun_info)) : multiset.disjoint h0 h1 := sorry --non-trivial
lemma new_lemma_27153 (h0 : not (group (has_one unsigned) -> false)) : @normalizer_condition.{0} (has_one.{0} unsigned) (@classical.by_contradiction'.{1} (group.{0} (has_one.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_27154 (h2 : topological_space (has_compl linarith.ineq)) : t0_space (has_compl linarith.ineq) := sorry --non-trivial
lemma new_lemma_27155 (h0 : not (ring (linear_ordered_semiring linarith.comp) -> false)) : @rank_condition.{0} (linear_ordered_semiring.{0} linarith.comp) (@classical.by_contradiction'.{1} (ring.{0} (linear_ordered_semiring.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_27156 (h0 : not (function.extfun Type topological_space -> false)) : @irreducible_space.{0} (has_top.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (has_top.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_27157 (h0 : topological_space (ring (has_Inf (has_add (has_Inf pos))))) : path_connected_space (ring (has_Inf (has_add (has_Inf pos)))) := sorry --non-trivial
lemma new_lemma_27158 (h0 : function.extfun Type group) : @is_simple_group.{0} (add_comm_monoid.{0} pos) (@function.extfun_app.{2 1} Type group.{0} h0 (add_comm_monoid.{0} pos))  := sorry --non-trivial
lemma new_lemma_27159 (h0 : topological_space (complete_linear_order num)) : locally_compact_space (complete_linear_order num) := sorry --non-trivial
lemma new_lemma_27160 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @t1_space.{0} (pseudo_metric_space.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (pseudo_metric_space.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_27161 (h0 : group (has_zero (comm_group name))) : normalizer_condition (has_zero (comm_group name)) := sorry --non-trivial
lemma new_lemma_27162 (h0 : topological_space (random_gen (with_bot linarith.ineq))) : totally_separated_space (random_gen (with_bot linarith.ineq)) := sorry --non-trivial
lemma new_lemma_27163 (h0 : functor.add_const (topological_space (add_comm_monoid Type)) Type) : @t1_space.{1} (add_comm_monoid.{1} Type) (@functor.add_const.run.{1 1} (topological_space.{1} (add_comm_monoid.{1} Type)) Type h0)  := sorry --non-trivial
lemma new_lemma_27164 (h0 : cancel_comm_monoid_with_zero (canonically_ordered_comm_semiring (option ennreal))) : unique_factorization_monoid (canonically_ordered_comm_semiring (option ennreal)) := sorry --non-trivial
lemma new_lemma_27165 (h0 : boolean_algebra.core pos -> boolean_algebra.core pos -> Prop) : is_symm (boolean_algebra.core pos) h0 := sorry --non-trivial
lemma new_lemma_27166 (h0 : list (ordered_semiring congr_arg_kind)) : palindrome h0 := sorry --non-trivial
lemma new_lemma_27167 (h0 : function.extfun (finset (Type -> Type)) (has_mem.mem topological_space)) : @irreducible_space.{0} (@id.{2} Type unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) topological_space.{0} (@function.extfun_app.{2 0} (finset.{1} (Type → Type)) (@has_mem.mem.{1 1} (Type → Type) (finset.{1} (Type → Type)) (@finset.has_mem.{1} (Type → Type)) topological_space.{0}) h0 (@has_emptyc.emptyc.{1} (finset.{1} (Type → Type)) (@finset.has_emptyc.{1} (Type → Type))))) (@id.{2} Type unsigned))  := sorry --non-trivial
lemma new_lemma_27168 (h1 : topological_space (distrib_lattice (random_gen (random_gen char)))) : t0_space (distrib_lattice (random_gen (random_gen char))) := sorry --non-trivial
lemma new_lemma_27169 (h0 : znum -> znum -> Prop) : is_antisymm znum h0 := sorry --non-trivial
lemma new_lemma_27170 (h0 : group (add_left_cancel_semigroup num)) : is_cyclic (add_left_cancel_semigroup num) := sorry --non-trivial
lemma new_lemma_27171 (h0 : functor.add_const (ring (semigroup pos)) Type) : @is_principal_ideal_ring.{0} (semigroup.{0} pos) (@functor.add_const.run.{0 1} (ring.{0} (semigroup.{0} pos)) Type h0)  := sorry --non-trivial
lemma new_lemma_27172 (h0 : finset (sub_neg_monoid (has_Inf Type))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_27173 (h0 : add_comm_semigroup enat -> add_comm_semigroup enat -> add_comm_semigroup enat) (h1 : add_comm_semigroup enat) : right_identity h0 h1 := sorry --non-trivial
lemma new_lemma_27174 (h0 : uniform_space (with_one (has_norm empty))) : separated_space (with_one (has_norm empty)) := sorry --non-trivial
lemma new_lemma_27175 (h0 : ring (uniform_space ennreal)) : strong_rank_condition (uniform_space ennreal) := sorry --non-trivial
lemma new_lemma_27176 (h0 : uniform_space (with_one (with_bot (measurable_space linarith.comp_source)))) : complete_space (with_one (with_bot (measurable_space linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_27177 (h1 : topological_space (semi_normed_ring linarith.ineq)) (h2 : preorder (semi_normed_ring linarith.ineq)) : order_topology (semi_normed_ring linarith.ineq) := sorry --non-trivial
lemma new_lemma_27178 (h0 : topological_space (complete_distrib_lattice (has_neg (ring linarith.comp)))) : regular_space (complete_distrib_lattice (has_neg (ring linarith.comp))) := sorry --non-trivial
lemma new_lemma_27179 (h0 : list (boolean_algebra.core (has_add (has_add (ring pos))))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_27180 (h0 : topological_space (has_ssubset reducibility_hints)) : totally_disconnected_space (has_ssubset reducibility_hints) := sorry --non-trivial
lemma new_lemma_27181 (h0 : ring (fintype to_additive.value_type)) : rank_condition (fintype to_additive.value_type) := sorry --non-trivial
lemma new_lemma_27182 (h0 : ring (has_neg (has_pos_part pos))) : is_domain (has_neg (has_pos_part pos)) := sorry --non-trivial
lemma new_lemma_27183 (h0 : semiring (add_group (semiring num))) : is_noetherian_ring (add_group (semiring num)) := sorry --non-trivial
lemma new_lemma_27184 (h0 : topological_space (has_add (finset linarith.comp))) : normal_space (has_add (finset linarith.comp)) := sorry --non-trivial
lemma new_lemma_27185 (h0 : function.extfun Type ring) : @rank_condition.{0} (add_comm_monoid.{0} num) (@function.extfun_app.{2 1} Type ring.{0} h0 (add_comm_monoid.{0} num))  := sorry --non-trivial
lemma new_lemma_27186 (h0 : functor.add_const (group (finset ennreal)) name) : @group.fg.{0} (finset.{0} ennreal) (@functor.add_const.run.{0 0} (group.{0} (finset.{0} ennreal)) name h0)  := sorry --non-trivial
lemma new_lemma_27187 (h0 : topological_space (boolean_algebra (has_pos_part linarith.comp))) : loc_path_connected_space (boolean_algebra (has_pos_part linarith.comp)) := sorry --non-trivial
lemma new_lemma_27188 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @separated_space.{0} (simple_graph.{0} pos) (@function.extfun_app.{2 1} Type uniform_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 uniform_space.{0}) (simple_graph.{0} pos))  := sorry --non-trivial
lemma new_lemma_27189 (h0 : functor.add_const (function.extfun nat fin) real) : @sequential_space.{1} (add_comm_monoid.{1} Type) (@matrix.vec_empty.{1} (topological_space.{1} (add_comm_monoid.{1} Type)) (@matrix.vec_empty.{0} (fin (@has_zero.zero.{0} nat nat.has_zero)) (@function.extfun_app.{1 1} nat fin (@functor.add_const.run.{0 0} (function.extfun.{1 1} nat fin) real h0) (@has_zero.zero.{0} nat nat.has_zero))))  := sorry --non-trivial
lemma new_lemma_27190 (h0 : filter (has_Inf (finset linarith.comp))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_27191 (h0 : complete_lattice (mul_zero_class (semiring congr_arg_kind))) : is_atomistic (mul_zero_class (semiring congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_27192 (h0 : complete_lattice (has_emptyc (has_top (has_top (has_inv linarith.comp_source))))) : is_compactly_generated (has_emptyc (has_top (has_top (has_inv linarith.comp_source)))) := sorry --non-trivial
lemma new_lemma_27193 (h0 : has_mem.mem (id linarith.comp_source) has_emptyc.emptyc) : @totally_disconnected_space.{0} (@id.{2} Type linarith.comp_source) (@finset.pi.empty.{1 0} Type topological_space.{0} (@id.{2} Type linarith.comp_source) h0)  := sorry --non-trivial
lemma new_lemma_27194 (h0 : ring (has_ssubset (comm_ring reducibility_hints))) : strong_rank_condition (has_ssubset (comm_ring reducibility_hints)) := sorry --non-trivial
lemma new_lemma_27195 (h0 : uniform_space (normed_lattice_add_comm_group (ring (has_Inf (finset linarith.comp))))) : separated_space (normed_lattice_add_comm_group (ring (has_Inf (finset linarith.comp)))) := sorry --non-trivial
lemma new_lemma_27196 (h0 : add_monoid (semigroup (semiring (semiring (semiring num))))) : add_monoid.fg (semigroup (semiring (semiring (semiring num)))) := sorry --non-trivial
lemma new_lemma_27197 (h0 : topological_space (topological_space (has_ssubset string_imp))) : path_connected_space (topological_space (has_ssubset string_imp)) := sorry --non-trivial
lemma new_lemma_27198 (h0 : not (function.extfun Type uniform_space -> false)) : @complete_space.{0} (complete_semilattice_Sup.{0} empty) (@function.extfun_app.{2 1} Type uniform_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type uniform_space.{0}) h0) (complete_semilattice_Sup.{0} empty))  := sorry --non-trivial
lemma new_lemma_27199 (h0 : not (ring (has_nnnorm linarith.comp_source) -> false)) : @rank_condition.{0} (has_nnnorm.{0} linarith.comp_source) (@classical.by_contradiction'.{1} (ring.{0} (has_nnnorm.{0} linarith.comp_source)) h0)  := sorry --non-trivial
lemma new_lemma_27200 (h0 : function.extfun Type topological_space) : @t0_space.{0} (add_comm_monoid.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (add_comm_monoid.{0} empty))  := sorry --non-trivial
lemma new_lemma_27201 (h0 : add_group (normed_lattice_add_comm_group (has_neg (has_neg (has_neg (has_neg pos)))))) : is_add_cyclic (normed_lattice_add_comm_group (has_neg (has_neg (has_neg (has_neg pos))))) := sorry --non-trivial
lemma new_lemma_27202 (h0 : topological_space (add_left_cancel_semigroup (option (option empty)))) : t1_space (add_left_cancel_semigroup (option (option empty))) := sorry --non-trivial
lemma new_lemma_27203 (h0 : list (boolean_algebra (ring (finset pos)))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_27204 (h0 : topological_space (comm_ring (has_nnnorm char))) : locally_compact_space (comm_ring (has_nnnorm char)) := sorry --non-trivial
lemma new_lemma_27205 (h0 : functor.comp uniform_space has_neg name) : @separated_space.{0} (has_neg.{0} name) (@functor.comp.run.{0 0 0} uniform_space.{0} has_neg.{0} name h0)  := sorry --non-trivial
lemma new_lemma_27206 (h0 : topological_space (pseudo_metric_space (finset (finset pos)))) : preconnected_space (pseudo_metric_space (finset (finset pos))) := sorry --non-trivial
lemma new_lemma_27207 (h0 : functor.add_const (topological_space (has_to_string pos)) num) : @normal_space.{0} (has_to_string.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (has_to_string.{0} pos)) num h0)  := sorry --non-trivial
lemma new_lemma_27208 (h0 : not (ring (has_to_string to_additive.value_type) -> false)) : @is_domain.{0} (has_to_string.{0} to_additive.value_type) (@classical.by_contradiction'.{1} (ring.{0} (has_to_string.{0} to_additive.value_type)) h0)  := sorry --non-trivial
lemma new_lemma_27209 (h0 : not (ring (normed_field char) -> false)) : @is_domain.{0} (normed_field.{0} char) (@classical.by_contradiction'.{1} (ring.{0} (normed_field.{0} char)) h0)  := sorry --non-trivial
lemma new_lemma_27210 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @locally_compact_space.{0} (with_one.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (with_one.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_27211 (h0 : function.extfun Type group) : @normalizer_condition.{0} (filter.{0} unsigned) (@function.extfun_app.{2 1} Type group.{0} h0 (filter.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_27212 (h0 : measurable_space char) (h1 : has_mul char) : has_measurable_mul₂ char := sorry --non-trivial
lemma new_lemma_27213 (h1 : function.extfun (Type -> Type) (function.extfun Type)) : @totally_separated_space.{0} (with_bot.{0} string_imp) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h1 topological_space.{0}) (with_bot.{0} string_imp))  := sorry --non-trivial
lemma new_lemma_27214 (h0 : not (ring (has_nnnorm reducibility_hints) -> false)) : @strong_rank_condition.{0} (has_nnnorm.{0} reducibility_hints) (@classical.by_contradiction'.{1} (ring.{0} (has_nnnorm.{0} reducibility_hints)) h0)  := sorry --non-trivial
lemma new_lemma_27215 (h0 : functor.add_const (list (linear_order empty)) empty) : list.nodup (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_27216 (h0 : topological_space (semiring (has_top (semiring (has_norm empty))))) : discrete_topology (semiring (has_top (semiring (has_norm empty)))) := sorry --non-trivial
lemma new_lemma_27217 (h0 : fin has_zero.zero) : @complete_lattice.is_Sup_finite_compact.{0} (generalized_boolean_algebra.{0} name) (@matrix.vec_empty.{0} (complete_lattice.{0} (generalized_boolean_algebra.{0} name)) h0)  := sorry --non-trivial
lemma new_lemma_27218 (h1 : topological_space (random_gen (comm_ring (comm_ring reducibility_hints)))) : t0_space (random_gen (comm_ring (comm_ring reducibility_hints))) := sorry --non-trivial
lemma new_lemma_27219 (h0 : ordered_comm_monoid (has_to_string (has_neg_part (has_neg_part pos)))) : has_exists_mul_of_le (has_to_string (has_neg_part (has_neg_part pos))) := sorry --non-trivial
lemma new_lemma_27220 (h0 : group (finset (cancel_monoid (finset ennreal)))) : is_simple_group (finset (cancel_monoid (finset ennreal))) := sorry --non-trivial
lemma new_lemma_27221 (h0 : functor.add_const (topological_space (boolean_algebra linarith.comp)) Type) : @loc_path_connected_space.{0} (boolean_algebra.{0} linarith.comp) (@functor.add_const.run.{0 1} (topological_space.{0} (boolean_algebra.{0} linarith.comp)) Type h0)  := sorry --non-trivial
lemma new_lemma_27222 (h0 : function.extfun (Type 1) topological_space) : @discrete_topology.{1} (normed_lattice_add_comm_group.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} h0 (normed_lattice_add_comm_group.{1} Type))  := sorry --non-trivial
lemma new_lemma_27223 (h0 : topological_space (canonically_ordered_comm_semiring (has_add Type))) : path_connected_space (canonically_ordered_comm_semiring (has_add Type)) := sorry --non-trivial
lemma new_lemma_27224 (h0 : topological_space (has_nnnorm (has_top fun_info))) : locally_compact_space (has_nnnorm (has_top fun_info)) := sorry --non-trivial
lemma new_lemma_27225 (h0 : topological_space (normed_comm_ring (has_Inf (has_Inf (has_neg (has_nndist linarith.comp)))))) : locally_compact_space (normed_comm_ring (has_Inf (has_Inf (has_neg (has_nndist linarith.comp))))) := sorry --non-trivial
lemma new_lemma_27226 (h0 : not (topological_space (metric_space char) -> false)) : @t0_space.{0} (metric_space.{0} char) (@classical.by_contradiction'.{1} (topological_space.{0} (metric_space.{0} char)) h0)  := sorry --non-trivial
lemma new_lemma_27227 (h0 : functor.add_const (functor.add_const (topological_space environment.implicit_infer_kind) Type) Type) : @locally_compact_space.{0} environment.implicit_infer_kind (@functor.add_const.run.{0 1} (topological_space.{0} environment.implicit_infer_kind) Type (@functor.add_const.run.{0 1} (functor.add_const.{0 1} (topological_space.{0} environment.implicit_infer_kind) Type) Type h0))  := sorry --non-trivial
lemma new_lemma_27228 (h0 : functor.add_const (list (mul_zero_class environment.implicit_infer_kind)) unsigned) : palindrome (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_27229 (h0 : function.extfun Type (functor.add_const (monoid (left_cancel_monoid unsigned)))) : @monoid.fg.{0} (left_cancel_monoid.{0} unsigned) (@functor.add_const.run.{0 0} (monoid.{0} (left_cancel_monoid.{0} unsigned)) (option.{0} (option.{0} (option.{0} unsigned))) (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (monoid.{0} (left_cancel_monoid.{0} unsigned))) h0 (option.{0} (option.{0} (option.{0} unsigned)))))  := sorry --non-trivial
lemma new_lemma_27230 (h0 : prod (normed_comm_ring (option (option pos))) (normed_comm_ring (option (option pos)))) : id_rel h0 := sorry --non-trivial
lemma new_lemma_27231 (h0 : group (filter (semiring empty))) : normalizer_condition (filter (semiring empty)) := sorry --non-trivial
lemma new_lemma_27232 (h0 : fun_info -> fun_info -> Prop) (h1 : set fun_info) : set.unbounded h0 h1 := sorry --non-trivial
lemma new_lemma_27233 (h1 : has_mem.mem group has_emptyc.emptyc) : @normalizer_condition.{0} (complete_semilattice_Sup.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type group.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) group.{0} h1) (complete_semilattice_Sup.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_27234 (h0 : uniform_space (topological_space (has_ssubset (random_gen (has_ssubset (has_ssubset char)))))) : complete_space (topological_space (has_ssubset (random_gen (has_ssubset (has_ssubset char))))) := sorry --non-trivial
lemma new_lemma_27235 (h0 : group (finset unsigned)) : is_simple_group (finset unsigned) := sorry --non-trivial
lemma new_lemma_27236 (h0 : filter (has_nndist (finset (finset (finset environment.implicit_infer_kind))))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_27237 (h0 : group (omega_complete_partial_order (option empty))) : normalizer_condition (omega_complete_partial_order (option empty)) := sorry --non-trivial
lemma new_lemma_27238 (h0 : topological_space (mul_zero_class (has_add ennreal))) : preirreducible_space (mul_zero_class (has_add ennreal)) := sorry --non-trivial
lemma new_lemma_27239 (h0 : ring (add_cancel_monoid (has_nndist linarith.comp))) : rank_condition (add_cancel_monoid (has_nndist linarith.comp)) := sorry --non-trivial
lemma new_lemma_27240 (h2 : complete_lattice (semi_normed_ring (comm_ring char))) : is_compactly_generated (semi_normed_ring (comm_ring char)) := sorry --non-trivial
lemma new_lemma_27241 (h0 : function.extfun (nat -> Type) (function.extfun nat)) : @is_add_cyclic.{0} (sub_neg_monoid.{0} linarith.comp) (@matrix.vec_empty.{0} (add_group.{0} (sub_neg_monoid.{0} linarith.comp)) (@function.extfun_app.{1 1} nat fin (@function.extfun_app.{2 1} (nat → Type) (function.extfun.{1 1} nat) h0 fin) (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_27242 (h0 : group (finset (has_Inf linarith.comp))) : is_cyclic (finset (has_Inf linarith.comp)) := sorry --non-trivial
lemma new_lemma_27243 (h0 : functor.add_const (semiring pos) Type) : @is_noetherian_ring.{0} pos (@functor.add_const.run.{0 1} (semiring.{0} pos) Type h0)  := sorry --non-trivial
lemma new_lemma_27244 (h0 : functor.add_const (function.extfun (Type 1) topological_space) pos) : @preconnected_space.{1} (semigroup.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) topological_space.{1}) pos h0) (semigroup.{1} Type))  := sorry --non-trivial
lemma new_lemma_27245 (h0 : functor.add_const (finset (has_nndist linarith.comp)) Type) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_27246 (h0 : filter (with_bot linarith.comp)) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_27247 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @normalizer_condition.{0} (simple_graph.{0} pos) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (simple_graph.{0} pos))  := sorry --non-trivial
lemma new_lemma_27248 (h1 : list (has_emptyc linarith.comp_source)) : list.nodup h1 := sorry --non-trivial
lemma new_lemma_27249 (h0 : filter (has_zero unsigned)) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_27250 (h0 : ring real) : is_principal_ideal_ring real := sorry --non-trivial
lemma new_lemma_27251 (h0 : functor.add_const (ring (ordered_comm_monoid linarith.comp)) (ring pos)) : @rank_condition.{0} (ordered_comm_monoid.{0} linarith.comp) (@functor.add_const.run.{0 0} (ring.{0} (ordered_comm_monoid.{0} linarith.comp)) (ring.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_27252 (h0 : functor.add_const (topological_space (has_Sup congr_arg_kind)) congr_arg_kind) : @locally_compact_space.{0} (has_Sup.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (has_Sup.{0} congr_arg_kind)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_27253 (h0 : ring (parser (random_gen to_additive.value_type))) : rank_condition (parser (random_gen to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_27254 (h0 : topological_space subsingleton_info) : preirreducible_space subsingleton_info := sorry --non-trivial
lemma new_lemma_27255 (h0 : fin has_zero.zero) : nat.perfect (id (matrix.vec_empty h0)) := sorry --non-trivial
lemma new_lemma_27256 (h0 : functor.add_const (topological_space (canonically_ordered_comm_semiring ennreal)) ennreal) : @t1_space.{0} (canonically_ordered_comm_semiring.{0} ennreal) (@functor.add_const.run.{0 0} (topological_space.{0} (canonically_ordered_comm_semiring.{0} ennreal)) ennreal h0)  := sorry --non-trivial
lemma new_lemma_27257 (h0 : functor.add_const (topological_space (complete_distrib_lattice pos)) environment.implicit_infer_kind) : @irreducible_space.{0} (complete_distrib_lattice.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (complete_distrib_lattice.{0} pos)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_27258 (h0 : topological_space (generalized_boolean_algebra Type)) : preirreducible_space (generalized_boolean_algebra Type) := sorry --non-trivial
lemma new_lemma_27259 (h0 : function.extfun Type topological_space) : @normal_space.{0} (add_group.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (add_group.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_27260 (h0 : functor.add_const (functor.add_const (topological_space Type) pos) Type) : @locally_compact_space.{1} Type (@functor.add_const.run.{1 0} (topological_space.{1} Type) pos (@functor.add_const.run.{1 1} (functor.add_const.{1 0} (topological_space.{1} Type) pos) Type h0))  := sorry --non-trivial
lemma new_lemma_27261 (h0 : functor.add_const (list (semigroup pos)) (has_zero environment.implicit_infer_kind)) : palindrome (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_27262 (h0 : group (has_emptyc fun_info)) : normalizer_condition (has_emptyc fun_info) := sorry --non-trivial
lemma new_lemma_27263 (h0 : topological_space (canonically_ordered_comm_semiring (comm_group unsigned))) : preconnected_space (canonically_ordered_comm_semiring (comm_group unsigned)) := sorry --non-trivial
lemma new_lemma_27264 (h0 : topological_space (linear_order (semiring (semiring (semiring (semiring (semiring (semiring num)))))))) : normal_space (linear_order (semiring (semiring (semiring (semiring (semiring (semiring num))))))) := sorry --non-trivial
lemma new_lemma_27265 (h0 : not (topological_space (has_inv to_additive.value_type) -> false)) : @t0_space.{0} (has_inv.{0} to_additive.value_type) (@classical.by_contradiction'.{1} (topological_space.{0} (has_inv.{0} to_additive.value_type)) h0)  := sorry --non-trivial
lemma new_lemma_27266 (h0 : complete_lattice (add_cancel_monoid (has_neg name))) : is_compactly_generated (add_cancel_monoid (has_neg name)) := sorry --non-trivial
lemma new_lemma_27267 (h0 : ordered_add_comm_monoid (has_pos_part real)) : archimedean (has_pos_part real) := sorry --non-trivial
lemma new_lemma_27268 (h0 : not (topological_space (has_union num) -> false)) : @normal_space.{0} (has_union.{0} num) (@classical.by_contradiction'.{1} (topological_space.{0} (has_union.{0} num)) h0)  := sorry --non-trivial
lemma new_lemma_27269 (h0 : group (linear_ordered_semiring (has_norm fun_info))) : is_cyclic (linear_ordered_semiring (has_norm fun_info)) := sorry --non-trivial
lemma new_lemma_27270 (h0 : functor.add_const (complete_lattice (has_neg_part Type)) (cancel_monoid (has_neg_part pos))) : @is_compactly_generated.{1} (has_neg_part.{1} Type) (@functor.add_const.run.{1 0} (complete_lattice.{1} (has_neg_part.{1} Type)) (cancel_monoid.{0} (has_neg_part.{0} pos)) h0)  := sorry --non-trivial
lemma new_lemma_27271 (h0 : group (ordered_comm_ring (has_neg linarith.comp))) : is_cyclic (ordered_comm_ring (has_neg linarith.comp)) := sorry --non-trivial
lemma new_lemma_27272 (h0 : functor.add_const (group (has_to_string linarith.comp)) (finset pos)) : @is_simple_group.{0} (has_to_string.{0} linarith.comp) (@functor.add_const.run.{0 0} (group.{0} (has_to_string.{0} linarith.comp)) (finset.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_27273 (h0 : functor.add_const (topological_space (canonically_ordered_comm_semiring unsigned)) pos) : @normal_space.{0} (canonically_ordered_comm_semiring.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (canonically_ordered_comm_semiring.{0} unsigned)) pos h0)  := sorry --non-trivial
lemma new_lemma_27274 (h0 : functor.add_const (group (plift unsigned)) num) : @is_cyclic.{1} (plift.{1} unsigned) (@functor.add_const.run.{1 0} (group.{1} (plift.{1} unsigned)) num h0)  := sorry --non-trivial
lemma new_lemma_27275 (h0 : uniform_space (distrib_lattice to_additive.value_type)) : complete_space (distrib_lattice to_additive.value_type) := sorry --non-trivial
lemma new_lemma_27276 (h1 : add_comm_semigroup std_gen -> add_comm_semigroup std_gen -> Prop) (h2 : list (add_comm_semigroup std_gen)) : list.chain' h1 h2 := sorry --non-trivial
lemma new_lemma_27277 (h0 : function.extfun Type (functor.comp uniform_space has_nndist)) : @complete_space.{0} (has_nndist.{0} name) (@functor.comp.run.{0 0 0} uniform_space.{0} has_nndist.{0} name (@function.extfun_app.{2 1} Type (functor.comp.{0 0 0} uniform_space.{0} has_nndist.{0}) h0 name))  := sorry --non-trivial
lemma new_lemma_27278 (h0 : complete_lattice (add_cancel_comm_monoid (has_nnnorm char))) : is_compactly_generated (add_cancel_comm_monoid (has_nnnorm char)) := sorry --non-trivial
lemma new_lemma_27279 (h0 : topological_space (has_nndist environment.implicit_infer_kind)) : preconnected_space (has_nndist environment.implicit_infer_kind) := sorry --non-trivial
lemma new_lemma_27280 (h0 : functor.add_const (ring (has_star empty)) empty) : @is_domain.{0} (has_star.{0} empty) (@functor.add_const.run.{0 0} (ring.{0} (has_star.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_27281 (h0 : functor.add_const (add_group (finset Type)) pos) : @is_add_cyclic.{1} (finset.{1} Type) (@functor.add_const.run.{1 0} (add_group.{1} (finset.{1} Type)) pos h0)  := sorry --non-trivial
lemma new_lemma_27282 (h0 : functor.comp topological_space has_to_string environment.implicit_infer_kind) : @irreducible_space.{0} (has_to_string.{0} environment.implicit_infer_kind) (@functor.comp.run.{0 0 0} topological_space.{0} has_to_string.{0} environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_27283 (h0 : ordered_add_comm_monoid (has_pos_part (ring (has_Inf (has_Inf (ring name)))))) : archimedean (has_pos_part (ring (has_Inf (has_Inf (ring name))))) := sorry --non-trivial
lemma new_lemma_27284 (h0 : functor.add_const (list (has_Sup unsigned)) unsigned) : palindrome (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_27285 (h0 : topological_space (has_ssubset (has_nnnorm (random_gen char)))) : locally_compact_space (has_ssubset (has_nnnorm (random_gen char))) := sorry --non-trivial
lemma new_lemma_27286 (h0 : has_mem.mem topological_space has_emptyc.emptyc) : @discrete_topology.{0} (semiring.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) topological_space.{0} h0) (semiring.{0} num))  := sorry --non-trivial
lemma new_lemma_27287 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : list.nodup (function.extfun_app (function.extfun_app h0 list) (has_Inf Type)) := sorry --non-trivial
lemma new_lemma_27288 (h0 : functor.add_const (topological_space (finset ennreal)) Type) : @normal_space.{0} (finset.{0} ennreal) (@functor.add_const.run.{0 1} (topological_space.{0} (finset.{0} ennreal)) Type h0)  := sorry --non-trivial
lemma new_lemma_27289 (h0 : functor.add_const (topological_space (has_zero linarith.comp)) (has_neg_part linarith.comp)) : @path_connected_space.{0} (has_zero.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (has_zero.{0} linarith.comp)) (has_neg_part.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_27290 (h0 : function.extfun Type topological_space) : @path_connected_space.{0} (has_Sup.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_Sup.{0} num))  := sorry --non-trivial
lemma new_lemma_27291 (h0 : functor.add_const (function.extfun (Type 1) group) Type) : @group.fg.{1} (has_zero.{1} Type) (@function.extfun_app.{3 2} (Type 1) group.{1} (@functor.add_const.run.{2 1} (function.extfun.{3 2} (Type 1) group.{1}) Type h0) (has_zero.{1} Type))  := sorry --non-trivial
lemma new_lemma_27292 (h0 : functor.add_const (topological_space (ring linarith.comp)) Type) : @path_connected_space.{0} (ring.{0} linarith.comp) (@functor.add_const.run.{0 1} (topological_space.{0} (ring.{0} linarith.comp)) Type h0)  := sorry --non-trivial
lemma new_lemma_27293 (h0 : fin has_zero.zero) : @preconnected_space.{1} (complete_distrib_lattice.{1} Type) (@matrix.vec_empty.{1} (topological_space.{1} (complete_distrib_lattice.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_27294 (h0 : fin has_zero.zero) : @group.fg.{1} (ordered_comm_ring.{1} Type) (@matrix.vec_empty.{1} (group.{1} (ordered_comm_ring.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_27295 (h0 : functor.add_const (topological_space (boolean_algebra.core pos)) name) : @loc_path_connected_space.{0} (boolean_algebra.core.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (boolean_algebra.core.{0} pos)) name h0)  := sorry --non-trivial
lemma new_lemma_27296 (h0 : cancel_comm_monoid_with_zero (has_Inf (has_zero linarith.comp))) : unique_factorization_monoid (has_Inf (has_zero linarith.comp)) := sorry --non-trivial
lemma new_lemma_27297 (h0 : function.extfun Type list) : list.nodup (function.extfun_app h0 (linear_ordered_field unsigned)) := sorry --non-trivial
lemma new_lemma_27298 (h0 : function.extfun Type group) : @group.fg.{0} (add_semigroup.{0} empty) (@function.extfun_app.{2 1} Type group.{0} h0 (add_semigroup.{0} empty))  := sorry --non-trivial
lemma new_lemma_27299 (h0 : complete_lattice (canonically_ordered_comm_semiring (finset Type))) : is_atomistic (canonically_ordered_comm_semiring (finset Type)) := sorry --non-trivial
lemma new_lemma_27300 (h0 : topological_space (linear_ordered_add_comm_group (with_bot (with_bot linarith.comp_source)))) : locally_compact_space (linear_ordered_add_comm_group (with_bot (with_bot linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_27301 (h1 : ring (normed_group fun_info)) : rank_condition (normed_group fun_info) := sorry --non-trivial
lemma new_lemma_27302 (h0 : (complete_lattice (complete_semilattice_Sup linarith.ineq) -> false) -> false) (h1 : complete_lattice (complete_semilattice_Sup linarith.ineq) -> false) (h2 : not (false -> false)) : @is_compactly_generated.{0} (complete_semilattice_Sup.{0} linarith.ineq) (@classical.by_contradiction'.{1} (complete_lattice.{0} (complete_semilattice_Sup.{0} linarith.ineq)) (@function.update.{0 0} (complete_lattice.{0} (complete_semilattice_Sup.{0} linarith.ineq) → false) (λ (a : complete_lattice.{0} (complete_semilattice_Sup.{0} linarith.ineq) → false), false) (λ (a b : complete_lattice.{0} (complete_semilattice_Sup.{0} linarith.ineq) → false), @decidable_eq_of_subsingleton.{0} (complete_lattice.{0} (complete_semilattice_Sup.{0} linarith.ineq) → false) (@pi.subsingleton.{1 0} (complete_lattice.{0} (complete_semilattice_Sup.{0} linarith.ineq)) (λ (ᾰ : complete_lattice.{0} (complete_semilattice_Sup.{0} linarith.ineq)), false) (λ (a : complete_lattice.{0} (complete_semilattice_Sup.{0} linarith.ineq)), subsingleton_prop false)) a b) h0 h1 (@classical.by_contradiction'.{0} false h2)))  := sorry --trivial
lemma new_lemma_27303 (h0 : not (add_monoid (add_right_cancel_monoid congr_arg_kind) -> false)) : @add_monoid.fg.{0} (add_right_cancel_monoid.{0} congr_arg_kind) (@classical.by_contradiction'.{1} (add_monoid.{0} (add_right_cancel_monoid.{0} congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_27304 (h0 : ring (canonically_ordered_add_monoid (option (option unsigned)))) : strong_rank_condition (canonically_ordered_add_monoid (option (option unsigned))) := sorry --non-trivial
lemma new_lemma_27305 (h0 : topological_space (semigroup (has_add (has_neg Type)))) : loc_path_connected_space (semigroup (has_add (has_neg Type))) := sorry --non-trivial
lemma new_lemma_27306 (h0 : group string.iterator_imp) : is_cyclic string.iterator_imp := sorry --non-trivial
lemma new_lemma_27307 (h0 : not (topological_space (div_inv_monoid (has_ssubset linarith.comp_source)) -> false)) : @totally_disconnected_space.{0} (div_inv_monoid.{0} (has_ssubset.{0} linarith.comp_source)) (@classical.by_contradiction'.{1} (topological_space.{0} (div_inv_monoid.{0} (has_ssubset.{0} linarith.comp_source))) h0)  := sorry --non-trivial
lemma new_lemma_27308 (h0 : functor.add_const (function.extfun Type add_monoid) pos) : @add_monoid.fg.{0} (boolean_algebra.{0} linarith.comp) (@function.extfun_app.{2 1} Type add_monoid.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type add_monoid.{0}) pos h0) (boolean_algebra.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_27309 (h0 : ring (has_lt (random_gen (random_gen (random_gen linarith.ineq))))) : rank_condition (has_lt (random_gen (random_gen (random_gen linarith.ineq)))) := sorry --non-trivial
lemma new_lemma_27310 (h0 : filter (distrib_lattice (has_norm (has_norm fun_info)))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_27311 (h0 : not (ring (linear_ordered_add_comm_group linarith.ineq) -> false)) : @strong_rank_condition.{0} (linear_ordered_add_comm_group.{0} linarith.ineq) (@classical.by_contradiction'.{1} (ring.{0} (linear_ordered_add_comm_group.{0} linarith.ineq)) h0)  := sorry --non-trivial
lemma new_lemma_27312 (h1 : topological_space fun_info) : totally_disconnected_space fun_info := sorry --non-trivial
lemma new_lemma_27313 (h0 : function.extfun Type topological_space) : @preirreducible_space.{0} unsigned (@function.extfun_app.{2 1} Type topological_space.{0} h0 unsigned)  := sorry --non-trivial
lemma new_lemma_27314 (h1 : function.extfun Type group) : @normalizer_condition.{0} (has_emptyc.{0} linarith.ineq) (@function.extfun_app.{2 1} Type group.{0} h1 (has_emptyc.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_27315 (h0 : not (topological_space (partial_order congr_arg_kind) -> false)) : @totally_disconnected_space.{0} (partial_order.{0} congr_arg_kind) (@classical.by_contradiction'.{1} (topological_space.{0} (partial_order.{0} congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_27316 (h0 : function.extfun Type uniform_space) : @complete_space.{0} (with_bot.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (with_bot.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_27317 (h0 : group (mul_zero_class (semiring congr_arg_kind))) : group.fg (mul_zero_class (semiring congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_27318 (h0 : functor.add_const (group (has_pos_part linarith.comp)) (has_Inf Type)) : @normalizer_condition.{0} (has_pos_part.{0} linarith.comp) (@functor.add_const.run.{0 1} (group.{0} (has_pos_part.{0} linarith.comp)) (has_Inf.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_27319 (h0 : filter (boolean_algebra (has_add (has_to_string (has_to_string (has_add (comm_group unsigned))))))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_27320 (h0 : cancel_comm_monoid_with_zero (measure_theory.measure_space (semiring num))) : unique_factorization_monoid (measure_theory.measure_space (semiring num)) := sorry --non-trivial
lemma new_lemma_27321 (h0 : function.extfun (Type 1) (functor.comp topological_space has_neg_part)) : @loc_path_connected_space.{1} (has_neg_part.{1} Type) (@functor.comp.run.{1 1 1} topological_space.{1} has_neg_part.{1} Type (@function.extfun_app.{3 2} (Type 1) (functor.comp.{1 1 1} topological_space.{1} has_neg_part.{1}) h0 Type))  := sorry --non-trivial
lemma new_lemma_27322 (h0 : semiring (plift empty)) : is_noetherian_ring (plift empty) := sorry --non-trivial
lemma new_lemma_27323 (h0 : functor.add_const (topological_space Type) linarith.comp) : @discrete_topology.{1} Type (@functor.add_const.run.{1 0} (topological_space.{1} Type) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_27324 (h0 : complete_lattice (left_cancel_monoid (semiring congr_arg_kind))) : complete_lattice.is_Sup_finite_compact (left_cancel_monoid (semiring congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_27325 (h0 : set (string.iterator_imp -> add_comm_semigroup (add_comm_semigroup (add_comm_semigroup (mul_one_class std_gen))))) : set.separates_points h0 := sorry --non-trivial
lemma new_lemma_27326 (h0 : group (has_to_string (semigroup name))) : is_simple_group (has_to_string (semigroup name)) := sorry --non-trivial
lemma new_lemma_27327 (h1 : ring (has_ssubset fun_info)) : strong_rank_condition (has_ssubset fun_info) := sorry --non-trivial
lemma new_lemma_27328 (h0 : uniform_space (dlist (has_nnnorm (has_nnnorm (has_nnnorm linarith.comp_source))))) : complete_space (dlist (has_nnnorm (has_nnnorm (has_nnnorm linarith.comp_source)))) := sorry --non-trivial
lemma new_lemma_27329 (h0 : complete_lattice (topological_space (boolean_algebra.core (has_ssubset string_imp)))) : is_compactly_generated (topological_space (boolean_algebra.core (has_ssubset string_imp))) := sorry --non-trivial
lemma new_lemma_27330 (h0 : group (has_bot (ordered_comm_monoid (sub_neg_monoid (comm_semigroup (has_bot (has_Inf real))))))) : is_cyclic (has_bot (ordered_comm_monoid (sub_neg_monoid (comm_semigroup (has_bot (has_Inf real)))))) := sorry --non-trivial
lemma new_lemma_27331 (h0 : filter (has_compl linarith.ineq)) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_27332 (h0 : functor.add_const Prop (measure_theory.measure_space (has_top empty))) : functor.add_const.run h0 := sorry --non-trivial
lemma new_lemma_27333 (h0 : group (add_right_cancel_monoid (semiring (semiring congr_arg_kind)))) : normalizer_condition (add_right_cancel_monoid (semiring (semiring congr_arg_kind))) := sorry --non-trivial
lemma new_lemma_27334 (h0 : topological_space ereal) : t2_5_space ereal := sorry --non-trivial
lemma new_lemma_27335 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @is_noetherian_ring.{1} (generalized_boolean_algebra.{1} Type) (@function.extfun_app.{3 2} (Type 1) semiring.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 semiring.{1}) (generalized_boolean_algebra.{1} Type))  := sorry --non-trivial
lemma new_lemma_27336 (h1 h2 : multiset (nondiscrete_normed_field (normed_field linarith.ineq))) : multiset.subset h1 h2 := sorry --non-trivial
lemma new_lemma_27337 (h0 : functor.add_const (function.extfun Type topological_space) (has_neg Type)) : @regular_space.{0} (boolean_algebra.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type topological_space.{0}) (has_neg.{1} Type) h0) (boolean_algebra.{0} pos))  := sorry --non-trivial
lemma new_lemma_27338 (h0 : ring (mul_one_class (has_le (mul_one_class string_imp)))) : rank_condition (mul_one_class (has_le (mul_one_class string_imp))) := sorry --non-trivial
lemma new_lemma_27339 (h0 : add_group (normed_field fun_info)) : is_add_cyclic (normed_field fun_info) := sorry --non-trivial
lemma new_lemma_27340 (h0 : function.extfun Type (functor.add_const (topological_space (option name)))) : @regular_space.{0} (option.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (option.{0} name)) unsigned (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (topological_space.{0} (option.{0} name))) h0 unsigned))  := sorry --non-trivial
lemma new_lemma_27341 (h0 : not (list (random_gen to_additive.value_type) -> false)) : list.nodup (classical.by_contradiction' h0) := sorry --non-trivial
lemma new_lemma_27342 (h0 : topological_space (with_bot (random_gen congr_arg_kind))) : t0_space (with_bot (random_gen congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_27343 (h0 : has_mem.mem (with_bot (has_norm congr_arg_kind)) has_emptyc.emptyc) : @is_atomistic.{0} (with_bot.{0} (has_norm.{0} congr_arg_kind)) (@finset.pi.empty.{1 0} Type complete_lattice.{0} (with_bot.{0} (has_norm.{0} congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_27344 (h0 : function.extfun (Type 1) semiring) : @is_noetherian_ring.{1} (mul_zero_class.{1} Type) (@function.extfun_app.{3 2} (Type 1) semiring.{1} h0 (mul_zero_class.{1} Type))  := sorry --non-trivial
lemma new_lemma_27345 (h1 : ring (add_monoid (normed_field linarith.ineq))) : strong_rank_condition (add_monoid (normed_field linarith.ineq)) := sorry --non-trivial
lemma new_lemma_27346 (h0 : ring (has_norm (dlist (has_top to_additive.value_type)))) : is_domain (has_norm (dlist (has_top to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_27347 (h0 : ring (has_norm (comm_ring (has_top linarith.ineq)))) : is_domain (has_norm (comm_ring (has_top linarith.ineq))) := sorry --non-trivial
lemma new_lemma_27348 (h0 : complete_lattice (uniform_space enat)) : is_compactly_generated (uniform_space enat) := sorry --non-trivial
lemma new_lemma_27349 (h2 : not (topological_space (random_gen string_imp) -> false)) : @totally_disconnected_space.{0} (random_gen.{0} string_imp) (@classical.by_contradiction'.{1} (topological_space.{0} (random_gen.{0} string_imp)) h2)  := sorry --non-trivial
lemma new_lemma_27350 (h0 : functor.add_const (complete_lattice (has_nndist environment.implicit_infer_kind)) linarith.comp) : @is_atomistic.{0} (has_nndist.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (complete_lattice.{0} (has_nndist.{0} environment.implicit_infer_kind)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_27351 (h0 : group (boolean_algebra.core (ring Type))) : group.fg (boolean_algebra.core (ring Type)) := sorry --non-trivial
lemma new_lemma_27352 (h0 : not (topological_space (option num) -> false)) : @discrete_topology.{0} (option.{0} num) (@classical.by_contradiction'.{1} (topological_space.{0} (option.{0} num)) h0)  := sorry --non-trivial
lemma new_lemma_27353 (h0 : topological_space (has_top (has_top (has_top linarith.comp_source)))) : totally_separated_space (has_top (has_top (has_top linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_27354 (h0 : topological_space (comm_group (option unsigned))) : path_connected_space (comm_group (option unsigned)) := sorry --non-trivial
lemma new_lemma_27355 (h0 : topological_space (ring (has_add (add_comm_monoid (has_neg_part (cancel_monoid Type)))))) : t1_space (ring (has_add (add_comm_monoid (has_neg_part (cancel_monoid Type))))) := sorry --non-trivial
lemma new_lemma_27356 (h0 : topological_space (has_append (distrib (distrib reducibility_hints)))) : path_connected_space (has_append (distrib (distrib reducibility_hints))) := sorry --non-trivial
lemma new_lemma_27357 (h0 : ring (has_Inf (sub_neg_monoid real))) : is_principal_ideal_ring (has_Inf (sub_neg_monoid real)) := sorry --non-trivial
lemma new_lemma_27358 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : palindrome (function.extfun_app (function.extfun_app h0 list) (ordered_comm_group unsigned)) := sorry --non-trivial
lemma new_lemma_27359 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @separated_space.{0} (ordered_comm_group.{0} empty) (@function.extfun_app.{2 1} Type uniform_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 uniform_space.{0}) (ordered_comm_group.{0} empty))  := sorry --non-trivial
lemma new_lemma_27360 (h0 : not (group (normed_field linarith.comp_source) -> false)) : @is_cyclic.{0} (normed_field.{0} linarith.comp_source) (@classical.by_contradiction'.{1} (group.{0} (normed_field.{0} linarith.comp_source)) h0)  := sorry --non-trivial
lemma new_lemma_27361 (h0 : uniform_space (pseudo_metric_space (option empty))) : complete_space (pseudo_metric_space (option empty)) := sorry --non-trivial
lemma new_lemma_27362 (h0 : function.extfun Type complete_lattice) : @complete_lattice.is_Sup_finite_compact.{0} (has_inv.{0} linarith.ineq) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (has_inv.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_27363 (h0 : ordered_comm_monoid (has_Inf (has_Inf name))) : has_exists_mul_of_le (has_Inf (has_Inf name)) := sorry --non-trivial
lemma new_lemma_27364 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @unique_factorization_monoid.{0} (has_Inf.{0} linarith.comp) (@function.extfun_app.{2 1} Type cancel_comm_monoid_with_zero.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 cancel_comm_monoid_with_zero.{0}) (has_Inf.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_27365 (h0 : function.extfun Type add_group) : @is_add_cyclic.{0} (left_cancel_semigroup.{0} unsigned) (@function.extfun_app.{2 1} Type add_group.{0} h0 (left_cancel_semigroup.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_27366 (h0 : functor.add_const (group (is_R_or_C unsigned)) empty) : @group.fg.{0} (is_R_or_C.{0} unsigned) (@functor.add_const.run.{0 0} (group.{0} (is_R_or_C.{0} unsigned)) empty h0)  := sorry --non-trivial
lemma new_lemma_27367 (h0 : function.extfun Type topological_space) : @totally_separated_space.{0} (normed_comm_ring.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (normed_comm_ring.{0} num))  := sorry --non-trivial
lemma new_lemma_27368 (h0 : monoid (ring (has_add (has_to_string name)))) : monoid.fg (ring (has_add (has_to_string name))) := sorry --non-trivial
lemma new_lemma_27369 (h0 : topological_space (cancel_monoid (finset name))) : t0_space (cancel_monoid (finset name)) := sorry --non-trivial
lemma new_lemma_27370 (h0 : topological_space (linear_ordered_semiring (random_gen num))) : path_connected_space (linear_ordered_semiring (random_gen num)) := sorry --non-trivial
lemma new_lemma_27371 (h0 : cancel_comm_monoid_with_zero (boolean_algebra (has_pos_part linarith.comp))) : unique_factorization_monoid (boolean_algebra (has_pos_part linarith.comp)) := sorry --non-trivial
lemma new_lemma_27372 (h0 : has_lt (has_nnnorm linarith.ineq)) : no_max_order (has_nnnorm linarith.ineq) := sorry --non-trivial
lemma new_lemma_27373 (h0 : has_top fun_info -> Prop) : Exists h0 := sorry --non-trivial
lemma new_lemma_27374 (h0 : functor.add_const (complete_lattice (boolean_algebra.core Type)) bool) : @is_compactly_generated.{1} (boolean_algebra.core.{1} Type) (@functor.add_const.run.{1 0} (complete_lattice.{1} (boolean_algebra.core.{1} Type)) bool h0)  := sorry --non-trivial
lemma new_lemma_27375 (h0 : functor.add_const (function.extfun Type cancel_comm_monoid_with_zero) pos) : @unique_factorization_monoid.{0} (cancel_monoid.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type cancel_comm_monoid_with_zero.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type cancel_comm_monoid_with_zero.{0}) pos h0) (cancel_monoid.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_27376 (h1 : complete_lattice (has_compl char)) : complete_lattice.is_Sup_finite_compact (has_compl char) := sorry --non-trivial
lemma new_lemma_27377 (h0 : fin has_zero.zero) : @is_domain.{1} (canonically_ordered_monoid.{1} Type) (@matrix.vec_empty.{1} (ring.{1} (canonically_ordered_monoid.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_27378 (h0 : not (function.extfun Type group -> false)) : @group.fg.{0} (semi_normed_comm_ring.{0} char) (@function.extfun_app.{2 1} Type group.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type group.{0}) h0) (semi_normed_comm_ring.{0} char))  := sorry --non-trivial
lemma new_lemma_27379 (h2 : complete_lattice (has_top fun_info)) : is_atomistic (has_top fun_info) := sorry --non-trivial
lemma new_lemma_27380 (h0 : complete_lattice (has_inter ennreal)) : is_atomistic (has_inter ennreal) := sorry --non-trivial
lemma new_lemma_27381 (h0 : functor.add_const (finset (pseudo_metric_space num)) ennreal) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_27382 (h0 : list (simple_graph (has_pos_part (boolean_algebra (ring (ring Type)))))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_27383 (h1 : set (non_unital_non_assoc_semiring string_imp)) : set.subsingleton h1 := sorry --non-trivial
lemma new_lemma_27384 (h0 : list (with_bot (has_inv (has_inv linarith.comp_source)))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_27385 (h0 : not (ring (normed_group unsigned) -> false)) : @is_domain.{0} (normed_group.{0} unsigned) (@classical.by_contradiction'.{1} (ring.{0} (normed_group.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_27386 (h0 : function.extfun Type topological_space) : @loc_path_connected_space.{0} (non_assoc_semiring.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (non_assoc_semiring.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_27387 (h0 : num -> num -> Prop) : is_strict_total_order' num h0 := sorry --non-trivial
lemma new_lemma_27388 (h0 : has_mem.mem (with_bot num) has_emptyc.emptyc) : @is_atomistic.{0} (with_bot.{0} num) (@finset.pi.empty.{1 0} Type complete_lattice.{0} (with_bot.{0} num) h0)  := sorry --non-trivial
lemma new_lemma_27389 (h0 : functor.add_const (add_group (has_neg unsigned)) linarith.comp) : @is_add_cyclic.{0} (has_neg.{0} unsigned) (@functor.add_const.run.{0 0} (add_group.{0} (has_neg.{0} unsigned)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_27390 (h0 h1 : multiset (has_nnnorm fun_info)) : multiset.subset h0 h1 := sorry --non-trivial
lemma new_lemma_27391 (h0 : topological_space (canonically_ordered_comm_semiring (has_neg Type))) : discrete_topology (canonically_ordered_comm_semiring (has_neg Type)) := sorry --non-trivial
lemma new_lemma_27392 (h0 : group (boolean_algebra Type)) : is_cyclic (boolean_algebra Type) := sorry --non-trivial
lemma new_lemma_27393 (h0 : topological_space (has_lt char)) (h1 : add_group (has_lt char)) : topological_add_group (has_lt char) := sorry --non-trivial
lemma new_lemma_27394 (h1 : ring (has_compl linarith.ineq)) : is_domain (has_compl linarith.ineq) := sorry --non-trivial
lemma new_lemma_27395 (h0 : function.extfun Type topological_space) : @path_connected_space.{0} (uniform_space.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (uniform_space.{0} pos))  := sorry --non-trivial
lemma new_lemma_27396 (h0 : cancel_comm_monoid_with_zero (add_cancel_comm_monoid congr_arg_kind)) : unique_factorization_monoid (add_cancel_comm_monoid congr_arg_kind) := sorry --non-trivial
lemma new_lemma_27397 (h0 : functor.add_const (function.extfun Type topological_space) (has_add Type)) : @sequential_space.{0} (has_Inf.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type topological_space.{0}) (has_add.{1} Type) h0) (has_Inf.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_27398 (h0 : prod (has_neg (has_to_string pos)) (has_neg (has_to_string pos))) : id_rel h0 := sorry --non-trivial
lemma new_lemma_27399 (h0 : group (with_zero (has_nnnorm (has_nnnorm fun_info)))) : is_cyclic (with_zero (has_nnnorm (has_nnnorm fun_info))) := sorry --non-trivial
lemma new_lemma_27400 (h0 : function.extfun (Type 1) topological_space) : @t1_space.{1} (boolean_algebra.core.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} h0 (boolean_algebra.core.{1} Type))  := sorry --non-trivial
lemma new_lemma_27401 (h0 : function.extfun Type ring) : @is_principal_ideal_ring.{0} (linear_ordered_field.{0} (option.{0} ennreal)) (@function.extfun_app.{2 1} Type ring.{0} h0 (linear_ordered_field.{0} (option.{0} ennreal)))  := sorry --non-trivial
lemma new_lemma_27402 (h0 : cancel_comm_monoid_with_zero (add_left_cancel_semigroup (option empty))) : unique_factorization_monoid (add_left_cancel_semigroup (option empty)) := sorry --non-trivial
lemma new_lemma_27403 (h0 : complete_lattice (with_one (has_norm fun_info))) : complete_lattice.is_Sup_finite_compact (with_one (has_norm fun_info)) := sorry --non-trivial
lemma new_lemma_27404 (h0 : topological_space (measurable_space (with_bot (with_bot to_additive.value_type)))) : locally_compact_space (measurable_space (with_bot (with_bot to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_27405 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @separated_space.{0} (canonically_ordered_comm_semiring.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type uniform_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 uniform_space.{0}) (canonically_ordered_comm_semiring.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_27406 (h0 : functor.add_const (ring (semigroup environment.implicit_infer_kind)) name) : @is_domain.{0} (semigroup.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (ring.{0} (semigroup.{0} environment.implicit_infer_kind)) name h0)  := sorry --non-trivial
lemma new_lemma_27407 (h0 : list (denumerable char)) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_27408 (h0 : function.extfun Type complete_lattice) : @complete_lattice.is_Sup_finite_compact.{0} (has_inter.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (has_inter.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_27409 (h0 : functor.add_const (function.extfun Type group) Type) : @normalizer_condition.{0} (has_Inf.{0} pos) (@function.extfun_app.{2 1} Type group.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type group.{0}) Type h0) (has_Inf.{0} pos))  := sorry --non-trivial
lemma new_lemma_27410 (h0 : complete_lattice (boolean_algebra environment.implicit_infer_kind)) : complete_lattice.is_Sup_finite_compact (boolean_algebra environment.implicit_infer_kind) := sorry --non-trivial
lemma new_lemma_27411 (h0 : ring (has_inv (denumerable linarith.ineq))) : is_domain (has_inv (denumerable linarith.ineq)) := sorry --non-trivial
lemma new_lemma_27412 (h0 : group (has_bot (has_neg linarith.comp))) : is_cyclic (has_bot (has_neg linarith.comp)) := sorry --non-trivial
lemma new_lemma_27413 (h0 : topological_space (complete_semilattice_Sup (random_gen linarith.comp_source))) : locally_compact_space (complete_semilattice_Sup (random_gen linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_27414 (h0 : topological_space (has_nndist (ring linarith.comp))) : totally_disconnected_space (has_nndist (ring linarith.comp)) := sorry --non-trivial
lemma new_lemma_27415 (h0 : prod (ring (option (option (option (option empty))))) (ring (option (option (option (option empty)))))) : id_rel h0 := sorry --non-trivial
lemma new_lemma_27416 (h0 : topological_space (measurable_space.dynkin_system (semiring linarith.comp))) : normal_space (measurable_space.dynkin_system (semiring linarith.comp)) := sorry --non-trivial
lemma new_lemma_27417 (h0 : functor.add_const (topological_space (has_nndist Type)) linarith.comp) : @preirreducible_space.{1} (has_nndist.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (has_nndist.{1} Type)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_27418 (h0 : function.extfun Type topological_space) : @t0_space.{0} (normed_group.{0} (denumerable.{0} linarith.ineq)) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (normed_group.{0} (denumerable.{0} linarith.ineq)))  := sorry --non-trivial
lemma new_lemma_27419 (h0 : complete_lattice (with_one linarith.ineq)) : complete_lattice.is_Sup_finite_compact (with_one linarith.ineq) := sorry --non-trivial
lemma new_lemma_27420 (h0 : functor.add_const (add_monoid (has_star num)) congr_arg_kind) : @add_monoid.fg.{0} (has_star.{0} num) (@functor.add_const.run.{0 0} (add_monoid.{0} (has_star.{0} num)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_27421 (h0 : functor.add_const (uniform_space (has_zero ennreal)) linarith.comp) : @complete_space.{0} (has_zero.{0} ennreal) (@functor.add_const.run.{0 0} (uniform_space.{0} (has_zero.{0} ennreal)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_27422 (h0 : semiring (finset (has_to_string pos))) : is_noetherian_ring (finset (has_to_string pos)) := sorry --non-trivial
lemma new_lemma_27423 (h0 : complete_lattice (with_one (has_norm fun_info))) : is_compactly_generated (with_one (has_norm fun_info)) := sorry --non-trivial
lemma new_lemma_27424 (h0 : ring (distrib reducibility_hints)) : strong_rank_condition (distrib reducibility_hints) := sorry --non-trivial
lemma new_lemma_27425 (h0 : ring (encodable to_additive.value_type)) : strong_rank_condition (encodable to_additive.value_type) := sorry --non-trivial
lemma new_lemma_27426 (h0 : ring (has_top (has_top linarith.comp_source))) : rank_condition (has_top (has_top linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_27427 (h0 : semiring (monoid congr_arg_kind)) : is_noetherian_ring (monoid congr_arg_kind) := sorry --non-trivial
lemma new_lemma_27428 (h0 : group (normed_group (semiring (semiring (semiring congr_arg_kind))))) : group.fg (normed_group (semiring (semiring (semiring congr_arg_kind)))) := sorry --non-trivial
lemma new_lemma_27429 (h0 : topological_space (generalized_boolean_algebra (has_neg (ring (has_neg Type))))) : discrete_topology (generalized_boolean_algebra (has_neg (ring (has_neg Type)))) := sorry --non-trivial
lemma new_lemma_27430 (h0 : semiring (add_group (has_norm unsigned))) : is_noetherian_ring (add_group (has_norm unsigned)) := sorry --non-trivial
lemma new_lemma_27431 (h0 : complete_lattice (has_compl (has_lt enat))) : complete_lattice.is_Sup_finite_compact (has_compl (has_lt enat)) := sorry --non-trivial
lemma new_lemma_27432 (h0 : functor.add_const (add_group (has_pos_part Type)) (ring Type)) : @is_add_cyclic.{1} (has_pos_part.{1} Type) (@functor.add_const.run.{1 1} (add_group.{1} (has_pos_part.{1} Type)) (ring.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_27433 (h0 : topological_space (ordered_ring (option congr_arg_kind))) : totally_disconnected_space (ordered_ring (option congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_27434 (h0 : functor.add_const (ordered_comm_monoid (has_neg_part Type)) (cancel_monoid Type)) : @has_exists_mul_of_le.{1} (has_neg_part.{1} Type) (@functor.add_const.run.{1 1} (ordered_comm_monoid.{1} (has_neg_part.{1} Type)) (cancel_monoid.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_27435 (h2 : topological_space (mul_one_class (mul_one_class (add_comm_semigroup string.iterator_imp)))) : totally_disconnected_space (mul_one_class (mul_one_class (add_comm_semigroup string.iterator_imp))) := sorry --non-trivial
lemma new_lemma_27436 (h0 : function.extfun nat fin) : @is_principal_ideal_ring.{0} (simple_graph.{0} linarith.comp) (@matrix.vec_empty.{0} (ring.{0} (simple_graph.{0} linarith.comp)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_27437 (h0 : functor.add_const (add_group (has_pos_part pos)) (has_neg pos)) : @is_add_cyclic.{0} (has_pos_part.{0} pos) (@functor.add_const.run.{0 0} (add_group.{0} (has_pos_part.{0} pos)) (has_neg.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_27438 (h0 : functor.add_const (functor.add_const (topological_space Type) linarith.comp) pos) : @totally_separated_space.{1} Type (@functor.add_const.run.{1 0} (topological_space.{1} Type) linarith.comp (@functor.add_const.run.{1 0} (functor.add_const.{1 0} (topological_space.{1} Type) linarith.comp) pos h0))  := sorry --non-trivial
lemma new_lemma_27439 (h0 : functor.add_const (add_group (semigroup empty)) (option empty)) : @is_add_cyclic.{0} (semigroup.{0} empty) (@functor.add_const.run.{0 0} (add_group.{0} (semigroup.{0} empty)) (option.{0} empty) h0)  := sorry --non-trivial
lemma new_lemma_27440 (h0 : preorder (add_comm_semigroup char)) (h1 : topological_space (add_comm_semigroup char)) : Sup_convergence_class (add_comm_semigroup char) := sorry --non-trivial
lemma new_lemma_27441 (h1 : function.extfun Type topological_space) : @path_connected_space.{0} (complete_semilattice_Sup.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h1 (complete_semilattice_Sup.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_27442 (h0 : add_group (linear_ordered_add_comm_monoid_with_top (has_lt string.iterator_imp))) : is_add_cyclic (linear_ordered_add_comm_monoid_with_top (has_lt string.iterator_imp)) := sorry --non-trivial
lemma new_lemma_27443 (h0 : functor.add_const (list (boolean_algebra.core linarith.comp)) name) : palindrome (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_27444 (h0 : function.extfun Type complete_lattice) : @complete_lattice.is_Sup_finite_compact.{0} (has_inter.{0} (option.{0} (option.{0} num))) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (has_inter.{0} (option.{0} (option.{0} num))))  := sorry --non-trivial
lemma new_lemma_27445 (h0 : ring (normed_lattice_add_comm_group (sub_neg_monoid Type))) : rank_condition (normed_lattice_add_comm_group (sub_neg_monoid Type)) := sorry --non-trivial
lemma new_lemma_27446 (h0 : cancel_comm_monoid_with_zero (preorder (semiring unsigned))) : unique_factorization_monoid (preorder (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_27447 (h0 : not (function.extfun (Type -> Type) (function.extfun Type) -> false)) : @strong_rank_condition.{0} (random_gen.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) (@classical.by_contradiction'.{2} (function.extfun.{2 2} (Type → Type) (function.extfun.{2 1} Type)) h0) ring.{0}) (random_gen.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_27448 (h0 : topological_space (pseudo_metric_space name)) : t0_space (pseudo_metric_space name) := sorry --non-trivial
lemma new_lemma_27449 (h0 : functor.add_const (complete_lattice (canonically_linear_ordered_monoid unsigned)) unsigned) : @is_compactly_generated.{0} (canonically_linear_ordered_monoid.{0} unsigned) (@functor.add_const.run.{0 0} (complete_lattice.{0} (canonically_linear_ordered_monoid.{0} unsigned)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_27450 (h0 h1 : multiset char) : multiset.disjoint h0 h1 := sorry --non-trivial
lemma new_lemma_27451 (h0 : not (topological_space (measure_theory.measure_space num) -> false)) : @path_connected_space.{0} (measure_theory.measure_space.{0} num) (@classical.by_contradiction'.{1} (topological_space.{0} (measure_theory.measure_space.{0} num)) h0)  := sorry --non-trivial
lemma new_lemma_27452 (h0 : functor.add_const (filter (has_to_string name)) pos) : countable_Inter_filter (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_27453 (h0 : function.extfun Type ring) : @is_principal_ideal_ring.{0} (option.{0} name) (@function.extfun_app.{2 1} Type ring.{0} h0 (option.{0} name))  := sorry --non-trivial
lemma new_lemma_27454 (h0 : group (finset name)) : is_simple_group (finset name) := sorry --non-trivial
lemma new_lemma_27455 (h0 : complete_lattice (distrib linarith.comp_source)) : is_compactly_generated (distrib linarith.comp_source) := sorry --non-trivial
lemma new_lemma_27456 (h0 : semiring (ring (has_to_string Type))) : is_noetherian_ring (ring (has_to_string Type)) := sorry --non-trivial
lemma new_lemma_27457 (h0 : topological_space (with_one linarith.comp)) : totally_separated_space (with_one linarith.comp) := sorry --non-trivial
lemma new_lemma_27458 (h0 : topological_space (div_inv_monoid (has_nnnorm linarith.ineq))) : totally_disconnected_space (div_inv_monoid (has_nnnorm linarith.ineq)) := sorry --non-trivial
lemma new_lemma_27459 (h0 : ring (free_add_monoid (semiring unsigned))) : strong_rank_condition (free_add_monoid (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_27460 (h0 : topological_space (distrib_lattice (has_top (has_top (has_top linarith.ineq))))) : totally_separated_space (distrib_lattice (has_top (has_top (has_top linarith.ineq)))) := sorry --non-trivial
lemma new_lemma_27461 (h0 : topological_space (canonically_ordered_monoid pos)) : regular_space (canonically_ordered_monoid pos) := sorry --non-trivial
lemma new_lemma_27462 (h0 : ring (has_div (mul_one_class linarith.comp_source))) : rank_condition (has_div (mul_one_class linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_27463 (h0 : topological_space (has_neg pos)) : normal_space (has_neg pos) := sorry --non-trivial
lemma new_lemma_27464 (h0 : not (ring (has_div (mul_one_class reducibility_hints)) -> false)) : @rank_condition.{0} (has_div.{0} (mul_one_class.{0} reducibility_hints)) (@classical.by_contradiction'.{1} (ring.{0} (has_div.{0} (mul_one_class.{0} reducibility_hints))) h0)  := sorry --non-trivial
lemma new_lemma_27465 (h0 : group (with_bot (semiring linarith.comp))) : normalizer_condition (with_bot (semiring linarith.comp)) := sorry --non-trivial
lemma new_lemma_27466 (h0 : group (has_Sup (semiring congr_arg_kind))) : normalizer_condition (has_Sup (semiring congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_27467 (h0 : topological_space (has_nnnorm (simple_graph (mul_one_class ereal)))) : t0_space (has_nnnorm (simple_graph (mul_one_class ereal))) := sorry --non-trivial
lemma new_lemma_27468 (h0 : functor.add_const (function.extfun Type topological_space) (has_neg pos)) : @irreducible_space.{0} (boolean_algebra.core.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) (has_neg.{0} pos) h0) (boolean_algebra.core.{0} pos))  := sorry --non-trivial
lemma new_lemma_27469 (h1 : topological_space string.iterator_imp) : path_connected_space string.iterator_imp := sorry --non-trivial
lemma new_lemma_27470 (h0 : topological_space (canonically_linear_ordered_monoid (has_add linarith.comp))) : sequential_space (canonically_linear_ordered_monoid (has_add linarith.comp)) := sorry --non-trivial
lemma new_lemma_27471 (h0 : complete_lattice (add_cancel_monoid (boolean_algebra name))) : complete_lattice.is_Sup_finite_compact (add_cancel_monoid (boolean_algebra name)) := sorry --non-trivial
lemma new_lemma_27472 (h0 : functor.add_const (list (add_comm_monoid environment.implicit_infer_kind)) name) : palindrome (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_27473 (h0 : topological_space (has_pos_part (canonically_ordered_monoid Type))) : totally_disconnected_space (has_pos_part (canonically_ordered_monoid Type)) := sorry --non-trivial
lemma new_lemma_27474 (h0 : function.extfun Type complete_lattice) : @complete_lattice.is_Sup_finite_compact.{0} (has_norm.{0} fun_info) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (has_norm.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_27475 (h0 : functor.add_const (uniform_space (has_nndist environment.implicit_infer_kind)) Type) : @separated_space.{0} (has_nndist.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 1} (uniform_space.{0} (has_nndist.{0} environment.implicit_infer_kind)) Type h0)  := sorry --non-trivial
lemma new_lemma_27476 (h0 : functor.add_const (fin has_zero.zero) Type) : @is_compactly_generated.{1} (normed_lattice_add_comm_group.{1} Type) (@matrix.vec_empty.{1} (complete_lattice.{1} (normed_lattice_add_comm_group.{1} Type)) (@functor.add_const.run.{0 1} (fin (@has_zero.zero.{0} nat nat.has_zero)) Type h0))  := sorry --non-trivial
lemma new_lemma_27477 (h0 : topological_space (linear_order unsigned)) : loc_path_connected_space (linear_order unsigned) := sorry --non-trivial
lemma new_lemma_27478 (h0 : topological_space (cancel_monoid (has_add environment.implicit_infer_kind))) : irreducible_space (cancel_monoid (has_add environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_27479 (h0 : prod (has_norm (semiring congr_arg_kind)) (has_norm (semiring congr_arg_kind))) : id_rel h0 := sorry --non-trivial
lemma new_lemma_27480 (h0 : topological_space (semilattice_inf linarith.comp_source)) : totally_disconnected_space (semilattice_inf linarith.comp_source) := sorry --non-trivial
lemma new_lemma_27481 (h0 : topological_space (comm_group (finset (add_comm_monoid name)))) : path_connected_space (comm_group (finset (add_comm_monoid name))) := sorry --non-trivial
lemma new_lemma_27482 (h0 : functor.add_const (topological_space (add_group num)) empty) : @totally_disconnected_space.{0} (add_group.{0} num) (@functor.add_const.run.{0 0} (topological_space.{0} (add_group.{0} num)) empty h0)  := sorry --non-trivial
lemma new_lemma_27483 (h0 : ring (id (semiring empty))) : is_domain (id (semiring empty)) := sorry --non-trivial
lemma new_lemma_27484 (h0 : function.extfun Type group) : @normalizer_condition.{0} (measurable_space.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type group.{0} h0 (measurable_space.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_27485 (h0 : functor.add_const (topological_space Type) (has_add name)) : @preconnected_space.{1} Type (@functor.add_const.run.{1 0} (topological_space.{1} Type) (has_add.{0} name) h0)  := sorry --non-trivial
lemma new_lemma_27486 (h0 : list (normed_group (has_top linarith.ineq))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_27487 (h0 : has_mem.mem group has_emptyc.emptyc) : @group.fg.{0} (semiring.{0} num) (@function.extfun_app.{2 1} Type group.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) group.{0} h0) (semiring.{0} num))  := sorry --non-trivial
lemma new_lemma_27488 (h0 : topological_space (add_cancel_monoid pos)) : loc_path_connected_space (add_cancel_monoid pos) := sorry --non-trivial
lemma new_lemma_27489 (h0 : topological_space (ordered_comm_ring to_additive.value_type)) : totally_disconnected_space (ordered_comm_ring to_additive.value_type) := sorry --non-trivial
lemma new_lemma_27490 (h0 : not (function.extfun Type uniform_space -> false)) : @complete_space.{0} (semiring.{0} linarith.comp) (@function.extfun_app.{2 1} Type uniform_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type uniform_space.{0}) h0) (semiring.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_27491 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @preconnected_space.{1} (boolean_algebra.core.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 topological_space.{1}) (boolean_algebra.core.{1} Type))  := sorry --non-trivial
lemma new_lemma_27492 (h0 : topological_space (has_emptyc (random_gen to_additive.value_type))) : path_connected_space (has_emptyc (random_gen to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_27493 (h0 : function.extfun Type group) : @group.fg.{0} (has_nndist.{0} linarith.comp) (@function.extfun_app.{2 1} Type group.{0} h0 (has_nndist.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_27494 (h0 : topological_space (dlist to_additive.value_type)) : totally_separated_space (dlist to_additive.value_type) := sorry --non-trivial
lemma new_lemma_27495 (h0 : ring (filter congr_arg_kind)) : is_principal_ideal_ring (filter congr_arg_kind) := sorry --non-trivial
lemma new_lemma_27496 (h0 : complete_lattice (semiring (semiring num))) : complete_lattice.is_Sup_finite_compact (semiring (semiring num)) := sorry --non-trivial
lemma new_lemma_27497 (h0 : functor.add_const (has_le (has_nndist environment.implicit_infer_kind)) Type) (h1 : has_nndist environment.implicit_infer_kind) : @is_top.{0} (has_nndist.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 1} (has_le.{0} (has_nndist.{0} environment.implicit_infer_kind)) Type h0) h1  := sorry --non-trivial
lemma new_lemma_27498 (h0 : functor.add_const (topological_space (cancel_monoid name)) name) : @topological_space.separable_space.{0} (cancel_monoid.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (cancel_monoid.{0} name)) name h0)  := sorry --non-trivial
lemma new_lemma_27499 (h0 : ring (ordered_comm_group num)) : strong_rank_condition (ordered_comm_group num) := sorry --non-trivial
lemma new_lemma_27500 (h0 : add_group (canonically_ordered_comm_semiring (option unsigned))) : is_add_cyclic (canonically_ordered_comm_semiring (option unsigned)) := sorry --non-trivial
lemma new_lemma_27501 (h0 : topological_space (has_norm (random_gen (with_bot to_additive.value_type)))) : irreducible_space (has_norm (random_gen (with_bot to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_27502 (h3 : add_group (denumerable linarith.comp_source)) : is_add_cyclic (denumerable linarith.comp_source) := sorry --non-trivial
lemma new_lemma_27503 (h1 : topological_space (add_monoid (comm_ring linarith.ineq))) : t0_space (add_monoid (comm_ring linarith.ineq)) := sorry --non-trivial
lemma new_lemma_27504 (h1 : topological_space (id fun_info)) : path_connected_space (id fun_info) := sorry --non-trivial
lemma new_lemma_27505 (h0 : not (function.extfun Type complete_lattice -> false)) : @is_compactly_generated.{0} (has_sub.{0} empty) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type complete_lattice.{0}) h0) (has_sub.{0} empty))  := sorry --non-trivial
lemma new_lemma_27506 (h0 : has_mem.mem (has_one congr_arg_kind) has_emptyc.emptyc) : @path_connected_space.{0} (has_one.{0} congr_arg_kind) (@finset.pi.empty.{1 0} Type topological_space.{0} (has_one.{0} congr_arg_kind) h0)  := sorry --non-trivial
lemma new_lemma_27507 (h0 : topological_space (distrib (mul_one_class fun_info))) : path_connected_space (distrib (mul_one_class fun_info)) := sorry --non-trivial
lemma new_lemma_27508 (h0 : functor.add_const (ring (add_comm_monoid name)) name) : @is_principal_ideal_ring.{0} (add_comm_monoid.{0} name) (@functor.add_const.run.{0 0} (ring.{0} (add_comm_monoid.{0} name)) name h0)  := sorry --non-trivial
lemma new_lemma_27509 (h0 : topological_space (finset (has_to_string (has_to_string num)))) : t1_space (finset (has_to_string (has_to_string num))) := sorry --non-trivial
lemma new_lemma_27510 (h0 : ring (topological_space (comm_ring char))) : rank_condition (topological_space (comm_ring char)) := sorry --non-trivial
lemma new_lemma_27511 (h0 : functor.comp ring boolean_algebra.core Type) : @is_principal_ideal_ring.{1} (boolean_algebra.core.{1} Type) (@functor.comp.run.{1 1 1} ring.{1} boolean_algebra.core.{1} Type h0)  := sorry --non-trivial
lemma new_lemma_27512 (h0 : function.extfun Type list) : list.nodup (function.extfun_app h0 (complete_distrib_lattice ennreal)) := sorry --non-trivial
lemma new_lemma_27513 (h3 : complete_lattice (has_ssubset reducibility_hints)) : is_compactly_generated (has_ssubset reducibility_hints) := sorry --non-trivial
lemma new_lemma_27514 (h0 : functor.add_const (function.extfun (Type 1) add_group) (has_neg linarith.comp)) : @is_add_cyclic.{1} (canonically_ordered_comm_semiring.{1} Type) (@function.extfun_app.{3 2} (Type 1) add_group.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) add_group.{1}) (has_neg.{0} linarith.comp) h0) (canonically_ordered_comm_semiring.{1} Type))  := sorry --non-trivial
lemma new_lemma_27515 (h0 : functor.add_const (uniform_space (cancel_monoid linarith.comp)) linarith.comp) : @complete_space.{0} (cancel_monoid.{0} linarith.comp) (@functor.add_const.run.{0 0} (uniform_space.{0} (cancel_monoid.{0} linarith.comp)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_27516 (h0 : has_mem.mem (semiring to_additive.value_type) has_emptyc.emptyc) : @separated_space.{0} (semiring.{0} to_additive.value_type) (@finset.pi.empty.{1 0} Type uniform_space.{0} (semiring.{0} to_additive.value_type) h0)  := sorry --non-trivial
lemma new_lemma_27517 (h0 : cancel_comm_monoid_with_zero (mul_zero_class (semiring (semiring num)))) : unique_factorization_monoid (mul_zero_class (semiring (semiring num))) := sorry --non-trivial
lemma new_lemma_27518 (h0 : group (comm_ring (random_gen fun_info))) : group.fg (comm_ring (random_gen fun_info)) := sorry --non-trivial
lemma new_lemma_27519 (h0 : functor.add_const (add_monoid (canonically_ordered_comm_semiring name)) environment.implicit_infer_kind) : @add_monoid.fg.{0} (canonically_ordered_comm_semiring.{0} name) (@functor.add_const.run.{0 0} (add_monoid.{0} (canonically_ordered_comm_semiring.{0} name)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_27520 (h0 : fin has_zero.zero) : @preconnected_space.{0} (has_pos_part.{0} real) (@matrix.vec_empty.{0} (topological_space.{0} (has_pos_part.{0} real)) h0)  := sorry --non-trivial
lemma new_lemma_27521 (h0 : topological_space (semigroup (finset pos))) : loc_path_connected_space (semigroup (finset pos)) := sorry --non-trivial
lemma new_lemma_27522 (h1 : function.extfun Type group) : @normalizer_condition.{0} (complete_semilattice_Sup.{0} string_imp) (@function.extfun_app.{2 1} Type group.{0} h1 (complete_semilattice_Sup.{0} string_imp))  := sorry --non-trivial
lemma new_lemma_27523 (h0 : add_monoid (ring (has_pos_part (has_add linarith.comp)))) : add_monoid.fg (ring (has_pos_part (has_add linarith.comp))) := sorry --non-trivial
lemma new_lemma_27524 (h0 : functor.add_const (topological_space (has_zero unsigned)) unsigned) : @t0_space.{0} (has_zero.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (has_zero.{0} unsigned)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_27525 (h0 : functor.add_const (function.extfun (Type 1) ordered_add_comm_monoid) Type) : @archimedean.{1} (has_neg.{1} Type) (@function.extfun_app.{3 2} (Type 1) ordered_add_comm_monoid.{1} (@functor.add_const.run.{2 1} (function.extfun.{3 2} (Type 1) ordered_add_comm_monoid.{1}) Type h0) (has_neg.{1} Type))  := sorry --non-trivial
lemma new_lemma_27526 (h0 : complete_lattice (mul_zero_class unsigned)) : is_compactly_generated (mul_zero_class unsigned) := sorry --non-trivial
lemma new_lemma_27527 (h0 : not (ring (has_emptyc linarith.comp) -> false)) : @strong_rank_condition.{0} (has_emptyc.{0} linarith.comp) (@classical.by_contradiction'.{1} (ring.{0} (has_emptyc.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_27528 (h0 : functor.add_const (ring (cancel_monoid unsigned)) unsigned) : @is_principal_ideal_ring.{0} (cancel_monoid.{0} unsigned) (@functor.add_const.run.{0 0} (ring.{0} (cancel_monoid.{0} unsigned)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_27529 (h0 : nat -> Prop -> metric_space to_additive.value_type -> Prop) (h1 : nat) (h2 : Prop) (h3 : list (metric_space to_additive.value_type)) : list.foldl_with_index_aux_spec h0 h1 h2 h3 := sorry --non-trivial
lemma new_lemma_27530 (h0 : function.extfun Type topological_space) : @discrete_topology.{0} (ring.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (ring.{0} pos))  := sorry --non-trivial
lemma new_lemma_27531 (h0 : has_lt (mul_one_class (normed_field fun_info))) : no_max_order (mul_one_class (normed_field fun_info)) := sorry --non-trivial
lemma new_lemma_27532 (h0 : topological_space (random_gen fun_info)) : irreducible_space (random_gen fun_info) := sorry --non-trivial
lemma new_lemma_27533 (h0 : function.extfun Type add_monoid) : add_monoid.fg (free_add_monoid empty) := sorry --non-trivial
lemma new_lemma_27534 (h0 : topological_space (normed_group empty)) : totally_separated_space (normed_group empty) := sorry --non-trivial
lemma new_lemma_27535 (h0 : function.extfun Type ring) : @is_domain.{0} fun_info (@function.extfun_app.{2 1} Type ring.{0} h0 fun_info)  := sorry --non-trivial
lemma new_lemma_27536 (h0 : ordered_add_comm_monoid (has_zero (has_to_string ennreal))) : archimedean (has_zero (has_to_string ennreal)) := sorry --non-trivial
lemma new_lemma_27537 (h0 : topological_space (has_nndist (has_add Type))) : sequential_space (has_nndist (has_add Type)) := sorry --non-trivial
lemma new_lemma_27538 (h0 : topological_space (add_cancel_monoid (ring Type))) : normal_space (add_cancel_monoid (ring Type)) := sorry --non-trivial
lemma new_lemma_27539 (h0 : functor.add_const (add_group (canonically_ordered_comm_semiring unsigned)) Type) : @is_add_cyclic.{0} (canonically_ordered_comm_semiring.{0} unsigned) (@functor.add_const.run.{0 1} (add_group.{0} (canonically_ordered_comm_semiring.{0} unsigned)) Type h0)  := sorry --non-trivial
lemma new_lemma_27540 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @has_exists_mul_of_le.{0} (has_neg.{0} pos) (@function.extfun_app.{2 1} Type ordered_comm_monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ordered_comm_monoid.{0}) (has_neg.{0} pos))  := sorry --non-trivial
lemma new_lemma_27541 (h0 : add_group (add_right_cancel_monoid empty)) : is_add_cyclic (add_right_cancel_monoid empty) := sorry --non-trivial
lemma new_lemma_27542 (h0 : function.extfun ((Type -> Type) -> Type 1) (function.extfun (Type -> Type))) : @normalizer_condition.{0} (has_inv.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) (@function.extfun_app.{3 2} ((Type → Type) → Type 1) (function.extfun.{2 2} (Type → Type)) h0 (function.extfun.{2 1} Type)) group.{0}) (has_inv.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_27543 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @locally_compact_space.{0} (has_ssubset.{0} string_imp) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_ssubset.{0} string_imp))  := sorry --non-trivial
lemma new_lemma_27544 (h0 : topological_space (id unsigned)) : preirreducible_space (id unsigned) := sorry --non-trivial
lemma new_lemma_27545 (h0 : measurable_space (measurable_space linarith.comp)) (h1 : has_div (measurable_space linarith.comp)) : has_measurable_div₂ (measurable_space linarith.comp) := sorry --non-trivial
lemma new_lemma_27546 (h0 : ring (ring (has_Inf (ordered_ring (ring linarith.comp))))) : is_domain (ring (has_Inf (ordered_ring (ring linarith.comp)))) := sorry --non-trivial
lemma new_lemma_27547 (h0 : has_mem.mem (has_emptyc to_additive.value_type) has_emptyc.emptyc) : @monoid.fg.{0} (has_emptyc.{0} to_additive.value_type) (@finset.pi.empty.{1 0} Type monoid.{0} (has_emptyc.{0} to_additive.value_type) h0)  := sorry --non-trivial
lemma new_lemma_27548 (h0 : complete_lattice (has_add (group_with_zero (option pos)))) : is_atomistic (has_add (group_with_zero (option pos))) := sorry --non-trivial
lemma new_lemma_27549 (h0 : complete_lattice (cancel_monoid (has_add (has_add pos)))) : is_compactly_generated (cancel_monoid (has_add (has_add pos))) := sorry --non-trivial
lemma new_lemma_27550 (h0 : topological_space (has_neg_part (comm_group name))) : totally_disconnected_space (has_neg_part (comm_group name)) := sorry --non-trivial
lemma new_lemma_27551 (h0 : group (boolean_algebra (has_add (has_add (add_cancel_monoid pos))))) : normalizer_condition (boolean_algebra (has_add (has_add (add_cancel_monoid pos)))) := sorry --non-trivial
lemma new_lemma_27552 (h0 : list (boolean_algebra (has_add unsigned))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_27553 (h0 : topological_space std_gen) (h1 : preorder std_gen) : order_closed_topology std_gen := sorry --non-trivial
lemma new_lemma_27554 (h0 : topological_space (boolean_algebra.core name)) : path_connected_space (boolean_algebra.core name) := sorry --non-trivial
lemma new_lemma_27555 (h0 : topological_space (finset empty)) : preirreducible_space (finset empty) := sorry --non-trivial
lemma new_lemma_27556 (h0 : functor.add_const (filter (has_to_string pos)) pos) : countable_Inter_filter (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_27557 (h0 : fin has_zero.zero) : @t0_space.{0} (has_pos_part.{0} pos) (@matrix.vec_empty.{0} (topological_space.{0} (has_pos_part.{0} pos)) h0)  := sorry --non-trivial
lemma new_lemma_27558 (h0 : functor.comp topological_space semigroup (complete_distrib_lattice pos)) : @totally_disconnected_space.{0} (semigroup.{0} (complete_distrib_lattice.{0} pos)) (@functor.comp.run.{0 0 0} topological_space.{0} semigroup.{0} (complete_distrib_lattice.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_27559 (h0 : functor.add_const (complete_lattice (add_comm_monoid linarith.comp)) linarith.comp) : @is_atomistic.{0} (add_comm_monoid.{0} linarith.comp) (@functor.add_const.run.{0 0} (complete_lattice.{0} (add_comm_monoid.{0} linarith.comp)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_27560 (h0 : function.extfun Type topological_space) : locally_compact_space real := sorry --non-trivial
lemma new_lemma_27561 (h0 : cancel_comm_monoid_with_zero (cancel_monoid (option (option unsigned)))) : unique_factorization_monoid (cancel_monoid (option (option unsigned))) := sorry --non-trivial
lemma new_lemma_27562 (h0 : not (function.extfun Type topological_space -> false)) : @locally_compact_space.{0} (with_bot.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (with_bot.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_27563 (h0 : complete_lattice (has_nnnorm fun_info)) : is_compactly_generated (has_nnnorm fun_info) := sorry --non-trivial
lemma new_lemma_27564 (h0 : add_monoid (ordered_comm_monoid (has_add (has_add (has_add pos))))) : add_monoid.fg (ordered_comm_monoid (has_add (has_add (has_add pos)))) := sorry --non-trivial
lemma new_lemma_27565 (h0 : functor.add_const (function.extfun (Type 1) topological_space) Type) : @topological_space.separable_space.{1} (simple_graph.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@functor.add_const.run.{2 1} (function.extfun.{3 2} (Type 1) topological_space.{1}) Type h0) (simple_graph.{1} Type))  := sorry --non-trivial
lemma new_lemma_27566 (h0 : ring (has_Inf (has_neg (has_add Type)))) : is_principal_ideal_ring (has_Inf (has_neg (has_add Type))) := sorry --non-trivial
lemma new_lemma_27567 (h0 : set (prod (has_top empty) (has_top empty))) : symmetric_rel h0 := sorry --non-trivial
lemma new_lemma_27568 (h0 : add_group (uniform_space (mul_one_class string_imp))) : is_add_cyclic (uniform_space (mul_one_class string_imp)) := sorry --non-trivial
lemma new_lemma_27569 (h0 : cancel_comm_monoid_with_zero (normed_comm_ring congr_arg_kind)) : unique_factorization_monoid (normed_comm_ring congr_arg_kind) := sorry --non-trivial
lemma new_lemma_27570 (h1 : function.extfun Type group) : @group.fg.{0} (has_top.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type group.{0} h1 (has_top.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_27571 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : palindrome (function.extfun_app (function.extfun_app h0 list) (normed_comm_ring ennreal)) := sorry --non-trivial
lemma new_lemma_27572 (h0 : functor.add_const (functor.comp complete_lattice boolean_algebra name) name) : @is_atomistic.{0} (boolean_algebra.{0} name) (@functor.comp.run.{0 0 0} complete_lattice.{0} boolean_algebra.{0} name (@functor.add_const.run.{0 0} (functor.comp.{0 0 0} complete_lattice.{0} boolean_algebra.{0} name) name h0))  := sorry --non-trivial
lemma new_lemma_27573 (h0 : functor.add_const (function.extfun Type group) Type) : @is_cyclic.{0} (cancel_monoid.{0} pos) (@function.extfun_app.{2 1} Type group.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type group.{0}) Type h0) (cancel_monoid.{0} pos))  := sorry --non-trivial
lemma new_lemma_27574 (h0 : topological_space (filter (omega_complete_partial_order unsigned))) : totally_separated_space (filter (omega_complete_partial_order unsigned)) := sorry --non-trivial
lemma new_lemma_27575 (h0 : function.extfun Type group) : @group.fg.{0} (@id.{2} Type string_imp) (@function.extfun_app.{2 1} Type group.{0} h0 (@id.{2} Type string_imp))  := sorry --non-trivial
lemma new_lemma_27576 (h0 : prod (has_union (semiring unsigned)) (has_union (semiring unsigned))) : id_rel h0 := sorry --non-trivial
lemma new_lemma_27577 (h0 : not (function.extfun Type topological_space -> false)) : @t0_space.{0} (random_gen.{0} fun_info) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (random_gen.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_27578 (h0 : complete_lattice (has_zero (option (option (option (option (option ennreal))))))) : is_atomistic (has_zero (option (option (option (option (option ennreal)))))) := sorry --non-trivial
lemma new_lemma_27579 (h0 : fin has_zero.zero) : @loc_path_connected_space.{0} (simple_graph.{0} linarith.comp) (@matrix.vec_empty.{0} (topological_space.{0} (simple_graph.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_27580 (h0 : ring (add_cancel_monoid (finset (finset unsigned)))) : is_principal_ideal_ring (add_cancel_monoid (finset (finset unsigned))) := sorry --non-trivial
lemma new_lemma_27581 (h0 : function.extfun Type filter) : filter.ne_bot (function.extfun_app h0 (normed_group empty)) := sorry --non-trivial
lemma new_lemma_27582 (h0 : monoid (random_gen (has_top (random_gen (random_gen linarith.ineq))))) : monoid.fg (random_gen (has_top (random_gen (random_gen linarith.ineq)))) := sorry --non-trivial
lemma new_lemma_27583 (h0 : function.extfun (Type 1) topological_space) : @sequential_space.{1} (has_Inf.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} h0 (has_Inf.{1} Type))  := sorry --non-trivial
lemma new_lemma_27584 (h0 : group (has_neg (semiring (semiring (semiring (semiring empty)))))) : normalizer_condition (has_neg (semiring (semiring (semiring (semiring empty))))) := sorry --non-trivial
lemma new_lemma_27585 (h0 : topological_space (semiring fun_info)) : path_connected_space (semiring fun_info) := sorry --non-trivial
lemma new_lemma_27586 (h0 : function.extfun (Type 1) group) : @is_simple_group.{1} (complete_distrib_lattice.{1} Type) (@function.extfun_app.{3 2} (Type 1) group.{1} h0 (complete_distrib_lattice.{1} Type))  := sorry --non-trivial
lemma new_lemma_27587 (h0 : ordered_comm_monoid (normed_comm_ring (option unsigned))) : has_exists_mul_of_le (normed_comm_ring (option unsigned)) := sorry --non-trivial
lemma new_lemma_27588 (h0 : not (function.extfun Type topological_space -> false)) : @totally_disconnected_space.{0} (has_norm.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (has_norm.{0} num))  := sorry --non-trivial
lemma new_lemma_27589 (h0 : uniform_space (complete_semilattice_Sup (random_gen (random_gen fun_info)))) : complete_space (complete_semilattice_Sup (random_gen (random_gen fun_info))) := sorry --non-trivial
lemma new_lemma_27590 (h0 : topological_space (option (semiring (semiring empty)))) : preirreducible_space (option (semiring (semiring empty))) := sorry --non-trivial
lemma new_lemma_27591 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_add_cyclic.{0} (linear_ordered_field.{0} (option.{0} pos)) (@function.extfun_app.{2 1} Type add_group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 add_group.{0}) (linear_ordered_field.{0} (option.{0} pos)))  := sorry --non-trivial
lemma new_lemma_27592 (h0 : filter (has_inv (random_gen string_imp))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_27593 (h0 : add_group (has_one (random_gen linarith.comp))) : is_add_cyclic (has_one (random_gen linarith.comp)) := sorry --non-trivial
lemma new_lemma_27594 (h0 : topological_space (measurable_space string_imp)) : locally_compact_space (measurable_space string_imp) := sorry --non-trivial
lemma new_lemma_27595 (h0 : complete_lattice (bin_tree (option unsigned))) : is_atomistic (bin_tree (option unsigned)) := sorry --non-trivial
lemma new_lemma_27596 (h0 : monoid (denumerable (random_gen string_imp))) : monoid.fg (denumerable (random_gen string_imp)) := sorry --non-trivial
lemma new_lemma_27597 (h0 : function.extfun (finset Type) (has_mem.mem (linear_ordered_semiring fun_info))) : @t0_space.{0} (linear_ordered_semiring.{0} fun_info) (@finset.pi.empty.{1 0} Type topological_space.{0} (linear_ordered_semiring.{0} fun_info) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (linear_ordered_semiring.{0} fun_info)) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_27598 (h0 : group (with_bot (semiring (measurable_space empty)))) : group.fg (with_bot (semiring (measurable_space empty))) := sorry --non-trivial
lemma new_lemma_27599 (h0 : cancel_comm_monoid_with_zero (linear_ordered_comm_ring empty)) (h1 : complete_lattice (gcd_monoid (linear_ordered_comm_ring empty))) : is_compactly_generated (gcd_monoid (linear_ordered_comm_ring empty)) := sorry --non-trivial
lemma new_lemma_27600 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @path_connected_space.{0} linarith.comp_source (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) linarith.comp_source)  := sorry --non-trivial
lemma new_lemma_27601 (h0 : add_monoid (canonically_ordered_add_monoid empty)) : add_monoid.fg (canonically_ordered_add_monoid empty) := sorry --non-trivial
lemma new_lemma_27602 (h0 : finset (comm_group (finset (has_neg environment.implicit_infer_kind)))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_27603 (h0 : function.extfun Type topological_space) : @topological_space.separable_space.{0} (has_pos_part.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_pos_part.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_27604 (h0 : functor.add_const (function.extfun Type ring) Type) : @rank_condition.{0} (has_to_string.{0} pos) (@function.extfun_app.{2 1} Type ring.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type ring.{0}) Type h0) (has_to_string.{0} pos))  := sorry --non-trivial
lemma new_lemma_27605 (h1 : ring (complete_semilattice_Sup (has_nnnorm (has_ssubset (random_gen (has_nnnorm string_imp)))))) : is_domain (complete_semilattice_Sup (has_nnnorm (has_ssubset (random_gen (has_nnnorm string_imp))))) := sorry --non-trivial
lemma new_lemma_27606 (h0 : topological_space (complete_distrib_lattice environment.implicit_infer_kind)) : locally_compact_space (complete_distrib_lattice environment.implicit_infer_kind) := sorry --non-trivial
lemma new_lemma_27607 (h0 : topological_space (has_norm (comm_ring fun_info))) : totally_disconnected_space (has_norm (comm_ring fun_info)) := sorry --non-trivial
lemma new_lemma_27608 (h0 : set (set (simple_graph environment.projection_info))) (h1 : set (simple_graph environment.projection_info)) : measurable_space.dynkin_system.generate_has h0 h1 := sorry --non-trivial
lemma new_lemma_27609 (h0 : topological_space linarith.comp_source) : path_connected_space linarith.comp_source := sorry --non-trivial
lemma new_lemma_27610 (h0 : topological_space (has_neg_part (has_add ennreal))) : locally_compact_space (has_neg_part (has_add ennreal)) := sorry --non-trivial
lemma new_lemma_27611 (h0 : complete_lattice (mul_zero_class (semiring (semiring (semiring congr_arg_kind))))) : is_atomistic (mul_zero_class (semiring (semiring (semiring congr_arg_kind)))) := sorry --non-trivial
lemma new_lemma_27612 (h0 : topological_space (ordered_comm_ring real)) : irreducible_space (ordered_comm_ring real) := sorry --non-trivial
lemma new_lemma_27613 (h0 : ring (has_one (has_top empty))) : is_domain (has_one (has_top empty)) := sorry --non-trivial
lemma new_lemma_27614 (h0 : ring (has_neg unsigned)) : is_domain (has_neg unsigned) := sorry --non-trivial
lemma new_lemma_27615 (h0 : measurable_space char -> measurable_space char -> Prop) : is_total (measurable_space char) h0 := sorry --non-trivial
lemma new_lemma_27616 (h0 : ordered_add_comm_monoid (normed_lattice_add_comm_group (has_Inf (has_Inf (ordered_comm_monoid real))))) : archimedean (normed_lattice_add_comm_group (has_Inf (has_Inf (ordered_comm_monoid real)))) := sorry --non-trivial
lemma new_lemma_27617 (h0 : group (has_to_string (has_to_string (has_to_string pos)))) : group.fg (has_to_string (has_to_string (has_to_string pos))) := sorry --non-trivial
lemma new_lemma_27618 (h0 : ring (has_neg_part (comm_group (comm_group (comm_group name))))) : strong_rank_condition (has_neg_part (comm_group (comm_group (comm_group name)))) := sorry --non-trivial
lemma new_lemma_27619 (h0 : filter (add_comm_monoid (comm_group (comm_group unsigned)))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_27620 (h0 : functor.add_const (group (boolean_algebra.core unsigned)) congr_arg_kind) : @is_cyclic.{0} (boolean_algebra.core.{0} unsigned) (@functor.add_const.run.{0 0} (group.{0} (boolean_algebra.core.{0} unsigned)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_27621 (h0 : topological_space (canonically_linear_ordered_monoid (option unsigned))) : loc_path_connected_space (canonically_linear_ordered_monoid (option unsigned)) := sorry --non-trivial
lemma new_lemma_27622 (h1 : topological_space (denumerable reducibility_hints)) : t0_space (denumerable reducibility_hints) := sorry --non-trivial
lemma new_lemma_27623 (h0 : complete_lattice (measurable_space (has_norm (has_norm linarith.comp)))) : is_atomistic (measurable_space (has_norm (has_norm linarith.comp))) := sorry --non-trivial
lemma new_lemma_27624 (h0 : uniform_space (add_comm_monoid (finset Type))) : complete_space (add_comm_monoid (finset Type)) := sorry --non-trivial
lemma new_lemma_27625 (h0 : functor.add_const (add_monoid (has_zero Type)) (has_add Type)) : @add_monoid.fg.{1} (has_zero.{1} Type) (@functor.add_const.run.{1 1} (add_monoid.{1} (has_zero.{1} Type)) (has_add.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_27626 (h0 : ring (measurable_space.dynkin_system (semiring (has_norm congr_arg_kind)))) : strong_rank_condition (measurable_space.dynkin_system (semiring (has_norm congr_arg_kind))) := sorry --non-trivial
lemma new_lemma_27627 (h0 : functor.add_const (monoid (has_add pos)) environment.implicit_infer_kind) : @monoid.fg.{0} (has_add.{0} pos) (@functor.add_const.run.{0 0} (monoid.{0} (has_add.{0} pos)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_27628 (h0 : functor.add_const (topological_space (has_Sup empty)) congr_arg_kind) : @irreducible_space.{0} (has_Sup.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (has_Sup.{0} empty)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_27629 (h0 : function.extfun Type ring) : @is_domain.{0} (generalized_boolean_algebra.{0} linarith.comp) (@function.extfun_app.{2 1} Type ring.{0} h0 (generalized_boolean_algebra.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_27630 (h0 : functor.add_const (add_monoid (has_neg name)) (option (option (option name)))) : @add_monoid.fg.{0} (has_neg.{0} name) (@functor.add_const.run.{0 0} (add_monoid.{0} (has_neg.{0} name)) (option.{0} (option.{0} (option.{0} name))) h0)  := sorry --non-trivial
lemma new_lemma_27631 (h0 h1 : multiset (nondiscrete_normed_field (add_comm_semigroup fun_info))) : multiset.subset h0 h1 := sorry --non-trivial
lemma new_lemma_27632 (h0 : ring (semigroup (semiring (semiring (semiring congr_arg_kind))))) : rank_condition (semigroup (semiring (semiring (semiring congr_arg_kind)))) := sorry --non-trivial
lemma new_lemma_27633 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @preconnected_space.{0} (add_cancel_monoid.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (add_cancel_monoid.{0} pos))  := sorry --non-trivial
lemma new_lemma_27634 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : filter.ne_bot (function.extfun_app (function.extfun_app h0 filter) (distrib_lattice string_imp)) := sorry --non-trivial
lemma new_lemma_27635 (h0 : functor.add_const Prop (semigroup Type)) : functor.add_const.run h0 := sorry --non-trivial
lemma new_lemma_27636 (h0 : ring (has_bot (has_add (has_add linarith.comp)))) : rank_condition (has_bot (has_add (has_add linarith.comp))) := sorry --non-trivial
lemma new_lemma_27637 (h0 : filter (ordered_comm_ring (has_Inf pos))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_27638 (h0 : functor.add_const (function.extfun Type ring) name) : @is_principal_ideal_ring.{0} (semigroup.{0} name) (@function.extfun_app.{2 1} Type ring.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type ring.{0}) name h0) (semigroup.{0} name))  := sorry --non-trivial
lemma new_lemma_27639 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @topological_space.separable_space.{0} (boolean_algebra.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (boolean_algebra.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_27640 (h0 : complete_lattice (has_top (has_norm (has_top to_additive.value_type)))) : complete_lattice.is_Sup_finite_compact (has_top (has_norm (has_top to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_27641 (h0 : topological_space (has_ssubset (has_nnnorm (has_nnnorm fun_info)))) : path_connected_space (has_ssubset (has_nnnorm (has_nnnorm fun_info))) := sorry --non-trivial
lemma new_lemma_27642 (h0 : fin has_zero.zero) : @sequential_space.{0} (normed_lattice_add_comm_group.{0} real) (@function.extfun_app.{2 1} Type topological_space.{0} (@matrix.vec_empty.{1} (function.extfun.{2 1} Type topological_space.{0}) h0) (normed_lattice_add_comm_group.{0} real))  := sorry --non-trivial
lemma new_lemma_27643 (h2 : topological_space (has_emptyc congr_arg_kind)) : locally_compact_space (has_emptyc congr_arg_kind) := sorry --non-trivial
lemma new_lemma_27644 (h0 : uniform_space (has_pos_part (finset (finset (ring linarith.comp))))) : separated_space (has_pos_part (finset (finset (ring linarith.comp)))) := sorry --non-trivial
lemma new_lemma_27645 (h0 : topological_space (has_norm (metric_space (semiring empty)))) : normal_space (has_norm (metric_space (semiring empty))) := sorry --non-trivial
lemma new_lemma_27646 (h0 : topological_space real) : locally_compact_space real := sorry --non-trivial
lemma new_lemma_27647 (h0 : measurable_space std_gen) (h1 : topological_space std_gen) (h2 : measure_theory.measure std_gen) : measure_theory.measure.outer_regular h2 := sorry --non-trivial
lemma new_lemma_27648 (h0 : not (uniform_space (measurable_space fun_info) -> false)) : @separated_space.{0} (measurable_space.{0} fun_info) (@classical.by_contradiction'.{1} (uniform_space.{0} (measurable_space.{0} fun_info)) h0)  := sorry --non-trivial
lemma new_lemma_27649 (h0 : functor.add_const (topological_space (partial_order congr_arg_kind)) empty) : @totally_separated_space.{0} (partial_order.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (partial_order.{0} congr_arg_kind)) empty h0)  := sorry --non-trivial
lemma new_lemma_27650 (h0 : topological_space (comm_group (has_to_string pos))) : preirreducible_space (comm_group (has_to_string pos)) := sorry --non-trivial
lemma new_lemma_27651 (h0 : group (finset (finset (has_neg environment.implicit_infer_kind)))) : group.fg (finset (finset (has_neg environment.implicit_infer_kind))) := sorry --non-trivial
lemma new_lemma_27652 (h0 : function.extfun Type ordered_comm_monoid) : @has_exists_mul_of_le.{0} (has_add.{0} real) (@function.extfun_app.{2 1} Type ordered_comm_monoid.{0} h0 (has_add.{0} real))  := sorry --non-trivial
lemma new_lemma_27653 (h0 : topological_space (boolean_algebra (has_bot (has_Inf pos)))) : sequential_space (boolean_algebra (has_bot (has_Inf pos))) := sorry --non-trivial
lemma new_lemma_27654 (h0 : function.extfun Type topological_space) : @locally_compact_space.{0} (add_comm_monoid.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (add_comm_monoid.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_27655 (h0 : topological_space (linear_ordered_semiring linarith.comp)) : locally_compact_space (linear_ordered_semiring linarith.comp) := sorry --non-trivial
lemma new_lemma_27656 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @group.fg.{0} pos (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) pos)  := sorry --non-trivial
lemma new_lemma_27657 (h0 : functor.add_const (topological_space (add_cancel_monoid pos)) Type) : @normal_space.{0} (add_cancel_monoid.{0} pos) (@functor.add_const.run.{0 1} (topological_space.{0} (add_cancel_monoid.{0} pos)) Type h0)  := sorry --non-trivial
lemma new_lemma_27658 (h1 : complete_lattice (id to_additive.value_type)) : complete_lattice.is_Sup_finite_compact (id to_additive.value_type) := sorry --non-trivial
lemma new_lemma_27659 (h0 : list (complete_distrib_lattice (cancel_monoid (has_to_string pos)))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_27660 (h0 : functor.add_const (complete_lattice (generalized_boolean_algebra Type)) pos) : @complete_lattice.is_Sup_finite_compact.{1} (generalized_boolean_algebra.{1} Type) (@functor.add_const.run.{1 0} (complete_lattice.{1} (generalized_boolean_algebra.{1} Type)) pos h0)  := sorry --non-trivial
lemma new_lemma_27661 (h0 : functor.add_const (ordered_comm_monoid (cancel_monoid pos)) pos) : @has_exists_mul_of_le.{0} (cancel_monoid.{0} pos) (@functor.add_const.run.{0 0} (ordered_comm_monoid.{0} (cancel_monoid.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_27662 (h1 : not (complete_lattice (add_cancel_comm_monoid linarith.comp_source) -> false)) : @complete_lattice.is_Sup_finite_compact.{0} (add_cancel_comm_monoid.{0} linarith.comp_source) (@classical.by_contradiction'.{1} (complete_lattice.{0} (add_cancel_comm_monoid.{0} linarith.comp_source)) h1)  := sorry --non-trivial
lemma new_lemma_27663 (h0 : functor.add_const (group (boolean_algebra linarith.comp)) environment.implicit_infer_kind) : @group.fg.{0} (boolean_algebra.{0} linarith.comp) (@functor.add_const.run.{0 0} (group.{0} (boolean_algebra.{0} linarith.comp)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_27664 (h0 : function.extfun Type group) : @is_cyclic.{0} (has_emptyc.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type group.{0} h0 (has_emptyc.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_27665 (h0 : set (has_nnnorm (semi_normed_comm_ring to_additive.value_type))) : set.finite h0 := sorry --non-trivial
lemma new_lemma_27666 (h0 : cancel_comm_monoid_with_zero (has_to_string (ring (finset (finset (ring linarith.comp)))))) : unique_factorization_monoid (has_to_string (ring (finset (finset (ring linarith.comp))))) := sorry --non-trivial
lemma new_lemma_27667 (h0 : ring (has_bot name)) : strong_rank_condition (has_bot name) := sorry --non-trivial
lemma new_lemma_27668 (h0 : list (cancel_monoid (cancel_monoid environment.implicit_infer_kind))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_27669 (h1 : complete_lattice (with_zero char)) : complete_lattice.is_Sup_finite_compact (with_zero char) := sorry --non-trivial
lemma new_lemma_27670 (h0 : function.extfun Type ring) : @strong_rank_condition.{0} (add_cancel_monoid.{0} empty) (@function.extfun_app.{2 1} Type ring.{0} h0 (add_cancel_monoid.{0} empty))  := sorry --non-trivial
lemma new_lemma_27671 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @group.fg.{0} (mul_zero_class.{0} pos) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (mul_zero_class.{0} pos))  := sorry --non-trivial
lemma new_lemma_27672 (h0 : ring (has_neg_part (boolean_algebra.core name))) : strong_rank_condition (has_neg_part (boolean_algebra.core name)) := sorry --non-trivial
lemma new_lemma_27673 (h0 : list (linear_ordered_add_comm_group (has_top (random_gen linarith.comp_source)))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_27674 (h0 : add_group (random_gen (has_zero fun_info))) : is_add_cyclic (random_gen (has_zero fun_info)) := sorry --non-trivial
lemma new_lemma_27675 (h0 : topological_space (distrib_lattice (random_gen to_additive.value_type))) : totally_separated_space (distrib_lattice (random_gen to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_27676 (h0 : functor.add_const (ring (boolean_algebra Type)) (has_to_string environment.implicit_infer_kind)) : @is_principal_ideal_ring.{1} (boolean_algebra.{1} Type) (@functor.add_const.run.{1 0} (ring.{1} (boolean_algebra.{1} Type)) (has_to_string.{0} environment.implicit_infer_kind) h0)  := sorry --non-trivial
lemma new_lemma_27677 (h0 : uniform_space (boolean_algebra.core (finset (boolean_algebra.core (finset (ring Type)))))) : separated_space (boolean_algebra.core (finset (boolean_algebra.core (finset (ring Type))))) := sorry --non-trivial
lemma new_lemma_27678 (h0 : fin has_zero.zero) : @is_simple_group.{0} (sub_neg_monoid.{0} name) (@function.extfun_app.{2 1} Type group.{0} (@matrix.vec_empty.{1} (function.extfun.{2 1} Type group.{0}) h0) (sub_neg_monoid.{0} name))  := sorry --non-trivial
lemma new_lemma_27679 (h0 : list (random_gen (has_ssubset (random_gen linarith.ineq)))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_27680 (h0 : uniform_space (has_to_string (has_sub linarith.comp))) : separated_space (has_to_string (has_sub linarith.comp)) := sorry --non-trivial
lemma new_lemma_27681 (h0 : function.extfun Type topological_space) : @loc_path_connected_space.{0} (has_neg.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_neg.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_27682 (h0 : functor.add_const (group (complete_distrib_lattice num)) empty) : @is_cyclic.{0} (complete_distrib_lattice.{0} num) (@functor.add_const.run.{0 0} (group.{0} (complete_distrib_lattice.{0} num)) empty h0)  := sorry --non-trivial
lemma new_lemma_27683 (h0 : has_mem.mem (has_emptyc congr_arg_kind) has_emptyc.emptyc) : @separated_space.{0} (has_emptyc.{0} congr_arg_kind) (@finset.pi.empty.{1 0} Type uniform_space.{0} (has_emptyc.{0} congr_arg_kind) h0)  := sorry --non-trivial
lemma new_lemma_27684 (h0 : complete_lattice (canonically_ordered_monoid pos)) : is_atomistic (canonically_ordered_monoid pos) := sorry --non-trivial
lemma new_lemma_27685 (h0 : functor.add_const (function.extfun (Type 1) topological_space) Type) : @t0_space.{1} (semigroup.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@functor.add_const.run.{2 1} (function.extfun.{3 2} (Type 1) topological_space.{1}) Type h0) (semigroup.{1} Type))  := sorry --non-trivial
lemma new_lemma_27686 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @unique_factorization_monoid.{0} (pseudo_metric_space.{0} empty) (@function.extfun_app.{2 1} Type cancel_comm_monoid_with_zero.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 cancel_comm_monoid_with_zero.{0}) (pseudo_metric_space.{0} empty))  := sorry --non-trivial
lemma new_lemma_27687 (h0 : functor.add_const (topological_space (finset Type)) linarith.comp) : @t0_space.{1} (finset.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (finset.{1} Type)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_27688 (h0 : topological_space (has_norm (has_top num))) : totally_separated_space (has_norm (has_top num)) := sorry --non-trivial
lemma new_lemma_27689 (h0 : fin has_zero.zero) : @normal_space.{1} (generalized_boolean_algebra.{1} Type) (@matrix.vec_empty.{1} (topological_space.{1} (generalized_boolean_algebra.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_27690 (h1 : function.extfun (Type -> Type) (function.extfun Type)) : @complete_space.{0} congr_arg_kind (@function.extfun_app.{2 1} Type uniform_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h1 uniform_space.{0}) congr_arg_kind)  := sorry --non-trivial
lemma new_lemma_27691 (h0 : not (function.extfun Type topological_space -> false)) : @totally_disconnected_space.{0} (with_bot.{0} linarith.ineq) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (with_bot.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_27692 (h0 : topological_space (complete_distrib_lattice (ring (ring Type)))) : t0_space (complete_distrib_lattice (ring (ring Type))) := sorry --non-trivial
lemma new_lemma_27693 (h0 : functor.add_const (topological_space (has_Sup congr_arg_kind)) empty) : @loc_path_connected_space.{0} (has_Sup.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (has_Sup.{0} congr_arg_kind)) empty h0)  := sorry --non-trivial
lemma new_lemma_27694 (h0 : functor.add_const (topological_space (mul_zero_class empty)) empty) : @normal_space.{0} (mul_zero_class.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (mul_zero_class.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_27695 (h0 : topological_space (linear_ordered_comm_ring (semiring (semiring congr_arg_kind)))) : path_connected_space (linear_ordered_comm_ring (semiring (semiring congr_arg_kind))) := sorry --non-trivial
lemma new_lemma_27696 (h0 : not (topological_space (linear_ordered_comm_group_with_zero linarith.comp_source) -> false)) : @path_connected_space.{0} (linear_ordered_comm_group_with_zero.{0} linarith.comp_source) (@classical.by_contradiction'.{1} (topological_space.{0} (linear_ordered_comm_group_with_zero.{0} linarith.comp_source)) h0)  := sorry --non-trivial
lemma new_lemma_27697 (h0 : not (function.extfun Type topological_space -> false)) : @locally_compact_space.{0} (has_top.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (has_top.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_27698 (h0 : function.extfun Type ring) : @is_domain.{0} (has_to_string.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type ring.{0} h0 (has_to_string.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_27699 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @irreducible_space.{0} znum (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) znum)  := sorry --non-trivial
lemma new_lemma_27700 (h1 : function.extfun Type complete_lattice) : complete_lattice.is_Sup_finite_compact (measurable_space to_additive.value_type) := sorry --non-trivial
lemma new_lemma_27701 (h0 : topological_space (finset (has_neg (finset (has_pos_part (mul_one_class Type)))))) : t0_space (finset (has_neg (finset (has_pos_part (mul_one_class Type))))) := sorry --non-trivial
lemma new_lemma_27702 (h1 : topological_space (fintype to_additive.value_type)) : t0_space (fintype to_additive.value_type) := sorry --non-trivial
lemma new_lemma_27703 (h0 : function.extfun (nat -> Type) (function.extfun nat)) : @is_noetherian_ring.{0} (sub_neg_monoid.{0} pos) (@matrix.vec_empty.{0} (semiring.{0} (sub_neg_monoid.{0} pos)) (@function.extfun_app.{1 1} nat fin (@function.extfun_app.{2 1} (nat → Type) (function.extfun.{1 1} nat) h0 fin) (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_27704 (h1 : add_comm_semigroup ereal -> add_comm_semigroup ereal -> add_comm_semigroup ereal) (h2 : add_comm_semigroup ereal) : right_identity h1 h2 := sorry --non-trivial
lemma new_lemma_27705 (h0 : functor.add_const (topological_space (semigroup environment.implicit_infer_kind)) pos) : @preirreducible_space.{0} (semigroup.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (semigroup.{0} environment.implicit_infer_kind)) pos h0)  := sorry --non-trivial
lemma new_lemma_27706 (h0 : not (ring (metric_space num) -> false)) : @rank_condition.{0} (metric_space.{0} num) (@classical.by_contradiction'.{1} (ring.{0} (metric_space.{0} num)) h0)  := sorry --non-trivial
lemma new_lemma_27707 (h0 : uniform_space (semi_normed_comm_ring (has_nnnorm fun_info))) : complete_space (semi_normed_comm_ring (has_nnnorm fun_info)) := sorry --non-trivial
lemma new_lemma_27708 (h2 : topological_space (has_compl string_imp)) : t0_space (has_compl string_imp) := sorry --non-trivial
lemma new_lemma_27709 (h0 : uniform_space (has_Sup (add_right_cancel_monoid empty))) : separated_space (has_Sup (add_right_cancel_monoid empty)) := sorry --non-trivial
lemma new_lemma_27710 (h0 : functor.add_const Prop (ordered_ring (option unsigned))) : functor.add_const.run h0 := sorry --non-trivial
lemma new_lemma_27711 (h0 : topological_space (div_inv_monoid (has_ssubset string_imp))) : path_connected_space (div_inv_monoid (has_ssubset string_imp)) := sorry --non-trivial
lemma new_lemma_27712 (h0 : function.extfun Type uniform_space) : @complete_space.{0} (comm_group.{0} string_imp) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (comm_group.{0} string_imp))  := sorry --non-trivial
lemma new_lemma_27713 (h0 : function.extfun Type topological_space) : @locally_compact_space.{0} (add_group.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (add_group.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_27714 (h0 : function.extfun Type (functor.comp add_monoid has_nndist)) : @add_monoid.fg.{0} (has_nndist.{0} pos) (@functor.comp.run.{0 0 0} add_monoid.{0} has_nndist.{0} pos (@function.extfun_app.{2 1} Type (functor.comp.{0 0 0} add_monoid.{0} has_nndist.{0}) h0 pos))  := sorry --non-trivial
lemma new_lemma_27715 (h0 : complete_lattice (semiring (has_norm (has_top fun_info)))) : is_atomistic (semiring (has_norm (has_top fun_info))) := sorry --non-trivial
lemma new_lemma_27716 (h0 : functor.add_const (topological_space (canonically_ordered_comm_semiring pos)) pos) : @sequential_space.{0} (canonically_ordered_comm_semiring.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (canonically_ordered_comm_semiring.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_27717 (h0 : function.extfun Type list) : list.nodup (function.extfun_app h0 (id to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_27718 (h0 : group (boolean_algebra (comm_group name))) : normalizer_condition (boolean_algebra (comm_group name)) := sorry --non-trivial
lemma new_lemma_27719 (h0 : functor.add_const (uniform_space (has_zero name)) Type) : @separated_space.{0} (has_zero.{0} name) (@functor.add_const.run.{0 1} (uniform_space.{0} (has_zero.{0} name)) Type h0)  := sorry --non-trivial
lemma new_lemma_27720 (h0 : ring (has_union (metric_space empty))) : is_domain (has_union (metric_space empty)) := sorry --non-trivial
lemma new_lemma_27721 (h0 : functor.add_const (topological_space (sub_neg_monoid linarith.comp)) Type) : @totally_separated_space.{0} (sub_neg_monoid.{0} linarith.comp) (@functor.add_const.run.{0 1} (topological_space.{0} (sub_neg_monoid.{0} linarith.comp)) Type h0)  := sorry --non-trivial
lemma new_lemma_27722 (h0 : function.extfun Type (prod (add_cancel_monoid empty))) : id_rel (function.extfun_app h0 (add_cancel_monoid empty)) := sorry --non-trivial
lemma new_lemma_27723 (h0 : function.extfun Type topological_space) : @loc_path_connected_space.{0} (has_to_string.{0} (option.{0} pos)) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_to_string.{0} (option.{0} pos)))  := sorry --non-trivial
lemma new_lemma_27724 (h0 : topological_space (normed_field (comm_ring linarith.comp_source))) : t0_space (normed_field (comm_ring linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_27725 (h0 : topological_space (semiring (option (option unsigned)))) : totally_separated_space (semiring (option (option unsigned))) := sorry --non-trivial
lemma new_lemma_27726 (h0 : prod std_gen std_gen) : set.diagonal std_gen h0 := sorry --non-trivial
lemma new_lemma_27727 (h0 : group (add_left_cancel_semigroup empty)) : is_cyclic (add_left_cancel_semigroup empty) := sorry --non-trivial
lemma new_lemma_27728 (h0 : functor.add_const (topological_space (is_R_or_C empty)) empty) : @irreducible_space.{0} (is_R_or_C.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (is_R_or_C.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_27729 (h0 : topological_space (ordered_comm_ring (ring linarith.comp))) : sequential_space (ordered_comm_ring (ring linarith.comp)) := sorry --non-trivial
lemma new_lemma_27730 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : filter.ne_bot (function.extfun_app (function.extfun_app h0 filter) (random_gen empty)) := sorry --non-trivial
lemma new_lemma_27731 (h0 : not (uniform_space (measure_theory.measure_space congr_arg_kind) -> false)) : @separated_space.{0} (measure_theory.measure_space.{0} congr_arg_kind) (@classical.by_contradiction'.{1} (uniform_space.{0} (measure_theory.measure_space.{0} congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_27732 (h0 : std_gen -> enat -> Prop) : relator.bi_unique h0 := sorry --non-trivial
lemma new_lemma_27733 (h0 : not (add_monoid (mul_zero_class congr_arg_kind) -> false)) : @add_monoid.fg.{0} (mul_zero_class.{0} congr_arg_kind) (@classical.by_contradiction'.{1} (add_monoid.{0} (mul_zero_class.{0} congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_27734 (h0 : function.extfun Type (functor.add_const (uniform_space (linear_order empty)))) : @separated_space.{0} (linear_order.{0} empty) (@functor.add_const.run.{0 0} (uniform_space.{0} (linear_order.{0} empty)) empty (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (uniform_space.{0} (linear_order.{0} empty))) h0 empty))  := sorry --non-trivial
lemma new_lemma_27735 (h0 : complete_lattice (add_group (has_top unsigned))) : complete_lattice.is_Sup_finite_compact (add_group (has_top unsigned)) := sorry --non-trivial
lemma new_lemma_27736 (h0 : not (has_mem.mem (has_emptyc linarith.ineq) has_emptyc.emptyc -> false)) : @totally_separated_space.{0} (has_emptyc.{0} linarith.ineq) (@finset.pi.empty.{1 0} Type topological_space.{0} (has_emptyc.{0} linarith.ineq) (@classical.by_contradiction'.{0} (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (has_emptyc.{0} linarith.ineq) (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))) h0))  := sorry --non-trivial
lemma new_lemma_27737 (h0 : topological_space (with_bot (has_norm congr_arg_kind))) : preirreducible_space (with_bot (has_norm congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_27738 (h0 : not (monoid (option congr_arg_kind) -> false)) : @monoid.fg.{0} (option.{0} congr_arg_kind) (@classical.by_contradiction'.{1} (monoid.{0} (option.{0} congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_27739 (h0 : filter (has_top (has_norm (semiring linarith.comp)))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_27740 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @discrete_topology.{0} (@id.{2} Type linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (@id.{2} Type linarith.comp))  := sorry --non-trivial
lemma new_lemma_27741 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @totally_disconnected_space.{0} (canonically_ordered_comm_semiring.{0} ennreal) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (canonically_ordered_comm_semiring.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_27742 (h0 : functor.add_const (filter (add_cancel_monoid unsigned)) (ring pos)) : countable_Inter_filter (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_27743 (h0 : ring (with_bot (has_top linarith.ineq))) : is_domain (with_bot (has_top linarith.ineq)) := sorry --non-trivial
lemma new_lemma_27744 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @preconnected_space.{0} (ordered_comm_ring.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (ordered_comm_ring.{0} name))  := sorry --non-trivial
lemma new_lemma_27745 (h0 : topological_space (complete_distrib_lattice (comm_group name))) : t0_space (complete_distrib_lattice (comm_group name)) := sorry --non-trivial
lemma new_lemma_27746 (h0 : functor.add_const (monoid (add_cancel_monoid pos)) (comm_group name)) : @monoid.fg.{0} (add_cancel_monoid.{0} pos) (@functor.add_const.run.{0 0} (monoid.{0} (add_cancel_monoid.{0} pos)) (comm_group.{0} name) h0)  := sorry --non-trivial
lemma new_lemma_27747 (h0 : complete_lattice (normed_comm_ring (option (option (option unsigned))))) : complete_lattice.is_Sup_finite_compact (normed_comm_ring (option (option (option unsigned)))) := sorry --non-trivial
lemma new_lemma_27748 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @discrete_topology.{0} (with_bot.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (with_bot.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_27749 (h0 : ring (has_nnnorm (has_nnnorm (mul_one_class reducibility_hints)))) : is_domain (has_nnnorm (has_nnnorm (mul_one_class reducibility_hints))) := sorry --non-trivial
lemma new_lemma_27750 (h0 : group (canonically_ordered_add_monoid unsigned)) : normalizer_condition (canonically_ordered_add_monoid unsigned) := sorry --non-trivial
lemma new_lemma_27751 (h0 : functor.add_const (function.extfun Type group) (has_pos_part pos)) : @is_simple_group.{0} (ring.{0} linarith.comp) (@function.extfun_app.{2 1} Type group.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type group.{0}) (has_pos_part.{0} pos) h0) (ring.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_27752 (h0 : topological_space (boolean_algebra name)) : topological_space.separable_space (boolean_algebra name) := sorry --non-trivial
lemma new_lemma_27753 (h0 : ring (has_add (comm_group (semigroup name)))) : rank_condition (has_add (comm_group (semigroup name))) := sorry --non-trivial
lemma new_lemma_27754 (h0 : topological_space (boolean_algebra (has_neg (has_Inf (has_neg (has_Inf (has_Inf pos))))))) : totally_disconnected_space (boolean_algebra (has_neg (has_Inf (has_neg (has_Inf (has_Inf pos)))))) := sorry --non-trivial
lemma new_lemma_27755 (h0 : function.extfun Type topological_space) : @loc_path_connected_space.{0} (has_add.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_add.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_27756 (h0 : functor.add_const (ring (add_cancel_monoid name)) Type) : @is_domain.{0} (add_cancel_monoid.{0} name) (@functor.add_const.run.{0 1} (ring.{0} (add_cancel_monoid.{0} name)) Type h0)  := sorry --non-trivial
lemma new_lemma_27757 (h0 : functor.add_const (topological_space (ordered_comm_ring Type)) linarith.comp) : @preirreducible_space.{1} (ordered_comm_ring.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (ordered_comm_ring.{1} Type)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_27758 (h0 : functor.add_const (group (has_zero unsigned)) Type) : @group.fg.{0} (has_zero.{0} unsigned) (@functor.add_const.run.{0 1} (group.{0} (has_zero.{0} unsigned)) Type h0)  := sorry --non-trivial
lemma new_lemma_27759 (h0 : functor.comp topological_space complete_distrib_lattice Type) : @preirreducible_space.{1} (complete_distrib_lattice.{1} Type) (@functor.comp.run.{1 1 1} topological_space.{1} complete_distrib_lattice.{1} Type h0)  := sorry --non-trivial
lemma new_lemma_27760 (h0 : functor.add_const (semiring (finset pos)) pos) : @is_noetherian_ring.{0} (finset.{0} pos) (@functor.add_const.run.{0 0} (semiring.{0} (finset.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_27761 (h0 : not (function.extfun (Type -> Type) (function.extfun Type) -> false)) : @t0_space.{0} (has_emptyc.{0} fun_info) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) (@classical.by_contradiction'.{2} (function.extfun.{2 2} (Type → Type) (function.extfun.{2 1} Type)) h0) topological_space.{0}) (has_emptyc.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_27762 (h0 : functor.add_const (topological_space (non_assoc_semiring empty)) empty) : @totally_disconnected_space.{0} (non_assoc_semiring.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (non_assoc_semiring.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_27763 (h0 : functor.add_const (topological_space (semigroup Type)) Type) : @normal_space.{1} (semigroup.{1} Type) (@functor.add_const.run.{1 1} (topological_space.{1} (semigroup.{1} Type)) Type h0)  := sorry --non-trivial
lemma new_lemma_27764 (h0 : function.extfun (finset (Type -> Type)) (has_mem.mem complete_lattice)) : @is_compactly_generated.{0} (with_bot.{0} num) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) complete_lattice.{0} (@function.extfun_app.{2 0} (finset.{1} (Type → Type)) (@has_mem.mem.{1 1} (Type → Type) (finset.{1} (Type → Type)) (@finset.has_mem.{1} (Type → Type)) complete_lattice.{0}) h0 (@has_emptyc.emptyc.{1} (finset.{1} (Type → Type)) (@finset.has_emptyc.{1} (Type → Type))))) (with_bot.{0} num))  := sorry --non-trivial
lemma new_lemma_27765 (h0 : function.extfun Type add_monoid) : @add_monoid.fg.{0} (finset.{0} empty) (@function.extfun_app.{2 1} Type add_monoid.{0} h0 (finset.{0} empty))  := sorry --non-trivial
lemma new_lemma_27766 (h0 : functor.add_const (ring (normed_linear_ordered_group num)) num) : @rank_condition.{0} (normed_linear_ordered_group.{0} num) (@functor.add_const.run.{0 0} (ring.{0} (normed_linear_ordered_group.{0} num)) num h0)  := sorry --non-trivial
lemma new_lemma_27767 (h0 : functor.add_const (topological_space (normed_comm_ring environment.implicit_infer_kind)) Type) : @loc_path_connected_space.{0} (normed_comm_ring.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 1} (topological_space.{0} (normed_comm_ring.{0} environment.implicit_infer_kind)) Type h0)  := sorry --non-trivial
lemma new_lemma_27768 (h0 : function.extfun Type add_group) : @is_add_cyclic.{0} (canonically_ordered_comm_semiring.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type add_group.{0} h0 (canonically_ordered_comm_semiring.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_27769 (h0 : function.extfun Type topological_space) : @totally_disconnected_space.{0} (has_add.{0} ennreal) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_add.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_27770 (h0 : functor.add_const (group (add_cancel_monoid name)) unsigned) : @normalizer_condition.{0} (add_cancel_monoid.{0} name) (@functor.add_const.run.{0 0} (group.{0} (add_cancel_monoid.{0} name)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_27771 (h0 : topological_space (semigroup (comm_group (comm_group (comm_group name))))) : topological_space.separable_space (semigroup (comm_group (comm_group (comm_group name)))) := sorry --non-trivial
lemma new_lemma_27772 (h0 : set (uniform_space (mul_one_class (mul_one_class linarith.ineq)))) : set.finite h0 := sorry --non-trivial
lemma new_lemma_27773 (h0 : topological_space (sub_neg_monoid (has_Inf Type))) : totally_separated_space (sub_neg_monoid (has_Inf Type)) := sorry --non-trivial
lemma new_lemma_27774 (h0 : topological_space (has_bot (semiring (semiring (semiring empty))))) : t1_space (has_bot (semiring (semiring (semiring empty)))) := sorry --non-trivial
lemma new_lemma_27775 (h3 : ring (topological_space to_additive.value_type)) : is_domain (topological_space to_additive.value_type) := sorry --non-trivial
lemma new_lemma_27776 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_compactly_generated.{0} (generalized_boolean_algebra.{0} name) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (generalized_boolean_algebra.{0} name))  := sorry --non-trivial
lemma new_lemma_27777 (h0 : topological_space (has_star (semiring (semiring empty)))) : preirreducible_space (has_star (semiring (semiring empty))) := sorry --non-trivial
lemma new_lemma_27778 (h0 : left_cancel_semigroup (non_assoc_semiring num) -> left_cancel_semigroup (non_assoc_semiring num) -> Prop) : is_strict_order (left_cancel_semigroup (non_assoc_semiring num)) h0 := sorry --non-trivial
lemma new_lemma_27779 (h0 : cancel_comm_monoid_with_zero (canonically_linear_ordered_monoid (ordered_comm_monoid real))) : unique_factorization_monoid (canonically_linear_ordered_monoid (ordered_comm_monoid real)) := sorry --non-trivial
lemma new_lemma_27780 (h0 : topological_space (distrib_lattice (has_inv string_imp))) : t0_space (distrib_lattice (has_inv string_imp)) := sorry --non-trivial
lemma new_lemma_27781 (h0 : ordered_comm_monoid (finset (comm_group unsigned))) : has_exists_mul_of_le (finset (comm_group unsigned)) := sorry --non-trivial
lemma new_lemma_27782 (h0 : topological_space (random_gen fun_info)) : totally_separated_space (random_gen fun_info) := sorry --non-trivial
lemma new_lemma_27783 (h0 : ordered_add_comm_monoid (semigroup (option pos))) : archimedean (semigroup (option pos)) := sorry --non-trivial
lemma new_lemma_27784 (h0 : functor.add_const (functor.add_const Prop (generalized_boolean_algebra pos)) pos) : functor.add_const.run (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_27785 (h0 : function.extfun Type topological_space) : @totally_disconnected_space.{0} (lex.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (lex.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_27786 (h1 : topological_space (add_comm_semigroup ereal)) : totally_disconnected_space (add_comm_semigroup ereal) := sorry --non-trivial
lemma new_lemma_27787 (h0 : fun_info) (h1 : sym2 fun_info) : sym2.mem h0 h1 := sorry --non-trivial
lemma new_lemma_27788 (h0 : add_monoid (has_zero name)) : add_monoid.fg (has_zero name) := sorry --non-trivial
lemma new_lemma_27789 (h0 : not (function.extfun Type group -> false)) : @normalizer_condition.{0} (with_bot.{0} empty) (@function.extfun_app.{2 1} Type group.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type group.{0}) h0) (with_bot.{0} empty))  := sorry --non-trivial
lemma new_lemma_27790 (h0 : topological_space (add_cancel_monoid (normed_comm_ring ennreal))) : topological_space.separable_space (add_cancel_monoid (normed_comm_ring ennreal)) := sorry --non-trivial
lemma new_lemma_27791 (h0 : function.extfun (nat -> Type) (function.extfun nat)) : @group.fg.{0} (complete_distrib_lattice.{0} real) (@matrix.vec_empty.{0} (group.{0} (complete_distrib_lattice.{0} real)) (@function.extfun_app.{1 1} nat fin (@function.extfun_app.{2 1} (nat → Type) (function.extfun.{1 1} nat) h0 fin) (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_27792 (h0 : functor.add_const (filter (has_Sup empty)) num) : filter.ne_bot (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_27793 (h0 : ring (complete_distrib_lattice (has_Inf (has_Inf (has_repr pos))))) : is_principal_ideal_ring (complete_distrib_lattice (has_Inf (has_Inf (has_repr pos)))) := sorry --non-trivial
lemma new_lemma_27794 (h0 : ring (has_neg empty)) : is_principal_ideal_ring (has_neg empty) := sorry --non-trivial
lemma new_lemma_27795 (h0 : function.extfun Type add_monoid) : @add_monoid.fg.{0} (has_neg.{0} name) (@function.extfun_app.{2 1} Type add_monoid.{0} h0 (has_neg.{0} name))  := sorry --non-trivial
lemma new_lemma_27796 (h0 : function.extfun (Type 1) monoid) : @monoid.fg.{1} (boolean_algebra.{1} Type) (@function.extfun_app.{3 2} (Type 1) monoid.{1} h0 (boolean_algebra.{1} Type))  := sorry --non-trivial
lemma new_lemma_27797 (h0 : function.extfun Type complete_lattice) : @is_atomistic.{0} (with_one.{0} fun_info) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (with_one.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_27798 (h0 : add_group (add_left_cancel_monoid (has_inv linarith.ineq))) : is_add_cyclic (add_left_cancel_monoid (has_inv linarith.ineq)) := sorry --non-trivial
lemma new_lemma_27799 (h0 : topological_space (canonically_linear_ordered_monoid (option name))) : t0_space (canonically_linear_ordered_monoid (option name)) := sorry --non-trivial
lemma new_lemma_27800 (h0 : cancel_comm_monoid_with_zero subsingleton_info) : unique_factorization_monoid subsingleton_info := sorry --non-trivial
lemma new_lemma_27801 (h0 : group (boolean_algebra.core (finset (finset pos)))) : group.fg (boolean_algebra.core (finset (finset pos))) := sorry --non-trivial
lemma new_lemma_27802 (h0 : function.extfun nat fin) : @irreducible_space.{0} (simple_graph.{0} pos) (@matrix.vec_empty.{0} (topological_space.{0} (simple_graph.{0} pos)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_27803 (h0 : ordered_comm_monoid (ordered_comm_ring real)) : has_exists_mul_of_le (ordered_comm_ring real) := sorry --non-trivial
lemma new_lemma_27804 (h0 : set (has_nnnorm ereal)) : set.finite h0 := sorry --non-trivial
lemma new_lemma_27805 (h0 : functor.comp topological_space ring name) : @irreducible_space.{0} (ring.{0} name) (@functor.comp.run.{0 0 0} topological_space.{0} ring.{0} name h0)  := sorry --non-trivial
lemma new_lemma_27806 (h0 : topological_space (generalized_boolean_algebra (boolean_algebra.core linarith.comp))) : irreducible_space (generalized_boolean_algebra (boolean_algebra.core linarith.comp)) := sorry --non-trivial
lemma new_lemma_27807 (h0 : functor.add_const (topological_space (ordered_comm_ring pos)) linarith.comp) : @regular_space.{0} (ordered_comm_ring.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (ordered_comm_ring.{0} pos)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_27808 (h0 : not (topological_space (linear_ordered_semiring linarith.comp_source) -> false)) : @discrete_topology.{0} (linear_ordered_semiring.{0} linarith.comp_source) (@classical.by_contradiction'.{1} (topological_space.{0} (linear_ordered_semiring.{0} linarith.comp_source)) h0)  := sorry --non-trivial
lemma new_lemma_27809 (h0 : fin has_zero.zero) : preconnected_space real := sorry --non-trivial
lemma new_lemma_27810 (h0 : topological_space (comm_ring (random_gen linarith.ineq))) : locally_compact_space (comm_ring (random_gen linarith.ineq)) := sorry --non-trivial
lemma new_lemma_27811 (h0 : function.extfun Type topological_space) : @locally_compact_space.{0} (denumerable.{0} string_imp) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (denumerable.{0} string_imp))  := sorry --non-trivial
lemma new_lemma_27812 (h0 : function.extfun Type topological_space) : @loc_path_connected_space.{0} (pseudo_metric_space.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (pseudo_metric_space.{0} name))  := sorry --non-trivial
lemma new_lemma_27813 (h0 : ring (boolean_algebra enat)) : is_domain (boolean_algebra enat) := sorry --non-trivial
lemma new_lemma_27814 (h0 : ring (semigroup (has_add linarith.comp))) : is_domain (semigroup (has_add linarith.comp)) := sorry --non-trivial
lemma new_lemma_27815 (h0 : functor.add_const (add_monoid (semigroup environment.implicit_infer_kind)) environment.implicit_infer_kind) : @add_monoid.fg.{0} (semigroup.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (add_monoid.{0} (semigroup.{0} environment.implicit_infer_kind)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_27816 (h0 : function.extfun Type topological_space) : @t0_space.{0} (normed_lattice_add_comm_group.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (normed_lattice_add_comm_group.{0} pos))  := sorry --non-trivial
lemma new_lemma_27817 (h0 : function.extfun (finset (Type -> Type)) (has_mem.mem topological_space)) : @irreducible_space.{0} (random_gen.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) topological_space.{0} (@function.extfun_app.{2 0} (finset.{1} (Type → Type)) (@has_mem.mem.{1 1} (Type → Type) (finset.{1} (Type → Type)) (@finset.has_mem.{1} (Type → Type)) topological_space.{0}) h0 (@has_emptyc.emptyc.{1} (finset.{1} (Type → Type)) (@finset.has_emptyc.{1} (Type → Type))))) (random_gen.{0} num))  := sorry --non-trivial
lemma new_lemma_27818 (h0 : complete_lattice (has_norm to_additive.value_type)) : is_compactly_generated (has_norm to_additive.value_type) := sorry --non-trivial
lemma new_lemma_27819 (h0 : semiring (add_group (semiring (semiring num)))) : is_noetherian_ring (add_group (semiring (semiring num))) := sorry --non-trivial
lemma new_lemma_27820 (h0 : has_lt to_additive.value_type) : no_max_order to_additive.value_type := sorry --non-trivial
lemma new_lemma_27821 (h0 : ring (has_add (has_Inf name))) : rank_condition (has_add (has_Inf name)) := sorry --non-trivial
lemma new_lemma_27822 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @unique_factorization_monoid.{0} (ordered_comm_ring.{0} linarith.comp) (@function.extfun_app.{2 1} Type cancel_comm_monoid_with_zero.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 cancel_comm_monoid_with_zero.{0}) (ordered_comm_ring.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_27823 (h1 : monoid (complete_semilattice_Sup (random_gen linarith.comp_source))) : monoid.fg (complete_semilattice_Sup (random_gen linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_27824 (h0 : topological_space (comm_group ennreal)) : normal_space (comm_group ennreal) := sorry --non-trivial
lemma new_lemma_27825 (h0 : function.extfun Type add_group) : @is_add_cyclic.{0} (bin_tree.{0} empty) (@function.extfun_app.{2 1} Type add_group.{0} h0 (bin_tree.{0} empty))  := sorry --non-trivial
lemma new_lemma_27826 (h0 : cancel_comm_monoid_with_zero (linear_ordered_semiring (semiring unsigned))) : unique_factorization_monoid (linear_ordered_semiring (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_27827 (h0 : list (normed_group (denumerable linarith.ineq))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_27828 (h0 : topological_space (has_Inf (has_neg (has_neg name)))) : t0_space (has_Inf (has_neg (has_neg name))) := sorry --non-trivial
lemma new_lemma_27829 (h0 : group (complete_semilattice_Sup (has_norm linarith.ineq))) : is_cyclic (complete_semilattice_Sup (has_norm linarith.ineq)) := sorry --non-trivial
lemma new_lemma_27830 (h0 : uniform_space (option (semiring (semiring (semiring (semiring congr_arg_kind)))))) : separated_space (option (semiring (semiring (semiring (semiring congr_arg_kind))))) := sorry --non-trivial
lemma new_lemma_27831 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @t0_space.{0} (linear_ordered_comm_ring.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (linear_ordered_comm_ring.{0} empty))  := sorry --non-trivial
lemma new_lemma_27832 (h0 : group (with_one (random_gen string_imp))) : is_cyclic (with_one (random_gen string_imp)) := sorry --non-trivial
lemma new_lemma_27833 (h0 : fin has_zero.zero) : @has_exists_mul_of_le.{0} (add_comm_monoid.{0} name) (@matrix.vec_empty.{0} (ordered_comm_monoid.{0} (add_comm_monoid.{0} name)) h0)  := sorry --non-trivial
lemma new_lemma_27834 (h0 : topological_space (ring (comm_group (comm_group Type)))) : locally_compact_space (ring (comm_group (comm_group Type))) := sorry --non-trivial
lemma new_lemma_27835 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_domain.{0} (has_to_string.{0} linarith.comp) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (has_to_string.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_27836 (h0 : functor.add_const (ring (linear_order num)) empty) : @rank_condition.{0} (linear_order.{0} num) (@functor.add_const.run.{0 0} (ring.{0} (linear_order.{0} num)) empty h0)  := sorry --non-trivial
lemma new_lemma_27837 (h0 : topological_space (has_add (has_to_string (complete_distrib_lattice (has_neg pos))))) : preconnected_space (has_add (has_to_string (complete_distrib_lattice (has_neg pos)))) := sorry --non-trivial
lemma new_lemma_27838 (h0 : functor.add_const (monoid (semigroup (mul_one_class linarith.comp))) environment.implicit_infer_kind) : @monoid.fg.{0} (semigroup.{0} (mul_one_class.{0} linarith.comp)) (@functor.add_const.run.{0 0} (monoid.{0} (semigroup.{0} (mul_one_class.{0} linarith.comp))) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_27839 (h0 : topological_space (id (random_gen linarith.ineq))) : locally_compact_space (id (random_gen linarith.ineq)) := sorry --non-trivial
lemma new_lemma_27840 (h0 : complete_lattice (normed_comm_ring (has_add unsigned))) : is_atomistic (normed_comm_ring (has_add unsigned)) := sorry --non-trivial
lemma new_lemma_27841 (h0 : group (has_zero (has_neg (has_neg (ring (ring Type)))))) : group.fg (has_zero (has_neg (has_neg (ring (ring Type))))) := sorry --non-trivial
lemma new_lemma_27842 (h0 : set (semi_normed_ring string_imp)) : set.finite h0 := sorry --non-trivial
lemma new_lemma_27843 (h0 : group (has_star unsigned)) : normalizer_condition (has_star unsigned) := sorry --non-trivial
lemma new_lemma_27844 (h0 : uniform_space (boolean_algebra (has_Inf (has_Inf Type)))) : complete_space (boolean_algebra (has_Inf (has_Inf Type))) := sorry --non-trivial
lemma new_lemma_27845 (h0 : not (topological_space (with_one linarith.comp_source) -> false)) : @totally_separated_space.{0} (with_one.{0} linarith.comp_source) (@classical.by_contradiction'.{1} (topological_space.{0} (with_one.{0} linarith.comp_source)) h0)  := sorry --non-trivial
lemma new_lemma_27846 (h1 : topological_space (uniform_space string_imp)) (h2 : preorder (uniform_space string_imp)) : order_topology (uniform_space string_imp) := sorry --non-trivial
lemma new_lemma_27847 (h0 : uniform_space (metric_space (metric_space linarith.comp))) : separated_space (metric_space (metric_space linarith.comp)) := sorry --non-trivial
lemma new_lemma_27848 (h0 : has_mem.mem ring has_emptyc.emptyc) : @strong_rank_condition.{0} (has_norm.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type ring.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) ring.{0} h0) (has_norm.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_27849 (h0 : fin has_zero.zero) : @normal_space.{0} (comm_semigroup.{0} pos) (@matrix.vec_empty.{0} (topological_space.{0} (comm_semigroup.{0} pos)) h0)  := sorry --non-trivial
lemma new_lemma_27850 (h0 : group (with_bot (has_emptyc fun_info))) : normalizer_condition (with_bot (has_emptyc fun_info)) := sorry --non-trivial
lemma new_lemma_27851 (h0 : empty) (h1 : ne (empty.elim h0) has_bot.bot) : with_bot.unbot (empty.elim h0) h1 := sorry --non-trivial
lemma new_lemma_27852 (h0 : topological_space (ordered_cancel_add_comm_monoid (option pos))) : totally_separated_space (ordered_cancel_add_comm_monoid (option pos)) := sorry --non-trivial
lemma new_lemma_27853 (h0 h1 : multiset (mul_one_class to_additive.value_type)) : multiset.disjoint h0 h1 := sorry --non-trivial
lemma new_lemma_27854 (h0 : functor.add_const (function.extfun Type topological_space) name) : @totally_separated_space.{0} (comm_semigroup.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) name h0) (comm_semigroup.{0} name))  := sorry --non-trivial
lemma new_lemma_27855 (h0 : ordered_add_comm_monoid (has_zero (boolean_algebra.core (finset (has_add num))))) : archimedean (has_zero (boolean_algebra.core (finset (has_add num)))) := sorry --non-trivial
lemma new_lemma_27856 (h0 : topological_space (cancel_monoid (boolean_algebra environment.implicit_infer_kind))) : irreducible_space (cancel_monoid (boolean_algebra environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_27857 (h0 : ring (has_add (has_nnnorm (has_nnnorm char)))) : is_domain (has_add (has_nnnorm (has_nnnorm char))) := sorry --non-trivial
lemma new_lemma_27858 (h0 : group (encodable (has_nnnorm (has_nnnorm linarith.ineq)))) : group.fg (encodable (has_nnnorm (has_nnnorm linarith.ineq))) := sorry --non-trivial
lemma new_lemma_27859 (h0 : empty) : @totally_disconnected_space.{0} string.iterator_imp (@empty.elim.{1} (topological_space.{0} string.iterator_imp) h0)  := sorry --non-trivial
lemma new_lemma_27860 (h0 : add_group (id (has_inv (has_inv to_additive.value_type)))) : is_add_cyclic (id (has_inv (has_inv to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_27861 (h0 : list (linear_ordered_add_comm_group (random_gen char))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_27862 (h0 : function.extfun Type ring) : @is_domain.{0} (canonically_linear_ordered_monoid.{0} pos) (@function.extfun_app.{2 1} Type ring.{0} h0 (canonically_linear_ordered_monoid.{0} pos))  := sorry --non-trivial
lemma new_lemma_27863 (h0 : topological_space (has_nndist (has_add ennreal))) : preconnected_space (has_nndist (has_add ennreal)) := sorry --non-trivial
lemma new_lemma_27864 (h1 : has_mem.mem (has_norm congr_arg_kind) has_emptyc.emptyc) : @is_add_cyclic.{0} (has_norm.{0} congr_arg_kind) (@finset.pi.empty.{1 0} Type add_group.{0} (has_norm.{0} congr_arg_kind) h1)  := sorry --non-trivial
lemma new_lemma_27865 (h0 : ring (complete_linear_order num)) : rank_condition (complete_linear_order num) := sorry --non-trivial
lemma new_lemma_27866 (h0 : not (function.extfun Type group -> false)) : @normalizer_condition.{0} (preorder.{0} num) (@function.extfun_app.{2 1} Type group.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type group.{0}) h0) (preorder.{0} num))  := sorry --non-trivial
lemma new_lemma_27867 (h0 : function.extfun Type topological_space) : @t0_space.{0} (canonically_ordered_comm_semiring.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (canonically_ordered_comm_semiring.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_27868 (h0 : has_mem.mem (has_emptyc empty) has_emptyc.emptyc) : @is_domain.{0} (has_emptyc.{0} empty) (@finset.pi.empty.{1 0} Type ring.{0} (has_emptyc.{0} empty) h0)  := sorry --non-trivial
lemma new_lemma_27869 (h0 : finset (add_comm_monoid empty)) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_27870 (h0 : fin has_zero.zero) : @rank_condition.{0} (simple_graph.{0} linarith.comp) (@matrix.vec_empty.{0} (ring.{0} (simple_graph.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_27871 (h0 : functor.add_const (ring (canonically_ordered_comm_semiring unsigned)) linarith.comp) : @strong_rank_condition.{0} (canonically_ordered_comm_semiring.{0} unsigned) (@functor.add_const.run.{0 0} (ring.{0} (canonically_ordered_comm_semiring.{0} unsigned)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_27872 (h0 : fin has_zero.zero) : @rank_condition.{0} (has_bot.{0} name) (@function.extfun_app.{2 1} Type ring.{0} (@matrix.vec_empty.{1} (function.extfun.{2 1} Type ring.{0}) h0) (has_bot.{0} name))  := sorry --non-trivial
lemma new_lemma_27873 (h0 : ordered_comm_monoid (has_zero (boolean_algebra.core pos))) : has_exists_mul_of_le (has_zero (boolean_algebra.core pos)) := sorry --non-trivial
lemma new_lemma_27874 (h0 : monoid (non_assoc_semiring (option (option unsigned)))) : monoid.fg (non_assoc_semiring (option (option unsigned))) := sorry --non-trivial
lemma new_lemma_27875 (h0 : prod (add_right_cancel_monoid empty) (add_right_cancel_monoid empty)) : id_rel h0 := sorry --non-trivial
lemma new_lemma_27876 (h0 : cancel_comm_monoid_with_zero (left_cancel_semigroup (has_top unsigned))) : unique_factorization_monoid (left_cancel_semigroup (has_top unsigned)) := sorry --non-trivial
lemma new_lemma_27877 (h0 : ordered_add_comm_monoid (has_zero (ring (ring (ring (ring (ring linarith.comp))))))) : archimedean (has_zero (ring (ring (ring (ring (ring linarith.comp)))))) := sorry --non-trivial
lemma new_lemma_27878 (h0 : complete_lattice (has_inv (has_ssubset (random_gen string_imp)))) : is_compactly_generated (has_inv (has_ssubset (random_gen string_imp))) := sorry --non-trivial
lemma new_lemma_27879 (h0 : add_monoid (has_inter empty)) : add_monoid.fg (has_inter empty) := sorry --non-trivial
lemma new_lemma_27880 (h0 : list (has_ssubset (random_gen string_imp))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_27881 (h0 : filter (has_inter empty)) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_27882 (h0 : topological_space (measurable_space (has_top (id (has_union linarith.comp))))) : normal_space (measurable_space (has_top (id (has_union linarith.comp)))) := sorry --non-trivial
lemma new_lemma_27883 (h0 : functor.add_const (ring (has_neg_part ennreal)) unsigned) : @is_principal_ideal_ring.{0} (has_neg_part.{0} ennreal) (@functor.add_const.run.{0 0} (ring.{0} (has_neg_part.{0} ennreal)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_27884 (h3 : topological_space (has_compl char)) : t0_space (has_compl char) := sorry --non-trivial
lemma new_lemma_27885 (h0 : topological_space (has_zero (pseudo_metric_space (ring (has_add unsigned))))) : path_connected_space (has_zero (pseudo_metric_space (ring (has_add unsigned)))) := sorry --non-trivial
lemma new_lemma_27886 (h0 : functor.add_const (monoid (ring Type)) (finset (finset Type))) : @monoid.fg.{1} (ring.{1} Type) (@functor.add_const.run.{1 1} (monoid.{1} (ring.{1} Type)) (finset.{1} (finset.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_27887 (h0 : functor.add_const (add_group (canonically_ordered_monoid pos)) linarith.comp) : @is_add_cyclic.{0} (canonically_ordered_monoid.{0} pos) (@functor.add_const.run.{0 0} (add_group.{0} (canonically_ordered_monoid.{0} pos)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_27888 (h0 : ring (linear_ordered_add_comm_group (has_nnnorm (has_nnnorm fun_info)))) : rank_condition (linear_ordered_add_comm_group (has_nnnorm (has_nnnorm fun_info))) := sorry --non-trivial
lemma new_lemma_27889 (h0 : group (normed_group (measurable_space (has_norm (semiring empty))))) : normalizer_condition (normed_group (measurable_space (has_norm (semiring empty)))) := sorry --non-trivial
lemma new_lemma_27890 (h0 : not (topological_space (linear_ordered_comm_ring empty) -> false)) : @preirreducible_space.{0} (linear_ordered_comm_ring.{0} empty) (@classical.by_contradiction'.{1} (topological_space.{0} (linear_ordered_comm_ring.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_27891 (h1 : not (complete_lattice (normed_field string_imp) -> false)) : @is_compactly_generated.{0} (normed_field.{0} string_imp) (@classical.by_contradiction'.{1} (complete_lattice.{0} (normed_field.{0} string_imp)) h1)  := sorry --non-trivial
lemma new_lemma_27892 (h0 : topological_space (has_neg (ring (finset (finset Type))))) : irreducible_space (has_neg (ring (finset (finset Type)))) := sorry --non-trivial
lemma new_lemma_27893 (h0 : semiring (option pos)) : is_noetherian_ring (option pos) := sorry --non-trivial
lemma new_lemma_27894 (h0 : not (nat -> false)) (h1 : vector Prop (classical.by_contradiction' h0)) (h2 : not (fin (classical.by_contradiction' h0) -> false)) : vector.nth h1 (classical.by_contradiction' h2) := sorry --non-trivial
lemma new_lemma_27895 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @strong_rank_condition.{1} (canonically_linear_ordered_monoid.{1} Type) (@function.extfun_app.{3 2} (Type 1) ring.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 ring.{1}) (canonically_linear_ordered_monoid.{1} Type))  := sorry --non-trivial
lemma new_lemma_27896 (h0 : has_mem.mem group has_emptyc.emptyc) : @is_cyclic.{0} (linear_ordered_add_comm_group.{0} fun_info) (@function.extfun_app.{2 1} Type group.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) group.{0} h0) (linear_ordered_add_comm_group.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_27897 (h0 : ring (has_add (has_add environment.implicit_infer_kind))) : is_domain (has_add (has_add environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_27898 (h0 : complete_lattice (random_gen (with_one fun_info))) : complete_lattice.is_Sup_finite_compact (random_gen (with_one fun_info)) := sorry --non-trivial
lemma new_lemma_27899 (h0 : complete_lattice (has_to_string (boolean_algebra.core Type))) : is_atomistic (has_to_string (boolean_algebra.core Type)) := sorry --non-trivial
lemma new_lemma_27900 (h0 : ring (has_star (semiring (semiring empty)))) : is_principal_ideal_ring (has_star (semiring (semiring empty))) := sorry --non-trivial
lemma new_lemma_27901 (h0 : function.extfun Type finset) : finset.nonempty (function.extfun_app h0 (canonically_ordered_add_monoid empty)) := sorry --non-trivial
lemma new_lemma_27902 (h0 : not (complete_lattice (semi_normed_comm_ring linarith.ineq) -> false)) : @is_compactly_generated.{0} (semi_normed_comm_ring.{0} linarith.ineq) (@classical.by_contradiction'.{1} (complete_lattice.{0} (semi_normed_comm_ring.{0} linarith.ineq)) h0)  := sorry --non-trivial
lemma new_lemma_27903 (h0 : functor.add_const (complete_lattice (finset unsigned)) name) : @complete_lattice.is_Sup_finite_compact.{0} (finset.{0} unsigned) (@functor.add_const.run.{0 0} (complete_lattice.{0} (finset.{0} unsigned)) name h0)  := sorry --non-trivial
lemma new_lemma_27904 (h0 : functor.add_const (functor.add_const (topological_space pos) Type) Type) : @irreducible_space.{0} pos (@functor.add_const.run.{0 1} (topological_space.{0} pos) Type (@functor.add_const.run.{0 1} (functor.add_const.{0 1} (topological_space.{0} pos) Type) Type h0))  := sorry --non-trivial
lemma new_lemma_27905 (h0 : list (has_star (option (semiring unsigned)))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_27906 (h0 : complete_lattice (option pos)) : complete_lattice.is_Sup_finite_compact (option pos) := sorry --non-trivial
lemma new_lemma_27907 (h0 : ring (complete_distrib_lattice (option (option (option ennreal))))) : is_principal_ideal_ring (complete_distrib_lattice (option (option (option ennreal)))) := sorry --non-trivial
lemma new_lemma_27908 (h0 : function.extfun Type complete_lattice) : @complete_lattice.is_Sup_finite_compact.{0} (has_top.{0} empty) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (has_top.{0} empty))  := sorry --non-trivial
lemma new_lemma_27909 (h0 : not (add_group (random_gen (mul_one_class char)) -> false)) : @is_add_cyclic.{0} (random_gen.{0} (mul_one_class.{0} char)) (@classical.by_contradiction'.{1} (add_group.{0} (random_gen.{0} (mul_one_class.{0} char))) h0)  := sorry --non-trivial
lemma new_lemma_27910 (h0 : uniform_space (random_gen empty)) : complete_space (random_gen empty) := sorry --non-trivial
lemma new_lemma_27911 (h0 : topological_space to_additive.value_type) (h1 : function.extfun (Type -> Type) (function.extfun Type)) : @order_closed_topology.{0} to_additive.value_type h0 (@function.extfun_app.{2 1} Type preorder.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h1 preorder.{0}) to_additive.value_type)  := sorry --non-trivial
lemma new_lemma_27912 (h0 : add_monoid (comm_group (has_add pos))) : add_monoid.fg (comm_group (has_add pos)) := sorry --non-trivial
lemma new_lemma_27913 (h0 : function.extfun Type ring) : @is_principal_ideal_ring.{0} (has_dist.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type ring.{0} h0 (has_dist.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_27914 (h0 : topological_space (linear_ordered_semiring (random_gen to_additive.value_type))) : totally_disconnected_space (linear_ordered_semiring (random_gen to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_27915 (h0 : group (complete_distrib_lattice (complete_distrib_lattice (finset unsigned)))) : group.fg (complete_distrib_lattice (complete_distrib_lattice (finset unsigned))) := sorry --non-trivial
lemma new_lemma_27916 (h0 : functor.add_const (finset (normed_comm_ring Type)) Type) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_27917 (h0 : function.extfun Type group) : @normalizer_condition.{0} (measurable_space.dynkin_system.{0} unsigned) (@function.extfun_app.{2 1} Type group.{0} h0 (measurable_space.dynkin_system.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_27918 (h0 : topological_space (has_norm unsigned)) : t0_space (has_norm unsigned) := sorry --non-trivial
lemma new_lemma_27919 (h2 : add_group (has_ssubset linarith.ineq)) : is_add_cyclic (has_ssubset linarith.ineq) := sorry --non-trivial
lemma new_lemma_27920 (h0 : set (simple_graph to_additive.value_type)) : set.subsingleton h0 := sorry --non-trivial
lemma new_lemma_27921 (h0 : not (semiring (has_norm num) -> false)) : @is_noetherian_ring.{0} (has_norm.{0} num) (@classical.by_contradiction'.{1} (semiring.{0} (has_norm.{0} num)) h0)  := sorry --non-trivial
lemma new_lemma_27922 (h0 : functor.add_const (function.extfun (Type 1) add_monoid) environment.implicit_infer_kind) : @add_monoid.fg.{1} (has_neg.{1} Type) (@function.extfun_app.{3 2} (Type 1) add_monoid.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) add_monoid.{1}) environment.implicit_infer_kind h0) (has_neg.{1} Type))  := sorry --non-trivial
lemma new_lemma_27923 (h0 : function.extfun Type topological_space) : @normal_space.{0} (has_add.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_add.{0} pos))  := sorry --non-trivial
lemma new_lemma_27924 (h0 : ring (generalized_boolean_algebra (has_add Type))) : is_principal_ideal_ring (generalized_boolean_algebra (has_add Type)) := sorry --non-trivial
lemma new_lemma_27925 (h0 : uniform_space (add_semigroup unsigned)) : complete_space (add_semigroup unsigned) := sorry --non-trivial
lemma new_lemma_27926 (h0 : group (has_neg (linear_ordered_comm_group num))) : normalizer_condition (has_neg (linear_ordered_comm_group num)) := sorry --non-trivial
lemma new_lemma_27927 (h0 : topological_space (complete_semilattice_Sup (has_norm empty))) : t0_space (complete_semilattice_Sup (has_norm empty)) := sorry --non-trivial
lemma new_lemma_27928 (h0 : functor.add_const (function.extfun Type topological_space) (ring name)) : @locally_compact_space.{0} (has_Inf.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) (ring.{0} name) h0) (has_Inf.{0} pos))  := sorry --non-trivial
lemma new_lemma_27929 (h0 : function.extfun Type topological_space) : @totally_disconnected_space.{0} (linear_ordered_comm_group.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (linear_ordered_comm_group.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_27930 (h0 : add_group (topological_space string.iterator_imp)) : is_add_cyclic (topological_space string.iterator_imp) := sorry --non-trivial
lemma new_lemma_27931 (h0 : functor.add_const (topological_space (normed_comm_ring unsigned)) pos) : @sequential_space.{0} (normed_comm_ring.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (normed_comm_ring.{0} unsigned)) pos h0)  := sorry --non-trivial
lemma new_lemma_27932 (h0 : functor.add_const (topological_space (ring unsigned)) unsigned) : @t1_space.{0} (ring.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (ring.{0} unsigned)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_27933 (h0 : complete_lattice (has_top (metric_space (has_norm empty)))) : complete_lattice.is_Sup_finite_compact (has_top (metric_space (has_norm empty))) := sorry --non-trivial
lemma new_lemma_27934 (h0 : function.extfun Type topological_space) : @path_connected_space.{0} (has_Inf.{0} real) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_Inf.{0} real))  := sorry --non-trivial
lemma new_lemma_27935 (h0 : cancel_comm_monoid_with_zero (add_comm_monoid (has_add name))) : unique_factorization_monoid (add_comm_monoid (has_add name)) := sorry --non-trivial
lemma new_lemma_27936 (h0 : filter (has_add linarith.comp_source)) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_27937 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @topological_space.separable_space.{0} (complete_distrib_lattice.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (complete_distrib_lattice.{0} name))  := sorry --non-trivial
lemma new_lemma_27938 (h0 : group (has_union (has_norm linarith.comp))) : normalizer_condition (has_union (has_norm linarith.comp)) := sorry --non-trivial
lemma new_lemma_27939 (h0 : topological_space (simple_graph (finset linarith.comp))) : topological_space.separable_space (simple_graph (finset linarith.comp)) := sorry --non-trivial
lemma new_lemma_27940 (h0 : topological_space (non_unital_semiring unsigned)) : totally_disconnected_space (non_unital_semiring unsigned) := sorry --non-trivial
lemma new_lemma_27941 (h1 : ring (topological_space to_additive.value_type)) : rank_condition (topological_space to_additive.value_type) := sorry --non-trivial
lemma new_lemma_27942 (h0 : topological_space (has_norm (semiring empty))) : normal_space (has_norm (semiring empty)) := sorry --non-trivial
lemma new_lemma_27943 (h0 : group (generalized_boolean_algebra (has_bot name))) : is_simple_group (generalized_boolean_algebra (has_bot name)) := sorry --non-trivial
lemma new_lemma_27944 (h0 : topological_space (ring ennreal)) : discrete_topology (ring ennreal) := sorry --non-trivial
lemma new_lemma_27945 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @separated_space.{0} (ordered_comm_ring.{0} linarith.comp) (@function.extfun_app.{2 1} Type uniform_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 uniform_space.{0}) (ordered_comm_ring.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_27946 (h0 : functor.add_const (function.extfun Type ring) pos) : @is_domain.{0} (has_neg_part.{0} pos) (@function.extfun_app.{2 1} Type ring.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type ring.{0}) pos h0) (has_neg_part.{0} pos))  := sorry --non-trivial
lemma new_lemma_27947 (h1 : group (distrib linarith.comp_source)) : is_cyclic (distrib linarith.comp_source) := sorry --non-trivial
lemma new_lemma_27948 (h0 : function.extfun Type group) : @group.fg.{0} (with_bot.{0} linarith.comp) (@function.extfun_app.{2 1} Type group.{0} h0 (with_bot.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_27949 (h0 : ring (has_compl (metric_space (random_gen (mul_one_class linarith.comp_source))))) : rank_condition (has_compl (metric_space (random_gen (mul_one_class linarith.comp_source)))) := sorry --non-trivial
lemma new_lemma_27950 (h0 : function.extfun (nat -> Type) (function.extfun nat)) : @path_connected_space.{0} (has_top.{0} (semiring.{0} empty)) (@matrix.vec_empty.{0} (topological_space.{0} (has_top.{0} (semiring.{0} empty))) (@function.extfun_app.{1 1} nat fin (@function.extfun_app.{2 1} (nat → Type) (function.extfun.{1 1} nat) h0 fin) (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_27951 (h0 : uniform_space (option (option (option (option (option empty)))))) : separated_space (option (option (option (option (option empty))))) := sorry --non-trivial
lemma new_lemma_27952 (h0 : topological_space (add_cancel_comm_monoid (comm_ring (random_gen string.iterator_imp)))) : t0_space (add_cancel_comm_monoid (comm_ring (random_gen string.iterator_imp))) := sorry --non-trivial
lemma new_lemma_27953 (h0 : uniform_space (comm_group (has_nndist Type))) : separated_space (comm_group (has_nndist Type)) := sorry --non-trivial
lemma new_lemma_27954 (h0 : ring (with_bot (has_emptyc ordering))) (h1 : monoid (subring (with_bot (has_emptyc ordering)))) : monoid.fg (subring (with_bot (has_emptyc ordering))) := sorry --non-trivial
lemma new_lemma_27955 (h1 : group (denumerable char)) : is_cyclic (denumerable char) := sorry --non-trivial
lemma new_lemma_27956 (h1 : ring (nondiscrete_normed_field ereal)) : strong_rank_condition (nondiscrete_normed_field ereal) := sorry --non-trivial
lemma new_lemma_27957 (h0 : ring (ring Type)) : is_principal_ideal_ring (ring Type) := sorry --non-trivial
lemma new_lemma_27958 (h0 : function.extfun Type topological_space) : @totally_separated_space.{0} (boolean_algebra.core.{0} (finset.{0} pos)) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (boolean_algebra.core.{0} (finset.{0} pos)))  := sorry --non-trivial
lemma new_lemma_27959 (h0 : monoid (filter unsigned)) : monoid.fg (filter unsigned) := sorry --non-trivial
lemma new_lemma_27960 (h0 : topological_space (topological_space (complete_semilattice_Sup (random_gen fun_info)))) : locally_compact_space (topological_space (complete_semilattice_Sup (random_gen fun_info))) := sorry --non-trivial
lemma new_lemma_27961 (h0 : topological_space (with_bot (normed_group (random_gen congr_arg_kind)))) : discrete_topology (with_bot (normed_group (random_gen congr_arg_kind))) := sorry --non-trivial
lemma new_lemma_27962 (h0 : option (ring (add_cancel_monoid (option name)))) (h1 : ring (add_cancel_monoid (option name))) : is_domain (add_cancel_monoid (option name)) := sorry --non-trivial
lemma new_lemma_27963 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @irreducible_space.{0} (with_bot.{0} fun_info) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (with_bot.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_27964 (h0 : uniform_space (canonically_linear_ordered_monoid (has_Inf (has_neg real)))) : complete_space (canonically_linear_ordered_monoid (has_Inf (has_neg real))) := sorry --non-trivial
lemma new_lemma_27965 (h0 : function.extfun Type uniform_space) : @separated_space.{0} (ring.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (ring.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_27966 (h0 : functor.add_const (semiring (add_cancel_monoid linarith.comp)) (has_add (finset pos))) : @is_noetherian_ring.{0} (add_cancel_monoid.{0} linarith.comp) (@functor.add_const.run.{0 0} (semiring.{0} (add_cancel_monoid.{0} linarith.comp)) (has_add.{0} (finset.{0} pos)) h0)  := sorry --non-trivial
lemma new_lemma_27967 (h0 : function.extfun Type topological_space) : @regular_space.{0} (semigroup.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (semigroup.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_27968 (h2 h3 : multiset (mul_one_class (add_comm_semigroup ereal))) : multiset.le h2 h3 := sorry --non-trivial
lemma new_lemma_27969 (h0 : functor.add_const (topological_space (add_comm_monoid unsigned)) environment.implicit_infer_kind) : @irreducible_space.{0} (add_comm_monoid.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (add_comm_monoid.{0} unsigned)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_27970 (h0 : topological_space (linear_order (option unsigned))) : normal_space (linear_order (option unsigned)) := sorry --non-trivial
lemma new_lemma_27971 (h0 : ring (has_Inf (has_Inf (has_pos_part linarith.comp)))) : rank_condition (has_Inf (has_Inf (has_pos_part linarith.comp))) := sorry --non-trivial
lemma new_lemma_27972 (h0 : functor.add_const (add_group (has_to_string Type)) Type) : @is_add_cyclic.{1} (has_to_string.{1} Type) (@functor.add_const.run.{1 1} (add_group.{1} (has_to_string.{1} Type)) Type h0)  := sorry --non-trivial
lemma new_lemma_27973 (h0 : not (group (random_gen reducibility_hints) -> false)) : @is_cyclic.{0} (random_gen.{0} reducibility_hints) (@classical.by_contradiction'.{1} (group.{0} (random_gen.{0} reducibility_hints)) h0)  := sorry --non-trivial
lemma new_lemma_27974 (h0 : functor.add_const (topological_space (is_R_or_C empty)) empty) : @preirreducible_space.{0} (is_R_or_C.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (is_R_or_C.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_27975 (h0 : functor.add_const (ring (comm_group pos)) linarith.comp) : @is_principal_ideal_ring.{0} (comm_group.{0} pos) (@functor.add_const.run.{0 0} (ring.{0} (comm_group.{0} pos)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_27976 (h0 : add_group (topological_space (random_gen string_imp))) : is_add_cyclic (topological_space (random_gen string_imp)) := sorry --non-trivial
lemma new_lemma_27977 (h0 : functor.add_const (topological_space (has_add pos)) Type) : @regular_space.{0} (has_add.{0} pos) (@functor.add_const.run.{0 1} (topological_space.{0} (has_add.{0} pos)) Type h0)  := sorry --non-trivial
lemma new_lemma_27978 (h0 : topological_space (ordered_cancel_add_comm_monoid (option (option unsigned)))) : t1_space (ordered_cancel_add_comm_monoid (option (option unsigned))) := sorry --non-trivial
lemma new_lemma_27979 (h0 : topological_space (has_ssubset (has_nnnorm char))) : locally_compact_space (has_ssubset (has_nnnorm char)) := sorry --non-trivial
lemma new_lemma_27980 (h0 : random_gen linarith.comp -> random_gen linarith.comp -> Prop) (h1 : random_gen linarith.comp) (h2 : function.extfun Type random_gen) : relation.join h0 h1 (function.extfun_app h2 linarith.comp) := sorry --non-trivial
lemma new_lemma_27981 (h0 : functor.add_const (topological_space (has_nndist Type)) pos) : @locally_compact_space.{1} (has_nndist.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (has_nndist.{1} Type)) pos h0)  := sorry --non-trivial
lemma new_lemma_27982 (h0 : topological_space (has_neg_part (has_to_string ennreal))) : regular_space (has_neg_part (has_to_string ennreal)) := sorry --non-trivial
lemma new_lemma_27983 (h0 : functor.add_const (topological_space (ordered_comm_monoid pos)) linarith.comp) : @totally_disconnected_space.{0} (ordered_comm_monoid.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (ordered_comm_monoid.{0} pos)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_27984 (h0 : topological_space (cancel_monoid (option empty))) : path_connected_space (cancel_monoid (option empty)) := sorry --non-trivial
lemma new_lemma_27985 (h1 : ring (random_gen (has_nnnorm fun_info))) : is_domain (random_gen (has_nnnorm fun_info)) := sorry --non-trivial
lemma new_lemma_27986 (h0 : topological_space (canonically_ordered_comm_semiring (has_neg (has_neg name)))) : t1_space (canonically_ordered_comm_semiring (has_neg (has_neg name))) := sorry --non-trivial
lemma new_lemma_27987 (h0 : not (group (measurable_space empty) -> false)) : @normalizer_condition.{0} (measurable_space.{0} empty) (@classical.by_contradiction'.{1} (group.{0} (measurable_space.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_27988 (h1 : complete_lattice (dlist (has_inv (has_inv (has_inv (has_inv string_imp)))))) : is_compactly_generated (dlist (has_inv (has_inv (has_inv (has_inv string_imp))))) := sorry --non-trivial
lemma new_lemma_27989 (h0 : functor.add_const (topological_space (has_zero name)) Type) : @topological_space.separable_space.{0} (has_zero.{0} name) (@functor.add_const.run.{0 1} (topological_space.{0} (has_zero.{0} name)) Type h0)  := sorry --non-trivial
lemma new_lemma_27990 (h2 : add_group (random_gen string_imp)) : is_add_cyclic (random_gen string_imp) := sorry --non-trivial
lemma new_lemma_27991 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_atomistic.{0} (complete_semilattice_Sup.{0} empty) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (complete_semilattice_Sup.{0} empty))  := sorry --non-trivial
lemma new_lemma_27992 (h0 : topological_space (linear_ordered_add_comm_group fun_info)) : totally_separated_space (linear_ordered_add_comm_group fun_info) := sorry --non-trivial
lemma new_lemma_27993 (h0 : functor.add_const (topological_space (has_zero Type)) environment.implicit_infer_kind) : @totally_separated_space.{1} (has_zero.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (has_zero.{1} Type)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_27994 (h0 : ring (semi_normed_comm_ring string.iterator_imp)) : is_domain (semi_normed_comm_ring string.iterator_imp) := sorry --non-trivial
lemma new_lemma_27995 (h0 : ring (has_norm to_additive.value_type)) (h1 : group (ring_topology (has_norm to_additive.value_type))) : is_cyclic (ring_topology (has_norm to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_27996 (h0 : topological_space (has_zero (finset (finset linarith.comp)))) : t0_space (has_zero (finset (finset linarith.comp))) := sorry --non-trivial
lemma new_lemma_27997 (h0 : add_monoid (has_bot (has_add (canonically_linear_ordered_monoid real)))) : add_monoid.fg (has_bot (has_add (canonically_linear_ordered_monoid real))) := sorry --non-trivial
lemma new_lemma_27998 (h0 : list (left_cancel_monoid congr_arg_kind)) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_27999 (h1 : uniform_space (denumerable (has_nnnorm (has_nnnorm (has_nnnorm to_additive.value_type))))) : complete_space (denumerable (has_nnnorm (has_nnnorm (has_nnnorm to_additive.value_type)))) := sorry --non-trivial
lemma new_lemma_28000 (h2 : topological_space (dlist linarith.comp_source)) : t0_space (dlist linarith.comp_source) := sorry --non-trivial
lemma new_lemma_28001 (h0 : functor.add_const (finset (has_add name)) Type) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_28002 (h0 : functor.add_const (complete_lattice (plift num)) empty) : @is_atomistic.{1} (plift.{1} num) (@functor.add_const.run.{1 0} (complete_lattice.{1} (plift.{1} num)) empty h0)  := sorry --non-trivial
lemma new_lemma_28003 (h0 : functor.add_const (list (add_semigroup empty)) empty) : palindrome (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_28004 (h0 : ring (has_neg (semigroup Type))) : is_principal_ideal_ring (has_neg (semigroup Type)) := sorry --non-trivial
lemma new_lemma_28005 (h0 : ring (has_add (has_add (sub_neg_monoid real)))) : rank_condition (has_add (has_add (sub_neg_monoid real))) := sorry --non-trivial
lemma new_lemma_28006 (h1 : topological_space (normed_field (has_nnnorm char))) : t0_space (normed_field (has_nnnorm char)) := sorry --non-trivial
lemma new_lemma_28007 (h0 : functor.add_const (topological_space (ring linarith.comp)) (has_neg Type)) : @topological_space.separable_space.{0} (ring.{0} linarith.comp) (@functor.add_const.run.{0 1} (topological_space.{0} (ring.{0} linarith.comp)) (has_neg.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_28008 (h0 : group (has_nnnorm (has_nnnorm (non_unital_non_assoc_semiring linarith.comp_source)))) : is_cyclic (has_nnnorm (has_nnnorm (non_unital_non_assoc_semiring linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_28009 (h0 : functor.add_const (group (has_neg linarith.comp)) pos) : @is_simple_group.{0} (has_neg.{0} linarith.comp) (@functor.add_const.run.{0 0} (group.{0} (has_neg.{0} linarith.comp)) pos h0)  := sorry --non-trivial
lemma new_lemma_28010 (h0 : function.extfun Type (functor.add_const (topological_space (preorder empty)))) : @irreducible_space.{0} (preorder.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (preorder.{0} empty)) empty (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (topological_space.{0} (preorder.{0} empty))) h0 empty))  := sorry --non-trivial
lemma new_lemma_28011 (h0 : functor.comp topological_space mul_zero_class environment.implicit_infer_kind) : @loc_path_connected_space.{0} (mul_zero_class.{0} environment.implicit_infer_kind) (@functor.comp.run.{0 0 0} topological_space.{0} mul_zero_class.{0} environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_28012 (h0 : functor.add_const (functor.add_const Prop pos) linarith.comp) : functor.add_const.run (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_28013 (h0 : functor.add_const (filter (has_Inf linarith.comp)) linarith.comp) : countable_Inter_filter (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_28014 (h0 : topological_space (has_neg (finset linarith.comp))) : preirreducible_space (has_neg (finset linarith.comp)) := sorry --non-trivial
lemma new_lemma_28015 (h0 : uniform_space (finset (finset pos))) : separated_space (finset (finset pos)) := sorry --non-trivial
lemma new_lemma_28016 (h0 : not (function.extfun Type topological_space -> false)) : @locally_compact_space.{0} (normed_group.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (normed_group.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_28017 (h0 : list (cancel_monoid (comm_group name))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_28018 (h0 : topological_space (with_bot (has_norm num))) : irreducible_space (with_bot (has_norm num)) := sorry --non-trivial
lemma new_lemma_28019 (h0 : topological_space (has_compl string.iterator_imp)) (h1 : add_group (has_compl string.iterator_imp)) : topological_add_group (has_compl string.iterator_imp) := sorry --non-trivial
lemma new_lemma_28020 (h0 : ring (semigroup (comm_group (comm_group pos)))) : is_principal_ideal_ring (semigroup (comm_group (comm_group pos))) := sorry --non-trivial
lemma new_lemma_28021 (h0 : function.extfun Type complete_lattice) : @complete_lattice.is_Sup_finite_compact.{0} (ordered_cancel_add_comm_monoid.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (ordered_cancel_add_comm_monoid.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_28022 (h0 : function.extfun Type semiring) : @is_noetherian_ring.{0} (finset.{0} unsigned) (@function.extfun_app.{2 1} Type semiring.{0} h0 (finset.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_28023 (h0 : group (has_nndist (has_to_string ennreal))) : normalizer_condition (has_nndist (has_to_string ennreal)) := sorry --non-trivial
lemma new_lemma_28024 (h0 : functor.add_const (complete_lattice (has_zero pos)) name) : @is_compactly_generated.{0} (has_zero.{0} pos) (@functor.add_const.run.{0 0} (complete_lattice.{0} (has_zero.{0} pos)) name h0)  := sorry --non-trivial
lemma new_lemma_28025 (h0 : function.extfun Type topological_space) : @t1_space.{0} (has_add.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_add.{0} num))  := sorry --non-trivial
lemma new_lemma_28026 (h0 : has_mem.mem topological_space has_emptyc.emptyc) : @t0_space.{0} (with_bot.{0} fun_info) (@function.extfun_app.{2 1} Type topological_space.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) topological_space.{0} h0) (with_bot.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_28027 (h0 : functor.add_const (group (has_neg_part Type)) Type) : @normalizer_condition.{1} (has_neg_part.{1} Type) (@functor.add_const.run.{1 1} (group.{1} (has_neg_part.{1} Type)) Type h0)  := sorry --non-trivial
lemma new_lemma_28028 (h0 : ring (finset Type)) : is_principal_ideal_ring (finset Type) := sorry --non-trivial
lemma new_lemma_28029 (h0 : topological_space (with_bot (random_gen char))) : t0_space (with_bot (random_gen char)) := sorry --non-trivial
lemma new_lemma_28030 (h0 : topological_space (canonically_ordered_comm_semiring (has_add Type))) : irreducible_space (canonically_ordered_comm_semiring (has_add Type)) := sorry --non-trivial
lemma new_lemma_28031 (h3 : add_group (uniform_space string.iterator_imp)) : is_add_cyclic (uniform_space string.iterator_imp) := sorry --non-trivial
lemma new_lemma_28032 (h0 : topological_space (add_comm_monoid unsigned)) : regular_space (add_comm_monoid unsigned) := sorry --non-trivial
lemma new_lemma_28033 (h1 : function.extfun Type topological_space) : @locally_compact_space.{0} (has_emptyc.{0} linarith.ineq) (@function.extfun_app.{2 1} Type topological_space.{0} h1 (has_emptyc.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_28034 (h0 : function.extfun nat fin) : @totally_disconnected_space.{0} (add_comm_monoid.{0} linarith.comp) (@matrix.vec_empty.{0} (topological_space.{0} (add_comm_monoid.{0} linarith.comp)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_28035 (h0 : semiring (canonically_ordered_comm_semiring pos)) : is_noetherian_ring (canonically_ordered_comm_semiring pos) := sorry --non-trivial
lemma new_lemma_28036 (h0 : group (complete_semilattice_Sup (with_bot linarith.comp_source))) : is_cyclic (complete_semilattice_Sup (with_bot linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_28037 (h0 : topological_space (is_R_or_C (option (option empty)))) : discrete_topology (is_R_or_C (option (option empty))) := sorry --non-trivial
lemma new_lemma_28038 (h0 : function.extfun Type group) : @group.fg.{0} (option.{0} num) (@function.extfun_app.{2 1} Type group.{0} h0 (option.{0} num))  := sorry --non-trivial
lemma new_lemma_28039 (h0 : function.extfun (nat -> Type) (function.extfun nat)) : @t0_space.{0} (has_bot.{0} pos) (@matrix.vec_empty.{0} (topological_space.{0} (has_bot.{0} pos)) (@function.extfun_app.{1 1} nat fin (@function.extfun_app.{2 1} (nat → Type) (function.extfun.{1 1} nat) h0 fin) (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_28040 (h0 : not (has_mem.mem (measurable_space linarith.comp_source) has_emptyc.emptyc -> false)) : @is_cyclic.{0} (measurable_space.{0} linarith.comp_source) (@finset.pi.empty.{1 0} Type group.{0} (measurable_space.{0} linarith.comp_source) (@classical.by_contradiction'.{0} (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (measurable_space.{0} linarith.comp_source) (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))) h0))  := sorry --non-trivial
lemma new_lemma_28041 (h0 : functor.add_const (uniform_space (left_cancel_monoid num)) empty) : @complete_space.{0} (left_cancel_monoid.{0} num) (@functor.add_const.run.{0 0} (uniform_space.{0} (left_cancel_monoid.{0} num)) empty h0)  := sorry --non-trivial
lemma new_lemma_28042 (h0 : not (ring (distrib_lattice (has_nnnorm fun_info)) -> false)) : @is_domain.{0} (distrib_lattice.{0} (has_nnnorm.{0} fun_info)) (@classical.by_contradiction'.{1} (ring.{0} (distrib_lattice.{0} (has_nnnorm.{0} fun_info))) h0)  := sorry --non-trivial
lemma new_lemma_28043 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @is_simple_group.{1} (simple_graph.{1} Type) (@function.extfun_app.{3 2} (Type 1) group.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 group.{1}) (simple_graph.{1} Type))  := sorry --non-trivial
lemma new_lemma_28044 (h0 : ring (normed_comm_ring (boolean_algebra name))) : rank_condition (normed_comm_ring (boolean_algebra name)) := sorry --non-trivial
lemma new_lemma_28045 (h0 : functor.add_const (uniform_space (complete_distrib_lattice linarith.comp)) linarith.comp) : @separated_space.{0} (complete_distrib_lattice.{0} linarith.comp) (@functor.add_const.run.{0 0} (uniform_space.{0} (complete_distrib_lattice.{0} linarith.comp)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_28046 (h0 : not (function.extfun Type add_group -> false)) : @is_add_cyclic.{0} (has_norm.{0} fun_info) (@function.extfun_app.{2 1} Type add_group.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type add_group.{0}) h0) (has_norm.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_28047 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : list.nodup (function.extfun_app (function.extfun_app h0 list) (dlist fun_info)) := sorry --non-trivial
lemma new_lemma_28048 (h0 : topological_space (has_norm (has_norm unsigned))) : discrete_topology (has_norm (has_norm unsigned)) := sorry --non-trivial
lemma new_lemma_28049 (h1 : complete_lattice (dlist to_additive.value_type)) : complete_lattice.is_Sup_finite_compact (dlist to_additive.value_type) := sorry --non-trivial
lemma new_lemma_28050 (h0 : ring (boolean_algebra (finset (has_neg pos)))) : rank_condition (boolean_algebra (finset (has_neg pos))) := sorry --non-trivial
lemma new_lemma_28051 (h2 : complete_lattice (has_div (monoid linarith.comp_source))) : is_compactly_generated (has_div (monoid linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_28052 (h0 : not (topological_space (with_one linarith.comp) -> false)) : @irreducible_space.{0} (with_one.{0} linarith.comp) (@classical.by_contradiction'.{1} (topological_space.{0} (with_one.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_28053 (h0 : topological_space (cancel_monoid (has_add name))) : loc_path_connected_space (cancel_monoid (has_add name)) := sorry --non-trivial
lemma new_lemma_28054 (h0 : group (comm_group (has_to_string Type))) : is_cyclic (comm_group (has_to_string Type)) := sorry --non-trivial
lemma new_lemma_28055 (h0 : ring (uniform_space (option num))) : is_principal_ideal_ring (uniform_space (option num)) := sorry --non-trivial
lemma new_lemma_28056 (h0 : filter (has_nndist (has_nndist ennreal))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_28057 (h0 : ring (has_div (uniform_space to_additive.value_type))) : rank_condition (has_div (uniform_space to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_28058 (h0 : not (topological_space (id empty) -> false)) : @t0_space.{0} (@id.{2} Type empty) (@classical.by_contradiction'.{1} (topological_space.{0} (@id.{2} Type empty)) h0)  := sorry --non-trivial
lemma new_lemma_28059 (h0 : num -> num -> Prop) : is_symm num h0 := sorry --non-trivial
lemma new_lemma_28060 (h0 : topological_space (has_bot (has_Inf pos))) : path_connected_space (has_bot (has_Inf pos)) := sorry --non-trivial
lemma new_lemma_28061 (h0 : ordered_add_comm_monoid (ordered_comm_ring (finset (finset linarith.comp)))) : archimedean (ordered_comm_ring (finset (finset linarith.comp))) := sorry --non-trivial
lemma new_lemma_28062 (h0 : complete_lattice (fintype (has_inv string_imp))) : is_compactly_generated (fintype (has_inv string_imp)) := sorry --non-trivial
lemma new_lemma_28063 (h0 : functor.add_const (topological_space (plift congr_arg_kind)) congr_arg_kind) : @path_connected_space.{1} (plift.{1} congr_arg_kind) (@functor.add_const.run.{1 0} (topological_space.{1} (plift.{1} congr_arg_kind)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_28064 (h0 : ring (has_div linarith.ineq)) : is_domain (has_div linarith.ineq) := sorry --non-trivial
lemma new_lemma_28065 (h0 : function.extfun Type complete_lattice) : @is_compactly_generated.{0} (has_compl.{0} fun_info) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (has_compl.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_28066 (h0 : add_group (has_compl (mul_one_class reducibility_hints))) : is_add_cyclic (has_compl (mul_one_class reducibility_hints)) := sorry --non-trivial
lemma new_lemma_28067 (h0 : functor.add_const (topological_space (comm_group linarith.comp)) environment.implicit_infer_kind) : @loc_path_connected_space.{0} (comm_group.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (comm_group.{0} linarith.comp)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_28068 (h0 : function.extfun Type topological_space) : @totally_separated_space.{0} (has_emptyc.{0} (random_gen.{0} linarith.comp_source)) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_emptyc.{0} (random_gen.{0} linarith.comp_source)))  := sorry --non-trivial
lemma new_lemma_28069 (h0 : complete_lattice (has_star (semiring (semiring empty)))) : is_compactly_generated (has_star (semiring (semiring empty))) := sorry --non-trivial
lemma new_lemma_28070 (h0 : topological_space (has_Sup (option (option (option unsigned))))) : preirreducible_space (has_Sup (option (option (option unsigned)))) := sorry --non-trivial
lemma new_lemma_28071 (h0 : semiring (group_with_zero ennreal)) : is_noetherian_ring (group_with_zero ennreal) := sorry --non-trivial
lemma new_lemma_28072 (h0 : semiring (has_Sup (semiring (semiring (semiring (semiring empty)))))) : is_noetherian_ring (has_Sup (semiring (semiring (semiring (semiring empty))))) := sorry --non-trivial
lemma new_lemma_28073 (h0 : function.extfun Type topological_space) : @t1_space.{0} (omega_complete_partial_order.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (omega_complete_partial_order.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_28074 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @totally_separated_space.{1} (comm_group.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 topological_space.{1}) (comm_group.{1} Type))  := sorry --non-trivial
lemma new_lemma_28075 (h0 : topological_space (sub_neg_monoid name)) : discrete_topology (sub_neg_monoid name) := sorry --non-trivial
lemma new_lemma_28076 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_atomistic.{0} (has_to_string.{0} (finset.{0} name)) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (has_to_string.{0} (finset.{0} name)))  := sorry --non-trivial
lemma new_lemma_28077 (h0 : has_neg (distrib fun_info)) (h1 : measurable_space (distrib fun_info)) : has_measurable_neg (distrib fun_info) := sorry --non-trivial
lemma new_lemma_28078 (h0 : functor.add_const Prop (monoid_with_zero num)) : functor.add_const.run h0 := sorry --non-trivial
lemma new_lemma_28079 (h0 : semiring (semiring unsigned)) : is_noetherian_ring (semiring unsigned) := sorry --non-trivial
lemma new_lemma_28080 (h0 : functor.add_const (function.extfun Type topological_space) name) : @preirreducible_space.{0} (has_neg.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) name h0) (has_neg.{0} name))  := sorry --non-trivial
lemma new_lemma_28081 (h0 h1 : multiset (has_nnnorm (nondiscrete_normed_field fun_info))) : multiset.subset h0 h1 := sorry --non-trivial
lemma new_lemma_28082 (h0 : group (filter num)) : normalizer_condition (filter num) := sorry --non-trivial
lemma new_lemma_28083 (h0 : functor.add_const (complete_lattice (linear_order empty)) unsigned) : @is_atomistic.{0} (linear_order.{0} empty) (@functor.add_const.run.{0 0} (complete_lattice.{0} (linear_order.{0} empty)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_28084 (h0 : complete_lattice (uniform_space (has_ssubset char))) : complete_lattice.is_Sup_finite_compact (uniform_space (has_ssubset char)) := sorry --non-trivial
lemma new_lemma_28085 (h0 : not (group (comm_ring char) -> false)) : @group.fg.{0} (comm_ring.{0} char) (@classical.by_contradiction'.{1} (group.{0} (comm_ring.{0} char)) h0)  := sorry --non-trivial
lemma new_lemma_28086 (h0 : topological_space (has_nndist (normed_comm_ring (boolean_algebra linarith.comp)))) : discrete_topology (has_nndist (normed_comm_ring (boolean_algebra linarith.comp))) := sorry --non-trivial
lemma new_lemma_28087 (h0 : ring (normed_field string_imp)) : is_domain (normed_field string_imp) := sorry --non-trivial
lemma new_lemma_28088 (h0 : topological_space (comm_group ennreal)) : t0_space (comm_group ennreal) := sorry --non-trivial
lemma new_lemma_28089 (h0 : not (monoid (linear_ordered_semiring unsigned) -> false)) : @monoid.fg.{0} (linear_ordered_semiring.{0} unsigned) (@classical.by_contradiction'.{1} (monoid.{0} (linear_ordered_semiring.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_28090 (h0 : complete_lattice (option (has_norm linarith.comp))) : complete_lattice.is_Sup_finite_compact (option (has_norm linarith.comp)) := sorry --non-trivial
lemma new_lemma_28091 (h0 : topological_space (random_gen (random_gen num))) : totally_disconnected_space (random_gen (random_gen num)) := sorry --non-trivial
lemma new_lemma_28092 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @rank_condition.{0} (semigroup.{0} linarith.comp) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (semigroup.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_28093 (h0 : group (has_Inf (has_Inf pos))) : normalizer_condition (has_Inf (has_Inf pos)) := sorry --non-trivial
lemma new_lemma_28094 (h0 : functor.add_const (topological_space (sub_neg_monoid name)) linarith.comp) : @regular_space.{0} (sub_neg_monoid.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (sub_neg_monoid.{0} name)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_28095 (h0 : ring (add_monoid char)) : strong_rank_condition (add_monoid char) := sorry --non-trivial
lemma new_lemma_28096 (h0 : functor.add_const (ordered_comm_monoid (mul_zero_class Type)) environment.implicit_infer_kind) : @has_exists_mul_of_le.{1} (mul_zero_class.{1} Type) (@functor.add_const.run.{1 0} (ordered_comm_monoid.{1} (mul_zero_class.{1} Type)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_28097 (h0 : group (finset (has_add (has_add pos)))) : is_simple_group (finset (has_add (has_add pos))) := sorry --non-trivial
lemma new_lemma_28098 (h0 : cancel_comm_monoid_with_zero (normed_comm_ring num)) : unique_factorization_monoid (normed_comm_ring num) := sorry --non-trivial
lemma new_lemma_28099 (h0 : semiring (has_ssubset fun_info)) (h1 : ideal (has_ssubset fun_info)) : ideal.is_prime h1 := sorry --non-trivial
lemma new_lemma_28100 (h0 : functor.add_const (topological_space (simple_graph Type)) pos) : @preirreducible_space.{1} (simple_graph.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (simple_graph.{1} Type)) pos h0)  := sorry --non-trivial
lemma new_lemma_28101 (h0 : uniform_space (left_cancel_monoid (semiring num))) : separated_space (left_cancel_monoid (semiring num)) := sorry --non-trivial
lemma new_lemma_28102 (h0 : not (ring (add_group congr_arg_kind) -> false)) : @rank_condition.{0} (add_group.{0} congr_arg_kind) (@classical.by_contradiction'.{1} (ring.{0} (add_group.{0} congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_28103 (h0 : fin has_zero.zero) : @preirreducible_space.{1} (has_pos_part.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@matrix.vec_empty.{2} (function.extfun.{3 2} (Type 1) topological_space.{1}) h0) (has_pos_part.{1} Type))  := sorry --non-trivial
lemma new_lemma_28104 (h0 : group (partial_order num)) : is_cyclic (partial_order num) := sorry --non-trivial
lemma new_lemma_28105 (h0 : functor.add_const (ordered_add_comm_monoid pos) (has_Inf linarith.comp)) : @archimedean.{0} pos (@functor.add_const.run.{0 0} (ordered_add_comm_monoid.{0} pos) (has_Inf.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_28106 (h0 : ordered_add_comm_monoid (add_comm_monoid (finset pos))) : archimedean (add_comm_monoid (finset pos)) := sorry --non-trivial
lemma new_lemma_28107 (h0 : ordered_comm_monoid (boolean_algebra.core (has_add pos))) : has_exists_mul_of_le (boolean_algebra.core (has_add pos)) := sorry --non-trivial
lemma new_lemma_28108 (h0 : group (has_neg (finset pos))) : group.fg (has_neg (finset pos)) := sorry --non-trivial
lemma new_lemma_28109 (h0 : not (group (complete_semilattice_Sup linarith.comp_source) -> false)) : @group.fg.{0} (complete_semilattice_Sup.{0} linarith.comp_source) (@classical.by_contradiction'.{1} (group.{0} (complete_semilattice_Sup.{0} linarith.comp_source)) h0)  := sorry --non-trivial
lemma new_lemma_28110 (h0 : has_le (has_inv to_additive.value_type)) (h1 : bounded_order (has_inv to_additive.value_type)) : is_simple_order (has_inv to_additive.value_type) := sorry --non-trivial
lemma new_lemma_28111 (h0 : function.extfun Type uniform_space) : @separated_space.{0} (has_union.{0} linarith.comp) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (has_union.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_28112 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @is_domain.{1} Type (@function.extfun_app.{3 2} (Type 1) ring.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 ring.{1}) Type)  := sorry --non-trivial
lemma new_lemma_28113 (h0 : topological_space (encodable (random_gen (random_gen linarith.ineq)))) : locally_compact_space (encodable (random_gen (random_gen linarith.ineq))) := sorry --non-trivial
lemma new_lemma_28114 (h0 : topological_space (cancel_monoid (has_add (has_add environment.implicit_infer_kind)))) : t0_space (cancel_monoid (has_add (has_add environment.implicit_infer_kind))) := sorry --non-trivial
lemma new_lemma_28115 (h0 : list (add_cancel_monoid (ring pos))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_28116 (h0 : function.extfun Type topological_space) : @preirreducible_space.{0} (ordered_comm_group.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (ordered_comm_group.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_28117 (h2 : not (topological_space linarith.ineq -> false)) : @t0_space.{0} linarith.ineq (@classical.by_contradiction'.{1} (topological_space.{0} linarith.ineq) h2)  := sorry --non-trivial
lemma new_lemma_28118 (h0 : complete_lattice (has_add (encodable linarith.ineq))) : complete_lattice.is_Sup_finite_compact (has_add (encodable linarith.ineq)) := sorry --non-trivial
lemma new_lemma_28119 (h0 : function.extfun Type (functor.add_const (functor.add_const Prop unsigned))) : functor.add_const.run (functor.add_const.run (function.extfun_app h0 name)) := sorry --non-trivial
lemma new_lemma_28120 (h0 : topological_space (semi_normed_ring (mul_one_class linarith.ineq))) : totally_disconnected_space (semi_normed_ring (mul_one_class linarith.ineq)) := sorry --non-trivial
lemma new_lemma_28121 (h2 : complete_lattice congr_arg_kind) : is_atomistic congr_arg_kind := sorry --non-trivial
lemma new_lemma_28122 (h0 : not (function.extfun (Type -> Type) (function.extfun Type) -> false)) : @rank_condition.{0} (has_norm.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) (@classical.by_contradiction'.{2} (function.extfun.{2 2} (Type → Type) (function.extfun.{2 1} Type)) h0) ring.{0}) (has_norm.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_28123 (h0 : functor.comp filter finset ennreal) : filter.ne_bot (functor.comp.run h0) := sorry --non-trivial
lemma new_lemma_28124 (h0 : function.extfun nat fin) : @separated_space.{0} (ordered_comm_monoid.{0} pos) (@matrix.vec_empty.{0} (uniform_space.{0} (ordered_comm_monoid.{0} pos)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_28125 (h0 : list (with_bot (has_inv (random_gen to_additive.value_type)))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_28126 (h0 : topological_space (random_gen (has_top (has_top congr_arg_kind)))) : path_connected_space (random_gen (has_top (has_top congr_arg_kind))) := sorry --non-trivial
lemma new_lemma_28127 (h0 : ring (has_top (semiring (random_gen num)))) : strong_rank_condition (has_top (semiring (random_gen num))) := sorry --non-trivial
lemma new_lemma_28128 (h0 : not (function.extfun Type group -> false)) : @group.fg.{0} (has_one.{0} unsigned) (@function.extfun_app.{2 1} Type group.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type group.{0}) h0) (has_one.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_28129 (h0 : group (semigroup (has_to_string (has_to_string pos)))) : group.fg (semigroup (has_to_string (has_to_string pos))) := sorry --non-trivial
lemma new_lemma_28130 (h0 : ring (has_Inf (has_Inf linarith.comp))) : is_principal_ideal_ring (has_Inf (has_Inf linarith.comp)) := sorry --non-trivial
lemma new_lemma_28131 (h1 h2 : multiset (normed_field reducibility_hints)) : multiset.subset h1 h2 := sorry --non-trivial
lemma new_lemma_28132 (h0 : has_coe linarith.ineq Prop) (h3 : linarith.ineq) : @coe_b.{1 1} linarith.ineq Prop h0 h3  := sorry --non-trivial
lemma new_lemma_28133 (h0 : topological_space (omega_complete_partial_order (option (option (option (option (option unsigned))))))) : t0_space (omega_complete_partial_order (option (option (option (option (option unsigned)))))) := sorry --non-trivial
lemma new_lemma_28134 (h0 : monoid (monoid (option empty))) : monoid.fg (monoid (option empty)) := sorry --non-trivial
lemma new_lemma_28135 (h0 : topological_space (preorder congr_arg_kind)) : normal_space (preorder congr_arg_kind) := sorry --non-trivial
lemma new_lemma_28136 (h0 : function.extfun Type ordered_add_comm_monoid) : @archimedean.{0} (has_edist.{0} unsigned) (@function.extfun_app.{2 1} Type ordered_add_comm_monoid.{0} h0 (has_edist.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_28137 (h0 : functor.add_const (group (has_nndist pos)) (has_to_string name)) : @normalizer_condition.{0} (has_nndist.{0} pos) (@functor.add_const.run.{0 0} (group.{0} (has_nndist.{0} pos)) (has_to_string.{0} name) h0)  := sorry --non-trivial
lemma new_lemma_28138 (h1 : add_group (simple_graph (mul_one_class linarith.comp_source))) : is_add_cyclic (simple_graph (mul_one_class linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_28139 (h0 : monoid (generalized_boolean_algebra (has_Inf (has_Inf pos)))) : monoid.fg (generalized_boolean_algebra (has_Inf (has_Inf pos))) := sorry --non-trivial
lemma new_lemma_28140 (h0 : uniform_space (has_edist num)) : separated_space (has_edist num) := sorry --non-trivial
lemma new_lemma_28141 (h0 : function.extfun Type complete_lattice) : @is_compactly_generated.{0} (canonically_linear_ordered_monoid.{0} name) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (canonically_linear_ordered_monoid.{0} name))  := sorry --non-trivial
lemma new_lemma_28142 (h0 : topological_space (linear_ordered_field num)) : irreducible_space (linear_ordered_field num) := sorry --non-trivial
lemma new_lemma_28143 (h0 : group (has_star congr_arg_kind)) : normalizer_condition (has_star congr_arg_kind) := sorry --non-trivial
lemma new_lemma_28144 (h0 : function.extfun Type topological_space) : @t0_space.{0} (has_nndist.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_nndist.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_28145 (h0 : topological_space (comm_group (comm_group unsigned))) : discrete_topology (comm_group (comm_group unsigned)) := sorry --non-trivial
lemma new_lemma_28146 (h0 : functor.add_const (add_monoid (boolean_algebra.core Type)) (has_neg Type)) : @add_monoid.fg.{1} (boolean_algebra.core.{1} Type) (@functor.add_const.run.{1 1} (add_monoid.{1} (boolean_algebra.core.{1} Type)) (has_neg.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_28147 (h0 : complete_lattice (uniform_space (has_ssubset linarith.ineq))) : complete_lattice.is_Sup_finite_compact (uniform_space (has_ssubset linarith.ineq)) := sorry --non-trivial
lemma new_lemma_28148 (h0 : topological_space (add_cancel_monoid (has_add (has_add (has_neg pos))))) : totally_separated_space (add_cancel_monoid (has_add (has_add (has_neg pos)))) := sorry --non-trivial
lemma new_lemma_28149 (h0 : functor.add_const (uniform_space (add_cancel_monoid Type)) (has_neg Type)) : @complete_space.{1} (add_cancel_monoid.{1} Type) (@functor.add_const.run.{1 1} (uniform_space.{1} (add_cancel_monoid.{1} Type)) (has_neg.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_28150 (h0 : function.extfun Type (functor.comp topological_space semigroup)) : @regular_space.{0} (semigroup.{0} name) (@functor.comp.run.{0 0 0} topological_space.{0} semigroup.{0} name (@function.extfun_app.{2 1} Type (functor.comp.{0 0 0} topological_space.{0} semigroup.{0}) h0 name))  := sorry --non-trivial
lemma new_lemma_28151 (h0 : ordered_add_comm_monoid (add_cancel_comm_monoid (option (option empty)))) : archimedean (add_cancel_comm_monoid (option (option empty))) := sorry --non-trivial
lemma new_lemma_28152 (h0 : not (complete_lattice (option num) -> false)) : @complete_lattice.is_Sup_finite_compact.{0} (option.{0} num) (@classical.by_contradiction'.{1} (complete_lattice.{0} (option.{0} num)) h0)  := sorry --non-trivial
lemma new_lemma_28153 (h1 : list (with_bot fun_info)) : list.nodup h1 := sorry --non-trivial
lemma new_lemma_28154 (h0 : function.extfun Type uniform_space) : @complete_space.{0} (with_bot.{0} fun_info) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (with_bot.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_28155 (h1 : topological_space (has_ssubset string_imp)) : t0_space (has_ssubset string_imp) := sorry --non-trivial
lemma new_lemma_28156 (h0 : not (group real.angle -> false)) : @normalizer_condition.{0} real.angle (@classical.by_contradiction'.{1} (group.{0} real.angle) h0)  := sorry --non-trivial
lemma new_lemma_28157 (h0 : topological_space (boolean_algebra (finset linarith.comp))) : t1_space (boolean_algebra (finset linarith.comp)) := sorry --non-trivial
lemma new_lemma_28158 (h0 : function.extfun Type topological_space) : @preirreducible_space.{0} (semigroup.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (semigroup.{0} num))  := sorry --non-trivial
lemma new_lemma_28159 (h0 : topological_space (semi_normed_ring string.iterator_imp)) : path_connected_space (semi_normed_ring string.iterator_imp) := sorry --non-trivial
lemma new_lemma_28160 (h0 : nat) (h1 : topological_space (fin h0)) : totally_disconnected_space (fin h0) := sorry --non-trivial
lemma new_lemma_28161 (h2 : topological_space string.iterator_imp) : path_connected_space string.iterator_imp := sorry --non-trivial
lemma new_lemma_28162 (h0 : group (has_top (has_norm (random_gen to_additive.value_type)))) : is_cyclic (has_top (has_norm (random_gen to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_28163 (h0 : finset (has_neg (finset Type))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_28164 (h0 : function.extfun nat fin) : @normal_space.{1} (simple_graph.{1} Type) (@matrix.vec_empty.{1} (topological_space.{1} (simple_graph.{1} Type)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_28165 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @preconnected_space.{0} (emetric_space.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (emetric_space.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_28166 (h0 : functor.add_const (topological_space (has_neg pos)) environment.implicit_infer_kind) : @loc_path_connected_space.{0} (has_neg.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (has_neg.{0} pos)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_28167 (h0 : function.extfun Type complete_lattice) : complete_lattice.is_Sup_finite_compact (measurable_space linarith.ineq) := sorry --non-trivial
lemma new_lemma_28168 (h0 : functor.add_const (topological_space (complete_distrib_lattice Type)) name) : @t0_space.{1} (complete_distrib_lattice.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (complete_distrib_lattice.{1} Type)) name h0)  := sorry --non-trivial
lemma new_lemma_28169 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @path_connected_space.{0} (boolean_algebra.core.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (boolean_algebra.core.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_28170 (h0 : complete_lattice (add_right_cancel_monoid linarith.comp)) : is_atomistic (add_right_cancel_monoid linarith.comp) := sorry --non-trivial
lemma new_lemma_28171 (h0 : not (complete_lattice (has_compl string_imp) -> false)) : @complete_lattice.is_Sup_finite_compact.{0} (has_compl.{0} string_imp) (@classical.by_contradiction'.{1} (complete_lattice.{0} (has_compl.{0} string_imp)) h0)  := sorry --non-trivial
lemma new_lemma_28172 (h0 : fin has_zero.zero) : matrix.vec_empty (id (matrix.vec_empty (id h0))) := sorry --non-trivial
lemma new_lemma_28173 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_atomistic.{0} (canonically_ordered_add_monoid.{0} empty) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (canonically_ordered_add_monoid.{0} empty))  := sorry --non-trivial
lemma new_lemma_28174 (h0 : finset (has_neg (finset (has_neg linarith.comp)))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_28175 (h0 : functor.add_const (topological_space (finset pos)) (ring (has_pos_part linarith.comp))) : @t0_space.{0} (finset.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (finset.{0} pos)) (ring.{0} (has_pos_part.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_28176 (h0 : not (topological_space (random_gen to_additive.value_type) -> false)) : @totally_disconnected_space.{0} (random_gen.{0} to_additive.value_type) (@classical.by_contradiction'.{1} (topological_space.{0} (random_gen.{0} to_additive.value_type)) h0)  := sorry --non-trivial
lemma new_lemma_28177 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @add_monoid.fg.{0} (boolean_algebra.core.{0} pos) (@function.extfun_app.{2 1} Type add_monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 add_monoid.{0}) (boolean_algebra.core.{0} pos))  := sorry --non-trivial
lemma new_lemma_28178 (h0 : group (has_union (semiring (semiring num)))) : is_cyclic (has_union (semiring (semiring num))) := sorry --non-trivial
lemma new_lemma_28179 (h1 : set (mul_one_class string.iterator_imp)) : set.finite h1 := sorry --non-trivial
lemma new_lemma_28180 (h0 : function.extfun Type topological_space) : @normal_space.{0} (has_add.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_add.{0} name))  := sorry --non-trivial
lemma new_lemma_28181 (h1 : topological_space (distrib (distrib (mul_one_class string_imp)))) : t2_5_space (distrib (distrib (mul_one_class string_imp))) := sorry --non-trivial
lemma new_lemma_28182 (h0 : functor.add_const (topological_space (comm_group name)) Type) : @irreducible_space.{0} (comm_group.{0} name) (@functor.add_const.run.{0 1} (topological_space.{0} (comm_group.{0} name)) Type h0)  := sorry --non-trivial
lemma new_lemma_28183 (h0 : topological_space (semiring (has_norm linarith.comp))) : path_connected_space (semiring (has_norm linarith.comp)) := sorry --non-trivial
lemma new_lemma_28184 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @complete_space.{0} (measurable_space.dynkin_system.{0} num) (@function.extfun_app.{2 1} Type uniform_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 uniform_space.{0}) (measurable_space.dynkin_system.{0} num))  := sorry --non-trivial
lemma new_lemma_28185 (h1 : monoid (with_bot linarith.comp_source)) : monoid.fg (with_bot linarith.comp_source) := sorry --non-trivial
lemma new_lemma_28186 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @normal_space.{0} (linear_ordered_semiring.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (linear_ordered_semiring.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_28187 (h0 : uniform_space (partial_order (semiring unsigned))) : separated_space (partial_order (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_28188 (h0 : topological_space (has_top (has_ssubset fun_info))) : path_connected_space (has_top (has_ssubset fun_info)) := sorry --non-trivial
lemma new_lemma_28189 (h0 : list (has_dist congr_arg_kind)) : palindrome h0 := sorry --non-trivial
lemma new_lemma_28190 (h0 : ring (add_group unsigned)) : is_principal_ideal_ring (add_group unsigned) := sorry --non-trivial
lemma new_lemma_28191 (h0 : uniform_space (has_Sup (semiring unsigned))) : separated_space (has_Sup (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_28192 (h0 : semiring (has_div to_additive.value_type)) (h1 : ideal (has_div to_additive.value_type)) : ideal.fg h1 := sorry --non-trivial
lemma new_lemma_28193 (h0 : functor.add_const (topological_space (comm_group linarith.comp)) (comm_group Type)) : @t0_space.{0} (comm_group.{0} linarith.comp) (@functor.add_const.run.{0 1} (topological_space.{0} (comm_group.{0} linarith.comp)) (comm_group.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_28194 (h0 : functor.comp topological_space boolean_algebra.core name) : @totally_disconnected_space.{0} (boolean_algebra.core.{0} name) (@functor.comp.run.{0 0 0} topological_space.{0} boolean_algebra.core.{0} name h0)  := sorry --non-trivial
lemma new_lemma_28195 (h0 : topological_space (with_bot (random_gen (random_gen linarith.comp_source)))) : totally_disconnected_space (with_bot (random_gen (random_gen linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_28196 (h0 : topological_space (has_div std_gen)) (h1 : preorder (has_div std_gen)) : order_topology (has_div std_gen) := sorry --non-trivial
lemma new_lemma_28197 (h0 : function.extfun Type ring) : @is_principal_ideal_ring.{0} (has_bot.{0} (option.{0} (option.{0} empty))) (@function.extfun_app.{2 1} Type ring.{0} h0 (has_bot.{0} (option.{0} (option.{0} empty))))  := sorry --non-trivial
lemma new_lemma_28198 (h0 : unsigned -> unsigned -> Prop) : is_strict_order unsigned h0 := sorry --non-trivial
lemma new_lemma_28199 (h0 : functor.add_const (complete_lattice (has_dist unsigned)) unsigned) : @complete_lattice.is_Sup_finite_compact.{0} (has_dist.{0} unsigned) (@functor.add_const.run.{0 0} (complete_lattice.{0} (has_dist.{0} unsigned)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_28200 (h0 : ring (random_gen (denumerable to_additive.value_type))) : is_domain (random_gen (denumerable to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_28201 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @locally_compact_space.{0} (with_one.{0} linarith.ineq) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (with_one.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_28202 (h0 : function.extfun Type ring) : @rank_condition.{0} (comm_group.{0} unsigned) (@function.extfun_app.{2 1} Type ring.{0} h0 (comm_group.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_28203 (h0 : list (linear_ordered_add_comm_group (has_norm linarith.ineq))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_28204 (h2 : ring (semiring fun_info)) : strong_rank_condition (semiring fun_info) := sorry --non-trivial
lemma new_lemma_28205 (h0 : functor.add_const (function.extfun Type add_group) (ring pos)) : @is_add_cyclic.{0} (ordered_comm_ring.{0} (ring.{0} (finset.{0} pos))) (@function.extfun_app.{2 1} Type add_group.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type add_group.{0}) (ring.{0} pos) h0) (ordered_comm_ring.{0} (ring.{0} (finset.{0} pos))))  := sorry --non-trivial
lemma new_lemma_28206 (h0 : not (topological_space (div_inv_monoid linarith.comp_source) -> false)) : @t0_space.{0} (div_inv_monoid.{0} linarith.comp_source) (@classical.by_contradiction'.{1} (topological_space.{0} (div_inv_monoid.{0} linarith.comp_source)) h0)  := sorry --non-trivial
lemma new_lemma_28207 (h0 : not (ring (distrib string.iterator_imp) -> false)) : @rank_condition.{0} (distrib.{0} string.iterator_imp) (@classical.by_contradiction'.{1} (ring.{0} (distrib.{0} string.iterator_imp)) h0)  := sorry --non-trivial
lemma new_lemma_28208 (h0 : not (finset (mul_zero_class congr_arg_kind) -> false)) : finset.nonempty (classical.by_contradiction' h0) := sorry --non-trivial
lemma new_lemma_28209 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @normal_space.{0} (metric_space.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (metric_space.{0} empty))  := sorry --non-trivial
lemma new_lemma_28210 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @complete_lattice.is_Sup_finite_compact.{0} (monoid.{0} num) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (monoid.{0} num))  := sorry --non-trivial
lemma new_lemma_28211 (h0 : has_mul (has_pos_part (has_pos_part (has_pos_part (has_pos_part (has_pos_part Type)))))) (h1 : has_pos_part (has_pos_part (has_pos_part (has_pos_part (has_pos_part Type))))) : is_regular h1 := sorry --non-trivial
lemma new_lemma_28212 (h0 : function.extfun Type uniform_space) : @complete_space.{0} (add_semigroup.{0} empty) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (add_semigroup.{0} empty))  := sorry --non-trivial
lemma new_lemma_28213 (h0 : function.extfun to_additive.value_type (fun (x : to_additive.value_type), Prop)) : Exists (function.extfun_app h0) := sorry --non-trivial
lemma new_lemma_28214 (h0 : function.extfun Type topological_space) : @t0_space.{0} linarith.comp_source (@function.extfun_app.{2 1} Type topological_space.{0} h0 linarith.comp_source)  := sorry --non-trivial
lemma new_lemma_28215 (h0 : not (group (mul_zero_class empty) -> false)) : @group.fg.{0} (mul_zero_class.{0} empty) (@classical.by_contradiction'.{1} (group.{0} (mul_zero_class.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_28216 (h0 : topological_space (comm_group (has_to_string (has_add (has_add ennreal))))) : totally_separated_space (comm_group (has_to_string (has_add (has_add ennreal)))) := sorry --non-trivial
lemma new_lemma_28217 (h0 : functor.add_const (ordered_comm_monoid (boolean_algebra Type)) (finset environment.implicit_infer_kind)) : @has_exists_mul_of_le.{1} (boolean_algebra.{1} Type) (@functor.add_const.run.{1 0} (ordered_comm_monoid.{1} (boolean_algebra.{1} Type)) (finset.{0} environment.implicit_infer_kind) h0)  := sorry --non-trivial
lemma new_lemma_28218 (h0 : complete_lattice (has_compl (semi_normed_ring linarith.comp_source))) : is_compactly_generated (has_compl (semi_normed_ring linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_28219 (h0 : topological_space (complete_distrib_lattice (has_add (has_add pos)))) : totally_disconnected_space (complete_distrib_lattice (has_add (has_add pos))) := sorry --non-trivial
lemma new_lemma_28220 (h0 : topological_space (cancel_monoid environment.implicit_infer_kind)) : totally_disconnected_space (cancel_monoid environment.implicit_infer_kind) := sorry --non-trivial
lemma new_lemma_28221 (h0 : functor.add_const (topological_space (semigroup name)) Type) : @preconnected_space.{0} (semigroup.{0} name) (@functor.add_const.run.{0 1} (topological_space.{0} (semigroup.{0} name)) Type h0)  := sorry --non-trivial
lemma new_lemma_28222 (h1 : not (ring (random_gen string_imp) -> false)) : @rank_condition.{0} (random_gen.{0} string_imp) (@classical.by_contradiction'.{1} (ring.{0} (random_gen.{0} string_imp)) h1)  := sorry --non-trivial
lemma new_lemma_28223 (h0 : functor.add_const (functor.add_const (complete_lattice Type) Type) (has_Inf Type)) : @complete_lattice.is_Sup_finite_compact.{1} Type (@functor.add_const.run.{1 1} (complete_lattice.{1} Type) Type (@functor.add_const.run.{1 1} (functor.add_const.{1 1} (complete_lattice.{1} Type) Type) (has_Inf.{1} Type) h0))  := sorry --non-trivial
lemma new_lemma_28224 (h0 : topological_space (has_zero (finset name))) : totally_disconnected_space (has_zero (finset name)) := sorry --non-trivial
lemma new_lemma_28225 (h0 : not (ring (has_ssubset to_additive.value_type) -> false)) : @rank_condition.{0} (has_ssubset.{0} to_additive.value_type) (@classical.by_contradiction'.{1} (ring.{0} (has_ssubset.{0} to_additive.value_type)) h0)  := sorry --non-trivial
lemma new_lemma_28226 (h1 : ring (with_one (has_nnnorm char))) : is_domain (with_one (has_nnnorm char)) := sorry --non-trivial
lemma new_lemma_28227 (h0 : functor.add_const (topological_space (ordered_cancel_add_comm_monoid empty)) unsigned) : @preconnected_space.{0} (ordered_cancel_add_comm_monoid.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (ordered_cancel_add_comm_monoid.{0} empty)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_28228 (h0 : function.extfun Type topological_space) : @t0_space.{0} (measurable_space.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (measurable_space.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_28229 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @rank_condition.{0} (add_cancel_comm_monoid.{0} empty) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (add_cancel_comm_monoid.{0} empty))  := sorry --non-trivial
lemma new_lemma_28230 (h0 : topological_space (has_norm (has_nnnorm (has_nnnorm fun_info)))) : t0_space (has_norm (has_nnnorm (has_nnnorm fun_info))) := sorry --non-trivial
lemma new_lemma_28231 (h0 : topological_space (comm_semigroup (ordered_comm_monoid real))) : t0_space (comm_semigroup (ordered_comm_monoid real)) := sorry --non-trivial
lemma new_lemma_28232 (h0 : topological_space (linear_ordered_comm_ring (semiring (semiring empty)))) : totally_separated_space (linear_ordered_comm_ring (semiring (semiring empty))) := sorry --non-trivial
lemma new_lemma_28233 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @strong_rank_condition.{0} (has_neg.{0} pos) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (has_neg.{0} pos))  := sorry --non-trivial
lemma new_lemma_28234 (h0 : uniform_space (has_Inf (has_neg (has_neg name)))) : complete_space (has_Inf (has_neg (has_neg name))) := sorry --non-trivial
lemma new_lemma_28235 (h0 : function.extfun Type uniform_space) : @complete_space.{0} (finset.{0} pos) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (finset.{0} pos))  := sorry --non-trivial
lemma new_lemma_28236 (h0 : functor.add_const (topological_space (ring name)) (boolean_algebra environment.implicit_infer_kind)) : @irreducible_space.{0} (ring.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (ring.{0} name)) (boolean_algebra.{0} environment.implicit_infer_kind) h0)  := sorry --non-trivial
lemma new_lemma_28237 (h0 : functor.add_const (uniform_space (has_Inf pos)) linarith.comp) : @separated_space.{0} (has_Inf.{0} pos) (@functor.add_const.run.{0 0} (uniform_space.{0} (has_Inf.{0} pos)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_28238 (h0 : group (add_left_cancel_monoid (with_zero (has_inv (random_gen linarith.ineq))))) : is_cyclic (add_left_cancel_monoid (with_zero (has_inv (random_gen linarith.ineq)))) := sorry --non-trivial
lemma new_lemma_28239 (h0 : ring (with_bot (random_gen (random_gen linarith.ineq)))) : rank_condition (with_bot (random_gen (random_gen linarith.ineq))) := sorry --non-trivial
lemma new_lemma_28240 (h0 : topological_space (ordered_comm_ring real)) : normal_space (ordered_comm_ring real) := sorry --non-trivial
lemma new_lemma_28241 (h1 : ring (has_emptyc (has_norm (has_norm (has_norm fun_info))))) : strong_rank_condition (has_emptyc (has_norm (has_norm (has_norm fun_info)))) := sorry --non-trivial
lemma new_lemma_28242 (h0 : function.extfun Type group) : @is_simple_group.{0} (group_with_zero.{0} (option.{0} unsigned)) (@function.extfun_app.{2 1} Type group.{0} h0 (group_with_zero.{0} (option.{0} unsigned)))  := sorry --non-trivial
lemma new_lemma_28243 (h0 : uniform_space (comm_group (normed_comm_ring Type))) : separated_space (comm_group (normed_comm_ring Type)) := sorry --non-trivial
lemma new_lemma_28244 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @monoid.fg.{0} (has_one.{0} unsigned) (@function.extfun_app.{2 1} Type monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 monoid.{0}) (has_one.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_28245 (h0 : function.extfun Type ring) : @strong_rank_condition.{0} (filter.{0} unsigned) (@function.extfun_app.{2 1} Type ring.{0} h0 (filter.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_28246 (h0 : function.extfun Type complete_lattice) : @is_atomistic.{0} (add_left_cancel_semigroup.{0} unsigned) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (add_left_cancel_semigroup.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_28247 (h0 : function.extfun Type list) : palindrome (function.extfun_app h0 (ordered_cancel_add_comm_monoid empty)) := sorry --non-trivial
lemma new_lemma_28248 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @strong_rank_condition.{0} (linear_ordered_semiring.{0} num) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (linear_ordered_semiring.{0} num))  := sorry --non-trivial
lemma new_lemma_28249 (h0 : ring (boolean_algebra (has_to_string (has_add pos)))) : is_principal_ideal_ring (boolean_algebra (has_to_string (has_add pos))) := sorry --non-trivial
lemma new_lemma_28250 (h0 : filter (ring (boolean_algebra unsigned))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_28251 (h0 : functor.add_const (topological_space (add_semigroup unsigned)) empty) : @irreducible_space.{0} (add_semigroup.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (add_semigroup.{0} unsigned)) empty h0)  := sorry --non-trivial
lemma new_lemma_28252 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @preconnected_space.{0} (boolean_algebra.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (boolean_algebra.{0} pos))  := sorry --non-trivial
lemma new_lemma_28253 (h0 : functor.add_const (semiring (has_Sup unsigned)) (option empty)) : @is_noetherian_ring.{0} (has_Sup.{0} unsigned) (@functor.add_const.run.{0 0} (semiring.{0} (has_Sup.{0} unsigned)) (option.{0} empty) h0)  := sorry --non-trivial
lemma new_lemma_28254 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @t1_space.{0} (ordered_comm_ring.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (ordered_comm_ring.{0} pos))  := sorry --non-trivial
lemma new_lemma_28255 (h0 : add_group (has_div linarith.ineq)) : is_add_cyclic (has_div linarith.ineq) := sorry --non-trivial
lemma new_lemma_28256 (h0 : topological_space (mul_one_class ereal)) (h1 : preorder (mul_one_class ereal)) : order_topology (mul_one_class ereal) := sorry --non-trivial
lemma new_lemma_28257 (h5 : set (char -> char)) : set.separates_points h5 := sorry --non-trivial
lemma new_lemma_28258 (h0 : function.extfun Type cancel_comm_monoid_with_zero) : @unique_factorization_monoid.{0} (bin_tree.{0} empty) (@function.extfun_app.{2 1} Type cancel_comm_monoid_with_zero.{0} h0 (bin_tree.{0} empty))  := sorry --non-trivial
lemma new_lemma_28259 (h0 : topological_space (has_pos_part (ring linarith.comp))) : sequential_space (has_pos_part (ring linarith.comp)) := sorry --non-trivial
lemma new_lemma_28260 (h0 : function.extfun Type cancel_comm_monoid_with_zero) : @unique_factorization_monoid.{0} (is_R_or_C.{0} unsigned) (@function.extfun_app.{2 1} Type cancel_comm_monoid_with_zero.{0} h0 (is_R_or_C.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_28261 (h0 : functor.add_const (topological_space (boolean_algebra pos)) (has_neg (has_neg (add_cancel_monoid (ring pos))))) : @t0_space.{0} (boolean_algebra.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (boolean_algebra.{0} pos)) (has_neg.{0} (has_neg.{0} (add_cancel_monoid.{0} (ring.{0} pos)))) h0)  := sorry --non-trivial
lemma new_lemma_28262 (h0 : topological_space (has_zero (has_to_string name))) : irreducible_space (has_zero (has_to_string name)) := sorry --non-trivial
lemma new_lemma_28263 (h0 : add_group (has_compl enat)) : is_add_cyclic (has_compl enat) := sorry --non-trivial
lemma new_lemma_28264 (h0 : function.extfun Type list) : palindrome (function.extfun_app h0 (add_cancel_monoid congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_28265 (h0 : topological_space (has_to_string environment.implicit_infer_kind)) : preirreducible_space (has_to_string environment.implicit_infer_kind) := sorry --non-trivial
lemma new_lemma_28266 (h0 : functor.add_const (topological_space (pseudo_metric_space empty)) empty) : @discrete_topology.{0} (pseudo_metric_space.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (pseudo_metric_space.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_28267 (h0 : functor.add_const (add_group (complete_distrib_lattice pos)) (has_add Type)) : @is_add_cyclic.{0} (complete_distrib_lattice.{0} pos) (@functor.add_const.run.{0 1} (add_group.{0} (complete_distrib_lattice.{0} pos)) (has_add.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_28268 (h0 : topological_space (has_bot (has_neg name))) : preconnected_space (has_bot (has_neg name)) := sorry --non-trivial
lemma new_lemma_28269 (h0 : function.extfun Type filter) : countable_Inter_filter (function.extfun_app h0 (add_cancel_monoid ennreal)) := sorry --non-trivial
lemma new_lemma_28270 (h0 : functor.add_const (topological_space (add_cancel_monoid name)) pos) : @totally_disconnected_space.{0} (add_cancel_monoid.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (add_cancel_monoid.{0} name)) pos h0)  := sorry --non-trivial
lemma new_lemma_28271 (h0 : functor.add_const (uniform_space (has_nndist linarith.comp)) Type) : @separated_space.{0} (has_nndist.{0} linarith.comp) (@functor.add_const.run.{0 1} (uniform_space.{0} (has_nndist.{0} linarith.comp)) Type h0)  := sorry --non-trivial
lemma new_lemma_28272 (h0 : functor.add_const (topological_space (complete_distrib_lattice empty)) empty) : @totally_separated_space.{0} (complete_distrib_lattice.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (complete_distrib_lattice.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_28273 (h0 : cancel_comm_monoid_with_zero (canonically_linear_ordered_monoid pos)) : unique_factorization_monoid (canonically_linear_ordered_monoid pos) := sorry --non-trivial
lemma new_lemma_28274 (h0 : cancel_comm_monoid_with_zero (free_add_monoid congr_arg_kind)) : unique_factorization_monoid (free_add_monoid congr_arg_kind) := sorry --non-trivial
lemma new_lemma_28275 (h0 : complete_lattice (has_norm (semiring (semiring num)))) : is_atomistic (has_norm (semiring (semiring num))) := sorry --non-trivial
lemma new_lemma_28276 (h0 : topological_space (boolean_algebra (sub_neg_monoid pos))) : totally_separated_space (boolean_algebra (sub_neg_monoid pos)) := sorry --non-trivial
lemma new_lemma_28277 (h0 : not (function.extfun Type complete_lattice -> false)) : @is_atomistic.{0} (has_top.{0} empty) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type complete_lattice.{0}) h0) (has_top.{0} empty))  := sorry --non-trivial
lemma new_lemma_28278 (h0 : functor.add_const (topological_space (has_neg_part environment.implicit_infer_kind)) name) : @irreducible_space.{0} (has_neg_part.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (has_neg_part.{0} environment.implicit_infer_kind)) name h0)  := sorry --non-trivial
lemma new_lemma_28279 (h0 : ring (has_bot linarith.comp)) : rank_condition (has_bot linarith.comp) := sorry --non-trivial
lemma new_lemma_28280 (h0 : topological_space (add_semigroup num)) : path_connected_space (add_semigroup num) := sorry --non-trivial
lemma new_lemma_28281 (h0 : functor.add_const (topological_space (sub_neg_monoid name)) (has_neg pos)) : @discrete_topology.{0} (sub_neg_monoid.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (sub_neg_monoid.{0} name)) (has_neg.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_28282 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @totally_disconnected_space.{0} (monoid.{0} ennreal) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (monoid.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_28283 (h0 : topological_space (boolean_algebra (comm_group (comm_group unsigned)))) : totally_separated_space (boolean_algebra (comm_group (comm_group unsigned))) := sorry --non-trivial
lemma new_lemma_28284 (h0 : function.extfun Type group) : @group.fg.{0} (cancel_monoid.{0} name) (@function.extfun_app.{2 1} Type group.{0} h0 (cancel_monoid.{0} name))  := sorry --non-trivial
lemma new_lemma_28285 (h0 : functor.add_const (function.extfun (Type 1) topological_space) pos) : @totally_disconnected_space.{1} (ordered_comm_ring.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) topological_space.{1}) pos h0) (ordered_comm_ring.{1} Type))  := sorry --non-trivial
lemma new_lemma_28286 (h0 : functor.add_const (finset (ring pos)) (has_neg pos)) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_28287 (h0 : topological_space (ordered_comm_monoid (ring Type))) : path_connected_space (ordered_comm_monoid (ring Type)) := sorry --non-trivial
lemma new_lemma_28288 (h1 : function.extfun Type ring) : @strong_rank_condition.{0} linarith.comp_source (@function.extfun_app.{2 1} Type ring.{0} h1 linarith.comp_source)  := sorry --non-trivial
lemma new_lemma_28289 (h0 : function.extfun Type complete_lattice) : @is_compactly_generated.{0} (distrib_lattice.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (distrib_lattice.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_28290 (h0 : functor.add_const (ring (has_add Type)) pos) : @rank_condition.{1} (has_add.{1} Type) (@functor.add_const.run.{1 0} (ring.{1} (has_add.{1} Type)) pos h0)  := sorry --non-trivial
lemma new_lemma_28291 (h0 : not (function.extfun Type topological_space -> false)) : @path_connected_space.{0} (semiring.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (semiring.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_28292 (h0 : topological_space (comm_group (comm_group Type))) : regular_space (comm_group (comm_group Type)) := sorry --non-trivial
lemma new_lemma_28293 (h0 : functor.comp topological_space cancel_monoid ennreal) : @preirreducible_space.{0} (cancel_monoid.{0} ennreal) (@functor.comp.run.{0 0 0} topological_space.{0} cancel_monoid.{0} ennreal h0)  := sorry --non-trivial
lemma new_lemma_28294 (h0 : function.extfun Type group) : @group.fg.{0} (left_cancel_semigroup.{0} empty) (@function.extfun_app.{2 1} Type group.{0} h0 (left_cancel_semigroup.{0} empty))  := sorry --non-trivial
lemma new_lemma_28295 (h0 : topological_space (distrib std_gen)) : path_connected_space (distrib std_gen) := sorry --non-trivial
lemma new_lemma_28296 (h0 : topological_space (semigroup (has_add name))) : t0_space (semigroup (has_add name)) := sorry --non-trivial
lemma new_lemma_28297 (h0 : topological_space (partial_order (option (option empty)))) : loc_path_connected_space (partial_order (option (option empty))) := sorry --non-trivial
lemma new_lemma_28298 (h0 : not (uniform_space (has_norm unsigned) -> false)) : @complete_space.{0} (has_norm.{0} unsigned) (@classical.by_contradiction'.{1} (uniform_space.{0} (has_norm.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_28299 (h0 : ring (normed_field (has_nnnorm (has_compl linarith.comp_source)))) : rank_condition (normed_field (has_nnnorm (has_compl linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_28300 (h1 : ring (has_append (has_nnnorm fun_info))) : rank_condition (has_append (has_nnnorm fun_info)) := sorry --non-trivial
lemma new_lemma_28301 (h0 : topological_space (boolean_algebra (boolean_algebra (boolean_algebra name)))) : t1_space (boolean_algebra (boolean_algebra (boolean_algebra name))) := sorry --non-trivial
lemma new_lemma_28302 (h0 : not (ring (has_norm linarith.comp) -> false)) : @strong_rank_condition.{0} (has_norm.{0} linarith.comp) (@classical.by_contradiction'.{1} (ring.{0} (has_norm.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_28303 (h0 : group (boolean_algebra.core (has_nndist linarith.comp))) : normalizer_condition (boolean_algebra.core (has_nndist linarith.comp)) := sorry --non-trivial
lemma new_lemma_28304 (h0 : functor.add_const (add_monoid (finset unsigned)) empty) : @add_monoid.fg.{0} (finset.{0} unsigned) (@functor.add_const.run.{0 0} (add_monoid.{0} (finset.{0} unsigned)) empty h0)  := sorry --non-trivial
lemma new_lemma_28305 (h0 : not (topological_space (comm_ring char) -> false)) : @path_connected_space.{0} (comm_ring.{0} char) (@classical.by_contradiction'.{1} (topological_space.{0} (comm_ring.{0} char)) h0)  := sorry --non-trivial
lemma new_lemma_28306 (h0 : ordered_comm_monoid (has_Inf (has_add name))) : has_exists_mul_of_le (has_Inf (has_add name)) := sorry --non-trivial
lemma new_lemma_28307 (h0 : not (finset (complete_linear_order unsigned) -> false)) : finset.nonempty (classical.by_contradiction' h0) := sorry --non-trivial
lemma new_lemma_28308 (h0 : complete_lattice (has_top (has_norm (comm_ring linarith.ineq)))) : complete_lattice.is_Sup_finite_compact (has_top (has_norm (comm_ring linarith.ineq))) := sorry --non-trivial
lemma new_lemma_28309 (h0 : functor.add_const (add_monoid (has_to_string unsigned)) linarith.comp) : @add_monoid.fg.{0} (has_to_string.{0} unsigned) (@functor.add_const.run.{0 0} (add_monoid.{0} (has_to_string.{0} unsigned)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_28310 (h0 : ring (linear_ordered_add_comm_group_with_top linarith.ineq)) : strong_rank_condition (linear_ordered_add_comm_group_with_top linarith.ineq) := sorry --non-trivial
lemma new_lemma_28311 (h0 : function.extfun (nat -> Type) (function.extfun nat)) : @discrete_topology.{0} (sub_neg_monoid.{0} linarith.comp) (@matrix.vec_empty.{0} (topological_space.{0} (sub_neg_monoid.{0} linarith.comp)) (@function.extfun_app.{1 1} nat fin (@function.extfun_app.{2 1} (nat → Type) (function.extfun.{1 1} nat) h0 fin) (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_28312 (h0 : function.extfun Type filter) : filter.ne_bot (function.extfun_app h0 (random_gen unsigned)) := sorry --non-trivial
lemma new_lemma_28313 (h0 : functor.add_const (function.extfun Type topological_space) environment.implicit_infer_kind) : @t1_space.{0} (semigroup.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) environment.implicit_infer_kind h0) (semigroup.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_28314 (h0 : ring (has_zero (normed_comm_ring Type))) : is_domain (has_zero (normed_comm_ring Type)) := sorry --non-trivial
lemma new_lemma_28315 (h0 : ordered_comm_monoid (add_cancel_monoid (boolean_algebra.core Type))) : has_exists_mul_of_le (add_cancel_monoid (boolean_algebra.core Type)) := sorry --non-trivial
lemma new_lemma_28316 (h0 : functor.add_const (monoid (semigroup pos)) linarith.comp) : @monoid.fg.{0} (semigroup.{0} pos) (@functor.add_const.run.{0 0} (monoid.{0} (semigroup.{0} pos)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_28317 (h0 : ring (add_left_cancel_semigroup (semiring (semiring empty)))) : rank_condition (add_left_cancel_semigroup (semiring (semiring empty))) := sorry --non-trivial
lemma new_lemma_28318 (h0 : add_group (ordered_comm_ring (has_add (has_add (has_nndist (has_add (finset (has_add pos)))))))) : is_add_cyclic (ordered_comm_ring (has_add (has_add (has_nndist (has_add (finset (has_add pos))))))) := sorry --non-trivial
lemma new_lemma_28319 (h0 : functor.comp topological_space pseudo_metric_space (option unsigned)) : @topological_space.separable_space.{0} (pseudo_metric_space.{0} (option.{0} unsigned)) (@functor.comp.run.{0 0 0} topological_space.{0} pseudo_metric_space.{0} (option.{0} unsigned) h0)  := sorry --non-trivial
lemma new_lemma_28320 (h0 : functor.add_const (topological_space (normed_comm_ring environment.implicit_infer_kind)) name) : @totally_separated_space.{0} (normed_comm_ring.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (normed_comm_ring.{0} environment.implicit_infer_kind)) name h0)  := sorry --non-trivial
lemma new_lemma_28321 (h0 : function.extfun Type topological_space) : @t0_space.{0} (dlist.{0} char) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (dlist.{0} char))  := sorry --non-trivial
lemma new_lemma_28322 (h0 : function.extfun Type complete_lattice) : @complete_lattice.is_Sup_finite_compact.{0} (semiring.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (semiring.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_28323 (h0 : list (left_cancel_monoid (semiring (semiring (semiring (semiring empty)))))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_28324 (h0 : functor.add_const Prop (finset (has_add (has_add Type)))) : functor.add_const.run h0 := sorry --non-trivial
lemma new_lemma_28325 (h0 : finset (has_pos_part (has_neg Type))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_28326 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : filter.ne_bot (function.extfun_app (function.extfun_app h0 filter) (has_nndist congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_28327 (h0 : function.extfun Type filter) : filter.ne_bot (function.extfun_app h0 (pseudo_metric_space pos)) := sorry --non-trivial
lemma new_lemma_28328 (h0 : functor.add_const (topological_space (normed_comm_ring unsigned)) pos) : @t1_space.{0} (normed_comm_ring.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (normed_comm_ring.{0} unsigned)) pos h0)  := sorry --non-trivial
lemma new_lemma_28329 (h0 : functor.add_const (functor.add_const (ring linarith.comp) pos) pos) : @is_principal_ideal_ring.{0} linarith.comp (@functor.add_const.run.{0 0} (ring.{0} linarith.comp) pos (@functor.add_const.run.{0 0} (functor.add_const.{0 0} (ring.{0} linarith.comp) pos) pos h0))  := sorry --non-trivial
lemma new_lemma_28330 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @rank_condition.{0} (@id.{2} Type linarith.comp_source) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (@id.{2} Type linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_28331 (h0 : function.extfun Type list) : list.nodup (function.extfun_app h0 (ring environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_28332 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @monoid.fg.{0} (has_norm.{0} num) (@function.extfun_app.{2 1} Type monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 monoid.{0}) (has_norm.{0} num))  := sorry --non-trivial
lemma new_lemma_28333 (h0 : set (multiplicative environment.projection_info)) : set.finite h0 := sorry --non-trivial
lemma new_lemma_28334 (h0 : uniform_space (has_inter (option unsigned))) : separated_space (has_inter (option unsigned)) := sorry --non-trivial
lemma new_lemma_28335 (h0 : topological_space (finset (finset pos))) : preconnected_space (finset (finset pos)) := sorry --non-trivial
lemma new_lemma_28336 (h0 : function.extfun (Type 1 -> Type) (function.extfun (Type 1))) : @topological_space.separable_space.{0} (normed_comm_ring.{0} linarith.comp) (@functor.add_const.run.{0 1} (topological_space.{0} (normed_comm_ring.{0} linarith.comp)) Type (@function.extfun_app.{3 1} (Type 1) (functor.add_const.{0 1} (topological_space.{0} (normed_comm_ring.{0} linarith.comp))) (@function.extfun_app.{3 3} (Type 1 → Type) (function.extfun.{3 1} (Type 1)) h0 (functor.add_const.{0 1} (topological_space.{0} (normed_comm_ring.{0} linarith.comp)))) Type))  := sorry --non-trivial
lemma new_lemma_28337 (h0 : function.extfun Type topological_space) : @totally_disconnected_space.{0} (has_add.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_add.{0} pos))  := sorry --non-trivial
lemma new_lemma_28338 (h0 : fin has_zero.zero) : @loc_path_connected_space.{0} (canonically_ordered_monoid.{0} linarith.comp) (@matrix.vec_empty.{0} (topological_space.{0} (canonically_ordered_monoid.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_28339 (h0 : topological_space (with_one (semiring empty))) : totally_separated_space (with_one (semiring empty)) := sorry --non-trivial
lemma new_lemma_28340 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @locally_compact_space.{0} (simple_graph.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (simple_graph.{0} pos))  := sorry --non-trivial
lemma new_lemma_28341 (h0 : not (topological_space (has_top congr_arg_kind) -> false)) : @topological_space.separable_space.{0} (has_top.{0} congr_arg_kind) (@classical.by_contradiction'.{1} (topological_space.{0} (has_top.{0} congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_28342 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @rank_condition.{0} (complete_linear_order.{0} num) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (complete_linear_order.{0} num))  := sorry --non-trivial
lemma new_lemma_28343 (h0 : topological_space (normed_lattice_add_comm_group (has_neg pos))) : topological_space.separable_space (normed_lattice_add_comm_group (has_neg pos)) := sorry --non-trivial
lemma new_lemma_28344 (h0 : complete_lattice (measurable_space.dynkin_system (semiring (semiring empty)))) : complete_lattice.is_Sup_finite_compact (measurable_space.dynkin_system (semiring (semiring empty))) := sorry --non-trivial
lemma new_lemma_28345 (h0 : has_mem.mem (measurable_space to_additive.value_type) has_emptyc.emptyc) : @totally_separated_space.{0} (measurable_space.{0} to_additive.value_type) (@finset.pi.empty.{1 0} Type topological_space.{0} (measurable_space.{0} to_additive.value_type) h0)  := sorry --non-trivial
lemma new_lemma_28346 (h0 : topological_space (has_bot (has_add pos))) : path_connected_space (has_bot (has_add pos)) := sorry --non-trivial
lemma new_lemma_28347 (h2 : ring to_additive.value_type) : strong_rank_condition to_additive.value_type := sorry --non-trivial
lemma new_lemma_28348 (h0 : not (uniform_space (has_append char) -> false)) : @complete_space.{0} (has_append.{0} char) (@classical.by_contradiction'.{1} (uniform_space.{0} (has_append.{0} char)) h0)  := sorry --non-trivial
lemma new_lemma_28349 (h0 : function.extfun Type topological_space) : @irreducible_space.{0} (has_to_string.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_to_string.{0} pos))  := sorry --non-trivial
lemma new_lemma_28350 (h0 : ring (generalized_boolean_algebra (sub_neg_monoid (has_add Type)))) : is_principal_ideal_ring (generalized_boolean_algebra (sub_neg_monoid (has_add Type))) := sorry --non-trivial
lemma new_lemma_28351 (h0 : functor.add_const (ring (has_neg_part environment.implicit_infer_kind)) (has_neg_part name)) : @rank_condition.{0} (has_neg_part.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (ring.{0} (has_neg_part.{0} environment.implicit_infer_kind)) (has_neg_part.{0} name) h0)  := sorry --non-trivial
lemma new_lemma_28352 (h0 : topological_space (has_Inf (has_Inf pos))) : totally_disconnected_space (has_Inf (has_Inf pos)) := sorry --non-trivial
lemma new_lemma_28353 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_atomistic.{0} (ring.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (ring.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_28354 (h0 : topological_space (normed_lattice_add_comm_group (has_add real))) : totally_disconnected_space (normed_lattice_add_comm_group (has_add real)) := sorry --non-trivial
lemma new_lemma_28355 (h0 : topological_space (boolean_algebra (ring (has_Inf pos)))) : sequential_space (boolean_algebra (ring (has_Inf pos))) := sorry --non-trivial
lemma new_lemma_28356 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @separated_space.{0} (ordered_comm_ring.{0} real) (@function.extfun_app.{2 1} Type uniform_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 uniform_space.{0}) (ordered_comm_ring.{0} real))  := sorry --non-trivial
lemma new_lemma_28357 (h0 : cancel_comm_monoid_with_zero (pseudo_metric_space pos)) : unique_factorization_monoid (pseudo_metric_space pos) := sorry --non-trivial
lemma new_lemma_28358 (h0 : monoid (ordered_ring empty)) : monoid.fg (ordered_ring empty) := sorry --non-trivial
lemma new_lemma_28359 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @locally_compact_space.{0} (@id.{2} Type (has_norm.{0} linarith.comp)) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (@id.{2} Type (has_norm.{0} linarith.comp)))  := sorry --non-trivial
lemma new_lemma_28360 (h0 : function.extfun Type topological_space) : @discrete_topology.{0} (has_to_string.{0} ennreal) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_to_string.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_28361 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @sequential_space.{0} (ordered_comm_ring.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (ordered_comm_ring.{0} pos))  := sorry --non-trivial
lemma new_lemma_28362 (h0 : functor.add_const (finset (boolean_algebra.core pos)) environment.implicit_infer_kind) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_28363 (h0 : ring (has_union (has_norm num))) : rank_condition (has_union (has_norm num)) := sorry --non-trivial
lemma new_lemma_28364 (h0 : set (ereal -> with_zero fun_info)) : set.separates_points h0 := sorry --non-trivial
lemma new_lemma_28365 (h0 : complete_lattice (simple_graph linarith.comp_source)) : complete_lattice.is_Sup_finite_compact (simple_graph linarith.comp_source) := sorry --non-trivial
lemma new_lemma_28366 (h0 : functor.add_const (topological_space (has_neg linarith.comp)) name) : @preirreducible_space.{0} (has_neg.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (has_neg.{0} linarith.comp)) name h0)  := sorry --non-trivial
lemma new_lemma_28367 (h0 : ordered_add_comm_monoid (canonically_ordered_add_monoid congr_arg_kind)) : archimedean (canonically_ordered_add_monoid congr_arg_kind) := sorry --non-trivial
lemma new_lemma_28368 (h0 : add_group (has_top (semiring (semiring congr_arg_kind)))) : is_add_cyclic (has_top (semiring (semiring congr_arg_kind))) := sorry --non-trivial
lemma new_lemma_28369 (h0 : group (normed_linear_ordered_group unsigned)) : group.fg (normed_linear_ordered_group unsigned) := sorry --non-trivial
lemma new_lemma_28370 (h0 : topological_space (has_inv (has_one (random_gen fun_info)))) : path_connected_space (has_inv (has_one (random_gen fun_info))) := sorry --non-trivial
lemma new_lemma_28371 (h0 : topological_space (comm_semigroup (sub_neg_monoid real))) : t1_space (comm_semigroup (sub_neg_monoid real)) := sorry --non-trivial
lemma new_lemma_28372 (h0 : functor.add_const (function.extfun Type topological_space) environment.implicit_infer_kind) : @totally_separated_space.{0} (semigroup.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) environment.implicit_infer_kind h0) (semigroup.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_28373 (h0 : function.extfun Type ordered_comm_monoid) : @has_exists_mul_of_le.{0} (has_to_string.{0} ennreal) (@function.extfun_app.{2 1} Type ordered_comm_monoid.{0} h0 (has_to_string.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_28374 (h0 : has_lt (ordered_ring empty)) (h1 : function.extfun (ordered_ring empty) (fun (x : ordered_ring empty), Prop)) : set.is_wf (function.extfun_app h1) := sorry --non-trivial
lemma new_lemma_28375 (h0 : ring (boolean_algebra (has_to_string (has_add (has_add (has_to_string Type)))))) : rank_condition (boolean_algebra (has_to_string (has_add (has_add (has_to_string Type))))) := sorry --non-trivial
lemma new_lemma_28376 (h0 : monoid (topological_space fun_info)) (h1 : topological_space (star_monoid (topological_space fun_info))) : t0_space (star_monoid (topological_space fun_info)) := sorry --non-trivial
lemma new_lemma_28377 (h0 : not (complete_lattice (metric_space unsigned) -> false)) : @is_atomistic.{0} (metric_space.{0} unsigned) (@classical.by_contradiction'.{1} (complete_lattice.{0} (metric_space.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_28378 (h0 : function.extfun Type ring) : @strong_rank_condition.{0} (finset.{0} unsigned) (@function.extfun_app.{2 1} Type ring.{0} h0 (finset.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_28379 (h0 : semiring (has_neg (option (has_neg (option num))))) : is_noetherian_ring (has_neg (option (has_neg (option num)))) := sorry --non-trivial
lemma new_lemma_28380 (h0 : not (complete_lattice (normed_group linarith.comp_source) -> false)) : @is_compactly_generated.{0} (normed_group.{0} linarith.comp_source) (@classical.by_contradiction'.{1} (complete_lattice.{0} (normed_group.{0} linarith.comp_source)) h0)  := sorry --non-trivial
lemma new_lemma_28381 (h0 : function.extfun Type finset) : finset.nonempty (function.extfun_app h0 (cancel_monoid num)) := sorry --non-trivial
lemma new_lemma_28382 (h0 : group (comm_group (finset linarith.comp))) : normalizer_condition (comm_group (finset linarith.comp)) := sorry --non-trivial
lemma new_lemma_28383 (h0 : not (add_group (has_union congr_arg_kind) -> false)) : @is_add_cyclic.{0} (has_union.{0} congr_arg_kind) (@classical.by_contradiction'.{1} (add_group.{0} (has_union.{0} congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_28384 (h0 : functor.add_const (ordered_comm_monoid (has_neg_part name)) (has_add pos)) : @has_exists_mul_of_le.{0} (has_neg_part.{0} name) (@functor.add_const.run.{0 0} (ordered_comm_monoid.{0} (has_neg_part.{0} name)) (has_add.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_28385 (h0 : add_group (semiring (random_gen (random_gen (random_gen fun_info))))) : is_add_cyclic (semiring (random_gen (random_gen (random_gen fun_info)))) := sorry --non-trivial
lemma new_lemma_28386 (h0 : functor.add_const (function.extfun (Type 1) topological_space) linarith.comp) : @totally_separated_space.{1} (ring.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) topological_space.{1}) linarith.comp h0) (ring.{1} Type))  := sorry --non-trivial
lemma new_lemma_28387 (h0 : topological_space (ordered_ring (linear_order empty))) : irreducible_space (ordered_ring (linear_order empty)) := sorry --non-trivial
lemma new_lemma_28388 (h0 : functor.add_const (ordered_add_comm_monoid (cancel_monoid unsigned)) (boolean_algebra Type)) : @archimedean.{0} (cancel_monoid.{0} unsigned) (@functor.add_const.run.{0 1} (ordered_add_comm_monoid.{0} (cancel_monoid.{0} unsigned)) (boolean_algebra.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_28389 (h0 : ring (normed_field (has_nnnorm enat))) : rank_condition (normed_field (has_nnnorm enat)) := sorry --non-trivial
lemma new_lemma_28390 (h0 : function.extfun Type (functor.comp topological_space has_neg_part)) : @totally_separated_space.{0} (has_neg_part.{0} ennreal) (@functor.comp.run.{0 0 0} topological_space.{0} has_neg_part.{0} ennreal (@function.extfun_app.{2 1} Type (functor.comp.{0 0 0} topological_space.{0} has_neg_part.{0}) h0 ennreal))  := sorry --non-trivial
lemma new_lemma_28391 (h1 : function.extfun Type topological_space) : @path_connected_space.{0} (random_gen.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type topological_space.{0} h1 (random_gen.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_28392 (h0 : topological_space (add_group (semiring congr_arg_kind))) : totally_separated_space (add_group (semiring congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_28393 (h0 : functor.add_const (topological_space (add_comm_monoid linarith.comp)) pos) : @irreducible_space.{0} (add_comm_monoid.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (add_comm_monoid.{0} linarith.comp)) pos h0)  := sorry --non-trivial
lemma new_lemma_28394 (h0 : functor.add_const (ordered_comm_monoid (has_pos_part linarith.comp)) (has_neg (has_neg Type))) : @has_exists_mul_of_le.{0} (has_pos_part.{0} linarith.comp) (@functor.add_const.run.{0 1} (ordered_comm_monoid.{0} (has_pos_part.{0} linarith.comp)) (has_neg.{1} (has_neg.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_28395 (h0 : group (option congr_arg_kind)) : is_cyclic (option congr_arg_kind) := sorry --non-trivial
lemma new_lemma_28396 (h0 : ring (has_top (random_gen to_additive.value_type))) : rank_condition (has_top (random_gen to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_28397 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_cyclic.{0} (has_inv.{0} char) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (has_inv.{0} char))  := sorry --non-trivial
lemma new_lemma_28398 (h0 : function.extfun Type topological_space) : @t1_space.{0} (non_assoc_semiring.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (non_assoc_semiring.{0} num))  := sorry --non-trivial
lemma new_lemma_28399 (h0 : functor.add_const (function.extfun Type topological_space) Type) : @totally_separated_space.{0} (semigroup.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type topological_space.{0}) Type h0) (semigroup.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_28400 (h0 : filter (linear_ordered_semiring (semiring (with_one (has_top unsigned))))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_28401 (h2 : complete_lattice (comm_ring linarith.ineq)) : is_compactly_generated (comm_ring linarith.ineq) := sorry --non-trivial
lemma new_lemma_28402 (h0 : functor.comp ring has_nndist environment.implicit_infer_kind) : @is_principal_ideal_ring.{0} (has_nndist.{0} environment.implicit_infer_kind) (@functor.comp.run.{0 0 0} ring.{0} has_nndist.{0} environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_28403 (h0 : topological_space (ordered_comm_ring (has_neg (has_neg (has_neg pos))))) : t0_space (ordered_comm_ring (has_neg (has_neg (has_neg pos)))) := sorry --non-trivial
lemma new_lemma_28404 (h0 : topological_space (add_comm_monoid (sub_neg_monoid linarith.comp))) : t0_space (add_comm_monoid (sub_neg_monoid linarith.comp)) := sorry --non-trivial
lemma new_lemma_28405 (h0 : set Prop) (h1 : set.is_wf h0) (h2 : set.nonempty h0) : @set.is_wf.min.{0} Prop (@complete_semilattice_Inf.to_partial_order.{0} Prop (@complete_lattice.to_complete_semilattice_Inf.{0} Prop Prop.complete_lattice)) h0 h1 h2  := sorry --non-trivial
lemma new_lemma_28406 (h0 : group (has_pos_part (ring (has_pos_part Type)))) : normalizer_condition (has_pos_part (ring (has_pos_part Type))) := sorry --non-trivial
lemma new_lemma_28407 (h0 : function.extfun Type topological_space) : @sequential_space.{0} (has_to_string.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_to_string.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_28408 (h0 : functor.add_const (complete_lattice (has_Sup unsigned)) (semiring (semiring empty))) : @is_compactly_generated.{0} (has_Sup.{0} unsigned) (@functor.add_const.run.{0 0} (complete_lattice.{0} (has_Sup.{0} unsigned)) (semiring.{0} (semiring.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_28409 (h0 : functor.add_const (add_group (has_neg_part unsigned)) name) : @is_add_cyclic.{0} (has_neg_part.{0} unsigned) (@functor.add_const.run.{0 0} (add_group.{0} (has_neg_part.{0} unsigned)) name h0)  := sorry --non-trivial
lemma new_lemma_28410 (h0 : ordered_add_comm_monoid (bin_tree empty)) : archimedean (bin_tree empty) := sorry --non-trivial
lemma new_lemma_28411 (h0 : uniform_space (id (has_inv (has_inv linarith.ineq)))) : complete_space (id (has_inv (has_inv linarith.ineq))) := sorry --non-trivial
lemma new_lemma_28412 (h0 : function.extfun Type complete_lattice) : @is_compactly_generated.{0} nnreal (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 nnreal)  := sorry --non-trivial
lemma new_lemma_28413 (h0 : filter (normed_comm_ring (has_add pos))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_28414 (h3 : ring (has_div string_imp)) : is_domain (has_div string_imp) := sorry --non-trivial
lemma new_lemma_28415 (h0 : function.extfun Type topological_space) : @totally_separated_space.{0} (ordered_comm_group.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (ordered_comm_group.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_28416 (h0 : fin has_zero.zero) : @is_atomistic.{0} (comm_semigroup.{0} pos) (@matrix.vec_empty.{0} (complete_lattice.{0} (comm_semigroup.{0} pos)) h0)  := sorry --non-trivial
lemma new_lemma_28417 (h0 : functor.add_const (functor.add_const (complete_lattice ennreal) num) (option (option (option unsigned)))) : complete_lattice.is_Sup_finite_compact ennreal := sorry --non-trivial
lemma new_lemma_28418 (h0 : topological_space (has_norm unsigned)) : topological_space.separable_space (has_norm unsigned) := sorry --non-trivial
lemma new_lemma_28419 (h0 : function.extfun nat fin) : @totally_separated_space.{0} (comm_semigroup.{0} real) (@matrix.vec_empty.{0} (topological_space.{0} (comm_semigroup.{0} real)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_28420 (h0 : ring (with_one (has_top (has_top linarith.comp_source)))) : is_domain (with_one (has_top (has_top linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_28421 (h0 : complete_lattice (random_gen (has_top to_additive.value_type))) : is_atomistic (random_gen (has_top to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_28422 (h0 : topological_space (has_dist congr_arg_kind)) : t1_space (has_dist congr_arg_kind) := sorry --non-trivial
lemma new_lemma_28423 (h0 : option (topological_space (normed_comm_ring (has_add (has_add (has_add (has_add (has_add Type)))))))) (h1 : topological_space (normed_comm_ring (has_add (has_add (has_add (has_add (has_add Type))))))) : t0_space (normed_comm_ring (has_add (has_add (has_add (has_add (has_add Type)))))) := sorry --non-trivial
lemma new_lemma_28424 (h0 : cancel_comm_monoid_with_zero (has_add (has_neg pos))) : unique_factorization_monoid (has_add (has_neg pos)) := sorry --non-trivial
lemma new_lemma_28425 (h0 : topological_space (semigroup (has_to_string environment.implicit_infer_kind))) : totally_disconnected_space (semigroup (has_to_string environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_28426 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : countable_Inter_filter (function.extfun_app (function.extfun_app h0 filter) (has_Inf linarith.comp)) := sorry --non-trivial
lemma new_lemma_28427 (h0 : topological_space (id (random_gen linarith.comp_source))) : totally_disconnected_space (id (random_gen linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_28428 (h0 : functor.add_const (ordered_add_comm_monoid (normed_comm_ring name)) linarith.comp) : @archimedean.{0} (normed_comm_ring.{0} name) (@functor.add_const.run.{0 0} (ordered_add_comm_monoid.{0} (normed_comm_ring.{0} name)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_28429 (h0 : functor.add_const (function.extfun Type ring) name) : @rank_condition.{0} (finset.{0} pos) (@function.extfun_app.{2 1} Type ring.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type ring.{0}) name h0) (finset.{0} pos))  := sorry --non-trivial
lemma new_lemma_28430 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_atomistic.{0} (random_gen.{0} empty) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (random_gen.{0} empty))  := sorry --non-trivial
lemma new_lemma_28431 (h1 : add_group (complete_semilattice_Sup linarith.comp_source)) : is_add_cyclic (complete_semilattice_Sup linarith.comp_source) := sorry --non-trivial
lemma new_lemma_28432 (h0 : not (function.extfun Type uniform_space -> false)) : @complete_space.{0} (has_norm.{0} (has_top.{0} (has_top.{0} (has_top.{0} (has_top.{0} fun_info))))) (@function.extfun_app.{2 1} Type uniform_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type uniform_space.{0}) h0) (has_norm.{0} (has_top.{0} (has_top.{0} (has_top.{0} (has_top.{0} fun_info))))))  := sorry --non-trivial
lemma new_lemma_28433 (h0 : semiring (id (has_norm (semiring congr_arg_kind)))) : is_noetherian_ring (id (has_norm (semiring congr_arg_kind))) := sorry --non-trivial
lemma new_lemma_28434 (h0 : functor.add_const (function.extfun Type complete_lattice) (option unsigned)) : @is_compactly_generated.{0} (canonically_ordered_comm_semiring.{0} name) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type complete_lattice.{0}) (option.{0} unsigned) h0) (canonically_ordered_comm_semiring.{0} name))  := sorry --non-trivial
lemma new_lemma_28435 (h0 : semiring (semigroup (has_neg pos))) : is_noetherian_ring (semigroup (has_neg pos)) := sorry --non-trivial
lemma new_lemma_28436 (h0 : functor.add_const (group (semigroup linarith.comp)) Type) : @group.fg.{0} (semigroup.{0} linarith.comp) (@functor.add_const.run.{0 1} (group.{0} (semigroup.{0} linarith.comp)) Type h0)  := sorry --non-trivial
lemma new_lemma_28437 (h0 : complete_lattice (free_add_monoid (semiring num))) : is_compactly_generated (free_add_monoid (semiring num)) := sorry --non-trivial
lemma new_lemma_28438 (h0 : group (boolean_algebra (boolean_algebra (finset (finset (has_neg linarith.comp)))))) : is_simple_group (boolean_algebra (boolean_algebra (finset (finset (has_neg linarith.comp))))) := sorry --non-trivial
lemma new_lemma_28439 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @rank_condition.{0} (has_Sup.{0} unsigned) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (has_Sup.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_28440 (h0 : function.extfun Type add_group) : @is_add_cyclic.{0} name (@function.extfun_app.{2 1} Type add_group.{0} h0 name)  := sorry --non-trivial
lemma new_lemma_28441 (h0 : ring (complete_distrib_lattice (ordered_comm_ring linarith.comp))) : is_domain (complete_distrib_lattice (ordered_comm_ring linarith.comp)) := sorry --non-trivial
lemma new_lemma_28442 (h0 : functor.add_const (ring (has_neg linarith.comp)) (has_pos_part pos)) : @is_domain.{0} (has_neg.{0} linarith.comp) (@functor.add_const.run.{0 0} (ring.{0} (has_neg.{0} linarith.comp)) (has_pos_part.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_28443 (h0 : functor.add_const (function.extfun Type topological_space) (has_neg (has_neg pos))) : @t0_space.{0} (has_add.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) (has_neg.{0} (has_neg.{0} pos)) h0) (has_add.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_28444 (h0 : set (add_comm_semigroup (add_comm_semigroup enat) -> mul_one_class (mul_one_class char))) : set.separates_points h0 := sorry --non-trivial
lemma new_lemma_28445 (h0 : function.extfun Type ring) : @is_domain.{0} (semiring.{0} (random_gen.{0} (has_top.{0} (has_top.{0} (has_norm.{0} (has_top.{0} (has_top.{0} congr_arg_kind))))))) (@function.extfun_app.{2 1} Type ring.{0} h0 (semiring.{0} (random_gen.{0} (has_top.{0} (has_top.{0} (has_norm.{0} (has_top.{0} (has_top.{0} congr_arg_kind))))))))  := sorry --non-trivial
lemma new_lemma_28446 (h0 : has_neg (nondiscrete_normed_field ereal)) (h1 : measurable_space (nondiscrete_normed_field ereal)) : has_measurable_neg (nondiscrete_normed_field ereal) := sorry --non-trivial
lemma new_lemma_28447 (h0 : function.extfun Type (functor.comp topological_space finset)) : @preconnected_space.{0} (finset.{0} pos) (@functor.comp.run.{0 0 0} topological_space.{0} finset.{0} pos (@function.extfun_app.{2 1} Type (functor.comp.{0 0 0} topological_space.{0} finset.{0}) h0 pos))  := sorry --non-trivial
lemma new_lemma_28448 (h0 : fin has_zero.zero) : @topological_space.separable_space.{0} (comm_semigroup.{0} pos) (@matrix.vec_empty.{0} (topological_space.{0} (comm_semigroup.{0} pos)) h0)  := sorry --non-trivial
lemma new_lemma_28449 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_cyclic.{0} (complete_distrib_lattice.{0} unsigned) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (complete_distrib_lattice.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_28450 (h0 : ring (dlist (has_inv to_additive.value_type))) : is_domain (dlist (has_inv to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_28451 (h0 : functor.add_const (group (has_to_string unsigned)) environment.implicit_infer_kind) : @is_cyclic.{0} (has_to_string.{0} unsigned) (@functor.add_const.run.{0 0} (group.{0} (has_to_string.{0} unsigned)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_28452 (h0 : functor.add_const (function.extfun Type uniform_space) name) : @separated_space.{0} (has_Inf.{0} pos) (@function.extfun_app.{2 1} Type uniform_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type uniform_space.{0}) name h0) (has_Inf.{0} pos))  := sorry --non-trivial
lemma new_lemma_28453 (h0 : add_monoid (with_one (semiring unsigned))) : add_monoid.fg (with_one (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_28454 (h0 : function.extfun (Type 1) complete_lattice) : @complete_lattice.is_Sup_finite_compact.{1} (boolean_algebra.{1} Type) (@function.extfun_app.{3 2} (Type 1) complete_lattice.{1} h0 (boolean_algebra.{1} Type))  := sorry --non-trivial
lemma new_lemma_28455 (h0 : functor.add_const (topological_space (has_add pos)) (has_neg (has_neg (has_neg (has_neg (has_neg Type)))))) : @totally_separated_space.{0} (has_add.{0} pos) (@functor.add_const.run.{0 1} (topological_space.{0} (has_add.{0} pos)) (has_neg.{1} (has_neg.{1} (has_neg.{1} (has_neg.{1} (has_neg.{1} Type))))) h0)  := sorry --non-trivial
lemma new_lemma_28456 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @discrete_topology.{0} (normed_comm_ring.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (normed_comm_ring.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_28457 (h0 : fin has_zero.zero) : @preconnected_space.{0} (has_bot.{0} real) (@matrix.vec_empty.{0} (topological_space.{0} (has_bot.{0} real)) h0)  := sorry --non-trivial
lemma new_lemma_28458 (h0 : group (has_pos_part Type)) : is_simple_group (has_pos_part Type) := sorry --non-trivial
lemma new_lemma_28459 (h0 : function.extfun Type ring) : @is_domain.{0} (ring.{0} ennreal) (@function.extfun_app.{2 1} Type ring.{0} h0 (ring.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_28460 (h0 : ring (pseudo_metric_space char)) : rank_condition (pseudo_metric_space char) := sorry --non-trivial
lemma new_lemma_28461 (h0 : topological_space (has_one (semiring empty))) : t0_space (has_one (semiring empty)) := sorry --non-trivial
lemma new_lemma_28462 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @normal_space.{0} (ordered_comm_monoid.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (ordered_comm_monoid.{0} name))  := sorry --non-trivial
lemma new_lemma_28463 (h0 : set (add_comm_semigroup fun_info -> char)) : set.separates_points h0 := sorry --non-trivial
lemma new_lemma_28464 (h0 : complete_lattice (normed_group (random_gen (random_gen to_additive.value_type)))) : is_compactly_generated (normed_group (random_gen (random_gen to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_28465 (h0 : topological_space (ordered_comm_monoid real)) : regular_space (ordered_comm_monoid real) := sorry --non-trivial
lemma new_lemma_28466 (h0 : set (string.iterator_imp -> has_le (mul_one_class (mul_one_class (mul_one_class string.iterator_imp))))) : set.separates_points h0 := sorry --non-trivial
lemma new_lemma_28467 (h1 : topological_space (has_inv string_imp)) : totally_separated_space (has_inv string_imp) := sorry --non-trivial
lemma new_lemma_28468 (h0 : topological_space (normed_comm_ring (option (option unsigned)))) : irreducible_space (normed_comm_ring (option (option unsigned))) := sorry --non-trivial
lemma new_lemma_28469 (h0 : functor.add_const (functor.add_const (group linarith.comp) Type) (ring Type)) : @normalizer_condition.{0} linarith.comp (@functor.add_const.run.{0 1} (group.{0} linarith.comp) Type (@functor.add_const.run.{0 1} (functor.add_const.{0 1} (group.{0} linarith.comp) Type) (ring.{1} Type) h0))  := sorry --non-trivial
lemma new_lemma_28470 (h0 : not (uniform_space (bin_tree congr_arg_kind) -> false)) : @complete_space.{0} (bin_tree.{0} congr_arg_kind) (@classical.by_contradiction'.{1} (uniform_space.{0} (bin_tree.{0} congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_28471 (h1 : ring (ordered_semiring linarith.comp_source)) : rank_condition (ordered_semiring linarith.comp_source) := sorry --non-trivial
lemma new_lemma_28472 (h0 : function.extfun Type topological_space) : @discrete_topology.{0} (linear_ordered_comm_ring.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (linear_ordered_comm_ring.{0} empty))  := sorry --non-trivial
lemma new_lemma_28473 (h0 : ordered_add_comm_monoid (has_inter (option num))) : archimedean (has_inter (option num)) := sorry --non-trivial
lemma new_lemma_28474 (h0 : function.extfun Type (functor.comp ordered_add_comm_monoid has_nndist)) : @archimedean.{0} (has_nndist.{0} (add_comm_monoid.{0} environment.implicit_infer_kind)) (@functor.comp.run.{0 0 0} ordered_add_comm_monoid.{0} has_nndist.{0} (add_comm_monoid.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type (functor.comp.{0 0 0} ordered_add_comm_monoid.{0} has_nndist.{0}) h0 (add_comm_monoid.{0} environment.implicit_infer_kind)))  := sorry --non-trivial
lemma new_lemma_28475 (h0 : add_group (add_left_cancel_monoid (has_ssubset linarith.comp_source))) : is_add_cyclic (add_left_cancel_monoid (has_ssubset linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_28476 (h0 : ordered_add_comm_monoid (has_pos_part (has_Inf real))) : archimedean (has_pos_part (has_Inf real)) := sorry --non-trivial
lemma new_lemma_28477 (h0 : ring (metric_space (semiring linarith.comp))) : strong_rank_condition (metric_space (semiring linarith.comp)) := sorry --non-trivial
lemma new_lemma_28478 (h0 : functor.add_const (group (comm_group Type)) (has_to_string (has_neg (has_neg linarith.comp)))) : @normalizer_condition.{1} (comm_group.{1} Type) (@functor.add_const.run.{1 0} (group.{1} (comm_group.{1} Type)) (has_to_string.{0} (has_neg.{0} (has_neg.{0} linarith.comp))) h0)  := sorry --non-trivial
lemma new_lemma_28479 (h0 : complete_lattice (option unsigned)) : complete_lattice.is_Sup_finite_compact (option unsigned) := sorry --non-trivial
lemma new_lemma_28480 (h0 : topological_space (is_R_or_C congr_arg_kind)) : path_connected_space (is_R_or_C congr_arg_kind) := sorry --non-trivial
lemma new_lemma_28481 (h0 : topological_space (has_ssubset (has_compl to_additive.value_type))) : totally_disconnected_space (has_ssubset (has_compl to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_28482 (h0 : topological_space (add_cancel_monoid (has_add (has_add unsigned)))) : path_connected_space (add_cancel_monoid (has_add (has_add unsigned))) := sorry --non-trivial
lemma new_lemma_28483 (h0 : topological_space (id (random_gen (random_gen linarith.comp_source)))) : totally_separated_space (id (random_gen (random_gen linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_28484 (h0 : group (boolean_algebra (has_to_string (finset pos)))) : normalizer_condition (boolean_algebra (has_to_string (finset pos))) := sorry --non-trivial
lemma new_lemma_28485 (h0 : functor.add_const (complete_lattice (semiring unsigned)) empty) : @is_compactly_generated.{0} (semiring.{0} unsigned) (@functor.add_const.run.{0 0} (complete_lattice.{0} (semiring.{0} unsigned)) empty h0)  := sorry --non-trivial
lemma new_lemma_28486 (h2 : topological_space empty) : t0_space empty := sorry --non-trivial
lemma new_lemma_28487 (h0 : ring (has_zero Type)) : strong_rank_condition (has_zero Type) := sorry --non-trivial
lemma new_lemma_28488 (h0 : ordered_add_comm_monoid (has_nndist (has_neg linarith.comp))) : archimedean (has_nndist (has_neg linarith.comp)) := sorry --non-trivial
lemma new_lemma_28489 (h0 : ring (free_add_monoid (semiring empty))) : is_principal_ideal_ring (free_add_monoid (semiring empty)) := sorry --non-trivial
lemma new_lemma_28490 (h0 : ordered_comm_monoid (add_cancel_monoid (boolean_algebra.core unsigned))) : has_exists_mul_of_le (add_cancel_monoid (boolean_algebra.core unsigned)) := sorry --non-trivial
lemma new_lemma_28491 (h0 : mul_zero_class Type -> Prop) : zzz_forall h0 := sorry --non-trivial
lemma new_lemma_28492 (h0 : topological_space (has_lt (mul_one_class linarith.ineq))) : t0_space (has_lt (mul_one_class linarith.ineq)) := sorry --non-trivial
lemma new_lemma_28493 (h0 : topological_space (canonically_ordered_monoid name)) : topological_space.separable_space (canonically_ordered_monoid name) := sorry --non-trivial
lemma new_lemma_28494 (h0 : ring (with_one (has_norm (has_norm (has_norm congr_arg_kind))))) : strong_rank_condition (with_one (has_norm (has_norm (has_norm congr_arg_kind)))) := sorry --non-trivial
lemma new_lemma_28495 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @archimedean.{0} (partial_order.{0} num) (@functor.add_const.run.{0 0} (ordered_add_comm_monoid.{0} (partial_order.{0} num)) empty (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (ordered_add_comm_monoid.{0} (partial_order.{0} num))) (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 (functor.add_const.{0 0} (ordered_add_comm_monoid.{0} (partial_order.{0} num)))) empty))  := sorry --non-trivial
lemma new_lemma_28496 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @add_monoid.fg.{0} (add_group.{0} unsigned) (@function.extfun_app.{2 1} Type add_monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 add_monoid.{0}) (add_group.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_28497 (h0 : functor.add_const (topological_space (semigroup name)) unsigned) : @normal_space.{0} (semigroup.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (semigroup.{0} name)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_28498 (h1 : not (uniform_space (random_gen linarith.comp_source) -> false)) : @complete_space.{0} (random_gen.{0} linarith.comp_source) (@classical.by_contradiction'.{1} (uniform_space.{0} (random_gen.{0} linarith.comp_source)) h1)  := sorry --non-trivial
lemma new_lemma_28499 (h0 : functor.add_const (ring (has_to_string Type)) (ring pos)) : @strong_rank_condition.{1} (has_to_string.{1} Type) (@functor.add_const.run.{1 0} (ring.{1} (has_to_string.{1} Type)) (ring.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_28500 (h0 : not (complete_lattice (linear_ordered_add_comm_group char) -> false)) : @is_compactly_generated.{0} (linear_ordered_add_comm_group.{0} char) (@classical.by_contradiction'.{1} (complete_lattice.{0} (linear_ordered_add_comm_group.{0} char)) h0)  := sorry --non-trivial
lemma new_lemma_28501 (h0 : functor.add_const (topological_space (ring name)) (has_neg Type)) : @totally_separated_space.{0} (ring.{0} name) (@functor.add_const.run.{0 1} (topological_space.{0} (ring.{0} name)) (has_neg.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_28502 (h1 : uniform_space (with_bot (with_bot (random_gen (random_gen (with_bot to_additive.value_type)))))) : complete_space (with_bot (with_bot (random_gen (random_gen (with_bot to_additive.value_type))))) := sorry --non-trivial
lemma new_lemma_28503 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @monoid.fg.{0} (linear_ordered_add_comm_group.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 monoid.{0}) (linear_ordered_add_comm_group.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_28504 (h1 : group (has_add string_imp)) : group.fg (has_add string_imp) := sorry --non-trivial
lemma new_lemma_28505 (h0 : has_mem.mem (linear_ordered_semiring to_additive.value_type) has_emptyc.emptyc) : @locally_compact_space.{0} (linear_ordered_semiring.{0} to_additive.value_type) (@finset.pi.empty.{1 0} Type topological_space.{0} (linear_ordered_semiring.{0} to_additive.value_type) h0)  := sorry --non-trivial
lemma new_lemma_28506 (h1 : ring (add_comm_semigroup linarith.ineq)) : strong_rank_condition (add_comm_semigroup linarith.ineq) := sorry --non-trivial
lemma new_lemma_28507 (h0 : monoid (semiring (has_norm linarith.comp))) : monoid.fg (semiring (has_norm linarith.comp)) := sorry --non-trivial
lemma new_lemma_28508 (h0 : function.extfun Type ring) : @is_domain.{0} (has_emptyc.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type ring.{0} h0 (has_emptyc.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_28509 (h0 : functor.add_const (filter (has_to_string Type)) Type) : countable_Inter_filter (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_28510 (h0 : functor.add_const (topological_space (complete_distrib_lattice name)) pos) : @sequential_space.{0} (complete_distrib_lattice.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (complete_distrib_lattice.{0} name)) pos h0)  := sorry --non-trivial
lemma new_lemma_28511 (h0 : functor.add_const (topological_space (semigroup Type)) linarith.comp) : @normal_space.{1} (semigroup.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (semigroup.{1} Type)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_28512 (h0 : topological_space (has_top (has_inv (comm_ring (comm_ring to_additive.value_type))))) : irreducible_space (has_top (has_inv (comm_ring (comm_ring to_additive.value_type)))) := sorry --non-trivial
lemma new_lemma_28513 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @t0_space.{0} (add_group.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (add_group.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_28514 (h0 : topological_space (has_add congr_arg_kind)) : path_connected_space (has_add congr_arg_kind) := sorry --non-trivial
lemma new_lemma_28515 (h0 : functor.add_const (topological_space (ring Type)) (has_neg pos)) : @t0_space.{1} (ring.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (ring.{1} Type)) (has_neg.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_28516 (h0 : fin has_zero.zero) : @rank_condition.{0} (canonically_ordered_monoid.{0} pos) (@function.extfun_app.{2 1} Type ring.{0} (@matrix.vec_empty.{1} (function.extfun.{2 1} Type ring.{0}) (@matrix.vec_empty.{0} (fin (@has_zero.zero.{0} nat nat.has_zero)) (@matrix.vec_empty.{0} (fin (@has_zero.zero.{0} nat nat.has_zero)) (@matrix.vec_empty.{0} (fin (@has_zero.zero.{0} nat nat.has_zero)) (@matrix.vec_empty.{0} (fin (@has_zero.zero.{0} nat nat.has_zero)) (@matrix.vec_empty.{0} (fin (@has_zero.zero.{0} nat nat.has_zero)) (@matrix.vec_empty.{0} (fin (@has_zero.zero.{0} nat nat.has_zero)) (@matrix.vec_empty.{0} (fin (@has_zero.zero.{0} nat nat.has_zero)) (@matrix.vec_empty.{0} (fin (@has_zero.zero.{0} nat nat.has_zero)) (@matrix.vec_empty.{0} (fin (@has_zero.zero.{0} nat nat.has_zero)) h0)))))))))) (canonically_ordered_monoid.{0} pos))  := sorry --non-trivial
lemma new_lemma_28517 (h0 : function.extfun Type semiring) : @is_noetherian_ring.{0} (has_pos_part.{0} name) (@function.extfun_app.{2 1} Type semiring.{0} h0 (has_pos_part.{0} name))  := sorry --non-trivial
lemma new_lemma_28518 (h0 : functor.add_const (ring (complete_distrib_lattice pos)) Type) : @is_principal_ideal_ring.{0} (complete_distrib_lattice.{0} pos) (@functor.add_const.run.{0 1} (ring.{0} (complete_distrib_lattice.{0} pos)) Type h0)  := sorry --non-trivial
lemma new_lemma_28519 (h0 : functor.add_const (topological_space (boolean_algebra.core Type)) pos) : @normal_space.{1} (boolean_algebra.core.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (boolean_algebra.core.{1} Type)) pos h0)  := sorry --non-trivial
lemma new_lemma_28520 (h0 : topological_space reducibility_hints) : path_connected_space reducibility_hints := sorry --non-trivial
lemma new_lemma_28521 (h0 : not (add_group (has_append to_additive.value_type) -> false)) : @is_add_cyclic.{0} (has_append.{0} to_additive.value_type) (@classical.by_contradiction'.{1} (add_group.{0} (has_append.{0} to_additive.value_type)) h0)  := sorry --non-trivial
lemma new_lemma_28522 (h0 : function.extfun Type complete_lattice) : @is_compactly_generated.{0} (complete_distrib_lattice.{0} unsigned) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (complete_distrib_lattice.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_28523 (h0 : ring (with_zero (has_ssubset linarith.comp_source))) : rank_condition (with_zero (has_ssubset linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_28524 (h0 : functor.add_const (group (has_neg name)) (has_neg linarith.comp)) : @normalizer_condition.{0} (has_neg.{0} name) (@functor.add_const.run.{0 0} (group.{0} (has_neg.{0} name)) (has_neg.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_28525 (h0 : functor.add_const (uniform_space (has_to_string name)) name) : @complete_space.{0} (has_to_string.{0} name) (@functor.add_const.run.{0 0} (uniform_space.{0} (has_to_string.{0} name)) name h0)  := sorry --non-trivial
lemma new_lemma_28526 (h0 : function.extfun Type ring) : @strong_rank_condition.{0} (generalized_boolean_algebra.{0} pos) (@function.extfun_app.{2 1} Type ring.{0} h0 (generalized_boolean_algebra.{0} pos))  := sorry --non-trivial
lemma new_lemma_28527 (h0 : function.extfun Type (functor.comp topological_space canonically_linear_ordered_monoid)) : @sequential_space.{0} (canonically_linear_ordered_monoid.{0} pos) (@functor.comp.run.{0 0 0} topological_space.{0} canonically_linear_ordered_monoid.{0} pos (@function.extfun_app.{2 1} Type (functor.comp.{0 0 0} topological_space.{0} canonically_linear_ordered_monoid.{0}) h0 pos))  := sorry --non-trivial
lemma new_lemma_28528 (h0 : add_group (has_neg_part (option (has_add (option (option (option unsigned))))))) : is_add_cyclic (has_neg_part (option (has_add (option (option (option unsigned)))))) := sorry --non-trivial
lemma new_lemma_28529 (h0 : complete_lattice (comm_group Type)) : is_atomistic (comm_group Type) := sorry --non-trivial
lemma new_lemma_28530 (h0 : complete_lattice (measurable_space.dynkin_system unsigned)) : complete_lattice.is_Sup_finite_compact (measurable_space.dynkin_system unsigned) := sorry --non-trivial
lemma new_lemma_28531 (h0 : function.extfun nat fin) : @sequential_space.{1} (has_add.{1} Type) (@matrix.vec_empty.{1} (topological_space.{1} (has_add.{1} Type)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_28532 (h0 : topological_space (normed_group (semiring linarith.comp))) : t0_space (normed_group (semiring linarith.comp)) := sorry --non-trivial
lemma new_lemma_28533 (h0 : list (cancel_monoid (boolean_algebra pos))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_28534 (h0 : topological_space (partial_order (semiring num))) : path_connected_space (partial_order (semiring num)) := sorry --non-trivial
lemma new_lemma_28535 (h0 : not (function.extfun Type add_group -> false)) : @is_add_cyclic.{0} (measurable_space.{0} fun_info) (@function.extfun_app.{2 1} Type add_group.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type add_group.{0}) h0) (measurable_space.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_28536 (h0 : ring (has_add (has_nnnorm fun_info))) : rank_condition (has_add (has_nnnorm fun_info)) := sorry --non-trivial
lemma new_lemma_28537 (h0 : filter (has_add (has_inv (complete_distrib_lattice (random_gen fun_info))))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_28538 (h1 : complete_lattice (has_le string_imp)) : complete_lattice.is_Sup_finite_compact (has_le string_imp) := sorry --non-trivial
lemma new_lemma_28539 (h0 : topological_space (has_ssubset (has_top fun_info))) : locally_compact_space (has_ssubset (has_top fun_info)) := sorry --non-trivial
lemma new_lemma_28540 (h0 : topological_space (has_top (comm_ring (comm_ring fun_info)))) : t0_space (has_top (comm_ring (comm_ring fun_info))) := sorry --non-trivial
lemma new_lemma_28541 (h0 : add_group (with_one (has_norm (semiring congr_arg_kind)))) : is_add_cyclic (with_one (has_norm (semiring congr_arg_kind))) := sorry --non-trivial
lemma new_lemma_28542 (h0 : topological_space (linear_ordered_add_comm_group (has_inv linarith.comp_source))) : t0_space (linear_ordered_add_comm_group (has_inv linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_28543 (h0 : function.extfun Type topological_space) : @irreducible_space.{0} (has_inv.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_inv.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_28544 (h0 : semiring (free_add_monoid ennreal)) : is_noetherian_ring (free_add_monoid ennreal) := sorry --non-trivial
lemma new_lemma_28545 (h0 : topological_space (simple_graph (ring linarith.comp))) : irreducible_space (simple_graph (ring linarith.comp)) := sorry --non-trivial
lemma new_lemma_28546 (h0 : not (function.extfun Type group -> false)) : @normalizer_condition.{0} fun_info (@function.extfun_app.{2 1} Type group.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type group.{0}) h0) fun_info)  := sorry --non-trivial
lemma new_lemma_28547 (h0 : filter (add_monoid (random_gen char))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_28548 (h0 : function.extfun Type group) : @is_simple_group.{0} (has_neg.{0} pos) (@function.extfun_app.{2 1} Type group.{0} h0 (has_neg.{0} pos))  := sorry --non-trivial
lemma new_lemma_28549 (h0 : group (dlist (has_top num))) : normalizer_condition (dlist (has_top num)) := sorry --non-trivial
lemma new_lemma_28550 (h0 : function.extfun Type topological_space) : @normal_space.{0} (generalized_boolean_algebra.{0} real) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (generalized_boolean_algebra.{0} real))  := sorry --non-trivial
lemma new_lemma_28551 (h1 : add_group (add_left_cancel_monoid to_additive.value_type)) : is_add_cyclic (add_left_cancel_monoid to_additive.value_type) := sorry --non-trivial
lemma new_lemma_28552 (h0 : topological_space (distrib enat)) : t0_space (distrib enat) := sorry --non-trivial
lemma new_lemma_28553 (h0 : has_mem.mem topological_space has_emptyc.emptyc) : @discrete_topology.{0} (normed_group.{0} linarith.ineq) (@function.extfun_app.{2 1} Type topological_space.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) topological_space.{0} h0) (normed_group.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_28554 (h0 : ring (linear_ordered_comm_group num)) : strong_rank_condition (linear_ordered_comm_group num) := sorry --non-trivial
lemma new_lemma_28555 (h2 : group (complete_semilattice_Sup string_imp)) : normalizer_condition (complete_semilattice_Sup string_imp) := sorry --non-trivial
lemma new_lemma_28556 (h0 : functor.add_const (ring (has_neg environment.implicit_infer_kind)) pos) : @strong_rank_condition.{0} (has_neg.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (ring.{0} (has_neg.{0} environment.implicit_infer_kind)) pos h0)  := sorry --non-trivial
lemma new_lemma_28557 (h0 : functor.add_const (topological_space (finset Type)) (has_Inf (finset pos))) : @preconnected_space.{1} (finset.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (finset.{1} Type)) (has_Inf.{0} (finset.{0} pos)) h0)  := sorry --non-trivial
lemma new_lemma_28558 (h0 : topological_space (has_to_string (ring linarith.comp))) : irreducible_space (has_to_string (ring linarith.comp)) := sorry --non-trivial
lemma new_lemma_28559 (h0 : function.extfun Type ring) : @is_domain.{0} (has_dist.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type ring.{0} h0 (has_dist.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_28560 (h0 : topological_space (has_pos_part (ordered_comm_monoid Type))) : locally_compact_space (has_pos_part (ordered_comm_monoid Type)) := sorry --non-trivial
lemma new_lemma_28561 (h0 : list (generalized_boolean_algebra (has_add pos))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_28562 (h0 : function.extfun Type uniform_space) : @complete_space.{0} (normed_group.{0} linarith.ineq) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (normed_group.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_28563 (h0 : ring (canonically_ordered_comm_semiring (option ennreal))) : strong_rank_condition (canonically_ordered_comm_semiring (option ennreal)) := sorry --non-trivial
lemma new_lemma_28564 (h0 : functor.add_const (group (boolean_algebra linarith.comp)) Type) : @normalizer_condition.{0} (boolean_algebra.{0} linarith.comp) (@functor.add_const.run.{0 1} (group.{0} (boolean_algebra.{0} linarith.comp)) Type h0)  := sorry --non-trivial
lemma new_lemma_28565 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @rank_condition.{0} (normed_group.{0} (random_gen.{0} fun_info)) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (normed_group.{0} (random_gen.{0} fun_info)))  := sorry --non-trivial
lemma new_lemma_28566 (h0 : add_monoid (id (id linarith.comp))) : add_monoid.fg (id (id linarith.comp)) := sorry --non-trivial
lemma new_lemma_28567 (h0 : topological_space (has_add (finset (finset environment.implicit_infer_kind)))) : path_connected_space (has_add (finset (finset environment.implicit_infer_kind))) := sorry --non-trivial
lemma new_lemma_28568 (h0 : function.extfun Type topological_space) : @totally_separated_space.{0} (lex.{0} ennreal) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (lex.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_28569 (h0 : add_group (plift (has_top empty))) : is_add_cyclic (plift (has_top empty)) := sorry --non-trivial
lemma new_lemma_28570 (h0 : functor.add_const (ordered_add_comm_monoid (linear_ordered_comm_monoid_with_zero empty)) num) : @archimedean.{0} (linear_ordered_comm_monoid_with_zero.{0} empty) (@functor.add_const.run.{0 0} (ordered_add_comm_monoid.{0} (linear_ordered_comm_monoid_with_zero.{0} empty)) num h0)  := sorry --non-trivial
lemma new_lemma_28571 (h0 : group (ring (option pos))) : normalizer_condition (ring (option pos)) := sorry --non-trivial
lemma new_lemma_28572 (h0 : uniform_space (random_gen char)) : complete_space (random_gen char) := sorry --non-trivial
lemma new_lemma_28573 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @complete_space.{0} (random_gen.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type uniform_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 uniform_space.{0}) (random_gen.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_28574 (h1 : function.extfun Type add_group) : @is_add_cyclic.{0} linarith.comp_source (@function.extfun_app.{2 1} Type add_group.{0} h1 linarith.comp_source)  := sorry --non-trivial
lemma new_lemma_28575 (h0 : not (function.extfun Type uniform_space -> false)) : @separated_space.{0} (left_cancel_semigroup.{0} unsigned) (@function.extfun_app.{2 1} Type uniform_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type uniform_space.{0}) h0) (left_cancel_semigroup.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_28576 (h0 : topological_space (add_cancel_monoid (finset (finset pos)))) : totally_separated_space (add_cancel_monoid (finset (finset pos))) := sorry --non-trivial
lemma new_lemma_28577 (h0 : function.extfun Type group) : @group.fg.{0} (canonically_ordered_comm_semiring.{0} empty) (@function.extfun_app.{2 1} Type group.{0} h0 (canonically_ordered_comm_semiring.{0} empty))  := sorry --non-trivial
lemma new_lemma_28578 (h0 : ring (canonically_ordered_comm_semiring (option (option (option (option empty)))))) : strong_rank_condition (canonically_ordered_comm_semiring (option (option (option (option empty))))) := sorry --non-trivial
lemma new_lemma_28579 (h0 : topological_space (add_group empty)) : t0_space (add_group empty) := sorry --non-trivial
lemma new_lemma_28580 (h0 : not (function.extfun Type topological_space -> false)) : @path_connected_space.{0} real.angle (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) real.angle)  := sorry --non-trivial
lemma new_lemma_28581 (h0 : finset (boolean_algebra (finset Type))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_28582 (h0 : monoid (finset (option empty))) : monoid.fg (finset (option empty)) := sorry --non-trivial
lemma new_lemma_28583 (h0 : functor.add_const (ring (has_Inf name)) Type) : @strong_rank_condition.{0} (has_Inf.{0} name) (@functor.add_const.run.{0 1} (ring.{0} (has_Inf.{0} name)) Type h0)  := sorry --non-trivial
lemma new_lemma_28584 (h0 : list (has_Inf (has_nndist (has_Inf linarith.comp)))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_28585 (h0 : functor.add_const (function.extfun Type cancel_comm_monoid_with_zero) (finset (finset ennreal))) : @unique_factorization_monoid.{0} (comm_group.{0} ennreal) (@function.extfun_app.{2 1} Type cancel_comm_monoid_with_zero.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type cancel_comm_monoid_with_zero.{0}) (finset.{0} (finset.{0} ennreal)) h0) (comm_group.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_28586 (h0 : functor.comp ring has_to_string unsigned) : @rank_condition.{0} (has_to_string.{0} unsigned) (@functor.comp.run.{0 0 0} ring.{0} has_to_string.{0} unsigned h0)  := sorry --non-trivial
lemma new_lemma_28587 (h0 : monoid (linear_ordered_add_comm_group num)) : monoid.fg (linear_ordered_add_comm_group num) := sorry --non-trivial
lemma new_lemma_28588 (h0 : functor.comp uniform_space add_comm_monoid name) : @complete_space.{0} (add_comm_monoid.{0} name) (@functor.comp.run.{0 0 0} uniform_space.{0} add_comm_monoid.{0} name h0)  := sorry --non-trivial
lemma new_lemma_28589 (h0 : function.extfun Type topological_space) : @discrete_topology.{0} (has_top.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_top.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_28590 (h0 : functor.add_const (topological_space (ordered_cancel_add_comm_monoid empty)) unsigned) : @irreducible_space.{0} (ordered_cancel_add_comm_monoid.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (ordered_cancel_add_comm_monoid.{0} empty)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_28591 (h0 : ring (has_nndist (complete_distrib_lattice Type))) : is_domain (has_nndist (complete_distrib_lattice Type)) := sorry --non-trivial
lemma new_lemma_28592 (h0 : has_mem.mem uniform_space has_emptyc.emptyc) : @complete_space.{0} (semiring.{0} linarith.comp) (@function.extfun_app.{2 1} Type uniform_space.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) uniform_space.{0} h0) (semiring.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_28593 (h0 : filter (fintype (random_gen (random_gen char)))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_28594 (h0 : filter (measurable_space (has_norm (has_top congr_arg_kind)))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_28595 (h0 : topological_space (measurable_space linarith.ineq)) : irreducible_space (measurable_space linarith.ineq) := sorry --non-trivial
lemma new_lemma_28596 (h2 : topological_space (has_top linarith.comp_source)) : t0_space (has_top linarith.comp_source) := sorry --non-trivial
lemma new_lemma_28597 (h1 : topological_space (has_lt linarith.comp_source)) : t0_space (has_lt linarith.comp_source) := sorry --non-trivial
lemma new_lemma_28598 (h0 : topological_space (has_nndist (has_to_string (finset ennreal)))) : t0_space (has_nndist (has_to_string (finset ennreal))) := sorry --non-trivial
lemma new_lemma_28599 (h0 : fin has_zero.zero) : @is_domain.{0} (has_bot.{0} real) (@function.extfun_app.{2 1} Type ring.{0} (@matrix.vec_empty.{1} (function.extfun.{2 1} Type ring.{0}) h0) (has_bot.{0} real))  := sorry --non-trivial
lemma new_lemma_28600 (h0 : topological_space (has_Inf (finset Type))) : topological_space.separable_space (has_Inf (finset Type)) := sorry --non-trivial
lemma new_lemma_28601 (h0 : topological_space (has_dist ennreal)) : topological_space.separable_space (has_dist ennreal) := sorry --non-trivial
lemma new_lemma_28602 (h0 : function.extfun Type topological_space) : @path_connected_space.{0} (is_R_or_C.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (is_R_or_C.{0} num))  := sorry --non-trivial
lemma new_lemma_28603 (h0 : functor.add_const (ring (has_add Type)) Type) : @strong_rank_condition.{1} (has_add.{1} Type) (@functor.add_const.run.{1 1} (ring.{1} (has_add.{1} Type)) Type h0)  := sorry --non-trivial
lemma new_lemma_28604 (h0 : semiring (ordered_comm_monoid (finset Type))) : is_noetherian_ring (ordered_comm_monoid (finset Type)) := sorry --non-trivial
lemma new_lemma_28605 (h1 : function.extfun (finset (Type -> Type)) (has_mem.mem topological_space)) : @irreducible_space.{0} string_imp (@function.extfun_app.{2 1} Type topological_space.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) topological_space.{0} (@function.extfun_app.{2 0} (finset.{1} (Type → Type)) (@has_mem.mem.{1 1} (Type → Type) (finset.{1} (Type → Type)) (@finset.has_mem.{1} (Type → Type)) topological_space.{0}) h1 (@has_emptyc.emptyc.{1} (finset.{1} (Type → Type)) (@finset.has_emptyc.{1} (Type → Type))))) string_imp)  := sorry --non-trivial
lemma new_lemma_28606 (h0 : function.extfun (prod name name) (fun (x : prod name name), Prop)) (h1 : prod name name) : symmetrize_rel (function.extfun_app h0) h1 := sorry --non-trivial
lemma new_lemma_28607 (h0 : functor.add_const (function.extfun (Type 1) uniform_space) linarith.comp) : @complete_space.{1} (ring.{1} Type) (@function.extfun_app.{3 2} (Type 1) uniform_space.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) uniform_space.{1}) linarith.comp h0) (ring.{1} Type))  := sorry --non-trivial
lemma new_lemma_28608 (h0 : topological_space (has_Inf (ring (ring name)))) : regular_space (has_Inf (ring (ring name))) := sorry --non-trivial
lemma new_lemma_28609 (h0 : topological_space (canonically_ordered_comm_semiring (has_nndist (ring linarith.comp)))) : sequential_space (canonically_ordered_comm_semiring (has_nndist (ring linarith.comp))) := sorry --non-trivial
lemma new_lemma_28610 (h2 : group (with_one (random_gen string_imp))) : normalizer_condition (with_one (random_gen string_imp)) := sorry --non-trivial
lemma new_lemma_28611 (h0 : functor.add_const (topological_space (has_to_string unsigned)) pos) : @topological_space.separable_space.{0} (has_to_string.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (has_to_string.{0} unsigned)) pos h0)  := sorry --non-trivial
lemma new_lemma_28612 (h0 : topological_space unsigned -> Prop) : @topological_space.separable_space.{0} unsigned (@classical.epsilon.{1} (topological_space.{0} unsigned) (@nonempty_of_inhabited.{1} (topological_space.{0} unsigned) (@inhabited_topological_space.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_28613 (h0 : topological_space (add_cancel_monoid (normed_comm_ring Type))) : preirreducible_space (add_cancel_monoid (normed_comm_ring Type)) := sorry --non-trivial
lemma new_lemma_28614 (h1 : add_group (fintype char)) : is_add_cyclic (fintype char) := sorry --non-trivial
lemma new_lemma_28615 (h0 : functor.add_const (ordered_comm_monoid (has_repr linarith.comp)) (has_add pos)) : @has_exists_mul_of_le.{0} (has_repr.{0} linarith.comp) (@functor.add_const.run.{0 0} (ordered_comm_monoid.{0} (has_repr.{0} linarith.comp)) (has_add.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_28616 (h0 : topological_space (measure_theory.measure_space (semiring unsigned))) : irreducible_space (measure_theory.measure_space (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_28617 (h0 : group (group_with_zero ennreal)) : normalizer_condition (group_with_zero ennreal) := sorry --non-trivial
lemma new_lemma_28618 (h2 : complete_lattice (has_inv (random_gen (random_gen string_imp)))) : complete_lattice.is_Sup_finite_compact (has_inv (random_gen (random_gen string_imp))) := sorry --non-trivial
lemma new_lemma_28619 (h0 : topological_space (nondiscrete_normed_field environment.projection_info)) (h1 : set (nondiscrete_normed_field environment.projection_info)) : is_path_connected h1 := sorry --non-trivial
lemma new_lemma_28620 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @totally_separated_space.{0} (add_cancel_monoid.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (add_cancel_monoid.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_28621 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @separated_space.{0} (ordered_comm_ring.{0} pos) (@function.extfun_app.{2 1} Type uniform_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 uniform_space.{0}) (ordered_comm_ring.{0} pos))  := sorry --non-trivial
lemma new_lemma_28622 (h0 : filter (group_with_zero (option (option (option ennreal))))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_28623 (h0 : function.extfun Type topological_space) : @totally_disconnected_space.{0} (add_comm_monoid.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (add_comm_monoid.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_28624 (h0 : function.extfun Type topological_space) : @preirreducible_space.{0} (@id.{2} Type empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (@id.{2} Type empty))  := sorry --non-trivial
lemma new_lemma_28625 (h0 : cancel_comm_monoid_with_zero (add_cancel_monoid (option (option (option unsigned))))) : unique_factorization_monoid (add_cancel_monoid (option (option (option unsigned)))) := sorry --non-trivial
lemma new_lemma_28626 (h0 : functor.add_const (topological_space (add_cancel_monoid linarith.comp)) Type) : @totally_disconnected_space.{0} (add_cancel_monoid.{0} linarith.comp) (@functor.add_const.run.{0 1} (topological_space.{0} (add_cancel_monoid.{0} linarith.comp)) Type h0)  := sorry --non-trivial
lemma new_lemma_28627 (h0 : ring (finset (has_add Type))) : is_domain (finset (has_add Type)) := sorry --non-trivial
lemma new_lemma_28628 (h0 : topological_space (linear_ordered_comm_ring (semiring congr_arg_kind))) : t1_space (linear_ordered_comm_ring (semiring congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_28629 (h0 : topological_space (has_neg (has_neg_part environment.implicit_infer_kind))) : totally_separated_space (has_neg (has_neg_part environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_28630 (h0 : functor.comp topological_space has_nndist name) : @discrete_topology.{0} (has_nndist.{0} name) (@functor.comp.run.{0 0 0} topological_space.{0} has_nndist.{0} name h0)  := sorry --non-trivial
lemma new_lemma_28631 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_add_cyclic.{0} (bin_tree.{0} num) (@function.extfun_app.{2 1} Type add_group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 add_group.{0}) (bin_tree.{0} num))  := sorry --non-trivial
lemma new_lemma_28632 (h0 : add_group (normed_lattice_add_comm_group (sub_neg_monoid real))) : is_add_cyclic (normed_lattice_add_comm_group (sub_neg_monoid real)) := sorry --non-trivial
lemma new_lemma_28633 (h0 : ordered_add_comm_monoid (add_cancel_monoid (add_comm_monoid Type))) : archimedean (add_cancel_monoid (add_comm_monoid Type)) := sorry --non-trivial
lemma new_lemma_28634 (h0 : semiring (non_assoc_semiring (has_top unsigned))) : is_noetherian_ring (non_assoc_semiring (has_top unsigned)) := sorry --non-trivial
lemma new_lemma_28635 (h0 : functor.add_const (semiring (ring linarith.comp)) (mul_one_class (mul_one_class linarith.comp))) : @is_noetherian_ring.{0} (ring.{0} linarith.comp) (@functor.add_const.run.{0 0} (semiring.{0} (ring.{0} linarith.comp)) (mul_one_class.{0} (mul_one_class.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_28636 (h0 : topological_space (has_neg_part (normed_comm_ring Type))) : locally_compact_space (has_neg_part (normed_comm_ring Type)) := sorry --non-trivial
lemma new_lemma_28637 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @t1_space.{0} (simple_graph.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (simple_graph.{0} pos))  := sorry --non-trivial
lemma new_lemma_28638 (h1 : ring (with_zero (div_inv_monoid (fintype char)))) : rank_condition (with_zero (div_inv_monoid (fintype char))) := sorry --non-trivial
lemma new_lemma_28639 (h0 : functor.add_const (ordered_add_comm_monoid (has_zero environment.implicit_infer_kind)) name) : @archimedean.{0} (has_zero.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (ordered_add_comm_monoid.{0} (has_zero.{0} environment.implicit_infer_kind)) name h0)  := sorry --non-trivial
lemma new_lemma_28640 (h0 : functor.add_const (prod (boolean_algebra.core name) (boolean_algebra.core name)) (has_add pos)) : id_rel (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_28641 (h0 : topological_space (normed_comm_ring (has_neg linarith.comp))) : totally_separated_space (normed_comm_ring (has_neg linarith.comp)) := sorry --non-trivial
lemma new_lemma_28642 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_domain.{0} (has_top.{0} linarith.comp) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (has_top.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_28643 (h0 : ring (with_bot (has_norm fun_info))) : strong_rank_condition (with_bot (has_norm fun_info)) := sorry --non-trivial
lemma new_lemma_28644 (h0 : ordered_comm_monoid (has_Inf name)) : has_exists_mul_of_le (has_Inf name) := sorry --non-trivial
lemma new_lemma_28645 (h0 : uniform_space (has_to_string (option unsigned))) : separated_space (has_to_string (option unsigned)) := sorry --non-trivial
lemma new_lemma_28646 (h0 : function.extfun Type topological_space) : @regular_space.{0} (normed_lattice_add_comm_group.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (normed_lattice_add_comm_group.{0} pos))  := sorry --non-trivial
lemma new_lemma_28647 (h0 : topological_space (has_neg_part (has_add name))) : preconnected_space (has_neg_part (has_add name)) := sorry --non-trivial
lemma new_lemma_28648 (h1 : group string_imp) : is_cyclic string_imp := sorry --non-trivial
lemma new_lemma_28649 (h0 : topological_space (add_comm_monoid (has_Inf (comm_semigroup pos)))) : path_connected_space (add_comm_monoid (has_Inf (comm_semigroup pos))) := sorry --non-trivial
lemma new_lemma_28650 (h0 : topological_space (has_one empty)) : preirreducible_space (has_one empty) := sorry --non-trivial
lemma new_lemma_28651 (h1 : ring (has_emptyc (has_top to_additive.value_type))) : strong_rank_condition (has_emptyc (has_top to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_28652 (h0 : function.extfun Type group) : @normalizer_condition.{0} (random_gen.{0} linarith.ineq) (@function.extfun_app.{2 1} Type group.{0} h0 (random_gen.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_28653 (h1 : set (add_comm_semigroup enat -> mul_one_class char)) : set.separates_points h1 := sorry --non-trivial
lemma new_lemma_28654 (h0 : functor.add_const (function.extfun Type ordered_comm_monoid) Type) : @has_exists_mul_of_le.{0} (normed_comm_ring.{0} name) (@function.extfun_app.{2 1} Type ordered_comm_monoid.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type ordered_comm_monoid.{0}) Type h0) (normed_comm_ring.{0} name))  := sorry --non-trivial
lemma new_lemma_28655 (h3 : filter (add_monoid (random_gen to_additive.value_type))) : filter.ne_bot h3 := sorry --non-trivial
lemma new_lemma_28656 (h1 : topological_space (linear_ordered_add_comm_group linarith.ineq)) : t0_space (linear_ordered_add_comm_group linarith.ineq) := sorry --non-trivial
lemma new_lemma_28657 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @discrete_topology.{0} (random_gen.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (random_gen.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_28658 (h0 : functor.add_const (function.extfun Type ring) (has_Inf pos)) : @is_domain.{0} (has_pos_part.{0} name) (@function.extfun_app.{2 1} Type ring.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type ring.{0}) (has_Inf.{0} pos) h0) (has_pos_part.{0} name))  := sorry --non-trivial
lemma new_lemma_28659 (h1 : topological_space (normed_field (has_nnnorm linarith.ineq))) : t0_space (normed_field (has_nnnorm linarith.ineq)) := sorry --non-trivial
lemma new_lemma_28660 (h0 : topological_space (boolean_algebra.core (option unsigned))) : irreducible_space (boolean_algebra.core (option unsigned)) := sorry --non-trivial
lemma new_lemma_28661 (h0 : functor.comp topological_space canonically_ordered_comm_semiring ennreal) : @regular_space.{0} (canonically_ordered_comm_semiring.{0} ennreal) (@functor.comp.run.{0 0 0} topological_space.{0} canonically_ordered_comm_semiring.{0} ennreal h0)  := sorry --non-trivial
lemma new_lemma_28662 (h0 : function.extfun Type complete_lattice) : @is_compactly_generated.{0} (measure_theory.measure_space.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (measure_theory.measure_space.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_28663 (h0 : semiring (add_comm_monoid unsigned)) : is_noetherian_ring (add_comm_monoid unsigned) := sorry --non-trivial
lemma new_lemma_28664 (h0 : group (has_zero (finset name))) : group.fg (has_zero (finset name)) := sorry --non-trivial
lemma new_lemma_28665 (h0 : functor.add_const (group (has_neg linarith.comp)) Type) : @is_cyclic.{0} (has_neg.{0} linarith.comp) (@functor.add_const.run.{0 1} (group.{0} (has_neg.{0} linarith.comp)) Type h0)  := sorry --non-trivial
lemma new_lemma_28666 (h0 : has_mem.mem ring has_emptyc.emptyc) : @strong_rank_condition.{0} (random_gen.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type ring.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) ring.{0} h0) (random_gen.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_28667 (h0 : topological_space (has_compl (comm_semigroup to_additive.value_type))) : totally_disconnected_space (has_compl (comm_semigroup to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_28668 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @loc_path_connected_space.{0} (ordered_ring.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (ordered_ring.{0} unsigned)) empty (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (topological_space.{0} (ordered_ring.{0} unsigned))) (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 (functor.add_const.{0 0} (topological_space.{0} (ordered_ring.{0} unsigned)))) empty))  := sorry --non-trivial
lemma new_lemma_28669 (h0 : not (ring (uniform_space fun_info) -> false)) : @rank_condition.{0} (uniform_space.{0} fun_info) (@classical.by_contradiction'.{1} (ring.{0} (uniform_space.{0} fun_info)) h0)  := sorry --non-trivial
lemma new_lemma_28670 (h0 : functor.add_const (group (finset Type)) (has_neg Type)) : @normalizer_condition.{1} (finset.{1} Type) (@functor.add_const.run.{1 1} (group.{1} (finset.{1} Type)) (has_neg.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_28671 (h0 : function.extfun Type complete_lattice) : @complete_lattice.is_Sup_finite_compact.{0} (preorder.{0} empty) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (preorder.{0} empty))  := sorry --non-trivial
lemma new_lemma_28672 (h0 : functor.add_const (topological_space (has_pos_part pos)) linarith.comp) : @preconnected_space.{0} (has_pos_part.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (has_pos_part.{0} pos)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_28673 (h0 : topological_space (has_union (semiring unsigned))) : discrete_topology (has_union (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_28674 (h0 : group (finset (finset (has_Inf Type)))) : normalizer_condition (finset (finset (has_Inf Type))) := sorry --non-trivial
lemma new_lemma_28675 (h0 : functor.add_const (filter (has_zero Type)) Type) : countable_Inter_filter (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_28676 (h1 : not (topological_space (has_ssubset string_imp) -> false)) : @totally_disconnected_space.{0} (has_ssubset.{0} string_imp) (@classical.by_contradiction'.{1} (topological_space.{0} (has_ssubset.{0} string_imp)) h1)  := sorry --non-trivial
lemma new_lemma_28677 (h0 : topological_space (has_star (semiring (semiring (semiring unsigned))))) : irreducible_space (has_star (semiring (semiring (semiring unsigned)))) := sorry --non-trivial
lemma new_lemma_28678 (h0 : functor.add_const (ordered_comm_monoid (has_nndist Type)) linarith.comp) : @has_exists_mul_of_le.{1} (has_nndist.{1} Type) (@functor.add_const.run.{1 0} (ordered_comm_monoid.{1} (has_nndist.{1} Type)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_28679 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @normalizer_condition.{0} (has_neg.{0} linarith.comp) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (has_neg.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_28680 (h0 : functor.add_const (ordered_comm_monoid pos) pos) : @has_exists_mul_of_le.{0} pos (@functor.add_const.run.{0 0} (ordered_comm_monoid.{0} pos) pos h0)  := sorry --non-trivial
lemma new_lemma_28681 (h0 : fin has_zero.zero) : @path_connected_space.{0} (normed_lattice_add_comm_group.{0} real) (@function.extfun_app.{2 1} Type topological_space.{0} (@matrix.vec_empty.{1} (function.extfun.{2 1} Type topological_space.{0}) h0) (normed_lattice_add_comm_group.{0} real))  := sorry --non-trivial
lemma new_lemma_28682 (h1 : add_group (nondiscrete_normed_field string.iterator_imp)) : is_add_cyclic (nondiscrete_normed_field string.iterator_imp) := sorry --non-trivial
lemma new_lemma_28683 (h0 : group (has_neg (ring environment.implicit_infer_kind))) : normalizer_condition (has_neg (ring environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_28684 (h0 : topological_space (has_nndist Type)) : t0_space (has_nndist Type) := sorry --non-trivial
lemma new_lemma_28685 (h0 : functor.add_const (functor.add_const (ring linarith.comp) pos) (normed_comm_ring linarith.comp)) : @rank_condition.{0} linarith.comp (@functor.add_const.run.{0 0} (ring.{0} linarith.comp) pos (@functor.add_const.run.{0 0} (functor.add_const.{0 0} (ring.{0} linarith.comp) pos) (normed_comm_ring.{0} linarith.comp) h0))  := sorry --non-trivial
lemma new_lemma_28686 (h0 : topological_space (non_unital_non_assoc_semiring fun_info)) : path_connected_space (non_unital_non_assoc_semiring fun_info) := sorry --non-trivial
lemma new_lemma_28687 (h0 : has_mem.mem (semiring congr_arg_kind) has_emptyc.emptyc) : @is_compactly_generated.{0} (semiring.{0} congr_arg_kind) (@finset.pi.empty.{1 0} Type complete_lattice.{0} (semiring.{0} congr_arg_kind) h0)  := sorry --non-trivial
lemma new_lemma_28688 (h0 : uniform_space (add_comm_monoid (sub_neg_monoid (ordered_comm_monoid real)))) : separated_space (add_comm_monoid (sub_neg_monoid (ordered_comm_monoid real))) := sorry --non-trivial
lemma new_lemma_28689 (h0 : function.extfun Type topological_space) : @irreducible_space.{0} (free_add_monoid.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (free_add_monoid.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_28690 (h2 : topological_space (semi_normed_ring reducibility_hints)) : t0_space (semi_normed_ring reducibility_hints) := sorry --non-trivial
lemma new_lemma_28691 (h0 : functor.add_const (topological_space (semigroup linarith.comp)) pos) : @t0_space.{0} (semigroup.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (semigroup.{0} linarith.comp)) pos h0)  := sorry --non-trivial
lemma new_lemma_28692 (h0 : ring (has_Inf (has_Inf real))) : is_principal_ideal_ring (has_Inf (has_Inf real)) := sorry --non-trivial
lemma new_lemma_28693 (h0 : functor.add_const (topological_space (has_nndist (comm_group unsigned))) linarith.comp) : @path_connected_space.{0} (has_nndist.{0} (comm_group.{0} unsigned)) (@functor.add_const.run.{0 0} (topological_space.{0} (has_nndist.{0} (comm_group.{0} unsigned))) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_28694 (h0 : topological_space (semi_normed_comm_ring (random_gen linarith.comp_source))) : path_connected_space (semi_normed_comm_ring (random_gen linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_28695 (h0 : not (semiring (non_assoc_semiring congr_arg_kind) -> false)) : @is_noetherian_ring.{0} (non_assoc_semiring.{0} congr_arg_kind) (@classical.by_contradiction'.{1} (semiring.{0} (non_assoc_semiring.{0} congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_28696 (h0 : filter (linear_ordered_add_comm_group linarith.comp_source)) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_28697 (h0 : group (semi_normed_ring unsigned)) : is_cyclic (semi_normed_ring unsigned) := sorry --non-trivial
lemma new_lemma_28698 (h0 : option (functor.add_const (topological_space (has_neg_part pos)) pos)) (h1 : functor.add_const (topological_space (has_neg_part pos)) pos) : @topological_space.separable_space.{0} (has_neg_part.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (has_neg_part.{0} pos)) pos (@option.get_or_else.{0} (functor.add_const.{0 0} (topological_space.{0} (has_neg_part.{0} pos)) pos) h0 h1))  := sorry --non-trivial
lemma new_lemma_28699 (h0 : topological_space (has_bot (has_pos_part (ordered_comm_monoid pos)))) : preconnected_space (has_bot (has_pos_part (ordered_comm_monoid pos))) := sorry --non-trivial
lemma new_lemma_28700 (h0 : functor.add_const (topological_space (has_nndist Type)) linarith.comp) : @path_connected_space.{1} (has_nndist.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (has_nndist.{1} Type)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_28701 (h0 : complete_lattice (has_nndist ennreal)) : complete_lattice.is_Sup_finite_compact (has_nndist ennreal) := sorry --non-trivial
lemma new_lemma_28702 (h1 : ring (linear_ordered_add_comm_group linarith.ineq)) : is_domain (linear_ordered_add_comm_group linarith.ineq) := sorry --non-trivial
lemma new_lemma_28703 (h0 : function.extfun Type topological_space) : @preconnected_space.{0} (ordered_comm_ring.{0} (has_nndist.{0} linarith.comp)) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (ordered_comm_ring.{0} (has_nndist.{0} linarith.comp)))  := sorry --non-trivial
lemma new_lemma_28704 (h0 : prod (has_bot (option (option (option (option unsigned))))) (has_bot (option (option (option (option unsigned)))))) : id_rel h0 := sorry --non-trivial
lemma new_lemma_28705 (h0 : finset (has_Inf (ring (has_Inf (ring Type))))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_28706 (h0 : topological_space (has_nndist linarith.comp)) : preconnected_space (has_nndist linarith.comp) := sorry --non-trivial
lemma new_lemma_28707 (h0 : topological_space (monoid (option unsigned))) : preirreducible_space (monoid (option unsigned)) := sorry --non-trivial
lemma new_lemma_28708 (h0 : function.extfun Type topological_space) : @preirreducible_space.{0} (canonically_ordered_monoid.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (canonically_ordered_monoid.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_28709 (h0 : ring (with_one (has_norm linarith.comp))) : is_domain (with_one (has_norm linarith.comp)) := sorry --non-trivial
lemma new_lemma_28710 (h0 : topological_space (add_comm_semigroup (add_comm_semigroup (add_comm_semigroup std_gen)))) (h1 : preorder (add_comm_semigroup (add_comm_semigroup (add_comm_semigroup std_gen)))) : order_topology (add_comm_semigroup (add_comm_semigroup (add_comm_semigroup std_gen))) := sorry --non-trivial
lemma new_lemma_28711 (h0 : function.extfun (Type 1) topological_space) : @totally_separated_space.{1} (plift.{1} congr_arg_kind) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} h0 (plift.{1} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_28712 (h0 : ring (has_zero (has_add (has_add name)))) : is_domain (has_zero (has_add (has_add name))) := sorry --non-trivial
lemma new_lemma_28713 (h0 : functor.add_const (function.extfun Type cancel_comm_monoid_with_zero) environment.implicit_infer_kind) : @unique_factorization_monoid.{0} (finset.{0} linarith.comp) (@function.extfun_app.{2 1} Type cancel_comm_monoid_with_zero.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type cancel_comm_monoid_with_zero.{0}) environment.implicit_infer_kind h0) (finset.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_28714 (h0 : add_monoid (semigroup (has_neg (normed_comm_ring linarith.comp)))) : add_monoid.fg (semigroup (has_neg (normed_comm_ring linarith.comp))) := sorry --non-trivial
lemma new_lemma_28715 (h0 : ordered_comm_monoid (has_Inf (ring linarith.comp))) : has_exists_mul_of_le (has_Inf (ring linarith.comp)) := sorry --non-trivial
lemma new_lemma_28716 (h0 : add_group (semi_normed_comm_ring environment.projection_info)) : is_add_cyclic (semi_normed_comm_ring environment.projection_info) := sorry --non-trivial
lemma new_lemma_28717 (h0 : add_monoid (has_one (semiring (semiring empty)))) : add_monoid.fg (has_one (semiring (semiring empty))) := sorry --non-trivial
lemma new_lemma_28718 (h0 : topological_space (comm_group (has_to_string environment.implicit_infer_kind))) : regular_space (comm_group (has_to_string environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_28719 (h0 : topological_space (add_cancel_comm_monoid (random_gen char))) : t0_space (add_cancel_comm_monoid (random_gen char)) := sorry --non-trivial
lemma new_lemma_28720 (h0 : semiring (is_R_or_C (with_zero empty))) : is_noetherian_ring (is_R_or_C (with_zero empty)) := sorry --non-trivial
lemma new_lemma_28721 (h0 : ring (add_cancel_monoid (finset linarith.comp))) : is_principal_ideal_ring (add_cancel_monoid (finset linarith.comp)) := sorry --non-trivial
lemma new_lemma_28722 (h0 : topological_space (has_Sup (option empty))) : normal_space (has_Sup (option empty)) := sorry --non-trivial
lemma new_lemma_28723 (h0 : complete_lattice (has_compl environment.projection_info)) : complete_lattice.is_Sup_finite_compact (has_compl environment.projection_info) := sorry --non-trivial
lemma new_lemma_28724 (h0 : topological_space (add_comm_monoid linarith.comp)) : preirreducible_space (add_comm_monoid linarith.comp) := sorry --non-trivial
lemma new_lemma_28725 (h0 : prod (has_to_string environment.implicit_infer_kind) (has_to_string environment.implicit_infer_kind)) : id_rel h0 := sorry --non-trivial
lemma new_lemma_28726 (h0 : topological_space (with_one (has_inv fun_info))) : totally_disconnected_space (with_one (has_inv fun_info)) := sorry --non-trivial
lemma new_lemma_28727 (h0 : topological_space (comm_group (has_add pos))) : regular_space (comm_group (has_add pos)) := sorry --non-trivial
lemma new_lemma_28728 (h0 : group (has_pos_part (ring (ring pos)))) : is_cyclic (has_pos_part (ring (ring pos))) := sorry --non-trivial
lemma new_lemma_28729 (h0 : ring (sub_neg_monoid (has_pos_part pos))) : rank_condition (sub_neg_monoid (has_pos_part pos)) := sorry --non-trivial
lemma new_lemma_28730 (h0 : not (function.extfun Type topological_space -> false)) : @irreducible_space.{0} (has_norm.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (has_norm.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_28731 (h0 : function.extfun Type topological_space) : @totally_disconnected_space.{0} (ordered_comm_ring.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (ordered_comm_ring.{0} pos))  := sorry --non-trivial
lemma new_lemma_28732 (h0 : ring (has_Inf (has_add (finset (has_add pos))))) : strong_rank_condition (has_Inf (has_add (finset (has_add pos)))) := sorry --non-trivial
lemma new_lemma_28733 (h0 : filter (has_bot (option (option (option unsigned))))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_28734 (h1 : ring to_additive.value_type) : is_domain to_additive.value_type := sorry --non-trivial
lemma new_lemma_28735 (h0 : function.extfun Type topological_space) : @path_connected_space.{0} (has_ssubset.{0} string_imp) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_ssubset.{0} string_imp))  := sorry --non-trivial
lemma new_lemma_28736 (h0 : topological_space (has_to_string (option (option (option ennreal))))) : preirreducible_space (has_to_string (option (option (option ennreal)))) := sorry --non-trivial
lemma new_lemma_28737 (h0 : topological_space (ordered_comm_monoid (has_Inf (has_add linarith.comp)))) : preirreducible_space (ordered_comm_monoid (has_Inf (has_add linarith.comp))) := sorry --non-trivial
lemma new_lemma_28738 (h0 : functor.add_const (function.extfun Type group) Type) : @group.fg.{0} (mul_zero_class.{0} pos) (@function.extfun_app.{2 1} Type group.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type group.{0}) Type h0) (mul_zero_class.{0} pos))  := sorry --non-trivial
lemma new_lemma_28739 (h1 : not (add_group (has_ssubset linarith.ineq) -> false)) : @is_add_cyclic.{0} (has_ssubset.{0} linarith.ineq) (@classical.by_contradiction'.{1} (add_group.{0} (has_ssubset.{0} linarith.ineq)) h1)  := sorry --non-trivial
lemma new_lemma_28740 (h0 : function.extfun Type list) : list.nodup (function.extfun_app h0 (linear_order empty)) := sorry --non-trivial
lemma new_lemma_28741 (h0 : functor.add_const (uniform_space (semigroup empty)) (semiring (semiring empty))) : @complete_space.{0} (semigroup.{0} empty) (@functor.add_const.run.{0 0} (uniform_space.{0} (semigroup.{0} empty)) (semiring.{0} (semiring.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_28742 (h0 : functor.add_const (finset (boolean_algebra linarith.comp)) (finset linarith.comp)) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_28743 (h0 : topological_space (normed_comm_ring (has_to_string unsigned))) : t0_space (normed_comm_ring (has_to_string unsigned)) := sorry --non-trivial
lemma new_lemma_28744 (h0 : list (semigroup (mul_one_class Type))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_28745 (h0 : group (distrib_lattice num)) : is_cyclic (distrib_lattice num) := sorry --non-trivial
lemma new_lemma_28746 (h0 : fin has_zero.zero) : @totally_separated_space.{0} (ordered_comm_monoid.{0} real) (@matrix.vec_empty.{0} (topological_space.{0} (ordered_comm_monoid.{0} real)) h0)  := sorry --non-trivial
lemma new_lemma_28747 (h0 : functor.add_const (topological_space (has_add environment.implicit_infer_kind)) name) : @preconnected_space.{0} (has_add.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (has_add.{0} environment.implicit_infer_kind)) name h0)  := sorry --non-trivial
lemma new_lemma_28748 (h1 : function.extfun Type complete_lattice) : @is_atomistic.{0} (with_one.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type complete_lattice.{0} h1 (with_one.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_28749 (h0 : complete_lattice (finset (finset (boolean_algebra (has_neg name))))) : complete_lattice.is_Sup_finite_compact (finset (finset (boolean_algebra (has_neg name)))) := sorry --non-trivial
lemma new_lemma_28750 (h0 : has_mem.mem ring has_emptyc.emptyc) : @is_domain.{0} unsigned (@function.extfun_app.{2 1} Type ring.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) ring.{0} h0) unsigned)  := sorry --non-trivial
lemma new_lemma_28751 (h0 : thunk pnat) (h1 : pnat) : pnat.coprime (@trace_call_stack.{0} pnat h0) (@id.{1} pnat h1)  := sorry --non-trivial
lemma new_lemma_28752 (h0 : functor.add_const (list (bin_tree empty)) congr_arg_kind) : palindrome (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_28753 (h0 : functor.add_const (group (option congr_arg_kind)) congr_arg_kind) : @normalizer_condition.{0} (option.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (group.{0} (option.{0} congr_arg_kind)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_28754 (h0 : function.extfun Type cancel_comm_monoid_with_zero) : @unique_factorization_monoid.{0} (has_nndist.{0} ennreal) (@function.extfun_app.{2 1} Type cancel_comm_monoid_with_zero.{0} h0 (has_nndist.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_28755 (h0 : filter (random_gen (has_nnnorm (has_nnnorm (has_nnnorm (has_nnnorm linarith.ineq)))))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_28756 (h0 : topological_space (simple_graph string.iterator_imp)) (h1 : add_group (simple_graph string.iterator_imp)) : topological_add_group (simple_graph string.iterator_imp) := sorry --non-trivial
lemma new_lemma_28757 (h1 : uniform_space (id to_additive.value_type)) : complete_space (id to_additive.value_type) := sorry --non-trivial
lemma new_lemma_28758 (h0 : function.extfun nat fin) : @normal_space.{0} (canonically_ordered_monoid.{0} real) (@function.extfun_app.{2 1} Type topological_space.{0} (@matrix.vec_empty.{1} (function.extfun.{2 1} Type topological_space.{0}) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero))) (canonically_ordered_monoid.{0} real))  := sorry --non-trivial
lemma new_lemma_28759 (h0 : functor.add_const (topological_space (cancel_monoid empty)) num) : @path_connected_space.{0} (cancel_monoid.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (cancel_monoid.{0} empty)) num h0)  := sorry --non-trivial
lemma new_lemma_28760 (h0 : topological_space (comm_ring (random_gen (random_gen (random_gen linarith.ineq))))) : totally_separated_space (comm_ring (random_gen (random_gen (random_gen linarith.ineq)))) := sorry --non-trivial
lemma new_lemma_28761 (h0 : complete_lattice (linear_ordered_comm_group pos)) : complete_lattice.is_Sup_finite_compact (linear_ordered_comm_group pos) := sorry --non-trivial
lemma new_lemma_28762 (h0 : functor.add_const (complete_lattice (has_zero environment.implicit_infer_kind)) environment.implicit_infer_kind) : @complete_lattice.is_Sup_finite_compact.{0} (has_zero.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (complete_lattice.{0} (has_zero.{0} environment.implicit_infer_kind)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_28763 (h0 : not (uniform_space (has_inv to_additive.value_type) -> false)) : @complete_space.{0} (has_inv.{0} to_additive.value_type) (@classical.by_contradiction'.{1} (uniform_space.{0} (has_inv.{0} to_additive.value_type)) h0)  := sorry --non-trivial
lemma new_lemma_28764 (h0 : not (function.extfun Type topological_space -> false)) : @irreducible_space.{0} (linear_ordered_semiring.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (linear_ordered_semiring.{0} num))  := sorry --non-trivial
lemma new_lemma_28765 (h0 : function.extfun Type uniform_space) : @separated_space.{0} (bin_tree.{0} unsigned) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (bin_tree.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_28766 (h0 : functor.add_const (monoid (ordered_comm_monoid pos)) Type) : @monoid.fg.{0} (ordered_comm_monoid.{0} pos) (@functor.add_const.run.{0 1} (monoid.{0} (ordered_comm_monoid.{0} pos)) Type h0)  := sorry --non-trivial
lemma new_lemma_28767 (h0 : function.extfun (nat -> Type) (function.extfun nat)) : @complete_space.{0} (has_pos_part.{0} linarith.comp) (@matrix.vec_empty.{0} (uniform_space.{0} (has_pos_part.{0} linarith.comp)) (@function.extfun_app.{1 1} nat fin (@function.extfun_app.{2 1} (nat → Type) (function.extfun.{1 1} nat) h0 fin) (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_28768 (h0 : function.extfun Type ring) : @rank_condition.{0} (ring.{0} name) (@function.extfun_app.{2 1} Type ring.{0} h0 (ring.{0} name))  := sorry --non-trivial
lemma new_lemma_28769 (h0 : functor.comp topological_space canonically_ordered_comm_semiring pos) : @regular_space.{0} (canonically_ordered_comm_semiring.{0} pos) (@functor.comp.run.{0 0 0} topological_space.{0} canonically_ordered_comm_semiring.{0} pos h0)  := sorry --non-trivial
lemma new_lemma_28770 (h0 : monoid (has_top (random_gen (random_gen (has_top linarith.comp_source))))) : monoid.fg (has_top (random_gen (random_gen (has_top linarith.comp_source)))) := sorry --non-trivial
lemma new_lemma_28771 (h0 : mul_one_class fun_info) (h1 : ring (monoid.End fun_info)) : strong_rank_condition (monoid.End fun_info) := sorry --non-trivial
lemma new_lemma_28772 (h0 : ring (omega_complete_partial_order num)) : strong_rank_condition (omega_complete_partial_order num) := sorry --non-trivial
lemma new_lemma_28773 (h0 : ordered_add_comm_monoid (semigroup (has_add pos))) : archimedean (semigroup (has_add pos)) := sorry --non-trivial
lemma new_lemma_28774 (h0 : add_group (has_pos_part (has_Inf real))) : is_add_cyclic (has_pos_part (has_Inf real)) := sorry --non-trivial
lemma new_lemma_28775 (h0 : fin has_zero.zero) : @normalizer_condition.{0} (has_bot.{0} linarith.comp) (@matrix.vec_empty.{0} (group.{0} (has_bot.{0} linarith.comp)) (@matrix.vec_empty.{0} (fin (@has_zero.zero.{0} nat nat.has_zero)) h0))  := sorry --non-trivial
lemma new_lemma_28776 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @preconnected_space.{0} (has_zero.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_zero.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_28777 (h0 : not (has_mem.mem (with_one congr_arg_kind) has_emptyc.emptyc -> false)) : @totally_disconnected_space.{0} (with_one.{0} congr_arg_kind) (@finset.pi.empty.{1 0} Type topological_space.{0} (with_one.{0} congr_arg_kind) (@classical.by_contradiction'.{0} (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (with_one.{0} congr_arg_kind) (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))) h0))  := sorry --non-trivial
lemma new_lemma_28778 (h0 : has_mem.mem linarith.comp has_emptyc.emptyc) : @totally_separated_space.{0} linarith.comp (@finset.pi.empty.{1 0} Type topological_space.{0} linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_28779 (h0 : function.extfun linarith.ineq (fun (x : linarith.ineq), Prop)) : @infi.{0 1} Prop (@conditionally_complete_lattice.to_has_Inf.{0} Prop (@complete_lattice.to_conditionally_complete_lattice.{0} Prop Prop.complete_lattice)) linarith.ineq (@function.extfun_app.{1 1} linarith.ineq (λ (x : linarith.ineq), Prop) h0)  := sorry --non-trivial
lemma new_lemma_28780 (h0 : monoid (complete_semilattice_Sup (has_inv (has_norm (has_inv (has_inv linarith.ineq)))))) : monoid.fg (complete_semilattice_Sup (has_inv (has_norm (has_inv (has_inv linarith.ineq))))) := sorry --non-trivial
lemma new_lemma_28781 (h1 : not (complete_lattice (with_bot linarith.comp_source) -> false)) : @is_compactly_generated.{0} (with_bot.{0} linarith.comp_source) (@classical.by_contradiction'.{1} (complete_lattice.{0} (with_bot.{0} linarith.comp_source)) h1)  := sorry --non-trivial
lemma new_lemma_28782 (h0 : semiring (semigroup (semiring unsigned))) : is_noetherian_ring (semigroup (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_28783 (h0 : set (distrib (has_compl string_imp))) : set.finite h0 := sorry --non-trivial
lemma new_lemma_28784 (h0 : not (complete_lattice (has_ssubset linarith.ineq) -> false)) : @complete_lattice.is_Sup_finite_compact.{0} (has_ssubset.{0} linarith.ineq) (@classical.by_contradiction'.{1} (complete_lattice.{0} (has_ssubset.{0} linarith.ineq)) h0)  := sorry --non-trivial
lemma new_lemma_28785 (h0 : complete_lattice (has_le (mul_one_class linarith.comp_source))) : complete_lattice.is_Sup_finite_compact (has_le (mul_one_class linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_28786 (h0 : ordered_add_comm_monoid (canonically_ordered_monoid (finset Type))) : archimedean (canonically_ordered_monoid (finset Type)) := sorry --non-trivial
lemma new_lemma_28787 (h0 : topological_space (semigroup (has_neg (has_add pos)))) : sequential_space (semigroup (has_neg (has_add pos))) := sorry --non-trivial
lemma new_lemma_28788 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @preirreducible_space.{0} (linear_ordered_field.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (linear_ordered_field.{0} empty))  := sorry --non-trivial
lemma new_lemma_28789 (h0 : function.extfun Type complete_lattice) : @is_compactly_generated.{0} (semiring.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (semiring.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_28790 (h0 : group (denumerable (with_bot to_additive.value_type))) : is_cyclic (denumerable (with_bot to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_28791 (h0 : ring (semi_normed_comm_ring to_additive.value_type)) : is_domain (semi_normed_comm_ring to_additive.value_type) := sorry --non-trivial
lemma new_lemma_28792 (h0 : functor.add_const (topological_space (add_comm_monoid environment.implicit_infer_kind)) (comm_group name)) : @t0_space.{0} (add_comm_monoid.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (add_comm_monoid.{0} environment.implicit_infer_kind)) (comm_group.{0} name) h0)  := sorry --non-trivial
lemma new_lemma_28793 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @unique_factorization_monoid.{1} (comm_group.{1} Type) (@function.extfun_app.{3 2} (Type 1) cancel_comm_monoid_with_zero.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 cancel_comm_monoid_with_zero.{1}) (comm_group.{1} Type))  := sorry --non-trivial
lemma new_lemma_28794 (h0 : topological_space (has_compl linarith.ineq)) (h1 : add_group (has_compl linarith.ineq)) : topological_add_group (has_compl linarith.ineq) := sorry --non-trivial
lemma new_lemma_28795 (h0 : ring (linear_ordered_add_comm_group (has_nnnorm linarith.ineq))) : rank_condition (linear_ordered_add_comm_group (has_nnnorm linarith.ineq)) := sorry --non-trivial
lemma new_lemma_28796 (h0 : functor.add_const (topological_space (option ennreal)) num) : @preirreducible_space.{0} (option.{0} ennreal) (@functor.add_const.run.{0 0} (topological_space.{0} (option.{0} ennreal)) num h0)  := sorry --non-trivial
lemma new_lemma_28797 (h0 : group (finset (has_neg environment.implicit_infer_kind))) : is_cyclic (finset (has_neg environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_28798 (h0 : topological_space (canonically_linear_ordered_monoid ennreal)) : preconnected_space (canonically_linear_ordered_monoid ennreal) := sorry --non-trivial
lemma new_lemma_28799 (h0 : functor.add_const (functor.add_const (ring auto.case_option) num) num) : @rank_condition.{0} auto.case_option (@functor.add_const.run.{0 0} (ring.{0} auto.case_option) num (@functor.add_const.run.{0 0} (functor.add_const.{0 0} (ring.{0} auto.case_option) num) num h0))  := sorry --non-trivial
lemma new_lemma_28800 (h0 : functor.add_const (topological_space (has_zero pos)) environment.implicit_infer_kind) : @locally_compact_space.{0} (has_zero.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (has_zero.{0} pos)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_28801 (h0 : uniform_space (semilattice_inf (semiring congr_arg_kind))) : separated_space (semilattice_inf (semiring congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_28802 (h0 : function.extfun Type topological_space) : @locally_compact_space.{0} (encodable.{0} fun_info) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (encodable.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_28803 (h0 : functor.add_const (ring (ring pos)) pos) : @rank_condition.{0} (ring.{0} pos) (@functor.add_const.run.{0 0} (ring.{0} (ring.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_28804 (h0 : topological_space (semiring (semiring (has_norm (has_norm (has_norm empty)))))) : irreducible_space (semiring (semiring (has_norm (has_norm (has_norm empty))))) := sorry --non-trivial
lemma new_lemma_28805 (h0 : function.extfun (Type 1) topological_space) : @normal_space.{1} (boolean_algebra.core.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} h0 (boolean_algebra.core.{1} Type))  := sorry --non-trivial
lemma new_lemma_28806 (h0 : cancel_comm_monoid_with_zero (has_neg (has_add linarith.comp))) : unique_factorization_monoid (has_neg (has_add linarith.comp)) := sorry --non-trivial
lemma new_lemma_28807 (h0 : list (add_left_cancel_semigroup (option unsigned))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_28808 (h0 : list (left_cancel_semigroup (semiring (semiring congr_arg_kind)))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_28809 (h0 : add_group (linear_ordered_add_comm_group (topological_space string_imp))) : is_add_cyclic (linear_ordered_add_comm_group (topological_space string_imp)) := sorry --non-trivial
lemma new_lemma_28810 (h0 : function.extfun Type ring) : @strong_rank_condition.{0} (has_zero.{0} unsigned) (@function.extfun_app.{2 1} Type ring.{0} h0 (has_zero.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_28811 (h0 : has_lt environment.projection_info) : no_max_order environment.projection_info := sorry --non-trivial
lemma new_lemma_28812 (h0 : group (linear_ordered_add_comm_group (has_nnnorm (has_nnnorm (random_gen linarith.comp_source))))) : group.fg (linear_ordered_add_comm_group (has_nnnorm (has_nnnorm (random_gen linarith.comp_source)))) := sorry --non-trivial
lemma new_lemma_28813 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @preirreducible_space.{0} (add_cancel_monoid.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (add_cancel_monoid.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_28814 (h0 : functor.add_const (ring (has_neg_part Type)) environment.implicit_infer_kind) : @strong_rank_condition.{1} (has_neg_part.{1} Type) (@functor.add_const.run.{1 0} (ring.{1} (has_neg_part.{1} Type)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_28815 (h0 : topological_space (has_pos_part (generalized_boolean_algebra Type))) : irreducible_space (has_pos_part (generalized_boolean_algebra Type)) := sorry --non-trivial
lemma new_lemma_28816 (h0 : topological_space (boolean_algebra.core (finset pos))) : preconnected_space (boolean_algebra.core (finset pos)) := sorry --non-trivial
lemma new_lemma_28817 (h0 : not (uniform_space (semi_normed_comm_ring linarith.ineq) -> false)) : @complete_space.{0} (semi_normed_comm_ring.{0} linarith.ineq) (@classical.by_contradiction'.{1} (uniform_space.{0} (semi_normed_comm_ring.{0} linarith.ineq)) h0)  := sorry --non-trivial
lemma new_lemma_28818 (h0 : has_mem.mem (has_one linarith.comp) has_emptyc.emptyc) : @is_atomistic.{0} (has_one.{0} linarith.comp) (@finset.pi.empty.{1 0} Type complete_lattice.{0} (has_one.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_28819 (h0 : functor.add_const (cancel_comm_monoid_with_zero (cancel_monoid Type)) ennreal) : @unique_factorization_monoid.{1} (cancel_monoid.{1} Type) (@functor.add_const.run.{1 0} (cancel_comm_monoid_with_zero.{1} (cancel_monoid.{1} Type)) ennreal h0)  := sorry --non-trivial
lemma new_lemma_28820 (h0 : topological_space (generalized_boolean_algebra (has_Inf (has_add (has_add (has_add Type)))))) : normal_space (generalized_boolean_algebra (has_Inf (has_add (has_add (has_add Type))))) := sorry --non-trivial
lemma new_lemma_28821 (h0 : function.extfun Type (functor.comp ordered_add_comm_monoid comm_group)) : @archimedean.{0} (comm_group.{0} name) (@functor.comp.run.{0 0 0} ordered_add_comm_monoid.{0} comm_group.{0} name (@function.extfun_app.{2 1} Type (functor.comp.{0 0 0} ordered_add_comm_monoid.{0} comm_group.{0}) h0 name))  := sorry --non-trivial
lemma new_lemma_28822 (h0 : functor.add_const (ordered_comm_monoid (comm_group linarith.comp)) environment.implicit_infer_kind) : @has_exists_mul_of_le.{0} (comm_group.{0} linarith.comp) (@functor.add_const.run.{0 0} (ordered_comm_monoid.{0} (comm_group.{0} linarith.comp)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_28823 (h0 : topological_space (as_linear_order (option unsigned))) : t0_space (as_linear_order (option unsigned)) := sorry --non-trivial
lemma new_lemma_28824 (h0 : not (topological_space (has_union congr_arg_kind) -> false)) : @discrete_topology.{0} (has_union.{0} congr_arg_kind) (@classical.by_contradiction'.{1} (topological_space.{0} (has_union.{0} congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_28825 (h0 : uniform_space (uniform_space (add_monoid (mul_one_class string_imp)))) : complete_space (uniform_space (add_monoid (mul_one_class string_imp))) := sorry --non-trivial
lemma new_lemma_28826 (h0 : topological_space (has_add (has_add real))) : locally_compact_space (has_add (has_add real)) := sorry --non-trivial
lemma new_lemma_28827 (h0 : functor.add_const (complete_lattice (ring Type)) environment.implicit_infer_kind) : @is_compactly_generated.{1} (ring.{1} Type) (@functor.add_const.run.{1 0} (complete_lattice.{1} (ring.{1} Type)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_28828 (h0 : function.extfun Type (functor.add_const (cancel_comm_monoid_with_zero pos))) : @unique_factorization_monoid.{0} pos (@functor.add_const.run.{0 0} (cancel_comm_monoid_with_zero.{0} pos) ennreal (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (cancel_comm_monoid_with_zero.{0} pos)) h0 ennreal))  := sorry --non-trivial
lemma new_lemma_28829 (h0 : cancel_comm_monoid_with_zero (has_zero (boolean_algebra.core pos))) : unique_factorization_monoid (has_zero (boolean_algebra.core pos)) := sorry --non-trivial
lemma new_lemma_28830 (h0 : fun_info -> fun_info -> Prop) : is_preorder fun_info h0 := sorry --non-trivial
lemma new_lemma_28831 (h0 : function.extfun Type filter) : countable_Inter_filter (function.extfun_app h0 (pseudo_metric_space pos)) := sorry --non-trivial
lemma new_lemma_28832 (h0 : group (has_ssubset linarith.ineq)) : is_cyclic (has_ssubset linarith.ineq) := sorry --non-trivial
lemma new_lemma_28833 (h0 : uniform_space (has_norm (has_inv linarith.comp_source))) : complete_space (has_norm (has_inv linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_28834 (h0 : uniform_space (left_cancel_semigroup num)) : complete_space (left_cancel_semigroup num) := sorry --non-trivial
lemma new_lemma_28835 (h0 : list (linear_ordered_field (option ennreal))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_28836 (h0 : function.extfun Type monoid) : @monoid.fg.{0} (normed_group.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type monoid.{0} h0 (normed_group.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_28837 (h0 : add_group (has_emptyc (has_top empty))) : is_add_cyclic (has_emptyc (has_top empty)) := sorry --non-trivial
lemma new_lemma_28838 (h0 : topological_space (boolean_algebra.core (ring linarith.comp))) : regular_space (boolean_algebra.core (ring linarith.comp)) := sorry --non-trivial
lemma new_lemma_28839 (h0 : not (function.extfun Type uniform_space -> false)) : @complete_space.{0} (has_bot.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type uniform_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type uniform_space.{0}) h0) (has_bot.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_28840 (h0 : functor.add_const (finset (canonically_linear_ordered_monoid real)) real) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_28841 (h0 : uniform_space (has_one (semiring (semiring congr_arg_kind)))) : complete_space (has_one (semiring (semiring congr_arg_kind))) := sorry --non-trivial
lemma new_lemma_28842 (h0 : function.extfun (finset (Type -> Type)) (has_mem.mem complete_lattice)) : @is_compactly_generated.{0} (normed_group.{0} num) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) complete_lattice.{0} (@function.extfun_app.{2 0} (finset.{1} (Type → Type)) (@has_mem.mem.{1 1} (Type → Type) (finset.{1} (Type → Type)) (@finset.has_mem.{1} (Type → Type)) complete_lattice.{0}) h0 (@has_emptyc.emptyc.{1} (finset.{1} (Type → Type)) (@finset.has_emptyc.{1} (Type → Type))))) (normed_group.{0} num))  := sorry --non-trivial
lemma new_lemma_28843 (h0 : ring (topological_space (has_ssubset (random_gen linarith.ineq)))) : strong_rank_condition (topological_space (has_ssubset (random_gen linarith.ineq))) := sorry --non-trivial
lemma new_lemma_28844 (h0 : monoid (with_one (has_top (has_norm (has_top num))))) : monoid.fg (with_one (has_top (has_norm (has_top num)))) := sorry --non-trivial
lemma new_lemma_28845 (h0 : functor.add_const (topological_space (semigroup unsigned)) environment.implicit_infer_kind) : @preirreducible_space.{0} (semigroup.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (semigroup.{0} unsigned)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_28846 (h0 : has_mem.mem (metric_space empty) has_emptyc.emptyc) : @locally_compact_space.{0} (metric_space.{0} empty) (@finset.pi.empty.{1 0} Type topological_space.{0} (metric_space.{0} empty) h0)  := sorry --non-trivial
lemma new_lemma_28847 (h0 : topological_space (uniform_space (mul_one_class (mul_one_class (mul_one_class linarith.ineq))))) (h1 : preorder (uniform_space (mul_one_class (mul_one_class (mul_one_class linarith.ineq))))) : order_topology (uniform_space (mul_one_class (mul_one_class (mul_one_class linarith.ineq)))) := sorry --non-trivial
lemma new_lemma_28848 (h0 : group (linear_ordered_field congr_arg_kind)) : is_simple_group (linear_ordered_field congr_arg_kind) := sorry --non-trivial
lemma new_lemma_28849 (h0 : not (complete_lattice (has_append char) -> false)) : @is_compactly_generated.{0} (has_append.{0} char) (@classical.by_contradiction'.{1} (complete_lattice.{0} (has_append.{0} char)) h0)  := sorry --non-trivial
lemma new_lemma_28850 (h0 : functor.add_const (topological_space (complete_semilattice_Sup unsigned)) num) : @t0_space.{0} (complete_semilattice_Sup.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (complete_semilattice_Sup.{0} unsigned)) num h0)  := sorry --non-trivial
lemma new_lemma_28851 (h0 : topological_space (has_edist unsigned)) : topological_space.separable_space (has_edist unsigned) := sorry --non-trivial
lemma new_lemma_28852 (h0 : function.extfun Type group) : @group.fg.{0} (has_one.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type group.{0} h0 (has_one.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_28853 (h0 : ring (has_top (has_ssubset linarith.ineq))) : is_domain (has_top (has_ssubset linarith.ineq)) := sorry --non-trivial
lemma new_lemma_28854 (h0 : functor.add_const (complete_lattice (complete_distrib_lattice unsigned)) name) : @is_atomistic.{0} (complete_distrib_lattice.{0} unsigned) (@functor.add_const.run.{0 0} (complete_lattice.{0} (complete_distrib_lattice.{0} unsigned)) name h0)  := sorry --non-trivial
lemma new_lemma_28855 (h0 : complete_lattice rat) : is_compactly_generated rat := sorry --non-trivial
lemma new_lemma_28856 (h0 : topological_space (mul_zero_class (semiring (semiring congr_arg_kind)))) : irreducible_space (mul_zero_class (semiring (semiring congr_arg_kind))) := sorry --non-trivial
lemma new_lemma_28857 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @normal_space.{0} (mul_zero_class.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (mul_zero_class.{0} name))  := sorry --non-trivial
lemma new_lemma_28858 (h0 : function.extfun Type topological_space) : @preconnected_space.{0} (has_pos_part.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_pos_part.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_28859 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @irreducible_space.{0} (generalized_boolean_algebra.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (generalized_boolean_algebra.{0} pos))  := sorry --non-trivial
lemma new_lemma_28860 (h0 : fin has_zero.zero) : @path_connected_space.{0} (generalized_boolean_algebra.{0} linarith.comp) (@matrix.vec_empty.{0} (topological_space.{0} (generalized_boolean_algebra.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_28861 (h0 : not (complete_lattice (add_group num) -> false)) : @is_compactly_generated.{0} (add_group.{0} num) (@classical.by_contradiction'.{1} (complete_lattice.{0} (add_group.{0} num)) h0)  := sorry --non-trivial
lemma new_lemma_28862 (h0 : list (function.extfun Type uniform_space)) (h1 : ne h0 list.nil) : @complete_space.{0} (with_one.{0} fun_info) (@function.extfun_app.{2 1} Type uniform_space.{0} (@list.last.{1} (function.extfun.{2 1} Type uniform_space.{0}) h0 h1) (with_one.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_28863 (h0 : function.extfun Type filter) : filter.ne_bot (function.extfun_app h0 (linear_ordered_semiring empty)) := sorry --non-trivial
lemma new_lemma_28864 (h0 : has_mul Type) : set.center Type (left_cancel_monoid congr_arg_kind) := sorry --non-trivial
lemma new_lemma_28865 (h0 : functor.add_const (ring (has_bot pos)) (has_Inf Type)) : @is_principal_ideal_ring.{0} (has_bot.{0} pos) (@functor.add_const.run.{0 1} (ring.{0} (has_bot.{0} pos)) (has_Inf.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_28866 (h0 : filter (has_Inf (finset (has_Inf pos)))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_28867 (h1 : add_group (measurable_space (random_gen (random_gen to_additive.value_type)))) : is_add_cyclic (measurable_space (random_gen (random_gen to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_28868 (h0 : function.extfun (finset Type) (has_mem.mem (with_bot fun_info))) : @totally_separated_space.{0} (with_bot.{0} fun_info) (@finset.pi.empty.{1 0} Type topological_space.{0} (with_bot.{0} fun_info) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (with_bot.{0} fun_info)) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_28869 (h0 : topological_space (with_bot (has_norm empty))) : totally_separated_space (with_bot (has_norm empty)) := sorry --non-trivial
lemma new_lemma_28870 (h0 : function.extfun (finset Type) (has_mem.mem (with_one linarith.ineq))) : @totally_disconnected_space.{0} (with_one.{0} linarith.ineq) (@finset.pi.empty.{1 0} Type topological_space.{0} (with_one.{0} linarith.ineq) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (with_one.{0} linarith.ineq)) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_28871 (h0 : topological_space (complete_distrib_lattice (ring name))) : locally_compact_space (complete_distrib_lattice (ring name)) := sorry --non-trivial
lemma new_lemma_28872 (h0 : function.extfun ((Type -> Type) -> Type 1) (function.extfun (Type -> Type))) : @totally_separated_space.{0} (with_one.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) (@function.extfun_app.{3 2} ((Type → Type) → Type 1) (function.extfun.{2 2} (Type → Type)) h0 (function.extfun.{2 1} Type)) topological_space.{0}) (with_one.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_28873 (h0 : ring (semiring (has_norm linarith.comp))) : is_domain (semiring (has_norm linarith.comp)) := sorry --non-trivial
lemma new_lemma_28874 (h0 : group (has_compl (has_ssubset to_additive.value_type))) : is_cyclic (has_compl (has_ssubset to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_28875 (h0 : topological_space (with_one (has_top (semiring linarith.comp_source)))) : irreducible_space (with_one (has_top (semiring linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_28876 (h1 h2 : multiset char) : multiset.le h1 h2 := sorry --non-trivial
lemma new_lemma_28877 (h0 : set (semi_normed_comm_ring (mul_one_class linarith.ineq))) : set.finite h0 := sorry --non-trivial
lemma new_lemma_28878 (h0 : functor.add_const (add_monoid (normed_comm_ring Type)) linarith.comp) : @add_monoid.fg.{1} (normed_comm_ring.{1} Type) (@functor.add_const.run.{1 0} (add_monoid.{1} (normed_comm_ring.{1} Type)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_28879 (h0 : topological_space (semiring (has_top empty))) : irreducible_space (semiring (has_top empty)) := sorry --non-trivial
lemma new_lemma_28880 (h0 : ring (linear_ordered_semiring (random_gen linarith.ineq))) : rank_condition (linear_ordered_semiring (random_gen linarith.ineq)) := sorry --non-trivial
lemma new_lemma_28881 (h0 : function.extfun Type (functor.comp group add_comm_monoid)) : @is_simple_group.{0} (add_comm_monoid.{0} environment.implicit_infer_kind) (@functor.comp.run.{0 0 0} group.{0} add_comm_monoid.{0} environment.implicit_infer_kind (@function.extfun_app.{2 1} Type (functor.comp.{0 0 0} group.{0} add_comm_monoid.{0}) h0 environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_28882 (h0 : functor.add_const (semiring (measurable_space.dynkin_system unsigned)) congr_arg_kind) : @is_noetherian_ring.{0} (measurable_space.dynkin_system.{0} unsigned) (@functor.add_const.run.{0 0} (semiring.{0} (measurable_space.dynkin_system.{0} unsigned)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_28883 (h0 : uniform_space (ordered_comm_monoid (boolean_algebra.core linarith.comp))) : complete_space (ordered_comm_monoid (boolean_algebra.core linarith.comp)) := sorry --non-trivial
lemma new_lemma_28884 (h0 : functor.add_const (complete_lattice (cancel_monoid num)) unsigned) : @is_compactly_generated.{0} (cancel_monoid.{0} num) (@functor.add_const.run.{0 0} (complete_lattice.{0} (cancel_monoid.{0} num)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_28885 (h0 : add_monoid (left_cancel_monoid empty)) : add_monoid.fg (left_cancel_monoid empty) := sorry --non-trivial
lemma new_lemma_28886 (h0 : add_monoid (mul_one_class fun_info)) (h1 : add_submonoid (mul_one_class fun_info)) : add_submonoid.fg h1 := sorry --non-trivial
lemma new_lemma_28887 (h0 : topological_space (encodable to_additive.value_type)) : totally_disconnected_space (encodable to_additive.value_type) := sorry --non-trivial
lemma new_lemma_28888 (h0 : functor.add_const (function.extfun Type ring) Type) : @is_principal_ideal_ring.{0} (canonically_ordered_comm_semiring.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type ring.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type ring.{0}) Type h0) (canonically_ordered_comm_semiring.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_28889 (h0 : functor.add_const (ring (has_repr pos)) pos) : @rank_condition.{0} (has_repr.{0} pos) (@functor.add_const.run.{0 0} (ring.{0} (has_repr.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_28890 (h0 : fin has_zero.zero) : @normal_space.{0} (simple_graph.{0} (has_add.{0} pos)) (@matrix.vec_empty.{0} (topological_space.{0} (simple_graph.{0} (has_add.{0} pos))) h0)  := sorry --non-trivial
lemma new_lemma_28891 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @complete_space.{0} (add_comm_monoid.{0} unsigned) (@function.extfun_app.{2 1} Type uniform_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 uniform_space.{0}) (add_comm_monoid.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_28892 (h0 : topological_space (semiring (has_top (has_top fun_info)))) : t0_space (semiring (has_top (has_top fun_info))) := sorry --non-trivial
lemma new_lemma_28893 (h0 : function.extfun Type topological_space) : @topological_space.separable_space.{0} (normed_group.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (normed_group.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_28894 (h0 : cancel_comm_monoid_with_zero (complete_distrib_lattice (semigroup name))) : unique_factorization_monoid (complete_distrib_lattice (semigroup name)) := sorry --non-trivial
lemma new_lemma_28895 (h0 : function.extfun Type uniform_space) : @separated_space.{0} (has_union.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (has_union.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_28896 (h0 : group (has_to_string (has_to_string congr_arg_kind))) : group.fg (has_to_string (has_to_string congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_28897 (h0 : functor.add_const (function.extfun (Type 1) topological_space) empty) : @path_connected_space.{1} (plift.{1} empty) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) topological_space.{1}) empty h0) (plift.{1} empty))  := sorry --non-trivial
lemma new_lemma_28898 (h0 : function.extfun Type list) : list.nodup (function.extfun_app h0 (cancel_monoid environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_28899 (h0 : not (uniform_space (linear_ordered_semiring unsigned) -> false)) : @complete_space.{0} (linear_ordered_semiring.{0} unsigned) (@classical.by_contradiction'.{1} (uniform_space.{0} (linear_ordered_semiring.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_28900 (h0 : function.extfun (Type -> Type) (function.extfun Type)) (h1 : function.extfun ((has_div (lex fun_info) -> false) -> Prop) (function.extfun (has_div (lex fun_info) -> false))) : @has_measurable_div₂.{0} (lex.{0} fun_info) (@function.extfun_app.{2 1} Type measurable_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 measurable_space.{0}) (lex.{0} fun_info)) (@classical.by_contradiction'.{1} (has_div.{0} (lex.{0} fun_info)) (@function.extfun_app.{0 0} (has_div.{0} (lex.{0} fun_info) → false) (λ (x : has_div.{0} (lex.{0} fun_info) → false), false) (@function.extfun_app.{1 0} ((has_div.{0} (lex.{0} fun_info) → false) → Prop) (function.extfun.{0 0} (has_div.{0} (lex.{0} fun_info) → false)) h1 (λ (x : has_div.{0} (lex.{0} fun_info) → false), false))))  := sorry --non-trivial
lemma new_lemma_28901 (h0 : function.extfun (finset Type) (has_mem.mem (has_one empty))) : @totally_disconnected_space.{0} (has_one.{0} empty) (@finset.pi.empty.{1 0} Type topological_space.{0} (has_one.{0} empty) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (has_one.{0} empty)) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_28902 (h0 : not (semiring num -> false)) : @is_noetherian_ring.{0} num (@classical.by_contradiction'.{1} (semiring.{0} num) h0)  := sorry --non-trivial
lemma new_lemma_28903 (h0 : list (has_zero (finset linarith.comp))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_28904 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_principal_ideal_ring.{0} (mul_zero_class.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (mul_zero_class.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_28905 (h0 : ring (has_Inf (ordered_comm_monoid pos))) : strong_rank_condition (has_Inf (ordered_comm_monoid pos)) := sorry --non-trivial
lemma new_lemma_28906 (h0 : function.extfun Type ring) : @rank_condition.{0} (ordered_comm_group.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type ring.{0} h0 (ordered_comm_group.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_28907 (h0 : group (add_cancel_comm_monoid (random_gen linarith.ineq))) : is_cyclic (add_cancel_comm_monoid (random_gen linarith.ineq)) := sorry --non-trivial
lemma new_lemma_28908 (h0 : ring (has_emptyc (has_inv (random_gen linarith.ineq)))) : is_domain (has_emptyc (has_inv (random_gen linarith.ineq))) := sorry --non-trivial
lemma new_lemma_28909 (h0 : uniform_space (measurable_space (random_gen (has_norm (random_gen fun_info))))) : complete_space (measurable_space (random_gen (has_norm (random_gen fun_info)))) := sorry --non-trivial
lemma new_lemma_28910 (h0 : group (ordered_comm_ring (has_add real))) : group.fg (ordered_comm_ring (has_add real)) := sorry --non-trivial
lemma new_lemma_28911 (h0 : topological_space (linear_ordered_field ennreal)) : preconnected_space (linear_ordered_field ennreal) := sorry --non-trivial
lemma new_lemma_28912 (h1 : uniform_space (non_unital_non_assoc_semiring linarith.ineq)) : complete_space (non_unital_non_assoc_semiring linarith.ineq) := sorry --non-trivial
lemma new_lemma_28913 (h0 : preorder (add_comm_semigroup linarith.ineq)) (h1 : set (add_comm_semigroup linarith.ineq)) : set.is_pwo h1 := sorry --non-trivial
lemma new_lemma_28914 (h0 : topological_space (has_nndist (finset linarith.comp))) : t1_space (has_nndist (finset linarith.comp)) := sorry --non-trivial
lemma new_lemma_28915 (h0 : function.extfun Type uniform_space) : @complete_space.{0} (simple_graph.{0} pos) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (simple_graph.{0} pos))  := sorry --non-trivial
lemma new_lemma_28916 (h0 : ordered_add_comm_monoid (generalized_boolean_algebra pos)) : archimedean (generalized_boolean_algebra pos) := sorry --non-trivial
lemma new_lemma_28917 (h0 : function.extfun nat fin) : @preirreducible_space.{1} (boolean_algebra.{1} Type) (@matrix.vec_empty.{1} (topological_space.{1} (boolean_algebra.{1} Type)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_28918 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @monoid.fg.{0} (add_cancel_monoid.{0} name) (@function.extfun_app.{2 1} Type monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 monoid.{0}) (add_cancel_monoid.{0} name))  := sorry --non-trivial
lemma new_lemma_28919 (h0 : functor.add_const (topological_space (has_add unsigned)) Type) : @t1_space.{0} (has_add.{0} unsigned) (@functor.add_const.run.{0 1} (topological_space.{0} (has_add.{0} unsigned)) Type h0)  := sorry --non-trivial
lemma new_lemma_28920 (h0 : uniform_space (has_bot (has_add (has_Inf real)))) : separated_space (has_bot (has_add (has_Inf real))) := sorry --non-trivial
lemma new_lemma_28921 (h0 : fin has_zero.zero) : @is_add_cyclic.{0} (ordered_comm_ring.{0} pos) (@matrix.vec_empty.{0} (add_group.{0} (ordered_comm_ring.{0} pos)) h0)  := sorry --non-trivial
lemma new_lemma_28922 (h0 : function.extfun Type topological_space) : @irreducible_space.{0} (linear_ordered_comm_group.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (linear_ordered_comm_group.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_28923 (h0 : functor.add_const (complete_lattice (has_to_string pos)) name) : @is_compactly_generated.{0} (has_to_string.{0} pos) (@functor.add_const.run.{0 0} (complete_lattice.{0} (has_to_string.{0} pos)) name h0)  := sorry --non-trivial
lemma new_lemma_28924 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @loc_path_connected_space.{0} (normed_lattice_add_comm_group.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (normed_lattice_add_comm_group.{0} name))  := sorry --non-trivial
lemma new_lemma_28925 (h0 : semiring (random_gen (mul_one_class linarith.ineq))) (h1 : ideal (random_gen (mul_one_class linarith.ineq))) : ideal.is_prime h1 := sorry --non-trivial
lemma new_lemma_28926 (h0 : ring (add_cancel_monoid (finset linarith.comp))) : strong_rank_condition (add_cancel_monoid (finset linarith.comp)) := sorry --non-trivial
lemma new_lemma_28927 (h0 : to_additive.value_type -> to_additive.value_type -> bool) : is_dec_refl h0 := sorry --non-trivial
lemma new_lemma_28928 (h0 : topological_space (ring (ring (has_zero Type)))) : loc_path_connected_space (ring (ring (has_zero Type))) := sorry --non-trivial
lemma new_lemma_28929 (h0 : ring (semiring (metric_space num))) : strong_rank_condition (semiring (metric_space num)) := sorry --non-trivial
lemma new_lemma_28930 (h0 : ring (with_one (has_top (has_norm (semiring (semiring unsigned)))))) : strong_rank_condition (with_one (has_top (has_norm (semiring (semiring unsigned))))) := sorry --non-trivial
lemma new_lemma_28931 (h0 : complete_lattice (has_pos_part (simple_graph (sub_neg_monoid real)))) : is_atomistic (has_pos_part (simple_graph (sub_neg_monoid real))) := sorry --non-trivial
lemma new_lemma_28932 (h0 : uniform_space (boolean_algebra (cancel_monoid Type))) : complete_space (boolean_algebra (cancel_monoid Type)) := sorry --non-trivial
lemma new_lemma_28933 (h0 : topological_space (complete_distrib_lattice (has_Inf linarith.comp))) : totally_separated_space (complete_distrib_lattice (has_Inf linarith.comp)) := sorry --non-trivial
lemma new_lemma_28934 (h0 : ring (nondiscrete_normed_field ereal)) : strong_rank_condition (nondiscrete_normed_field ereal) := sorry --non-trivial
lemma new_lemma_28935 (h0 : topological_space (filter unsigned)) (h1 : preorder (filter unsigned)) : order_topology (filter unsigned) := sorry --non-trivial
lemma new_lemma_28936 (h0 : topological_space (dlist (random_gen fun_info))) : irreducible_space (dlist (random_gen fun_info)) := sorry --non-trivial
lemma new_lemma_28937 (h0 : group (normed_group (random_gen (with_one to_additive.value_type)))) : normalizer_condition (normed_group (random_gen (with_one to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_28938 (h0 : functor.add_const (finset (add_comm_monoid linarith.comp)) Type) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_28939 (h0 : semiring (with_one (semiring (has_norm unsigned)))) : is_noetherian_ring (with_one (semiring (has_norm unsigned))) := sorry --non-trivial
lemma new_lemma_28940 (h0 : ring (linear_ordered_comm_group_with_zero (denumerable char))) : is_domain (linear_ordered_comm_group_with_zero (denumerable char)) := sorry --non-trivial
lemma new_lemma_28941 (h0 : group (random_gen (random_gen num))) : is_cyclic (random_gen (random_gen num)) := sorry --non-trivial
lemma new_lemma_28942 (h0 : topological_space (add_group congr_arg_kind)) : path_connected_space (add_group congr_arg_kind) := sorry --non-trivial
lemma new_lemma_28943 (h0 : functor.add_const (filter (normed_comm_ring pos)) linarith.comp) : filter.ne_bot (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_28944 (h0 : functor.add_const (function.extfun (Type 1) topological_space) (ring pos)) : @totally_disconnected_space.{1} (has_add.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) topological_space.{1}) (ring.{0} pos) h0) (has_add.{1} Type))  := sorry --non-trivial
lemma new_lemma_28945 (h0 : not (filter (add_group unsigned) -> false)) : filter.ne_bot (classical.by_contradiction' h0) := sorry --non-trivial
lemma new_lemma_28946 (h0 : functor.add_const (complete_lattice (is_R_or_C unsigned)) (semiring empty)) : @is_atomistic.{0} (is_R_or_C.{0} unsigned) (@functor.add_const.run.{0 0} (complete_lattice.{0} (is_R_or_C.{0} unsigned)) (semiring.{0} empty) h0)  := sorry --non-trivial
lemma new_lemma_28947 (h0 : list (complete_linear_order (semiring (normed_linear_ordered_group empty)))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_28948 (h0 : fin has_zero.zero) : @is_principal_ideal_ring.{0} (boolean_algebra.{0} real) (@function.extfun_app.{2 1} Type ring.{0} (@matrix.vec_empty.{1} (function.extfun.{2 1} Type ring.{0}) (@matrix.vec_empty.{0} (fin (@has_zero.zero.{0} nat nat.has_zero)) h0)) (boolean_algebra.{0} real))  := sorry --non-trivial
lemma new_lemma_28949 (h0 : ring (has_to_string Type)) : is_domain (has_to_string Type) := sorry --non-trivial
lemma new_lemma_28950 (h0 : group (dlist (random_gen string_imp))) : group.fg (dlist (random_gen string_imp)) := sorry --non-trivial
lemma new_lemma_28951 (h0 : group (add_comm_monoid Type)) : is_cyclic (add_comm_monoid Type) := sorry --non-trivial
lemma new_lemma_28952 (h0 : ring (has_add (has_neg (mul_one_class linarith.comp)))) : is_domain (has_add (has_neg (mul_one_class linarith.comp))) := sorry --non-trivial
lemma new_lemma_28953 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @path_connected_space.{1} (cancel_monoid.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 topological_space.{1}) (cancel_monoid.{1} Type))  := sorry --non-trivial
lemma new_lemma_28954 (h0 : topological_space (has_norm (semiring (semiring (has_norm (semiring (semiring empty))))))) : path_connected_space (has_norm (semiring (semiring (has_norm (semiring (semiring empty)))))) := sorry --non-trivial
lemma new_lemma_28955 (h2 : ring (distrib (has_ssubset (has_ssubset char)))) : strong_rank_condition (distrib (has_ssubset (has_ssubset char))) := sorry --non-trivial
lemma new_lemma_28956 (h1 : not (add_group (random_gen linarith.comp_source) -> false)) : @is_add_cyclic.{0} (random_gen.{0} linarith.comp_source) (@classical.by_contradiction'.{1} (add_group.{0} (random_gen.{0} linarith.comp_source)) h1)  := sorry --non-trivial
lemma new_lemma_28957 (h0 : not (topological_space (has_sub linarith.comp) -> false)) : @t0_space.{0} (has_sub.{0} linarith.comp) (@classical.by_contradiction'.{1} (topological_space.{0} (has_sub.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_28958 (h0 : list (semigroup (has_neg_part Type))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_28959 (h0 : topological_space (generalized_boolean_algebra (has_pos_part linarith.comp))) : totally_separated_space (generalized_boolean_algebra (has_pos_part linarith.comp)) := sorry --non-trivial
lemma new_lemma_28960 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_domain.{0} (ordered_cancel_add_comm_monoid.{0} pos) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (ordered_cancel_add_comm_monoid.{0} pos))  := sorry --non-trivial
lemma new_lemma_28961 (h0 : filter (has_pos_part (ring (ordered_comm_ring Type)))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_28962 (h0 : topological_space (add_cancel_monoid (has_to_string ennreal))) : totally_separated_space (add_cancel_monoid (has_to_string ennreal)) := sorry --non-trivial
lemma new_lemma_28963 (h0 : ring (left_cancel_semigroup congr_arg_kind)) : is_principal_ideal_ring (left_cancel_semigroup congr_arg_kind) := sorry --non-trivial
lemma new_lemma_28964 (h0 : topological_space (linear_ordered_semiring num)) : irreducible_space (linear_ordered_semiring num) := sorry --non-trivial
lemma new_lemma_28965 (h0 : functor.add_const (monoid (is_R_or_C unsigned)) unsigned) : @monoid.fg.{0} (is_R_or_C.{0} unsigned) (@functor.add_const.run.{0 0} (monoid.{0} (is_R_or_C.{0} unsigned)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_28966 (h0 : topological_space (has_Inf name)) : topological_space.separable_space (has_Inf name) := sorry --non-trivial
lemma new_lemma_28967 (h0 : functor.add_const (topological_space (cancel_monoid linarith.comp)) environment.implicit_infer_kind) : @preirreducible_space.{0} (cancel_monoid.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (cancel_monoid.{0} linarith.comp)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_28968 (h0 : complete_lattice (has_Inf (sub_neg_monoid (has_add (has_Inf real))))) : is_atomistic (has_Inf (sub_neg_monoid (has_add (has_Inf real)))) := sorry --non-trivial
lemma new_lemma_28969 (h1 : set (has_nnnorm string.iterator_imp)) : set.finite h1 := sorry --non-trivial
lemma new_lemma_28970 (h0 : topological_space (add_comm_monoid (comm_group (has_to_string (comm_group Type))))) : regular_space (add_comm_monoid (comm_group (has_to_string (comm_group Type)))) := sorry --non-trivial
lemma new_lemma_28971 (h0 : list (preorder unsigned)) : palindrome h0 := sorry --non-trivial
lemma new_lemma_28972 (h0 h1 : multiset (nondiscrete_normed_field (normed_field (normed_field char)))) : multiset.disjoint h0 h1 := sorry --non-trivial
lemma new_lemma_28973 (h1 : ring (metric_space linarith.comp_source)) : is_domain (metric_space linarith.comp_source) := sorry --non-trivial
lemma new_lemma_28974 (h0 : ring (semi_normed_comm_ring (with_one char))) : is_domain (semi_normed_comm_ring (with_one char)) := sorry --non-trivial
lemma new_lemma_28975 (h0 : add_monoid (semigroup (ring (ring name)))) : add_monoid.fg (semigroup (ring (ring name))) := sorry --non-trivial
lemma new_lemma_28976 (h0 : functor.add_const (topological_space (linear_ordered_field unsigned)) unsigned) : @totally_disconnected_space.{0} (linear_ordered_field.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (linear_ordered_field.{0} unsigned)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_28977 (h0 : list (has_inv (random_gen linarith.ineq))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_28978 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @is_principal_ideal_ring.{1} (ordered_comm_monoid.{1} Type) (@function.extfun_app.{3 2} (Type 1) ring.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 ring.{1}) (ordered_comm_monoid.{1} Type))  := sorry --non-trivial
lemma new_lemma_28979 (h0 : list (sub_neg_monoid (has_add Type))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_28980 (h0 : uniform_space (has_neg (has_neg_part pos))) : complete_space (has_neg (has_neg_part pos)) := sorry --non-trivial
lemma new_lemma_28981 (h2 : not (has_mem.mem (with_one num) has_emptyc.emptyc -> false)) : @is_compactly_generated.{0} (with_one.{0} num) (@finset.pi.empty.{1 0} Type complete_lattice.{0} (with_one.{0} num) (@classical.by_contradiction'.{0} (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (with_one.{0} num) (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))) h2))  := sorry --non-trivial
lemma new_lemma_28982 (h0 : uniform_space (dlist linarith.ineq)) : complete_space (dlist linarith.ineq) := sorry --non-trivial
lemma new_lemma_28983 (h0 : finset (ring (finset linarith.comp))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_28984 (h0 : topological_space (has_ssubset (random_gen string_imp))) : locally_compact_space (has_ssubset (random_gen string_imp)) := sorry --non-trivial
lemma new_lemma_28985 (h5 : topological_space (add_comm_semigroup fun_info)) : t0_space (add_comm_semigroup fun_info) := sorry --non-trivial
lemma new_lemma_28986 (h0 : group congr_arg_kind) : is_cyclic congr_arg_kind := sorry --non-trivial
lemma new_lemma_28987 (h0 : topological_space (complete_semilattice_Sup (semiring (semiring unsigned)))) : irreducible_space (complete_semilattice_Sup (semiring (semiring unsigned))) := sorry --non-trivial
lemma new_lemma_28988 (h0 : function.extfun ((Type -> Type) -> Type 1) (function.extfun (Type -> Type))) : @is_compactly_generated.{0} (has_to_string.{0} ennreal) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) (@function.extfun_app.{3 2} ((Type → Type) → Type 1) (function.extfun.{2 2} (Type → Type)) h0 (function.extfun.{2 1} Type)) complete_lattice.{0}) (has_to_string.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_28989 (h0 : functor.add_const (ring (has_nndist name)) ennreal) : @strong_rank_condition.{0} (has_nndist.{0} name) (@functor.add_const.run.{0 0} (ring.{0} (has_nndist.{0} name)) ennreal h0)  := sorry --non-trivial
lemma new_lemma_28990 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_domain.{0} (cancel_monoid.{0} ennreal) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (cancel_monoid.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_28991 (h0 : not (topological_space (has_star empty) -> false)) : @totally_disconnected_space.{0} (has_star.{0} empty) (@classical.by_contradiction'.{1} (topological_space.{0} (has_star.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_28992 (h0 : functor.add_const (topological_space (pseudo_metric_space pos)) pos) : @regular_space.{0} (pseudo_metric_space.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (pseudo_metric_space.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_28993 (h0 : complete_lattice real) : complete_lattice.is_Sup_finite_compact real := sorry --non-trivial
lemma new_lemma_28994 (h0 : function.extfun Type cancel_comm_monoid_with_zero) : @unique_factorization_monoid.{0} (has_to_string.{0} linarith.comp) (@function.extfun_app.{2 1} Type cancel_comm_monoid_with_zero.{0} h0 (has_to_string.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_28995 (h0 : add_monoid (ordered_ring (semiring (semiring (semiring empty))))) : add_monoid.fg (ordered_ring (semiring (semiring (semiring empty)))) := sorry --non-trivial
lemma new_lemma_28996 (h0 : group (id (random_gen linarith.ineq))) : normalizer_condition (id (random_gen linarith.ineq)) := sorry --non-trivial
lemma new_lemma_28997 (h0 : measurable_space (has_append (mul_one_class char))) (h1 : has_mul (has_append (mul_one_class char))) : has_measurable_mul₂ (has_append (mul_one_class char)) := sorry --non-trivial
lemma new_lemma_28998 (h0 : topological_space (add_group (semiring (semiring congr_arg_kind)))) : normal_space (add_group (semiring (semiring congr_arg_kind))) := sorry --non-trivial
lemma new_lemma_28999 (h0 : function.extfun Type topological_space) : @topological_space.separable_space.{0} (normed_comm_ring.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (normed_comm_ring.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_29000 (h0 : functor.add_const (ring (ring name)) name) : @is_domain.{0} (ring.{0} name) (@functor.add_const.run.{0 0} (ring.{0} (ring.{0} name)) name h0)  := sorry --non-trivial
lemma new_lemma_29001 (h0 : functor.add_const (list (measurable_space.dynkin_system unsigned)) unsigned) : list.nodup (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_29002 (h0 : fin has_zero.zero) : @sequential_space.{0} (normed_lattice_add_comm_group.{0} real) (@matrix.vec_empty.{0} (topological_space.{0} (normed_lattice_add_comm_group.{0} real)) h0)  := sorry --non-trivial
lemma new_lemma_29003 (h0 : functor.add_const (complete_lattice (has_neg pos)) environment.implicit_infer_kind) : @complete_lattice.is_Sup_finite_compact.{0} (has_neg.{0} pos) (@functor.add_const.run.{0 0} (complete_lattice.{0} (has_neg.{0} pos)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_29004 (h0 : topological_space (semigroup (option ennreal))) : discrete_topology (semigroup (option ennreal)) := sorry --non-trivial
lemma new_lemma_29005 (h0 : uniform_space (generalized_boolean_algebra (ring (has_nndist Type)))) : separated_space (generalized_boolean_algebra (ring (has_nndist Type))) := sorry --non-trivial
lemma new_lemma_29006 (h0 : ring (additive (normed_ring string_imp))) : is_domain (additive (normed_ring string_imp)) := sorry --non-trivial
lemma new_lemma_29007 (h0 : topological_space (has_norm unsigned)) : irreducible_space (has_norm unsigned) := sorry --non-trivial
lemma new_lemma_29008 (h0 : functor.add_const (list (ring Type)) (finset pos)) : palindrome (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_29009 (h0 : topological_space (measure_theory.measure_space (semiring unsigned))) : topological_space.separable_space (measure_theory.measure_space (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_29010 (h0 : functor.add_const (ring (boolean_algebra.core pos)) pos) : @strong_rank_condition.{0} (boolean_algebra.core.{0} pos) (@functor.add_const.run.{0 0} (ring.{0} (boolean_algebra.core.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_29011 (h0 : preorder (add_comm_semigroup (mul_one_class (mul_one_class enat)))) (h2 : Prop) : set.is_pwo (id (fun (h1 : add_comm_semigroup (mul_one_class (mul_one_class enat))), h2)) := sorry --non-trivial
lemma new_lemma_29012 (h0 : functor.add_const (topological_space (has_nndist pos)) pos) : @irreducible_space.{0} (has_nndist.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (has_nndist.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_29013 (h0 h1 : multiset (mul_one_class ereal)) : multiset.subset h0 h1 := sorry --non-trivial
lemma new_lemma_29014 (h0 : topological_space (add_left_cancel_semigroup empty)) : locally_compact_space (add_left_cancel_semigroup empty) := sorry --non-trivial
lemma new_lemma_29015 (h1 : function.extfun Type (functor.comp group has_top)) : @is_cyclic.{0} (has_top.{0} fun_info) (@functor.comp.run.{0 0 0} group.{0} has_top.{0} fun_info (@function.extfun_app.{2 1} Type (functor.comp.{0 0 0} group.{0} has_top.{0}) h1 fun_info))  := sorry --non-trivial
lemma new_lemma_29016 (h0 : complete_lattice (canonically_ordered_comm_semiring (has_add name))) : is_compactly_generated (canonically_ordered_comm_semiring (has_add name)) := sorry --non-trivial
lemma new_lemma_29017 (h0 : topological_space (has_edist linarith.ineq)) (h1 : preorder (has_edist linarith.ineq)) : order_closed_topology (has_edist linarith.ineq) := sorry --non-trivial
lemma new_lemma_29018 (h0 : topological_space (has_neg_part (has_add Type))) : totally_disconnected_space (has_neg_part (has_add Type)) := sorry --non-trivial
lemma new_lemma_29019 (h0 : functor.add_const (add_monoid (semigroup linarith.comp)) (has_neg (has_Inf (has_neg linarith.comp)))) : @add_monoid.fg.{0} (semigroup.{0} linarith.comp) (@functor.add_const.run.{0 0} (add_monoid.{0} (semigroup.{0} linarith.comp)) (has_neg.{0} (has_Inf.{0} (has_neg.{0} linarith.comp))) h0)  := sorry --non-trivial
lemma new_lemma_29020 (h0 : function.extfun (finset Type) (has_mem.mem (normed_group empty))) : @locally_compact_space.{0} (normed_group.{0} empty) (@finset.pi.empty.{1 0} Type topological_space.{0} (normed_group.{0} empty) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (normed_group.{0} empty)) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_29021 (h0 : monoid (finset (normed_comm_ring (boolean_algebra pos)))) : monoid.fg (finset (normed_comm_ring (boolean_algebra pos))) := sorry --non-trivial
lemma new_lemma_29022 (h0 : list (has_sdiff empty)) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_29023 (h0 : ring (random_gen (random_gen (random_gen (random_gen (random_gen num)))))) : is_domain (random_gen (random_gen (random_gen (random_gen (random_gen num))))) := sorry --non-trivial
lemma new_lemma_29024 (h0 : functor.add_const (group (is_R_or_C empty)) empty) : @normalizer_condition.{0} (is_R_or_C.{0} empty) (@functor.add_const.run.{0 0} (group.{0} (is_R_or_C.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_29025 (h0 : ring (linear_ordered_field (option (option empty)))) : is_domain (linear_ordered_field (option (option empty))) := sorry --non-trivial
lemma new_lemma_29026 (h0 : functor.add_const (ordered_comm_monoid (boolean_algebra ordering)) pos) : @has_exists_mul_of_le.{0} (boolean_algebra.{0} ordering) (@functor.add_const.run.{0 0} (ordered_comm_monoid.{0} (boolean_algebra.{0} ordering)) pos h0)  := sorry --non-trivial
lemma new_lemma_29027 (h0 : group (has_bot (has_Inf real))) : normalizer_condition (has_bot (has_Inf real)) := sorry --non-trivial
lemma new_lemma_29028 (h0 : function.extfun Type complete_lattice) : @is_compactly_generated.{0} auto.case_option (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 auto.case_option)  := sorry --non-trivial
lemma new_lemma_29029 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @normal_space.{0} (canonically_ordered_add_monoid.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (canonically_ordered_add_monoid.{0} empty)) empty (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (topological_space.{0} (canonically_ordered_add_monoid.{0} empty))) (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 (functor.add_const.{0 0} (topological_space.{0} (canonically_ordered_add_monoid.{0} empty)))) empty))  := sorry --non-trivial
lemma new_lemma_29030 (h0 : topological_space num -> Prop) : @totally_disconnected_space.{0} num (@classical.epsilon.{1} (topological_space.{0} num) (@nonempty_of_inhabited.{1} (topological_space.{0} num) (@inhabited_topological_space.{0} num)) h0)  := sorry --non-trivial
lemma new_lemma_29031 (h0 : topological_space (semi_normed_ring to_additive.value_type)) : totally_disconnected_space (semi_normed_ring to_additive.value_type) := sorry --non-trivial
lemma new_lemma_29032 (h0 : functor.add_const (topological_space (boolean_algebra name)) name) : @loc_path_connected_space.{0} (boolean_algebra.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (boolean_algebra.{0} name)) name h0)  := sorry --non-trivial
lemma new_lemma_29033 (h0 : topological_space (simple_graph pos)) : irreducible_space (simple_graph pos) := sorry --non-trivial
lemma new_lemma_29034 (h0 : ordered_comm_monoid (normed_comm_ring linarith.comp)) : has_exists_mul_of_le (normed_comm_ring linarith.comp) := sorry --non-trivial
lemma new_lemma_29035 (h0 : group auto.case_option) : normalizer_condition auto.case_option := sorry --non-trivial
lemma new_lemma_29036 (h1 : topological_space std_gen) (h2 : preorder std_gen) : order_topology std_gen := sorry --non-trivial
lemma new_lemma_29037 (h0 : function.extfun (Type 1) finset) : finset.nonempty (function.extfun_app h0 (comm_group Type)) := sorry --non-trivial
lemma new_lemma_29038 (h0 : semiring (normed_comm_ring (option (option (option (option unsigned)))))) : is_noetherian_ring (normed_comm_ring (option (option (option (option unsigned))))) := sorry --non-trivial
lemma new_lemma_29039 (h0 : filter (semigroup pos)) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_29040 (h0 : complete_lattice (has_compl (random_gen string_imp))) : complete_lattice.is_Sup_finite_compact (has_compl (random_gen string_imp)) := sorry --non-trivial
lemma new_lemma_29041 (h0 : topological_space (boolean_algebra (has_add (has_neg_part name)))) : totally_disconnected_space (boolean_algebra (has_add (has_neg_part name))) := sorry --non-trivial
lemma new_lemma_29042 (h0 : functor.add_const (group (boolean_algebra.core name)) environment.implicit_infer_kind) : @normalizer_condition.{0} (boolean_algebra.core.{0} name) (@functor.add_const.run.{0 0} (group.{0} (boolean_algebra.core.{0} name)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_29043 (h0 : functor.add_const (topological_space (has_to_string pos)) linarith.comp) : @t0_space.{0} (has_to_string.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (has_to_string.{0} pos)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_29044 (h0 : monoid (ordered_comm_ring (has_add Type))) : monoid.fg (ordered_comm_ring (has_add Type)) := sorry --non-trivial
lemma new_lemma_29045 (h0 : ring (ring (boolean_algebra (boolean_algebra pos)))) : is_domain (ring (boolean_algebra (boolean_algebra pos))) := sorry --non-trivial
lemma new_lemma_29046 (h0 : topological_space (preorder num)) : path_connected_space (preorder num) := sorry --non-trivial
lemma new_lemma_29047 (h0 : topological_space (mul_one_class linarith.comp_source)) (h1 : add_group (mul_one_class linarith.comp_source)) : topological_add_group (mul_one_class linarith.comp_source) := sorry --non-trivial
lemma new_lemma_29048 (h0 : functor.add_const (topological_space (boolean_algebra.core name)) (has_add name)) : @irreducible_space.{0} (boolean_algebra.core.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (boolean_algebra.core.{0} name)) (has_add.{0} name) h0)  := sorry --non-trivial
lemma new_lemma_29049 (h0 : topological_space (add_comm_monoid ennreal)) : preirreducible_space (add_comm_monoid ennreal) := sorry --non-trivial
lemma new_lemma_29050 (h0 : functor.add_const (topological_space (complete_distrib_lattice name)) real) : @locally_compact_space.{0} (complete_distrib_lattice.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (complete_distrib_lattice.{0} name)) real h0)  := sorry --non-trivial
lemma new_lemma_29051 (h0 : not (ring num -> false)) : @is_domain.{0} num (@classical.by_contradiction'.{1} (ring.{0} num) h0)  := sorry --non-trivial
lemma new_lemma_29052 (h0 : topological_space (complete_semilattice_Sup (semiring unsigned))) : t1_space (complete_semilattice_Sup (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_29053 (h0 : functor.add_const (topological_space (has_to_string environment.implicit_infer_kind)) name) : @totally_disconnected_space.{0} (has_to_string.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (has_to_string.{0} environment.implicit_infer_kind)) name h0)  := sorry --non-trivial
lemma new_lemma_29054 (h0 : complete_lattice (linear_ordered_semiring (random_gen num))) : complete_lattice.is_Sup_finite_compact (linear_ordered_semiring (random_gen num)) := sorry --non-trivial
lemma new_lemma_29055 (h0 : topological_space (has_pos_part (has_Inf (has_pos_part (has_Inf real))))) : path_connected_space (has_pos_part (has_Inf (has_pos_part (has_Inf real)))) := sorry --non-trivial
lemma new_lemma_29056 (h0 : functor.add_const (topological_space (add_cancel_monoid pos)) name) : @discrete_topology.{0} (add_cancel_monoid.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (add_cancel_monoid.{0} pos)) name h0)  := sorry --non-trivial
lemma new_lemma_29057 (h0 : functor.add_const (function.extfun (Type 1) topological_space) name) : @preirreducible_space.{1} (has_to_string.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) topological_space.{1}) name h0) (has_to_string.{1} Type))  := sorry --non-trivial
lemma new_lemma_29058 (h0 : function.extfun Type uniform_space) : @separated_space.{0} (cancel_monoid.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (cancel_monoid.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_29059 (h0 : ring (finset name)) : rank_condition (finset name) := sorry --non-trivial
lemma new_lemma_29060 (h0 : uniform_space (ring (boolean_algebra pos))) : complete_space (ring (boolean_algebra pos)) := sorry --non-trivial
lemma new_lemma_29061 (h0 : finset (comm_group (has_to_string (has_add pos)))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_29062 (h0 : topological_space (simple_graph (has_pos_part linarith.comp))) : locally_compact_space (simple_graph (has_pos_part linarith.comp)) := sorry --non-trivial
lemma new_lemma_29063 (h0 : function.extfun Type complete_lattice) : @is_atomistic.{0} (@id.{2} Type linarith.comp) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (@id.{2} Type linarith.comp))  := sorry --non-trivial
lemma new_lemma_29064 (h0 : uniform_space (has_to_string (has_add (semigroup name)))) : separated_space (has_to_string (has_add (semigroup name))) := sorry --non-trivial
lemma new_lemma_29065 (h0 : complete_lattice (has_norm (has_norm (id unsigned)))) : is_atomistic (has_norm (has_norm (id unsigned))) := sorry --non-trivial
lemma new_lemma_29066 (h0 : functor.add_const (complete_lattice (linear_order unsigned)) empty) : @is_compactly_generated.{0} (linear_order.{0} unsigned) (@functor.add_const.run.{0 0} (complete_lattice.{0} (linear_order.{0} unsigned)) empty h0)  := sorry --non-trivial
lemma new_lemma_29067 (h0 : list (partial_order congr_arg_kind)) : palindrome h0 := sorry --non-trivial
lemma new_lemma_29068 (h0 : not (topological_space linarith.comp -> false)) : @preirreducible_space.{0} linarith.comp (@classical.by_contradiction'.{1} (topological_space.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_29069 (h0 : semiring (monoid (option unsigned))) : is_noetherian_ring (monoid (option unsigned)) := sorry --non-trivial
lemma new_lemma_29070 (h0 : functor.comp ring canonically_ordered_comm_semiring Type) : @is_principal_ideal_ring.{1} (canonically_ordered_comm_semiring.{1} Type) (@functor.comp.run.{1 1 1} ring.{1} canonically_ordered_comm_semiring.{1} Type h0)  := sorry --non-trivial
lemma new_lemma_29071 (h1 : not (topological_space (denumerable fun_info) -> false)) : @path_connected_space.{0} (denumerable.{0} fun_info) (@classical.by_contradiction'.{1} (topological_space.{0} (denumerable.{0} fun_info)) h1)  := sorry --non-trivial
lemma new_lemma_29072 (h0 : group (add_comm_monoid (ring Type))) : group.fg (add_comm_monoid (ring Type)) := sorry --non-trivial
lemma new_lemma_29073 (h0 : topological_space (has_neg_part (comm_group (comm_group (has_add Type))))) : loc_path_connected_space (has_neg_part (comm_group (comm_group (has_add Type)))) := sorry --non-trivial
lemma new_lemma_29074 (h0 : function.extfun Type list) : list.nodup (function.extfun_app h0 (topological_space string_imp)) := sorry --non-trivial
lemma new_lemma_29075 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @t1_space.{0} (canonically_ordered_add_monoid.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (canonically_ordered_add_monoid.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_29076 (h0 : functor.add_const (function.extfun Type topological_space) linarith.comp) : @preconnected_space.{0} (complete_distrib_lattice.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) linarith.comp h0) (complete_distrib_lattice.{0} name))  := sorry --non-trivial
lemma new_lemma_29077 (h0 : topological_space (has_add (semigroup (add_comm_monoid environment.implicit_infer_kind)))) : regular_space (has_add (semigroup (add_comm_monoid environment.implicit_infer_kind))) := sorry --non-trivial
lemma new_lemma_29078 (h0 : comm_group pnat -> comm_group pnat -> Prop) : symmetric h0 := sorry --non-trivial
lemma new_lemma_29079 (h0 : ring (boolean_algebra.core (has_add (finset unsigned)))) : is_principal_ideal_ring (boolean_algebra.core (has_add (finset unsigned))) := sorry --non-trivial
lemma new_lemma_29080 (h0 : semiring (linear_ordered_semiring (semiring unsigned))) : is_noetherian_ring (linear_ordered_semiring (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_29081 (h0 : uniform_space (sub_neg_monoid (finset Type))) : separated_space (sub_neg_monoid (finset Type)) := sorry --non-trivial
lemma new_lemma_29082 (h0 : not (uniform_space (random_gen (random_gen linarith.comp_source)) -> false)) : @complete_space.{0} (random_gen.{0} (random_gen.{0} linarith.comp_source)) (@classical.by_contradiction'.{1} (uniform_space.{0} (random_gen.{0} (random_gen.{0} linarith.comp_source))) h0)  := sorry --non-trivial
lemma new_lemma_29083 (h0 : topological_space (has_neg_part pos)) : sequential_space (has_neg_part pos) := sorry --non-trivial
lemma new_lemma_29084 (h2 : group (distrib (has_nnnorm (has_nnnorm fun_info)))) (h3 : subgroup (distrib (has_nnnorm (has_nnnorm fun_info)))) : subgroup.is_commutative h3 := sorry --non-trivial
lemma new_lemma_29085 (h0 : function.extfun Type group) : @is_cyclic.{0} (linear_ordered_comm_ring.{0} unsigned) (@function.extfun_app.{2 1} Type group.{0} h0 (linear_ordered_comm_ring.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_29086 (h1 : group (has_ssubset linarith.ineq)) : is_cyclic (has_ssubset linarith.ineq) := sorry --non-trivial
lemma new_lemma_29087 (h0 : fin has_zero.zero) : @totally_separated_space.{0} (normed_lattice_add_comm_group.{0} (has_Inf.{0} pos)) (@matrix.vec_empty.{0} (topological_space.{0} (normed_lattice_add_comm_group.{0} (has_Inf.{0} pos))) h0)  := sorry --non-trivial
lemma new_lemma_29088 (h0 : ring (complete_distrib_lattice (option empty))) : rank_condition (complete_distrib_lattice (option empty)) := sorry --non-trivial
lemma new_lemma_29089 (h0 : topological_space (boolean_algebra.core (has_add (cancel_monoid name)))) : discrete_topology (boolean_algebra.core (has_add (cancel_monoid name))) := sorry --non-trivial
lemma new_lemma_29090 (h0 : add_group (linear_ordered_field congr_arg_kind)) : is_add_cyclic (linear_ordered_field congr_arg_kind) := sorry --non-trivial
lemma new_lemma_29091 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @path_connected_space.{0} (has_one.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_one.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_29092 (h0 : ordered_comm_monoid (has_to_string (has_add linarith.comp))) : has_exists_mul_of_le (has_to_string (has_add linarith.comp)) := sorry --non-trivial
lemma new_lemma_29093 (h0 : ring (linear_ordered_field (option (option empty)))) : is_principal_ideal_ring (linear_ordered_field (option (option empty))) := sorry --non-trivial
lemma new_lemma_29094 (h2 : set (has_le linarith.comp_source)) : set.finite h2 := sorry --non-trivial
lemma new_lemma_29095 (h0 : has_mem.mem topological_space has_emptyc.emptyc) : @locally_compact_space.{0} (with_bot.{0} fun_info) (@function.extfun_app.{2 1} Type topological_space.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) topological_space.{0} h0) (with_bot.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_29096 (h0 : group (add_cancel_monoid environment.implicit_infer_kind)) : normalizer_condition (add_cancel_monoid environment.implicit_infer_kind) := sorry --non-trivial
lemma new_lemma_29097 (h0 : function.extfun Type add_group) : @is_add_cyclic.{0} (comm_monoid.{0} empty) (@function.extfun_app.{2 1} Type add_group.{0} h0 (comm_monoid.{0} empty))  := sorry --non-trivial
lemma new_lemma_29098 (h0 : group (semigroup (finset (has_neg (ring Type))))) : is_cyclic (semigroup (finset (has_neg (ring Type)))) := sorry --non-trivial
lemma new_lemma_29099 (h0 : functor.add_const (ring (has_neg name)) linarith.comp) : @is_principal_ideal_ring.{0} (has_neg.{0} name) (@functor.add_const.run.{0 0} (ring.{0} (has_neg.{0} name)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_29100 (h0 : complete_lattice (has_norm (has_top (has_top (has_top congr_arg_kind))))) : complete_lattice.is_Sup_finite_compact (has_norm (has_top (has_top (has_top congr_arg_kind)))) := sorry --non-trivial
lemma new_lemma_29101 (h0 h1 : multiset (nondiscrete_normed_field (nondiscrete_normed_field string.iterator_imp))) : multiset.disjoint h0 h1 := sorry --non-trivial
lemma new_lemma_29102 (h0 : complete_lattice (has_one (semiring unsigned))) : complete_lattice.is_Sup_finite_compact (has_one (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_29103 (h0 : filter (normed_comm_ring (has_add (has_add (has_add (has_to_string Type)))))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_29104 (h0 : group (mul_zero_class (has_nndist (semigroup environment.implicit_infer_kind)))) : is_cyclic (mul_zero_class (has_nndist (semigroup environment.implicit_infer_kind))) := sorry --non-trivial
lemma new_lemma_29105 (h0 : group (normed_lattice_add_comm_group (has_add linarith.comp))) : group.fg (normed_lattice_add_comm_group (has_add linarith.comp)) := sorry --non-trivial
lemma new_lemma_29106 (h0 : topological_space (random_gen (has_norm (semiring empty)))) : t0_space (random_gen (has_norm (semiring empty))) := sorry --non-trivial
lemma new_lemma_29107 (h0 : functor.add_const (list (bin_tree unsigned)) unsigned) : list.nodup (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_29108 (h3 : has_lt enat) : no_max_order enat := sorry --non-trivial
lemma new_lemma_29109 (h0 : has_mem.mem (measurable_space congr_arg_kind) has_emptyc.emptyc) : @discrete_topology.{0} (measurable_space.{0} congr_arg_kind) (@finset.pi.empty.{1 0} Type topological_space.{0} (measurable_space.{0} congr_arg_kind) h0)  := sorry --non-trivial
lemma new_lemma_29110 (h0 : complete_lattice (has_zero to_additive.value_type)) : complete_lattice.is_Sup_finite_compact (has_zero to_additive.value_type) := sorry --non-trivial
lemma new_lemma_29111 (h0 : functor.add_const (ordered_add_comm_monoid (semigroup unsigned)) pos) : @archimedean.{0} (semigroup.{0} unsigned) (@functor.add_const.run.{0 0} (ordered_add_comm_monoid.{0} (semigroup.{0} unsigned)) pos h0)  := sorry --non-trivial
lemma new_lemma_29112 (h0 : functor.add_const (list (bin_tree empty)) num) : palindrome (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_29113 (h0 : add_group (ordered_comm_group congr_arg_kind)) : is_add_cyclic (ordered_comm_group congr_arg_kind) := sorry --non-trivial
lemma new_lemma_29114 (h0 : topological_space (has_add (has_nndist (has_add pos)))) : totally_separated_space (has_add (has_nndist (has_add pos))) := sorry --non-trivial
lemma new_lemma_29115 (h0 : ring (has_div (has_compl string_imp))) : rank_condition (has_div (has_compl string_imp)) := sorry --non-trivial
lemma new_lemma_29116 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @rank_condition.{1} (has_add.{1} Type) (@function.extfun_app.{3 2} (Type 1) ring.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 ring.{1}) (has_add.{1} Type))  := sorry --non-trivial
lemma new_lemma_29117 (h0 : ring (dlist (random_gen to_additive.value_type))) : is_domain (dlist (random_gen to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_29118 (h0 : group (has_nndist (finset unsigned))) : group.fg (has_nndist (finset unsigned)) := sorry --non-trivial
lemma new_lemma_29119 (h0 : group (normed_field (random_gen (comm_ring (random_gen char))))) : is_cyclic (normed_field (random_gen (comm_ring (random_gen char)))) := sorry --non-trivial
lemma new_lemma_29120 (h0 : topological_space (with_one unsigned)) : regular_space (with_one unsigned) := sorry --non-trivial
lemma new_lemma_29121 (h0 : complete_lattice (has_pos_part (ordered_comm_monoid (ordered_comm_monoid real)))) : is_atomistic (has_pos_part (ordered_comm_monoid (ordered_comm_monoid real))) := sorry --non-trivial
lemma new_lemma_29122 (h0 : function.extfun Type ring) : @is_domain.{0} (metric_space.{0} unsigned) (@function.extfun_app.{2 1} Type ring.{0} h0 (metric_space.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_29123 (h0 : not (function.extfun Type add_group -> false)) : @is_add_cyclic.{0} (with_one.{0} fun_info) (@function.extfun_app.{2 1} Type add_group.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type add_group.{0}) h0) (with_one.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_29124 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @t0_space.{0} (has_Sup.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_Sup.{0} empty))  := sorry --non-trivial
lemma new_lemma_29125 (h0 : function.extfun Type (functor.add_const (list (has_Sup unsigned)))) : palindrome (functor.add_const.run (function.extfun_app h0 unsigned)) := sorry --non-trivial
lemma new_lemma_29126 (h0 : group (has_nndist environment.implicit_infer_kind)) : normalizer_condition (has_nndist environment.implicit_infer_kind) := sorry --non-trivial
lemma new_lemma_29127 (h1 : complete_lattice (add_monoid char)) : complete_lattice.is_Sup_finite_compact (add_monoid char) := sorry --non-trivial
lemma new_lemma_29128 (h0 : add_monoid (generalized_boolean_algebra (has_scalar Type real))) : add_monoid.fg (generalized_boolean_algebra (has_scalar Type real)) := sorry --non-trivial
lemma new_lemma_29129 (h0 : group (normed_group (random_gen to_additive.value_type))) : is_cyclic (normed_group (random_gen to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_29130 (h0 : boolean_algebra (has_add environment.implicit_infer_kind) -> Prop) : zzz_forall h0 := sorry --non-trivial
lemma new_lemma_29131 (h0 : functor.add_const (complete_lattice (ordered_ring empty)) congr_arg_kind) : @is_atomistic.{0} (ordered_ring.{0} empty) (@functor.add_const.run.{0 0} (complete_lattice.{0} (ordered_ring.{0} empty)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_29132 (h0 : semiring (linear_ordered_comm_group (has_add Type))) : is_noetherian_ring (linear_ordered_comm_group (has_add Type)) := sorry --non-trivial
lemma new_lemma_29133 (h0 : functor.add_const (filter (finset Type)) pos) : countable_Inter_filter (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_29134 (h0 : topological_space (metric_space (semiring unsigned))) : totally_disconnected_space (metric_space (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_29135 (h0 : pfun (add_comm_semigroup char) Prop) (h1 : coe_sort (pfun.dom h0)) : pfun.as_subtype h0 h1 := sorry --non-trivial
lemma new_lemma_29136 (h0 : complete_lattice (plift (semiring unsigned))) : is_compactly_generated (plift (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_29137 (h0 : group (with_zero to_additive.value_type)) : group.fg (with_zero to_additive.value_type) := sorry --non-trivial
lemma new_lemma_29138 (h0 : not (uniform_space (has_append linarith.comp_source) -> false)) : @complete_space.{0} (has_append.{0} linarith.comp_source) (@classical.by_contradiction'.{1} (uniform_space.{0} (has_append.{0} linarith.comp_source)) h0)  := sorry --non-trivial
lemma new_lemma_29139 (h0 : complete_lattice (pseudo_metric_space pos)) : is_atomistic (pseudo_metric_space pos) := sorry --non-trivial
lemma new_lemma_29140 (h0 : functor.add_const (add_group (has_edist unsigned)) empty) : @is_add_cyclic.{0} (has_edist.{0} unsigned) (@functor.add_const.run.{0 0} (add_group.{0} (has_edist.{0} unsigned)) empty h0)  := sorry --non-trivial
lemma new_lemma_29141 (h0 : not (filter num -> false)) : filter.ne_bot (classical.by_contradiction' h0) := sorry --non-trivial
lemma new_lemma_29142 (h1 : not (ring (has_compl reducibility_hints) -> false)) : @rank_condition.{0} (has_compl.{0} reducibility_hints) (@classical.by_contradiction'.{1} (ring.{0} (has_compl.{0} reducibility_hints)) h1)  := sorry --non-trivial
lemma new_lemma_29143 (h0 : functor.add_const (group (has_nndist congr_arg_kind)) num) : @group.fg.{0} (has_nndist.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (group.{0} (has_nndist.{0} congr_arg_kind)) num h0)  := sorry --non-trivial
lemma new_lemma_29144 (h0 : topological_space (semigroup (has_Inf linarith.comp))) : topological_space.separable_space (semigroup (has_Inf linarith.comp)) := sorry --non-trivial
lemma new_lemma_29145 (h0 : function.extfun Type topological_space) : @discrete_topology.{0} (semiring.{0} (option.{0} unsigned)) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (semiring.{0} (option.{0} unsigned)))  := sorry --non-trivial
lemma new_lemma_29146 (h0 : functor.add_const (topological_space (has_Inf linarith.comp)) pos) : @preirreducible_space.{0} (has_Inf.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (has_Inf.{0} linarith.comp)) pos h0)  := sorry --non-trivial
lemma new_lemma_29147 (h0 : functor.add_const (topological_space (boolean_algebra.core environment.implicit_infer_kind)) Type) : @regular_space.{0} (boolean_algebra.core.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 1} (topological_space.{0} (boolean_algebra.core.{0} environment.implicit_infer_kind)) Type h0)  := sorry --non-trivial
lemma new_lemma_29148 (h0 : functor.add_const (functor.add_const (uniform_space znum) num) empty) : @complete_space.{0} znum (@functor.add_const.run.{0 0} (uniform_space.{0} znum) num (@functor.add_const.run.{0 0} (functor.add_const.{0 0} (uniform_space.{0} znum) num) empty h0))  := sorry --non-trivial
lemma new_lemma_29149 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @strong_rank_condition.{0} (linear_ordered_field.{0} empty) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (linear_ordered_field.{0} empty))  := sorry --non-trivial
lemma new_lemma_29150 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @sequential_space.{0} (cancel_monoid.{0} ennreal) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (cancel_monoid.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_29151 (h0 : topological_space (has_emptyc (add_semigroup (random_gen linarith.comp)))) : t0_space (has_emptyc (add_semigroup (random_gen linarith.comp))) := sorry --non-trivial
lemma new_lemma_29152 (h0 : topological_space (has_Inf (has_Inf Type))) : totally_disconnected_space (has_Inf (has_Inf Type)) := sorry --non-trivial
lemma new_lemma_29153 (h0 : topological_space (mul_zero_class (complete_distrib_lattice unsigned))) : topological_space.separable_space (mul_zero_class (complete_distrib_lattice unsigned)) := sorry --non-trivial
lemma new_lemma_29154 (h0 : not (topological_space (linear_ordered_comm_group_with_zero char) -> false)) : @path_connected_space.{0} (linear_ordered_comm_group_with_zero.{0} char) (@classical.by_contradiction'.{1} (topological_space.{0} (linear_ordered_comm_group_with_zero.{0} char)) h0)  := sorry --non-trivial
lemma new_lemma_29155 (h0 : function.extfun Type ring) : @is_principal_ideal_ring.{0} (group_with_zero.{0} unsigned) (@function.extfun_app.{2 1} Type ring.{0} h0 (group_with_zero.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_29156 (h0 : complete_lattice (has_append (has_nnnorm (has_nnnorm fun_info)))) : is_compactly_generated (has_append (has_nnnorm (has_nnnorm fun_info))) := sorry --non-trivial
lemma new_lemma_29157 (h0 : function.extfun Type topological_space) : @totally_disconnected_space.{0} (mul_zero_class.{0} ennreal) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (mul_zero_class.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_29158 (h0 : function.extfun Type group) : @group.fg.{0} (boolean_algebra.core.{0} pos) (@function.extfun_app.{2 1} Type group.{0} h0 (boolean_algebra.core.{0} pos))  := sorry --non-trivial
lemma new_lemma_29159 (h0 : topological_space (encodable (has_nnnorm (random_gen linarith.ineq)))) : t0_space (encodable (has_nnnorm (random_gen linarith.ineq))) := sorry --non-trivial
lemma new_lemma_29160 (h0 : finset (has_neg (has_nndist linarith.comp))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_29161 (h0 : group (complete_distrib_lattice pos)) : group.fg (complete_distrib_lattice pos) := sorry --non-trivial
lemma new_lemma_29162 (h0 : function.extfun Type complete_lattice) : @is_compactly_generated.{0} (add_comm_monoid.{0} unsigned) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (add_comm_monoid.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_29163 (h0 : complete_lattice (uniform_space (metric_space char)) -> Prop) (h1 : Exists (fun (x : complete_lattice (uniform_space (metric_space char))), h0 x)) : complete_lattice.is_Sup_finite_compact (uniform_space (metric_space char)) := sorry --non-trivial
lemma new_lemma_29164 (h0 : topological_space (linear_ordered_add_comm_group (has_nnnorm linarith.ineq))) : t0_space (linear_ordered_add_comm_group (has_nnnorm linarith.ineq)) := sorry --non-trivial
lemma new_lemma_29165 (h1 : function.extfun Type monoid) : @monoid.fg.{0} (semiring.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type monoid.{0} h1 (semiring.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_29166 (h0 : group (boolean_algebra.core linarith.comp)) : group.fg (boolean_algebra.core linarith.comp) := sorry --non-trivial
lemma new_lemma_29167 (h0 : filter (boolean_algebra.core (mul_zero_class pos))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_29168 (h0 : functor.add_const (function.extfun Type topological_space) (ordered_ring name)) : @locally_compact_space.{0} (has_to_string.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) (ordered_ring.{0} name) h0) (has_to_string.{0} name))  := sorry --non-trivial
lemma new_lemma_29169 (h0 : topological_space (finset (boolean_algebra.core Type))) : t1_space (finset (boolean_algebra.core Type)) := sorry --non-trivial
lemma new_lemma_29170 (h0 : filter (comm_ring string_imp)) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_29171 (h0 : has_mem.mem (with_bot fun_info) has_emptyc.emptyc) : @is_atomistic.{0} (with_bot.{0} fun_info) (@finset.pi.empty.{1 0} Type complete_lattice.{0} (with_bot.{0} fun_info) h0)  := sorry --non-trivial
lemma new_lemma_29172 (h0 : ring (mul_zero_class (semiring (semiring (semiring (semiring congr_arg_kind)))))) : strong_rank_condition (mul_zero_class (semiring (semiring (semiring (semiring congr_arg_kind))))) := sorry --non-trivial
lemma new_lemma_29173 (h0 : list (semigroup (semiring unsigned))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_29174 (h1 : add_group (comm_ring (has_nnnorm char))) : is_add_cyclic (comm_ring (has_nnnorm char)) := sorry --non-trivial
lemma new_lemma_29175 (h0 : function.extfun Type ring) : @is_principal_ideal_ring.{0} (comm_semigroup.{0} real) (@function.extfun_app.{2 1} Type ring.{0} h0 (comm_semigroup.{0} real))  := sorry --non-trivial
lemma new_lemma_29176 (h0 : functor.add_const (function.extfun Type ordered_add_comm_monoid) pos) : @archimedean.{0} (has_zero.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type ordered_add_comm_monoid.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type ordered_add_comm_monoid.{0}) pos h0) (has_zero.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_29177 (h0 : function.extfun Type semiring) : @is_noetherian_ring.{0} (has_to_string.{0} num) (@function.extfun_app.{2 1} Type semiring.{0} h0 (has_to_string.{0} num))  := sorry --non-trivial
lemma new_lemma_29178 (h1 : group (id string_imp)) : is_cyclic (id string_imp) := sorry --non-trivial
lemma new_lemma_29179 (h0 : topological_space (mul_zero_class (semiring unsigned))) : totally_separated_space (mul_zero_class (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_29180 (h0 : topological_space (has_pos_part Type)) : sequential_space (has_pos_part Type) := sorry --non-trivial
lemma new_lemma_29181 (h0 : topological_space (has_ssubset (mul_one_class string.iterator_imp))) : path_connected_space (has_ssubset (mul_one_class string.iterator_imp)) := sorry --non-trivial
lemma new_lemma_29182 (h0 : ring (has_zero (ring (ring (has_to_string (finset pos)))))) : is_principal_ideal_ring (has_zero (ring (ring (has_to_string (finset pos))))) := sorry --non-trivial
lemma new_lemma_29183 (h0 : topological_space (canonically_linear_ordered_monoid pos)) : preirreducible_space (canonically_linear_ordered_monoid pos) := sorry --non-trivial
lemma new_lemma_29184 (h0 : has_mem.mem ring has_emptyc.emptyc) : @is_domain.{0} (group_with_zero.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type ring.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) ring.{0} h0) (group_with_zero.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_29185 (h0 : list (id to_additive.value_type)) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_29186 (h0 : fin has_zero.zero) : @has_exists_mul_of_le.{1} (sub_neg_monoid.{1} Type) (@matrix.vec_empty.{1} (ordered_comm_monoid.{1} (sub_neg_monoid.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_29187 (h0 : group (cancel_monoid environment.implicit_infer_kind)) : group.fg (cancel_monoid environment.implicit_infer_kind) := sorry --non-trivial
lemma new_lemma_29188 (h0 : topological_space (add_cancel_monoid (has_Inf (has_Inf linarith.comp)))) : normal_space (add_cancel_monoid (has_Inf (has_Inf linarith.comp))) := sorry --non-trivial
lemma new_lemma_29189 (h0 : group (complete_semilattice_Sup num)) : normalizer_condition (complete_semilattice_Sup num) := sorry --non-trivial
lemma new_lemma_29190 (h0 : functor.add_const (topological_space (comm_group pos)) unsigned) : @irreducible_space.{0} (comm_group.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (comm_group.{0} pos)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_29191 (h0 : functor.add_const (add_group (finset Type)) environment.implicit_infer_kind) : @is_add_cyclic.{1} (finset.{1} Type) (@functor.add_const.run.{1 0} (add_group.{1} (finset.{1} Type)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_29192 (h0 : functor.add_const (topological_space (has_neg_part unsigned)) pos) : @sequential_space.{0} (has_neg_part.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (has_neg_part.{0} unsigned)) pos h0)  := sorry --non-trivial
lemma new_lemma_29193 (h0 : filter (add_comm_monoid (comm_group pos))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_29194 (h1 : list (distrib_lattice char)) : list.nodup h1 := sorry --non-trivial
lemma new_lemma_29195 (h2 : function.extfun Type topological_space) : @totally_disconnected_space.{0} (complete_semilattice_Sup.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h2 (complete_semilattice_Sup.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_29196 (h0 : fin has_zero.zero) : @is_principal_ideal_ring.{0} (normed_lattice_add_comm_group.{0} pos) (@matrix.vec_empty.{0} (ring.{0} (normed_lattice_add_comm_group.{0} pos)) h0)  := sorry --non-trivial
lemma new_lemma_29197 (h0 : topological_space (has_neg (finset (option (has_nndist environment.implicit_infer_kind))))) : loc_path_connected_space (has_neg (finset (option (has_nndist environment.implicit_infer_kind)))) := sorry --non-trivial
lemma new_lemma_29198 (h0 : functor.add_const (cancel_comm_monoid_with_zero (add_group congr_arg_kind)) empty) : @unique_factorization_monoid.{0} (add_group.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (cancel_comm_monoid_with_zero.{0} (add_group.{0} congr_arg_kind)) empty h0)  := sorry --non-trivial
lemma new_lemma_29199 (h0 : functor.add_const (complete_lattice (semigroup unsigned)) unsigned) : @is_compactly_generated.{0} (semigroup.{0} unsigned) (@functor.add_const.run.{0 0} (complete_lattice.{0} (semigroup.{0} unsigned)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_29200 (h0 : functor.add_const (topological_space (semigroup Type)) Type) : @totally_disconnected_space.{1} (semigroup.{1} Type) (@functor.add_const.run.{1 1} (topological_space.{1} (semigroup.{1} Type)) Type h0)  := sorry --non-trivial
lemma new_lemma_29201 (h0 : functor.add_const (group (has_add unsigned)) Type) : @group.fg.{0} (has_add.{0} unsigned) (@functor.add_const.run.{0 1} (group.{0} (has_add.{0} unsigned)) Type h0)  := sorry --non-trivial
lemma new_lemma_29202 (h0 : list (as_linear_order unsigned)) : palindrome h0 := sorry --non-trivial
lemma new_lemma_29203 (h0 : function.extfun Type uniform_space) : @complete_space.{0} (mul_zero_class.{0} num) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (mul_zero_class.{0} num))  := sorry --non-trivial
lemma new_lemma_29204 (h0 : functor.add_const (topological_space (has_to_string name)) (comm_group (comm_group name))) : @t0_space.{0} (has_to_string.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (has_to_string.{0} name)) (comm_group.{0} (comm_group.{0} name)) h0)  := sorry --non-trivial
lemma new_lemma_29205 (h0 : topological_space (has_bot name)) : discrete_topology (has_bot name) := sorry --non-trivial
lemma new_lemma_29206 (h0 : not (function.extfun Type topological_space -> false)) : @locally_compact_space.{0} (semiring.{0} linarith.ineq) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (semiring.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_29207 (h0 : complete_lattice (topological_space (has_append (has_nnnorm linarith.ineq)))) : complete_lattice.is_Sup_finite_compact (topological_space (has_append (has_nnnorm linarith.ineq))) := sorry --non-trivial
lemma new_lemma_29208 (h0 : function.extfun Type ring) : @is_domain.{0} (has_union.{0} fun_info) (@function.extfun_app.{2 1} Type ring.{0} h0 (has_union.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_29209 (h0 : topological_space (preorder empty)) : preconnected_space (preorder empty) := sorry --non-trivial
lemma new_lemma_29210 (h0 : function.extfun nat fin) : @irreducible_space.{0} (ordered_comm_ring.{0} pos) (@matrix.vec_empty.{0} (topological_space.{0} (ordered_comm_ring.{0} pos)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_29211 (h0 : group (has_ssubset (has_nnnorm linarith.ineq))) : group.fg (has_ssubset (has_nnnorm linarith.ineq)) := sorry --non-trivial
lemma new_lemma_29212 (h0 : uniform_space (encodable (has_nnnorm to_additive.value_type))) : complete_space (encodable (has_nnnorm to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_29213 (h0 : topological_space (normed_group (has_top (has_top linarith.comp_source)))) : totally_disconnected_space (normed_group (has_top (has_top linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_29214 (h0 : option (topological_space (add_group (semiring unsigned)))) (h1 : topological_space (add_group (semiring unsigned))) : topological_space.separable_space (add_group (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_29215 (h0 : functor.add_const (complete_lattice (has_neg Type)) environment.implicit_infer_kind) : @is_compactly_generated.{1} (has_neg.{1} Type) (@functor.add_const.run.{1 0} (complete_lattice.{1} (has_neg.{1} Type)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_29216 (h0 : ring empty) : strong_rank_condition empty := sorry --non-trivial
lemma new_lemma_29217 (h0 : filter (cancel_monoid Type)) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_29218 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @irreducible_space.{0} (random_gen.{0} (random_gen.{0} linarith.comp_source)) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (random_gen.{0} (random_gen.{0} linarith.comp_source)))  := sorry --non-trivial
lemma new_lemma_29219 (h0 : functor.add_const (functor.add_const (uniform_space linarith.comp) Type) linarith.comp) : @complete_space.{0} linarith.comp (@functor.add_const.run.{0 1} (uniform_space.{0} linarith.comp) Type (@functor.add_const.run.{0 0} (functor.add_const.{0 1} (uniform_space.{0} linarith.comp) Type) linarith.comp h0))  := sorry --non-trivial
lemma new_lemma_29220 (h0 : ring bool) : strong_rank_condition bool := sorry --non-trivial
lemma new_lemma_29221 (h0 : list (semigroup (has_neg_part pos))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_29222 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_noetherian_ring.{0} (pseudo_metric_space.{0} empty) (@function.extfun_app.{2 1} Type semiring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 semiring.{0}) (pseudo_metric_space.{0} empty))  := sorry --non-trivial
lemma new_lemma_29223 (h1 : ring (has_compl (comm_ring (comm_ring (comm_ring (comm_ring (comm_ring char))))))) : rank_condition (has_compl (comm_ring (comm_ring (comm_ring (comm_ring (comm_ring char)))))) := sorry --non-trivial
lemma new_lemma_29224 (h0 : functor.add_const (group (linear_ordered_cancel_comm_monoid empty)) unsigned) : @normalizer_condition.{0} (linear_ordered_cancel_comm_monoid.{0} empty) (@functor.add_const.run.{0 0} (group.{0} (linear_ordered_cancel_comm_monoid.{0} empty)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_29225 (h0 : complete_lattice (has_ssubset (add_comm_semigroup linarith.ineq))) : complete_lattice.is_Sup_finite_compact (has_ssubset (add_comm_semigroup linarith.ineq)) := sorry --non-trivial
lemma new_lemma_29226 (h0 : function.extfun Type (functor.comp ordered_add_comm_monoid cancel_monoid)) : @archimedean.{0} (cancel_monoid.{0} name) (@functor.comp.run.{0 0 0} ordered_add_comm_monoid.{0} cancel_monoid.{0} name (@function.extfun_app.{2 1} Type (functor.comp.{0 0 0} ordered_add_comm_monoid.{0} cancel_monoid.{0}) h0 name))  := sorry --non-trivial
lemma new_lemma_29227 (h0 : uniform_space ereal) (h1 : set ereal) : is_separated h1 := sorry --non-trivial
lemma new_lemma_29228 (h0 : has_lt (non_unital_non_assoc_semiring enat)) : no_max_order (non_unital_non_assoc_semiring enat) := sorry --non-trivial
lemma new_lemma_29229 (h0 : group (has_emptyc (has_norm empty))) : group.fg (has_emptyc (has_norm empty)) := sorry --non-trivial
lemma new_lemma_29230 (h0 : functor.add_const (functor.add_const (ordered_add_comm_monoid Type) Type) Type) : @archimedean.{1} Type (@functor.add_const.run.{1 1} (ordered_add_comm_monoid.{1} Type) Type (@functor.add_const.run.{1 1} (functor.add_const.{1 1} (ordered_add_comm_monoid.{1} Type) Type) Type h0))  := sorry --non-trivial
lemma new_lemma_29231 (h0 : fin has_zero.zero) : @is_cyclic.{0} (add_comm_monoid.{0} real) (@matrix.vec_empty.{0} (group.{0} (add_comm_monoid.{0} real)) h0)  := sorry --non-trivial
lemma new_lemma_29232 (h0 : functor.add_const (uniform_space (has_nndist unsigned)) (option empty)) : @separated_space.{0} (has_nndist.{0} unsigned) (@functor.add_const.run.{0 0} (uniform_space.{0} (has_nndist.{0} unsigned)) (option.{0} empty) h0)  := sorry --non-trivial
lemma new_lemma_29233 (h0 : has_scalar linarith.comp congr_arg_kind) (h1 : has_scalar (mul_opposite linarith.comp) congr_arg_kind) : is_central_scalar linarith.comp congr_arg_kind := sorry --non-trivial
lemma new_lemma_29234 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_domain.{0} (has_bot.{0} real) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (has_bot.{0} real))  := sorry --non-trivial
lemma new_lemma_29235 (h0 : group (has_emptyc (random_gen (random_gen to_additive.value_type)))) : normalizer_condition (has_emptyc (random_gen (random_gen to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_29236 (h1 : complete_lattice (linear_order char)) : is_compactly_generated (linear_order char) := sorry --non-trivial
lemma new_lemma_29237 (h0 : complete_lattice (comm_semigroup Type)) : is_compactly_generated (comm_semigroup Type) := sorry --non-trivial
lemma new_lemma_29238 (h0 : topological_space (complete_linear_order empty)) : loc_path_connected_space (complete_linear_order empty) := sorry --non-trivial
lemma new_lemma_29239 (h0 : topological_space (with_one (has_nnnorm linarith.comp_source))) : totally_disconnected_space (with_one (has_nnnorm linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_29240 (h0 : topological_space (mul_zero_class congr_arg_kind)) : path_connected_space (mul_zero_class congr_arg_kind) := sorry --non-trivial
lemma new_lemma_29241 (h0 : add_monoid (has_add (has_zero (add_cancel_monoid (finset (add_cancel_monoid name)))))) : add_monoid.fg (has_add (has_zero (add_cancel_monoid (finset (add_cancel_monoid name))))) := sorry --non-trivial
lemma new_lemma_29242 (h0 : topological_space (plift (semiring empty))) : preirreducible_space (plift (semiring empty)) := sorry --non-trivial
lemma new_lemma_29243 (h0 : complete_lattice (ordered_comm_ring Type)) : is_atomistic (ordered_comm_ring Type) := sorry --non-trivial
lemma new_lemma_29244 (h0 : uniform_space (has_inv to_additive.value_type)) : complete_space (has_inv to_additive.value_type) := sorry --non-trivial
lemma new_lemma_29245 (h0 : functor.comp ring finset Type) : @is_principal_ideal_ring.{1} (finset.{1} Type) (@functor.comp.run.{1 1 1} ring.{1} finset.{1} Type h0)  := sorry --non-trivial
lemma new_lemma_29246 (h0 : topological_space (ordered_cancel_add_comm_monoid (option (option (option (option ennreal)))))) : preirreducible_space (ordered_cancel_add_comm_monoid (option (option (option (option ennreal))))) := sorry --non-trivial
lemma new_lemma_29247 (h0 : topological_space (non_assoc_semiring unsigned)) : irreducible_space (non_assoc_semiring unsigned) := sorry --non-trivial
lemma new_lemma_29248 (h0 : function.extfun Type group) : @group.fg.{0} (metric_space.{0} num) (@function.extfun_app.{2 1} Type group.{0} h0 (metric_space.{0} num))  := sorry --non-trivial
lemma new_lemma_29249 (h0 : ring (canonically_linear_ordered_monoid congr_arg_kind)) : strong_rank_condition (canonically_linear_ordered_monoid congr_arg_kind) := sorry --non-trivial
lemma new_lemma_29250 (h1 : topological_space (fintype linarith.ineq)) : path_connected_space (fintype linarith.ineq) := sorry --non-trivial
lemma new_lemma_29251 (h0 : functor.add_const (function.extfun Type monoid) pos) : @monoid.fg.{0} (has_zero.{0} linarith.comp) (@function.extfun_app.{2 1} Type monoid.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type monoid.{0}) pos h0) (has_zero.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_29252 (h0 : function.extfun Type group) : @is_cyclic.{0} (has_inv.{0} (has_top.{0} to_additive.value_type)) (@function.extfun_app.{2 1} Type group.{0} h0 (has_inv.{0} (has_top.{0} to_additive.value_type)))  := sorry --non-trivial
lemma new_lemma_29253 (h0 : topological_space (monoid_with_zero num)) : normal_space (monoid_with_zero num) := sorry --non-trivial
lemma new_lemma_29254 (h0 : topological_space rat) : locally_compact_space rat := sorry --non-trivial
lemma new_lemma_29255 (h0 : ring (sub_neg_monoid (has_bot real))) : strong_rank_condition (sub_neg_monoid (has_bot real)) := sorry --non-trivial
lemma new_lemma_29256 (h0 : topological_space (has_top (has_top linarith.comp_source))) : irreducible_space (has_top (has_top linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_29257 (h0 : function.extfun Type (functor.add_const (complete_lattice (ordered_ring unsigned)))) : @complete_lattice.is_Sup_finite_compact.{0} (ordered_ring.{0} unsigned) (@functor.add_const.run.{0 0} (complete_lattice.{0} (ordered_ring.{0} unsigned)) num (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (complete_lattice.{0} (ordered_ring.{0} unsigned))) h0 num))  := sorry --non-trivial
lemma new_lemma_29258 (h0 : ring (canonically_linear_ordered_monoid (has_add (has_Inf (has_pos_part real))))) : is_domain (canonically_linear_ordered_monoid (has_add (has_Inf (has_pos_part real)))) := sorry --non-trivial
lemma new_lemma_29259 (h0 : ring (monoid (option (option unsigned)))) : rank_condition (monoid (option (option unsigned))) := sorry --non-trivial
lemma new_lemma_29260 (h0 : not (add_monoid (complete_linear_order num) -> false)) : @add_monoid.fg.{0} (complete_linear_order.{0} num) (@classical.by_contradiction'.{1} (add_monoid.{0} (complete_linear_order.{0} num)) h0)  := sorry --non-trivial
lemma new_lemma_29261 (h0 : topological_space (linear_ordered_cancel_comm_monoid congr_arg_kind)) : preirreducible_space (linear_ordered_cancel_comm_monoid congr_arg_kind) := sorry --non-trivial
lemma new_lemma_29262 (h0 : filter (with_zero (random_gen to_additive.value_type))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_29263 (h0 : functor.add_const (add_monoid (has_pos_part linarith.comp)) (has_add linarith.comp)) : @add_monoid.fg.{0} (has_pos_part.{0} linarith.comp) (@functor.add_const.run.{0 0} (add_monoid.{0} (has_pos_part.{0} linarith.comp)) (has_add.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_29264 (h0 : filter (has_zero (finset name))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_29265 (h0 : uniform_space (ordered_cancel_add_comm_monoid (option (option empty)))) : complete_space (ordered_cancel_add_comm_monoid (option (option empty))) := sorry --non-trivial
lemma new_lemma_29266 (h0 : complete_lattice (has_nndist (has_Inf (has_pos_part linarith.comp)))) : is_compactly_generated (has_nndist (has_Inf (has_pos_part linarith.comp))) := sorry --non-trivial
lemma new_lemma_29267 (h0 : ring (has_top (has_top (has_top fun_info)))) : rank_condition (has_top (has_top (has_top fun_info))) := sorry --non-trivial
lemma new_lemma_29268 (h0 : has_le (has_norm (has_norm string_imp))) (h1 : not (function.extfun Type has_norm -> false)) : is_min (function.extfun_app (classical.by_contradiction' h1) (has_norm string_imp)) := sorry --non-trivial
lemma new_lemma_29269 (h0 : topological_space (denumerable (has_nnnorm (has_nnnorm linarith.comp_source)))) : t0_space (denumerable (has_nnnorm (has_nnnorm linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_29270 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : filter.ne_bot (function.extfun_app (function.extfun_app h0 filter) (has_to_string num)) := sorry --non-trivial
lemma new_lemma_29271 (h0 : functor.add_const (ordered_comm_monoid (add_cancel_monoid Type)) (has_neg_part (comm_group (has_zero pos)))) : @has_exists_mul_of_le.{1} (add_cancel_monoid.{1} Type) (@functor.add_const.run.{1 0} (ordered_comm_monoid.{1} (add_cancel_monoid.{1} Type)) (has_neg_part.{0} (comm_group.{0} (has_zero.{0} pos))) h0)  := sorry --non-trivial
lemma new_lemma_29272 (h0 : not (ring (add_monoid fun_info) -> false)) : @rank_condition.{0} (add_monoid.{0} fun_info) (@classical.by_contradiction'.{1} (ring.{0} (add_monoid.{0} fun_info)) h0)  := sorry --non-trivial
lemma new_lemma_29273 (h0 : ring (ordered_cancel_add_comm_monoid (option unsigned))) : strong_rank_condition (ordered_cancel_add_comm_monoid (option unsigned)) := sorry --non-trivial
lemma new_lemma_29274 (h0 : not (complete_lattice (has_emptyc fun_info) -> false)) : @complete_lattice.is_Sup_finite_compact.{0} (has_emptyc.{0} fun_info) (@classical.by_contradiction'.{1} (complete_lattice.{0} (has_emptyc.{0} fun_info)) h0)  := sorry --non-trivial
lemma new_lemma_29275 (h0 : monoid (has_zero (normed_comm_ring linarith.comp))) : monoid.fg (has_zero (normed_comm_ring linarith.comp)) := sorry --non-trivial
lemma new_lemma_29276 (h0 : ring (has_compl (has_nnnorm string.iterator_imp))) : rank_condition (has_compl (has_nnnorm string.iterator_imp)) := sorry --non-trivial
lemma new_lemma_29277 (h0 : topological_space (linear_ordered_semiring linarith.comp)) : discrete_topology (linear_ordered_semiring linarith.comp) := sorry --non-trivial
lemma new_lemma_29278 (h0 : topological_space (linear_ordered_add_comm_group (has_inv (random_gen (random_gen fun_info))))) : t0_space (linear_ordered_add_comm_group (has_inv (random_gen (random_gen fun_info)))) := sorry --non-trivial
lemma new_lemma_29279 (h0 : function.extfun Type group) : @is_simple_group.{0} (pseudo_metric_space.{0} name) (@function.extfun_app.{2 1} Type group.{0} h0 (pseudo_metric_space.{0} name))  := sorry --non-trivial
lemma new_lemma_29280 (h0 : ring (distrib (mul_one_class enat))) : rank_condition (distrib (mul_one_class enat)) := sorry --non-trivial
lemma new_lemma_29281 (h0 : ring (has_nndist (has_add environment.implicit_infer_kind))) : strong_rank_condition (has_nndist (has_add environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_29282 (h0 : prod (canonically_ordered_monoid (semiring congr_arg_kind)) (canonically_ordered_monoid (semiring congr_arg_kind))) : id_rel h0 := sorry --non-trivial
lemma new_lemma_29283 (h0 : complete_lattice (distrib_lattice to_additive.value_type)) : complete_lattice.is_Sup_finite_compact (distrib_lattice to_additive.value_type) := sorry --non-trivial
lemma new_lemma_29284 (h1 h2 : multiset environment.projection_info) : multiset.disjoint h1 h2 := sorry --non-trivial
lemma new_lemma_29285 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @preirreducible_space.{0} (ordered_comm_monoid.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (ordered_comm_monoid.{0} pos))  := sorry --non-trivial
lemma new_lemma_29286 (h0 : has_lt string.iterator_imp) : no_max_order string.iterator_imp := sorry --non-trivial
lemma new_lemma_29287 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @add_monoid.fg.{0} (finset.{0} real) (@function.extfun_app.{2 1} Type add_monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 add_monoid.{0}) (finset.{0} real))  := sorry --non-trivial
lemma new_lemma_29288 (h0 : complete_lattice (ring (ring environment.implicit_infer_kind))) : complete_lattice.is_Sup_finite_compact (ring (ring environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_29289 (h0 : list (normed_group (comm_ring (has_ssubset (linear_ordered_add_comm_group fun_info))))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_29290 (h0 : topological_space (mul_zero_class Type)) : preirreducible_space (mul_zero_class Type) := sorry --non-trivial
lemma new_lemma_29291 (h0 : functor.add_const (function.extfun Type topological_space) environment.implicit_infer_kind) : @discrete_topology.{0} (has_add.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) environment.implicit_infer_kind h0) (has_add.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_29292 (h0 : filter (id (semiring unsigned))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_29293 (h0 : functor.comp topological_space comm_group pos) : @sequential_space.{0} (comm_group.{0} pos) (@functor.comp.run.{0 0 0} topological_space.{0} comm_group.{0} pos h0)  := sorry --non-trivial
lemma new_lemma_29294 (h0 : has_mem.mem (semiring fun_info) has_emptyc.emptyc) : @discrete_topology.{0} (semiring.{0} fun_info) (@finset.pi.empty.{1 0} Type topological_space.{0} (semiring.{0} fun_info) h0)  := sorry --non-trivial
lemma new_lemma_29295 (h0 : functor.add_const (topological_space auto.case_option) congr_arg_kind) : @topological_space.separable_space.{0} auto.case_option (@functor.add_const.run.{0 0} (topological_space.{0} auto.case_option) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_29296 (h0 : ring (linear_ordered_field empty)) : is_domain (linear_ordered_field empty) := sorry --non-trivial
lemma new_lemma_29297 (h0 : functor.add_const (add_monoid (has_nndist pos)) Type) : @add_monoid.fg.{0} (has_nndist.{0} pos) (@functor.add_const.run.{0 1} (add_monoid.{0} (has_nndist.{0} pos)) Type h0)  := sorry --non-trivial
lemma new_lemma_29298 (h0 : pnat) (h1 : thunk (list pnat)) (h2 : ulower pnat) : pnat.coprime (@list.ilast'.{0} pnat h0 (@trace_call_stack.{0} (list.{0} pnat) h1)) (@ulower.up.{0} pnat encodable.pnat h2)  := sorry --non-trivial
lemma new_lemma_29299 (h0 : functor.add_const (uniform_space (linear_order unsigned)) empty) : @complete_space.{0} (linear_order.{0} unsigned) (@functor.add_const.run.{0 0} (uniform_space.{0} (linear_order.{0} unsigned)) empty h0)  := sorry --non-trivial
lemma new_lemma_29300 (h0 : complete_lattice (simple_graph (has_pos_part Type))) : complete_lattice.is_Sup_finite_compact (simple_graph (has_pos_part Type)) := sorry --non-trivial
lemma new_lemma_29301 (h0 : functor.add_const (ring (canonically_ordered_comm_semiring pos)) linarith.comp) : @is_domain.{0} (canonically_ordered_comm_semiring.{0} pos) (@functor.add_const.run.{0 0} (ring.{0} (canonically_ordered_comm_semiring.{0} pos)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_29302 (h0 : function.extfun Type topological_space) : @normal_space.{0} (random_gen.{0} fun_info) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (random_gen.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_29303 (h0 : complete_lattice (distrib_lattice (has_inv (has_inv (has_inv fun_info))))) : is_atomistic (distrib_lattice (has_inv (has_inv (has_inv fun_info)))) := sorry --non-trivial
lemma new_lemma_29304 (h0 : monoid (has_top (semiring (semiring (id linarith.comp))))) : monoid.fg (has_top (semiring (semiring (id linarith.comp)))) := sorry --non-trivial
lemma new_lemma_29305 (h0 : complete_lattice (finset empty)) : complete_lattice.is_Sup_finite_compact (finset empty) := sorry --non-trivial
lemma new_lemma_29306 (h0 : topological_space (left_cancel_monoid (semiring (semiring num)))) : topological_space.separable_space (left_cancel_monoid (semiring (semiring num))) := sorry --non-trivial
lemma new_lemma_29307 (h0 : functor.add_const (topological_space (has_bot pos)) Type) : @regular_space.{0} (has_bot.{0} pos) (@functor.add_const.run.{0 1} (topological_space.{0} (has_bot.{0} pos)) Type h0)  := sorry --non-trivial
lemma new_lemma_29308 (h0 : function.extfun Type filter) : filter.ne_bot (function.extfun_app h0 (has_nndist ennreal)) := sorry --non-trivial
lemma new_lemma_29309 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @rank_condition.{0} (has_add.{0} linarith.comp) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (has_add.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_29310 (h0 : ring (has_add (sub_neg_monoid (sub_neg_monoid (sub_neg_monoid (sub_neg_monoid Type)))))) : rank_condition (has_add (sub_neg_monoid (sub_neg_monoid (sub_neg_monoid (sub_neg_monoid Type))))) := sorry --non-trivial
lemma new_lemma_29311 (h0 : complete_lattice (boolean_algebra.core pos)) : complete_lattice.is_Sup_finite_compact (boolean_algebra.core pos) := sorry --non-trivial
lemma new_lemma_29312 (h0 : add_monoid (has_star (has_top (semiring (semiring (semiring congr_arg_kind)))))) : add_monoid.fg (has_star (has_top (semiring (semiring (semiring congr_arg_kind))))) := sorry --non-trivial
lemma new_lemma_29313 (h1 : has_lt (has_nnnorm linarith.comp_source)) : no_max_order (has_nnnorm linarith.comp_source) := sorry --non-trivial
lemma new_lemma_29314 (h0 : uniform_space (has_add (boolean_algebra.core Type))) : separated_space (has_add (boolean_algebra.core Type)) := sorry --non-trivial
lemma new_lemma_29315 (h0 : function.extfun Type complete_lattice) : @is_atomistic.{0} (omega_complete_partial_order.{0} unsigned) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (omega_complete_partial_order.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_29316 (h0 : ordered_comm_monoid (cancel_monoid name)) : has_exists_mul_of_le (cancel_monoid name) := sorry --non-trivial
lemma new_lemma_29317 (h0 : functor.add_const (function.extfun Type group) unsigned) : @group.fg.{0} (has_add.{0} pos) (@function.extfun_app.{2 1} Type group.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type group.{0}) unsigned h0) (has_add.{0} pos))  := sorry --non-trivial
lemma new_lemma_29318 (h0 : uniform_space (filter num)) : separated_space (filter num) := sorry --non-trivial
lemma new_lemma_29319 (h0 : group (option empty)) : normalizer_condition (option empty) := sorry --non-trivial
lemma new_lemma_29320 (h0 : filter (left_cancel_semigroup (semiring (semiring (semiring (semiring congr_arg_kind)))))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_29321 (h0 : prod (canonically_linear_ordered_monoid (option ennreal)) (canonically_linear_ordered_monoid (option ennreal))) : id_rel h0 := sorry --non-trivial
lemma new_lemma_29322 (h0 : prod (boolean_algebra.core congr_arg_kind) (boolean_algebra.core congr_arg_kind)) : id_rel h0 := sorry --non-trivial
lemma new_lemma_29323 (h0 : topological_space (measurable_space (semiring (has_top congr_arg_kind)))) : preirreducible_space (measurable_space (semiring (has_top congr_arg_kind))) := sorry --non-trivial
lemma new_lemma_29324 (h0 : functor.add_const (group (has_to_string environment.implicit_infer_kind)) linarith.comp) : @normalizer_condition.{0} (has_to_string.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (group.{0} (has_to_string.{0} environment.implicit_infer_kind)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_29325 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @strong_rank_condition.{0} (has_to_string.{0} ennreal) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (has_to_string.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_29326 (h0 : topological_space (add_comm_monoid (has_neg environment.implicit_infer_kind))) : path_connected_space (add_comm_monoid (has_neg environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_29327 (h0 : functor.comp topological_space ring unsigned) : @totally_separated_space.{0} (ring.{0} unsigned) (@functor.comp.run.{0 0 0} topological_space.{0} ring.{0} unsigned h0)  := sorry --non-trivial
lemma new_lemma_29328 (h0 : has_mem.mem num has_emptyc.emptyc) : @separated_space.{0} num (@finset.pi.empty.{1 0} Type uniform_space.{0} num h0)  := sorry --non-trivial
lemma new_lemma_29329 (h0 : ring (boolean_algebra (comm_group (comm_group name)))) : rank_condition (boolean_algebra (comm_group (comm_group name))) := sorry --non-trivial
lemma new_lemma_29330 (h0 : functor.comp topological_space linear_ordered_add_comm_group_with_top ennreal) : @path_connected_space.{0} (linear_ordered_add_comm_group_with_top.{0} ennreal) (@functor.comp.run.{0 0 0} topological_space.{0} linear_ordered_add_comm_group_with_top.{0} ennreal h0)  := sorry --non-trivial
lemma new_lemma_29331 (h0 : group (comm_ring (has_top to_additive.value_type))) : group.fg (comm_ring (has_top to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_29332 (h0 : functor.add_const (topological_space (ordered_comm_ring Type)) Type) : @discrete_topology.{1} (ordered_comm_ring.{1} Type) (@functor.add_const.run.{1 1} (topological_space.{1} (ordered_comm_ring.{1} Type)) Type h0)  := sorry --non-trivial
lemma new_lemma_29333 (h0 h1 : multiset (normed_field linarith.ineq)) : multiset.subset h0 h1 := sorry --non-trivial
lemma new_lemma_29334 (h0 : topological_space (has_Inf (ring linarith.comp))) : t0_space (has_Inf (ring linarith.comp)) := sorry --non-trivial
lemma new_lemma_29335 (h0 : prod (mul_zero_class (semiring num)) (mul_zero_class (semiring num))) : id_rel h0 := sorry --non-trivial
lemma new_lemma_29336 (h0 : topological_space (add_left_cancel_monoid (random_gen char))) : totally_disconnected_space (add_left_cancel_monoid (random_gen char)) := sorry --non-trivial
lemma new_lemma_29337 (h0 : ring (semi_normed_comm_ring (mul_one_class std_gen))) : rank_condition (semi_normed_comm_ring (mul_one_class std_gen)) := sorry --non-trivial
lemma new_lemma_29338 (h0 : complete_lattice (generalized_boolean_algebra (has_neg Type))) : complete_lattice.is_Sup_finite_compact (generalized_boolean_algebra (has_neg Type)) := sorry --non-trivial
lemma new_lemma_29339 (h2 : function.extfun Type uniform_space) : @separated_space.{0} (measurable_space.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type uniform_space.{0} h2 (measurable_space.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_29340 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @preconnected_space.{0} (canonically_linear_ordered_monoid.{0} real) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (canonically_linear_ordered_monoid.{0} real))  := sorry --non-trivial
lemma new_lemma_29341 (h0 : add_monoid (comm_semigroup name)) : add_monoid.fg (comm_semigroup name) := sorry --non-trivial
lemma new_lemma_29342 (h0 : monoid (with_one (has_inv (random_gen fun_info)))) : monoid.fg (with_one (has_inv (random_gen fun_info))) := sorry --non-trivial
lemma new_lemma_29343 (h0 : function.extfun (Type 1) (functor.comp group has_neg_part)) : @is_simple_group.{1} (has_neg_part.{1} Type) (@functor.comp.run.{1 1 1} group.{1} has_neg_part.{1} Type (@function.extfun_app.{3 2} (Type 1) (functor.comp.{1 1 1} group.{1} has_neg_part.{1}) h0 Type))  := sorry --non-trivial
lemma new_lemma_29344 (h0 : semiring (complete_distrib_lattice num)) : is_noetherian_ring (complete_distrib_lattice num) := sorry --non-trivial
lemma new_lemma_29345 (h0 : function.extfun Type topological_space) : @t0_space.{0} (with_bot.{0} (has_ssubset.{0} linarith.ineq)) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (with_bot.{0} (has_ssubset.{0} linarith.ineq)))  := sorry --non-trivial
lemma new_lemma_29346 (h0 : function.extfun (Type 1) group) : @normalizer_condition.{1} (complete_distrib_lattice.{1} Type) (@function.extfun_app.{3 2} (Type 1) group.{1} h0 (complete_distrib_lattice.{1} Type))  := sorry --non-trivial
lemma new_lemma_29347 (h0 : function.extfun Type list) : list.nodup (function.extfun_app h0 (free_add_monoid unsigned)) := sorry --non-trivial
lemma new_lemma_29348 (h0 : topological_space (has_emptyc to_additive.value_type)) : t0_space (has_emptyc to_additive.value_type) := sorry --non-trivial
lemma new_lemma_29349 (h0 : topological_space (has_nndist (option unsigned))) : t1_space (has_nndist (option unsigned)) := sorry --non-trivial
lemma new_lemma_29350 (h0 : complete_lattice (semi_normed_comm_ring fun_info)) : complete_lattice.is_Sup_finite_compact (semi_normed_comm_ring fun_info) := sorry --non-trivial
lemma new_lemma_29351 (h0 : ring (topological_space fun_info)) : rank_condition (topological_space fun_info) := sorry --non-trivial
lemma new_lemma_29352 (h0 : topological_space (has_ssubset (random_gen fun_info))) : t0_space (has_ssubset (random_gen fun_info)) := sorry --non-trivial
lemma new_lemma_29353 (h1 : topological_space (add_monoid (fintype reducibility_hints))) : totally_disconnected_space (add_monoid (fintype reducibility_hints)) := sorry --non-trivial
lemma new_lemma_29354 (h0 : topological_space (ordered_comm_monoid real)) : path_connected_space (ordered_comm_monoid real) := sorry --non-trivial
lemma new_lemma_29355 (h1 : topological_space (complete_semilattice_Sup num)) : totally_separated_space (complete_semilattice_Sup num) := sorry --non-trivial
lemma new_lemma_29356 (h0 : filter (random_gen empty)) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_29357 (h0 : function.extfun Type topological_space) : @discrete_topology.{0} (monoid.{0} (option.{0} pos)) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (monoid.{0} (option.{0} pos)))  := sorry --non-trivial
lemma new_lemma_29358 (h0 : not (function.extfun Type topological_space -> false)) : @path_connected_space.{0} (has_one.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (has_one.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_29359 (h3 : semiring char) (h4 : ideal char) : ideal.is_prime h4 := sorry --non-trivial
lemma new_lemma_29360 (h0 : functor.add_const (functor.add_const (ordered_comm_monoid Type) Type) Type) : @has_exists_mul_of_le.{1} Type (@functor.add_const.run.{1 1} (ordered_comm_monoid.{1} Type) Type (@functor.add_const.run.{1 1} (functor.add_const.{1 1} (ordered_comm_monoid.{1} Type) Type) Type h0))  := sorry --non-trivial
lemma new_lemma_29361 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @archimedean.{0} (normed_comm_ring.{0} ennreal) (@function.extfun_app.{2 1} Type ordered_add_comm_monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ordered_add_comm_monoid.{0}) (normed_comm_ring.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_29362 (h0 : function.extfun (finset Type) (has_mem.mem (with_bot num))) : @is_atomistic.{0} (with_bot.{0} num) (@finset.pi.empty.{1 0} Type complete_lattice.{0} (with_bot.{0} num) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (with_bot.{0} num)) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_29363 (h0 : monoid (has_neg_part (has_add (boolean_algebra (has_add Type))))) : monoid.fg (has_neg_part (has_add (boolean_algebra (has_add Type)))) := sorry --non-trivial
lemma new_lemma_29364 (h0 : function.extfun Type uniform_space) : @separated_space.{0} (with_bot.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (with_bot.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_29365 (h0 : topological_space (with_bot (semiring empty))) : totally_separated_space (with_bot (semiring empty)) := sorry --non-trivial
lemma new_lemma_29366 (h0 : set (nondiscrete_normed_field string.iterator_imp -> linarith.ineq)) : set.separates_points h0 := sorry --non-trivial
lemma new_lemma_29367 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_cyclic.{0} (with_one.{0} linarith.comp) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (with_one.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_29368 (h0 : topological_space (ring (has_neg (has_neg (finset name))))) : normal_space (ring (has_neg (has_neg (finset name)))) := sorry --non-trivial
lemma new_lemma_29369 (h0 : topological_space (comm_ring (has_ssubset (has_ssubset linarith.comp_source)))) : path_connected_space (comm_ring (has_ssubset (has_ssubset linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_29370 (h0 : functor.add_const (topological_space (has_add linarith.comp)) (finset linarith.comp)) : @locally_compact_space.{0} (has_add.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (has_add.{0} linarith.comp)) (finset.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_29371 (h0 : topological_space (ring (finset (ring linarith.comp)))) : totally_disconnected_space (ring (finset (ring linarith.comp))) := sorry --non-trivial
lemma new_lemma_29372 (h0 : ring (linear_ordered_comm_group congr_arg_kind)) : is_principal_ideal_ring (linear_ordered_comm_group congr_arg_kind) := sorry --non-trivial
lemma new_lemma_29373 (h0 : ring (has_nnnorm (mul_one_class char))) : rank_condition (has_nnnorm (mul_one_class char)) := sorry --non-trivial
lemma new_lemma_29374 (h0 : topological_space (ordered_comm_monoid (has_Inf pos))) : locally_compact_space (ordered_comm_monoid (has_Inf pos)) := sorry --non-trivial
lemma new_lemma_29375 (h0 : topological_space (has_ssubset environment.projection_info)) (h1 : add_group (has_ssubset environment.projection_info)) : topological_add_group (has_ssubset environment.projection_info) := sorry --non-trivial
lemma new_lemma_29376 (h0 : group (boolean_algebra.core (finset name))) : group.fg (boolean_algebra.core (finset name)) := sorry --non-trivial
lemma new_lemma_29377 (h0 : topological_space (boolean_algebra.core (has_add (has_to_string pos)))) : totally_disconnected_space (boolean_algebra.core (has_add (has_to_string pos))) := sorry --non-trivial
lemma new_lemma_29378 (h0 : topological_space (comm_monoid (option empty))) : preirreducible_space (comm_monoid (option empty)) := sorry --non-trivial
lemma new_lemma_29379 (h0 : monoid (has_Sup empty)) : monoid.fg (has_Sup empty) := sorry --non-trivial
lemma new_lemma_29380 (h0 : not (function.extfun Type semiring -> false)) : @is_noetherian_ring.{0} num (@function.extfun_app.{2 1} Type semiring.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type semiring.{0}) h0) num)  := sorry --non-trivial
lemma new_lemma_29381 (h0 : functor.add_const (function.extfun Type ring) linarith.comp) : @is_domain.{0} (has_Inf.{0} pos) (@function.extfun_app.{2 1} Type ring.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type ring.{0}) linarith.comp h0) (has_Inf.{0} pos))  := sorry --non-trivial
lemma new_lemma_29382 (h0 : ring (cancel_monoid unsigned)) : strong_rank_condition (cancel_monoid unsigned) := sorry --non-trivial
lemma new_lemma_29383 (h0 : topological_space (has_compl (random_gen (random_gen (random_gen to_additive.value_type))))) : totally_disconnected_space (has_compl (random_gen (random_gen (random_gen to_additive.value_type)))) := sorry --non-trivial
lemma new_lemma_29384 (h0 : not (filter (measurable_space.dynkin_system num) -> false)) : filter.ne_bot (classical.by_contradiction' h0) := sorry --non-trivial
lemma new_lemma_29385 (h0 : group (id linarith.comp)) : normalizer_condition (id linarith.comp) := sorry --non-trivial
lemma new_lemma_29386 (h0 : complete_lattice (ring (has_neg (has_neg pos)))) : is_atomistic (ring (has_neg (has_neg pos))) := sorry --non-trivial
lemma new_lemma_29387 (h0 : topological_space (boolean_algebra.core (has_pos_part pos))) : t0_space (boolean_algebra.core (has_pos_part pos)) := sorry --non-trivial
lemma new_lemma_29388 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @preconnected_space.{1} (has_nndist.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 topological_space.{1}) (has_nndist.{1} Type))  := sorry --non-trivial
lemma new_lemma_29389 (h0 : uniform_space (free_add_monoid fun_info)) : complete_space (free_add_monoid fun_info) := sorry --non-trivial
lemma new_lemma_29390 (h0 : random_gen (random_gen char) -> random_gen (random_gen char) -> Prop) : is_total_preorder (random_gen (random_gen char)) h0 := sorry --non-trivial
lemma new_lemma_29391 (h0 : ring (cancel_monoid (cancel_monoid Type))) : rank_condition (cancel_monoid (cancel_monoid Type)) := sorry --non-trivial
lemma new_lemma_29392 (h0 : add_group (has_ssubset (random_gen (random_gen (random_gen char))))) : is_add_cyclic (has_ssubset (random_gen (random_gen (random_gen char)))) := sorry --non-trivial
lemma new_lemma_29393 (h0 : group (has_norm (has_nnnorm fun_info))) : group.fg (has_norm (has_nnnorm fun_info)) := sorry --non-trivial
lemma new_lemma_29394 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @normal_space.{0} (has_add.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_add.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_29395 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @separated_space.{0} (semigroup.{0} empty) (@function.extfun_app.{2 1} Type uniform_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 uniform_space.{0}) (semigroup.{0} empty))  := sorry --non-trivial
lemma new_lemma_29396 (h1 : topological_space (add_cancel_comm_monoid (random_gen (random_gen (random_gen char))))) : t0_space (add_cancel_comm_monoid (random_gen (random_gen (random_gen char)))) := sorry --non-trivial
lemma new_lemma_29397 (h0 : list (add_comm_monoid environment.implicit_infer_kind)) : palindrome h0 := sorry --non-trivial
lemma new_lemma_29398 (h0 : topological_space (with_bot (semiring (semiring (semiring linarith.comp))))) : totally_disconnected_space (with_bot (semiring (semiring (semiring linarith.comp)))) := sorry --non-trivial
lemma new_lemma_29399 (h0 : function.extfun (Type 1) ring) : @is_principal_ideal_ring.{1} (normed_comm_ring.{1} Type) (@function.extfun_app.{3 2} (Type 1) ring.{1} h0 (normed_comm_ring.{1} Type))  := sorry --non-trivial
lemma new_lemma_29400 (h0 : list (has_Inf (has_neg Type))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_29401 (h0 : monoid (has_top (has_norm string_imp))) : monoid.fg (has_top (has_norm string_imp)) := sorry --non-trivial
lemma new_lemma_29402 (h0 : topological_space (has_neg Type)) : preirreducible_space (has_neg Type) := sorry --non-trivial
lemma new_lemma_29403 (h0 : prod num num) : id_rel h0 := sorry --non-trivial
lemma new_lemma_29404 (h0 : ordered_comm_monoid (generalized_boolean_algebra (ring linarith.comp))) : has_exists_mul_of_le (generalized_boolean_algebra (ring linarith.comp)) := sorry --non-trivial
lemma new_lemma_29405 (h0 : set (has_append environment.projection_info)) : set.finite h0 := sorry --non-trivial
lemma new_lemma_29406 (h0 : functor.add_const (function.extfun (Type 1) complete_lattice) linarith.comp) : @is_compactly_generated.{1} (ring.{1} Type) (@function.extfun_app.{3 2} (Type 1) complete_lattice.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) complete_lattice.{1}) linarith.comp h0) (ring.{1} Type))  := sorry --non-trivial
lemma new_lemma_29407 (h0 : function.extfun Type ring) : @rank_condition.{0} (boolean_algebra.{0} unsigned) (@function.extfun_app.{2 1} Type ring.{0} h0 (boolean_algebra.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_29408 (h0 : ring (has_ssubset (mul_one_class string.iterator_imp))) : strong_rank_condition (has_ssubset (mul_one_class string.iterator_imp)) := sorry --non-trivial
lemma new_lemma_29409 (h0 : function.extfun Type topological_space) : @path_connected_space.{0} (canonically_ordered_comm_semiring.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (canonically_ordered_comm_semiring.{0} name))  := sorry --non-trivial
lemma new_lemma_29410 (h0 : functor.add_const (semiring (add_group congr_arg_kind)) unsigned) : @is_noetherian_ring.{0} (add_group.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (semiring.{0} (add_group.{0} congr_arg_kind)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_29411 (h0 : topological_space (mul_one_class (add_comm_semigroup ereal))) : path_connected_space (mul_one_class (add_comm_semigroup ereal)) := sorry --non-trivial
lemma new_lemma_29412 (h0 : topological_space (canonically_linear_ordered_monoid pos)) : locally_compact_space (canonically_linear_ordered_monoid pos) := sorry --non-trivial
lemma new_lemma_29413 (h0 : functor.comp list semigroup (finset pos)) : palindrome (functor.comp.run h0) := sorry --non-trivial
lemma new_lemma_29414 (h0 : topological_space (comm_ring linarith.comp_source)) : path_connected_space (comm_ring linarith.comp_source) := sorry --non-trivial
lemma new_lemma_29415 (h0 : functor.add_const (function.extfun Type ring) Type) : @rank_condition.{0} (has_add.{0} pos) (@function.extfun_app.{2 1} Type ring.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type ring.{0}) Type h0) (has_add.{0} pos))  := sorry --non-trivial
lemma new_lemma_29416 (h0 : complete_lattice (has_add real)) : is_atomistic (has_add real) := sorry --non-trivial
lemma new_lemma_29417 (h0 : add_monoid (measurable_space congr_arg_kind)) : add_monoid.fg (measurable_space congr_arg_kind) := sorry --non-trivial
lemma new_lemma_29418 (h0 : topological_space (semiring string_imp)) : totally_separated_space (semiring string_imp) := sorry --non-trivial
lemma new_lemma_29419 (h0 : topological_space (complete_linear_order num)) : totally_disconnected_space (complete_linear_order num) := sorry --non-trivial
lemma new_lemma_29420 (h0 : functor.add_const (function.extfun Type topological_space) linarith.comp) : @discrete_topology.{0} (ordered_comm_monoid.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) linarith.comp h0) (ordered_comm_monoid.{0} pos))  := sorry --non-trivial
lemma new_lemma_29421 (h0 : ordered_comm_monoid (generalized_boolean_algebra (ring Type))) : has_exists_mul_of_le (generalized_boolean_algebra (ring Type)) := sorry --non-trivial
lemma new_lemma_29422 (h0 : ordered_add_comm_monoid (option congr_arg_kind)) : archimedean (option congr_arg_kind) := sorry --non-trivial
lemma new_lemma_29423 (h0 : functor.add_const (topological_space (has_zero linarith.comp)) (has_Inf pos)) : @irreducible_space.{0} (has_zero.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (has_zero.{0} linarith.comp)) (has_Inf.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_29424 (h0 : ring (normed_group (has_top fun_info))) : is_domain (normed_group (has_top fun_info)) := sorry --non-trivial
lemma new_lemma_29425 (h0 : has_mem.mem complete_lattice has_emptyc.emptyc) : @is_atomistic.{0} (linear_ordered_semiring.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) complete_lattice.{0} h0) (linear_ordered_semiring.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_29426 (h0 : fin has_zero.zero) : @locally_compact_space.{0} (ordered_comm_monoid.{0} linarith.comp) (@matrix.vec_empty.{0} (topological_space.{0} (ordered_comm_monoid.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_29427 (h0 : add_monoid (comm_group ennreal)) : add_monoid.fg (comm_group ennreal) := sorry --non-trivial
lemma new_lemma_29428 (h0 : function.extfun (Type 1) list) : palindrome (function.extfun_app h0 (generalized_boolean_algebra Type)) := sorry --non-trivial
lemma new_lemma_29429 (h0 : functor.add_const (list (boolean_algebra pos)) pos) : list.nodup (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_29430 (h1 : topological_space (comm_ring string_imp)) : t0_space (comm_ring string_imp) := sorry --non-trivial
lemma new_lemma_29431 (h0 : functor.add_const (function.extfun (Type 1) ordered_comm_monoid) name) : @has_exists_mul_of_le.{1} Type (@function.extfun_app.{3 2} (Type 1) ordered_comm_monoid.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) ordered_comm_monoid.{1}) name h0) Type)  := sorry --non-trivial
lemma new_lemma_29432 (h0 : topological_space (measurable_space (has_inv (has_inv linarith.comp_source)))) : totally_separated_space (measurable_space (has_inv (has_inv linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_29433 (h0 : topological_space (linear_ordered_comm_ring empty)) : normal_space (linear_ordered_comm_ring empty) := sorry --non-trivial
lemma new_lemma_29434 (h0 : functor.add_const (topological_space (has_Sup empty)) empty) : @normal_space.{0} (has_Sup.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (has_Sup.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_29435 (h0 : cancel_comm_monoid_with_zero (semigroup (boolean_algebra Type))) : unique_factorization_monoid (semigroup (boolean_algebra Type)) := sorry --non-trivial
lemma new_lemma_29436 (h0 : add_group (id (has_norm (has_norm num)))) : is_add_cyclic (id (has_norm (has_norm num))) := sorry --non-trivial
lemma new_lemma_29437 (h0 : uniform_space (add_comm_monoid pos)) : complete_space (add_comm_monoid pos) := sorry --non-trivial
lemma new_lemma_29438 (h0 : function.extfun Type add_monoid) : @add_monoid.fg.{0} (has_dist.{0} unsigned) (@function.extfun_app.{2 1} Type add_monoid.{0} h0 (has_dist.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_29439 (h0 : topological_space (has_compl (has_nnnorm linarith.ineq))) : t0_space (has_compl (has_nnnorm linarith.ineq)) := sorry --non-trivial
lemma new_lemma_29440 (h0 : function.extfun (Type 1) topological_space) : @sequential_space.{1} (normed_lattice_add_comm_group.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} h0 (normed_lattice_add_comm_group.{1} Type))  := sorry --non-trivial
lemma new_lemma_29441 (h0 : topological_space (boolean_algebra.core (has_neg (has_neg Type)))) : locally_compact_space (boolean_algebra.core (has_neg (has_neg Type))) := sorry --non-trivial
lemma new_lemma_29442 (h0 : semiring (comm_semigroup (has_bot real))) : is_noetherian_ring (comm_semigroup (has_bot real)) := sorry --non-trivial
lemma new_lemma_29443 (h0 : prod (semigroup (finset name)) (semigroup (finset name))) : id_rel h0 := sorry --non-trivial
lemma new_lemma_29444 (h0 : group (semigroup (has_add (boolean_algebra linarith.comp)))) : group.fg (semigroup (has_add (boolean_algebra linarith.comp))) := sorry --non-trivial
lemma new_lemma_29445 (h0 : monoid (boolean_algebra.core (ring pos))) : monoid.fg (boolean_algebra.core (ring pos)) := sorry --non-trivial
lemma new_lemma_29446 (h0 : topological_space (has_zero (has_to_string (ring unsigned)))) : preconnected_space (has_zero (has_to_string (ring unsigned))) := sorry --non-trivial
lemma new_lemma_29447 (h0 : topological_space (has_union (semiring (semiring empty)))) : totally_disconnected_space (has_union (semiring (semiring empty))) := sorry --non-trivial
lemma new_lemma_29448 (h0 : list (semigroup (finset environment.implicit_infer_kind))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_29449 (h0 : group (has_zero name)) : is_cyclic (has_zero name) := sorry --non-trivial
lemma new_lemma_29450 (h0 : filter (boolean_algebra (has_add (has_neg_part Type)))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_29451 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @totally_disconnected_space.{0} (with_bot.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (with_bot.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_29452 (h0 : topological_space (linear_ordered_field (option empty))) : t1_space (linear_ordered_field (option empty)) := sorry --non-trivial
lemma new_lemma_29453 (h0 : topological_space (add_cancel_monoid (option name))) : totally_disconnected_space (add_cancel_monoid (option name)) := sorry --non-trivial
lemma new_lemma_29454 (h0 : function.extfun Type filter) : filter.ne_bot (function.extfun_app h0 (mul_zero_class empty)) := sorry --non-trivial
lemma new_lemma_29455 (h0 : function.extfun (Type 1) group) : @is_simple_group.{1} (finset.{1} Type) (@function.extfun_app.{3 2} (Type 1) group.{1} h0 (finset.{1} Type))  := sorry --non-trivial
lemma new_lemma_29456 (h0 : functor.add_const (topological_space (has_neg_part name)) linarith.comp) : @discrete_topology.{0} (has_neg_part.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (has_neg_part.{0} name)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_29457 (h0 : functor.add_const (topological_space (has_to_string Type)) (normed_comm_ring environment.implicit_infer_kind)) : @irreducible_space.{1} (has_to_string.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (has_to_string.{1} Type)) (normed_comm_ring.{0} environment.implicit_infer_kind) h0)  := sorry --non-trivial
lemma new_lemma_29458 (h0 : functor.add_const (topological_space (linear_ordered_comm_ring unsigned)) (semiring num)) : @locally_compact_space.{0} (linear_ordered_comm_ring.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (linear_ordered_comm_ring.{0} unsigned)) (semiring.{0} num) h0)  := sorry --non-trivial
lemma new_lemma_29459 (h0 : uniform_space (with_one (with_bot (random_gen (with_bot (with_bot string_imp)))))) : complete_space (with_one (with_bot (random_gen (with_bot (with_bot string_imp))))) := sorry --non-trivial
lemma new_lemma_29460 (h0 : function.extfun Type monoid) : @monoid.fg.{0} (finset.{0} linarith.comp) (@function.extfun_app.{2 1} Type monoid.{0} h0 (finset.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_29461 (h0 : ring (has_dist (option empty))) : strong_rank_condition (has_dist (option empty)) := sorry --non-trivial
lemma new_lemma_29462 (h0 : not (function.extfun Type topological_space -> false)) : @discrete_topology.{0} (@id.{2} Type empty) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (@id.{2} Type empty))  := sorry --non-trivial
lemma new_lemma_29463 (h0 : not (functor.add_const Prop (has_top empty) -> false)) : functor.add_const.run (classical.by_contradiction' h0) := sorry --non-trivial
lemma new_lemma_29464 (h1 : ring (has_div string.iterator_imp)) : rank_condition (has_div string.iterator_imp) := sorry --non-trivial
lemma new_lemma_29465 (h0 : function.extfun Type topological_space) : @loc_path_connected_space.{0} (comm_group.{0} ennreal) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (comm_group.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_29466 (h0 : add_group (measurable_space (has_norm (semiring unsigned)))) : is_add_cyclic (measurable_space (has_norm (semiring unsigned))) := sorry --non-trivial
lemma new_lemma_29467 (h0 : topological_space (has_neg unsigned)) : totally_separated_space (has_neg unsigned) := sorry --non-trivial
lemma new_lemma_29468 (h0 : not (complete_lattice (linear_ordered_comm_ring congr_arg_kind) -> false)) : @is_compactly_generated.{0} (linear_ordered_comm_ring.{0} congr_arg_kind) (@classical.by_contradiction'.{1} (complete_lattice.{0} (linear_ordered_comm_ring.{0} congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_29469 (h0 : function.extfun Type complete_lattice) : @is_atomistic.{0} (complete_semilattice_Sup.{0} linarith.ineq) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (complete_semilattice_Sup.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_29470 (h1 : ring (uniform_space string.iterator_imp)) : rank_condition (uniform_space string.iterator_imp) := sorry --non-trivial
lemma new_lemma_29471 (h0 : uniform_space (has_neg (canonically_linear_ordered_add_monoid pos))) : separated_space (has_neg (canonically_linear_ordered_add_monoid pos)) := sorry --non-trivial
lemma new_lemma_29472 (h0 : topological_space (semiring (has_top linarith.comp_source))) : irreducible_space (semiring (has_top linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_29473 (h0 : not (uniform_space (denumerable (has_nnnorm linarith.ineq)) -> false)) : @complete_space.{0} (denumerable.{0} (has_nnnorm.{0} linarith.ineq)) (@classical.by_contradiction'.{1} (uniform_space.{0} (denumerable.{0} (has_nnnorm.{0} linarith.ineq))) h0)  := sorry --non-trivial
lemma new_lemma_29474 (h0 : functor.add_const (add_monoid (normed_comm_ring unsigned)) Type) : @add_monoid.fg.{0} (normed_comm_ring.{0} unsigned) (@functor.add_const.run.{0 1} (add_monoid.{0} (normed_comm_ring.{0} unsigned)) Type h0)  := sorry --non-trivial
lemma new_lemma_29475 (h0 : group (free_add_monoid num)) : group.fg (free_add_monoid num) := sorry --non-trivial
lemma new_lemma_29476 (h1 : has_mul (has_append string_imp)) (h2 : has_zero (has_append string_imp)) : no_zero_divisors (has_append string_imp) := sorry --non-trivial
lemma new_lemma_29477 (h0 : function.extfun (finset (Type -> Type)) (has_mem.mem monoid)) : @monoid.fg.{0} (semiring.{0} num) (@function.extfun_app.{2 1} Type monoid.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) monoid.{0} (@function.extfun_app.{2 0} (finset.{1} (Type → Type)) (@has_mem.mem.{1 1} (Type → Type) (finset.{1} (Type → Type)) (@finset.has_mem.{1} (Type → Type)) monoid.{0}) h0 (@has_emptyc.emptyc.{1} (finset.{1} (Type → Type)) (@finset.has_emptyc.{1} (Type → Type))))) (semiring.{0} num))  := sorry --non-trivial
lemma new_lemma_29478 (h0 : add_monoid (has_neg (finset (finset Type)))) : add_monoid.fg (has_neg (finset (finset Type))) := sorry --non-trivial
lemma new_lemma_29479 (h0 : functor.add_const (complete_lattice (cancel_monoid name)) pos) : @is_atomistic.{0} (cancel_monoid.{0} name) (@functor.add_const.run.{0 0} (complete_lattice.{0} (cancel_monoid.{0} name)) pos h0)  := sorry --non-trivial
lemma new_lemma_29480 (h0 : topological_space (with_one (comm_ring linarith.ineq))) : path_connected_space (with_one (comm_ring linarith.ineq)) := sorry --non-trivial
lemma new_lemma_29481 (h0 : finset (simple_graph (semigroup (has_neg Type)))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_29482 (h2 : set (add_comm_semigroup enat -> char)) : set.separates_points h2 := sorry --non-trivial
lemma new_lemma_29483 (h0 : list (linear_ordered_cancel_comm_monoid empty)) : palindrome h0 := sorry --non-trivial
lemma new_lemma_29484 (h0 : uniform_space (sub_neg_monoid name)) : separated_space (sub_neg_monoid name) := sorry --non-trivial
lemma new_lemma_29485 (h0 : functor.add_const (topological_space (mul_zero_class name)) Type) : @locally_compact_space.{0} (mul_zero_class.{0} name) (@functor.add_const.run.{0 1} (topological_space.{0} (mul_zero_class.{0} name)) Type h0)  := sorry --non-trivial
lemma new_lemma_29486 (h0 : topological_space (linear_ordered_field unsigned)) : preconnected_space (linear_ordered_field unsigned) := sorry --non-trivial
lemma new_lemma_29487 (h0 : topological_space (normed_linear_ordered_group congr_arg_kind)) : irreducible_space (normed_linear_ordered_group congr_arg_kind) := sorry --non-trivial
lemma new_lemma_29488 (h0 : function.extfun Type group) : @is_simple_group.{0} (has_nndist.{0} name) (@function.extfun_app.{2 1} Type group.{0} h0 (has_nndist.{0} name))  := sorry --non-trivial
lemma new_lemma_29489 (h0 : has_mem.mem (has_emptyc linarith.comp) has_emptyc.emptyc) : @locally_compact_space.{0} (has_emptyc.{0} linarith.comp) (@finset.pi.empty.{1 0} Type topological_space.{0} (has_emptyc.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_29490 (h0 : functor.add_const (function.extfun Type ring) name) : @rank_condition.{0} (has_add.{0} (has_pos_part.{0} ordering)) (@function.extfun_app.{2 1} Type ring.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type ring.{0}) name h0) (has_add.{0} (has_pos_part.{0} ordering)))  := sorry --non-trivial
lemma new_lemma_29491 (h0 : functor.add_const (topological_space (ring unsigned)) pos) : @locally_compact_space.{0} (ring.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (ring.{0} unsigned)) pos h0)  := sorry --non-trivial
lemma new_lemma_29492 (h0 : function.extfun Type group) : @is_cyclic.{0} (filter.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type group.{0} h0 (filter.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_29493 (h0 : group (boolean_algebra (has_to_string (has_add pos)))) : is_simple_group (boolean_algebra (has_to_string (has_add pos))) := sorry --non-trivial
lemma new_lemma_29494 (h0 : topological_space (has_add (has_add (ring linarith.comp)))) : topological_space.separable_space (has_add (has_add (ring linarith.comp))) := sorry --non-trivial
lemma new_lemma_29495 (h0 : functor.add_const (topological_space (has_add linarith.comp)) (has_neg (has_zero (has_add Type)))) : @sequential_space.{0} (has_add.{0} linarith.comp) (@functor.add_const.run.{0 1} (topological_space.{0} (has_add.{0} linarith.comp)) (has_neg.{1} (has_zero.{1} (has_add.{1} Type))) h0)  := sorry --non-trivial
lemma new_lemma_29496 (h0 : not (topological_space (non_unital_non_assoc_semiring string.iterator_imp) -> false)) : @totally_disconnected_space.{0} (non_unital_non_assoc_semiring.{0} string.iterator_imp) (@classical.by_contradiction'.{1} (topological_space.{0} (non_unital_non_assoc_semiring.{0} string.iterator_imp)) h0)  := sorry --non-trivial
lemma new_lemma_29497 (h0 : functor.add_const (monoid (has_zero linarith.comp)) (has_to_string linarith.comp)) : @monoid.fg.{0} (has_zero.{0} linarith.comp) (@functor.add_const.run.{0 0} (monoid.{0} (has_zero.{0} linarith.comp)) (has_to_string.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_29498 (h0 : list (comm_group (has_neg_part (comm_group (has_to_string pos))))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_29499 (h0 : functor.add_const (functor.add_const (complete_lattice name) unsigned) num) : @is_atomistic.{0} name (@functor.add_const.run.{0 0} (complete_lattice.{0} name) unsigned (@functor.add_const.run.{0 0} (functor.add_const.{0 0} (complete_lattice.{0} name) unsigned) num h0))  := sorry --non-trivial
lemma new_lemma_29500 (h0 : functor.add_const (function.extfun (Type 1) group) (ring pos)) : @is_simple_group.{1} (normed_comm_ring.{1} Type) (@function.extfun_app.{3 2} (Type 1) group.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) group.{1}) (ring.{0} pos) h0) (normed_comm_ring.{1} Type))  := sorry --non-trivial
lemma new_lemma_29501 (h0 : group (has_neg (finset linarith.comp))) : is_simple_group (has_neg (finset linarith.comp)) := sorry --non-trivial
lemma new_lemma_29502 (h0 : topological_space (complete_distrib_lattice pos)) : loc_path_connected_space (complete_distrib_lattice pos) := sorry --non-trivial
lemma new_lemma_29503 (h0 : finset (has_zero unsigned)) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_29504 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @complete_space.{0} (add_cancel_monoid.{0} linarith.comp) (@function.extfun_app.{2 1} Type uniform_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 uniform_space.{0}) (add_cancel_monoid.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_29505 (h0 : add_group (complete_distrib_lattice (semigroup name))) : is_add_cyclic (complete_distrib_lattice (semigroup name)) := sorry --non-trivial
lemma new_lemma_29506 (h0 : add_monoid (has_Inf (has_Inf real))) : add_monoid.fg (has_Inf (has_Inf real)) := sorry --non-trivial
lemma new_lemma_29507 (h0 : complete_lattice (fintype linarith.comp_source)) : complete_lattice.is_Sup_finite_compact (fintype linarith.comp_source) := sorry --non-trivial
lemma new_lemma_29508 (h0 : topological_space (boolean_algebra (boolean_algebra (finset (has_Inf Type))))) : totally_disconnected_space (boolean_algebra (boolean_algebra (finset (has_Inf Type)))) := sorry --non-trivial
lemma new_lemma_29509 (h0 : topological_space (with_zero (random_gen linarith.ineq))) : irreducible_space (with_zero (random_gen linarith.ineq)) := sorry --non-trivial
lemma new_lemma_29510 (h0 : complete_lattice (ordered_comm_ring (has_add (has_Inf pos)))) : complete_lattice.is_Sup_finite_compact (ordered_comm_ring (has_add (has_Inf pos))) := sorry --non-trivial
lemma new_lemma_29511 (h0 : topological_space (plift (semiring congr_arg_kind))) : sequential_space (plift (semiring congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_29512 (h0 : uniform_space (canonically_ordered_comm_semiring (has_nndist Type))) : separated_space (canonically_ordered_comm_semiring (has_nndist Type)) := sorry --non-trivial
lemma new_lemma_29513 (h0 : monoid (normed_comm_ring Type)) : monoid.fg (normed_comm_ring Type) := sorry --non-trivial
lemma new_lemma_29514 (h0 : functor.add_const (topological_space (has_star empty)) congr_arg_kind) : @t0_space.{0} (has_star.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (has_star.{0} empty)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_29515 (h0 : not (function.extfun Type ring -> false)) : @rank_condition.{0} (has_one.{0} empty) (@function.extfun_app.{2 1} Type ring.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type ring.{0}) h0) (has_one.{0} empty))  := sorry --non-trivial
lemma new_lemma_29516 (h0 : group (has_top (with_bot (semiring (semiring empty))))) : normalizer_condition (has_top (with_bot (semiring (semiring empty)))) := sorry --non-trivial
lemma new_lemma_29517 (h0 : functor.add_const (filter (ordered_comm_ring name)) (has_neg Type)) : countable_Inter_filter (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_29518 (h0 : filter (generalized_boolean_algebra (boolean_algebra.core Type))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_29519 (h0 : topological_space (has_inv (random_gen (random_gen fun_info)))) : irreducible_space (has_inv (random_gen (random_gen fun_info))) := sorry --non-trivial
lemma new_lemma_29520 (h0 : function.extfun Type complete_lattice) : @is_atomistic.{0} (has_edist.{0} empty) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (has_edist.{0} empty))  := sorry --non-trivial
lemma new_lemma_29521 (h0 : topological_space (linear_ordered_comm_group (option (option empty)))) : t0_space (linear_ordered_comm_group (option (option empty))) := sorry --non-trivial
lemma new_lemma_29522 (h0 : group (id (has_norm (has_norm (has_norm linarith.comp))))) : is_cyclic (id (has_norm (has_norm (has_norm linarith.comp)))) := sorry --non-trivial
lemma new_lemma_29523 (h0 : not (monoid (has_emptyc (has_norm linarith.comp_source)) -> false)) : @monoid.fg.{0} (has_emptyc.{0} (has_norm.{0} linarith.comp_source)) (@classical.by_contradiction'.{1} (monoid.{0} (has_emptyc.{0} (has_norm.{0} linarith.comp_source))) h0)  := sorry --non-trivial
lemma new_lemma_29524 (h0 : functor.add_const (topological_space (ring name)) pos) : @totally_disconnected_space.{0} (ring.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (ring.{0} name)) pos h0)  := sorry --non-trivial
lemma new_lemma_29525 (h0 : topological_space (cancel_monoid empty)) : preirreducible_space (cancel_monoid empty) := sorry --non-trivial
lemma new_lemma_29526 (h0 : set (has_lt char)) : set.subsingleton h0 := sorry --non-trivial
lemma new_lemma_29527 (h0 : ring (non_unital_non_assoc_semiring linarith.ineq)) : strong_rank_condition (non_unital_non_assoc_semiring linarith.ineq) := sorry --non-trivial
lemma new_lemma_29528 (h0 : uniform_space (linear_order (option (option (option (option empty)))))) : complete_space (linear_order (option (option (option (option empty))))) := sorry --non-trivial
lemma new_lemma_29529 (h0 : function.extfun (Type 1) topological_space) : @totally_disconnected_space.{1} (plift.{1} empty) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} h0 (plift.{1} empty))  := sorry --non-trivial
lemma new_lemma_29530 (h0 : functor.add_const (list (has_neg name)) Type) : palindrome (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_29531 (h0 : preorder (mul_one_class (mul_one_class std_gen))) (h1 : set (mul_one_class (mul_one_class std_gen))) : set.is_pwo h1 := sorry --non-trivial
lemma new_lemma_29532 (h0 : function.extfun Type ring) : @rank_condition.{0} (metric_space.{0} unsigned) (@function.extfun_app.{2 1} Type ring.{0} h0 (metric_space.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_29533 (h0 : add_group (metric_space (metric_space (semiring (semiring (metric_space num)))))) : is_add_cyclic (metric_space (metric_space (semiring (semiring (metric_space num))))) := sorry --non-trivial
lemma new_lemma_29534 (h0 : semiring (has_to_string ennreal)) : is_noetherian_ring (has_to_string ennreal) := sorry --non-trivial
lemma new_lemma_29535 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @topological_space.separable_space.{0} (add_comm_monoid.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (add_comm_monoid.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_29536 (h0 : finset (has_nndist (has_nndist (has_nndist (option name))))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_29537 (h1 : complete_lattice (measurable_space num)) : is_compactly_generated (measurable_space num) := sorry --non-trivial
lemma new_lemma_29538 (h0 : function.extfun Type topological_space) : @discrete_topology.{0} (has_norm.{0} fun_info) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_norm.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_29539 (h0 : topological_space (sub_neg_monoid Type)) : preirreducible_space (sub_neg_monoid Type) := sorry --non-trivial
lemma new_lemma_29540 (h0 : functor.add_const (semiring (ordered_ring congr_arg_kind)) unsigned) : @is_noetherian_ring.{0} (ordered_ring.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (semiring.{0} (ordered_ring.{0} congr_arg_kind)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_29541 (h0 : semiring (linear_ordered_comm_monoid_with_zero (option (option (option (option empty)))))) : is_noetherian_ring (linear_ordered_comm_monoid_with_zero (option (option (option (option empty))))) := sorry --non-trivial
lemma new_lemma_29542 (h0 : functor.comp topological_space has_neg ennreal) : @locally_compact_space.{0} (has_neg.{0} ennreal) (@functor.comp.run.{0 0 0} topological_space.{0} has_neg.{0} ennreal h0)  := sorry --non-trivial
lemma new_lemma_29543 (h0 : topological_space (has_Inf (has_to_string (has_add (has_to_string linarith.comp))))) : t1_space (has_Inf (has_to_string (has_add (has_to_string linarith.comp)))) := sorry --non-trivial
lemma new_lemma_29544 (h0 : functor.add_const (add_group (cancel_monoid environment.implicit_infer_kind)) (ring (cancel_monoid name))) : @is_add_cyclic.{0} (cancel_monoid.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (add_group.{0} (cancel_monoid.{0} environment.implicit_infer_kind)) (ring.{0} (cancel_monoid.{0} name)) h0)  := sorry --non-trivial
lemma new_lemma_29545 (h0 : functor.add_const (group (ordered_comm_ring pos)) linarith.comp) : @is_cyclic.{0} (ordered_comm_ring.{0} pos) (@functor.add_const.run.{0 0} (group.{0} (ordered_comm_ring.{0} pos)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_29546 (h0 : functor.add_const (topological_space (cancel_monoid unsigned)) pos) : @locally_compact_space.{0} (cancel_monoid.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (cancel_monoid.{0} unsigned)) pos h0)  := sorry --non-trivial
lemma new_lemma_29547 (h0 : functor.add_const (list (ring pos)) (normed_comm_ring Type)) : palindrome (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_29548 (h0 : not (group (has_ssubset (has_nnnorm fun_info)) -> false)) : @is_cyclic.{0} (has_ssubset.{0} (has_nnnorm.{0} fun_info)) (@classical.by_contradiction'.{1} (group.{0} (has_ssubset.{0} (has_nnnorm.{0} fun_info))) h0)  := sorry --non-trivial
lemma new_lemma_29549 (h1 : topological_space (mul_one_class fun_info)) (h2 : set (mul_one_class fun_info)) : is_path_connected h2 := sorry --non-trivial
lemma new_lemma_29550 (h0 : functor.add_const (topological_space (has_neg_part environment.implicit_infer_kind)) Type) : @locally_compact_space.{0} (has_neg_part.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 1} (topological_space.{0} (has_neg_part.{0} environment.implicit_infer_kind)) Type h0)  := sorry --non-trivial
lemma new_lemma_29551 (h0 : function.extfun Type topological_space) : @discrete_topology.{0} (mul_zero_class.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (mul_zero_class.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_29552 (h0 : random_gen (has_norm linarith.comp) -> random_gen (has_norm linarith.comp) -> Prop) : reflexive h0 := sorry --non-trivial
lemma new_lemma_29553 (h0 : has_norm (semiring (has_top linarith.comp_source)) -> has_norm (semiring (has_top linarith.comp_source)) -> Prop) : reflexive h0 := sorry --non-trivial
lemma new_lemma_29554 (h0 : topological_space (boolean_algebra.core Type)) : preirreducible_space (boolean_algebra.core Type) := sorry --non-trivial
lemma new_lemma_29555 (h0 : functor.add_const (ordered_add_comm_monoid (generalized_boolean_algebra linarith.comp)) linarith.comp) : @archimedean.{0} (generalized_boolean_algebra.{0} linarith.comp) (@functor.add_const.run.{0 0} (ordered_add_comm_monoid.{0} (generalized_boolean_algebra.{0} linarith.comp)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_29556 (h1 : ring string_imp) : strong_rank_condition string_imp := sorry --non-trivial
lemma new_lemma_29557 (h0 : topological_space (with_one (semiring (semiring (has_norm unsigned))))) : discrete_topology (with_one (semiring (semiring (has_norm unsigned)))) := sorry --non-trivial
lemma new_lemma_29558 (h0 : functor.add_const (function.extfun (Type 1) ring) linarith.comp) : @is_principal_ideal_ring.{1} (complete_distrib_lattice.{1} Type) (@function.extfun_app.{3 2} (Type 1) ring.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) ring.{1}) linarith.comp h0) (complete_distrib_lattice.{1} Type))  := sorry --non-trivial
lemma new_lemma_29559 (h0 : fin has_zero.zero) : @archimedean.{1} (canonically_linear_ordered_monoid.{1} Type) (@matrix.vec_empty.{1} (ordered_add_comm_monoid.{1} (canonically_linear_ordered_monoid.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_29560 (h0 : functor.add_const (topological_space (has_star unsigned)) num) : @discrete_topology.{0} (has_star.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (has_star.{0} unsigned)) num h0)  := sorry --non-trivial
lemma new_lemma_29561 (h2 : ring (has_add to_additive.value_type)) : strong_rank_condition (has_add to_additive.value_type) := sorry --non-trivial
lemma new_lemma_29562 (h0 : topological_space (bin_tree (has_ssubset string_imp))) : path_connected_space (bin_tree (has_ssubset string_imp)) := sorry --non-trivial
lemma new_lemma_29563 (h0 : complete_lattice (has_one (semiring congr_arg_kind))) : complete_lattice.is_Sup_finite_compact (has_one (semiring congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_29564 (h0 : not (ring (non_unital_non_assoc_semiring reducibility_hints) -> false)) : @is_domain.{0} (non_unital_non_assoc_semiring.{0} reducibility_hints) (@classical.by_contradiction'.{1} (ring.{0} (non_unital_non_assoc_semiring.{0} reducibility_hints)) h0)  := sorry --non-trivial
lemma new_lemma_29565 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @t0_space.{0} (random_gen.{0} (semiring.{0} (semiring.{0} linarith.comp))) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (random_gen.{0} (semiring.{0} (semiring.{0} linarith.comp))))  := sorry --non-trivial
lemma new_lemma_29566 (h0 : function.extfun Type topological_space) : @loc_path_connected_space.{0} (has_Inf.{0} real) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_Inf.{0} real))  := sorry --non-trivial
lemma new_lemma_29567 (h0 : monoid (linear_ordered_semiring (semiring congr_arg_kind))) : monoid.fg (linear_ordered_semiring (semiring congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_29568 (h1 : complete_lattice (semi_normed_comm_ring std_gen)) : complete_lattice.is_Sup_finite_compact (semi_normed_comm_ring std_gen) := sorry --non-trivial
lemma new_lemma_29569 (h0 : functor.add_const (function.extfun (Type 1) complete_lattice) Type) : @is_compactly_generated.{1} (add_cancel_monoid.{1} Type) (@function.extfun_app.{3 2} (Type 1) complete_lattice.{1} (@functor.add_const.run.{2 1} (function.extfun.{3 2} (Type 1) complete_lattice.{1}) Type h0) (add_cancel_monoid.{1} Type))  := sorry --non-trivial
lemma new_lemma_29570 (h0 : ring (has_top (semiring (has_union (semiring (semiring congr_arg_kind)))))) : is_domain (has_top (semiring (has_union (semiring (semiring congr_arg_kind))))) := sorry --non-trivial
lemma new_lemma_29571 (h0 : function.extfun Type ring) : @is_domain.{0} (bin_tree.{0} unsigned) (@function.extfun_app.{2 1} Type ring.{0} h0 (bin_tree.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_29572 (h0 : list (boolean_algebra (finset (finset environment.implicit_infer_kind)))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_29573 (h0 : ring (has_add pos)) : strong_rank_condition (has_add pos) := sorry --non-trivial
lemma new_lemma_29574 (h0 : add_group (linear_ordered_semiring (with_bot (semiring (semiring linarith.comp))))) : is_add_cyclic (linear_ordered_semiring (with_bot (semiring (semiring linarith.comp)))) := sorry --non-trivial
lemma new_lemma_29575 (h0 : functor.add_const (topological_space (plift empty)) num) : @topological_space.separable_space.{1} (plift.{1} empty) (@functor.add_const.run.{1 0} (topological_space.{1} (plift.{1} empty)) num h0)  := sorry --non-trivial
lemma new_lemma_29576 (h0 : not (function.extfun Type complete_lattice -> false)) : @is_atomistic.{0} to_additive.value_type (@function.extfun_app.{2 1} Type complete_lattice.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type complete_lattice.{0}) h0) to_additive.value_type)  := sorry --non-trivial
lemma new_lemma_29577 (h0 : complete_lattice (has_neg (ring (has_add unsigned)))) : is_compactly_generated (has_neg (ring (has_add unsigned))) := sorry --non-trivial
lemma new_lemma_29578 (h0 : list (complete_distrib_lattice (ring Type))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_29579 (h0 : complete_lattice (boolean_algebra.core Type)) : is_compactly_generated (boolean_algebra.core Type) := sorry --non-trivial
lemma new_lemma_29580 (h0 : ring (has_Sup congr_arg_kind)) : strong_rank_condition (has_Sup congr_arg_kind) := sorry --non-trivial
lemma new_lemma_29581 (h0 : topological_space (finset (has_add linarith.comp))) : loc_path_connected_space (finset (has_add linarith.comp)) := sorry --non-trivial
lemma new_lemma_29582 (h0 : has_mem.mem topological_space has_emptyc.emptyc) : @t0_space.{0} congr_arg_kind (@function.extfun_app.{2 1} Type topological_space.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) topological_space.{0} h0) congr_arg_kind)  := sorry --non-trivial
lemma new_lemma_29583 (h0 : not (filter Prop -> false)) : @filter.Limsup.{0} Prop (@complete_lattice.to_conditionally_complete_lattice.{0} Prop Prop.complete_lattice) (@classical.by_contradiction'.{1} (filter.{0} Prop) h0)  := sorry --non-trivial
lemma new_lemma_29584 (h0 : ring (random_gen (metric_space to_additive.value_type))) : is_domain (random_gen (metric_space to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_29585 (h0 : topological_space (has_nnnorm (mul_one_class fun_info))) : totally_disconnected_space (has_nnnorm (mul_one_class fun_info)) := sorry --non-trivial
lemma new_lemma_29586 (h0 : functor.add_const (topological_space (normed_linear_ordered_group empty)) congr_arg_kind) : @irreducible_space.{0} (normed_linear_ordered_group.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (normed_linear_ordered_group.{0} empty)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_29587 (h0 : functor.add_const (topological_space (normed_comm_ring pos)) Type) : @loc_path_connected_space.{0} (normed_comm_ring.{0} pos) (@functor.add_const.run.{0 1} (topological_space.{0} (normed_comm_ring.{0} pos)) Type h0)  := sorry --non-trivial
lemma new_lemma_29588 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @rank_condition.{0} (add_group.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (add_group.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_29589 (h0 : ring (has_inner empty congr_arg_kind)) : is_domain (has_inner empty congr_arg_kind) := sorry --non-trivial
lemma new_lemma_29590 (h0 : topological_space (monoid (option empty))) : totally_separated_space (monoid (option empty)) := sorry --non-trivial
lemma new_lemma_29591 (h0 : complete_lattice (free_add_monoid (semiring (semiring (semiring (semiring (semiring congr_arg_kind))))))) : is_atomistic (free_add_monoid (semiring (semiring (semiring (semiring (semiring congr_arg_kind)))))) := sorry --non-trivial
lemma new_lemma_29592 (h0 : cancel_comm_monoid_with_zero (generalized_boolean_algebra (has_neg name))) : unique_factorization_monoid (generalized_boolean_algebra (has_neg name)) := sorry --non-trivial
lemma new_lemma_29593 (h0 : functor.add_const (topological_space (semigroup unsigned)) name) : @regular_space.{0} (semigroup.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (semigroup.{0} unsigned)) name h0)  := sorry --non-trivial
lemma new_lemma_29594 (h0 : functor.add_const (topological_space (normed_comm_ring pos)) environment.implicit_infer_kind) : @regular_space.{0} (normed_comm_ring.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (normed_comm_ring.{0} pos)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_29595 (h0 : topological_space (has_to_string (finset pos))) : loc_path_connected_space (has_to_string (finset pos)) := sorry --non-trivial
lemma new_lemma_29596 (h0 : complete_lattice (with_bot (semiring empty))) : complete_lattice.is_Sup_finite_compact (with_bot (semiring empty)) := sorry --non-trivial
lemma new_lemma_29597 (h0 : function.extfun Type uniform_space) : @separated_space.{0} (canonically_ordered_add_monoid.{0} unsigned) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (canonically_ordered_add_monoid.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_29598 (h0 : not (topological_space (has_sub num) -> false)) : @normal_space.{0} (has_sub.{0} num) (@classical.by_contradiction'.{1} (topological_space.{0} (has_sub.{0} num)) h0)  := sorry --non-trivial
lemma new_lemma_29599 (h1 : topological_space (has_nnnorm fun_info)) : path_connected_space (has_nnnorm fun_info) := sorry --non-trivial
lemma new_lemma_29600 (h0 : topological_space (canonically_ordered_monoid (has_Inf (has_bot name)))) : path_connected_space (canonically_ordered_monoid (has_Inf (has_bot name))) := sorry --non-trivial
lemma new_lemma_29601 (h0 : topological_space (semigroup (ring Type))) : regular_space (semigroup (ring Type)) := sorry --non-trivial
lemma new_lemma_29602 (h0 : functor.add_const (function.extfun Type topological_space) (ring linarith.comp)) : @path_connected_space.{0} (add_cancel_monoid.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) (ring.{0} linarith.comp) h0) (add_cancel_monoid.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_29603 (h0 : functor.add_const (function.extfun Type ring) pos) : @is_principal_ideal_ring.{0} (normed_comm_ring.{0} name) (@function.extfun_app.{2 1} Type ring.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type ring.{0}) pos h0) (normed_comm_ring.{0} name))  := sorry --non-trivial
lemma new_lemma_29604 (h0 : add_group (comm_group (has_add unsigned))) : is_add_cyclic (comm_group (has_add unsigned)) := sorry --non-trivial
lemma new_lemma_29605 (h0 : complete_lattice (complete_semilattice_Sup (random_gen linarith.ineq))) : is_compactly_generated (complete_semilattice_Sup (random_gen linarith.ineq)) := sorry --non-trivial
lemma new_lemma_29606 (h0 : function.extfun Type group) : @normalizer_condition.{0} pos (@function.extfun_app.{2 1} Type group.{0} h0 pos)  := sorry --non-trivial
lemma new_lemma_29607 (h0 : functor.add_const (function.extfun Type complete_lattice) linarith.comp) : @complete_lattice.is_Sup_finite_compact.{0} (sub_neg_monoid.{0} linarith.comp) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type complete_lattice.{0}) linarith.comp h0) (sub_neg_monoid.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_29608 (h0 : finset (ordered_ring (semiring empty))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_29609 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : list.nodup (function.extfun_app (function.extfun_app h0 list) (bin_tree empty)) := sorry --non-trivial
lemma new_lemma_29610 (h0 : function.extfun (Type 1) complete_lattice) : @is_compactly_generated.{1} (mul_zero_class.{1} Type) (@function.extfun_app.{3 2} (Type 1) complete_lattice.{1} h0 (mul_zero_class.{1} Type))  := sorry --non-trivial
lemma new_lemma_29611 (h0 : function.extfun Type topological_space) : @preirreducible_space.{0} (has_neg.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_neg.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_29612 (h0 : group (has_compl fun_info)) : group.fg (has_compl fun_info) := sorry --non-trivial
lemma new_lemma_29613 (h0 : topological_space (canonically_ordered_comm_semiring pos)) : t1_space (canonically_ordered_comm_semiring pos) := sorry --non-trivial
lemma new_lemma_29614 (h0 : topological_space (simple_graph empty)) : locally_compact_space (simple_graph empty) := sorry --non-trivial
lemma new_lemma_29615 (h0 : ring (measurable_space.dynkin_system (semiring unsigned))) : is_principal_ideal_ring (measurable_space.dynkin_system (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_29616 (h0 : ordered_add_comm_monoid (has_add ennreal)) : archimedean (has_add ennreal) := sorry --non-trivial
lemma new_lemma_29617 (h0 : function.extfun Type ring) : @is_domain.{0} (has_nndist.{0} name) (@function.extfun_app.{2 1} Type ring.{0} h0 (has_nndist.{0} name))  := sorry --non-trivial
lemma new_lemma_29618 (h0 : functor.add_const (topological_space (ordered_comm_semiring unsigned)) num) : @t1_space.{0} (ordered_comm_semiring.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (ordered_comm_semiring.{0} unsigned)) num h0)  := sorry --non-trivial
lemma new_lemma_29619 (h0 : functor.add_const (cancel_comm_monoid_with_zero (canonically_ordered_comm_semiring pos)) Type) : @unique_factorization_monoid.{0} (canonically_ordered_comm_semiring.{0} pos) (@functor.add_const.run.{0 1} (cancel_comm_monoid_with_zero.{0} (canonically_ordered_comm_semiring.{0} pos)) Type h0)  := sorry --non-trivial
lemma new_lemma_29620 (h0 : topological_space (linear_ordered_cancel_comm_monoid (option (option unsigned)))) : normal_space (linear_ordered_cancel_comm_monoid (option (option unsigned))) := sorry --non-trivial
lemma new_lemma_29621 (h0 : topological_space (has_top (has_ssubset (has_ssubset (has_ssubset to_additive.value_type))))) : t0_space (has_top (has_ssubset (has_ssubset (has_ssubset to_additive.value_type)))) := sorry --non-trivial
lemma new_lemma_29622 (h0 : monoid (normed_group (has_top num))) : monoid.fg (normed_group (has_top num)) := sorry --non-trivial
lemma new_lemma_29623 (h0 : function.extfun Type (functor.comp ordered_comm_monoid has_neg)) : @has_exists_mul_of_le.{0} (has_neg.{0} environment.implicit_infer_kind) (@functor.comp.run.{0 0 0} ordered_comm_monoid.{0} has_neg.{0} environment.implicit_infer_kind (@function.extfun_app.{2 1} Type (functor.comp.{0 0 0} ordered_comm_monoid.{0} has_neg.{0}) h0 environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_29624 (h0 : not (ring (semi_normed_comm_ring string.iterator_imp) -> false)) : @is_domain.{0} (semi_normed_comm_ring.{0} string.iterator_imp) (@classical.by_contradiction'.{1} (ring.{0} (semi_normed_comm_ring.{0} string.iterator_imp)) h0)  := sorry --non-trivial
lemma new_lemma_29625 (h2 : topological_space (mul_one_class (add_comm_semigroup linarith.ineq))) (h3 : set (mul_one_class (add_comm_semigroup linarith.ineq))) : is_path_connected h3 := sorry --non-trivial
lemma new_lemma_29626 (h0 : functor.add_const (cancel_comm_monoid_with_zero (complete_distrib_lattice pos)) linarith.comp) : @unique_factorization_monoid.{0} (complete_distrib_lattice.{0} pos) (@functor.add_const.run.{0 0} (cancel_comm_monoid_with_zero.{0} (complete_distrib_lattice.{0} pos)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_29627 (h0 : not (monoid (bin_tree num) -> false)) : @monoid.fg.{0} (bin_tree.{0} num) (@classical.by_contradiction'.{1} (monoid.{0} (bin_tree.{0} num)) h0)  := sorry --non-trivial
lemma new_lemma_29628 (h0 : topological_space (has_Inf (add_cancel_monoid name))) : totally_separated_space (has_Inf (add_cancel_monoid name)) := sorry --non-trivial
lemma new_lemma_29629 (h0 : topological_space (ring (has_neg_part (has_add environment.implicit_infer_kind)))) : loc_path_connected_space (ring (has_neg_part (has_add environment.implicit_infer_kind))) := sorry --non-trivial
lemma new_lemma_29630 (h0 : ring (has_to_string (normed_comm_ring (semigroup (has_add unsigned))))) : is_domain (has_to_string (normed_comm_ring (semigroup (has_add unsigned)))) := sorry --non-trivial
lemma new_lemma_29631 (h0 : functor.add_const (function.extfun Type monoid) environment.implicit_infer_kind) : @monoid.fg.{0} (add_cancel_monoid.{0} linarith.comp) (@function.extfun_app.{2 1} Type monoid.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type monoid.{0}) environment.implicit_infer_kind h0) (add_cancel_monoid.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_29632 (h0 : topological_space (plift (has_top (semiring empty)))) : t0_space (plift (has_top (semiring empty))) := sorry --non-trivial
lemma new_lemma_29633 (h0 : function.extfun Type filter) : countable_Inter_filter (function.extfun_app h0 (has_add unsigned)) := sorry --non-trivial
lemma new_lemma_29634 (h0 : finset (boolean_algebra.core (has_neg (has_neg (has_neg (has_neg linarith.comp)))))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_29635 (h0 : functor.add_const (list (semigroup linarith.comp)) pos) : list.nodup (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_29636 (h0 : topological_space (semigroup (mul_one_class (finset linarith.comp)))) : topological_space.separable_space (semigroup (mul_one_class (finset linarith.comp))) := sorry --non-trivial
lemma new_lemma_29637 (h0 : functor.add_const (complete_lattice znum) unsigned) : @complete_lattice.is_Sup_finite_compact.{0} znum (@functor.add_const.run.{0 0} (complete_lattice.{0} znum) unsigned h0)  := sorry --non-trivial
lemma new_lemma_29638 (h0 : functor.add_const (function.extfun (Type 1) topological_space) Type) : @discrete_topology.{1} (has_Inf.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@functor.add_const.run.{2 1} (function.extfun.{3 2} (Type 1) topological_space.{1}) Type h0) (has_Inf.{1} Type))  := sorry --non-trivial
lemma new_lemma_29639 (h0 : not (semiring (semiring linarith.comp) -> false)) : @is_noetherian_ring.{0} (semiring.{0} linarith.comp) (@classical.by_contradiction'.{1} (semiring.{0} (semiring.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_29640 (h0 : monoid (normed_comm_ring (ring Type))) : monoid.fg (normed_comm_ring (ring Type)) := sorry --non-trivial
lemma new_lemma_29641 (h0 : function.extfun Type topological_space) : @t1_space.{0} (ring.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (ring.{0} name))  := sorry --non-trivial
lemma new_lemma_29642 (h0 : topological_space (boolean_algebra.core (boolean_algebra.core linarith.comp))) : t0_space (boolean_algebra.core (boolean_algebra.core linarith.comp)) := sorry --non-trivial
lemma new_lemma_29643 (h1 : not (topological_space (random_gen congr_arg_kind) -> false)) : @t0_space.{0} (random_gen.{0} congr_arg_kind) (@classical.by_contradiction'.{1} (topological_space.{0} (random_gen.{0} congr_arg_kind)) h1)  := sorry --non-trivial
lemma new_lemma_29644 (h0 : functor.add_const (complete_lattice (canonically_linear_ordered_monoid unsigned)) unsigned) : @is_atomistic.{0} (canonically_linear_ordered_monoid.{0} unsigned) (@functor.add_const.run.{0 0} (complete_lattice.{0} (canonically_linear_ordered_monoid.{0} unsigned)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_29645 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @complete_lattice.is_Sup_finite_compact.{0} (add_comm_monoid.{0} num) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (add_comm_monoid.{0} num))  := sorry --non-trivial
lemma new_lemma_29646 (h0 : functor.add_const (topological_space (canonically_ordered_comm_semiring empty)) unsigned) : @topological_space.separable_space.{0} (canonically_ordered_comm_semiring.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (canonically_ordered_comm_semiring.{0} empty)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_29647 (h1 : not (function.extfun Type uniform_space -> false)) : @complete_space.{0} congr_arg_kind (@function.extfun_app.{2 1} Type uniform_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type uniform_space.{0}) h1) congr_arg_kind)  := sorry --non-trivial
lemma new_lemma_29648 (h0 : topological_space (has_append (mul_one_class to_additive.value_type))) : t0_space (has_append (mul_one_class to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_29649 (h0 : ring (linear_ordered_comm_group (linear_ordered_comm_group unsigned))) : rank_condition (linear_ordered_comm_group (linear_ordered_comm_group unsigned)) := sorry --non-trivial
lemma new_lemma_29650 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @path_connected_space.{0} (left_cancel_semigroup.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (left_cancel_semigroup.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_29651 (h0 : group (denumerable (random_gen (random_gen (random_gen (random_gen string_imp)))))) : group.fg (denumerable (random_gen (random_gen (random_gen (random_gen string_imp))))) := sorry --non-trivial
lemma new_lemma_29652 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @rank_condition.{0} (partial_order.{0} (semiring.{0} (semiring.{0} (semiring.{0} (semiring.{0} (semiring.{0} num)))))) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (partial_order.{0} (semiring.{0} (semiring.{0} (semiring.{0} (semiring.{0} (semiring.{0} num)))))))  := sorry --non-trivial
lemma new_lemma_29653 (h0 : topological_space (add_semigroup empty)) : path_connected_space (add_semigroup empty) := sorry --non-trivial
lemma new_lemma_29654 (h0 : functor.add_const (topological_space (add_group unsigned)) empty) : @preirreducible_space.{0} (add_group.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (add_group.{0} unsigned)) empty h0)  := sorry --non-trivial
lemma new_lemma_29655 (h0 : not (function.extfun Type uniform_space -> false)) : @separated_space.{0} (has_emptyc.{0} num) (@function.extfun_app.{2 1} Type uniform_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type uniform_space.{0}) h0) (has_emptyc.{0} num))  := sorry --non-trivial
lemma new_lemma_29656 (h0 : ring (has_ssubset (add_comm_semigroup (mul_one_class string.iterator_imp)))) : is_domain (has_ssubset (add_comm_semigroup (mul_one_class string.iterator_imp))) := sorry --non-trivial
lemma new_lemma_29657 (h0 : not (topological_space (measurable_space congr_arg_kind) -> false)) : @totally_disconnected_space.{0} (measurable_space.{0} congr_arg_kind) (@classical.by_contradiction'.{1} (topological_space.{0} (measurable_space.{0} congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_29658 (h0 : functor.comp group cancel_monoid ennreal) : @is_cyclic.{0} (cancel_monoid.{0} ennreal) (@functor.comp.run.{0 0 0} group.{0} cancel_monoid.{0} ennreal h0)  := sorry --non-trivial
lemma new_lemma_29659 (h0 : uniform_space (comm_semigroup (sub_neg_monoid pos))) : complete_space (comm_semigroup (sub_neg_monoid pos)) := sorry --non-trivial
lemma new_lemma_29660 (h0 : functor.add_const Prop (semiring unsigned)) : functor.add_const.run h0 := sorry --non-trivial
lemma new_lemma_29661 (h0 : uniform_space (has_pos_part pos)) : separated_space (has_pos_part pos) := sorry --non-trivial
lemma new_lemma_29662 (h0 : list (ordered_comm_monoid (ring (ring (ring linarith.comp))))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_29663 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @loc_path_connected_space.{0} (semigroup.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (semigroup.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_29664 (h0 : group (has_top (has_norm (semiring num)))) : normalizer_condition (has_top (has_norm (semiring num))) := sorry --non-trivial
lemma new_lemma_29665 (h0 : functor.add_const (add_monoid (has_add pos)) unsigned) : @add_monoid.fg.{0} (has_add.{0} pos) (@functor.add_const.run.{0 0} (add_monoid.{0} (has_add.{0} pos)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_29666 (h0 : topological_space (left_cancel_semigroup num)) : preirreducible_space (left_cancel_semigroup num) := sorry --non-trivial
lemma new_lemma_29667 (h0 : add_monoid (pseudo_metric_space (option ennreal))) : add_monoid.fg (pseudo_metric_space (option ennreal)) := sorry --non-trivial
lemma new_lemma_29668 (h0 : list (comm_group (semigroup (has_nndist Type)))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_29669 (h0 : group (has_to_string (comm_group pos))) : is_simple_group (has_to_string (comm_group pos)) := sorry --non-trivial
lemma new_lemma_29670 (h1 : complete_lattice (simple_graph (mul_one_class string_imp))) : complete_lattice.is_Sup_finite_compact (simple_graph (mul_one_class string_imp)) := sorry --non-trivial
lemma new_lemma_29671 (h0 : function.extfun Type (functor.add_const (uniform_space (has_Sup empty)))) : @separated_space.{0} (has_Sup.{0} empty) (@functor.add_const.run.{0 0} (uniform_space.{0} (has_Sup.{0} empty)) empty (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (uniform_space.{0} (has_Sup.{0} empty))) h0 empty))  := sorry --non-trivial
lemma new_lemma_29672 (h0 : function.extfun nat fin) : @locally_compact_space.{0} (measurable_space.{0} (semiring.{0} (semiring.{0} (semiring.{0} empty)))) (@matrix.vec_empty.{0} (topological_space.{0} (measurable_space.{0} (semiring.{0} (semiring.{0} (semiring.{0} empty))))) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_29673 (h0 : function.extfun (finset (Type -> Type)) (has_mem.mem topological_space)) : @discrete_topology.{0} (with_bot.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) topological_space.{0} (@function.extfun_app.{2 0} (finset.{1} (Type → Type)) (@has_mem.mem.{1 1} (Type → Type) (finset.{1} (Type → Type)) (@finset.has_mem.{1} (Type → Type)) topological_space.{0}) h0 (@has_emptyc.emptyc.{1} (finset.{1} (Type → Type)) (@finset.has_emptyc.{1} (Type → Type))))) (with_bot.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_29674 (h0 : not (prod (measurable_space.dynkin_system empty) (measurable_space.dynkin_system empty) -> false)) : id_rel (classical.by_contradiction' h0) := sorry --non-trivial
lemma new_lemma_29675 (h0 : ring (topological_space (has_nnnorm linarith.ineq))) : is_domain (topological_space (has_nnnorm linarith.ineq)) := sorry --non-trivial
lemma new_lemma_29676 (h0 : functor.add_const (function.extfun Type topological_space) Type) : @irreducible_space.{0} (semigroup.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type topological_space.{0}) Type h0) (semigroup.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_29677 (h0 : functor.add_const (group (has_nndist linarith.comp)) linarith.comp) : @is_cyclic.{0} (has_nndist.{0} linarith.comp) (@functor.add_const.run.{0 0} (group.{0} (has_nndist.{0} linarith.comp)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_29678 (h0 : functor.add_const (ordered_add_comm_monoid (finset environment.implicit_infer_kind)) pos) : @archimedean.{0} (finset.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (ordered_add_comm_monoid.{0} (finset.{0} environment.implicit_infer_kind)) pos h0)  := sorry --non-trivial
lemma new_lemma_29679 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @group.fg.{0} (measurable_space.{0} linarith.ineq) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (measurable_space.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_29680 (h0 : add_monoid (mul_zero_class (has_nndist name))) : add_monoid.fg (mul_zero_class (has_nndist name)) := sorry --non-trivial
lemma new_lemma_29681 (h0 : functor.add_const (group (has_zero name)) name) : @normalizer_condition.{0} (has_zero.{0} name) (@functor.add_const.run.{0 0} (group.{0} (has_zero.{0} name)) name h0)  := sorry --non-trivial
lemma new_lemma_29682 (h0 : list (normed_comm_ring pos)) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_29683 (h0 : monoid (cancel_monoid (has_neg environment.implicit_infer_kind))) : monoid.fg (cancel_monoid (has_neg environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_29684 (h0 : complete_lattice pos) : is_compactly_generated pos := sorry --non-trivial
lemma new_lemma_29685 (h0 : functor.add_const (semiring (semigroup unsigned)) name) : @is_noetherian_ring.{0} (semigroup.{0} unsigned) (@functor.add_const.run.{0 0} (semiring.{0} (semigroup.{0} unsigned)) name h0)  := sorry --non-trivial
lemma new_lemma_29686 (h0 : function.extfun Type ring) : @rank_condition.{0} (linear_ordered_cancel_comm_monoid.{0} num) (@function.extfun_app.{2 1} Type ring.{0} h0 (linear_ordered_cancel_comm_monoid.{0} num))  := sorry --non-trivial
lemma new_lemma_29687 (h1 : not (group (measurable_space num) -> false)) : @is_cyclic.{0} (measurable_space.{0} num) (@classical.by_contradiction'.{1} (group.{0} (measurable_space.{0} num)) h1)  := sorry --non-trivial
lemma new_lemma_29688 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @t0_space.{0} (has_ssubset.{0} linarith.ineq) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_ssubset.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_29689 (h0 : uniform_space (has_pos_part (boolean_algebra linarith.comp))) : complete_space (has_pos_part (boolean_algebra linarith.comp)) := sorry --non-trivial
lemma new_lemma_29690 (h0 : function.extfun Type topological_space) : @totally_separated_space.{0} (normed_group.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (normed_group.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_29691 (h0 : topological_space (generalized_boolean_algebra Type)) : loc_path_connected_space (generalized_boolean_algebra Type) := sorry --non-trivial
lemma new_lemma_29692 (h0 : topological_space (boolean_algebra (has_to_string environment.implicit_infer_kind))) : discrete_topology (boolean_algebra (has_to_string environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_29693 (h0 : functor.add_const (complete_lattice (finset linarith.comp)) linarith.comp) : @is_compactly_generated.{0} (finset.{0} linarith.comp) (@functor.add_const.run.{0 0} (complete_lattice.{0} (finset.{0} linarith.comp)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_29694 (h0 : finset (comm_group (has_zero pos))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_29695 (h0 : fin has_zero.zero) : @path_connected_space.{1} (canonically_linear_ordered_monoid.{1} Type) (@matrix.vec_empty.{1} (topological_space.{1} (canonically_linear_ordered_monoid.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_29696 (h0 : group (comm_group (option pos))) : group.fg (comm_group (option pos)) := sorry --non-trivial
lemma new_lemma_29697 (h0 : group (with_one congr_arg_kind)) : group.fg (with_one congr_arg_kind) := sorry --non-trivial
lemma new_lemma_29698 (h0 : uniform_space (dlist (random_gen char))) : complete_space (dlist (random_gen char)) := sorry --non-trivial
lemma new_lemma_29699 (h0 : topological_space (ordered_comm_ring (has_Inf (has_Inf real)))) : preirreducible_space (ordered_comm_ring (has_Inf (has_Inf real))) := sorry --non-trivial
lemma new_lemma_29700 (h0 : complete_lattice (simple_graph (mul_one_class string.iterator_imp))) : complete_lattice.is_Sup_finite_compact (simple_graph (mul_one_class string.iterator_imp)) := sorry --non-trivial
lemma new_lemma_29701 (h0 : set (has_ssubset (mul_one_class char))) : set.finite h0 := sorry --non-trivial
lemma new_lemma_29702 (h2 : monoid (distrib_lattice (has_top (has_top linarith.ineq)))) : monoid.fg (distrib_lattice (has_top (has_top linarith.ineq))) := sorry --non-trivial
lemma new_lemma_29703 (h0 : topological_space (normed_comm_ring (has_to_string (has_to_string (has_to_string num))))) : preconnected_space (normed_comm_ring (has_to_string (has_to_string (has_to_string num)))) := sorry --non-trivial
lemma new_lemma_29704 (h0 : complete_lattice (normed_field (metric_space to_additive.value_type))) : complete_lattice.is_Sup_finite_compact (normed_field (metric_space to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_29705 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @group.fg.{0} (boolean_algebra.{0} name) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (boolean_algebra.{0} name))  := sorry --non-trivial
lemma new_lemma_29706 (h0 : ring (boolean_algebra.core (has_add environment.implicit_infer_kind))) : rank_condition (boolean_algebra.core (has_add environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_29707 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_cyclic.{0} (add_cancel_monoid.{0} ennreal) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (add_cancel_monoid.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_29708 (h0 : monoid (add_right_cancel_monoid (ordered_ring empty))) : monoid.fg (add_right_cancel_monoid (ordered_ring empty)) := sorry --non-trivial
lemma new_lemma_29709 (h0 : complete_lattice (ordered_ring unsigned)) : is_atomistic (ordered_ring unsigned) := sorry --non-trivial
lemma new_lemma_29710 (h0 : functor.add_const (topological_space (generalized_boolean_algebra Type)) linarith.comp) : @regular_space.{1} (generalized_boolean_algebra.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (generalized_boolean_algebra.{1} Type)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_29711 (h0 : ring (linear_ordered_add_comm_group (has_nnnorm (has_nnnorm linarith.ineq)))) : is_domain (linear_ordered_add_comm_group (has_nnnorm (has_nnnorm linarith.ineq))) := sorry --non-trivial
lemma new_lemma_29712 (h0 : topological_space (boolean_algebra (finset pos))) : preirreducible_space (boolean_algebra (finset pos)) := sorry --non-trivial
lemma new_lemma_29713 (h0 : complete_lattice (has_lt linarith.ineq)) : complete_lattice.is_Sup_finite_compact (has_lt linarith.ineq) := sorry --non-trivial
lemma new_lemma_29714 (h0 : not (functor.add_const Prop num -> false)) : functor.add_const.run (classical.by_contradiction' h0) := sorry --non-trivial
lemma new_lemma_29715 (h0 : complete_lattice (add_comm_monoid unsigned)) : complete_lattice.is_Sup_finite_compact (add_comm_monoid unsigned) := sorry --non-trivial
lemma new_lemma_29716 (h0 : complete_lattice (has_star (semiring (semiring unsigned)))) : is_compactly_generated (has_star (semiring (semiring unsigned))) := sorry --non-trivial
lemma new_lemma_29717 (h0 : monoid (linear_ordered_comm_group (option (option empty)))) : monoid.fg (linear_ordered_comm_group (option (option empty))) := sorry --non-trivial
lemma new_lemma_29718 (h0 : not (has_mem.mem (has_top linarith.comp_source) has_emptyc.emptyc -> false)) : @rank_condition.{0} (has_top.{0} linarith.comp_source) (@finset.pi.empty.{1 0} Type ring.{0} (has_top.{0} linarith.comp_source) (@classical.by_contradiction'.{0} (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (has_top.{0} linarith.comp_source) (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))) h0))  := sorry --non-trivial
lemma new_lemma_29719 (h1 : std_gen -> std_gen -> std_gen) : associative h1 := sorry --non-trivial
lemma new_lemma_29720 (h3 : topological_space (fintype fun_info)) : path_connected_space (fintype fun_info) := sorry --non-trivial
lemma new_lemma_29721 (h0 : prod (pseudo_metric_space pos) (pseudo_metric_space pos)) : id_rel h0 := sorry --non-trivial
lemma new_lemma_29722 (h0 : function.extfun Type ring) : @strong_rank_condition.{0} (has_to_string.{0} linarith.comp) (@function.extfun_app.{2 1} Type ring.{0} h0 (has_to_string.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_29723 (h0 : topological_space (has_compl (has_neg (semi_normed_comm_ring enat)))) : path_connected_space (has_compl (has_neg (semi_normed_comm_ring enat))) := sorry --non-trivial
lemma new_lemma_29724 (h0 : group (has_union (semiring fun_info))) : group.fg (has_union (semiring fun_info)) := sorry --non-trivial
lemma new_lemma_29725 (h0 : ordered_add_comm_monoid (add_cancel_monoid (has_add name))) : archimedean (add_cancel_monoid (has_add name)) := sorry --non-trivial
lemma new_lemma_29726 (h0 : topological_space (has_add (has_nnnorm (has_nnnorm (has_nnnorm fun_info))))) : path_connected_space (has_add (has_nnnorm (has_nnnorm (has_nnnorm fun_info)))) := sorry --non-trivial
lemma new_lemma_29727 (h0 : ring (ring (has_Inf (has_pos_part pos)))) : is_domain (ring (has_Inf (has_pos_part pos))) := sorry --non-trivial
lemma new_lemma_29728 (h0 : set (prod (random_gen to_additive.value_type) (random_gen to_additive.value_type))) : symmetric_rel h0 := sorry --non-trivial
lemma new_lemma_29729 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_atomistic.{0} linarith.comp (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) linarith.comp)  := sorry --non-trivial
lemma new_lemma_29730 (h0 : functor.add_const (function.extfun (Type 1) group) (has_neg (has_neg linarith.comp))) : @is_simple_group.{1} (has_zero.{1} Type) (@function.extfun_app.{3 2} (Type 1) group.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) group.{1}) (has_neg.{0} (has_neg.{0} linarith.comp)) h0) (has_zero.{1} Type))  := sorry --non-trivial
lemma new_lemma_29731 (h2 : has_le char) (h3 : char) : is_max h3 := sorry --non-trivial
lemma new_lemma_29732 (h0 : topological_space (boolean_algebra.core (has_add Type))) : locally_compact_space (boolean_algebra.core (has_add Type)) := sorry --non-trivial
lemma new_lemma_29733 (h0 : topological_space (has_star (semiring (semiring congr_arg_kind)))) : totally_disconnected_space (has_star (semiring (semiring congr_arg_kind))) := sorry --non-trivial
lemma new_lemma_29734 (h1 : topological_space (semiring (random_gen (with_bot to_additive.value_type)))) : irreducible_space (semiring (random_gen (with_bot to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_29735 (h0 : topological_space (complete_semilattice_Sup unsigned)) : discrete_topology (complete_semilattice_Sup unsigned) := sorry --non-trivial
lemma new_lemma_29736 (h0 : functor.add_const (complete_lattice (ordered_comm_ring linarith.comp)) (has_add linarith.comp)) : @is_compactly_generated.{0} (ordered_comm_ring.{0} linarith.comp) (@functor.add_const.run.{0 0} (complete_lattice.{0} (ordered_comm_ring.{0} linarith.comp)) (has_add.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_29737 (h0 : functor.add_const (semiring (bin_tree empty)) empty) : @is_noetherian_ring.{0} (bin_tree.{0} empty) (@functor.add_const.run.{0 0} (semiring.{0} (bin_tree.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_29738 (h0 : topological_space (complete_semilattice_Sup num)) : totally_separated_space (complete_semilattice_Sup num) := sorry --non-trivial
lemma new_lemma_29739 (h0 : functor.add_const (topological_space (finset name)) name) : @preconnected_space.{0} (finset.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (finset.{0} name)) name h0)  := sorry --non-trivial
lemma new_lemma_29740 (h0 : list (add_cancel_monoid num)) : palindrome h0 := sorry --non-trivial
lemma new_lemma_29741 (h0 : functor.add_const (topological_space (has_to_string linarith.comp)) pos) : @totally_disconnected_space.{0} (has_to_string.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (has_to_string.{0} linarith.comp)) pos h0)  := sorry --non-trivial
lemma new_lemma_29742 (h0 : topological_space (boolean_algebra (has_add environment.implicit_infer_kind))) : preconnected_space (boolean_algebra (has_add environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_29743 (h0 : topological_space (has_le string.iterator_imp)) : path_connected_space (has_le string.iterator_imp) := sorry --non-trivial
lemma new_lemma_29744 (h0 : functor.add_const (function.extfun Type topological_space) linarith.comp) : @irreducible_space.{0} (ring.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) linarith.comp h0) (ring.{0} pos))  := sorry --non-trivial
lemma new_lemma_29745 (h0 : group (has_add (boolean_algebra (has_nndist linarith.comp)))) : is_cyclic (has_add (boolean_algebra (has_nndist linarith.comp))) := sorry --non-trivial
lemma new_lemma_29746 (h0 : not (add_monoid (linear_ordered_comm_ring unsigned) -> false)) : @add_monoid.fg.{0} (linear_ordered_comm_ring.{0} unsigned) (@classical.by_contradiction'.{1} (add_monoid.{0} (linear_ordered_comm_ring.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_29747 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : countable_Inter_filter (function.extfun_app (function.extfun_app h0 filter) (cancel_monoid ennreal)) := sorry --non-trivial
lemma new_lemma_29748 (h0 : ring (has_nndist (finset Type))) : is_domain (has_nndist (finset Type)) := sorry --non-trivial
lemma new_lemma_29749 (h0 : topological_space (boolean_algebra (normed_comm_ring (has_add Type)))) : irreducible_space (boolean_algebra (normed_comm_ring (has_add Type))) := sorry --non-trivial
lemma new_lemma_29750 (h0 : prod (non_assoc_semiring (option empty)) (non_assoc_semiring (option empty))) : id_rel h0 := sorry --non-trivial
lemma new_lemma_29751 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_add_cyclic.{0} (canonically_ordered_comm_semiring.{0} empty) (@function.extfun_app.{2 1} Type add_group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 add_group.{0}) (canonically_ordered_comm_semiring.{0} empty))  := sorry --non-trivial
lemma new_lemma_29752 (h0 : uniform_space (has_norm (semiring (semiring (semiring (measurable_space empty)))))) : separated_space (has_norm (semiring (semiring (semiring (measurable_space empty))))) := sorry --non-trivial
lemma new_lemma_29753 (h0 : topological_space (has_add Type)) : irreducible_space (has_add Type) := sorry --non-trivial
lemma new_lemma_29754 (h0 : topological_space (boolean_algebra (has_neg linarith.comp))) : regular_space (boolean_algebra (has_neg linarith.comp)) := sorry --non-trivial
lemma new_lemma_29755 (h0 : topological_space (bin_tree congr_arg_kind)) : path_connected_space (bin_tree congr_arg_kind) := sorry --non-trivial
lemma new_lemma_29756 (h0 : function.extfun Type ring) : @is_domain.{0} (has_top.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type ring.{0} h0 (has_top.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_29757 (h0 : group (mul_zero_class (semiring num))) : is_cyclic (mul_zero_class (semiring num)) := sorry --non-trivial
lemma new_lemma_29758 (h0 : topological_space (normed_group (semiring (semiring empty)))) : locally_compact_space (normed_group (semiring (semiring empty))) := sorry --non-trivial
lemma new_lemma_29759 (h0 : topological_space (has_Inf (has_neg (has_neg (has_add name))))) : loc_path_connected_space (has_Inf (has_neg (has_neg (has_add name)))) := sorry --non-trivial
lemma new_lemma_29760 (h0 : ring (denumerable (random_gen string_imp))) : rank_condition (denumerable (random_gen string_imp)) := sorry --non-trivial
lemma new_lemma_29761 (h0 : add_group (measurable_space.dynkin_system (semiring (semiring (semiring empty))))) : is_add_cyclic (measurable_space.dynkin_system (semiring (semiring (semiring empty)))) := sorry --non-trivial
lemma new_lemma_29762 (h0 h1 : not (multiset (uniform_space char) -> false)) : multiset.disjoint (classical.by_contradiction' h0) (classical.by_contradiction' h1) := sorry --non-trivial
lemma new_lemma_29763 (h0 : functor.add_const (ring (as_linear_order empty)) unsigned) : @rank_condition.{0} (as_linear_order.{0} empty) (@functor.add_const.run.{0 0} (ring.{0} (as_linear_order.{0} empty)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_29764 (h0 : function.extfun Type topological_space) : @discrete_topology.{0} (linear_ordered_comm_group.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (linear_ordered_comm_group.{0} empty))  := sorry --non-trivial
lemma new_lemma_29765 (h0 : topological_space (complete_linear_order (semiring empty))) : discrete_topology (complete_linear_order (semiring empty)) := sorry --non-trivial
lemma new_lemma_29766 (h0 : topological_space (has_add real)) : totally_separated_space (has_add real) := sorry --non-trivial
lemma new_lemma_29767 (h0 : group (measurable_space (has_emptyc linarith.comp))) : group.fg (measurable_space (has_emptyc linarith.comp)) := sorry --non-trivial
lemma new_lemma_29768 (h0 : topological_space (finset (has_neg (has_add (ring (has_neg (ring (ring (has_add Type))))))))) : t0_space (finset (has_neg (has_add (ring (has_neg (ring (ring (has_add Type)))))))) := sorry --non-trivial
lemma new_lemma_29769 (h0 : function.extfun Type ring) : @strong_rank_condition.{0} (add_left_cancel_semigroup.{0} unsigned) (@function.extfun_app.{2 1} Type ring.{0} h0 (add_left_cancel_semigroup.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_29770 (h0 : topological_space (boolean_algebra.core (option (monoid_with_zero (option (option pos)))))) : locally_compact_space (boolean_algebra.core (option (monoid_with_zero (option (option pos))))) := sorry --non-trivial
lemma new_lemma_29771 (h0 : monoid (normed_linear_ordered_group num)) : monoid.fg (normed_linear_ordered_group num) := sorry --non-trivial
lemma new_lemma_29772 (h0 : ring (complete_distrib_lattice linarith.ineq)) : rank_condition (complete_distrib_lattice linarith.ineq) := sorry --non-trivial
lemma new_lemma_29773 (h0 : functor.add_const (ring (ordered_comm_ring name)) linarith.comp) : @strong_rank_condition.{0} (ordered_comm_ring.{0} name) (@functor.add_const.run.{0 0} (ring.{0} (ordered_comm_ring.{0} name)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_29774 (h0 : function.extfun Type filter) : filter.ne_bot (function.extfun_app h0 (add_group empty)) := sorry --non-trivial
lemma new_lemma_29775 (h0 : finset (comm_group (comm_group Type))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_29776 (h1 : ring (fintype (fintype to_additive.value_type))) : rank_condition (fintype (fintype to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_29777 (h0 : fin has_zero.zero) : @topological_space.separable_space.{0} (ordered_comm_ring.{0} pos) (@matrix.vec_empty.{0} (topological_space.{0} (ordered_comm_ring.{0} pos)) (@matrix.vec_empty.{0} (fin (@has_zero.zero.{0} nat nat.has_zero)) h0))  := sorry --non-trivial
lemma new_lemma_29778 (h0 : topological_space (has_top (with_bot (has_top to_additive.value_type)))) : irreducible_space (has_top (with_bot (has_top to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_29779 (h0 : functor.add_const (add_monoid (canonically_ordered_comm_semiring pos)) (mul_zero_class pos)) : @add_monoid.fg.{0} (canonically_ordered_comm_semiring.{0} pos) (@functor.add_const.run.{0 0} (add_monoid.{0} (canonically_ordered_comm_semiring.{0} pos)) (mul_zero_class.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_29780 (h0 : topological_space (has_neg Type)) : discrete_topology (has_neg Type) := sorry --non-trivial
lemma new_lemma_29781 (h0 : functor.add_const (ring (complete_distrib_lattice name)) pos) : @rank_condition.{0} (complete_distrib_lattice.{0} name) (@functor.add_const.run.{0 0} (ring.{0} (complete_distrib_lattice.{0} name)) pos h0)  := sorry --non-trivial
lemma new_lemma_29782 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : list.nodup (function.extfun_app (function.extfun_app h0 list) (has_dist unsigned)) := sorry --non-trivial
lemma new_lemma_29783 (h0 : preorder (option empty) -> preorder (option empty) -> Prop) : is_strict_order (preorder (option empty)) h0 := sorry --non-trivial
lemma new_lemma_29784 (h0 : group (random_gen (random_gen (random_gen linarith.comp_source)))) : group.fg (random_gen (random_gen (random_gen linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_29785 (h0 : topological_space (normed_group (semiring num))) : normal_space (normed_group (semiring num)) := sorry --non-trivial
lemma new_lemma_29786 (h0 : function.extfun Type (functor.comp topological_space has_to_string)) : @t0_space.{0} (has_to_string.{0} unsigned) (@functor.comp.run.{0 0 0} topological_space.{0} has_to_string.{0} unsigned (@function.extfun_app.{2 1} Type (functor.comp.{0 0 0} topological_space.{0} has_to_string.{0}) h0 unsigned))  := sorry --non-trivial
lemma new_lemma_29787 (h0 : list (has_inv (random_gen fun_info))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_29788 (h0 : function.extfun Type topological_space) : @normal_space.{0} (ordered_comm_monoid.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (ordered_comm_monoid.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_29789 (h0 : ordered_comm_monoid (ring (option (option (option pos))))) : has_exists_mul_of_le (ring (option (option (option pos)))) := sorry --non-trivial
lemma new_lemma_29790 (h0 : functor.add_const (ordered_add_comm_monoid (ring unsigned)) (has_neg environment.implicit_infer_kind)) : @archimedean.{0} (ring.{0} unsigned) (@functor.add_const.run.{0 0} (ordered_add_comm_monoid.{0} (ring.{0} unsigned)) (has_neg.{0} environment.implicit_infer_kind) h0)  := sorry --non-trivial
lemma new_lemma_29791 (h0 : topological_space (with_bot (has_norm empty))) : normal_space (with_bot (has_norm empty)) := sorry --non-trivial
lemma new_lemma_29792 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @loc_path_connected_space.{1} (has_nndist.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 topological_space.{1}) (has_nndist.{1} Type))  := sorry --non-trivial
lemma new_lemma_29793 (h0 : not (topological_space (has_sub empty) -> false)) : @topological_space.separable_space.{0} (has_sub.{0} empty) (@classical.by_contradiction'.{1} (topological_space.{0} (has_sub.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_29794 (h0 : complete_lattice (has_norm (has_inv (has_inv (has_inv linarith.ineq))))) : is_atomistic (has_norm (has_inv (has_inv (has_inv linarith.ineq)))) := sorry --non-trivial
lemma new_lemma_29795 (h0 : topological_space (ring empty)) : t1_space (ring empty) := sorry --non-trivial
lemma new_lemma_29796 (h0 : list (boolean_algebra.core (comm_group (comm_group (comm_group Type))))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_29797 (h0 : functor.add_const (topological_space (simple_graph pos)) Type) : @normal_space.{0} (simple_graph.{0} pos) (@functor.add_const.run.{0 1} (topological_space.{0} (simple_graph.{0} pos)) Type h0)  := sorry --non-trivial
lemma new_lemma_29798 (h0 : topological_space (add_group (has_norm linarith.comp))) : preirreducible_space (add_group (has_norm linarith.comp)) := sorry --non-trivial
lemma new_lemma_29799 (h0 : function.extfun Type topological_space) : @totally_separated_space.{0} (comm_monoid.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (comm_monoid.{0} empty))  := sorry --non-trivial
lemma new_lemma_29800 (h0 : has_mem.mem (semiring empty) has_emptyc.emptyc) : @preirreducible_space.{0} (semiring.{0} empty) (@finset.pi.empty.{1 0} Type topological_space.{0} (semiring.{0} empty) h0)  := sorry --non-trivial
lemma new_lemma_29801 (h0 : complete_lattice (boolean_algebra (has_to_string (has_to_string unsigned)))) : complete_lattice.is_Sup_finite_compact (boolean_algebra (has_to_string (has_to_string unsigned))) := sorry --non-trivial
lemma new_lemma_29802 (h0 : monoid (random_gen (random_gen (random_gen to_additive.value_type)))) : monoid.fg (random_gen (random_gen (random_gen to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_29803 (h0 : functor.add_const (ring name) unsigned) : @strong_rank_condition.{0} name (@functor.add_const.run.{0 0} (ring.{0} name) unsigned h0)  := sorry --non-trivial
lemma new_lemma_29804 (h0 : filter (has_compl (has_nnnorm linarith.comp_source))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_29805 (h0 : topological_space (complete_semilattice_Sup empty)) : totally_separated_space (complete_semilattice_Sup empty) := sorry --non-trivial
lemma new_lemma_29806 (h0 : topological_space (free_add_monoid congr_arg_kind)) : totally_separated_space (free_add_monoid congr_arg_kind) := sorry --non-trivial
lemma new_lemma_29807 (h0 : ring (uniform_space (mul_one_class (mul_one_class (mul_one_class string_imp))))) : strong_rank_condition (uniform_space (mul_one_class (mul_one_class (mul_one_class string_imp)))) := sorry --non-trivial
lemma new_lemma_29808 (h0 : topological_space (has_div (mul_one_class char))) : totally_disconnected_space (has_div (mul_one_class char)) := sorry --non-trivial
lemma new_lemma_29809 (h0 : group (ordered_cancel_add_comm_monoid congr_arg_kind)) : is_cyclic (ordered_cancel_add_comm_monoid congr_arg_kind) := sorry --non-trivial
lemma new_lemma_29810 (h0 : function.extfun (finset Type) (has_mem.mem (has_top num))) : @discrete_topology.{0} (has_top.{0} num) (@finset.pi.empty.{1 0} Type topological_space.{0} (has_top.{0} num) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (has_top.{0} num)) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_29811 (h0 : functor.add_const (topological_space (boolean_algebra linarith.comp)) (has_add name)) : @discrete_topology.{0} (boolean_algebra.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (boolean_algebra.{0} linarith.comp)) (has_add.{0} name) h0)  := sorry --non-trivial
lemma new_lemma_29812 (h0 : functor.add_const (topological_space (boolean_algebra name)) (comm_group Type)) : @preconnected_space.{0} (boolean_algebra.{0} name) (@functor.add_const.run.{0 1} (topological_space.{0} (boolean_algebra.{0} name)) (comm_group.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_29813 (h0 : add_group (random_gen (has_top (denumerable linarith.ineq)))) : is_add_cyclic (random_gen (has_top (denumerable linarith.ineq))) := sorry --non-trivial
lemma new_lemma_29814 (h0 : functor.add_const (topological_space (has_add pos)) linarith.comp) : @t0_space.{0} (has_add.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (has_add.{0} pos)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_29815 (h0 : functor.add_const Prop (pseudo_metric_space (option unsigned))) : functor.add_const.run h0 := sorry --non-trivial
lemma new_lemma_29816 (h0 : topological_space (has_to_string (finset linarith.comp))) : normal_space (has_to_string (finset linarith.comp)) := sorry --non-trivial
lemma new_lemma_29817 (h0 : functor.add_const (semiring (has_star empty)) unsigned) : @is_noetherian_ring.{0} (has_star.{0} empty) (@functor.add_const.run.{0 0} (semiring.{0} (has_star.{0} empty)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_29818 (h0 : functor.add_const (group (comm_group unsigned)) name) : @normalizer_condition.{0} (comm_group.{0} unsigned) (@functor.add_const.run.{0 0} (group.{0} (comm_group.{0} unsigned)) name h0)  := sorry --non-trivial
lemma new_lemma_29819 (h0 : topological_space (add_cancel_monoid (finset linarith.comp))) : normal_space (add_cancel_monoid (finset linarith.comp)) := sorry --non-trivial
lemma new_lemma_29820 (h0 : complete_lattice (has_lt environment.implicit_infer_kind)) : is_compactly_generated (has_lt environment.implicit_infer_kind) := sorry --non-trivial
lemma new_lemma_29821 (h0 : not (topological_space (has_star unsigned) -> false)) : @totally_separated_space.{0} (has_star.{0} unsigned) (@classical.by_contradiction'.{1} (topological_space.{0} (has_star.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_29822 (h0 : not (complete_lattice (has_compl linarith.ineq) -> false)) : @complete_lattice.is_Sup_finite_compact.{0} (has_compl.{0} linarith.ineq) (@classical.by_contradiction'.{1} (complete_lattice.{0} (has_compl.{0} linarith.ineq)) h0)  := sorry --non-trivial
lemma new_lemma_29823 (h0 : function.extfun Type cancel_comm_monoid_with_zero) : @unique_factorization_monoid.{0} (monoid.{0} num) (@function.extfun_app.{2 1} Type cancel_comm_monoid_with_zero.{0} h0 (monoid.{0} num))  := sorry --non-trivial
lemma new_lemma_29824 (h0 : functor.add_const (finset (cancel_monoid name)) Type) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_29825 (h0 : function.extfun Type complete_lattice) : @is_atomistic.{0} (has_norm.{0} linarith.ineq) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (has_norm.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_29826 (h0 : list (finset (has_pos_part (has_nndist linarith.comp)))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_29827 (h0 : function.extfun nat fin) : @has_exists_mul_of_le.{0} (has_bot.{0} real) (@function.extfun_app.{2 1} Type ordered_comm_monoid.{0} (@matrix.vec_empty.{1} (function.extfun.{2 1} Type ordered_comm_monoid.{0}) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero))) (has_bot.{0} real))  := sorry --non-trivial
lemma new_lemma_29828 (h0 : function.extfun Type topological_space) : @path_connected_space.{0} (has_neg.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_neg.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_29829 (h0 : topological_space (group_with_zero (option (option (option (option ennreal)))))) : t0_space (group_with_zero (option (option (option (option ennreal))))) := sorry --non-trivial
lemma new_lemma_29830 (h0 : ring (has_top linarith.ineq)) : is_domain (has_top linarith.ineq) := sorry --non-trivial
lemma new_lemma_29831 (h0 : ring (add_comm_monoid ennreal)) : is_principal_ideal_ring (add_comm_monoid ennreal) := sorry --non-trivial
lemma new_lemma_29832 (h0 : functor.add_const (ring (has_Inf linarith.comp)) pos) : @is_domain.{0} (has_Inf.{0} linarith.comp) (@functor.add_const.run.{0 0} (ring.{0} (has_Inf.{0} linarith.comp)) pos h0)  := sorry --non-trivial
lemma new_lemma_29833 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_compactly_generated.{0} (@id.{2} Type num) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (@id.{2} Type num))  := sorry --non-trivial
lemma new_lemma_29834 (h0 : function.extfun Type (functor.comp topological_space complete_distrib_lattice)) : @discrete_topology.{0} (complete_distrib_lattice.{0} name) (@functor.comp.run.{0 0 0} topological_space.{0} complete_distrib_lattice.{0} name (@function.extfun_app.{2 1} Type (functor.comp.{0 0 0} topological_space.{0} complete_distrib_lattice.{0}) h0 name))  := sorry --non-trivial
lemma new_lemma_29835 (h0 : uniform_space (boolean_algebra.core Type)) : separated_space (boolean_algebra.core Type) := sorry --non-trivial
lemma new_lemma_29836 (h0 : functor.add_const (topological_space (generalized_boolean_algebra Type)) (simple_graph linarith.comp)) : @t0_space.{1} (generalized_boolean_algebra.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (generalized_boolean_algebra.{1} Type)) (simple_graph.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_29837 (h0 : topological_space (comm_group (boolean_algebra.core (has_add name)))) : irreducible_space (comm_group (boolean_algebra.core (has_add name))) := sorry --non-trivial
lemma new_lemma_29838 (h1 : complete_lattice (random_gen linarith.ineq)) : is_compactly_generated (random_gen linarith.ineq) := sorry --non-trivial
lemma new_lemma_29839 (h0 : functor.add_const Prop (normed_comm_ring name)) : functor.add_const.run h0 := sorry --non-trivial
lemma new_lemma_29840 (h0 : function.extfun Type ring) : @is_domain.{0} (has_top.{0} fun_info) (@function.extfun_app.{2 1} Type ring.{0} h0 (has_top.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_29841 (h0 : ordered_add_comm_monoid (generalized_boolean_algebra (has_add name))) : archimedean (generalized_boolean_algebra (has_add name)) := sorry --non-trivial
lemma new_lemma_29842 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @irreducible_space.{0} (measurable_space.dynkin_system.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (measurable_space.dynkin_system.{0} num))  := sorry --non-trivial
lemma new_lemma_29843 (h0 : functor.add_const (complete_lattice (has_zero ennreal)) name) : @complete_lattice.is_Sup_finite_compact.{0} (has_zero.{0} ennreal) (@functor.add_const.run.{0 0} (complete_lattice.{0} (has_zero.{0} ennreal)) name h0)  := sorry --non-trivial
lemma new_lemma_29844 (h0 : set (add_comm_semigroup (add_comm_semigroup (mul_one_class ereal)) -> ereal)) : set.separates_points (is_lub h0) := sorry --non-trivial
lemma new_lemma_29845 (h0 : function.extfun Type group) : @is_cyclic.{0} (has_zero.{0} num) (@function.extfun_app.{2 1} Type group.{0} h0 (has_zero.{0} num))  := sorry --non-trivial
lemma new_lemma_29846 (h0 : normed_comm_ring ennreal -> normed_comm_ring ennreal -> Prop) : is_refl (normed_comm_ring ennreal) h0 := sorry --non-trivial
lemma new_lemma_29847 (h0 : function.extfun (finset (Type -> Type)) (has_mem.mem topological_space)) : @locally_compact_space.{0} linarith.comp_source (@function.extfun_app.{2 1} Type topological_space.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) topological_space.{0} (@function.extfun_app.{2 0} (finset.{1} (Type → Type)) (@has_mem.mem.{1 1} (Type → Type) (finset.{1} (Type → Type)) (@finset.has_mem.{1} (Type → Type)) topological_space.{0}) h0 (@has_emptyc.emptyc.{1} (finset.{1} (Type → Type)) (@finset.has_emptyc.{1} (Type → Type))))) linarith.comp_source)  := sorry --non-trivial
lemma new_lemma_29848 (h0 : function.extfun Type filter) : filter.ne_bot (function.extfun_app h0 (has_zero ennreal)) := sorry --non-trivial
lemma new_lemma_29849 (h0 : functor.add_const (add_group (comm_group unsigned)) name) : @is_add_cyclic.{0} (comm_group.{0} unsigned) (@functor.add_const.run.{0 0} (add_group.{0} (comm_group.{0} unsigned)) name h0)  := sorry --non-trivial
lemma new_lemma_29850 (h0 : filter (distrib string_imp)) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_29851 (h0 : topological_space (normed_lattice_add_comm_group (has_add (has_add (has_Inf pos))))) : loc_path_connected_space (normed_lattice_add_comm_group (has_add (has_add (has_Inf pos)))) := sorry --non-trivial
lemma new_lemma_29852 (h0 : list (ring (option (option unsigned)))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_29853 (h0 : functor.add_const (complete_lattice (finset pos)) Type) : @is_compactly_generated.{0} (finset.{0} pos) (@functor.add_const.run.{0 1} (complete_lattice.{0} (finset.{0} pos)) Type h0)  := sorry --non-trivial
lemma new_lemma_29854 (h0 : function.extfun Type group) : @normalizer_condition.{0} (add_right_cancel_monoid.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type group.{0} h0 (add_right_cancel_monoid.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_29855 (h0 : fin has_zero.zero) : @is_compactly_generated.{0} (canonically_ordered_monoid.{0} linarith.comp) (@matrix.vec_empty.{0} (complete_lattice.{0} (canonically_ordered_monoid.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_29856 (h0 : function.extfun Type topological_space) : @regular_space.{0} (has_neg.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_neg.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_29857 (h0 : topological_space (semigroup (finset linarith.comp))) : totally_disconnected_space (semigroup (finset linarith.comp)) := sorry --non-trivial
lemma new_lemma_29858 (h0 : filter (complete_distrib_lattice congr_arg_kind)) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_29859 (h0 : ring (uniform_space (add_right_cancel_monoid reducibility_hints))) : is_domain (uniform_space (add_right_cancel_monoid reducibility_hints)) := sorry --non-trivial
lemma new_lemma_29860 (h0 : function.extfun Type monoid) : @monoid.fg.{0} (linear_ordered_add_comm_group.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type monoid.{0} h0 (linear_ordered_add_comm_group.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_29861 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @complete_space.{0} (normed_comm_ring.{0} empty) (@function.extfun_app.{2 1} Type uniform_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 uniform_space.{0}) (normed_comm_ring.{0} empty))  := sorry --non-trivial
lemma new_lemma_29862 (h0 : functor.add_const (group (ring linarith.comp)) (ring pos)) : @is_simple_group.{0} (ring.{0} linarith.comp) (@functor.add_const.run.{0 0} (group.{0} (ring.{0} linarith.comp)) (ring.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_29863 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_cyclic.{0} (add_comm_monoid.{0} unsigned) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (add_comm_monoid.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_29864 (h0 : functor.add_const (topological_space (cancel_monoid pos)) name) : @totally_disconnected_space.{0} (cancel_monoid.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (cancel_monoid.{0} pos)) name h0)  := sorry --non-trivial
lemma new_lemma_29865 (h0 : filter (add_comm_monoid (option ennreal))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_29866 (h0 : functor.add_const (list (has_add name)) unsigned) : list.nodup (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_29867 (h0 : functor.add_const (topological_space (has_neg linarith.comp)) Type) : @path_connected_space.{0} (has_neg.{0} linarith.comp) (@functor.add_const.run.{0 1} (topological_space.{0} (has_neg.{0} linarith.comp)) Type h0)  := sorry --non-trivial
lemma new_lemma_29868 (h0 : add_group (has_norm (with_bot to_additive.value_type))) : is_add_cyclic (has_norm (with_bot to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_29869 (h0 : topological_space (normed_group (has_norm fun_info))) : totally_disconnected_space (normed_group (has_norm fun_info)) := sorry --non-trivial
lemma new_lemma_29870 (h0 : function.extfun Type complete_lattice) : @complete_lattice.is_Sup_finite_compact.{0} (has_nndist.{0} pos) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (has_nndist.{0} pos))  := sorry --non-trivial
lemma new_lemma_29871 (h0 : metric_space pos) (h1 : set pos) : euclidean_geometry.cospherical h1 := sorry --non-trivial
lemma new_lemma_29872 (h2 : has_mem.mem (linear_ordered_add_comm_group linarith.comp_source) has_emptyc.emptyc) : @totally_disconnected_space.{0} (linear_ordered_add_comm_group.{0} linarith.comp_source) (@finset.pi.empty.{1 0} Type topological_space.{0} (linear_ordered_add_comm_group.{0} linarith.comp_source) h2)  := sorry --non-trivial
lemma new_lemma_29873 (h0 : topological_space (has_zero (ring linarith.comp))) : totally_disconnected_space (has_zero (ring linarith.comp)) := sorry --non-trivial
lemma new_lemma_29874 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @loc_path_connected_space.{0} (finset.{0} ennreal) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (finset.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_29875 (h0 : functor.add_const (ordered_add_comm_monoid (has_neg linarith.comp)) name) : @archimedean.{0} (has_neg.{0} linarith.comp) (@functor.add_const.run.{0 0} (ordered_add_comm_monoid.{0} (has_neg.{0} linarith.comp)) name h0)  := sorry --non-trivial
lemma new_lemma_29876 (h0 : list (topological_space (has_nnnorm (random_gen fun_info)))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_29877 (h0 : functor.add_const (add_monoid (has_to_string pos)) Type) : @add_monoid.fg.{0} (has_to_string.{0} pos) (@functor.add_const.run.{0 1} (add_monoid.{0} (has_to_string.{0} pos)) Type h0)  := sorry --non-trivial
lemma new_lemma_29878 (h0 : function.extfun (Type 1) (functor.comp group boolean_algebra)) : @group.fg.{1} (boolean_algebra.{1} Type) (@functor.comp.run.{1 1 1} group.{1} boolean_algebra.{1} Type (@function.extfun_app.{3 2} (Type 1) (functor.comp.{1 1 1} group.{1} boolean_algebra.{1}) h0 Type))  := sorry --non-trivial
lemma new_lemma_29879 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @sequential_space.{1} Type (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 topological_space.{1}) Type)  := sorry --non-trivial
lemma new_lemma_29880 (h0 : functor.add_const (finset (has_pos_part Type)) (has_neg Type)) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_29881 (h0 : function.extfun Type topological_space) : @totally_separated_space.{0} (with_one.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (with_one.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_29882 (h0 : ring (has_nndist (has_neg pos))) : rank_condition (has_nndist (has_neg pos)) := sorry --non-trivial
lemma new_lemma_29883 (h0 : function.extfun Type topological_space) : @normal_space.{0} (add_group.{0} (semiring.{0} unsigned)) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (add_group.{0} (semiring.{0} unsigned)))  := sorry --non-trivial
lemma new_lemma_29884 (h0 : function.extfun Type ring) : @is_principal_ideal_ring.{0} (normed_group.{0} empty) (@function.extfun_app.{2 1} Type ring.{0} h0 (normed_group.{0} empty))  := sorry --non-trivial
lemma new_lemma_29885 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @add_monoid.fg.{1} (semigroup.{1} Type) (@function.extfun_app.{3 2} (Type 1) add_monoid.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 add_monoid.{1}) (semigroup.{1} Type))  := sorry --non-trivial
lemma new_lemma_29886 (h0 : ordered_add_comm_monoid (monoid (option unsigned))) : archimedean (monoid (option unsigned)) := sorry --non-trivial
lemma new_lemma_29887 (h0 : functor.add_const (ordered_add_comm_monoid (mul_zero_class Type)) Type) : @archimedean.{1} (mul_zero_class.{1} Type) (@functor.add_const.run.{1 1} (ordered_add_comm_monoid.{1} (mul_zero_class.{1} Type)) Type h0)  := sorry --non-trivial
lemma new_lemma_29888 (h0 : filter (normed_comm_ring (ring environment.implicit_infer_kind))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_29889 (h0 : ring (uniform_space linarith.comp_source)) : rank_condition (uniform_space linarith.comp_source) := sorry --non-trivial
lemma new_lemma_29890 (h1 : ring (semi_normed_ring (has_nnnorm (has_nnnorm linarith.ineq)))) : rank_condition (semi_normed_ring (has_nnnorm (has_nnnorm linarith.ineq))) := sorry --non-trivial
lemma new_lemma_29891 (h0 : functor.add_const (group (finset pos)) (has_Inf (has_Inf linarith.comp))) : @is_simple_group.{0} (finset.{0} pos) (@functor.add_const.run.{0 0} (group.{0} (finset.{0} pos)) (has_Inf.{0} (has_Inf.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_29892 (h0 : list (filter congr_arg_kind)) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_29893 (h0 : functor.add_const (ordered_comm_monoid (add_cancel_monoid linarith.comp)) linarith.comp) : @has_exists_mul_of_le.{0} (add_cancel_monoid.{0} linarith.comp) (@functor.add_const.run.{0 0} (ordered_comm_monoid.{0} (add_cancel_monoid.{0} linarith.comp)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_29894 (h0 : ring (has_nndist (has_add unsigned))) : strong_rank_condition (has_nndist (has_add unsigned)) := sorry --non-trivial
lemma new_lemma_29895 (h2 : function.extfun Type add_group) : @is_add_cyclic.{0} congr_arg_kind (@function.extfun_app.{2 1} Type add_group.{0} h2 congr_arg_kind)  := sorry --non-trivial
lemma new_lemma_29896 (h0 : functor.add_const (list (ordered_comm_ring Type)) (ring linarith.comp)) : list.nodup (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_29897 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @regular_space.{1} (normed_linear_ordered_group.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 topological_space.{1}) (normed_linear_ordered_group.{1} Type))  := sorry --non-trivial
lemma new_lemma_29898 (h0 : functor.add_const (ring (boolean_algebra.core empty)) (option empty)) : @rank_condition.{0} (boolean_algebra.core.{0} empty) (@functor.add_const.run.{0 0} (ring.{0} (boolean_algebra.core.{0} empty)) (option.{0} empty) h0)  := sorry --non-trivial
lemma new_lemma_29899 (h0 : functor.add_const (function.extfun Type topological_space) linarith.comp) : @t0_space.{0} (complete_distrib_lattice.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) linarith.comp h0) (complete_distrib_lattice.{0} name))  := sorry --non-trivial
lemma new_lemma_29900 (h1 : function.extfun (Type -> Type) (function.extfun Type)) : @group.fg.{0} (with_bot.{0} fun_info) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h1 group.{0}) (with_bot.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_29901 (h0 : not (uniform_space (has_one unsigned) -> false)) : @separated_space.{0} (has_one.{0} unsigned) (@classical.by_contradiction'.{1} (uniform_space.{0} (has_one.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_29902 (h0 : function.extfun Type (functor.comp topological_space has_neg)) : @regular_space.{0} (has_neg.{0} pos) (@functor.comp.run.{0 0 0} topological_space.{0} has_neg.{0} pos (@function.extfun_app.{2 1} Type (functor.comp.{0 0 0} topological_space.{0} has_neg.{0}) h0 pos))  := sorry --non-trivial
lemma new_lemma_29903 (h0 : function.extfun Type group) : @normalizer_condition.{0} (has_bot.{0} pos) (@function.extfun_app.{2 1} Type group.{0} h0 (has_bot.{0} pos))  := sorry --non-trivial
lemma new_lemma_29904 (h0 : function.extfun (Type 1) (functor.add_const Prop)) : functor.add_const.run (function.extfun_app h0 (has_Inf Type)) := sorry --non-trivial
lemma new_lemma_29905 (h0 : semiring (linear_order empty)) : is_noetherian_ring (linear_order empty) := sorry --non-trivial
lemma new_lemma_29906 (h0 : not (function.extfun (finset Type) (has_mem.mem linarith.comp) -> false)) : @monoid.fg.{0} linarith.comp (@finset.pi.empty.{1 0} Type monoid.{0} linarith.comp (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) linarith.comp) (@classical.by_contradiction'.{0} (function.extfun.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) linarith.comp)) h0) (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_29907 (h0 : add_group (topological_space (comm_ring to_additive.value_type))) : is_add_cyclic (topological_space (comm_ring to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_29908 (h1 : topological_space (add_comm_semigroup (mul_one_class char))) (h2 : set (add_comm_semigroup (mul_one_class char))) : is_path_connected h2 := sorry --non-trivial
lemma new_lemma_29909 (h0 : function.extfun Type (functor.comp topological_space mul_zero_class)) : @topological_space.separable_space.{0} (mul_zero_class.{0} unsigned) (@functor.comp.run.{0 0 0} topological_space.{0} mul_zero_class.{0} unsigned (@function.extfun_app.{2 1} Type (functor.comp.{0 0 0} topological_space.{0} mul_zero_class.{0}) h0 unsigned))  := sorry --non-trivial
lemma new_lemma_29910 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @normalizer_condition.{0} (dlist.{0} linarith.ineq) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (dlist.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_29911 (h0 : ring (complete_distrib_lattice (normed_comm_ring Type))) : is_domain (complete_distrib_lattice (normed_comm_ring Type)) := sorry --non-trivial
lemma new_lemma_29912 (h0 : complete_lattice (has_one empty)) : is_compactly_generated (has_one empty) := sorry --non-trivial
lemma new_lemma_29913 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_atomistic.{0} (has_sub.{0} num) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (has_sub.{0} num))  := sorry --non-trivial
lemma new_lemma_29914 (h0 : topological_space (has_nndist pos)) : totally_disconnected_space (has_nndist pos) := sorry --non-trivial
lemma new_lemma_29915 (h0 : not (ring (normed_group char) -> false)) : @is_domain.{0} (normed_group.{0} char) (@classical.by_contradiction'.{1} (ring.{0} (normed_group.{0} char)) h0)  := sorry --non-trivial
lemma new_lemma_29916 (h0 : semiring (has_dist (option (option ennreal)))) : is_noetherian_ring (has_dist (option (option ennreal))) := sorry --non-trivial
lemma new_lemma_29917 (h0 : group (canonically_linear_ordered_monoid Type)) : is_simple_group (canonically_linear_ordered_monoid Type) := sorry --non-trivial
lemma new_lemma_29918 (h0 : functor.add_const (finset (has_to_string Type)) Type) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_29919 (h1 : not (function.extfun Type ring -> false)) : @strong_rank_condition.{0} (linear_ordered_semiring.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type ring.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type ring.{0}) h1) (linear_ordered_semiring.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_29920 (h0 : function.extfun Type ring) : @strong_rank_condition.{0} (finset.{0} num) (@function.extfun_app.{2 1} Type ring.{0} h0 (finset.{0} num))  := sorry --non-trivial
lemma new_lemma_29921 (h0 : functor.add_const (topological_space (ring environment.implicit_infer_kind)) Type) : @sequential_space.{0} (ring.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 1} (topological_space.{0} (ring.{0} environment.implicit_infer_kind)) Type h0)  := sorry --non-trivial
lemma new_lemma_29922 (h0 : topological_space (comm_semigroup (has_bot (sub_neg_monoid real)))) : discrete_topology (comm_semigroup (has_bot (sub_neg_monoid real))) := sorry --non-trivial
lemma new_lemma_29923 (h0 : functor.add_const (group (has_Inf pos)) name) : @normalizer_condition.{0} (has_Inf.{0} pos) (@functor.add_const.run.{0 0} (group.{0} (has_Inf.{0} pos)) name h0)  := sorry --non-trivial
lemma new_lemma_29924 (h0 : topological_space (uniform_space (plift char))) : path_connected_space (uniform_space (plift char)) := sorry --non-trivial
lemma new_lemma_29925 (h0 : list (boolean_algebra.core num)) : palindrome h0 := sorry --non-trivial
lemma new_lemma_29926 (h0 : topological_space (simple_graph (has_Inf (has_Inf pos)))) : loc_path_connected_space (simple_graph (has_Inf (has_Inf pos))) := sorry --non-trivial
lemma new_lemma_29927 (h0 : functor.add_const (ring (has_neg linarith.comp)) Type) : @strong_rank_condition.{0} (has_neg.{0} linarith.comp) (@functor.add_const.run.{0 1} (ring.{0} (has_neg.{0} linarith.comp)) Type h0)  := sorry --non-trivial
lemma new_lemma_29928 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @add_monoid.fg.{0} (with_bot.{0} linarith.comp) (@function.extfun_app.{2 1} Type add_monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 add_monoid.{0}) (with_bot.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_29929 (h0 : prod (with_bot (semiring num)) (with_bot (semiring num))) : id_rel h0 := sorry --non-trivial
lemma new_lemma_29930 (h0 : topological_space (pseudo_metric_space (option (option empty)))) : discrete_topology (pseudo_metric_space (option (option empty))) := sorry --non-trivial
lemma new_lemma_29931 (h0 : functor.add_const (function.extfun Type topological_space) Type) : @t1_space.{0} (ring.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type topological_space.{0}) Type h0) (ring.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_29932 (h0 : functor.add_const (topological_space (ordered_cancel_add_comm_monoid ennreal)) num) : @irreducible_space.{0} (ordered_cancel_add_comm_monoid.{0} ennreal) (@functor.add_const.run.{0 0} (topological_space.{0} (ordered_cancel_add_comm_monoid.{0} ennreal)) num h0)  := sorry --non-trivial
lemma new_lemma_29933 (h0 : topological_space (has_nndist (has_to_string (has_to_string (ring (has_neg pos)))))) : topological_space.separable_space (has_nndist (has_to_string (has_to_string (ring (has_neg pos))))) := sorry --non-trivial
lemma new_lemma_29934 (h0 : topological_space (monoid congr_arg_kind)) : irreducible_space (monoid congr_arg_kind) := sorry --non-trivial
lemma new_lemma_29935 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @topological_space.separable_space.{0} (canonically_linear_ordered_monoid.{0} real) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (canonically_linear_ordered_monoid.{0} real))  := sorry --non-trivial
lemma new_lemma_29936 (h0 : not (group (semiring num) -> false)) : @is_cyclic.{0} (semiring.{0} num) (@classical.by_contradiction'.{1} (group.{0} (semiring.{0} num)) h0)  := sorry --non-trivial
lemma new_lemma_29937 (h0 : topological_space (topological_space (has_nnnorm linarith.ineq))) : t0_space (topological_space (has_nnnorm linarith.ineq)) := sorry --non-trivial
lemma new_lemma_29938 (h0 : functor.add_const (topological_space (boolean_algebra unsigned)) linarith.comp) : @preconnected_space.{0} (boolean_algebra.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (boolean_algebra.{0} unsigned)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_29939 (h0 : function.extfun Type uniform_space) : @complete_space.{0} (has_Inf.{0} linarith.comp) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (has_Inf.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_29940 (h0 : topological_space (has_lt std_gen)) : t0_space (has_lt std_gen) := sorry --non-trivial
lemma new_lemma_29941 (h0 : topological_space (cancel_monoid (option empty))) : topological_space.separable_space (cancel_monoid (option empty)) := sorry --non-trivial
lemma new_lemma_29942 (h0 : fin has_zero.zero) (h1 h2 : nat) : nat.modeq (matrix.vec_empty h0) h1 h2 := sorry --non-trivial
lemma new_lemma_29943 (h3 : topological_space char) (h4 : preorder char) : order_topology char := sorry --non-trivial
lemma new_lemma_29944 (h0 : uniform_space (option (semiring (semiring (semiring (semiring (semiring num))))))) : separated_space (option (semiring (semiring (semiring (semiring (semiring num)))))) := sorry --non-trivial
lemma new_lemma_29945 (h0 : ring (has_zero (option ennreal))) : is_domain (has_zero (option ennreal)) := sorry --non-trivial
lemma new_lemma_29946 (h0 : ring (sub_neg_monoid pos)) : rank_condition (sub_neg_monoid pos) := sorry --non-trivial
lemma new_lemma_29947 (h0 : fin has_zero.zero) : @is_atomistic.{0} real (@functor.add_const.run.{0 0} (complete_lattice.{0} real) pos (@matrix.vec_empty.{0} (functor.add_const.{0 0} (complete_lattice.{0} real) pos) h0))  := sorry --non-trivial
lemma new_lemma_29948 (h0 : functor.add_const (add_monoid (canonically_ordered_monoid linarith.comp)) name) : @add_monoid.fg.{0} (canonically_ordered_monoid.{0} linarith.comp) (@functor.add_const.run.{0 0} (add_monoid.{0} (canonically_ordered_monoid.{0} linarith.comp)) name h0)  := sorry --non-trivial
lemma new_lemma_29949 (h0 : is_empty Type) : @complete_lattice.is_Sup_finite_compact.{0} (add_comm_semigroup.{0} enat) (@is_empty.elim.{2 1} Type h0 complete_lattice.{0} (add_comm_semigroup.{0} enat))  := sorry --non-trivial
lemma new_lemma_29950 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_compactly_generated.{0} (encodable.{0} string_imp) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (encodable.{0} string_imp))  := sorry --non-trivial
lemma new_lemma_29951 (h0 : uniform_space (topological_space (has_nnnorm reducibility_hints))) : complete_space (topological_space (has_nnnorm reducibility_hints)) := sorry --non-trivial
lemma new_lemma_29952 (h0 : not (topological_space (has_nnnorm (random_gen reducibility_hints)) -> false)) : @t0_space.{0} (has_nnnorm.{0} (random_gen.{0} reducibility_hints)) (@classical.by_contradiction'.{1} (topological_space.{0} (has_nnnorm.{0} (random_gen.{0} reducibility_hints))) h0)  := sorry --non-trivial
lemma new_lemma_29953 (h0 : filter (has_pos_part (normed_comm_ring (has_neg (has_sdiff (has_neg (normed_comm_ring (has_add (finset pos))))))))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_29954 (h0 : function.extfun Type ring) : @is_domain.{0} (has_top.{0} (comm_ring.{0} (random_gen.{0} (random_gen.{0} (random_gen.{0} fun_info))))) (@function.extfun_app.{2 1} Type ring.{0} h0 (has_top.{0} (comm_ring.{0} (random_gen.{0} (random_gen.{0} (random_gen.{0} fun_info))))))  := sorry --non-trivial
lemma new_lemma_29955 (h0 : functor.add_const (ring (has_to_string Type)) (has_add Type)) : @is_principal_ideal_ring.{1} (has_to_string.{1} Type) (@functor.add_const.run.{1 1} (ring.{1} (has_to_string.{1} Type)) (has_add.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_29956 (h0 : not (topological_space (has_compl linarith.ineq) -> false)) : @locally_compact_space.{0} (has_compl.{0} linarith.ineq) (@classical.by_contradiction'.{1} (topological_space.{0} (has_compl.{0} linarith.ineq)) h0)  := sorry --non-trivial
lemma new_lemma_29957 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @complete_lattice.is_Sup_finite_compact.{0} (ring.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (ring.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_29958 (h0 : topological_space (simple_graph (ring (finset linarith.comp)))) : discrete_topology (simple_graph (ring (finset linarith.comp))) := sorry --non-trivial
lemma new_lemma_29959 (h0 : complete_lattice (has_emptyc (has_norm (has_top to_additive.value_type)))) : is_atomistic (has_emptyc (has_norm (has_top to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_29960 (h0 : topological_space (has_union (id (has_norm (has_union (has_union congr_arg_kind)))))) : path_connected_space (has_union (id (has_norm (has_union (has_union congr_arg_kind))))) := sorry --non-trivial
lemma new_lemma_29961 (h0 : filter (canonically_ordered_monoid linarith.comp)) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_29962 (h0 : functor.comp topological_space boolean_algebra.core name) : @path_connected_space.{0} (boolean_algebra.core.{0} name) (@functor.comp.run.{0 0 0} topological_space.{0} boolean_algebra.core.{0} name h0)  := sorry --non-trivial
lemma new_lemma_29963 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @is_compactly_generated.{1} (semigroup.{1} Type) (@function.extfun_app.{3 2} (Type 1) complete_lattice.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 complete_lattice.{1}) (semigroup.{1} Type))  := sorry --non-trivial
lemma new_lemma_29964 (h0 : complete_lattice (measure_theory.measure_space (option (semiring empty)))) : complete_lattice.is_Sup_finite_compact (measure_theory.measure_space (option (semiring empty))) := sorry --non-trivial
lemma new_lemma_29965 (h0 : function.extfun Type complete_lattice) : @is_atomistic.{0} (has_star.{0} num) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (has_star.{0} num))  := sorry --non-trivial
lemma new_lemma_29966 (h0 : list (has_to_string (ring (mul_one_class Type)))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_29967 (h0 : topological_space (omega_complete_partial_order empty)) : path_connected_space (omega_complete_partial_order empty) := sorry --non-trivial
lemma new_lemma_29968 (h0 : topological_space (add_cancel_monoid (ring pos))) : irreducible_space (add_cancel_monoid (ring pos)) := sorry --non-trivial
lemma new_lemma_29969 (h0 : topological_space (denumerable (has_nnnorm fun_info))) : path_connected_space (denumerable (has_nnnorm fun_info)) := sorry --non-trivial
lemma new_lemma_29970 (h0 : function.extfun (Type 1) semiring) : @is_noetherian_ring.{1} Type (@function.extfun_app.{3 2} (Type 1) semiring.{1} h0 Type)  := sorry --non-trivial
lemma new_lemma_29971 (h0 : function.extfun Type add_monoid) : @add_monoid.fg.{0} (has_union.{0} (semiring.{0} (has_union.{0} (semiring.{0} (semiring.{0} (semiring.{0} linarith.comp)))))) (@function.extfun_app.{2 1} Type add_monoid.{0} h0 (has_union.{0} (semiring.{0} (has_union.{0} (semiring.{0} (semiring.{0} (semiring.{0} linarith.comp)))))))  := sorry --non-trivial
lemma new_lemma_29972 (h0 : ring (mul_one_class (mul_one_class enat))) : strong_rank_condition (mul_one_class (mul_one_class enat)) := sorry --non-trivial
lemma new_lemma_29973 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @totally_separated_space.{0} (has_neg_part.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_neg_part.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_29974 (h0 : topological_space (bin_tree empty)) : totally_disconnected_space (bin_tree empty) := sorry --non-trivial
lemma new_lemma_29975 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_simple_group.{0} (has_neg_part.{0} pos) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (has_neg_part.{0} pos))  := sorry --non-trivial
lemma new_lemma_29976 (h0 h1 : multiset (add_comm_semigroup fun_info)) : multiset.subset h0 h1 := sorry --non-trivial
lemma new_lemma_29977 (h0 : topological_space (has_compl ereal)) : t0_space (has_compl ereal) := sorry --non-trivial
lemma new_lemma_29978 (h2 : has_lt string.iterator_imp) : no_max_order string.iterator_imp := sorry --non-trivial
lemma new_lemma_29979 (h0 : topological_space (boolean_algebra (has_Inf linarith.comp))) : topological_space.separable_space (boolean_algebra (has_Inf linarith.comp)) := sorry --non-trivial
lemma new_lemma_29980 (h0 : function.extfun Type (functor.add_const (prod (ordered_ring empty) (ordered_ring empty)))) : id_rel (functor.add_const.run (function.extfun_app h0 empty)) := sorry --non-trivial
lemma new_lemma_29981 (h0 : functor.comp ring mul_zero_class pos) : @rank_condition.{0} (mul_zero_class.{0} pos) (@functor.comp.run.{0 0 0} ring.{0} mul_zero_class.{0} pos h0)  := sorry --non-trivial
lemma new_lemma_29982 (h0 : ring (topological_space (denumerable (comm_ring char)))) : strong_rank_condition (topological_space (denumerable (comm_ring char))) := sorry --non-trivial
lemma new_lemma_29983 (h0 : topological_space (with_bot (has_top (has_top num)))) : totally_disconnected_space (with_bot (has_top (has_top num))) := sorry --non-trivial
lemma new_lemma_29984 (h0 : functor.add_const (complete_lattice (semigroup Type)) (ring Type)) : @is_compactly_generated.{1} (semigroup.{1} Type) (@functor.add_const.run.{1 1} (complete_lattice.{1} (semigroup.{1} Type)) (ring.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_29985 (h0 : not (topological_space (metric_space (metric_space string_imp)) -> false)) : @totally_disconnected_space.{0} (metric_space.{0} (metric_space.{0} string_imp)) (@classical.by_contradiction'.{1} (topological_space.{0} (metric_space.{0} (metric_space.{0} string_imp))) h0)  := sorry --non-trivial
lemma new_lemma_29986 (h0 : functor.add_const (function.extfun Type add_monoid) linarith.comp) : @add_monoid.fg.{0} (has_zero.{0} pos) (@function.extfun_app.{2 1} Type add_monoid.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type add_monoid.{0}) linarith.comp h0) (has_zero.{0} pos))  := sorry --non-trivial
lemma new_lemma_29987 (h0 : functor.add_const (topological_space (has_to_string pos)) unsigned) : @regular_space.{0} (has_to_string.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (has_to_string.{0} pos)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_29988 (h0 : functor.add_const (topological_space (has_to_string pos)) pos) : @preirreducible_space.{0} (has_to_string.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (has_to_string.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_29989 (h0 : preorder (normed_linear_ordered_group empty)) (h1 : cancel_comm_monoid_with_zero (omega_complete_partial_order.chain (normed_linear_ordered_group empty))) : unique_factorization_monoid (omega_complete_partial_order.chain (normed_linear_ordered_group empty)) := sorry --non-trivial
lemma new_lemma_29990 (h2 : topological_space enat) : topological_space.first_countable_topology enat := sorry --non-trivial
lemma new_lemma_29991 (h0 : function.extfun Type topological_space) : @sequential_space.{0} (has_zero.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_zero.{0} pos))  := sorry --non-trivial
lemma new_lemma_29992 (h0 : function.extfun (Type 1) filter) : filter.ne_bot (function.extfun_app h0 (has_neg Type)) := sorry --non-trivial
lemma new_lemma_29993 (h0 : function.extfun Type topological_space) : @locally_compact_space.{0} (measurable_space.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (measurable_space.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_29994 (h0 : has_mem.mem (normed_group empty) has_emptyc.emptyc) : @group.fg.{0} (normed_group.{0} empty) (@finset.pi.empty.{1 0} Type group.{0} (normed_group.{0} empty) h0)  := sorry --non-trivial
lemma new_lemma_29995 (h0 : functor.add_const (group (has_Inf linarith.comp)) linarith.comp) : @is_cyclic.{0} (has_Inf.{0} linarith.comp) (@functor.add_const.run.{0 0} (group.{0} (has_Inf.{0} linarith.comp)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_29996 (h0 : add_group (has_Inf (boolean_algebra.core pos))) : is_add_cyclic (has_Inf (boolean_algebra.core pos)) := sorry --non-trivial
lemma new_lemma_29997 (h0 : uniform_space (has_one linarith.comp)) : complete_space (has_one linarith.comp) := sorry --non-trivial
lemma new_lemma_29998 (h0 : functor.add_const (topological_space (cancel_monoid name)) environment.implicit_infer_kind) : @topological_space.separable_space.{0} (cancel_monoid.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (cancel_monoid.{0} name)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_29999 (h0 : add_group (ordered_comm_ring (ring pos))) : is_add_cyclic (ordered_comm_ring (ring pos)) := sorry --non-trivial
lemma new_lemma_30000 (h0 : group (finset (finset (finset (has_neg Type))))) : is_simple_group (finset (finset (finset (has_neg Type)))) := sorry --non-trivial
lemma new_lemma_30001 (h0 : function.extfun (Type 1) (prod (plift empty))) : id_rel (function.extfun_app h0 (plift empty)) := sorry --non-trivial
lemma new_lemma_30002 (h0 : topological_space (comm_semigroup (has_Inf pos))) : path_connected_space (comm_semigroup (has_Inf pos)) := sorry --non-trivial
lemma new_lemma_30003 (h0 : group (complete_semilattice_Sup (has_top fun_info))) : group.fg (complete_semilattice_Sup (has_top fun_info)) := sorry --non-trivial
lemma new_lemma_30004 (h0 : topological_space (ring (ring (has_zero linarith.comp)))) : preirreducible_space (ring (ring (has_zero linarith.comp))) := sorry --non-trivial
lemma new_lemma_30005 (h0 : complete_lattice (ordered_cancel_comm_monoid (semiring num))) : is_compactly_generated (ordered_cancel_comm_monoid (semiring num)) := sorry --non-trivial
lemma new_lemma_30006 (h0 : functor.add_const (topological_space (pseudo_metric_space name)) unsigned) : @normal_space.{0} (pseudo_metric_space.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (pseudo_metric_space.{0} name)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_30007 (h0 : complete_lattice (comm_ring (has_nnnorm (random_gen linarith.ineq)))) : is_compactly_generated (comm_ring (has_nnnorm (random_gen linarith.ineq))) := sorry --non-trivial
lemma new_lemma_30008 (h0 : not (function.extfun Type topological_space -> false)) : @totally_separated_space.{0} (with_bot.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (with_bot.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_30009 (h1 : set (set string.iterator_imp)) (h2 : set string.iterator_imp) : filter.generate_sets h1 h2 := sorry --non-trivial
lemma new_lemma_30010 (h0 : function.extfun (finset Type) (has_mem.mem (linear_ordered_semiring fun_info))) : @path_connected_space.{0} (linear_ordered_semiring.{0} fun_info) (@finset.pi.empty.{1 0} Type topological_space.{0} (linear_ordered_semiring.{0} fun_info) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (linear_ordered_semiring.{0} fun_info)) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_30011 (h0 : topological_space (add_cancel_comm_monoid (mul_one_class (cancel_comm_monoid_with_zero char)))) : t0_space (add_cancel_comm_monoid (mul_one_class (cancel_comm_monoid_with_zero char))) := sorry --non-trivial
lemma new_lemma_30012 (h0 : not (add_group (id congr_arg_kind) -> false)) : @is_add_cyclic.{0} (@id.{2} Type congr_arg_kind) (@classical.by_contradiction'.{1} (add_group.{0} (@id.{2} Type congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_30013 (h0 : list (pseudo_metric_space (finset (finset (has_add (finset pos)))))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_30014 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @group.fg.{0} (measurable_space.{0} num) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (measurable_space.{0} num))  := sorry --non-trivial
lemma new_lemma_30015 (h1 : not (topological_space (semiring linarith.comp_source) -> false)) : @path_connected_space.{0} (semiring.{0} linarith.comp_source) (@classical.by_contradiction'.{1} (topological_space.{0} (semiring.{0} linarith.comp_source)) h1)  := sorry --non-trivial
lemma new_lemma_30016 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @normal_space.{0} (linear_ordered_comm_group.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (linear_ordered_comm_group.{0} pos))  := sorry --non-trivial
lemma new_lemma_30017 (h0 : functor.add_const (list (has_Sup unsigned)) congr_arg_kind) : palindrome (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_30018 (h0 : fin has_zero.zero) : @strong_rank_condition.{0} (canonically_ordered_monoid.{0} real) (@matrix.vec_empty.{0} (ring.{0} (canonically_ordered_monoid.{0} real)) h0)  := sorry --non-trivial
lemma new_lemma_30019 (h0 : ring (ring (ring (comm_group Type)))) : rank_condition (ring (ring (comm_group Type))) := sorry --non-trivial
lemma new_lemma_30020 (h0 : topological_space (cancel_monoid (option name))) : regular_space (cancel_monoid (option name)) := sorry --non-trivial
lemma new_lemma_30021 (h0 : add_group (uniform_space (mul_one_class (semi_normed_ring linarith.comp_source)))) : is_add_cyclic (uniform_space (mul_one_class (semi_normed_ring linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_30022 (h0 : functor.add_const (function.extfun Type cancel_comm_monoid_with_zero) Type) : @unique_factorization_monoid.{0} (generalized_boolean_algebra.{0} pos) (@function.extfun_app.{2 1} Type cancel_comm_monoid_with_zero.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type cancel_comm_monoid_with_zero.{0}) Type h0) (generalized_boolean_algebra.{0} pos))  := sorry --non-trivial
lemma new_lemma_30023 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_add_cyclic.{0} (preorder.{0} unsigned) (@function.extfun_app.{2 1} Type add_group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 add_group.{0}) (preorder.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_30024 (h0 : topological_space (linear_ordered_comm_ring (semiring (semiring (semiring empty))))) : t0_space (linear_ordered_comm_ring (semiring (semiring (semiring empty)))) := sorry --non-trivial
lemma new_lemma_30025 (h0 : ring (encodable linarith.comp_source)) : is_domain (encodable linarith.comp_source) := sorry --non-trivial
lemma new_lemma_30026 (h0 : function.extfun Type (prod (monoid unsigned))) : id_rel (function.extfun_app h0 (monoid unsigned)) := sorry --non-trivial
lemma new_lemma_30027 (h0 : complete_lattice (has_nnnorm (random_gen char))) : is_compactly_generated (has_nnnorm (random_gen char)) := sorry --non-trivial
lemma new_lemma_30028 (h0 : functor.add_const (topological_space (semiring congr_arg_kind)) num) : @discrete_topology.{0} (semiring.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (semiring.{0} congr_arg_kind)) num h0)  := sorry --non-trivial
lemma new_lemma_30029 (h0 : functor.add_const (topological_space (has_add linarith.comp)) linarith.comp) : @regular_space.{0} (has_add.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (has_add.{0} linarith.comp)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_30030 (h0 : function.extfun Type uniform_space) : @separated_space.{0} (non_assoc_semiring.{0} empty) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (non_assoc_semiring.{0} empty))  := sorry --non-trivial
lemma new_lemma_30031 (h0 : uniform_space (semiring (random_gen fun_info))) : complete_space (semiring (random_gen fun_info)) := sorry --non-trivial
lemma new_lemma_30032 (h0 : function.extfun Type list) : list.nodup (function.extfun_app h0 (omega_complete_partial_order unsigned)) := sorry --non-trivial
lemma new_lemma_30033 (h0 : topological_space (semigroup (finset (finset pos)))) : t1_space (semigroup (finset (finset pos))) := sorry --non-trivial
lemma new_lemma_30034 (h0 : functor.add_const (topological_space (add_cancel_monoid (has_neg pos))) linarith.comp) : @discrete_topology.{0} (add_cancel_monoid.{0} (has_neg.{0} pos)) (@functor.add_const.run.{0 0} (topological_space.{0} (add_cancel_monoid.{0} (has_neg.{0} pos))) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_30035 (h0 : topological_space (comm_group (ordered_cancel_comm_monoid ennreal))) : loc_path_connected_space (comm_group (ordered_cancel_comm_monoid ennreal)) := sorry --non-trivial
lemma new_lemma_30036 (h0 : function.extfun Type ring) : @strong_rank_condition.{0} (measure_theory.measure_space.{0} empty) (@function.extfun_app.{2 1} Type ring.{0} h0 (measure_theory.measure_space.{0} empty))  := sorry --non-trivial
lemma new_lemma_30037 (h0 : functor.add_const (complete_lattice (boolean_algebra Type)) pos) : @is_compactly_generated.{1} (boolean_algebra.{1} Type) (@functor.add_const.run.{1 0} (complete_lattice.{1} (boolean_algebra.{1} Type)) pos h0)  := sorry --non-trivial
lemma new_lemma_30038 (h0 : list (add_cancel_monoid (option unsigned))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_30039 (h0 : ring (has_to_string (has_neg environment.implicit_infer_kind))) : is_principal_ideal_ring (has_to_string (has_neg environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_30040 (h0 : not (function.extfun Type topological_space -> false)) : @discrete_topology.{0} (random_gen.{0} linarith.ineq) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (random_gen.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_30041 (h0 : group (boolean_algebra (has_Inf (has_Inf (has_nndist (finset pos)))))) : is_simple_group (boolean_algebra (has_Inf (has_Inf (has_nndist (finset pos))))) := sorry --non-trivial
lemma new_lemma_30042 (h0 : ring (uniform_space (has_lt linarith.comp_source))) : rank_condition (uniform_space (has_lt linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_30043 (h0 : functor.add_const (group (has_neg linarith.comp)) environment.implicit_infer_kind) : @is_simple_group.{0} (has_neg.{0} linarith.comp) (@functor.add_const.run.{0 0} (group.{0} (has_neg.{0} linarith.comp)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_30044 (h0 : has_mem.mem complete_lattice has_emptyc.emptyc) : @is_atomistic.{0} (has_top.{0} num) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) complete_lattice.{0} h0) (has_top.{0} num))  := sorry --non-trivial
lemma new_lemma_30045 (h0 : monoid (boolean_algebra (has_to_string linarith.comp))) : monoid.fg (boolean_algebra (has_to_string linarith.comp)) := sorry --non-trivial
lemma new_lemma_30046 (h0 : function.extfun Type (functor.comp topological_space cancel_monoid)) : @discrete_topology.{0} (cancel_monoid.{0} name) (@functor.comp.run.{0 0 0} topological_space.{0} cancel_monoid.{0} name (@function.extfun_app.{2 1} Type (functor.comp.{0 0 0} topological_space.{0} cancel_monoid.{0}) h0 name))  := sorry --non-trivial
lemma new_lemma_30047 (h0 : functor.add_const (ring (finset name)) linarith.comp) : @is_domain.{0} (finset.{0} name) (@functor.add_const.run.{0 0} (ring.{0} (finset.{0} name)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_30048 (h1 : topological_space (div_inv_monoid string_imp)) : totally_disconnected_space (div_inv_monoid string_imp) := sorry --non-trivial
lemma new_lemma_30049 (h0 : topological_space (metric_space (has_norm congr_arg_kind))) : irreducible_space (metric_space (has_norm congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_30050 (h0 : function.extfun Type ring) : @rank_condition.{0} (ordered_comm_monoid.{0} real) (@function.extfun_app.{2 1} Type ring.{0} h0 (ordered_comm_monoid.{0} real))  := sorry --non-trivial
lemma new_lemma_30051 (h0 : function.extfun Type group) : @is_cyclic.{0} (ordered_cancel_add_comm_monoid.{0} unsigned) (@function.extfun_app.{2 1} Type group.{0} h0 (ordered_cancel_add_comm_monoid.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_30052 (h0 : complete_lattice (semiring (has_top (has_top (has_top (has_top fun_info)))))) : is_compactly_generated (semiring (has_top (has_top (has_top (has_top fun_info))))) := sorry --non-trivial
lemma new_lemma_30053 (h0 : topological_space (normed_comm_ring (has_neg Type))) : t0_space (normed_comm_ring (has_neg Type)) := sorry --non-trivial
lemma new_lemma_30054 (h1 : function.extfun (Type -> Type) (function.extfun Type)) : @is_add_cyclic.{0} (with_one.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type add_group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h1 add_group.{0}) (with_one.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_30055 (h0 : topological_space (has_to_string (mul_one_class Type))) : regular_space (has_to_string (mul_one_class Type)) := sorry --non-trivial
lemma new_lemma_30056 (h0 : complete_lattice (has_div (mul_one_class (mul_one_class (mul_one_class fun_info))))) : is_compactly_generated (has_div (mul_one_class (mul_one_class (mul_one_class fun_info)))) := sorry --non-trivial
lemma new_lemma_30057 (h0 : complete_lattice (has_dist congr_arg_kind)) : complete_lattice.is_Sup_finite_compact (has_dist congr_arg_kind) := sorry --non-trivial
lemma new_lemma_30058 (h0 : function.extfun Type ring) : @rank_condition.{0} (is_R_or_C.{0} unsigned) (@function.extfun_app.{2 1} Type ring.{0} h0 (is_R_or_C.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_30059 (h1 : ring (div_inv_monoid to_additive.value_type)) : strong_rank_condition (div_inv_monoid to_additive.value_type) := sorry --non-trivial
lemma new_lemma_30060 (h0 : topological_space (add_cancel_monoid (finset (finset name)))) : path_connected_space (add_cancel_monoid (finset (finset name))) := sorry --non-trivial
lemma new_lemma_30061 (h0 : group (generalized_boolean_algebra (has_add (has_pos_part pos)))) : group.fg (generalized_boolean_algebra (has_add (has_pos_part pos))) := sorry --non-trivial
lemma new_lemma_30062 (h0 : function.extfun Type uniform_space) : @separated_space.{0} (@id.{2} Type congr_arg_kind) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (@id.{2} Type congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_30063 (h0 : topological_space (has_edist (option (option empty)))) : topological_space.separable_space (has_edist (option (option empty))) := sorry --non-trivial
lemma new_lemma_30064 (h0 : filter (comm_group (has_add name))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_30065 (h0 : ordered_comm_monoid (canonically_ordered_comm_semiring (ring name))) : has_exists_mul_of_le (canonically_ordered_comm_semiring (ring name)) := sorry --non-trivial
lemma new_lemma_30066 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_principal_ideal_ring.{0} (canonically_linear_ordered_monoid.{0} ennreal) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (canonically_linear_ordered_monoid.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_30067 (h0 : functor.add_const (function.extfun (Type 1) add_monoid) (ring pos)) : @add_monoid.fg.{1} (has_to_string.{1} Type) (@function.extfun_app.{3 2} (Type 1) add_monoid.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) add_monoid.{1}) (ring.{0} pos) h0) (has_to_string.{1} Type))  := sorry --non-trivial
lemma new_lemma_30068 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @discrete_topology.{1} (has_add.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 topological_space.{1}) (has_add.{1} Type))  := sorry --non-trivial
lemma new_lemma_30069 (h0 : functor.add_const (topological_space (canonically_ordered_comm_semiring environment.implicit_infer_kind)) name) : @irreducible_space.{0} (canonically_ordered_comm_semiring.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (canonically_ordered_comm_semiring.{0} environment.implicit_infer_kind)) name h0)  := sorry --non-trivial
lemma new_lemma_30070 (h0 : add_comm_semigroup (add_comm_semigroup (add_comm_semigroup fun_info)) -> char) (h1 : char) : set.range h0 h1 := sorry --non-trivial
lemma new_lemma_30071 (h0 : group (has_Inf (has_Inf (has_pos_part pos)))) : group.fg (has_Inf (has_Inf (has_pos_part pos))) := sorry --non-trivial
lemma new_lemma_30072 (h0 : topological_space (normed_comm_ring (finset (finset (finset (finset (finset pos))))))) : loc_path_connected_space (normed_comm_ring (finset (finset (finset (finset (finset pos)))))) := sorry --non-trivial
lemma new_lemma_30073 (h0 : function.extfun Type group) : @group.fg.{0} (add_left_cancel_semigroup.{0} empty) (@function.extfun_app.{2 1} Type group.{0} h0 (add_left_cancel_semigroup.{0} empty))  := sorry --non-trivial
lemma new_lemma_30074 (h0 : fin has_zero.zero) : @is_simple_group.{0} (add_comm_monoid.{0} pos) (@matrix.vec_empty.{0} (group.{0} (add_comm_monoid.{0} pos)) h0)  := sorry --non-trivial
lemma new_lemma_30075 (h0 : prod (ordered_ring num) (ordered_ring num)) : id_rel h0 := sorry --non-trivial
lemma new_lemma_30076 (h0 : list (topological_space (has_inv linarith.comp_source))) : @irreducible_space.{0} (has_inv.{0} linarith.comp_source) (@list.ilast.{0} (topological_space.{0} (has_inv.{0} linarith.comp_source)) (@inhabited_topological_space.{0} (has_inv.{0} linarith.comp_source)) h0)  := sorry --non-trivial
lemma new_lemma_30077 (h1 : ring (has_ssubset reducibility_hints)) : rank_condition (has_ssubset reducibility_hints) := sorry --non-trivial
lemma new_lemma_30078 (h1 : set (string.iterator_imp -> linarith.ineq)) : set.separates_points h1 := sorry --non-trivial
lemma new_lemma_30079 (h0 : topological_space (boolean_algebra (has_Inf (has_Inf linarith.comp)))) : t0_space (boolean_algebra (has_Inf (has_Inf linarith.comp))) := sorry --non-trivial
lemma new_lemma_30080 (h0 : function.extfun Type topological_space) : @regular_space.{0} (simple_graph.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (simple_graph.{0} pos))  := sorry --non-trivial
lemma new_lemma_30081 (h0 : function.extfun Type complete_lattice) : @is_compactly_generated.{0} (ordered_comm_ring.{0} linarith.comp) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (ordered_comm_ring.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_30082 (h0 : topological_space (ordered_comm_ring (has_pos_part name))) : discrete_topology (ordered_comm_ring (has_pos_part name)) := sorry --non-trivial
lemma new_lemma_30083 (h0 : topological_space (cancel_monoid (finset name))) : regular_space (cancel_monoid (finset name)) := sorry --non-trivial
lemma new_lemma_30084 (h0 : cancel_comm_monoid_with_zero (has_Inf (has_neg name))) : unique_factorization_monoid (has_Inf (has_neg name)) := sorry --non-trivial
lemma new_lemma_30085 (h0 : has_lt (canonically_linear_ordered_monoid std_gen)) : no_max_order (canonically_linear_ordered_monoid std_gen) := sorry --non-trivial
lemma new_lemma_30086 (h0 : complete_lattice (normed_group (has_norm linarith.ineq))) : is_compactly_generated (normed_group (has_norm linarith.ineq)) := sorry --non-trivial
lemma new_lemma_30087 (h0 : functor.add_const (ring (linear_ordered_comm_ring num)) (semiring empty)) : @strong_rank_condition.{0} (linear_ordered_comm_ring.{0} num) (@functor.add_const.run.{0 0} (ring.{0} (linear_ordered_comm_ring.{0} num)) (semiring.{0} empty) h0)  := sorry --non-trivial
lemma new_lemma_30088 (h0 : ring (linear_ordered_add_comm_group (has_nnnorm linarith.ineq))) : is_domain (linear_ordered_add_comm_group (has_nnnorm linarith.ineq)) := sorry --non-trivial
lemma new_lemma_30089 (h0 : functor.add_const Prop (finset pos)) : functor.add_const.run h0 := sorry --non-trivial
lemma new_lemma_30090 (h0 : topological_space (option congr_arg_kind)) : preirreducible_space (option congr_arg_kind) := sorry --non-trivial
lemma new_lemma_30091 (h0 : complete_lattice (filter empty)) : is_atomistic (filter empty) := sorry --non-trivial
lemma new_lemma_30092 (h0 : function.extfun Type uniform_space) : @separated_space.{0} (semiring.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (semiring.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_30093 (h0 : functor.add_const (complete_lattice (has_nndist pos)) ennreal) : @is_compactly_generated.{0} (has_nndist.{0} pos) (@functor.add_const.run.{0 0} (complete_lattice.{0} (has_nndist.{0} pos)) ennreal h0)  := sorry --non-trivial
lemma new_lemma_30094 (h1 : complete_lattice (denumerable (comm_ring linarith.comp_source))) : complete_lattice.is_Sup_finite_compact (denumerable (comm_ring linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_30095 (h1 : complete_lattice (has_append to_additive.value_type)) : is_compactly_generated (has_append to_additive.value_type) := sorry --non-trivial
lemma new_lemma_30096 (h0 : group (semi_normed_comm_ring (random_gen fun_info))) : group.fg (semi_normed_comm_ring (random_gen fun_info)) := sorry --non-trivial
lemma new_lemma_30097 (h0 : functor.add_const (ring (canonically_linear_ordered_monoid pos)) (option name)) : @strong_rank_condition.{0} (canonically_linear_ordered_monoid.{0} pos) (@functor.add_const.run.{0 0} (ring.{0} (canonically_linear_ordered_monoid.{0} pos)) (option.{0} name) h0)  := sorry --non-trivial
lemma new_lemma_30098 (h0 : filter (has_add (has_add (has_bot real)))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_30099 (h0 : topological_space (has_emptyc (has_norm linarith.ineq))) : totally_separated_space (has_emptyc (has_norm linarith.ineq)) := sorry --non-trivial
lemma new_lemma_30100 (h0 : topological_space (parser (semiring (semiring (option (semiring (semiring num))))))) : totally_disconnected_space (parser (semiring (semiring (option (semiring (semiring num)))))) := sorry --non-trivial
lemma new_lemma_30101 (h0 : functor.add_const (function.extfun Type finset) linarith.comp) : finset.nonempty (function.extfun_app (functor.add_const.run h0) (has_Inf linarith.comp)) := sorry --non-trivial
lemma new_lemma_30102 (h1 : ring (has_nnnorm (mul_one_class char))) : rank_condition (has_nnnorm (mul_one_class char)) := sorry --non-trivial
lemma new_lemma_30103 (h0 : topological_space (normed_comm_ring (semigroup environment.implicit_infer_kind))) : sequential_space (normed_comm_ring (semigroup environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_30104 (h0 : complete_lattice (comm_ring (has_compl string.iterator_imp))) : complete_lattice.is_Sup_finite_compact (comm_ring (has_compl string.iterator_imp)) := sorry --non-trivial
lemma new_lemma_30105 (h0 : not (add_group (normed_group (has_top fun_info)) -> false)) : @is_add_cyclic.{0} (normed_group.{0} (has_top.{0} fun_info)) (@classical.by_contradiction'.{1} (add_group.{0} (normed_group.{0} (has_top.{0} fun_info))) h0)  := sorry --non-trivial
lemma new_lemma_30106 (h0 : ring (semi_normed_ring char)) : rank_condition (semi_normed_ring char) := sorry --non-trivial
lemma new_lemma_30107 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @archimedean.{0} (complete_distrib_lattice.{0} empty) (@functor.add_const.run.{0 0} (ordered_add_comm_monoid.{0} (complete_distrib_lattice.{0} empty)) (option.{0} (option.{0} empty)) (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (ordered_add_comm_monoid.{0} (complete_distrib_lattice.{0} empty))) (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 (functor.add_const.{0 0} (ordered_add_comm_monoid.{0} (complete_distrib_lattice.{0} empty)))) (option.{0} (option.{0} empty))))  := sorry --non-trivial
lemma new_lemma_30108 (h0 : function.extfun Type monoid) : @monoid.fg.{0} (comm_semigroup.{0} real) (@function.extfun_app.{2 1} Type monoid.{0} h0 (comm_semigroup.{0} real))  := sorry --non-trivial
lemma new_lemma_30109 (h0 : monoid (measure_theory.measure_space (has_top num))) : monoid.fg (measure_theory.measure_space (has_top num)) := sorry --non-trivial
lemma new_lemma_30110 (h0 : prod (simple_graph (comm_monoid unsigned)) (simple_graph (comm_monoid unsigned))) : id_rel h0 := sorry --non-trivial
lemma new_lemma_30111 (h0 : add_group (has_div fun_info)) : is_add_cyclic (has_div fun_info) := sorry --non-trivial
lemma new_lemma_30112 (h0 : ring (pseudo_metric_space (option (option (option (option pos)))))) : is_domain (pseudo_metric_space (option (option (option (option pos))))) := sorry --non-trivial
lemma new_lemma_30113 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : palindrome (function.extfun_app (function.extfun_app h0 list) (complete_distrib_lattice Type)) := sorry --non-trivial
lemma new_lemma_30114 (h0 : functor.add_const (function.extfun (Type 1) ordered_add_comm_monoid) linarith.comp) : @archimedean.{1} (boolean_algebra.{1} Type) (@function.extfun_app.{3 2} (Type 1) ordered_add_comm_monoid.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) ordered_add_comm_monoid.{1}) linarith.comp h0) (boolean_algebra.{1} Type))  := sorry --non-trivial
lemma new_lemma_30115 (h0 : functor.add_const (group (has_neg linarith.comp)) linarith.comp) : @is_cyclic.{0} (has_neg.{0} linarith.comp) (@functor.add_const.run.{0 0} (group.{0} (has_neg.{0} linarith.comp)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_30116 (h0 : list (plift unsigned)) : palindrome h0 := sorry --non-trivial
lemma new_lemma_30117 (h0 : function.extfun Type (functor.comp topological_space normed_comm_ring)) : @discrete_topology.{0} (normed_comm_ring.{0} name) (@functor.comp.run.{0 0 0} topological_space.{0} normed_comm_ring.{0} name (@function.extfun_app.{2 1} Type (functor.comp.{0 0 0} topological_space.{0} normed_comm_ring.{0}) h0 name))  := sorry --non-trivial
lemma new_lemma_30118 (h0 : functor.add_const (topological_space (cancel_monoid linarith.comp)) name) : @preconnected_space.{0} (cancel_monoid.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (cancel_monoid.{0} linarith.comp)) name h0)  := sorry --non-trivial
lemma new_lemma_30119 (h0 : function.extfun Type uniform_space) : @separated_space.{0} (semigroup.{0} name) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (semigroup.{0} name))  := sorry --non-trivial
lemma new_lemma_30120 (h0 : function.extfun Type topological_space) : @preconnected_space.{0} (ordered_cancel_add_comm_monoid.{0} ennreal) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (ordered_cancel_add_comm_monoid.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_30121 (h0 : functor.add_const (topological_space (has_nndist name)) linarith.comp) : @topological_space.separable_space.{0} (has_nndist.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (has_nndist.{0} name)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_30122 (h0 : topological_space (add_comm_monoid (normed_comm_ring unsigned))) : irreducible_space (add_comm_monoid (normed_comm_ring unsigned)) := sorry --non-trivial
lemma new_lemma_30123 (h0 : group (add_comm_monoid congr_arg_kind)) : normalizer_condition (add_comm_monoid congr_arg_kind) := sorry --non-trivial
lemma new_lemma_30124 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_principal_ideal_ring.{0} (has_neg_part.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (has_neg_part.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_30125 (h0 : topological_space (distrib char)) : totally_disconnected_space (distrib char) := sorry --non-trivial
lemma new_lemma_30126 (h0 : functor.add_const (topological_space (has_nndist environment.implicit_infer_kind)) Type) : @preconnected_space.{0} (has_nndist.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 1} (topological_space.{0} (has_nndist.{0} environment.implicit_infer_kind)) Type h0)  := sorry --non-trivial
lemma new_lemma_30127 (h0 : functor.add_const (topological_space (comm_group unsigned)) environment.implicit_infer_kind) : @preconnected_space.{0} (comm_group.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (comm_group.{0} unsigned)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_30128 (h0 : function.extfun Type topological_space) : @totally_disconnected_space.{0} (with_one.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (with_one.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_30129 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @strong_rank_condition.{0} (has_one.{0} empty) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (has_one.{0} empty))  := sorry --non-trivial
lemma new_lemma_30130 (h0 : topological_space (has_nndist (finset pos))) : normal_space (has_nndist (finset pos)) := sorry --non-trivial
lemma new_lemma_30131 (h0 : topological_space (has_to_string Type)) : preirreducible_space (has_to_string Type) := sorry --non-trivial
lemma new_lemma_30132 (h0 : ring (finset (finset pos))) : rank_condition (finset (finset pos)) := sorry --non-trivial
lemma new_lemma_30133 (h0 : finset (semigroup (has_nndist (finset pos)))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_30134 (h1 : uniform_space (semi_normed_ring linarith.comp_source)) : complete_space (semi_normed_ring linarith.comp_source) := sorry --non-trivial
lemma new_lemma_30135 (h0 : topological_space (boolean_algebra (has_to_string linarith.comp))) : regular_space (boolean_algebra (has_to_string linarith.comp)) := sorry --non-trivial
lemma new_lemma_30136 (h0 : fin has_zero.zero) : @is_compactly_generated.{1} (ordered_comm_ring.{1} Type) (@matrix.vec_empty.{1} (complete_lattice.{1} (ordered_comm_ring.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_30137 (h0 : topological_space (ring (has_add name))) : t1_space (ring (has_add name)) := sorry --non-trivial
lemma new_lemma_30138 (h0 : not (function.extfun Type monoid -> false)) : @monoid.fg.{0} (has_top.{0} linarith.comp) (@function.extfun_app.{2 1} Type monoid.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type monoid.{0}) h0) (has_top.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_30139 (h0 : functor.add_const (topological_space (add_cancel_monoid environment.implicit_infer_kind)) (has_zero pos)) : @totally_disconnected_space.{0} (add_cancel_monoid.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (add_cancel_monoid.{0} environment.implicit_infer_kind)) (has_zero.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_30140 (h0 : uniform_space (has_Inf (has_Inf (has_add (has_add (has_add pos)))))) : separated_space (has_Inf (has_Inf (has_add (has_add (has_add pos))))) := sorry --non-trivial
lemma new_lemma_30141 (h0 : not (group (plift empty) -> false)) : @group.fg.{1} (plift.{1} empty) (@classical.by_contradiction'.{2} (group.{1} (plift.{1} empty)) h0)  := sorry --non-trivial
lemma new_lemma_30142 (h0 : ordered_add_comm_monoid (has_Inf (finset Type))) : archimedean (has_Inf (finset Type)) := sorry --non-trivial
lemma new_lemma_30143 (h1 : uniform_space (topological_space (add_comm_monoid char))) : complete_space (topological_space (add_comm_monoid char)) := sorry --non-trivial
lemma new_lemma_30144 (h0 : uniform_space (generalized_boolean_algebra (has_nndist linarith.comp))) : complete_space (generalized_boolean_algebra (has_nndist linarith.comp)) := sorry --non-trivial
lemma new_lemma_30145 (h0 : not (filter (add_monoid to_additive.value_type) -> false)) : filter.ne_bot (classical.by_contradiction' h0) := sorry --non-trivial
lemma new_lemma_30146 (h0 : not (topological_space (has_add linarith.comp_source) -> false)) : @t0_space.{0} (has_add.{0} linarith.comp_source) (@classical.by_contradiction'.{1} (topological_space.{0} (has_add.{0} linarith.comp_source)) h0)  := sorry --non-trivial
lemma new_lemma_30147 (h0 : functor.add_const (filter (add_cancel_monoid pos)) name) : countable_Inter_filter (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_30148 (h0 : cancel_comm_monoid_with_zero (ordered_cancel_add_comm_monoid (option unsigned))) : unique_factorization_monoid (ordered_cancel_add_comm_monoid (option unsigned)) := sorry --non-trivial
lemma new_lemma_30149 (h0 : prod (linear_ordered_comm_group num) (linear_ordered_comm_group num)) : id_rel h0 := sorry --non-trivial
lemma new_lemma_30150 (h0 : functor.add_const (topological_space (mul_zero_class num)) (semiring (semiring empty))) : @normal_space.{0} (mul_zero_class.{0} num) (@functor.add_const.run.{0 0} (topological_space.{0} (mul_zero_class.{0} num)) (semiring.{0} (semiring.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_30151 (h0 : functor.add_const (function.extfun Type ordered_add_comm_monoid) Type) : @archimedean.{0} (has_pos_part.{0} linarith.comp) (@function.extfun_app.{2 1} Type ordered_add_comm_monoid.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type ordered_add_comm_monoid.{0}) Type h0) (has_pos_part.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_30152 (h0 : functor.add_const (function.extfun Type group) linarith.comp) : @is_cyclic.{0} (has_pos_part.{0} pos) (@function.extfun_app.{2 1} Type group.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type group.{0}) linarith.comp h0) (has_pos_part.{0} pos))  := sorry --non-trivial
lemma new_lemma_30153 (h0 : functor.add_const (function.extfun Type uniform_space) unsigned) : @separated_space.{0} (cancel_monoid.{0} unsigned) (@function.extfun_app.{2 1} Type uniform_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type uniform_space.{0}) unsigned h0) (cancel_monoid.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_30154 (h0 : has_mem.mem (mul_zero_class unsigned) has_zero.zero) : @is_add_cyclic.{0} (mul_zero_class.{0} unsigned) (@multiset.pi.empty.{1 0} Type add_group.{0} (mul_zero_class.{0} unsigned) h0)  := sorry --non-trivial
lemma new_lemma_30155 (h0 : ring (has_bot congr_arg_kind)) : rank_condition (has_bot congr_arg_kind) := sorry --non-trivial
lemma new_lemma_30156 (h0 : topological_space (canonically_linear_ordered_monoid (has_add (has_Inf linarith.comp)))) : regular_space (canonically_linear_ordered_monoid (has_add (has_Inf linarith.comp))) := sorry --non-trivial
lemma new_lemma_30157 (h0 : ordered_comm_monoid (boolean_algebra (finset (finset environment.implicit_infer_kind)))) : has_exists_mul_of_le (boolean_algebra (finset (finset environment.implicit_infer_kind))) := sorry --non-trivial
lemma new_lemma_30158 (h0 : add_group (complete_semilattice_Sup (measurable_space linarith.comp_source))) : is_add_cyclic (complete_semilattice_Sup (measurable_space linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_30159 (h0 : topological_space (has_union (has_norm num))) : path_connected_space (has_union (has_norm num)) := sorry --non-trivial
lemma new_lemma_30160 (h0 : functor.add_const (ring (boolean_algebra.core unsigned)) num) : @is_domain.{0} (boolean_algebra.core.{0} unsigned) (@functor.add_const.run.{0 0} (ring.{0} (boolean_algebra.core.{0} unsigned)) num h0)  := sorry --non-trivial
lemma new_lemma_30161 (h0 : function.extfun Type group) : @is_simple_group.{0} (normed_comm_ring.{0} (option.{0} unsigned)) (@function.extfun_app.{2 1} Type group.{0} h0 (normed_comm_ring.{0} (option.{0} unsigned)))  := sorry --non-trivial
lemma new_lemma_30162 (h0 : topological_space (has_dist empty)) : totally_disconnected_space (has_dist empty) := sorry --non-trivial
lemma new_lemma_30163 (h0 : functor.add_const (topological_space (has_neg environment.implicit_infer_kind)) (boolean_algebra pos)) : @path_connected_space.{0} (has_neg.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (has_neg.{0} environment.implicit_infer_kind)) (boolean_algebra.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_30164 (h0 : not (function.extfun (Type 1) uniform_space -> false)) : @separated_space.{1} (plift.{1} empty) (@function.extfun_app.{3 2} (Type 1) uniform_space.{1} (@classical.by_contradiction'.{3} (function.extfun.{3 2} (Type 1) uniform_space.{1}) h0) (plift.{1} empty))  := sorry --non-trivial
lemma new_lemma_30165 (h0 : topological_space (semi_normed_comm_ring (normed_group (normed_group string_imp)))) : totally_disconnected_space (semi_normed_comm_ring (normed_group (normed_group string_imp))) := sorry --non-trivial
lemma new_lemma_30166 (h0 : ring (ordered_comm_monoid (has_add (has_add linarith.comp)))) : rank_condition (ordered_comm_monoid (has_add (has_add linarith.comp))) := sorry --non-trivial
lemma new_lemma_30167 (h0 : function.extfun Type ring) : @is_domain.{0} (linear_ordered_field.{0} (has_to_string.{0} ennreal)) (@function.extfun_app.{2 1} Type ring.{0} h0 (linear_ordered_field.{0} (has_to_string.{0} ennreal)))  := sorry --non-trivial
lemma new_lemma_30168 (h0 : function.extfun (finset (Type -> Type)) (has_mem.mem complete_lattice)) : @complete_lattice.is_Sup_finite_compact.{0} (random_gen.{0} fun_info) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) complete_lattice.{0} (@function.extfun_app.{2 0} (finset.{1} (Type → Type)) (@has_mem.mem.{1 1} (Type → Type) (finset.{1} (Type → Type)) (@finset.has_mem.{1} (Type → Type)) complete_lattice.{0}) h0 (@has_emptyc.emptyc.{1} (finset.{1} (Type → Type)) (@finset.has_emptyc.{1} (Type → Type))))) (random_gen.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_30169 (h0 : function.extfun Type topological_space) : @locally_compact_space.{0} (canonically_ordered_comm_semiring.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (canonically_ordered_comm_semiring.{0} empty))  := sorry --non-trivial
lemma new_lemma_30170 (h0 : finset (has_zero (option (option (option (option (option (option pos)))))))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_30171 (h0 : topological_space string.iterator) (h1 : add_group string.iterator) : topological_add_group string.iterator := sorry --non-trivial
lemma new_lemma_30172 (h0 : not (ring (complete_semilattice_Sup linarith.ineq) -> false)) : @strong_rank_condition.{0} (complete_semilattice_Sup.{0} linarith.ineq) (@classical.by_contradiction'.{1} (ring.{0} (complete_semilattice_Sup.{0} linarith.ineq)) h0)  := sorry --non-trivial
lemma new_lemma_30173 (h0 : finset (finset (has_neg pos))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_30174 (h0 : functor.add_const (topological_space znum) (option (option (option unsigned)))) : @path_connected_space.{0} znum (@functor.add_const.run.{0 0} (topological_space.{0} znum) (option.{0} (option.{0} (option.{0} unsigned))) h0)  := sorry --non-trivial
lemma new_lemma_30175 (h0 : functor.add_const (filter (canonically_ordered_comm_semiring name)) linarith.comp) : countable_Inter_filter (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_30176 (h0 : has_mem.mem (with_one linarith.comp) has_emptyc.emptyc) : @totally_separated_space.{0} (with_one.{0} linarith.comp) (@finset.pi.empty.{1 0} Type topological_space.{0} (with_one.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_30177 (h0 : functor.add_const (complete_lattice (ring name)) (has_neg_part name)) : @is_compactly_generated.{0} (ring.{0} name) (@functor.add_const.run.{0 0} (complete_lattice.{0} (ring.{0} name)) (has_neg_part.{0} name) h0)  := sorry --non-trivial
lemma new_lemma_30178 (h0 : function.extfun nat fin) : @rank_condition.{0} (normed_lattice_add_comm_group.{0} linarith.comp) (@matrix.vec_empty.{0} (ring.{0} (normed_lattice_add_comm_group.{0} linarith.comp)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_30179 (h0 : filter (comm_group (has_nndist (finset environment.implicit_infer_kind)))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_30180 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @totally_separated_space.{0} (has_nndist.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_nndist.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_30181 (h0 : monoid (has_Inf (has_pos_part (has_add (has_add linarith.comp))))) : monoid.fg (has_Inf (has_pos_part (has_add (has_add linarith.comp)))) := sorry --non-trivial
lemma new_lemma_30182 (h0 : functor.add_const (group (add_comm_monoid Type)) linarith.comp) : @is_simple_group.{1} (add_comm_monoid.{1} Type) (@functor.add_const.run.{1 0} (group.{1} (add_comm_monoid.{1} Type)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_30183 (h0 : prod (linear_ordered_comm_group congr_arg_kind) (linear_ordered_comm_group congr_arg_kind)) : id_rel h0 := sorry --non-trivial
lemma new_lemma_30184 (h0 : functor.add_const (add_monoid (has_to_string Type)) linarith.comp) : @add_monoid.fg.{1} (has_to_string.{1} Type) (@functor.add_const.run.{1 0} (add_monoid.{1} (has_to_string.{1} Type)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_30185 (h0 : fin has_zero.zero) : @is_compactly_generated.{0} (has_add.{0} real) (@matrix.vec_empty.{0} (complete_lattice.{0} (has_add.{0} real)) (@matrix.vec_empty.{0} (fin (@has_zero.zero.{0} nat nat.has_zero)) h0))  := sorry --non-trivial
lemma new_lemma_30186 (h0 : ordered_add_comm_monoid (has_Sup num)) : archimedean (has_Sup num) := sorry --non-trivial
lemma new_lemma_30187 (h1 : function.extfun Type list) : list.nodup (function.extfun_app h1 congr_arg_kind) := sorry --non-trivial
lemma new_lemma_30188 (h0 : topological_space (linear_ordered_add_comm_group (random_gen fun_info))) : locally_compact_space (linear_ordered_add_comm_group (random_gen fun_info)) := sorry --non-trivial
lemma new_lemma_30189 (h0 : list (boolean_algebra.core ennreal)) : palindrome h0 := sorry --non-trivial
lemma new_lemma_30190 (h1 : has_mem.mem (metric_space num) has_emptyc.emptyc) : @discrete_topology.{0} (metric_space.{0} num) (@finset.pi.empty.{1 0} Type topological_space.{0} (metric_space.{0} num) h1)  := sorry --non-trivial
lemma new_lemma_30191 (h2 : ring (random_gen char)) : rank_condition (random_gen char) := sorry --non-trivial
lemma new_lemma_30192 (h0 : group (add_semigroup (option empty))) : group.fg (add_semigroup (option empty)) := sorry --non-trivial
lemma new_lemma_30193 (h0 : filter (boolean_algebra (ring Type))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_30194 (h0 : function.extfun Type ring) : @is_principal_ideal_ring.{0} (linear_ordered_cancel_comm_monoid.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type ring.{0} h0 (linear_ordered_cancel_comm_monoid.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_30195 (h0 : functor.add_const (add_group (semigroup Type)) Type) : @is_add_cyclic.{1} (semigroup.{1} Type) (@functor.add_const.run.{1 1} (add_group.{1} (semigroup.{1} Type)) Type h0)  := sorry --non-trivial
lemma new_lemma_30196 (h0 : topological_space (option (semiring num))) : totally_separated_space (option (semiring num)) := sorry --non-trivial
lemma new_lemma_30197 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @unique_factorization_monoid.{0} (has_to_string.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type cancel_comm_monoid_with_zero.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 cancel_comm_monoid_with_zero.{0}) (has_to_string.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_30198 (h0 : functor.add_const (function.extfun Type topological_space) ennreal) : @locally_compact_space.{0} (has_nndist.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) ennreal h0) (has_nndist.{0} pos))  := sorry --non-trivial
lemma new_lemma_30199 (h0 : function.extfun Type add_group) : is_add_cyclic real := sorry --non-trivial
lemma new_lemma_30200 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @topological_space.separable_space.{0} (has_zero.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_zero.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_30201 (h0 : functor.add_const (topological_space (simple_graph Type)) name) : @regular_space.{1} (simple_graph.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (simple_graph.{1} Type)) name h0)  := sorry --non-trivial
lemma new_lemma_30202 (h0 h1 : Prop) : id (or h0 h1) := sorry --non-trivial
lemma new_lemma_30203 (h0 : has_mem.mem (has_top congr_arg_kind) has_emptyc.emptyc) : @monoid.fg.{0} (has_top.{0} congr_arg_kind) (@finset.pi.empty.{1 0} Type monoid.{0} (has_top.{0} congr_arg_kind) h0)  := sorry --non-trivial
lemma new_lemma_30204 (h0 : ring (bin_tree (semiring (semiring (semiring empty))))) : strong_rank_condition (bin_tree (semiring (semiring (semiring empty)))) := sorry --non-trivial
lemma new_lemma_30205 (h0 : topological_space (boolean_algebra.core (has_add Type))) : normal_space (boolean_algebra.core (has_add Type)) := sorry --non-trivial
lemma new_lemma_30206 (h0 : has_coe (add_comm_semigroup (add_comm_semigroup linarith.ineq)) Prop) (h1 : add_comm_semigroup (add_comm_semigroup linarith.ineq)) : @coe_b.{1 1} (add_comm_semigroup.{0} (add_comm_semigroup.{0} linarith.ineq)) Prop h0 h1  := sorry --non-trivial
lemma new_lemma_30207 (h0 : cancel_comm_monoid_with_zero (add_right_cancel_monoid (semiring num))) : unique_factorization_monoid (add_right_cancel_monoid (semiring num)) := sorry --non-trivial
lemma new_lemma_30208 (h0 : topological_space (has_nndist (ordered_comm_monoid linarith.comp))) : normal_space (has_nndist (ordered_comm_monoid linarith.comp)) := sorry --non-trivial
lemma new_lemma_30209 (h0 : list (has_zero linarith.comp)) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_30210 (h0 : function.extfun Type add_group) : @is_add_cyclic.{0} (has_top.{0} linarith.ineq) (@function.extfun_app.{2 1} Type add_group.{0} h0 (has_top.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_30211 (h0 : functor.add_const (topological_space (semigroup pos)) linarith.comp) : @t0_space.{0} (semigroup.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (semigroup.{0} pos)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_30212 (h0 : functor.add_const (ordered_add_comm_monoid (has_nndist pos)) environment.implicit_infer_kind) : @archimedean.{0} (has_nndist.{0} pos) (@functor.add_const.run.{0 0} (ordered_add_comm_monoid.{0} (has_nndist.{0} pos)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_30213 (h0 : complete_lattice (has_norm char)) : complete_lattice.is_Sup_finite_compact (has_norm char) := sorry --non-trivial
lemma new_lemma_30214 (h1 : complete_lattice (distrib_lattice linarith.comp_source)) : is_compactly_generated (distrib_lattice linarith.comp_source) := sorry --non-trivial
lemma new_lemma_30215 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_compactly_generated.{0} (complete_semilattice_Sup.{0} fun_info) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (complete_semilattice_Sup.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_30216 (h0 : topological_space (ring (cancel_monoid (has_neg_part (boolean_algebra environment.implicit_infer_kind))))) : t0_space (ring (cancel_monoid (has_neg_part (boolean_algebra environment.implicit_infer_kind)))) := sorry --non-trivial
lemma new_lemma_30217 (h1 : ring (semiring (has_top (has_top to_additive.value_type)))) : strong_rank_condition (semiring (has_top (has_top to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_30218 (h0 : function.extfun Type ring) : @rank_condition.{0} (preorder.{0} num) (@function.extfun_app.{2 1} Type ring.{0} h0 (preorder.{0} num))  := sorry --non-trivial
lemma new_lemma_30219 (h0 : function.extfun Type cancel_comm_monoid_with_zero) : @unique_factorization_monoid.{0} (has_bot.{0} real) (@function.extfun_app.{2 1} Type cancel_comm_monoid_with_zero.{0} h0 (has_bot.{0} real))  := sorry --non-trivial
lemma new_lemma_30220 (h0 : filter (boolean_algebra.core (option pos))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_30221 (h0 : functor.add_const (topological_space (bin_tree empty)) num) : @topological_space.separable_space.{0} (bin_tree.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (bin_tree.{0} empty)) num h0)  := sorry --non-trivial
lemma new_lemma_30222 (h0 : topological_space (boolean_algebra (finset environment.implicit_infer_kind))) : locally_compact_space (boolean_algebra (finset environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_30223 (h0 : topological_space (add_group (semiring (semiring (has_union empty))))) : irreducible_space (add_group (semiring (semiring (has_union empty)))) := sorry --non-trivial
lemma new_lemma_30224 (h0 : topological_space (ring (normed_comm_ring (finset environment.implicit_infer_kind)))) : preirreducible_space (ring (normed_comm_ring (finset environment.implicit_infer_kind))) := sorry --non-trivial
lemma new_lemma_30225 (h0 : ring (has_top (semiring empty))) : rank_condition (has_top (semiring empty)) := sorry --non-trivial
lemma new_lemma_30226 (h0 : topological_space (semigroup (mul_one_class (has_neg Type)))) : discrete_topology (semigroup (mul_one_class (has_neg Type))) := sorry --non-trivial
lemma new_lemma_30227 (h0 : function.extfun Type (functor.add_const (complete_lattice znum))) : @is_atomistic.{0} znum (@functor.add_const.run.{0 0} (complete_lattice.{0} znum) ennreal (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (complete_lattice.{0} znum)) h0 ennreal))  := sorry --non-trivial
lemma new_lemma_30228 (h0 : has_mem.mem (with_one congr_arg_kind) has_emptyc.emptyc) : @totally_disconnected_space.{0} (with_one.{0} congr_arg_kind) (@finset.pi.empty.{1 0} Type topological_space.{0} (with_one.{0} congr_arg_kind) h0)  := sorry --non-trivial
lemma new_lemma_30229 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @normalizer_condition.{0} (ordered_cancel_add_comm_monoid.{0} pos) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (ordered_cancel_add_comm_monoid.{0} pos))  := sorry --non-trivial
lemma new_lemma_30230 (h0 : fin has_zero.zero) : @regular_space.{0} (has_add.{0} pos) (@matrix.vec_empty.{0} (topological_space.{0} (has_add.{0} pos)) (@matrix.vec_empty.{0} (fin (@has_zero.zero.{0} nat nat.has_zero)) h0))  := sorry --non-trivial
lemma new_lemma_30231 (h0 : functor.add_const (function.extfun Type topological_space) Type) : @loc_path_connected_space.{0} (ring.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type topological_space.{0}) Type h0) (ring.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_30232 (h0 : functor.add_const (finset (semiring num)) num) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_30233 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_principal_ideal_ring.{0} (ordered_comm_group.{0} empty) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (ordered_comm_group.{0} empty))  := sorry --non-trivial
lemma new_lemma_30234 (h0 : function.extfun (Type 1) ring) : @is_domain.{1} (normed_lattice_add_comm_group.{1} Type) (@function.extfun_app.{3 2} (Type 1) ring.{1} h0 (normed_lattice_add_comm_group.{1} Type))  := sorry --non-trivial
lemma new_lemma_30235 (h0 : function.extfun Type semiring) : @is_noetherian_ring.{0} (linear_ordered_semiring.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type semiring.{0} h0 (linear_ordered_semiring.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_30236 (h0 : complete_lattice (has_norm (has_norm to_additive.value_type))) : is_compactly_generated (has_norm (has_norm to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_30237 (h0 : functor.comp (prod (has_one congr_arg_kind)) has_one congr_arg_kind) : id_rel (functor.comp.run h0) := sorry --non-trivial
lemma new_lemma_30238 (h0 : topological_space (has_inner unsigned congr_arg_kind)) : discrete_topology (has_inner unsigned congr_arg_kind) := sorry --non-trivial
lemma new_lemma_30239 (h0 : function.extfun Type add_group) : @is_add_cyclic.{0} (semigroup.{0} unsigned) (@function.extfun_app.{2 1} Type add_group.{0} h0 (semigroup.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_30240 (h0 : not (add_group (random_gen congr_arg_kind) -> false)) : @is_add_cyclic.{0} (random_gen.{0} congr_arg_kind) (@classical.by_contradiction'.{1} (add_group.{0} (random_gen.{0} congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_30241 (h0 : uniform_space (has_emptyc (semiring empty))) : complete_space (has_emptyc (semiring empty)) := sorry --non-trivial
lemma new_lemma_30242 (h0 : topological_space (measurable_space (has_top to_additive.value_type))) : discrete_topology (measurable_space (has_top to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_30243 (h0 : functor.add_const (filter (generalized_boolean_algebra pos)) linarith.comp) : countable_Inter_filter (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_30244 (h0 : lattice Type) (h1 : bounded_order Type) (h2 : Type) : is_compl h2 char := sorry --non-trivial
lemma new_lemma_30245 (h0 : function.extfun Type complete_lattice) : @is_compactly_generated.{0} (normed_group.{0} unsigned) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (normed_group.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_30246 (h0 : topological_space (has_pos_part (has_add (has_add (has_add (has_pos_part linarith.comp)))))) : sequential_space (has_pos_part (has_add (has_add (has_add (has_pos_part linarith.comp))))) := sorry --non-trivial
lemma new_lemma_30247 (h0 : functor.add_const (ordered_add_comm_monoid (measurable_space.dynkin_system empty)) empty) : @archimedean.{0} (measurable_space.dynkin_system.{0} empty) (@functor.add_const.run.{0 0} (ordered_add_comm_monoid.{0} (measurable_space.dynkin_system.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_30248 (h0 : functor.add_const (functor.add_const (topological_space pos) pos) Type) : @t1_space.{0} pos (@functor.add_const.run.{0 0} (topological_space.{0} pos) pos (@functor.add_const.run.{0 1} (functor.add_const.{0 0} (topological_space.{0} pos) pos) Type h0))  := sorry --non-trivial
lemma new_lemma_30249 (h0 : functor.add_const (functor.add_const (ring linarith.comp) Type) linarith.comp) : @is_principal_ideal_ring.{0} linarith.comp (@functor.add_const.run.{0 1} (ring.{0} linarith.comp) Type (@functor.add_const.run.{0 0} (functor.add_const.{0 1} (ring.{0} linarith.comp) Type) linarith.comp h0))  := sorry --non-trivial
lemma new_lemma_30250 (h0 : topological_space (has_norm (semiring (has_norm num)))) : irreducible_space (has_norm (semiring (has_norm num))) := sorry --non-trivial
lemma new_lemma_30251 (h0 : function.extfun Type monoid) : @monoid.fg.{0} (has_top.{0} (has_top.{0} (random_gen.{0} (random_gen.{0} (random_gen.{0} (random_gen.{0} fun_info)))))) (@function.extfun_app.{2 1} Type monoid.{0} h0 (has_top.{0} (has_top.{0} (random_gen.{0} (random_gen.{0} (random_gen.{0} (random_gen.{0} fun_info)))))))  := sorry --non-trivial
lemma new_lemma_30252 (h0 : functor.add_const (group (comm_group pos)) unsigned) : @normalizer_condition.{0} (comm_group.{0} pos) (@functor.add_const.run.{0 0} (group.{0} (comm_group.{0} pos)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_30253 (h0 : complete_lattice (has_top (has_norm num))) : is_compactly_generated (has_top (has_norm num)) := sorry --non-trivial
lemma new_lemma_30254 (h0 : add_group (has_norm num)) (h1 : not (add_subgroup (has_norm num) -> false)) : add_subgroup.normal (classical.by_contradiction' h1) := sorry --non-trivial
lemma new_lemma_30255 (h1 : topological_space (measurable_space.dynkin_system num)) : totally_disconnected_space (measurable_space.dynkin_system num) := sorry --non-trivial
lemma new_lemma_30256 (h0 : function.extfun Type ring) : @is_domain.{0} (with_bot.{0} linarith.comp) (@function.extfun_app.{2 1} Type ring.{0} h0 (with_bot.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_30257 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_add_cyclic.{0} (partial_order.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type add_group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 add_group.{0}) (partial_order.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_30258 (h0 : not (has_mem.mem (has_norm empty) has_emptyc.emptyc -> false)) : @is_add_cyclic.{0} (has_norm.{0} empty) (@finset.pi.empty.{1 0} Type add_group.{0} (has_norm.{0} empty) (@classical.by_contradiction'.{0} (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (has_norm.{0} empty) (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))) h0))  := sorry --non-trivial
lemma new_lemma_30259 (h0 : function.extfun Type list) : list.nodup (function.extfun_app h0 (linear_ordered_add_comm_group string_imp)) := sorry --non-trivial
lemma new_lemma_30260 (h0 : ordered_add_comm_monoid (semigroup congr_arg_kind)) : archimedean (semigroup congr_arg_kind) := sorry --non-trivial
lemma new_lemma_30261 (h0 : uniform_space (canonically_ordered_comm_semiring (option num))) : separated_space (canonically_ordered_comm_semiring (option num)) := sorry --non-trivial
lemma new_lemma_30262 (h0 : monoid (complete_semilattice_Sup (semiring (has_norm empty)))) : monoid.fg (complete_semilattice_Sup (semiring (has_norm empty))) := sorry --non-trivial
lemma new_lemma_30263 (h0 : functor.add_const Prop (canonically_ordered_comm_semiring (mul_zero_class name))) : functor.add_const.run h0 := sorry --non-trivial
lemma new_lemma_30264 (h0 : filter (has_neg (has_add (has_add environment.implicit_infer_kind)))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_30265 (h0 : function.extfun Type topological_space) : @irreducible_space.{0} (add_comm_monoid.{0} ennreal) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (add_comm_monoid.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_30266 (h0 : functor.add_const (list (finset linarith.comp)) pos) : palindrome (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_30267 (h0 : function.extfun Type ring) : @is_principal_ideal_ring.{0} (has_bot.{0} (has_add.{0} pos)) (@function.extfun_app.{2 1} Type ring.{0} h0 (has_bot.{0} (has_add.{0} pos)))  := sorry --non-trivial
lemma new_lemma_30268 (h0 : functor.add_const (function.extfun (Type 1) topological_space) pos) : @discrete_topology.{1} (has_nndist.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) topological_space.{1}) pos h0) (has_nndist.{1} Type))  := sorry --non-trivial
lemma new_lemma_30269 (h0 : finset (add_cancel_monoid (has_zero Type))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_30270 (h0 : functor.add_const (semiring (has_bot real)) real) : @is_noetherian_ring.{0} (has_bot.{0} real) (@functor.add_const.run.{0 0} (semiring.{0} (has_bot.{0} real)) real h0)  := sorry --non-trivial
lemma new_lemma_30271 (h0 : uniform_space (generalized_boolean_algebra (sub_neg_monoid (sub_neg_monoid real)))) : complete_space (generalized_boolean_algebra (sub_neg_monoid (sub_neg_monoid real))) := sorry --non-trivial
lemma new_lemma_30272 (h0 : functor.add_const (add_group (semigroup unsigned)) empty) : @is_add_cyclic.{0} (semigroup.{0} unsigned) (@functor.add_const.run.{0 0} (add_group.{0} (semigroup.{0} unsigned)) empty h0)  := sorry --non-trivial
lemma new_lemma_30273 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @discrete_topology.{0} (has_zero.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_zero.{0} name))  := sorry --non-trivial
lemma new_lemma_30274 (h0 : function.extfun Type topological_space) : @topological_space.separable_space.{0} (linear_ordered_comm_ring.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (linear_ordered_comm_ring.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_30275 (h0 : topological_space (measurable_space (id empty))) : path_connected_space (measurable_space (id empty)) := sorry --non-trivial
lemma new_lemma_30276 (h0 : complete_lattice (measurable_space (has_top num))) : complete_lattice.is_Sup_finite_compact (measurable_space (has_top num)) := sorry --non-trivial
lemma new_lemma_30277 (h0 : function.extfun Type topological_space) : @normal_space.{0} (add_comm_monoid.{0} ennreal) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (add_comm_monoid.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_30278 (h0 : add_group (with_bot linarith.comp)) : is_add_cyclic (with_bot linarith.comp) := sorry --non-trivial
lemma new_lemma_30279 (h0 : function.extfun Type topological_space) : @totally_separated_space.{0} (has_union.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_union.{0} num))  := sorry --non-trivial
lemma new_lemma_30280 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @complete_lattice.is_Sup_finite_compact.{0} (normed_group.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (normed_group.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_30281 (h4 : has_lt (mul_one_class linarith.ineq)) : no_max_order (mul_one_class linarith.ineq) := sorry --non-trivial
lemma new_lemma_30282 (h0 : group (has_norm (random_gen to_additive.value_type))) : is_cyclic (has_norm (random_gen to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_30283 (h0 : functor.add_const (topological_space Type) Type) : @t0_space.{1} Type (@functor.add_const.run.{1 1} (topological_space.{1} Type) Type h0)  := sorry --non-trivial
lemma new_lemma_30284 (h0 : topological_space (has_add (has_pos_part (has_Inf Type)))) : loc_path_connected_space (has_add (has_pos_part (has_Inf Type))) := sorry --non-trivial
lemma new_lemma_30285 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @add_monoid.fg.{0} (finset.{0} name) (@function.extfun_app.{2 1} Type add_monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 add_monoid.{0}) (finset.{0} name))  := sorry --non-trivial
lemma new_lemma_30286 (h0 : function.extfun Type monoid) : @monoid.fg.{0} (has_to_string.{0} ennreal) (@function.extfun_app.{2 1} Type monoid.{0} h0 (has_to_string.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_30287 (h0 : uniform_space (cancel_monoid (option ennreal))) : complete_space (cancel_monoid (option ennreal)) := sorry --non-trivial
lemma new_lemma_30288 (h0 : semiring (has_nndist (finset (finset (has_to_string pos))))) : is_noetherian_ring (has_nndist (finset (finset (has_to_string pos)))) := sorry --non-trivial
lemma new_lemma_30289 (h0 : functor.add_const (ring (has_Sup unsigned)) num) : @rank_condition.{0} (has_Sup.{0} unsigned) (@functor.add_const.run.{0 0} (ring.{0} (has_Sup.{0} unsigned)) num h0)  := sorry --non-trivial
lemma new_lemma_30290 (h0 : functor.add_const (ordered_comm_monoid (complete_distrib_lattice pos)) (has_neg (has_neg name))) : @has_exists_mul_of_le.{0} (complete_distrib_lattice.{0} pos) (@functor.add_const.run.{0 0} (ordered_comm_monoid.{0} (complete_distrib_lattice.{0} pos)) (has_neg.{0} (has_neg.{0} name)) h0)  := sorry --non-trivial
lemma new_lemma_30291 (h0 : function.extfun Type topological_space) : @normal_space.{0} (cancel_monoid.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (cancel_monoid.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_30292 (h0 : group (has_top linarith.ineq)) : group.fg (has_top linarith.ineq) := sorry --non-trivial
lemma new_lemma_30293 (h0 : function.extfun Type complete_lattice) : @is_atomistic.{0} (canonically_ordered_comm_semiring.{0} ennreal) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (canonically_ordered_comm_semiring.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_30294 (h0 : ring (has_one (semiring unsigned))) : strong_rank_condition (has_one (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_30295 (h0 : function.extfun Type topological_space) : @regular_space.{0} (has_neg_part.{0} ennreal) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_neg_part.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_30296 (h0 : prod (has_dist congr_arg_kind) (has_dist congr_arg_kind)) : id_rel h0 := sorry --non-trivial
lemma new_lemma_30297 (h0 : add_group (topological_space (has_ssubset string_imp))) : is_add_cyclic (topological_space (has_ssubset string_imp)) := sorry --non-trivial
lemma new_lemma_30298 (h0 : ring (complete_distrib_lattice (has_add real))) : strong_rank_condition (complete_distrib_lattice (has_add real)) := sorry --non-trivial
lemma new_lemma_30299 (h0 : function.extfun nat fin) : @is_principal_ideal_ring.{0} (has_bot.{0} linarith.comp) (@matrix.vec_empty.{0} (ring.{0} (has_bot.{0} linarith.comp)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_30300 (h0 : topological_space (distrib_lattice linarith.comp_source)) : path_connected_space (distrib_lattice linarith.comp_source) := sorry --non-trivial
lemma new_lemma_30301 (h0 : topological_space (cancel_monoid (boolean_algebra name))) : regular_space (cancel_monoid (boolean_algebra name)) := sorry --non-trivial
lemma new_lemma_30302 (h1 : topological_space (has_lt reducibility_hints)) : path_connected_space (has_lt reducibility_hints) := sorry --non-trivial
lemma new_lemma_30303 (h0 : not (topological_space (has_sub empty) -> false)) : @totally_separated_space.{0} (has_sub.{0} empty) (@classical.by_contradiction'.{1} (topological_space.{0} (has_sub.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_30304 (h0 : ring (has_to_string name)) : strong_rank_condition (has_to_string name) := sorry --non-trivial
lemma new_lemma_30305 (h0 : topological_space linarith.comp_source) (h1 : add_group linarith.comp_source) : topological_add_group linarith.comp_source := sorry --non-trivial
lemma new_lemma_30306 (h0 : functor.add_const (group (comm_group pos)) (has_neg Type)) : @group.fg.{0} (comm_group.{0} pos) (@functor.add_const.run.{0 1} (group.{0} (comm_group.{0} pos)) (has_neg.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_30307 (h0 : ring (has_one (semiring (linear_ordered_semiring (has_top empty))))) : is_domain (has_one (semiring (linear_ordered_semiring (has_top empty)))) := sorry --non-trivial
lemma new_lemma_30308 (h0 : function.extfun Type semiring) : @is_noetherian_ring.{0} (with_bot.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type semiring.{0} h0 (with_bot.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_30309 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_domain.{0} (comm_monoid.{0} unsigned) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (comm_monoid.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_30310 (h0 : topological_space (semigroup (add_cancel_monoid unsigned))) : normal_space (semigroup (add_cancel_monoid unsigned)) := sorry --non-trivial
lemma new_lemma_30311 (h0 : function.extfun Type group) : @is_cyclic.{0} (normed_comm_ring.{0} name) (@function.extfun_app.{2 1} Type group.{0} h0 (normed_comm_ring.{0} name))  := sorry --non-trivial
lemma new_lemma_30312 (h0 : functor.add_const (topological_space (finset environment.implicit_infer_kind)) environment.implicit_infer_kind) : @regular_space.{0} (finset.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (finset.{0} environment.implicit_infer_kind)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_30313 (h0 : functor.add_const (function.extfun (Type 1) monoid) environment.implicit_infer_kind) : @monoid.fg.{1} (has_neg.{1} Type) (@function.extfun_app.{3 2} (Type 1) monoid.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) monoid.{1}) environment.implicit_infer_kind h0) (has_neg.{1} Type))  := sorry --non-trivial
lemma new_lemma_30314 (h0 : functor.add_const (topological_space (has_Sup Type)) Type) : @preconnected_space.{1} (has_Sup.{1} Type) (@functor.add_const.run.{1 1} (topological_space.{1} (has_Sup.{1} Type)) Type h0)  := sorry --non-trivial
lemma new_lemma_30315 (h0 : has_mem.mem complete_lattice has_emptyc.emptyc) : @complete_lattice.is_Sup_finite_compact.{0} (with_one.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) complete_lattice.{0} h0) (with_one.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_30316 (h0 : functor.add_const (group (normed_comm_ring linarith.comp)) linarith.comp) : @is_simple_group.{0} (normed_comm_ring.{0} linarith.comp) (@functor.add_const.run.{0 0} (group.{0} (normed_comm_ring.{0} linarith.comp)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_30317 (h0 : functor.add_const (finset (ring Type)) pos) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_30318 (h0 : functor.add_const (ring (has_star unsigned)) empty) : @is_principal_ideal_ring.{0} (has_star.{0} unsigned) (@functor.add_const.run.{0 0} (ring.{0} (has_star.{0} unsigned)) empty h0)  := sorry --non-trivial
lemma new_lemma_30319 (h0 : not (ring (has_compl to_additive.value_type) -> false)) : @rank_condition.{0} (has_compl.{0} to_additive.value_type) (@classical.by_contradiction'.{1} (ring.{0} (has_compl.{0} to_additive.value_type)) h0)  := sorry --non-trivial
lemma new_lemma_30320 (h0 : topological_space (semiring (has_inv (has_inv (random_gen linarith.comp_source))))) : t0_space (semiring (has_inv (has_inv (random_gen linarith.comp_source)))) := sorry --non-trivial
lemma new_lemma_30321 (h0 : fin has_zero.zero) : @strong_rank_condition.{0} (finset.{0} real) (@function.extfun_app.{2 1} Type ring.{0} (@matrix.vec_empty.{1} (function.extfun.{2 1} Type ring.{0}) h0) (finset.{0} real))  := sorry --non-trivial
lemma new_lemma_30322 (h0 : finset (boolean_algebra (has_add pos))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_30323 (h0 : filter (semigroup pos)) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_30324 (h0 : complete_lattice (has_neg linarith.comp)) : complete_lattice.is_Sup_finite_compact (has_neg linarith.comp) := sorry --non-trivial
lemma new_lemma_30325 (h0 : ring (add_left_cancel_semigroup (semiring (semiring empty)))) : is_domain (add_left_cancel_semigroup (semiring (semiring empty))) := sorry --non-trivial
lemma new_lemma_30326 (h0 : not (ring (has_emptyc (random_gen linarith.ineq)) -> false)) : @rank_condition.{0} (has_emptyc.{0} (random_gen.{0} linarith.ineq)) (@classical.by_contradiction'.{1} (ring.{0} (has_emptyc.{0} (random_gen.{0} linarith.ineq))) h0)  := sorry --non-trivial
lemma new_lemma_30327 (h0 : add_monoid (cancel_monoid linarith.comp)) : add_monoid.fg (cancel_monoid linarith.comp) := sorry --non-trivial
lemma new_lemma_30328 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @add_monoid.fg.{1} (plift.{1} (has_edist.{0} empty)) (@function.extfun_app.{3 2} (Type 1) add_monoid.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 add_monoid.{1}) (plift.{1} (has_edist.{0} empty)))  := sorry --non-trivial
lemma new_lemma_30329 (h3 : topological_space string.iterator_imp) (h4 : set (set string.iterator_imp)) : topological_space.is_topological_basis h4 := sorry --non-trivial
lemma new_lemma_30330 (h0 : complete_lattice (semigroup empty)) : is_atomistic (semigroup empty) := sorry --non-trivial
lemma new_lemma_30331 (h0 : not (topological_space (non_unital_non_assoc_semiring string.iterator_imp) -> false)) : @path_connected_space.{0} (non_unital_non_assoc_semiring.{0} string.iterator_imp) (@classical.by_contradiction'.{1} (topological_space.{0} (non_unital_non_assoc_semiring.{0} string.iterator_imp)) h0)  := sorry --non-trivial
lemma new_lemma_30332 (h0 : uniform_space (semi_normed_ring reducibility_hints)) : complete_space (semi_normed_ring reducibility_hints) := sorry --non-trivial
lemma new_lemma_30333 (h0 : topological_space (is_R_or_C char)) : locally_compact_space (is_R_or_C char) := sorry --non-trivial
lemma new_lemma_30334 (h0 : not (function.extfun Type ring -> false)) : @is_domain.{0} (random_gen.{0} empty) (@function.extfun_app.{2 1} Type ring.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type ring.{0}) h0) (random_gen.{0} empty))  := sorry --non-trivial
lemma new_lemma_30335 (h0 : topological_space (boolean_algebra.core (option name))) : t1_space (boolean_algebra.core (option name)) := sorry --non-trivial
lemma new_lemma_30336 (h0 : group (has_norm (has_norm congr_arg_kind))) : group.fg (has_norm (has_norm congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_30337 (h0 : add_group (add_comm_monoid (comm_group name))) : is_add_cyclic (add_comm_monoid (comm_group name)) := sorry --non-trivial
lemma new_lemma_30338 (h0 : topological_space (has_le fun_info) -> linarith.ineq) (h1 : coe_sort (set.range h0)) : @path_connected_space.{0} (has_le.{0} fun_info) (@set.range_splitting.{0 0} (topological_space.{0} (has_le.{0} fun_info)) linarith.ineq h0 h1)  := sorry --non-trivial
lemma new_lemma_30339 (h1 : topological_space (has_append char)) : totally_disconnected_space (has_append char) := sorry --non-trivial
lemma new_lemma_30340 (h0 : fin has_zero.zero) : @locally_compact_space.{0} (has_add.{0} linarith.comp) (@matrix.vec_empty.{0} (topological_space.{0} (has_add.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_30341 (h0 : filter (ring (comm_group unsigned))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_30342 (h0 : functor.comp filter has_nndist pos) : filter.ne_bot (functor.comp.run h0) := sorry --non-trivial
lemma new_lemma_30343 (h0 : complete_lattice (metric_space unsigned)) : is_atomistic (metric_space unsigned) := sorry --non-trivial
lemma new_lemma_30344 (h0 : uniform_space (ordered_ring (semiring unsigned))) : complete_space (ordered_ring (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_30345 (h0 : functor.comp group semigroup name) : @is_simple_group.{0} (semigroup.{0} name) (@functor.comp.run.{0 0 0} group.{0} semigroup.{0} name h0)  := sorry --non-trivial
lemma new_lemma_30346 (h0 : semiring (add_comm_monoid congr_arg_kind)) : is_noetherian_ring (add_comm_monoid congr_arg_kind) := sorry --non-trivial
lemma new_lemma_30347 (h0 : ring (normed_field (comm_ring linarith.comp_source))) : is_domain (normed_field (comm_ring linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_30348 (h0 : function.extfun Type filter) : filter.ne_bot (function.extfun_app h0 (complete_distrib_lattice ennreal)) := sorry --non-trivial
lemma new_lemma_30349 (h0 : topological_space (comm_group (comm_group unsigned))) : totally_separated_space (comm_group (comm_group unsigned)) := sorry --non-trivial
lemma new_lemma_30350 (h0 : ring (topological_space (has_ssubset (has_ssubset linarith.ineq)))) : strong_rank_condition (topological_space (has_ssubset (has_ssubset linarith.ineq))) := sorry --non-trivial
lemma new_lemma_30351 (h0 : function.extfun Type semiring) : @is_noetherian_ring.{0} (add_group.{0} empty) (@function.extfun_app.{2 1} Type semiring.{0} h0 (add_group.{0} empty))  := sorry --non-trivial
lemma new_lemma_30352 (h0 : functor.add_const (ring (has_neg ennreal)) ennreal) : @is_principal_ideal_ring.{0} (has_neg.{0} ennreal) (@functor.add_const.run.{0 0} (ring.{0} (has_neg.{0} ennreal)) ennreal h0)  := sorry --non-trivial
lemma new_lemma_30353 (h0 : function.extfun ((Type -> Type) -> Type 1) (function.extfun (Type -> Type))) : @group.fg.{0} (random_gen.{0} char) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) (@function.extfun_app.{3 2} ((Type → Type) → Type 1) (function.extfun.{2 2} (Type → Type)) h0 (function.extfun.{2 1} Type)) group.{0}) (random_gen.{0} char))  := sorry --non-trivial
lemma new_lemma_30354 (h0 : group (boolean_algebra (has_pos_part Type))) : is_cyclic (boolean_algebra (has_pos_part Type)) := sorry --non-trivial
lemma new_lemma_30355 (h0 : topological_space (sub_neg_monoid (has_Inf pos))) : loc_path_connected_space (sub_neg_monoid (has_Inf pos)) := sorry --non-trivial
lemma new_lemma_30356 (h0 : function.extfun Type filter) : filter.ne_bot (function.extfun_app h0 (add_cancel_monoid environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_30357 (h0 : function.extfun Type topological_space) : @topological_space.separable_space.{0} (complete_distrib_lattice.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (complete_distrib_lattice.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_30358 (h0 : not (topological_space (topological_space char) -> false)) : @t0_space.{0} (topological_space.{0} char) (@classical.by_contradiction'.{1} (topological_space.{0} (topological_space.{0} char)) h0)  := sorry --non-trivial
lemma new_lemma_30359 (h0 : function.extfun Type topological_space) : @t1_space.{0} (preorder.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (preorder.{0} num))  := sorry --non-trivial
lemma new_lemma_30360 (h0 : uniform_space (option pos)) : separated_space (option pos) := sorry --non-trivial
lemma new_lemma_30361 (h0 : not (function.extfun Type filter -> false)) : filter.ne_bot (function.extfun_app (classical.by_contradiction' h0) (add_group congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_30362 (h0 : monoid (complete_semilattice_Sup num)) : monoid.fg (complete_semilattice_Sup num) := sorry --non-trivial
lemma new_lemma_30363 (h0 : function.extfun Type ring) : @is_principal_ideal_ring.{0} (has_inter.{0} empty) (@function.extfun_app.{2 1} Type ring.{0} h0 (has_inter.{0} empty))  := sorry --non-trivial
lemma new_lemma_30364 (h0 : add_group (has_neg (mul_zero_class pos))) : is_add_cyclic (has_neg (mul_zero_class pos)) := sorry --non-trivial
lemma new_lemma_30365 (h0 : topological_space (has_neg congr_arg_kind)) : normal_space (has_neg congr_arg_kind) := sorry --non-trivial
lemma new_lemma_30366 (h0 : not (function.extfun Type topological_space -> false)) : @totally_separated_space.{0} (semiring.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (semiring.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_30367 (h0 : topological_space (has_to_string (has_add Type))) : locally_compact_space (has_to_string (has_add Type)) := sorry --non-trivial
lemma new_lemma_30368 (h2 : set (environment.projection_info -> ereal)) : set.separates_points h2 := sorry --non-trivial
lemma new_lemma_30369 (h0 : ordered_comm_monoid char -> ordered_comm_monoid char) (h1 : ordered_comm_monoid char) : function.is_fixed_pt h0 h1 := sorry --non-trivial
lemma new_lemma_30370 (h0 : topological_space (has_bot (has_Inf linarith.comp))) : t0_space (has_bot (has_Inf linarith.comp)) := sorry --non-trivial
lemma new_lemma_30371 (h0 : function.extfun Type (functor.add_const (ordered_add_comm_monoid pos))) : @archimedean.{0} pos (@functor.add_const.run.{0 0} (ordered_add_comm_monoid.{0} pos) name (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (ordered_add_comm_monoid.{0} pos)) h0 name))  := sorry --non-trivial
lemma new_lemma_30372 (h0 : has_mem.mem (normed_group linarith.comp) has_emptyc.emptyc) : @path_connected_space.{0} (normed_group.{0} linarith.comp) (@finset.pi.empty.{1 0} Type topological_space.{0} (normed_group.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_30373 (h0 : functor.add_const (topological_space (has_to_string ennreal)) unsigned) : @topological_space.separable_space.{0} (has_to_string.{0} ennreal) (@functor.add_const.run.{0 0} (topological_space.{0} (has_to_string.{0} ennreal)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_30374 (h0 : functor.add_const (cancel_comm_monoid_with_zero (finset name)) (ring linarith.comp)) : @unique_factorization_monoid.{0} (finset.{0} name) (@functor.add_const.run.{0 0} (cancel_comm_monoid_with_zero.{0} (finset.{0} name)) (ring.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_30375 (h0 : set (plift (boolean_algebra (mul_one_class (mul_one_class (mul_one_class linarith.comp_source)))))) : set.finite h0 := sorry --non-trivial
lemma new_lemma_30376 (h0 : functor.add_const (ring (has_nndist pos)) linarith.comp) : @is_domain.{0} (has_nndist.{0} pos) (@functor.add_const.run.{0 0} (ring.{0} (has_nndist.{0} pos)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_30377 (h0 : uniform_space (has_union (with_bot linarith.comp))) : complete_space (has_union (with_bot linarith.comp)) := sorry --non-trivial
lemma new_lemma_30378 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @t1_space.{0} (has_inter.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_inter.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_30379 (h0 : functor.add_const (topological_space (add_cancel_monoid Type)) pos) : @irreducible_space.{1} (add_cancel_monoid.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (add_cancel_monoid.{1} Type)) pos h0)  := sorry --non-trivial
lemma new_lemma_30380 (h0 : ring (finset (finset (has_pos_part (has_pos_part linarith.comp))))) : is_domain (finset (finset (has_pos_part (has_pos_part linarith.comp)))) := sorry --non-trivial
lemma new_lemma_30381 (h0 : topological_space (measurable_space.dynkin_system (has_union empty))) : locally_compact_space (measurable_space.dynkin_system (has_union empty)) := sorry --non-trivial
lemma new_lemma_30382 (h0 : filter (linear_ordered_add_comm_group (has_norm (has_norm (has_norm to_additive.value_type))))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_30383 (h0 : topological_space (cancel_monoid (comm_group (comm_group (has_add name))))) : preirreducible_space (cancel_monoid (comm_group (comm_group (has_add name)))) := sorry --non-trivial
lemma new_lemma_30384 (h0 : topological_space (normed_field (has_nnnorm (has_nnnorm reducibility_hints)))) : totally_disconnected_space (normed_field (has_nnnorm (has_nnnorm reducibility_hints))) := sorry --non-trivial
lemma new_lemma_30385 (h0 : function.extfun Type topological_space) : @totally_separated_space.{0} (canonically_linear_ordered_monoid.{0} ennreal) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (canonically_linear_ordered_monoid.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_30386 (h0 : ring (ring (has_Inf linarith.comp))) : rank_condition (ring (has_Inf linarith.comp)) := sorry --non-trivial
lemma new_lemma_30387 (h0 : topological_space (topological_space (has_nnnorm reducibility_hints))) : totally_disconnected_space (topological_space (has_nnnorm reducibility_hints)) := sorry --non-trivial
lemma new_lemma_30388 (h1 : not (complete_lattice (semi_normed_comm_ring linarith.comp_source) -> false)) : @is_compactly_generated.{0} (semi_normed_comm_ring.{0} linarith.comp_source) (@classical.by_contradiction'.{1} (complete_lattice.{0} (semi_normed_comm_ring.{0} linarith.comp_source)) h1)  := sorry --non-trivial
lemma new_lemma_30389 (h0 : functor.add_const (filter (has_nndist unsigned)) (has_add unsigned)) : countable_Inter_filter (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_30390 (h0 : has_mem.mem (has_norm num) has_emptyc.emptyc) : @totally_separated_space.{0} (has_norm.{0} num) (@finset.pi.empty.{1 0} Type topological_space.{0} (has_norm.{0} num) h0)  := sorry --non-trivial
lemma new_lemma_30391 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @preconnected_space.{1} (cancel_monoid.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 topological_space.{1}) (cancel_monoid.{1} Type))  := sorry --non-trivial
lemma new_lemma_30392 (h0 : ring (normed_group (random_gen string_imp))) : is_domain (normed_group (random_gen string_imp)) := sorry --non-trivial
lemma new_lemma_30393 (h0 : functor.add_const (topological_space (preorder num)) num) : @totally_separated_space.{0} (preorder.{0} num) (@functor.add_const.run.{0 0} (topological_space.{0} (preorder.{0} num)) num h0)  := sorry --non-trivial
lemma new_lemma_30394 (h0 : ring (comm_ring string.iterator_imp)) : is_domain (comm_ring string.iterator_imp) := sorry --non-trivial
lemma new_lemma_30395 (h0 : function.extfun Type uniform_space) : @separated_space.{0} (has_to_string.{0} linarith.comp) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (has_to_string.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_30396 (h0 : functor.add_const Prop (cancel_monoid (comm_group Type))) : functor.add_const.run h0 := sorry --non-trivial
lemma new_lemma_30397 (h0 : finset (option (option (option (option pos))))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_30398 (h0 : ring (non_unital_non_assoc_semiring (has_ssubset string_imp))) : is_domain (non_unital_non_assoc_semiring (has_ssubset string_imp)) := sorry --non-trivial
lemma new_lemma_30399 (h0 : ring (semi_normed_comm_ring (has_nnnorm to_additive.value_type))) : strong_rank_condition (semi_normed_comm_ring (has_nnnorm to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_30400 (h0 : ring (normed_comm_ring (add_comm_monoid environment.implicit_infer_kind))) : is_principal_ideal_ring (normed_comm_ring (add_comm_monoid environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_30401 (h0 : complete_lattice (add_semigroup (option (option unsigned)))) : is_compactly_generated (add_semigroup (option (option unsigned))) := sorry --non-trivial
lemma new_lemma_30402 (h0 : topological_space (has_compl linarith.ineq)) : totally_disconnected_space (has_compl linarith.ineq) := sorry --non-trivial
lemma new_lemma_30403 (h0 : set (set char)) (h1 : char) : set.sInter h0 h1 := sorry --non-trivial
lemma new_lemma_30404 (h0 : complete_lattice (linear_ordered_cancel_add_comm_monoid char)) : is_atomistic (linear_ordered_cancel_add_comm_monoid char) := sorry --non-trivial
lemma new_lemma_30405 (h0 : complete_lattice (semiring (semiring empty))) : is_atomistic (semiring (semiring empty)) := sorry --non-trivial
lemma new_lemma_30406 (h0 : topological_space (measurable_space.dynkin_system congr_arg_kind)) : normal_space (measurable_space.dynkin_system congr_arg_kind) := sorry --non-trivial
lemma new_lemma_30407 (h0 : ring (normed_lattice_add_comm_group (has_Inf linarith.comp))) : rank_condition (normed_lattice_add_comm_group (has_Inf linarith.comp)) := sorry --non-trivial
lemma new_lemma_30408 (h0 : functor.add_const (ring (add_comm_monoid pos)) environment.implicit_infer_kind) : @is_principal_ideal_ring.{0} (add_comm_monoid.{0} pos) (@functor.add_const.run.{0 0} (ring.{0} (add_comm_monoid.{0} pos)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_30409 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @group.fg.{0} (normed_comm_ring.{0} name) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (normed_comm_ring.{0} name))  := sorry --non-trivial
lemma new_lemma_30410 (h0 : topological_space (has_lt (random_gen char))) : t0_space (has_lt (random_gen char)) := sorry --non-trivial
lemma new_lemma_30411 (h0 : monoid (boolean_algebra.core ennreal)) : monoid.fg (boolean_algebra.core ennreal) := sorry --non-trivial
lemma new_lemma_30412 (h0 : topological_space (ring (finset (has_add (finset pos))))) : loc_path_connected_space (ring (finset (has_add (finset pos)))) := sorry --non-trivial
lemma new_lemma_30413 (h0 : topological_space (left_cancel_semigroup congr_arg_kind)) : t1_space (left_cancel_semigroup congr_arg_kind) := sorry --non-trivial
lemma new_lemma_30414 (h0 : not (has_mem.mem topological_space has_emptyc.emptyc -> false)) : @t0_space.{0} (with_bot.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) topological_space.{0} (@classical.by_contradiction'.{0} (@has_mem.mem.{1 1} (Type → Type) (finset.{1} (Type → Type)) (@finset.has_mem.{1} (Type → Type)) topological_space.{0} (@has_emptyc.emptyc.{1} (finset.{1} (Type → Type)) (@finset.has_emptyc.{1} (Type → Type)))) h0)) (with_bot.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_30415 (h0 : functor.add_const (topological_space (ordered_comm_monoid pos)) (boolean_algebra.core name)) : @t1_space.{0} (ordered_comm_monoid.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (ordered_comm_monoid.{0} pos)) (boolean_algebra.core.{0} name) h0)  := sorry --non-trivial
lemma new_lemma_30416 (h0 : monoid (random_gen (has_top (has_inv (random_gen fun_info))))) : monoid.fg (random_gen (has_top (has_inv (random_gen fun_info)))) := sorry --non-trivial
lemma new_lemma_30417 (h0 : ring (ring (mul_one_class (mul_one_class linarith.comp)))) : is_principal_ideal_ring (ring (mul_one_class (mul_one_class linarith.comp))) := sorry --non-trivial
lemma new_lemma_30418 (h0 : has_mem.mem (has_inter num) has_emptyc.emptyc) : @monoid.fg.{0} (has_inter.{0} num) (@finset.pi.empty.{1 0} Type monoid.{0} (has_inter.{0} num) h0)  := sorry --non-trivial
lemma new_lemma_30419 (h0 : functor.add_const (complete_lattice (add_comm_monoid environment.implicit_infer_kind)) name) : @is_atomistic.{0} (add_comm_monoid.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (complete_lattice.{0} (add_comm_monoid.{0} environment.implicit_infer_kind)) name h0)  := sorry --non-trivial
lemma new_lemma_30420 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @group.fg.{0} (sub_neg_monoid.{0} pos) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (sub_neg_monoid.{0} pos))  := sorry --non-trivial
lemma new_lemma_30421 (h0 : functor.add_const (function.extfun (Type 1) topological_space) (has_Inf linarith.comp)) : @totally_disconnected_space.{1} Type (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) topological_space.{1}) (has_Inf.{0} linarith.comp) h0) Type)  := sorry --non-trivial
lemma new_lemma_30422 (h0 : ring (with_bot (has_norm (has_norm num)))) : strong_rank_condition (with_bot (has_norm (has_norm num))) := sorry --non-trivial
lemma new_lemma_30423 (h0 : topological_space (boolean_algebra.core (semigroup pos))) : loc_path_connected_space (boolean_algebra.core (semigroup pos)) := sorry --non-trivial
lemma new_lemma_30424 (h0 : function.extfun Type topological_space) : @topological_space.separable_space.{0} (boolean_algebra.core.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (boolean_algebra.core.{0} num))  := sorry --non-trivial
lemma new_lemma_30425 (h0 : group (normed_group (denumerable linarith.ineq))) : normalizer_condition (normed_group (denumerable linarith.ineq)) := sorry --non-trivial
lemma new_lemma_30426 (h0 : topological_space (finset (has_to_string (has_nndist linarith.comp)))) : t1_space (finset (has_to_string (has_nndist linarith.comp))) := sorry --non-trivial
lemma new_lemma_30427 (h0 : functor.add_const (topological_space (canonically_ordered_comm_semiring Type)) linarith.comp) : @t0_space.{1} (canonically_ordered_comm_semiring.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (canonically_ordered_comm_semiring.{1} Type)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_30428 (h0 : functor.add_const (function.extfun Type uniform_space) Type) : @complete_space.{0} (add_cancel_monoid.{0} pos) (@function.extfun_app.{2 1} Type uniform_space.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type uniform_space.{0}) Type h0) (add_cancel_monoid.{0} pos))  := sorry --non-trivial
lemma new_lemma_30429 (h0 : function.extfun Type topological_space) : @normal_space.{0} (ring.{0} ennreal) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (ring.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_30430 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_noetherian_ring.{0} (has_neg.{0} name) (@function.extfun_app.{2 1} Type semiring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 semiring.{0}) (has_neg.{0} name))  := sorry --non-trivial
lemma new_lemma_30431 (h0 : complete_lattice (linear_ordered_cancel_comm_monoid congr_arg_kind)) : complete_lattice.is_Sup_finite_compact (linear_ordered_cancel_comm_monoid congr_arg_kind) := sorry --non-trivial
lemma new_lemma_30432 (h0 : functor.add_const (topological_space (linear_order unsigned)) unsigned) : @totally_separated_space.{0} (linear_order.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (linear_order.{0} unsigned)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_30433 (h2 : add_group (distrib (comm_ring char))) : is_add_cyclic (distrib (comm_ring char)) := sorry --non-trivial
lemma new_lemma_30434 (h0 : complete_lattice (has_append (random_gen (has_nnnorm (has_nnnorm char))))) : is_compactly_generated (has_append (random_gen (has_nnnorm (has_nnnorm char)))) := sorry --non-trivial
lemma new_lemma_30435 (h0 : has_mem.mem (has_top empty) has_emptyc.emptyc) : @totally_separated_space.{0} (has_top.{0} empty) (@finset.pi.empty.{1 0} Type topological_space.{0} (has_top.{0} empty) h0)  := sorry --non-trivial
lemma new_lemma_30436 (h0 : uniform_space (denumerable string_imp)) : complete_space (denumerable string_imp) := sorry --non-trivial
lemma new_lemma_30437 (h0 : filter (has_nndist (has_neg (has_neg pos)))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_30438 (h0 : has_mem.mem (measurable_space linarith.comp) has_emptyc.emptyc) : @group.fg.{0} (measurable_space.{0} linarith.comp) (@finset.pi.empty.{1 0} Type group.{0} (measurable_space.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_30439 (h0 : not (topological_space linarith.ineq -> false)) : @path_connected_space.{0} linarith.ineq (@classical.by_contradiction'.{1} (topological_space.{0} linarith.ineq) h0)  := sorry --non-trivial
lemma new_lemma_30440 (h0 : functor.add_const (ring (normed_comm_ring Type)) name) : @is_domain.{1} (normed_comm_ring.{1} Type) (@functor.add_const.run.{1 0} (ring.{1} (normed_comm_ring.{1} Type)) name h0)  := sorry --non-trivial
lemma new_lemma_30441 (h0 : functor.add_const (cancel_comm_monoid_with_zero (ring pos)) linarith.comp) : @unique_factorization_monoid.{0} (ring.{0} pos) (@functor.add_const.run.{0 0} (cancel_comm_monoid_with_zero.{0} (ring.{0} pos)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_30442 (h0 : functor.add_const (uniform_space (has_Inf linarith.comp)) name) : @complete_space.{0} (has_Inf.{0} linarith.comp) (@functor.add_const.run.{0 0} (uniform_space.{0} (has_Inf.{0} linarith.comp)) name h0)  := sorry --non-trivial
lemma new_lemma_30443 (h0 : topological_space (cancel_monoid pos)) : path_connected_space (cancel_monoid pos) := sorry --non-trivial
lemma new_lemma_30444 (h0 : ring (canonically_ordered_comm_semiring (option (option (option empty))))) : is_principal_ideal_ring (canonically_ordered_comm_semiring (option (option (option empty)))) := sorry --non-trivial
lemma new_lemma_30445 (h0 : topological_space (add_cancel_monoid (add_comm_monoid environment.implicit_infer_kind))) : path_connected_space (add_cancel_monoid (add_comm_monoid environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_30446 (h0 : filter (add_cancel_monoid (has_add (finset (has_add linarith.comp))))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_30447 (h0 : filter (non_assoc_semiring (semiring (semiring (semiring congr_arg_kind))))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_30448 (h0 : function.extfun Type add_group) : @is_add_cyclic.{0} (ring.{0} ennreal) (@function.extfun_app.{2 1} Type add_group.{0} h0 (ring.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_30449 (h0 : functor.add_const (monoid (linear_order empty)) empty) : @monoid.fg.{0} (linear_order.{0} empty) (@functor.add_const.run.{0 0} (monoid.{0} (linear_order.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_30450 (h0 : not (topological_space (has_emptyc (random_gen linarith.comp_source)) -> false)) : @path_connected_space.{0} (has_emptyc.{0} (random_gen.{0} linarith.comp_source)) (@classical.by_contradiction'.{1} (topological_space.{0} (has_emptyc.{0} (random_gen.{0} linarith.comp_source))) h0)  := sorry --non-trivial
lemma new_lemma_30451 (h1 : topological_space (nondiscrete_normed_field string.iterator_imp)) : totally_disconnected_space (nondiscrete_normed_field string.iterator_imp) := sorry --non-trivial
lemma new_lemma_30452 (h0 : uniform_space (ring (semigroup name))) : separated_space (ring (semigroup name)) := sorry --non-trivial
lemma new_lemma_30453 (h0 : has_le (distrib_lattice (random_gen linarith.comp_source))) (h1 : bounded_order (distrib_lattice (random_gen linarith.comp_source))) : is_simple_order (distrib_lattice (random_gen linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_30454 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @monoid.fg.{0} (with_one.{0} empty) (@function.extfun_app.{2 1} Type monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 monoid.{0}) (with_one.{0} empty))  := sorry --non-trivial
lemma new_lemma_30455 (h0 : not (prod (plift num) (plift num) -> false)) : id_rel (classical.by_contradiction' h0) := sorry --non-trivial
lemma new_lemma_30456 (h0 : topological_space (has_star (semiring num))) : topological_space.separable_space (has_star (semiring num)) := sorry --non-trivial
lemma new_lemma_30457 (h0 : topological_space (denumerable (has_lt linarith.ineq))) : path_connected_space (denumerable (has_lt linarith.ineq)) := sorry --non-trivial
lemma new_lemma_30458 (h0 : group (monoid_with_zero (option (option unsigned)))) : is_simple_group (monoid_with_zero (option (option unsigned))) := sorry --non-trivial
lemma new_lemma_30459 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_compactly_generated.{0} (monoid_with_zero.{0} unsigned) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (monoid_with_zero.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_30460 (h0 : function.extfun (finset (Type -> Type)) (has_mem.mem ring)) : @rank_condition.{0} (semiring.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type ring.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) ring.{0} (@function.extfun_app.{2 0} (finset.{1} (Type → Type)) (@has_mem.mem.{1 1} (Type → Type) (finset.{1} (Type → Type)) (@finset.has_mem.{1} (Type → Type)) ring.{0}) h0 (@has_emptyc.emptyc.{1} (finset.{1} (Type → Type)) (@finset.has_emptyc.{1} (Type → Type))))) (semiring.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_30461 (h0 : complete_lattice (canonically_ordered_monoid (ring Type))) : is_compactly_generated (canonically_ordered_monoid (ring Type)) := sorry --non-trivial
lemma new_lemma_30462 (h0 : group (has_add (has_pos_part linarith.comp))) : is_simple_group (has_add (has_pos_part linarith.comp)) := sorry --non-trivial
lemma new_lemma_30463 (h0 : topological_space (ring (has_neg_part Type))) : preconnected_space (ring (has_neg_part Type)) := sorry --non-trivial
lemma new_lemma_30464 (h0 : semiring (linear_ordered_semiring (has_norm num))) : is_noetherian_ring (linear_ordered_semiring (has_norm num)) := sorry --non-trivial
lemma new_lemma_30465 (h0 : list (complete_semilattice_Sup (has_ssubset linarith.ineq))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_30466 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @preirreducible_space.{0} (has_Inf.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_Inf.{0} pos))  := sorry --non-trivial
lemma new_lemma_30467 (h0 : functor.add_const (group (ring Type)) (has_pos_part (ring linarith.comp))) : @normalizer_condition.{1} (ring.{1} Type) (@functor.add_const.run.{1 0} (group.{1} (ring.{1} Type)) (has_pos_part.{0} (ring.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_30468 (h1 : ring (has_inv char)) : is_domain (has_inv char) := sorry --non-trivial
lemma new_lemma_30469 (h0 : functor.add_const (topological_space (semigroup congr_arg_kind)) unsigned) : @t0_space.{0} (semigroup.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (semigroup.{0} congr_arg_kind)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_30470 (h0 : functor.add_const (complete_lattice pos) pos) : @is_compactly_generated.{0} pos (@functor.add_const.run.{0 0} (complete_lattice.{0} pos) pos h0)  := sorry --non-trivial
lemma new_lemma_30471 (h0 : topological_space (mul_zero_class environment.implicit_infer_kind)) : normal_space (mul_zero_class environment.implicit_infer_kind) := sorry --non-trivial
lemma new_lemma_30472 (h0 : function.extfun Type (functor.comp topological_space add_comm_monoid)) : @irreducible_space.{0} (add_comm_monoid.{0} name) (@functor.comp.run.{0 0 0} topological_space.{0} add_comm_monoid.{0} name (@function.extfun_app.{2 1} Type (functor.comp.{0 0 0} topological_space.{0} add_comm_monoid.{0}) h0 name))  := sorry --non-trivial
lemma new_lemma_30473 (h0 : monoid (add_comm_monoid (boolean_algebra Type))) : monoid.fg (add_comm_monoid (boolean_algebra Type)) := sorry --non-trivial
lemma new_lemma_30474 (h0 : functor.add_const (list (ring Type)) (normed_comm_ring pos)) : list.nodup (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_30475 (h0 : function.extfun (Type 1) topological_space) : @discrete_topology.{1} (generalized_boolean_algebra.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} h0 (generalized_boolean_algebra.{1} Type))  := sorry --non-trivial
lemma new_lemma_30476 (h0 : has_lt (has_compl ereal)) : no_max_order (has_compl ereal) := sorry --non-trivial
lemma new_lemma_30477 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @rank_condition.{0} (normed_linear_ordered_group.{0} unsigned) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (normed_linear_ordered_group.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_30478 (h0 : functor.add_const (add_monoid (add_comm_monoid num)) num) : @add_monoid.fg.{0} (add_comm_monoid.{0} num) (@functor.add_const.run.{0 0} (add_monoid.{0} (add_comm_monoid.{0} num)) num h0)  := sorry --non-trivial
lemma new_lemma_30479 (h0 : not (filter (complete_linear_order num) -> false)) : filter.ne_bot (classical.by_contradiction' h0) := sorry --non-trivial
lemma new_lemma_30480 (h0 : topological_space (as_linear_order congr_arg_kind)) : normal_space (as_linear_order congr_arg_kind) := sorry --non-trivial
lemma new_lemma_30481 (h0 : function.extfun Type topological_space) : @locally_compact_space.{0} (topological_space.{0} fun_info) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (topological_space.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_30482 (h0 : topological_space (has_norm congr_arg_kind)) : topological_space.separable_space (has_norm congr_arg_kind) := sorry --non-trivial
lemma new_lemma_30483 (h0 : topological_space (has_le (mul_one_class linarith.comp_source))) (h1 : preorder (has_le (mul_one_class linarith.comp_source))) : order_closed_topology (has_le (mul_one_class linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_30484 (h0 : ring (has_lt (has_compl string.iterator_imp))) : rank_condition (has_lt (has_compl string.iterator_imp)) := sorry --non-trivial
lemma new_lemma_30485 (h0 : ring (complete_distrib_lattice (option (option empty)))) : is_domain (complete_distrib_lattice (option (option empty))) := sorry --non-trivial
lemma new_lemma_30486 (h0 : topological_space (finset name)) : normal_space (finset name) := sorry --non-trivial
lemma new_lemma_30487 (h0 : group (normed_field (random_gen (random_gen string_imp)))) : is_cyclic (normed_field (random_gen (random_gen string_imp))) := sorry --non-trivial
lemma new_lemma_30488 (h0 : function.extfun Type add_monoid) : @add_monoid.fg.{0} (has_add.{0} linarith.comp) (@function.extfun_app.{2 1} Type add_monoid.{0} h0 (has_add.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_30489 (h0 : functor.add_const (topological_space name) congr_arg_kind) : @t0_space.{0} name (@functor.add_const.run.{0 0} (topological_space.{0} name) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_30490 (h0 : functor.add_const (topological_space (comm_group Type)) name) : @path_connected_space.{1} (comm_group.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (comm_group.{1} Type)) name h0)  := sorry --non-trivial
lemma new_lemma_30491 (h0 : ordered_comm_monoid (has_Inf (has_Inf Type))) : has_exists_mul_of_le (has_Inf (has_Inf Type)) := sorry --non-trivial
lemma new_lemma_30492 (h0 : topological_space (simple_graph (option empty))) : topological_space.separable_space (simple_graph (option empty)) := sorry --non-trivial
lemma new_lemma_30493 (h0 : uniform_space (has_nndist (boolean_algebra name))) : separated_space (has_nndist (boolean_algebra name)) := sorry --non-trivial
lemma new_lemma_30494 (h0 : topological_space (nondiscrete_normed_field (add_comm_semigroup char))) : t0_space (nondiscrete_normed_field (add_comm_semigroup char)) := sorry --non-trivial
lemma new_lemma_30495 (h3 : ring (distrib fun_info)) : is_domain (distrib fun_info) := sorry --non-trivial
lemma new_lemma_30496 (h0 : complete_lattice (mul_zero_class environment.implicit_infer_kind)) : is_compactly_generated (mul_zero_class environment.implicit_infer_kind) := sorry --non-trivial
lemma new_lemma_30497 (h0 : functor.add_const (ring (sub_neg_monoid name)) pos) : @is_principal_ideal_ring.{0} (sub_neg_monoid.{0} name) (@functor.add_const.run.{0 0} (ring.{0} (sub_neg_monoid.{0} name)) pos h0)  := sorry --non-trivial
lemma new_lemma_30498 (h0 : uniform_space (has_top (has_norm (has_norm num)))) : complete_space (has_top (has_norm (has_norm num))) := sorry --non-trivial
lemma new_lemma_30499 (h0 : topological_space pos) : preconnected_space pos := sorry --non-trivial
lemma new_lemma_30500 (h0 : ring (add_monoid (random_gen (random_gen char)))) : rank_condition (add_monoid (random_gen (random_gen char))) := sorry --non-trivial
lemma new_lemma_30501 (h0 : function.extfun Type topological_space) : @path_connected_space.{0} (complete_distrib_lattice.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (complete_distrib_lattice.{0} pos))  := sorry --non-trivial
lemma new_lemma_30502 (h0 : functor.comp cancel_comm_monoid_with_zero has_zero pos) : @unique_factorization_monoid.{0} (has_zero.{0} pos) (@functor.comp.run.{0 0 0} cancel_comm_monoid_with_zero.{0} has_zero.{0} pos h0)  := sorry --non-trivial
lemma new_lemma_30503 (h0 : group (normed_field (random_gen string_imp))) : is_cyclic (normed_field (random_gen string_imp)) := sorry --non-trivial
lemma new_lemma_30504 (h0 : function.extfun Type topological_space) : @locally_compact_space.{0} (comm_monoid.{0} (option.{0} empty)) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (comm_monoid.{0} (option.{0} empty)))  := sorry --non-trivial
lemma new_lemma_30505 (h0 : functor.add_const (ordered_add_comm_monoid (bin_tree empty)) unsigned) : @archimedean.{0} (bin_tree.{0} empty) (@functor.add_const.run.{0 0} (ordered_add_comm_monoid.{0} (bin_tree.{0} empty)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_30506 (h0 : complete_lattice (has_nnnorm (non_unital_non_assoc_semiring (has_nnnorm (has_nnnorm enat))))) : is_compactly_generated (has_nnnorm (non_unital_non_assoc_semiring (has_nnnorm (has_nnnorm enat)))) := sorry --non-trivial
lemma new_lemma_30507 (h0 : function.extfun Type topological_space) : @t0_space.{0} (cancel_monoid.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (cancel_monoid.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_30508 (h0 : ring (boolean_algebra (has_pos_part Type))) : is_domain (boolean_algebra (has_pos_part Type)) := sorry --non-trivial
lemma new_lemma_30509 (h0 : complete_lattice (add_monoid (has_nnnorm (has_nnnorm char)))) : complete_lattice.is_Sup_finite_compact (add_monoid (has_nnnorm (has_nnnorm char))) := sorry --non-trivial
lemma new_lemma_30510 (h0 : not (function.extfun Type uniform_space -> false)) : @separated_space.{0} (mul_zero_class.{0} num) (@function.extfun_app.{2 1} Type uniform_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type uniform_space.{0}) h0) (mul_zero_class.{0} num))  := sorry --non-trivial
lemma new_lemma_30511 (h0 : topological_space (comm_group (has_ssubset (option (has_neg_part num))))) : totally_disconnected_space (comm_group (has_ssubset (option (has_neg_part num)))) := sorry --non-trivial
lemma new_lemma_30512 (h0 : group (random_gen (ordered_semiring linarith.comp_source))) : group.fg (random_gen (ordered_semiring linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_30513 (h0 : ring (semigroup (ring Type))) : is_domain (semigroup (ring Type)) := sorry --non-trivial
lemma new_lemma_30514 (h0 : function.extfun (finset (Type -> Type)) (has_mem.mem topological_space)) : @totally_disconnected_space.{0} (has_top.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) topological_space.{0} (@function.extfun_app.{2 0} (finset.{1} (Type → Type)) (@has_mem.mem.{1 1} (Type → Type) (finset.{1} (Type → Type)) (@finset.has_mem.{1} (Type → Type)) topological_space.{0}) h0 (@has_emptyc.emptyc.{1} (finset.{1} (Type → Type)) (@finset.has_emptyc.{1} (Type → Type))))) (has_top.{0} num))  := sorry --non-trivial
lemma new_lemma_30515 (h0 : functor.add_const (ring (partial_order unsigned)) num) : @rank_condition.{0} (partial_order.{0} unsigned) (@functor.add_const.run.{0 0} (ring.{0} (partial_order.{0} unsigned)) num h0)  := sorry --non-trivial
lemma new_lemma_30516 (h0 : functor.add_const (semiring (ring ennreal)) (option ennreal)) : @is_noetherian_ring.{0} (ring.{0} ennreal) (@functor.add_const.run.{0 0} (semiring.{0} (ring.{0} ennreal)) (option.{0} ennreal) h0)  := sorry --non-trivial
lemma new_lemma_30517 (h0 : functor.add_const (finset (ordered_comm_ring pos)) linarith.comp) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_30518 (h0 : fin has_zero.zero) : @preconnected_space.{0} (normed_lattice_add_comm_group.{0} pos) (@matrix.vec_empty.{0} (topological_space.{0} (normed_lattice_add_comm_group.{0} pos)) h0)  := sorry --non-trivial
lemma new_lemma_30519 (h1 : add_group linarith.ineq) : is_add_cyclic linarith.ineq := sorry --non-trivial
lemma new_lemma_30520 (h0 : functor.add_const (list (semigroup Type)) (has_nndist pos)) : palindrome (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_30521 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @irreducible_space.{0} (as_linear_order.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (as_linear_order.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_30522 (h0 : topological_space (add_comm_monoid (option (option (option num))))) : t0_space (add_comm_monoid (option (option (option num)))) := sorry --non-trivial
lemma new_lemma_30523 (h0 : functor.add_const (functor.comp filter semigroup pos) pos) : countable_Inter_filter (functor.comp.run (functor.add_const.run h0)) := sorry --non-trivial
lemma new_lemma_30524 (h0 : complete_lattice (has_compl (random_gen char))) : is_compactly_generated (has_compl (random_gen char)) := sorry --non-trivial
lemma new_lemma_30525 (h0 : functor.add_const (uniform_space (add_comm_monoid pos)) name) : @separated_space.{0} (add_comm_monoid.{0} pos) (@functor.add_const.run.{0 0} (uniform_space.{0} (add_comm_monoid.{0} pos)) name h0)  := sorry --non-trivial
lemma new_lemma_30526 (h0 : topological_space (ordered_comm_group unsigned)) : totally_separated_space (ordered_comm_group unsigned) := sorry --non-trivial
lemma new_lemma_30527 (h0 : topological_space (ordered_ring (semiring unsigned))) : path_connected_space (ordered_ring (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_30528 (h0 : ordered_add_comm_monoid (canonically_linear_ordered_monoid (has_Inf real))) : archimedean (canonically_linear_ordered_monoid (has_Inf real)) := sorry --non-trivial
lemma new_lemma_30529 (h0 : add_group (random_gen unsigned)) : is_add_cyclic (random_gen unsigned) := sorry --non-trivial
lemma new_lemma_30530 (h0 : functor.add_const (topological_space (has_nndist linarith.comp)) environment.implicit_infer_kind) : @irreducible_space.{0} (has_nndist.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (has_nndist.{0} linarith.comp)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_30531 (h0 : topological_space (has_to_string (comm_group (comm_group Type)))) : loc_path_connected_space (has_to_string (comm_group (comm_group Type))) := sorry --non-trivial
lemma new_lemma_30532 (h0 : not (topological_space (fintype linarith.ineq) -> false)) : @path_connected_space.{0} (fintype.{0} linarith.ineq) (@classical.by_contradiction'.{1} (topological_space.{0} (fintype.{0} linarith.ineq)) h0)  := sorry --non-trivial
lemma new_lemma_30533 (h0 : functor.add_const (ring (has_neg_part environment.implicit_infer_kind)) Type) : @strong_rank_condition.{0} (has_neg_part.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 1} (ring.{0} (has_neg_part.{0} environment.implicit_infer_kind)) Type h0)  := sorry --non-trivial
lemma new_lemma_30534 (h0 : uniform_space (ordered_comm_group (option (option (option (option empty)))))) : separated_space (ordered_comm_group (option (option (option (option empty))))) := sorry --non-trivial
lemma new_lemma_30535 (h0 : functor.add_const (function.extfun Type cancel_comm_monoid_with_zero) pos) : @unique_factorization_monoid.{0} (add_cancel_monoid.{0} pos) (@function.extfun_app.{2 1} Type cancel_comm_monoid_with_zero.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type cancel_comm_monoid_with_zero.{0}) pos h0) (add_cancel_monoid.{0} pos))  := sorry --non-trivial
lemma new_lemma_30536 (h0 : add_group (has_one (linear_ordered_semiring linarith.comp))) : is_add_cyclic (has_one (linear_ordered_semiring linarith.comp)) := sorry --non-trivial
lemma new_lemma_30537 (h0 : functor.add_const (function.extfun Type monoid) linarith.comp) : @monoid.fg.{0} (has_zero.{0} pos) (@function.extfun_app.{2 1} Type monoid.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type monoid.{0}) linarith.comp h0) (has_zero.{0} pos))  := sorry --non-trivial
lemma new_lemma_30538 (h0 : function.extfun Type topological_space) : @normal_space.{0} (linear_ordered_comm_group.{0} (option.{0} empty)) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (linear_ordered_comm_group.{0} (option.{0} empty)))  := sorry --non-trivial
lemma new_lemma_30539 (h0 : fin has_zero.zero) : @normalizer_condition.{0} (complete_distrib_lattice.{0} real) (@matrix.vec_empty.{0} (group.{0} (complete_distrib_lattice.{0} real)) h0)  := sorry --non-trivial
lemma new_lemma_30540 (h0 : topological_space (has_to_string (has_Inf (has_Inf environment.implicit_infer_kind)))) : t1_space (has_to_string (has_Inf (has_Inf environment.implicit_infer_kind))) := sorry --non-trivial
lemma new_lemma_30541 (h0 : function.extfun Type topological_space) : @totally_separated_space.{0} (measurable_space.{0} fun_info) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (measurable_space.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_30542 (h0 : topological_space (normed_group (random_gen (has_top fun_info)))) : locally_compact_space (normed_group (random_gen (has_top fun_info))) := sorry --non-trivial
lemma new_lemma_30543 (h0 : cancel_comm_monoid_with_zero (has_add (ring linarith.comp))) : unique_factorization_monoid (has_add (ring linarith.comp)) := sorry --non-trivial
lemma new_lemma_30544 (h0 : add_monoid (linear_ordered_semiring (has_norm fun_info))) : add_monoid.fg (linear_ordered_semiring (has_norm fun_info)) := sorry --non-trivial
lemma new_lemma_30545 (h0 : function.extfun Type add_monoid) : @add_monoid.fg.{0} (@id.{2} Type linarith.comp) (@function.extfun_app.{2 1} Type add_monoid.{0} h0 (@id.{2} Type linarith.comp))  := sorry --non-trivial
lemma new_lemma_30546 (h0 : topological_space (canonically_linear_ordered_monoid (has_Inf linarith.comp))) : regular_space (canonically_linear_ordered_monoid (has_Inf linarith.comp)) := sorry --non-trivial
lemma new_lemma_30547 (h0 : function.extfun Type topological_space) : @preirreducible_space.{0} (option.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (option.{0} pos))  := sorry --non-trivial
lemma new_lemma_30548 (h0 : function.extfun Type uniform_space) : @complete_space.{0} (comm_ring.{0} fun_info) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (comm_ring.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_30549 (h0 : has_mem.mem add_monoid has_emptyc.emptyc) : @add_monoid.fg.{0} (@id.{2} Type linarith.comp) (@function.extfun_app.{2 1} Type add_monoid.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) add_monoid.{0} h0) (@id.{2} Type linarith.comp))  := sorry --non-trivial
lemma new_lemma_30550 (h0 : topological_space (distrib_lattice (with_bot to_additive.value_type))) : totally_separated_space (distrib_lattice (with_bot to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_30551 (h0 : functor.add_const (group (has_zero pos)) name) : @normalizer_condition.{0} (has_zero.{0} pos) (@functor.add_const.run.{0 0} (group.{0} (has_zero.{0} pos)) name h0)  := sorry --non-trivial
lemma new_lemma_30552 (h0 : topological_space (add_cancel_monoid (has_neg name))) : locally_compact_space (add_cancel_monoid (has_neg name)) := sorry --non-trivial
lemma new_lemma_30553 (h0 : add_group (topological_space (has_nnnorm (has_nnnorm (has_nnnorm linarith.ineq))))) : is_add_cyclic (topological_space (has_nnnorm (has_nnnorm (has_nnnorm linarith.ineq)))) := sorry --non-trivial
lemma new_lemma_30554 (h0 : topological_space (has_zero (ring linarith.comp))) : regular_space (has_zero (ring linarith.comp)) := sorry --non-trivial
lemma new_lemma_30555 (h0 : functor.add_const (ordered_comm_monoid (has_pos_part pos)) linarith.comp) : @has_exists_mul_of_le.{0} (has_pos_part.{0} pos) (@functor.add_const.run.{0 0} (ordered_comm_monoid.{0} (has_pos_part.{0} pos)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_30556 (h0 : topological_space (normed_group (random_gen (random_gen fun_info)))) : discrete_topology (normed_group (random_gen (random_gen fun_info))) := sorry --non-trivial
lemma new_lemma_30557 (h0 h1 : multiset (nondiscrete_normed_field string.iterator_imp)) : multiset.disjoint h0 h1 := sorry --non-trivial
lemma new_lemma_30558 (h0 : topological_space (ordered_comm_monoid (has_Inf (boolean_algebra.core pos)))) : t0_space (ordered_comm_monoid (has_Inf (boolean_algebra.core pos))) := sorry --non-trivial
lemma new_lemma_30559 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_cyclic.{0} (measurable_space.{0} num) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (measurable_space.{0} num))  := sorry --non-trivial
lemma new_lemma_30560 (h0 : topological_space (normed_comm_ring (comm_group Type))) : normal_space (normed_comm_ring (comm_group Type)) := sorry --non-trivial
lemma new_lemma_30561 (h0 : ring (comm_ring (random_gen (normed_field linarith.comp_source)))) : strong_rank_condition (comm_ring (random_gen (normed_field linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_30562 (h0 : group (generalized_boolean_algebra (ring (has_Inf linarith.comp)))) : is_simple_group (generalized_boolean_algebra (ring (has_Inf linarith.comp))) := sorry --non-trivial
lemma new_lemma_30563 (h0 : topological_space (ring ennreal)) : preirreducible_space (ring ennreal) := sorry --non-trivial
lemma new_lemma_30564 (h0 : topological_space (partial_order unsigned)) : topological_space.separable_space (partial_order unsigned) := sorry --non-trivial
lemma new_lemma_30565 (h0 : add_monoid fun_info) (h2 : fun_info) : is_of_fin_add_order h2 := sorry --non-trivial
lemma new_lemma_30566 (h0 : topological_space environment.projection_info) (h2 : Prop) : is_path_connected (id (fun (h1 : environment.projection_info), h2)) := sorry --non-trivial
lemma new_lemma_30567 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @regular_space.{0} (sub_neg_monoid.{0} real) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (sub_neg_monoid.{0} real))  := sorry --non-trivial
lemma new_lemma_30568 (h0 : not (ring (semi_normed_comm_ring (has_lt linarith.comp_source)) -> false)) : @rank_condition.{0} (semi_normed_comm_ring.{0} (has_lt.{0} linarith.comp_source)) (@classical.by_contradiction'.{1} (ring.{0} (semi_normed_comm_ring.{0} (has_lt.{0} linarith.comp_source))) h0)  := sorry --non-trivial
lemma new_lemma_30569 (h0 : functor.add_const (topological_space (has_nndist pos)) environment.implicit_infer_kind) : @loc_path_connected_space.{0} (has_nndist.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (has_nndist.{0} pos)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_30570 (h0 : semiring (boolean_algebra.core (semigroup linarith.comp))) : is_noetherian_ring (boolean_algebra.core (semigroup linarith.comp)) := sorry --non-trivial
lemma new_lemma_30571 (h0 : function.extfun Type group) : @normalizer_condition.{0} (has_to_string.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type group.{0} h0 (has_to_string.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_30572 (h0 : topological_space (simple_graph (option (option empty)))) : t0_space (simple_graph (option (option empty))) := sorry --non-trivial
lemma new_lemma_30573 (h0 : ordered_add_comm_monoid (comm_group (has_neg_part pos))) : archimedean (comm_group (has_neg_part pos)) := sorry --non-trivial
lemma new_lemma_30574 (h0 : functor.add_const (function.extfun (Type 1) uniform_space) pos) : @separated_space.{1} (has_add.{1} Type) (@function.extfun_app.{3 2} (Type 1) uniform_space.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) uniform_space.{1}) pos h0) (has_add.{1} Type))  := sorry --non-trivial
lemma new_lemma_30575 (h0 : ring (has_ssubset (mul_one_class (distrib (normed_field linarith.ineq))))) : rank_condition (has_ssubset (mul_one_class (distrib (normed_field linarith.ineq)))) := sorry --non-trivial
lemma new_lemma_30576 (h0 : function.extfun Type (functor.comp topological_space cancel_monoid)) : @sequential_space.{0} (cancel_monoid.{0} environment.implicit_infer_kind) (@functor.comp.run.{0 0 0} topological_space.{0} cancel_monoid.{0} environment.implicit_infer_kind (@function.extfun_app.{2 1} Type (functor.comp.{0 0 0} topological_space.{0} cancel_monoid.{0}) h0 environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_30577 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @group.fg.{0} (semigroup.{0} unsigned) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (semigroup.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_30578 (h0 : functor.add_const (function.extfun Type add_monoid) linarith.comp) : @add_monoid.fg.{0} (ring.{0} pos) (@function.extfun_app.{2 1} Type add_monoid.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type add_monoid.{0}) linarith.comp h0) (ring.{0} pos))  := sorry --non-trivial
lemma new_lemma_30579 (h0 : functor.add_const (topological_space (boolean_algebra.core Type)) Type) : @t0_space.{1} (boolean_algebra.core.{1} Type) (@functor.add_const.run.{1 1} (topological_space.{1} (boolean_algebra.core.{1} Type)) Type h0)  := sorry --non-trivial
lemma new_lemma_30580 (h0 : functor.add_const (topological_space (normed_comm_ring linarith.comp)) name) : @path_connected_space.{0} (normed_comm_ring.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (normed_comm_ring.{0} linarith.comp)) name h0)  := sorry --non-trivial
lemma new_lemma_30581 (h1 : not (function.extfun Type group -> false)) : @normalizer_condition.{0} (with_bot.{0} fun_info) (@function.extfun_app.{2 1} Type group.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type group.{0}) h1) (with_bot.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_30582 (h0 : monoid (measurable_space.dynkin_system empty)) (h1 : topological_space (star_monoid (measurable_space.dynkin_system empty))) : path_connected_space (star_monoid (measurable_space.dynkin_system empty)) := sorry --non-trivial
lemma new_lemma_30583 (h0 : function.extfun Type list) : list.nodup (function.extfun_app h0 (has_top fun_info)) := sorry --non-trivial
lemma new_lemma_30584 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @irreducible_space.{0} linarith.comp_source (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) linarith.comp_source)  := sorry --non-trivial
lemma new_lemma_30585 (h0 : fin has_zero.zero) : @is_domain.{1} (sub_neg_monoid.{1} Type) (@matrix.vec_empty.{1} (ring.{1} (sub_neg_monoid.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_30586 (h0 : finset (finset real)) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_30587 (h0 : ring (simple_graph linarith.comp_source)) : strong_rank_condition (simple_graph linarith.comp_source) := sorry --non-trivial
lemma new_lemma_30588 (h0 : list (has_bot (has_neg (has_Inf real)))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_30589 (h0 : filter (metric_space (semiring (semiring (semiring (semiring (semiring congr_arg_kind))))))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_30590 (h0 : ring (normed_linear_ordered_group unsigned)) : strong_rank_condition (normed_linear_ordered_group unsigned) := sorry --non-trivial
lemma new_lemma_30591 (h0 : functor.add_const (group (finset Type)) environment.implicit_infer_kind) : @normalizer_condition.{1} (finset.{1} Type) (@functor.add_const.run.{1 0} (group.{1} (finset.{1} Type)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_30592 (h0 : filter (boolean_algebra.core (has_zero name))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_30593 (h1 : function.extfun (Type -> Type) (function.extfun Type)) : @is_cyclic.{0} empty (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h1 group.{0}) empty)  := sorry --non-trivial
lemma new_lemma_30594 (h0 : filter (has_neg Type)) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_30595 (h0 : functor.add_const (function.extfun Type ring) Type) : @is_domain.{0} (has_pos_part.{0} linarith.comp) (@function.extfun_app.{2 1} Type ring.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type ring.{0}) Type h0) (has_pos_part.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_30596 (h0 : list (topological_space linarith.comp_source)) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_30597 (h0 : topological_space (semiring (has_top (has_top (has_top fun_info))))) : totally_disconnected_space (semiring (has_top (has_top (has_top fun_info)))) := sorry --non-trivial
lemma new_lemma_30598 (h0 : functor.add_const (cancel_comm_monoid_with_zero znum) (option (option (option (option unsigned))))) : @unique_factorization_monoid.{0} znum (@functor.add_const.run.{0 0} (cancel_comm_monoid_with_zero.{0} znum) (option.{0} (option.{0} (option.{0} (option.{0} unsigned)))) h0)  := sorry --non-trivial
lemma new_lemma_30599 (h0 : functor.add_const (ring (complete_distrib_lattice Type)) linarith.comp) : @strong_rank_condition.{1} (complete_distrib_lattice.{1} Type) (@functor.add_const.run.{1 0} (ring.{1} (complete_distrib_lattice.{1} Type)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_30600 (h0 : fin has_zero.zero) : @is_cyclic.{0} (generalized_boolean_algebra.{0} real) (@matrix.vec_empty.{0} (group.{0} (generalized_boolean_algebra.{0} real)) h0)  := sorry --non-trivial
lemma new_lemma_30601 (h0 : topological_space (has_zero (has_neg_part environment.implicit_infer_kind))) : loc_path_connected_space (has_zero (has_neg_part environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_30602 (h0 : topological_space (measurable_space (has_inv (has_inv linarith.comp_source)))) : locally_compact_space (measurable_space (has_inv (has_inv linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_30603 (h0 : topological_space (add_semigroup congr_arg_kind)) : loc_path_connected_space (add_semigroup congr_arg_kind) := sorry --non-trivial
lemma new_lemma_30604 (h0 : filter (complete_distrib_lattice (finset ennreal))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_30605 (h0 : topological_space (has_to_string (ring (finset (finset environment.implicit_infer_kind))))) : locally_compact_space (has_to_string (ring (finset (finset environment.implicit_infer_kind)))) := sorry --non-trivial
lemma new_lemma_30606 (h0 : functor.add_const (topological_space (add_comm_monoid Type)) (has_add (has_add Type))) : @preconnected_space.{1} (add_comm_monoid.{1} Type) (@functor.add_const.run.{1 1} (topological_space.{1} (add_comm_monoid.{1} Type)) (has_add.{1} (has_add.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_30607 (h3 : list (has_emptyc linarith.ineq)) : list.nodup h3 := sorry --non-trivial
lemma new_lemma_30608 (h0 : functor.add_const (topological_space (has_Inf Type)) pos) : @totally_separated_space.{1} (has_Inf.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (has_Inf.{1} Type)) pos h0)  := sorry --non-trivial
lemma new_lemma_30609 (h0 : topological_space (has_le to_additive.value_type)) : t0_space (has_le to_additive.value_type) := sorry --non-trivial
lemma new_lemma_30610 (h0 : topological_space (add_comm_monoid (semigroup (semigroup environment.implicit_infer_kind)))) : irreducible_space (add_comm_monoid (semigroup (semigroup environment.implicit_infer_kind))) := sorry --non-trivial
lemma new_lemma_30611 (h0 : add_monoid (linear_ordered_field (cancel_monoid (cancel_monoid ennreal)))) : add_monoid.fg (linear_ordered_field (cancel_monoid (cancel_monoid ennreal))) := sorry --non-trivial
lemma new_lemma_30612 (h0 : has_emptyc ereal) (h1 : sym2 (has_emptyc ereal)) : sym2.mem h0 h1 := sorry --non-trivial
lemma new_lemma_30613 (h0 : function.extfun Type cancel_comm_monoid_with_zero) : @unique_factorization_monoid.{0} (has_pos_part.{0} name) (@function.extfun_app.{2 1} Type cancel_comm_monoid_with_zero.{0} h0 (has_pos_part.{0} name))  := sorry --non-trivial
lemma new_lemma_30614 (h0 : functor.add_const (ring (mul_zero_class num)) empty) : @strong_rank_condition.{0} (mul_zero_class.{0} num) (@functor.add_const.run.{0 0} (ring.{0} (mul_zero_class.{0} num)) empty h0)  := sorry --non-trivial
lemma new_lemma_30615 (h0 : function.extfun Type topological_space) : @t1_space.{0} (left_cancel_semigroup.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (left_cancel_semigroup.{0} empty))  := sorry --non-trivial
lemma new_lemma_30616 (h0 : comm_ring (has_nnnorm char) -> comm_ring (has_nnnorm char) -> comm_ring (has_nnnorm char)) : associative h0 := sorry --non-trivial
lemma new_lemma_30617 (h0 : function.extfun Type (prod (has_one num))) : id_rel (function.extfun_app h0 (has_one num)) := sorry --non-trivial
lemma new_lemma_30618 (h0 : group (ring (boolean_algebra.core (normed_comm_ring (boolean_algebra pos))))) : is_simple_group (ring (boolean_algebra.core (normed_comm_ring (boolean_algebra pos)))) := sorry --non-trivial
lemma new_lemma_30619 (h0 : function.extfun Type topological_space) : @normal_space.{0} (boolean_algebra.core.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (boolean_algebra.core.{0} pos))  := sorry --non-trivial
lemma new_lemma_30620 (h0 : ring (generalized_boolean_algebra (has_Inf real))) : rank_condition (generalized_boolean_algebra (has_Inf real)) := sorry --non-trivial
lemma new_lemma_30621 (h0 : topological_space (ordered_comm_monoid (boolean_algebra.core linarith.comp))) : totally_separated_space (ordered_comm_monoid (boolean_algebra.core linarith.comp)) := sorry --non-trivial
lemma new_lemma_30622 (h0 : add_monoid (boolean_algebra.core (ring linarith.comp))) : add_monoid.fg (boolean_algebra.core (ring linarith.comp)) := sorry --non-trivial
lemma new_lemma_30623 (h0 : uniform_space (ring Type)) : complete_space (ring Type) := sorry --non-trivial
lemma new_lemma_30624 (h0 : not (group (semiring unsigned) -> false)) : @is_cyclic.{0} (semiring.{0} unsigned) (@classical.by_contradiction'.{1} (group.{0} (semiring.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_30625 (h0 : topological_space (canonically_ordered_comm_semiring (finset name))) : locally_compact_space (canonically_ordered_comm_semiring (finset name)) := sorry --non-trivial
lemma new_lemma_30626 (h0 : functor.add_const (topological_space (boolean_algebra pos)) (has_neg Type)) : @topological_space.separable_space.{0} (boolean_algebra.{0} pos) (@functor.add_const.run.{0 1} (topological_space.{0} (boolean_algebra.{0} pos)) (has_neg.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_30627 (h0 : functor.add_const (monoid (normed_comm_ring name)) linarith.comp) : @monoid.fg.{0} (normed_comm_ring.{0} name) (@functor.add_const.run.{0 0} (monoid.{0} (normed_comm_ring.{0} name)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_30628 (h0 : functor.add_const (ring (finset name)) pos) : @rank_condition.{0} (finset.{0} name) (@functor.add_const.run.{0 0} (ring.{0} (finset.{0} name)) pos h0)  := sorry --non-trivial
lemma new_lemma_30629 (h0 : group (finset (finset Type))) : group.fg (finset (finset Type)) := sorry --non-trivial
lemma new_lemma_30630 (h0 : add_group (has_append fun_info)) : is_add_cyclic (has_append fun_info) := sorry --non-trivial
lemma new_lemma_30631 (h0 : functor.add_const (ring (boolean_algebra.core pos)) linarith.comp) : @is_principal_ideal_ring.{0} (boolean_algebra.core.{0} pos) (@functor.add_const.run.{0 0} (ring.{0} (boolean_algebra.core.{0} pos)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_30632 (h0 : functor.add_const (complete_lattice pos) ennreal) : @complete_lattice.is_Sup_finite_compact.{0} pos (@functor.add_const.run.{0 0} (complete_lattice.{0} pos) ennreal h0)  := sorry --non-trivial
lemma new_lemma_30633 (h0 : finset (cancel_monoid ennreal)) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_30634 (h0 : function.extfun Type uniform_space) : @separated_space.{0} (has_star.{0} empty) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (has_star.{0} empty))  := sorry --non-trivial
lemma new_lemma_30635 (h0 : function.extfun Type topological_space) : @locally_compact_space.{0} (has_zero.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_zero.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_30636 (h2 : topological_space (mul_one_class fun_info)) : path_connected_space (mul_one_class fun_info) := sorry --non-trivial
lemma new_lemma_30637 (h0 : topological_space (finset (mul_one_class to_additive.value_type))) : path_connected_space (finset (mul_one_class to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_30638 (h0 : functor.add_const (topological_space (complete_distrib_lattice name)) name) : @sequential_space.{0} (complete_distrib_lattice.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (complete_distrib_lattice.{0} name)) name h0)  := sorry --non-trivial
lemma new_lemma_30639 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @discrete_topology.{0} (ordered_comm_monoid.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (ordered_comm_monoid.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_30640 (h0 : topological_space (add_cancel_monoid (finset unsigned))) : irreducible_space (add_cancel_monoid (finset unsigned)) := sorry --non-trivial
lemma new_lemma_30641 (h0 : not (complete_lattice (with_bot congr_arg_kind) -> false)) : @complete_lattice.is_Sup_finite_compact.{0} (with_bot.{0} congr_arg_kind) (@classical.by_contradiction'.{1} (complete_lattice.{0} (with_bot.{0} congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_30642 (h0 : functor.add_const (functor.comp ring has_neg_part ennreal) name) : @is_principal_ideal_ring.{0} (has_neg_part.{0} ennreal) (@functor.comp.run.{0 0 0} ring.{0} has_neg_part.{0} ennreal (@functor.add_const.run.{0 0} (functor.comp.{0 0 0} ring.{0} has_neg_part.{0} ennreal) name h0))  := sorry --non-trivial
lemma new_lemma_30643 (h1 : set (nondiscrete_normed_field std_gen)) : set.finite h1 := sorry --non-trivial
lemma new_lemma_30644 (h0 : functor.add_const (topological_space (add_comm_monoid Type)) pos) : @irreducible_space.{1} (add_comm_monoid.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (add_comm_monoid.{1} Type)) pos h0)  := sorry --non-trivial
lemma new_lemma_30645 (h0 : group (ring (finset linarith.comp))) : is_cyclic (ring (finset linarith.comp)) := sorry --non-trivial
lemma new_lemma_30646 (h0 : fin has_zero.zero) : @has_exists_mul_of_le.{1} (canonically_linear_ordered_monoid.{1} Type) (@matrix.vec_empty.{1} (ordered_comm_monoid.{1} (canonically_linear_ordered_monoid.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_30647 (h0 : group (normed_group (has_top (has_top fun_info)))) : is_cyclic (normed_group (has_top (has_top fun_info))) := sorry --non-trivial
lemma new_lemma_30648 (h1 : topological_space (random_gen (has_nnnorm (has_nnnorm (has_nnnorm (has_inv char)))))) : path_connected_space (random_gen (has_nnnorm (has_nnnorm (has_nnnorm (has_inv char))))) := sorry --non-trivial
lemma new_lemma_30649 (h0 : topological_space (has_star (semiring (semiring unsigned)))) : irreducible_space (has_star (semiring (semiring unsigned))) := sorry --non-trivial
lemma new_lemma_30650 (h0 : topological_space (boolean_algebra (finset pos))) : totally_separated_space (boolean_algebra (finset pos)) := sorry --non-trivial
lemma new_lemma_30651 (h0 : functor.add_const (function.extfun Type group) environment.implicit_infer_kind) : @group.fg.{0} (cancel_monoid.{0} ennreal) (@function.extfun_app.{2 1} Type group.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type group.{0}) environment.implicit_infer_kind h0) (cancel_monoid.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_30652 (h0 : has_add (option (option (option ennreal))) -> has_add (option (option (option ennreal))) -> Prop) : is_symm (has_add (option (option (option ennreal)))) h0 := sorry --non-trivial
lemma new_lemma_30653 (h0 : functor.add_const (function.extfun Type ring) Type) : @rank_condition.{0} (has_zero.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type ring.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type ring.{0}) Type h0) (has_zero.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_30654 (h0 : topological_space (preorder empty)) : topological_space.separable_space (preorder empty) := sorry --non-trivial
lemma new_lemma_30655 (h0 : list (denumerable string_imp)) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_30656 (h1 : ring (has_ssubset to_additive.value_type)) : strong_rank_condition (has_ssubset to_additive.value_type) := sorry --non-trivial
lemma new_lemma_30657 (h0 : function.extfun Type topological_space) : @totally_disconnected_space.{0} (has_pos_part.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_pos_part.{0} name))  := sorry --non-trivial
lemma new_lemma_30658 (h0 : topological_space (has_Inf (has_add (has_add name)))) : sequential_space (has_Inf (has_add (has_add name))) := sorry --non-trivial
lemma new_lemma_30659 (h0 : topological_space (normed_linear_ordered_group empty)) : preirreducible_space (normed_linear_ordered_group empty) := sorry --non-trivial
lemma new_lemma_30660 (h0 : function.extfun Type (functor.comp topological_space add_cancel_monoid)) : @preirreducible_space.{0} (add_cancel_monoid.{0} unsigned) (@functor.comp.run.{0 0 0} topological_space.{0} add_cancel_monoid.{0} unsigned (@function.extfun_app.{2 1} Type (functor.comp.{0 0 0} topological_space.{0} add_cancel_monoid.{0}) h0 unsigned))  := sorry --non-trivial
lemma new_lemma_30661 (h0 : uniform_space (canonically_linear_ordered_monoid pos)) : separated_space (canonically_linear_ordered_monoid pos) := sorry --non-trivial
lemma new_lemma_30662 (h0 : function.extfun Type topological_space) : @irreducible_space.{0} (semigroup.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (semigroup.{0} num))  := sorry --non-trivial
lemma new_lemma_30663 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @preirreducible_space.{1} (canonically_ordered_monoid.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 topological_space.{1}) (canonically_ordered_monoid.{1} Type))  := sorry --non-trivial
lemma new_lemma_30664 (h0 : function.extfun Type topological_space) : @path_connected_space.{0} (ring.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (ring.{0} num))  := sorry --non-trivial
lemma new_lemma_30665 (h0 : topological_space (distrib_lattice to_additive.value_type)) : irreducible_space (distrib_lattice to_additive.value_type) := sorry --non-trivial
lemma new_lemma_30666 (h0 : function.extfun ((Type -> Type) -> Type 1) (function.extfun (Type -> Type))) : @unique_factorization_monoid.{0} (omega_complete_partial_order.{0} empty) (@function.extfun_app.{2 1} Type cancel_comm_monoid_with_zero.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) (@function.extfun_app.{3 2} ((Type → Type) → Type 1) (function.extfun.{2 2} (Type → Type)) h0 (function.extfun.{2 1} Type)) cancel_comm_monoid_with_zero.{0}) (omega_complete_partial_order.{0} empty))  := sorry --non-trivial
lemma new_lemma_30667 (h0 : group ennreal) : is_cyclic ennreal := sorry --non-trivial
lemma new_lemma_30668 (h0 : function.extfun Type group) : @is_cyclic.{0} (boolean_algebra.core.{0} ennreal) (@function.extfun_app.{2 1} Type group.{0} h0 (boolean_algebra.core.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_30669 (h0 : function.extfun Type uniform_space) : @complete_space.{0} (preorder.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (preorder.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_30670 (h0 : ring (has_add (ordered_comm_ring linarith.comp_source))) : strong_rank_condition (has_add (ordered_comm_ring linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_30671 (h0 : function.extfun Type list) : list.nodup (function.extfun_app h0 (comm_group name)) := sorry --non-trivial
lemma new_lemma_30672 (h0 : topological_space (complete_semilattice_Sup linarith.ineq)) : totally_separated_space (complete_semilattice_Sup linarith.ineq) := sorry --non-trivial
lemma new_lemma_30673 (h0 : functor.add_const (ring (canonically_ordered_comm_semiring pos)) Type) : @strong_rank_condition.{0} (canonically_ordered_comm_semiring.{0} pos) (@functor.add_const.run.{0 1} (ring.{0} (canonically_ordered_comm_semiring.{0} pos)) Type h0)  := sorry --non-trivial
lemma new_lemma_30674 (h0 : function.extfun Type topological_space) : @preirreducible_space.{0} (with_bot.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (with_bot.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_30675 (h6 : group (has_append to_additive.value_type)) : is_cyclic (has_append to_additive.value_type) := sorry --non-trivial
lemma new_lemma_30676 (h0 : function.extfun Type topological_space) : @t1_space.{0} (generalized_boolean_algebra.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (generalized_boolean_algebra.{0} pos))  := sorry --non-trivial
lemma new_lemma_30677 (h0 : has_mem.mem (with_one congr_arg_kind) has_emptyc.emptyc) : @totally_separated_space.{0} (with_one.{0} congr_arg_kind) (@finset.pi.empty.{1 0} Type topological_space.{0} (with_one.{0} congr_arg_kind) h0)  := sorry --non-trivial
lemma new_lemma_30678 (h0 : ring (has_compl (has_nnnorm (has_nnnorm linarith.comp_source)))) : is_domain (has_compl (has_nnnorm (has_nnnorm linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_30679 (h0 : functor.add_const (cancel_comm_monoid_with_zero (ordered_ring empty)) congr_arg_kind) : @unique_factorization_monoid.{0} (ordered_ring.{0} empty) (@functor.add_const.run.{0 0} (cancel_comm_monoid_with_zero.{0} (ordered_ring.{0} empty)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_30680 (h0 : functor.add_const (topological_space (boolean_algebra pos)) name) : @sequential_space.{0} (boolean_algebra.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (boolean_algebra.{0} pos)) name h0)  := sorry --non-trivial
lemma new_lemma_30681 (h0 : complete_lattice (has_compl ereal)) : is_compactly_generated (has_compl ereal) := sorry --non-trivial
lemma new_lemma_30682 (h0 : monoid (distrib_lattice (random_gen to_additive.value_type))) : monoid.fg (distrib_lattice (random_gen to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_30683 (h0 : ring (is_R_or_C num)) : is_domain (is_R_or_C num) := sorry --non-trivial
lemma new_lemma_30684 (h0 : functor.add_const (filter (cancel_monoid ennreal)) name) : filter.ne_bot (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_30685 (h0 : ring (has_inv (has_inv (random_gen to_additive.value_type)))) : rank_condition (has_inv (has_inv (random_gen to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_30686 (h0 : topological_space (has_inter unsigned)) : totally_separated_space (has_inter unsigned) := sorry --non-trivial
lemma new_lemma_30687 (h0 : group (boolean_algebra (has_to_string (ring name)))) : is_simple_group (boolean_algebra (has_to_string (ring name))) := sorry --non-trivial
lemma new_lemma_30688 (h0 : functor.add_const (topological_space (has_neg pos)) (has_neg linarith.comp)) : @regular_space.{0} (has_neg.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (has_neg.{0} pos)) (has_neg.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_30689 (h0 : function.extfun Type filter) : filter.ne_bot (function.extfun_app h0 (linear_ordered_comm_monoid_with_zero unsigned)) := sorry --non-trivial
lemma new_lemma_30690 (h0 : complete_lattice (plift (option unsigned))) : complete_lattice.is_Sup_finite_compact (plift (option unsigned)) := sorry --non-trivial
lemma new_lemma_30691 (h0 : functor.add_const (topological_space (semigroup pos)) (has_add pos)) : @irreducible_space.{0} (semigroup.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (semigroup.{0} pos)) (has_add.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_30692 (h0 : topological_space (group_with_zero (option num))) : preirreducible_space (group_with_zero (option num)) := sorry --non-trivial
lemma new_lemma_30693 (h0 : not (group (has_union num) -> false)) : @normalizer_condition.{0} (has_union.{0} num) (@classical.by_contradiction'.{1} (group.{0} (has_union.{0} num)) h0)  := sorry --non-trivial
lemma new_lemma_30694 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_add_cyclic.{0} (group_with_zero.{0} unsigned) (@function.extfun_app.{2 1} Type add_group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 add_group.{0}) (group_with_zero.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_30695 (h0 : functor.add_const (topological_space (add_comm_monoid pos)) environment.implicit_infer_kind) : @regular_space.{0} (add_comm_monoid.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (add_comm_monoid.{0} pos)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_30696 (h0 : ring (complete_semilattice_Sup (random_gen (random_gen (random_gen (with_bot fun_info)))))) : rank_condition (complete_semilattice_Sup (random_gen (random_gen (random_gen (with_bot fun_info))))) := sorry --non-trivial
lemma new_lemma_30697 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @monoid.fg.{0} (measurable_space.{0} num) (@function.extfun_app.{2 1} Type monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 monoid.{0}) (measurable_space.{0} num))  := sorry --non-trivial
lemma new_lemma_30698 (h0 : ring (ring (ring (ring Type)))) : is_principal_ideal_ring (ring (ring (ring Type))) := sorry --non-trivial
lemma new_lemma_30699 (h0 : list (has_norm (has_inv (random_gen (has_top fun_info))))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_30700 (h0 : fin has_zero.zero) : @t0_space.{0} (normed_lattice_add_comm_group.{0} linarith.comp) (@matrix.vec_empty.{0} (topological_space.{0} (normed_lattice_add_comm_group.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_30701 (h0 : topological_space (dlist (has_norm linarith.ineq))) : t0_space (dlist (has_norm linarith.ineq)) := sorry --non-trivial
lemma new_lemma_30702 (h0 : topological_space (has_emptyc (random_gen (has_norm num)))) : locally_compact_space (has_emptyc (random_gen (has_norm num))) := sorry --non-trivial
lemma new_lemma_30703 (h0 : topological_space (has_nndist (add_comm_monoid environment.implicit_infer_kind))) : sequential_space (has_nndist (add_comm_monoid environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_30704 (h0 : has_nndist name -> has_nndist name -> Prop) : is_antisymm (has_nndist name) h0 := sorry --non-trivial
lemma new_lemma_30705 (h0 : functor.add_const (topological_space (has_neg unsigned)) name) : @loc_path_connected_space.{0} (has_neg.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (has_neg.{0} unsigned)) name h0)  := sorry --non-trivial
lemma new_lemma_30706 (h0 : fin has_zero.zero) : @discrete_topology.{0} (sub_neg_monoid.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} (@matrix.vec_empty.{1} (function.extfun.{2 1} Type topological_space.{0}) h0) (sub_neg_monoid.{0} name))  := sorry --non-trivial
lemma new_lemma_30707 (h0 : topological_space (canonically_linear_ordered_monoid real)) : preconnected_space (canonically_linear_ordered_monoid real) := sorry --non-trivial
lemma new_lemma_30708 (h1 : has_mem.mem congr_arg_kind has_emptyc.emptyc) : @totally_separated_space.{0} congr_arg_kind (@finset.pi.empty.{1 0} Type topological_space.{0} congr_arg_kind h1)  := sorry --non-trivial
lemma new_lemma_30709 (h0 : set (ereal -> add_comm_semigroup ereal)) : set.separates_points h0 := sorry --non-trivial
lemma new_lemma_30710 (h0 : function.extfun Type ring) : @rank_condition.{0} (pseudo_emetric_space.{0} unsigned) (@function.extfun_app.{2 1} Type ring.{0} h0 (pseudo_emetric_space.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_30711 (h0 : ring (measure_theory.measure_space (has_top unsigned))) : rank_condition (measure_theory.measure_space (has_top unsigned)) := sorry --non-trivial
lemma new_lemma_30712 (h0 : add_group (fintype linarith.ineq)) : is_add_cyclic (fintype linarith.ineq) := sorry --non-trivial
lemma new_lemma_30713 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @normalizer_condition.{0} (has_inv.{0} linarith.ineq) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (has_inv.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_30714 (h0 : not (topological_space (left_cancel_semigroup empty) -> false)) : @t1_space.{0} (left_cancel_semigroup.{0} empty) (@classical.by_contradiction'.{1} (topological_space.{0} (left_cancel_semigroup.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_30715 (h0 : functor.add_const (group (semigroup Type)) (has_neg_part (has_neg_part Type))) : @normalizer_condition.{1} (semigroup.{1} Type) (@functor.add_const.run.{1 1} (group.{1} (semigroup.{1} Type)) (has_neg_part.{1} (has_neg_part.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_30716 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @unique_factorization_monoid.{0} (normed_comm_ring.{0} linarith.comp) (@function.extfun_app.{2 1} Type cancel_comm_monoid_with_zero.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 cancel_comm_monoid_with_zero.{0}) (normed_comm_ring.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_30717 (h0 : function.extfun (finset Type) (has_mem.mem (with_bot empty))) : @complete_space.{0} (with_bot.{0} empty) (@finset.pi.empty.{1 0} Type uniform_space.{0} (with_bot.{0} empty) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (with_bot.{0} empty)) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_30718 (h1 : function.extfun (Type -> Type) (function.extfun Type)) : @rank_condition.{0} (@id.{2} Type to_additive.value_type) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h1 ring.{0}) (@id.{2} Type to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_30719 (h0 : function.extfun Type semiring) : @is_noetherian_ring.{0} (has_neg_part.{0} ennreal) (@function.extfun_app.{2 1} Type semiring.{0} h0 (has_neg_part.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_30720 (h0 : functor.add_const (function.extfun Type topological_space) (ring name)) : @totally_separated_space.{0} (ordered_comm_ring.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) (ring.{0} name) h0) (ordered_comm_ring.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_30721 (h0 : topological_space (has_top to_additive.value_type)) : t0_space (has_top to_additive.value_type) := sorry --non-trivial
lemma new_lemma_30722 (h0 : group (has_add (has_neg (semigroup linarith.comp)))) : is_simple_group (has_add (has_neg (semigroup linarith.comp))) := sorry --non-trivial
lemma new_lemma_30723 (h1 : set (mul_one_class char)) : set.subsingleton h1 := sorry --non-trivial
lemma new_lemma_30724 (h0 : complete_lattice (ordered_comm_ring (boolean_algebra.core (has_add linarith.comp)))) : is_compactly_generated (ordered_comm_ring (boolean_algebra.core (has_add linarith.comp))) := sorry --non-trivial
lemma new_lemma_30725 (h0 : functor.add_const (function.extfun Type complete_lattice) (option unsigned)) : @is_atomistic.{0} (has_neg.{0} pos) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type complete_lattice.{0}) (option.{0} unsigned) h0) (has_neg.{0} pos))  := sorry --non-trivial
lemma new_lemma_30726 (h0 : function.extfun Type ring) : @strong_rank_condition.{0} (has_add.{0} linarith.comp) (@function.extfun_app.{2 1} Type ring.{0} h0 (has_add.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_30727 (h0 : topological_space (simple_graph (has_pos_part pos))) : regular_space (simple_graph (has_pos_part pos)) := sorry --non-trivial
lemma new_lemma_30728 (h0 : add_group (id (has_inv fun_info))) : is_add_cyclic (id (has_inv fun_info)) := sorry --non-trivial
lemma new_lemma_30729 (h0 : functor.add_const (topological_space (has_nndist Type)) Type) : @locally_compact_space.{1} (has_nndist.{1} Type) (@functor.add_const.run.{1 1} (topological_space.{1} (has_nndist.{1} Type)) Type h0)  := sorry --non-trivial
lemma new_lemma_30730 (h0 : set (linear_ordered_comm_group_with_zero ereal)) : set.finite h0 := sorry --non-trivial
lemma new_lemma_30731 (h0 : functor.add_const (add_group (add_comm_monoid pos)) name) : @is_add_cyclic.{0} (add_comm_monoid.{0} pos) (@functor.add_const.run.{0 0} (add_group.{0} (add_comm_monoid.{0} pos)) name h0)  := sorry --non-trivial
lemma new_lemma_30732 (h0 : has_star (semiring congr_arg_kind) -> has_star (semiring congr_arg_kind) -> Prop) : is_strict_order (has_star (semiring congr_arg_kind)) h0 := sorry --non-trivial
lemma new_lemma_30733 (h0 : functor.add_const (list (semigroup unsigned)) pos) : palindrome (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_30734 (h0 : functor.add_const (group (semigroup pos)) linarith.comp) : @is_simple_group.{0} (semigroup.{0} pos) (@functor.add_const.run.{0 0} (group.{0} (semigroup.{0} pos)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_30735 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @t0_space.{0} (has_inv.{0} char) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_inv.{0} char))  := sorry --non-trivial
lemma new_lemma_30736 (h0 : topological_space (has_neg_part linarith.comp)) : preconnected_space (has_neg_part linarith.comp) := sorry --non-trivial
lemma new_lemma_30737 (h0 : list (boolean_algebra (finset (has_nndist (ring (has_pos_part pos)))))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_30738 (h0 : has_mem.mem (has_emptyc congr_arg_kind) has_emptyc.emptyc) : @monoid.fg.{0} (has_emptyc.{0} congr_arg_kind) (@finset.pi.empty.{1 0} Type monoid.{0} (has_emptyc.{0} congr_arg_kind) h0)  := sorry --non-trivial
lemma new_lemma_30739 (h0 : uniform_space pos) : complete_space pos := sorry --non-trivial
lemma new_lemma_30740 (h0 : ring (has_to_string (normed_comm_ring environment.implicit_infer_kind))) : rank_condition (has_to_string (normed_comm_ring environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_30741 (h0 : topological_space (normed_comm_ring (has_neg_part ennreal))) : locally_compact_space (normed_comm_ring (has_neg_part ennreal)) := sorry --non-trivial
lemma new_lemma_30742 (h0 : functor.add_const (ring (comm_group Type)) Type) : @rank_condition.{1} (comm_group.{1} Type) (@functor.add_const.run.{1 1} (ring.{1} (comm_group.{1} Type)) Type h0)  := sorry --non-trivial
lemma new_lemma_30743 (h0 : topological_space (has_Sup (option unsigned))) : path_connected_space (has_Sup (option unsigned)) := sorry --non-trivial
lemma new_lemma_30744 (h0 : complete_lattice (canonically_linear_ordered_monoid (has_neg_part name))) : is_compactly_generated (canonically_linear_ordered_monoid (has_neg_part name)) := sorry --non-trivial
lemma new_lemma_30745 (h0 : ring (generalized_boolean_algebra (ordered_comm_ring pos))) : is_principal_ideal_ring (generalized_boolean_algebra (ordered_comm_ring pos)) := sorry --non-trivial
lemma new_lemma_30746 (h0 : functor.add_const (function.extfun (Type 1) semiring) Type) : @is_noetherian_ring.{1} (has_nndist.{1} Type) (@function.extfun_app.{3 2} (Type 1) semiring.{1} (@functor.add_const.run.{2 1} (function.extfun.{3 2} (Type 1) semiring.{1}) Type h0) (has_nndist.{1} Type))  := sorry --non-trivial
lemma new_lemma_30747 (h0 : add_group (has_one (has_top unsigned))) : is_add_cyclic (has_one (has_top unsigned)) := sorry --non-trivial
lemma new_lemma_30748 (h0 : functor.add_const (complete_lattice (ordered_ring unsigned)) congr_arg_kind) : @is_atomistic.{0} (ordered_ring.{0} unsigned) (@functor.add_const.run.{0 0} (complete_lattice.{0} (ordered_ring.{0} unsigned)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_30749 (h0 : list (has_norm (has_ssubset string_imp))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_30750 (h0 : functor.add_const (topological_space linarith.comp) (option empty)) : @totally_disconnected_space.{0} linarith.comp (@functor.add_const.run.{0 0} (topological_space.{0} linarith.comp) (option.{0} empty) h0)  := sorry --non-trivial
lemma new_lemma_30751 (h2 : ring (add_comm_semigroup std_gen)) : is_domain (add_comm_semigroup std_gen) := sorry --non-trivial
lemma new_lemma_30752 (h1 : monoid (normed_group (has_top (has_top linarith.comp_source)))) : monoid.fg (normed_group (has_top (has_top linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_30753 (h0 : complete_lattice (has_neg ennreal)) : is_atomistic (has_neg ennreal) := sorry --non-trivial
lemma new_lemma_30754 (h0 : function.extfun (Type 1) topological_space) : @topological_space.separable_space.{1} (plift.{1} num) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} h0 (plift.{1} num))  := sorry --non-trivial
lemma new_lemma_30755 (h0 : filter (partial_order congr_arg_kind)) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_30756 (h0 : function.extfun Type (functor.add_const (filter auto.case_option))) : filter.ne_bot (functor.add_const.run (function.extfun_app h0 empty)) := sorry --non-trivial
lemma new_lemma_30757 (h2 : ring (non_unital_non_assoc_semiring string_imp)) : is_domain (non_unital_non_assoc_semiring string_imp) := sorry --non-trivial
lemma new_lemma_30758 (h0 : ordered_add_comm_monoid (linear_order (semiring empty))) : archimedean (linear_order (semiring empty)) := sorry --non-trivial
lemma new_lemma_30759 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @locally_compact_space.{0} (has_union.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_union.{0} empty))  := sorry --non-trivial
lemma new_lemma_30760 (h0 : function.extfun Type (prod (canonically_ordered_comm_semiring congr_arg_kind))) : id_rel (function.extfun_app h0 (canonically_ordered_comm_semiring congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_30761 (h0 : function.extfun (finset (Type -> Type)) (has_mem.mem complete_lattice)) : @complete_lattice.is_Sup_finite_compact.{0} string_imp (@function.extfun_app.{2 1} Type complete_lattice.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) complete_lattice.{0} (@function.extfun_app.{2 0} (finset.{1} (Type → Type)) (@has_mem.mem.{1 1} (Type → Type) (finset.{1} (Type → Type)) (@finset.has_mem.{1} (Type → Type)) complete_lattice.{0}) h0 (@has_emptyc.emptyc.{1} (finset.{1} (Type → Type)) (@finset.has_emptyc.{1} (Type → Type))))) string_imp)  := sorry --non-trivial
lemma new_lemma_30762 (h0 : semiring (semigroup name)) : is_noetherian_ring (semigroup name) := sorry --non-trivial
lemma new_lemma_30763 (h0 : functor.add_const (filter (has_add linarith.comp)) linarith.comp) : countable_Inter_filter (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_30764 (h0 : function.extfun Type ring) : @strong_rank_condition.{0} (canonically_linear_ordered_monoid.{0} pos) (@function.extfun_app.{2 1} Type ring.{0} h0 (canonically_linear_ordered_monoid.{0} pos))  := sorry --non-trivial
lemma new_lemma_30765 (h0 : function.extfun Type add_group) : @is_add_cyclic.{0} (normed_comm_ring.{0} ennreal) (@function.extfun_app.{2 1} Type add_group.{0} h0 (normed_comm_ring.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_30766 (h0 : topological_space (has_add (finset linarith.comp))) : totally_disconnected_space (has_add (finset linarith.comp)) := sorry --non-trivial
lemma new_lemma_30767 (h0 : has_mem.mem (random_gen linarith.comp_source) has_emptyc.emptyc) : @complete_space.{0} (random_gen.{0} linarith.comp_source) (@finset.pi.empty.{1 0} Type uniform_space.{0} (random_gen.{0} linarith.comp_source) h0)  := sorry --non-trivial
lemma new_lemma_30768 (h0 : functor.add_const (topological_space (left_cancel_monoid num)) num) : @t0_space.{0} (left_cancel_monoid.{0} num) (@functor.add_const.run.{0 0} (topological_space.{0} (left_cancel_monoid.{0} num)) num h0)  := sorry --non-trivial
lemma new_lemma_30769 (h0 : add_group (topological_space (has_nnnorm (denumerable (random_gen char))))) : is_add_cyclic (topological_space (has_nnnorm (denumerable (random_gen char)))) := sorry --non-trivial
lemma new_lemma_30770 (h4 : topological_space (complete_semilattice_Sup linarith.comp_source)) : irreducible_space (complete_semilattice_Sup linarith.comp_source) := sorry --non-trivial
lemma new_lemma_30771 (h0 : functor.add_const (group (has_add linarith.comp)) name) : @group.fg.{0} (has_add.{0} linarith.comp) (@functor.add_const.run.{0 0} (group.{0} (has_add.{0} linarith.comp)) name h0)  := sorry --non-trivial
lemma new_lemma_30772 (h0 : monoid (linear_ordered_field (comm_monoid unsigned))) : monoid.fg (linear_ordered_field (comm_monoid unsigned)) := sorry --non-trivial
lemma new_lemma_30773 (h0 : topological_space (has_top (has_norm num))) : path_connected_space (has_top (has_norm num)) := sorry --non-trivial
lemma new_lemma_30774 (h0 : ordered_comm_monoid (ordered_comm_ring (ring (ring Type)))) : has_exists_mul_of_le (ordered_comm_ring (ring (ring Type))) := sorry --non-trivial
lemma new_lemma_30775 (h0 : group (monoid_with_zero (option ennreal))) : is_cyclic (monoid_with_zero (option ennreal)) := sorry --non-trivial
lemma new_lemma_30776 (h0 : topological_space (semiring (with_bot (has_norm (with_bot to_additive.value_type))))) : totally_disconnected_space (semiring (with_bot (has_norm (with_bot to_additive.value_type)))) := sorry --non-trivial
lemma new_lemma_30777 (h0 : functor.add_const (topological_space (normed_linear_ordered_group unsigned)) unsigned) : @totally_separated_space.{0} (normed_linear_ordered_group.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (normed_linear_ordered_group.{0} unsigned)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_30778 (h0 : functor.add_const (semiring (has_star unsigned)) unsigned) : @is_noetherian_ring.{0} (has_star.{0} unsigned) (@functor.add_const.run.{0 0} (semiring.{0} (has_star.{0} unsigned)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_30779 (h0 : cancel_comm_monoid_with_zero (has_star empty)) : unique_factorization_monoid (has_star empty) := sorry --non-trivial
lemma new_lemma_30780 (h2 : topological_space (normed_group string_imp)) : irreducible_space (normed_group string_imp) := sorry --non-trivial
lemma new_lemma_30781 (h0 : functor.add_const (ring (finset unsigned)) environment.implicit_infer_kind) : @is_domain.{0} (finset.{0} unsigned) (@functor.add_const.run.{0 0} (ring.{0} (finset.{0} unsigned)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_30782 (h0 : functor.add_const (topological_space (has_dist num)) num) : @loc_path_connected_space.{0} (has_dist.{0} num) (@functor.add_const.run.{0 0} (topological_space.{0} (has_dist.{0} num)) num h0)  := sorry --non-trivial
lemma new_lemma_30783 (h0 : not (topological_space (plift empty) -> false)) : @totally_disconnected_space.{1} (plift.{1} empty) (@classical.by_contradiction'.{2} (topological_space.{1} (plift.{1} empty)) h0)  := sorry --non-trivial
lemma new_lemma_30784 (h0 : ordered_add_comm_monoid (omega_complete_partial_order (semiring empty))) : archimedean (omega_complete_partial_order (semiring empty)) := sorry --non-trivial
lemma new_lemma_30785 (h0 : functor.add_const (topological_space (free_add_monoid congr_arg_kind)) unsigned) : @topological_space.separable_space.{0} (free_add_monoid.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (free_add_monoid.{0} congr_arg_kind)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_30786 (h0 : topological_space (boolean_algebra (has_pos_part (has_add pos)))) : t1_space (boolean_algebra (has_pos_part (has_add pos))) := sorry --non-trivial
lemma new_lemma_30787 (h0 : functor.add_const (function.extfun Type topological_space) (has_to_string (has_to_string (finset pos)))) : @preconnected_space.{0} (has_zero.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) (has_to_string.{0} (has_to_string.{0} (finset.{0} pos))) h0) (has_zero.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_30788 (h0 : not (function.extfun Type topological_space -> false)) : @preirreducible_space.{0} (@id.{2} Type empty) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (@id.{2} Type empty))  := sorry --non-trivial
lemma new_lemma_30789 (h0 : uniform_space (canonically_ordered_comm_semiring (has_Inf (has_Inf (has_add pos))))) : separated_space (canonically_ordered_comm_semiring (has_Inf (has_Inf (has_add pos)))) := sorry --non-trivial
lemma new_lemma_30790 (h0 : functor.comp topological_space boolean_algebra unsigned) : @regular_space.{0} (boolean_algebra.{0} unsigned) (@functor.comp.run.{0 0 0} topological_space.{0} boolean_algebra.{0} unsigned h0)  := sorry --non-trivial
lemma new_lemma_30791 (h1 : topological_space (semiring (random_gen congr_arg_kind))) : totally_separated_space (semiring (random_gen congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_30792 (h0 : functor.add_const (finset (has_to_string Type)) linarith.comp) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_30793 (h1 : topological_space (with_bot (random_gen linarith.comp))) : totally_disconnected_space (with_bot (random_gen linarith.comp)) := sorry --non-trivial
lemma new_lemma_30794 (h0 : ring (linear_ordered_field empty)) : strong_rank_condition (linear_ordered_field empty) := sorry --non-trivial
lemma new_lemma_30795 (h0 : topological_space (add_group unsigned)) (h1 : preorder (add_group unsigned)) : order_closed_topology (add_group unsigned) := sorry --non-trivial
lemma new_lemma_30796 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @irreducible_space.{0} (with_bot.{0} (comm_ring.{0} (random_gen.{0} (comm_ring.{0} linarith.ineq)))) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (with_bot.{0} (comm_ring.{0} (random_gen.{0} (comm_ring.{0} linarith.ineq)))))  := sorry --non-trivial
lemma new_lemma_30797 (h0 : ring (has_inv (random_gen to_additive.value_type))) : rank_condition (has_inv (random_gen to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_30798 (h0 : functor.add_const (function.extfun Type uniform_space) name) : @complete_space.{0} (has_add.{0} pos) (@function.extfun_app.{2 1} Type uniform_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type uniform_space.{0}) name h0) (has_add.{0} pos))  := sorry --non-trivial
lemma new_lemma_30799 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : list.nodup (function.extfun_app (function.extfun_app h0 list) (with_one linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_30800 (h0 : functor.add_const (topological_space (ring pos)) (has_pos_part (ring linarith.comp))) : @topological_space.separable_space.{0} (ring.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (ring.{0} pos)) (has_pos_part.{0} (ring.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_30801 (h0 : ring (has_edist congr_arg_kind)) : strong_rank_condition (has_edist congr_arg_kind) := sorry --non-trivial
lemma new_lemma_30802 (h0 : functor.add_const (topological_space (plift congr_arg_kind)) empty) : @topological_space.separable_space.{1} (plift.{1} congr_arg_kind) (@functor.add_const.run.{1 0} (topological_space.{1} (plift.{1} congr_arg_kind)) empty h0)  := sorry --non-trivial
lemma new_lemma_30803 (h0 : not (function.extfun (finset Type) (has_mem.mem to_additive.value_type) -> false)) : @is_add_cyclic.{0} to_additive.value_type (@finset.pi.empty.{1 0} Type add_group.{0} to_additive.value_type (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) to_additive.value_type) (@classical.by_contradiction'.{0} (function.extfun.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) to_additive.value_type)) h0) (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_30804 (h1 : function.extfun Type uniform_space) : @complete_space.{0} (metric_space.{0} num) (@function.extfun_app.{2 1} Type uniform_space.{0} h1 (metric_space.{0} num))  := sorry --non-trivial
lemma new_lemma_30805 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_add_cyclic.{0} (as_linear_order.{0} unsigned) (@function.extfun_app.{2 1} Type add_group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 add_group.{0}) (as_linear_order.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_30806 (h1 : ring (has_append string_imp)) : rank_condition (has_append string_imp) := sorry --non-trivial
lemma new_lemma_30807 (h0 : has_mem.mem (random_gen linarith.comp) has_emptyc.emptyc) : @is_add_cyclic.{0} (random_gen.{0} linarith.comp) (@finset.pi.empty.{1 0} Type add_group.{0} (random_gen.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_30808 (h0 : has_mem.mem (normed_group num) has_emptyc.emptyc) : @irreducible_space.{0} (normed_group.{0} num) (@finset.pi.empty.{1 0} Type topological_space.{0} (normed_group.{0} num) h0)  := sorry --non-trivial
lemma new_lemma_30809 (h0 : ring (linear_ordered_semiring (semiring unsigned))) : strong_rank_condition (linear_ordered_semiring (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_30810 (h0 : functor.add_const (function.extfun Type ring) pos) : @rank_condition.{0} (normed_comm_ring.{0} pos) (@function.extfun_app.{2 1} Type ring.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type ring.{0}) pos h0) (normed_comm_ring.{0} pos))  := sorry --non-trivial
lemma new_lemma_30811 (h0 : topological_space (add_cancel_monoid (add_cancel_monoid Type))) : discrete_topology (add_cancel_monoid (add_cancel_monoid Type)) := sorry --non-trivial
lemma new_lemma_30812 (h0 : complete_lattice (ordered_comm_monoid (sub_neg_monoid (ordered_comm_monoid (has_Inf real))))) : is_atomistic (ordered_comm_monoid (sub_neg_monoid (ordered_comm_monoid (has_Inf real)))) := sorry --non-trivial
lemma new_lemma_30813 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @irreducible_space.{0} (has_zero.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_zero.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_30814 (h0 : functor.add_const (ring (has_inter unsigned)) unsigned) : @is_principal_ideal_ring.{0} (has_inter.{0} unsigned) (@functor.add_const.run.{0 0} (ring.{0} (has_inter.{0} unsigned)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_30815 (h0 : topological_space (boolean_algebra (has_bot real))) : regular_space (boolean_algebra (has_bot real)) := sorry --non-trivial
lemma new_lemma_30816 (h0 : functor.add_const (function.extfun Type ordered_comm_monoid) (add_cancel_monoid Type)) : @has_exists_mul_of_le.{0} (has_add.{0} linarith.comp) (@function.extfun_app.{2 1} Type ordered_comm_monoid.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type ordered_comm_monoid.{0}) (add_cancel_monoid.{1} Type) h0) (has_add.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_30817 (h0 : function.extfun Type complete_lattice) : @is_compactly_generated.{0} (has_norm.{0} fun_info) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (has_norm.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_30818 (h0 : add_group (linear_ordered_semiring congr_arg_kind)) : is_add_cyclic (linear_ordered_semiring congr_arg_kind) := sorry --non-trivial
lemma new_lemma_30819 (h0 : not (has_mem.mem (has_emptyc empty) has_emptyc.emptyc -> false)) : @is_compactly_generated.{0} (has_emptyc.{0} empty) (@finset.pi.empty.{1 0} Type complete_lattice.{0} (has_emptyc.{0} empty) (@classical.by_contradiction'.{0} (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (has_emptyc.{0} empty) (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))) h0))  := sorry --non-trivial
lemma new_lemma_30820 (h1 : not (group (has_lt reducibility_hints) -> false)) : @is_cyclic.{0} (has_lt.{0} reducibility_hints) (@classical.by_contradiction'.{1} (group.{0} (has_lt.{0} reducibility_hints)) h1)  := sorry --non-trivial
lemma new_lemma_30821 (h0 : functor.add_const (ordered_comm_monoid (linear_ordered_field Type)) (has_add Type)) : @has_exists_mul_of_le.{1} (linear_ordered_field.{1} Type) (@functor.add_const.run.{1 1} (ordered_comm_monoid.{1} (linear_ordered_field.{1} Type)) (has_add.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_30822 (h0 : uniform_space (has_top (has_inv (random_gen linarith.ineq)))) : complete_space (has_top (has_inv (random_gen linarith.ineq))) := sorry --non-trivial
lemma new_lemma_30823 (h0 : functor.add_const (uniform_space (left_cancel_monoid empty)) num) : @separated_space.{0} (left_cancel_monoid.{0} empty) (@functor.add_const.run.{0 0} (uniform_space.{0} (left_cancel_monoid.{0} empty)) num h0)  := sorry --non-trivial
lemma new_lemma_30824 (h0 : functor.add_const (group (boolean_algebra environment.implicit_infer_kind)) environment.implicit_infer_kind) : @group.fg.{0} (boolean_algebra.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (group.{0} (boolean_algebra.{0} environment.implicit_infer_kind)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_30825 (h0 : set (has_nnnorm real.angle)) : set.subsingleton h0 := sorry --non-trivial
lemma new_lemma_30826 (h0 : filter (canonically_ordered_monoid fun_info)) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_30827 (h0 : function.extfun Type topological_space) : @path_connected_space.{0} (linear_ordered_comm_monoid_with_zero.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (linear_ordered_comm_monoid_with_zero.{0} empty))  := sorry --non-trivial
lemma new_lemma_30828 (h0 : functor.add_const (topological_space (cancel_monoid name)) linarith.comp) : @discrete_topology.{0} (cancel_monoid.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (cancel_monoid.{0} name)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_30829 (h0 : ring (ordered_comm_monoid pos)) : strong_rank_condition (ordered_comm_monoid pos) := sorry --non-trivial
lemma new_lemma_30830 (h0 : functor.add_const (list (has_Inf linarith.comp)) linarith.comp) : list.nodup (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_30831 (h0 : not (ring (random_gen string.iterator_imp) -> false)) : @rank_condition.{0} (random_gen.{0} string.iterator_imp) (@classical.by_contradiction'.{1} (ring.{0} (random_gen.{0} string.iterator_imp)) h0)  := sorry --non-trivial
lemma new_lemma_30832 (h0 : uniform_space (semigroup (has_add (add_cancel_monoid (has_add name))))) : complete_space (semigroup (has_add (add_cancel_monoid (has_add name)))) := sorry --non-trivial
lemma new_lemma_30833 (h0 : topological_space (has_sub (measurable_space.dynkin_system empty))) : totally_disconnected_space (has_sub (measurable_space.dynkin_system empty)) := sorry --non-trivial
lemma new_lemma_30834 (h0 : functor.add_const (topological_space Type) linarith.comp) : @locally_compact_space.{1} Type (@functor.add_const.run.{1 0} (topological_space.{1} Type) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_30835 (h0 : topological_space (has_pos_part (has_Inf (has_Inf (has_Inf linarith.comp))))) : totally_separated_space (has_pos_part (has_Inf (has_Inf (has_Inf linarith.comp)))) := sorry --non-trivial
lemma new_lemma_30836 (h0 : filter (normed_group to_additive.value_type)) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_30837 (h0 : linear_ordered_ring (has_nnnorm fun_info)) (h1 : multiset (linear_ordered_ring (has_nnnorm fun_info))) : multiset.mem h0 h1 := sorry --non-trivial
lemma new_lemma_30838 (h1 : topological_space (semi_normed_comm_ring string_imp)) : locally_compact_space (semi_normed_comm_ring string_imp) := sorry --non-trivial
lemma new_lemma_30839 (h0 : function.extfun Type list) : list.nodup (function.extfun_app h0 (add_cancel_monoid unsigned)) := sorry --non-trivial
lemma new_lemma_30840 (h0 : functor.add_const (function.extfun Type topological_space) (has_pos_part linarith.comp)) : @regular_space.{0} (has_zero.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) (has_pos_part.{0} linarith.comp) h0) (has_zero.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_30841 (h0 : topological_space (has_bot (has_Inf (has_neg Type)))) : totally_separated_space (has_bot (has_Inf (has_neg Type))) := sorry --non-trivial
lemma new_lemma_30842 (h0 : monoid (has_union (metric_space num))) : monoid.fg (has_union (metric_space num)) := sorry --non-trivial
lemma new_lemma_30843 (h0 : functor.add_const (ring (complete_distrib_lattice environment.implicit_infer_kind)) name) : @rank_condition.{0} (complete_distrib_lattice.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (ring.{0} (complete_distrib_lattice.{0} environment.implicit_infer_kind)) name h0)  := sorry --non-trivial
lemma new_lemma_30844 (h0 : topological_space (linear_ordered_add_comm_group (has_top (has_top linarith.ineq)))) : irreducible_space (linear_ordered_add_comm_group (has_top (has_top linarith.ineq))) := sorry --non-trivial
lemma new_lemma_30845 (h0 : function.extfun Type ring) : @rank_condition.{0} (semigroup.{0} pos) (@function.extfun_app.{2 1} Type ring.{0} h0 (semigroup.{0} pos))  := sorry --non-trivial
lemma new_lemma_30846 (h0 : topological_space (add_monoid to_additive.value_type)) (h1 : set (add_monoid to_additive.value_type)) : is_seq_closed h1 := sorry --non-trivial
lemma new_lemma_30847 (h0 : topological_space (add_comm_monoid empty)) : totally_separated_space (add_comm_monoid empty) := sorry --non-trivial
lemma new_lemma_30848 (h0 : topological_space (ordered_comm_ring (has_to_string Type))) : preirreducible_space (ordered_comm_ring (has_to_string Type)) := sorry --non-trivial
lemma new_lemma_30849 (h0 : functor.add_const (ring (has_neg pos)) Type) : @is_principal_ideal_ring.{0} (has_neg.{0} pos) (@functor.add_const.run.{0 1} (ring.{0} (has_neg.{0} pos)) Type h0)  := sorry --non-trivial
lemma new_lemma_30850 (h0 : ring (has_append (denumerable reducibility_hints))) : is_domain (has_append (denumerable reducibility_hints)) := sorry --non-trivial
lemma new_lemma_30851 (h0 : ring (random_gen (has_nnnorm (random_gen char)))) : is_domain (random_gen (has_nnnorm (random_gen char))) := sorry --non-trivial
lemma new_lemma_30852 (h0 : functor.add_const (topological_space (canonically_ordered_comm_semiring unsigned)) (has_neg name)) : @discrete_topology.{0} (canonically_ordered_comm_semiring.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (canonically_ordered_comm_semiring.{0} unsigned)) (has_neg.{0} name) h0)  := sorry --non-trivial
lemma new_lemma_30853 (h0 : semiring (has_sub empty)) : is_noetherian_ring (has_sub empty) := sorry --non-trivial
lemma new_lemma_30854 (h0 : topological_space (boolean_algebra.core empty)) : topological_space.separable_space (boolean_algebra.core empty) := sorry --non-trivial
lemma new_lemma_30855 (h0 : topological_space (simple_graph (mul_one_class fun_info))) (h1 : add_group (simple_graph (mul_one_class fun_info))) : topological_add_group (simple_graph (mul_one_class fun_info)) := sorry --non-trivial
lemma new_lemma_30856 (h0 : not (complete_lattice (non_assoc_semiring congr_arg_kind) -> false)) : @is_compactly_generated.{0} (non_assoc_semiring.{0} congr_arg_kind) (@classical.by_contradiction'.{1} (complete_lattice.{0} (non_assoc_semiring.{0} congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_30857 (h3 : group (has_nnnorm char)) : is_cyclic (has_nnnorm char) := sorry --non-trivial
lemma new_lemma_30858 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @t0_space.{0} (finset.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (finset.{0} pos))  := sorry --non-trivial
lemma new_lemma_30859 (h0 : functor.add_const Prop (has_nndist (finset linarith.comp))) : functor.add_const.run h0 := sorry --non-trivial
lemma new_lemma_30860 (h0 : has_add std_gen) (h1 : has_le std_gen) (h2 : std_gen) : add_le_cancellable h2 := sorry --non-trivial
lemma new_lemma_30861 (h0 : monoid (ring pos)) : monoid.fg (ring pos) := sorry --non-trivial
lemma new_lemma_30862 (h0 : functor.add_const (ordered_add_comm_monoid (add_cancel_monoid Type)) (has_neg_part Type)) : @archimedean.{1} (add_cancel_monoid.{1} Type) (@functor.add_const.run.{1 1} (ordered_add_comm_monoid.{1} (add_cancel_monoid.{1} Type)) (has_neg_part.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_30863 (h2 : topological_space linarith.comp_source) : totally_separated_space linarith.comp_source := sorry --non-trivial
lemma new_lemma_30864 (h0 : ring (has_star (semiring unsigned))) : rank_condition (has_star (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_30865 (h0 : group (random_gen empty)) : group.fg (random_gen empty) := sorry --non-trivial
lemma new_lemma_30866 (h0 : complete_lattice (has_append (random_gen (random_gen (random_gen (random_gen fun_info)))))) : is_compactly_generated (has_append (random_gen (random_gen (random_gen (random_gen fun_info))))) := sorry --non-trivial
lemma new_lemma_30867 (h0 : functor.add_const (topological_space (has_pos_part name)) Type) : @discrete_topology.{0} (has_pos_part.{0} name) (@functor.add_const.run.{0 1} (topological_space.{0} (has_pos_part.{0} name)) Type h0)  := sorry --non-trivial
lemma new_lemma_30868 (h0 : function.extfun Type ring) : @rank_condition.{0} (has_norm.{0} string_imp) (@function.extfun_app.{2 1} Type ring.{0} h0 (has_norm.{0} string_imp))  := sorry --non-trivial
lemma new_lemma_30869 (h0 : topological_space ereal) (h1 : preorder ereal) : order_closed_topology ereal := sorry --non-trivial
lemma new_lemma_30870 (h0 : list (boolean_algebra (comm_group (comm_group Type)))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_30871 (h0 : not (topological_space (with_bot linarith.ineq) -> false)) : @totally_disconnected_space.{0} (with_bot.{0} linarith.ineq) (@classical.by_contradiction'.{1} (topological_space.{0} (with_bot.{0} linarith.ineq)) h0)  := sorry --non-trivial
lemma new_lemma_30872 (h0 : functor.add_const (ring (pseudo_metric_space num)) ennreal) : @strong_rank_condition.{0} (pseudo_metric_space.{0} num) (@functor.add_const.run.{0 0} (ring.{0} (pseudo_metric_space.{0} num)) ennreal h0)  := sorry --non-trivial
lemma new_lemma_30873 (h0 : has_mem.mem (has_norm to_additive.value_type) has_emptyc.emptyc) : @is_domain.{0} (has_norm.{0} to_additive.value_type) (@finset.pi.empty.{1 0} Type ring.{0} (has_norm.{0} to_additive.value_type) h0)  := sorry --non-trivial
lemma new_lemma_30874 (h0 : not (topological_space (left_cancel_semigroup unsigned) -> false)) : @discrete_topology.{0} (left_cancel_semigroup.{0} unsigned) (@classical.by_contradiction'.{1} (topological_space.{0} (left_cancel_semigroup.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_30875 (h0 : functor.add_const (function.extfun (Type 1) group) pos) : @normalizer_condition.{1} (normed_comm_ring.{1} Type) (@function.extfun_app.{3 2} (Type 1) group.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) group.{1}) pos h0) (normed_comm_ring.{1} Type))  := sorry --non-trivial
lemma new_lemma_30876 (h0 : semiring (add_comm_monoid empty)) : is_noetherian_ring (add_comm_monoid empty) := sorry --non-trivial
lemma new_lemma_30877 (h0 : topological_space (finset (has_add linarith.comp))) : preconnected_space (finset (has_add linarith.comp)) := sorry --non-trivial
lemma new_lemma_30878 (h0 : group (has_neg (ring (has_neg (has_pos_part pos))))) : group.fg (has_neg (ring (has_neg (has_pos_part pos)))) := sorry --non-trivial
lemma new_lemma_30879 (h0 : function.extfun Type (functor.add_const (topological_space (mul_zero_class unsigned)))) : @t1_space.{0} (mul_zero_class.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (mul_zero_class.{0} unsigned)) unsigned (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (topological_space.{0} (mul_zero_class.{0} unsigned))) h0 unsigned))  := sorry --non-trivial
lemma new_lemma_30880 (h0 : not (finset (measure_theory.measure_space empty) -> false)) : finset.nonempty (classical.by_contradiction' h0) := sorry --non-trivial
lemma new_lemma_30881 (h0 : filter (add_cancel_monoid (comm_group name))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_30882 (h0 : filter (comm_group (has_neg_part name))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_30883 (h0 : functor.add_const (topological_space (canonically_linear_ordered_monoid pos)) (option (option pos))) : @path_connected_space.{0} (canonically_linear_ordered_monoid.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (canonically_linear_ordered_monoid.{0} pos)) (option.{0} (option.{0} pos)) h0)  := sorry --non-trivial
lemma new_lemma_30884 (h0 : topological_space (add_group (semiring (semiring empty)))) : t0_space (add_group (semiring (semiring empty))) := sorry --non-trivial
lemma new_lemma_30885 (h0 : monoid (distrib_lattice (with_bot to_additive.value_type))) : monoid.fg (distrib_lattice (with_bot to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_30886 (h0 : topological_space (has_one num)) : locally_compact_space (has_one num) := sorry --non-trivial
lemma new_lemma_30887 (h0 : not (function.extfun Type ring -> false)) : @is_domain.{0} (has_compl.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type ring.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type ring.{0}) h0) (has_compl.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_30888 (h0 : topological_space (measurable_space (semiring linarith.comp))) : normal_space (measurable_space (semiring linarith.comp)) := sorry --non-trivial
lemma new_lemma_30889 (h0 : functor.add_const (group (add_comm_monoid linarith.comp)) environment.implicit_infer_kind) : @group.fg.{0} (add_comm_monoid.{0} linarith.comp) (@functor.add_const.run.{0 0} (group.{0} (add_comm_monoid.{0} linarith.comp)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_30890 (h0 : finset (filter empty)) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_30891 (h0 : set (enat -> add_comm_semigroup char)) : set.separates_points h0 := sorry --non-trivial
lemma new_lemma_30892 (h0 : function.extfun Type topological_space) : @regular_space.{0} (simple_graph.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (simple_graph.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_30893 (h0 : cancel_comm_monoid_with_zero (has_neg (comm_group (comm_group (comm_group Type))))) : unique_factorization_monoid (has_neg (comm_group (comm_group (comm_group Type)))) := sorry --non-trivial
lemma new_lemma_30894 (h0 : topological_space (is_R_or_C congr_arg_kind)) : loc_path_connected_space (is_R_or_C congr_arg_kind) := sorry --non-trivial
lemma new_lemma_30895 (h0 : functor.add_const (topological_space (complete_distrib_lattice pos)) linarith.comp) : @irreducible_space.{0} (complete_distrib_lattice.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (complete_distrib_lattice.{0} pos)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_30896 (h0 : add_monoid (finset (has_neg pos))) : add_monoid.fg (finset (has_neg pos)) := sorry --non-trivial
lemma new_lemma_30897 (h0 : not (has_mem.mem (semiring fun_info) has_emptyc.emptyc -> false)) : @complete_lattice.is_Sup_finite_compact.{0} (semiring.{0} fun_info) (@finset.pi.empty.{1 0} Type complete_lattice.{0} (semiring.{0} fun_info) (@classical.by_contradiction'.{0} (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (semiring.{0} fun_info) (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))) h0))  := sorry --non-trivial
lemma new_lemma_30898 (h0 : ring (complete_distrib_lattice (comm_group (boolean_algebra Type)))) : strong_rank_condition (complete_distrib_lattice (comm_group (boolean_algebra Type))) := sorry --non-trivial
lemma new_lemma_30899 (h0 : complete_lattice (has_neg_part (comm_group (semigroup (semigroup name))))) : complete_lattice.is_Sup_finite_compact (has_neg_part (comm_group (semigroup (semigroup name)))) := sorry --non-trivial
lemma new_lemma_30900 (h0 : topological_space (has_to_string (option num))) : preconnected_space (has_to_string (option num)) := sorry --non-trivial
lemma new_lemma_30901 (h0 : topological_space (has_neg (finset pos))) : irreducible_space (has_neg (finset pos)) := sorry --non-trivial
lemma new_lemma_30902 (h0 h1 : multiset (mul_one_class char)) : multiset.disjoint h0 h1 := sorry --non-trivial
lemma new_lemma_30903 (h0 : functor.add_const (ring (normed_comm_ring linarith.comp)) pos) : @strong_rank_condition.{0} (normed_comm_ring.{0} linarith.comp) (@functor.add_const.run.{0 0} (ring.{0} (normed_comm_ring.{0} linarith.comp)) pos h0)  := sorry --non-trivial
lemma new_lemma_30904 (h0 : topological_space (filter num)) : irreducible_space (filter num) := sorry --non-trivial
lemma new_lemma_30905 (h0 : topological_space (measurable_space (has_norm num))) : locally_compact_space (measurable_space (has_norm num)) := sorry --non-trivial
lemma new_lemma_30906 (h0 : functor.add_const (group (complete_distrib_lattice pos)) (ring Type)) : @is_simple_group.{0} (complete_distrib_lattice.{0} pos) (@functor.add_const.run.{0 1} (group.{0} (complete_distrib_lattice.{0} pos)) (ring.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_30907 (h0 : uniform_space (boolean_algebra.core empty)) : complete_space (boolean_algebra.core empty) := sorry --non-trivial
lemma new_lemma_30908 (h0 : topological_space (ring environment.implicit_infer_kind)) : t1_space (ring environment.implicit_infer_kind) := sorry --non-trivial
lemma new_lemma_30909 (h0 : group (complete_distrib_lattice (has_add linarith.comp))) : is_simple_group (complete_distrib_lattice (has_add linarith.comp)) := sorry --non-trivial
lemma new_lemma_30910 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @totally_separated_space.{0} (normed_lattice_add_comm_group.{0} real) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (normed_lattice_add_comm_group.{0} real))  := sorry --non-trivial
lemma new_lemma_30911 (h0 : monoid (finset congr_arg_kind)) : monoid.fg (finset congr_arg_kind) := sorry --non-trivial
lemma new_lemma_30912 (h0 : prod (linear_ordered_field pos) (linear_ordered_field pos)) : id_rel h0 := sorry --non-trivial
lemma new_lemma_30913 (h0 : functor.add_const (functor.add_const (ordered_comm_monoid linarith.comp) pos) linarith.comp) : @has_exists_mul_of_le.{0} linarith.comp (@functor.add_const.run.{0 0} (ordered_comm_monoid.{0} linarith.comp) pos (@functor.add_const.run.{0 0} (functor.add_const.{0 0} (ordered_comm_monoid.{0} linarith.comp) pos) linarith.comp h0))  := sorry --non-trivial
lemma new_lemma_30914 (h0 : functor.add_const (function.extfun (Type 1) group) pos) : @group.fg.{1} (boolean_algebra.{1} Type) (@function.extfun_app.{3 2} (Type 1) group.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) group.{1}) pos h0) (boolean_algebra.{1} Type))  := sorry --non-trivial
lemma new_lemma_30915 (h0 : topological_space (ordered_ring (semiring (semiring num)))) : irreducible_space (ordered_ring (semiring (semiring num))) := sorry --non-trivial
lemma new_lemma_30916 (h0 : add_group (has_add (has_bot real))) : is_add_cyclic (has_add (has_bot real)) := sorry --non-trivial
lemma new_lemma_30917 (h0 : function.extfun Type (functor.add_const Prop)) : functor.add_const.run (function.extfun_app h0 (has_Inf pos)) := sorry --non-trivial
lemma new_lemma_30918 (h0 : topological_space (has_neg_part (has_add (has_to_string ennreal)))) : sequential_space (has_neg_part (has_add (has_to_string ennreal))) := sorry --non-trivial
lemma new_lemma_30919 (h0 : functor.add_const (add_monoid (has_add linarith.comp)) linarith.comp) : @add_monoid.fg.{0} (has_add.{0} linarith.comp) (@functor.add_const.run.{0 0} (add_monoid.{0} (has_add.{0} linarith.comp)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_30920 (h0 : filter (linear_ordered_add_comm_group (has_inv (random_gen (has_inv (random_gen to_additive.value_type)))))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_30921 (h0 : not (topological_space (random_gen unsigned) -> false)) : @preirreducible_space.{0} (random_gen.{0} unsigned) (@classical.by_contradiction'.{1} (topological_space.{0} (random_gen.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_30922 (h0 : functor.add_const (ring (has_Inf pos)) linarith.comp) : @strong_rank_condition.{0} (has_Inf.{0} pos) (@functor.add_const.run.{0 0} (ring.{0} (has_Inf.{0} pos)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_30923 (h0 : functor.add_const (function.extfun Type topological_space) Type) : @totally_separated_space.{0} (has_add.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type topological_space.{0}) Type h0) (has_add.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_30924 (h0 : group (comm_semigroup (has_pos_part Type))) : group.fg (comm_semigroup (has_pos_part Type)) := sorry --non-trivial
lemma new_lemma_30925 (h0 : group (preorder (semiring (semiring empty)))) : group.fg (preorder (semiring (semiring empty))) := sorry --non-trivial
lemma new_lemma_30926 (h0 : topological_space (generalized_boolean_algebra (sub_neg_monoid pos))) : t1_space (generalized_boolean_algebra (sub_neg_monoid pos)) := sorry --non-trivial
lemma new_lemma_30927 (h0 : group (boolean_algebra (ring (ring linarith.comp)))) : is_simple_group (boolean_algebra (ring (ring linarith.comp))) := sorry --non-trivial
lemma new_lemma_30928 (h0 : group (sub_neg_monoid num)) : normalizer_condition (sub_neg_monoid num) := sorry --non-trivial
lemma new_lemma_30929 (h1 : set (char -> ereal)) : set.separates_points h1 := sorry --non-trivial
lemma new_lemma_30930 (h0 : topological_space (generalized_boolean_algebra (has_add (has_add (boolean_algebra.core Type))))) : locally_compact_space (generalized_boolean_algebra (has_add (has_add (boolean_algebra.core Type)))) := sorry --non-trivial
lemma new_lemma_30931 (h0 : topological_space (complete_semilattice_Sup (random_gen linarith.comp_source))) : irreducible_space (complete_semilattice_Sup (random_gen linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_30932 (h0 : group (finset pos)) : is_cyclic (finset pos) := sorry --non-trivial
lemma new_lemma_30933 (h0 : topological_space (pseudo_metric_space (option ennreal))) : locally_compact_space (pseudo_metric_space (option ennreal)) := sorry --non-trivial
lemma new_lemma_30934 (h0 : functor.add_const (monoid (has_to_string Type)) Type) : @monoid.fg.{1} (has_to_string.{1} Type) (@functor.add_const.run.{1 1} (monoid.{1} (has_to_string.{1} Type)) Type h0)  := sorry --non-trivial
lemma new_lemma_30935 (h0 : topological_space (add_comm_monoid (comm_group name))) : loc_path_connected_space (add_comm_monoid (comm_group name)) := sorry --non-trivial
lemma new_lemma_30936 (h0 : complete_lattice (mul_one_class (mul_one_class linarith.ineq))) : complete_lattice.is_Sup_finite_compact (mul_one_class (mul_one_class linarith.ineq)) := sorry --non-trivial
lemma new_lemma_30937 (h0 : topological_space (option (semiring (semiring empty)))) : topological_space.separable_space (option (semiring (semiring empty))) := sorry --non-trivial
lemma new_lemma_30938 (h0 : function.extfun Type (functor.add_const Prop)) : functor.add_const.run (function.extfun_app h0 (semiring linarith.comp)) := sorry --non-trivial
lemma new_lemma_30939 (h0 : function.extfun Type cancel_comm_monoid_with_zero) : @unique_factorization_monoid.{0} (has_to_string.{0} unsigned) (@function.extfun_app.{2 1} Type cancel_comm_monoid_with_zero.{0} h0 (has_to_string.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_30940 (h0 : functor.add_const (cancel_comm_monoid_with_zero (add_cancel_monoid pos)) Type) : @unique_factorization_monoid.{0} (add_cancel_monoid.{0} pos) (@functor.add_const.run.{0 1} (cancel_comm_monoid_with_zero.{0} (add_cancel_monoid.{0} pos)) Type h0)  := sorry --non-trivial
lemma new_lemma_30941 (h0 : topological_space (semigroup (option ennreal))) : preconnected_space (semigroup (option ennreal)) := sorry --non-trivial
lemma new_lemma_30942 (h0 : set (linear_ordered_comm_group_with_zero string.iterator_imp)) : set.subsingleton h0 := sorry --non-trivial
lemma new_lemma_30943 (h0 : semiring (has_inner unsigned congr_arg_kind)) : is_noetherian_ring (has_inner unsigned congr_arg_kind) := sorry --non-trivial
lemma new_lemma_30944 (h0 : monoid (has_emptyc (random_gen linarith.ineq))) : monoid.fg (has_emptyc (random_gen linarith.ineq)) := sorry --non-trivial
lemma new_lemma_30945 (h0 : has_mem.mem (has_emptyc linarith.comp) has_emptyc.emptyc) : @irreducible_space.{0} (has_emptyc.{0} linarith.comp) (@finset.pi.empty.{1 0} Type topological_space.{0} (has_emptyc.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_30946 (h0 : topological_space (add_cancel_monoid (has_add linarith.comp))) : t1_space (add_cancel_monoid (has_add linarith.comp)) := sorry --non-trivial
lemma new_lemma_30947 (h0 : complete_lattice (non_assoc_semiring empty)) : is_compactly_generated (non_assoc_semiring empty) := sorry --non-trivial
lemma new_lemma_30948 (h1 : ring (distrib (has_ssubset (has_ssubset (random_gen (has_ssubset (has_ssubset char))))))) : is_domain (distrib (has_ssubset (has_ssubset (random_gen (has_ssubset (has_ssubset char)))))) := sorry --non-trivial
lemma new_lemma_30949 (h0 : functor.add_const (topological_space (finset unsigned)) environment.implicit_infer_kind) : @t1_space.{0} (finset.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (finset.{0} unsigned)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_30950 (h0 : functor.add_const (filter (has_nndist ennreal)) unsigned) : countable_Inter_filter (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_30951 (h0 : topological_space name) : preirreducible_space name := sorry --non-trivial
lemma new_lemma_30952 (h0 : function.extfun Type topological_space) : @t0_space.{0} (boolean_algebra.core.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (boolean_algebra.core.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_30953 (h0 : add_monoid (boolean_algebra (has_bot Type))) : add_monoid.fg (boolean_algebra (has_bot Type)) := sorry --non-trivial
lemma new_lemma_30954 (h0 : uniform_space (left_cancel_monoid (option unsigned))) : complete_space (left_cancel_monoid (option unsigned)) := sorry --non-trivial
lemma new_lemma_30955 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_add_cyclic.{0} (has_add.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type add_group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 add_group.{0}) (has_add.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_30956 (h0 : function.extfun Type topological_space) : @regular_space.{0} (normed_comm_ring.{0} ennreal) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (normed_comm_ring.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_30957 (h0 : set (has_ssubset (semigroup (mul_one_class string.iterator_imp)))) : set.finite h0 := sorry --non-trivial
lemma new_lemma_30958 (h0 : functor.add_const (function.extfun Type add_monoid) Type) : @add_monoid.fg.{0} (boolean_algebra.{0} linarith.comp) (@function.extfun_app.{2 1} Type add_monoid.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type add_monoid.{0}) Type h0) (boolean_algebra.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_30959 (h0 : fin has_zero.zero) : @preirreducible_space.{0} (canonically_linear_ordered_monoid.{0} real) (@function.extfun_app.{2 1} Type topological_space.{0} (@matrix.vec_empty.{1} (function.extfun.{2 1} Type topological_space.{0}) h0) (canonically_linear_ordered_monoid.{0} real))  := sorry --non-trivial
lemma new_lemma_30960 (h0 : functor.add_const (semiring (cancel_monoid unsigned)) congr_arg_kind) : @is_noetherian_ring.{0} (cancel_monoid.{0} unsigned) (@functor.add_const.run.{0 0} (semiring.{0} (cancel_monoid.{0} unsigned)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_30961 (h0 : function.extfun Type topological_space) : @locally_compact_space.{0} (has_neg.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_neg.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_30962 (h0 : function.extfun Type add_monoid) : @add_monoid.fg.{0} (complete_distrib_lattice.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type add_monoid.{0} h0 (complete_distrib_lattice.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_30963 (h0 : topological_space (has_emptyc (random_gen (has_inv to_additive.value_type)))) : path_connected_space (has_emptyc (random_gen (has_inv to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_30964 (h0 : ring (canonically_linear_ordered_monoid (has_neg Type))) : rank_condition (canonically_linear_ordered_monoid (has_neg Type)) := sorry --non-trivial
lemma new_lemma_30965 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @totally_separated_space.{0} (finset.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (finset.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_30966 (h0 : function.extfun Type group) : @is_cyclic.{0} (fintype.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type group.{0} h0 (fintype.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_30967 (h0 : topological_space (boolean_algebra environment.implicit_infer_kind)) : sequential_space (boolean_algebra environment.implicit_infer_kind) := sorry --non-trivial
lemma new_lemma_30968 (h0 : group (complete_semilattice_Sup (distrib_lattice string_imp))) : is_cyclic (complete_semilattice_Sup (distrib_lattice string_imp)) := sorry --non-trivial
lemma new_lemma_30969 (h0 : functor.add_const (topological_space (cancel_monoid Type)) (comm_group name)) : @path_connected_space.{1} (cancel_monoid.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (cancel_monoid.{1} Type)) (comm_group.{0} name) h0)  := sorry --non-trivial
lemma new_lemma_30970 (h0 : measurable_space to_additive.value_type) (h1 : measure_theory.measure to_additive.value_type) : measure_theory.is_probability_measure h1 := sorry --non-trivial
lemma new_lemma_30971 (h0 : function.extfun Type (functor.comp topological_space comm_group)) : @loc_path_connected_space.{0} (comm_group.{0} unsigned) (@functor.comp.run.{0 0 0} topological_space.{0} comm_group.{0} unsigned (@function.extfun_app.{2 1} Type (functor.comp.{0 0 0} topological_space.{0} comm_group.{0}) h0 unsigned))  := sorry --non-trivial
lemma new_lemma_30972 (h0 : char -> char) (h1 : char) : function.is_fixed_pt h0 h1 := sorry --non-trivial
lemma new_lemma_30973 (h0 : ring (normed_field (has_nnnorm (has_nnnorm (has_nnnorm linarith.comp_source))))) : rank_condition (normed_field (has_nnnorm (has_nnnorm (has_nnnorm linarith.comp_source)))) := sorry --non-trivial
lemma new_lemma_30974 (h0 : group (has_zero (finset name))) : is_cyclic (has_zero (finset name)) := sorry --non-trivial
lemma new_lemma_30975 (h0 : not (uniform_space (has_div char) -> false)) : @complete_space.{0} (has_div.{0} char) (@classical.by_contradiction'.{1} (uniform_space.{0} (has_div.{0} char)) h0)  := sorry --non-trivial
lemma new_lemma_30976 (h0 : not (uniform_space (div_inv_monoid to_additive.value_type) -> false)) : @complete_space.{0} (div_inv_monoid.{0} to_additive.value_type) (@classical.by_contradiction'.{1} (uniform_space.{0} (div_inv_monoid.{0} to_additive.value_type)) h0)  := sorry --non-trivial
lemma new_lemma_30977 (h0 : add_monoid (mul_zero_class environment.implicit_infer_kind)) : add_monoid.fg (mul_zero_class environment.implicit_infer_kind) := sorry --non-trivial
lemma new_lemma_30978 (h0 : cancel_comm_monoid_with_zero (ring Type)) : unique_factorization_monoid (ring Type) := sorry --non-trivial
lemma new_lemma_30979 (h0 : functor.add_const (topological_space (ring environment.implicit_infer_kind)) linarith.comp) : @totally_separated_space.{0} (ring.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (ring.{0} environment.implicit_infer_kind)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_30980 (h0 : group (comm_ring (has_nnnorm (has_nnnorm char)))) : group.fg (comm_ring (has_nnnorm (has_nnnorm char))) := sorry --non-trivial
lemma new_lemma_30981 (h0 : list (option empty)) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_30982 (h0 : complete_lattice (distrib (mul_one_class (has_ssubset enat)))) : complete_lattice.is_Sup_finite_compact (distrib (mul_one_class (has_ssubset enat))) := sorry --non-trivial
lemma new_lemma_30983 (h0 : functor.add_const (function.extfun Type ordered_comm_monoid) linarith.comp) : @has_exists_mul_of_le.{0} (canonically_ordered_comm_semiring.{0} pos) (@function.extfun_app.{2 1} Type ordered_comm_monoid.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type ordered_comm_monoid.{0}) linarith.comp h0) (canonically_ordered_comm_semiring.{0} pos))  := sorry --non-trivial
lemma new_lemma_30984 (h0 : function.extfun Type add_group) : @is_add_cyclic.{0} (measure_theory.measure_space.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type add_group.{0} h0 (measure_theory.measure_space.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_30985 (h0 : functor.comp topological_space add_comm_monoid name) : @irreducible_space.{0} (add_comm_monoid.{0} name) (@functor.comp.run.{0 0 0} topological_space.{0} add_comm_monoid.{0} name h0)  := sorry --non-trivial
lemma new_lemma_30986 (h0 : complete_lattice (has_norm (semiring (semiring unsigned)))) : complete_lattice.is_Sup_finite_compact (has_norm (semiring (semiring unsigned))) := sorry --non-trivial
lemma new_lemma_30987 (h0 : complete_lattice (canonically_linear_ordered_monoid (has_neg Type))) : complete_lattice.is_Sup_finite_compact (canonically_linear_ordered_monoid (has_neg Type)) := sorry --non-trivial
lemma new_lemma_30988 (h0 : complete_lattice (has_lt fun_info)) : complete_lattice.is_Sup_finite_compact (has_lt fun_info) := sorry --non-trivial
lemma new_lemma_30989 (h0 : functor.add_const (topological_space (finset pos)) Type) : @totally_separated_space.{0} (finset.{0} pos) (@functor.add_const.run.{0 1} (topological_space.{0} (finset.{0} pos)) Type h0)  := sorry --non-trivial
lemma new_lemma_30990 (h0 : functor.add_const (function.extfun (Type 1) add_group) name) : @is_add_cyclic.{1} (ordered_comm_monoid.{1} Type) (@function.extfun_app.{3 2} (Type 1) add_group.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) add_group.{1}) name h0) (ordered_comm_monoid.{1} Type))  := sorry --non-trivial
lemma new_lemma_30991 (h0 : group (has_top (random_gen char))) : is_cyclic (has_top (random_gen char)) := sorry --non-trivial
lemma new_lemma_30992 (h0 : ring (simple_graph (ring (has_Inf linarith.comp)))) : is_principal_ideal_ring (simple_graph (ring (has_Inf linarith.comp))) := sorry --non-trivial
lemma new_lemma_30993 (h0 : monoid (random_gen (random_gen (random_gen num)))) : monoid.fg (random_gen (random_gen (random_gen num))) := sorry --non-trivial
lemma new_lemma_30994 (h0 : group (generalized_boolean_algebra (ring linarith.comp))) : is_simple_group (generalized_boolean_algebra (ring linarith.comp)) := sorry --non-trivial
lemma new_lemma_30995 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : palindrome (function.extfun_app (function.extfun_app h0 list) (ordered_ring unsigned)) := sorry --non-trivial
lemma new_lemma_30996 (h0 : filter (canonically_ordered_monoid (has_Inf (has_pos_part linarith.comp)))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_30997 (h0 : topological_space string.iterator_imp) : t0_space string.iterator_imp := sorry --non-trivial
lemma new_lemma_30998 (h0 : functor.add_const (topological_space (finset environment.implicit_infer_kind)) name) : @regular_space.{0} (finset.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (finset.{0} environment.implicit_infer_kind)) name h0)  := sorry --non-trivial
lemma new_lemma_30999 (h0 : topological_space (monoid (option (option empty)))) : discrete_topology (monoid (option (option empty))) := sorry --non-trivial
lemma new_lemma_31000 (h0 : complete_lattice (ordered_comm_ring (has_nndist name))) : is_compactly_generated (ordered_comm_ring (has_nndist name)) := sorry --non-trivial
lemma new_lemma_31001 (h0 : not (ring (random_gen to_additive.value_type) -> false)) : @rank_condition.{0} (random_gen.{0} to_additive.value_type) (@classical.by_contradiction'.{1} (ring.{0} (random_gen.{0} to_additive.value_type)) h0)  := sorry --non-trivial
lemma new_lemma_31002 (h0 : functor.add_const (ring (semigroup pos)) (ring Type)) : @is_domain.{0} (semigroup.{0} pos) (@functor.add_const.run.{0 1} (ring.{0} (semigroup.{0} pos)) (ring.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_31003 (h0 : function.extfun Type uniform_space) : @complete_space.{0} (linear_ordered_field.{0} pos) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (linear_ordered_field.{0} pos))  := sorry --non-trivial
lemma new_lemma_31004 (h0 : add_group (normed_group (random_gen (random_gen linarith.comp_source)))) : is_add_cyclic (normed_group (random_gen (random_gen linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_31005 (h0 : function.extfun Type complete_lattice) : @is_atomistic.{0} (boolean_algebra.core.{0} ennreal) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (boolean_algebra.core.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_31006 (h0 : has_le (has_add (random_gen linarith.comp_source))) (h1 : bounded_order (has_add (random_gen linarith.comp_source))) : is_simple_order (has_add (random_gen linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_31007 (h0 : functor.comp list has_nndist pos) : palindrome (functor.comp.run h0) := sorry --non-trivial
lemma new_lemma_31008 (h0 : function.extfun nat fin) : @is_principal_ideal_ring.{0} (has_add.{0} linarith.comp) (@matrix.vec_empty.{0} (ring.{0} (has_add.{0} linarith.comp)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_31009 (h0 : topological_space (complete_distrib_lattice (has_pos_part linarith.comp))) : irreducible_space (complete_distrib_lattice (has_pos_part linarith.comp)) := sorry --non-trivial
lemma new_lemma_31010 (h0 : functor.add_const (topological_space (mul_zero_class Type)) pos) : @irreducible_space.{1} (mul_zero_class.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (mul_zero_class.{1} Type)) pos h0)  := sorry --non-trivial
lemma new_lemma_31011 (h0 : has_mem.mem complete_lattice has_emptyc.emptyc) : @is_atomistic.{0} empty (@function.extfun_app.{2 1} Type complete_lattice.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) complete_lattice.{0} h0) empty)  := sorry --non-trivial
lemma new_lemma_31012 (h0 : functor.add_const (finset (has_inter unsigned)) unsigned) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_31013 (h0 : ring (has_to_string (random_gen reducibility_hints))) : strong_rank_condition (has_to_string (random_gen reducibility_hints)) := sorry --non-trivial
lemma new_lemma_31014 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @t0_space.{0} (dlist.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (dlist.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_31015 (h0 : functor.add_const (function.extfun (Type 1) ring) linarith.comp) : @is_domain.{1} (boolean_algebra.{1} Type) (@function.extfun_app.{3 2} (Type 1) ring.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) ring.{1}) linarith.comp h0) (boolean_algebra.{1} Type))  := sorry --non-trivial
lemma new_lemma_31016 (h0 : ring (plift unsigned)) : strong_rank_condition (plift unsigned) := sorry --non-trivial
lemma new_lemma_31017 (h1 : add_group (semi_normed_comm_ring string_imp)) : is_add_cyclic (semi_normed_comm_ring string_imp) := sorry --non-trivial
lemma new_lemma_31018 (h0 : nat) (h1 : has_mul (array h0 num)) (h2 : not (array h0 num -> false)) : is_regular (classical.by_contradiction' h2) := sorry --non-trivial
lemma new_lemma_31019 (h0 : function.extfun Type group) : @is_cyclic.{0} (has_compl.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type group.{0} h0 (has_compl.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_31020 (h0 : function.extfun Type group) : @is_cyclic.{0} (finset.{0} ennreal) (@function.extfun_app.{2 1} Type group.{0} h0 (finset.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_31021 (h0 : group (semiring (has_norm (random_gen (has_norm num))))) : normalizer_condition (semiring (has_norm (random_gen (has_norm num)))) := sorry --non-trivial
lemma new_lemma_31022 (h0 : ring (has_div complex)) : strong_rank_condition (has_div complex) := sorry --non-trivial
lemma new_lemma_31023 (h0 : not (function.extfun Type complete_lattice -> false)) : @complete_lattice.is_Sup_finite_compact.{0} to_additive.value_type (@function.extfun_app.{2 1} Type complete_lattice.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type complete_lattice.{0}) h0) to_additive.value_type)  := sorry --non-trivial
lemma new_lemma_31024 (h0 : add_group (semigroup num)) : is_add_cyclic (semigroup num) := sorry --non-trivial
lemma new_lemma_31025 (h0 : functor.add_const (monoid (add_comm_monoid pos)) environment.implicit_infer_kind) : @monoid.fg.{0} (add_comm_monoid.{0} pos) (@functor.add_const.run.{0 0} (monoid.{0} (add_comm_monoid.{0} pos)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_31026 (h0 : uniform_space (boolean_algebra (has_neg pos))) : separated_space (boolean_algebra (has_neg pos)) := sorry --non-trivial
lemma new_lemma_31027 (h0 : topological_space (dlist (has_nnnorm (has_nnnorm linarith.ineq)))) : t0_space (dlist (has_nnnorm (has_nnnorm linarith.ineq))) := sorry --non-trivial
lemma new_lemma_31028 (h0 : monoid (finset (has_to_string pos))) : monoid.fg (finset (has_to_string pos)) := sorry --non-trivial
lemma new_lemma_31029 (h0 : group (has_to_string unsigned)) : is_simple_group (has_to_string unsigned) := sorry --non-trivial
lemma new_lemma_31030 (h0 : list (has_to_string (has_neg pos))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_31031 (h0 : ring (complete_distrib_lattice linarith.comp)) : rank_condition (complete_distrib_lattice linarith.comp) := sorry --non-trivial
lemma new_lemma_31032 (h0 : not (topological_space (has_emptyc to_additive.value_type) -> false)) : @totally_separated_space.{0} (has_emptyc.{0} to_additive.value_type) (@classical.by_contradiction'.{1} (topological_space.{0} (has_emptyc.{0} to_additive.value_type)) h0)  := sorry --non-trivial
lemma new_lemma_31033 (h0 : ring (has_nnnorm (has_le (pseudo_metric_space std_gen)))) : rank_condition (has_nnnorm (has_le (pseudo_metric_space std_gen))) := sorry --non-trivial
lemma new_lemma_31034 (h8 : complete_lattice (comm_ring (metric_space to_additive.value_type))) : complete_lattice.is_Sup_finite_compact (comm_ring (metric_space to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_31035 (h0 : add_group (has_bot (has_Inf (has_add Type)))) : is_add_cyclic (has_bot (has_Inf (has_add Type))) := sorry --non-trivial
lemma new_lemma_31036 (h0 : monoid (has_union (has_norm (has_norm empty)))) : monoid.fg (has_union (has_norm (has_norm empty))) := sorry --non-trivial
lemma new_lemma_31037 (h0 : functor.add_const (uniform_space (cancel_monoid environment.implicit_infer_kind)) linarith.comp) : @separated_space.{0} (cancel_monoid.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (uniform_space.{0} (cancel_monoid.{0} environment.implicit_infer_kind)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_31038 (h0 : prod (has_sub (has_top unsigned)) (has_sub (has_top unsigned))) : id_rel h0 := sorry --non-trivial
lemma new_lemma_31039 (h0 : functor.add_const (group (has_add pos)) pos) : @is_simple_group.{0} (has_add.{0} pos) (@functor.add_const.run.{0 0} (group.{0} (has_add.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_31040 (h0 : topological_space (linear_ordered_semiring (semiring (semiring unsigned)))) : path_connected_space (linear_ordered_semiring (semiring (semiring unsigned))) := sorry --non-trivial
lemma new_lemma_31041 (h1 : add_group (normed_group (has_ssubset to_additive.value_type))) : is_add_cyclic (normed_group (has_ssubset to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_31042 (h0 : ordered_comm_monoid (has_neg environment.implicit_infer_kind)) : has_exists_mul_of_le (has_neg environment.implicit_infer_kind) := sorry --non-trivial
lemma new_lemma_31043 (h0 : add_monoid (has_add (has_bot real))) : add_monoid.fg (has_add (has_bot real)) := sorry --non-trivial
lemma new_lemma_31044 (h0 : topological_space (monoid num)) : loc_path_connected_space (monoid num) := sorry --non-trivial
lemma new_lemma_31045 (h1 : complete_lattice (id string_imp)) : is_atomistic (id string_imp) := sorry --non-trivial
lemma new_lemma_31046 (h0 : topological_space (has_union (has_union (has_union empty)))) : irreducible_space (has_union (has_union (has_union empty))) := sorry --non-trivial
lemma new_lemma_31047 (h0 : topological_space (add_comm_monoid unsigned)) : loc_path_connected_space (add_comm_monoid unsigned) := sorry --non-trivial
lemma new_lemma_31048 (h0 : function.extfun Type complete_lattice) : @is_atomistic.{0} (complete_distrib_lattice.{0} name) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (complete_distrib_lattice.{0} name))  := sorry --non-trivial
lemma new_lemma_31049 (h0 : fin has_zero.zero) : @t1_space.{0} (has_bot.{0} real) (@matrix.vec_empty.{0} (topological_space.{0} (has_bot.{0} real)) h0)  := sorry --non-trivial
lemma new_lemma_31050 (h0 : topological_space (non_assoc_semiring (semiring congr_arg_kind))) : totally_disconnected_space (non_assoc_semiring (semiring congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_31051 (h0 : group (normed_group (has_nnnorm linarith.comp_source))) : is_cyclic (normed_group (has_nnnorm linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_31052 (h0 : function.extfun (finset Type) (has_mem.mem (metric_space linarith.comp))) : @path_connected_space.{0} (metric_space.{0} linarith.comp) (@finset.pi.empty.{1 0} Type topological_space.{0} (metric_space.{0} linarith.comp) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (metric_space.{0} linarith.comp)) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_31053 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @group.fg.{1} (canonically_ordered_monoid.{1} Type) (@function.extfun_app.{3 2} (Type 1) group.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 group.{1}) (canonically_ordered_monoid.{1} Type))  := sorry --non-trivial
lemma new_lemma_31054 (h0 : functor.add_const (ring (add_cancel_monoid name)) environment.implicit_infer_kind) : @is_domain.{0} (add_cancel_monoid.{0} name) (@functor.add_const.run.{0 0} (ring.{0} (add_cancel_monoid.{0} name)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_31055 (h0 : functor.add_const (ordered_add_comm_monoid (option pos)) unsigned) : @archimedean.{0} (option.{0} pos) (@functor.add_const.run.{0 0} (ordered_add_comm_monoid.{0} (option.{0} pos)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_31056 (h0 : topological_space (add_semigroup (option (option unsigned)))) : loc_path_connected_space (add_semigroup (option (option unsigned))) := sorry --non-trivial
lemma new_lemma_31057 (h0 : topological_space (boolean_algebra (semigroup linarith.comp))) : t1_space (boolean_algebra (semigroup linarith.comp)) := sorry --non-trivial
lemma new_lemma_31058 (h0 : complete_lattice (measurable_space (has_inv to_additive.value_type))) : complete_lattice.is_Sup_finite_compact (measurable_space (has_inv to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_31059 (h0 : topological_space (mul_one_class to_additive.value_type)) (h1 : list (preorder (mul_one_class to_additive.value_type))) (h2 : nat) (h3 : has_lt.lt h2 (list.length h1)) : @order_closed_topology.{0} (mul_one_class.{0} to_additive.value_type) h0 (@list.nth_le.{0} (preorder.{0} (mul_one_class.{0} to_additive.value_type)) h1 h2 h3)  := sorry --non-trivial
lemma new_lemma_31060 (h0 : function.extfun Type (functor.add_const (topological_space (add_left_cancel_semigroup unsigned)))) : @path_connected_space.{0} (add_left_cancel_semigroup.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (add_left_cancel_semigroup.{0} unsigned)) empty (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (topological_space.{0} (add_left_cancel_semigroup.{0} unsigned))) h0 empty))  := sorry --non-trivial
lemma new_lemma_31061 (h0 : topological_space (has_to_string (semigroup name))) : preconnected_space (has_to_string (semigroup name)) := sorry --non-trivial
lemma new_lemma_31062 (h0 : functor.add_const (cancel_comm_monoid_with_zero (option num)) num) : @unique_factorization_monoid.{0} (option.{0} num) (@functor.add_const.run.{0 0} (cancel_comm_monoid_with_zero.{0} (option.{0} num)) num h0)  := sorry --non-trivial
lemma new_lemma_31063 (h0 : topological_space (denumerable (has_inter linarith.ineq))) : path_connected_space (denumerable (has_inter linarith.ineq)) := sorry --non-trivial
lemma new_lemma_31064 (h0 : fin has_zero.zero) : @rank_condition.{0} (boolean_algebra.{0} pos) (@function.extfun_app.{2 1} Type ring.{0} (@matrix.vec_empty.{1} (function.extfun.{2 1} Type ring.{0}) h0) (boolean_algebra.{0} pos))  := sorry --non-trivial
lemma new_lemma_31065 (h0 : has_neg (has_compl (has_lt linarith.ineq))) (h1 : measurable_space (has_compl (has_lt linarith.ineq))) : has_measurable_neg (has_compl (has_lt linarith.ineq)) := sorry --non-trivial
lemma new_lemma_31066 (h0 : topological_space (linear_ordered_comm_ring (random_gen linarith.comp_source))) : locally_compact_space (linear_ordered_comm_ring (random_gen linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_31067 (h0 : function.extfun Type complete_lattice) : @is_compactly_generated.{0} (cancel_monoid.{0} pos) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (cancel_monoid.{0} pos))  := sorry --non-trivial
lemma new_lemma_31068 (h0 : topological_space (add_monoid (random_gen string_imp))) : t0_space (add_monoid (random_gen string_imp)) := sorry --non-trivial
lemma new_lemma_31069 (h0 : functor.add_const (semiring (preorder empty)) empty) : @is_noetherian_ring.{0} (preorder.{0} empty) (@functor.add_const.run.{0 0} (semiring.{0} (preorder.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_31070 (h0 : functor.add_const (topological_space (ordered_ring num)) empty) : @totally_disconnected_space.{0} (ordered_ring.{0} num) (@functor.add_const.run.{0 0} (topological_space.{0} (ordered_ring.{0} num)) empty h0)  := sorry --non-trivial
lemma new_lemma_31071 (h0 : filter (add_cancel_comm_monoid empty) -> Prop) (h1 : Exists (fun (x : filter (add_cancel_comm_monoid empty)), h0 x)) : filter.ne_bot (classical.some h1) := sorry --non-trivial
lemma new_lemma_31072 (h0 : function.extfun Type filter) : filter.ne_bot (function.extfun_app h0 (omega_complete_partial_order pos)) := sorry --non-trivial
lemma new_lemma_31073 (h0 : not (topological_space (complete_semilattice_Sup linarith.ineq) -> false)) : @t0_space.{0} (complete_semilattice_Sup.{0} linarith.ineq) (@classical.by_contradiction'.{1} (topological_space.{0} (complete_semilattice_Sup.{0} linarith.ineq)) h0)  := sorry --non-trivial
lemma new_lemma_31074 (h0 : functor.add_const (topological_space (semigroup Type)) linarith.comp) : @topological_space.separable_space.{1} (semigroup.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (semigroup.{1} Type)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_31075 (h0 : add_group (add_right_cancel_monoid (semiring (semiring unsigned)))) : is_add_cyclic (add_right_cancel_monoid (semiring (semiring unsigned))) := sorry --non-trivial
lemma new_lemma_31076 (h0 : function.extfun Type topological_space) : @normal_space.{0} (pseudo_metric_space.{0} (option.{0} congr_arg_kind)) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (pseudo_metric_space.{0} (option.{0} congr_arg_kind)))  := sorry --non-trivial
lemma new_lemma_31077 (h0 : functor.add_const (function.extfun Type topological_space) real) : @discrete_topology.{0} (comm_semigroup.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) real h0) (comm_semigroup.{0} name))  := sorry --non-trivial
lemma new_lemma_31078 (h0 : ring (has_bot (option unsigned))) : rank_condition (has_bot (option unsigned)) := sorry --non-trivial
lemma new_lemma_31079 (h2 : function.extfun Type list) : list.nodup (function.extfun_app h2 (measurable_space string_imp)) := sorry --non-trivial
lemma new_lemma_31080 (h0 : ring (plift (semiring congr_arg_kind))) : strong_rank_condition (plift (semiring congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_31081 (h0 : has_mem.mem empty has_emptyc.emptyc) : @is_add_cyclic.{0} empty (@finset.pi.empty.{1 0} Type add_group.{0} empty h0)  := sorry --non-trivial
lemma new_lemma_31082 (h1 : measurable_space linarith.ineq -> measurable_space linarith.ineq) (h2 : list (measurable_space linarith.ineq)) : list.nodup (list.modify_last h1 h2) := sorry --non-trivial
lemma new_lemma_31083 (h0 : topological_space (linear_ordered_comm_group congr_arg_kind)) : irreducible_space (linear_ordered_comm_group congr_arg_kind) := sorry --non-trivial
lemma new_lemma_31084 (h0 : function.extfun (finset (Type -> Type)) (has_mem.mem uniform_space)) : @complete_space.{0} (with_bot.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type uniform_space.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) uniform_space.{0} (@function.extfun_app.{2 0} (finset.{1} (Type → Type)) (@has_mem.mem.{1 1} (Type → Type) (finset.{1} (Type → Type)) (@finset.has_mem.{1} (Type → Type)) uniform_space.{0}) h0 (@has_emptyc.emptyc.{1} (finset.{1} (Type → Type)) (@finset.has_emptyc.{1} (Type → Type))))) (with_bot.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_31085 (h0 : mul_one_class (simple_graph fun_info)) (h1 : add_group (submonoid (simple_graph fun_info)) -> Prop) (h2 : Exists (fun (x : add_group (submonoid (simple_graph fun_info))), h1 x)) : @is_add_cyclic.{0} (@submonoid.{0} (simple_graph.{0} fun_info) h0) (@classical.some.{1} (add_group.{0} (@submonoid.{0} (simple_graph.{0} fun_info) h0)) h1 h2)  := sorry --non-trivial
lemma new_lemma_31086 (h0 : not (ring (semi_normed_ring string_imp) -> false)) : @rank_condition.{0} (semi_normed_ring.{0} string_imp) (@classical.by_contradiction'.{1} (ring.{0} (semi_normed_ring.{0} string_imp)) h0)  := sorry --non-trivial
lemma new_lemma_31087 (h0 : function.extfun Type topological_space) : @totally_disconnected_space.{0} (measure_theory.measure_space.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (measure_theory.measure_space.{0} empty))  := sorry --non-trivial
lemma new_lemma_31088 (h0 : functor.add_const (finset (semigroup linarith.comp)) (ring (ring (has_neg Type)))) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_31089 (h0 : uniform_space (generalized_boolean_algebra (finset pos))) : separated_space (generalized_boolean_algebra (finset pos)) := sorry --non-trivial
lemma new_lemma_31090 (h0 : Prop) : list.tfae (list.ret h0) := sorry --non-trivial
lemma new_lemma_31091 (h0 : ring (topological_space (conditionally_complete_linear_order char))) : is_domain (topological_space (conditionally_complete_linear_order char)) := sorry --non-trivial
lemma new_lemma_31092 (h0 : has_mem.mem add_group has_emptyc.emptyc) : @is_add_cyclic.{0} (linear_ordered_semiring.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type add_group.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) add_group.{0} h0) (linear_ordered_semiring.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_31093 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @rank_condition.{0} (canonically_ordered_add_monoid.{0} unsigned) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (canonically_ordered_add_monoid.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_31094 (h0 : functor.add_const (topological_space (add_comm_monoid name)) name) : @sequential_space.{0} (add_comm_monoid.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (add_comm_monoid.{0} name)) name h0)  := sorry --non-trivial
lemma new_lemma_31095 (h0 : functor.add_const (topological_space (has_Inf Type)) pos) : @t1_space.{1} (has_Inf.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (has_Inf.{1} Type)) pos h0)  := sorry --non-trivial
lemma new_lemma_31096 (h0 : functor.add_const (topological_space (canonically_linear_ordered_monoid ennreal)) num) : @normal_space.{0} (canonically_linear_ordered_monoid.{0} ennreal) (@functor.add_const.run.{0 0} (topological_space.{0} (canonically_linear_ordered_monoid.{0} ennreal)) num h0)  := sorry --non-trivial
lemma new_lemma_31097 (h1 : function.extfun Type complete_lattice) : @is_atomistic.{0} (semiring.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type complete_lattice.{0} h1 (semiring.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_31098 (h0 : topological_space (simple_graph linarith.ineq)) (h1 : preorder (simple_graph linarith.ineq)) : order_closed_topology (simple_graph linarith.ineq) := sorry --non-trivial
lemma new_lemma_31099 (h0 : ring (denumerable (random_gen reducibility_hints))) : strong_rank_condition (denumerable (random_gen reducibility_hints)) := sorry --non-trivial
lemma new_lemma_31100 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @strong_rank_condition.{0} (linear_ordered_comm_monoid_with_zero.{0} empty) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (linear_ordered_comm_monoid_with_zero.{0} empty))  := sorry --non-trivial
lemma new_lemma_31101 (h0 : functor.comp cancel_comm_monoid_with_zero complete_distrib_lattice Type) : @unique_factorization_monoid.{1} (complete_distrib_lattice.{1} Type) (@functor.comp.run.{1 1 1} cancel_comm_monoid_with_zero.{1} complete_distrib_lattice.{1} Type h0)  := sorry --non-trivial
lemma new_lemma_31102 (h0 : add_group (has_zero (option (option ennreal)))) : is_add_cyclic (has_zero (option (option ennreal))) := sorry --non-trivial
lemma new_lemma_31103 (h0 : add_group (has_norm (random_gen (random_gen (random_gen string_imp))))) : is_add_cyclic (has_norm (random_gen (random_gen (random_gen string_imp)))) := sorry --non-trivial
lemma new_lemma_31104 (h0 : ring (complete_semilattice_Sup congr_arg_kind)) : strong_rank_condition (complete_semilattice_Sup congr_arg_kind) := sorry --non-trivial
lemma new_lemma_31105 (h0 : measurable_space (random_gen linarith.comp)) (h1 : function.extfun (finset (Type -> Type)) (has_mem.mem has_add)) : @has_measurable_add.{0} (random_gen.{0} linarith.comp) h0 (@function.extfun_app.{2 1} Type has_add.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) has_add.{0} (@function.extfun_app.{2 0} (finset.{1} (Type → Type)) (@has_mem.mem.{1 1} (Type → Type) (finset.{1} (Type → Type)) (@finset.has_mem.{1} (Type → Type)) has_add.{0}) h1 (@has_emptyc.emptyc.{1} (finset.{1} (Type → Type)) (@finset.has_emptyc.{1} (Type → Type))))) (random_gen.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_31106 (h0 : std_gen -> std_gen -> Prop) : pairwise h0 := sorry --non-trivial
lemma new_lemma_31107 (h0 : add_group (simple_graph (normed_field reducibility_hints))) : is_add_cyclic (simple_graph (normed_field reducibility_hints)) := sorry --non-trivial
lemma new_lemma_31108 (h0 : functor.add_const (semiring (normed_comm_ring pos)) pos) : @is_noetherian_ring.{0} (normed_comm_ring.{0} pos) (@functor.add_const.run.{0 0} (semiring.{0} (normed_comm_ring.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_31109 (h0 : measurable_space (omega_complete_partial_order empty)) (h1 : function.extfun (Type -> Type) (function.extfun Type)) : @has_measurable_mul.{0} (omega_complete_partial_order.{0} empty) h0 (@function.extfun_app.{2 1} Type has_mul.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h1 has_mul.{0}) (omega_complete_partial_order.{0} empty))  := sorry --non-trivial
lemma new_lemma_31110 (h0 : ring (boolean_algebra.core (add_comm_monoid Type))) : strong_rank_condition (boolean_algebra.core (add_comm_monoid Type)) := sorry --non-trivial
lemma new_lemma_31111 (h0 : has_lt (nondiscrete_normed_field (nondiscrete_normed_field string.iterator_imp))) : no_max_order (nondiscrete_normed_field (nondiscrete_normed_field string.iterator_imp)) := sorry --non-trivial
lemma new_lemma_31112 (h0 : group (has_pos_part (finset name))) : normalizer_condition (has_pos_part (finset name)) := sorry --non-trivial
lemma new_lemma_31113 (h0 : topological_space (has_one unsigned)) : irreducible_space (has_one unsigned) := sorry --non-trivial
lemma new_lemma_31114 (h0 : topological_space (complete_semilattice_Sup (has_emptyc congr_arg_kind))) : irreducible_space (complete_semilattice_Sup (has_emptyc congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_31115 (h0 : semiring (complete_distrib_lattice (has_add (has_bot real)))) : is_noetherian_ring (complete_distrib_lattice (has_add (has_bot real))) := sorry --non-trivial
lemma new_lemma_31116 (h0 : topological_space (measurable_space (has_top num))) : preirreducible_space (measurable_space (has_top num)) := sorry --non-trivial
lemma new_lemma_31117 (h0 : list (ordered_comm_monoid (has_add (ring pos)))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_31118 (h0 : function.extfun (set empty) (fun (x : set empty), Prop)) : is_countably_spanning (function.extfun_app h0) := sorry --non-trivial
lemma new_lemma_31119 (h0 : functor.add_const (group (boolean_algebra pos)) (ring environment.implicit_infer_kind)) : @group.fg.{0} (boolean_algebra.{0} pos) (@functor.add_const.run.{0 0} (group.{0} (boolean_algebra.{0} pos)) (ring.{0} environment.implicit_infer_kind) h0)  := sorry --non-trivial
lemma new_lemma_31120 (h1 : topological_space (has_compl enat)) (h2 : preorder (has_compl enat)) : order_closed_topology (has_compl enat) := sorry --non-trivial
lemma new_lemma_31121 (h0 : list (has_neg Type)) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_31122 (h0 : function.extfun Type finset) : finset.nonempty (function.extfun_app h0 (simple_graph congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_31123 (h0 : topological_space (has_top (semiring congr_arg_kind))) : irreducible_space (has_top (semiring congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_31124 (h0 : ring (boolean_algebra (option num))) : is_domain (boolean_algebra (option num)) := sorry --non-trivial
lemma new_lemma_31125 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @monoid.fg.{0} (normed_comm_ring.{0} ennreal) (@function.extfun_app.{2 1} Type monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 monoid.{0}) (normed_comm_ring.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_31126 (h0 : ring (has_append (has_ssubset (random_gen char)))) : strong_rank_condition (has_append (has_ssubset (random_gen char))) := sorry --non-trivial
lemma new_lemma_31127 (h0 : function.extfun (Type 1) ring) : @rank_condition.{1} (has_nndist.{1} Type) (@function.extfun_app.{3 2} (Type 1) ring.{1} h0 (has_nndist.{1} Type))  := sorry --non-trivial
lemma new_lemma_31128 (h0 : uniform_space (has_append linarith.comp_source)) : complete_space (has_append linarith.comp_source) := sorry --non-trivial
lemma new_lemma_31129 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @normalizer_condition.{0} (pseudo_metric_space.{0} unsigned) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (pseudo_metric_space.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_31130 (h0 : semiring (with_bot (semiring congr_arg_kind))) : is_noetherian_ring (with_bot (semiring congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_31131 (h0 : functor.add_const (topological_space (has_inter empty)) empty) : @totally_separated_space.{0} (has_inter.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (has_inter.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_31132 (h0 : topological_space (add_comm_monoid (rel Type name))) : topological_space.separable_space (add_comm_monoid (rel Type name)) := sorry --non-trivial
lemma new_lemma_31133 (h0 : ordered_add_comm_monoid (generalized_boolean_algebra Type)) : archimedean (generalized_boolean_algebra Type) := sorry --non-trivial
lemma new_lemma_31134 (h0 : ring (has_ssubset (has_inv to_additive.value_type))) : strong_rank_condition (has_ssubset (has_inv to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_31135 (h0 : function.extfun Type group) : @normalizer_condition.{0} (free_add_monoid.{0} (ordered_ring.{0} empty)) (@function.extfun_app.{2 1} Type group.{0} h0 (free_add_monoid.{0} (ordered_ring.{0} empty)))  := sorry --non-trivial
lemma new_lemma_31136 (h0 : uniform_space (option (semiring empty))) : complete_space (option (semiring empty)) := sorry --non-trivial
lemma new_lemma_31137 (h0 : group (semigroup pos)) : is_simple_group (semigroup pos) := sorry --non-trivial
lemma new_lemma_31138 (h0 : add_monoid (generalized_boolean_algebra (has_add (boolean_algebra.core (has_add Type))))) : add_monoid.fg (generalized_boolean_algebra (has_add (boolean_algebra.core (has_add Type)))) := sorry --non-trivial
lemma new_lemma_31139 (h0 : complete_lattice (random_gen (random_gen string.iterator_imp))) : complete_lattice.is_Sup_finite_compact (random_gen (random_gen string.iterator_imp)) := sorry --non-trivial
lemma new_lemma_31140 (h0 : topological_space (topological_space (random_gen (random_gen string_imp)))) : path_connected_space (topological_space (random_gen (random_gen string_imp))) := sorry --non-trivial
lemma new_lemma_31141 (h0 : topological_space (distrib (has_nnnorm (has_nnnorm (has_nnnorm fun_info))))) : totally_disconnected_space (distrib (has_nnnorm (has_nnnorm (has_nnnorm fun_info)))) := sorry --non-trivial
lemma new_lemma_31142 (h0 : topological_space (cancel_monoid (option empty))) : locally_compact_space (cancel_monoid (option empty)) := sorry --non-trivial
lemma new_lemma_31143 (h0 : group (with_one (random_gen (has_inv (has_inv to_additive.value_type))))) : normalizer_condition (with_one (random_gen (has_inv (has_inv to_additive.value_type)))) := sorry --non-trivial
lemma new_lemma_31144 (h0 : functor.add_const (ordered_comm_monoid (add_comm_monoid Type)) linarith.comp) : @has_exists_mul_of_le.{1} (add_comm_monoid.{1} Type) (@functor.add_const.run.{1 0} (ordered_comm_monoid.{1} (add_comm_monoid.{1} Type)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_31145 (h0 : set (string.iterator_imp -> mul_one_class char)) : set.separates_points h0 := sorry --non-trivial
lemma new_lemma_31146 (h0 : list (random_gen (has_top (has_nnnorm fun_info)))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_31147 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @loc_path_connected_space.{0} (monoid.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (monoid.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_31148 (h0 : not (topological_space (has_ssubset fun_info) -> false)) : @t0_space.{0} (has_ssubset.{0} fun_info) (@classical.by_contradiction'.{1} (topological_space.{0} (has_ssubset.{0} fun_info)) h0)  := sorry --non-trivial
lemma new_lemma_31149 (h0 : functor.add_const (topological_space (has_neg pos)) (ring (has_neg linarith.comp))) : @irreducible_space.{0} (has_neg.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (has_neg.{0} pos)) (ring.{0} (has_neg.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_31150 (h0 : functor.add_const (topological_space (free_add_monoid congr_arg_kind)) empty) : @path_connected_space.{0} (free_add_monoid.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (free_add_monoid.{0} congr_arg_kind)) empty h0)  := sorry --non-trivial
lemma new_lemma_31151 (h0 : functor.add_const (add_group (boolean_algebra.core name)) pos) : @is_add_cyclic.{0} (boolean_algebra.core.{0} name) (@functor.add_const.run.{0 0} (add_group.{0} (boolean_algebra.core.{0} name)) pos h0)  := sorry --non-trivial
lemma new_lemma_31152 (h0 : complete_lattice (has_norm (has_top linarith.comp_source))) : complete_lattice.is_Sup_finite_compact (has_norm (has_top linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_31153 (h0 : ring (random_gen (mul_one_class (mul_one_class (mul_one_class linarith.comp_source))))) : is_domain (random_gen (mul_one_class (mul_one_class (mul_one_class linarith.comp_source)))) := sorry --non-trivial
lemma new_lemma_31154 (h0 : functor.add_const (uniform_space (normed_comm_ring name)) (option (mul_zero_class unsigned))) : @separated_space.{0} (normed_comm_ring.{0} name) (@functor.add_const.run.{0 0} (uniform_space.{0} (normed_comm_ring.{0} name)) (option.{0} (mul_zero_class.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_31155 (h0 : functor.add_const (topological_space (ordered_ring empty)) empty) : @preirreducible_space.{0} (ordered_ring.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (ordered_ring.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_31156 (h0 : fin has_zero.zero) : @irreducible_space.{1} (canonically_linear_ordered_monoid.{1} Type) (@matrix.vec_empty.{1} (topological_space.{1} (canonically_linear_ordered_monoid.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_31157 (h0 : uniform_space (has_zero pos)) : complete_space (has_zero pos) := sorry --non-trivial
lemma new_lemma_31158 (h0 : functor.add_const (topological_space (generalized_boolean_algebra linarith.comp)) pos) : @normal_space.{0} (generalized_boolean_algebra.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (generalized_boolean_algebra.{0} linarith.comp)) pos h0)  := sorry --non-trivial
lemma new_lemma_31159 (h0 : group (has_Inf (finset Type))) : is_cyclic (has_Inf (finset Type)) := sorry --non-trivial
lemma new_lemma_31160 (h0 : add_group (with_one (has_norm congr_arg_kind))) : is_add_cyclic (with_one (has_norm congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_31161 (h0 : topological_space (finset linarith.comp)) : path_connected_space (finset linarith.comp) := sorry --non-trivial
lemma new_lemma_31162 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @strong_rank_condition.{0} (has_nndist.{0} pos) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (has_nndist.{0} pos))  := sorry --non-trivial
lemma new_lemma_31163 (h0 : uniform_space (has_one fun_info)) : complete_space (has_one fun_info) := sorry --non-trivial
lemma new_lemma_31164 (h0 : topological_space (linear_ordered_comm_ring (has_top empty))) : irreducible_space (linear_ordered_comm_ring (has_top empty)) := sorry --non-trivial
lemma new_lemma_31165 (h0 : topological_space (distrib linarith.ineq)) : t0_space (distrib linarith.ineq) := sorry --non-trivial
lemma new_lemma_31166 (h0 : functor.add_const (function.extfun Type topological_space) (ring Type)) : @sequential_space.{0} (has_to_string.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type topological_space.{0}) (ring.{1} Type) h0) (has_to_string.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_31167 (h0 : functor.comp complete_lattice has_nndist pos) : @is_compactly_generated.{0} (has_nndist.{0} pos) (@functor.comp.run.{0 0 0} complete_lattice.{0} has_nndist.{0} pos h0)  := sorry --non-trivial
lemma new_lemma_31168 (h0 : function.extfun Type topological_space) : @discrete_topology.{0} (cancel_monoid.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (cancel_monoid.{0} name))  := sorry --non-trivial
lemma new_lemma_31169 (h0 : topological_space (simple_graph linarith.comp_source)) (h1 : add_group (simple_graph linarith.comp_source)) : topological_add_group (simple_graph linarith.comp_source) := sorry --non-trivial
lemma new_lemma_31170 (h0 : functor.add_const (list (free_add_monoid unsigned)) congr_arg_kind) : palindrome (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_31171 (h0 : function.extfun Type ring) : @is_principal_ideal_ring.{0} (has_add.{0} ennreal) (@function.extfun_app.{2 1} Type ring.{0} h0 (has_add.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_31172 (h0 : topological_space (denumerable (random_gen (random_gen (has_top linarith.comp_source))))) : t0_space (denumerable (random_gen (random_gen (has_top linarith.comp_source)))) := sorry --non-trivial
lemma new_lemma_31173 (h0 : cancel_comm_monoid_with_zero (mul_zero_class (semiring congr_arg_kind))) : unique_factorization_monoid (mul_zero_class (semiring congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_31174 (h0 : functor.add_const (topological_space (comm_monoid_with_zero empty)) unsigned) : @t1_space.{0} (comm_monoid_with_zero.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (comm_monoid_with_zero.{0} empty)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_31175 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @group.fg.{0} (measurable_space.{0} string_imp) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (measurable_space.{0} string_imp))  := sorry --non-trivial
lemma new_lemma_31176 (h0 : filter (has_Inf (sub_neg_monoid real))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_31177 (h0 : ring (normed_field (metric_space (comm_ring reducibility_hints)))) : strong_rank_condition (normed_field (metric_space (comm_ring reducibility_hints))) := sorry --non-trivial
lemma new_lemma_31178 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_cyclic.{0} (complete_distrib_lattice.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (complete_distrib_lattice.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_31179 (h0 : functor.add_const (topological_space name) empty) : @preirreducible_space.{0} name (@functor.add_const.run.{0 0} (topological_space.{0} name) empty h0)  := sorry --non-trivial
lemma new_lemma_31180 (h0 : function.extfun nat fin) : @is_cyclic.{0} (ordered_comm_monoid.{0} linarith.comp) (@matrix.vec_empty.{0} (group.{0} (ordered_comm_monoid.{0} linarith.comp)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_31181 (h0 : function.extfun ((Type -> Type) -> Type 1) (function.extfun (Type -> Type))) : @preconnected_space.{0} (has_to_string.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) (@function.extfun_app.{3 2} ((Type → Type) → Type 1) (function.extfun.{2 2} (Type → Type)) h0 (function.extfun.{2 1} Type)) topological_space.{0}) (has_to_string.{0} empty))  := sorry --non-trivial
lemma new_lemma_31182 (h0 : topological_space (finset (has_add (has_add (has_add (finset pos)))))) : preirreducible_space (finset (has_add (has_add (has_add (finset pos))))) := sorry --non-trivial
lemma new_lemma_31183 (h1 : function.extfun Type topological_space) : @path_connected_space.{0} (with_one.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h1 (with_one.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_31184 (h0 : topological_space (has_one (has_norm empty))) : path_connected_space (has_one (has_norm empty)) := sorry --non-trivial
lemma new_lemma_31185 (h0 : topological_space (has_nndist (with_bot (has_to_string ennreal)))) : totally_disconnected_space (has_nndist (with_bot (has_to_string ennreal))) := sorry --non-trivial
lemma new_lemma_31186 (h0 : function.extfun Type ring) : @strong_rank_condition.{0} (with_bot.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type ring.{0} h0 (with_bot.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_31187 (h0 : functor.add_const (topological_space (add_cancel_monoid environment.implicit_infer_kind)) linarith.comp) : @preirreducible_space.{0} (add_cancel_monoid.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (add_cancel_monoid.{0} environment.implicit_infer_kind)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_31188 (h0 : functor.add_const (topological_space (left_cancel_monoid congr_arg_kind)) unsigned) : @irreducible_space.{0} (left_cancel_monoid.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (left_cancel_monoid.{0} congr_arg_kind)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_31189 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_compactly_generated.{0} (linear_ordered_comm_ring.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (linear_ordered_comm_ring.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_31190 (h0 : function.extfun nat fin) : @is_principal_ideal_ring.{0} (normed_lattice_add_comm_group.{0} pos) (@matrix.vec_empty.{0} (ring.{0} (normed_lattice_add_comm_group.{0} pos)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_31191 (h0 : group (bin_tree (semiring (semiring (semiring empty))))) : group.fg (bin_tree (semiring (semiring (semiring empty)))) := sorry --non-trivial
lemma new_lemma_31192 (h0 : topological_space (has_neg_part (has_to_string pos))) : regular_space (has_neg_part (has_to_string pos)) := sorry --non-trivial
lemma new_lemma_31193 (h0 : function.extfun Type topological_space) : @totally_disconnected_space.{0} (lattice.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (lattice.{0} name))  := sorry --non-trivial
lemma new_lemma_31194 (h0 : topological_space (has_nndist (has_add linarith.comp))) : preconnected_space (has_nndist (has_add linarith.comp)) := sorry --non-trivial
lemma new_lemma_31195 (h0 : function.extfun Type group) : @normalizer_condition.{0} (with_one.{0} unsigned) (@function.extfun_app.{2 1} Type group.{0} h0 (with_one.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_31196 (h0 : topological_space (boolean_algebra.core name)) : totally_disconnected_space (boolean_algebra.core name) := sorry --non-trivial
lemma new_lemma_31197 (h0 : topological_space (has_inv to_additive.value_type)) : totally_disconnected_space (has_inv to_additive.value_type) := sorry --non-trivial
lemma new_lemma_31198 (h0 : set (distrib (uniform_space string.iterator_imp))) : set.subsingleton h0 := sorry --non-trivial
lemma new_lemma_31199 (h1 : group (measurable_space string_imp)) : is_cyclic (measurable_space string_imp) := sorry --non-trivial
lemma new_lemma_31200 (h1 : not (ring (distrib linarith.comp_source) -> false)) : @is_domain.{0} (distrib.{0} linarith.comp_source) (@classical.by_contradiction'.{1} (ring.{0} (distrib.{0} linarith.comp_source)) h1)  := sorry --non-trivial
lemma new_lemma_31201 (h0 : functor.add_const (ring (normed_linear_ordered_group congr_arg_kind)) congr_arg_kind) : @strong_rank_condition.{0} (normed_linear_ordered_group.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (ring.{0} (normed_linear_ordered_group.{0} congr_arg_kind)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_31202 (h0 : topological_space (nondiscrete_normed_field fun_info)) (h1 : preorder (nondiscrete_normed_field fun_info)) : order_closed_topology (nondiscrete_normed_field fun_info) := sorry --non-trivial
lemma new_lemma_31203 (h0 : topological_space (has_top (random_gen (random_gen linarith.comp_source)))) : discrete_topology (has_top (random_gen (random_gen linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_31204 (h0 : ring (finset (mul_one_class Type))) : is_domain (finset (mul_one_class Type)) := sorry --non-trivial
lemma new_lemma_31205 (h0 : functor.add_const (list (has_Sup empty)) num) : palindrome (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_31206 (h0 : group (metric_space (semiring (semiring (semiring unsigned))))) : is_cyclic (metric_space (semiring (semiring (semiring unsigned)))) := sorry --non-trivial
lemma new_lemma_31207 (h0 : functor.add_const (function.extfun (Type 1) ordered_comm_monoid) Type) : @has_exists_mul_of_le.{1} (ordered_comm_ring.{1} Type) (@function.extfun_app.{3 2} (Type 1) ordered_comm_monoid.{1} (@functor.add_const.run.{2 1} (function.extfun.{3 2} (Type 1) ordered_comm_monoid.{1}) Type h0) (ordered_comm_ring.{1} Type))  := sorry --non-trivial
lemma new_lemma_31208 (h1 : set (distrib (uniform_space string.iterator_imp))) : set.finite h1 := sorry --non-trivial
lemma new_lemma_31209 (h0 : has_mem.mem topological_space has_emptyc.emptyc) : @irreducible_space.{0} real.angle (@function.extfun_app.{2 1} Type topological_space.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) topological_space.{0} h0) real.angle)  := sorry --non-trivial
lemma new_lemma_31210 (h0 : function.extfun Type filter) : filter.ne_bot (function.extfun_app h0 (add_cancel_monoid pos)) := sorry --non-trivial
lemma new_lemma_31211 (h0 : topological_space (mul_zero_class (has_neg_part (has_neg_part ennreal)))) : t0_space (mul_zero_class (has_neg_part (has_neg_part ennreal))) := sorry --non-trivial
lemma new_lemma_31212 (h0 : has_lt char) : no_max_order char := sorry --non-trivial
lemma new_lemma_31213 (h1 : set (normed_field std_gen)) : set.finite h1 := sorry --non-trivial
lemma new_lemma_31214 (h0 : topological_space (simple_graph pos)) : preconnected_space (simple_graph pos) := sorry --non-trivial
lemma new_lemma_31215 (h0 : finset (has_star (semiring (semiring congr_arg_kind)))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_31216 (h0 : function.extfun Type group) : @is_cyclic.{0} (has_norm.{0} char) (@function.extfun_app.{2 1} Type group.{0} h0 (has_norm.{0} char))  := sorry --non-trivial
lemma new_lemma_31217 (h0 : prod congr_arg_kind congr_arg_kind) : id_rel h0 := sorry --non-trivial
lemma new_lemma_31218 (h0 : function.extfun Type ring) : @is_domain.{0} (with_one.{0} fun_info) (@function.extfun_app.{2 1} Type ring.{0} h0 (with_one.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_31219 (h0 : topological_space (has_bot (has_add (has_Inf (has_add Type))))) : t0_space (has_bot (has_add (has_Inf (has_add Type)))) := sorry --non-trivial
lemma new_lemma_31220 (h0 : topological_space (cancel_monoid (has_to_string unsigned))) : preirreducible_space (cancel_monoid (has_to_string unsigned)) := sorry --non-trivial
lemma new_lemma_31221 (h0 : ordered_comm_monoid (finset (has_to_string unsigned))) : has_exists_mul_of_le (finset (has_to_string unsigned)) := sorry --non-trivial
lemma new_lemma_31222 (h0 : topological_space (with_bot (semiring (semiring (semiring unsigned))))) : topological_space.separable_space (with_bot (semiring (semiring (semiring unsigned)))) := sorry --non-trivial
lemma new_lemma_31223 (h0 : function.extfun (finset (Type -> Type)) (has_mem.mem topological_space)) : @locally_compact_space.{0} (random_gen.{0} fun_info) (@function.extfun_app.{2 1} Type topological_space.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) topological_space.{0} (@function.extfun_app.{2 0} (finset.{1} (Type → Type)) (@has_mem.mem.{1 1} (Type → Type) (finset.{1} (Type → Type)) (@finset.has_mem.{1} (Type → Type)) topological_space.{0}) h0 (@has_emptyc.emptyc.{1} (finset.{1} (Type → Type)) (@finset.has_emptyc.{1} (Type → Type))))) (random_gen.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_31224 (h0 : complete_lattice (free_add_monoid (semiring empty))) : complete_lattice.is_Sup_finite_compact (free_add_monoid (semiring empty)) := sorry --non-trivial
lemma new_lemma_31225 (h3 : topological_space (random_gen (has_ssubset (has_ssubset (free_add_monoid char))))) : t0_space (random_gen (has_ssubset (has_ssubset (free_add_monoid char)))) := sorry --non-trivial
lemma new_lemma_31226 (h0 : functor.add_const (function.extfun Type topological_space) linarith.comp) : @preirreducible_space.{0} (boolean_algebra.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) linarith.comp h0) (boolean_algebra.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_31227 (h0 : fin has_zero.zero) : @has_exists_mul_of_le.{0} (ordered_comm_ring.{0} name) (@function.extfun_app.{2 1} Type ordered_comm_monoid.{0} (@matrix.vec_empty.{1} (function.extfun.{2 1} Type ordered_comm_monoid.{0}) h0) (ordered_comm_ring.{0} name))  := sorry --non-trivial
lemma new_lemma_31228 (h0 : functor.add_const (topological_space (ring Type)) linarith.comp) : @t0_space.{1} (ring.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (ring.{1} Type)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_31229 (h0 : function.extfun (Type 1) semiring) : @is_noetherian_ring.{1} (has_bot.{1} Type) (@function.extfun_app.{3 2} (Type 1) semiring.{1} h0 (has_bot.{1} Type))  := sorry --non-trivial
lemma new_lemma_31230 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_cyclic.{0} (comm_ring.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (comm_ring.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_31231 (h0 : topological_space (finset pos)) : irreducible_space (finset pos) := sorry --non-trivial
lemma new_lemma_31232 (h0 : topological_space (semiring (has_top fun_info))) : t0_space (semiring (has_top fun_info)) := sorry --non-trivial
lemma new_lemma_31233 (h0 : topological_space (ring (finset (has_Inf Type)))) : discrete_topology (ring (finset (has_Inf Type))) := sorry --non-trivial
lemma new_lemma_31234 (h0 : filter (cancel_monoid num)) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_31235 (h0 : function.extfun Type complete_lattice) : @is_compactly_generated.{0} pos (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 pos)  := sorry --non-trivial
lemma new_lemma_31236 (h0 : functor.add_const (filter (boolean_algebra.core Type)) unsigned) : countable_Inter_filter (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_31237 (h0 : topological_space (has_norm (random_gen to_additive.value_type))) : t0_space (has_norm (random_gen to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_31238 (h0 : add_group (with_zero to_additive.value_type)) : is_add_cyclic (with_zero to_additive.value_type) := sorry --non-trivial
lemma new_lemma_31239 (h0 : topological_space (canonically_ordered_add_monoid unsigned)) : normal_space (canonically_ordered_add_monoid unsigned) := sorry --non-trivial
lemma new_lemma_31240 (h0 : function.extfun (finset (Type -> Type)) (has_mem.mem topological_space)) : @totally_disconnected_space.{0} (measurable_space.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) topological_space.{0} (@function.extfun_app.{2 0} (finset.{1} (Type → Type)) (@has_mem.mem.{1 1} (Type → Type) (finset.{1} (Type → Type)) (@finset.has_mem.{1} (Type → Type)) topological_space.{0}) h0 (@has_emptyc.emptyc.{1} (finset.{1} (Type → Type)) (@finset.has_emptyc.{1} (Type → Type))))) (measurable_space.{0} empty))  := sorry --non-trivial
lemma new_lemma_31241 (h0 : functor.add_const (function.extfun Type topological_space) pos) : @totally_separated_space.{0} (semigroup.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) pos h0) (semigroup.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_31242 (h0 : monoid (id congr_arg_kind)) : monoid.fg (id congr_arg_kind) := sorry --non-trivial
lemma new_lemma_31243 (h1 : group (has_emptyc string_imp)) : normalizer_condition (has_emptyc string_imp) := sorry --non-trivial
lemma new_lemma_31244 (h0 : function.extfun Type cancel_comm_monoid_with_zero) : @unique_factorization_monoid.{0} (normed_linear_ordered_group.{0} empty) (@function.extfun_app.{2 1} Type cancel_comm_monoid_with_zero.{0} h0 (normed_linear_ordered_group.{0} empty))  := sorry --non-trivial
lemma new_lemma_31245 (h0 : topological_space (has_lt linarith.ineq)) (h1 : not (preorder (has_lt linarith.ineq) -> false)) : @order_topology.{0} (has_lt.{0} linarith.ineq) h0 (@classical.by_contradiction'.{1} (preorder.{0} (has_lt.{0} linarith.ineq)) h1)  := sorry --non-trivial
lemma new_lemma_31246 (h0 : function.extfun Type group) : @normalizer_condition.{0} (normed_group.{0} unsigned) (@function.extfun_app.{2 1} Type group.{0} h0 (normed_group.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_31247 (h0 : add_monoid (normed_lattice_add_comm_group (ordered_comm_monoid Type))) : add_monoid.fg (normed_lattice_add_comm_group (ordered_comm_monoid Type)) := sorry --non-trivial
lemma new_lemma_31248 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_principal_ideal_ring.{0} (add_cancel_monoid.{0} linarith.comp) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (add_cancel_monoid.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_31249 (h0 : functor.add_const (topological_space (has_neg pos)) (has_zero Type)) : @topological_space.separable_space.{0} (has_neg.{0} pos) (@functor.add_const.run.{0 1} (topological_space.{0} (has_neg.{0} pos)) (has_zero.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_31250 (h1 : not (monoid (with_one congr_arg_kind) -> false)) : @monoid.fg.{0} (with_one.{0} congr_arg_kind) (@classical.by_contradiction'.{1} (monoid.{0} (with_one.{0} congr_arg_kind)) h1)  := sorry --non-trivial
lemma new_lemma_31251 (h0 : uniform_space (has_neg (has_add Type))) : separated_space (has_neg (has_add Type)) := sorry --non-trivial
lemma new_lemma_31252 (h0 : functor.add_const (ring (has_add Type)) Type) : @rank_condition.{1} (has_add.{1} Type) (@functor.add_const.run.{1 1} (ring.{1} (has_add.{1} Type)) Type h0)  := sorry --non-trivial
lemma new_lemma_31253 (h0 : ring (has_norm (comm_ring (random_gen to_additive.value_type)))) : rank_condition (has_norm (comm_ring (random_gen to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_31254 (h0 : topological_space (add_cancel_monoid (has_add (has_neg linarith.comp)))) : locally_compact_space (add_cancel_monoid (has_add (has_neg linarith.comp))) := sorry --non-trivial
lemma new_lemma_31255 (h0 : add_group (option (option (option ennreal)))) : is_add_cyclic (option (option (option ennreal))) := sorry --non-trivial
lemma new_lemma_31256 (h0 : functor.add_const (topological_space (generalized_boolean_algebra Type)) name) : @t0_space.{1} (generalized_boolean_algebra.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (generalized_boolean_algebra.{1} Type)) name h0)  := sorry --non-trivial
lemma new_lemma_31257 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_cyclic.{0} (left_cancel_monoid.{0} empty) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (left_cancel_monoid.{0} empty))  := sorry --non-trivial
lemma new_lemma_31258 (h0 : functor.add_const (topological_space (has_bot linarith.comp)) Type) : @locally_compact_space.{0} (has_bot.{0} linarith.comp) (@functor.add_const.run.{0 1} (topological_space.{0} (has_bot.{0} linarith.comp)) Type h0)  := sorry --non-trivial
lemma new_lemma_31259 (h0 : ring (normed_lattice_add_comm_group (option empty))) : rank_condition (normed_lattice_add_comm_group (option empty)) := sorry --non-trivial
lemma new_lemma_31260 (h0 : topological_space (metric_space (semiring linarith.comp))) : t0_space (metric_space (semiring linarith.comp)) := sorry --non-trivial
lemma new_lemma_31261 (h0 : functor.add_const (topological_space (complete_distrib_lattice unsigned)) empty) : @totally_separated_space.{0} (complete_distrib_lattice.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (complete_distrib_lattice.{0} unsigned)) empty h0)  := sorry --non-trivial
lemma new_lemma_31262 (h0 : group (with_bot (with_bot string_imp))) : group.fg (with_bot (with_bot string_imp)) := sorry --non-trivial
lemma new_lemma_31263 (h0 : not (function.extfun Type topological_space -> false)) : @t0_space.{0} (has_norm.{0} linarith.ineq) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (has_norm.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_31264 (h0 : topological_space (cancel_monoid (has_add (has_add Type)))) : t0_space (cancel_monoid (has_add (has_add Type))) := sorry --non-trivial
lemma new_lemma_31265 (h0 : functor.add_const (topological_space (ordered_comm_ring name)) linarith.comp) : @irreducible_space.{0} (ordered_comm_ring.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (ordered_comm_ring.{0} name)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_31266 (h0 : functor.add_const (cancel_comm_monoid_with_zero (left_cancel_monoid unsigned)) unsigned) : @unique_factorization_monoid.{0} (left_cancel_monoid.{0} unsigned) (@functor.add_const.run.{0 0} (cancel_comm_monoid_with_zero.{0} (left_cancel_monoid.{0} unsigned)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_31267 (h0 : functor.add_const (add_group (has_nndist environment.implicit_infer_kind)) pos) : @is_add_cyclic.{0} (has_nndist.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (add_group.{0} (has_nndist.{0} environment.implicit_infer_kind)) pos h0)  := sorry --non-trivial
lemma new_lemma_31268 (h0 : group (denumerable fun_info)) : normalizer_condition (denumerable fun_info) := sorry --non-trivial
lemma new_lemma_31269 (h0 : function.extfun Type topological_space) : @path_connected_space.{0} linarith.ineq (@function.extfun_app.{2 1} Type topological_space.{0} h0 linarith.ineq)  := sorry --non-trivial
lemma new_lemma_31270 (h0 : has_to_string (boolean_algebra Type) -> has_to_string (boolean_algebra Type) -> Prop) : is_refl (has_to_string (boolean_algebra Type)) h0 := sorry --non-trivial
lemma new_lemma_31271 (h0 : functor.add_const (finset (has_neg linarith.comp)) (has_to_string Type)) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_31272 (h0 : monoid (has_neg (option (option num)))) : monoid.fg (has_neg (option (option num))) := sorry --non-trivial
lemma new_lemma_31273 (h0 : functor.add_const (complete_lattice (has_zero pos)) pos) : @is_compactly_generated.{0} (has_zero.{0} pos) (@functor.add_const.run.{0 0} (complete_lattice.{0} (has_zero.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_31274 (h0 : filter (linear_ordered_comm_group (option unsigned))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_31275 (h0 : has_mem.mem (has_ssubset linarith.ineq) has_emptyc.emptyc) : @strong_rank_condition.{0} (has_ssubset.{0} linarith.ineq) (@finset.pi.empty.{1 0} Type ring.{0} (has_ssubset.{0} linarith.ineq) h0)  := sorry --non-trivial
lemma new_lemma_31276 (h0 : function.extfun (Type 1) topological_space) : @normal_space.{1} (has_zero.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} h0 (has_zero.{1} Type))  := sorry --non-trivial
lemma new_lemma_31277 (h0 : functor.add_const (topological_space (has_pos_part pos)) pos) : @totally_disconnected_space.{0} (has_pos_part.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (has_pos_part.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_31278 (h0 : topological_space (has_add (ring (ring name)))) : t0_space (has_add (ring (ring name))) := sorry --non-trivial
lemma new_lemma_31279 (h0 : function.extfun Type has_le) : @no_bot_order.{0} (encodable.{0} linarith.ineq) (@function.extfun_app.{2 1} Type has_le.{0} h0 (encodable.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_31280 (h0 : not (topological_space (div_inv_monoid to_additive.value_type) -> false)) : @path_connected_space.{0} (div_inv_monoid.{0} to_additive.value_type) (@classical.by_contradiction'.{1} (topological_space.{0} (div_inv_monoid.{0} to_additive.value_type)) h0)  := sorry --non-trivial
lemma new_lemma_31281 (h0 : filter (has_ssubset string_imp)) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_31282 (h0 : complete_lattice (has_append (metric_space char))) : complete_lattice.is_Sup_finite_compact (has_append (metric_space char)) := sorry --non-trivial
lemma new_lemma_31283 (h0 : option (ring (has_append string_imp))) (h1 : not (coe_sort (option.is_some h0) -> false)) : @strong_rank_condition.{0} (has_append.{0} string_imp) (@option.get.{0} (ring.{0} (has_append.{0} string_imp)) h0 (@classical.by_contradiction'.{0} (@coe_sort.{1 1} bool Prop coe_sort_bool (@option.is_some.{0} (ring.{0} (has_append.{0} string_imp)) h0)) h1))  := sorry --non-trivial
lemma new_lemma_31284 (h0 : group (semigroup (finset (has_Inf environment.implicit_infer_kind)))) : is_simple_group (semigroup (finset (has_Inf environment.implicit_infer_kind))) := sorry --non-trivial
lemma new_lemma_31285 (h0 : function.extfun Type list) : list.nodup (function.extfun_app h0 (comm_ring char)) := sorry --non-trivial
lemma new_lemma_31286 (h0 : ring (has_neg_part (normed_comm_ring unsigned))) : rank_condition (has_neg_part (normed_comm_ring unsigned)) := sorry --non-trivial
lemma new_lemma_31287 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @discrete_topology.{0} (has_bot.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_bot.{0} name))  := sorry --non-trivial
lemma new_lemma_31288 (h0 : add_group (cancel_monoid ennreal)) : is_add_cyclic (cancel_monoid ennreal) := sorry --non-trivial
lemma new_lemma_31289 (h0 : finset (has_add (has_Inf Type))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_31290 (h0 : functor.comp topological_space has_add name) : @totally_disconnected_space.{0} (has_add.{0} name) (@functor.comp.run.{0 0 0} topological_space.{0} has_add.{0} name h0)  := sorry --non-trivial
lemma new_lemma_31291 (h0 : group (is_R_or_C (option (option (semiring empty))))) : group.fg (is_R_or_C (option (option (semiring empty)))) := sorry --non-trivial
lemma new_lemma_31292 (h0 : group (semigroup linarith.comp)) : group.fg (semigroup linarith.comp) := sorry --non-trivial
lemma new_lemma_31293 (h0 : ring (add_cancel_comm_monoid (random_gen (random_gen (has_ssubset string.iterator_imp))))) : is_domain (add_cancel_comm_monoid (random_gen (random_gen (has_ssubset string.iterator_imp)))) := sorry --non-trivial
lemma new_lemma_31294 (h0 : functor.add_const (finset (sub_neg_monoid pos)) pos) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_31295 (h0 : topological_space (semiring (has_top (has_top congr_arg_kind)))) : t0_space (semiring (has_top (has_top congr_arg_kind))) := sorry --non-trivial
lemma new_lemma_31296 (h0 : topological_space (add_cancel_monoid (finset (finset (finset linarith.comp))))) : discrete_topology (add_cancel_monoid (finset (finset (finset linarith.comp)))) := sorry --non-trivial
lemma new_lemma_31297 (h0 : function.extfun (finset Type) (has_mem.mem (has_top fun_info))) : @is_compactly_generated.{0} (has_top.{0} fun_info) (@finset.pi.empty.{1 0} Type complete_lattice.{0} (has_top.{0} fun_info) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (has_top.{0} fun_info)) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_31298 (h0 : functor.add_const (add_monoid (sub_neg_monoid pos)) linarith.comp) : @add_monoid.fg.{0} (sub_neg_monoid.{0} pos) (@functor.add_const.run.{0 0} (add_monoid.{0} (sub_neg_monoid.{0} pos)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_31299 (h0 : complete_lattice (has_norm (linear_ordered_semiring unsigned))) : complete_lattice.is_Sup_finite_compact (has_norm (linear_ordered_semiring unsigned)) := sorry --non-trivial
lemma new_lemma_31300 (h0 : add_group (canonically_linear_ordered_monoid (option (option pos)))) : is_add_cyclic (canonically_linear_ordered_monoid (option (option pos))) := sorry --non-trivial
lemma new_lemma_31301 (h0 : not (ring (distrib (has_nnnorm (has_nnnorm (denumerable char)))) -> false)) : @is_domain.{0} (distrib.{0} (has_nnnorm.{0} (has_nnnorm.{0} (denumerable.{0} char)))) (@classical.by_contradiction'.{1} (ring.{0} (distrib.{0} (has_nnnorm.{0} (has_nnnorm.{0} (denumerable.{0} char))))) h0)  := sorry --non-trivial
lemma new_lemma_31302 (h0 : function.extfun Type uniform_space) : @separated_space.{0} (add_comm_monoid.{0} ennreal) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (add_comm_monoid.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_31303 (h0 : uniform_space (simple_graph (boolean_algebra.core (has_Inf pos)))) : separated_space (simple_graph (boolean_algebra.core (has_Inf pos))) := sorry --non-trivial
lemma new_lemma_31304 (h0 : function.extfun (finset (Type -> Type)) (has_mem.mem add_group)) : @is_add_cyclic.{0} (with_one.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type add_group.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) add_group.{0} (@function.extfun_app.{2 0} (finset.{1} (Type → Type)) (@has_mem.mem.{1 1} (Type → Type) (finset.{1} (Type → Type)) (@finset.has_mem.{1} (Type → Type)) add_group.{0}) h0 (@has_emptyc.emptyc.{1} (finset.{1} (Type → Type)) (@finset.has_emptyc.{1} (Type → Type))))) (with_one.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_31305 (h0 : list (topological_space (has_inv string_imp))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_31306 (h0 : function.extfun Type ring) : @rank_condition.{0} (comm_group.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type ring.{0} h0 (comm_group.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_31307 (h0 : topological_space (has_one linarith.comp)) : preirreducible_space (has_one linarith.comp) := sorry --non-trivial
lemma new_lemma_31308 (h0 : topological_space (simple_graph (has_pos_part name))) : normal_space (simple_graph (has_pos_part name)) := sorry --non-trivial
lemma new_lemma_31309 (h0 : functor.add_const (add_group (add_cancel_monoid name)) environment.implicit_infer_kind) : @is_add_cyclic.{0} (add_cancel_monoid.{0} name) (@functor.add_const.run.{0 0} (add_group.{0} (add_cancel_monoid.{0} name)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_31310 (h0 : not (ring (linear_ordered_semiring linarith.ineq) -> false)) : @is_domain.{0} (linear_ordered_semiring.{0} linarith.ineq) (@classical.by_contradiction'.{1} (ring.{0} (linear_ordered_semiring.{0} linarith.ineq)) h0)  := sorry --non-trivial
lemma new_lemma_31311 (h7 : set (char -> enat)) : set.separates_points h7 := sorry --non-trivial
lemma new_lemma_31312 (h0 h1 : multiset (distrib (has_nnnorm string.iterator_imp))) : multiset.disjoint h0 h1 := sorry --non-trivial
lemma new_lemma_31313 (h0 : monoid (measurable_space (has_norm to_additive.value_type))) : monoid.fg (measurable_space (has_norm to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_31314 (h0 : function.extfun Type ring) : @is_domain.{0} (has_one.{0} unsigned) (@function.extfun_app.{2 1} Type ring.{0} h0 (has_one.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_31315 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @strong_rank_condition.{0} (linear_ordered_comm_group.{0} num) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (linear_ordered_comm_group.{0} num))  := sorry --non-trivial
lemma new_lemma_31316 (h0 : topological_space (ordered_comm_monoid (ordered_comm_monoid pos))) : topological_space.separable_space (ordered_comm_monoid (ordered_comm_monoid pos)) := sorry --non-trivial
lemma new_lemma_31317 (h0 : topological_space (id (semiring (has_norm num)))) : totally_separated_space (id (semiring (has_norm num))) := sorry --non-trivial
lemma new_lemma_31318 (h0 : ring (complete_distrib_lattice (normed_comm_ring name))) : rank_condition (complete_distrib_lattice (normed_comm_ring name)) := sorry --non-trivial
lemma new_lemma_31319 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @loc_path_connected_space.{0} (ordered_comm_ring.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (ordered_comm_ring.{0} pos))  := sorry --non-trivial
lemma new_lemma_31320 (h0 : functor.add_const (group (semigroup linarith.comp)) (has_to_string linarith.comp)) : @group.fg.{0} (semigroup.{0} linarith.comp) (@functor.add_const.run.{0 0} (group.{0} (semigroup.{0} linarith.comp)) (has_to_string.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_31321 (h0 : not (function.extfun Type topological_space -> false)) : @t0_space.{0} (has_one.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (has_one.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_31322 (h0 : has_add Type) : @function.periodic_pts.{1} (has_add.{1} Type) (@functor.add_const.run.{1 0} (has_add.{1} Type) (has_add.{0} (comm_group.{0} (comm_group.{0} (has_add.{0} (complete_distrib_lattice.{0} (mul_zero_class.{0} (comm_group.{0} pos)))))))) h0  := sorry --non-trivial
lemma new_lemma_31323 (h0 : function.extfun Type ring) : @is_domain.{0} (has_add.{0} name) (@function.extfun_app.{2 1} Type ring.{0} h0 (has_add.{0} name))  := sorry --non-trivial
lemma new_lemma_31324 (h0 : set (add_comm_semigroup (mul_one_class enat) -> enat)) : set.separates_points h0 := sorry --non-trivial
lemma new_lemma_31325 (h0 : functor.add_const (group (boolean_algebra.core pos)) (has_pos_part Type)) : @is_cyclic.{0} (boolean_algebra.core.{0} pos) (@functor.add_const.run.{0 1} (group.{0} (boolean_algebra.core.{0} pos)) (has_pos_part.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_31326 (h0 : function.extfun Type finset) : finset.nonempty (function.extfun_app h0 (uniform_space.core empty)) := sorry --non-trivial
lemma new_lemma_31327 (h0 : ring (has_compl (mul_one_class fun_info))) : strong_rank_condition (has_compl (mul_one_class fun_info)) := sorry --non-trivial
lemma new_lemma_31328 (h0 : function.extfun Type (functor.comp complete_lattice has_nndist)) : @complete_lattice.is_Sup_finite_compact.{0} (has_nndist.{0} ennreal) (@functor.comp.run.{0 0 0} complete_lattice.{0} has_nndist.{0} ennreal (@function.extfun_app.{2 1} Type (functor.comp.{0 0 0} complete_lattice.{0} has_nndist.{0}) h0 ennreal))  := sorry --non-trivial
lemma new_lemma_31329 (h0 : functor.add_const (list (ordered_ring empty)) congr_arg_kind) : palindrome (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_31330 (h0 : functor.add_const (topological_space (mul_zero_class empty)) num) : @totally_separated_space.{0} (mul_zero_class.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (mul_zero_class.{0} empty)) num h0)  := sorry --non-trivial
lemma new_lemma_31331 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_cyclic.{0} (random_gen.{0} fun_info) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (random_gen.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_31332 (h0 : function.extfun (Type 1) complete_lattice) : @complete_lattice.is_Sup_finite_compact.{1} (has_add.{1} Type) (@function.extfun_app.{3 2} (Type 1) complete_lattice.{1} h0 (has_add.{1} Type))  := sorry --non-trivial
lemma new_lemma_31333 (h0 : topological_space (ordered_comm_monoid (boolean_algebra.core pos))) : normal_space (ordered_comm_monoid (boolean_algebra.core pos)) := sorry --non-trivial
lemma new_lemma_31334 (h0 : not (topological_space (semiring linarith.comp_source) -> false)) : @path_connected_space.{0} (semiring.{0} linarith.comp_source) (@classical.by_contradiction'.{1} (topological_space.{0} (semiring.{0} linarith.comp_source)) h0)  := sorry --non-trivial
lemma new_lemma_31335 (h0 : group (normed_linear_ordered_group congr_arg_kind)) : group.fg (normed_linear_ordered_group congr_arg_kind) := sorry --non-trivial
lemma new_lemma_31336 (h0 : functor.add_const (topological_space (left_cancel_monoid unsigned)) unsigned) : @totally_separated_space.{0} (left_cancel_monoid.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (left_cancel_monoid.{0} unsigned)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_31337 (h0 : group (add_cancel_monoid (finset (has_add linarith.comp)))) : normalizer_condition (add_cancel_monoid (finset (has_add linarith.comp))) := sorry --non-trivial
lemma new_lemma_31338 (h0 : group (with_bot linarith.ineq)) : group.fg (with_bot linarith.ineq) := sorry --non-trivial
lemma new_lemma_31339 (h0 : not (ring (fintype fun_info) -> false)) : @rank_condition.{0} (fintype.{0} fun_info) (@classical.by_contradiction'.{1} (ring.{0} (fintype.{0} fun_info)) h0)  := sorry --non-trivial
lemma new_lemma_31340 (h0 : functor.add_const (monoid (add_cancel_monoid unsigned)) unsigned) : @monoid.fg.{0} (add_cancel_monoid.{0} unsigned) (@functor.add_const.run.{0 0} (monoid.{0} (add_cancel_monoid.{0} unsigned)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_31341 (h0 : topological_space (complete_semilattice_Sup (measurable_space.dynkin_system unsigned))) : discrete_topology (complete_semilattice_Sup (measurable_space.dynkin_system unsigned)) := sorry --non-trivial
lemma new_lemma_31342 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @group.fg.{0} (normed_group.{0} empty) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (normed_group.{0} empty))  := sorry --non-trivial
lemma new_lemma_31343 (h0 : group (boolean_algebra.core (has_add (has_to_string congr_arg_kind)))) : is_simple_group (boolean_algebra.core (has_add (has_to_string congr_arg_kind))) := sorry --non-trivial
lemma new_lemma_31344 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_principal_ideal_ring.{0} (has_Inf.{0} linarith.comp) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (has_Inf.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_31345 (h0 : functor.add_const (topological_space name) unsigned) : @normal_space.{0} name (@functor.add_const.run.{0 0} (topological_space.{0} name) unsigned h0)  := sorry --non-trivial
lemma new_lemma_31346 (h0 : function.extfun Type (functor.add_const (topological_space (normed_linear_ordered_group unsigned)))) : @preirreducible_space.{0} (normed_linear_ordered_group.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (normed_linear_ordered_group.{0} unsigned)) num (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (topological_space.{0} (normed_linear_ordered_group.{0} unsigned))) h0 num))  := sorry --non-trivial
lemma new_lemma_31347 (h0 : add_group (has_neg (option ennreal))) : is_add_cyclic (has_neg (option ennreal)) := sorry --non-trivial
lemma new_lemma_31348 (h0 : functor.add_const (group (comm_group linarith.comp)) linarith.comp) : @normalizer_condition.{0} (comm_group.{0} linarith.comp) (@functor.add_const.run.{0 0} (group.{0} (comm_group.{0} linarith.comp)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_31349 (h0 : group (complete_distrib_lattice congr_arg_kind)) : is_cyclic (complete_distrib_lattice congr_arg_kind) := sorry --non-trivial
lemma new_lemma_31350 (h0 : functor.add_const (semiring (ordered_comm_monoid pos)) linarith.comp) : @is_noetherian_ring.{0} (ordered_comm_monoid.{0} pos) (@functor.add_const.run.{0 0} (semiring.{0} (ordered_comm_monoid.{0} pos)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_31351 (h0 : group (has_ssubset (has_nnnorm (random_gen fun_info)))) : is_cyclic (has_ssubset (has_nnnorm (random_gen fun_info))) := sorry --non-trivial
lemma new_lemma_31352 (h0 : list (generalized_boolean_algebra (finset linarith.comp))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_31353 (h0 : functor.add_const (group (canonically_ordered_add_monoid empty)) (option empty)) : @normalizer_condition.{0} (canonically_ordered_add_monoid.{0} empty) (@functor.add_const.run.{0 0} (group.{0} (canonically_ordered_add_monoid.{0} empty)) (option.{0} empty) h0)  := sorry --non-trivial
lemma new_lemma_31354 (h0 : functor.add_const (ordered_add_comm_monoid (add_right_cancel_monoid empty)) empty) : @archimedean.{0} (add_right_cancel_monoid.{0} empty) (@functor.add_const.run.{0 0} (ordered_add_comm_monoid.{0} (add_right_cancel_monoid.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_31355 (h0 : function.extfun Type add_group) : @is_add_cyclic.{0} (@id.{2} Type fun_info) (@function.extfun_app.{2 1} Type add_group.{0} h0 (@id.{2} Type fun_info))  := sorry --non-trivial
lemma new_lemma_31356 (h0 : topological_space (add_cancel_monoid (has_add environment.implicit_infer_kind))) : totally_disconnected_space (add_cancel_monoid (has_add environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_31357 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_compactly_generated.{0} (add_comm_monoid.{0} ennreal) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (add_comm_monoid.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_31358 (h0 : complete_lattice (has_add (sub_neg_monoid pos))) : is_atomistic (has_add (sub_neg_monoid pos)) := sorry --non-trivial
lemma new_lemma_31359 (h0 : function.extfun Type topological_space) : @totally_separated_space.{0} (canonically_ordered_comm_semiring.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (canonically_ordered_comm_semiring.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_31360 (h0 : function.extfun (Type 1) ring) : @is_domain.{1} (comm_group.{1} Type) (@function.extfun_app.{3 2} (Type 1) ring.{1} h0 (comm_group.{1} Type))  := sorry --non-trivial
lemma new_lemma_31361 (h0 : functor.add_const (complete_lattice (has_pos_part linarith.comp)) (has_pos_part pos)) : @is_compactly_generated.{0} (has_pos_part.{0} linarith.comp) (@functor.add_const.run.{0 0} (complete_lattice.{0} (has_pos_part.{0} linarith.comp)) (has_pos_part.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_31362 (h0 : functor.add_const (monoid (boolean_algebra environment.implicit_infer_kind)) pos) : @monoid.fg.{0} (boolean_algebra.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (monoid.{0} (boolean_algebra.{0} environment.implicit_infer_kind)) pos h0)  := sorry --non-trivial
lemma new_lemma_31363 (h0 : topological_space (ordered_comm_monoid (boolean_algebra.core (has_add (ring (has_add name)))))) : irreducible_space (ordered_comm_monoid (boolean_algebra.core (has_add (ring (has_add name))))) := sorry --non-trivial
lemma new_lemma_31364 (h0 : topological_space (left_cancel_monoid (option (semiring unsigned)))) : preirreducible_space (left_cancel_monoid (option (semiring unsigned))) := sorry --non-trivial
lemma new_lemma_31365 (h3 : add_group (semi_normed_comm_ring (has_append linarith.ineq))) : is_add_cyclic (semi_normed_comm_ring (has_append linarith.ineq)) := sorry --non-trivial
lemma new_lemma_31366 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @archimedean.{0} (finset.{0} num) (@function.extfun_app.{2 1} Type ordered_add_comm_monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ordered_add_comm_monoid.{0}) (finset.{0} num))  := sorry --non-trivial
lemma new_lemma_31367 (h0 : function.extfun Type topological_space) : @normal_space.{0} pos (@function.extfun_app.{2 1} Type topological_space.{0} h0 pos)  := sorry --non-trivial
lemma new_lemma_31368 (h0 : functor.add_const (complete_lattice (canonically_ordered_monoid pos)) real) : @is_atomistic.{0} (canonically_ordered_monoid.{0} pos) (@functor.add_const.run.{0 0} (complete_lattice.{0} (canonically_ordered_monoid.{0} pos)) real h0)  := sorry --non-trivial
lemma new_lemma_31369 (h0 : filter (measurable_space string_imp)) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_31370 (h0 : function.extfun Type uniform_space) : @complete_space.{0} (canonically_ordered_add_monoid.{0} empty) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (canonically_ordered_add_monoid.{0} empty))  := sorry --non-trivial
lemma new_lemma_31371 (h1 : ring (has_emptyc (has_top fun_info))) : strong_rank_condition (has_emptyc (has_top fun_info)) := sorry --non-trivial
lemma new_lemma_31372 (h4 : add_group (add_comm_semigroup linarith.ineq)) : is_add_cyclic (add_comm_semigroup linarith.ineq) := sorry --non-trivial
lemma new_lemma_31373 (h0 h1 : function.extfun (Type -> Type) (function.extfun Type)) : @is_regular.{0} (has_top.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type has_mul.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 has_mul.{0}) (has_top.{0} to_additive.value_type)) (@function.extfun_app.{2 1} Type has_top.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h1 has_top.{0}) to_additive.value_type)  := sorry --non-trivial
lemma new_lemma_31374 (h0 : functor.add_const (monoid (has_neg_part Type)) (has_add linarith.comp)) : @monoid.fg.{1} (has_neg_part.{1} Type) (@functor.add_const.run.{1 0} (monoid.{1} (has_neg_part.{1} Type)) (has_add.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_31375 (h2 : ring (complete_semilattice_Sup (pseudo_emetric_space linarith.comp_source))) : is_domain (complete_semilattice_Sup (pseudo_emetric_space linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_31376 (h0 : function.extfun Type topological_space) : @totally_disconnected_space.{0} (semigroup.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (semigroup.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_31377 (h0 : finset (canonically_ordered_comm_semiring (option empty))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_31378 (h0 : ring (comm_group (finset pos))) : strong_rank_condition (comm_group (finset pos)) := sorry --non-trivial
lemma new_lemma_31379 (h0 : topological_space (omega_complete_partial_order (add_left_cancel_semigroup congr_arg_kind))) : locally_compact_space (omega_complete_partial_order (add_left_cancel_semigroup congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_31380 (h2 : topological_space (has_emptyc num)) : t0_space (has_emptyc num) := sorry --non-trivial
lemma new_lemma_31381 (h0 : functor.comp ordered_add_comm_monoid boolean_algebra.core name) : @archimedean.{0} (boolean_algebra.core.{0} name) (@functor.comp.run.{0 0 0} ordered_add_comm_monoid.{0} boolean_algebra.core.{0} name h0)  := sorry --non-trivial
lemma new_lemma_31382 (h0 : group (generalized_boolean_algebra (has_bot (sub_neg_monoid (has_bot (has_bot name)))))) : is_cyclic (generalized_boolean_algebra (has_bot (sub_neg_monoid (has_bot (has_bot name))))) := sorry --non-trivial
lemma new_lemma_31383 (h0 : function.extfun Type topological_space) : @locally_compact_space.{0} (@id.{2} Type num) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (@id.{2} Type num))  := sorry --non-trivial
lemma new_lemma_31384 (h0 : add_monoid (has_Sup (add_right_cancel_monoid num))) : add_monoid.fg (has_Sup (add_right_cancel_monoid num)) := sorry --non-trivial
lemma new_lemma_31385 (h0 : functor.add_const (group (semigroup (has_neg linarith.comp))) linarith.comp) : @is_simple_group.{0} (semigroup.{0} (has_neg.{0} linarith.comp)) (@functor.add_const.run.{0 0} (group.{0} (semigroup.{0} (has_neg.{0} linarith.comp))) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_31386 (h0 : functor.add_const (function.extfun Type topological_space) pos) : @irreducible_space.{0} (semigroup.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) pos h0) (semigroup.{0} pos))  := sorry --non-trivial
lemma new_lemma_31387 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @rank_condition.{0} (ring.{0} num) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (ring.{0} num))  := sorry --non-trivial
lemma new_lemma_31388 (h0 : functor.add_const (topological_space (boolean_algebra Type)) (has_zero linarith.comp)) : @t0_space.{1} (boolean_algebra.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (boolean_algebra.{1} Type)) (has_zero.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_31389 (h0 : functor.add_const (topological_space (complete_distrib_lattice num)) empty) : @preirreducible_space.{0} (complete_distrib_lattice.{0} num) (@functor.add_const.run.{0 0} (topological_space.{0} (complete_distrib_lattice.{0} num)) empty h0)  := sorry --non-trivial
lemma new_lemma_31390 (h0 : add_group (finset pos)) : is_add_cyclic (finset pos) := sorry --non-trivial
lemma new_lemma_31391 (h0 : topological_space (normed_comm_ring (ring pos))) : totally_separated_space (normed_comm_ring (ring pos)) := sorry --non-trivial
lemma new_lemma_31392 (h0 : topological_space (add_comm_semigroup fun_info)) (h1 : preorder (add_comm_semigroup fun_info)) : order_closed_topology (add_comm_semigroup fun_info) := sorry --non-trivial
lemma new_lemma_31393 (h0 : topological_space (has_nndist ennreal)) : t0_space (has_nndist ennreal) := sorry --non-trivial
lemma new_lemma_31394 (h0 : function.extfun Type topological_space) : @sequential_space.{0} (cancel_monoid.{0} ennreal) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (cancel_monoid.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_31395 (h0 : functor.add_const (ring (has_neg name)) linarith.comp) : @strong_rank_condition.{0} (has_neg.{0} name) (@functor.add_const.run.{0 0} (ring.{0} (has_neg.{0} name)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_31396 (h0 : function.extfun Type topological_space) : @totally_separated_space.{0} (with_one.{0} linarith.ineq) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (with_one.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_31397 (h0 : not (uniform_space (has_sub unsigned) -> false)) : @complete_space.{0} (has_sub.{0} unsigned) (@classical.by_contradiction'.{1} (uniform_space.{0} (has_sub.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_31398 (h0 : functor.add_const (uniform_space (is_R_or_C empty)) empty) : @complete_space.{0} (is_R_or_C.{0} empty) (@functor.add_const.run.{0 0} (uniform_space.{0} (is_R_or_C.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_31399 (h0 : filter (has_zero (add_cancel_monoid ennreal))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_31400 (h0 : function.extfun (semigroup ennreal) (fun (x : semigroup ennreal), num)) : function.has_right_inverse (function.extfun_app h0) := sorry --non-trivial
lemma new_lemma_31401 (h0 : topological_space (linear_ordered_semiring (semiring unsigned))) : discrete_topology (linear_ordered_semiring (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_31402 (h0 : topological_space (linear_ordered_comm_group pos)) : totally_separated_space (linear_ordered_comm_group pos) := sorry --non-trivial
lemma new_lemma_31403 (h0 : topological_space string_imp) : discrete_topology string_imp := sorry --non-trivial
lemma new_lemma_31404 (h0 : function.extfun Type topological_space) : @preirreducible_space.{0} (random_gen.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (random_gen.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_31405 (h0 : topological_space (has_inv (random_gen to_additive.value_type))) : path_connected_space (has_inv (random_gen to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_31406 (h0 : group (topological_space linarith.ineq)) : group.fg (topological_space linarith.ineq) := sorry --non-trivial
lemma new_lemma_31407 (h0 : has_le (nondiscrete_normed_field fun_info)) (h1 : nondiscrete_normed_field fun_info) : is_max h1 := sorry --non-trivial
lemma new_lemma_31408 (h0 : has_mem.mem (measurable_space congr_arg_kind) has_emptyc.emptyc) : @totally_separated_space.{0} (measurable_space.{0} congr_arg_kind) (@finset.pi.empty.{1 0} Type topological_space.{0} (measurable_space.{0} congr_arg_kind) h0)  := sorry --non-trivial
lemma new_lemma_31409 (h0 : functor.add_const (monoid (semigroup Type)) (has_neg Type)) : @monoid.fg.{1} (semigroup.{1} Type) (@functor.add_const.run.{1 1} (monoid.{1} (semigroup.{1} Type)) (has_neg.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_31410 (h0 : function.extfun Type topological_space) : @preirreducible_space.{0} (has_union.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_union.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_31411 (h0 : functor.add_const (topological_space (simple_graph linarith.comp)) Type) : @discrete_topology.{0} (simple_graph.{0} linarith.comp) (@functor.add_const.run.{0 1} (topological_space.{0} (simple_graph.{0} linarith.comp)) Type h0)  := sorry --non-trivial
lemma new_lemma_31412 (h0 : not (complete_lattice (complete_linear_order unsigned) -> false)) : @is_compactly_generated.{0} (complete_linear_order.{0} unsigned) (@classical.by_contradiction'.{1} (complete_lattice.{0} (complete_linear_order.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_31413 (h1 : topological_space to_additive.value_type) : locally_compact_space to_additive.value_type := sorry --non-trivial
lemma new_lemma_31414 (h1 : function.extfun (prod num num) (fun (x : prod num num), Prop)) (h2 : prod num num) : symmetrize_rel (function.extfun_app h1) h2 := sorry --non-trivial
lemma new_lemma_31415 (h0 : functor.add_const (topological_space (has_to_string unsigned)) name) : @sequential_space.{0} (has_to_string.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (has_to_string.{0} unsigned)) name h0)  := sorry --non-trivial
lemma new_lemma_31416 (h0 : group (has_add (option (option unsigned)))) : is_simple_group (has_add (option (option unsigned))) := sorry --non-trivial
lemma new_lemma_31417 (h0 : functor.comp topological_space has_add (option unsigned)) : @irreducible_space.{0} (has_add.{0} (option.{0} unsigned)) (@functor.comp.run.{0 0 0} topological_space.{0} has_add.{0} (option.{0} unsigned) h0)  := sorry --non-trivial
lemma new_lemma_31418 (h0 : functor.add_const (topological_space (has_Inf pos)) linarith.comp) : @sequential_space.{0} (has_Inf.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (has_Inf.{0} pos)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_31419 (h0 : complete_lattice (measure_theory.measure_space (semiring num))) : is_compactly_generated (measure_theory.measure_space (semiring num)) := sorry --non-trivial
lemma new_lemma_31420 (h0 : semiring (measurable_space.dynkin_system (semiring (semiring congr_arg_kind)))) : is_noetherian_ring (measurable_space.dynkin_system (semiring (semiring congr_arg_kind))) := sorry --non-trivial
lemma new_lemma_31421 (h0 : ring (add_left_cancel_monoid char)) : strong_rank_condition (add_left_cancel_monoid char) := sorry --non-trivial
lemma new_lemma_31422 (h0 : functor.add_const (topological_space (has_add real)) real) : @locally_compact_space.{0} (has_add.{0} real) (@functor.add_const.run.{0 0} (topological_space.{0} (has_add.{0} real)) real h0)  := sorry --non-trivial
lemma new_lemma_31423 (h0 : group (has_norm (random_gen linarith.ineq))) : is_cyclic (has_norm (random_gen linarith.ineq)) := sorry --non-trivial
lemma new_lemma_31424 (h0 : uniform_space (has_add (has_add real))) : complete_space (has_add (has_add real)) := sorry --non-trivial
lemma new_lemma_31425 (h0 : has_Inf (ordered_comm_monoid real) -> has_Inf (ordered_comm_monoid real) -> Prop) : transitive h0 := sorry --non-trivial
lemma new_lemma_31426 (h0 : function.extfun Type topological_space) : @irreducible_space.{0} (add_group.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (add_group.{0} empty))  := sorry --non-trivial
lemma new_lemma_31427 (h0 : topological_space (has_neg (ring (has_neg_part (has_neg_part (has_add (has_add Type))))))) : discrete_topology (has_neg (ring (has_neg_part (has_neg_part (has_add (has_add Type)))))) := sorry --non-trivial
lemma new_lemma_31428 (h0 : uniform_space (normed_comm_ring (ring (has_Inf Type)))) : complete_space (normed_comm_ring (ring (has_Inf Type))) := sorry --non-trivial
lemma new_lemma_31429 (h0 : topological_space (complete_semilattice_Sup (has_norm congr_arg_kind))) : locally_compact_space (complete_semilattice_Sup (has_norm congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_31430 (h0 : topological_space (id (semiring (semiring congr_arg_kind)))) : totally_separated_space (id (semiring (semiring congr_arg_kind))) := sorry --non-trivial
lemma new_lemma_31431 (h0 : filter (has_to_string (has_add (has_neg (ring linarith.comp))))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_31432 (h0 : function.extfun (finset Type) (has_mem.mem (has_one unsigned))) : @add_monoid.fg.{0} (has_one.{0} unsigned) (@finset.pi.empty.{1 0} Type add_monoid.{0} (has_one.{0} unsigned) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (has_one.{0} unsigned)) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_31433 (h0 : functor.add_const (complete_lattice (has_neg environment.implicit_infer_kind)) pos) : @is_atomistic.{0} (has_neg.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (complete_lattice.{0} (has_neg.{0} environment.implicit_infer_kind)) pos h0)  := sorry --non-trivial
lemma new_lemma_31434 (h0 : ring (complete_semilattice_Sup (comm_ring (random_gen fun_info)))) : is_domain (complete_semilattice_Sup (comm_ring (random_gen fun_info))) := sorry --non-trivial
lemma new_lemma_31435 (h0 : filter (has_append fun_info)) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_31436 (h0 : not (function.extfun Type group -> false)) : @group.fg.{0} (encodable.{0} linarith.ineq) (@function.extfun_app.{2 1} Type group.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type group.{0}) h0) (encodable.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_31437 (h0 : function.extfun Type (prod (canonically_linear_ordered_monoid unsigned))) : id_rel (function.extfun_app h0 (canonically_linear_ordered_monoid unsigned)) := sorry --non-trivial
lemma new_lemma_31438 (h1 : topological_space (has_emptyc (random_gen to_additive.value_type))) : totally_disconnected_space (has_emptyc (random_gen to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_31439 (h0 : function.extfun Type topological_space) : @locally_compact_space.{0} (add_comm_monoid.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (add_comm_monoid.{0} empty))  := sorry --non-trivial
lemma new_lemma_31440 (h1 : group (complete_semilattice_Sup linarith.comp_source)) : is_cyclic (complete_semilattice_Sup linarith.comp_source) := sorry --non-trivial
lemma new_lemma_31441 (h0 : not (function.extfun Type group -> false)) : @normalizer_condition.{0} (has_union.{0} unsigned) (@function.extfun_app.{2 1} Type group.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type group.{0}) h0) (has_union.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_31442 (h0 : has_mem.mem complete_lattice has_emptyc.emptyc) : @is_atomistic.{0} (@id.{2} Type empty) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) complete_lattice.{0} h0) (@id.{2} Type empty))  := sorry --non-trivial
lemma new_lemma_31443 (h0 : group (has_nndist (normed_comm_ring Type))) : is_cyclic (has_nndist (normed_comm_ring Type)) := sorry --non-trivial
lemma new_lemma_31444 (h0 : add_group (non_unital_non_assoc_semiring enat)) : is_add_cyclic (non_unital_non_assoc_semiring enat) := sorry --non-trivial
lemma new_lemma_31445 (h0 : add_group (has_zero num)) : is_add_cyclic (has_zero num) := sorry --non-trivial
lemma new_lemma_31446 (h0 : functor.add_const (topological_space (cancel_monoid name)) (has_neg linarith.comp)) : @totally_separated_space.{0} (cancel_monoid.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (cancel_monoid.{0} name)) (has_neg.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_31447 (h0 : topological_space (with_one congr_arg_kind)) : t0_space (with_one congr_arg_kind) := sorry --non-trivial
lemma new_lemma_31448 (h0 : functor.add_const (group (simple_graph linarith.comp)) name) : @group.fg.{0} (simple_graph.{0} linarith.comp) (@functor.add_const.run.{0 0} (group.{0} (simple_graph.{0} linarith.comp)) name h0)  := sorry --non-trivial
lemma new_lemma_31449 (h0 : functor.add_const (functor.add_const (topological_space Type) linarith.comp) name) : @totally_separated_space.{1} Type (@functor.add_const.run.{1 0} (topological_space.{1} Type) linarith.comp (@functor.add_const.run.{1 0} (functor.add_const.{1 0} (topological_space.{1} Type) linarith.comp) name h0))  := sorry --non-trivial
lemma new_lemma_31450 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @preconnected_space.{1} (has_pos_part.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 topological_space.{1}) (has_pos_part.{1} Type))  := sorry --non-trivial
lemma new_lemma_31451 (h0 : functor.add_const (uniform_space (normed_comm_ring Type)) environment.implicit_infer_kind) : @separated_space.{1} (normed_comm_ring.{1} Type) (@functor.add_const.run.{1 0} (uniform_space.{1} (normed_comm_ring.{1} Type)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_31452 (h0 : group (finset (has_to_string (has_neg (mul_one_class (has_neg pos)))))) : is_simple_group (finset (has_to_string (has_neg (mul_one_class (has_neg pos))))) := sorry --non-trivial
lemma new_lemma_31453 (h0 : function.extfun Type monoid) : @monoid.fg.{0} (boolean_algebra.core.{0} unsigned) (@function.extfun_app.{2 1} Type monoid.{0} h0 (boolean_algebra.core.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_31454 (h0 : finset (normed_comm_ring (has_to_string (comm_group pos)))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_31455 (h0 : group (has_top fun_info)) : group.fg (has_top fun_info) := sorry --non-trivial
lemma new_lemma_31456 (h0 : function.extfun Type topological_space) : @totally_separated_space.{0} (sub_neg_monoid.{0} real) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (sub_neg_monoid.{0} real))  := sorry --non-trivial
lemma new_lemma_31457 (h0 : group (normed_lattice_add_comm_group (has_pos_part (has_Inf pos)))) : group.fg (normed_lattice_add_comm_group (has_pos_part (has_Inf pos))) := sorry --non-trivial
lemma new_lemma_31458 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @archimedean.{0} (has_add.{0} pos) (@function.extfun_app.{2 1} Type ordered_add_comm_monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ordered_add_comm_monoid.{0}) (has_add.{0} pos))  := sorry --non-trivial
lemma new_lemma_31459 (h0 : ordered_comm_monoid (boolean_algebra (finset (has_Inf pos)))) : has_exists_mul_of_le (boolean_algebra (finset (has_Inf pos))) := sorry --non-trivial
lemma new_lemma_31460 (h0 : ring (nondiscrete_normed_field std_gen)) : strong_rank_condition (nondiscrete_normed_field std_gen) := sorry --non-trivial
lemma new_lemma_31461 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @t0_space.{0} (with_one.{0} (semiring.{0} (semiring.{0} (has_norm.{0} (has_top.{0} (has_norm.{0} linarith.comp)))))) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (with_one.{0} (semiring.{0} (semiring.{0} (has_norm.{0} (has_top.{0} (has_norm.{0} linarith.comp)))))))  := sorry --non-trivial
lemma new_lemma_31462 (h0 : ring (has_compl (random_gen (random_gen (random_gen (has_nnnorm linarith.ineq)))))) : is_domain (has_compl (random_gen (random_gen (random_gen (has_nnnorm linarith.ineq))))) := sorry --non-trivial
lemma new_lemma_31463 (h0 h1 : multiset (add_comm_semigroup (mul_one_class (mul_one_class string.iterator_imp)))) : multiset.disjoint h0 h1 := sorry --non-trivial
lemma new_lemma_31464 (h2 : has_lt (mul_one_class string.iterator_imp)) : no_max_order (mul_one_class string.iterator_imp) := sorry --non-trivial
lemma new_lemma_31465 (h0 : prod (group_with_zero ennreal) (group_with_zero ennreal)) : id_rel h0 := sorry --non-trivial
lemma new_lemma_31466 (h0 : function.extfun Type ordered_add_comm_monoid) : @archimedean.{0} (finset.{0} empty) (@function.extfun_app.{2 1} Type ordered_add_comm_monoid.{0} h0 (finset.{0} empty))  := sorry --non-trivial
lemma new_lemma_31467 (h0 : ring (encodable (random_gen (random_gen char)))) : is_domain (encodable (random_gen (random_gen char))) := sorry --non-trivial
lemma new_lemma_31468 (h0 : functor.add_const (filter (mul_zero_class Type)) pos) : filter.ne_bot (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_31469 (h0 : set (has_le (normed_field to_additive.value_type))) : set.finite h0 := sorry --non-trivial
lemma new_lemma_31470 (h0 : functor.add_const (topological_space (has_zero environment.implicit_infer_kind)) pos) : @locally_compact_space.{0} (has_zero.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (has_zero.{0} environment.implicit_infer_kind)) pos h0)  := sorry --non-trivial
lemma new_lemma_31471 (h0 : topological_space (option (option (option pos)))) : sequential_space (option (option (option pos))) := sorry --non-trivial
lemma new_lemma_31472 (h0 : group (has_neg (has_zero name))) : group.fg (has_neg (has_zero name)) := sorry --non-trivial
lemma new_lemma_31473 (h0 : function.extfun ((Type -> Type) -> Type 1) (function.extfun (Type -> Type))) : @monoid.fg.{0} (@id.{2} Type linarith.comp_source) (@function.extfun_app.{2 1} Type monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) (@function.extfun_app.{3 2} ((Type → Type) → Type 1) (function.extfun.{2 2} (Type → Type)) h0 (function.extfun.{2 1} Type)) monoid.{0}) (@id.{2} Type linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_31474 (h0 : function.extfun Type semiring) : @is_noetherian_ring.{0} (normed_comm_ring.{0} name) (@function.extfun_app.{2 1} Type semiring.{0} h0 (normed_comm_ring.{0} name))  := sorry --non-trivial
lemma new_lemma_31475 (h0 : not (function.extfun Type ring -> false)) : @strong_rank_condition.{0} (semiring.{0} empty) (@function.extfun_app.{2 1} Type ring.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type ring.{0}) h0) (semiring.{0} empty))  := sorry --non-trivial
lemma new_lemma_31476 (h0 : ring (has_ssubset (has_nnnorm linarith.ineq))) : rank_condition (has_ssubset (has_nnnorm linarith.ineq)) := sorry --non-trivial
lemma new_lemma_31477 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @is_principal_ideal_ring.{1} (has_Inf.{1} Type) (@function.extfun_app.{3 2} (Type 1) ring.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 ring.{1}) (has_Inf.{1} Type))  := sorry --non-trivial
lemma new_lemma_31478 (h0 : not (group num -> false)) : @is_cyclic.{0} num (@classical.by_contradiction'.{1} (group.{0} num) h0)  := sorry --non-trivial
lemma new_lemma_31479 (h0 : topological_space (id (random_gen (has_norm linarith.comp)))) : locally_compact_space (id (random_gen (has_norm linarith.comp))) := sorry --non-trivial
lemma new_lemma_31480 (h0 : topological_space (semiring num)) : topological_space.separable_space (semiring num) := sorry --non-trivial
lemma new_lemma_31481 (h0 : function.extfun (Type 1) ring) : @is_principal_ideal_ring.{1} (has_neg_part.{1} Type) (@function.extfun_app.{3 2} (Type 1) ring.{1} h0 (has_neg_part.{1} Type))  := sorry --non-trivial
lemma new_lemma_31482 (h0 : uniform_space (has_add (has_Inf linarith.comp))) : complete_space (has_add (has_Inf linarith.comp)) := sorry --non-trivial
lemma new_lemma_31483 (h0 : ordered_semiring name) (h1 : fin has_zero.zero) : @monoid.fg.{0} (@floor_semiring.{0} name h0) (@matrix.vec_empty.{0} (monoid.{0} (@floor_semiring.{0} name h0)) h1)  := sorry --non-trivial
lemma new_lemma_31484 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @preconnected_space.{1} (has_add.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 topological_space.{1}) (has_add.{1} Type))  := sorry --non-trivial
lemma new_lemma_31485 (h0 : fin has_zero.zero) : @complete_space.{0} (generalized_boolean_algebra.{0} pos) (@matrix.vec_empty.{0} (uniform_space.{0} (generalized_boolean_algebra.{0} pos)) h0)  := sorry --non-trivial
lemma new_lemma_31486 (h0 : group (has_one (semiring (semiring empty)))) : normalizer_condition (has_one (semiring (semiring empty))) := sorry --non-trivial
lemma new_lemma_31487 (h0 : functor.add_const (topological_space (cancel_monoid unsigned)) environment.implicit_infer_kind) : @irreducible_space.{0} (cancel_monoid.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (cancel_monoid.{0} unsigned)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_31488 (h0 : list (simple_graph linarith.comp)) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_31489 (h0 : functor.add_const (topological_space (canonically_linear_ordered_monoid pos)) (option pos)) : @sequential_space.{0} (canonically_linear_ordered_monoid.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (canonically_linear_ordered_monoid.{0} pos)) (option.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_31490 (h0 : complete_lattice (has_nnnorm char)) : is_compactly_generated (has_nnnorm char) := sorry --non-trivial
lemma new_lemma_31491 (h0 : has_mem.mem (has_emptyc empty) has_emptyc.emptyc) : @complete_lattice.is_Sup_finite_compact.{0} (has_emptyc.{0} empty) (@finset.pi.empty.{1 0} Type complete_lattice.{0} (has_emptyc.{0} empty) h0)  := sorry --non-trivial
lemma new_lemma_31492 (h0 : add_monoid (has_to_string (has_neg_part name))) : add_monoid.fg (has_to_string (has_neg_part name)) := sorry --non-trivial
lemma new_lemma_31493 (h1 : uniform_space (denumerable char)) : complete_space (denumerable char) := sorry --non-trivial
lemma new_lemma_31494 (h0 : function.extfun Type filter) : filter.ne_bot (function.extfun_app h0 (canonically_ordered_comm_semiring pos)) := sorry --non-trivial
lemma new_lemma_31495 (h0 : functor.add_const (topological_space (semigroup unsigned)) Type) : @path_connected_space.{0} (semigroup.{0} unsigned) (@functor.add_const.run.{0 1} (topological_space.{0} (semigroup.{0} unsigned)) Type h0)  := sorry --non-trivial
lemma new_lemma_31496 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @preirreducible_space.{0} (ordered_cancel_add_comm_monoid.{0} ennreal) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (ordered_cancel_add_comm_monoid.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_31497 (h0 : functor.add_const (finset (linear_ordered_cancel_comm_monoid empty)) (option (option unsigned))) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_31498 (h0 : functor.add_const (functor.add_const (ring linarith.comp) Type) pos) : @rank_condition.{0} linarith.comp (@functor.add_const.run.{0 1} (ring.{0} linarith.comp) Type (@functor.add_const.run.{0 0} (functor.add_const.{0 1} (ring.{0} linarith.comp) Type) pos h0))  := sorry --non-trivial
lemma new_lemma_31499 (h0 : not (topological_space (has_norm empty) -> false)) : @totally_disconnected_space.{0} (has_norm.{0} empty) (@classical.by_contradiction'.{1} (topological_space.{0} (has_norm.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_31500 (h0 : function.extfun (finset (Type -> Type)) (has_mem.mem topological_space)) : @irreducible_space.{0} (measurable_space.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) topological_space.{0} (@function.extfun_app.{2 0} (finset.{1} (Type → Type)) (@has_mem.mem.{1 1} (Type → Type) (finset.{1} (Type → Type)) (@finset.has_mem.{1} (Type → Type)) topological_space.{0}) h0 (@has_emptyc.emptyc.{1} (finset.{1} (Type → Type)) (@finset.has_emptyc.{1} (Type → Type))))) (measurable_space.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_31501 (h0 : functor.add_const (uniform_space (option empty)) (semiring congr_arg_kind)) : @separated_space.{0} (option.{0} empty) (@functor.add_const.run.{0 0} (uniform_space.{0} (option.{0} empty)) (semiring.{0} congr_arg_kind) h0)  := sorry --non-trivial
lemma new_lemma_31502 (h0 : ring (comm_group (has_to_string (has_to_string pos)))) : is_principal_ideal_ring (comm_group (has_to_string (has_to_string pos))) := sorry --non-trivial
lemma new_lemma_31503 (h0 : functor.add_const (ordered_add_comm_monoid (simple_graph Type)) (has_add pos)) : @archimedean.{1} (simple_graph.{1} Type) (@functor.add_const.run.{1 0} (ordered_add_comm_monoid.{1} (simple_graph.{1} Type)) (has_add.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_31504 (h1 : set (mul_one_class (normed_field reducibility_hints))) : set.finite h1 := sorry --non-trivial
lemma new_lemma_31505 (h0 : functor.add_const (add_group (pseudo_metric_space pos)) pos) : @is_add_cyclic.{0} (pseudo_metric_space.{0} pos) (@functor.add_const.run.{0 0} (add_group.{0} (pseudo_metric_space.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_31506 (h0 : topological_space (group_with_zero ennreal)) : discrete_topology (group_with_zero ennreal) := sorry --non-trivial
lemma new_lemma_31507 (h0 : function.extfun Type topological_space) : @t0_space.{0} (canonically_ordered_monoid.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (canonically_ordered_monoid.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_31508 (h0 : function.extfun Type topological_space) : @preconnected_space.{0} (normed_comm_ring.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (normed_comm_ring.{0} empty))  := sorry --non-trivial
lemma new_lemma_31509 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @discrete_topology.{0} (canonically_ordered_comm_semiring.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (canonically_ordered_comm_semiring.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_31510 (h0 : complete_lattice (semigroup (has_to_string pos))) : is_atomistic (semigroup (has_to_string pos)) := sorry --non-trivial
lemma new_lemma_31511 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_atomistic.{0} (boolean_algebra.core.{0} pos) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (boolean_algebra.core.{0} pos))  := sorry --non-trivial
lemma new_lemma_31512 (h0 : complete_lattice (comm_ring string.iterator_imp)) : complete_lattice.is_Sup_finite_compact (comm_ring string.iterator_imp) := sorry --non-trivial
lemma new_lemma_31513 (h0 : functor.add_const (topological_space (cancel_monoid environment.implicit_infer_kind)) pos) : @discrete_topology.{0} (cancel_monoid.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (cancel_monoid.{0} environment.implicit_infer_kind)) pos h0)  := sorry --non-trivial
lemma new_lemma_31514 (h0 : fin has_zero.zero) : @topological_space.separable_space.{0} (ring.{0} real) (@matrix.vec_empty.{0} (topological_space.{0} (ring.{0} real)) h0)  := sorry --non-trivial
lemma new_lemma_31515 (h0 : functor.add_const (topological_space (semigroup empty)) empty) : @loc_path_connected_space.{0} (semigroup.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (semigroup.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_31516 (h0 : functor.add_const (uniform_space (semigroup Type)) linarith.comp) : @separated_space.{1} (semigroup.{1} Type) (@functor.add_const.run.{1 0} (uniform_space.{1} (semigroup.{1} Type)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_31517 (h0 : uniform_space (has_top (has_top empty))) : separated_space (has_top (has_top empty)) := sorry --non-trivial
lemma new_lemma_31518 (h0 : complete_lattice (add_group (semiring (semiring (semiring (semiring num)))))) : complete_lattice.is_Sup_finite_compact (add_group (semiring (semiring (semiring (semiring num))))) := sorry --non-trivial
lemma new_lemma_31519 (h0 : ring (denumerable (random_gen reducibility_hints))) : is_domain (denumerable (random_gen reducibility_hints)) := sorry --non-trivial
lemma new_lemma_31520 (h0 : list (semigroup (has_to_string (has_to_string Type)))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_31521 (h0 : topological_space string_imp) (h1 : topological_space (mul_one_class string.iterator_imp)) (h2 : string_imp -> mul_one_class string.iterator_imp) : embedding h2 := sorry --non-trivial
lemma new_lemma_31522 (h0 : functor.add_const (function.extfun Type ordered_comm_monoid) pos) : @has_exists_mul_of_le.{0} (semigroup.{0} pos) (@function.extfun_app.{2 1} Type ordered_comm_monoid.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type ordered_comm_monoid.{0}) pos h0) (semigroup.{0} pos))  := sorry --non-trivial
lemma new_lemma_31523 (h1 : topological_space (has_compl to_additive.value_type)) : totally_disconnected_space (has_compl to_additive.value_type) := sorry --non-trivial
lemma new_lemma_31524 (h0 : topological_space (normed_linear_ordered_group empty)) : t1_space (normed_linear_ordered_group empty) := sorry --non-trivial
lemma new_lemma_31525 (h0 : not (ring (complete_semilattice_Sup num) -> false)) : @is_principal_ideal_ring.{0} (complete_semilattice_Sup.{0} num) (@classical.by_contradiction'.{1} (ring.{0} (complete_semilattice_Sup.{0} num)) h0)  := sorry --non-trivial
lemma new_lemma_31526 (h0 : ordered_comm_monoid (add_comm_monoid (has_add (has_add (has_add environment.implicit_infer_kind))))) : has_exists_mul_of_le (add_comm_monoid (has_add (has_add (has_add environment.implicit_infer_kind)))) := sorry --non-trivial
lemma new_lemma_31527 (h0 : ring enat) : strong_rank_condition enat := sorry --non-trivial
lemma new_lemma_31528 (h0 : uniform_space (measurable_space (has_norm congr_arg_kind))) : separated_space (measurable_space (has_norm congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_31529 (h0 : function.extfun (finset Type) (has_mem.mem (has_top congr_arg_kind))) : @monoid.fg.{0} (has_top.{0} congr_arg_kind) (@finset.pi.empty.{1 0} Type monoid.{0} (has_top.{0} congr_arg_kind) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (has_top.{0} congr_arg_kind)) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_31530 (h0 : topological_space (has_top (has_norm num))) : totally_separated_space (has_top (has_norm num)) := sorry --non-trivial
lemma new_lemma_31531 (h0 : function.extfun (finset (Type -> Type)) (has_mem.mem ring)) : @strong_rank_condition.{0} (@id.{2} Type num) (@function.extfun_app.{2 1} Type ring.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) ring.{0} (@function.extfun_app.{2 0} (finset.{1} (Type → Type)) (@has_mem.mem.{1 1} (Type → Type) (finset.{1} (Type → Type)) (@finset.has_mem.{1} (Type → Type)) ring.{0}) h0 (@has_emptyc.emptyc.{1} (finset.{1} (Type → Type)) (@finset.has_emptyc.{1} (Type → Type))))) (@id.{2} Type num))  := sorry --non-trivial
lemma new_lemma_31532 (h0 : fin has_zero.zero) : @normal_space.{0} (comm_semigroup.{0} real) (@matrix.vec_empty.{0} (topological_space.{0} (comm_semigroup.{0} real)) h0)  := sorry --non-trivial
lemma new_lemma_31533 (h0 : topological_space (sub_neg_monoid (has_pos_part linarith.comp))) : t1_space (sub_neg_monoid (has_pos_part linarith.comp)) := sorry --non-trivial
lemma new_lemma_31534 (h0 : ring (has_append (comm_ring char))) : strong_rank_condition (has_append (comm_ring char)) := sorry --non-trivial
lemma new_lemma_31535 (h0 : function.extfun Type ring) : @is_principal_ideal_ring.{0} (option.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type ring.{0} h0 (option.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_31536 (h0 : set (mul_one_class (mul_one_class std_gen) -> fun_info)) : set.separates_points h0 := sorry --non-trivial
lemma new_lemma_31537 (h0 : uniform_space (linear_order (semiring empty))) : separated_space (linear_order (semiring empty)) := sorry --non-trivial
lemma new_lemma_31538 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_simple_group.{0} (finset.{0} pos) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (finset.{0} pos))  := sorry --non-trivial
lemma new_lemma_31539 (h0 : list (simple_graph (has_add Type))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_31540 (h0 : topological_space (has_inv (random_gen linarith.ineq))) : totally_separated_space (has_inv (random_gen linarith.ineq)) := sorry --non-trivial
lemma new_lemma_31541 (h0 : cancel_comm_monoid_with_zero (ring (has_to_string unsigned))) : unique_factorization_monoid (ring (has_to_string unsigned)) := sorry --non-trivial
lemma new_lemma_31542 (h0 : function.extfun (random_gen fun_info) (fun (x : random_gen fun_info), Prop)) : @infi.{0 1} Prop (@conditionally_complete_lattice.to_has_Inf.{0} Prop (@complete_lattice.to_conditionally_complete_lattice.{0} Prop Prop.complete_lattice)) (random_gen.{0} fun_info) (@function.extfun_app.{1 1} (random_gen.{0} fun_info) (λ (x : random_gen.{0} fun_info), Prop) h0)  := sorry --non-trivial
lemma new_lemma_31543 (h0 : uniform_space (measurable_space.dynkin_system linarith.comp)) : separated_space (measurable_space.dynkin_system linarith.comp) := sorry --non-trivial
lemma new_lemma_31544 (h0 : topological_space (ring (finset (has_add environment.implicit_infer_kind)))) : preirreducible_space (ring (finset (has_add environment.implicit_infer_kind))) := sorry --non-trivial
lemma new_lemma_31545 (h0 : function.extfun Type ring) : @is_domain.{0} (ordered_comm_monoid.{0} pos) (@function.extfun_app.{2 1} Type ring.{0} h0 (ordered_comm_monoid.{0} pos))  := sorry --non-trivial
lemma new_lemma_31546 (h0 : functor.add_const (ring (has_Inf pos)) pos) : @is_principal_ideal_ring.{0} (has_Inf.{0} pos) (@functor.add_const.run.{0 0} (ring.{0} (has_Inf.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_31547 (h0 : has_neg (nondiscrete_normed_field (mul_one_class fun_info))) (h1 : measurable_space (nondiscrete_normed_field (mul_one_class fun_info))) : has_measurable_neg (nondiscrete_normed_field (mul_one_class fun_info)) := sorry --non-trivial
lemma new_lemma_31548 (h0 : topological_space (linear_ordered_semiring (has_norm (has_norm fun_info)))) : totally_separated_space (linear_ordered_semiring (has_norm (has_norm fun_info))) := sorry --non-trivial
lemma new_lemma_31549 (h0 : complete_lattice (left_cancel_semigroup (option unsigned))) : is_atomistic (left_cancel_semigroup (option unsigned)) := sorry --non-trivial
lemma new_lemma_31550 (h0 : add_cancel_monoid ennreal -> add_cancel_monoid ennreal -> Prop) : is_symm (add_cancel_monoid ennreal) h0 := sorry --non-trivial
lemma new_lemma_31551 (h0 : filter (ordered_cancel_add_comm_monoid congr_arg_kind)) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_31552 (h0 : monoid (with_one (has_norm (has_inv (has_inv linarith.comp_source))))) : monoid.fg (with_one (has_norm (has_inv (has_inv linarith.comp_source)))) := sorry --non-trivial
lemma new_lemma_31553 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @archimedean.{0} (complete_distrib_lattice.{0} linarith.comp) (@function.extfun_app.{2 1} Type ordered_add_comm_monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ordered_add_comm_monoid.{0}) (complete_distrib_lattice.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_31554 (h0 : functor.add_const (list (comm_group linarith.comp)) (ring (has_to_string (has_nndist pos)))) : list.nodup (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_31555 (h0 : list (option (option (option (option (option (option (option pos)))))))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_31556 (h0 : functor.add_const (complete_lattice (mul_zero_class num)) congr_arg_kind) : @is_atomistic.{0} (mul_zero_class.{0} num) (@functor.add_const.run.{0 0} (complete_lattice.{0} (mul_zero_class.{0} num)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_31557 (h0 : functor.add_const (filter (semigroup pos)) (has_neg_part Type)) : filter.ne_bot (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_31558 (h0 h1 : multiset (linear_ordered_comm_group_with_zero fun_info)) : multiset.subset h0 h1 := sorry --non-trivial
lemma new_lemma_31559 (h0 : ring (ordered_cancel_add_comm_monoid empty)) : is_principal_ideal_ring (ordered_cancel_add_comm_monoid empty) := sorry --non-trivial
lemma new_lemma_31560 (h0 : ring (bin_tree empty)) : rank_condition (bin_tree empty) := sorry --non-trivial
lemma new_lemma_31561 (h0 : complete_lattice (semigroup (has_to_string (has_neg_part (has_to_string unsigned))))) : is_compactly_generated (semigroup (has_to_string (has_neg_part (has_to_string unsigned)))) := sorry --non-trivial
lemma new_lemma_31562 (h0 : functor.add_const (function.extfun Type ring) linarith.comp) : @is_domain.{0} (ring.{0} pos) (@function.extfun_app.{2 1} Type ring.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type ring.{0}) linarith.comp h0) (ring.{0} pos))  := sorry --non-trivial
lemma new_lemma_31563 (h0 : functor.add_const (list (bin_tree empty)) num) : list.nodup (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_31564 (h0 : ring (ordered_cancel_add_comm_monoid pos)) : is_domain (ordered_cancel_add_comm_monoid pos) := sorry --non-trivial
lemma new_lemma_31565 (h0 : function.extfun Type (functor.add_const (ring (has_Sup congr_arg_kind)))) : @is_domain.{0} (has_Sup.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (ring.{0} (has_Sup.{0} congr_arg_kind)) unsigned (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (ring.{0} (has_Sup.{0} congr_arg_kind))) h0 unsigned))  := sorry --non-trivial
lemma new_lemma_31566 (h0 : complete_lattice (has_neg (has_neg (has_neg (has_neg name))))) : is_compactly_generated (has_neg (has_neg (has_neg (has_neg name)))) := sorry --non-trivial
lemma new_lemma_31567 (h0 : function.extfun Type complete_lattice) : @complete_lattice.is_Sup_finite_compact.{0} (has_top.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (has_top.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_31568 (h0 : functor.add_const (monoid (complete_distrib_lattice linarith.comp)) Type) : @monoid.fg.{0} (complete_distrib_lattice.{0} linarith.comp) (@functor.add_const.run.{0 1} (monoid.{0} (complete_distrib_lattice.{0} linarith.comp)) Type h0)  := sorry --non-trivial
lemma new_lemma_31569 (h0 : filter (add_cancel_monoid environment.implicit_infer_kind)) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_31570 (h0 : topological_space (metric_space (has_norm (has_norm (has_norm empty))))) : locally_compact_space (metric_space (has_norm (has_norm (has_norm empty)))) := sorry --non-trivial
lemma new_lemma_31571 (h0 : prod (has_sub (semiring (semiring unsigned))) (has_sub (semiring (semiring unsigned)))) : id_rel h0 := sorry --non-trivial
lemma new_lemma_31572 (h0 : not (complete_lattice (semi_normed_ring (has_lt linarith.comp_source)) -> false)) : @complete_lattice.is_Sup_finite_compact.{0} (semi_normed_ring.{0} (has_lt.{0} linarith.comp_source)) (@classical.by_contradiction'.{1} (complete_lattice.{0} (semi_normed_ring.{0} (has_lt.{0} linarith.comp_source))) h0)  := sorry --non-trivial
lemma new_lemma_31573 (h0 : filter (generalized_boolean_algebra (has_add name))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_31574 (h0 : add_monoid (measure_theory.measure_space (has_sub unsigned))) : add_monoid.fg (measure_theory.measure_space (has_sub unsigned)) := sorry --non-trivial
lemma new_lemma_31575 (h0 : topological_space (has_top num)) : irreducible_space (has_top num) := sorry --non-trivial
lemma new_lemma_31576 (h0 : function.extfun Type complete_lattice) : @is_compactly_generated.{0} (is_R_or_C.{0} (option.{0} unsigned)) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (is_R_or_C.{0} (option.{0} unsigned)))  := sorry --non-trivial
lemma new_lemma_31577 (h0 : topological_space (option empty)) : normal_space (option empty) := sorry --non-trivial
lemma new_lemma_31578 (h1 : ring char) (h2 : add_group (normed_field (ring.positive_cone char))) : is_add_cyclic (normed_field (ring.positive_cone char)) := sorry --non-trivial
lemma new_lemma_31579 (h0 : functor.add_const (function.extfun Type add_monoid) Type) : @add_monoid.fg.{0} (boolean_algebra.{0} real) (@function.extfun_app.{2 1} Type add_monoid.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type add_monoid.{0}) Type h0) (boolean_algebra.{0} real))  := sorry --non-trivial
lemma new_lemma_31580 (h0 : uniform_space (semiring (semiring unsigned))) : separated_space (semiring (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_31581 (h0 : complete_lattice (has_emptyc (has_norm linarith.comp))) : complete_lattice.is_Sup_finite_compact (has_emptyc (has_norm linarith.comp)) := sorry --non-trivial
lemma new_lemma_31582 (h0 : monoid (measurable_space.dynkin_system (semiring num))) : monoid.fg (measurable_space.dynkin_system (semiring num)) := sorry --non-trivial
lemma new_lemma_31583 (h0 : uniform_space (has_append linarith.ineq)) : complete_space (has_append linarith.ineq) := sorry --non-trivial
lemma new_lemma_31584 (h0 : group (cancel_monoid (finset pos))) : group.fg (cancel_monoid (finset pos)) := sorry --non-trivial
lemma new_lemma_31585 (h0 : function.extfun Type complete_lattice) : @is_compactly_generated.{0} (linear_ordered_add_comm_group.{0} (has_top.{0} linarith.ineq)) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (linear_ordered_add_comm_group.{0} (has_top.{0} linarith.ineq)))  := sorry --non-trivial
lemma new_lemma_31586 (h0 : topological_space (has_neg pos)) : discrete_topology (has_neg pos) := sorry --non-trivial
lemma new_lemma_31587 (h0 : functor.add_const (topological_space (boolean_algebra.core real)) ennreal) : @discrete_topology.{0} (boolean_algebra.core.{0} real) (@functor.add_const.run.{0 0} (topological_space.{0} (boolean_algebra.core.{0} real)) ennreal h0)  := sorry --non-trivial
lemma new_lemma_31588 (h0 : has_mem.mem topological_space has_emptyc.emptyc) : @irreducible_space.{0} (has_top.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) topological_space.{0} h0) (has_top.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_31589 (h0 : functor.add_const (uniform_space (complete_distrib_lattice empty)) empty) : @separated_space.{0} (complete_distrib_lattice.{0} empty) (@functor.add_const.run.{0 0} (uniform_space.{0} (complete_distrib_lattice.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_31590 (h0 : semiring (preorder (option congr_arg_kind))) : is_noetherian_ring (preorder (option congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_31591 (h0 : uniform_space (with_one (has_inv linarith.ineq))) : complete_space (with_one (has_inv linarith.ineq)) := sorry --non-trivial
lemma new_lemma_31592 (h0 : functor.add_const (semiring (ring pos)) (ring linarith.comp)) : @is_noetherian_ring.{0} (ring.{0} pos) (@functor.add_const.run.{0 0} (semiring.{0} (ring.{0} pos)) (ring.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_31593 (h0 : add_group (random_gen (has_nnnorm (has_nnnorm (has_nnnorm (has_nnnorm (has_nnnorm fun_info))))))) : is_add_cyclic (random_gen (has_nnnorm (has_nnnorm (has_nnnorm (has_nnnorm (has_nnnorm fun_info)))))) := sorry --non-trivial
lemma new_lemma_31594 (h0 : functor.add_const (monoid (canonically_ordered_comm_semiring ennreal)) Type) : @monoid.fg.{0} (canonically_ordered_comm_semiring.{0} ennreal) (@functor.add_const.run.{0 1} (monoid.{0} (canonically_ordered_comm_semiring.{0} ennreal)) Type h0)  := sorry --non-trivial
lemma new_lemma_31595 (h0 : finset (measurable_space.dynkin_system unsigned)) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_31596 (h0 : group (has_add (option (option ennreal)))) : is_simple_group (has_add (option (option ennreal))) := sorry --non-trivial
lemma new_lemma_31597 (h0 : fin has_zero.zero) : @is_compactly_generated.{1} (complete_distrib_lattice.{1} Type) (@matrix.vec_empty.{1} (complete_lattice.{1} (complete_distrib_lattice.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_31598 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @monoid.fg.{0} (has_inv.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 monoid.{0}) (has_inv.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_31599 (h0 : functor.add_const (ring (normed_comm_ring unsigned)) linarith.comp) : @strong_rank_condition.{0} (normed_comm_ring.{0} unsigned) (@functor.add_const.run.{0 0} (ring.{0} (normed_comm_ring.{0} unsigned)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_31600 (h0 : ring (uniform_space empty)) : rank_condition (uniform_space empty) := sorry --non-trivial
lemma new_lemma_31601 (h0 : monoid (dlist linarith.ineq)) : monoid.fg (dlist linarith.ineq) := sorry --non-trivial
lemma new_lemma_31602 (h0 : fin has_zero.zero) : @regular_space.{0} (has_pos_part.{0} linarith.comp) (@matrix.vec_empty.{0} (topological_space.{0} (has_pos_part.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_31603 (h0 : functor.add_const (function.extfun Type uniform_space) (finset pos)) : @separated_space.{0} (add_cancel_monoid.{0} pos) (@function.extfun_app.{2 1} Type uniform_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type uniform_space.{0}) (finset.{0} pos) h0) (add_cancel_monoid.{0} pos))  := sorry --non-trivial
lemma new_lemma_31604 (h0 : not (ring (left_cancel_semigroup unsigned) -> false)) : @is_principal_ideal_ring.{0} (left_cancel_semigroup.{0} unsigned) (@classical.by_contradiction'.{1} (ring.{0} (left_cancel_semigroup.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_31605 (h0 : functor.add_const (topological_space (comm_group name)) Type) : @t1_space.{0} (comm_group.{0} name) (@functor.add_const.run.{0 1} (topological_space.{0} (comm_group.{0} name)) Type h0)  := sorry --non-trivial
lemma new_lemma_31606 (h0 : topological_space (bin_tree unsigned)) : t0_space (bin_tree unsigned) := sorry --non-trivial
lemma new_lemma_31607 (h0 : ordered_comm_monoid (boolean_algebra.core (has_add name))) : has_exists_mul_of_le (boolean_algebra.core (has_add name)) := sorry --non-trivial
lemma new_lemma_31608 (h0 : functor.add_const (function.extfun Type topological_space) linarith.comp) : @irreducible_space.{0} (normed_comm_ring.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) linarith.comp h0) (normed_comm_ring.{0} pos))  := sorry --non-trivial
lemma new_lemma_31609 (h0 : add_monoid (has_nndist (has_neg Type))) : add_monoid.fg (has_nndist (has_neg Type)) := sorry --non-trivial
lemma new_lemma_31610 (h0 : not (function.extfun (Type -> Type) (function.extfun Type) -> false)) : @group.fg.{0} (complete_semilattice_Sup.{0} unsigned) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) (@classical.by_contradiction'.{2} (function.extfun.{2 2} (Type → Type) (function.extfun.{2 1} Type)) h0) group.{0}) (complete_semilattice_Sup.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_31611 (h0 : topological_space (add_cancel_monoid (has_add (has_add pos)))) : t0_space (add_cancel_monoid (has_add (has_add pos))) := sorry --non-trivial
lemma new_lemma_31612 (h0 : list (boolean_algebra.core Type)) : palindrome h0 := sorry --non-trivial
lemma new_lemma_31613 (h1 : filter (with_zero char)) : filter.ne_bot h1 := sorry --non-trivial
lemma new_lemma_31614 (h0 : functor.add_const (ring (left_cancel_semigroup unsigned)) empty) : @is_principal_ideal_ring.{0} (left_cancel_semigroup.{0} unsigned) (@functor.add_const.run.{0 0} (ring.{0} (left_cancel_semigroup.{0} unsigned)) empty h0)  := sorry --non-trivial
lemma new_lemma_31615 (h0 : complete_lattice (with_one (has_norm (semiring congr_arg_kind)))) : is_atomistic (with_one (has_norm (semiring congr_arg_kind))) := sorry --non-trivial
lemma new_lemma_31616 (h0 : functor.add_const (function.extfun Type group) environment.implicit_infer_kind) : @is_cyclic.{0} (has_zero.{0} linarith.comp) (@function.extfun_app.{2 1} Type group.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type group.{0}) environment.implicit_infer_kind h0) (has_zero.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_31617 (h0 : topological_space (has_bot (option num))) : path_connected_space (has_bot (option num)) := sorry --non-trivial
lemma new_lemma_31618 (h0 : uniform_space (cancel_monoid (boolean_algebra (has_to_string Type)))) : separated_space (cancel_monoid (boolean_algebra (has_to_string Type))) := sorry --non-trivial
lemma new_lemma_31619 (h0 : ring (has_nndist (comm_group (comm_group linarith.comp)))) : strong_rank_condition (has_nndist (comm_group (comm_group linarith.comp))) := sorry --non-trivial
lemma new_lemma_31620 (h0 : complete_lattice (semigroup (add_cancel_monoid (comm_group (comm_group ennreal))))) : is_atomistic (semigroup (add_cancel_monoid (comm_group (comm_group ennreal)))) := sorry --non-trivial
lemma new_lemma_31621 (h0 : ring (linear_order unsigned)) : strong_rank_condition (linear_order unsigned) := sorry --non-trivial
lemma new_lemma_31622 (h0 : not (monoid (with_one num) -> false)) : @monoid.fg.{0} (with_one.{0} num) (@classical.by_contradiction'.{1} (monoid.{0} (with_one.{0} num)) h0)  := sorry --non-trivial
lemma new_lemma_31623 (h0 : measurable_space (nondiscrete_normed_field environment.projection_info)) (h1 : filter (nondiscrete_normed_field environment.projection_info)) : filter.is_measurably_generated h1 := sorry --non-trivial
lemma new_lemma_31624 (h0 : list (canonically_ordered_comm_semiring (option empty))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_31625 (h0 : function.extfun Type group) : @normalizer_condition.{0} (add_group.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type group.{0} h0 (add_group.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_31626 (h0 : complete_lattice (add_group congr_arg_kind)) : is_atomistic (add_group congr_arg_kind) := sorry --non-trivial
lemma new_lemma_31627 (h0 : functor.add_const (topological_space (add_group empty)) unsigned) : @topological_space.separable_space.{0} (add_group.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (add_group.{0} empty)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_31628 (h0 : topological_space (finset num)) : t1_space (finset num) := sorry --non-trivial
lemma new_lemma_31629 (h0 : uniform_space (with_zero linarith.comp_source)) (h1 : filter (with_zero linarith.comp_source)) : cauchy h1 := sorry --non-trivial
lemma new_lemma_31630 (h0 : uniform_space (has_nndist (option empty))) : complete_space (has_nndist (option empty)) := sorry --non-trivial
lemma new_lemma_31631 (h0 : function.extfun (finset (Type -> Type)) (has_mem.mem monoid)) : @monoid.fg.{0} (linear_ordered_ring.{0} fun_info) (@function.extfun_app.{2 1} Type monoid.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) monoid.{0} (@function.extfun_app.{2 0} (finset.{1} (Type → Type)) (@has_mem.mem.{1 1} (Type → Type) (finset.{1} (Type → Type)) (@finset.has_mem.{1} (Type → Type)) monoid.{0}) h0 (@has_emptyc.emptyc.{1} (finset.{1} (Type → Type)) (@finset.has_emptyc.{1} (Type → Type))))) (linear_ordered_ring.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_31632 (h0 : not (topological_space (add_right_cancel_monoid unsigned) -> false)) : @totally_disconnected_space.{0} (add_right_cancel_monoid.{0} unsigned) (@classical.by_contradiction'.{1} (topological_space.{0} (add_right_cancel_monoid.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_31633 (h0 : functor.add_const (add_group (ordered_comm_ring Type)) name) : @is_add_cyclic.{1} (ordered_comm_ring.{1} Type) (@functor.add_const.run.{1 0} (add_group.{1} (ordered_comm_ring.{1} Type)) name h0)  := sorry --non-trivial
lemma new_lemma_31634 (h0 : topological_space (canonically_ordered_comm_semiring (has_add unsigned))) : discrete_topology (canonically_ordered_comm_semiring (has_add unsigned)) := sorry --non-trivial
lemma new_lemma_31635 (h0 : functor.add_const (monoid (semigroup pos)) (has_neg linarith.comp)) : @monoid.fg.{0} (semigroup.{0} pos) (@functor.add_const.run.{0 0} (monoid.{0} (semigroup.{0} pos)) (has_neg.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_31636 (h0 : functor.add_const (functor.add_const Prop pos) pos) : functor.add_const.run (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_31637 (h0 : ring (linear_ordered_semiring (semiring (semiring (semiring (semiring num)))))) : strong_rank_condition (linear_ordered_semiring (semiring (semiring (semiring (semiring num))))) := sorry --non-trivial
lemma new_lemma_31638 (h0 : function.extfun Type topological_space) : @irreducible_space.{0} (boolean_algebra.core.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (boolean_algebra.core.{0} empty))  := sorry --non-trivial
lemma new_lemma_31639 (h0 : topological_space (random_gen (has_norm (has_top linarith.comp)))) : normal_space (random_gen (has_norm (has_top linarith.comp))) := sorry --non-trivial
lemma new_lemma_31640 (h0 : not (ring (has_star congr_arg_kind) -> false)) : @rank_condition.{0} (has_star.{0} congr_arg_kind) (@classical.by_contradiction'.{1} (ring.{0} (has_star.{0} congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_31641 (h0 : function.extfun Type topological_space) : @preirreducible_space.{0} (has_neg_part.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_neg_part.{0} name))  := sorry --non-trivial
lemma new_lemma_31642 (h0 : complete_lattice (encodable (has_inv (has_nnnorm fun_info)))) : complete_lattice.is_Sup_finite_compact (encodable (has_inv (has_nnnorm fun_info))) := sorry --non-trivial
lemma new_lemma_31643 (h0 : complete_lattice (div_inv_monoid to_additive.value_type)) : complete_lattice.is_Sup_finite_compact (div_inv_monoid to_additive.value_type) := sorry --non-trivial
lemma new_lemma_31644 (h0 : ring (has_top (has_norm congr_arg_kind))) : strong_rank_condition (has_top (has_norm congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_31645 (h0 : function.extfun (finset (Type -> Type)) (has_mem.mem topological_space)) : @irreducible_space.{0} (linear_ordered_add_comm_group.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) topological_space.{0} (@function.extfun_app.{2 0} (finset.{1} (Type → Type)) (@has_mem.mem.{1 1} (Type → Type) (finset.{1} (Type → Type)) (@finset.has_mem.{1} (Type → Type)) topological_space.{0}) h0 (@has_emptyc.emptyc.{1} (finset.{1} (Type → Type)) (@finset.has_emptyc.{1} (Type → Type))))) (linear_ordered_add_comm_group.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_31646 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @totally_disconnected_space.{0} (has_add.{0} (option.{0} (option.{0} pos))) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_add.{0} (option.{0} (option.{0} pos))))  := sorry --non-trivial
lemma new_lemma_31647 (h0 : prod (complete_distrib_lattice (has_scalar Type real)) (complete_distrib_lattice (has_scalar Type real))) : id_rel h0 := sorry --non-trivial
lemma new_lemma_31648 (h0 : functor.add_const (topological_space (generalized_boolean_algebra real)) real) : @t1_space.{0} (generalized_boolean_algebra.{0} real) (@functor.add_const.run.{0 0} (topological_space.{0} (generalized_boolean_algebra.{0} real)) real h0)  := sorry --non-trivial
lemma new_lemma_31649 (h0 : function.extfun nat fin) : @is_domain.{0} (has_add.{0} (has_add.{0} linarith.comp)) (@matrix.vec_empty.{0} (ring.{0} (has_add.{0} (has_add.{0} linarith.comp))) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_31650 (h0 : group (has_nndist (add_comm_monoid pos))) : group.fg (has_nndist (add_comm_monoid pos)) := sorry --non-trivial
lemma new_lemma_31651 (h0 : ring (has_to_string (option (option (option (option unsigned)))))) : rank_condition (has_to_string (option (option (option (option unsigned))))) := sorry --non-trivial
lemma new_lemma_31652 (h0 : function.extfun Type (prod (left_cancel_monoid (semiring congr_arg_kind)))) : id_rel (function.extfun_app h0 (left_cancel_monoid (semiring congr_arg_kind))) := sorry --non-trivial
lemma new_lemma_31653 (h1 : topological_space (has_top (has_norm congr_arg_kind))) : locally_compact_space (has_top (has_norm congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_31654 (h0 : list (linear_ordered_comm_group (option num))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_31655 (h0 : functor.add_const (topological_space empty) num) : locally_compact_space empty := sorry --non-trivial
lemma new_lemma_31656 (h0 : functor.add_const (uniform_space (free_add_monoid empty)) (semiring (semiring (semiring (semiring empty))))) : @complete_space.{0} (free_add_monoid.{0} empty) (@functor.add_const.run.{0 0} (uniform_space.{0} (free_add_monoid.{0} empty)) (semiring.{0} (semiring.{0} (semiring.{0} (semiring.{0} empty)))) h0)  := sorry --non-trivial
lemma new_lemma_31657 (h0 : topological_space (preorder empty)) : discrete_topology (preorder empty) := sorry --non-trivial
lemma new_lemma_31658 (h0 : functor.add_const (add_monoid (finset name)) environment.implicit_infer_kind) : @add_monoid.fg.{0} (finset.{0} name) (@functor.add_const.run.{0 0} (add_monoid.{0} (finset.{0} name)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_31659 (h0 : not (ring (distrib char) -> false)) : @rank_condition.{0} (distrib.{0} char) (@classical.by_contradiction'.{1} (ring.{0} (distrib.{0} char)) h0)  := sorry --non-trivial
lemma new_lemma_31660 (h0 : not (list (option num) -> false)) : list.nodup (classical.by_contradiction' h0) := sorry --non-trivial
lemma new_lemma_31661 (h0 : topological_space (distrib_lattice (has_inv (random_gen to_additive.value_type)))) : locally_compact_space (distrib_lattice (has_inv (random_gen to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_31662 (h0 : function.extfun Type list) : palindrome (function.extfun_app h0 (linear_ordered_field congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_31663 (h0 : topological_space (normed_group (semiring (semiring unsigned)))) : normal_space (normed_group (semiring (semiring unsigned))) := sorry --non-trivial
lemma new_lemma_31664 (h2 : ring (semi_normed_ring linarith.ineq)) : is_domain (semi_normed_ring linarith.ineq) := sorry --non-trivial
lemma new_lemma_31665 (h0 : not (function.extfun Type ring -> false)) : @is_domain.{0} (has_ssubset.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type ring.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type ring.{0}) h0) (has_ssubset.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_31666 (h0 : topological_space (linear_ordered_comm_group pos)) : t1_space (linear_ordered_comm_group pos) := sorry --non-trivial
lemma new_lemma_31667 (h0 : topological_space (has_zero ennreal)) : irreducible_space (has_zero ennreal) := sorry --non-trivial
lemma new_lemma_31668 (h0 : group (has_compl linarith.comp_source)) : group.fg (has_compl linarith.comp_source) := sorry --non-trivial
lemma new_lemma_31669 (h2 : preorder fun_info) (h3 : set fun_info) : set.is_pwo h3 := sorry --non-trivial
lemma new_lemma_31670 (h0 : function.extfun Type (prod (has_one unsigned))) : id_rel (function.extfun_app h0 (has_one unsigned)) := sorry --non-trivial
lemma new_lemma_31671 (h0 : ring (uniform_space (distrib fun_info))) : rank_condition (uniform_space (distrib fun_info)) := sorry --non-trivial
lemma new_lemma_31672 (h0 : ordered_add_comm_monoid (has_nndist (option (finset unsigned)))) : archimedean (has_nndist (option (finset unsigned))) := sorry --non-trivial
lemma new_lemma_31673 (h0 : topological_space (has_Inf (ring (has_neg (ordered_ring (has_Inf name)))))) : preconnected_space (has_Inf (ring (has_neg (ordered_ring (has_Inf name))))) := sorry --non-trivial
lemma new_lemma_31674 (h0 : not (group (random_gen fun_info) -> false)) : @group.fg.{0} (random_gen.{0} fun_info) (@classical.by_contradiction'.{1} (group.{0} (random_gen.{0} fun_info)) h0)  := sorry --non-trivial
lemma new_lemma_31675 (h0 : group (boolean_algebra.core (option pos))) : group.fg (boolean_algebra.core (option pos)) := sorry --non-trivial
lemma new_lemma_31676 (h0 : uniform_space (add_cancel_monoid (has_add (finset (normed_comm_ring Type))))) : complete_space (add_cancel_monoid (has_add (finset (normed_comm_ring Type)))) := sorry --non-trivial
lemma new_lemma_31677 (h0 : finset (comm_group (has_add (finset name)))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_31678 (h0 : list (has_union num)) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_31679 (h0 : semiring (measurable_space.dynkin_system (semiring unsigned))) : is_noetherian_ring (measurable_space.dynkin_system (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_31680 (h0 : cancel_comm_monoid_with_zero (add_cancel_monoid (has_pos_part (has_neg (has_Inf pos))))) : unique_factorization_monoid (add_cancel_monoid (has_pos_part (has_neg (has_Inf pos)))) := sorry --non-trivial
lemma new_lemma_31681 (h0 : functor.add_const (topological_space (has_add Type)) Type) : @t1_space.{1} (has_add.{1} Type) (@functor.add_const.run.{1 1} (topological_space.{1} (has_add.{1} Type)) Type h0)  := sorry --non-trivial
lemma new_lemma_31682 (h0 : topological_space (plift (semiring unsigned))) : path_connected_space (plift (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_31683 (h0 h1 : function.extfun (Type -> Type) (function.extfun Type)) : @Inf_convergence_class.{0} (linear_ordered_add_comm_group.{0} linarith.ineq) (@function.extfun_app.{2 1} Type preorder.{0} (@id.{2} (function.extfun.{2 1} Type preorder.{0}) (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 preorder.{0})) (linear_ordered_add_comm_group.{0} linarith.ineq)) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h1 topological_space.{0}) (linear_ordered_add_comm_group.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_31684 (h0 : group (non_assoc_semiring empty)) : group.fg (non_assoc_semiring empty) := sorry --non-trivial
lemma new_lemma_31685 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @irreducible_space.{0} (has_bot.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_bot.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_31686 (h0 : ring (plift (has_norm num))) : rank_condition (plift (has_norm num)) := sorry --non-trivial
lemma new_lemma_31687 (h0 : uniform_space (has_edist congr_arg_kind)) : separated_space (has_edist congr_arg_kind) := sorry --non-trivial
lemma new_lemma_31688 (h3 : ring (with_one char)) : rank_condition (with_one char) := sorry --non-trivial
lemma new_lemma_31689 (h0 : topological_space (has_add (has_Inf (has_Inf real)))) : path_connected_space (has_add (has_Inf (has_Inf real))) := sorry --non-trivial
lemma new_lemma_31690 (h0 : ring (normed_field (random_gen linarith.ineq))) : strong_rank_condition (normed_field (random_gen linarith.ineq)) := sorry --non-trivial
lemma new_lemma_31691 (h0 : fin has_zero.zero) : @is_add_cyclic.{0} (has_pos_part.{0} pos) (@matrix.vec_empty.{0} (add_group.{0} (has_pos_part.{0} pos)) (@function.extfun_app.{1 1} nat fin (@matrix.vec_empty.{0} (function.extfun.{1 1} nat fin) h0) (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_31692 (h0 : complete_lattice (has_neg (has_add pos))) : complete_lattice.is_Sup_finite_compact (has_neg (has_add pos)) := sorry --non-trivial
lemma new_lemma_31693 (h0 : ring (distrib_lattice fun_info)) : strong_rank_condition (distrib_lattice fun_info) := sorry --non-trivial
lemma new_lemma_31694 (h0 : has_mem.mem (has_norm linarith.comp_source) has_emptyc.emptyc) : @complete_lattice.is_Sup_finite_compact.{0} (has_norm.{0} linarith.comp_source) (@finset.pi.empty.{1 0} Type complete_lattice.{0} (has_norm.{0} linarith.comp_source) h0)  := sorry --non-trivial
lemma new_lemma_31695 (h0 : functor.add_const (function.extfun Type topological_space) environment.implicit_infer_kind) : @locally_compact_space.{0} (has_zero.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) environment.implicit_infer_kind h0) (has_zero.{0} pos))  := sorry --non-trivial
lemma new_lemma_31696 (h0 : topological_space (has_pos_part name)) : preconnected_space (has_pos_part name) := sorry --non-trivial
lemma new_lemma_31697 (h0 : function.extfun Type topological_space) : @totally_disconnected_space.{0} (has_nndist.{0} real) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_nndist.{0} real))  := sorry --non-trivial
lemma new_lemma_31698 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : filter.ne_bot (function.extfun_app (function.extfun_app h0 filter) (add_comm_monoid Type)) := sorry --non-trivial
lemma new_lemma_31699 (h0 : topological_space (boolean_algebra.core (has_add unsigned))) : topological_space.separable_space (boolean_algebra.core (has_add unsigned)) := sorry --non-trivial
lemma new_lemma_31700 (h0 : ring (has_top (comm_ring fun_info))) : is_domain (has_top (comm_ring fun_info)) := sorry --non-trivial
lemma new_lemma_31701 (h0 : set (has_div to_additive.value_type)) : set.subsingleton h0 := sorry --non-trivial
lemma new_lemma_31702 (h0 : functor.add_const (function.extfun Type complete_lattice) pos) : @is_compactly_generated.{0} (has_zero.{0} linarith.comp) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type complete_lattice.{0}) pos h0) (has_zero.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_31703 (h1 : measurable_space std_gen) (h2 : set std_gen) : measurable_set h2 := sorry --non-trivial
lemma new_lemma_31704 (h0 : topological_space (distrib (has_ssubset linarith.ineq))) : path_connected_space (distrib (has_ssubset linarith.ineq)) := sorry --non-trivial
lemma new_lemma_31705 (h0 : measurable_space enat) (h1 : complete_lattice (measure_theory.measure enat)) : is_compactly_generated (measure_theory.measure enat) := sorry --non-trivial
lemma new_lemma_31706 (h0 : functor.add_const (function.extfun Type uniform_space) environment.implicit_infer_kind) : @complete_space.{0} (semigroup.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type uniform_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type uniform_space.{0}) environment.implicit_infer_kind h0) (semigroup.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_31707 (h0 : topological_space (has_add (monoid_with_zero pos))) : preirreducible_space (has_add (monoid_with_zero pos)) := sorry --non-trivial
lemma new_lemma_31708 (h0 : topological_space (ring (ring pos))) : totally_separated_space (ring (ring pos)) := sorry --non-trivial
lemma new_lemma_31709 (h0 : uniform_space (simple_graph (ring (has_pos_part pos)))) : separated_space (simple_graph (ring (has_pos_part pos))) := sorry --non-trivial
lemma new_lemma_31710 (h0 : complete_lattice (normed_group empty)) : complete_lattice.is_Sup_finite_compact (normed_group empty) := sorry --non-trivial
lemma new_lemma_31711 (h1 : set (std_gen -> enat)) : set.separates_points h1 := sorry --non-trivial
lemma new_lemma_31712 (h0 : topological_space (has_bot (has_Inf linarith.comp))) : preirreducible_space (has_bot (has_Inf linarith.comp)) := sorry --non-trivial
lemma new_lemma_31713 (h0 : ring (add_comm_monoid (semigroup Type))) : rank_condition (add_comm_monoid (semigroup Type)) := sorry --non-trivial
lemma new_lemma_31714 (h0 : functor.add_const (group (mul_zero_class pos)) (complete_distrib_lattice Type)) : @normalizer_condition.{0} (mul_zero_class.{0} pos) (@functor.add_const.run.{0 1} (group.{0} (mul_zero_class.{0} pos)) (complete_distrib_lattice.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_31715 (h0 : filter (topological_space (denumerable linarith.ineq))) : @totally_disconnected_space.{0} (denumerable.{0} linarith.ineq) (@filter.Limsup.{0} (topological_space.{0} (denumerable.{0} linarith.ineq)) (@complete_lattice.to_conditionally_complete_lattice.{0} (topological_space.{0} (denumerable.{0} linarith.ineq)) (@topological_space.complete_lattice.{0} (denumerable.{0} linarith.ineq))) h0)  := sorry --non-trivial
lemma new_lemma_31716 (h0 : functor.add_const (group (preorder congr_arg_kind)) unsigned) : @is_cyclic.{0} (preorder.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (group.{0} (preorder.{0} congr_arg_kind)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_31717 (h0 : not (topological_space (id empty) -> false)) : @totally_separated_space.{0} (@id.{2} Type empty) (@classical.by_contradiction'.{1} (topological_space.{0} (@id.{2} Type empty)) h0)  := sorry --non-trivial
lemma new_lemma_31718 (h0 : functor.add_const (topological_space (boolean_algebra.core name)) linarith.comp) : @normal_space.{0} (boolean_algebra.core.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (boolean_algebra.core.{0} name)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_31719 (h0 : cancel_comm_monoid_with_zero (has_zero name)) : unique_factorization_monoid (has_zero name) := sorry --non-trivial
lemma new_lemma_31720 (h0 : not (topological_space (measurable_space (has_norm linarith.ineq)) -> false)) : @irreducible_space.{0} (measurable_space.{0} (has_norm.{0} linarith.ineq)) (@classical.by_contradiction'.{1} (topological_space.{0} (measurable_space.{0} (has_norm.{0} linarith.ineq))) h0)  := sorry --non-trivial
lemma new_lemma_31721 (h0 : ordered_comm_monoid (has_add environment.implicit_infer_kind)) : has_exists_mul_of_le (has_add environment.implicit_infer_kind) := sorry --non-trivial
lemma new_lemma_31722 (h0 : topological_space (add_comm_monoid (has_to_string (comm_group Type)))) : loc_path_connected_space (add_comm_monoid (has_to_string (comm_group Type))) := sorry --non-trivial
lemma new_lemma_31723 (h0 : function.extfun Type group) : @is_cyclic.{0} (group_with_zero.{0} num) (@function.extfun_app.{2 1} Type group.{0} h0 (group_with_zero.{0} num))  := sorry --non-trivial
lemma new_lemma_31724 (h0 : not (ring (has_norm unsigned) -> false)) : @rank_condition.{0} (has_norm.{0} unsigned) (@classical.by_contradiction'.{1} (ring.{0} (has_norm.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_31725 (h0 : functor.add_const (finset (linear_ordered_field unsigned)) unsigned) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_31726 (h0 : functor.add_const (topological_space (has_dist unsigned)) num) : @preirreducible_space.{0} (has_dist.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (has_dist.{0} unsigned)) num h0)  := sorry --non-trivial
lemma new_lemma_31727 (h1 : complete_lattice (topological_space (has_nnnorm to_additive.value_type))) : is_compactly_generated (topological_space (has_nnnorm to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_31728 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @sequential_space.{1} (has_pos_part.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 topological_space.{1}) (has_pos_part.{1} Type))  := sorry --non-trivial
lemma new_lemma_31729 (h1 : ring char) : rank_condition char := sorry --non-trivial
lemma new_lemma_31730 (h0 : topological_space (normed_comm_ring (has_neg_part name))) : preconnected_space (normed_comm_ring (has_neg_part name)) := sorry --non-trivial
lemma new_lemma_31731 (h0 : topological_space (ordered_comm_monoid (has_Inf real))) : path_connected_space (ordered_comm_monoid (has_Inf real)) := sorry --non-trivial
lemma new_lemma_31732 (h0 : list (has_top (has_ssubset linarith.ineq))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_31733 (h0 : fin has_zero.zero) : @sequential_space.{0} (sub_neg_monoid.{0} pos) (@matrix.vec_empty.{0} (topological_space.{0} (sub_neg_monoid.{0} pos)) (@matrix.vec_empty.{0} (fin (@has_zero.zero.{0} nat nat.has_zero)) h0))  := sorry --non-trivial
lemma new_lemma_31734 (h0 : function.extfun Type (functor.add_const (topological_space (add_cancel_comm_monoid empty)))) : @normal_space.{0} (add_cancel_comm_monoid.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (add_cancel_comm_monoid.{0} empty)) empty (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (topological_space.{0} (add_cancel_comm_monoid.{0} empty))) h0 empty))  := sorry --non-trivial
lemma new_lemma_31735 (h0 : function.extfun Type (functor.add_const (topological_space (simple_graph name)))) : @preirreducible_space.{0} (simple_graph.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (simple_graph.{0} name)) pos (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (topological_space.{0} (simple_graph.{0} name))) h0 pos))  := sorry --non-trivial
lemma new_lemma_31736 (h0 : functor.add_const (ring (semigroup unsigned)) Type) : @rank_condition.{0} (semigroup.{0} unsigned) (@functor.add_const.run.{0 1} (ring.{0} (semigroup.{0} unsigned)) Type h0)  := sorry --non-trivial
lemma new_lemma_31737 (h2 : topological_space (with_one num)) : path_connected_space (with_one num) := sorry --non-trivial
lemma new_lemma_31738 (h0 : functor.add_const (function.extfun Type topological_space) pos) : @sequential_space.{0} (semigroup.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) pos h0) (semigroup.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_31739 (h0 : ring (linear_ordered_semiring (semiring (semiring congr_arg_kind)))) : is_principal_ideal_ring (linear_ordered_semiring (semiring (semiring congr_arg_kind))) := sorry --non-trivial
lemma new_lemma_31740 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_atomistic.{0} (sub_neg_monoid.{0} real) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (sub_neg_monoid.{0} real))  := sorry --non-trivial
lemma new_lemma_31741 (h0 : not (uniform_space (random_gen num) -> false)) : @separated_space.{0} (random_gen.{0} num) (@classical.by_contradiction'.{1} (uniform_space.{0} (random_gen.{0} num)) h0)  := sorry --non-trivial
lemma new_lemma_31742 (h0 : fin has_zero.zero) : @archimedean.{0} (sub_neg_monoid.{0} pos) (@matrix.vec_empty.{0} (ordered_add_comm_monoid.{0} (sub_neg_monoid.{0} pos)) (@matrix.vec_empty.{0} (fin (@has_zero.zero.{0} nat nat.has_zero)) h0))  := sorry --non-trivial
lemma new_lemma_31743 (h0 : monoid (has_pos_part (has_Inf real))) : monoid.fg (has_pos_part (has_Inf real)) := sorry --non-trivial
lemma new_lemma_31744 (h2 : topological_space char) (h3 : preorder char) : order_closed_topology char := sorry --non-trivial
lemma new_lemma_31745 (h0 : functor.add_const (list (has_nndist name)) linarith.comp) : palindrome (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_31746 (h0 : add_group (with_bot fun_info)) : is_add_cyclic (with_bot fun_info) := sorry --non-trivial
lemma new_lemma_31747 (h0 : functor.add_const (topological_space (complete_distrib_lattice name)) Type) : @normal_space.{0} (complete_distrib_lattice.{0} name) (@functor.add_const.run.{0 1} (topological_space.{0} (complete_distrib_lattice.{0} name)) Type h0)  := sorry --non-trivial
lemma new_lemma_31748 (h2 : has_nnnorm linarith.comp_source -> has_nnnorm linarith.comp_source -> Prop) : is_strict_total_order' (has_nnnorm linarith.comp_source) h2 := sorry --non-trivial
lemma new_lemma_31749 (h0 : has_mem.mem (normed_group (has_norm linarith.comp_source)) has_emptyc.emptyc) : @irreducible_space.{0} (normed_group.{0} (has_norm.{0} linarith.comp_source)) (@finset.pi.empty.{1 0} Type topological_space.{0} (normed_group.{0} (has_norm.{0} linarith.comp_source)) h0)  := sorry --non-trivial
lemma new_lemma_31750 (h0 : functor.add_const (topological_space (ring linarith.comp)) name) : @totally_disconnected_space.{0} (ring.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (ring.{0} linarith.comp)) name h0)  := sorry --non-trivial
lemma new_lemma_31751 (h0 : not (semiring (option unsigned) -> false)) : @is_noetherian_ring.{0} (option.{0} unsigned) (@classical.by_contradiction'.{1} (semiring.{0} (option.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_31752 (h0 : list (topological_space (linear_ordered_add_comm_group (has_nnnorm fun_info)))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_31753 (h0 : complete_lattice (has_top string_imp)) : is_compactly_generated (has_top string_imp) := sorry --non-trivial
lemma new_lemma_31754 (h0 : function.extfun (finset (Type -> Type)) (has_mem.mem complete_lattice)) : @complete_lattice.is_Sup_finite_compact.{0} (has_top.{0} empty) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) complete_lattice.{0} (@function.extfun_app.{2 0} (finset.{1} (Type → Type)) (@has_mem.mem.{1 1} (Type → Type) (finset.{1} (Type → Type)) (@finset.has_mem.{1} (Type → Type)) complete_lattice.{0}) h0 (@has_emptyc.emptyc.{1} (finset.{1} (Type → Type)) (@finset.has_emptyc.{1} (Type → Type))))) (has_top.{0} empty))  := sorry --non-trivial
lemma new_lemma_31755 (h0 : ring (ring (option unsigned))) : strong_rank_condition (ring (option unsigned)) := sorry --non-trivial
lemma new_lemma_31756 (h0 : functor.comp (functor.comp topological_space boolean_algebra.core) with_top nnreal) : @sequential_space.{0} (boolean_algebra.core.{0} ennreal) (@functor.comp.run.{0 0 0} topological_space.{0} boolean_algebra.core.{0} ennreal (@functor.comp.run.{0 0 0} (functor.comp.{0 0 0} topological_space.{0} boolean_algebra.core.{0}) with_top.{0} nnreal h0))  := sorry --non-trivial
lemma new_lemma_31757 (h0 : has_mem.mem (normed_group empty) has_emptyc.emptyc) : @totally_separated_space.{0} (normed_group.{0} empty) (@finset.pi.empty.{1 0} Type topological_space.{0} (normed_group.{0} empty) h0)  := sorry --non-trivial
lemma new_lemma_31758 (h0 : functor.comp topological_space has_add Type) : @locally_compact_space.{1} (has_add.{1} Type) (@functor.comp.run.{1 1 1} topological_space.{1} has_add.{1} Type h0)  := sorry --non-trivial
lemma new_lemma_31759 (h0 : ordered_add_comm_monoid (normed_group empty)) : archimedean (normed_group empty) := sorry --non-trivial
lemma new_lemma_31760 (h0 : topological_space (canonically_ordered_comm_semiring (ring (ring linarith.comp)))) : preirreducible_space (canonically_ordered_comm_semiring (ring (ring linarith.comp))) := sorry --non-trivial
lemma new_lemma_31761 (h0 : not (complete_lattice (add_monoid (comm_ring linarith.ineq)) -> false)) : @complete_lattice.is_Sup_finite_compact.{0} (add_monoid.{0} (comm_ring.{0} linarith.ineq)) (@classical.by_contradiction'.{1} (complete_lattice.{0} (add_monoid.{0} (comm_ring.{0} linarith.ineq))) h0)  := sorry --non-trivial
lemma new_lemma_31762 (h0 : topological_space (has_neg_part (option unsigned))) : sequential_space (has_neg_part (option unsigned)) := sorry --non-trivial
lemma new_lemma_31763 (h0 : filter (add_cancel_monoid ennreal)) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_31764 (h1 : not (complete_lattice (random_gen linarith.ineq) -> false)) : @complete_lattice.is_Sup_finite_compact.{0} (random_gen.{0} linarith.ineq) (@classical.by_contradiction'.{1} (complete_lattice.{0} (random_gen.{0} linarith.ineq)) h1)  := sorry --non-trivial
lemma new_lemma_31765 (h0 : not (uniform_space (has_norm (random_gen congr_arg_kind)) -> false)) : @separated_space.{0} (has_norm.{0} (random_gen.{0} congr_arg_kind)) (@classical.by_contradiction'.{1} (uniform_space.{0} (has_norm.{0} (random_gen.{0} congr_arg_kind))) h0)  := sorry --non-trivial
lemma new_lemma_31766 (h0 : not (topological_space (has_norm linarith.ineq) -> false)) : @irreducible_space.{0} (has_norm.{0} linarith.ineq) (@classical.by_contradiction'.{1} (topological_space.{0} (has_norm.{0} linarith.ineq)) h0)  := sorry --non-trivial
lemma new_lemma_31767 (h0 : ring (has_inv (comm_ring fun_info))) : rank_condition (has_inv (comm_ring fun_info)) := sorry --non-trivial
lemma new_lemma_31768 (h0 : ring (add_left_cancel_monoid (has_nnnorm fun_info))) : rank_condition (add_left_cancel_monoid (has_nnnorm fun_info)) := sorry --non-trivial
lemma new_lemma_31769 (h0 : functor.add_const (complete_lattice (has_to_string unsigned)) name) : @is_atomistic.{0} (has_to_string.{0} unsigned) (@functor.add_const.run.{0 0} (complete_lattice.{0} (has_to_string.{0} unsigned)) name h0)  := sorry --non-trivial
lemma new_lemma_31770 (h0 : group (complete_distrib_lattice (has_Inf (has_Inf real)))) : is_cyclic (complete_distrib_lattice (has_Inf (has_Inf real))) := sorry --non-trivial
lemma new_lemma_31771 (h0 : functor.add_const (filter (finset pos)) name) : filter.ne_bot (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_31772 (h0 : function.extfun Type list) : list.nodup (function.extfun_app h0 (id linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_31773 (h0 : list (add_left_cancel_semigroup (option unsigned))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_31774 (h0 : ring (canonically_ordered_comm_semiring (option ennreal))) : is_principal_ideal_ring (canonically_ordered_comm_semiring (option ennreal)) := sorry --non-trivial
lemma new_lemma_31775 (h3 : Prop) : set.separates_points (id (fun (h0 : string.iterator_imp -> char), h3)) := sorry --non-trivial
lemma new_lemma_31776 (h0 : uniform_space (has_Inf (has_Inf Type))) : complete_space (has_Inf (has_Inf Type)) := sorry --non-trivial
lemma new_lemma_31777 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_cyclic.{0} (has_add.{0} fun_info) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (has_add.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_31778 (h0 : function.extfun Type list) : list.nodup (function.extfun_app h0 auto.case_option) := sorry --non-trivial
lemma new_lemma_31779 (h0 : functor.add_const (topological_space (mul_zero_class pos)) unsigned) : @totally_separated_space.{0} (mul_zero_class.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (mul_zero_class.{0} pos)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_31780 (h0 : group (complete_semilattice_Sup char)) : group.fg (complete_semilattice_Sup char) := sorry --non-trivial
lemma new_lemma_31781 (h0 : functor.add_const (ring (canonically_ordered_comm_semiring Type)) name) : @strong_rank_condition.{1} (canonically_ordered_comm_semiring.{1} Type) (@functor.add_const.run.{1 0} (ring.{1} (canonically_ordered_comm_semiring.{1} Type)) name h0)  := sorry --non-trivial
lemma new_lemma_31782 (h0 : topological_space (canonically_ordered_comm_semiring (option unsigned))) : t1_space (canonically_ordered_comm_semiring (option unsigned)) := sorry --non-trivial
lemma new_lemma_31783 (h0 : ring (rel Type Type)) : strong_rank_condition (rel Type Type) := sorry --non-trivial
lemma new_lemma_31784 (h0 : function.extfun Type semiring) : @is_noetherian_ring.{0} (comm_monoid.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type semiring.{0} h0 (comm_monoid.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_31785 (h0 : topological_space (add_cancel_monoid (option ennreal))) : discrete_topology (add_cancel_monoid (option ennreal)) := sorry --non-trivial
lemma new_lemma_31786 (h0 : functor.add_const (ordered_add_comm_monoid (boolean_algebra Type)) linarith.comp) : @archimedean.{1} (boolean_algebra.{1} Type) (@functor.add_const.run.{1 0} (ordered_add_comm_monoid.{1} (boolean_algebra.{1} Type)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_31787 (h0 : functor.add_const (function.extfun Type topological_space) (finset Type)) : @preconnected_space.{0} (boolean_algebra.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type topological_space.{0}) (finset.{1} Type) h0) (boolean_algebra.{0} name))  := sorry --non-trivial
lemma new_lemma_31788 (h0 : topological_space (comm_ring (has_ssubset fun_info))) : path_connected_space (comm_ring (has_ssubset fun_info)) := sorry --non-trivial
lemma new_lemma_31789 (h0 : functor.add_const (add_group (comm_group Type)) pos) : @is_add_cyclic.{1} (comm_group.{1} Type) (@functor.add_const.run.{1 0} (add_group.{1} (comm_group.{1} Type)) pos h0)  := sorry --non-trivial
lemma new_lemma_31790 (h0 : topological_space (has_nndist (comm_group pos))) : loc_path_connected_space (has_nndist (comm_group pos)) := sorry --non-trivial
lemma new_lemma_31791 (h0 : nat) (h1 : array h0 unit) (h2 : nat) : @trace_call_stack.{0} Prop (@indistinguishable.{0} unit punit.topological_space.{0} (@array.read'.{0} h0 unit sort.inhabited'.{1} h1 h2))  := sorry --non-trivial
lemma new_lemma_31792 (h0 : topological_space (normed_group empty)) : topological_space.separable_space (normed_group empty) := sorry --non-trivial
lemma new_lemma_31793 (h0 : has_mem.mem (has_norm num) has_emptyc.emptyc) : @rank_condition.{0} (has_norm.{0} num) (@finset.pi.empty.{1 0} Type ring.{0} (has_norm.{0} num) h0)  := sorry --non-trivial
lemma new_lemma_31794 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_cyclic.{0} (simple_graph.{0} linarith.comp) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (simple_graph.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_31795 (h0 : finset (boolean_algebra.core congr_arg_kind) -> finset (boolean_algebra.core congr_arg_kind) -> Prop) : is_symm (finset (boolean_algebra.core congr_arg_kind)) h0 := sorry --non-trivial
lemma new_lemma_31796 (h0 : complete_lattice (comm_ring (random_gen (random_gen string_imp)))) : is_compactly_generated (comm_ring (random_gen (random_gen string_imp))) := sorry --non-trivial
lemma new_lemma_31797 (h0 : topological_space (sub_neg_monoid (has_add pos))) : normal_space (sub_neg_monoid (has_add pos)) := sorry --non-trivial
lemma new_lemma_31798 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_add_cyclic.{0} (with_bot.{0} linarith.ineq) (@function.extfun_app.{2 1} Type add_group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 add_group.{0}) (with_bot.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_31799 (h0 : topological_space (random_gen (random_gen to_additive.value_type))) : totally_disconnected_space (random_gen (random_gen to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_31800 (h0 : functor.add_const (topological_space (finset linarith.comp)) (ring pos)) : @topological_space.separable_space.{0} (finset.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (finset.{0} linarith.comp)) (ring.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_31801 (h0 : topological_space (ordered_comm_monoid (has_add pos))) : sequential_space (ordered_comm_monoid (has_add pos)) := sorry --non-trivial
lemma new_lemma_31802 (h0 : function.extfun Type topological_space) : @locally_compact_space.{0} (has_neg_part.{0} ennreal) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_neg_part.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_31803 (h0 : functor.add_const (group (comm_group pos)) unsigned) : @is_simple_group.{0} (comm_group.{0} pos) (@functor.add_const.run.{0 0} (group.{0} (comm_group.{0} pos)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_31804 (h0 : ring (has_bot unsigned)) : is_domain (has_bot unsigned) := sorry --non-trivial
lemma new_lemma_31805 (h0 : functor.add_const (topological_space (has_pos_part linarith.comp)) name) : @discrete_topology.{0} (has_pos_part.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (has_pos_part.{0} linarith.comp)) name h0)  := sorry --non-trivial
lemma new_lemma_31806 (h0 : topological_space (finset (has_to_string (has_to_string (has_to_string (has_to_string linarith.comp)))))) : regular_space (finset (has_to_string (has_to_string (has_to_string (has_to_string linarith.comp))))) := sorry --non-trivial
lemma new_lemma_31807 (h0 : has_neg (has_ssubset to_additive.value_type)) (h1 : measurable_space (has_ssubset to_additive.value_type)) : has_measurable_neg (has_ssubset to_additive.value_type) := sorry --non-trivial
lemma new_lemma_31808 (h0 : function.extfun Type topological_space) : @irreducible_space.{0} (ordered_cancel_add_comm_monoid.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (ordered_cancel_add_comm_monoid.{0} empty))  := sorry --non-trivial
lemma new_lemma_31809 (h0 : ring (emetric_space unsigned)) : is_principal_ideal_ring (emetric_space unsigned) := sorry --non-trivial
lemma new_lemma_31810 (h0 : functor.add_const (ring (generalized_boolean_algebra linarith.comp)) name) : @strong_rank_condition.{0} (generalized_boolean_algebra.{0} linarith.comp) (@functor.add_const.run.{0 0} (ring.{0} (generalized_boolean_algebra.{0} linarith.comp)) name h0)  := sorry --non-trivial
lemma new_lemma_31811 (h0 : functor.add_const (add_monoid (preorder num)) unsigned) : @add_monoid.fg.{0} (preorder.{0} num) (@functor.add_const.run.{0 0} (add_monoid.{0} (preorder.{0} num)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_31812 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @irreducible_space.{0} (ordered_comm_monoid.{0} real) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (ordered_comm_monoid.{0} real))  := sorry --non-trivial
lemma new_lemma_31813 (h0 : topological_space (comm_semigroup (ordered_comm_monoid linarith.comp))) : path_connected_space (comm_semigroup (ordered_comm_monoid linarith.comp)) := sorry --non-trivial
lemma new_lemma_31814 (h0 : filter (semigroup (has_neg (has_neg pos)))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_31815 (h0 : function.extfun Type topological_space) : @normal_space.{0} (non_assoc_semiring.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (non_assoc_semiring.{0} empty))  := sorry --non-trivial
lemma new_lemma_31816 (h0 : list (list Prop)) (h1 : ne h0 list.nil) : list.head (list.last h0 h1) := sorry --non-trivial
lemma new_lemma_31817 (h0 : functor.add_const (monoid (cancel_monoid name)) name) : @monoid.fg.{0} (cancel_monoid.{0} name) (@functor.add_const.run.{0 0} (monoid.{0} (cancel_monoid.{0} name)) name h0)  := sorry --non-trivial
lemma new_lemma_31818 (h0 : functor.add_const (topological_space (has_neg environment.implicit_infer_kind)) name) : @regular_space.{0} (has_neg.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (has_neg.{0} environment.implicit_infer_kind)) name h0)  := sorry --non-trivial
lemma new_lemma_31819 (h0 : functor.add_const (add_monoid (canonically_linear_ordered_monoid pos)) unsigned) : @add_monoid.fg.{0} (canonically_linear_ordered_monoid.{0} pos) (@functor.add_const.run.{0 0} (add_monoid.{0} (canonically_linear_ordered_monoid.{0} pos)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_31820 (h0 : ring (has_top (semiring unsigned))) : is_domain (has_top (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_31821 (h0 : not (filter (encodable linarith.comp_source) -> false)) : filter.ne_bot (classical.by_contradiction' h0) := sorry --non-trivial
lemma new_lemma_31822 (h0 : topological_space (add_cancel_monoid (has_add Type))) : locally_compact_space (add_cancel_monoid (has_add Type)) := sorry --non-trivial
lemma new_lemma_31823 (h0 : add_group (has_sub unsigned)) : is_add_cyclic (has_sub unsigned) := sorry --non-trivial
lemma new_lemma_31824 (h0 : function.extfun Type group) : @is_cyclic.{0} (has_pos_part.{0} name) (@function.extfun_app.{2 1} Type group.{0} h0 (has_pos_part.{0} name))  := sorry --non-trivial
lemma new_lemma_31825 (h0 : topological_space (has_union linarith.comp)) : path_connected_space (has_union linarith.comp) := sorry --non-trivial
lemma new_lemma_31826 (h0 : functor.add_const (ordered_add_comm_monoid (ring name)) (ring Type)) : @archimedean.{0} (ring.{0} name) (@functor.add_const.run.{0 1} (ordered_add_comm_monoid.{0} (ring.{0} name)) (ring.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_31827 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @preirreducible_space.{0} (canonically_ordered_monoid.{0} real) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (canonically_ordered_monoid.{0} real))  := sorry --non-trivial
lemma new_lemma_31828 (h0 : add_group (boolean_algebra.core congr_arg_kind)) : is_add_cyclic (boolean_algebra.core congr_arg_kind) := sorry --non-trivial
lemma new_lemma_31829 (h0 : finset (mul_zero_class (has_add environment.implicit_infer_kind))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_31830 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_principal_ideal_ring.{0} (has_nndist.{0} name) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (has_nndist.{0} name))  := sorry --non-trivial
lemma new_lemma_31831 (h0 : uniform_space (has_Inf name)) : separated_space (has_Inf name) := sorry --non-trivial
lemma new_lemma_31832 (h0 : filter (fintype (linear_ordered_comm_ring fun_info))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_31833 (h0 : not (ring (complete_semilattice_Sup fun_info) -> false)) : @strong_rank_condition.{0} (complete_semilattice_Sup.{0} fun_info) (@classical.by_contradiction'.{1} (ring.{0} (complete_semilattice_Sup.{0} fun_info)) h0)  := sorry --non-trivial
lemma new_lemma_31834 (h0 : functor.add_const (list (boolean_algebra name)) (has_add Type)) : list.nodup (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_31835 (h0 : Type) (h1 : h0) (h2 : h0 -> id (ring (add_comm_semigroup ereal))) : @strong_rank_condition.{0} (add_comm_semigroup.{0} ereal) (@id_bind.{0} h0 (ring.{0} (add_comm_semigroup.{0} ereal)) h1 h2)  := sorry --non-trivial
lemma new_lemma_31836 (h0 : monoid (has_emptyc (semiring num))) : monoid.fg (has_emptyc (semiring num)) := sorry --non-trivial
lemma new_lemma_31837 (h0 : uniform_space (ordered_comm_ring (has_neg Type))) : separated_space (ordered_comm_ring (has_neg Type)) := sorry --non-trivial
lemma new_lemma_31838 (h1 : topological_space (with_bot to_additive.value_type)) : t0_space (with_bot to_additive.value_type) := sorry --non-trivial
lemma new_lemma_31839 (h0 : topological_space (comm_group (finset pos))) : irreducible_space (comm_group (finset pos)) := sorry --non-trivial
lemma new_lemma_31840 (h0 : monoid (boolean_algebra linarith.comp)) : monoid.fg (boolean_algebra linarith.comp) := sorry --non-trivial
lemma new_lemma_31841 (h0 : group (cancel_monoid (has_to_string (has_to_string num)))) : group.fg (cancel_monoid (has_to_string (has_to_string num))) := sorry --non-trivial
lemma new_lemma_31842 (h0 : semiring (has_add Type)) : is_noetherian_ring (has_add Type) := sorry --non-trivial
lemma new_lemma_31843 (h0 : monoid (linear_ordered_comm_ring (semiring num))) : monoid.fg (linear_ordered_comm_ring (semiring num)) := sorry --non-trivial
lemma new_lemma_31844 (h0 : prod (comm_group unsigned) (comm_group unsigned)) : id_rel h0 := sorry --non-trivial
lemma new_lemma_31845 (h0 : functor.add_const (function.extfun Type semiring) linarith.comp) : @is_noetherian_ring.{0} (ordered_comm_ring.{0} linarith.comp) (@function.extfun_app.{2 1} Type semiring.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type semiring.{0}) linarith.comp h0) (ordered_comm_ring.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_31846 (h0 : not (topological_space (semiring linarith.comp_source) -> false)) : @irreducible_space.{0} (semiring.{0} linarith.comp_source) (@classical.by_contradiction'.{1} (topological_space.{0} (semiring.{0} linarith.comp_source)) h0)  := sorry --non-trivial
lemma new_lemma_31847 (h0 : uniform_space (finset (has_neg (has_neg (has_neg linarith.comp))))) : complete_space (finset (has_neg (has_neg (has_neg linarith.comp)))) := sorry --non-trivial
lemma new_lemma_31848 (h0 : topological_space (boolean_algebra real)) : totally_separated_space (boolean_algebra real) := sorry --non-trivial
lemma new_lemma_31849 (h1 : group (distrib_lattice linarith.ineq)) : is_cyclic (distrib_lattice linarith.ineq) := sorry --non-trivial
lemma new_lemma_31850 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @strong_rank_condition.{0} (normed_comm_ring.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (normed_comm_ring.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_31851 (h0 : not (ring (has_nnnorm reducibility_hints) -> false)) : @rank_condition.{0} (has_nnnorm.{0} reducibility_hints) (@classical.by_contradiction'.{1} (ring.{0} (has_nnnorm.{0} reducibility_hints)) h0)  := sorry --non-trivial
lemma new_lemma_31852 (h0 : functor.add_const (complete_lattice (finset unsigned)) Type) : @complete_lattice.is_Sup_finite_compact.{0} (finset.{0} unsigned) (@functor.add_const.run.{0 1} (complete_lattice.{0} (finset.{0} unsigned)) Type h0)  := sorry --non-trivial
lemma new_lemma_31853 (h0 : ring (has_to_string (has_add environment.implicit_infer_kind))) : rank_condition (has_to_string (has_add environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_31854 (h1 : uniform_space (add_monoid fun_info)) : complete_space (add_monoid fun_info) := sorry --non-trivial
lemma new_lemma_31855 (h0 : function.extfun Type topological_space) : @path_connected_space.{0} (pseudo_emetric_space.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (pseudo_emetric_space.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_31856 (h0 : functor.add_const (ordered_comm_monoid (monoid_with_zero pos)) pos) : @has_exists_mul_of_le.{0} (monoid_with_zero.{0} pos) (@functor.add_const.run.{0 0} (ordered_comm_monoid.{0} (monoid_with_zero.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_31857 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : list.ilast (function.extfun_app (function.extfun_app h0 list) Prop) := sorry --non-trivial
lemma new_lemma_31858 (h0 : functor.add_const (ordered_comm_monoid (normed_comm_ring name)) (option (option pos))) : @has_exists_mul_of_le.{0} (normed_comm_ring.{0} name) (@functor.add_const.run.{0 0} (ordered_comm_monoid.{0} (normed_comm_ring.{0} name)) (option.{0} (option.{0} pos)) h0)  := sorry --non-trivial
lemma new_lemma_31859 (h0 : has_mem.mem ring has_emptyc.emptyc) : @is_domain.{1} Type (@function.extfun_app.{3 2} (Type 1) ring.{1} (@finset.pi.empty.{2 2} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) ring.{1} h0) Type)  := sorry --non-trivial
lemma new_lemma_31860 (h0 : topological_space (boolean_algebra.core unsigned)) : t1_space (boolean_algebra.core unsigned) := sorry --non-trivial
lemma new_lemma_31861 (h0 : list (group_with_zero (option ennreal))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_31862 (h0 : not (filter (measurable_space.dynkin_system congr_arg_kind) -> false)) : filter.ne_bot (classical.by_contradiction' h0) := sorry --non-trivial
lemma new_lemma_31863 (h0 : topological_space (distrib (distrib fun_info))) : path_connected_space (distrib (distrib fun_info)) := sorry --non-trivial
lemma new_lemma_31864 (h0 : functor.add_const (group (has_neg name)) pos) : @group.fg.{0} (has_neg.{0} name) (@functor.add_const.run.{0 0} (group.{0} (has_neg.{0} name)) pos h0)  := sorry --non-trivial
lemma new_lemma_31865 (h0 : topological_space (semi_normed_comm_ring (has_nnnorm (has_nnnorm string_imp)))) : totally_disconnected_space (semi_normed_comm_ring (has_nnnorm (has_nnnorm string_imp))) := sorry --non-trivial
lemma new_lemma_31866 (h0 : topological_space (ordered_comm_ring (has_Inf (has_bot real)))) : irreducible_space (ordered_comm_ring (has_Inf (has_bot real))) := sorry --non-trivial
lemma new_lemma_31867 (h0 : functor.add_const (group (add_left_cancel_semigroup unsigned)) empty) : @is_cyclic.{0} (add_left_cancel_semigroup.{0} unsigned) (@functor.add_const.run.{0 0} (group.{0} (add_left_cancel_semigroup.{0} unsigned)) empty h0)  := sorry --non-trivial
lemma new_lemma_31868 (h0 : function.extfun Type topological_space) : @loc_path_connected_space.{0} (ordered_comm_ring.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (ordered_comm_ring.{0} pos))  := sorry --non-trivial
lemma new_lemma_31869 (h0 : topological_space (finset (ring linarith.comp))) : regular_space (finset (ring linarith.comp)) := sorry --non-trivial
lemma new_lemma_31870 (h2 h3 : multiset (has_lt (mul_one_class to_additive.value_type))) : multiset.disjoint h2 h3 := sorry --non-trivial
lemma new_lemma_31871 (h0 : filter (has_add (has_neg environment.implicit_infer_kind))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_31872 (h0 : topological_space (topological_space (has_lt fun_info))) : totally_disconnected_space (topological_space (has_lt fun_info)) := sorry --non-trivial
lemma new_lemma_31873 (h0 : group (semi_normed_comm_ring to_additive.value_type)) : group.fg (semi_normed_comm_ring to_additive.value_type) := sorry --non-trivial
lemma new_lemma_31874 (h0 : topological_space (linear_ordered_comm_group empty)) : irreducible_space (linear_ordered_comm_group empty) := sorry --non-trivial
lemma new_lemma_31875 (h0 : function.extfun Type topological_space) : @totally_disconnected_space.{0} (ordered_comm_group.{0} (option.{0} empty)) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (ordered_comm_group.{0} (option.{0} empty)))  := sorry --non-trivial
lemma new_lemma_31876 (h0 : prod (semigroup (option (option (option (option name))))) (semigroup (option (option (option (option name)))))) : id_rel h0 := sorry --non-trivial
lemma new_lemma_31877 (h0 h2 : multiset enat) : multiset.disjoint h0 h2 := sorry --non-trivial
lemma new_lemma_31878 (h0 : fin has_zero.zero) : @discrete_topology.{1} (complete_distrib_lattice.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@matrix.vec_empty.{2} (function.extfun.{3 2} (Type 1) topological_space.{1}) (@matrix.vec_empty.{0} (fin (@has_zero.zero.{0} nat nat.has_zero)) h0)) (complete_distrib_lattice.{1} Type))  := sorry --non-trivial
lemma new_lemma_31879 (h0 : char -> nat) (h1 : nat) (h2 : add_group (derive_fintype.finset_above char h0 h1)) : is_add_cyclic (derive_fintype.finset_above char h0 h1) := sorry --non-trivial
lemma new_lemma_31880 (h0 : complete_lattice (monoid_with_zero (option pos))) : is_atomistic (monoid_with_zero (option pos)) := sorry --non-trivial
lemma new_lemma_31881 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @topological_space.separable_space.{0} (ordered_comm_ring.{0} real) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (ordered_comm_ring.{0} real))  := sorry --non-trivial
lemma new_lemma_31882 (h0 : monoid (measurable_space (random_gen to_additive.value_type))) : monoid.fg (measurable_space (random_gen to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_31883 (h0 : topological_space (normed_comm_ring (complete_distrib_lattice name))) : normal_space (normed_comm_ring (complete_distrib_lattice name)) := sorry --non-trivial
lemma new_lemma_31884 (h0 : ring (normed_field (has_nnnorm (has_lt reducibility_hints)))) : rank_condition (normed_field (has_nnnorm (has_lt reducibility_hints))) := sorry --non-trivial
lemma new_lemma_31885 (h0 : not (topological_space (has_sub num) -> false)) : @topological_space.separable_space.{0} (has_sub.{0} num) (@classical.by_contradiction'.{1} (topological_space.{0} (has_sub.{0} num)) h0)  := sorry --non-trivial
lemma new_lemma_31886 (h0 : functor.add_const (topological_space (has_to_string unsigned)) name) : @normal_space.{0} (has_to_string.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (has_to_string.{0} unsigned)) name h0)  := sorry --non-trivial
lemma new_lemma_31887 (h0 : topological_space (omega_complete_partial_order (option congr_arg_kind))) : totally_disconnected_space (omega_complete_partial_order (option congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_31888 (h0 : topological_space (with_one (random_gen (random_gen linarith.comp_source)))) : path_connected_space (with_one (random_gen (random_gen linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_31889 (h0 : functor.add_const (topological_space (boolean_algebra.core unsigned)) (option unsigned)) : @t0_space.{0} (boolean_algebra.core.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (boolean_algebra.core.{0} unsigned)) (option.{0} unsigned) h0)  := sorry --non-trivial
lemma new_lemma_31890 (h0 : not (function.extfun Type topological_space -> false)) : @locally_compact_space.{0} (complete_lattice.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (complete_lattice.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_31891 (h0 : ring (has_append (has_nnnorm (comm_ring fun_info)))) : rank_condition (has_append (has_nnnorm (comm_ring fun_info))) := sorry --non-trivial
lemma new_lemma_31892 (h0 : topological_space (has_neg (comm_group (has_add (has_to_string (has_add name)))))) : regular_space (has_neg (comm_group (has_add (has_to_string (has_add name))))) := sorry --non-trivial
lemma new_lemma_31893 (h0 : topological_space (has_star empty)) : discrete_topology (has_star empty) := sorry --non-trivial
lemma new_lemma_31894 (h0 : group (canonically_ordered_monoid name)) : is_cyclic (canonically_ordered_monoid name) := sorry --non-trivial
lemma new_lemma_31895 (h0 : measurable_space char) (h2 : measure_theory.measure char) : measure_theory.is_finite_measure h2 := sorry --non-trivial
lemma new_lemma_31896 (h0 : finset (ordered_comm_monoid linarith.comp)) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_31897 (h0 : topological_space (semiring (has_norm linarith.ineq))) : discrete_topology (semiring (has_norm linarith.ineq)) := sorry --non-trivial
lemma new_lemma_31898 (h0 : ring (complete_distrib_lattice (has_add (ring (has_nndist (has_add (has_add pos))))))) : rank_condition (complete_distrib_lattice (has_add (ring (has_nndist (has_add (has_add pos)))))) := sorry --non-trivial
lemma new_lemma_31899 (h0 : function.extfun Type topological_space) : @path_connected_space.{0} (has_norm.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_norm.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_31900 (h0 : ring (has_neg_part (has_neg_part (has_add Type)))) : strong_rank_condition (has_neg_part (has_neg_part (has_add Type))) := sorry --non-trivial
lemma new_lemma_31901 (h0 : has_mem.mem (with_bot fun_info) has_emptyc.emptyc) : @add_monoid.fg.{0} (with_bot.{0} fun_info) (@finset.pi.empty.{1 0} Type add_monoid.{0} (with_bot.{0} fun_info) h0)  := sorry --non-trivial
lemma new_lemma_31902 (h0 : not (filter (has_union linarith.comp) -> false)) : filter.ne_bot (classical.by_contradiction' h0) := sorry --non-trivial
lemma new_lemma_31903 (h0 : topological_space (mul_one_class (mul_one_class fun_info))) : totally_disconnected_space (mul_one_class (mul_one_class fun_info)) := sorry --non-trivial
lemma new_lemma_31904 (h0 : ring linarith.comp) : rank_condition linarith.comp := sorry --non-trivial
lemma new_lemma_31905 (h0 : functor.add_const (function.extfun (Type 1) cancel_comm_monoid_with_zero) linarith.comp) : @unique_factorization_monoid.{1} (has_Inf.{1} Type) (@function.extfun_app.{3 2} (Type 1) cancel_comm_monoid_with_zero.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) cancel_comm_monoid_with_zero.{1}) linarith.comp h0) (has_Inf.{1} Type))  := sorry --non-trivial
lemma new_lemma_31906 (h0 : functor.add_const (ordered_comm_monoid (has_neg pos)) name) : @has_exists_mul_of_le.{0} (has_neg.{0} pos) (@functor.add_const.run.{0 0} (ordered_comm_monoid.{0} (has_neg.{0} pos)) name h0)  := sorry --non-trivial
lemma new_lemma_31907 (h0 : functor.add_const (topological_space (has_nndist name)) Type) : @preirreducible_space.{0} (has_nndist.{0} name) (@functor.add_const.run.{0 1} (topological_space.{0} (has_nndist.{0} name)) Type h0)  := sorry --non-trivial
lemma new_lemma_31908 (h0 : ring (has_zero (ring environment.implicit_infer_kind))) : rank_condition (has_zero (ring environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_31909 (h0 : uniform_space (has_top (random_gen fun_info))) : complete_space (has_top (random_gen fun_info)) := sorry --non-trivial
lemma new_lemma_31910 (h0 : topological_space (has_compl char)) : path_connected_space (has_compl char) := sorry --non-trivial
lemma new_lemma_31911 (h0 : functor.add_const (list (has_star empty)) (semiring empty)) : palindrome (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_31912 (h0 : functor.comp topological_space mul_zero_class Type) : @irreducible_space.{1} (mul_zero_class.{1} Type) (@functor.comp.run.{1 1 1} topological_space.{1} mul_zero_class.{1} Type h0)  := sorry --non-trivial
lemma new_lemma_31913 (h0 : group (add_comm_monoid num)) : is_cyclic (add_comm_monoid num) := sorry --non-trivial
lemma new_lemma_31914 (h0 : complete_lattice (simple_graph reducibility_hints)) : complete_lattice.is_Sup_finite_compact (simple_graph reducibility_hints) := sorry --non-trivial
lemma new_lemma_31915 (h0 : topological_space (has_top to_additive.value_type)) : totally_disconnected_space (has_top to_additive.value_type) := sorry --non-trivial
lemma new_lemma_31916 (h0 : function.extfun Type topological_space) : @preconnected_space.{0} (pseudo_metric_space.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (pseudo_metric_space.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_31917 (h0 : function.extfun Type topological_space) : @irreducible_space.{0} (measurable_space.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (measurable_space.{0} num))  := sorry --non-trivial
lemma new_lemma_31918 (h0 : monoid (has_norm (random_gen (random_gen (random_gen (complete_semilattice_Sup linarith.ineq)))))) : monoid.fg (has_norm (random_gen (random_gen (random_gen (complete_semilattice_Sup linarith.ineq))))) := sorry --non-trivial
lemma new_lemma_31919 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @complete_lattice.is_Sup_finite_compact.{0} (with_bot.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (with_bot.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_31920 (h0 : function.extfun Type add_group) : @is_add_cyclic.{0} (pseudo_metric_space.{0} ennreal) (@function.extfun_app.{2 1} Type add_group.{0} h0 (pseudo_metric_space.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_31921 (h0 : empty -> empty -> Prop) : well_founded h0 := sorry --non-trivial
lemma new_lemma_31922 (h0 : function.extfun Type topological_space) : @locally_compact_space.{0} (ordered_cancel_add_comm_monoid.{0} (option.{0} num)) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (ordered_cancel_add_comm_monoid.{0} (option.{0} num)))  := sorry --non-trivial
lemma new_lemma_31923 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @path_connected_space.{0} (has_emptyc.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_emptyc.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_31924 (h0 : not (topological_space (dlist linarith.comp_source) -> false)) : @locally_compact_space.{0} (dlist.{0} linarith.comp_source) (@classical.by_contradiction'.{1} (topological_space.{0} (dlist.{0} linarith.comp_source)) h0)  := sorry --non-trivial
lemma new_lemma_31925 (h0 : semiring (with_one (has_norm unsigned))) : is_noetherian_ring (with_one (has_norm unsigned)) := sorry --non-trivial
lemma new_lemma_31926 (h0 : function.extfun Type topological_space) : @preirreducible_space.{0} (ring.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (ring.{0} empty))  := sorry --non-trivial
lemma new_lemma_31927 (h0 : function.extfun Type topological_space) : @totally_disconnected_space.{0} (canonically_ordered_comm_semiring.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (canonically_ordered_comm_semiring.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_31928 (h0 : complete_lattice (has_lt (comm_ring char))) : is_compactly_generated (has_lt (comm_ring char)) := sorry --non-trivial
lemma new_lemma_31929 (h0 : functor.add_const (function.extfun Type topological_space) linarith.comp) : @totally_disconnected_space.{0} (boolean_algebra.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) linarith.comp h0) (boolean_algebra.{0} pos))  := sorry --non-trivial
lemma new_lemma_31930 (h1 : complete_lattice (has_compl linarith.comp_source)) : complete_lattice.is_Sup_finite_compact (has_compl linarith.comp_source) := sorry --non-trivial
lemma new_lemma_31931 (h0 : ring (complete_semilattice_Sup string_imp)) : is_domain (complete_semilattice_Sup string_imp) := sorry --non-trivial
lemma new_lemma_31932 (h0 : topological_space (canonically_ordered_monoid Type)) : sequential_space (canonically_ordered_monoid Type) := sorry --non-trivial
lemma new_lemma_31933 (h0 : functor.add_const (function.extfun (Type 1) topological_space) pos) : @sequential_space.{1} (normed_comm_ring.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) topological_space.{1}) pos h0) (normed_comm_ring.{1} Type))  := sorry --non-trivial
lemma new_lemma_31934 (h0 : functor.add_const (group (add_cancel_monoid name)) (has_add pos)) : @group.fg.{0} (add_cancel_monoid.{0} name) (@functor.add_const.run.{0 0} (group.{0} (add_cancel_monoid.{0} name)) (has_add.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_31935 (h0 : uniform_space (ordered_comm_monoid (has_Inf Type))) : separated_space (ordered_comm_monoid (has_Inf Type)) := sorry --non-trivial
lemma new_lemma_31936 (h0 : function.extfun Type add_group) : @is_add_cyclic.{0} (has_inv.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type add_group.{0} h0 (has_inv.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_31937 (h7 : uniform_space (add_comm_semigroup (add_comm_semigroup (add_comm_semigroup linarith.ineq)))) : complete_space (add_comm_semigroup (add_comm_semigroup (add_comm_semigroup linarith.ineq))) := sorry --non-trivial
lemma new_lemma_31938 (h0 : ring (comm_group (finset pos))) : is_principal_ideal_ring (comm_group (finset pos)) := sorry --non-trivial
lemma new_lemma_31939 (h0 : ring (has_neg ennreal)) : is_domain (has_neg ennreal) := sorry --non-trivial
lemma new_lemma_31940 (h0 : uniform_space (with_one (has_norm empty))) : complete_space (with_one (has_norm empty)) := sorry --non-trivial
lemma new_lemma_31941 (h0 : functor.add_const (group (semigroup name)) unsigned) : @normalizer_condition.{0} (semigroup.{0} name) (@functor.add_const.run.{0 0} (group.{0} (semigroup.{0} name)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_31942 (h0 : not (has_mem.mem (has_top to_additive.value_type) has_emptyc.emptyc -> false)) : @totally_separated_space.{0} (has_top.{0} to_additive.value_type) (@finset.pi.empty.{1 0} Type topological_space.{0} (has_top.{0} to_additive.value_type) (@classical.by_contradiction'.{0} (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (has_top.{0} to_additive.value_type) (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))) h0))  := sorry --non-trivial
lemma new_lemma_31943 (h0 : functor.add_const (topological_space (simple_graph Type)) linarith.comp) : @irreducible_space.{1} (simple_graph.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (simple_graph.{1} Type)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_31944 (h0 : functor.add_const (list (has_star empty)) empty) : palindrome (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_31945 (h0 : measurable_space (semi_normed_ring string_imp)) (h1 : filter (semi_normed_ring string_imp)) : filter.is_measurably_generated h1 := sorry --non-trivial
lemma new_lemma_31946 (h0 : functor.add_const (topological_space (mul_zero_class Type)) Type) : @locally_compact_space.{1} (mul_zero_class.{1} Type) (@functor.add_const.run.{1 1} (topological_space.{1} (mul_zero_class.{1} Type)) Type h0)  := sorry --non-trivial
lemma new_lemma_31947 (h1 : complete_lattice (linear_ordered_add_comm_group_with_top char)) : complete_lattice.is_Sup_finite_compact (linear_ordered_add_comm_group_with_top char) := sorry --non-trivial
lemma new_lemma_31948 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @monoid.fg.{1} (has_to_string.{1} Type) (@function.extfun_app.{3 2} (Type 1) monoid.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 monoid.{1}) (has_to_string.{1} Type))  := sorry --non-trivial
lemma new_lemma_31949 (h0 : fin has_zero.zero) : @is_add_cyclic.{0} (has_pos_part.{0} linarith.comp) (@matrix.vec_empty.{0} (add_group.{0} (has_pos_part.{0} linarith.comp)) (@function.extfun_app.{1 1} nat fin (@functor.add_const.run.{0 0} (function.extfun.{1 1} nat fin) linarith.comp (@matrix.vec_empty.{0} (functor.add_const.{0 0} (function.extfun.{1 1} nat fin) linarith.comp) h0)) (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_31950 (h0 : uniform_space (has_edist (option (option (option (option (option (option (option empty))))))))) : complete_space (has_edist (option (option (option (option (option (option (option empty)))))))) := sorry --non-trivial
lemma new_lemma_31951 (h0 : not (topological_space (id unsigned) -> false)) : @totally_separated_space.{0} (@id.{2} Type unsigned) (@classical.by_contradiction'.{1} (topological_space.{0} (@id.{2} Type unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_31952 (h0 : topological_space (canonically_ordered_comm_semiring Type)) : preirreducible_space (canonically_ordered_comm_semiring Type) := sorry --non-trivial
lemma new_lemma_31953 (h0 : function.extfun nat fin) : @is_compactly_generated.{0} (comm_semigroup.{0} real) (@matrix.vec_empty.{0} (complete_lattice.{0} (comm_semigroup.{0} real)) (@matrix.vec_empty.{0} (fin (@has_zero.zero.{0} nat nat.has_zero)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero))))  := sorry --non-trivial
lemma new_lemma_31954 (h0 : functor.add_const (list (comm_monoid_with_zero empty)) empty) : list.nodup (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_31955 (h0 : not (function.extfun Type uniform_space -> false)) : @separated_space.{0} (add_group.{0} linarith.comp) (@function.extfun_app.{2 1} Type uniform_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type uniform_space.{0}) h0) (add_group.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_31956 (h0 : function.extfun Type semiring) : @is_noetherian_ring.{0} (has_sub.{0} num) (@function.extfun_app.{2 1} Type semiring.{0} h0 (has_sub.{0} num))  := sorry --non-trivial
lemma new_lemma_31957 (h0 : ring (topological_space (div_inv_monoid to_additive.value_type))) : strong_rank_condition (topological_space (div_inv_monoid to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_31958 (h0 : topological_space (add_right_cancel_monoid (semiring num))) : normal_space (add_right_cancel_monoid (semiring num)) := sorry --non-trivial
lemma new_lemma_31959 (h0 : function.extfun Type finset) : finset.nonempty (function.extfun_app h0 (linear_ordered_field unsigned)) := sorry --non-trivial
lemma new_lemma_31960 (h0 : function.extfun Type ring) : @strong_rank_condition.{0} (boolean_algebra.{0} name) (@function.extfun_app.{2 1} Type ring.{0} h0 (boolean_algebra.{0} name))  := sorry --non-trivial
lemma new_lemma_31961 (h0 : ring (normed_linear_ordered_group (semiring empty))) : is_principal_ideal_ring (normed_linear_ordered_group (semiring empty)) := sorry --non-trivial
lemma new_lemma_31962 (h0 : list (boolean_algebra (has_to_string unsigned))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_31963 (h0 : with_bot pnat) (h1 : ne h0 has_bot.bot) (h2 : ulower (ulower pnat)) : pnat.coprime (id (id (id (with_bot.unbot h0 h1)))) (ulower.up (ulower.up h2)) := sorry --non-trivial
lemma new_lemma_31964 (h0 : function.extfun Type uniform_space) : @complete_space.{0} (has_neg.{0} unsigned) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (has_neg.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_31965 (h0 : group (ordered_comm_monoid (comm_semigroup (has_add real)))) : group.fg (ordered_comm_monoid (comm_semigroup (has_add real))) := sorry --non-trivial
lemma new_lemma_31966 (h0 : topological_space (has_star empty)) : irreducible_space (has_star empty) := sorry --non-trivial
lemma new_lemma_31967 (h1 : filter (has_dist (has_nnnorm char))) : filter.ne_bot h1 := sorry --non-trivial
lemma new_lemma_31968 (h0 : uniform_space (has_Inf (ring Type))) : complete_space (has_Inf (ring Type)) := sorry --non-trivial
lemma new_lemma_31969 (h0 : functor.add_const (topological_space (has_to_string unsigned)) pos) : @discrete_topology.{0} (has_to_string.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (has_to_string.{0} unsigned)) pos h0)  := sorry --non-trivial
lemma new_lemma_31970 (h0 : functor.add_const (list (mul_zero_class pos)) unsigned) : palindrome (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_31971 (h0 : functor.add_const (list (normed_comm_ring pos)) name) : palindrome (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_31972 (h0 : fin has_zero.zero) : @regular_space.{0} (has_bot.{0} pos) (@matrix.vec_empty.{0} (topological_space.{0} (has_bot.{0} pos)) h0)  := sorry --non-trivial
lemma new_lemma_31973 (h0 : functor.add_const (cancel_comm_monoid_with_zero (add_cancel_monoid name)) Type) : @unique_factorization_monoid.{0} (add_cancel_monoid.{0} name) (@functor.add_const.run.{0 1} (cancel_comm_monoid_with_zero.{0} (add_cancel_monoid.{0} name)) Type h0)  := sorry --non-trivial
lemma new_lemma_31974 (h0 : functor.add_const (topological_space (semiring unsigned)) (semiring (semiring num))) : @normal_space.{0} (semiring.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (semiring.{0} unsigned)) (semiring.{0} (semiring.{0} num)) h0)  := sorry --non-trivial
lemma new_lemma_31975 (h0 : function.extfun Type monoid) : @monoid.fg.{0} (ring.{0} unsigned) (@function.extfun_app.{2 1} Type monoid.{0} h0 (ring.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_31976 (h0 : topological_space (generalized_boolean_algebra (has_add name))) : preirreducible_space (generalized_boolean_algebra (has_add name)) := sorry --non-trivial
lemma new_lemma_31977 (h0 : list (denumerable (random_gen to_additive.value_type))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_31978 (h0 : complete_lattice (linear_ordered_comm_group (option congr_arg_kind))) : is_atomistic (linear_ordered_comm_group (option congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_31979 (h0 : group (normed_lattice_add_comm_group (has_Inf (has_add pos)))) : is_simple_group (normed_lattice_add_comm_group (has_Inf (has_add pos))) := sorry --non-trivial
lemma new_lemma_31980 (h0 : filter (has_add (ring linarith.comp))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_31981 (h0 : add_group (mul_zero_class name)) : is_add_cyclic (mul_zero_class name) := sorry --non-trivial
lemma new_lemma_31982 (h0 : topological_space (distrib (semi_normed_ring fun_info))) : path_connected_space (distrib (semi_normed_ring fun_info)) := sorry --non-trivial
lemma new_lemma_31983 (h0 : functor.comp topological_space canonically_ordered_comm_semiring Type) : @discrete_topology.{1} (canonically_ordered_comm_semiring.{1} Type) (@functor.comp.run.{1 1 1} topological_space.{1} canonically_ordered_comm_semiring.{1} Type h0)  := sorry --non-trivial
lemma new_lemma_31984 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @normalizer_condition.{0} (boolean_algebra.{0} pos) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (boolean_algebra.{0} pos))  := sorry --non-trivial
lemma new_lemma_31985 (h1 : ring (normed_field std_gen)) : is_domain (normed_field std_gen) := sorry --non-trivial
lemma new_lemma_31986 (h0 : topological_space (complete_linear_order congr_arg_kind)) : totally_separated_space (complete_linear_order congr_arg_kind) := sorry --non-trivial
lemma new_lemma_31987 (h0 : functor.add_const (function.extfun Type list) name) : list.nodup (function.extfun_app (functor.add_const.run h0) (has_add name)) := sorry --non-trivial
lemma new_lemma_31988 (h0 : topological_space (normed_comm_ring (option unsigned))) : path_connected_space (normed_comm_ring (option unsigned)) := sorry --non-trivial
lemma new_lemma_31989 (h0 : functor.add_const (function.extfun Type ring) pos) : @is_principal_ideal_ring.{0} (has_neg.{0} pos) (@function.extfun_app.{2 1} Type ring.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type ring.{0}) pos h0) (has_neg.{0} pos))  := sorry --non-trivial
lemma new_lemma_31990 (h0 : prod (has_neg ennreal) (has_neg ennreal)) : id_rel h0 := sorry --non-trivial
lemma new_lemma_31991 (h0 : function.extfun Type topological_space) : @totally_separated_space.{0} (ring.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (ring.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_31992 (h0 : functor.comp (functor.comp topological_space has_to_string) mul_zero_class unsigned) : @sequential_space.{0} (has_to_string.{0} (mul_zero_class.{0} unsigned)) (@functor.comp.run.{0 0 0} topological_space.{0} has_to_string.{0} (mul_zero_class.{0} unsigned) (@functor.comp.run.{0 0 0} (functor.comp.{0 0 0} topological_space.{0} has_to_string.{0}) mul_zero_class.{0} unsigned h0))  := sorry --non-trivial
lemma new_lemma_31993 (h0 : topological_space (add_cancel_monoid (has_add (has_add linarith.comp)))) : t1_space (add_cancel_monoid (has_add (has_add linarith.comp))) := sorry --non-trivial
lemma new_lemma_31994 (h0 : complete_lattice (ordered_cancel_add_comm_monoid empty)) : complete_lattice.is_Sup_finite_compact (ordered_cancel_add_comm_monoid empty) := sorry --non-trivial
lemma new_lemma_31995 (h0 : list (plift congr_arg_kind)) : palindrome h0 := sorry --non-trivial
lemma new_lemma_31996 (h0 : function.extfun Type topological_space) : @locally_compact_space.{0} (has_zero.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_zero.{0} pos))  := sorry --non-trivial
lemma new_lemma_31997 (h0 : functor.add_const (uniform_space (has_add name)) name) : @complete_space.{0} (has_add.{0} name) (@functor.add_const.run.{0 0} (uniform_space.{0} (has_add.{0} name)) name h0)  := sorry --non-trivial
lemma new_lemma_31998 (h0 : not (ring (has_lt char) -> false)) : @rank_condition.{0} (has_lt.{0} char) (@classical.by_contradiction'.{1} (ring.{0} (has_lt.{0} char)) h0)  := sorry --non-trivial
lemma new_lemma_31999 (h0 : functor.add_const (topological_space (has_zero linarith.comp)) (finset linarith.comp)) : @regular_space.{0} (has_zero.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (has_zero.{0} linarith.comp)) (finset.{0} linarith.comp) h0)  := sorry --non-trivial
