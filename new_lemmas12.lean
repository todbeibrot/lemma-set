import imports
lemma new_lemma_96000 (h0 : not (function.extfun Type list -> false)) : list.nodup (function.extfun_app (classical.by_contradiction' h0) (random_gen linarith.ineq)) := sorry --non-trivial
lemma new_lemma_96001 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @t0_space.{0} (ordered_cancel_add_comm_monoid.{0} ennreal) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (ordered_cancel_add_comm_monoid.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_96002 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : countable_Inter_filter (function.extfun_app (function.extfun_app h0 filter) (finset pos)) := sorry --non-trivial
lemma new_lemma_96003 (h0 : topological_space (generalized_boolean_algebra (has_Inf (has_Inf (has_Inf (has_add pos)))))) : sequential_space (generalized_boolean_algebra (has_Inf (has_Inf (has_Inf (has_add pos))))) := sorry --non-trivial
lemma new_lemma_96004 (h0 : topological_space (has_top (has_norm linarith.comp_source))) : totally_separated_space (has_top (has_norm linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_96005 (h0 : group (random_gen (has_nnnorm (has_top (has_top (has_top fun_info)))))) : group.fg (random_gen (has_nnnorm (has_top (has_top (has_top fun_info))))) := sorry --non-trivial
lemma new_lemma_96006 (h0 : semiring (partial_order (semiring congr_arg_kind))) : is_noetherian_ring (partial_order (semiring congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_96007 (h0 : function.extfun Type topological_space) : @totally_disconnected_space.{0} (boolean_algebra.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (boolean_algebra.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_96008 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @totally_disconnected_space.{0} (metric_space.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (metric_space.{0} num))  := sorry --non-trivial
lemma new_lemma_96009 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @path_connected_space.{1} (boolean_algebra.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 topological_space.{1}) (boolean_algebra.{1} Type))  := sorry --non-trivial
lemma new_lemma_96010 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @totally_disconnected_space.{0} (ordered_comm_ring.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (ordered_comm_ring.{0} pos))  := sorry --non-trivial
lemma new_lemma_96011 (h0 : has_vadd char char) (h1 h2 : measurable_space char) : has_measurable_vadd₂ char char := sorry --non-trivial
lemma new_lemma_96012 (h0 : ordered_comm_monoid (has_neg (has_neg Type))) : has_exists_mul_of_le (has_neg (has_neg Type)) := sorry --non-trivial
lemma new_lemma_96013 (h0 : uniform_space (uniform_space (random_gen (semigroup char)))) : complete_space (uniform_space (random_gen (semigroup char))) := sorry --non-trivial
lemma new_lemma_96014 (h0 : functor.add_const (topological_space (has_to_string name)) name) : @totally_separated_space.{0} (has_to_string.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (has_to_string.{0} name)) name h0)  := sorry --non-trivial
lemma new_lemma_96015 (h0 : uniform_space (measurable_space (has_inv (random_gen linarith.ineq)))) : complete_space (measurable_space (has_inv (random_gen linarith.ineq))) := sorry --non-trivial
lemma new_lemma_96016 (h0 : topological_space (has_nndist name)) : sequential_space (has_nndist name) := sorry --non-trivial
lemma new_lemma_96017 (h0 : not (topological_space (measure_theory.measure_space congr_arg_kind) -> false)) : @discrete_topology.{0} (measure_theory.measure_space.{0} congr_arg_kind) (@classical.by_contradiction'.{1} (topological_space.{0} (measure_theory.measure_space.{0} congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_96018 (h0 : finset (option (semiring (semiring congr_arg_kind)))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_96019 (h0 : functor.add_const (complete_lattice (boolean_algebra pos)) (has_Inf linarith.comp)) : @is_compactly_generated.{0} (boolean_algebra.{0} pos) (@functor.add_const.run.{0 0} (complete_lattice.{0} (boolean_algebra.{0} pos)) (has_Inf.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_96020 (h0 : functor.add_const (function.extfun (Type 1) list) name) : palindrome (function.extfun_app (functor.add_const.run h0) (boolean_algebra.core Type)) := sorry --non-trivial
lemma new_lemma_96021 (h0 : function.extfun Type group) : @is_cyclic.{0} (dlist.{0} string_imp) (@function.extfun_app.{2 1} Type group.{0} h0 (dlist.{0} string_imp))  := sorry --non-trivial
lemma new_lemma_96022 (h0 : group (add_cancel_monoid (has_add (boolean_algebra.core (has_add name))))) : is_cyclic (add_cancel_monoid (has_add (boolean_algebra.core (has_add name)))) := sorry --non-trivial
lemma new_lemma_96023 (h0 : functor.add_const (ordered_comm_monoid (normed_comm_ring Type)) name) : @has_exists_mul_of_le.{1} (normed_comm_ring.{1} Type) (@functor.add_const.run.{1 0} (ordered_comm_monoid.{1} (normed_comm_ring.{1} Type)) name h0)  := sorry --non-trivial
lemma new_lemma_96024 (h0 : functor.add_const (complete_lattice (add_cancel_monoid pos)) pos) : @is_atomistic.{0} (add_cancel_monoid.{0} pos) (@functor.add_const.run.{0 0} (complete_lattice.{0} (add_cancel_monoid.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_96025 (h0 : topological_space (has_nndist (has_neg_part (has_nndist ennreal)))) : path_connected_space (has_nndist (has_neg_part (has_nndist ennreal))) := sorry --non-trivial
lemma new_lemma_96026 (h0 : functor.add_const (filter (ring linarith.comp)) linarith.comp) : filter.ne_bot (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_96027 (h0 : list (canonically_linear_ordered_monoid (option unsigned))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_96028 (h0 : ring (complete_semilattice_Sup (random_gen (random_gen linarith.comp_source)))) : is_domain (complete_semilattice_Sup (random_gen (random_gen linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_96029 (h0 : semiring (mul_zero_class num)) : is_noetherian_ring (mul_zero_class num) := sorry --non-trivial
lemma new_lemma_96030 (h0 : ordered_comm_monoid (normed_lattice_add_comm_group (has_neg pos))) : has_exists_mul_of_le (normed_lattice_add_comm_group (has_neg pos)) := sorry --non-trivial
lemma new_lemma_96031 (h0 : functor.add_const (function.extfun Type group) linarith.comp) : @group.fg.{0} (ring.{0} pos) (@function.extfun_app.{2 1} Type group.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type group.{0}) linarith.comp h0) (ring.{0} pos))  := sorry --non-trivial
lemma new_lemma_96032 (h0 : ring (finset (mul_one_class (has_neg environment.implicit_infer_kind)))) : is_principal_ideal_ring (finset (mul_one_class (has_neg environment.implicit_infer_kind))) := sorry --non-trivial
lemma new_lemma_96033 (h0 : functor.add_const (function.extfun Type topological_space) (option (mul_zero_class pos))) : @normal_space.{0} (mul_zero_class.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) (option.{0} (mul_zero_class.{0} pos)) h0) (mul_zero_class.{0} name))  := sorry --non-trivial
lemma new_lemma_96034 (h0 : functor.add_const (list (finset pos)) Type) : palindrome (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_96035 (h0 : function.extfun nat fin) : @path_connected_space.{1} (canonically_ordered_monoid.{1} Type) (@matrix.vec_empty.{1} (topological_space.{1} (canonically_ordered_monoid.{1} Type)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_96036 (h0 : topological_space (has_neg (has_nndist name))) : regular_space (has_neg (has_nndist name)) := sorry --non-trivial
lemma new_lemma_96037 (h0 : semiring (normed_lattice_add_comm_group (has_neg (has_Inf real)))) : is_noetherian_ring (normed_lattice_add_comm_group (has_neg (has_Inf real))) := sorry --non-trivial
lemma new_lemma_96038 (h0 : ring (denumerable (random_gen (has_inv string_imp)))) : strong_rank_condition (denumerable (random_gen (has_inv string_imp))) := sorry --non-trivial
lemma new_lemma_96039 (h0 : functor.add_const (group (has_zero Type)) linarith.comp) : @group.fg.{1} (has_zero.{1} Type) (@functor.add_const.run.{1 0} (group.{1} (has_zero.{1} Type)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_96040 (h0 : add_group (ring congr_arg_kind)) : is_add_cyclic (ring congr_arg_kind) := sorry --non-trivial
lemma new_lemma_96041 (h0 : functor.add_const (list (has_edist empty)) (option (option empty))) : palindrome (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_96042 (h4 : set (std_gen -> enat)) : set.separates_points h4 := sorry --non-trivial
lemma new_lemma_96043 (h0 : topological_space (semi_normed_ring to_additive.value_type)) (h1 : preorder (semi_normed_ring to_additive.value_type)) : order_topology (semi_normed_ring to_additive.value_type) := sorry --non-trivial
lemma new_lemma_96044 (h0 : not (complete_lattice (distrib to_additive.value_type) -> false)) : @complete_lattice.is_Sup_finite_compact.{0} (distrib.{0} to_additive.value_type) (@classical.by_contradiction'.{1} (complete_lattice.{0} (distrib.{0} to_additive.value_type)) h0)  := sorry --non-trivial
lemma new_lemma_96045 (h0 : topological_space (has_lt to_additive.value_type)) (h1 : preorder (has_lt to_additive.value_type)) : order_topology (has_lt to_additive.value_type) := sorry --non-trivial
lemma new_lemma_96046 (h1 : complete_lattice (complete_semilattice_Sup linarith.comp)) : complete_lattice.is_Sup_finite_compact (complete_semilattice_Sup linarith.comp) := sorry --non-trivial
lemma new_lemma_96047 (h0 : not (group (with_bot fun_info) -> false)) : @is_cyclic.{0} (with_bot.{0} fun_info) (@classical.by_contradiction'.{1} (group.{0} (with_bot.{0} fun_info)) h0)  := sorry --non-trivial
lemma new_lemma_96048 (h0 : uniform_space (add_group (has_top (semiring linarith.comp)))) : separated_space (add_group (has_top (semiring linarith.comp))) := sorry --non-trivial
lemma new_lemma_96049 (h0 : group (add_cancel_monoid (boolean_algebra Type))) : is_cyclic (add_cancel_monoid (boolean_algebra Type)) := sorry --non-trivial
lemma new_lemma_96050 (h0 : group (finset (finset (has_nndist Type)))) : is_simple_group (finset (finset (has_nndist Type))) := sorry --non-trivial
lemma new_lemma_96051 (h0 : function.extfun (finset Type) (has_mem.mem (has_emptyc linarith.comp_source))) : @irreducible_space.{0} (has_emptyc.{0} linarith.comp_source) (@finset.pi.empty.{1 0} Type topological_space.{0} (has_emptyc.{0} linarith.comp_source) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (has_emptyc.{0} linarith.comp_source)) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_96052 (h0 : ring (distrib (mul_one_class to_additive.value_type))) : is_domain (distrib (mul_one_class to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_96053 (h0 : topological_space (sub_neg_monoid (has_Inf linarith.comp))) : t1_space (sub_neg_monoid (has_Inf linarith.comp)) := sorry --non-trivial
lemma new_lemma_96054 (h0 : function.extfun Type group) : @normalizer_condition.{0} (linear_ordered_cancel_comm_monoid.{0} (semiring.{0} empty)) (@function.extfun_app.{2 1} Type group.{0} h0 (linear_ordered_cancel_comm_monoid.{0} (semiring.{0} empty)))  := sorry --non-trivial
lemma new_lemma_96055 (h0 : topological_space (has_pos_part (has_Inf linarith.comp))) : topological_space.separable_space (has_pos_part (has_Inf linarith.comp)) := sorry --non-trivial
lemma new_lemma_96056 (h0 : ring (lex (distrib (comm_ring char)))) : is_domain (lex (distrib (comm_ring char))) := sorry --non-trivial
lemma new_lemma_96057 (h0 : filter (boolean_algebra.core (comm_group environment.implicit_infer_kind))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_96058 (h1 : topological_space (with_one (has_top linarith.comp_source))) : totally_disconnected_space (with_one (has_top linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_96059 (h0 : ring (finset (finset (finset linarith.comp)))) : is_principal_ideal_ring (finset (finset (finset linarith.comp))) := sorry --non-trivial
lemma new_lemma_96060 (h1 : ring (linear_ordered_comm_group_with_zero string.iterator_imp)) : strong_rank_condition (linear_ordered_comm_group_with_zero string.iterator_imp) := sorry --non-trivial
lemma new_lemma_96061 (h0 : group (has_pos_part (finset (has_add (has_add (has_add pos)))))) : normalizer_condition (has_pos_part (finset (has_add (has_add (has_add pos))))) := sorry --non-trivial
lemma new_lemma_96062 (h0 : add_group (has_norm (random_gen (random_gen num)))) : is_add_cyclic (has_norm (random_gen (random_gen num))) := sorry --non-trivial
lemma new_lemma_96063 (h0 : ordered_comm_monoid (ordered_comm_monoid real)) : has_exists_mul_of_le (ordered_comm_monoid real) := sorry --non-trivial
lemma new_lemma_96064 (h0 : function.extfun Type topological_space) : @totally_separated_space.{0} (has_neg.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_neg.{0} num))  := sorry --non-trivial
lemma new_lemma_96065 (h0 : function.extfun Type group) : @group.fg.{0} (left_cancel_semigroup.{0} unsigned) (@function.extfun_app.{2 1} Type group.{0} h0 (left_cancel_semigroup.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_96066 (h0 : topological_space (linear_ordered_semiring (semiring (semiring (semiring empty))))) : path_connected_space (linear_ordered_semiring (semiring (semiring (semiring empty)))) := sorry --non-trivial
lemma new_lemma_96067 (h0 : functor.add_const (topological_space pos) pos) : @loc_path_connected_space.{0} pos (@functor.add_const.run.{0 0} (topological_space.{0} pos) pos h0)  := sorry --non-trivial
lemma new_lemma_96068 (h0 : functor.add_const (topological_space (semigroup environment.implicit_infer_kind)) environment.implicit_infer_kind) : @t0_space.{0} (semigroup.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (semigroup.{0} environment.implicit_infer_kind)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_96069 (h0 : not (function.extfun Type ring -> false)) : @strong_rank_condition.{0} (has_star.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type ring.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type ring.{0}) h0) (has_star.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_96070 (h0 : topological_space (canonically_ordered_monoid pos)) : totally_disconnected_space (canonically_ordered_monoid pos) := sorry --non-trivial
lemma new_lemma_96071 (h0 : topological_space (has_sub (semiring congr_arg_kind))) : discrete_topology (has_sub (semiring congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_96072 (h0 : functor.add_const (add_monoid (non_assoc_semiring congr_arg_kind)) unsigned) : @add_monoid.fg.{0} (non_assoc_semiring.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (add_monoid.{0} (non_assoc_semiring.{0} congr_arg_kind)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_96073 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @discrete_topology.{0} (semigroup.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (semigroup.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_96074 (h0 : group (add_cancel_comm_monoid (has_nnnorm (has_nnnorm (has_nnnorm reducibility_hints))))) : is_cyclic (add_cancel_comm_monoid (has_nnnorm (has_nnnorm (has_nnnorm reducibility_hints)))) := sorry --non-trivial
lemma new_lemma_96075 (h0 : semiring (boolean_algebra (has_Inf name))) : is_noetherian_ring (boolean_algebra (has_Inf name)) := sorry --non-trivial
lemma new_lemma_96076 (h0 : ring (with_bot (random_gen fun_info))) : rank_condition (with_bot (random_gen fun_info)) := sorry --non-trivial
lemma new_lemma_96077 (h0 : topological_space (add_right_cancel_monoid (semiring (semiring num)))) : discrete_topology (add_right_cancel_monoid (semiring (semiring num))) := sorry --non-trivial
lemma new_lemma_96078 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_compactly_generated.{0} (add_cancel_monoid.{0} linarith.comp) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (add_cancel_monoid.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_96079 (h0 : ring (linear_ordered_comm_group_with_zero string_imp)) : rank_condition (linear_ordered_comm_group_with_zero string_imp) := sorry --non-trivial
lemma new_lemma_96080 (h0 : set (non_unital_non_assoc_semiring std_gen)) : set.subsingleton h0 := sorry --non-trivial
lemma new_lemma_96081 (h0 : topological_space (boolean_algebra (finset environment.implicit_infer_kind))) : sequential_space (boolean_algebra (finset environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_96082 (h0 : list (ordered_comm_group (option (option empty)))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_96083 (h0 : complete_lattice (has_norm (has_norm (has_norm linarith.comp_source)))) : complete_lattice.is_Sup_finite_compact (has_norm (has_norm (has_norm linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_96084 (h0 : function.extfun Type uniform_space) : @separated_space.{0} (canonically_ordered_comm_semiring.{0} linarith.comp) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (canonically_ordered_comm_semiring.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_96085 (h0 : topological_space (mul_zero_class empty)) : t0_space (mul_zero_class empty) := sorry --non-trivial
lemma new_lemma_96086 (h0 : function.extfun (finset (Type -> Type)) (has_mem.mem topological_space)) : @discrete_topology.{0} (with_one.{0} fun_info) (@function.extfun_app.{2 1} Type topological_space.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) topological_space.{0} (@function.extfun_app.{2 0} (finset.{1} (Type → Type)) (@has_mem.mem.{1 1} (Type → Type) (finset.{1} (Type → Type)) (@finset.has_mem.{1} (Type → Type)) topological_space.{0}) h0 (@has_emptyc.emptyc.{1} (finset.{1} (Type → Type)) (@finset.has_emptyc.{1} (Type → Type))))) (with_one.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_96087 (h0 : functor.add_const (function.extfun Type topological_space) name) : @t0_space.{0} (has_nndist.{0} ennreal) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) name h0) (has_nndist.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_96088 (h2 : topological_space (add_comm_semigroup (normed_field std_gen))) (h3 : preorder (add_comm_semigroup (normed_field std_gen))) : order_closed_topology (add_comm_semigroup (normed_field std_gen)) := sorry --non-trivial
lemma new_lemma_96089 (h0 : filter (has_top (has_norm num))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_96090 (h0 : ring (add_cancel_comm_monoid (has_nnnorm (comm_ring (has_nnnorm reducibility_hints))))) : is_domain (add_cancel_comm_monoid (has_nnnorm (comm_ring (has_nnnorm reducibility_hints)))) := sorry --non-trivial
lemma new_lemma_96091 (h0 : ring (normed_group unsigned)) : is_principal_ideal_ring (normed_group unsigned) := sorry --non-trivial
lemma new_lemma_96092 (h0 : functor.add_const (ring (mul_zero_class unsigned)) empty) : @rank_condition.{0} (mul_zero_class.{0} unsigned) (@functor.add_const.run.{0 0} (ring.{0} (mul_zero_class.{0} unsigned)) empty h0)  := sorry --non-trivial
lemma new_lemma_96093 (h0 : function.extfun Type semiring) : @is_noetherian_ring.{0} (has_add.{0} linarith.comp) (@function.extfun_app.{2 1} Type semiring.{0} h0 (has_add.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_96094 (h0 : functor.add_const (function.extfun Type group) linarith.comp) : @group.fg.{0} (generalized_boolean_algebra.{0} linarith.comp) (@function.extfun_app.{2 1} Type group.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type group.{0}) linarith.comp h0) (generalized_boolean_algebra.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_96095 (h2 : group (with_one num)) : group.fg (with_one num) := sorry --non-trivial
lemma new_lemma_96096 (h0 : ring (complete_semilattice_Sup (random_gen (random_gen to_additive.value_type)))) : rank_condition (complete_semilattice_Sup (random_gen (random_gen to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_96097 (h0 : not (function.extfun Type ring -> false)) : @rank_condition.{0} (has_one.{0} linarith.comp) (@function.extfun_app.{2 1} Type ring.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type ring.{0}) h0) (has_one.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_96098 (h0 : topological_space (has_zero (option (option (option unsigned))))) : regular_space (has_zero (option (option (option unsigned)))) := sorry --non-trivial
lemma new_lemma_96099 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @t0_space.{1} (normed_lattice_add_comm_group.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 topological_space.{1}) (normed_lattice_add_comm_group.{1} Type))  := sorry --non-trivial
lemma new_lemma_96100 (h0 : function.extfun Type (functor.add_const (topological_space (has_to_string ennreal)))) : @irreducible_space.{0} (has_to_string.{0} ennreal) (@functor.add_const.run.{0 0} (topological_space.{0} (has_to_string.{0} ennreal)) num (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (topological_space.{0} (has_to_string.{0} ennreal))) h0 num))  := sorry --non-trivial
lemma new_lemma_96101 (h0 : topological_space (with_bot (has_norm (has_norm num)))) : discrete_topology (with_bot (has_norm (has_norm num))) := sorry --non-trivial
lemma new_lemma_96102 (h0 : functor.add_const (filter (has_add environment.implicit_infer_kind)) (has_neg (has_neg (ring Type)))) : filter.ne_bot (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_96103 (h0 : functor.add_const (topological_space (ordered_comm_monoid linarith.comp)) Type) : @preconnected_space.{0} (ordered_comm_monoid.{0} linarith.comp) (@functor.add_const.run.{0 1} (topological_space.{0} (ordered_comm_monoid.{0} linarith.comp)) Type h0)  := sorry --non-trivial
lemma new_lemma_96104 (h0 : simple_graph (semi_normed_ring (mul_one_class (mul_one_class (mul_one_class (mul_one_class std_gen)))))) (h1 : semi_normed_ring (mul_one_class (mul_one_class (mul_one_class (mul_one_class std_gen))))) : set.subsingleton (simple_graph.neighbor_set h0 h1) := sorry --non-trivial
lemma new_lemma_96105 (h0 : finset (measurable_space linarith.comp)) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_96106 (h0 : functor.add_const (semiring (boolean_algebra.core empty)) unsigned) : @is_noetherian_ring.{0} (boolean_algebra.core.{0} empty) (@functor.add_const.run.{0 0} (semiring.{0} (boolean_algebra.core.{0} empty)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_96107 (h0 : functor.add_const (add_group (boolean_algebra Type)) Type) : @is_add_cyclic.{1} (boolean_algebra.{1} Type) (@functor.add_const.run.{1 1} (add_group.{1} (boolean_algebra.{1} Type)) Type h0)  := sorry --non-trivial
lemma new_lemma_96108 (h0 : ordered_comm_monoid (boolean_algebra (has_Inf linarith.comp))) : has_exists_mul_of_le (boolean_algebra (has_Inf linarith.comp)) := sorry --non-trivial
lemma new_lemma_96109 (h0 : not (ring (fintype to_additive.value_type) -> false)) : @is_domain.{0} (fintype.{0} to_additive.value_type) (@classical.by_contradiction'.{1} (ring.{0} (fintype.{0} to_additive.value_type)) h0)  := sorry --non-trivial
lemma new_lemma_96110 (h0 : complete_lattice (add_right_cancel_monoid (semiring num))) : is_compactly_generated (add_right_cancel_monoid (semiring num)) := sorry --non-trivial
lemma new_lemma_96111 (h0 : ring (measurable_space.dynkin_system (semiring (semiring (has_norm unsigned))))) : strong_rank_condition (measurable_space.dynkin_system (semiring (semiring (has_norm unsigned)))) := sorry --non-trivial
lemma new_lemma_96112 (h1 : function.extfun Type group) : @is_cyclic.{0} (measurable_space.{0} empty) (@function.extfun_app.{2 1} Type group.{0} h1 (measurable_space.{0} empty))  := sorry --non-trivial
lemma new_lemma_96113 (h0 : functor.add_const (list (comm_group linarith.comp)) linarith.comp) : list.nodup (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_96114 (h0 : topological_space (normed_lattice_add_comm_group (has_Inf (has_add pos)))) : preconnected_space (normed_lattice_add_comm_group (has_Inf (has_add pos))) := sorry --non-trivial
lemma new_lemma_96115 (h0 : set (preorder fun_info)) : set.subsingleton h0 := sorry --non-trivial
lemma new_lemma_96116 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @rank_condition.{0} (add_group.{0} empty) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (add_group.{0} empty))  := sorry --non-trivial
lemma new_lemma_96117 (h0 : monoid (has_dist (comm_monoid unsigned))) : monoid.fg (has_dist (comm_monoid unsigned)) := sorry --non-trivial
lemma new_lemma_96118 (h0 : complete_lattice (with_bot (random_gen (random_gen num)))) : is_atomistic (with_bot (random_gen (random_gen num))) := sorry --non-trivial
lemma new_lemma_96119 (h0 : function.extfun Type topological_space) : @discrete_topology.{0} (has_union.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_union.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_96120 (h0 : function.extfun Type topological_space) : @path_connected_space.{0} (random_gen.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (random_gen.{0} num))  := sorry --non-trivial
lemma new_lemma_96121 (h0 : ring (monoid (option (option unsigned)))) : is_principal_ideal_ring (monoid (option (option unsigned))) := sorry --non-trivial
lemma new_lemma_96122 (h0 : ring (finset (finset (has_add linarith.comp)))) : rank_condition (finset (finset (has_add linarith.comp))) := sorry --non-trivial
lemma new_lemma_96123 (h0 : not (function.extfun (Type -> Type) (function.extfun Type) -> false)) : @preirreducible_space.{0} (normed_group.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) (@classical.by_contradiction'.{2} (function.extfun.{2 2} (Type → Type) (function.extfun.{2 1} Type)) h0) topological_space.{0}) (normed_group.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_96124 (h0 : uniform_space (has_union (has_union (has_union linarith.comp)))) : separated_space (has_union (has_union (has_union linarith.comp))) := sorry --non-trivial
lemma new_lemma_96125 (h0 : topological_space (has_add (has_add linarith.comp))) : sequential_space (has_add (has_add linarith.comp)) := sorry --non-trivial
lemma new_lemma_96126 (h0 : functor.add_const (function.extfun Type group) name) : @normalizer_condition.{0} (has_Inf.{0} linarith.comp) (@function.extfun_app.{2 1} Type group.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type group.{0}) name h0) (has_Inf.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_96127 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_principal_ideal_ring.{0} (has_neg.{0} pos) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (has_neg.{0} pos))  := sorry --non-trivial
lemma new_lemma_96128 (h0 : functor.add_const (list (has_add linarith.comp)) pos) : palindrome (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_96129 (h0 : functor.add_const (function.extfun Type complete_lattice) pos) : @is_atomistic.{0} (ring.{0} pos) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type complete_lattice.{0}) pos h0) (ring.{0} pos))  := sorry --non-trivial
lemma new_lemma_96130 (h0 : set (add_comm_semigroup (add_comm_semigroup linarith.ineq) -> ereal)) : set.separates_points h0 := sorry --non-trivial
lemma new_lemma_96131 (h0 : ring (measure_theory.measure_space linarith.ineq)) : strong_rank_condition (measure_theory.measure_space linarith.ineq) := sorry --non-trivial
lemma new_lemma_96132 (h0 : functor.add_const Prop (add_comm_monoid (finset (finset (finset pos))))) : functor.add_const.run h0 := sorry --non-trivial
lemma new_lemma_96133 (h0 : semiring (has_add (has_pos_part pos))) : is_noetherian_ring (has_add (has_pos_part pos)) := sorry --non-trivial
lemma new_lemma_96134 (h0 : topological_space (complete_distrib_lattice (option (option (option empty))))) : t0_space (complete_distrib_lattice (option (option (option empty)))) := sorry --non-trivial
lemma new_lemma_96135 (h0 : function.extfun Type topological_space) : @path_connected_space.{0} (has_nndist.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_nndist.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_96136 (h0 : topological_space (comm_group (comm_group (comm_group pos)))) : normal_space (comm_group (comm_group (comm_group pos))) := sorry --non-trivial
lemma new_lemma_96137 (h0 : cancel_comm_monoid_with_zero (add_right_cancel_monoid unsigned)) : unique_factorization_monoid (add_right_cancel_monoid unsigned) := sorry --non-trivial
lemma new_lemma_96138 (h0 : functor.add_const (function.extfun Type topological_space) pos) : @totally_disconnected_space.{0} (semigroup.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) pos h0) (semigroup.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_96139 (h0 : group (topological_space (random_gen (random_gen to_additive.value_type)))) : group.fg (topological_space (random_gen (random_gen to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_96140 (h1 : filter (linear_ordered_add_comm_group (has_inv string_imp))) : filter.ne_bot h1 := sorry --non-trivial
lemma new_lemma_96141 (h0 : ring (has_zero (comm_group (comm_group (comm_group name))))) : strong_rank_condition (has_zero (comm_group (comm_group (comm_group name)))) := sorry --non-trivial
lemma new_lemma_96142 (h0 : group (comm_semigroup real)) : normalizer_condition (comm_semigroup real) := sorry --non-trivial
lemma new_lemma_96143 (h0 : ring (topological_space (topological_space linarith.comp_source))) : strong_rank_condition (topological_space (topological_space linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_96144 (h0 : semiring (add_right_cancel_monoid num)) : is_noetherian_ring (add_right_cancel_monoid num) := sorry --non-trivial
lemma new_lemma_96145 (h0 : function.extfun Type topological_space) : @locally_compact_space.{0} (non_assoc_semiring.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (non_assoc_semiring.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_96146 (h0 : uniform_space (cancel_monoid ennreal)) : separated_space (cancel_monoid ennreal) := sorry --non-trivial
lemma new_lemma_96147 (h0 : topological_space (boolean_algebra.core (has_neg_part (comm_group name)))) : normal_space (boolean_algebra.core (has_neg_part (comm_group name))) := sorry --non-trivial
lemma new_lemma_96148 (h0 : fin has_zero.zero) : @preirreducible_space.{1} (canonically_ordered_comm_semiring.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@matrix.vec_empty.{2} (function.extfun.{3 2} (Type 1) topological_space.{1}) h0) (canonically_ordered_comm_semiring.{1} Type))  := sorry --non-trivial
lemma new_lemma_96149 (h0 : functor.add_const (function.extfun Type list) name) : palindrome (function.extfun_app (functor.add_const.run h0) (has_Inf pos)) := sorry --non-trivial
lemma new_lemma_96150 (h0 : monoid (has_top (semiring num))) : monoid.fg (has_top (semiring num)) := sorry --non-trivial
lemma new_lemma_96151 (h0 : uniform_space (has_le to_additive.value_type)) : complete_space (has_le to_additive.value_type) := sorry --non-trivial
lemma new_lemma_96152 (h0 : functor.add_const (topological_space (boolean_algebra Type)) (has_Inf pos)) : @preirreducible_space.{1} (boolean_algebra.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (boolean_algebra.{1} Type)) (has_Inf.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_96153 (h0 : functor.add_const (topological_space (normed_comm_ring environment.implicit_infer_kind)) Type) : @regular_space.{0} (normed_comm_ring.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 1} (topological_space.{0} (normed_comm_ring.{0} environment.implicit_infer_kind)) Type h0)  := sorry --non-trivial
lemma new_lemma_96154 (h1 : list (fintype (linear_ordered_add_comm_group (comm_ring (linear_ordered_add_comm_group char))))) : list.nodup h1 := sorry --non-trivial
lemma new_lemma_96155 (h1 : topological_space (random_gen congr_arg_kind)) : locally_compact_space (random_gen congr_arg_kind) := sorry --non-trivial
lemma new_lemma_96156 (h0 : not (topological_space (normed_group empty) -> false)) : @discrete_topology.{0} (normed_group.{0} empty) (@classical.by_contradiction'.{1} (topological_space.{0} (normed_group.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_96157 (h0 : has_lt (has_lt (mul_one_class (mul_one_class linarith.comp_source)))) : no_max_order (has_lt (mul_one_class (mul_one_class linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_96158 (h0 : topological_space (has_one (semiring linarith.comp))) : locally_compact_space (has_one (semiring linarith.comp)) := sorry --non-trivial
lemma new_lemma_96159 (h0 : group (comm_group (has_add (has_add environment.implicit_infer_kind)))) : group.fg (comm_group (has_add (has_add environment.implicit_infer_kind))) := sorry --non-trivial
lemma new_lemma_96160 (h0 : not (complete_lattice (complete_semilattice_Sup num) -> false)) : @is_compactly_generated.{0} (complete_semilattice_Sup.{0} num) (@classical.by_contradiction'.{1} (complete_lattice.{0} (complete_semilattice_Sup.{0} num)) h0)  := sorry --non-trivial
lemma new_lemma_96161 (h0 : list (semigroup num)) : palindrome h0 := sorry --non-trivial
lemma new_lemma_96162 (h0 : add_monoid (semiring (has_norm empty))) : add_monoid.fg (semiring (has_norm empty)) := sorry --non-trivial
lemma new_lemma_96163 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @regular_space.{0} (generalized_boolean_algebra.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (generalized_boolean_algebra.{0} pos))  := sorry --non-trivial
lemma new_lemma_96164 (h0 : not (complete_lattice string.iterator_imp -> false)) : @complete_lattice.is_Sup_finite_compact.{0} string.iterator_imp (@classical.by_contradiction'.{1} (complete_lattice.{0} string.iterator_imp) h0)  := sorry --non-trivial
lemma new_lemma_96165 (h0 : not (function.extfun Type monoid -> false)) : @monoid.fg.{0} (normed_group.{0} fun_info) (@function.extfun_app.{2 1} Type monoid.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type monoid.{0}) h0) (normed_group.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_96166 (h0 : function.extfun Type finset) : finset.nonempty (function.extfun_app h0 (preorder empty)) := sorry --non-trivial
lemma new_lemma_96167 (h1 : topological_space (has_append (comm_ring (comm_ring reducibility_hints)))) : t0_space (has_append (comm_ring (comm_ring reducibility_hints))) := sorry --non-trivial
lemma new_lemma_96168 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : finset.nonempty (function.extfun_app (function.extfun_app h0 finset) (has_edist empty)) := sorry --non-trivial
lemma new_lemma_96169 (h0 : ring (ordered_comm_ring (has_pos_part pos))) : is_domain (ordered_comm_ring (has_pos_part pos)) := sorry --non-trivial
lemma new_lemma_96170 (h0 : not (add_group (complete_semilattice_Sup linarith.ineq) -> false)) : @is_add_cyclic.{0} (complete_semilattice_Sup.{0} linarith.ineq) (@classical.by_contradiction'.{1} (add_group.{0} (complete_semilattice_Sup.{0} linarith.ineq)) h0)  := sorry --non-trivial
lemma new_lemma_96171 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @normal_space.{0} (complete_distrib_lattice.{0} (option.{0} empty)) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (complete_distrib_lattice.{0} (option.{0} empty)))  := sorry --non-trivial
lemma new_lemma_96172 (h0 : group (has_add (option (option (option (option pos)))))) : is_cyclic (has_add (option (option (option (option pos))))) := sorry --non-trivial
lemma new_lemma_96173 (h0 : add_monoid (has_inter congr_arg_kind)) : add_monoid.fg (has_inter congr_arg_kind) := sorry --non-trivial
lemma new_lemma_96174 (h0 : ereal) (h1 : set ereal) : set.mem h0 h1 := sorry --non-trivial
lemma new_lemma_96175 (h0 : function.extfun Type topological_space) : @preirreducible_space.{0} (normed_linear_ordered_group.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (normed_linear_ordered_group.{0} empty))  := sorry --non-trivial
lemma new_lemma_96176 (h0 : set (enat -> mul_one_class enat)) : set.separates_points h0 := sorry --non-trivial
lemma new_lemma_96177 (h0 : uniform_space (simple_graph (finset (finset (finset linarith.comp))))) : separated_space (simple_graph (finset (finset (finset linarith.comp)))) := sorry --non-trivial
lemma new_lemma_96178 (h0 : ring (linear_ordered_semiring to_additive.value_type)) : is_domain (linear_ordered_semiring to_additive.value_type) := sorry --non-trivial
lemma new_lemma_96179 (h0 : group (normed_lattice_add_comm_group (has_add (has_Inf pos)))) : is_cyclic (normed_lattice_add_comm_group (has_add (has_Inf pos))) := sorry --non-trivial
lemma new_lemma_96180 (h0 : ring (uniform_space (mul_one_class enat))) : strong_rank_condition (uniform_space (mul_one_class enat)) := sorry --non-trivial
lemma new_lemma_96181 (h0 : not (function.extfun (Type -> Type) (function.extfun Type) -> false)) : @t0_space.{0} fun_info (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) (@classical.by_contradiction'.{2} (function.extfun.{2 2} (Type → Type) (function.extfun.{2 1} Type)) h0) topological_space.{0}) fun_info)  := sorry --non-trivial
lemma new_lemma_96182 (h0 : fin has_zero.zero) : @unique_factorization_monoid.{0} (normed_lattice_add_comm_group.{0} linarith.comp) (@matrix.vec_empty.{0} (cancel_comm_monoid_with_zero.{0} (normed_lattice_add_comm_group.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_96183 (h0 : topological_space (add_group empty)) : normal_space (add_group empty) := sorry --non-trivial
lemma new_lemma_96184 (h0 : topological_space (lex empty)) : totally_separated_space (lex empty) := sorry --non-trivial
lemma new_lemma_96185 (h0 : topological_space (boolean_algebra (has_add pos))) : totally_separated_space (boolean_algebra (has_add pos)) := sorry --non-trivial
lemma new_lemma_96186 (h0 : add_monoid (simple_graph (has_add linarith.comp))) : add_monoid.fg (simple_graph (has_add linarith.comp)) := sorry --non-trivial
lemma new_lemma_96187 (h0 : function.extfun Type monoid) : @monoid.fg.{0} (has_inter.{0} ennreal) (@function.extfun_app.{2 1} Type monoid.{0} h0 (has_inter.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_96188 (h0 : semiring (finset (option (finset pos)))) : is_noetherian_ring (finset (option (finset pos))) := sorry --non-trivial
lemma new_lemma_96189 (h0 : functor.add_const (topological_space (mul_zero_class name)) pos) : @path_connected_space.{0} (mul_zero_class.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (mul_zero_class.{0} name)) pos h0)  := sorry --non-trivial
lemma new_lemma_96190 (h0 : functor.add_const (topological_space (semigroup pos)) (finset linarith.comp)) : @totally_disconnected_space.{0} (semigroup.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (semigroup.{0} pos)) (finset.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_96191 (h0 : topological_space (has_pos_part (finset (finset Type)))) : irreducible_space (has_pos_part (finset (finset Type))) := sorry --non-trivial
lemma new_lemma_96192 (h0 : semiring (has_nndist (has_neg_part Type))) : is_noetherian_ring (has_nndist (has_neg_part Type)) := sorry --non-trivial
lemma new_lemma_96193 (h1 : function.extfun (Type -> Type) (function.extfun Type)) : @complete_lattice.is_Sup_finite_compact.{0} (@id.{2} Type string_imp) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h1 complete_lattice.{0}) (@id.{2} Type string_imp))  := sorry --non-trivial
lemma new_lemma_96194 (h0 : topological_space (boolean_algebra.core (boolean_algebra.core (finset pos)))) : normal_space (boolean_algebra.core (boolean_algebra.core (finset pos))) := sorry --non-trivial
lemma new_lemma_96195 (h0 : topological_space (has_bot (sub_neg_monoid (sub_neg_monoid (sub_neg_monoid name))))) : path_connected_space (has_bot (sub_neg_monoid (sub_neg_monoid (sub_neg_monoid name)))) := sorry --non-trivial
lemma new_lemma_96196 (h0 : filter (ring (mul_one_class linarith.comp))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_96197 (h0 : topological_space (complete_distrib_lattice (has_add Type))) : totally_separated_space (complete_distrib_lattice (has_add Type)) := sorry --non-trivial
lemma new_lemma_96198 (h0 : topological_space (has_nnnorm linarith.comp_source)) : totally_disconnected_space (has_nnnorm linarith.comp_source) := sorry --non-trivial
lemma new_lemma_96199 (h0 : prod (has_to_string Type) (has_to_string Type)) : id_rel h0 := sorry --non-trivial
lemma new_lemma_96200 (h0 : ring (has_emptyc (has_top fun_info))) : strong_rank_condition (has_emptyc (has_top fun_info)) := sorry --non-trivial
lemma new_lemma_96201 (h0 : function.extfun nat fin) : @complete_space.{0} (canonically_ordered_monoid.{0} linarith.comp) (@matrix.vec_empty.{0} (uniform_space.{0} (canonically_ordered_monoid.{0} linarith.comp)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_96202 (h1 : topological_space (with_zero (has_inv (has_inv (has_ssubset string_imp))))) : totally_disconnected_space (with_zero (has_inv (has_inv (has_ssubset string_imp)))) := sorry --non-trivial
lemma new_lemma_96203 (h0 : prod (has_neg Type) (has_neg Type)) : id_rel h0 := sorry --non-trivial
lemma new_lemma_96204 (h1 : add_group (has_compl char)) : is_add_cyclic (has_compl char) := sorry --non-trivial
lemma new_lemma_96205 (h0 : function.extfun Type complete_lattice) : @is_compactly_generated.{0} (has_inv.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (has_inv.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_96206 (h0 : functor.add_const (function.extfun Type topological_space) (finset (finset pos))) : @preirreducible_space.{0} (has_nndist.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) (finset.{0} (finset.{0} pos)) h0) (has_nndist.{0} pos))  := sorry --non-trivial
lemma new_lemma_96207 (h0 : topological_space (normed_comm_ring (has_add name))) : totally_disconnected_space (normed_comm_ring (has_add name)) := sorry --non-trivial
lemma new_lemma_96208 (h0 : functor.add_const (ordered_add_comm_monoid (ordered_comm_ring real)) (has_Inf (has_Inf name))) : @archimedean.{0} (ordered_comm_ring.{0} real) (@functor.add_const.run.{0 0} (ordered_add_comm_monoid.{0} (ordered_comm_ring.{0} real)) (has_Inf.{0} (has_Inf.{0} name)) h0)  := sorry --non-trivial
lemma new_lemma_96209 (h0 : not (ring name -> false)) : @is_domain.{0} name (@classical.by_contradiction'.{1} (ring.{0} name) h0)  := sorry --non-trivial
lemma new_lemma_96210 (h0 : add_group (has_emptyc (random_gen (has_top (random_gen linarith.comp_source))))) : is_add_cyclic (has_emptyc (random_gen (has_top (random_gen linarith.comp_source)))) := sorry --non-trivial
lemma new_lemma_96211 (h0 : filter (add_comm_monoid (comm_group Type))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_96212 (h0 : functor.add_const (ring (normed_comm_ring name)) pos) : @rank_condition.{0} (normed_comm_ring.{0} name) (@functor.add_const.run.{0 0} (ring.{0} (normed_comm_ring.{0} name)) pos h0)  := sorry --non-trivial
lemma new_lemma_96213 (h0 : complete_lattice (ordered_comm_ring (has_Inf real))) : is_compactly_generated (ordered_comm_ring (has_Inf real)) := sorry --non-trivial
lemma new_lemma_96214 (h0 : ring (boolean_algebra.core ennreal)) : strong_rank_condition (boolean_algebra.core ennreal) := sorry --non-trivial
lemma new_lemma_96215 (h0 : uniform_space (linear_ordered_semiring linarith.comp)) : complete_space (linear_ordered_semiring linarith.comp) := sorry --non-trivial
lemma new_lemma_96216 (h0 : topological_space (monoid_with_zero ennreal)) : preconnected_space (monoid_with_zero ennreal) := sorry --non-trivial
lemma new_lemma_96217 (h0 : complete_lattice (has_star (semiring (semiring congr_arg_kind)))) : is_compactly_generated (has_star (semiring (semiring congr_arg_kind))) := sorry --non-trivial
lemma new_lemma_96218 (h0 : monoid (normed_linear_ordered_group empty)) : monoid.fg (normed_linear_ordered_group empty) := sorry --non-trivial
lemma new_lemma_96219 (h0 : ring (sub_neg_monoid Type)) : is_principal_ideal_ring (sub_neg_monoid Type) := sorry --non-trivial
lemma new_lemma_96220 (h0 : topological_space (has_union (semiring congr_arg_kind))) : locally_compact_space (has_union (semiring congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_96221 (h0 : functor.add_const (add_monoid (has_zero linarith.comp)) linarith.comp) : @add_monoid.fg.{0} (has_zero.{0} linarith.comp) (@functor.add_const.run.{0 0} (add_monoid.{0} (has_zero.{0} linarith.comp)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_96222 (h0 : function.extfun (Type 1) ring) : @is_principal_ideal_ring.{1} (has_zero.{1} Type) (@function.extfun_app.{3 2} (Type 1) ring.{1} h0 (has_zero.{1} Type))  := sorry --non-trivial
lemma new_lemma_96223 (h0 : topological_space (normed_lattice_add_comm_group (has_pos_part Type))) : topological_space.separable_space (normed_lattice_add_comm_group (has_pos_part Type)) := sorry --non-trivial
lemma new_lemma_96224 (h0 : complete_lattice (comm_group (has_neg_part pos))) : is_compactly_generated (comm_group (has_neg_part pos)) := sorry --non-trivial
lemma new_lemma_96225 (h0 : group (has_nndist (has_add (has_nndist (mul_zero_class (option name)))))) : is_cyclic (has_nndist (has_add (has_nndist (mul_zero_class (option name))))) := sorry --non-trivial
lemma new_lemma_96226 (h0 : topological_space (random_gen (has_nnnorm char))) (h1 : option (topological_space (random_gen (has_nnnorm char)))) : t0_space (random_gen (has_nnnorm char)) := sorry --non-trivial
lemma new_lemma_96227 (h0 : functor.add_const (function.extfun Type ordered_comm_monoid) Type) : @has_exists_mul_of_le.{0} (add_comm_monoid.{0} linarith.comp) (@function.extfun_app.{2 1} Type ordered_comm_monoid.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type ordered_comm_monoid.{0}) Type h0) (add_comm_monoid.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_96228 (h0 h1 : multiset (add_comm_semigroup fun_info)) : multiset.le h0 h1 := sorry --non-trivial
lemma new_lemma_96229 (h0 : cancel_comm_monoid_with_zero (ring (normed_comm_ring pos))) : unique_factorization_monoid (ring (normed_comm_ring pos)) := sorry --non-trivial
lemma new_lemma_96230 (h0 : complete_lattice (has_union linarith.comp)) : is_atomistic (has_union linarith.comp) := sorry --non-trivial
lemma new_lemma_96231 (h0 : not (complete_lattice (measurable_space linarith.comp_source) -> false)) : complete_lattice.is_Sup_finite_compact (measurable_space linarith.comp_source) := sorry --non-trivial
lemma new_lemma_96232 (h0 : uniform_space (boolean_algebra (has_Inf (has_pos_part linarith.comp)))) : complete_space (boolean_algebra (has_Inf (has_pos_part linarith.comp))) := sorry --non-trivial
lemma new_lemma_96233 (h0 : functor.add_const (topological_space (cancel_monoid pos)) name) : @discrete_topology.{0} (cancel_monoid.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (cancel_monoid.{0} pos)) name h0)  := sorry --non-trivial
lemma new_lemma_96234 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @strong_rank_condition.{0} (finset.{0} ennreal) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (finset.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_96235 (h1 : complete_lattice (with_one (random_gen to_additive.value_type))) : is_atomistic (with_one (random_gen to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_96236 (h0 : topological_space (ordered_comm_monoid (has_pos_part pos))) : irreducible_space (ordered_comm_monoid (has_pos_part pos)) := sorry --non-trivial
lemma new_lemma_96237 (h0 : functor.add_const (function.extfun Type list) name) : list.nodup (function.extfun_app (functor.add_const.run h0) (has_nndist pos)) := sorry --non-trivial
lemma new_lemma_96238 (h0 : monoid (is_R_or_C unsigned)) : monoid.fg (is_R_or_C unsigned) := sorry --non-trivial
lemma new_lemma_96239 (h0 : topological_space linarith.comp) : locally_compact_space linarith.comp := sorry --non-trivial
lemma new_lemma_96240 (h0 : functor.add_const (topological_space (add_cancel_monoid unsigned)) linarith.comp) : @totally_separated_space.{0} (add_cancel_monoid.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (add_cancel_monoid.{0} unsigned)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_96241 (h0 : not (function.extfun Type add_monoid -> false)) : @add_monoid.fg.{0} (with_bot.{0} empty) (@function.extfun_app.{2 1} Type add_monoid.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type add_monoid.{0}) h0) (with_bot.{0} empty))  := sorry --non-trivial
lemma new_lemma_96242 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @rank_condition.{0} (metric_space.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (metric_space.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_96243 (h0 : functor.add_const (ordered_comm_monoid (finset linarith.comp)) linarith.comp) : @has_exists_mul_of_le.{0} (finset.{0} linarith.comp) (@functor.add_const.run.{0 0} (ordered_comm_monoid.{0} (finset.{0} linarith.comp)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_96244 (h0 : function.extfun Type group) : @group.fg.{0} (mul_zero_class.{0} empty) (@function.extfun_app.{2 1} Type group.{0} h0 (mul_zero_class.{0} empty))  := sorry --non-trivial
lemma new_lemma_96245 (h0 : topological_space (has_add (option (option (ring pos))))) : totally_separated_space (has_add (option (option (ring pos)))) := sorry --non-trivial
lemma new_lemma_96246 (h0 : preorder char) (h1 : topological_space char) : Sup_convergence_class char := sorry --non-trivial
lemma new_lemma_96247 (h0 : topological_space (ordered_comm_monoid (has_add (has_Inf pos)))) : discrete_topology (ordered_comm_monoid (has_add (has_Inf pos))) := sorry --non-trivial
lemma new_lemma_96248 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @normalizer_condition.{0} (metric_space.{0} unsigned) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (metric_space.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_96249 (h0 : has_mem.mem linarith.comp_source has_emptyc.emptyc) : @locally_compact_space.{0} linarith.comp_source (@finset.pi.empty.{1 0} Type topological_space.{0} linarith.comp_source h0)  := sorry --non-trivial
lemma new_lemma_96250 (h0 : set (char -> fun_info)) : set.separates_points h0 := sorry --non-trivial
lemma new_lemma_96251 (h0 : topological_space (add_group (random_gen (has_norm num)))) : normal_space (add_group (random_gen (has_norm num))) := sorry --non-trivial
lemma new_lemma_96252 (h0 : group (normed_comm_ring (ring linarith.comp))) : is_simple_group (normed_comm_ring (ring linarith.comp)) := sorry --non-trivial
lemma new_lemma_96253 (h0 : ring (has_Inf (has_add (ring linarith.comp)))) : strong_rank_condition (has_Inf (has_add (ring linarith.comp))) := sorry --non-trivial
lemma new_lemma_96254 (h0 : uniform_space (has_star (semiring congr_arg_kind))) : complete_space (has_star (semiring congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_96255 (h0 : functor.add_const (semiring (group_with_zero num)) num) : @is_noetherian_ring.{0} (group_with_zero.{0} num) (@functor.add_const.run.{0 0} (semiring.{0} (group_with_zero.{0} num)) num h0)  := sorry --non-trivial
lemma new_lemma_96256 (h0 : add_group (is_R_or_C (semiring empty))) : is_add_cyclic (is_R_or_C (semiring empty)) := sorry --non-trivial
lemma new_lemma_96257 (h0 : group (add_group (has_union empty))) : is_cyclic (add_group (has_union empty)) := sorry --non-trivial
lemma new_lemma_96258 (h0 : topological_space (has_to_string (has_norm (has_top linarith.ineq)))) : locally_compact_space (has_to_string (has_norm (has_top linarith.ineq))) := sorry --non-trivial
lemma new_lemma_96259 (h0 : functor.add_const (cancel_comm_monoid_with_zero (has_Sup num)) num) : @unique_factorization_monoid.{0} (has_Sup.{0} num) (@functor.add_const.run.{0 0} (cancel_comm_monoid_with_zero.{0} (has_Sup.{0} num)) num h0)  := sorry --non-trivial
lemma new_lemma_96260 (h0 : functor.add_const (complete_lattice (simple_graph linarith.comp)) pos) : @is_compactly_generated.{0} (simple_graph.{0} linarith.comp) (@functor.add_const.run.{0 0} (complete_lattice.{0} (simple_graph.{0} linarith.comp)) pos h0)  := sorry --non-trivial
lemma new_lemma_96261 (h0 : add_group (has_le (simple_graph (normed_field (has_ssubset (normed_field reducibility_hints)))))) : is_add_cyclic (has_le (simple_graph (normed_field (has_ssubset (normed_field reducibility_hints))))) := sorry --non-trivial
lemma new_lemma_96262 (h0 : not (topological_space (random_gen linarith.ineq) -> false)) : @discrete_topology.{0} (random_gen.{0} linarith.ineq) (@classical.by_contradiction'.{1} (topological_space.{0} (random_gen.{0} linarith.ineq)) h0)  := sorry --non-trivial
lemma new_lemma_96263 (h0 : function.extfun (Type 1) complete_lattice) : @complete_lattice.is_Sup_finite_compact.{1} (complete_distrib_lattice.{1} Type) (@function.extfun_app.{3 2} (Type 1) complete_lattice.{1} h0 (complete_distrib_lattice.{1} Type))  := sorry --non-trivial
lemma new_lemma_96264 (h0 : group (with_one string_imp)) : normalizer_condition (with_one string_imp) := sorry --non-trivial
lemma new_lemma_96265 (h0 : not (has_mem.mem (linear_ordered_semiring num) has_emptyc.emptyc -> false)) : @totally_disconnected_space.{0} (linear_ordered_semiring.{0} num) (@finset.pi.empty.{1 0} Type topological_space.{0} (linear_ordered_semiring.{0} num) (@classical.by_contradiction'.{0} (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (linear_ordered_semiring.{0} num) (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))) h0))  := sorry --non-trivial
lemma new_lemma_96266 (h1 : not (complete_lattice (has_ssubset string_imp) -> false)) : @is_compactly_generated.{0} (has_ssubset.{0} string_imp) (@classical.by_contradiction'.{1} (complete_lattice.{0} (has_ssubset.{0} string_imp)) h1)  := sorry --non-trivial
lemma new_lemma_96267 (h0 : topological_space (complete_semilattice_Sup linarith.comp)) : locally_compact_space (complete_semilattice_Sup linarith.comp) := sorry --non-trivial
lemma new_lemma_96268 (h0 : functor.add_const (topological_space (left_cancel_monoid congr_arg_kind)) num) : @topological_space.separable_space.{0} (left_cancel_monoid.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (left_cancel_monoid.{0} congr_arg_kind)) num h0)  := sorry --non-trivial
lemma new_lemma_96269 (h1 : complete_lattice (linear_ordered_comm_group_with_zero linarith.comp_source)) : is_compactly_generated (linear_ordered_comm_group_with_zero linarith.comp_source) := sorry --non-trivial
lemma new_lemma_96270 (h0 : function.extfun Type monoid) : @monoid.fg.{0} (complete_distrib_lattice.{0} ennreal) (@function.extfun_app.{2 1} Type monoid.{0} h0 (complete_distrib_lattice.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_96271 (h0 : topological_space (has_emptyc (omega_complete_partial_order linarith.ineq))) : discrete_topology (has_emptyc (omega_complete_partial_order linarith.ineq)) := sorry --non-trivial
lemma new_lemma_96272 (h0 : functor.add_const (filter (comm_group name)) (has_neg linarith.comp)) : filter.ne_bot (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_96273 (h0 : topological_space (boolean_algebra (has_neg_part environment.implicit_infer_kind))) : t1_space (boolean_algebra (has_neg_part environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_96274 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @discrete_topology.{0} (has_norm.{0} fun_info) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_norm.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_96275 (h0 : uniform_space (ordered_comm_monoid (has_neg real))) : complete_space (ordered_comm_monoid (has_neg real)) := sorry --non-trivial
lemma new_lemma_96276 (h0 : function.extfun Type topological_space) : @loc_path_connected_space.{0} (has_inner.{0 0} (option.{0} empty) empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_inner.{0 0} (option.{0} empty) empty))  := sorry --non-trivial
lemma new_lemma_96277 (h0 : ring (has_append (random_gen (random_gen (random_gen char))))) : rank_condition (has_append (random_gen (random_gen (random_gen char)))) := sorry --non-trivial
lemma new_lemma_96278 (h0 : list (topological_space (distrib fun_info))) : @totally_disconnected_space.{0} (distrib.{0} fun_info) (@list.ilast.{0} (topological_space.{0} (distrib.{0} fun_info)) (@inhabited_topological_space.{0} (distrib.{0} fun_info)) h0)  := sorry --non-trivial
lemma new_lemma_96279 (h0 : functor.add_const (complete_lattice (preorder num)) empty) : @complete_lattice.is_Sup_finite_compact.{0} (preorder.{0} num) (@functor.add_const.run.{0 0} (complete_lattice.{0} (preorder.{0} num)) empty h0)  := sorry --non-trivial
lemma new_lemma_96280 (h0 : topological_space (random_gen (has_top to_additive.value_type))) : totally_separated_space (random_gen (has_top to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_96281 (h0 : function.extfun (Type 1) monoid) : @monoid.fg.{1} (add_cancel_monoid.{1} Type) (@function.extfun_app.{3 2} (Type 1) monoid.{1} h0 (add_cancel_monoid.{1} Type))  := sorry --non-trivial
lemma new_lemma_96282 (h0 : ordered_add_comm_monoid (canonically_ordered_comm_semiring (has_to_string pos))) : archimedean (canonically_ordered_comm_semiring (has_to_string pos)) := sorry --non-trivial
lemma new_lemma_96283 (h0 : function.extfun Type ring) : @is_principal_ideal_ring.{0} (has_bot.{0} real) (@function.extfun_app.{2 1} Type ring.{0} h0 (has_bot.{0} real))  := sorry --non-trivial
lemma new_lemma_96284 (h0 : topological_space (add_comm_monoid unsigned)) : totally_separated_space (add_comm_monoid unsigned) := sorry --non-trivial
lemma new_lemma_96285 (h1 : not (uniform_space (simple_graph reducibility_hints) -> false)) : @complete_space.{0} (simple_graph.{0} reducibility_hints) (@classical.by_contradiction'.{1} (uniform_space.{0} (simple_graph.{0} reducibility_hints)) h1)  := sorry --non-trivial
lemma new_lemma_96286 (h0 : group (finset (finset (add_comm_monoid unsigned)))) : group.fg (finset (finset (add_comm_monoid unsigned))) := sorry --non-trivial
lemma new_lemma_96287 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @preirreducible_space.{0} (generalized_boolean_algebra.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (generalized_boolean_algebra.{0} name))  := sorry --non-trivial
lemma new_lemma_96288 (h0 : ring (ordered_cancel_add_comm_monoid (option (option (option empty))))) : is_domain (ordered_cancel_add_comm_monoid (option (option (option empty)))) := sorry --non-trivial
lemma new_lemma_96289 (h0 : topological_space (normed_group (has_top linarith.comp_source))) : irreducible_space (normed_group (has_top linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_96290 (h0 : complete_lattice (random_gen unsigned)) : is_compactly_generated (random_gen unsigned) := sorry --non-trivial
lemma new_lemma_96291 (h0 : topological_space (has_to_string congr_arg_kind)) : totally_separated_space (has_to_string congr_arg_kind) := sorry --non-trivial
lemma new_lemma_96292 (h0 : ring (has_pos_part (sub_neg_monoid real))) : is_principal_ideal_ring (has_pos_part (sub_neg_monoid real)) := sorry --non-trivial
lemma new_lemma_96293 (h0 : topological_space (normed_lattice_add_comm_group (has_bot (has_add real)))) : loc_path_connected_space (normed_lattice_add_comm_group (has_bot (has_add real))) := sorry --non-trivial
lemma new_lemma_96294 (h0 : fin has_zero.zero) : @complete_lattice.is_Sup_finite_compact.{1} (has_pos_part.{1} Type) (@matrix.vec_empty.{1} (complete_lattice.{1} (has_pos_part.{1} Type)) (@matrix.vec_empty.{0} (fin (@has_zero.zero.{0} nat nat.has_zero)) h0))  := sorry --non-trivial
lemma new_lemma_96295 (h0 : functor.add_const (topological_space (boolean_algebra Type)) (has_zero pos)) : @topological_space.separable_space.{1} (boolean_algebra.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (boolean_algebra.{1} Type)) (has_zero.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_96296 (h0 : topological_space (has_add (has_pos_part Type))) : totally_disconnected_space (has_add (has_pos_part Type)) := sorry --non-trivial
lemma new_lemma_96297 (h0 : list (has_add (option (option pos)))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_96298 (h0 : functor.add_const (function.extfun (Type 1) topological_space) (ring Type)) : @topological_space.separable_space.{1} (has_nndist.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@functor.add_const.run.{2 1} (function.extfun.{3 2} (Type 1) topological_space.{1}) (ring.{1} Type) h0) (has_nndist.{1} Type))  := sorry --non-trivial
lemma new_lemma_96299 (h0 : functor.add_const (topological_space (has_zero unsigned)) name) : @topological_space.separable_space.{0} (has_zero.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (has_zero.{0} unsigned)) name h0)  := sorry --non-trivial
lemma new_lemma_96300 (h0 : complete_lattice (has_Inf name)) : is_compactly_generated (has_Inf name) := sorry --non-trivial
lemma new_lemma_96301 (h0 : ring (has_add (add_cancel_monoid name))) : is_principal_ideal_ring (has_add (add_cancel_monoid name)) := sorry --non-trivial
lemma new_lemma_96302 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @rank_condition.{0} (has_Inf.{0} real) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (has_Inf.{0} real))  := sorry --non-trivial
lemma new_lemma_96303 (h0 : add_group (nondiscrete_normed_field (mul_one_class linarith.ineq))) : is_add_cyclic (nondiscrete_normed_field (mul_one_class linarith.ineq)) := sorry --non-trivial
lemma new_lemma_96304 (h0 : function.extfun Type topological_space) : @totally_separated_space.{0} (add_cancel_monoid.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (add_cancel_monoid.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_96305 (h0 : topological_space (normed_group (random_gen (random_gen linarith.ineq)))) : irreducible_space (normed_group (random_gen (random_gen linarith.ineq))) := sorry --non-trivial
lemma new_lemma_96306 (h0 : function.extfun Type topological_space) : @path_connected_space.{0} (measurable_space.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (measurable_space.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_96307 (h0 : functor.add_const (ring (ordered_comm_monoid Type)) Type) : @is_domain.{1} (ordered_comm_monoid.{1} Type) (@functor.add_const.run.{1 1} (ring.{1} (ordered_comm_monoid.{1} Type)) Type h0)  := sorry --non-trivial
lemma new_lemma_96308 (h1 : complete_lattice (add_monoid (fintype char))) : complete_lattice.is_Sup_finite_compact (add_monoid (fintype char)) := sorry --non-trivial
lemma new_lemma_96309 (h0 : function.extfun Type topological_space) : @discrete_topology.{0} (has_top.{0} fun_info) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_top.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_96310 (h0 : not (complete_lattice (measurable_space.dynkin_system num) -> false)) : @is_atomistic.{0} (measurable_space.dynkin_system.{0} num) (@classical.by_contradiction'.{1} (complete_lattice.{0} (measurable_space.dynkin_system.{0} num)) h0)  := sorry --non-trivial
lemma new_lemma_96311 (h0 : group (normed_comm_ring (comm_group linarith.comp))) : is_cyclic (normed_comm_ring (comm_group linarith.comp)) := sorry --non-trivial
lemma new_lemma_96312 (h0 : prod (ordered_comm_ring real) (ordered_comm_ring real)) : id_rel h0 := sorry --non-trivial
lemma new_lemma_96313 (h0 : ordered_comm_monoid (has_pos_part (ring Type))) : has_exists_mul_of_le (has_pos_part (ring Type)) := sorry --non-trivial
lemma new_lemma_96314 (h0 : monoid (has_Inf (finset (has_Inf Type)))) : monoid.fg (has_Inf (finset (has_Inf Type))) := sorry --non-trivial
lemma new_lemma_96315 (h0 : has_mul char) (h1 : con char) (h2 : set (add_comm_semigroup fun_info -> add_comm_semigroup (con.quotient h1))) : set.separates_points h2 := sorry --non-trivial
lemma new_lemma_96316 (h0 : functor.add_const (function.extfun (Type 1) complete_lattice) environment.implicit_infer_kind) : @is_compactly_generated.{1} (has_to_string.{1} Type) (@function.extfun_app.{3 2} (Type 1) complete_lattice.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) complete_lattice.{1}) environment.implicit_infer_kind h0) (has_to_string.{1} Type))  := sorry --non-trivial
lemma new_lemma_96317 (h0 : functor.add_const (topological_space (boolean_algebra Type)) environment.implicit_infer_kind) : @topological_space.separable_space.{1} (boolean_algebra.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (boolean_algebra.{1} Type)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_96318 (h1 : uniform_space (with_bot (with_bot (has_inv (random_gen (with_bot to_additive.value_type)))))) : complete_space (with_bot (with_bot (has_inv (random_gen (with_bot to_additive.value_type))))) := sorry --non-trivial
lemma new_lemma_96319 (h1 : add_group (semi_normed_comm_ring char)) : is_add_cyclic (semi_normed_comm_ring char) := sorry --non-trivial
lemma new_lemma_96320 (h0 : functor.add_const (filter (complete_distrib_lattice Type)) name) : countable_Inter_filter (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_96321 (h0 : functor.add_const (complete_lattice (normed_linear_ordered_group empty)) (semiring unsigned)) : @is_compactly_generated.{0} (normed_linear_ordered_group.{0} empty) (@functor.add_const.run.{0 0} (complete_lattice.{0} (normed_linear_ordered_group.{0} empty)) (semiring.{0} unsigned) h0)  := sorry --non-trivial
lemma new_lemma_96322 (h0 : functor.add_const (function.extfun Type topological_space) linarith.comp) : @regular_space.{0} (has_add.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) linarith.comp h0) (has_add.{0} pos))  := sorry --non-trivial
lemma new_lemma_96323 (h0 : complete_lattice (left_cancel_monoid congr_arg_kind)) : is_atomistic (left_cancel_monoid congr_arg_kind) := sorry --non-trivial
lemma new_lemma_96324 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @t1_space.{0} (has_dist.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_dist.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_96325 (h0 : topological_space (finset linarith.comp)) : totally_disconnected_space (finset linarith.comp) := sorry --non-trivial
lemma new_lemma_96326 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @normal_space.{0} (has_edist.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_edist.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_96327 (h0 : has_mem.mem ring has_emptyc.emptyc) : @rank_condition.{0} empty (@function.extfun_app.{2 1} Type ring.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) ring.{0} h0) empty)  := sorry --non-trivial
lemma new_lemma_96328 (h0 : topological_space (dlist (random_gen char))) : locally_compact_space (dlist (random_gen char)) := sorry --non-trivial
lemma new_lemma_96329 (h0 : function.extfun Type topological_space) : @locally_compact_space.{0} (metric_space.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (metric_space.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_96330 (h0 : finset (has_inter congr_arg_kind)) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_96331 (h0 : add_group (with_zero string_imp)) : is_add_cyclic (with_zero string_imp) := sorry --non-trivial
lemma new_lemma_96332 (h0 : functor.add_const (topological_space (semiring empty)) (semiring empty)) : @t1_space.{0} (semiring.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (semiring.{0} empty)) (semiring.{0} empty) h0)  := sorry --non-trivial
lemma new_lemma_96333 (h2 : Prop) : h2 := sorry --non-trivial
lemma new_lemma_96334 (h0 : topological_space (has_emptyc (semiring fun_info))) : totally_separated_space (has_emptyc (semiring fun_info)) := sorry --non-trivial
lemma new_lemma_96335 (h0 : function.extfun Type (functor.add_const (topological_space pos))) : @loc_path_connected_space.{0} pos (@functor.add_const.run.{0 0} (topological_space.{0} pos) name (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (topological_space.{0} pos)) h0 name))  := sorry --non-trivial
lemma new_lemma_96336 (h0 : function.extfun Type add_monoid) : @add_monoid.fg.{0} (left_cancel_monoid.{0} num) (@function.extfun_app.{2 1} Type add_monoid.{0} h0 (left_cancel_monoid.{0} num))  := sorry --non-trivial
lemma new_lemma_96337 (h0 : functor.add_const (complete_lattice (has_add pos)) linarith.comp) : @is_compactly_generated.{0} (has_add.{0} pos) (@functor.add_const.run.{0 0} (complete_lattice.{0} (has_add.{0} pos)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_96338 (h0 : function.extfun nat fin) : @is_principal_ideal_ring.{0} (ordered_comm_monoid.{0} linarith.comp) (@function.extfun_app.{2 1} Type ring.{0} (@matrix.vec_empty.{1} (function.extfun.{2 1} Type ring.{0}) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero))) (ordered_comm_monoid.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_96339 (h0 : complete_lattice (has_lt (add_zero_class (mul_one_class linarith.ineq)))) : is_compactly_generated (has_lt (add_zero_class (mul_one_class linarith.ineq))) := sorry --non-trivial
lemma new_lemma_96340 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @preirreducible_space.{0} (pseudo_metric_space.{0} ennreal) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (pseudo_metric_space.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_96341 (h0 : add_cancel_monoid name -> add_cancel_monoid name -> Prop) : well_founded h0 := sorry --non-trivial
lemma new_lemma_96342 (h0 : ring (ordered_comm_ring (has_neg (has_neg Type)))) : is_principal_ideal_ring (ordered_comm_ring (has_neg (has_neg Type))) := sorry --non-trivial
lemma new_lemma_96343 (h0 : monoid (boolean_algebra.core (finset (finset environment.implicit_infer_kind)))) : monoid.fg (boolean_algebra.core (finset (finset environment.implicit_infer_kind))) := sorry --non-trivial
lemma new_lemma_96344 (h0 : function.extfun Type ring) : @strong_rank_condition.{0} (has_pos_part.{0} name) (@function.extfun_app.{2 1} Type ring.{0} h0 (has_pos_part.{0} name))  := sorry --non-trivial
lemma new_lemma_96345 (h1 : ring (random_gen congr_arg_kind)) : is_domain (random_gen congr_arg_kind) := sorry --non-trivial
lemma new_lemma_96346 (h0 : ordered_add_comm_monoid (add_comm_monoid (option empty))) : archimedean (add_comm_monoid (option empty)) := sorry --non-trivial
lemma new_lemma_96347 (h0 : functor.add_const (add_monoid (normed_linear_ordered_group congr_arg_kind)) unsigned) : @add_monoid.fg.{0} (normed_linear_ordered_group.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (add_monoid.{0} (normed_linear_ordered_group.{0} congr_arg_kind)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_96348 (h0 : function.extfun (Type 1) ring) : @rank_condition.{1} (plift.{1} unsigned) (@function.extfun_app.{3 2} (Type 1) ring.{1} h0 (plift.{1} unsigned))  := sorry --non-trivial
lemma new_lemma_96349 (h0 : topological_space (has_one (has_top empty))) : discrete_topology (has_one (has_top empty)) := sorry --non-trivial
lemma new_lemma_96350 (h1 : add_group (with_one (random_gen (random_gen linarith.comp_source)))) : is_add_cyclic (with_one (random_gen (random_gen linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_96351 (h0 : ring (normed_linear_ordered_group (random_gen char))) : is_domain (normed_linear_ordered_group (random_gen char)) := sorry --non-trivial
lemma new_lemma_96352 (h0 : function.extfun Type ring) : @strong_rank_condition.{0} (left_cancel_monoid.{0} num) (@function.extfun_app.{2 1} Type ring.{0} h0 (left_cancel_monoid.{0} num))  := sorry --non-trivial
lemma new_lemma_96353 (h0 : function.extfun (Type 1) semiring) : @is_noetherian_ring.{1} (normed_lattice_add_comm_group.{1} Type) (@function.extfun_app.{3 2} (Type 1) semiring.{1} h0 (normed_lattice_add_comm_group.{1} Type))  := sorry --non-trivial
lemma new_lemma_96354 (h0 : complete_lattice (add_group empty)) : complete_lattice.is_Sup_finite_compact (add_group empty) := sorry --non-trivial
lemma new_lemma_96355 (h0 : topological_space (sub_neg_monoid (has_neg pos))) : path_connected_space (sub_neg_monoid (has_neg pos)) := sorry --non-trivial
lemma new_lemma_96356 (h0 : not (topological_space (with_one (has_top congr_arg_kind)) -> false)) : @irreducible_space.{0} (with_one.{0} (has_top.{0} congr_arg_kind)) (@classical.by_contradiction'.{1} (topological_space.{0} (with_one.{0} (has_top.{0} congr_arg_kind))) h0)  := sorry --non-trivial
lemma new_lemma_96357 (h0 : uniform_space (has_bot (comm_semigroup (has_pos_part linarith.comp)))) : separated_space (has_bot (comm_semigroup (has_pos_part linarith.comp))) := sorry --non-trivial
lemma new_lemma_96358 (h0 : function.extfun Type group) : @group.fg.{0} (filter.{0} empty) (@function.extfun_app.{2 1} Type group.{0} h0 (filter.{0} empty))  := sorry --non-trivial
lemma new_lemma_96359 (h0 : list (normed_comm_ring (finset pos))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_96360 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @irreducible_space.{0} (add_right_cancel_monoid.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (add_right_cancel_monoid.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_96361 (h0 : not (pseudo_metric_space (random_gen linarith.comp) -> false)) (h1 : monoid (random_gen linarith.comp)) : @has_lipschitz_mul.{0} (random_gen.{0} linarith.comp) (@classical.by_contradiction'.{1} (pseudo_metric_space.{0} (random_gen.{0} linarith.comp)) h0) h1  := sorry --non-trivial
lemma new_lemma_96362 (h0 : monoid (with_one (random_gen (random_gen (has_inv linarith.comp_source))))) : monoid.fg (with_one (random_gen (random_gen (has_inv linarith.comp_source)))) := sorry --non-trivial
lemma new_lemma_96363 (h0 : functor.add_const (uniform_space (preorder unsigned)) congr_arg_kind) : @complete_space.{0} (preorder.{0} unsigned) (@functor.add_const.run.{0 0} (uniform_space.{0} (preorder.{0} unsigned)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_96364 (h0 : functor.add_const (complete_lattice (normed_linear_ordered_group unsigned)) unsigned) : @is_compactly_generated.{0} (normed_linear_ordered_group.{0} unsigned) (@functor.add_const.run.{0 0} (complete_lattice.{0} (normed_linear_ordered_group.{0} unsigned)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_96365 (h0 : functor.add_const (list (semigroup empty)) (option empty)) : list.nodup (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_96366 (h0 : functor.add_const (topological_space (linear_ordered_cancel_comm_monoid empty)) empty) : @t1_space.{0} (linear_ordered_cancel_comm_monoid.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (linear_ordered_cancel_comm_monoid.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_96367 (h0 : ring (canonically_ordered_monoid (has_add linarith.comp))) : is_domain (canonically_ordered_monoid (has_add linarith.comp)) := sorry --non-trivial
lemma new_lemma_96368 (h1 : functor.comp topological_space semi_normed_comm_ring fun_info) : @totally_disconnected_space.{0} (semi_normed_comm_ring.{0} fun_info) (@functor.comp.run.{0 0 0} topological_space.{0} semi_normed_comm_ring.{0} fun_info h1)  := sorry --non-trivial
lemma new_lemma_96369 (h0 : complete_lattice (group_with_zero num)) : complete_lattice.is_Sup_finite_compact (group_with_zero num) := sorry --non-trivial
lemma new_lemma_96370 (h0 : group (linear_ordered_add_comm_group (has_top (random_gen (has_inv linarith.ineq))))) : normalizer_condition (linear_ordered_add_comm_group (has_top (random_gen (has_inv linarith.ineq)))) := sorry --non-trivial
lemma new_lemma_96371 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : filter.ne_bot (function.extfun_app (function.extfun_app h0 filter) (semi_normed_comm_ring char)) := sorry --non-trivial
lemma new_lemma_96372 (h0 : add_group (canonically_ordered_monoid (sub_neg_monoid pos))) : is_add_cyclic (canonically_ordered_monoid (sub_neg_monoid pos)) := sorry --non-trivial
lemma new_lemma_96373 (h0 : topological_space (with_bot (has_norm fun_info))) : locally_compact_space (with_bot (has_norm fun_info)) := sorry --non-trivial
lemma new_lemma_96374 (h0 : list (linear_ordered_comm_monoid_with_zero empty)) : palindrome h0 := sorry --non-trivial
lemma new_lemma_96375 (h0 : functor.add_const (filter (has_to_string pos)) linarith.comp) : filter.ne_bot (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_96376 (h0 : group (ordered_ring (semiring empty))) : is_cyclic (ordered_ring (semiring empty)) := sorry --non-trivial
lemma new_lemma_96377 (h0 : functor.add_const (group (has_neg environment.implicit_infer_kind)) (has_neg linarith.comp)) : @group.fg.{0} (has_neg.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (group.{0} (has_neg.{0} environment.implicit_infer_kind)) (has_neg.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_96378 (h0 : group (encodable (random_gen (random_gen string_imp)))) : is_cyclic (encodable (random_gen (random_gen string_imp))) := sorry --non-trivial
lemma new_lemma_96379 (h0 : uniform_space (complete_semilattice_Sup (random_gen linarith.ineq))) : complete_space (complete_semilattice_Sup (random_gen linarith.ineq)) := sorry --non-trivial
lemma new_lemma_96380 (h0 : fin has_zero.zero) : @is_atomistic.{0} (has_Inf.{0} real) (@matrix.vec_empty.{0} (complete_lattice.{0} (has_Inf.{0} real)) h0)  := sorry --non-trivial
lemma new_lemma_96381 (h0 : function.extfun Type group) : @group.fg.{0} (has_inv.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type group.{0} h0 (has_inv.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_96382 (h0 : topological_space (canonically_ordered_monoid Type)) : preconnected_space (canonically_ordered_monoid Type) := sorry --non-trivial
lemma new_lemma_96383 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @topological_space.separable_space.{0} (linear_ordered_comm_group.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (linear_ordered_comm_group.{0} empty))  := sorry --non-trivial
lemma new_lemma_96384 (h0 : filter (preorder char)) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_96385 (h0 : functor.add_const (group (generalized_boolean_algebra Type)) pos) : @normalizer_condition.{1} (generalized_boolean_algebra.{1} Type) (@functor.add_const.run.{1 0} (group.{1} (generalized_boolean_algebra.{1} Type)) pos h0)  := sorry --non-trivial
lemma new_lemma_96386 (h0 : functor.add_const (topological_space (cancel_monoid linarith.comp)) (boolean_algebra Type)) : @t1_space.{0} (cancel_monoid.{0} linarith.comp) (@functor.add_const.run.{0 1} (topological_space.{0} (cancel_monoid.{0} linarith.comp)) (boolean_algebra.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_96387 (h0 : not (ring (measurable_space num) -> false)) : @rank_condition.{0} (measurable_space.{0} num) (@classical.by_contradiction'.{1} (ring.{0} (measurable_space.{0} num)) h0)  := sorry --non-trivial
lemma new_lemma_96388 (h0 : add_group (normed_linear_ordered_group (option (option empty)))) : is_add_cyclic (normed_linear_ordered_group (option (option empty))) := sorry --non-trivial
lemma new_lemma_96389 (h0 : filter (has_norm (has_norm empty))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_96390 (h0 : functor.add_const Prop (has_neg (has_nndist ennreal))) : functor.add_const.run h0 := sorry --non-trivial
lemma new_lemma_96391 (h0 : topological_space (add_cancel_comm_monoid string_imp)) : t0_space (add_cancel_comm_monoid string_imp) := sorry --non-trivial
lemma new_lemma_96392 (h0 : topological_space (has_norm (semiring (semiring empty)))) : totally_disconnected_space (has_norm (semiring (semiring empty))) := sorry --non-trivial
lemma new_lemma_96393 (h0 : group (has_pos_part name)) : group.fg (has_pos_part name) := sorry --non-trivial
lemma new_lemma_96394 (h0 : functor.add_const (topological_space (simple_graph pos)) linarith.comp) : @path_connected_space.{0} (simple_graph.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (simple_graph.{0} pos)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_96395 (h0 : functor.add_const (topological_space (add_comm_monoid unsigned)) Type) : @path_connected_space.{0} (add_comm_monoid.{0} unsigned) (@functor.add_const.run.{0 1} (topological_space.{0} (add_comm_monoid.{0} unsigned)) Type h0)  := sorry --non-trivial
lemma new_lemma_96396 (h0 : ordered_add_comm_monoid (has_inner empty congr_arg_kind)) : archimedean (has_inner empty congr_arg_kind) := sorry --non-trivial
lemma new_lemma_96397 (h0 : function.extfun Type ring) : @is_principal_ideal_ring.{0} (has_bot.{0} empty) (@function.extfun_app.{2 1} Type ring.{0} h0 (has_bot.{0} empty))  := sorry --non-trivial
lemma new_lemma_96398 (h0 : function.extfun Type semiring) : @is_noetherian_ring.{0} (has_bot.{0} real) (@function.extfun_app.{2 1} Type semiring.{0} h0 (has_bot.{0} real))  := sorry --non-trivial
lemma new_lemma_96399 (h0 : ring (has_nnnorm (has_ssubset linarith.comp_source))) : is_domain (has_nnnorm (has_ssubset linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_96400 (h0 : functor.add_const (uniform_space (has_Inf Type)) (ring (ring Type))) : @separated_space.{1} (has_Inf.{1} Type) (@functor.add_const.run.{1 1} (uniform_space.{1} (has_Inf.{1} Type)) (ring.{1} (ring.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_96401 (h0 : ring (add_cancel_comm_monoid to_additive.value_type)) : rank_condition (add_cancel_comm_monoid to_additive.value_type) := sorry --non-trivial
lemma new_lemma_96402 (h1 : add_group (has_emptyc linarith.ineq)) : is_add_cyclic (has_emptyc linarith.ineq) := sorry --non-trivial
lemma new_lemma_96403 (h0 h1 : multiset (normed_field string.iterator_imp)) : multiset.subset h0 h1 := sorry --non-trivial
lemma new_lemma_96404 (h0 : uniform_space (add_cancel_monoid (finset linarith.comp))) : complete_space (add_cancel_monoid (finset linarith.comp)) := sorry --non-trivial
lemma new_lemma_96405 (h1 : ring (topological_space char)) : rank_condition (topological_space char) := sorry --non-trivial
lemma new_lemma_96406 (h0 : topological_space (normed_comm_ring (option pos))) : preirreducible_space (normed_comm_ring (option pos)) := sorry --non-trivial
lemma new_lemma_96407 (h0 : functor.add_const (function.extfun (Type 1) topological_space) Type) : @t0_space.{1} (has_to_string.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@functor.add_const.run.{2 1} (function.extfun.{3 2} (Type 1) topological_space.{1}) Type h0) (has_to_string.{1} Type))  := sorry --non-trivial
lemma new_lemma_96408 (h0 : functor.add_const (ordered_add_comm_monoid (finset pos)) pos) : @archimedean.{0} (finset.{0} pos) (@functor.add_const.run.{0 0} (ordered_add_comm_monoid.{0} (finset.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_96409 (h0 : functor.add_const (monoid (semigroup Type)) (has_neg unsigned)) : @monoid.fg.{1} (semigroup.{1} Type) (@functor.add_const.run.{1 0} (monoid.{1} (semigroup.{1} Type)) (has_neg.{0} unsigned) h0)  := sorry --non-trivial
lemma new_lemma_96410 (h0 : group (semigroup (has_neg linarith.comp))) : normalizer_condition (semigroup (has_neg linarith.comp)) := sorry --non-trivial
lemma new_lemma_96411 (h0 : topological_space (has_div (mul_one_class linarith.ineq))) (h1 : preorder (has_div (mul_one_class linarith.ineq))) : order_topology (has_div (mul_one_class linarith.ineq)) := sorry --non-trivial
lemma new_lemma_96412 (h0 : group (has_inv to_additive.value_type)) : group.fg (has_inv to_additive.value_type) := sorry --non-trivial
lemma new_lemma_96413 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @separated_space.{1} (boolean_algebra.core.{1} Type) (@function.extfun_app.{3 2} (Type 1) uniform_space.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 uniform_space.{1}) (boolean_algebra.core.{1} Type))  := sorry --non-trivial
lemma new_lemma_96414 (h0 : ordered_add_comm_monoid (linear_ordered_field (option (option unsigned)))) : archimedean (linear_ordered_field (option (option unsigned))) := sorry --non-trivial
lemma new_lemma_96415 (h0 : heq (comm_ring char) (add_cancel_comm_monoid string.iterator_imp)) (h1 : group (comm_ring char)) : @is_cyclic.{0} (add_cancel_comm_monoid.{0} string.iterator_imp) (@heq.elim.{2 1} Type (comm_ring.{0} char) group.{0} (add_cancel_comm_monoid.{0} string.iterator_imp) h0 h1)  := sorry --non-trivial
lemma new_lemma_96416 (h0 : complete_lattice (ordered_ring (option (option (option empty))))) : complete_lattice.is_Sup_finite_compact (ordered_ring (option (option (option empty)))) := sorry --non-trivial
lemma new_lemma_96417 (h0 : functor.add_const (ordered_add_comm_monoid (normed_comm_ring pos)) (finset name)) : @archimedean.{0} (normed_comm_ring.{0} pos) (@functor.add_const.run.{0 0} (ordered_add_comm_monoid.{0} (normed_comm_ring.{0} pos)) (finset.{0} name) h0)  := sorry --non-trivial
lemma new_lemma_96418 (h0 : functor.add_const (topological_space (comm_group pos)) Type) : @t0_space.{0} (comm_group.{0} pos) (@functor.add_const.run.{0 1} (topological_space.{0} (comm_group.{0} pos)) Type h0)  := sorry --non-trivial
lemma new_lemma_96419 (h0 : topological_space (canonically_linear_ordered_monoid (option num))) : locally_compact_space (canonically_linear_ordered_monoid (option num)) := sorry --non-trivial
lemma new_lemma_96420 (h0 : ring (topological_space linarith.comp_source)) : rank_condition (topological_space linarith.comp_source) := sorry --non-trivial
lemma new_lemma_96421 (h0 : functor.add_const (monoid (mul_zero_class environment.implicit_infer_kind)) Type) : @monoid.fg.{0} (mul_zero_class.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 1} (monoid.{0} (mul_zero_class.{0} environment.implicit_infer_kind)) Type h0)  := sorry --non-trivial
lemma new_lemma_96422 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @loc_path_connected_space.{1} (canonically_ordered_comm_semiring.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 topological_space.{1}) (canonically_ordered_comm_semiring.{1} Type))  := sorry --non-trivial
lemma new_lemma_96423 (h0 : functor.add_const (group (linear_ordered_cancel_comm_monoid num)) empty) : @is_cyclic.{0} (linear_ordered_cancel_comm_monoid.{0} num) (@functor.add_const.run.{0 0} (group.{0} (linear_ordered_cancel_comm_monoid.{0} num)) empty h0)  := sorry --non-trivial
lemma new_lemma_96424 (h0 : function.extfun Type ring) : @is_principal_ideal_ring.{0} (monoid.{0} unsigned) (@function.extfun_app.{2 1} Type ring.{0} h0 (monoid.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_96425 (h0 : group (bin_tree (semiring empty))) : is_cyclic (bin_tree (semiring empty)) := sorry --non-trivial
lemma new_lemma_96426 (h0 : functor.add_const (group (has_nndist linarith.comp)) name) : @group.fg.{0} (has_nndist.{0} linarith.comp) (@functor.add_const.run.{0 0} (group.{0} (has_nndist.{0} linarith.comp)) name h0)  := sorry --non-trivial
lemma new_lemma_96427 (h0 : function.extfun Type topological_space) : @discrete_topology.{0} (has_top.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_top.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_96428 (h0 : not (topological_space (has_nnnorm fun_info) -> false)) : @locally_compact_space.{0} (has_nnnorm.{0} fun_info) (@classical.by_contradiction'.{1} (topological_space.{0} (has_nnnorm.{0} fun_info)) h0)  := sorry --non-trivial
lemma new_lemma_96429 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_principal_ideal_ring.{0} (has_add.{0} pos) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (has_add.{0} pos))  := sorry --non-trivial
lemma new_lemma_96430 (h0 : topological_space (canonically_linear_ordered_monoid (option ennreal))) : totally_disconnected_space (canonically_linear_ordered_monoid (option ennreal)) := sorry --non-trivial
lemma new_lemma_96431 (h1 : topological_space (with_one (random_gen (random_gen string_imp)))) : locally_compact_space (with_one (random_gen (random_gen string_imp))) := sorry --non-trivial
lemma new_lemma_96432 (h0 : monoid (cancel_monoid name)) : monoid.fg (cancel_monoid name) := sorry --non-trivial
lemma new_lemma_96433 (h0 : not (cancel_comm_monoid_with_zero (non_assoc_semiring empty) -> false)) : @unique_factorization_monoid.{0} (non_assoc_semiring.{0} empty) (@classical.by_contradiction'.{1} (cancel_comm_monoid_with_zero.{0} (non_assoc_semiring.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_96434 (h1 : not (topological_space (uniform_space linarith.comp_source) -> false)) : @path_connected_space.{0} (uniform_space.{0} linarith.comp_source) (@classical.by_contradiction'.{1} (topological_space.{0} (uniform_space.{0} linarith.comp_source)) h1)  := sorry --non-trivial
lemma new_lemma_96435 : subsingleton (random_gen linarith.ineq) := sorry --non-trivial
lemma new_lemma_96436 (h0 : topological_space (add_cancel_monoid (has_add environment.implicit_infer_kind))) : locally_compact_space (add_cancel_monoid (has_add environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_96437 (h0 : complete_lattice (with_zero (with_one linarith.comp_source))) : is_compactly_generated (with_zero (with_one linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_96438 (h0 : ring (has_neg_part (option pos))) : is_principal_ideal_ring (has_neg_part (option pos)) := sorry --non-trivial
lemma new_lemma_96439 (h0 : functor.add_const (topological_space (complete_distrib_lattice Type)) Type) : @sequential_space.{1} (complete_distrib_lattice.{1} Type) (@functor.add_const.run.{1 1} (topological_space.{1} (complete_distrib_lattice.{1} Type)) Type h0)  := sorry --non-trivial
lemma new_lemma_96440 (h0 : topological_space (canonically_ordered_comm_semiring unsigned)) : normal_space (canonically_ordered_comm_semiring unsigned) := sorry --non-trivial
lemma new_lemma_96441 (h0 : uniform_space (has_norm (has_top empty))) : separated_space (has_norm (has_top empty)) := sorry --non-trivial
lemma new_lemma_96442 (h0 : function.extfun Type complete_lattice) : @is_compactly_generated.{0} (has_zero.{0} ennreal) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (has_zero.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_96443 (h0 : function.extfun Type filter) : filter.ne_bot (function.extfun_app h0 (option pos)) := sorry --non-trivial
lemma new_lemma_96444 (h0 : functor.comp add_group has_neg_part Type) : @is_add_cyclic.{1} (has_neg_part.{1} Type) (@functor.comp.run.{1 1 1} add_group.{1} has_neg_part.{1} Type h0)  := sorry --non-trivial
lemma new_lemma_96445 (h0 : add_monoid (with_one (has_norm (has_top (has_top linarith.comp))))) : add_monoid.fg (with_one (has_norm (has_top (has_top linarith.comp)))) := sorry --non-trivial
lemma new_lemma_96446 (h0 : functor.add_const (ordered_comm_monoid (mul_zero_class name)) Type) : @has_exists_mul_of_le.{0} (mul_zero_class.{0} name) (@functor.add_const.run.{0 1} (ordered_comm_monoid.{0} (mul_zero_class.{0} name)) Type h0)  := sorry --non-trivial
lemma new_lemma_96447 (h0 : topological_space (pseudo_metric_space congr_arg_kind)) : normal_space (pseudo_metric_space congr_arg_kind) := sorry --non-trivial
lemma new_lemma_96448 (h0 : topological_space (has_add (has_add pos))) : totally_separated_space (has_add (has_add pos)) := sorry --non-trivial
lemma new_lemma_96449 (h0 : group (semiring (random_gen (random_gen num)))) : normalizer_condition (semiring (random_gen (random_gen num))) := sorry --non-trivial
lemma new_lemma_96450 (h0 : function.extfun Type topological_space) : @loc_path_connected_space.{0} (add_comm_monoid.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (add_comm_monoid.{0} empty))  := sorry --non-trivial
lemma new_lemma_96451 (h0 : uniform_space (normed_group (with_bot (with_bot (with_bot to_additive.value_type))))) : complete_space (normed_group (with_bot (with_bot (with_bot to_additive.value_type)))) := sorry --non-trivial
lemma new_lemma_96452 (h0 : group (has_to_string (has_add (has_add pos)))) : normalizer_condition (has_to_string (has_add (has_add pos))) := sorry --non-trivial
lemma new_lemma_96453 (h0 : function.extfun (Type 1) filter) : filter.ne_bot (function.extfun_app h0 (plift unsigned)) := sorry --non-trivial
lemma new_lemma_96454 (h0 : semiring (has_to_string unsigned)) : is_noetherian_ring (has_to_string unsigned) := sorry --non-trivial
lemma new_lemma_96455 (h0 : fin has_zero.zero) : @preirreducible_space.{1} (canonically_ordered_monoid.{1} Type) (@matrix.vec_empty.{1} (topological_space.{1} (canonically_ordered_monoid.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_96456 (h0 : functor.add_const (ring (semigroup congr_arg_kind)) congr_arg_kind) : @strong_rank_condition.{0} (semigroup.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (ring.{0} (semigroup.{0} congr_arg_kind)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_96457 (h0 : uniform_space (add_comm_monoid (cancel_monoid environment.implicit_infer_kind))) : separated_space (add_comm_monoid (cancel_monoid environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_96458 (h0 : topological_space (mul_zero_class (semiring unsigned))) : totally_disconnected_space (mul_zero_class (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_96459 (h0 : topological_space (sub_neg_monoid (has_add linarith.comp))) : t1_space (sub_neg_monoid (has_add linarith.comp)) := sorry --non-trivial
lemma new_lemma_96460 (h0 : add_group (has_inter congr_arg_kind)) : is_add_cyclic (has_inter congr_arg_kind) := sorry --non-trivial
lemma new_lemma_96461 (h0 : left_cancel_semigroup (semiring (semiring num)) -> left_cancel_semigroup (semiring (semiring num)) -> Prop) : is_strict_order (left_cancel_semigroup (semiring (semiring num))) h0 := sorry --non-trivial
lemma new_lemma_96462 (h0 : group (ring (option ennreal))) : is_cyclic (ring (option ennreal)) := sorry --non-trivial
lemma new_lemma_96463 (h0 : list (ordered_cancel_add_comm_monoid (option (option (option unsigned))))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_96464 (h0 : functor.add_const Prop (finset (semigroup Type))) : functor.add_const.run h0 := sorry --non-trivial
lemma new_lemma_96465 (h0 : functor.add_const (uniform_space (left_cancel_monoid unsigned)) num) : @complete_space.{0} (left_cancel_monoid.{0} unsigned) (@functor.add_const.run.{0 0} (uniform_space.{0} (left_cancel_monoid.{0} unsigned)) num h0)  := sorry --non-trivial
lemma new_lemma_96466 (h0 : function.extfun (finset Type) (has_mem.mem linarith.comp)) : @complete_lattice.is_Sup_finite_compact.{0} linarith.comp (@finset.pi.empty.{1 0} Type complete_lattice.{0} linarith.comp (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) linarith.comp) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_96467 (h0 : functor.add_const (function.extfun (Type 1) topological_space) Type) : @path_connected_space.{1} (has_nndist.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@functor.add_const.run.{2 1} (function.extfun.{3 2} (Type 1) topological_space.{1}) Type h0) (has_nndist.{1} Type))  := sorry --non-trivial
lemma new_lemma_96468 (h0 : monoid (random_gen (has_norm congr_arg_kind))) : monoid.fg (random_gen (has_norm congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_96469 (h0 : functor.add_const (function.extfun Type topological_space) pos) : @t1_space.{0} (has_zero.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) pos h0) (has_zero.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_96470 (h0 : ordered_add_comm_monoid (add_cancel_monoid (has_add Type))) : archimedean (add_cancel_monoid (has_add Type)) := sorry --non-trivial
lemma new_lemma_96471 (h0 : set (uniform_space (mul_one_class to_additive.value_type))) : set.finite h0 := sorry --non-trivial
lemma new_lemma_96472 (h0 : topological_space (has_lt enat)) (h1 : preorder (has_lt enat)) : order_topology (has_lt enat) := sorry --non-trivial
lemma new_lemma_96473 (h0 : topological_space (with_bot (has_top to_additive.value_type))) : discrete_topology (with_bot (has_top to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_96474 (h0 : topological_space (linear_ordered_comm_group_with_zero string.iterator_imp)) (h1 : set (linear_ordered_comm_group_with_zero string.iterator_imp)) : is_preirreducible h1 := sorry --non-trivial
lemma new_lemma_96475 (h0 : topological_space (has_ssubset (has_nnnorm (random_gen (random_gen fun_info))))) : path_connected_space (has_ssubset (has_nnnorm (random_gen (random_gen fun_info)))) := sorry --non-trivial
lemma new_lemma_96476 (h0 : ring (has_nnnorm (mul_one_class linarith.comp_source))) : is_domain (has_nnnorm (mul_one_class linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_96477 (h0 : group (encodable (has_nnnorm (has_nnnorm (has_nnnorm fun_info))))) : is_cyclic (encodable (has_nnnorm (has_nnnorm (has_nnnorm fun_info)))) := sorry --non-trivial
lemma new_lemma_96478 (h0 : topological_space (uniform_space (uniform_space linarith.ineq))) : t0_space (uniform_space (uniform_space linarith.ineq)) := sorry --non-trivial
lemma new_lemma_96479 (h0 : functor.add_const (topological_space (boolean_algebra pos)) Type) : @preconnected_space.{0} (boolean_algebra.{0} pos) (@functor.add_const.run.{0 1} (topological_space.{0} (boolean_algebra.{0} pos)) Type h0)  := sorry --non-trivial
lemma new_lemma_96480 (h0 : functor.add_const (group (finset environment.implicit_infer_kind)) name) : @group.fg.{0} (finset.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (group.{0} (finset.{0} environment.implicit_infer_kind)) name h0)  := sorry --non-trivial
lemma new_lemma_96481 (h0 : functor.add_const (complete_lattice (has_to_string num)) num) : @is_atomistic.{0} (has_to_string.{0} num) (@functor.add_const.run.{0 0} (complete_lattice.{0} (has_to_string.{0} num)) num h0)  := sorry --non-trivial
lemma new_lemma_96482 (h0 : topological_space (has_one (has_top unsigned))) : normal_space (has_one (has_top unsigned)) := sorry --non-trivial
lemma new_lemma_96483 (h0 : ring (has_nndist (has_nndist Type))) : is_domain (has_nndist (has_nndist Type)) := sorry --non-trivial
lemma new_lemma_96484 (h0 : topological_space (has_zero (has_neg Type))) : path_connected_space (has_zero (has_neg Type)) := sorry --non-trivial
lemma new_lemma_96485 (h0 : functor.add_const (filter (complete_distrib_lattice unsigned)) linarith.comp) : countable_Inter_filter (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_96486 (h0 : topological_space (denumerable (random_gen char))) : locally_compact_space (denumerable (random_gen char)) := sorry --non-trivial
lemma new_lemma_96487 (h0 : functor.add_const (group (add_comm_monoid environment.implicit_infer_kind)) Type) : @normalizer_condition.{0} (add_comm_monoid.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 1} (group.{0} (add_comm_monoid.{0} environment.implicit_infer_kind)) Type h0)  := sorry --non-trivial
lemma new_lemma_96488 (h0 : functor.add_const (group (plift num)) empty) : @normalizer_condition.{1} (plift.{1} num) (@functor.add_const.run.{1 0} (group.{1} (plift.{1} num)) empty h0)  := sorry --non-trivial
lemma new_lemma_96489 (h0 : cancel_comm_monoid_with_zero (has_lt string.iterator_imp)) : unique_factorization_monoid (has_lt string.iterator_imp) := sorry --non-trivial
lemma new_lemma_96490 (h0 : functor.add_const (topological_space (has_nndist linarith.comp)) Type) : @regular_space.{0} (has_nndist.{0} linarith.comp) (@functor.add_const.run.{0 1} (topological_space.{0} (has_nndist.{0} linarith.comp)) Type h0)  := sorry --non-trivial
lemma new_lemma_96491 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_atomistic.{0} (has_zero.{0} (option.{0} pos)) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (has_zero.{0} (option.{0} pos)))  := sorry --non-trivial
lemma new_lemma_96492 (h0 : functor.add_const (complete_lattice (has_neg name)) (boolean_algebra (boolean_algebra (finset Type)))) : @is_atomistic.{0} (has_neg.{0} name) (@functor.add_const.run.{0 1} (complete_lattice.{0} (has_neg.{0} name)) (boolean_algebra.{1} (boolean_algebra.{1} (finset.{1} Type))) h0)  := sorry --non-trivial
lemma new_lemma_96493 (h0 : functor.add_const (ring (add_comm_monoid empty)) empty) : @is_principal_ideal_ring.{0} (add_comm_monoid.{0} empty) (@functor.add_const.run.{0 0} (ring.{0} (add_comm_monoid.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_96494 (h0 : complete_lattice (has_nnnorm string.iterator_imp)) : complete_lattice.is_Sup_finite_compact (has_nnnorm string.iterator_imp) := sorry --non-trivial
lemma new_lemma_96495 (h0 : add_monoid (complete_distrib_lattice (has_neg_part (has_add pos)))) : add_monoid.fg (complete_distrib_lattice (has_neg_part (has_add pos))) := sorry --non-trivial
lemma new_lemma_96496 (h0 : group (distrib_lattice (has_append fun_info))) : is_cyclic (distrib_lattice (has_append fun_info)) := sorry --non-trivial
lemma new_lemma_96497 (h0 : topological_space (has_nndist (finset (finset Type)))) : normal_space (has_nndist (finset (finset Type))) := sorry --non-trivial
lemma new_lemma_96498 (h0 : functor.add_const (ordered_add_comm_monoid (boolean_algebra pos)) (has_add pos)) : @archimedean.{0} (boolean_algebra.{0} pos) (@functor.add_const.run.{0 0} (ordered_add_comm_monoid.{0} (boolean_algebra.{0} pos)) (has_add.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_96499 (h0 : function.extfun (nat -> Type) (function.extfun nat)) : @is_compactly_generated.{1} (normed_lattice_add_comm_group.{1} Type) (@matrix.vec_empty.{1} (complete_lattice.{1} (normed_lattice_add_comm_group.{1} Type)) (@function.extfun_app.{1 1} nat fin (@function.extfun_app.{2 1} (nat → Type) (function.extfun.{1 1} nat) h0 fin) (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_96500 (h0 : uniform_space (has_zero (has_neg_part name))) : separated_space (has_zero (has_neg_part name)) := sorry --non-trivial
lemma new_lemma_96501 (h0 : topological_space (order_dual num)) : totally_disconnected_space (order_dual num) := sorry --non-trivial
lemma new_lemma_96502 (h0 : uniform_space (has_nndist (finset pos))) : separated_space (has_nndist (finset pos)) := sorry --non-trivial
lemma new_lemma_96503 (h0 : topological_space (add_cancel_monoid (finset (has_add (finset (finset (has_add Type))))))) : loc_path_connected_space (add_cancel_monoid (finset (has_add (finset (finset (has_add Type)))))) := sorry --non-trivial
lemma new_lemma_96504 (h0 : functor.add_const (semiring (has_nndist Type)) linarith.comp) : @is_noetherian_ring.{1} (has_nndist.{1} Type) (@functor.add_const.run.{1 0} (semiring.{1} (has_nndist.{1} Type)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_96505 (h0 : function.extfun Type topological_space) : @t0_space.{0} (metric_space.{0} fun_info) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (metric_space.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_96506 (h2 : ring (nondiscrete_normed_field (add_comm_semigroup (add_comm_semigroup char)))) : strong_rank_condition (nondiscrete_normed_field (add_comm_semigroup (add_comm_semigroup char))) := sorry --non-trivial
lemma new_lemma_96507 (h0 : list (has_dist ennreal)) : palindrome h0 := sorry --non-trivial
lemma new_lemma_96508 (h0 : group (has_add (finset Type))) : is_simple_group (has_add (finset Type)) := sorry --non-trivial
lemma new_lemma_96509 (h0 : ring (has_edist num)) : is_domain (has_edist num) := sorry --non-trivial
lemma new_lemma_96510 (h0 : topological_space (boolean_algebra name)) : sequential_space (boolean_algebra name) := sorry --non-trivial
lemma new_lemma_96511 (h2 : topological_space congr_arg_kind) : totally_disconnected_space congr_arg_kind := sorry --non-trivial
lemma new_lemma_96512 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @has_exists_mul_of_le.{0} (has_bot.{0} pos) (@function.extfun_app.{2 1} Type ordered_comm_monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ordered_comm_monoid.{0}) (has_bot.{0} pos))  := sorry --non-trivial
lemma new_lemma_96513 (h0 : topological_space (complete_distrib_lattice (has_neg pos))) : locally_compact_space (complete_distrib_lattice (has_neg pos)) := sorry --non-trivial
lemma new_lemma_96514 (h0 : function.extfun Type complete_lattice) : @is_compactly_generated.{0} (finset.{0} real) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (finset.{0} real))  := sorry --non-trivial
lemma new_lemma_96515 (h0 : group (complete_distrib_lattice num)) : group.fg (complete_distrib_lattice num) := sorry --non-trivial
lemma new_lemma_96516 (h0 : complete_lattice (ordered_comm_monoid (has_add linarith.comp))) : complete_lattice.is_Sup_finite_compact (ordered_comm_monoid (has_add linarith.comp)) := sorry --non-trivial
lemma new_lemma_96517 (h0 : functor.add_const (group (add_comm_monoid Type)) (has_to_string name)) : @normalizer_condition.{1} (add_comm_monoid.{1} Type) (@functor.add_const.run.{1 0} (group.{1} (add_comm_monoid.{1} Type)) (has_to_string.{0} name) h0)  := sorry --non-trivial
lemma new_lemma_96518 (h0 : topological_space (ordered_comm_ring (has_neg linarith.comp))) : t0_space (ordered_comm_ring (has_neg linarith.comp)) := sorry --non-trivial
lemma new_lemma_96519 (h3 : has_mem.mem (with_one num) has_emptyc.emptyc) : @is_cyclic.{0} (with_one.{0} num) (@finset.pi.empty.{1 0} Type group.{0} (with_one.{0} num) h3)  := sorry --non-trivial
lemma new_lemma_96520 (h0 : functor.add_const (complete_lattice (add_cancel_monoid environment.implicit_infer_kind)) linarith.comp) : @is_compactly_generated.{0} (add_cancel_monoid.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (complete_lattice.{0} (add_cancel_monoid.{0} environment.implicit_infer_kind)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_96521 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @topological_space.separable_space.{0} (semigroup.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (semigroup.{0} pos))  := sorry --non-trivial
lemma new_lemma_96522 (h0 : add_group (normed_field (has_nnnorm (has_nnnorm linarith.comp_source)))) : is_add_cyclic (normed_field (has_nnnorm (has_nnnorm linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_96523 (h0 : group (has_norm (complete_semilattice_Sup (random_gen linarith.ineq)))) : is_cyclic (has_norm (complete_semilattice_Sup (random_gen linarith.ineq))) := sorry --non-trivial
lemma new_lemma_96524 (h0 : functor.add_const (topological_space (ring pos)) linarith.comp) : @preirreducible_space.{0} (ring.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (ring.{0} pos)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_96525 (h0 : function.extfun Type topological_space) : @path_connected_space.{0} (normed_lattice_add_comm_group.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (normed_lattice_add_comm_group.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_96526 (h0 : add_group (semigroup (has_nndist name))) : is_add_cyclic (semigroup (has_nndist name)) := sorry --non-trivial
lemma new_lemma_96527 (h0 : filter (boolean_algebra.core (has_to_string unsigned))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_96528 (h0 : topological_space (add_cancel_monoid (boolean_algebra (has_to_string linarith.comp)))) : path_connected_space (add_cancel_monoid (boolean_algebra (has_to_string linarith.comp))) := sorry --non-trivial
lemma new_lemma_96529 (h0 : function.extfun Type filter) : filter.ne_bot (function.extfun_app h0 (finset linarith.comp)) := sorry --non-trivial
lemma new_lemma_96530 (h0 : fin has_zero.zero) : @rank_condition.{0} (ordered_comm_ring.{0} real) (@function.extfun_app.{2 1} Type ring.{0} (@matrix.vec_empty.{1} (function.extfun.{2 1} Type ring.{0}) h0) (ordered_comm_ring.{0} real))  := sorry --non-trivial
lemma new_lemma_96531 (h0 : topological_space (canonically_linear_ordered_monoid num)) : totally_disconnected_space (canonically_linear_ordered_monoid num) := sorry --non-trivial
lemma new_lemma_96532 (h0 : topological_space (canonically_ordered_monoid (has_add real))) : preirreducible_space (canonically_ordered_monoid (has_add real)) := sorry --non-trivial
lemma new_lemma_96533 (h0 : uniform_space (has_Inf (has_nndist linarith.comp))) : separated_space (has_Inf (has_nndist linarith.comp)) := sorry --non-trivial
lemma new_lemma_96534 (h1 : not (topological_space (has_norm congr_arg_kind) -> false)) : @totally_disconnected_space.{0} (has_norm.{0} congr_arg_kind) (@classical.by_contradiction'.{1} (topological_space.{0} (has_norm.{0} congr_arg_kind)) h1)  := sorry --non-trivial
lemma new_lemma_96535 (h0 : ring (has_inner empty congr_arg_kind)) : is_principal_ideal_ring (has_inner empty congr_arg_kind) := sorry --non-trivial
lemma new_lemma_96536 (h0 : function.extfun (Type 1) (functor.add_const Prop)) : functor.add_const.run (function.extfun_app h0 (simple_graph Type)) := sorry --non-trivial
lemma new_lemma_96537 (h0 : list (ordered_comm_ring (ring (ring (ring Type))))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_96538 (h0 : functor.add_const (filter (cancel_monoid Type)) Type) : filter.ne_bot (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_96539 (h0 : functor.add_const (topological_space (simple_graph name)) (finset pos)) : @regular_space.{0} (simple_graph.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (simple_graph.{0} name)) (finset.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_96540 (h0 : functor.add_const (function.extfun (Type 1) ring) (ring Type)) : @is_principal_ideal_ring.{1} (has_neg_part.{1} Type) (@function.extfun_app.{3 2} (Type 1) ring.{1} (@functor.add_const.run.{2 1} (function.extfun.{3 2} (Type 1) ring.{1}) (ring.{1} Type) h0) (has_neg_part.{1} Type))  := sorry --non-trivial
lemma new_lemma_96541 (h0 : ring (add_comm_monoid (option unsigned))) : rank_condition (add_comm_monoid (option unsigned)) := sorry --non-trivial
lemma new_lemma_96542 (h0 : function.extfun Type ring) : @strong_rank_condition.{0} (has_norm.{0} empty) (@function.extfun_app.{2 1} Type ring.{0} h0 (has_norm.{0} empty))  := sorry --non-trivial
lemma new_lemma_96543 (h0 : topological_space (has_add (finset (has_neg pos)))) : totally_separated_space (has_add (finset (has_neg pos))) := sorry --non-trivial
lemma new_lemma_96544 (h0 : functor.add_const (add_monoid (has_nndist pos)) pos) : @add_monoid.fg.{0} (has_nndist.{0} pos) (@functor.add_const.run.{0 0} (add_monoid.{0} (has_nndist.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_96545 (h0 : ordered_add_comm_monoid (pseudo_emetric_space unsigned)) : archimedean (pseudo_emetric_space unsigned) := sorry --non-trivial
lemma new_lemma_96546 (h0 : function.extfun Type add_group) : @is_add_cyclic.{0} (linear_ordered_add_comm_group.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type add_group.{0} h0 (linear_ordered_add_comm_group.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_96547 (h1 : uniform_space (has_append linarith.ineq)) : complete_space (has_append linarith.ineq) := sorry --non-trivial
lemma new_lemma_96548 (h0 : function.extfun nat fin) : @path_connected_space.{0} (ordered_comm_monoid.{0} name) (@matrix.vec_empty.{0} (topological_space.{0} (ordered_comm_monoid.{0} name)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_96549 (h0 : functor.add_const (topological_space (finset name)) linarith.comp) : @t1_space.{0} (finset.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (finset.{0} name)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_96550 (h0 : topological_space (has_nndist (has_nndist (finset (finset name))))) : discrete_topology (has_nndist (has_nndist (finset (finset name)))) := sorry --non-trivial
lemma new_lemma_96551 (h1 : not (topological_space (metric_space num) -> false)) : @normal_space.{0} (metric_space.{0} num) (@classical.by_contradiction'.{1} (topological_space.{0} (metric_space.{0} num)) h1)  := sorry --non-trivial
lemma new_lemma_96552 (h0 : complete_lattice (linear_ordered_semiring (random_gen (random_gen (random_gen num))))) : is_compactly_generated (linear_ordered_semiring (random_gen (random_gen (random_gen num)))) := sorry --non-trivial
lemma new_lemma_96553 (h0 : functor.add_const (add_monoid (monoid unsigned)) congr_arg_kind) : @add_monoid.fg.{0} (monoid.{0} unsigned) (@functor.add_const.run.{0 0} (add_monoid.{0} (monoid.{0} unsigned)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_96554 (h1 : function.extfun (has_inv num) (fun (x : has_inv num), Prop)) : @infi.{0 1} Prop (@conditionally_complete_lattice.to_has_Inf.{0} Prop (@complete_lattice.to_conditionally_complete_lattice.{0} Prop Prop.complete_lattice)) (has_inv.{0} num) (@function.extfun_app.{1 1} (has_inv.{0} num) (λ (x : has_inv.{0} num), Prop) h1)  := sorry --non-trivial
lemma new_lemma_96555 (h0 : group (ordered_cancel_add_comm_monoid (option pos))) : is_simple_group (ordered_cancel_add_comm_monoid (option pos)) := sorry --non-trivial
lemma new_lemma_96556 (h0 h1 : multiset (simple_graph string.iterator_imp)) : multiset.subset h0 h1 := sorry --non-trivial
lemma new_lemma_96557 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : list.nodup (function.extfun_app (function.extfun_app h0 list) (cancel_monoid pos)) := sorry --non-trivial
lemma new_lemma_96558 (h0 : add_group (normed_group (semiring linarith.comp))) : is_add_cyclic (normed_group (semiring linarith.comp)) := sorry --non-trivial
lemma new_lemma_96559 (h0 : uniform_space (topological_space (random_gen (random_gen (random_gen char))))) : complete_space (topological_space (random_gen (random_gen (random_gen char)))) := sorry --non-trivial
lemma new_lemma_96560 (h0 : topological_space (monoid num)) : preirreducible_space (monoid num) := sorry --non-trivial
lemma new_lemma_96561 (h0 : functor.add_const (topological_space (normed_lattice_add_comm_group linarith.comp)) linarith.comp) : @totally_separated_space.{0} (normed_lattice_add_comm_group.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (normed_lattice_add_comm_group.{0} linarith.comp)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_96562 (h0 : topological_space (measurable_space to_additive.value_type)) : t0_space (measurable_space to_additive.value_type) := sorry --non-trivial
lemma new_lemma_96563 (h0 : filter (non_assoc_semiring (semiring (semiring (semiring unsigned)))) -> Prop) (h1 : Exists (fun (x : filter (non_assoc_semiring (semiring (semiring (semiring unsigned))))), h0 x)) : filter.ne_bot (classical.some h1) := sorry --non-trivial
lemma new_lemma_96564 (h0 : function.extfun Type topological_space) : @loc_path_connected_space.{0} (ordered_comm_group.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (ordered_comm_group.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_96565 (h0 : uniform_space (random_gen (random_gen (comm_ring to_additive.value_type)))) : complete_space (random_gen (random_gen (comm_ring to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_96566 (h0 : function.extfun (finset (Type -> Type)) (has_mem.mem complete_lattice)) : is_atomistic (measurable_space (has_top num)) := sorry --non-trivial
lemma new_lemma_96567 (h0 : function.extfun Type (functor.add_const Prop)) : functor.add_const.run (function.extfun_app h0 num) := sorry --non-trivial
lemma new_lemma_96568 (h0 : functor.add_const (complete_lattice (has_nndist num)) empty) : @is_compactly_generated.{0} (has_nndist.{0} num) (@functor.add_const.run.{0 0} (complete_lattice.{0} (has_nndist.{0} num)) empty h0)  := sorry --non-trivial
lemma new_lemma_96569 (h0 : complete_lattice (has_le std_gen)) : complete_lattice.is_Sup_finite_compact (has_le std_gen) := sorry --non-trivial
lemma new_lemma_96570 (h0 : cancel_comm_monoid_with_zero (pseudo_metric_space (option (option unsigned)))) : unique_factorization_monoid (pseudo_metric_space (option (option unsigned))) := sorry --non-trivial
lemma new_lemma_96571 (h0 : topological_space (boolean_algebra (boolean_algebra.core name))) : normal_space (boolean_algebra (boolean_algebra.core name)) := sorry --non-trivial
lemma new_lemma_96572 (h0 : topological_space (ring (option unsigned))) : normal_space (ring (option unsigned)) := sorry --non-trivial
lemma new_lemma_96573 (h0 : not (function.extfun (Type -> Type) (function.extfun Type) -> false)) : @strong_rank_condition.{0} num (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) (@classical.by_contradiction'.{2} (function.extfun.{2 2} (Type → Type) (function.extfun.{2 1} Type)) h0) ring.{0}) num)  := sorry --non-trivial
lemma new_lemma_96574 (h0 : not (uniform_space empty -> false)) : separated_space empty := sorry --non-trivial
lemma new_lemma_96575 (h0 : list (add_comm_monoid (finset linarith.comp))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_96576 (h0 : functor.add_const (function.extfun Type ring) name) : @rank_condition.{0} (has_zero.{0} name) (@function.extfun_app.{2 1} Type ring.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type ring.{0}) name h0) (has_zero.{0} name))  := sorry --non-trivial
lemma new_lemma_96577 (h0 : ring (has_ssubset (random_gen linarith.ineq))) : strong_rank_condition (has_ssubset (random_gen linarith.ineq)) := sorry --non-trivial
lemma new_lemma_96578 (h1 : filter (has_inv to_additive.value_type)) : filter.ne_bot h1 := sorry --non-trivial
lemma new_lemma_96579 (h0 : function.extfun (finset Type) (has_mem.mem (with_bot linarith.comp_source))) : @t0_space.{0} (with_bot.{0} linarith.comp_source) (@finset.pi.empty.{1 0} Type topological_space.{0} (with_bot.{0} linarith.comp_source) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (with_bot.{0} linarith.comp_source)) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_96580 (h0 : complete_lattice (id (has_top linarith.ineq))) : is_atomistic (id (has_top linarith.ineq)) := sorry --non-trivial
lemma new_lemma_96581 (h0 : ring (normed_group (has_norm empty))) : is_domain (normed_group (has_norm empty)) := sorry --non-trivial
lemma new_lemma_96582 (h0 : functor.add_const (filter (semigroup name)) environment.implicit_infer_kind) : countable_Inter_filter (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_96583 (h0 : group (ring (has_neg_part (has_neg_part linarith.comp)))) : is_cyclic (ring (has_neg_part (has_neg_part linarith.comp))) := sorry --non-trivial
lemma new_lemma_96584 (h0 : add_group (linear_ordered_add_comm_group (with_bot linarith.ineq))) : is_add_cyclic (linear_ordered_add_comm_group (with_bot linarith.ineq)) := sorry --non-trivial
lemma new_lemma_96585 (h0 : function.extfun Type topological_space) : @totally_disconnected_space.{0} (add_cancel_monoid.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (add_cancel_monoid.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_96586 (h0 : has_mem.mem topological_space has_emptyc.emptyc) : @totally_separated_space.{0} (has_norm.{0} fun_info) (@function.extfun_app.{2 1} Type topological_space.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) topological_space.{0} h0) (has_norm.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_96587 (h2 : topological_space congr_arg_kind) : totally_separated_space congr_arg_kind := sorry --non-trivial
lemma new_lemma_96588 (h0 : topological_space (has_nndist (finset pos))) : regular_space (has_nndist (finset pos)) := sorry --non-trivial
lemma new_lemma_96589 (h0 : topological_space (with_one num)) : path_connected_space (with_one num) := sorry --non-trivial
lemma new_lemma_96590 (h0 : add_monoid (has_bot (ordered_comm_monoid pos))) : add_monoid.fg (has_bot (ordered_comm_monoid pos)) := sorry --non-trivial
lemma new_lemma_96591 (h0 : complete_lattice (semigroup (boolean_algebra pos))) : is_compactly_generated (semigroup (boolean_algebra pos)) := sorry --non-trivial
lemma new_lemma_96592 (h0 : group (dlist (random_gen (has_nnnorm (has_nnnorm linarith.comp_source))))) : group.fg (dlist (random_gen (has_nnnorm (has_nnnorm linarith.comp_source)))) := sorry --non-trivial
lemma new_lemma_96593 (h0 : functor.add_const (topological_space (cancel_monoid Type)) Type) : @sequential_space.{1} (cancel_monoid.{1} Type) (@functor.add_const.run.{1 1} (topological_space.{1} (cancel_monoid.{1} Type)) Type h0)  := sorry --non-trivial
lemma new_lemma_96594 (h0 : ring (has_ssubset linarith.comp_source)) : strong_rank_condition (has_ssubset linarith.comp_source) := sorry --non-trivial
lemma new_lemma_96595 (h0 : topological_space (has_add (has_nnnorm linarith.comp_source))) : totally_disconnected_space (has_add (has_nnnorm linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_96596 (h0 : functor.add_const (add_monoid (complete_distrib_lattice congr_arg_kind)) unsigned) : @add_monoid.fg.{0} (complete_distrib_lattice.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (add_monoid.{0} (complete_distrib_lattice.{0} congr_arg_kind)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_96597 (h0 : functor.add_const (function.extfun Type topological_space) name) : @path_connected_space.{0} linarith.comp (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) name h0) linarith.comp)  := sorry --non-trivial
lemma new_lemma_96598 (h0 : group (has_zero (finset linarith.comp))) : normalizer_condition (has_zero (finset linarith.comp)) := sorry --non-trivial
lemma new_lemma_96599 (h0 : topological_space (ordered_comm_ring (has_Inf (has_Inf Type)))) : sequential_space (ordered_comm_ring (has_Inf (has_Inf Type))) := sorry --non-trivial
lemma new_lemma_96600 (h0 : topological_space (has_add linarith.ineq)) : t0_space (has_add linarith.ineq) := sorry --non-trivial
lemma new_lemma_96601 (h0 : group (canonically_ordered_monoid (has_add pos))) : is_simple_group (canonically_ordered_monoid (has_add pos)) := sorry --non-trivial
lemma new_lemma_96602 (h0 h1 : multiset (semi_normed_ring char)) : multiset.disjoint h0 h1 := sorry --non-trivial
lemma new_lemma_96603 (h0 : functor.add_const (topological_space (has_Inf pos)) pos) : @totally_disconnected_space.{0} (has_Inf.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (has_Inf.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_96604 (h0 : uniform_space (ordered_comm_monoid (has_to_string Type))) : complete_space (ordered_comm_monoid (has_to_string Type)) := sorry --non-trivial
lemma new_lemma_96605 (h0 : functor.add_const (topological_space (ring pos)) (has_neg Type)) : @totally_separated_space.{0} (ring.{0} pos) (@functor.add_const.run.{0 1} (topological_space.{0} (ring.{0} pos)) (has_neg.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_96606 (h0 : functor.add_const (topological_space (left_cancel_semigroup congr_arg_kind)) congr_arg_kind) : @t1_space.{0} (left_cancel_semigroup.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (left_cancel_semigroup.{0} congr_arg_kind)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_96607 (h0 : option (filter Prop)) : @Lim.{0} Prop sierpinski_space (@nonempty_of_inhabited.{1} Prop sort.inhabited.{0}) (@list.head.{0} (filter.{0} Prop) (@filter.inhabited.{0} Prop) (@option.to_list.{0} (filter.{0} Prop) h0))  := sorry --non-trivial
lemma new_lemma_96608 (h1 : complete_lattice (simple_graph linarith.comp_source)) : is_compactly_generated (simple_graph linarith.comp_source) := sorry --non-trivial
lemma new_lemma_96609 (h0 : function.extfun Type group) : @group.fg.{0} (has_inv.{0} fun_info) (@function.extfun_app.{2 1} Type group.{0} h0 (has_inv.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_96610 (h0 : filter (normed_comm_ring (has_pos_part (finset (ring Type))))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_96611 (h0 : ring (distrib (has_nnnorm string.iterator_imp))) : is_domain (distrib (has_nnnorm string.iterator_imp)) := sorry --non-trivial
lemma new_lemma_96612 (h0 : topological_space (mul_one_class (mul_one_class (mul_one_class (add_comm_semigroup enat))))) : totally_disconnected_space (mul_one_class (mul_one_class (mul_one_class (add_comm_semigroup enat)))) := sorry --non-trivial
lemma new_lemma_96613 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : list.nodup (function.extfun_app (function.extfun_app h0 list) (has_zero Type)) := sorry --non-trivial
lemma new_lemma_96614 (h0 : normed_comm_ring (option (option empty))) (h1 : filter (normed_comm_ring (option (option empty)))) : @path_connected_space.{0} (normed_comm_ring.{0} (option.{0} (option.{0} empty))) (@nhds_adjoint.{0} (normed_comm_ring.{0} (option.{0} (option.{0} empty))) h0 h1)  := sorry --non-trivial
lemma new_lemma_96615 (h0 : not (function.extfun Type add_group -> false)) : @is_add_cyclic.{0} (linear_ordered_semiring.{0} empty) (@function.extfun_app.{2 1} Type add_group.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type add_group.{0}) h0) (linear_ordered_semiring.{0} empty))  := sorry --non-trivial
lemma new_lemma_96616 (h0 : has_coe (random_gen fun_info) Prop) (h1 : random_gen fun_info) : @coe_b.{1 1} (random_gen.{0} fun_info) Prop h0 h1  := sorry --non-trivial
lemma new_lemma_96617 (h0 : filter (has_dist num)) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_96618 (h0 : not (topological_space (linear_ordered_add_comm_group string_imp) -> false)) : @path_connected_space.{0} (linear_ordered_add_comm_group.{0} string_imp) (@classical.by_contradiction'.{1} (topological_space.{0} (linear_ordered_add_comm_group.{0} string_imp)) h0)  := sorry --non-trivial
lemma new_lemma_96619 (h0 : add_group (normed_lattice_add_comm_group (sub_neg_monoid (sub_neg_monoid real)))) : is_add_cyclic (normed_lattice_add_comm_group (sub_neg_monoid (sub_neg_monoid real))) := sorry --non-trivial
lemma new_lemma_96620 (h0 : topological_space (has_one (linear_ordered_semiring num))) : irreducible_space (has_one (linear_ordered_semiring num)) := sorry --non-trivial
lemma new_lemma_96621 (h0 : function.extfun Type topological_space) : @path_connected_space.{0} (cancel_monoid.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (cancel_monoid.{0} pos))  := sorry --non-trivial
lemma new_lemma_96622 (h0 : function.extfun nat fin) : @is_noetherian_ring.{0} (complete_distrib_lattice.{0} pos) (@matrix.vec_empty.{0} (semiring.{0} (complete_distrib_lattice.{0} pos)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_96623 (h0 : group (option (option pos))) : is_cyclic (option (option pos)) := sorry --non-trivial
lemma new_lemma_96624 (h1 : not (ring (semi_normed_ring linarith.ineq) -> false)) : @is_domain.{0} (semi_normed_ring.{0} linarith.ineq) (@classical.by_contradiction'.{1} (ring.{0} (semi_normed_ring.{0} linarith.ineq)) h1)  := sorry --non-trivial
lemma new_lemma_96625 (h0 : topological_space (canonically_linear_ordered_monoid (ordered_comm_monoid Type))) : normal_space (canonically_linear_ordered_monoid (ordered_comm_monoid Type)) := sorry --non-trivial
lemma new_lemma_96626 (h1 : add_group (semi_normed_comm_ring (random_gen (comm_ring reducibility_hints)))) : is_add_cyclic (semi_normed_comm_ring (random_gen (comm_ring reducibility_hints))) := sorry --non-trivial
lemma new_lemma_96627 (h0 : topological_space (dlist (random_gen string_imp))) : locally_compact_space (dlist (random_gen string_imp)) := sorry --non-trivial
lemma new_lemma_96628 (h0 : functor.add_const (function.extfun Type ordered_comm_monoid) Type) : @has_exists_mul_of_le.{0} (has_add.{0} pos) (@function.extfun_app.{2 1} Type ordered_comm_monoid.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type ordered_comm_monoid.{0}) Type h0) (has_add.{0} pos))  := sorry --non-trivial
lemma new_lemma_96629 (h0 : function.extfun Type group) : @is_cyclic.{0} (encodable.{0} fun_info) (@function.extfun_app.{2 1} Type group.{0} h0 (encodable.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_96630 (h0 : functor.add_const (semiring (comm_group unsigned)) name) : @is_noetherian_ring.{0} (comm_group.{0} unsigned) (@functor.add_const.run.{0 0} (semiring.{0} (comm_group.{0} unsigned)) name h0)  := sorry --non-trivial
lemma new_lemma_96631 (h0 : topological_space (canonically_ordered_comm_semiring (boolean_algebra Type))) : topological_space.separable_space (canonically_ordered_comm_semiring (boolean_algebra Type)) := sorry --non-trivial
lemma new_lemma_96632 (h0 : not (group (fintype to_additive.value_type) -> false)) : @is_cyclic.{0} (fintype.{0} to_additive.value_type) (@classical.by_contradiction'.{1} (group.{0} (fintype.{0} to_additive.value_type)) h0)  := sorry --non-trivial
lemma new_lemma_96633 (h0 : not (topological_space (metric_space num) -> false)) : @normal_space.{0} (metric_space.{0} num) (@classical.by_contradiction'.{1} (topological_space.{0} (metric_space.{0} num)) h0)  := sorry --non-trivial
lemma new_lemma_96634 (h0 : function.extfun Type list) : list.nodup (function.extfun_app h0 (sub_neg_monoid unsigned)) := sorry --non-trivial
lemma new_lemma_96635 (h0 : topological_space (normed_lattice_add_comm_group (sub_neg_monoid (sub_neg_monoid (has_neg real))))) : t1_space (normed_lattice_add_comm_group (sub_neg_monoid (sub_neg_monoid (has_neg real)))) := sorry --non-trivial
lemma new_lemma_96636 (h0 : functor.add_const (topological_space (normed_comm_ring environment.implicit_infer_kind)) name) : @loc_path_connected_space.{0} (normed_comm_ring.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (normed_comm_ring.{0} environment.implicit_infer_kind)) name h0)  := sorry --non-trivial
lemma new_lemma_96637 (h0 : ring (id (random_gen linarith.comp))) : strong_rank_condition (id (random_gen linarith.comp)) := sorry --non-trivial
lemma new_lemma_96638 (h0 : topological_space (has_neg (has_to_string (finset (finset (finset pos)))))) : normal_space (has_neg (has_to_string (finset (finset (finset pos))))) := sorry --non-trivial
lemma new_lemma_96639 (h0 : group (has_append (has_nnnorm (has_nnnorm char)))) : is_cyclic (has_append (has_nnnorm (has_nnnorm char))) := sorry --non-trivial
lemma new_lemma_96640 (h0 : not (complete_lattice (distrib_lattice char) -> false)) : @complete_lattice.is_Sup_finite_compact.{0} (distrib_lattice.{0} char) (@classical.by_contradiction'.{1} (complete_lattice.{0} (distrib_lattice.{0} char)) h0)  := sorry --non-trivial
lemma new_lemma_96641 (h0 : cancel_comm_monoid_with_zero (ring congr_arg_kind)) : unique_factorization_monoid (ring congr_arg_kind) := sorry --non-trivial
lemma new_lemma_96642 (h0 : functor.add_const (topological_space (plift empty)) num) : @preirreducible_space.{1} (plift.{1} empty) (@functor.add_const.run.{1 0} (topological_space.{1} (plift.{1} empty)) num h0)  := sorry --non-trivial
lemma new_lemma_96643 (h0 : filter (random_gen (semiring empty))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_96644 (h0 : set (linear_ordered_add_comm_monoid environment.projection_info)) : set.finite h0 := sorry --non-trivial
lemma new_lemma_96645 (h0 : topological_space (boolean_algebra.core congr_arg_kind)) : loc_path_connected_space (boolean_algebra.core congr_arg_kind) := sorry --non-trivial
lemma new_lemma_96646 (h0 : functor.add_const (topological_space (comm_group environment.implicit_infer_kind)) linarith.comp) : @preconnected_space.{0} (comm_group.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (comm_group.{0} environment.implicit_infer_kind)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_96647 (h0 : functor.add_const (topological_space (semigroup linarith.comp)) Type) : @sequential_space.{0} (semigroup.{0} linarith.comp) (@functor.add_const.run.{0 1} (topological_space.{0} (semigroup.{0} linarith.comp)) Type h0)  := sorry --non-trivial
lemma new_lemma_96648 (h0 : fin has_zero.zero) : @monoid.fg.{0} (complete_distrib_lattice.{0} pos) (@matrix.vec_empty.{0} (monoid.{0} (complete_distrib_lattice.{0} pos)) h0)  := sorry --non-trivial
lemma new_lemma_96649 (h0 : has_mem.mem (random_gen linarith.comp_source) has_emptyc.emptyc) : @is_add_cyclic.{0} (random_gen.{0} linarith.comp_source) (@finset.pi.empty.{1 0} Type add_group.{0} (random_gen.{0} linarith.comp_source) h0)  := sorry --non-trivial
lemma new_lemma_96650 : false := sorry --ntrivial
lemma new_lemma_96651 (h0 : topological_space (boolean_algebra (has_add linarith.comp))) : path_connected_space (boolean_algebra (has_add linarith.comp)) := sorry --non-trivial
lemma new_lemma_96652 (h0 : complete_lattice (has_inf fun_info)) : is_compactly_generated (has_inf fun_info) := sorry --non-trivial
lemma new_lemma_96653 (h0 : topological_space (complete_distrib_lattice (finset (finset (finset linarith.comp))))) : loc_path_connected_space (complete_distrib_lattice (finset (finset (finset linarith.comp)))) := sorry --non-trivial
lemma new_lemma_96654 (h0 : function.extfun nat fin) : @normalizer_condition.{0} (sub_neg_monoid.{0} (has_Inf.{0} pos)) (@matrix.vec_empty.{0} (group.{0} (sub_neg_monoid.{0} (has_Inf.{0} pos))) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_96655 (h0 : topological_space (canonically_ordered_comm_semiring environment.implicit_infer_kind)) : totally_separated_space (canonically_ordered_comm_semiring environment.implicit_infer_kind) := sorry --non-trivial
lemma new_lemma_96656 (h0 : topological_space (has_neg_part (semigroup (has_add (has_nndist name))))) : totally_separated_space (has_neg_part (semigroup (has_add (has_nndist name)))) := sorry --non-trivial
lemma new_lemma_96657 (h2 : add_group (denumerable char)) : is_add_cyclic (denumerable char) := sorry --non-trivial
lemma new_lemma_96658 (h0 : topological_space (normed_lattice_add_comm_group (has_neg (ordered_comm_monoid real)))) : regular_space (normed_lattice_add_comm_group (has_neg (ordered_comm_monoid real))) := sorry --non-trivial
lemma new_lemma_96659 (h0 : topological_space (complete_distrib_lattice (option (option pos)))) : sequential_space (complete_distrib_lattice (option (option pos))) := sorry --non-trivial
lemma new_lemma_96660 (h0 : not (ring (linear_ordered_comm_group_with_zero linarith.comp_source) -> false)) : @strong_rank_condition.{0} (linear_ordered_comm_group_with_zero.{0} linarith.comp_source) (@classical.by_contradiction'.{1} (ring.{0} (linear_ordered_comm_group_with_zero.{0} linarith.comp_source)) h0)  := sorry --non-trivial
lemma new_lemma_96661 (h0 : add_group (random_gen (has_top (has_top (has_top linarith.ineq))))) : is_add_cyclic (random_gen (has_top (has_top (has_top linarith.ineq)))) := sorry --non-trivial
lemma new_lemma_96662 (h0 : ring (complete_distrib_lattice (semiring unsigned))) : strong_rank_condition (complete_distrib_lattice (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_96663 (h0 : functor.add_const (function.extfun (Type 1) uniform_space) pos) : @complete_space.{1} (has_zero.{1} Type) (@function.extfun_app.{3 2} (Type 1) uniform_space.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) uniform_space.{1}) pos h0) (has_zero.{1} Type))  := sorry --non-trivial
lemma new_lemma_96664 (h0 : ordered_comm_monoid (simple_graph pos)) : has_exists_mul_of_le (simple_graph pos) := sorry --non-trivial
lemma new_lemma_96665 (h0 : group (monoid_with_zero (option (option (complete_distrib_lattice unsigned))))) : is_simple_group (monoid_with_zero (option (option (complete_distrib_lattice unsigned)))) := sorry --non-trivial
lemma new_lemma_96666 (h1 : topological_space (with_bot (has_top to_additive.value_type))) : t0_space (with_bot (has_top to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_96667 (h0 : add_group (normed_group (has_top (has_top fun_info)))) : is_add_cyclic (normed_group (has_top (has_top fun_info))) := sorry --non-trivial
lemma new_lemma_96668 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @discrete_topology.{0} (complete_distrib_lattice.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (complete_distrib_lattice.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_96669 (h0 : function.extfun Type topological_space) : @irreducible_space.{0} (with_bot.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (with_bot.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_96670 (h0 : add_group (ordered_comm_monoid pos)) : is_add_cyclic (ordered_comm_monoid pos) := sorry --non-trivial
lemma new_lemma_96671 (h0 : uniform_space (normed_group (has_norm (semiring unsigned)))) : complete_space (normed_group (has_norm (semiring unsigned))) := sorry --non-trivial
lemma new_lemma_96672 (h1 : topological_space (div_inv_monoid linarith.ineq)) : t0_space (div_inv_monoid linarith.ineq) := sorry --non-trivial
lemma new_lemma_96673 (h0 : topological_space (has_to_string (has_to_string linarith.comp))) : t0_space (has_to_string (has_to_string linarith.comp)) := sorry --non-trivial
lemma new_lemma_96674 (h0 : filter (complete_semilattice_Sup (random_gen linarith.comp_source))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_96675 (h0 : topological_space (has_norm (comm_ring (comm_ring linarith.ineq)))) : t0_space (has_norm (comm_ring (comm_ring linarith.ineq))) := sorry --non-trivial
lemma new_lemma_96676 (h0 : functor.add_const (topological_space (canonically_ordered_comm_semiring pos)) Type) : @normal_space.{0} (canonically_ordered_comm_semiring.{0} pos) (@functor.add_const.run.{0 1} (topological_space.{0} (canonically_ordered_comm_semiring.{0} pos)) Type h0)  := sorry --non-trivial
lemma new_lemma_96677 (h0 : function.extfun Type topological_space) : @t0_space.{0} (finset.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (finset.{0} pos))  := sorry --non-trivial
lemma new_lemma_96678 (h1 : topological_space (random_gen reducibility_hints)) : path_connected_space (random_gen reducibility_hints) := sorry --non-trivial
lemma new_lemma_96679 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : countable_Inter_filter (function.extfun_app (function.extfun_app h0 filter) (has_neg_part unsigned)) := sorry --non-trivial
lemma new_lemma_96680 (h0 : not (topological_space (add_right_cancel_monoid congr_arg_kind) -> false)) : @locally_compact_space.{0} (add_right_cancel_monoid.{0} congr_arg_kind) (@classical.by_contradiction'.{1} (topological_space.{0} (add_right_cancel_monoid.{0} congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_96681 (h0 : function.extfun Type topological_space) : @t0_space.{0} (linear_ordered_semiring.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (linear_ordered_semiring.{0} empty))  := sorry --non-trivial
lemma new_lemma_96682 (h0 : group (semigroup name)) : normalizer_condition (semigroup name) := sorry --non-trivial
lemma new_lemma_96683 (h0 : functor.add_const (complete_lattice (boolean_algebra.core Type)) (finset Type)) : @is_atomistic.{1} (boolean_algebra.core.{1} Type) (@functor.add_const.run.{1 1} (complete_lattice.{1} (boolean_algebra.core.{1} Type)) (finset.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_96684 (h0 : function.extfun Type group) : @normalizer_condition.{0} (omega_complete_partial_order.{0} unsigned) (@function.extfun_app.{2 1} Type group.{0} h0 (omega_complete_partial_order.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_96685 (h0 : fin has_zero.zero) : @complete_space.{0} (canonically_ordered_monoid.{0} linarith.comp) (@matrix.vec_empty.{0} (uniform_space.{0} (canonically_ordered_monoid.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_96686 (h0 : fin has_zero.zero) : @unique_factorization_monoid.{0} (canonically_ordered_comm_semiring.{0} linarith.comp) (@matrix.vec_empty.{0} (cancel_comm_monoid_with_zero.{0} (canonically_ordered_comm_semiring.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_96687 (h0 : finset (has_to_string (has_pos_part pos))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_96688 (h0 : functor.add_const (ordered_comm_monoid (cancel_monoid pos)) (comm_group Type)) : @has_exists_mul_of_le.{0} (cancel_monoid.{0} pos) (@functor.add_const.run.{0 1} (ordered_comm_monoid.{0} (cancel_monoid.{0} pos)) (comm_group.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_96689 (h0 : group (canonically_ordered_monoid (has_pos_part (has_pos_part real)))) : group.fg (canonically_ordered_monoid (has_pos_part (has_pos_part real))) := sorry --non-trivial
lemma new_lemma_96690 (h0 : uniform_space (has_norm linarith.comp)) : separated_space (has_norm linarith.comp) := sorry --non-trivial
lemma new_lemma_96691 (h0 : function.extfun nat fin) : @normalizer_condition.{0} (ordered_comm_ring.{0} pos) (@matrix.vec_empty.{0} (group.{0} (ordered_comm_ring.{0} pos)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_96692 (h0 : uniform_space (has_star (semiring (semiring empty)))) : separated_space (has_star (semiring (semiring empty))) := sorry --non-trivial
lemma new_lemma_96693 (h0 : add_monoid (has_union unsigned)) : add_monoid.fg (has_union unsigned) := sorry --non-trivial
lemma new_lemma_96694 (h0 : fun_info -> Prop) : @infi.{0 1} Prop (@conditionally_complete_lattice.to_has_Inf.{0} Prop (@complete_lattice.to_conditionally_complete_lattice.{0} Prop Prop.complete_lattice)) fun_info h0  := sorry --non-trivial
lemma new_lemma_96695 (h0 : set (nondiscrete_normed_field ereal)) : set.finite h0 := sorry --non-trivial
lemma new_lemma_96696 (h0 : function.extfun Type ordered_add_comm_monoid) : @archimedean.{0} (finset.{0} unsigned) (@function.extfun_app.{2 1} Type ordered_add_comm_monoid.{0} h0 (finset.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_96697 (h0 : function.extfun nat fin) : @separated_space.{0} (has_Inf.{0} real) (@function.extfun_app.{2 1} Type uniform_space.{0} (@matrix.vec_empty.{1} (function.extfun.{2 1} Type uniform_space.{0}) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero))) (has_Inf.{0} real))  := sorry --non-trivial
lemma new_lemma_96698 (h0 : functor.add_const (topological_space (canonically_ordered_comm_semiring name)) Type) : @t0_space.{0} (canonically_ordered_comm_semiring.{0} name) (@functor.add_const.run.{0 1} (topological_space.{0} (canonically_ordered_comm_semiring.{0} name)) Type h0)  := sorry --non-trivial
lemma new_lemma_96699 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : palindrome (function.extfun_app (function.extfun_app h0 list) (cancel_monoid name)) := sorry --non-trivial
lemma new_lemma_96700 (h0 : not (function.extfun Type group -> false)) : @is_cyclic.{0} (linear_ordered_add_comm_group.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type group.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type group.{0}) h0) (linear_ordered_add_comm_group.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_96701 (h0 : group (add_group_with_zero_nhd empty)) : normalizer_condition (add_group_with_zero_nhd empty) := sorry --non-trivial
lemma new_lemma_96702 (h0 : topological_space (complete_distrib_lattice (has_neg name))) : t0_space (complete_distrib_lattice (has_neg name)) := sorry --non-trivial
lemma new_lemma_96703 (h0 : group (has_top (random_gen linarith.ineq))) : is_cyclic (has_top (random_gen linarith.ineq)) := sorry --non-trivial
lemma new_lemma_96704 (h0 : functor.add_const (topological_space (add_left_cancel_semigroup empty)) empty) : @preirreducible_space.{0} (add_left_cancel_semigroup.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (add_left_cancel_semigroup.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_96705 (h0 : functor.add_const (monoid (boolean_algebra Type)) environment.implicit_infer_kind) : @monoid.fg.{1} (boolean_algebra.{1} Type) (@functor.add_const.run.{1 0} (monoid.{1} (boolean_algebra.{1} Type)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_96706 (h0 : semiring (has_dist (option ennreal))) : is_noetherian_ring (has_dist (option ennreal)) := sorry --non-trivial
lemma new_lemma_96707 (h0 : has_lt (nondiscrete_normed_field (add_comm_semigroup linarith.ineq))) : no_max_order (nondiscrete_normed_field (add_comm_semigroup linarith.ineq)) := sorry --non-trivial
lemma new_lemma_96708 (h0 : complete_lattice (add_monoid (has_nnnorm (has_nnnorm fun_info)))) : is_compactly_generated (add_monoid (has_nnnorm (has_nnnorm fun_info))) := sorry --non-trivial
lemma new_lemma_96709 (h0 : function.extfun Type group) : @is_cyclic.{0} (has_norm.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type group.{0} h0 (has_norm.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_96710 (h0 : semiring (complete_distrib_lattice (has_add real))) : is_noetherian_ring (complete_distrib_lattice (has_add real)) := sorry --non-trivial
lemma new_lemma_96711 (h0 : list (add_cancel_monoid (has_neg_part (add_comm_monoid (has_neg_part Type))))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_96712 (h0 : function.extfun Type topological_space) : @normal_space.{0} (cancel_monoid.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (cancel_monoid.{0} name))  := sorry --non-trivial
lemma new_lemma_96713 (h0 : cancel_comm_monoid_with_zero (linear_ordered_comm_monoid_with_zero (semiring empty))) : unique_factorization_monoid (linear_ordered_comm_monoid_with_zero (semiring empty)) := sorry --non-trivial
lemma new_lemma_96714 (h0 : functor.add_const (function.extfun Type topological_space) (ring environment.implicit_infer_kind)) : @path_connected_space.{0} (normed_comm_ring.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) (ring.{0} environment.implicit_infer_kind) h0) (normed_comm_ring.{0} pos))  := sorry --non-trivial
lemma new_lemma_96715 (h0 : functor.comp topological_space canonically_ordered_comm_semiring (has_add Type)) : @topological_space.separable_space.{1} (canonically_ordered_comm_semiring.{1} (has_add.{1} Type)) (@functor.comp.run.{1 1 1} topological_space.{1} canonically_ordered_comm_semiring.{1} (has_add.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_96716 (h0 : has_mem.mem (with_bot empty) has_emptyc.emptyc) : @is_cyclic.{0} (with_bot.{0} empty) (@finset.pi.empty.{1 0} Type group.{0} (with_bot.{0} empty) h0)  := sorry --non-trivial
lemma new_lemma_96717 (h0 : topological_space (has_add (has_Inf (has_add linarith.comp)))) : path_connected_space (has_add (has_Inf (has_add linarith.comp))) := sorry --non-trivial
lemma new_lemma_96718 (h0 : has_mem.mem (normed_group (has_top fun_info)) has_emptyc.emptyc) : @is_domain.{0} (normed_group.{0} (has_top.{0} fun_info)) (@finset.pi.empty.{1 0} Type ring.{0} (normed_group.{0} (has_top.{0} fun_info)) h0)  := sorry --non-trivial
lemma new_lemma_96719 (h0 : function.extfun Type topological_space) : @totally_disconnected_space.{0} (boolean_algebra.core.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (boolean_algebra.core.{0} num))  := sorry --non-trivial
lemma new_lemma_96720 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @topological_space.separable_space.{0} (simple_graph.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (simple_graph.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_96721 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_cyclic.{0} (option.{0} ennreal) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (option.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_96722 (h0 : not (function.extfun Type ring -> false)) : @strong_rank_condition.{0} (normed_group.{0} linarith.comp) (@function.extfun_app.{2 1} Type ring.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type ring.{0}) h0) (normed_group.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_96723 (h0 : add_group (uniform_space (mul_one_class linarith.ineq))) : is_add_cyclic (uniform_space (mul_one_class linarith.ineq)) := sorry --non-trivial
lemma new_lemma_96724 (h0 : ring (has_nnnorm fun_info)) : is_domain (has_nnnorm fun_info) := sorry --non-trivial
lemma new_lemma_96725 (h0 : functor.add_const (functor.add_const (uniform_space Type) pos) pos) : @separated_space.{1} Type (@functor.add_const.run.{1 0} (uniform_space.{1} Type) pos (@functor.add_const.run.{1 0} (functor.add_const.{1 0} (uniform_space.{1} Type) pos) pos h0))  := sorry --non-trivial
lemma new_lemma_96726 (h0 : has_pos_part Type -> has_pos_part Type -> has_pos_part Type) : left_cancelative h0 := sorry --non-trivial
lemma new_lemma_96727 (h0 : ring (option (option (option empty)))) : is_domain (option (option (option empty))) := sorry --non-trivial
lemma new_lemma_96728 (h0 : ring subsingleton_info) : is_domain subsingleton_info := sorry --non-trivial
lemma new_lemma_96729 (h0 : group (finset (has_neg linarith.comp))) : group.fg (finset (has_neg linarith.comp)) := sorry --non-trivial
lemma new_lemma_96730 (h0 : monoid (semigroup (has_add (has_neg environment.implicit_infer_kind)))) : monoid.fg (semigroup (has_add (has_neg environment.implicit_infer_kind))) := sorry --non-trivial
lemma new_lemma_96731 (h0 : topological_space (has_zero (ring Type))) : preirreducible_space (has_zero (ring Type)) := sorry --non-trivial
lemma new_lemma_96732 (h0 : functor.add_const (finset (canonically_ordered_comm_semiring name)) unsigned) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_96733 (h0 : topological_space (has_pos_part (ordered_comm_monoid (sub_neg_monoid real)))) : preconnected_space (has_pos_part (ordered_comm_monoid (sub_neg_monoid real))) := sorry --non-trivial
lemma new_lemma_96734 (h0 : filter (finset (option pos))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_96735 (h0 : group (id (has_top (has_top (linear_ordered_add_comm_group linarith.comp_source))))) : normalizer_condition (id (has_top (has_top (linear_ordered_add_comm_group linarith.comp_source)))) := sorry --non-trivial
lemma new_lemma_96736 (h0 : group (random_gen (has_inv (has_inv (random_gen (random_gen fun_info)))))) : normalizer_condition (random_gen (has_inv (has_inv (random_gen (random_gen fun_info))))) := sorry --non-trivial
lemma new_lemma_96737 (h0 : environment.implicit_infer_kind -> Prop) : zzz_forall h0 := sorry --non-trivial
lemma new_lemma_96738 (h0 : topological_space (has_nndist (complete_distrib_lattice real))) : preconnected_space (has_nndist (complete_distrib_lattice real)) := sorry --non-trivial
lemma new_lemma_96739 (h0 : list (distrib_lattice (random_gen to_additive.value_type))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_96740 (h0 : ring (normed_group (random_gen linarith.comp_source))) : is_domain (normed_group (random_gen linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_96741 (h0 : complete_lattice (denumerable (random_gen (random_gen linarith.comp_source)))) : is_compactly_generated (denumerable (random_gen (random_gen linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_96742 (h0 : uniform_space (measurable_space.dynkin_system (has_top (has_norm unsigned)))) : complete_space (measurable_space.dynkin_system (has_top (has_norm unsigned))) := sorry --non-trivial
lemma new_lemma_96743 (h0 : complete_lattice (id (random_gen to_additive.value_type))) : complete_lattice.is_Sup_finite_compact (id (random_gen to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_96744 (h0 : add_comm_group (distrib (semiring linarith.comp))) (h1 : has_norm (distrib (semiring linarith.comp))) : normed_group.core (distrib (semiring linarith.comp)) := sorry --non-trivial
lemma new_lemma_96745 (h0 : topological_space (has_star (semiring unsigned))) : irreducible_space (has_star (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_96746 (h0 : function.extfun Type topological_space) : @topological_space.separable_space.{0} (canonically_ordered_monoid.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (canonically_ordered_monoid.{0} name))  := sorry --non-trivial
lemma new_lemma_96747 (h0 : functor.add_const (topological_space (has_to_string pos)) (finset Type)) : @regular_space.{0} (has_to_string.{0} pos) (@functor.add_const.run.{0 1} (topological_space.{0} (has_to_string.{0} pos)) (finset.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_96748 (h0 : uniform_space (add_right_cancel_monoid num)) : complete_space (add_right_cancel_monoid num) := sorry --non-trivial
lemma new_lemma_96749 (h0 : ring (distrib (has_nnnorm (has_nnnorm (comm_ring linarith.ineq))))) : is_domain (distrib (has_nnnorm (has_nnnorm (comm_ring linarith.ineq)))) := sorry --non-trivial
lemma new_lemma_96750 (h0 : add_group (has_add (random_gen (random_gen to_additive.value_type)))) : is_add_cyclic (has_add (random_gen (random_gen to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_96751 (h0 : pseudo_metric_space (has_to_string num) -> pseudo_metric_space (has_to_string num) -> Prop) : is_symm (pseudo_metric_space (has_to_string num)) h0 := sorry --non-trivial
lemma new_lemma_96752 (h0 : functor.add_const (topological_space (has_star num)) empty) : @irreducible_space.{0} (has_star.{0} num) (@functor.add_const.run.{0 0} (topological_space.{0} (has_star.{0} num)) empty h0)  := sorry --non-trivial
lemma new_lemma_96753 (h0 : function.extfun Type (functor.add_const (complete_lattice (normed_group unsigned)))) : @is_atomistic.{0} (normed_group.{0} unsigned) (@functor.add_const.run.{0 0} (complete_lattice.{0} (normed_group.{0} unsigned)) empty (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (complete_lattice.{0} (normed_group.{0} unsigned))) h0 empty))  := sorry --non-trivial
lemma new_lemma_96754 (h0 : topological_space (has_nndist (option num))) : totally_disconnected_space (has_nndist (option num)) := sorry --non-trivial
lemma new_lemma_96755 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : finset.nonempty (function.extfun_app (function.extfun_app h0 finset) (normed_comm_ring ennreal)) := sorry --non-trivial
lemma new_lemma_96756 (h0 : functor.add_const (ring (non_assoc_semiring unsigned)) (has_edist unsigned)) : @is_domain.{0} (non_assoc_semiring.{0} unsigned) (@functor.add_const.run.{0 0} (ring.{0} (non_assoc_semiring.{0} unsigned)) (has_edist.{0} unsigned) h0)  := sorry --non-trivial
lemma new_lemma_96757 (h0 : topological_space (has_inter ennreal)) : irreducible_space (has_inter ennreal) := sorry --non-trivial
lemma new_lemma_96758 (h0 : group (random_gen (has_inv to_additive.value_type))) : is_cyclic (random_gen (has_inv to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_96759 (h0 : function.extfun Type topological_space) : @path_connected_space.{0} (ordered_cancel_add_comm_monoid.{0} (option.{0} unsigned)) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (ordered_cancel_add_comm_monoid.{0} (option.{0} unsigned)))  := sorry --non-trivial
lemma new_lemma_96760 (h0 : function.extfun Type filter) : filter.ne_bot (function.extfun_app h0 (preorder congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_96761 (h0 : functor.add_const (function.extfun Type filter) (has_pos_part (finset pos))) : countable_Inter_filter (function.extfun_app (functor.add_const.run h0) (has_Inf linarith.comp)) := sorry --non-trivial
lemma new_lemma_96762 (h0 : fin has_zero.zero) : @preirreducible_space.{1} (complete_distrib_lattice.{1} Type) (@matrix.vec_empty.{1} (topological_space.{1} (complete_distrib_lattice.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_96763 (h0 : not (is_empty (denumerable char) -> false)) (h1 : denumerable char) : @is_add_cyclic.{0} (denumerable.{0} linarith.ineq) (@is_empty.elim'.{1 1} (denumerable.{0} char) (add_group.{0} (denumerable.{0} linarith.ineq)) (@classical.by_contradiction'.{0} (is_empty.{1} (denumerable.{0} char)) h0) h1)  := sorry --non-trivial
lemma new_lemma_96764 (h1 : function.extfun Type complete_lattice) : @complete_lattice.is_Sup_finite_compact.{0} (semiring.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type complete_lattice.{0} h1 (semiring.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_96765 (h0 : topological_space (sub_neg_monoid (has_Inf (has_add Type)))) : totally_separated_space (sub_neg_monoid (has_Inf (has_add Type))) := sorry --non-trivial
lemma new_lemma_96766 (h0 : ordered_add_comm_monoid (has_nndist (option (option (option pos))))) : archimedean (has_nndist (option (option (option pos)))) := sorry --non-trivial
lemma new_lemma_96767 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @preirreducible_space.{0} (partial_order.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (partial_order.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_96768 (h1 : ring (distrib linarith.comp_source)) : rank_condition (distrib linarith.comp_source) := sorry --non-trivial
lemma new_lemma_96769 (h0 : complete_lattice (has_lt linarith.comp_source)) : is_compactly_generated (has_lt linarith.comp_source) := sorry --non-trivial
lemma new_lemma_96770 (h0 : functor.add_const (topological_space (complete_linear_order num)) num) : @topological_space.separable_space.{0} (complete_linear_order.{0} num) (@functor.add_const.run.{0 0} (topological_space.{0} (complete_linear_order.{0} num)) num h0)  := sorry --non-trivial
lemma new_lemma_96771 (h0 : not (topological_space (metric_space unsigned) -> false)) : @totally_disconnected_space.{0} (metric_space.{0} unsigned) (@classical.by_contradiction'.{1} (topological_space.{0} (metric_space.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_96772 (h0 : topological_space (has_bot (has_neg (has_neg (has_neg name))))) : discrete_topology (has_bot (has_neg (has_neg (has_neg name)))) := sorry --non-trivial
lemma new_lemma_96773 (h0 : functor.add_const (topological_space (monoid_with_zero pos)) unsigned) : @t0_space.{0} (monoid_with_zero.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (monoid_with_zero.{0} pos)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_96774 (h0 : topological_space (canonically_ordered_monoid (has_Inf real))) : topological_space.separable_space (canonically_ordered_monoid (has_Inf real)) := sorry --non-trivial
lemma new_lemma_96775 (h0 : functor.add_const (ordered_add_comm_monoid (bin_tree congr_arg_kind)) unsigned) : @archimedean.{0} (bin_tree.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (ordered_add_comm_monoid.{0} (bin_tree.{0} congr_arg_kind)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_96776 (h0 : function.extfun Type topological_space) : @t1_space.{0} (has_to_string.{0} ennreal) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_to_string.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_96777 (h0 : is_empty (add_comm_semigroup (add_comm_semigroup (add_comm_semigroup std_gen)))) (h1 : add_comm_semigroup (add_comm_semigroup (add_comm_semigroup std_gen))) : is_empty.elim' h0 h1 := sorry --non-trivial
lemma new_lemma_96778 (h0 : functor.add_const (add_monoid (complete_distrib_lattice environment.implicit_infer_kind)) linarith.comp) : @add_monoid.fg.{0} (complete_distrib_lattice.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (add_monoid.{0} (complete_distrib_lattice.{0} environment.implicit_infer_kind)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_96779 (h0 : function.extfun Type uniform_space) : @complete_space.{0} (canonically_ordered_add_monoid.{0} unsigned) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (canonically_ordered_add_monoid.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_96780 (h0 : topological_space (has_add (finset Type))) : topological_space.separable_space (has_add (finset Type)) := sorry --non-trivial
lemma new_lemma_96781 (h0 : prod (has_star num) (has_star num)) : id_rel h0 := sorry --non-trivial
lemma new_lemma_96782 (h0 : function.extfun Type (functor.add_const (topological_space (add_left_cancel_semigroup empty)))) : @loc_path_connected_space.{0} (add_left_cancel_semigroup.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (add_left_cancel_semigroup.{0} empty)) empty (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (topological_space.{0} (add_left_cancel_semigroup.{0} empty))) h0 empty))  := sorry --non-trivial
lemma new_lemma_96783 (h0 : function.extfun Type topological_space) : @irreducible_space.{0} (complete_semilattice_Sup.{0} fun_info) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (complete_semilattice_Sup.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_96784 (h0 : finset (has_pos_part (has_Inf linarith.comp))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_96785 (h0 : functor.add_const (group (boolean_algebra unsigned)) linarith.comp) : @is_simple_group.{0} (boolean_algebra.{0} unsigned) (@functor.add_const.run.{0 0} (group.{0} (boolean_algebra.{0} unsigned)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_96786 (h0 : functor.add_const (ring (ordered_comm_ring Type)) Type) : @is_principal_ideal_ring.{1} (ordered_comm_ring.{1} Type) (@functor.add_const.run.{1 1} (ring.{1} (ordered_comm_ring.{1} Type)) Type h0)  := sorry --non-trivial
lemma new_lemma_96787 (h0 : not (topological_space (topological_space char) -> false)) : @totally_disconnected_space.{0} (topological_space.{0} char) (@classical.by_contradiction'.{1} (topological_space.{0} (topological_space.{0} char)) h0)  := sorry --non-trivial
lemma new_lemma_96788 (h0 : add_group (ordered_comm_group (random_gen reducibility_hints))) : is_add_cyclic (ordered_comm_group (random_gen reducibility_hints)) := sorry --non-trivial
lemma new_lemma_96789 (h0 : ring (has_emptyc (random_gen linarith.comp_source))) : rank_condition (has_emptyc (random_gen linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_96790 (h0 : function.extfun (finset Type) (has_mem.mem (semiring to_additive.value_type))) : @complete_lattice.is_Sup_finite_compact.{0} (semiring.{0} to_additive.value_type) (@finset.pi.empty.{1 0} Type complete_lattice.{0} (semiring.{0} to_additive.value_type) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (semiring.{0} to_additive.value_type)) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_96791 (h0 : functor.add_const (topological_space (has_neg pos)) (has_neg environment.implicit_infer_kind)) : @loc_path_connected_space.{0} (has_neg.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (has_neg.{0} pos)) (has_neg.{0} environment.implicit_infer_kind) h0)  := sorry --non-trivial
lemma new_lemma_96792 (h0 : not (complete_lattice (linear_ordered_comm_ring unsigned) -> false)) : @is_compactly_generated.{0} (linear_ordered_comm_ring.{0} unsigned) (@classical.by_contradiction'.{1} (complete_lattice.{0} (linear_ordered_comm_ring.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_96793 (h0 : function.extfun Type topological_space) : @t1_space.{0} (has_Inf.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_Inf.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_96794 (h0 : ring (has_nndist (has_add pos))) : is_principal_ideal_ring (has_nndist (has_add pos)) := sorry --non-trivial
lemma new_lemma_96795 (h0 : ring (linear_ordered_comm_group (option (option (option congr_arg_kind))))) : is_domain (linear_ordered_comm_group (option (option (option congr_arg_kind)))) := sorry --non-trivial
lemma new_lemma_96796 (h0 : monoid (has_add (has_pos_part linarith.comp))) : monoid.fg (has_add (has_pos_part linarith.comp)) := sorry --non-trivial
lemma new_lemma_96797 (h0 : topological_space (non_assoc_semiring congr_arg_kind)) : locally_compact_space (non_assoc_semiring congr_arg_kind) := sorry --non-trivial
lemma new_lemma_96798 (h0 : functor.add_const (monoid (has_neg linarith.comp)) pos) : @monoid.fg.{0} (has_neg.{0} linarith.comp) (@functor.add_const.run.{0 0} (monoid.{0} (has_neg.{0} linarith.comp)) pos h0)  := sorry --non-trivial
lemma new_lemma_96799 (h0 : topological_space (ring (option (option empty)))) : totally_disconnected_space (ring (option (option empty))) := sorry --non-trivial
lemma new_lemma_96800 (h1 : topological_space (has_lt linarith.comp_source)) (h2 : add_group (has_lt linarith.comp_source)) : topological_add_group (has_lt linarith.comp_source) := sorry --non-trivial
lemma new_lemma_96801 (h0 : group (ordered_comm_ring (has_Inf (has_add real)))) : group.fg (ordered_comm_ring (has_Inf (has_add real))) := sorry --non-trivial
lemma new_lemma_96802 (h0 : functor.add_const (list (add_semigroup empty)) num) : list.nodup (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_96803 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : finset.nonempty (function.extfun_app (function.extfun_app h0 finset) (option pos)) := sorry --non-trivial
lemma new_lemma_96804 (h0 : function.extfun Type filter) : filter.ne_bot (function.extfun_app h0 (has_top string_imp)) := sorry --non-trivial
lemma new_lemma_96805 (h0 : functor.add_const (topological_space (has_add Type)) pos) : @discrete_topology.{1} (has_add.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (has_add.{1} Type)) pos h0)  := sorry --non-trivial
lemma new_lemma_96806 (h0 : complete_lattice (has_norm (semiring fun_info))) : is_compactly_generated (has_norm (semiring fun_info)) := sorry --non-trivial
lemma new_lemma_96807 (h0 : functor.add_const (function.extfun Type topological_space) Type) : @regular_space.{0} (finset.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type topological_space.{0}) Type h0) (finset.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_96808 (h0 : not (topological_space (has_union unsigned) -> false)) : @totally_separated_space.{0} (has_union.{0} unsigned) (@classical.by_contradiction'.{1} (topological_space.{0} (has_union.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_96809 (h0 : function.extfun Type topological_space) : @t0_space.{0} (canonically_linear_ordered_monoid.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (canonically_linear_ordered_monoid.{0} pos))  := sorry --non-trivial
lemma new_lemma_96810 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @rank_condition.{0} (has_dist.{0} empty) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (has_dist.{0} empty))  := sorry --non-trivial
lemma new_lemma_96811 (h0 : topological_space (linear_ordered_comm_group (option (option ennreal)))) : t0_space (linear_ordered_comm_group (option (option ennreal))) := sorry --non-trivial
lemma new_lemma_96812 (h0 : fin has_zero.zero) : @preconnected_space.{0} (has_bot.{0} linarith.comp) (@matrix.vec_empty.{0} (topological_space.{0} (has_bot.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_96813 (h0 : function.extfun Type topological_space) : @preconnected_space.{0} (normed_comm_ring.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (normed_comm_ring.{0} pos))  := sorry --non-trivial
lemma new_lemma_96814 (h0 : complete_lattice (metric_space (has_norm empty))) : complete_lattice.is_Sup_finite_compact (metric_space (has_norm empty)) := sorry --non-trivial
lemma new_lemma_96815 (h0 : topological_space (normed_group (metric_space num))) : normal_space (normed_group (metric_space num)) := sorry --non-trivial
lemma new_lemma_96816 (h0 : function.extfun Type uniform_space) : @complete_space.{0} (normed_linear_ordered_group.{0} unsigned) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (normed_linear_ordered_group.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_96817 (h0 : functor.add_const (ring (boolean_algebra.core pos)) (finset pos)) : @is_domain.{0} (boolean_algebra.core.{0} pos) (@functor.add_const.run.{0 0} (ring.{0} (boolean_algebra.core.{0} pos)) (finset.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_96818 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @complete_lattice.is_Sup_finite_compact.{0} (has_neg.{0} name) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (has_neg.{0} name))  := sorry --non-trivial
lemma new_lemma_96819 (h0 : functor.add_const (ring (add_comm_monoid pos)) Type) : @is_domain.{0} (add_comm_monoid.{0} pos) (@functor.add_const.run.{0 1} (ring.{0} (add_comm_monoid.{0} pos)) Type h0)  := sorry --non-trivial
lemma new_lemma_96820 (h0 : function.extfun Type topological_space) : @t1_space.{0} (has_neg_part.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_neg_part.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_96821 (h0 : function.extfun (Type 1) topological_space) : @path_connected_space.{1} (sub_neg_monoid.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} h0 (sub_neg_monoid.{1} Type))  := sorry --non-trivial
lemma new_lemma_96822 (h0 : function.extfun Type add_monoid) : @add_monoid.fg.{0} (normed_lattice_add_comm_group.{0} name) (@function.extfun_app.{2 1} Type add_monoid.{0} h0 (normed_lattice_add_comm_group.{0} name))  := sorry --non-trivial
lemma new_lemma_96823 (h0 : functor.add_const (function.extfun Type add_group) linarith.comp) : @is_add_cyclic.{0} linarith.comp (@function.extfun_app.{2 1} Type add_group.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type add_group.{0}) linarith.comp h0) linarith.comp)  := sorry --non-trivial
lemma new_lemma_96824 (h0 : ring (ring (has_Inf Type))) : is_domain (ring (has_Inf Type)) := sorry --non-trivial
lemma new_lemma_96825 (h0 : topological_space (normed_linear_ordered_group (semiring congr_arg_kind))) : irreducible_space (normed_linear_ordered_group (semiring congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_96826 (h0 : filter (left_cancel_monoid (option unsigned))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_96827 (h0 : add_monoid (has_add (finset environment.implicit_infer_kind))) : add_monoid.fg (has_add (finset environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_96828 (h0 : function.extfun (Type 1) group) : @normalizer_condition.{1} (plift.{1} num) (@function.extfun_app.{3 2} (Type 1) group.{1} h0 (plift.{1} num))  := sorry --non-trivial
lemma new_lemma_96829 (h0 : topological_space (has_top (has_top (has_top (has_top linarith.ineq))))) : path_connected_space (has_top (has_top (has_top (has_top linarith.ineq)))) := sorry --non-trivial
lemma new_lemma_96830 (h0 : monoid (ordered_comm_monoid linarith.comp)) : monoid.fg (ordered_comm_monoid linarith.comp) := sorry --non-trivial
lemma new_lemma_96831 (h0 : topological_space ennreal) : irreducible_space ennreal := sorry --non-trivial
lemma new_lemma_96832 (h0 : ring (comm_ring (random_gen (random_gen to_additive.value_type)))) : strong_rank_condition (comm_ring (random_gen (random_gen to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_96833 (h0 : function.extfun Type group) : @is_cyclic.{0} (add_group.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type group.{0} h0 (add_group.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_96834 (h0 : set (add_comm_semigroup (mul_one_class (mul_one_class (mul_one_class (mul_one_class (mul_one_class enat))))))) : set.finite h0 := sorry --non-trivial
lemma new_lemma_96835 (h0 : ring (distrib char)) : strong_rank_condition (distrib char) := sorry --non-trivial
lemma new_lemma_96836 (h0 : functor.add_const (filter (boolean_algebra Type)) linarith.comp) : countable_Inter_filter (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_96837 (h0 : function.extfun Type ring) : @is_principal_ideal_ring.{0} (complete_distrib_lattice.{0} (option.{0} ennreal)) (@function.extfun_app.{2 1} Type ring.{0} h0 (complete_distrib_lattice.{0} (option.{0} ennreal)))  := sorry --non-trivial
lemma new_lemma_96838 (h0 : functor.add_const (filter (has_add pos)) Type) : countable_Inter_filter (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_96839 (h0 : function.extfun Type ring) : @strong_rank_condition.{0} (measurable_space.{0} linarith.ineq) (@function.extfun_app.{2 1} Type ring.{0} h0 (measurable_space.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_96840 (h0 : functor.add_const (function.extfun (Type 1) uniform_space) Type) : @separated_space.{1} (has_to_string.{1} Type) (@function.extfun_app.{3 2} (Type 1) uniform_space.{1} (@functor.add_const.run.{2 1} (function.extfun.{3 2} (Type 1) uniform_space.{1}) Type h0) (has_to_string.{1} Type))  := sorry --non-trivial
lemma new_lemma_96841 (h0 : function.extfun Type monoid) : @monoid.fg.{0} (has_top.{0} unsigned) (@function.extfun_app.{2 1} Type monoid.{0} h0 (has_top.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_96842 (h0 : uniform_space (has_zero (comm_group name))) : complete_space (has_zero (comm_group name)) := sorry --non-trivial
lemma new_lemma_96843 (h0 : fin has_zero.zero) (h1 : with_bot pnat) (h2 : ne h1 has_bot.bot) : pnat.coprime (matrix.vec_empty h0) (with_bot.unbot h1 h2) := sorry --non-trivial
lemma new_lemma_96844 (h0 : function.extfun Type topological_space) : @irreducible_space.{0} (linear_ordered_add_comm_group.{0} (has_norm.{0} fun_info)) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (linear_ordered_add_comm_group.{0} (has_norm.{0} fun_info)))  := sorry --non-trivial
lemma new_lemma_96845 (h1 : topological_space (has_compl (has_ssubset char))) : path_connected_space (has_compl (has_ssubset char)) := sorry --non-trivial
lemma new_lemma_96846 (h0 : finset (has_neg (has_add (has_neg (has_pos_part linarith.comp))))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_96847 (h0 : function.extfun Type group) : @is_cyclic.{0} (sub_neg_monoid.{0} real) (@function.extfun_app.{2 1} Type group.{0} h0 (sub_neg_monoid.{0} real))  := sorry --non-trivial
lemma new_lemma_96848 (h0 : topological_space (has_add (has_neg pos))) : path_connected_space (has_add (has_neg pos)) := sorry --non-trivial
lemma new_lemma_96849 (h0 : topological_space (normed_group (random_gen (random_gen linarith.ineq)))) : t0_space (normed_group (random_gen (random_gen linarith.ineq))) := sorry --non-trivial
lemma new_lemma_96850 (h0 : ordered_add_comm_monoid (left_cancel_semigroup (semiring empty))) : archimedean (left_cancel_semigroup (semiring empty)) := sorry --non-trivial
lemma new_lemma_96851 (h0 : function.extfun (Type 1) (functor.add_const (list Type))) : palindrome (functor.add_const.run (function.extfun_app h0 (has_add (finset (ring Type))))) := sorry --non-trivial
lemma new_lemma_96852 (h1 : filter (div_inv_monoid to_additive.value_type)) : filter.ne_bot h1 := sorry --non-trivial
lemma new_lemma_96853 (h0 : complete_lattice (add_comm_monoid (has_add (has_zero name)))) : complete_lattice.is_Sup_finite_compact (add_comm_monoid (has_add (has_zero name))) := sorry --non-trivial
lemma new_lemma_96854 (h0 : functor.add_const (topological_space (has_Inf pos)) name) : @t0_space.{0} (has_Inf.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (has_Inf.{0} pos)) name h0)  := sorry --non-trivial
lemma new_lemma_96855 (h3 : ring linarith.ineq) : strong_rank_condition linarith.ineq := sorry --non-trivial
lemma new_lemma_96856 (h0 : group (complete_distrib_lattice Type)) : is_simple_group (complete_distrib_lattice Type) := sorry --non-trivial
lemma new_lemma_96857 (h0 : functor.add_const (topological_space (ring linarith.comp)) Type) : @topological_space.separable_space.{0} (ring.{0} linarith.comp) (@functor.add_const.run.{0 1} (topological_space.{0} (ring.{0} linarith.comp)) Type h0)  := sorry --non-trivial
lemma new_lemma_96858 (h0 : topological_space (has_neg_part environment.implicit_infer_kind)) : totally_disconnected_space (has_neg_part environment.implicit_infer_kind) := sorry --non-trivial
lemma new_lemma_96859 (h0 : function.extfun Type topological_space) : @t1_space.{0} (add_cancel_monoid.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (add_cancel_monoid.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_96860 (h0 : functor.add_const (complete_lattice (boolean_algebra pos)) Type) : @is_compactly_generated.{0} (boolean_algebra.{0} pos) (@functor.add_const.run.{0 1} (complete_lattice.{0} (boolean_algebra.{0} pos)) Type h0)  := sorry --non-trivial
lemma new_lemma_96861 (h0 : topological_space (ring (has_nndist (has_add pos)))) : normal_space (ring (has_nndist (has_add pos))) := sorry --non-trivial
lemma new_lemma_96862 (h0 : functor.add_const (function.extfun Type topological_space) (has_Inf (has_pos_part linarith.comp))) : @sequential_space.{0} (ring.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) (has_Inf.{0} (has_pos_part.{0} linarith.comp)) h0) (ring.{0} pos))  := sorry --non-trivial
lemma new_lemma_96863 (h0 : group (has_norm linarith.ineq)) : group.fg (has_norm linarith.ineq) := sorry --non-trivial
lemma new_lemma_96864 (h0 : functor.add_const (function.extfun Type complete_lattice) (has_Inf linarith.comp)) : @complete_lattice.is_Sup_finite_compact.{0} (add_cancel_monoid.{0} name) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type complete_lattice.{0}) (has_Inf.{0} linarith.comp) h0) (add_cancel_monoid.{0} name))  := sorry --non-trivial
lemma new_lemma_96865 (h0 : ring (comm_ring (comm_ring (has_nnnorm (has_nnnorm reducibility_hints))))) : strong_rank_condition (comm_ring (comm_ring (has_nnnorm (has_nnnorm reducibility_hints)))) := sorry --non-trivial
lemma new_lemma_96866 (h2 : has_coe (nondiscrete_normed_field enat) Prop) (h3 : nondiscrete_normed_field enat) : @coe_b.{1 1} (nondiscrete_normed_field.{0} enat) Prop h2 h3  := sorry --non-trivial
lemma new_lemma_96867 (h1 : function.extfun Type complete_lattice) : @is_compactly_generated.{0} to_additive.value_type (@function.extfun_app.{2 1} Type complete_lattice.{0} h1 to_additive.value_type)  := sorry --non-trivial
lemma new_lemma_96868 (h0 : list (is_R_or_C unsigned)) : palindrome h0 := sorry --non-trivial
lemma new_lemma_96869 (h0 : not (ring (topological_space string_imp) -> false)) : @strong_rank_condition.{0} (topological_space.{0} string_imp) (@classical.by_contradiction'.{1} (ring.{0} (topological_space.{0} string_imp)) h0)  := sorry --non-trivial
lemma new_lemma_96870 (h0 : function.extfun Type topological_space) : @totally_disconnected_space.{0} (boolean_algebra.{0} (finset.{0} name)) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (boolean_algebra.{0} (finset.{0} name)))  := sorry --non-trivial
lemma new_lemma_96871 (h0 : not (topological_space (metric_space reducibility_hints) -> false)) : @t0_space.{0} (metric_space.{0} reducibility_hints) (@classical.by_contradiction'.{1} (topological_space.{0} (metric_space.{0} reducibility_hints)) h0)  := sorry --non-trivial
lemma new_lemma_96872 (h0 : cancel_comm_monoid_with_zero (linear_ordered_comm_group (option empty))) : unique_factorization_monoid (linear_ordered_comm_group (option empty)) := sorry --non-trivial
lemma new_lemma_96873 (h0 : topological_space (linear_ordered_field empty)) : locally_compact_space (linear_ordered_field empty) := sorry --non-trivial
lemma new_lemma_96874 (h0 : complete_lattice (has_top (has_inv (has_inv to_additive.value_type)))) : is_atomistic (has_top (has_inv (has_inv to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_96875 (h0 : functor.add_const (topological_space (add_cancel_monoid pos)) Type) : @loc_path_connected_space.{0} (add_cancel_monoid.{0} pos) (@functor.add_const.run.{0 1} (topological_space.{0} (add_cancel_monoid.{0} pos)) Type h0)  := sorry --non-trivial
lemma new_lemma_96876 (h0 : group (semigroup (has_neg name))) : is_simple_group (semigroup (has_neg name)) := sorry --non-trivial
lemma new_lemma_96877 (h0 : functor.add_const (ring (has_edist unsigned)) congr_arg_kind) : @is_principal_ideal_ring.{0} (has_edist.{0} unsigned) (@functor.add_const.run.{0 0} (ring.{0} (has_edist.{0} unsigned)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_96878 (h0 : add_group (mul_zero_class (finset (has_nndist environment.implicit_infer_kind)))) : is_add_cyclic (mul_zero_class (finset (has_nndist environment.implicit_infer_kind))) := sorry --non-trivial
lemma new_lemma_96879 (h0 : functor.add_const (function.extfun (Type 1) add_group) (ring linarith.comp)) : @is_add_cyclic.{1} (simple_graph.{1} Type) (@function.extfun_app.{3 2} (Type 1) add_group.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) add_group.{1}) (ring.{0} linarith.comp) h0) (simple_graph.{1} Type))  := sorry --non-trivial
lemma new_lemma_96880 (h0 : fin has_zero.zero) : @is_principal_ideal_ring.{1} (boolean_algebra.{1} Type) (@matrix.vec_empty.{1} (ring.{1} (boolean_algebra.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_96881 (h0 : functor.add_const (complete_lattice (has_nndist pos)) pos) : @is_atomistic.{0} (has_nndist.{0} pos) (@functor.add_const.run.{0 0} (complete_lattice.{0} (has_nndist.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_96882 (h0 : topological_space (has_nndist (ring Type))) : loc_path_connected_space (has_nndist (ring Type)) := sorry --non-trivial
lemma new_lemma_96883 (h0 : not (ring (has_nndist linarith.comp_source) -> false)) : @strong_rank_condition.{0} (has_nndist.{0} linarith.comp_source) (@classical.by_contradiction'.{1} (ring.{0} (has_nndist.{0} linarith.comp_source)) h0)  := sorry --non-trivial
lemma new_lemma_96884 (h0 : functor.add_const (ring (has_zero name)) Type) : @rank_condition.{0} (has_zero.{0} name) (@functor.add_const.run.{0 1} (ring.{0} (has_zero.{0} name)) Type h0)  := sorry --non-trivial
lemma new_lemma_96885 (h0 : function.extfun Type group) : @is_cyclic.{0} (measurable_space.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type group.{0} h0 (measurable_space.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_96886 (h0 : functor.add_const (topological_space (ring Type)) linarith.comp) : @irreducible_space.{1} (ring.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (ring.{1} Type)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_96887 (h0 : finset (non_assoc_semiring num)) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_96888 (h0 : add_monoid (canonically_linear_ordered_monoid (has_pos_part (sub_neg_monoid Type)))) : add_monoid.fg (canonically_linear_ordered_monoid (has_pos_part (sub_neg_monoid Type))) := sorry --non-trivial
lemma new_lemma_96889 (h0 : functor.add_const (uniform_space (boolean_algebra.core linarith.comp)) (has_neg_part Type)) : @complete_space.{0} (boolean_algebra.core.{0} linarith.comp) (@functor.add_const.run.{0 1} (uniform_space.{0} (boolean_algebra.core.{0} linarith.comp)) (has_neg_part.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_96890 (h0 : complete_lattice (normed_group (has_norm string_imp))) : is_compactly_generated (normed_group (has_norm string_imp)) := sorry --non-trivial
lemma new_lemma_96891 (h0 : topological_space (finset (has_add (finset (has_add name))))) : sequential_space (finset (has_add (finset (has_add name)))) := sorry --non-trivial
lemma new_lemma_96892 (h0 : add_monoid (with_one num)) : add_monoid.fg (with_one num) := sorry --non-trivial
lemma new_lemma_96893 (h1 : complete_lattice (topological_space (random_gen char))) : complete_lattice.is_Sup_finite_compact (topological_space (random_gen char)) := sorry --non-trivial
lemma new_lemma_96894 (h0 : prod (has_union num) (has_union num)) : id_rel h0 := sorry --non-trivial
lemma new_lemma_96895 (h0 : topological_space (random_gen (has_norm linarith.comp))) : preirreducible_space (random_gen (has_norm linarith.comp)) := sorry --non-trivial
lemma new_lemma_96896 (h0 : function.extfun Type complete_lattice) : is_compactly_generated (filter unsigned) := sorry --non-trivial
lemma new_lemma_96897 (h0 : function.extfun Type group) : @normalizer_condition.{0} (@id.{2} Type empty) (@function.extfun_app.{2 1} Type group.{0} h0 (@id.{2} Type empty))  := sorry --non-trivial
lemma new_lemma_96898 (h0 : list (has_star (option (option (option (option (option (option (option empty))))))))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_96899 (h0 : functor.add_const (semiring (has_neg name)) (has_neg pos)) : @is_noetherian_ring.{0} (has_neg.{0} name) (@functor.add_const.run.{0 0} (semiring.{0} (has_neg.{0} name)) (has_neg.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_96900 (h0 : function.extfun Type add_monoid) : @add_monoid.fg.{0} (has_neg_part.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type add_monoid.{0} h0 (has_neg_part.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_96901 (h0 : complete_lattice (ring (option (option (option (option (option (option (option (option unsigned)))))))))) : is_atomistic (ring (option (option (option (option (option (option (option (option unsigned))))))))) := sorry --non-trivial
lemma new_lemma_96902 (h0 : ordered_comm_monoid (option (option unsigned))) : has_exists_mul_of_le (option (option unsigned)) := sorry --non-trivial
lemma new_lemma_96903 (h0 : group (div_inv_monoid linarith.ineq)) : group.fg (div_inv_monoid linarith.ineq) := sorry --non-trivial
lemma new_lemma_96904 (h0 : topological_space (canonically_linear_ordered_monoid real)) : locally_compact_space (canonically_linear_ordered_monoid real) := sorry --non-trivial
lemma new_lemma_96905 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @strong_rank_condition.{0} (semigroup.{0} linarith.comp) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (semigroup.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_96906 (h0 : ordered_add_comm_monoid (is_R_or_C empty)) : archimedean (is_R_or_C empty) := sorry --non-trivial
lemma new_lemma_96907 (h0 : uniform_space (bin_tree (semiring (semiring (semiring num))))) : separated_space (bin_tree (semiring (semiring (semiring num)))) := sorry --non-trivial
lemma new_lemma_96908 (h1 : ring (nondiscrete_normed_field linarith.ineq)) : is_domain (nondiscrete_normed_field linarith.ineq) := sorry --non-trivial
lemma new_lemma_96909 (h0 : function.extfun Type topological_space) : @t0_space.{0} (normed_comm_ring.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (normed_comm_ring.{0} pos))  := sorry --non-trivial
lemma new_lemma_96910 (h0 : topological_space (has_norm (has_top (random_gen (has_one empty))))) : normal_space (has_norm (has_top (random_gen (has_one empty)))) := sorry --non-trivial
lemma new_lemma_96911 (h0 : functor.add_const (function.extfun Type topological_space) Type) : @locally_compact_space.{0} (boolean_algebra.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type topological_space.{0}) Type h0) (boolean_algebra.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_96912 (h0 : add_monoid (generalized_boolean_algebra (has_add real))) : add_monoid.fg (generalized_boolean_algebra (has_add real)) := sorry --non-trivial
lemma new_lemma_96913 (h0 : complete_lattice (add_cancel_monoid (has_add linarith.comp))) : complete_lattice.is_Sup_finite_compact (add_cancel_monoid (has_add linarith.comp)) := sorry --non-trivial
lemma new_lemma_96914 (h0 : not (function.extfun Type add_monoid -> false)) : @add_monoid.fg.{0} (random_gen.{0} linarith.comp) (@function.extfun_app.{2 1} Type add_monoid.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type add_monoid.{0}) h0) (random_gen.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_96915 (h0 : functor.add_const (complete_lattice (comm_group environment.implicit_infer_kind)) environment.implicit_infer_kind) : @is_atomistic.{0} (comm_group.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (complete_lattice.{0} (comm_group.{0} environment.implicit_infer_kind)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_96916 (h0 : topological_space (has_compl (has_compl to_additive.value_type))) : t0_space (has_compl (has_compl to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_96917 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @normal_space.{1} (semigroup.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 topological_space.{1}) (semigroup.{1} Type))  := sorry --non-trivial
lemma new_lemma_96918 (h0 : functor.add_const (ordered_add_comm_monoid (has_neg Type)) pos) : @archimedean.{1} (has_neg.{1} Type) (@functor.add_const.run.{1 0} (ordered_add_comm_monoid.{1} (has_neg.{1} Type)) pos h0)  := sorry --non-trivial
lemma new_lemma_96919 (h0 : topological_space (has_pos_part pos)) : preconnected_space (has_pos_part pos) := sorry --non-trivial
lemma new_lemma_96920 (h0 : topological_space (ordered_ring congr_arg_kind)) : locally_compact_space (ordered_ring congr_arg_kind) := sorry --non-trivial
lemma new_lemma_96921 (h0 : measurable_space linarith.comp_source) (h1 : has_mul linarith.comp_source) (h2 : measure_theory.measure linarith.comp_source) : measure_theory.measure.is_mul_right_invariant h2 := sorry --non-trivial
lemma new_lemma_96922 (h0 : topological_space (normed_group (random_gen (random_gen string_imp)))) : locally_compact_space (normed_group (random_gen (random_gen string_imp))) := sorry --non-trivial
lemma new_lemma_96923 (h0 : list (measurable_space.dynkin_system congr_arg_kind)) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_96924 (h0 : function.extfun Type list) : list.nodup (function.extfun_app h0 (normed_group linarith.ineq)) := sorry --non-trivial
lemma new_lemma_96925 (h0 : measurable_space (nondiscrete_normed_field (mul_one_class linarith.ineq))) (h1 : measure_theory.measure (nondiscrete_normed_field (mul_one_class linarith.ineq))) : measure_theory.is_finite_measure h1 := sorry --non-trivial
lemma new_lemma_96926 (h0 : functor.add_const (function.extfun Type ring) pos) : @is_domain.{0} (normed_comm_ring.{0} pos) (@function.extfun_app.{2 1} Type ring.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type ring.{0}) pos h0) (normed_comm_ring.{0} pos))  := sorry --non-trivial
lemma new_lemma_96927 (h0 : prod (normed_linear_ordered_group unsigned) (normed_linear_ordered_group unsigned)) : set.diagonal (normed_linear_ordered_group unsigned) h0 := sorry --non-trivial
lemma new_lemma_96928 (h1 : topological_space (metric_space to_additive.value_type)) : t0_space (metric_space to_additive.value_type) := sorry --non-trivial
lemma new_lemma_96929 (h0 : functor.add_const (group (complete_distrib_lattice linarith.comp)) Type) : @group.fg.{0} (complete_distrib_lattice.{0} linarith.comp) (@functor.add_const.run.{0 1} (group.{0} (complete_distrib_lattice.{0} linarith.comp)) Type h0)  := sorry --non-trivial
lemma new_lemma_96930 (h0 : topological_space (simple_graph linarith.comp)) : loc_path_connected_space (simple_graph linarith.comp) := sorry --non-trivial
lemma new_lemma_96931 (h0 : ring (dlist (random_gen char))) : rank_condition (dlist (random_gen char)) := sorry --non-trivial
lemma new_lemma_96932 (h0 : not (topological_space (non_assoc_semiring congr_arg_kind) -> false)) : @topological_space.separable_space.{0} (non_assoc_semiring.{0} congr_arg_kind) (@classical.by_contradiction'.{1} (topological_space.{0} (non_assoc_semiring.{0} congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_96933 (h0 : topological_space (id congr_arg_kind)) : discrete_topology (id congr_arg_kind) := sorry --non-trivial
lemma new_lemma_96934 (h0 : filter (has_nnnorm (random_gen (linear_ordered_semiring (random_gen linarith.ineq))))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_96935 (h0 : function.extfun Type (functor.add_const Prop)) : functor.add_const.run (function.extfun_app h0 (semiring congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_96936 (h0 : add_group (nondiscrete_normed_field (normed_field (mul_one_class string.iterator_imp)))) : is_add_cyclic (nondiscrete_normed_field (normed_field (mul_one_class string.iterator_imp))) := sorry --non-trivial
lemma new_lemma_96937 (h0 : complete_lattice (add_comm_monoid linarith.comp)) : is_atomistic (add_comm_monoid linarith.comp) := sorry --non-trivial
lemma new_lemma_96938 (h0 : functor.add_const (add_monoid (left_cancel_monoid unsigned)) unsigned) (h1 : left_cancel_monoid unsigned) : @is_add_unit.{0} (left_cancel_monoid.{0} unsigned) (@functor.add_const.run.{0 0} (add_monoid.{0} (left_cancel_monoid.{0} unsigned)) unsigned h0) h1  := sorry --non-trivial
lemma new_lemma_96939 (h0 : complete_lattice (partial_order congr_arg_kind)) : complete_lattice.is_Sup_finite_compact (partial_order congr_arg_kind) := sorry --non-trivial
lemma new_lemma_96940 (h0 : group (add_comm_monoid ennreal)) : group.fg (add_comm_monoid ennreal) := sorry --non-trivial
lemma new_lemma_96941 (h0 : ring (ordered_comm_monoid (ring (ring linarith.comp)))) : rank_condition (ordered_comm_monoid (ring (ring linarith.comp))) := sorry --non-trivial
lemma new_lemma_96942 (h0 : finset (has_nndist (ordered_comm_ring (ring Type)))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_96943 (h0 : complete_lattice (semiring (has_norm (has_norm (semiring congr_arg_kind))))) : is_compactly_generated (semiring (has_norm (has_norm (semiring congr_arg_kind)))) := sorry --non-trivial
lemma new_lemma_96944 (h1 h2 : multiset (non_unital_non_assoc_semiring string_imp)) : multiset.disjoint h1 h2 := sorry --non-trivial
lemma new_lemma_96945 (h0 : ring (normed_group (has_nnnorm to_additive.value_type))) : rank_condition (normed_group (has_nnnorm to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_96946 (h0 : topological_space (has_Inf (has_zero linarith.comp))) : sequential_space (has_Inf (has_zero linarith.comp)) := sorry --non-trivial
lemma new_lemma_96947 (h0 : topological_space (measurable_space (semiring empty))) : preirreducible_space (measurable_space (semiring empty)) := sorry --non-trivial
lemma new_lemma_96948 (h0 : functor.add_const (ring (has_Inf Type)) name) : @is_principal_ideal_ring.{1} (has_Inf.{1} Type) (@functor.add_const.run.{1 0} (ring.{1} (has_Inf.{1} Type)) name h0)  := sorry --non-trivial
lemma new_lemma_96949 (h0 : functor.add_const (filter (has_Inf linarith.comp)) Type) : filter.ne_bot (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_96950 (h0 : topological_space (has_pos_part (finset (finset (has_add (has_add linarith.comp)))))) : regular_space (has_pos_part (finset (finset (has_add (has_add linarith.comp))))) := sorry --non-trivial
lemma new_lemma_96951 (h0 : functor.add_const (add_group (has_nndist pos)) pos) : @is_add_cyclic.{0} (has_nndist.{0} pos) (@functor.add_const.run.{0 0} (add_group.{0} (has_nndist.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_96952 (h0 : function.extfun Type ordered_add_comm_monoid) : @archimedean.{0} (linear_ordered_cancel_comm_monoid.{0} unsigned) (@function.extfun_app.{2 1} Type ordered_add_comm_monoid.{0} h0 (linear_ordered_cancel_comm_monoid.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_96953 (h0 : complete_lattice Type) : complete_lattice.is_Sup_finite_compact Type := sorry --non-trivial
lemma new_lemma_96954 (h0 : Prop) (h1 : znum -> znum -> znum) : id (yyy_to h0 (is_idempotent znum h1)) := sorry --non-trivial
lemma new_lemma_96955 (h0 : functor.add_const (group (normed_comm_ring unsigned)) (has_neg pos)) : @is_simple_group.{0} (normed_comm_ring.{0} unsigned) (@functor.add_const.run.{0 0} (group.{0} (normed_comm_ring.{0} unsigned)) (has_neg.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_96956 (h0 : fin has_zero.zero) : @t0_space.{1} (normed_lattice_add_comm_group.{1} Type) (@matrix.vec_empty.{1} (topological_space.{1} (normed_lattice_add_comm_group.{1} Type)) (@matrix.vec_empty.{0} (fin (@has_zero.zero.{0} nat nat.has_zero)) h0))  := sorry --non-trivial
lemma new_lemma_96957 (h0 : ring (add_left_cancel_monoid (with_zero (random_gen linarith.ineq)))) : strong_rank_condition (add_left_cancel_monoid (with_zero (random_gen linarith.ineq))) := sorry --non-trivial
lemma new_lemma_96958 (h0 : topological_space (has_add (has_add (has_Inf (has_Inf Type))))) : locally_compact_space (has_add (has_add (has_Inf (has_Inf Type)))) := sorry --non-trivial
lemma new_lemma_96959 (h0 : topological_space (has_add (normed_comm_ring Type))) : regular_space (has_add (normed_comm_ring Type)) := sorry --non-trivial
lemma new_lemma_96960 (h0 : ordered_comm_monoid (ring (has_nndist (has_add (has_nndist (has_Inf linarith.comp)))))) : has_exists_mul_of_le (ring (has_nndist (has_add (has_nndist (has_Inf linarith.comp))))) := sorry --non-trivial
lemma new_lemma_96961 (h1 h2 : multiset (has_nnnorm ereal)) : multiset.subset h1 h2 := sorry --non-trivial
lemma new_lemma_96962 (h0 : topological_space (add_group (semiring empty))) : totally_disconnected_space (add_group (semiring empty)) := sorry --non-trivial
lemma new_lemma_96963 (h0 : functor.add_const (topological_space (has_Sup unsigned)) unsigned) : @normal_space.{0} (has_Sup.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (has_Sup.{0} unsigned)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_96964 (h0 : ordered_comm_monoid (has_pos_part (has_pos_part Type))) : has_exists_mul_of_le (has_pos_part (has_pos_part Type)) := sorry --non-trivial
lemma new_lemma_96965 (h0 : functor.add_const (list (ordered_comm_ring pos)) (has_neg Type)) : list.nodup (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_96966 (h0 : function.extfun Type topological_space) : @totally_disconnected_space.{0} (pseudo_metric_space.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (pseudo_metric_space.{0} pos))  := sorry --non-trivial
lemma new_lemma_96967 (h0 : functor.add_const (filter (semigroup pos)) Type) : filter.ne_bot (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_96968 (h0 : not (has_mem.mem (has_top congr_arg_kind) has_emptyc.emptyc -> false)) : @rank_condition.{0} (has_top.{0} congr_arg_kind) (@finset.pi.empty.{1 0} Type ring.{0} (has_top.{0} congr_arg_kind) (@classical.by_contradiction'.{0} (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (has_top.{0} congr_arg_kind) (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))) h0))  := sorry --non-trivial
lemma new_lemma_96969 (h0 : semiring (canonically_ordered_comm_semiring (option unsigned))) : is_noetherian_ring (canonically_ordered_comm_semiring (option unsigned)) := sorry --non-trivial
lemma new_lemma_96970 (h0 : function.extfun Type topological_space) : @totally_disconnected_space.{0} (filter.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (filter.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_96971 (h0 : not (function.extfun Type topological_space -> false)) : @topological_space.separable_space.{0} (random_gen.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (random_gen.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_96972 (h0 : uniform_space (add_group empty)) : complete_space (add_group empty) := sorry --non-trivial
lemma new_lemma_96973 (h0 : semiring (add_comm_semigroup fun_info)) (h1 : ideal (add_comm_semigroup fun_info)) : ideal.is_prime h1 := sorry --non-trivial
lemma new_lemma_96974 (h0 : not (complete_lattice (random_gen num) -> false)) : @is_atomistic.{0} (random_gen.{0} num) (@classical.by_contradiction'.{1} (complete_lattice.{0} (random_gen.{0} num)) h0)  := sorry --non-trivial
lemma new_lemma_96975 (h0 : not (function.extfun Type topological_space -> false)) : @totally_separated_space.{0} (option.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (option.{0} num))  := sorry --non-trivial
lemma new_lemma_96976 (h0 : topological_space (has_add linarith.comp)) : totally_disconnected_space (has_add linarith.comp) := sorry --non-trivial
lemma new_lemma_96977 (h0 : add_monoid (ordered_comm_monoid (has_add pos))) : add_monoid.fg (ordered_comm_monoid (has_add pos)) := sorry --non-trivial
lemma new_lemma_96978 (h0 : ring (uniform_space (random_gen (random_gen (random_gen char))))) : strong_rank_condition (uniform_space (random_gen (random_gen (random_gen char)))) := sorry --non-trivial
lemma new_lemma_96979 (h0 : ring (measurable_space (has_norm (has_norm (has_norm num))))) : is_domain (measurable_space (has_norm (has_norm (has_norm num)))) := sorry --non-trivial
lemma new_lemma_96980 (h0 : function.extfun Type topological_space) : @preirreducible_space.{0} (emetric_space.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (emetric_space.{0} empty))  := sorry --non-trivial
lemma new_lemma_96981 (h0 : function.extfun Type topological_space) : @path_connected_space.{0} (ordered_ring.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (ordered_ring.{0} pos))  := sorry --non-trivial
lemma new_lemma_96982 (h0 : function.extfun (finset Type) (has_mem.mem (semiring num))) : @strong_rank_condition.{0} (semiring.{0} num) (@finset.pi.empty.{1 0} Type ring.{0} (semiring.{0} num) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (semiring.{0} num)) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_96983 (h0 : functor.add_const (add_monoid (comm_group Type)) pos) : @add_monoid.fg.{1} (comm_group.{1} Type) (@functor.add_const.run.{1 0} (add_monoid.{1} (comm_group.{1} Type)) pos h0)  := sorry --non-trivial
lemma new_lemma_96984 (h0 : functor.add_const (topological_space (canonically_ordered_comm_semiring Type)) Type) : @topological_space.separable_space.{1} (canonically_ordered_comm_semiring.{1} Type) (@functor.add_const.run.{1 1} (topological_space.{1} (canonically_ordered_comm_semiring.{1} Type)) Type h0)  := sorry --non-trivial
lemma new_lemma_96985 (h0 : function.extfun Type complete_lattice) : @is_atomistic.{0} (ordered_cancel_add_comm_monoid.{0} num) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (ordered_cancel_add_comm_monoid.{0} num))  := sorry --non-trivial
lemma new_lemma_96986 (h1 : topological_space (semiring (has_top (semiring to_additive.value_type)))) : totally_separated_space (semiring (has_top (semiring to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_96987 (h2 : has_mem.mem complete_lattice has_emptyc.emptyc) : @is_atomistic.{0} linarith.comp (@function.extfun_app.{2 1} Type complete_lattice.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) complete_lattice.{0} h2) linarith.comp)  := sorry --non-trivial
lemma new_lemma_96988 (h0 : topological_space (add_cancel_monoid (ordered_ring linarith.comp))) : topological_space.separable_space (add_cancel_monoid (ordered_ring linarith.comp)) := sorry --non-trivial
lemma new_lemma_96989 (h0 : function.extfun Type complete_lattice) : @is_compactly_generated.{0} (mul_zero_class.{0} pos) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (mul_zero_class.{0} pos))  := sorry --non-trivial
lemma new_lemma_96990 (h0 : not (function.extfun Type topological_space -> false)) : @t0_space.{0} (dlist.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (dlist.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_96991 (h0 : function.extfun Type group) : @normalizer_condition.{0} (canonically_linear_ordered_monoid.{0} pos) (@function.extfun_app.{2 1} Type group.{0} h0 (canonically_linear_ordered_monoid.{0} pos))  := sorry --non-trivial
lemma new_lemma_96992 (h0 : ring (comm_group (has_add name))) : is_domain (comm_group (has_add name)) := sorry --non-trivial
lemma new_lemma_96993 (h0 : topological_space (has_nndist (has_add unsigned))) : t0_space (has_nndist (has_add unsigned)) := sorry --non-trivial
lemma new_lemma_96994 (h1 : uniform_space (non_unital_non_assoc_semiring (semi_normed_ring linarith.ineq))) : complete_space (non_unital_non_assoc_semiring (semi_normed_ring linarith.ineq)) := sorry --non-trivial
lemma new_lemma_96995 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @path_connected_space.{0} (generalized_boolean_algebra.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (generalized_boolean_algebra.{0} pos))  := sorry --non-trivial
lemma new_lemma_96996 (h0 : topological_space (measurable_space to_additive.value_type)) : discrete_topology (measurable_space to_additive.value_type) := sorry --non-trivial
lemma new_lemma_96997 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @rank_condition.{0} (has_inv.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (has_inv.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_96998 (h0 : function.extfun Type topological_space) : @totally_separated_space.{0} (canonically_ordered_monoid.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (canonically_ordered_monoid.{0} name))  := sorry --non-trivial
lemma new_lemma_96999 (h0 : function.extfun Type uniform_space) : @complete_space.{0} fun_info (@function.extfun_app.{2 1} Type uniform_space.{0} h0 fun_info)  := sorry --non-trivial
lemma new_lemma_97000 (h0 : topological_space (add_comm_monoid (has_neg linarith.comp))) : t1_space (add_comm_monoid (has_neg linarith.comp)) := sorry --non-trivial
lemma new_lemma_97001 (h1 : function.extfun (Type -> Type) (function.extfun Type)) : @totally_disconnected_space.{0} (comm_ring.{0} string_imp) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h1 topological_space.{0}) (comm_ring.{0} string_imp))  := sorry --non-trivial
lemma new_lemma_97002 (h0 : not (topological_space (normed_group num) -> false)) : @t0_space.{0} (normed_group.{0} num) (@classical.by_contradiction'.{1} (topological_space.{0} (normed_group.{0} num)) h0)  := sorry --non-trivial
lemma new_lemma_97003 (h0 : topological_space (has_sub (semiring unsigned))) : totally_separated_space (has_sub (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_97004 (h0 : function.extfun nat fin) : @is_compactly_generated.{0} (normed_lattice_add_comm_group.{0} name) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@matrix.vec_empty.{1} (function.extfun.{2 1} Type complete_lattice.{0}) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero))) (normed_lattice_add_comm_group.{0} name))  := sorry --non-trivial
lemma new_lemma_97005 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_compactly_generated.{0} (canonically_linear_ordered_monoid.{0} linarith.comp) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (canonically_linear_ordered_monoid.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_97006 (h0 : not (topological_space empty -> false)) : topological_space.separable_space empty := sorry --non-trivial
lemma new_lemma_97007 (h0 : topological_space (canonically_ordered_comm_semiring (has_nndist ennreal))) : normal_space (canonically_ordered_comm_semiring (has_nndist ennreal)) := sorry --non-trivial
lemma new_lemma_97008 (h0 : ring (dlist (has_ssubset (random_gen to_additive.value_type)))) : is_domain (dlist (has_ssubset (random_gen to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_97009 (h0 : cancel_comm_monoid_with_zero (normed_comm_ring linarith.comp)) : unique_factorization_monoid (normed_comm_ring linarith.comp) := sorry --non-trivial
lemma new_lemma_97010 (h0 : functor.add_const (group (has_nndist name)) pos) : @group.fg.{0} (has_nndist.{0} name) (@functor.add_const.run.{0 0} (group.{0} (has_nndist.{0} name)) pos h0)  := sorry --non-trivial
lemma new_lemma_97011 (h0 : not (topological_space (normed_lattice_add_comm_group char) -> false)) : @totally_disconnected_space.{0} (normed_lattice_add_comm_group.{0} char) (@classical.by_contradiction'.{1} (topological_space.{0} (normed_lattice_add_comm_group.{0} char)) h0)  := sorry --non-trivial
lemma new_lemma_97012 (h0 : group (semiring (semiring (add_group (semiring (has_norm (has_norm empty))))))) : group.fg (semiring (semiring (add_group (semiring (has_norm (has_norm empty)))))) := sorry --non-trivial
lemma new_lemma_97013 (h0 : functor.add_const (functor.comp complete_lattice mul_zero_class ennreal) (finset environment.implicit_infer_kind)) : @complete_lattice.is_Sup_finite_compact.{0} (mul_zero_class.{0} ennreal) (@functor.add_const.run.{0 1} (complete_lattice.{0} (mul_zero_class.{0} ennreal)) Type (@functor.comp.run.{0 0 0} complete_lattice.{0} mul_zero_class.{0} ennreal (@functor.add_const.run.{0 0} (functor.comp.{0 0 0} complete_lattice.{0} mul_zero_class.{0} ennreal) (finset.{0} environment.implicit_infer_kind) h0)))  := sorry --non-trivial
lemma new_lemma_97014 (h0 : ring (has_norm (random_gen congr_arg_kind))) : rank_condition (has_norm (random_gen congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_97015 (h0 : topological_space (has_zero (ring Type))) : loc_path_connected_space (has_zero (ring Type)) := sorry --non-trivial
lemma new_lemma_97016 (h0 : ring (cancel_monoid (has_to_string (cancel_monoid Type)))) : is_principal_ideal_ring (cancel_monoid (has_to_string (cancel_monoid Type))) := sorry --non-trivial
lemma new_lemma_97017 (h1 : topological_space (has_norm congr_arg_kind)) : t0_space (has_norm congr_arg_kind) := sorry --non-trivial
lemma new_lemma_97018 (h0 : topological_space (has_neg (option (option (option (option ennreal)))))) : path_connected_space (has_neg (option (option (option (option ennreal))))) := sorry --non-trivial
lemma new_lemma_97019 (h0 : has_mem.mem monoid has_emptyc.emptyc) : @monoid.fg.{0} (with_bot.{0} fun_info) (@function.extfun_app.{2 1} Type monoid.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) monoid.{0} h0) (with_bot.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_97020 (h0 : comm_semiring linarith.ineq) (h1 : linarith.ineq) : is_coprime h1 linarith.ineq.lt := sorry --non-trivial
lemma new_lemma_97021 (h0 : uniform_space (comm_semigroup (comm_semigroup (comm_semigroup real)))) : separated_space (comm_semigroup (comm_semigroup (comm_semigroup real))) := sorry --non-trivial
lemma new_lemma_97022 (h0 : function.extfun Type finset) : finset.nonempty (function.extfun_app h0 (pseudo_metric_space ennreal)) := sorry --non-trivial
lemma new_lemma_97023 (h0 : function.extfun Type (functor.comp group comm_group)) : @is_simple_group.{0} (comm_group.{0} name) (@functor.comp.run.{0 0 0} group.{0} comm_group.{0} name (@function.extfun_app.{2 1} Type (functor.comp.{0 0 0} group.{0} comm_group.{0}) h0 name))  := sorry --non-trivial
lemma new_lemma_97024 (h0 : functor.add_const (topological_space (free_add_monoid empty)) empty) : @t1_space.{0} (free_add_monoid.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (free_add_monoid.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_97025 (h0 : functor.add_const (uniform_space (complete_distrib_lattice name)) name) : @complete_space.{0} (complete_distrib_lattice.{0} name) (@functor.add_const.run.{0 0} (uniform_space.{0} (complete_distrib_lattice.{0} name)) name h0)  := sorry --non-trivial
lemma new_lemma_97026 (h0 : functor.add_const (monoid (canonically_ordered_comm_semiring Type)) (finset Type)) : @monoid.fg.{1} (canonically_ordered_comm_semiring.{1} Type) (@functor.add_const.run.{1 1} (monoid.{1} (canonically_ordered_comm_semiring.{1} Type)) (finset.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_97027 (h0 : functor.add_const (group (has_neg environment.implicit_infer_kind)) Type) : @normalizer_condition.{0} (has_neg.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 1} (group.{0} (has_neg.{0} environment.implicit_infer_kind)) Type h0)  := sorry --non-trivial
lemma new_lemma_97028 (h0 : topological_space (ring (has_to_string (has_zero linarith.comp)))) : t1_space (ring (has_to_string (has_zero linarith.comp))) := sorry --non-trivial
lemma new_lemma_97029 (h0 : functor.add_const (topological_space (boolean_algebra.core name)) (option pos)) : @t1_space.{0} (boolean_algebra.core.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (boolean_algebra.core.{0} name)) (option.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_97030 (h0 : group (has_top (has_top (has_top (has_top (has_top to_additive.value_type)))))) : is_cyclic (has_top (has_top (has_top (has_top (has_top to_additive.value_type))))) := sorry --non-trivial
lemma new_lemma_97031 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @monoid.fg.{0} (has_inter.{0} unsigned) (@function.extfun_app.{2 1} Type monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 monoid.{0}) (has_inter.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_97032 (h0 : ring (semigroup (has_nndist linarith.comp))) : is_domain (semigroup (has_nndist linarith.comp)) := sorry --non-trivial
lemma new_lemma_97033 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @complete_lattice.is_Sup_finite_compact.{0} (has_top.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (has_top.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_97034 (h0 : prod (has_edist empty) (has_edist empty)) : id_rel h0 := sorry --non-trivial
lemma new_lemma_97035 (h0 : ordered_add_comm_monoid (left_cancel_semigroup congr_arg_kind)) : archimedean (left_cancel_semigroup congr_arg_kind) := sorry --non-trivial
lemma new_lemma_97036 (h0 : function.extfun Type complete_lattice) : is_atomistic (filter unsigned) := sorry --non-trivial
lemma new_lemma_97037 (h0 : function.extfun Type topological_space) : @irreducible_space.{0} (free_add_monoid.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (free_add_monoid.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_97038 (h0 : functor.add_const (ordered_add_comm_monoid (boolean_algebra Type)) name) : @archimedean.{1} (boolean_algebra.{1} Type) (@functor.add_const.run.{1 0} (ordered_add_comm_monoid.{1} (boolean_algebra.{1} Type)) name h0)  := sorry --non-trivial
lemma new_lemma_97039 (h0 : ordered_add_comm_monoid (partial_order empty)) : archimedean (partial_order empty) := sorry --non-trivial
lemma new_lemma_97040 (h0 : functor.add_const (group (has_to_string pos)) name) : @group.fg.{0} (has_to_string.{0} pos) (@functor.add_const.run.{0 0} (group.{0} (has_to_string.{0} pos)) name h0)  := sorry --non-trivial
lemma new_lemma_97041 (h0 : list (add_cancel_monoid (cancel_monoid (has_neg_part (semigroup (mul_zero_class Type)))))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_97042 (h0 : function.extfun Type topological_space) : @totally_disconnected_space.{0} (finset.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (finset.{0} name))  := sorry --non-trivial
lemma new_lemma_97043 (h0 : functor.add_const (list pos) pos) : palindrome (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_97044 (h0 : has_neg (linear_ordered_comm_group_with_zero (mul_one_class std_gen))) (h1 : measurable_space (linear_ordered_comm_group_with_zero (mul_one_class std_gen))) : has_measurable_neg (linear_ordered_comm_group_with_zero (mul_one_class std_gen)) := sorry --non-trivial
lemma new_lemma_97045 (h0 : complete_lattice (normed_field (mul_one_class char))) : complete_lattice.is_Sup_finite_compact (normed_field (mul_one_class char)) := sorry --non-trivial
lemma new_lemma_97046 (h0 : functor.add_const (topological_space (normed_linear_ordered_group unsigned)) unsigned) : @irreducible_space.{0} (normed_linear_ordered_group.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (normed_linear_ordered_group.{0} unsigned)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_97047 (h0 : complete_lattice (has_nnnorm ereal)) : is_atomistic (has_nnnorm ereal) := sorry --non-trivial
lemma new_lemma_97048 (h0 : list (mul_zero_class (finset unsigned))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_97049 (h0 : uniform_space (topological_space stieltjes_function)) : complete_space (topological_space stieltjes_function) := sorry --non-trivial
lemma new_lemma_97050 (h0 : not (monoid (mul_zero_class congr_arg_kind) -> false)) : @monoid.fg.{0} (mul_zero_class.{0} congr_arg_kind) (@classical.by_contradiction'.{1} (monoid.{0} (mul_zero_class.{0} congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_97051 (h1 : ring (normed_group (random_gen (has_top linarith.ineq)))) : is_domain (normed_group (random_gen (has_top linarith.ineq))) := sorry --non-trivial
lemma new_lemma_97052 (h0 : functor.add_const (topological_space (add_cancel_monoid name)) pos) : @path_connected_space.{0} (add_cancel_monoid.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (add_cancel_monoid.{0} name)) pos h0)  := sorry --non-trivial
lemma new_lemma_97053 (h0 : ring (has_to_string (option (option ennreal)))) : rank_condition (has_to_string (option (option ennreal))) := sorry --non-trivial
lemma new_lemma_97054 (h0 : group (boolean_algebra.core (has_add Type))) : is_simple_group (boolean_algebra.core (has_add Type)) := sorry --non-trivial
lemma new_lemma_97055 (h0 : ordered_add_comm_monoid (bin_tree num)) : archimedean (bin_tree num) := sorry --non-trivial
lemma new_lemma_97056 (h0 : function.extfun Type group) : @is_cyclic.{0} (generalized_boolean_algebra.{0} pos) (@function.extfun_app.{2 1} Type group.{0} h0 (generalized_boolean_algebra.{0} pos))  := sorry --non-trivial
lemma new_lemma_97057 (h0 : ring (boolean_algebra (ring name))) : rank_condition (boolean_algebra (ring name)) := sorry --non-trivial
lemma new_lemma_97058 (h0 : not (topological_space (partial_order empty) -> false)) : @topological_space.separable_space.{0} (partial_order.{0} empty) (@classical.by_contradiction'.{1} (topological_space.{0} (partial_order.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_97059 (h0 : ordered_add_comm_monoid (left_cancel_monoid unsigned)) : archimedean (left_cancel_monoid unsigned) := sorry --non-trivial
lemma new_lemma_97060 (h0 : group (comm_monoid (semiring (semiring empty)))) : is_cyclic (comm_monoid (semiring (semiring empty))) := sorry --non-trivial
lemma new_lemma_97061 (h0 : list (canonically_linear_ordered_monoid (option (has_to_string pos)))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_97062 (h0 : topological_space (mul_zero_class (mul_zero_class pos))) : regular_space (mul_zero_class (mul_zero_class pos)) := sorry --non-trivial
lemma new_lemma_97063 (h0 : function.extfun Type cancel_comm_monoid_with_zero) : @unique_factorization_monoid.{0} (is_R_or_C.{0} empty) (@function.extfun_app.{2 1} Type cancel_comm_monoid_with_zero.{0} h0 (is_R_or_C.{0} empty))  := sorry --non-trivial
lemma new_lemma_97064 (h0 : group (ordered_cancel_add_comm_monoid ennreal)) : normalizer_condition (ordered_cancel_add_comm_monoid ennreal) := sorry --non-trivial
lemma new_lemma_97065 (h0 : group (add_comm_monoid (finset (finset environment.implicit_infer_kind)))) : group.fg (add_comm_monoid (finset (finset environment.implicit_infer_kind))) := sorry --non-trivial
lemma new_lemma_97066 (h1 : topological_space (has_emptyc (measurable_space linarith.ineq))) : irreducible_space (has_emptyc (measurable_space linarith.ineq)) := sorry --non-trivial
lemma new_lemma_97067 (h2 : ring (fintype linarith.ineq)) : strong_rank_condition (fintype linarith.ineq) := sorry --non-trivial
lemma new_lemma_97068 (h0 : ring (has_top (has_top string_imp))) : is_domain (has_top (has_top string_imp)) := sorry --non-trivial
lemma new_lemma_97069 (h3 : ring (semi_normed_comm_ring reducibility_hints)) : is_domain (semi_normed_comm_ring reducibility_hints) := sorry --non-trivial
lemma new_lemma_97070 (h0 : function.extfun Type filter) : filter.ne_bot (function.extfun_app h0 (semiring congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_97071 (h0 : function.extfun Type topological_space) : @t0_space.{0} (add_left_cancel_semigroup.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (add_left_cancel_semigroup.{0} empty))  := sorry --non-trivial
lemma new_lemma_97072 (h0 : topological_space (preorder Type)) : locally_compact_space (preorder Type) := sorry --non-trivial
lemma new_lemma_97073 (h0 : function.extfun Type topological_space) : @loc_path_connected_space.{0} (as_linear_order.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (as_linear_order.{0} num))  := sorry --non-trivial
lemma new_lemma_97074 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @normal_space.{0} (monoid.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (monoid.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_97075 (h0 : not (add_group (complete_linear_order congr_arg_kind) -> false)) : @is_add_cyclic.{0} (complete_linear_order.{0} congr_arg_kind) (@classical.by_contradiction'.{1} (add_group.{0} (complete_linear_order.{0} congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_97076 (h0 : ring (comm_ring (random_gen (random_gen linarith.ineq)))) : is_domain (comm_ring (random_gen (random_gen linarith.ineq))) := sorry --non-trivial
lemma new_lemma_97077 (h0 : functor.add_const (function.extfun Type topological_space) linarith.comp) : @t1_space.{0} (has_zero.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) linarith.comp h0) (has_zero.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_97078 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @complete_lattice.is_Sup_finite_compact.{0} (left_cancel_monoid.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (left_cancel_monoid.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_97079 (h0 : group (semigroup environment.implicit_infer_kind)) : normalizer_condition (semigroup environment.implicit_infer_kind) := sorry --non-trivial
lemma new_lemma_97080 (h0 : complete_lattice (has_nndist (option unsigned))) : is_compactly_generated (has_nndist (option unsigned)) := sorry --non-trivial
lemma new_lemma_97081 (h0 : ring (semiring (random_gen linarith.ineq))) : is_domain (semiring (random_gen linarith.ineq)) := sorry --non-trivial
lemma new_lemma_97082 (h0 : add_group (topological_space (random_gen (random_gen char)))) : is_add_cyclic (topological_space (random_gen (random_gen char))) := sorry --non-trivial
lemma new_lemma_97083 (h0 : group (has_zero (boolean_algebra.core unsigned))) : normalizer_condition (has_zero (boolean_algebra.core unsigned)) := sorry --non-trivial
lemma new_lemma_97084 (h0 : ring (normed_field std_gen)) : strong_rank_condition (normed_field std_gen) := sorry --non-trivial
lemma new_lemma_97085 (h0 : ring (ordered_ring (semiring congr_arg_kind))) : strong_rank_condition (ordered_ring (semiring congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_97086 (h0 : cancel_comm_monoid_with_zero (ordered_cancel_add_comm_monoid unsigned)) : unique_factorization_monoid (ordered_cancel_add_comm_monoid unsigned) := sorry --non-trivial
lemma new_lemma_97087 (h0 : functor.add_const (cancel_comm_monoid_with_zero (boolean_algebra.core name)) environment.implicit_infer_kind) : @unique_factorization_monoid.{0} (boolean_algebra.core.{0} name) (@functor.add_const.run.{0 0} (cancel_comm_monoid_with_zero.{0} (boolean_algebra.core.{0} name)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_97088 (h0 : not (ring (plift unsigned) -> false)) : @strong_rank_condition.{1} (plift.{1} unsigned) (@classical.by_contradiction'.{2} (ring.{1} (plift.{1} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_97089 (h0 : topological_space (option (semiring num))) : topological_space.separable_space (option (semiring num)) := sorry --non-trivial
lemma new_lemma_97090 (h0 : group (has_to_string (add_comm_monoid unsigned))) : is_simple_group (has_to_string (add_comm_monoid unsigned)) := sorry --non-trivial
lemma new_lemma_97091 (h0 : complete_lattice (comm_group name)) : is_compactly_generated (comm_group name) := sorry --non-trivial
lemma new_lemma_97092 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @t0_space.{0} (has_top.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_top.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_97093 (h0 : function.extfun Type topological_space) : @topological_space.separable_space.{0} (semiring.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (semiring.{0} num))  := sorry --non-trivial
lemma new_lemma_97094 (h0 : function.extfun (finset (Type -> Type)) (has_mem.mem complete_lattice)) : @is_atomistic.{0} (has_norm.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) complete_lattice.{0} (@function.extfun_app.{2 0} (finset.{1} (Type → Type)) (@has_mem.mem.{1 1} (Type → Type) (finset.{1} (Type → Type)) (@finset.has_mem.{1} (Type → Type)) complete_lattice.{0}) h0 (@has_emptyc.emptyc.{1} (finset.{1} (Type → Type)) (@finset.has_emptyc.{1} (Type → Type))))) (has_norm.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_97095 (h0 : topological_space (has_add (has_zero linarith.comp))) : topological_space.separable_space (has_add (has_zero linarith.comp)) := sorry --non-trivial
lemma new_lemma_97096 (h0 : topological_space (has_to_string (has_to_string (has_to_string pos)))) : regular_space (has_to_string (has_to_string (has_to_string pos))) := sorry --non-trivial
lemma new_lemma_97097 (h0 : functor.add_const (function.extfun Type group) Type) : @group.fg.{0} (has_Inf.{0} pos) (@function.extfun_app.{2 1} Type group.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type group.{0}) Type h0) (has_Inf.{0} pos))  := sorry --non-trivial
lemma new_lemma_97098 (h0 : add_group (linear_ordered_comm_group_with_zero (mul_one_class linarith.comp_source))) : is_add_cyclic (linear_ordered_comm_group_with_zero (mul_one_class linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_97099 (h0 : functor.add_const (topological_space (add_comm_monoid Type)) congr_arg_kind) : @totally_disconnected_space.{1} (add_comm_monoid.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (add_comm_monoid.{1} Type)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_97100 (h0 : complete_lattice (canonically_ordered_monoid (sub_neg_monoid real))) : complete_lattice.is_Sup_finite_compact (canonically_ordered_monoid (sub_neg_monoid real)) := sorry --non-trivial
lemma new_lemma_97101 (h0 : function.extfun (finset Type) (has_mem.mem (complete_semilattice_Sup unsigned))) : @monoid.fg.{0} (complete_semilattice_Sup.{0} unsigned) (@finset.pi.empty.{1 0} Type monoid.{0} (complete_semilattice_Sup.{0} unsigned) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (complete_semilattice_Sup.{0} unsigned)) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_97102 (h0 : topological_space (has_pos_part (ring (ring (has_add (has_nndist Type)))))) : irreducible_space (has_pos_part (ring (ring (has_add (has_nndist Type))))) := sorry --non-trivial
lemma new_lemma_97103 (h0 : ordered_comm_monoid (boolean_algebra (has_add (finset (finset (finset (finset pos))))))) : has_exists_mul_of_le (boolean_algebra (has_add (finset (finset (finset (finset pos)))))) := sorry --non-trivial
lemma new_lemma_97104 (h0 : not (uniform_space (bin_tree congr_arg_kind) -> false)) : @separated_space.{0} (bin_tree.{0} congr_arg_kind) (@classical.by_contradiction'.{1} (uniform_space.{0} (bin_tree.{0} congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_97105 (h0 : not (topological_space (add_left_cancel_monoid to_additive.value_type) -> false)) : @path_connected_space.{0} (add_left_cancel_monoid.{0} to_additive.value_type) (@classical.by_contradiction'.{1} (topological_space.{0} (add_left_cancel_monoid.{0} to_additive.value_type)) h0)  := sorry --non-trivial
lemma new_lemma_97106 (h0 : list (div_inv_monoid (random_gen (random_gen fun_info)))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_97107 (h0 : topological_space (has_union (semiring empty))) : normal_space (has_union (semiring empty)) := sorry --non-trivial
lemma new_lemma_97108 (h0 : function.extfun Type group) : @is_cyclic.{0} (complete_semilattice_Sup.{0} string_imp) (@function.extfun_app.{2 1} Type group.{0} h0 (complete_semilattice_Sup.{0} string_imp))  := sorry --non-trivial
lemma new_lemma_97109 (h0 : add_group (complete_linear_order (semiring empty))) : is_add_cyclic (complete_linear_order (semiring empty)) := sorry --non-trivial
lemma new_lemma_97110 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @t1_space.{0} (linear_ordered_field.{0} ennreal) (@functor.add_const.run.{0 0} (topological_space.{0} (linear_ordered_field.{0} ennreal)) num (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (topological_space.{0} (linear_ordered_field.{0} ennreal))) (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 (functor.add_const.{0 0} (topological_space.{0} (linear_ordered_field.{0} ennreal)))) num))  := sorry --non-trivial
lemma new_lemma_97111 (h0 : functor.add_const (function.extfun Type finset) pos) : finset.nonempty (function.extfun_app (functor.add_const.run h0) (finset pos)) := sorry --non-trivial
lemma new_lemma_97112 (h0 : ring (has_inter unsigned)) : is_principal_ideal_ring (has_inter unsigned) := sorry --non-trivial
lemma new_lemma_97113 (h0 : functor.add_const (function.extfun (Type 1) topological_space) linarith.comp) : @normal_space.{1} (ring.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) topological_space.{1}) linarith.comp h0) (ring.{1} Type))  := sorry --non-trivial
lemma new_lemma_97114 (h0 : functor.add_const (group (comm_group Type)) Type) : @group.fg.{1} (comm_group.{1} Type) (@functor.add_const.run.{1 1} (group.{1} (comm_group.{1} Type)) Type h0)  := sorry --non-trivial
lemma new_lemma_97115 (h0 : filter (has_pos_part (has_add pos))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_97116 (h0 : topological_space (simple_graph (has_add (finset Type)))) : preconnected_space (simple_graph (has_add (finset Type))) := sorry --non-trivial
lemma new_lemma_97117 (h0 : not (function.extfun Type uniform_space -> false)) : @complete_space.{0} (semi_normed_comm_ring.{0} reducibility_hints) (@function.extfun_app.{2 1} Type uniform_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type uniform_space.{0}) h0) (semi_normed_comm_ring.{0} reducibility_hints))  := sorry --non-trivial
lemma new_lemma_97118 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @t0_space.{0} (group_with_zero.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (group_with_zero.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_97119 (h0 : function.extfun Type ring) : @is_domain.{0} (cancel_monoid.{0} ennreal) (@function.extfun_app.{2 1} Type ring.{0} h0 (cancel_monoid.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_97120 (h0 : topological_space (has_norm unsigned)) : preirreducible_space (has_norm unsigned) := sorry --non-trivial
lemma new_lemma_97121 (h1 : topological_space (distrib (random_gen (random_gen string_imp)))) : path_connected_space (distrib (random_gen (random_gen string_imp))) := sorry --non-trivial
lemma new_lemma_97122 (h0 : ring (has_zero (finset Type))) : is_principal_ideal_ring (has_zero (finset Type)) := sorry --non-trivial
lemma new_lemma_97123 (h0 : ring (normed_field reducibility_hints)) : is_domain (normed_field reducibility_hints) := sorry --non-trivial
lemma new_lemma_97124 (h0 : topological_space (add_group unsigned)) : totally_disconnected_space (add_group unsigned) := sorry --non-trivial
lemma new_lemma_97125 (h0 : finset (has_add (finset (finset pos)))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_97126 (h0 : set (add_comm_semigroup std_gen -> string.iterator_imp)) : set.separates_points h0 := sorry --non-trivial
lemma new_lemma_97127 (h0 : functor.comp filter comm_group name) : filter.ne_bot (functor.comp.run h0) := sorry --non-trivial
lemma new_lemma_97128 (h0 : functor.add_const (topological_space (comm_group ennreal)) Type) : @discrete_topology.{0} (comm_group.{0} ennreal) (@functor.add_const.run.{0 1} (topological_space.{0} (comm_group.{0} ennreal)) Type h0)  := sorry --non-trivial
lemma new_lemma_97129 (h0 : filter (finset (has_Inf (finset (has_Inf (boolean_algebra (has_neg (finset pos)))))))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_97130 (h0 : has_mem.mem (with_one congr_arg_kind) has_emptyc.emptyc) : @is_cyclic.{0} (with_one.{0} congr_arg_kind) (@finset.pi.empty.{1 0} Type group.{0} (with_one.{0} congr_arg_kind) h0)  := sorry --non-trivial
lemma new_lemma_97131 (h0 : topological_space (left_cancel_semigroup (semiring (semiring (semiring congr_arg_kind))))) : locally_compact_space (left_cancel_semigroup (semiring (semiring (semiring congr_arg_kind)))) := sorry --non-trivial
lemma new_lemma_97132 (h0 : functor.add_const (add_group (add_right_cancel_monoid congr_arg_kind)) congr_arg_kind) : @is_add_cyclic.{0} (add_right_cancel_monoid.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (add_group.{0} (add_right_cancel_monoid.{0} congr_arg_kind)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_97133 (h0 : not (function.extfun Type complete_lattice -> false)) : @is_compactly_generated.{0} (has_norm.{0} fun_info) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type complete_lattice.{0}) h0) (has_norm.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_97134 (h0 : functor.add_const (topological_space (has_to_string pos)) name) : @totally_separated_space.{0} (has_to_string.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (has_to_string.{0} pos)) name h0)  := sorry --non-trivial
lemma new_lemma_97135 (h0 : complete_lattice (add_cancel_monoid (normed_comm_ring (has_neg linarith.comp)))) : is_compactly_generated (add_cancel_monoid (normed_comm_ring (has_neg linarith.comp))) := sorry --non-trivial
lemma new_lemma_97136 (h1 : uniform_space (add_left_cancel_monoid char)) : complete_space (add_left_cancel_monoid char) := sorry --non-trivial
lemma new_lemma_97137 (h0 : not (complete_lattice (partial_order congr_arg_kind) -> false)) : @is_atomistic.{0} (partial_order.{0} congr_arg_kind) (@classical.by_contradiction'.{1} (complete_lattice.{0} (partial_order.{0} congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_97138 (h0 : group (add_cancel_monoid (has_nndist environment.implicit_infer_kind))) : is_cyclic (add_cancel_monoid (has_nndist environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_97139 (h0 : not (topological_space (semiring congr_arg_kind) -> false)) : @totally_separated_space.{0} (semiring.{0} congr_arg_kind) (@classical.by_contradiction'.{1} (topological_space.{0} (semiring.{0} congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_97140 (h0 : uniform_space (id (random_gen (has_top to_additive.value_type)))) : complete_space (id (random_gen (has_top to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_97141 (h0 : ordered_comm_monoid (comm_semigroup (comm_semigroup (has_bot real)))) : has_exists_mul_of_le (comm_semigroup (comm_semigroup (has_bot real))) := sorry --non-trivial
lemma new_lemma_97142 (h0 : topological_space (has_nndist (boolean_algebra Type))) : locally_compact_space (has_nndist (boolean_algebra Type)) := sorry --non-trivial
lemma new_lemma_97143 (h0 : topological_space (has_union (semiring (semiring empty)))) : t0_space (has_union (semiring (semiring empty))) := sorry --non-trivial
lemma new_lemma_97144 (h0 : not (topological_space (random_gen congr_arg_kind) -> false)) : @totally_disconnected_space.{0} (random_gen.{0} congr_arg_kind) (@classical.by_contradiction'.{1} (topological_space.{0} (random_gen.{0} congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_97145 (h0 : function.extfun Type (functor.add_const (topological_space (left_cancel_monoid empty)))) : @t1_space.{0} (left_cancel_monoid.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (left_cancel_monoid.{0} empty)) num (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (topological_space.{0} (left_cancel_monoid.{0} empty))) h0 num))  := sorry --non-trivial
lemma new_lemma_97146 (h1 : topological_space (uniform_space to_additive.value_type)) : t0_space (uniform_space to_additive.value_type) := sorry --non-trivial
lemma new_lemma_97147 (h0 : function.extfun Type complete_lattice) : @complete_lattice.is_Sup_finite_compact.{0} (left_cancel_monoid.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (left_cancel_monoid.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_97148 (h3 : ring (has_append to_additive.value_type)) : strong_rank_condition (has_append to_additive.value_type) := sorry --non-trivial
lemma new_lemma_97149 (h0 : complete_lattice (has_neg (option pos))) : complete_lattice.is_Sup_finite_compact (has_neg (option pos)) := sorry --non-trivial
lemma new_lemma_97150 (h0 : function.extfun Type (functor.add_const (ring (left_cancel_monoid num)))) : @rank_condition.{0} (left_cancel_monoid.{0} num) (@functor.add_const.run.{0 0} (ring.{0} (left_cancel_monoid.{0} num)) congr_arg_kind (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (ring.{0} (left_cancel_monoid.{0} num))) h0 congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_97151 (h0 : complete_lattice (normed_lattice_add_comm_group (sub_neg_monoid (sub_neg_monoid real)))) : is_compactly_generated (normed_lattice_add_comm_group (sub_neg_monoid (sub_neg_monoid real))) := sorry --non-trivial
lemma new_lemma_97152 (h0 : not (function.extfun Type monoid -> false)) : @monoid.fg.{0} (has_emptyc.{0} num) (@function.extfun_app.{2 1} Type monoid.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type monoid.{0}) h0) (has_emptyc.{0} num))  := sorry --non-trivial
lemma new_lemma_97153 (h0 : topological_space (measurable_space.dynkin_system (semiring unsigned))) : discrete_topology (measurable_space.dynkin_system (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_97154 (h0 : function.extfun Type group) : @group.fg.{0} (partial_order.{0} empty) (@function.extfun_app.{2 1} Type group.{0} h0 (partial_order.{0} empty))  := sorry --non-trivial
lemma new_lemma_97155 (h0 : function.extfun Type semiring) : @is_noetherian_ring.{0} (add_right_cancel_monoid.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type semiring.{0} h0 (add_right_cancel_monoid.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_97156 (h0 : function.extfun Type (functor.comp ring ring)) : @rank_condition.{0} (ring.{0} pos) (@functor.comp.run.{0 0 0} ring.{0} ring.{0} pos (@function.extfun_app.{2 1} Type (functor.comp.{0 0 0} ring.{0} ring.{0}) h0 pos))  := sorry --non-trivial
lemma new_lemma_97157 (h0 : complete_lattice (linear_ordered_add_comm_group string_imp)) : is_compactly_generated (linear_ordered_add_comm_group string_imp) := sorry --non-trivial
lemma new_lemma_97158 (h0 : ring (complete_semilattice_Sup num)) : rank_condition (complete_semilattice_Sup num) := sorry --non-trivial
lemma new_lemma_97159 (h0 : functor.add_const (filter (has_zero unsigned)) name) : countable_Inter_filter (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_97160 (h0 : list (has_neg (has_neg (ring pos)))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_97161 (h0 : functor.add_const (ring (has_Sup congr_arg_kind)) num) : @is_principal_ideal_ring.{0} (has_Sup.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (ring.{0} (has_Sup.{0} congr_arg_kind)) num h0)  := sorry --non-trivial
lemma new_lemma_97162 (h0 : ordered_comm_monoid (complete_distrib_lattice (has_add linarith.comp))) : has_exists_mul_of_le (complete_distrib_lattice (has_add linarith.comp)) := sorry --non-trivial
lemma new_lemma_97163 (h1 : set (normed_field char)) : set.finite h1 := sorry --non-trivial
lemma new_lemma_97164 (h0 : functor.add_const (topological_space (semigroup name)) pos) : @discrete_topology.{0} (semigroup.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (semigroup.{0} name)) pos h0)  := sorry --non-trivial
lemma new_lemma_97165 (h0 : not (ring (normed_group (semiring (semiring (semiring (semiring empty))))) -> false)) : @rank_condition.{0} (normed_group.{0} (semiring.{0} (semiring.{0} (semiring.{0} (semiring.{0} empty))))) (@classical.by_contradiction'.{1} (ring.{0} (normed_group.{0} (semiring.{0} (semiring.{0} (semiring.{0} (semiring.{0} empty)))))) h0)  := sorry --non-trivial
lemma new_lemma_97166 (h0 : uniform_space (complete_distrib_lattice (preorder congr_arg_kind))) : separated_space (complete_distrib_lattice (preorder congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_97167 (h0 : uniform_space (with_zero (has_nnnorm to_additive.value_type))) : complete_space (with_zero (has_nnnorm to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_97168 (h0 : fin has_zero.zero) : is_noetherian_ring real := sorry --non-trivial
lemma new_lemma_97169 (h0 : complete_lattice (has_neg (option (has_neg (option (linear_ordered_field (option unsigned))))))) : is_atomistic (has_neg (option (has_neg (option (linear_ordered_field (option unsigned)))))) := sorry --non-trivial
lemma new_lemma_97170 (h0 : not (topological_space (semiring empty) -> false)) : @totally_disconnected_space.{0} (semiring.{0} empty) (@classical.by_contradiction'.{1} (topological_space.{0} (semiring.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_97171 (h0 : not (complete_lattice (with_bot num) -> false)) : @complete_lattice.is_Sup_finite_compact.{0} (with_bot.{0} num) (@classical.by_contradiction'.{1} (complete_lattice.{0} (with_bot.{0} num)) h0)  := sorry --non-trivial
lemma new_lemma_97172 (h0 : topological_space (with_one (has_nnnorm to_additive.value_type))) : t0_space (with_one (has_nnnorm to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_97173 (h0 : functor.add_const (complete_lattice (has_zero linarith.comp)) environment.implicit_infer_kind) : @is_compactly_generated.{0} (has_zero.{0} linarith.comp) (@functor.add_const.run.{0 0} (complete_lattice.{0} (has_zero.{0} linarith.comp)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_97174 (h0 : functor.add_const (ring (ordered_comm_monoid linarith.comp)) name) : @is_domain.{0} (ordered_comm_monoid.{0} linarith.comp) (@functor.add_const.run.{0 0} (ring.{0} (ordered_comm_monoid.{0} linarith.comp)) name h0)  := sorry --non-trivial
lemma new_lemma_97175 (h0 : function.extfun Type group) : @normalizer_condition.{0} (ordered_ring.{0} empty) (@function.extfun_app.{2 1} Type group.{0} h0 (ordered_ring.{0} empty))  := sorry --non-trivial
lemma new_lemma_97176 (h0 : topological_space (cancel_monoid (has_add environment.implicit_infer_kind))) : locally_compact_space (cancel_monoid (has_add environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_97177 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @has_exists_mul_of_le.{0} (has_add.{0} pos) (@function.extfun_app.{2 1} Type ordered_comm_monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ordered_comm_monoid.{0}) (has_add.{0} pos))  := sorry --non-trivial
lemma new_lemma_97178 (h0 : function.extfun Type ordered_add_comm_monoid) : @archimedean.{0} (semigroup.{0} pos) (@function.extfun_app.{2 1} Type ordered_add_comm_monoid.{0} h0 (semigroup.{0} pos))  := sorry --non-trivial
lemma new_lemma_97179 (h0 : ring (has_norm num)) : strong_rank_condition (has_norm num) := sorry --non-trivial
lemma new_lemma_97180 (h0 : function.extfun Type (functor.add_const (finset ennreal))) : finset.nonempty (functor.add_const.run (function.extfun_app h0 (option num))) := sorry --non-trivial
lemma new_lemma_97181 (h0 : ring (has_nndist (finset environment.implicit_infer_kind))) : rank_condition (has_nndist (finset environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_97182 (h0 : uniform_space (semiring (semiring (has_norm linarith.comp)))) : complete_space (semiring (semiring (has_norm linarith.comp))) := sorry --non-trivial
lemma new_lemma_97183 (h0 : has_mem.mem (id unsigned) has_emptyc.emptyc) : @locally_compact_space.{0} (@id.{2} Type unsigned) (@finset.pi.empty.{1 0} Type topological_space.{0} (@id.{2} Type unsigned) h0)  := sorry --non-trivial
lemma new_lemma_97184 (h0 : group (has_Inf (has_pos_part pos))) : normalizer_condition (has_Inf (has_pos_part pos)) := sorry --non-trivial
lemma new_lemma_97185 (h0 : topological_space (preorder num)) : loc_path_connected_space (preorder num) := sorry --non-trivial
lemma new_lemma_97186 (h0 : ring (topological_space (has_ssubset (has_ssubset (has_ssubset char))))) : is_domain (topological_space (has_ssubset (has_ssubset (has_ssubset char)))) := sorry --non-trivial
lemma new_lemma_97187 (h0 : functor.add_const (cancel_comm_monoid_with_zero (canonically_ordered_comm_semiring pos)) pos) : @unique_factorization_monoid.{0} (canonically_ordered_comm_semiring.{0} pos) (@functor.add_const.run.{0 0} (cancel_comm_monoid_with_zero.{0} (canonically_ordered_comm_semiring.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_97188 (h0 : ring (preorder environment.implicit_infer_kind)) (h1 : ring (subring (preorder environment.implicit_infer_kind))) : is_domain (subring (preorder environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_97189 (h0 : functor.add_const (topological_space (add_cancel_monoid Type)) Type) : @sequential_space.{1} (add_cancel_monoid.{1} Type) (@functor.add_const.run.{1 1} (topological_space.{1} (add_cancel_monoid.{1} Type)) Type h0)  := sorry --non-trivial
lemma new_lemma_97190 (h0 : not (function.extfun Type topological_space -> false)) : @irreducible_space.{0} (metric_space.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (metric_space.{0} num))  := sorry --non-trivial
lemma new_lemma_97191 (h2 : topological_space (add_left_cancel_monoid to_additive.value_type)) : t0_space (add_left_cancel_monoid to_additive.value_type) := sorry --non-trivial
lemma new_lemma_97192 (h0 : functor.add_const (list (boolean_algebra Type)) name) : list.nodup (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_97193 (h0 : uniform_space (omega_complete_partial_order congr_arg_kind)) : complete_space (omega_complete_partial_order congr_arg_kind) := sorry --non-trivial
lemma new_lemma_97194 (h0 : topological_space (boolean_algebra (has_Inf linarith.comp))) : locally_compact_space (boolean_algebra (has_Inf linarith.comp)) := sorry --non-trivial
lemma new_lemma_97195 (h1 : list (denumerable (random_gen string_imp))) : list.nodup h1 := sorry --non-trivial
lemma new_lemma_97196 (h0 : functor.add_const (topological_space (canonically_ordered_monoid linarith.comp)) linarith.comp) : @totally_disconnected_space.{0} (canonically_ordered_monoid.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (canonically_ordered_monoid.{0} linarith.comp)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_97197 (h0 : topological_space (complete_linear_order (semiring empty))) : totally_disconnected_space (complete_linear_order (semiring empty)) := sorry --non-trivial
lemma new_lemma_97198 (h0 : ring (boolean_algebra (has_to_string unsigned))) : is_domain (boolean_algebra (has_to_string unsigned)) := sorry --non-trivial
lemma new_lemma_97199 (h0 : group (linear_ordered_add_comm_group (has_inv linarith.ineq))) : is_cyclic (linear_ordered_add_comm_group (has_inv linarith.ineq)) := sorry --non-trivial
lemma new_lemma_97200 (h0 : topological_space (with_one (semiring (semiring unsigned)))) : preirreducible_space (with_one (semiring (semiring unsigned))) := sorry --non-trivial
lemma new_lemma_97201 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @normalizer_condition.{0} (option.{0} num) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (option.{0} num))  := sorry --non-trivial
lemma new_lemma_97202 (h1 : function.extfun Type group) : @normalizer_condition.{0} congr_arg_kind (@function.extfun_app.{2 1} Type group.{0} h1 congr_arg_kind)  := sorry --non-trivial
lemma new_lemma_97203 (h0 : functor.add_const (semiring (non_assoc_semiring num)) (semiring congr_arg_kind)) : @is_noetherian_ring.{0} (non_assoc_semiring.{0} num) (@functor.add_const.run.{0 0} (semiring.{0} (non_assoc_semiring.{0} num)) (semiring.{0} congr_arg_kind) h0)  := sorry --non-trivial
lemma new_lemma_97204 (h0 : topological_space (add_left_cancel_semigroup empty) -> Prop) (h1 : Exists (fun (x : topological_space (add_left_cancel_semigroup empty)), h0 x)) : @t1_space.{0} (add_left_cancel_semigroup.{0} empty) (@classical.some.{1} (topological_space.{0} (add_left_cancel_semigroup.{0} empty)) h0 h1)  := sorry --non-trivial
lemma new_lemma_97205 (h0 : ring (uniform_space (is_R_or_C string_imp))) : is_domain (uniform_space (is_R_or_C string_imp)) := sorry --non-trivial
lemma new_lemma_97206 (h0 : functor.comp topological_space ring unsigned) : @preirreducible_space.{0} (ring.{0} unsigned) (@functor.comp.run.{0 0 0} topological_space.{0} ring.{0} unsigned h0)  := sorry --non-trivial
lemma new_lemma_97207 (h0 : ring (has_lt fun_info)) : is_domain (has_lt fun_info) := sorry --non-trivial
lemma new_lemma_97208 (h0 : add_monoid (has_Inf (has_add (ordered_ring Type)))) : add_monoid.fg (has_Inf (has_add (ordered_ring Type))) := sorry --non-trivial
lemma new_lemma_97209 (h0 : topological_space (measurable_space linarith.comp_source)) : irreducible_space (measurable_space linarith.comp_source) := sorry --non-trivial
lemma new_lemma_97210 (h0 : set (uniform_space string.iterator_imp)) : set.subsingleton h0 := sorry --non-trivial
lemma new_lemma_97211 (h0 : has_neg (distrib linarith.ineq)) (h1 : measurable_space (distrib linarith.ineq)) : has_measurable_neg (distrib linarith.ineq) := sorry --non-trivial
lemma new_lemma_97212 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @normal_space.{0} (semigroup.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (semigroup.{0} name))  := sorry --non-trivial
lemma new_lemma_97213 (h0 : topological_space (plift (bin_tree congr_arg_kind))) : irreducible_space (plift (bin_tree congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_97214 (h1 : has_mem.mem (measurable_space linarith.comp) has_emptyc.emptyc) : @add_monoid.fg.{0} (measurable_space.{0} linarith.comp) (@finset.pi.empty.{1 0} Type add_monoid.{0} (measurable_space.{0} linarith.comp) h1)  := sorry --non-trivial
lemma new_lemma_97215 (h0 : has_mem.mem (has_norm linarith.comp_source) has_emptyc.emptyc) : @complete_space.{0} (has_norm.{0} linarith.comp_source) (@finset.pi.empty.{1 0} Type uniform_space.{0} (has_norm.{0} linarith.comp_source) h0)  := sorry --non-trivial
lemma new_lemma_97216 (h0 : functor.add_const (list (ring pos)) Type) : palindrome (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_97217 (h0 : ring (add_group (has_top (has_top unsigned)))) : rank_condition (add_group (has_top (has_top unsigned))) := sorry --non-trivial
lemma new_lemma_97218 (h0 : topological_space fun_info) : locally_compact_space fun_info := sorry --non-trivial
lemma new_lemma_97219 (h0 : not (monoid (linear_ordered_semiring empty) -> false)) : @monoid.fg.{0} (linear_ordered_semiring.{0} empty) (@classical.by_contradiction'.{1} (monoid.{0} (linear_ordered_semiring.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_97220 (h0 : topological_space (has_nndist (has_add name))) : irreducible_space (has_nndist (has_add name)) := sorry --non-trivial
lemma new_lemma_97221 (h0 : functor.add_const Prop (add_comm_monoid (option unsigned))) : functor.add_const.run h0 := sorry --non-trivial
lemma new_lemma_97222 (h0 : group (normed_lattice_add_comm_group (comm_semigroup pos))) : normalizer_condition (normed_lattice_add_comm_group (comm_semigroup pos)) := sorry --non-trivial
lemma new_lemma_97223 (h0 : ring (ordered_cancel_add_comm_monoid pos)) : is_principal_ideal_ring (ordered_cancel_add_comm_monoid pos) := sorry --non-trivial
lemma new_lemma_97224 (h1 : complete_lattice linarith.ineq) : is_atomistic linarith.ineq := sorry --non-trivial
lemma new_lemma_97225 (h0 : prod (boolean_algebra.core ennreal) (boolean_algebra.core ennreal)) : id_rel h0 := sorry --non-trivial
lemma new_lemma_97226 (h0 : ordered_add_comm_monoid (has_nndist pos)) : archimedean (has_nndist pos) := sorry --non-trivial
lemma new_lemma_97227 (h0 : function.extfun Type topological_space) : @totally_separated_space.{0} (canonically_ordered_monoid.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (canonically_ordered_monoid.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_97228 (h0 : not (function.extfun Type uniform_space -> false)) : @complete_space.{0} (normed_group.{0} linarith.comp) (@function.extfun_app.{2 1} Type uniform_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type uniform_space.{0}) h0) (normed_group.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_97229 (h0 : functor.add_const (list (add_cancel_monoid Type)) (ring Type)) : list.nodup (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_97230 (h0 : functor.add_const (finset (non_assoc_semiring congr_arg_kind)) num) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_97231 (h0 : uniform_space (normed_field (mul_one_class to_additive.value_type))) : complete_space (normed_field (mul_one_class to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_97232 (h0 : topological_space nnreal) : totally_disconnected_space nnreal := sorry --non-trivial
lemma new_lemma_97233 (h0 : functor.add_const (cancel_comm_monoid_with_zero (has_add linarith.comp)) (finset (ring (has_neg_part Type)))) : @unique_factorization_monoid.{0} (has_add.{0} linarith.comp) (@functor.add_const.run.{0 1} (cancel_comm_monoid_with_zero.{0} (has_add.{0} linarith.comp)) (finset.{1} (ring.{1} (has_neg_part.{1} Type))) h0)  := sorry --non-trivial
lemma new_lemma_97234 (h1 : group (has_nnnorm (random_gen fun_info))) : is_cyclic (has_nnnorm (random_gen fun_info)) := sorry --non-trivial
lemma new_lemma_97235 (h0 : functor.add_const (topological_space (has_to_string pos)) unsigned) : @locally_compact_space.{0} (has_to_string.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (has_to_string.{0} pos)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_97236 (h0 : uniform_space (boolean_algebra.core (has_to_string pos))) : complete_space (boolean_algebra.core (has_to_string pos)) := sorry --non-trivial
lemma new_lemma_97237 (h0 : not (topological_space (has_norm empty) -> false)) : @totally_separated_space.{0} (has_norm.{0} empty) (@classical.by_contradiction'.{1} (topological_space.{0} (has_norm.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_97238 (h0 : function.extfun Type ordered_comm_monoid) : @has_exists_mul_of_le.{0} (has_add.{0} unsigned) (@function.extfun_app.{2 1} Type ordered_comm_monoid.{0} h0 (has_add.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_97239 (h0 : list (semigroup (option (has_add (has_nndist pos))))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_97240 (h1 : has_neg (has_compl std_gen)) (h2 : measurable_space (has_compl std_gen)) : has_measurable_neg (has_compl std_gen) := sorry --non-trivial
lemma new_lemma_97241 (h0 : topological_space (finset (has_add pos))) : t1_space (finset (has_add pos)) := sorry --non-trivial
lemma new_lemma_97242 (h0 : topological_space (has_pos_part (has_to_string linarith.comp))) : totally_disconnected_space (has_pos_part (has_to_string linarith.comp)) := sorry --non-trivial
lemma new_lemma_97243 (h0 : functor.add_const (function.extfun (Type 1) topological_space) (ring Type)) : @path_connected_space.{1} (semigroup.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@functor.add_const.run.{2 1} (function.extfun.{3 2} (Type 1) topological_space.{1}) (ring.{1} Type) h0) (semigroup.{1} Type))  := sorry --non-trivial
lemma new_lemma_97244 (h0 : function.extfun Type group) : @normalizer_condition.{0} (measurable_space.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type group.{0} h0 (measurable_space.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_97245 (h0 : functor.add_const (function.extfun Type topological_space) Type) : @topological_space.separable_space.{0} (has_zero.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type topological_space.{0}) Type h0) (has_zero.{0} pos))  := sorry --non-trivial
lemma new_lemma_97246 (h1 : set (mul_one_class linarith.ineq)) : set.finite h1 := sorry --non-trivial
lemma new_lemma_97247 (h0 : ring (has_pos_part (has_pos_part (has_add Type)))) : is_domain (has_pos_part (has_pos_part (has_add Type))) := sorry --non-trivial
lemma new_lemma_97248 (h0 : functor.add_const (function.extfun Type topological_space) linarith.comp) : @locally_compact_space.{0} (boolean_algebra.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) linarith.comp h0) (boolean_algebra.{0} name))  := sorry --non-trivial
lemma new_lemma_97249 (h0 : finset (generalized_boolean_algebra name)) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_97250 (h0 : function.extfun Type uniform_space) : @separated_space.{0} (sub_neg_monoid.{0} real) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (sub_neg_monoid.{0} real))  := sorry --non-trivial
lemma new_lemma_97251 (h0 : finset (comm_group name)) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_97252 (h0 : functor.add_const (ring (ring linarith.comp)) Type) : @rank_condition.{0} (ring.{0} linarith.comp) (@functor.add_const.run.{0 1} (ring.{0} (ring.{0} linarith.comp)) Type h0)  := sorry --non-trivial
lemma new_lemma_97253 (h0 : function.extfun Type group) : @normalizer_condition.{0} (linear_ordered_comm_group.{0} num) (@function.extfun_app.{2 1} Type group.{0} h0 (linear_ordered_comm_group.{0} num))  := sorry --non-trivial
lemma new_lemma_97254 (h0 : topological_space (has_norm (has_top (has_top to_additive.value_type)))) : discrete_topology (has_norm (has_top (has_top to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_97255 (h0 : functor.add_const (topological_space (has_Sup empty)) num) : @irreducible_space.{0} (has_Sup.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (has_Sup.{0} empty)) num h0)  := sorry --non-trivial
lemma new_lemma_97256 (h0 : topological_space (ordered_comm_monoid (has_add (has_bot (has_add (has_add real)))))) : totally_disconnected_space (ordered_comm_monoid (has_add (has_bot (has_add (has_add real))))) := sorry --non-trivial
lemma new_lemma_97257 (h0 : ring (semi_normed_ring (metric_space to_additive.value_type))) : rank_condition (semi_normed_ring (metric_space to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_97258 (h0 : uniform_space (has_nndist (has_add Type))) : separated_space (has_nndist (has_add Type)) := sorry --non-trivial
lemma new_lemma_97259 (h0 : functor.add_const (ring (comm_group unsigned)) Type) : @is_principal_ideal_ring.{0} (comm_group.{0} unsigned) (@functor.add_const.run.{0 1} (ring.{0} (comm_group.{0} unsigned)) Type h0)  := sorry --non-trivial
lemma new_lemma_97260 (h0 : function.extfun Type group) : @is_cyclic.{0} (random_gen.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type group.{0} h0 (random_gen.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_97261 (h0 : ring (cancel_monoid (option (option ennreal)))) : is_principal_ideal_ring (cancel_monoid (option (option ennreal))) := sorry --non-trivial
lemma new_lemma_97262 (h0 : fin has_zero.zero) : @add_monoid.fg.{0} (comm_semigroup.{0} real) (@matrix.vec_empty.{0} (add_monoid.{0} (comm_semigroup.{0} real)) h0)  := sorry --non-trivial
lemma new_lemma_97263 (h0 : functor.add_const (ring (boolean_algebra Type)) linarith.comp) : @is_domain.{1} (boolean_algebra.{1} Type) (@functor.add_const.run.{1 0} (ring.{1} (boolean_algebra.{1} Type)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_97264 (h0 : topological_space (has_nnnorm (comm_ring reducibility_hints))) : t0_space (has_nnnorm (comm_ring reducibility_hints)) := sorry --non-trivial
lemma new_lemma_97265 (h1 : ring (measurable_space (has_top linarith.ineq))) : strong_rank_condition (measurable_space (has_top linarith.ineq)) := sorry --non-trivial
lemma new_lemma_97266 (h0 : functor.add_const (topological_space (plift empty)) congr_arg_kind) : @discrete_topology.{1} (plift.{1} empty) (@functor.add_const.run.{1 0} (topological_space.{1} (plift.{1} empty)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_97267 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @archimedean.{0} (add_right_cancel_monoid.{0} empty) (@function.extfun_app.{2 1} Type ordered_add_comm_monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ordered_add_comm_monoid.{0}) (add_right_cancel_monoid.{0} empty))  := sorry --non-trivial
lemma new_lemma_97268 (h0 : topological_space (has_add (has_add name))) : loc_path_connected_space (has_add (has_add name)) := sorry --non-trivial
lemma new_lemma_97269 (h0 : ring (has_neg_part Type)) : is_principal_ideal_ring (has_neg_part Type) := sorry --non-trivial
lemma new_lemma_97270 (h0 : topological_space (boolean_algebra (has_neg (generalized_boolean_algebra (has_bot name))))) : sequential_space (boolean_algebra (has_neg (generalized_boolean_algebra (has_bot name)))) := sorry --non-trivial
lemma new_lemma_97271 (h0 : functor.add_const (function.extfun Type ring) pos) : @is_domain.{0} (has_to_string.{0} pos) (@function.extfun_app.{2 1} Type ring.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type ring.{0}) pos h0) (has_to_string.{0} pos))  := sorry --non-trivial
lemma new_lemma_97272 (h0 : functor.add_const (topological_space (has_Inf pos)) name) : @normal_space.{0} (has_Inf.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (has_Inf.{0} pos)) name h0)  := sorry --non-trivial
lemma new_lemma_97273 (h0 : functor.add_const Prop (canonically_ordered_comm_semiring unsigned)) : functor.add_const.run h0 := sorry --non-trivial
lemma new_lemma_97274 (h0 : ring (random_gen (metric_space string_imp))) : rank_condition (random_gen (metric_space string_imp)) := sorry --non-trivial
lemma new_lemma_97275 (h0 : functor.add_const (ring (has_to_string environment.implicit_infer_kind)) environment.implicit_infer_kind) : @strong_rank_condition.{0} (has_to_string.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (ring.{0} (has_to_string.{0} environment.implicit_infer_kind)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_97276 (h1 : has_lt (simple_graph environment.projection_info)) : no_max_order (simple_graph environment.projection_info) := sorry --non-trivial
lemma new_lemma_97277 (h0 : add_monoid (semiring (random_gen empty))) : add_monoid.fg (semiring (random_gen empty)) := sorry --non-trivial
lemma new_lemma_97278 (h0 : ring (distrib_lattice (has_nnnorm linarith.comp_source))) : rank_condition (distrib_lattice (has_nnnorm linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_97279 (h0 : functor.add_const (topological_space auto.case_option) empty) : @loc_path_connected_space.{0} auto.case_option (@functor.add_const.run.{0 0} (topological_space.{0} auto.case_option) empty h0)  := sorry --non-trivial
lemma new_lemma_97280 (h0 : ring (fintype (random_gen string_imp))) : is_domain (fintype (random_gen string_imp)) := sorry --non-trivial
lemma new_lemma_97281 (h0 : functor.add_const (ring (pseudo_metric_space unsigned)) unsigned) : @rank_condition.{0} (pseudo_metric_space.{0} unsigned) (@functor.add_const.run.{0 0} (ring.{0} (pseudo_metric_space.{0} unsigned)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_97282 (h0 : functor.add_const (complete_lattice (free_add_monoid empty)) empty) : @complete_lattice.is_Sup_finite_compact.{0} (free_add_monoid.{0} empty) (@functor.add_const.run.{0 0} (complete_lattice.{0} (free_add_monoid.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_97283 (h0 : functor.add_const (cancel_comm_monoid_with_zero (has_Inf linarith.comp)) (has_neg linarith.comp)) : @unique_factorization_monoid.{0} (has_Inf.{0} linarith.comp) (@functor.add_const.run.{0 0} (cancel_comm_monoid_with_zero.{0} (has_Inf.{0} linarith.comp)) (has_neg.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_97284 (h0 : filter (has_add string_imp)) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_97285 (h0 : topological_space (has_top (has_inv (has_inv to_additive.value_type)))) : locally_compact_space (has_top (has_inv (has_inv to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_97286 (h0 : ring (linear_ordered_comm_group_with_zero string.iterator_imp)) : rank_condition (linear_ordered_comm_group_with_zero string.iterator_imp) := sorry --non-trivial
lemma new_lemma_97287 (h0 : group (ring num)) : group.fg (ring num) := sorry --non-trivial
lemma new_lemma_97288 (h0 : semiring (option unsigned)) : is_noetherian_ring (option unsigned) := sorry --non-trivial
lemma new_lemma_97289 (h0 : ring (has_add linarith.comp_source)) : strong_rank_condition (has_add linarith.comp_source) := sorry --non-trivial
lemma new_lemma_97290 (h0 : complete_lattice (linear_ordered_add_comm_group (has_norm (has_inv linarith.ineq)))) : is_compactly_generated (linear_ordered_add_comm_group (has_norm (has_inv linarith.ineq))) := sorry --non-trivial
lemma new_lemma_97291 (h0 : topological_space (add_left_cancel_semigroup unsigned)) : topological_space.separable_space (add_left_cancel_semigroup unsigned) := sorry --non-trivial
lemma new_lemma_97292 (h0 : topological_space (complete_semilattice_Sup (has_top (has_top fun_info)))) : irreducible_space (complete_semilattice_Sup (has_top (has_top fun_info))) := sorry --non-trivial
lemma new_lemma_97293 (h0 : filter (has_add (finset (ring Type)))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_97294 (h0 : function.extfun Type topological_space) : @t1_space.{0} (has_Sup.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_Sup.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_97295 (h0 : group (canonically_ordered_comm_semiring (option pos))) : normalizer_condition (canonically_ordered_comm_semiring (option pos)) := sorry --non-trivial
lemma new_lemma_97296 (h0 : topological_space (add_cancel_comm_monoid reducibility_hints)) : t0_space (add_cancel_comm_monoid reducibility_hints) := sorry --non-trivial
lemma new_lemma_97297 (h1 : measurable_space std_gen) (h2 : has_mul std_gen) (h3 : measure_theory.measure std_gen) : measure_theory.measure.is_mul_left_invariant h3 := sorry --non-trivial
lemma new_lemma_97298 (h0 : semiring (non_assoc_semiring num)) : is_noetherian_ring (non_assoc_semiring num) := sorry --non-trivial
lemma new_lemma_97299 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @unique_factorization_monoid.{0} (linear_ordered_comm_group.{0} ennreal) (@function.extfun_app.{2 1} Type cancel_comm_monoid_with_zero.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 cancel_comm_monoid_with_zero.{0}) (linear_ordered_comm_group.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_97300 (h0 : add_group (has_zero Type)) : is_add_cyclic (has_zero Type) := sorry --non-trivial
lemma new_lemma_97301 (h0 : functor.add_const (function.extfun Type topological_space) (has_Inf name)) : @t1_space.{0} (has_Inf.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) (has_Inf.{0} name) h0) (has_Inf.{0} pos))  := sorry --non-trivial
lemma new_lemma_97302 (h1 : uniform_space (mul_one_class enat)) : complete_space (mul_one_class enat) := sorry --non-trivial
lemma new_lemma_97303 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @preirreducible_space.{0} (ordered_comm_group.{0} (option.{0} empty)) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (ordered_comm_group.{0} (option.{0} empty)))  := sorry --non-trivial
lemma new_lemma_97304 (h0 : ring (semiring (semiring (semiring unsigned)))) : rank_condition (semiring (semiring (semiring unsigned))) := sorry --non-trivial
lemma new_lemma_97305 (h0 : topological_space (pseudo_metric_space linarith.comp_source)) : totally_disconnected_space (pseudo_metric_space linarith.comp_source) := sorry --non-trivial
lemma new_lemma_97306 (h0 : filter (has_to_string (add_comm_monoid (add_comm_monoid Type)))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_97307 (h0 : function.extfun (finset Type) (has_mem.mem (measurable_space linarith.comp_source))) : @complete_space.{0} (measurable_space.{0} linarith.comp_source) (@finset.pi.empty.{1 0} Type uniform_space.{0} (measurable_space.{0} linarith.comp_source) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (measurable_space.{0} linarith.comp_source)) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_97308 (h0 : function.extfun Type group) : @normalizer_condition.{0} (option.{0} empty) (@function.extfun_app.{2 1} Type group.{0} h0 (option.{0} empty))  := sorry --non-trivial
lemma new_lemma_97309 (h0 : function.extfun Type topological_space) : @path_connected_space.{0} (add_cancel_monoid.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (add_cancel_monoid.{0} empty))  := sorry --non-trivial
lemma new_lemma_97310 (h0 : not (complete_lattice (comm_ring string.iterator_imp) -> false)) : @complete_lattice.is_Sup_finite_compact.{0} (comm_ring.{0} string.iterator_imp) (@classical.by_contradiction'.{1} (complete_lattice.{0} (comm_ring.{0} string.iterator_imp)) h0)  := sorry --non-trivial
lemma new_lemma_97311 (h0 : complete_lattice (complete_distrib_lattice (has_add unsigned))) : is_compactly_generated (complete_distrib_lattice (has_add unsigned)) := sorry --non-trivial
lemma new_lemma_97312 (h0 : topological_space (has_union (semiring (semiring (semiring congr_arg_kind))))) : locally_compact_space (has_union (semiring (semiring (semiring congr_arg_kind)))) := sorry --non-trivial
lemma new_lemma_97313 (h0 : ring (measurable_space (has_top num))) : rank_condition (measurable_space (has_top num)) := sorry --non-trivial
lemma new_lemma_97314 (h0 : filter (boolean_algebra.core (option (option unsigned)))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_97315 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @monoid.fg.{0} (semiring.{0} unsigned) (@function.extfun_app.{2 1} Type monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 monoid.{0}) (semiring.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_97316 (h1 : add_group (encodable char)) : is_add_cyclic (encodable char) := sorry --non-trivial
lemma new_lemma_97317 (h0 : uniform_space (cancel_monoid (comm_group ennreal))) : complete_space (cancel_monoid (comm_group ennreal)) := sorry --non-trivial
lemma new_lemma_97318 (h0 : topological_space (linear_ordered_comm_ring (semiring (semiring empty)))) : topological_space.separable_space (linear_ordered_comm_ring (semiring (semiring empty))) := sorry --non-trivial
lemma new_lemma_97319 (h0 : not (topological_space (semi_normed_comm_ring linarith.ineq) -> false)) : @t0_space.{0} (semi_normed_comm_ring.{0} linarith.ineq) (@classical.by_contradiction'.{1} (topological_space.{0} (semi_normed_comm_ring.{0} linarith.ineq)) h0)  := sorry --non-trivial
lemma new_lemma_97320 (h0 : functor.add_const (finset (bin_tree unsigned)) unsigned) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_97321 (h0 : topological_space (normed_lattice_add_comm_group (has_bot pos))) : t1_space (normed_lattice_add_comm_group (has_bot pos)) := sorry --non-trivial
lemma new_lemma_97322 (h0 : monoid (has_zero (has_add (has_add (has_to_string (has_add Type)))))) : monoid.fg (has_zero (has_add (has_add (has_to_string (has_add Type))))) := sorry --non-trivial
lemma new_lemma_97323 (h0 : ring (normed_comm_ring (has_neg linarith.comp))) : is_domain (normed_comm_ring (has_neg linarith.comp)) := sorry --non-trivial
lemma new_lemma_97324 (h0 : functor.add_const (topological_space pos) linarith.comp) : @normal_space.{0} pos (@functor.add_const.run.{0 0} (topological_space.{0} pos) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_97325 (h0 : functor.comp ring add_comm_monoid ennreal) : @is_domain.{0} (add_comm_monoid.{0} ennreal) (@functor.comp.run.{0 0 0} ring.{0} add_comm_monoid.{0} ennreal h0)  := sorry --non-trivial
lemma new_lemma_97326 (h3 : complete_lattice (encodable linarith.ineq)) : complete_lattice.is_Sup_finite_compact (encodable linarith.ineq) := sorry --non-trivial
lemma new_lemma_97327 (h1 : ring (has_compl string_imp)) : strong_rank_condition (has_compl string_imp) := sorry --non-trivial
lemma new_lemma_97328 (h0 : semiring (has_nndist (comm_group (has_to_string (comm_group (has_to_string unsigned)))))) : is_noetherian_ring (has_nndist (comm_group (has_to_string (comm_group (has_to_string unsigned))))) := sorry --non-trivial
lemma new_lemma_97329 (h0 : monoid (normed_group (semiring congr_arg_kind))) : monoid.fg (normed_group (semiring congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_97330 (h0 : topological_space (cancel_monoid (option (option (option (option (option empty))))))) : discrete_topology (cancel_monoid (option (option (option (option (option empty)))))) := sorry --non-trivial
lemma new_lemma_97331 (h0 : function.extfun Type topological_space) : @preconnected_space.{0} (has_nndist.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_nndist.{0} name))  := sorry --non-trivial
lemma new_lemma_97332 (h0 : group (has_nnnorm (random_gen (random_gen (random_gen string.iterator_imp))))) : is_cyclic (has_nnnorm (random_gen (random_gen (random_gen string.iterator_imp)))) := sorry --non-trivial
lemma new_lemma_97333 (h0 : complete_lattice (random_gen (has_top (has_top congr_arg_kind)))) : is_atomistic (random_gen (has_top (has_top congr_arg_kind))) := sorry --non-trivial
lemma new_lemma_97334 (h0 : functor.add_const (topological_space (boolean_algebra Type)) pos) : @sequential_space.{1} (boolean_algebra.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (boolean_algebra.{1} Type)) pos h0)  := sorry --non-trivial
lemma new_lemma_97335 (h0 : function.extfun Type filter) : filter.ne_bot (function.extfun_app h0 (has_zero pos)) := sorry --non-trivial
lemma new_lemma_97336 (h0 : complete_lattice (ordered_comm_ring (has_add pos))) : is_compactly_generated (ordered_comm_ring (has_add pos)) := sorry --non-trivial
lemma new_lemma_97337 (h0 : functor.add_const (ring (has_bot empty)) empty) : @is_domain.{0} (has_bot.{0} empty) (@functor.add_const.run.{0 0} (ring.{0} (has_bot.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_97338 (h2 : filter (topological_space to_additive.value_type)) : filter.ne_bot h2 := sorry --non-trivial
lemma new_lemma_97339 (h0 : topological_space (has_neg (finset (finset (finset pos))))) : normal_space (has_neg (finset (finset (finset pos)))) := sorry --non-trivial
lemma new_lemma_97340 (h0 : topological_space (simple_graph (boolean_algebra.core pos))) : path_connected_space (simple_graph (boolean_algebra.core pos)) := sorry --non-trivial
lemma new_lemma_97341 (h1 : set (add_comm_semigroup enat -> fun_info)) : set.separates_points h1 := sorry --non-trivial
lemma new_lemma_97342 (h0 : ring (has_ssubset (random_gen (random_gen linarith.ineq)))) : rank_condition (has_ssubset (random_gen (random_gen linarith.ineq))) := sorry --non-trivial
lemma new_lemma_97343 (h0 : functor.add_const (add_monoid (add_cancel_monoid linarith.comp)) (ring Type)) : @add_monoid.fg.{0} (add_cancel_monoid.{0} linarith.comp) (@functor.add_const.run.{0 1} (add_monoid.{0} (add_cancel_monoid.{0} linarith.comp)) (ring.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_97344 (h0 : add_group (has_norm (has_norm (has_norm empty)))) : is_add_cyclic (has_norm (has_norm (has_norm empty))) := sorry --non-trivial
lemma new_lemma_97345 (h0 : functor.add_const (ordered_add_comm_monoid (cancel_monoid Type)) name) : @archimedean.{1} (cancel_monoid.{1} Type) (@functor.add_const.run.{1 0} (ordered_add_comm_monoid.{1} (cancel_monoid.{1} Type)) name h0)  := sorry --non-trivial
lemma new_lemma_97346 (h0 : function.extfun Type ring) : @is_domain.{0} (add_comm_monoid.{0} pos) (@function.extfun_app.{2 1} Type ring.{0} h0 (add_comm_monoid.{0} pos))  := sorry --non-trivial
lemma new_lemma_97347 (h0 : topological_space (canonically_ordered_monoid (has_add (has_add Type)))) : preconnected_space (canonically_ordered_monoid (has_add (has_add Type))) := sorry --non-trivial
lemma new_lemma_97348 (h0 : complete_lattice (canonically_ordered_comm_semiring (finset linarith.comp))) : is_compactly_generated (canonically_ordered_comm_semiring (finset linarith.comp)) := sorry --non-trivial
lemma new_lemma_97349 (h0 : function.extfun Type ring) : @rank_condition.{0} (preorder.{0} (option.{0} empty)) (@function.extfun_app.{2 1} Type ring.{0} h0 (preorder.{0} (option.{0} empty)))  := sorry --non-trivial
lemma new_lemma_97350 (h0 : functor.add_const (topological_space (finset pos)) (has_neg linarith.comp)) : @locally_compact_space.{0} (finset.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (finset.{0} pos)) (has_neg.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_97351 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @totally_disconnected_space.{0} (has_union.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_union.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_97352 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_principal_ideal_ring.{0} (normed_comm_ring.{0} name) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (normed_comm_ring.{0} name))  := sorry --non-trivial
lemma new_lemma_97353 (h0 : not (function.extfun Type uniform_space -> false)) : @complete_space.{0} (add_group.{0} unsigned) (@function.extfun_app.{2 1} Type uniform_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type uniform_space.{0}) h0) (add_group.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_97354 (h0 : not (topological_space (has_norm linarith.comp) -> false)) : @normal_space.{0} (has_norm.{0} linarith.comp) (@classical.by_contradiction'.{1} (topological_space.{0} (has_norm.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_97355 (h1 : topological_space (has_inv to_additive.value_type)) : locally_compact_space (has_inv to_additive.value_type) := sorry --non-trivial
lemma new_lemma_97356 (h1 : not (filter (dlist string_imp) -> false)) : filter.ne_bot (classical.by_contradiction' h1) := sorry --non-trivial
lemma new_lemma_97357 (h0 : add_group (normed_group (has_ssubset to_additive.value_type))) : is_add_cyclic (normed_group (has_ssubset to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_97358 (h0 : functor.add_const (ring (boolean_algebra.core Type)) pos) : @is_domain.{1} (boolean_algebra.core.{1} Type) (@functor.add_const.run.{1 0} (ring.{1} (boolean_algebra.core.{1} Type)) pos h0)  := sorry --non-trivial
lemma new_lemma_97359 (h0 : ordered_comm_ring (has_nndist (has_neg name)) -> ordered_comm_ring (has_nndist (has_neg name)) -> Prop) : reflexive h0 := sorry --non-trivial
lemma new_lemma_97360 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @totally_separated_space.{0} (has_Inf.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_Inf.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_97361 (h0 : complete_lattice (has_inv (has_ssubset linarith.ineq))) : complete_lattice.is_Sup_finite_compact (has_inv (has_ssubset linarith.ineq)) := sorry --non-trivial
lemma new_lemma_97362 (h0 : function.extfun (finset Type) (has_mem.mem (has_emptyc linarith.ineq))) : @group.fg.{0} (has_emptyc.{0} linarith.ineq) (@finset.pi.empty.{1 0} Type group.{0} (has_emptyc.{0} linarith.ineq) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (has_emptyc.{0} linarith.ineq)) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_97363 (h0 : uniform_space (boolean_algebra (has_Inf linarith.comp))) : complete_space (boolean_algebra (has_Inf linarith.comp)) := sorry --non-trivial
lemma new_lemma_97364 (h0 : topological_space (has_nndist (comm_group name))) : totally_separated_space (has_nndist (comm_group name)) := sorry --non-trivial
lemma new_lemma_97365 (h0 : group (semigroup name)) : is_cyclic (semigroup name) := sorry --non-trivial
lemma new_lemma_97366 (h0 : function.extfun Type add_group) : @is_add_cyclic.{0} (with_bot.{0} empty) (@function.extfun_app.{2 1} Type add_group.{0} h0 (with_bot.{0} empty))  := sorry --non-trivial
lemma new_lemma_97367 (h1 : uniform_space (normed_field (has_nnnorm reducibility_hints))) : complete_space (normed_field (has_nnnorm reducibility_hints)) := sorry --non-trivial
lemma new_lemma_97368 (h0 : function.extfun Type complete_lattice) : @complete_lattice.is_Sup_finite_compact.{0} (has_emptyc.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (has_emptyc.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_97369 (h0 : topological_space (cancel_monoid unsigned)) : totally_separated_space (cancel_monoid unsigned) := sorry --non-trivial
lemma new_lemma_97370 (h0 : function.extfun Type cancel_comm_monoid_with_zero) : @unique_factorization_monoid.{0} (add_cancel_comm_monoid.{0} unsigned) (@function.extfun_app.{2 1} Type cancel_comm_monoid_with_zero.{0} h0 (add_cancel_comm_monoid.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_97371 (h0 : functor.add_const (fin has_zero.zero) (boolean_algebra.core (has_pos_part pos))) : @is_compactly_generated.{1} (has_pos_part.{1} Type) (@matrix.vec_empty.{1} (complete_lattice.{1} (has_pos_part.{1} Type)) (@functor.add_const.run.{0 0} (fin (@has_zero.zero.{0} nat nat.has_zero)) (boolean_algebra.core.{0} (has_pos_part.{0} pos)) h0))  := sorry --non-trivial
lemma new_lemma_97372 (h0 : topological_space (has_to_string (has_nndist name))) : totally_separated_space (has_to_string (has_nndist name)) := sorry --non-trivial
lemma new_lemma_97373 (h0 : topological_space (add_comm_monoid (add_cancel_monoid name))) : path_connected_space (add_comm_monoid (add_cancel_monoid name)) := sorry --non-trivial
lemma new_lemma_97374 (h1 : topological_space (has_norm (has_norm linarith.ineq))) : t0_space (has_norm (has_norm linarith.ineq)) := sorry --non-trivial
lemma new_lemma_97375 (h0 : uniform_space (comm_group (finset (boolean_algebra Type)))) : separated_space (comm_group (finset (boolean_algebra Type))) := sorry --non-trivial
lemma new_lemma_97376 (h0 : ring (has_bot (has_bot (sub_neg_monoid (has_Inf real))))) : strong_rank_condition (has_bot (has_bot (sub_neg_monoid (has_Inf real)))) := sorry --non-trivial
lemma new_lemma_97377 (h2 : ring (random_gen to_additive.value_type)) : rank_condition (random_gen to_additive.value_type) := sorry --non-trivial
lemma new_lemma_97378 (h0 : complete_lattice (add_cancel_comm_monoid (random_gen linarith.comp_source))) : complete_lattice.is_Sup_finite_compact (add_cancel_comm_monoid (random_gen linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_97379 (h0 : set (simple_graph char)) : set.subsingleton h0 := sorry --non-trivial
lemma new_lemma_97380 (h0 : not (function.extfun Type topological_space -> false)) : @normal_space.{0} (with_bot.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (with_bot.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_97381 (h0 : function.extfun Type ordered_add_comm_monoid) : @archimedean.{0} (complete_distrib_lattice.{0} name) (@function.extfun_app.{2 1} Type ordered_add_comm_monoid.{0} h0 (complete_distrib_lattice.{0} name))  := sorry --non-trivial
lemma new_lemma_97382 (h0 : not (function.extfun Type group -> false)) : @is_cyclic.{0} congr_arg_kind (@function.extfun_app.{2 1} Type group.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type group.{0}) h0) congr_arg_kind)  := sorry --non-trivial
lemma new_lemma_97383 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @totally_disconnected_space.{0} (cancel_monoid.{0} ennreal) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (cancel_monoid.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_97384 (h0 : topological_space (has_nnnorm (has_nnnorm fun_info))) : t0_space (has_nnnorm (has_nnnorm fun_info)) := sorry --non-trivial
lemma new_lemma_97385 (h0 : functor.add_const (function.extfun Type topological_space) pos) : @sequential_space.{0} (finset.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) pos h0) (finset.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_97386 (h0 : measurable_space linarith.ineq) (h1 : measure_theory.measure linarith.ineq) : measure_theory.is_finite_measure h1 := sorry --non-trivial
lemma new_lemma_97387 (h1 : filter (comm_ring (with_bot (with_bot string_imp)))) : filter.ne_bot h1 := sorry --non-trivial
lemma new_lemma_97388 (h2 : complete_lattice (has_compl to_additive.value_type)) : complete_lattice.is_Sup_finite_compact (has_compl to_additive.value_type) := sorry --non-trivial
lemma new_lemma_97389 (h0 : functor.add_const (group (ring linarith.comp)) Type) : @normalizer_condition.{0} (ring.{0} linarith.comp) (@functor.add_const.run.{0 1} (group.{0} (ring.{0} linarith.comp)) Type h0)  := sorry --non-trivial
lemma new_lemma_97390 (h0 : add_group (distrib (mul_one_class linarith.ineq))) : is_add_cyclic (distrib (mul_one_class linarith.ineq)) := sorry --non-trivial
lemma new_lemma_97391 (h0 : group (normed_group linarith.ineq)) : normalizer_condition (normed_group linarith.ineq) := sorry --non-trivial
lemma new_lemma_97392 (h0 : function.extfun Type ring) : @rank_condition.{0} (semiring.{0} unsigned) (@function.extfun_app.{2 1} Type ring.{0} h0 (semiring.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_97393 (h0 : ring (with_bot (has_norm (has_norm fun_info)))) : rank_condition (with_bot (has_norm (has_norm fun_info))) := sorry --non-trivial
lemma new_lemma_97394 (h0 : functor.add_const (topological_space (left_cancel_monoid unsigned)) congr_arg_kind) : @discrete_topology.{0} (left_cancel_monoid.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (left_cancel_monoid.{0} unsigned)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_97395 (h0 : topological_space (has_div linarith.ineq)) (h1 : not (preorder (has_div linarith.ineq) -> false)) : @order_topology.{0} (has_div.{0} linarith.ineq) h0 (@classical.by_contradiction'.{1} (preorder.{0} (has_div.{0} linarith.ineq)) h1)  := sorry --non-trivial
lemma new_lemma_97396 (h0 : uniform_space (boolean_algebra.core (finset (has_neg_part pos)))) : separated_space (boolean_algebra.core (finset (has_neg_part pos))) := sorry --non-trivial
lemma new_lemma_97397 (h0 : function.extfun Type topological_space) : @path_connected_space.{0} (measurable_space.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (measurable_space.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_97398 (h0 : complete_lattice (has_le environment.projection_info)) : complete_lattice.is_Sup_finite_compact (has_le environment.projection_info) := sorry --non-trivial
lemma new_lemma_97399 (h0 : set (ereal -> mul_one_class enat)) : set.separates_points h0 := sorry --non-trivial
lemma new_lemma_97400 (h1 : function.extfun (Type -> Type) (function.extfun Type)) : @t0_space.{0} (with_bot.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h1 topological_space.{0}) (with_bot.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_97401 (h0 : empty) : @is_compactly_generated.{0} (has_inv.{0} fun_info) (@empty.elim.{1} (complete_lattice.{0} (has_inv.{0} fun_info)) (@id.{1} empty h0))  := sorry --non-trivial
lemma new_lemma_97402 (h0 : functor.add_const (functor.add_const (group pos) unsigned) pos) : @group.fg.{0} pos (@functor.add_const.run.{0 0} (group.{0} pos) unsigned (@functor.add_const.run.{0 0} (functor.add_const.{0 0} (group.{0} pos) unsigned) pos h0))  := sorry --non-trivial
lemma new_lemma_97403 (h0 : complete_lattice (has_nndist (option (option (option unsigned))))) : is_compactly_generated (has_nndist (option (option (option unsigned)))) := sorry --non-trivial
lemma new_lemma_97404 (h0 : functor.add_const (topological_space (boolean_algebra Type)) Type) : @totally_separated_space.{1} (boolean_algebra.{1} Type) (@functor.add_const.run.{1 1} (topological_space.{1} (boolean_algebra.{1} Type)) Type h0)  := sorry --non-trivial
lemma new_lemma_97405 (h0 : uniform_space (semi_normed_ring (mul_one_class (mul_one_class (comm_ring linarith.comp_source))))) : complete_space (semi_normed_ring (mul_one_class (mul_one_class (comm_ring linarith.comp_source)))) := sorry --non-trivial
lemma new_lemma_97406 (h0 : topological_space (has_compl (comm_ring (random_gen to_additive.value_type)))) : t0_space (has_compl (comm_ring (random_gen to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_97407 (h0 : functor.add_const (topological_space (semiring congr_arg_kind)) unsigned) : @irreducible_space.{0} (semiring.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (semiring.{0} congr_arg_kind)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_97408 (h0 : functor.add_const (topological_space (boolean_algebra Type)) name) : @loc_path_connected_space.{1} (boolean_algebra.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (boolean_algebra.{1} Type)) name h0)  := sorry --non-trivial
lemma new_lemma_97409 (h0 : not (monoid (preorder num) -> false)) : @monoid.fg.{0} (preorder.{0} num) (@classical.by_contradiction'.{1} (monoid.{0} (preorder.{0} num)) h0)  := sorry --non-trivial
lemma new_lemma_97410 (h0 : list (comm_semigroup pos)) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_97411 (h0 : ordered_add_comm_monoid (has_inner (option (option empty)) empty)) : archimedean (has_inner (option (option empty)) empty) := sorry --non-trivial
lemma new_lemma_97412 (h0 : function.extfun nat fin) : @discrete_topology.{0} (normed_lattice_add_comm_group.{0} linarith.comp) (@matrix.vec_empty.{0} (topological_space.{0} (normed_lattice_add_comm_group.{0} linarith.comp)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_97413 (h0 : has_mem.mem topological_space has_emptyc.emptyc) : @path_connected_space.{0} linarith.comp (@function.extfun_app.{2 1} Type topological_space.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) topological_space.{0} h0) linarith.comp)  := sorry --non-trivial
lemma new_lemma_97414 (h0 : set (plift environment.projection_info)) : set.finite h0 := sorry --non-trivial
lemma new_lemma_97415 (h0 : topological_space (comm_group Type)) : locally_compact_space (comm_group Type) := sorry --non-trivial
lemma new_lemma_97416 (h0 : function.extfun Type group) : @is_cyclic.{0} (has_add.{0} linarith.ineq) (@function.extfun_app.{2 1} Type group.{0} h0 (has_add.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_97417 (h0 : functor.add_const (topological_space (ring Type)) (has_add Type)) : @loc_path_connected_space.{1} (ring.{1} Type) (@functor.add_const.run.{1 1} (topological_space.{1} (ring.{1} Type)) (has_add.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_97418 (h0 : group (complete_linear_order (has_top (has_top empty)))) : normalizer_condition (complete_linear_order (has_top (has_top empty))) := sorry --non-trivial
lemma new_lemma_97419 (h0 : topological_space (boolean_algebra (add_comm_monoid (has_to_string pos)))) : t1_space (boolean_algebra (add_comm_monoid (has_to_string pos))) := sorry --non-trivial
lemma new_lemma_97420 (h0 : topological_space (ring (has_add (has_add name)))) : totally_separated_space (ring (has_add (has_add name))) := sorry --non-trivial
lemma new_lemma_97421 (h0 h1 : multiset ereal) : multiset.disjoint h0 h1 := sorry --non-trivial
lemma new_lemma_97422 (h1 : topological_space (distrib to_additive.value_type)) : totally_disconnected_space (distrib to_additive.value_type) := sorry --non-trivial
lemma new_lemma_97423 (h0 : functor.add_const (topological_space (normed_comm_ring pos)) Type) : @totally_disconnected_space.{0} (normed_comm_ring.{0} pos) (@functor.add_const.run.{0 1} (topological_space.{0} (normed_comm_ring.{0} pos)) Type h0)  := sorry --non-trivial
lemma new_lemma_97424 (h1 : add_group (linear_ordered_add_comm_group fun_info)) : is_add_cyclic (linear_ordered_add_comm_group fun_info) := sorry --non-trivial
lemma new_lemma_97425 (h0 : topological_space (canonically_linear_ordered_monoid (has_Inf real))) : normal_space (canonically_linear_ordered_monoid (has_Inf real)) := sorry --non-trivial
lemma new_lemma_97426 (h0 : has_mem.mem (has_one empty) has_emptyc.emptyc) : @group.fg.{0} (has_one.{0} empty) (@finset.pi.empty.{1 0} Type group.{0} (has_one.{0} empty) h0)  := sorry --non-trivial
lemma new_lemma_97427 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_compactly_generated.{0} (has_neg_part.{0} ennreal) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (has_neg_part.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_97428 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_cyclic.{0} (add_right_cancel_monoid.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (add_right_cancel_monoid.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_97429 (h0 : function.extfun Type cancel_comm_monoid_with_zero) : @unique_factorization_monoid.{0} (add_cancel_comm_monoid.{0} empty) (@function.extfun_app.{2 1} Type cancel_comm_monoid_with_zero.{0} h0 (add_cancel_comm_monoid.{0} empty))  := sorry --non-trivial
lemma new_lemma_97430 (h0 : add_group linarith.comp_source) : is_add_cyclic linarith.comp_source := sorry --non-trivial
lemma new_lemma_97431 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_domain.{0} (has_neg.{0} linarith.comp) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (has_neg.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_97432 (h0 : add_monoid (measurable_space.dynkin_system unsigned)) (h1 : topological_space (add_units (measurable_space.dynkin_system unsigned))) : locally_compact_space (add_units (measurable_space.dynkin_system unsigned)) := sorry --non-trivial
lemma new_lemma_97433 (h0 : complete_lattice (ordered_comm_ring (has_Inf (has_Inf (has_Inf real))))) : is_atomistic (ordered_comm_ring (has_Inf (has_Inf (has_Inf real)))) := sorry --non-trivial
lemma new_lemma_97434 (h0 : topological_space (with_one (denumerable (random_gen (random_gen fun_info))))) : path_connected_space (with_one (denumerable (random_gen (random_gen fun_info)))) := sorry --non-trivial
lemma new_lemma_97435 (h0 : functor.add_const (group (add_cancel_monoid name)) (finset (finset environment.implicit_infer_kind))) : @group.fg.{0} (add_cancel_monoid.{0} name) (@functor.add_const.run.{0 0} (group.{0} (add_cancel_monoid.{0} name)) (finset.{0} (finset.{0} environment.implicit_infer_kind)) h0)  := sorry --non-trivial
lemma new_lemma_97436 (h0 : complete_lattice (non_unital_non_assoc_semiring char)) : is_compactly_generated (non_unital_non_assoc_semiring char) := sorry --non-trivial
lemma new_lemma_97437 (h0 : finset (boolean_algebra (has_nndist name))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_97438 (h3 h4 : multiset (monoid_with_zero char)) : multiset.disjoint h3 h4 := sorry --non-trivial
lemma new_lemma_97439 (h0 : group (normed_lattice_add_comm_group (has_pos_part real))) : is_simple_group (normed_lattice_add_comm_group (has_pos_part real)) := sorry --non-trivial
lemma new_lemma_97440 (h0 : filter (boolean_algebra (has_neg environment.implicit_infer_kind))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_97441 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @rank_condition.{0} (has_neg.{0} name) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (has_neg.{0} name))  := sorry --non-trivial
lemma new_lemma_97442 (h0 : functor.add_const (topological_space (comm_group pos)) linarith.comp) : @topological_space.separable_space.{0} (comm_group.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (comm_group.{0} pos)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_97443 (h0 : topological_space (complete_distrib_lattice (option pos))) : preirreducible_space (complete_distrib_lattice (option pos)) := sorry --non-trivial
lemma new_lemma_97444 (h0 : fin has_zero.zero) : @is_compactly_generated.{0} (has_add.{0} linarith.comp) (@matrix.vec_empty.{0} (complete_lattice.{0} (has_add.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_97445 (h0 : list (boolean_algebra (ring linarith.comp))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_97446 (h0 : functor.add_const (list (semigroup Type)) (has_nndist Type)) : list.nodup (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_97447 (h0 : functor.comp topological_space has_add name) : @loc_path_connected_space.{0} (has_add.{0} name) (@functor.comp.run.{0 0 0} topological_space.{0} has_add.{0} name h0)  := sorry --non-trivial
lemma new_lemma_97448 (h0 : not (topological_space (non_assoc_semiring (semiring (semiring (semiring (semiring empty))))) -> false)) : @path_connected_space.{0} (non_assoc_semiring.{0} (semiring.{0} (semiring.{0} (semiring.{0} (semiring.{0} empty))))) (@classical.by_contradiction'.{1} (topological_space.{0} (non_assoc_semiring.{0} (semiring.{0} (semiring.{0} (semiring.{0} (semiring.{0} empty)))))) h0)  := sorry --non-trivial
lemma new_lemma_97449 (h0 : functor.comp add_monoid has_neg name) : @add_monoid.fg.{0} (has_neg.{0} name) (@functor.comp.run.{0 0 0} add_monoid.{0} has_neg.{0} name h0)  := sorry --non-trivial
lemma new_lemma_97450 (h0 : complete_lattice (has_inv (has_nnnorm (random_gen (has_nnnorm fun_info))))) : is_compactly_generated (has_inv (has_nnnorm (random_gen (has_nnnorm fun_info)))) := sorry --non-trivial
lemma new_lemma_97451 (h0 : ring (has_ssubset (random_gen (has_ssubset reducibility_hints)))) : rank_condition (has_ssubset (random_gen (has_ssubset reducibility_hints))) := sorry --non-trivial
lemma new_lemma_97452 (h0 : functor.add_const (topological_space (finset pos)) linarith.comp) : @irreducible_space.{0} (finset.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (finset.{0} pos)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_97453 (h0 : functor.add_const (function.extfun (Type 1) topological_space) pos) : @preirreducible_space.{1} (generalized_boolean_algebra.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) topological_space.{1}) pos h0) (generalized_boolean_algebra.{1} Type))  := sorry --non-trivial
lemma new_lemma_97454 (h0 : function.extfun Type uniform_space) : @complete_space.{0} (canonically_ordered_comm_semiring.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (canonically_ordered_comm_semiring.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_97455 (h0 : function.extfun Type topological_space) : @normal_space.{0} (normed_comm_ring.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (normed_comm_ring.{0} pos))  := sorry --non-trivial
lemma new_lemma_97456 (h0 : ring (semigroup (has_Inf (has_nndist (has_pos_part (finset linarith.comp)))))) : is_principal_ideal_ring (semigroup (has_Inf (has_nndist (has_pos_part (finset linarith.comp))))) := sorry --non-trivial
lemma new_lemma_97457 (h0 : function.extfun Type group) : @is_cyclic.{0} (measurable_space.dynkin_system.{0} unsigned) (@function.extfun_app.{2 1} Type group.{0} h0 (measurable_space.dynkin_system.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_97458 (h0 : topological_space (has_div enat)) : t0_space (has_div enat) := sorry --non-trivial
lemma new_lemma_97459 (h0 : functor.add_const (topological_space (semigroup pos)) environment.implicit_infer_kind) : @t1_space.{0} (semigroup.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (semigroup.{0} pos)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_97460 (h0 : function.extfun Type cancel_comm_monoid_with_zero) : @unique_factorization_monoid.{0} (mul_zero_class.{0} num) (@function.extfun_app.{2 1} Type cancel_comm_monoid_with_zero.{0} h0 (mul_zero_class.{0} num))  := sorry --non-trivial
lemma new_lemma_97461 (h0 : function.extfun (Type 1) semiring) : @is_noetherian_ring.{1} (canonically_ordered_comm_semiring.{1} Type) (@function.extfun_app.{3 2} (Type 1) semiring.{1} h0 (canonically_ordered_comm_semiring.{1} Type))  := sorry --non-trivial
lemma new_lemma_97462 (h0 : ring (ordered_comm_ring (has_neg (has_neg name)))) : rank_condition (ordered_comm_ring (has_neg (has_neg name))) := sorry --non-trivial
lemma new_lemma_97463 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : filter.ne_bot (function.extfun_app (function.extfun_app h0 filter) (linear_ordered_field ennreal)) := sorry --non-trivial
lemma new_lemma_97464 (h0 : functor.add_const Prop (canonically_linear_ordered_monoid Type)) : functor.add_const.run h0 := sorry --non-trivial
lemma new_lemma_97465 (h0 : topological_space (linear_ordered_comm_ring (semiring (semiring unsigned)))) : totally_separated_space (linear_ordered_comm_ring (semiring (semiring unsigned))) := sorry --non-trivial
lemma new_lemma_97466 (h0 : uniform_space (normed_linear_ordered_group (option empty))) : complete_space (normed_linear_ordered_group (option empty)) := sorry --non-trivial
lemma new_lemma_97467 (h0 : function.extfun Type group) : @group.fg.{0} (has_norm.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type group.{0} h0 (has_norm.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_97468 (h0 : topological_space (linear_order empty)) : normal_space (linear_order empty) := sorry --non-trivial
lemma new_lemma_97469 (h0 : functor.add_const (topological_space (normed_comm_ring environment.implicit_infer_kind)) Type) : @t0_space.{0} (normed_comm_ring.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 1} (topological_space.{0} (normed_comm_ring.{0} environment.implicit_infer_kind)) Type h0)  := sorry --non-trivial
lemma new_lemma_97470 (h1 : topological_space (with_bot linarith.comp_source)) : irreducible_space (with_bot linarith.comp_source) := sorry --non-trivial
lemma new_lemma_97471 (h0 : complete_lattice (has_neg_part (boolean_algebra name))) : is_compactly_generated (has_neg_part (boolean_algebra name)) := sorry --non-trivial
lemma new_lemma_97472 (h0 : uniform_space (option congr_arg_kind)) : separated_space (option congr_arg_kind) := sorry --non-trivial
lemma new_lemma_97473 (h0 : function.extfun Type monoid) : @monoid.fg.{0} (has_Inf.{0} linarith.comp) (@function.extfun_app.{2 1} Type monoid.{0} h0 (has_Inf.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_97474 (h0 : monoid (canonically_ordered_comm_semiring (finset linarith.comp))) : monoid.fg (canonically_ordered_comm_semiring (finset linarith.comp)) := sorry --non-trivial
lemma new_lemma_97475 (h0 : topological_space (has_add Type)) : preirreducible_space (has_add Type) := sorry --non-trivial
lemma new_lemma_97476 (h0 : functor.add_const (topological_space (has_zero pos)) linarith.comp) : @locally_compact_space.{0} (has_zero.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (has_zero.{0} pos)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_97477 (h0 : uniform_space (has_to_string (option (option (option ennreal))))) : complete_space (has_to_string (option (option (option ennreal)))) := sorry --non-trivial
lemma new_lemma_97478 (h0 : function.extfun Type uniform_space) : @separated_space.{0} (random_gen.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (random_gen.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_97479 (h0 : topological_space (free_add_monoid unsigned)) : normal_space (free_add_monoid unsigned) := sorry --non-trivial
lemma new_lemma_97480 (h0 : uniform_space (ordered_comm_monoid (has_neg linarith.comp))) : separated_space (ordered_comm_monoid (has_neg linarith.comp)) := sorry --non-trivial
lemma new_lemma_97481 (h0 : uniform_space (has_nnnorm (mul_one_class ereal))) : complete_space (has_nnnorm (mul_one_class ereal)) := sorry --non-trivial
lemma new_lemma_97482 (h0 : topological_space (omega_complete_partial_order empty)) : t0_space (omega_complete_partial_order empty) := sorry --non-trivial
lemma new_lemma_97483 (h1 : not (ring (encodable string_imp) -> false)) : @strong_rank_condition.{0} (encodable.{0} string_imp) (@classical.by_contradiction'.{1} (ring.{0} (encodable.{0} string_imp)) h1)  := sorry --non-trivial
lemma new_lemma_97484 (h0 : topological_space (cancel_monoid (semigroup (boolean_algebra.core (comm_group linarith.comp))))) : preconnected_space (cancel_monoid (semigroup (boolean_algebra.core (comm_group linarith.comp)))) := sorry --non-trivial
lemma new_lemma_97485 (h0 : functor.comp monoid has_add Type) : @monoid.fg.{1} (has_add.{1} Type) (@functor.comp.run.{1 1 1} monoid.{1} has_add.{1} Type h0)  := sorry --non-trivial
lemma new_lemma_97486 (h1 : function.extfun Type add_group) : @is_add_cyclic.{0} (has_norm.{0} fun_info) (@function.extfun_app.{2 1} Type add_group.{0} h1 (has_norm.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_97487 (h0 : functor.add_const (topological_space (bin_tree unsigned)) empty) : @topological_space.separable_space.{0} (bin_tree.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (bin_tree.{0} unsigned)) empty h0)  := sorry --non-trivial
lemma new_lemma_97488 (h0 : topological_space (has_norm (random_gen fun_info))) : locally_compact_space (has_norm (random_gen fun_info)) := sorry --non-trivial
lemma new_lemma_97489 (h0 : functor.add_const (topological_space (add_comm_monoid name)) Type) : @discrete_topology.{0} (add_comm_monoid.{0} name) (@functor.add_const.run.{0 1} (topological_space.{0} (add_comm_monoid.{0} name)) Type h0)  := sorry --non-trivial
lemma new_lemma_97490 (h0 : ordered_comm_monoid (add_comm_monoid ennreal)) : has_exists_mul_of_le (add_comm_monoid ennreal) := sorry --non-trivial
lemma new_lemma_97491 (h0 : topological_space (comm_group pos)) : preconnected_space (comm_group pos) := sorry --non-trivial
lemma new_lemma_97492 (h0 : semiring (add_cancel_monoid (finset (finset environment.implicit_infer_kind)))) : is_noetherian_ring (add_cancel_monoid (finset (finset environment.implicit_infer_kind))) := sorry --non-trivial
lemma new_lemma_97493 (h1 : has_lift (add_cancel_comm_monoid (has_nnnorm char)) Prop) (h2 : add_cancel_comm_monoid (has_nnnorm char)) : @lift.{1 1} (add_cancel_comm_monoid.{0} (has_nnnorm.{0} char)) Prop h1 h2  := sorry --non-trivial
lemma new_lemma_97494 (h1 : add_group (linear_ordered_add_comm_group string_imp)) : is_add_cyclic (linear_ordered_add_comm_group string_imp) := sorry --non-trivial
lemma new_lemma_97495 (h0 : functor.add_const (add_group (complete_distrib_lattice pos)) environment.implicit_infer_kind) : @is_add_cyclic.{0} (complete_distrib_lattice.{0} pos) (@functor.add_const.run.{0 0} (add_group.{0} (complete_distrib_lattice.{0} pos)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_97496 (h0 : topological_space (semigroup (has_Inf Type))) : loc_path_connected_space (semigroup (has_Inf Type)) := sorry --non-trivial
lemma new_lemma_97497 (h0 : uniform_space (linear_ordered_comm_group_with_zero (mul_one_class linarith.comp_source))) : complete_space (linear_ordered_comm_group_with_zero (mul_one_class linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_97498 (h0 : function.extfun Type topological_space) : @path_connected_space.{0} (option.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (option.{0} empty))  := sorry --non-trivial
lemma new_lemma_97499 (h0 : uniform_space (simple_graph (finset (finset Type)))) : separated_space (simple_graph (finset (finset Type))) := sorry --non-trivial
lemma new_lemma_97500 (h0 : monoid (generalized_boolean_algebra (has_Inf Type))) : monoid.fg (generalized_boolean_algebra (has_Inf Type)) := sorry --non-trivial
lemma new_lemma_97501 (h0 : functor.add_const (semiring (ordered_comm_ring linarith.comp)) Type) : @is_noetherian_ring.{0} (ordered_comm_ring.{0} linarith.comp) (@functor.add_const.run.{0 1} (semiring.{0} (ordered_comm_ring.{0} linarith.comp)) Type h0)  := sorry --non-trivial
lemma new_lemma_97502 (h0 : not (add_group (denumerable (has_nnnorm linarith.comp_source)) -> false)) : @is_add_cyclic.{0} (denumerable.{0} (has_nnnorm.{0} linarith.comp_source)) (@classical.by_contradiction'.{1} (add_group.{0} (denumerable.{0} (has_nnnorm.{0} linarith.comp_source))) h0)  := sorry --non-trivial
lemma new_lemma_97503 (h0 : complete_lattice (left_cancel_monoid num)) : is_compactly_generated (left_cancel_monoid num) := sorry --non-trivial
lemma new_lemma_97504 (h0 : ordered_add_comm_monoid (has_dist (option (option (option (option num)))))) : archimedean (has_dist (option (option (option (option num))))) := sorry --non-trivial
lemma new_lemma_97505 (h0 : complete_lattice (distrib (has_compl std_gen))) : is_compactly_generated (distrib (has_compl std_gen)) := sorry --non-trivial
lemma new_lemma_97506 (h0 : add_group (linear_ordered_comm_ring (semiring (semiring empty)))) : is_add_cyclic (linear_ordered_comm_ring (semiring (semiring empty))) := sorry --non-trivial
lemma new_lemma_97507 (h0 : not (function.extfun Type group -> false)) : @is_cyclic.{0} (random_gen.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type group.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type group.{0}) h0) (random_gen.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_97508 (h3 : group (comm_ring char)) : is_cyclic (comm_ring char) := sorry --non-trivial
lemma new_lemma_97509 (h0 : functor.add_const (topological_space (has_Sup congr_arg_kind)) congr_arg_kind) : @totally_separated_space.{0} (has_Sup.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (has_Sup.{0} congr_arg_kind)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_97510 (h0 : topological_space (plift (semiring congr_arg_kind))) : irreducible_space (plift (semiring congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_97511 (h0 : ring (has_nndist (comm_group name))) : rank_condition (has_nndist (comm_group name)) := sorry --non-trivial
lemma new_lemma_97512 (h0 : functor.add_const (complete_lattice (sub_neg_monoid congr_arg_kind)) unsigned) : @complete_lattice.is_Sup_finite_compact.{0} (sub_neg_monoid.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (complete_lattice.{0} (sub_neg_monoid.{0} congr_arg_kind)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_97513 (h0 : function.extfun Type cancel_comm_monoid_with_zero) : @unique_factorization_monoid.{0} (canonically_ordered_monoid.{0} pos) (@function.extfun_app.{2 1} Type cancel_comm_monoid_with_zero.{0} h0 (canonically_ordered_monoid.{0} pos))  := sorry --non-trivial
lemma new_lemma_97514 (h0 : uniform_space (mul_zero_class (finset pos))) : separated_space (mul_zero_class (finset pos)) := sorry --non-trivial
lemma new_lemma_97515 (h0 : filter (linear_ordered_field name)) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_97516 (h0 : functor.add_const (add_group (boolean_algebra linarith.comp)) (has_pos_part (has_Inf Type))) : @is_add_cyclic.{0} (boolean_algebra.{0} linarith.comp) (@functor.add_const.run.{0 1} (add_group.{0} (boolean_algebra.{0} linarith.comp)) (has_pos_part.{1} (has_Inf.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_97517 (h1 : function.extfun Type uniform_space) : separated_space empty := sorry --non-trivial
lemma new_lemma_97518 (h0 : ring (has_dist (option (option (option (option (option empty))))))) : is_domain (has_dist (option (option (option (option (option empty)))))) := sorry --non-trivial
lemma new_lemma_97519 (h0 : add_monoid (ordered_comm_ring (finset Type))) : add_monoid.fg (ordered_comm_ring (finset Type)) := sorry --non-trivial
lemma new_lemma_97520 (h0 : monoid (finset (ring (add_right_cancel_monoid linarith.comp)))) : monoid.fg (finset (ring (add_right_cancel_monoid linarith.comp))) := sorry --non-trivial
lemma new_lemma_97521 (h0 : not (has_mem.mem (measurable_space linarith.ineq) has_emptyc.emptyc -> false)) : @complete_space.{0} (measurable_space.{0} linarith.ineq) (@finset.pi.empty.{1 0} Type uniform_space.{0} (measurable_space.{0} linarith.ineq) (@classical.by_contradiction'.{0} (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (measurable_space.{0} linarith.ineq) (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))) h0))  := sorry --non-trivial
lemma new_lemma_97522 (h0 : function.extfun Type ring) : @is_principal_ideal_ring.{0} (simple_graph.{0} linarith.comp) (@function.extfun_app.{2 1} Type ring.{0} h0 (simple_graph.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_97523 (h0 : topological_space (has_zero (option unsigned))) : t1_space (has_zero (option unsigned)) := sorry --non-trivial
lemma new_lemma_97524 (h0 : not (has_mem.mem (has_top linarith.comp_source) has_emptyc.emptyc -> false)) : @totally_disconnected_space.{0} (has_top.{0} linarith.comp_source) (@finset.pi.empty.{1 0} Type topological_space.{0} (has_top.{0} linarith.comp_source) (@classical.by_contradiction'.{0} (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (has_top.{0} linarith.comp_source) (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))) h0))  := sorry --non-trivial
lemma new_lemma_97525 (h0 : topological_space (option pos)) : discrete_topology (option pos) := sorry --non-trivial
lemma new_lemma_97526 (h0 : functor.add_const (filter (preorder unsigned)) unsigned) : filter.ne_bot (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_97527 (h0 : set (has_nnnorm fun_info)) : set.finite h0 := sorry --non-trivial
lemma new_lemma_97528 (h0 : not (has_mem.mem (with_bot to_additive.value_type) has_emptyc.emptyc -> false)) : @normalizer_condition.{0} (with_bot.{0} to_additive.value_type) (@finset.pi.empty.{1 0} Type group.{0} (with_bot.{0} to_additive.value_type) (@classical.by_contradiction'.{0} (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (with_bot.{0} to_additive.value_type) (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))) h0))  := sorry --non-trivial
lemma new_lemma_97529 (h0 : add_monoid (add_comm_semigroup enat)) (h2 : has_one (add_comm_semigroup enat)) : char_zero (add_comm_semigroup enat) := sorry --non-trivial
lemma new_lemma_97530 (h0 : function.extfun Type monoid) : @monoid.fg.{0} (add_comm_monoid.{0} pos) (@function.extfun_app.{2 1} Type monoid.{0} h0 (add_comm_monoid.{0} pos))  := sorry --non-trivial
lemma new_lemma_97531 (h0 : group (add_semigroup congr_arg_kind)) : is_cyclic (add_semigroup congr_arg_kind) := sorry --non-trivial
lemma new_lemma_97532 (h0 : topological_space (has_neg (has_to_string unsigned))) : topological_space.separable_space (has_neg (has_to_string unsigned)) := sorry --non-trivial
lemma new_lemma_97533 (h0 : functor.add_const (topological_space (option name)) (option pos)) : @preconnected_space.{0} (option.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (option.{0} name)) (option.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_97534 (h0 : functor.add_const (ring (preorder num)) unsigned) : @is_principal_ideal_ring.{0} (preorder.{0} num) (@functor.add_const.run.{0 0} (ring.{0} (preorder.{0} num)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_97535 (h0 : functor.add_const (function.extfun (Type 1) topological_space) name) : @totally_separated_space.{1} (simple_graph.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) topological_space.{1}) name h0) (simple_graph.{1} Type))  := sorry --non-trivial
lemma new_lemma_97536 (h0 : not (cancel_comm_monoid_with_zero (mul_zero_class congr_arg_kind) -> false)) : @unique_factorization_monoid.{0} (mul_zero_class.{0} congr_arg_kind) (@classical.by_contradiction'.{1} (cancel_comm_monoid_with_zero.{0} (mul_zero_class.{0} congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_97537 (h0 : ring (distrib enat)) : rank_condition (distrib enat) := sorry --non-trivial
lemma new_lemma_97538 (h0 : functor.add_const (group (add_comm_monoid pos)) linarith.comp) : @normalizer_condition.{0} (add_comm_monoid.{0} pos) (@functor.add_const.run.{0 0} (group.{0} (add_comm_monoid.{0} pos)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_97539 (h0 : function.extfun (finset Type) (has_mem.mem unsigned)) : @monoid.fg.{0} unsigned (@finset.pi.empty.{1 0} Type monoid.{0} unsigned (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) unsigned) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_97540 (h0 : topological_space (comm_group (boolean_algebra name))) : t1_space (comm_group (boolean_algebra name)) := sorry --non-trivial
lemma new_lemma_97541 (h0 : topological_space (boolean_algebra (has_Inf (ring (finset (has_Inf (has_Inf Type))))))) : discrete_topology (boolean_algebra (has_Inf (ring (finset (has_Inf (has_Inf Type)))))) := sorry --non-trivial
lemma new_lemma_97542 (h0 : function.extfun Type ring) : @strong_rank_condition.{0} (@id.{2} Type empty) (@function.extfun_app.{2 1} Type ring.{0} h0 (@id.{2} Type empty))  := sorry --non-trivial
lemma new_lemma_97543 (h0 : filter (comm_group (has_add unsigned))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_97544 (h1 : complete_lattice (normed_field string_imp)) : complete_lattice.is_Sup_finite_compact (normed_field string_imp) := sorry --non-trivial
lemma new_lemma_97545 (h0 : ring (topological_space (has_ssubset string_imp))) : strong_rank_condition (topological_space (has_ssubset string_imp)) := sorry --non-trivial
lemma new_lemma_97546 (h0 : not (add_group (has_top num) -> false)) : @is_add_cyclic.{0} (has_top.{0} num) (@classical.by_contradiction'.{1} (add_group.{0} (has_top.{0} num)) h0)  := sorry --non-trivial
lemma new_lemma_97547 (h0 : monoid (has_union (normed_group linarith.comp))) : monoid.fg (has_union (normed_group linarith.comp)) := sorry --non-trivial
lemma new_lemma_97548 (h0 : not (topological_space (metric_space empty) -> false)) : @t0_space.{0} (metric_space.{0} empty) (@classical.by_contradiction'.{1} (topological_space.{0} (metric_space.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_97549 (h0 : group (has_pos_part (has_nnnorm (has_nnnorm (random_gen (has_nnnorm (dlist linarith.ineq))))))) : is_cyclic (has_pos_part (has_nnnorm (has_nnnorm (random_gen (has_nnnorm (dlist linarith.ineq)))))) := sorry --non-trivial
lemma new_lemma_97550 (h0 : list (has_nndist environment.implicit_infer_kind)) : palindrome h0 := sorry --non-trivial
lemma new_lemma_97551 (h0 : list (canonically_linear_ordered_monoid num)) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_97552 (h0 : complete_lattice (random_gen reducibility_hints)) : is_compactly_generated (random_gen reducibility_hints) := sorry --non-trivial
lemma new_lemma_97553 (h0 : cancel_comm_monoid_with_zero (ordered_comm_monoid (has_pos_part pos))) : unique_factorization_monoid (ordered_comm_monoid (has_pos_part pos)) := sorry --non-trivial
lemma new_lemma_97554 (h0 : complete_lattice (semiring linarith.comp_source)) : is_compactly_generated (semiring linarith.comp_source) := sorry --non-trivial
lemma new_lemma_97555 (h0 : functor.add_const (ring (add_comm_monoid Type)) name) : @rank_condition.{1} (add_comm_monoid.{1} Type) (@functor.add_const.run.{1 0} (ring.{1} (add_comm_monoid.{1} Type)) name h0)  := sorry --non-trivial
lemma new_lemma_97556 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @monoid.fg.{0} (measurable_space.{0} (has_top.{0} (has_top.{0} (has_top.{0} (has_top.{0} (has_top.{0} (has_top.{0} fun_info))))))) (@function.extfun_app.{2 1} Type monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 monoid.{0}) (measurable_space.{0} (has_top.{0} (has_top.{0} (has_top.{0} (has_top.{0} (has_top.{0} (has_top.{0} fun_info))))))))  := sorry --non-trivial
lemma new_lemma_97557 (h0 : functor.add_const (ordered_add_comm_monoid (monoid unsigned)) empty) : @archimedean.{0} (monoid.{0} unsigned) (@functor.add_const.run.{0 0} (ordered_add_comm_monoid.{0} (monoid.{0} unsigned)) empty h0)  := sorry --non-trivial
lemma new_lemma_97558 (h0 : add_monoid (comm_semigroup (sub_neg_monoid (sub_neg_monoid Type)))) : add_monoid.fg (comm_semigroup (sub_neg_monoid (sub_neg_monoid Type))) := sorry --non-trivial
lemma new_lemma_97559 (h1 : uniform_space (with_bot (has_top linarith.comp_source))) : complete_space (with_bot (has_top linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_97560 (h0 : ordered_add_comm_monoid (has_inner empty (option (option empty)))) : archimedean (has_inner empty (option (option empty))) := sorry --non-trivial
lemma new_lemma_97561 (h0 : topological_space (linear_ordered_semiring (semiring (linear_ordered_semiring empty)))) : normal_space (linear_ordered_semiring (semiring (linear_ordered_semiring empty))) := sorry --non-trivial
lemma new_lemma_97562 (h0 : not (has_mem.mem Type has_emptyc.emptyc -> false)) : @group.fg.{1} Type (@finset.pi.empty.{2 1} (Type 1) group.{1} Type (@classical.by_contradiction'.{0} (@has_mem.mem.{2 2} (Type 1) (finset.{2} (Type 1)) (@finset.has_mem.{2} (Type 1)) Type (@has_emptyc.emptyc.{2} (finset.{2} (Type 1)) (@finset.has_emptyc.{2} (Type 1)))) h0))  := sorry --non-trivial
lemma new_lemma_97563 (h0 : complete_lattice (comm_group (option ennreal))) : is_compactly_generated (comm_group (option ennreal)) := sorry --non-trivial
lemma new_lemma_97564 (h0 : group (uniform_space (normed_field reducibility_hints))) : is_cyclic (uniform_space (normed_field reducibility_hints)) := sorry --non-trivial
lemma new_lemma_97565 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @totally_disconnected_space.{0} (has_to_string.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_to_string.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_97566 (h0 : functor.add_const (finset (measurable_space.dynkin_system empty)) unsigned) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_97567 (h0 : filter (dlist (comm_ring linarith.ineq))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_97568 (h0 : topological_space (linear_ordered_semiring linarith.comp)) : irreducible_space (linear_ordered_semiring linarith.comp) := sorry --non-trivial
lemma new_lemma_97569 (h0 : finset Prop) (h1 : finset.nonempty h0) : @finset.min'.{0} Prop Prop.linear_order h0 h1  := sorry --non-trivial
lemma new_lemma_97570 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_noetherian_ring.{0} (measurable_space.dynkin_system.{0} linarith.comp) (@function.extfun_app.{2 1} Type semiring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 semiring.{0}) (measurable_space.dynkin_system.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_97571 (h0 : function.extfun Type topological_space) : @path_connected_space.{0} (normed_comm_ring.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (normed_comm_ring.{0} empty))  := sorry --non-trivial
lemma new_lemma_97572 (h0 : uniform_space (cancel_monoid (boolean_algebra Type))) : separated_space (cancel_monoid (boolean_algebra Type)) := sorry --non-trivial
lemma new_lemma_97573 (h0 : topological_space (boolean_algebra (has_neg (has_neg (has_neg (has_neg linarith.comp)))))) : totally_disconnected_space (boolean_algebra (has_neg (has_neg (has_neg (has_neg linarith.comp))))) := sorry --non-trivial
lemma new_lemma_97574 (h0 : group (has_to_string (add_comm_monoid (ring pos)))) : is_simple_group (has_to_string (add_comm_monoid (ring pos))) := sorry --non-trivial
lemma new_lemma_97575 (h0 : has_mem.mem (linear_ordered_semiring congr_arg_kind) has_emptyc.emptyc) : @is_atomistic.{0} (linear_ordered_semiring.{0} congr_arg_kind) (@finset.pi.empty.{1 0} Type complete_lattice.{0} (linear_ordered_semiring.{0} congr_arg_kind) h0)  := sorry --non-trivial
lemma new_lemma_97576 (h0 : fin has_zero.zero) : @archimedean.{0} (normed_lattice_add_comm_group.{0} pos) (@matrix.vec_empty.{0} (ordered_add_comm_monoid.{0} (normed_lattice_add_comm_group.{0} pos)) h0)  := sorry --non-trivial
lemma new_lemma_97577 (h0 : monoid (boolean_algebra (semigroup name))) : monoid.fg (boolean_algebra (semigroup name)) := sorry --non-trivial
lemma new_lemma_97578 (h0 : complete_lattice (has_nndist (ring (has_neg (has_neg pos))))) : is_compactly_generated (has_nndist (ring (has_neg (has_neg pos)))) := sorry --non-trivial
lemma new_lemma_97579 (h0 : topological_space (ring (option pos))) : preconnected_space (ring (option pos)) := sorry --non-trivial
lemma new_lemma_97580 (h0 : ordered_comm_monoid (cancel_monoid (has_add Type))) : has_exists_mul_of_le (cancel_monoid (has_add Type)) := sorry --non-trivial
lemma new_lemma_97581 (h0 : ring (has_compl (mul_one_class (has_compl to_additive.value_type)))) : strong_rank_condition (has_compl (mul_one_class (has_compl to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_97582 (h0 : functor.add_const (function.extfun Type add_monoid) Type) : @add_monoid.fg.{0} (add_comm_monoid.{0} linarith.comp) (@function.extfun_app.{2 1} Type add_monoid.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type add_monoid.{0}) Type h0) (add_comm_monoid.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_97583 (h0 : complete_lattice (has_ssubset (mul_one_class ereal))) : complete_lattice.is_Sup_finite_compact (has_ssubset (mul_one_class ereal)) := sorry --non-trivial
lemma new_lemma_97584 (h0 : function.extfun Type topological_space) : @topological_space.separable_space.{0} (ordered_comm_ring.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (ordered_comm_ring.{0} pos))  := sorry --non-trivial
lemma new_lemma_97585 (h0 : functor.add_const (ring (has_Inf linarith.comp)) (has_Inf linarith.comp)) : @strong_rank_condition.{0} (has_Inf.{0} linarith.comp) (@functor.add_const.run.{0 0} (ring.{0} (has_Inf.{0} linarith.comp)) (has_Inf.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_97586 (h0 : functor.add_const (group (has_neg_part Type)) pos) : @normalizer_condition.{1} (has_neg_part.{1} Type) (@functor.add_const.run.{1 0} (group.{1} (has_neg_part.{1} Type)) pos h0)  := sorry --non-trivial
lemma new_lemma_97587 (h0 : functor.add_const (topological_space (group_with_zero ennreal)) num) : @irreducible_space.{0} (group_with_zero.{0} ennreal) (@functor.add_const.run.{0 0} (topological_space.{0} (group_with_zero.{0} ennreal)) num h0)  := sorry --non-trivial
lemma new_lemma_97588 (h0 : topological_space (linear_ordered_field (option unsigned))) : topological_space.separable_space (linear_ordered_field (option unsigned)) := sorry --non-trivial
lemma new_lemma_97589 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_add_cyclic.{0} (has_bot.{0} name) (@function.extfun_app.{2 1} Type add_group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 add_group.{0}) (has_bot.{0} name))  := sorry --non-trivial
lemma new_lemma_97590 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @locally_compact_space.{0} (simple_graph.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (simple_graph.{0} name))  := sorry --non-trivial
lemma new_lemma_97591 (h0 : ordered_comm_monoid (sub_neg_monoid (has_add linarith.comp))) : has_exists_mul_of_le (sub_neg_monoid (has_add linarith.comp)) := sorry --non-trivial
lemma new_lemma_97592 (h0 : filter (finset (comm_group ennreal))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_97593 (h0 : not (add_group (has_star congr_arg_kind) -> false)) : @is_add_cyclic.{0} (has_star.{0} congr_arg_kind) (@classical.by_contradiction'.{1} (add_group.{0} (has_star.{0} congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_97594 (h0 : list (linear_ordered_add_comm_group (random_gen (with_bot to_additive.value_type)))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_97595 (h0 : group (non_assoc_semiring (semiring empty))) : normalizer_condition (non_assoc_semiring (semiring empty)) := sorry --non-trivial
lemma new_lemma_97596 (h0 : topological_space (has_one (semiring (has_norm (semiring congr_arg_kind))))) : discrete_topology (has_one (semiring (has_norm (semiring congr_arg_kind)))) := sorry --non-trivial
lemma new_lemma_97597 (h1 : not (functor.comp add_group has_append string_imp -> false)) : @is_add_cyclic.{0} (has_append.{0} string_imp) (@functor.comp.run.{0 0 0} add_group.{0} has_append.{0} string_imp (@classical.by_contradiction'.{1} (functor.comp.{0 0 0} add_group.{0} has_append.{0} string_imp) h1))  := sorry --non-trivial
lemma new_lemma_97598 (h0 : ring (normed_comm_ring (has_nndist (finset Type)))) : strong_rank_condition (normed_comm_ring (has_nndist (finset Type))) := sorry --non-trivial
lemma new_lemma_97599 (h0 : functor.add_const (topological_space (ring Type)) Type) : @preirreducible_space.{1} (ring.{1} Type) (@functor.add_const.run.{1 1} (topological_space.{1} (ring.{1} Type)) Type h0)  := sorry --non-trivial
lemma new_lemma_97600 (h0 : function.extfun Type group) : @is_cyclic.{0} (monoid.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type group.{0} h0 (monoid.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_97601 (h0 : functor.add_const (list (semigroup Type)) (comm_group Type)) : list.nodup (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_97602 (h0 : not (topological_space (option unsigned) -> false)) : @locally_compact_space.{0} (option.{0} unsigned) (@classical.by_contradiction'.{1} (topological_space.{0} (option.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_97603 (h0 : functor.add_const (ordered_add_comm_monoid (simple_graph pos)) name) : @archimedean.{0} (simple_graph.{0} pos) (@functor.add_const.run.{0 0} (ordered_add_comm_monoid.{0} (simple_graph.{0} pos)) name h0)  := sorry --non-trivial
lemma new_lemma_97604 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @locally_compact_space.{1} (canonically_ordered_comm_semiring.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 topological_space.{1}) (canonically_ordered_comm_semiring.{1} Type))  := sorry --non-trivial
lemma new_lemma_97605 (h0 : function.extfun Type topological_space) : @topological_space.separable_space.{0} (cancel_monoid.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (cancel_monoid.{0} num))  := sorry --non-trivial
lemma new_lemma_97606 (h0 : functor.add_const (function.extfun Type list) (ring linarith.comp)) : palindrome (function.extfun_app (functor.add_const.run h0) (add_comm_monoid name)) := sorry --non-trivial
lemma new_lemma_97607 (h0 : has_mem.mem (random_gen to_additive.value_type) has_emptyc.emptyc) : @path_connected_space.{0} (random_gen.{0} to_additive.value_type) (@finset.pi.empty.{1 0} Type topological_space.{0} (random_gen.{0} to_additive.value_type) h0)  := sorry --non-trivial
lemma new_lemma_97608 (h0 : measurable_space (add_comm_semigroup reducibility_hints)) (h1 : filter (add_comm_semigroup reducibility_hints)) : filter.is_measurably_generated h1 := sorry --non-trivial
lemma new_lemma_97609 (h0 : function.extfun Type ring) : @strong_rank_condition.{0} (semiring.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type ring.{0} h0 (semiring.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_97610 (h0 : functor.add_const (topological_space (add_cancel_monoid name)) Type) : @normal_space.{0} (add_cancel_monoid.{0} name) (@functor.add_const.run.{0 1} (topological_space.{0} (add_cancel_monoid.{0} name)) Type h0)  := sorry --non-trivial
lemma new_lemma_97611 (h0 : not (function.extfun Type group -> false)) : @is_cyclic.{0} (denumerable.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type group.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type group.{0}) h0) (denumerable.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_97612 (h0 : add_comm_group nnreal) (h1 : has_norm nnreal) : normed_group.core nnreal := sorry --non-trivial
lemma new_lemma_97613 (h0 : function.extfun Type group) : @normalizer_condition.{0} (non_assoc_semiring.{0} unsigned) (@function.extfun_app.{2 1} Type group.{0} h0 (non_assoc_semiring.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_97614 (h0 : topological_space (has_neg (has_neg_part (finset pos)))) : discrete_topology (has_neg (has_neg_part (finset pos))) := sorry --non-trivial
lemma new_lemma_97615 (h0 : complete_lattice (add_comm_monoid (comm_group (comm_group pos)))) : complete_lattice.is_Sup_finite_compact (add_comm_monoid (comm_group (comm_group pos))) := sorry --non-trivial
lemma new_lemma_97616 (h0 : functor.add_const (topological_space (ordered_comm_ring Type)) Type) : @totally_separated_space.{1} (ordered_comm_ring.{1} Type) (@functor.add_const.run.{1 1} (topological_space.{1} (ordered_comm_ring.{1} Type)) Type h0)  := sorry --non-trivial
lemma new_lemma_97617 (h0 : topological_space (linear_ordered_add_comm_group (random_gen string_imp))) : path_connected_space (linear_ordered_add_comm_group (random_gen string_imp)) := sorry --non-trivial
lemma new_lemma_97618 (h0 : ring (has_add (sub_neg_monoid pos))) : is_domain (has_add (sub_neg_monoid pos)) := sorry --non-trivial
lemma new_lemma_97619 (h0 : function.extfun Type topological_space) : @discrete_topology.{0} (comm_semigroup.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (comm_semigroup.{0} name))  := sorry --non-trivial
lemma new_lemma_97620 (h4 : uniform_space (has_nnnorm (random_gen (random_gen linarith.ineq)))) : complete_space (has_nnnorm (random_gen (random_gen linarith.ineq))) := sorry --non-trivial
lemma new_lemma_97621 (h0 : uniform_space (complete_distrib_lattice (has_bot (has_bot (has_bot real))))) : complete_space (complete_distrib_lattice (has_bot (has_bot (has_bot real)))) := sorry --non-trivial
lemma new_lemma_97622 (h0 : monoid (normed_comm_ring (option unsigned))) : monoid.fg (normed_comm_ring (option unsigned)) := sorry --non-trivial
lemma new_lemma_97623 (h0 : topological_space (canonically_ordered_comm_semiring (has_neg (has_neg name)))) : loc_path_connected_space (canonically_ordered_comm_semiring (has_neg (has_neg name))) := sorry --non-trivial
lemma new_lemma_97624 (h0 : functor.add_const (topological_space (finset linarith.comp)) name) : @normal_space.{0} (finset.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (finset.{0} linarith.comp)) name h0)  := sorry --non-trivial
lemma new_lemma_97625 (h0 : uniform_space (free_add_monoid empty)) : separated_space (free_add_monoid empty) := sorry --non-trivial
lemma new_lemma_97626 (h0 : topological_space (has_top (has_top (has_top empty)))) : normal_space (has_top (has_top (has_top empty))) := sorry --non-trivial
lemma new_lemma_97627 (h0 : topological_space (id (semiring linarith.comp))) : irreducible_space (id (semiring linarith.comp)) := sorry --non-trivial
lemma new_lemma_97628 (h0 : functor.add_const (ordered_add_comm_monoid (bin_tree unsigned)) (option unsigned)) : @archimedean.{0} (bin_tree.{0} unsigned) (@functor.add_const.run.{0 0} (ordered_add_comm_monoid.{0} (bin_tree.{0} unsigned)) (option.{0} unsigned) h0)  := sorry --non-trivial
lemma new_lemma_97629 (h0 : function.extfun Type list) : palindrome (function.extfun_app h0 (boolean_algebra.core environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_97630 (h0 : functor.add_const (list (add_cancel_monoid pos)) linarith.comp) : palindrome (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_97631 (h0 : ring (finset (ordered_comm_ring (has_Inf (ordered_comm_ring Type))))) : is_principal_ideal_ring (finset (ordered_comm_ring (has_Inf (ordered_comm_ring Type)))) := sorry --non-trivial
lemma new_lemma_97632 (h0 : functor.add_const (monoid ennreal) congr_arg_kind) : monoid.fg ennreal := sorry --non-trivial
lemma new_lemma_97633 (h0 : topological_space (add_cancel_comm_monoid string.iterator_imp)) : t0_space (add_cancel_comm_monoid string.iterator_imp) := sorry --non-trivial
lemma new_lemma_97634 (h0 : semiring (nondiscrete_normed_field reducibility_hints)) (h1 : ideal (nondiscrete_normed_field reducibility_hints)) : ideal.is_prime h1 := sorry --non-trivial
lemma new_lemma_97635 (h0 : function.extfun Type topological_space) : @discrete_topology.{0} (linear_ordered_semiring.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (linear_ordered_semiring.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_97636 (h0 : not (complete_lattice (uniform_space (uniform_space string_imp)) -> false)) : is_compactly_generated (uniform_space (uniform_space string_imp)) := sorry --non-trivial
lemma new_lemma_97637 (h0 : group (add_cancel_monoid congr_arg_kind)) : group.fg (add_cancel_monoid congr_arg_kind) := sorry --non-trivial
lemma new_lemma_97638 (h0 : functor.add_const (function.extfun Type topological_space) pos) : @preconnected_space.{0} (ring.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) pos h0) (ring.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_97639 (h0 : topological_space (has_emptyc (random_gen fun_info))) : totally_disconnected_space (has_emptyc (random_gen fun_info)) := sorry --non-trivial
lemma new_lemma_97640 (h0 : functor.add_const (filter (finset environment.implicit_infer_kind)) Type) : countable_Inter_filter (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_97641 (h0 : ring (dlist string_imp)) : rank_condition (dlist string_imp) := sorry --non-trivial
lemma new_lemma_97642 : @trace_call_stack.{0} Prop (@is_of_fin_order.{0} unit (@ring.to_monoid.{0} unit (@normed_ring.to_ring.{0} unit (@normed_comm_ring.to_normed_ring.{0} unit punit.normed_comm_ring.{0}))))  := sorry --non-trivial
lemma new_lemma_97643 (h0 : functor.add_const (topological_space (has_to_string pos)) (has_neg Type)) : @irreducible_space.{0} (has_to_string.{0} pos) (@functor.add_const.run.{0 1} (topological_space.{0} (has_to_string.{0} pos)) (has_neg.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_97644 (h0 : ring (option (option unsigned))) : rank_condition (option (option unsigned)) := sorry --non-trivial
lemma new_lemma_97645 (h0 : filter (with_zero linarith.comp_source)) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_97646 (h0 : functor.add_const (ring (boolean_algebra Type)) Type) : @rank_condition.{1} (boolean_algebra.{1} Type) (@functor.add_const.run.{1 1} (ring.{1} (boolean_algebra.{1} Type)) Type h0)  := sorry --non-trivial
lemma new_lemma_97647 (h0 : function.extfun ((Type -> Type) -> Type 1) (function.extfun (Type -> Type))) : @is_cyclic.{0} auto.case_option (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) (@function.extfun_app.{3 2} ((Type → Type) → Type 1) (function.extfun.{2 2} (Type → Type)) h0 (function.extfun.{2 1} Type)) group.{0}) auto.case_option)  := sorry --non-trivial
lemma new_lemma_97648 (h0 : filter (has_norm (random_gen (random_gen (random_gen (random_gen (random_gen fun_info))))))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_97649 (h0 : topological_space (has_top (has_norm linarith.comp_source))) : totally_disconnected_space (has_top (has_norm linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_97650 (h0 : finset (complete_linear_order (semiring empty))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_97651 (h1 : topological_space (nondiscrete_normed_field reducibility_hints)) : totally_disconnected_space (nondiscrete_normed_field reducibility_hints) := sorry --non-trivial
lemma new_lemma_97652 (h0 : functor.add_const (ring (has_zero ennreal)) pos) : @is_principal_ideal_ring.{0} (has_zero.{0} ennreal) (@functor.add_const.run.{0 0} (ring.{0} (has_zero.{0} ennreal)) pos h0)  := sorry --non-trivial
lemma new_lemma_97653 (h0 : ring (distrib real.angle)) : rank_condition (distrib real.angle) := sorry --non-trivial
lemma new_lemma_97654 (h0 : function.extfun Type topological_space) : @totally_separated_space.{0} (has_union.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_union.{0} empty))  := sorry --non-trivial
lemma new_lemma_97655 (h0 : function.extfun Type group) : @is_cyclic.{0} (canonically_linear_ordered_monoid.{0} pos) (@function.extfun_app.{2 1} Type group.{0} h0 (canonically_linear_ordered_monoid.{0} pos))  := sorry --non-trivial
lemma new_lemma_97656 (h0 : function.extfun Type topological_space) : @normal_space.{0} (normed_comm_ring.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (normed_comm_ring.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_97657 (h0 : functor.add_const (filter auto.case_option) num -> Prop) (h1 : Exists (fun (x : functor.add_const (filter auto.case_option) num), h0 x)) : filter.ne_bot (functor.add_const.run (classical.some h1)) := sorry --non-trivial
lemma new_lemma_97658 (h0 : topological_space (ordered_comm_ring (has_bot (has_bot (sub_neg_monoid (has_bot pos)))))) : normal_space (ordered_comm_ring (has_bot (has_bot (sub_neg_monoid (has_bot pos))))) := sorry --non-trivial
lemma new_lemma_97659 (h0 : topological_space (ring (boolean_algebra (has_Inf (has_pos_part Type))))) : totally_disconnected_space (ring (boolean_algebra (has_Inf (has_pos_part Type)))) := sorry --non-trivial
lemma new_lemma_97660 (h0 : has_mem.mem empty has_emptyc.emptyc) : @group.fg.{0} empty (@finset.pi.empty.{1 0} Type group.{0} empty h0)  := sorry --non-trivial
lemma new_lemma_97661 (h0 : functor.add_const (list (boolean_algebra pos)) pos) : palindrome (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_97662 (h1 : uniform_space (topological_space (fintype (denumerable char)))) : complete_space (topological_space (fintype (denumerable char))) := sorry --non-trivial
lemma new_lemma_97663 (h2 : complete_lattice string.iterator_imp) : complete_lattice.is_Sup_finite_compact string.iterator_imp := sorry --non-trivial
lemma new_lemma_97664 (h0 : topological_space (ordered_comm_ring name)) : discrete_topology (ordered_comm_ring name) := sorry --non-trivial
lemma new_lemma_97665 (h0 : topological_space (complete_semilattice_Sup (random_gen fun_info))) : t0_space (complete_semilattice_Sup (random_gen fun_info)) := sorry --non-trivial
lemma new_lemma_97666 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @normal_space.{0} (random_gen.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (random_gen.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_97667 (h0 : topological_space (has_add (ring linarith.comp))) : locally_compact_space (has_add (ring linarith.comp)) := sorry --non-trivial
lemma new_lemma_97668 (h0 : functor.add_const (function.extfun Type uniform_space) pos) : @complete_space.{0} pos (@function.extfun_app.{2 1} Type uniform_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type uniform_space.{0}) pos h0) pos)  := sorry --non-trivial
lemma new_lemma_97669 (h0 : ring (has_top (has_inv to_additive.value_type))) : rank_condition (has_top (has_inv to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_97670 (h0 : topological_space (ordered_cancel_add_comm_monoid (option ennreal))) : totally_separated_space (ordered_cancel_add_comm_monoid (option ennreal)) := sorry --non-trivial
lemma new_lemma_97671 (h0 : topological_space (semigroup congr_arg_kind)) : locally_compact_space (semigroup congr_arg_kind) := sorry --non-trivial
lemma new_lemma_97672 (h0 : topological_space (has_div (mul_one_class string_imp))) : path_connected_space (has_div (mul_one_class string_imp)) := sorry --non-trivial
lemma new_lemma_97673 (h0 : complete_lattice (normed_comm_ring environment.implicit_infer_kind)) : complete_lattice.is_Sup_finite_compact (normed_comm_ring environment.implicit_infer_kind) := sorry --non-trivial
lemma new_lemma_97674 (h0 : function.extfun Type topological_space) : @t0_space.{0} (linear_ordered_comm_group.{0} ennreal) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (linear_ordered_comm_group.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_97675 (h0 : filter (finset (option unsigned))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_97676 (h0 : has_lt linarith.ineq) : no_max_order linarith.ineq := sorry --non-trivial
lemma new_lemma_97677 (h0 : list (boolean_algebra (finset (finset (has_pos_part (has_Inf (has_pos_part Type))))))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_97678 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @discrete_topology.{0} (with_one.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (with_one.{0} empty))  := sorry --non-trivial
lemma new_lemma_97679 (h0 : add_group (complete_semilattice_Sup (has_norm to_additive.value_type))) : is_add_cyclic (complete_semilattice_Sup (has_norm to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_97680 (h0 : ring (has_nndist pos)) : is_principal_ideal_ring (has_nndist pos) := sorry --non-trivial
lemma new_lemma_97681 (h0 : functor.add_const (function.extfun (Type 1) topological_space) environment.implicit_infer_kind) : @totally_separated_space.{1} (has_nndist.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) topological_space.{1}) environment.implicit_infer_kind h0) (has_nndist.{1} Type))  := sorry --non-trivial
lemma new_lemma_97682 (h0 : complete_lattice (cancel_monoid (has_add name))) : is_atomistic (cancel_monoid (has_add name)) := sorry --non-trivial
lemma new_lemma_97683 (h0 : complete_lattice (has_inner empty empty)) : complete_lattice.is_Sup_finite_compact (has_inner empty empty) := sorry --non-trivial
lemma new_lemma_97684 (h0 : functor.add_const (topological_space (complete_distrib_lattice environment.implicit_infer_kind)) Type) : @regular_space.{0} (complete_distrib_lattice.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 1} (topological_space.{0} (complete_distrib_lattice.{0} environment.implicit_infer_kind)) Type h0)  := sorry --non-trivial
lemma new_lemma_97685 (h0 : add_group (has_add (sub_neg_monoid real))) : is_add_cyclic (has_add (sub_neg_monoid real)) := sorry --non-trivial
lemma new_lemma_97686 (h0 : monoid (random_gen (random_gen congr_arg_kind))) : monoid.fg (random_gen (random_gen congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_97687 (h0 : function.extfun Type (functor.add_const (ring (add_cancel_monoid empty)))) : @strong_rank_condition.{0} (add_cancel_monoid.{0} empty) (@functor.add_const.run.{0 0} (ring.{0} (add_cancel_monoid.{0} empty)) unsigned (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (ring.{0} (add_cancel_monoid.{0} empty))) h0 unsigned))  := sorry --non-trivial
lemma new_lemma_97688 (h0 : functor.add_const (functor.add_const (filter Type) linarith.comp) unsigned) : countable_Inter_filter (functor.add_const.run (functor.add_const.run h0)) := sorry --non-trivial
lemma new_lemma_97689 (h0 : add_group (random_gen (random_gen (random_gen (random_gen (random_gen num)))))) : is_add_cyclic (random_gen (random_gen (random_gen (random_gen (random_gen num))))) := sorry --non-trivial
lemma new_lemma_97690 (h0 : topological_space (comm_group (cancel_monoid pos))) : totally_separated_space (comm_group (cancel_monoid pos)) := sorry --non-trivial
lemma new_lemma_97691 (h0 : functor.add_const (ordered_add_comm_monoid (finset Type)) Type) : @archimedean.{1} (finset.{1} Type) (@functor.add_const.run.{1 1} (ordered_add_comm_monoid.{1} (finset.{1} Type)) Type h0)  := sorry --non-trivial
lemma new_lemma_97692 (h0 : function.extfun Type group) : @is_cyclic.{0} (simple_graph.{0} unsigned) (@function.extfun_app.{2 1} Type group.{0} h0 (simple_graph.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_97693 (h0 : complete_lattice (with_one (semiring num))) : complete_lattice.is_Sup_finite_compact (with_one (semiring num)) := sorry --non-trivial
lemma new_lemma_97694 (h0 : fin has_zero.zero) : @normalizer_condition.{0} (canonically_linear_ordered_monoid.{0} real) (@function.extfun_app.{2 1} Type group.{0} (@matrix.vec_empty.{1} (function.extfun.{2 1} Type group.{0}) h0) (canonically_linear_ordered_monoid.{0} real))  := sorry --non-trivial
lemma new_lemma_97695 (h0 : semiring (generalized_boolean_algebra (sub_neg_monoid (sub_neg_monoid real)))) : is_noetherian_ring (generalized_boolean_algebra (sub_neg_monoid (sub_neg_monoid real))) := sorry --non-trivial
lemma new_lemma_97696 (h0 : topological_space (semi_normed_ring (has_ssubset char))) : path_connected_space (semi_normed_ring (has_ssubset char)) := sorry --non-trivial
lemma new_lemma_97697 (h0 : function.extfun Type group) : @group.fg.{0} (filter.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type group.{0} h0 (filter.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_97698 (h0 : add_group (with_zero linarith.comp_source)) : is_add_cyclic (with_zero linarith.comp_source) := sorry --non-trivial
lemma new_lemma_97699 (h1 h2 : multiset (nondiscrete_normed_field fun_info)) : multiset.subset h1 h2 := sorry --non-trivial
lemma new_lemma_97700 (h0 : functor.add_const (ring (ring environment.implicit_infer_kind)) Type) : @is_domain.{0} (ring.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 1} (ring.{0} (ring.{0} environment.implicit_infer_kind)) Type h0)  := sorry --non-trivial
lemma new_lemma_97701 (h0 : add_monoid (nondiscrete_normed_field (add_comm_semigroup char))) (h1 : nondiscrete_normed_field (add_comm_semigroup char)) : is_add_unit h1 := sorry --non-trivial
lemma new_lemma_97702 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @archimedean.{0} auto.case_option (@function.extfun_app.{2 1} Type ordered_add_comm_monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ordered_add_comm_monoid.{0}) auto.case_option)  := sorry --non-trivial
lemma new_lemma_97703 (h0 : topological_space (partial_order (semiring (semiring congr_arg_kind)))) : t0_space (partial_order (semiring (semiring congr_arg_kind))) := sorry --non-trivial
lemma new_lemma_97704 (h0 : topological_space (random_gen (has_norm linarith.ineq))) : totally_disconnected_space (random_gen (has_norm linarith.ineq)) := sorry --non-trivial
lemma new_lemma_97705 (h0 : functor.add_const (topological_space (has_neg_part pos)) name) : @loc_path_connected_space.{0} (has_neg_part.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (has_neg_part.{0} pos)) name h0)  := sorry --non-trivial
lemma new_lemma_97706 (h0 : rel char (fun_info -> char)) (h1 : set char) : set.separates_points (rel.image h0 h1) := sorry --non-trivial
lemma new_lemma_97707 (h0 : topological_space (semigroup pos)) : irreducible_space (semigroup pos) := sorry --non-trivial
lemma new_lemma_97708 (h0 : functor.add_const (topological_space (normed_comm_ring pos)) (has_pos_part pos)) : @discrete_topology.{0} (normed_comm_ring.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (normed_comm_ring.{0} pos)) (has_pos_part.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_97709 (h0 : topological_space (has_union (semiring congr_arg_kind))) : discrete_topology (has_union (semiring congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_97710 (h0 : topological_space (has_to_string (has_nndist environment.implicit_infer_kind))) : path_connected_space (has_to_string (has_nndist environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_97711 (h3 : has_lt (mul_one_class char)) : no_max_order (mul_one_class char) := sorry --non-trivial
lemma new_lemma_97712 (h0 : not (topological_space (measure_theory.measure_space unsigned) -> false)) : @t0_space.{0} (measure_theory.measure_space.{0} unsigned) (@classical.by_contradiction'.{1} (topological_space.{0} (measure_theory.measure_space.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_97713 (h0 : functor.add_const (topological_space (finset linarith.comp)) linarith.comp) : @sequential_space.{0} (finset.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (finset.{0} linarith.comp)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_97714 (h0 : fin has_zero.zero) : @topological_space.separable_space.{1} (canonically_ordered_monoid.{1} Type) (@matrix.vec_empty.{1} (topological_space.{1} (canonically_ordered_monoid.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_97715 (h0 : uniform_space (pseudo_metric_space (option (option empty)))) : separated_space (pseudo_metric_space (option (option empty))) := sorry --non-trivial
lemma new_lemma_97716 (h0 : functor.add_const (topological_space (cancel_monoid linarith.comp)) name) : @locally_compact_space.{0} (cancel_monoid.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (cancel_monoid.{0} linarith.comp)) name h0)  := sorry --non-trivial
lemma new_lemma_97717 (h0 : group (semigroup (finset (has_neg (ring (ring (ring (has_nndist linarith.comp)))))))) : is_simple_group (semigroup (finset (has_neg (ring (ring (ring (has_nndist linarith.comp))))))) := sorry --non-trivial
lemma new_lemma_97718 (h1 : semiring reducibility_hints) (h2 : ideal reducibility_hints) : ideal.is_prime h2 := sorry --non-trivial
lemma new_lemma_97719 (h0 : topological_space (has_top fun_info)) : locally_compact_space (has_top fun_info) := sorry --non-trivial
lemma new_lemma_97720 (h0 : empty -> congr_arg_kind -> congr_arg_kind) : left_commutative h0 := sorry --non-trivial
lemma new_lemma_97721 (h0 : fin has_zero.zero) : @totally_disconnected_space.{0} (normed_lattice_add_comm_group.{0} real) (@matrix.vec_empty.{0} (topological_space.{0} (normed_lattice_add_comm_group.{0} real)) h0)  := sorry --non-trivial
lemma new_lemma_97722 (h0 : functor.add_const (topological_space (is_R_or_C empty)) (semiring empty)) : @t0_space.{0} (is_R_or_C.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (is_R_or_C.{0} empty)) (semiring.{0} empty) h0)  := sorry --non-trivial
lemma new_lemma_97723 (h1 : add_group (dlist fun_info)) : is_add_cyclic (dlist fun_info) := sorry --non-trivial
lemma new_lemma_97724 (h0 : not (function.extfun Type topological_space -> false)) : @totally_disconnected_space.{0} (normed_group.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (normed_group.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_97725 (h0 : topological_space (metric_space (has_norm (has_norm (semiring unsigned))))) : normal_space (metric_space (has_norm (has_norm (semiring unsigned)))) := sorry --non-trivial
lemma new_lemma_97726 (h0 : uniform_space (add_left_cancel_semigroup empty)) : complete_space (add_left_cancel_semigroup empty) := sorry --non-trivial
lemma new_lemma_97727 (h0 : add_group (add_monoid char)) : is_add_cyclic (add_monoid char) := sorry --non-trivial
lemma new_lemma_97728 (h0 : list (boolean_algebra name)) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_97729 (h0 : topological_space (add_group (semiring linarith.comp))) : path_connected_space (add_group (semiring linarith.comp)) := sorry --non-trivial
lemma new_lemma_97730 (h0 : ring (has_ssubset (mul_one_class fun_info))) : is_domain (has_ssubset (mul_one_class fun_info)) := sorry --non-trivial
lemma new_lemma_97731 (h0 : function.extfun (Type -> Type) (function.extfun Type)) (h1 : topological_space (group_with_zero linarith.comp)) : @Inf_convergence_class.{0} (group_with_zero.{0} linarith.comp) (@function.extfun_app.{2 1} Type preorder.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 preorder.{0}) (group_with_zero.{0} linarith.comp)) h1  := sorry --non-trivial
lemma new_lemma_97732 (h0 : cancel_comm_monoid_with_zero (has_pos_part real)) : unique_factorization_monoid (has_pos_part real) := sorry --non-trivial
lemma new_lemma_97733 (h0 : add_monoid (ordered_comm_group (option (option (option (option empty)))))) : add_monoid.fg (ordered_comm_group (option (option (option (option empty))))) := sorry --non-trivial
lemma new_lemma_97734 (h0 : functor.add_const (function.extfun Type complete_lattice) Type) : @complete_lattice.is_Sup_finite_compact.{0} (has_add.{0} pos) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type complete_lattice.{0}) Type h0) (has_add.{0} pos))  := sorry --non-trivial
lemma new_lemma_97735 (h0 : functor.add_const (group (has_neg linarith.comp)) (normed_comm_ring linarith.comp)) : @is_simple_group.{0} (has_neg.{0} linarith.comp) (@functor.add_const.run.{0 0} (group.{0} (has_neg.{0} linarith.comp)) (normed_comm_ring.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_97736 (h0 : functor.add_const (ring (comm_group name)) pos) : @is_domain.{0} (comm_group.{0} name) (@functor.add_const.run.{0 0} (ring.{0} (comm_group.{0} name)) pos h0)  := sorry --non-trivial
lemma new_lemma_97737 (h0 : ring (has_nnnorm (mul_one_class (mul_one_class string.iterator_imp)))) : rank_condition (has_nnnorm (mul_one_class (mul_one_class string.iterator_imp))) := sorry --non-trivial
lemma new_lemma_97738 (h1 h2 : multiset (nondiscrete_normed_field linarith.ineq)) : multiset.disjoint h1 h2 := sorry --non-trivial
lemma new_lemma_97739 (h0 : complete_lattice (ordered_comm_monoid real)) : is_atomistic (ordered_comm_monoid real) := sorry --non-trivial
lemma new_lemma_97740 (h0 : group (mul_zero_class ennreal)) : is_cyclic (mul_zero_class ennreal) := sorry --non-trivial
lemma new_lemma_97741 (h0 : topological_space (has_top congr_arg_kind)) : path_connected_space (has_top congr_arg_kind) := sorry --non-trivial
lemma new_lemma_97742 (h1 : ring (distrib char)) : is_domain (distrib char) := sorry --non-trivial
lemma new_lemma_97743 (h0 : monoid (comm_group name)) : monoid.fg (comm_group name) := sorry --non-trivial
lemma new_lemma_97744 (h0 : topological_space string.iterator_imp) : topological_space.first_countable_topology string.iterator_imp := sorry --non-trivial
lemma new_lemma_97745 (h0 : finset (ordered_ring (option (option (option (option ennreal)))))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_97746 (h0 : not (ring (has_compl reducibility_hints) -> false)) : @is_domain.{0} (has_compl.{0} reducibility_hints) (@classical.by_contradiction'.{1} (ring.{0} (has_compl.{0} reducibility_hints)) h0)  := sorry --non-trivial
lemma new_lemma_97747 (h0 : topological_space (ordered_comm_monoid (has_Inf linarith.comp))) : preirreducible_space (ordered_comm_monoid (has_Inf linarith.comp)) := sorry --non-trivial
lemma new_lemma_97748 (h0 : list (cancel_monoid (has_zero pos))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_97749 (h0 : topological_space (fintype string_imp)) : totally_disconnected_space (fintype string_imp) := sorry --non-trivial
lemma new_lemma_97750 (h0 : function.extfun Type group) : @is_cyclic.{0} (has_nndist.{0} (option.{0} empty)) (@function.extfun_app.{2 1} Type group.{0} h0 (has_nndist.{0} (option.{0} empty)))  := sorry --non-trivial
lemma new_lemma_97751 (h0 : has_mem.mem string_imp has_emptyc.emptyc) : @is_add_cyclic.{0} string_imp (@finset.pi.empty.{1 0} Type add_group.{0} string_imp h0)  := sorry --non-trivial
lemma new_lemma_97752 (h0 : cancel_comm_monoid_with_zero (has_add name)) : unique_factorization_monoid (has_add name) := sorry --non-trivial
lemma new_lemma_97753 (h0 : fin has_zero.zero) : @loc_path_connected_space.{1} (preorder.{1} Type) (@matrix.vec_empty.{1} (topological_space.{1} (preorder.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_97754 (h0 : has_scalar char enat) (h1 : has_scalar (mul_opposite char) enat) : is_central_scalar char enat := sorry --non-trivial
lemma new_lemma_97755 (h0 : topological_space (has_zero (option name))) : totally_disconnected_space (has_zero (option name)) := sorry --non-trivial
lemma new_lemma_97756 (h0 : functor.add_const (topological_space (has_zero linarith.comp)) Type) : @regular_space.{0} (has_zero.{0} linarith.comp) (@functor.add_const.run.{0 1} (topological_space.{0} (has_zero.{0} linarith.comp)) Type h0)  := sorry --non-trivial
lemma new_lemma_97757 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @group.fg.{0} (random_gen.{0} fun_info) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (random_gen.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_97758 (h0 : function.extfun Type monoid) : @monoid.fg.{0} (option.{0} empty) (@function.extfun_app.{2 1} Type monoid.{0} h0 (option.{0} empty))  := sorry --non-trivial
lemma new_lemma_97759 (h0 : functor.add_const (topological_space (has_neg_part unsigned)) pos) : @totally_disconnected_space.{0} (has_neg_part.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (has_neg_part.{0} unsigned)) pos h0)  := sorry --non-trivial
lemma new_lemma_97760 (h0 : topological_space (generalized_boolean_algebra (boolean_algebra.core (ring Type)))) : irreducible_space (generalized_boolean_algebra (boolean_algebra.core (ring Type))) := sorry --non-trivial
lemma new_lemma_97761 (h0 : topological_space (encodable fun_info)) : totally_disconnected_space (encodable fun_info) := sorry --non-trivial
lemma new_lemma_97762 (h0 : topological_space (boolean_algebra.core (has_add ennreal))) : preirreducible_space (boolean_algebra.core (has_add ennreal)) := sorry --non-trivial
lemma new_lemma_97763 (h0 : not (topological_space (dlist char) -> false)) : @t0_space.{0} (dlist.{0} char) (@classical.by_contradiction'.{1} (topological_space.{0} (dlist.{0} char)) h0)  := sorry --non-trivial
lemma new_lemma_97764 (h0 : functor.add_const (add_group (ordered_comm_ring name)) (finset pos)) : @is_add_cyclic.{0} (ordered_comm_ring.{0} name) (@functor.add_const.run.{0 0} (add_group.{0} (ordered_comm_ring.{0} name)) (finset.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_97765 (h0 : finset (finset (option num))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_97766 (h0 : functor.add_const (finset (has_zero linarith.comp)) environment.implicit_infer_kind) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_97767 (h0 : functor.add_const (topological_space (mul_zero_class congr_arg_kind)) unsigned) : @irreducible_space.{0} (mul_zero_class.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (mul_zero_class.{0} congr_arg_kind)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_97768 (h0 : group (has_nnnorm (metric_space (comm_ring linarith.ineq)))) : is_cyclic (has_nnnorm (metric_space (comm_ring linarith.ineq))) := sorry --non-trivial
lemma new_lemma_97769 (h0 : group (complete_distrib_lattice (has_pos_part Type))) : is_cyclic (complete_distrib_lattice (has_pos_part Type)) := sorry --non-trivial
lemma new_lemma_97770 (h0 : topological_space (boolean_algebra (has_add real))) : loc_path_connected_space (boolean_algebra (has_add real)) := sorry --non-trivial
lemma new_lemma_97771 (h0 : ring (has_top (pseudo_emetric_space linarith.ineq))) : rank_condition (has_top (pseudo_emetric_space linarith.ineq)) := sorry --non-trivial
lemma new_lemma_97772 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_atomistic.{0} to_additive.value_type (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) to_additive.value_type)  := sorry --non-trivial
lemma new_lemma_97773 (h0 : functor.add_const (ring (ring Type)) (has_neg Type)) : @is_domain.{1} (ring.{1} Type) (@functor.add_const.run.{1 1} (ring.{1} (ring.{1} Type)) (has_neg.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_97774 (h0 : has_lt string.iterator) : no_max_order string.iterator := sorry --non-trivial
lemma new_lemma_97775 (h0 : function.extfun Type complete_lattice) : @complete_lattice.is_Sup_finite_compact.{0} (linear_ordered_semiring.{0} num) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (linear_ordered_semiring.{0} num))  := sorry --non-trivial
lemma new_lemma_97776 (h0 : functor.add_const (list (has_nndist name)) Type) : palindrome (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_97777 (h0 : functor.add_const (topological_space (semigroup name)) (mul_zero_class Type)) : @totally_disconnected_space.{0} (semigroup.{0} name) (@functor.add_const.run.{0 1} (topological_space.{0} (semigroup.{0} name)) (mul_zero_class.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_97778 (h0 : function.extfun Type group) : @is_cyclic.{0} (simple_graph.{0} pos) (@function.extfun_app.{2 1} Type group.{0} h0 (simple_graph.{0} pos))  := sorry --non-trivial
lemma new_lemma_97779 (h0 : function.extfun Type complete_lattice) : @is_atomistic.{0} (omega_complete_partial_order.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (omega_complete_partial_order.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_97780 (h0 : group (ring (has_neg Type))) : is_cyclic (ring (has_neg Type)) := sorry --non-trivial
lemma new_lemma_97781 (h0 : topological_space (normed_group (has_norm unsigned))) : t0_space (normed_group (has_norm unsigned)) := sorry --non-trivial
lemma new_lemma_97782 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_add_cyclic.{0} (comm_group.{0} pos) (@function.extfun_app.{2 1} Type add_group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 add_group.{0}) (comm_group.{0} pos))  := sorry --non-trivial
lemma new_lemma_97783 (h0 : functor.add_const (function.extfun Type group) pos) : @group.fg.{0} (has_add.{0} name) (@function.extfun_app.{2 1} Type group.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type group.{0}) pos h0) (has_add.{0} name))  := sorry --non-trivial
lemma new_lemma_97784 (h0 : group (has_add real)) : is_simple_group (has_add real) := sorry --non-trivial
lemma new_lemma_97785 (h0 : topological_space (has_zero (has_add (ring (has_Inf linarith.comp))))) : discrete_topology (has_zero (has_add (ring (has_Inf linarith.comp)))) := sorry --non-trivial
lemma new_lemma_97786 (h0 : add_monoid (simple_graph (finset (finset (finset (finset linarith.comp)))))) : add_monoid.fg (simple_graph (finset (finset (finset (finset linarith.comp))))) := sorry --non-trivial
lemma new_lemma_97787 (h0 : ordered_comm_monoid (has_Inf (has_nndist (has_add (has_nndist (finset (has_nndist pos))))))) : has_exists_mul_of_le (has_Inf (has_nndist (has_add (has_nndist (finset (has_nndist pos)))))) := sorry --non-trivial
lemma new_lemma_97788 (h0 : fin has_zero.zero) : id (id (matrix.vec_empty h0)) := sorry --non-trivial
lemma new_lemma_97789 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @normal_space.{1} (boolean_algebra.core.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 topological_space.{1}) (boolean_algebra.core.{1} Type))  := sorry --non-trivial
lemma new_lemma_97790 (h0 : functor.add_const (filter (finset linarith.comp)) linarith.comp) : filter.ne_bot (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_97791 (h0 : multiset (topological_space (distrib_lattice char))) : @totally_disconnected_space.{0} (distrib_lattice.{0} char) (@multiset.inf.{0} (topological_space.{0} (distrib_lattice.{0} char)) (@lattice.to_semilattice_inf.{0} (topological_space.{0} (distrib_lattice.{0} char)) (@conditionally_complete_lattice.to_lattice.{0} (topological_space.{0} (distrib_lattice.{0} char)) (@complete_lattice.to_conditionally_complete_lattice.{0} (topological_space.{0} (distrib_lattice.{0} char)) (@topological_space.complete_lattice.{0} (distrib_lattice.{0} char))))) (@bounded_order.to_order_top.{0} (topological_space.{0} (distrib_lattice.{0} char)) (@preorder.to_has_le.{0} (topological_space.{0} (distrib_lattice.{0} char)) (@partial_order.to_preorder.{0} (topological_space.{0} (distrib_lattice.{0} char)) (@semilattice_inf.to_partial_order.{0} (topological_space.{0} (distrib_lattice.{0} char)) (@lattice.to_semilattice_inf.{0} (topological_space.{0} (distrib_lattice.{0} char)) (@conditionally_complete_lattice.to_lattice.{0} (topological_space.{0} (distrib_lattice.{0} char)) (@complete_lattice.to_conditionally_complete_lattice.{0} (topological_space.{0} (distrib_lattice.{0} char)) (@topological_space.complete_lattice.{0} (distrib_lattice.{0} char)))))))) (@complete_lattice.to_bounded_order.{0} (topological_space.{0} (distrib_lattice.{0} char)) (@topological_space.complete_lattice.{0} (distrib_lattice.{0} char)))) h0)  := sorry --non-trivial
lemma new_lemma_97792 (h0 : not (function.extfun Type add_group -> false)) : @is_add_cyclic.{0} (has_norm.{0} num) (@function.extfun_app.{2 1} Type add_group.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type add_group.{0}) h0) (has_norm.{0} num))  := sorry --non-trivial
lemma new_lemma_97793 (h0 : has_mem.mem (distrib (linear_ordered_add_comm_group (topological_space reducibility_hints))) has_emptyc.emptyc) : @rank_condition.{0} (distrib.{0} (linear_ordered_add_comm_group.{0} (topological_space.{0} reducibility_hints))) (@finset.pi.empty.{1 0} Type ring.{0} (distrib.{0} (linear_ordered_add_comm_group.{0} (topological_space.{0} reducibility_hints))) h0)  := sorry --non-trivial
lemma new_lemma_97794 (h0 : cancel_comm_monoid_with_zero (has_star num)) : unique_factorization_monoid (has_star num) := sorry --non-trivial
lemma new_lemma_97795 (h0 : ring (denumerable (has_ssubset (random_gen (has_ssubset to_additive.value_type))))) : strong_rank_condition (denumerable (has_ssubset (random_gen (has_ssubset to_additive.value_type)))) := sorry --non-trivial
lemma new_lemma_97796 (h0 : functor.add_const (ring (has_neg linarith.comp)) linarith.comp) : @rank_condition.{0} (has_neg.{0} linarith.comp) (@functor.add_const.run.{0 0} (ring.{0} (has_neg.{0} linarith.comp)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_97797 (h0 : functor.add_const (semiring (semiring congr_arg_kind)) congr_arg_kind) : @is_noetherian_ring.{0} (semiring.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (semiring.{0} (semiring.{0} congr_arg_kind)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_97798 (h0 : list (has_nndist congr_arg_kind)) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_97799 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @add_monoid.fg.{0} (boolean_algebra.{0} name) (@function.extfun_app.{2 1} Type add_monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 add_monoid.{0}) (boolean_algebra.{0} name))  := sorry --non-trivial
lemma new_lemma_97800 (h0 : not (function.extfun Type topological_space -> false)) : @discrete_topology.{0} (with_bot.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (with_bot.{0} num))  := sorry --non-trivial
lemma new_lemma_97801 (h0 : add_group (add_cancel_monoid (option (option (option (option (option empty))))))) : is_add_cyclic (add_cancel_monoid (option (option (option (option (option empty)))))) := sorry --non-trivial
lemma new_lemma_97802 (h0 : ring (has_lt (has_div string.iterator_imp))) : rank_condition (has_lt (has_div string.iterator_imp)) := sorry --non-trivial
lemma new_lemma_97803 (h0 : group (semigroup (has_add (has_ssubset pos)))) : normalizer_condition (semigroup (has_add (has_ssubset pos))) := sorry --non-trivial
lemma new_lemma_97804 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_domain.{0} (has_to_string.{0} empty) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (has_to_string.{0} empty))  := sorry --non-trivial
lemma new_lemma_97805 (h1 : ring (add_left_cancel_monoid char)) : is_domain (add_left_cancel_monoid char) := sorry --non-trivial
lemma new_lemma_97806 (h0 : has_mem.mem (random_gen num) has_emptyc.emptyc) : @is_cyclic.{0} (random_gen.{0} num) (@finset.pi.empty.{1 0} Type group.{0} (random_gen.{0} num) h0)  := sorry --non-trivial
lemma new_lemma_97807 (h0 : complete_lattice (with_one (measurable_space linarith.comp))) : complete_lattice.is_Sup_finite_compact (with_one (measurable_space linarith.comp)) := sorry --non-trivial
lemma new_lemma_97808 (h0 : function.extfun Type topological_space) : @locally_compact_space.{0} (has_star.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_star.{0} empty))  := sorry --non-trivial
lemma new_lemma_97809 (h1 : char -> char -> Prop) (h2 : ring (linear_ordered_add_comm_monoid (quot h1))) : strong_rank_condition (linear_ordered_add_comm_monoid (quot h1)) := sorry --non-trivial
lemma new_lemma_97810 (h0 : filter (boolean_algebra.core (has_to_string (has_to_string (has_to_string (has_to_string pos)))))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_97811 (h0 : group (has_Sup empty)) : group.fg (has_Sup empty) := sorry --non-trivial
lemma new_lemma_97812 (h0 : uniform_space (semi_normed_comm_ring enat)) : complete_space (semi_normed_comm_ring enat) := sorry --non-trivial
lemma new_lemma_97813 (h0 : complete_lattice (option (semiring empty))) : is_atomistic (option (semiring empty)) := sorry --non-trivial
lemma new_lemma_97814 (h1 : function.extfun (Type -> Type) (function.extfun Type)) : @is_cyclic.{0} (@id.{2} Type to_additive.value_type) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h1 group.{0}) (@id.{2} Type to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_97815 (h0 : filter (has_compl (has_nnnorm linarith.ineq))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_97816 (h0 : add_monoid (complete_linear_order (semiring unsigned))) : add_monoid.fg (complete_linear_order (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_97817 (h0 : ordered_add_comm_monoid (comm_group ennreal)) : archimedean (comm_group ennreal) := sorry --non-trivial
lemma new_lemma_97818 (h0 : filter (boolean_algebra.core (semigroup (cancel_monoid pos)))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_97819 (h0 : function.extfun Type topological_space) : @loc_path_connected_space.{0} (monoid_with_zero.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (monoid_with_zero.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_97820 (h0 : function.extfun Type ring) : @rank_condition.{0} (has_emptyc.{0} fun_info) (@function.extfun_app.{2 1} Type ring.{0} h0 (has_emptyc.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_97821 (h0 : topological_space linarith.comp) : irreducible_space linarith.comp := sorry --non-trivial
lemma new_lemma_97822 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_cyclic.{0} (with_one.{0} linarith.ineq) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (with_one.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_97823 (h0 : functor.add_const (function.extfun Type ring) Type) : @is_principal_ideal_ring.{0} (semigroup.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type ring.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type ring.{0}) Type h0) (semigroup.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_97824 (h0 : functor.add_const (topological_space (add_comm_monoid linarith.comp)) environment.implicit_infer_kind) : @loc_path_connected_space.{0} (add_comm_monoid.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (add_comm_monoid.{0} linarith.comp)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_97825 (h0 : uniform_space (semigroup (has_to_string name))) : separated_space (semigroup (has_to_string name)) := sorry --non-trivial
lemma new_lemma_97826 (h0 : function.extfun ((Type -> Type) -> Type 1) (function.extfun (Type -> Type))) : @monoid.fg.{0} (has_ssubset.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) (@function.extfun_app.{3 2} ((Type → Type) → Type 1) (function.extfun.{2 2} (Type → Type)) h0 (function.extfun.{2 1} Type)) monoid.{0}) (has_ssubset.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_97827 (h0 : functor.add_const (topological_space (normed_comm_ring name)) (option pos)) : @loc_path_connected_space.{0} (normed_comm_ring.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (normed_comm_ring.{0} name)) (option.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_97828 (h0 : topological_space (has_star num)) : preconnected_space (has_star num) := sorry --non-trivial
lemma new_lemma_97829 (h0 : functor.add_const (function.extfun Type topological_space) name) : @preirreducible_space.{0} (has_Inf.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) name h0) (has_Inf.{0} name))  := sorry --non-trivial
lemma new_lemma_97830 (h0 : topological_space (has_neg (option (option (option pos))))) : preirreducible_space (has_neg (option (option (option pos)))) := sorry --non-trivial
lemma new_lemma_97831 (h0 : functor.add_const (topological_space (semigroup linarith.comp)) (has_neg (ring (has_neg pos)))) : @path_connected_space.{0} (semigroup.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (semigroup.{0} linarith.comp)) (has_neg.{0} (ring.{0} (has_neg.{0} pos))) h0)  := sorry --non-trivial
lemma new_lemma_97832 (h0 : topological_space (comm_semigroup pos)) : t1_space (comm_semigroup pos) := sorry --non-trivial
lemma new_lemma_97833 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @totally_separated_space.{0} (simple_graph.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (simple_graph.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_97834 (h0 : add_group (random_gen (mul_one_class string_imp))) : is_add_cyclic (random_gen (mul_one_class string_imp)) := sorry --non-trivial
lemma new_lemma_97835 (h0 : group (ordered_comm_monoid (has_nnnorm (has_nnnorm (has_nnnorm (has_nnnorm char)))))) : is_cyclic (ordered_comm_monoid (has_nnnorm (has_nnnorm (has_nnnorm (has_nnnorm char))))) := sorry --non-trivial
lemma new_lemma_97836 (h0 : topological_space (normed_group (random_gen num))) : t0_space (normed_group (random_gen num)) := sorry --non-trivial
lemma new_lemma_97837 (h0 : filter (semigroup (finset (has_pos_part (has_pos_part (has_pos_part (has_to_string name))))))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_97838 (h0 : functor.add_const (topological_space (complete_distrib_lattice pos)) Type) : @loc_path_connected_space.{0} (complete_distrib_lattice.{0} pos) (@functor.add_const.run.{0 1} (topological_space.{0} (complete_distrib_lattice.{0} pos)) Type h0)  := sorry --non-trivial
lemma new_lemma_97839 (h0 : function.extfun (Type 1) topological_space) : @t0_space.{1} (has_nndist.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} h0 (has_nndist.{1} Type))  := sorry --non-trivial
lemma new_lemma_97840 (h0 : semiring (has_star (semiring (semiring (semiring empty))))) : is_noetherian_ring (has_star (semiring (semiring (semiring empty)))) := sorry --non-trivial
lemma new_lemma_97841 (h1 : topological_space (distrib_lattice to_additive.value_type)) : t0_space (distrib_lattice to_additive.value_type) := sorry --non-trivial
lemma new_lemma_97842 (h0 : functor.add_const (complete_lattice (ordered_ring num)) empty) : @complete_lattice.is_Sup_finite_compact.{0} (ordered_ring.{0} num) (@functor.add_const.run.{0 0} (complete_lattice.{0} (ordered_ring.{0} num)) empty h0)  := sorry --non-trivial
lemma new_lemma_97843 (h1 : group (id linarith.comp_source)) : is_cyclic (id linarith.comp_source) := sorry --non-trivial
lemma new_lemma_97844 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @add_monoid.fg.{1} (has_Inf.{1} Type) (@function.extfun_app.{3 2} (Type 1) add_monoid.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 add_monoid.{1}) (has_Inf.{1} Type))  := sorry --non-trivial
lemma new_lemma_97845 (h0 : topological_space (normed_comm_ring ennreal)) : t0_space (normed_comm_ring ennreal) := sorry --non-trivial
lemma new_lemma_97846 (h0 : not (topological_space (has_one num) -> false)) : @normal_space.{0} (has_one.{0} num) (@classical.by_contradiction'.{1} (topological_space.{0} (has_one.{0} num)) h0)  := sorry --non-trivial
lemma new_lemma_97847 (h0 : function.extfun (nat -> Type) (function.extfun nat)) : @sequential_space.{0} (normed_lattice_add_comm_group.{0} pos) (@matrix.vec_empty.{0} (topological_space.{0} (normed_lattice_add_comm_group.{0} pos)) (@function.extfun_app.{1 1} nat fin (@function.extfun_app.{2 1} (nat → Type) (function.extfun.{1 1} nat) h0 fin) (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_97848 (h0 : ring (metric_space (has_top linarith.comp))) : strong_rank_condition (metric_space (has_top linarith.comp)) := sorry --non-trivial
lemma new_lemma_97849 (h0 : complete_lattice (canonically_ordered_monoid (comm_semigroup real))) : complete_lattice.is_Sup_finite_compact (canonically_ordered_monoid (comm_semigroup real)) := sorry --non-trivial
lemma new_lemma_97850 (h0 : ereal -> ereal -> ereal) (h2 : ereal) : right_identity h0 h2 := sorry --non-trivial
lemma new_lemma_97851 (h0 : function.extfun Type uniform_space) : @separated_space.{0} (add_cancel_monoid.{0} pos) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (add_cancel_monoid.{0} pos))  := sorry --non-trivial
lemma new_lemma_97852 (h0 : topological_space (finset (has_add Type))) : path_connected_space (finset (has_add Type)) := sorry --non-trivial
lemma new_lemma_97853 (h0 : functor.add_const (topological_space (add_comm_monoid name)) Type) : @preirreducible_space.{0} (add_comm_monoid.{0} name) (@functor.add_const.run.{0 1} (topological_space.{0} (add_comm_monoid.{0} name)) Type h0)  := sorry --non-trivial
lemma new_lemma_97854 (h0 : complete_lattice (has_nndist (finset Type))) : is_atomistic (has_nndist (finset Type)) := sorry --non-trivial
lemma new_lemma_97855 (h0 : ordered_add_comm_monoid (has_zero (boolean_algebra (has_add pos)))) : archimedean (has_zero (boolean_algebra (has_add pos))) := sorry --non-trivial
lemma new_lemma_97856 (h0 : functor.add_const (ring (comm_group name)) name) : @is_domain.{0} (comm_group.{0} name) (@functor.add_const.run.{0 0} (ring.{0} (comm_group.{0} name)) name h0)  := sorry --non-trivial
lemma new_lemma_97857 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @locally_compact_space.{0} (ordered_cancel_add_comm_monoid.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (ordered_cancel_add_comm_monoid.{0} pos))  := sorry --non-trivial
lemma new_lemma_97858 (h0 : function.extfun (Type 1) group) : @group.fg.{1} (plift.{1} empty) (@function.extfun_app.{3 2} (Type 1) group.{1} h0 (plift.{1} empty))  := sorry --non-trivial
lemma new_lemma_97859 (h0 : function.extfun (finset (Type -> Type)) (has_mem.mem topological_space)) : @totally_separated_space.{0} (measurable_space.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) topological_space.{0} (@function.extfun_app.{2 0} (finset.{1} (Type → Type)) (@has_mem.mem.{1 1} (Type → Type) (finset.{1} (Type → Type)) (@finset.has_mem.{1} (Type → Type)) topological_space.{0}) h0 (@has_emptyc.emptyc.{1} (finset.{1} (Type → Type)) (@finset.has_emptyc.{1} (Type → Type))))) (measurable_space.{0} num))  := sorry --non-trivial
lemma new_lemma_97860 (h0 : complete_lattice (with_bot (has_top (has_top (has_top fun_info))))) : is_compactly_generated (with_bot (has_top (has_top (has_top fun_info)))) := sorry --non-trivial
lemma new_lemma_97861 (h0 : not (complete_lattice (normed_field to_additive.value_type) -> false)) : @complete_lattice.is_Sup_finite_compact.{0} (normed_field.{0} to_additive.value_type) (@classical.by_contradiction'.{1} (complete_lattice.{0} (normed_field.{0} to_additive.value_type)) h0)  := sorry --non-trivial
lemma new_lemma_97862 (h0 : uniform_space (boolean_algebra (ring pos))) : complete_space (boolean_algebra (ring pos)) := sorry --non-trivial
lemma new_lemma_97863 (h0 : not (group (linear_ordered_semiring unsigned) -> false)) : @is_cyclic.{0} (linear_ordered_semiring.{0} unsigned) (@classical.by_contradiction'.{1} (group.{0} (linear_ordered_semiring.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_97864 (h0 : functor.add_const (topological_space (has_add pos)) (finset linarith.comp)) : @normal_space.{0} (has_add.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (has_add.{0} pos)) (finset.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_97865 (h0 : fin has_zero.zero) : @is_cyclic.{0} (canonically_ordered_monoid.{0} pos) (@matrix.vec_empty.{0} (group.{0} (canonically_ordered_monoid.{0} pos)) h0)  := sorry --non-trivial
lemma new_lemma_97866 (h0 : function.extfun Type (functor.add_const (uniform_space (filter empty)))) : @complete_space.{0} (filter.{0} empty) (@functor.add_const.run.{0 0} (uniform_space.{0} (filter.{0} empty)) empty (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (uniform_space.{0} (filter.{0} empty))) h0 empty))  := sorry --non-trivial
lemma new_lemma_97867 (h0 : functor.add_const (ring (has_zero unsigned)) environment.implicit_infer_kind) : @is_domain.{0} (has_zero.{0} unsigned) (@functor.add_const.run.{0 0} (ring.{0} (has_zero.{0} unsigned)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_97868 (h0 : functor.add_const (list (has_neg_part name)) Type) : list.nodup (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_97869 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @discrete_topology.{0} (mul_zero_class.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (mul_zero_class.{0} pos))  := sorry --non-trivial
lemma new_lemma_97870 (h1 : has_lt ereal) : no_max_order ereal := sorry --non-trivial
lemma new_lemma_97871 (h0 : complete_lattice (has_Sup (option empty))) : is_atomistic (has_Sup (option empty)) := sorry --non-trivial
lemma new_lemma_97872 (h1 h2 : nat) (h3 : thunk Prop) : scope_trace h3 := sorry --non-trivial
lemma new_lemma_97873 (h0 : complete_lattice (with_one (has_top (has_top (has_norm (semiring linarith.comp)))))) : is_compactly_generated (with_one (has_top (has_top (has_norm (semiring linarith.comp))))) := sorry --non-trivial
lemma new_lemma_97874 (h0 : function.extfun Type ordered_add_comm_monoid) : @archimedean.{0} (has_bot.{0} unsigned) (@function.extfun_app.{2 1} Type ordered_add_comm_monoid.{0} h0 (has_bot.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_97875 (h0 : topological_space (distrib_lattice linarith.ineq)) : path_connected_space (distrib_lattice linarith.ineq) := sorry --non-trivial
lemma new_lemma_97876 (h0 : complete_lattice (has_zero (finset (finset name)))) : is_atomistic (has_zero (finset (finset name))) := sorry --non-trivial
lemma new_lemma_97877 (h0 : topological_space (ring pos)) : preconnected_space (ring pos) := sorry --non-trivial
lemma new_lemma_97878 (h0 : function.extfun Type add_monoid) : @add_monoid.fg.{0} (add_semigroup.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type add_monoid.{0} h0 (add_semigroup.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_97879 (h2 : ring (nondiscrete_normed_field reducibility_hints)) : strong_rank_condition (nondiscrete_normed_field reducibility_hints) := sorry --non-trivial
lemma new_lemma_97880 (h0 : functor.add_const (ordered_comm_monoid (ring linarith.comp)) name) : @has_exists_mul_of_le.{0} (ring.{0} linarith.comp) (@functor.add_const.run.{0 0} (ordered_comm_monoid.{0} (ring.{0} linarith.comp)) name h0)  := sorry --non-trivial
lemma new_lemma_97881 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @normal_space.{0} (pseudo_metric_space.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (pseudo_metric_space.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_97882 (h0 : ordered_add_comm_monoid (sub_neg_monoid real)) : archimedean (sub_neg_monoid real) := sorry --non-trivial
lemma new_lemma_97883 (h0 : add_monoid (has_top num)) : add_monoid.fg (has_top num) := sorry --non-trivial
lemma new_lemma_97884 (h0 : not (complete_lattice (has_emptyc congr_arg_kind) -> false)) : @is_compactly_generated.{0} (has_emptyc.{0} congr_arg_kind) (@classical.by_contradiction'.{1} (complete_lattice.{0} (has_emptyc.{0} congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_97885 (h0 : fin has_zero.zero) : @preconnected_space.{1} (sub_neg_monoid.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@matrix.vec_empty.{2} (function.extfun.{3 2} (Type 1) topological_space.{1}) h0) (sub_neg_monoid.{1} Type))  := sorry --non-trivial
lemma new_lemma_97886 (h1 : topological_space (distrib char)) : path_connected_space (distrib char) := sorry --non-trivial
lemma new_lemma_97887 (h0 : topological_space (has_zero (boolean_algebra linarith.comp))) : locally_compact_space (has_zero (boolean_algebra linarith.comp)) := sorry --non-trivial
lemma new_lemma_97888 (h0 : add_monoid (add_group (semiring (semiring unsigned)))) : add_monoid.fg (add_group (semiring (semiring unsigned))) := sorry --non-trivial
lemma new_lemma_97889 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @preconnected_space.{0} (mul_zero_class.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (mul_zero_class.{0} pos))  := sorry --non-trivial
lemma new_lemma_97890 (h0 : function.extfun Type group) : @normalizer_condition.{0} (monoid_with_zero.{0} unsigned) (@function.extfun_app.{2 1} Type group.{0} h0 (monoid_with_zero.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_97891 (h0 : functor.add_const (list (bin_tree empty)) empty) : list.nodup (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_97892 (h0 : topological_space (distrib_lattice linarith.comp_source)) : totally_separated_space (distrib_lattice linarith.comp_source) := sorry --non-trivial
lemma new_lemma_97893 (h0 : functor.add_const (add_monoid (mul_zero_class unsigned)) name) : @add_monoid.fg.{0} (mul_zero_class.{0} unsigned) (@functor.add_const.run.{0 0} (add_monoid.{0} (mul_zero_class.{0} unsigned)) name h0)  := sorry --non-trivial
lemma new_lemma_97894 (h0 : functor.comp topological_space semigroup Type) : @preirreducible_space.{1} (semigroup.{1} Type) (@functor.comp.run.{1 1 1} topological_space.{1} semigroup.{1} Type h0)  := sorry --non-trivial
lemma new_lemma_97895 (h0 : semiring (metric_space (has_norm empty))) : is_noetherian_ring (metric_space (has_norm empty)) := sorry --non-trivial
lemma new_lemma_97896 (h0 : uniform_space (has_nndist (comm_group (comm_group (has_to_string (has_neg_part Type)))))) : complete_space (has_nndist (comm_group (comm_group (has_to_string (has_neg_part Type))))) := sorry --non-trivial
lemma new_lemma_97897 (h0 : function.extfun Type group) : @is_cyclic.{0} (boolean_algebra.core.{0} pos) (@function.extfun_app.{2 1} Type group.{0} h0 (boolean_algebra.core.{0} pos))  := sorry --non-trivial
lemma new_lemma_97898 (h0 : function.extfun Type topological_space) : @preirreducible_space.{0} (canonically_ordered_comm_semiring.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (canonically_ordered_comm_semiring.{0} num))  := sorry --non-trivial
lemma new_lemma_97899 (h0 : ring (linear_ordered_semiring (has_top (has_norm (random_gen num))))) : is_domain (linear_ordered_semiring (has_top (has_norm (random_gen num)))) := sorry --non-trivial
lemma new_lemma_97900 (h0 : add_group (measure_theory.measure_space congr_arg_kind)) : is_add_cyclic (measure_theory.measure_space congr_arg_kind) := sorry --non-trivial
lemma new_lemma_97901 (h0 : functor.comp topological_space canonically_ordered_comm_semiring pos) : @totally_separated_space.{0} (canonically_ordered_comm_semiring.{0} pos) (@functor.comp.run.{0 0 0} topological_space.{0} canonically_ordered_comm_semiring.{0} pos h0)  := sorry --non-trivial
lemma new_lemma_97902 (h0 : group (linear_ordered_semiring (has_top num))) : group.fg (linear_ordered_semiring (has_top num)) := sorry --non-trivial
lemma new_lemma_97903 (h0 : not (topological_space (has_compl (uniform_space enat)) -> false)) : @t0_space.{0} (has_compl.{0} (uniform_space.{0} enat)) (@classical.by_contradiction'.{1} (topological_space.{0} (has_compl.{0} (uniform_space.{0} enat))) h0)  := sorry --non-trivial
lemma new_lemma_97904 (h0 : function.extfun Type complete_lattice) : @is_compactly_generated.{0} (complete_linear_order.{0} empty) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (complete_linear_order.{0} empty))  := sorry --non-trivial
lemma new_lemma_97905 (h0 : not (ring (add_group linarith.comp) -> false)) : @rank_condition.{0} (add_group.{0} linarith.comp) (@classical.by_contradiction'.{1} (ring.{0} (add_group.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_97906 (h0 : ordered_add_comm_monoid (ordered_comm_ring (has_Inf (finset (has_neg (has_neg linarith.comp)))))) : archimedean (ordered_comm_ring (has_Inf (finset (has_neg (has_neg linarith.comp))))) := sorry --non-trivial
lemma new_lemma_97907 (h0 : functor.add_const (topological_space (measurable_space.dynkin_system congr_arg_kind)) congr_arg_kind) : @preirreducible_space.{0} (measurable_space.dynkin_system.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (measurable_space.dynkin_system.{0} congr_arg_kind)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_97908 (h0 : has_mem.mem (linear_ordered_semiring congr_arg_kind) has_emptyc.emptyc) : @locally_compact_space.{0} (linear_ordered_semiring.{0} congr_arg_kind) (@finset.pi.empty.{1 0} Type topological_space.{0} (linear_ordered_semiring.{0} congr_arg_kind) h0)  := sorry --non-trivial
lemma new_lemma_97909 (h0 : semiring (canonically_linear_ordered_monoid empty)) : is_noetherian_ring (canonically_linear_ordered_monoid empty) := sorry --non-trivial
lemma new_lemma_97910 (h0 : complete_lattice (has_top char)) : is_compactly_generated (has_top char) := sorry --non-trivial
lemma new_lemma_97911 (h0 : topological_space (boolean_algebra (finset (finset environment.implicit_infer_kind)))) : locally_compact_space (boolean_algebra (finset (finset environment.implicit_infer_kind))) := sorry --non-trivial
lemma new_lemma_97912 (h0 : function.extfun Type complete_lattice) : @is_compactly_generated.{0} (semiring.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (semiring.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_97913 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @t0_space.{0} (has_union.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_union.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_97914 (h0 : functor.add_const (topological_space (has_neg environment.implicit_infer_kind)) linarith.comp) : @t0_space.{0} (has_neg.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (has_neg.{0} environment.implicit_infer_kind)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_97915 (h0 : function.extfun Type ring) : @strong_rank_condition.{0} (add_group.{0} empty) (@function.extfun_app.{2 1} Type ring.{0} h0 (add_group.{0} empty))  := sorry --non-trivial
lemma new_lemma_97916 (h0 : function.extfun Type list) : palindrome (function.extfun_app h0 (add_cancel_comm_monoid congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_97917 (h0 : topological_space (mul_zero_class (has_nndist name))) : totally_disconnected_space (mul_zero_class (has_nndist name)) := sorry --non-trivial
lemma new_lemma_97918 (h0 : functor.add_const (ordered_add_comm_monoid (semiring congr_arg_kind)) unsigned) : @archimedean.{0} (semiring.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (ordered_add_comm_monoid.{0} (semiring.{0} congr_arg_kind)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_97919 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_compactly_generated.{0} (semigroup.{0} ennreal) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (semigroup.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_97920 (h1 : monoid (with_bot string_imp)) : monoid.fg (with_bot string_imp) := sorry --non-trivial
lemma new_lemma_97921 (h0 : group (semigroup linarith.comp)) : is_cyclic (semigroup linarith.comp) := sorry --non-trivial
lemma new_lemma_97922 (h0 : functor.add_const (monoid (normed_comm_ring name)) (boolean_algebra.core Type)) : @monoid.fg.{0} (normed_comm_ring.{0} name) (@functor.add_const.run.{0 1} (monoid.{0} (normed_comm_ring.{0} name)) (boolean_algebra.core.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_97923 (h0 : function.extfun Type topological_space) : @discrete_topology.{0} (has_bot.{0} (semiring.{0} empty)) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_bot.{0} (semiring.{0} empty)))  := sorry --non-trivial
lemma new_lemma_97924 (h0 : not (filter (encodable string_imp) -> false)) : filter.ne_bot (classical.by_contradiction' h0) := sorry --non-trivial
lemma new_lemma_97925 (h0 : ring (has_to_string (has_neg Type))) : rank_condition (has_to_string (has_neg Type)) := sorry --non-trivial
lemma new_lemma_97926 (h0 : add_monoid (has_Inf (finset pos))) : add_monoid.fg (has_Inf (finset pos)) := sorry --non-trivial
lemma new_lemma_97927 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_domain.{0} (has_add.{0} linarith.comp) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (has_add.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_97928 (h0 : functor.add_const (topological_space (has_zero name)) pos) : @regular_space.{0} (has_zero.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (has_zero.{0} name)) pos h0)  := sorry --non-trivial
lemma new_lemma_97929 (h0 : functor.add_const (topological_space (simple_graph Type)) Type) : @preirreducible_space.{1} (simple_graph.{1} Type) (@functor.add_const.run.{1 1} (topological_space.{1} (simple_graph.{1} Type)) Type h0)  := sorry --non-trivial
lemma new_lemma_97930 (h0 : not (function.extfun (Type -> Type) (function.extfun Type) -> false)) : @complete_space.{0} (measurable_space.{0} empty) (@function.extfun_app.{2 1} Type uniform_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) (@classical.by_contradiction'.{2} (function.extfun.{2 2} (Type → Type) (function.extfun.{2 1} Type)) h0) uniform_space.{0}) (measurable_space.{0} empty))  := sorry --non-trivial
lemma new_lemma_97931 (h0 : functor.comp ring finset ennreal) : @strong_rank_condition.{0} (finset.{0} ennreal) (@functor.comp.run.{0 0 0} ring.{0} finset.{0} ennreal h0)  := sorry --non-trivial
lemma new_lemma_97932 (h0 : complete_lattice (normed_field environment.projection_info)) : is_compactly_generated (normed_field environment.projection_info) := sorry --non-trivial
lemma new_lemma_97933 (h0 : ring (filter num)) : is_domain (filter num) := sorry --non-trivial
lemma new_lemma_97934 (h0 : add_group (comm_group name)) : is_add_cyclic (comm_group name) := sorry --non-trivial
lemma new_lemma_97935 (h0 : not (complete_lattice (add_right_cancel_monoid empty) -> false)) : @is_atomistic.{0} (add_right_cancel_monoid.{0} empty) (@classical.by_contradiction'.{1} (complete_lattice.{0} (add_right_cancel_monoid.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_97936 (h0 : ring (has_inv (has_nnnorm to_additive.value_type))) : is_domain (has_inv (has_nnnorm to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_97937 (h0 : uniform_space (linear_ordered_semiring (random_gen congr_arg_kind))) : separated_space (linear_ordered_semiring (random_gen congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_97938 (h0 : functor.add_const (cancel_comm_monoid_with_zero (ordered_comm_monoid pos)) name) : @unique_factorization_monoid.{0} (ordered_comm_monoid.{0} pos) (@functor.add_const.run.{0 0} (cancel_comm_monoid_with_zero.{0} (ordered_comm_monoid.{0} pos)) name h0)  := sorry --non-trivial
lemma new_lemma_97939 (h0 : functor.add_const (cancel_comm_monoid_with_zero (comm_group ennreal)) Type) : @unique_factorization_monoid.{0} (comm_group.{0} ennreal) (@functor.add_const.run.{0 1} (cancel_comm_monoid_with_zero.{0} (comm_group.{0} ennreal)) Type h0)  := sorry --non-trivial
lemma new_lemma_97940 (h0 : function.extfun Type uniform_space) : @separated_space.{0} (has_add.{0} pos) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (has_add.{0} pos))  := sorry --non-trivial
lemma new_lemma_97941 (h0 : functor.add_const (complete_lattice (add_comm_monoid Type)) pos) : @is_atomistic.{1} (add_comm_monoid.{1} Type) (@functor.add_const.run.{1 0} (complete_lattice.{1} (add_comm_monoid.{1} Type)) pos h0)  := sorry --non-trivial
lemma new_lemma_97942 (h0 : topological_space (has_add Type)) : sequential_space (has_add Type) := sorry --non-trivial
lemma new_lemma_97943 (h0 : not (has_mem.mem (linear_ordered_add_comm_group fun_info) has_emptyc.emptyc -> false)) : @totally_disconnected_space.{0} (linear_ordered_add_comm_group.{0} fun_info) (@finset.pi.empty.{1 0} Type topological_space.{0} (linear_ordered_add_comm_group.{0} fun_info) (@classical.by_contradiction'.{0} (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (linear_ordered_add_comm_group.{0} fun_info) (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))) h0))  := sorry --non-trivial
lemma new_lemma_97944 (h1 : uniform_space (with_zero string_imp)) : complete_space (with_zero string_imp) := sorry --non-trivial
lemma new_lemma_97945 (h0 : not (function.extfun Type filter -> false)) : filter.ne_bot (function.extfun_app (classical.by_contradiction' h0) (normed_group unsigned)) := sorry --non-trivial
lemma new_lemma_97946 (h0 : function.extfun Type ordered_add_comm_monoid) : @archimedean.{0} (has_star.{0} empty) (@function.extfun_app.{2 1} Type ordered_add_comm_monoid.{0} h0 (has_star.{0} empty))  := sorry --non-trivial
lemma new_lemma_97947 (h1 : topological_space (uniform_space to_additive.value_type)) : totally_disconnected_space (uniform_space to_additive.value_type) := sorry --non-trivial
lemma new_lemma_97948 (h0 : ring (has_to_string (has_to_string ennreal))) : is_domain (has_to_string (has_to_string ennreal)) := sorry --non-trivial
lemma new_lemma_97949 (h0 : function.extfun Type add_group) : @is_add_cyclic.{0} (sub_neg_monoid.{0} linarith.comp) (@function.extfun_app.{2 1} Type add_group.{0} h0 (sub_neg_monoid.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_97950 (h0 : topological_space (add_semigroup empty)) : discrete_topology (add_semigroup empty) := sorry --non-trivial
lemma new_lemma_97951 (h0 : set (std_gen -> ereal)) : set.separates_points h0 := sorry --non-trivial
lemma new_lemma_97952 (h0 : topological_space (with_bot (random_gen (with_bot to_additive.value_type)))) : path_connected_space (with_bot (random_gen (with_bot to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_97953 (h0 : monoid (complete_distrib_lattice (finset Type))) : monoid.fg (complete_distrib_lattice (finset Type)) := sorry --non-trivial
lemma new_lemma_97954 (h0 : functor.add_const (ring (cancel_monoid Type)) (boolean_algebra pos)) : @is_domain.{1} (cancel_monoid.{1} Type) (@functor.add_const.run.{1 0} (ring.{1} (cancel_monoid.{1} Type)) (boolean_algebra.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_97955 (h0 : fin has_zero.zero) : @is_cyclic.{0} (complete_distrib_lattice.{0} real) (@matrix.vec_empty.{0} (group.{0} (complete_distrib_lattice.{0} real)) h0)  := sorry --non-trivial
lemma new_lemma_97956 (h0 : with_bot (ulower Prop)) (h1 : ne (id h0) has_bot.bot) : @ulower.up.{0} Prop encodable.Prop (@with_bot.unbot.{0} (@ulower.{0} Prop encodable.Prop) (@id.{1} (with_bot.{0} (@ulower.{0} Prop encodable.Prop)) h0) h1)  := sorry --non-trivial
lemma new_lemma_97957 (h0 : function.extfun (finset Type) (has_mem.mem (random_gen linarith.comp))) : @totally_separated_space.{0} (random_gen.{0} linarith.comp) (@finset.pi.empty.{1 0} Type topological_space.{0} (random_gen.{0} linarith.comp) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (random_gen.{0} linarith.comp)) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_97958 (h0 : group (partial_order (semiring congr_arg_kind))) : group.fg (partial_order (semiring congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_97959 (h0 : topological_space (boolean_algebra (comm_group (comm_group (comm_group (comm_group Type)))))) : preconnected_space (boolean_algebra (comm_group (comm_group (comm_group (comm_group Type))))) := sorry --non-trivial
lemma new_lemma_97960 (h0 : ring (denumerable to_additive.value_type)) : strong_rank_condition (denumerable to_additive.value_type) := sorry --non-trivial
lemma new_lemma_97961 (h0 : uniform_space (semi_normed_ring (sub_neg_monoid to_additive.value_type))) : complete_space (semi_normed_ring (sub_neg_monoid to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_97962 (h0 : cancel_comm_monoid_with_zero (has_to_string pos)) : unique_factorization_monoid (has_to_string pos) := sorry --non-trivial
lemma new_lemma_97963 (h0 : semiring (has_zero (finset Type))) : is_noetherian_ring (has_zero (finset Type)) := sorry --non-trivial
lemma new_lemma_97964 (h0 : not (ring (mul_zero_class congr_arg_kind) -> false)) : @is_domain.{0} (mul_zero_class.{0} congr_arg_kind) (@classical.by_contradiction'.{1} (ring.{0} (mul_zero_class.{0} congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_97965 (h0 : function.extfun Type complete_lattice) : @complete_lattice.is_Sup_finite_compact.{0} (left_cancel_monoid.{0} unsigned) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (left_cancel_monoid.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_97966 (h0 : ring (has_ssubset (metric_space (metric_space (random_gen to_additive.value_type))))) : rank_condition (has_ssubset (metric_space (metric_space (random_gen to_additive.value_type)))) := sorry --non-trivial
lemma new_lemma_97967 (h0 : prod ereal ereal) (h1 : uniform_space ereal) : separation_rel ereal h0 := sorry --non-trivial
lemma new_lemma_97968 (h0 : function.extfun Type topological_space) : @sequential_space.{0} (ordered_cancel_add_comm_monoid.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (ordered_cancel_add_comm_monoid.{0} pos))  := sorry --non-trivial
lemma new_lemma_97969 (h0 : fin has_zero.zero) : @monoid.fg.{0} (random_gen.{0} (has_top.{0} (has_top.{0} linarith.comp))) (@matrix.vec_empty.{0} (monoid.{0} (random_gen.{0} (has_top.{0} (has_top.{0} linarith.comp)))) h0)  := sorry --non-trivial
lemma new_lemma_97970 (h0 : function.extfun Type topological_space) : @preconnected_space.{0} (cancel_monoid.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (cancel_monoid.{0} pos))  := sorry --non-trivial
lemma new_lemma_97971 (h0 : functor.add_const (function.extfun (Type 1) filter) pos) : countable_Inter_filter (function.extfun_app (functor.add_const.run h0) (boolean_algebra Type)) := sorry --non-trivial
lemma new_lemma_97972 (h0 : complete_lattice (has_add (sub_neg_monoid (sub_neg_monoid Type)))) : is_compactly_generated (has_add (sub_neg_monoid (sub_neg_monoid Type))) := sorry --non-trivial
lemma new_lemma_97973 (h0 : functor.add_const (topological_space (semigroup environment.implicit_infer_kind)) linarith.comp) : @normal_space.{0} (semigroup.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (semigroup.{0} environment.implicit_infer_kind)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_97974 (h0 : fin has_zero.zero) : @rank_condition.{1} (ordered_comm_ring.{1} Type) (@matrix.vec_empty.{1} (ring.{1} (ordered_comm_ring.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_97975 (h0 : function.extfun Type topological_space) : @t1_space.{0} (right_cancel_semigroup.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (right_cancel_semigroup.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_97976 (h0 : group (complete_distrib_lattice (boolean_algebra.core Type))) : group.fg (complete_distrib_lattice (boolean_algebra.core Type)) := sorry --non-trivial
lemma new_lemma_97977 (h0 : finset (has_nnnorm (has_nnnorm (has_nnnorm reducibility_hints)))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_97978 (h0 : topological_space (add_group empty)) : t1_space (add_group empty) := sorry --non-trivial
lemma new_lemma_97979 (h0 : filter (has_add (add_left_cancel_monoid string_imp))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_97980 (h0 : functor.add_const (uniform_space (omega_complete_partial_order empty)) congr_arg_kind) : @separated_space.{0} (omega_complete_partial_order.{0} empty) (@functor.add_const.run.{0 0} (uniform_space.{0} (omega_complete_partial_order.{0} empty)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_97981 (h0 : ring (option (has_add ennreal))) : rank_condition (option (has_add ennreal)) := sorry --non-trivial
lemma new_lemma_97982 (h0 : not (complete_lattice (has_append reducibility_hints) -> false)) : @complete_lattice.is_Sup_finite_compact.{0} (has_append.{0} reducibility_hints) (@classical.by_contradiction'.{1} (complete_lattice.{0} (has_append.{0} reducibility_hints)) h0)  := sorry --non-trivial
lemma new_lemma_97983 (h0 : has_lt (nondiscrete_normed_field (add_comm_semigroup reducibility_hints))) : no_max_order (nondiscrete_normed_field (add_comm_semigroup reducibility_hints)) := sorry --non-trivial
lemma new_lemma_97984 (h0 : function.extfun nat fin) : @monoid.fg.{0} (ordered_comm_monoid.{0} real) (@matrix.vec_empty.{0} (monoid.{0} (ordered_comm_monoid.{0} real)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_97985 (h0 : topological_space (complete_semilattice_Sup (has_top (has_norm linarith.ineq)))) : totally_disconnected_space (complete_semilattice_Sup (has_top (has_norm linarith.ineq))) := sorry --non-trivial
lemma new_lemma_97986 (h1 h2 : multiset (has_nnnorm char)) : multiset.disjoint h1 h2 := sorry --non-trivial
lemma new_lemma_97987 (h0 : group (with_bot (semiring num))) : is_cyclic (with_bot (semiring num)) := sorry --non-trivial
lemma new_lemma_97988 (h0 : topological_space (ordered_comm_monoid (boolean_algebra.core Type))) : discrete_topology (ordered_comm_monoid (boolean_algebra.core Type)) := sorry --non-trivial
lemma new_lemma_97989 (h0 : topological_space (with_zero (random_gen (random_gen (has_inv linarith.comp_source))))) : path_connected_space (with_zero (random_gen (random_gen (has_inv linarith.comp_source)))) := sorry --non-trivial
lemma new_lemma_97990 (h0 : prod (with_bot (semiring unsigned)) (with_bot (semiring unsigned))) : id_rel h0 := sorry --non-trivial
lemma new_lemma_97991 (h0 : topological_space (has_neg (has_add (has_add (has_add (has_add linarith.comp)))))) : discrete_topology (has_neg (has_add (has_add (has_add (has_add linarith.comp))))) := sorry --non-trivial
lemma new_lemma_97992 (h0 : topological_space (sub_neg_monoid congr_arg_kind)) : topological_space.separable_space (sub_neg_monoid congr_arg_kind) := sorry --non-trivial
lemma new_lemma_97993 (h0 : has_neg (has_ssubset linarith.ineq)) (h1 : measurable_space (has_ssubset linarith.ineq)) : has_measurable_neg (has_ssubset linarith.ineq) := sorry --non-trivial
lemma new_lemma_97994 (h0 : group (linear_ordered_field name)) : normalizer_condition (linear_ordered_field name) := sorry --non-trivial
lemma new_lemma_97995 (h0 : group (id (random_gen (has_inv (random_gen (has_inv (random_gen fun_info))))))) : normalizer_condition (id (random_gen (has_inv (random_gen (has_inv (random_gen fun_info)))))) := sorry --non-trivial
lemma new_lemma_97996 (h0 : functor.add_const (topological_space (has_to_string linarith.comp)) linarith.comp) : @totally_disconnected_space.{0} (has_to_string.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (has_to_string.{0} linarith.comp)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_97997 (h0 : functor.add_const (group (sub_neg_monoid pos)) pos) : @group.fg.{0} (sub_neg_monoid.{0} pos) (@functor.add_const.run.{0 0} (group.{0} (sub_neg_monoid.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_97998 (h0 : functor.add_const (group (semigroup num)) empty) : @is_cyclic.{0} (semigroup.{0} num) (@functor.add_const.run.{0 0} (group.{0} (semigroup.{0} num)) empty h0)  := sorry --non-trivial
lemma new_lemma_97999 (h0 : not (ring (uniform_space (metric_space to_additive.value_type)) -> false)) : @is_domain.{0} (uniform_space.{0} (metric_space.{0} to_additive.value_type)) (@classical.by_contradiction'.{1} (ring.{0} (uniform_space.{0} (metric_space.{0} to_additive.value_type))) h0)  := sorry --non-trivial
lemma new_lemma_98000 (h0 : topological_space (has_add (has_Inf real))) : t1_space (has_add (has_Inf real)) := sorry --non-trivial
lemma new_lemma_98001 (h0 : ring (encodable (random_gen (random_gen string_imp)))) : is_domain (encodable (random_gen (random_gen string_imp))) := sorry --non-trivial
lemma new_lemma_98002 (h0 : function.extfun nat fin) : @separated_space.{1} (simple_graph.{1} Type) (@matrix.vec_empty.{1} (uniform_space.{1} (simple_graph.{1} Type)) (@function.extfun_app.{1 1} nat fin (@matrix.vec_empty.{0} (function.extfun.{1 1} nat fin) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero))) (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_98003 (h0 : not (function.extfun Type complete_lattice -> false)) : @complete_lattice.is_Sup_finite_compact.{0} (comm_ring.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type complete_lattice.{0}) h0) (comm_ring.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_98004 (h1 : set (uniform_space reducibility_hints)) : set.finite h1 := sorry --non-trivial
lemma new_lemma_98005 (h0 : ordered_comm_monoid (ring (has_pos_part (has_add (has_add Type))))) : has_exists_mul_of_le (ring (has_pos_part (has_add (has_add Type)))) := sorry --non-trivial
lemma new_lemma_98006 (h0 : function.extfun ((Type -> Type) -> Type 1) (function.extfun (Type -> Type))) : @is_noetherian_ring.{0} (has_to_string.{0} ennreal) (@function.extfun_app.{2 1} Type semiring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) (@function.extfun_app.{3 2} ((Type → Type) → Type 1) (function.extfun.{2 2} (Type → Type)) h0 (function.extfun.{2 1} Type)) semiring.{0}) (has_to_string.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_98007 (h0 : functor.add_const (monoid (has_add pos)) (has_neg_part Type)) : @monoid.fg.{0} (has_add.{0} pos) (@functor.add_const.run.{0 1} (monoid.{0} (has_add.{0} pos)) (has_neg_part.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_98008 (h0 : finset (ordered_semiring empty)) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_98009 (h0 : function.extfun (finset Type) (has_mem.mem (normed_group string_imp))) : @is_domain.{0} (normed_group.{0} string_imp) (@finset.pi.empty.{1 0} Type ring.{0} (normed_group.{0} string_imp) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (normed_group.{0} string_imp)) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_98010 (h0 : not (group (uniform_space reducibility_hints) -> false)) : @is_cyclic.{0} (uniform_space.{0} reducibility_hints) (@classical.by_contradiction'.{1} (group.{0} (uniform_space.{0} reducibility_hints)) h0)  := sorry --non-trivial
lemma new_lemma_98011 (h0 : functor.add_const (functor.add_const (topological_space pos) pos) Type) : @locally_compact_space.{0} pos (@functor.add_const.run.{0 0} (topological_space.{0} pos) pos (@functor.add_const.run.{0 1} (functor.add_const.{0 0} (topological_space.{0} pos) pos) Type h0))  := sorry --non-trivial
lemma new_lemma_98012 (h0 : functor.add_const (topological_space (boolean_algebra linarith.comp)) environment.implicit_infer_kind) : @irreducible_space.{0} (boolean_algebra.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (boolean_algebra.{0} linarith.comp)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_98013 (h0 : topological_space (dlist (has_nnnorm (has_nnnorm fun_info)))) : totally_disconnected_space (dlist (has_nnnorm (has_nnnorm fun_info))) := sorry --non-trivial
lemma new_lemma_98014 (h0 : add_monoid (add_group (has_norm fun_info))) : add_monoid.fg (add_group (has_norm fun_info)) := sorry --non-trivial
lemma new_lemma_98015 (h0 : functor.add_const (topological_space (ring pos)) name) : @path_connected_space.{0} (ring.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (ring.{0} pos)) name h0)  := sorry --non-trivial
lemma new_lemma_98016 (h0 : ordered_comm_monoid (canonically_ordered_comm_semiring (comm_group name))) : has_exists_mul_of_le (canonically_ordered_comm_semiring (comm_group name)) := sorry --non-trivial
lemma new_lemma_98017 (h0 : ring (distrib (has_nnnorm char))) : strong_rank_condition (distrib (has_nnnorm char)) := sorry --non-trivial
lemma new_lemma_98018 (h0 : ring (normed_group (semiring (has_top congr_arg_kind)))) : is_domain (normed_group (semiring (has_top congr_arg_kind))) := sorry --non-trivial
lemma new_lemma_98019 (h0 : function.extfun Type topological_space) : @discrete_topology.{0} (has_bot.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_bot.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_98020 (h0 : ring (has_to_string (has_neg (ring linarith.comp)))) : rank_condition (has_to_string (has_neg (ring linarith.comp))) := sorry --non-trivial
lemma new_lemma_98021 (h0 : function.extfun (Type 1) complete_lattice) : @is_atomistic.{1} (complete_distrib_lattice.{1} Type) (@function.extfun_app.{3 2} (Type 1) complete_lattice.{1} h0 (complete_distrib_lattice.{1} Type))  := sorry --non-trivial
lemma new_lemma_98022 (h0 : add_group (with_one ereal)) : is_add_cyclic (with_one ereal) := sorry --non-trivial
lemma new_lemma_98023 (h0 : fin has_zero.zero) : @loc_path_connected_space.{1} (normed_lattice_add_comm_group.{1} Type) (@matrix.vec_empty.{1} (topological_space.{1} (normed_lattice_add_comm_group.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_98024 (h0 : ring (free_add_monoid (semiring empty))) : rank_condition (free_add_monoid (semiring empty)) := sorry --non-trivial
lemma new_lemma_98025 (h0 : function.extfun (Type 1) group) : @group.fg.{1} (plift.{1} unsigned) (@function.extfun_app.{3 2} (Type 1) group.{1} h0 (plift.{1} unsigned))  := sorry --non-trivial
lemma new_lemma_98026 (h0 : monoid (add_cancel_monoid (mul_one_class (finset pos)))) : monoid.fg (add_cancel_monoid (mul_one_class (finset pos))) := sorry --non-trivial
lemma new_lemma_98027 (h0 : functor.add_const (cancel_comm_monoid_with_zero (has_neg_part unsigned)) (has_add pos)) : @unique_factorization_monoid.{0} (has_neg_part.{0} unsigned) (@functor.add_const.run.{0 0} (cancel_comm_monoid_with_zero.{0} (has_neg_part.{0} unsigned)) (has_add.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_98028 (h1 : ring (linear_ordered_field string_imp)) : rank_condition (linear_ordered_field string_imp) := sorry --non-trivial
lemma new_lemma_98029 (h0 : topological_space (has_inv (has_nnnorm (random_gen (random_gen char))))) : totally_disconnected_space (has_inv (has_nnnorm (random_gen (random_gen char)))) := sorry --non-trivial
lemma new_lemma_98030 (h0 : function.extfun Type group) : @group.fg.{0} (add_group.{0} num) (@function.extfun_app.{2 1} Type group.{0} h0 (add_group.{0} num))  := sorry --non-trivial
lemma new_lemma_98031 (h0 : topological_space (boolean_algebra (semigroup name))) : loc_path_connected_space (boolean_algebra (semigroup name)) := sorry --non-trivial
lemma new_lemma_98032 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @totally_disconnected_space.{0} (mul_zero_class.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (mul_zero_class.{0} pos))  := sorry --non-trivial
lemma new_lemma_98033 (h0 : function.extfun Type topological_space) : @preconnected_space.{0} (emetric_space.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (emetric_space.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_98034 (h0 : functor.add_const (topological_space (cancel_monoid name)) name) : @totally_separated_space.{0} (cancel_monoid.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (cancel_monoid.{0} name)) name h0)  := sorry --non-trivial
lemma new_lemma_98035 (h1 : function.extfun Type ring) : @rank_condition.{0} (distrib_lattice.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type ring.{0} h1 (distrib_lattice.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_98036 (h0 : cancel_comm_monoid_with_zero (linear_ordered_field (option ennreal))) : unique_factorization_monoid (linear_ordered_field (option ennreal)) := sorry --non-trivial
lemma new_lemma_98037 (h0 : function.extfun Type ring) : @is_principal_ideal_ring.{0} (canonically_ordered_comm_semiring.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type ring.{0} h0 (canonically_ordered_comm_semiring.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_98038 (h0 : filter (add_cancel_monoid (has_add linarith.comp))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_98039 (h0 : topological_space (has_pos_part (has_Inf name))) : totally_disconnected_space (has_pos_part (has_Inf name)) := sorry --non-trivial
lemma new_lemma_98040 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : preirreducible_space real := sorry --non-trivial
lemma new_lemma_98041 (h0 : functor.add_const (complete_lattice (ordered_cancel_add_comm_monoid empty)) empty) : @complete_lattice.is_Sup_finite_compact.{0} (ordered_cancel_add_comm_monoid.{0} empty) (@functor.add_const.run.{0 0} (complete_lattice.{0} (ordered_cancel_add_comm_monoid.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_98042 (h3 : not (list congr_arg_kind -> false)) : list.nodup (classical.by_contradiction' h3) := sorry --non-trivial
lemma new_lemma_98043 (h0 : list (has_neg_part (comm_group (option pos)))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_98044 (h0 : function.extfun Type topological_space) : @preconnected_space.{0} (ordered_cancel_add_comm_monoid.{0} (option.{0} empty)) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (ordered_cancel_add_comm_monoid.{0} (option.{0} empty)))  := sorry --non-trivial
lemma new_lemma_98045 (h2 : function.extfun Type group) : @is_cyclic.{0} (complete_semilattice_Sup.{0} string_imp) (@function.extfun_app.{2 1} Type group.{0} h2 (complete_semilattice_Sup.{0} string_imp))  := sorry --non-trivial
lemma new_lemma_98046 (h0 : filter (has_zero (has_to_string unsigned))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_98047 (h0 : complete_linear_order (non_assoc_semiring empty) -> complete_linear_order (non_assoc_semiring empty) -> Prop) : is_refl (complete_linear_order (non_assoc_semiring empty)) h0 := sorry --non-trivial
lemma new_lemma_98048 (h0 : functor.add_const (complete_lattice (cancel_monoid num)) congr_arg_kind) : @complete_lattice.is_Sup_finite_compact.{0} (cancel_monoid.{0} num) (@functor.add_const.run.{0 0} (complete_lattice.{0} (cancel_monoid.{0} num)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_98049 (h0 : group (generalized_boolean_algebra (has_bot (has_bot name)))) : group.fg (generalized_boolean_algebra (has_bot (has_bot name))) := sorry --non-trivial
lemma new_lemma_98050 (h0 : add_group (cancel_monoid (has_add pos))) : is_add_cyclic (cancel_monoid (has_add pos)) := sorry --non-trivial
lemma new_lemma_98051 (h0 : functor.add_const (topological_space (canonically_ordered_comm_semiring unsigned)) linarith.comp) : @regular_space.{0} (canonically_ordered_comm_semiring.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (canonically_ordered_comm_semiring.{0} unsigned)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_98052 (h0 : function.extfun Type topological_space) : @sequential_space.{0} (canonically_ordered_comm_semiring.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (canonically_ordered_comm_semiring.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_98053 (h0 : topological_space (has_nndist (finset (has_add linarith.comp)))) : locally_compact_space (has_nndist (finset (has_add linarith.comp))) := sorry --non-trivial
lemma new_lemma_98054 (h0 : topological_space (has_Inf (has_add pos))) : discrete_topology (has_Inf (has_add pos)) := sorry --non-trivial
lemma new_lemma_98055 (h0 : topological_space (has_bot linarith.comp)) : regular_space (has_bot linarith.comp) := sorry --non-trivial
lemma new_lemma_98056 (h0 : ring (has_add (boolean_algebra pos))) : is_principal_ideal_ring (has_add (boolean_algebra pos)) := sorry --non-trivial
lemma new_lemma_98057 (h0 : topological_space (cancel_monoid (has_add (boolean_algebra name)))) : normal_space (cancel_monoid (has_add (boolean_algebra name))) := sorry --non-trivial
lemma new_lemma_98058 (h0 : functor.add_const (cancel_comm_monoid_with_zero (has_Sup empty)) num) : @unique_factorization_monoid.{0} (has_Sup.{0} empty) (@functor.add_const.run.{0 0} (cancel_comm_monoid_with_zero.{0} (has_Sup.{0} empty)) num h0)  := sorry --non-trivial
lemma new_lemma_98059 (h0 : function.extfun Type add_group) : @is_add_cyclic.{0} (add_semigroup.{0} num) (@function.extfun_app.{2 1} Type add_group.{0} h0 (add_semigroup.{0} num))  := sorry --non-trivial
lemma new_lemma_98060 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_noetherian_ring.{0} (add_comm_monoid.{0} num) (@function.extfun_app.{2 1} Type semiring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 semiring.{0}) (add_comm_monoid.{0} num))  := sorry --non-trivial
lemma new_lemma_98061 (h1 : not (complete_lattice (has_compl string_imp) -> false)) : @complete_lattice.is_Sup_finite_compact.{0} (has_compl.{0} string_imp) (@classical.by_contradiction'.{1} (complete_lattice.{0} (has_compl.{0} string_imp)) h1)  := sorry --non-trivial
lemma new_lemma_98062 (h0 : functor.add_const (topological_space (linear_order empty)) num) : @loc_path_connected_space.{0} (linear_order.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (linear_order.{0} empty)) num h0)  := sorry --non-trivial
lemma new_lemma_98063 (h0 : functor.add_const (uniform_space (ordered_ring unsigned)) unsigned) : @complete_space.{0} (ordered_ring.{0} unsigned) (@functor.add_const.run.{0 0} (uniform_space.{0} (ordered_ring.{0} unsigned)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_98064 (h0 : topological_space (normed_comm_ring (option (option (option (option (option empty))))))) : totally_separated_space (normed_comm_ring (option (option (option (option (option empty)))))) := sorry --non-trivial
lemma new_lemma_98065 (h1 : preorder (add_comm_semigroup (mul_one_class (mul_one_class ereal)))) (h2 : set (add_comm_semigroup (mul_one_class (mul_one_class ereal)))) : set.is_pwo h2 := sorry --non-trivial
lemma new_lemma_98066 (h0 : topological_space (has_norm fun_info)) : totally_separated_space (has_norm fun_info) := sorry --non-trivial
lemma new_lemma_98067 (h0 : uniform_space (add_comm_monoid (option (option unsigned)))) : complete_space (add_comm_monoid (option (option unsigned))) := sorry --non-trivial
lemma new_lemma_98068 (h0 : topological_space (normed_comm_ring (has_add name))) : preconnected_space (normed_comm_ring (has_add name)) := sorry --non-trivial
lemma new_lemma_98069 (h1 : list (dlist (random_gen to_additive.value_type))) : list.nodup h1 := sorry --non-trivial
lemma new_lemma_98070 (h0 : has_mem.mem (id num) has_emptyc.emptyc) : @irreducible_space.{0} (@id.{2} Type num) (@finset.pi.empty.{1 0} Type topological_space.{0} (@id.{2} Type num) h0)  := sorry --non-trivial
lemma new_lemma_98071 (h0 : group (ring environment.implicit_infer_kind)) : normalizer_condition (ring environment.implicit_infer_kind) := sorry --non-trivial
lemma new_lemma_98072 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @strong_rank_condition.{0} (monoid.{0} pos) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (monoid.{0} pos))  := sorry --non-trivial
lemma new_lemma_98073 (h0 : functor.add_const (cancel_comm_monoid_with_zero (ring Type)) (has_neg_part Type)) : @unique_factorization_monoid.{1} (ring.{1} Type) (@functor.add_const.run.{1 1} (cancel_comm_monoid_with_zero.{1} (ring.{1} Type)) (has_neg_part.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_98074 (h0 : nat) (h1 : topological_space (array h0 (add_comm_semigroup (add_comm_semigroup (add_comm_semigroup ereal))))) : t0_space (array h0 (add_comm_semigroup (add_comm_semigroup (add_comm_semigroup ereal)))) := sorry --non-trivial
lemma new_lemma_98075 (h0 : functor.add_const (complete_lattice (has_Inf Type)) environment.implicit_infer_kind) : @is_compactly_generated.{1} (has_Inf.{1} Type) (@functor.add_const.run.{1 0} (complete_lattice.{1} (has_Inf.{1} Type)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_98076 (h0 : prod (has_nndist (option num)) (has_nndist (option num))) : id_rel h0 := sorry --non-trivial
lemma new_lemma_98077 (h0 : filter (boolean_algebra (mul_one_class Type))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_98078 (h0 : complete_lattice (boolean_algebra.core ennreal)) : complete_lattice.is_Sup_finite_compact (boolean_algebra.core ennreal) := sorry --non-trivial
lemma new_lemma_98079 (h0 : topological_space (has_nndist (comm_monoid unsigned))) : totally_separated_space (has_nndist (comm_monoid unsigned)) := sorry --non-trivial
lemma new_lemma_98080 (h0 : topological_space (complete_distrib_lattice (has_pos_part real))) : t0_space (complete_distrib_lattice (has_pos_part real)) := sorry --non-trivial
lemma new_lemma_98081 (h0 : add_group (linear_ordered_comm_ring (semiring (semiring (semiring empty))))) : is_add_cyclic (linear_ordered_comm_ring (semiring (semiring (semiring empty)))) := sorry --non-trivial
lemma new_lemma_98082 (h1 : complete_lattice (has_ssubset linarith.comp_source)) : complete_lattice.is_Sup_finite_compact (has_ssubset linarith.comp_source) := sorry --non-trivial
lemma new_lemma_98083 (h0 : monoid (add_left_cancel_semigroup empty)) : monoid.fg (add_left_cancel_semigroup empty) := sorry --non-trivial
lemma new_lemma_98084 (h0 : functor.add_const (ring (ordered_comm_ring linarith.comp)) name) : @rank_condition.{0} (ordered_comm_ring.{0} linarith.comp) (@functor.add_const.run.{0 0} (ring.{0} (ordered_comm_ring.{0} linarith.comp)) name h0)  := sorry --non-trivial
lemma new_lemma_98085 (h0 : not (ring (has_nnnorm string.iterator_imp) -> false)) : @is_domain.{0} (has_nnnorm.{0} string.iterator_imp) (@classical.by_contradiction'.{1} (ring.{0} (has_nnnorm.{0} string.iterator_imp)) h0)  := sorry --non-trivial
lemma new_lemma_98086 (h0 : comm_semigroup Type -> comm_semigroup Type -> Prop) : transitive h0 := sorry --non-trivial
lemma new_lemma_98087 (h0 : add_group (has_to_string (add_comm_monoid environment.implicit_infer_kind))) : is_add_cyclic (has_to_string (add_comm_monoid environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_98088 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @monoid.fg.{1} (finset.{1} Type) (@function.extfun_app.{3 2} (Type 1) monoid.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 monoid.{1}) (finset.{1} Type))  := sorry --non-trivial
lemma new_lemma_98089 (h0 : uniform_space (add_comm_monoid (has_neg pos))) : separated_space (add_comm_monoid (has_neg pos)) := sorry --non-trivial
lemma new_lemma_98090 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @locally_compact_space.{1} (simple_graph.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 topological_space.{1}) (simple_graph.{1} Type))  := sorry --non-trivial
lemma new_lemma_98091 (h0 : ring (has_add (has_Inf name))) : strong_rank_condition (has_add (has_Inf name)) := sorry --non-trivial
lemma new_lemma_98092 (h0 : functor.add_const (topological_space (ring linarith.comp)) (has_neg pos)) : @t1_space.{0} (ring.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (ring.{0} linarith.comp)) (has_neg.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_98093 (h1 : complete_lattice (has_emptyc (random_gen (random_gen to_additive.value_type)))) : complete_lattice.is_Sup_finite_compact (has_emptyc (random_gen (random_gen to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_98094 (h1 : ring (add_left_cancel_monoid string_imp)) : strong_rank_condition (add_left_cancel_monoid string_imp) := sorry --non-trivial
lemma new_lemma_98095 (h0 : topological_space (semigroup (comm_group name))) : totally_separated_space (semigroup (comm_group name)) := sorry --non-trivial
lemma new_lemma_98096 (h0 : not (add_group (has_lt (distrib_lattice to_additive.value_type)) -> false)) : @is_add_cyclic.{0} (has_lt.{0} (distrib_lattice.{0} to_additive.value_type)) (@classical.by_contradiction'.{1} (add_group.{0} (has_lt.{0} (distrib_lattice.{0} to_additive.value_type))) h0)  := sorry --non-trivial
lemma new_lemma_98097 (h0 : fin has_zero.zero) : strong_rank_condition real := sorry --non-trivial
lemma new_lemma_98098 (h0 : complete_lattice (has_Sup (semiring (semiring (semiring empty))))) : is_compactly_generated (has_Sup (semiring (semiring (semiring empty)))) := sorry --non-trivial
lemma new_lemma_98099 (h0 : ring (with_one fun_info)) : strong_rank_condition (with_one fun_info) := sorry --non-trivial
lemma new_lemma_98100 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @t0_space.{0} (has_one.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_one.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_98101 (h0 : complete_lattice (has_union empty)) : complete_lattice.is_Sup_finite_compact (has_union empty) := sorry --non-trivial
lemma new_lemma_98102 (h0 : topological_space (left_cancel_semigroup congr_arg_kind)) : topological_space.separable_space (left_cancel_semigroup congr_arg_kind) := sorry --non-trivial
lemma new_lemma_98103 (h0 : function.extfun Type topological_space) : @sequential_space.{0} (canonically_linear_ordered_monoid.{0} ennreal) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (canonically_linear_ordered_monoid.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_98104 (h0 : topological_space (measurable_space (semiring (has_norm num)))) : locally_compact_space (measurable_space (semiring (has_norm num))) := sorry --non-trivial
lemma new_lemma_98105 (h0 : topological_space (add_comm_monoid (option (option unsigned)))) : topological_space.separable_space (add_comm_monoid (option (option unsigned))) := sorry --non-trivial
lemma new_lemma_98106 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @rank_condition.{0} (with_bot.{0} num) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (with_bot.{0} num))  := sorry --non-trivial
lemma new_lemma_98107 (h0 : functor.add_const (group (add_comm_monoid pos)) (finset pos)) : @normalizer_condition.{0} (add_comm_monoid.{0} pos) (@functor.add_const.run.{0 0} (group.{0} (add_comm_monoid.{0} pos)) (finset.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_98108 (h0 : has_mem.mem (has_one linarith.comp) has_emptyc.emptyc) : @preirreducible_space.{0} (has_one.{0} linarith.comp) (@finset.pi.empty.{1 0} Type topological_space.{0} (has_one.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_98109 (h0 : function.extfun (finset (Type -> Type)) (has_mem.mem complete_lattice)) : @is_atomistic.{0} num (@function.extfun_app.{2 1} Type complete_lattice.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) complete_lattice.{0} (@function.extfun_app.{2 0} (finset.{1} (Type → Type)) (@has_mem.mem.{1 1} (Type → Type) (finset.{1} (Type → Type)) (@finset.has_mem.{1} (Type → Type)) complete_lattice.{0}) h0 (@has_emptyc.emptyc.{1} (finset.{1} (Type → Type)) (@finset.has_emptyc.{1} (Type → Type))))) num)  := sorry --non-trivial
lemma new_lemma_98110 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : filter.ne_bot (function.extfun_app (function.extfun_app h0 filter) (has_bot unsigned)) := sorry --non-trivial
lemma new_lemma_98111 (h0 : functor.add_const (topological_space (complete_semilattice_Sup num)) (semiring (semiring num))) : @preirreducible_space.{0} (complete_semilattice_Sup.{0} num) (@functor.add_const.run.{0 0} (topological_space.{0} (complete_semilattice_Sup.{0} num)) (semiring.{0} (semiring.{0} num)) h0)  := sorry --non-trivial
lemma new_lemma_98112 (h0 : function.extfun Type topological_space) : @loc_path_connected_space.{0} (pseudo_metric_space.{0} (option.{0} pos)) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (pseudo_metric_space.{0} (option.{0} pos)))  := sorry --non-trivial
lemma new_lemma_98113 (h1 : function.extfun Type uniform_space) : @complete_space.{0} (measurable_space.{0} string_imp) (@function.extfun_app.{2 1} Type uniform_space.{0} h1 (measurable_space.{0} string_imp))  := sorry --non-trivial
lemma new_lemma_98114 (h0 : functor.add_const (ordered_add_comm_monoid (monoid empty)) empty) : @archimedean.{0} (monoid.{0} empty) (@functor.add_const.run.{0 0} (ordered_add_comm_monoid.{0} (monoid.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_98115 (h0 : monoid (add_cancel_monoid (has_add (has_add (has_add Type))))) : monoid.fg (add_cancel_monoid (has_add (has_add (has_add Type)))) := sorry --non-trivial
lemma new_lemma_98116 (h0 : fin has_zero.zero) : @is_domain.{0} (normed_lattice_add_comm_group.{0} pos) (@matrix.vec_empty.{0} (ring.{0} (normed_lattice_add_comm_group.{0} pos)) h0)  := sorry --non-trivial
lemma new_lemma_98117 (h0 : functor.add_const (topological_space (has_neg_part unsigned)) unsigned) : @totally_separated_space.{0} (has_neg_part.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (has_neg_part.{0} unsigned)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_98118 (h0 : not (function.extfun Type ring -> false)) : @is_domain.{0} unsigned (@function.extfun_app.{2 1} Type ring.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type ring.{0}) h0) unsigned)  := sorry --non-trivial
lemma new_lemma_98119 (h0 : topological_space (has_neg (boolean_algebra.core (finset unsigned)))) : normal_space (has_neg (boolean_algebra.core (finset unsigned))) := sorry --non-trivial
lemma new_lemma_98120 (h0 : functor.add_const (topological_space (cancel_monoid name)) Type) : @preconnected_space.{0} (cancel_monoid.{0} name) (@functor.add_const.run.{0 1} (topological_space.{0} (cancel_monoid.{0} name)) Type h0)  := sorry --non-trivial
lemma new_lemma_98121 (h0 : topological_space (comm_group (option pos))) : preirreducible_space (comm_group (option pos)) := sorry --non-trivial
lemma new_lemma_98122 (h0 : functor.add_const (add_monoid (ordered_comm_ring pos)) name) : @add_monoid.fg.{0} (ordered_comm_ring.{0} pos) (@functor.add_const.run.{0 0} (add_monoid.{0} (ordered_comm_ring.{0} pos)) name h0)  := sorry --non-trivial
lemma new_lemma_98123 (h0 : functor.add_const (ordered_add_comm_monoid (canonically_ordered_comm_semiring unsigned)) Type) : @archimedean.{0} (canonically_ordered_comm_semiring.{0} unsigned) (@functor.add_const.run.{0 1} (ordered_add_comm_monoid.{0} (canonically_ordered_comm_semiring.{0} unsigned)) Type h0)  := sorry --non-trivial
lemma new_lemma_98124 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @discrete_topology.{0} (pseudo_metric_space.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (pseudo_metric_space.{0} pos))  := sorry --non-trivial
lemma new_lemma_98125 (h0 : ordered_comm_monoid (has_nndist (normed_comm_ring (has_Inf pos)))) : has_exists_mul_of_le (has_nndist (normed_comm_ring (has_Inf pos))) := sorry --non-trivial
lemma new_lemma_98126 (h0 : complete_lattice (simple_graph (monoid_with_zero ereal))) : complete_lattice.is_Sup_finite_compact (simple_graph (monoid_with_zero ereal)) := sorry --non-trivial
lemma new_lemma_98127 (h0 : list (has_neg Type)) : palindrome h0 := sorry --non-trivial
lemma new_lemma_98128 (h0 : group (with_one (has_top linarith.comp_source))) : is_cyclic (with_one (has_top linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_98129 (h0 : functor.comp topological_space complete_distrib_lattice Type) : @totally_separated_space.{1} (complete_distrib_lattice.{1} Type) (@functor.comp.run.{1 1 1} topological_space.{1} complete_distrib_lattice.{1} Type h0)  := sorry --non-trivial
lemma new_lemma_98130 (h0 : ring (simple_graph Type)) : is_principal_ideal_ring (simple_graph Type) := sorry --non-trivial
lemma new_lemma_98131 (h0 : topological_space (semiring unsigned)) : irreducible_space (semiring unsigned) := sorry --non-trivial
lemma new_lemma_98132 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @preirreducible_space.{0} (measurable_space.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (measurable_space.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_98133 (h0 : ring (left_cancel_monoid empty)) : rank_condition (left_cancel_monoid empty) := sorry --non-trivial
lemma new_lemma_98134 (h0 : not (complete_lattice (distrib char) -> false)) : @complete_lattice.is_Sup_finite_compact.{0} (distrib.{0} char) (@classical.by_contradiction'.{1} (complete_lattice.{0} (distrib.{0} char)) h0)  := sorry --non-trivial
lemma new_lemma_98135 (h0 : functor.add_const (uniform_space (boolean_algebra.core environment.implicit_infer_kind)) (has_add linarith.comp)) : @complete_space.{0} (boolean_algebra.core.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (uniform_space.{0} (boolean_algebra.core.{0} environment.implicit_infer_kind)) (has_add.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_98136 (h0 : semiring (simple_graph Type)) : is_noetherian_ring (simple_graph Type) := sorry --non-trivial
lemma new_lemma_98137 (h0 : complete_lattice (comm_group (has_neg_part environment.implicit_infer_kind))) : is_compactly_generated (comm_group (has_neg_part environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_98138 (h1 : topological_space (has_nnnorm fun_info)) : t0_space (has_nnnorm fun_info) := sorry --non-trivial
lemma new_lemma_98139 (h0 : has_inv to_additive.value_type -> Prop) : @infi.{0 1} Prop (@conditionally_complete_lattice.to_has_Inf.{0} Prop (@complete_lattice.to_conditionally_complete_lattice.{0} Prop Prop.complete_lattice)) (has_inv.{0} to_additive.value_type) h0  := sorry --non-trivial
lemma new_lemma_98140 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @locally_compact_space.{0} (has_pos_part.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_pos_part.{0} name))  := sorry --non-trivial
lemma new_lemma_98141 (h0 : cancel_comm_monoid_with_zero (monoid (option (option unsigned)))) : unique_factorization_monoid (monoid (option (option unsigned))) := sorry --non-trivial
lemma new_lemma_98142 (h0 : fin has_zero.zero) : @unique_factorization_monoid.{0} (boolean_algebra.{0} pos) (@matrix.vec_empty.{0} (cancel_comm_monoid_with_zero.{0} (boolean_algebra.{0} pos)) h0)  := sorry --non-trivial
lemma new_lemma_98143 (h0 : function.extfun Type add_group) : @is_add_cyclic.{0} (with_one.{0} fun_info) (@function.extfun_app.{2 1} Type add_group.{0} h0 (with_one.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_98144 (h1 : topological_space (with_one (has_top fun_info))) : discrete_topology (with_one (has_top fun_info)) := sorry --non-trivial
lemma new_lemma_98145 (h0 : function.extfun (has_norm linarith.ineq) (fun (x : has_norm linarith.ineq), Prop)) : set.infinite (function.extfun_app h0) := sorry --non-trivial
lemma new_lemma_98146 (h0 : function.extfun Type (functor.add_const (topological_space (linear_ordered_cancel_comm_monoid congr_arg_kind)))) : @topological_space.separable_space.{0} (linear_ordered_cancel_comm_monoid.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (linear_ordered_cancel_comm_monoid.{0} congr_arg_kind)) empty (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (topological_space.{0} (linear_ordered_cancel_comm_monoid.{0} congr_arg_kind))) h0 empty))  := sorry --non-trivial
lemma new_lemma_98147 (h0 : ordered_comm_monoid (linear_ordered_field pos)) : has_exists_mul_of_le (linear_ordered_field pos) := sorry --non-trivial
lemma new_lemma_98148 (h0 : cancel_comm_monoid_with_zero (boolean_algebra name)) : unique_factorization_monoid (boolean_algebra name) := sorry --non-trivial
lemma new_lemma_98149 (h0 : topological_space (ring (ring name))) : t0_space (ring (ring name)) := sorry --non-trivial
lemma new_lemma_98150 (h0 : not (topological_space (plift unsigned) -> false)) : @irreducible_space.{1} (plift.{1} unsigned) (@classical.by_contradiction'.{2} (topological_space.{1} (plift.{1} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_98151 (h0 : function.extfun Type topological_space) : @totally_disconnected_space.{0} (encodable.{0} fun_info) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (encodable.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_98152 (h0 : topological_space (ordered_comm_ring (has_Inf (has_Inf (has_Inf linarith.comp))))) : regular_space (ordered_comm_ring (has_Inf (has_Inf (has_Inf linarith.comp)))) := sorry --non-trivial
lemma new_lemma_98153 (h0 : topological_space (normed_comm_ring ennreal)) : topological_space.separable_space (normed_comm_ring ennreal) := sorry --non-trivial
lemma new_lemma_98154 (h0 : topological_space (has_pos_part (has_Inf Type))) : regular_space (has_pos_part (has_Inf Type)) := sorry --non-trivial
lemma new_lemma_98155 (h0 : ring (semiring (metric_space (semiring num)))) : is_domain (semiring (metric_space (semiring num))) := sorry --non-trivial
lemma new_lemma_98156 (h0 : topological_space (has_top congr_arg_kind)) : t0_space (has_top congr_arg_kind) := sorry --non-trivial
lemma new_lemma_98157 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_add_cyclic.{0} (add_group.{0} empty) (@function.extfun_app.{2 1} Type add_group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 add_group.{0}) (add_group.{0} empty))  := sorry --non-trivial
lemma new_lemma_98158 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @separated_space.{0} (has_top.{0} fun_info) (@function.extfun_app.{2 1} Type uniform_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 uniform_space.{0}) (has_top.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_98159 (h0 : not (add_group (has_norm empty) -> false)) : @is_add_cyclic.{0} (has_norm.{0} empty) (@classical.by_contradiction'.{1} (add_group.{0} (has_norm.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_98160 (h0 : ring (linear_ordered_semiring (random_gen linarith.comp))) : strong_rank_condition (linear_ordered_semiring (random_gen linarith.comp)) := sorry --non-trivial
lemma new_lemma_98161 (h0 : functor.comp topological_space cancel_monoid pos) : @loc_path_connected_space.{0} (cancel_monoid.{0} pos) (@functor.comp.run.{0 0 0} topological_space.{0} cancel_monoid.{0} pos h0)  := sorry --non-trivial
lemma new_lemma_98162 (h0 h1 : multiset (random_gen linarith.ineq)) : multiset.disjoint h0 h1 := sorry --non-trivial
lemma new_lemma_98163 (h0 : add_group (with_bot (comm_ring (has_inv to_additive.value_type)))) : is_add_cyclic (with_bot (comm_ring (has_inv to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_98164 (h0 : functor.add_const (function.extfun Type topological_space) (finset pos)) : @preconnected_space.{0} (has_zero.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) (finset.{0} pos) h0) (has_zero.{0} pos))  := sorry --non-trivial
lemma new_lemma_98165 (h0 : functor.comp filter cancel_monoid Type) : filter.ne_bot (functor.comp.run h0) := sorry --non-trivial
lemma new_lemma_98166 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @group.fg.{0} (semi_normed_comm_ring.{0} fun_info) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (semi_normed_comm_ring.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_98167 (h0 : finset (semiring unsigned)) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_98168 (h0 : enat -> enat -> enat) (h1 : enat -> enat) (h2 : enat) : right_inverse h0 h1 h2 := sorry --non-trivial
lemma new_lemma_98169 (h0 : not (function.extfun Type add_group -> false)) : @is_add_cyclic.{0} (denumerable.{0} fun_info) (@function.extfun_app.{2 1} Type add_group.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type add_group.{0}) h0) (denumerable.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_98170 (h0 : has_zero (add_cancel_comm_monoid to_additive.value_type)) (h1 : ring (nat.arithmetic_function (add_cancel_comm_monoid to_additive.value_type))) : strong_rank_condition (nat.arithmetic_function (add_cancel_comm_monoid to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_98171 (h0 : topological_space (ordered_comm_ring (has_Inf name))) : preirreducible_space (ordered_comm_ring (has_Inf name)) := sorry --non-trivial
lemma new_lemma_98172 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_atomistic.{0} (has_nndist.{0} ennreal) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (has_nndist.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_98173 (h1 : uniform_space (linear_ordered_comm_group_with_zero to_additive.value_type)) : complete_space (linear_ordered_comm_group_with_zero to_additive.value_type) := sorry --non-trivial
lemma new_lemma_98174 (h0 : not (add_group (div_inv_monoid char) -> false)) : @is_add_cyclic.{0} (div_inv_monoid.{0} char) (@classical.by_contradiction'.{1} (add_group.{0} (div_inv_monoid.{0} char)) h0)  := sorry --non-trivial
lemma new_lemma_98175 (h0 : functor.add_const (semiring (canonically_linear_ordered_monoid name)) (mul_zero_class unsigned)) : @is_noetherian_ring.{0} (canonically_linear_ordered_monoid.{0} name) (@functor.add_const.run.{0 0} (semiring.{0} (canonically_linear_ordered_monoid.{0} name)) (mul_zero_class.{0} unsigned) h0)  := sorry --non-trivial
lemma new_lemma_98176 (h0 : ring (id (has_norm empty))) : is_domain (id (has_norm empty)) := sorry --non-trivial
lemma new_lemma_98177 (h0 : functor.add_const (topological_space (add_comm_monoid pos)) linarith.comp) : @regular_space.{0} (add_comm_monoid.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (add_comm_monoid.{0} pos)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_98178 (h0 : add_monoid (has_add unsigned)) : add_monoid.fg (has_add unsigned) := sorry --non-trivial
lemma new_lemma_98179 (h0 : ring (ring (option empty))) : is_domain (ring (option empty)) := sorry --non-trivial
lemma new_lemma_98180 (h0 : function.extfun Type ordered_comm_monoid) : @has_exists_mul_of_le.{0} (boolean_algebra.{0} unsigned) (@function.extfun_app.{2 1} Type ordered_comm_monoid.{0} h0 (boolean_algebra.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_98181 (h0 : functor.add_const (topological_space (option empty)) num) : @totally_disconnected_space.{0} (option.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (option.{0} empty)) num h0)  := sorry --non-trivial
lemma new_lemma_98182 (h1 : topological_space (normed_group linarith.ineq)) : irreducible_space (normed_group linarith.ineq) := sorry --non-trivial
lemma new_lemma_98183 (h0 : list (plift empty)) : palindrome h0 := sorry --non-trivial
lemma new_lemma_98184 (h0 : functor.add_const (topological_space (has_add environment.implicit_infer_kind)) pos) : @normal_space.{0} (has_add.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (has_add.{0} environment.implicit_infer_kind)) pos h0)  := sorry --non-trivial
lemma new_lemma_98185 (h0 : functor.add_const (topological_space (boolean_algebra.core environment.implicit_infer_kind)) linarith.comp) : @totally_disconnected_space.{0} (boolean_algebra.core.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (boolean_algebra.core.{0} environment.implicit_infer_kind)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_98186 (h0 : topological_space (has_zero (option ennreal))) : totally_separated_space (has_zero (option ennreal)) := sorry --non-trivial
lemma new_lemma_98187 (h0 : function.extfun Type topological_space) : @preirreducible_space.{0} (preorder.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (preorder.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_98188 (h0 : topological_space (simple_graph (has_Inf linarith.comp))) : locally_compact_space (simple_graph (has_Inf linarith.comp)) := sorry --non-trivial
lemma new_lemma_98189 (h0 : functor.add_const (filter (boolean_algebra pos)) Type) : countable_Inter_filter (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_98190 (h0 : functor.add_const (topological_space (has_to_string linarith.comp)) Type) : @irreducible_space.{0} (has_to_string.{0} linarith.comp) (@functor.add_const.run.{0 1} (topological_space.{0} (has_to_string.{0} linarith.comp)) Type h0)  := sorry --non-trivial
lemma new_lemma_98191 (h0 : topological_space (has_nndist (semigroup (semigroup Type)))) : path_connected_space (has_nndist (semigroup (semigroup Type))) := sorry --non-trivial
lemma new_lemma_98192 (h0 : monoid (linear_ordered_semiring (semiring (semiring (semiring empty))))) : monoid.fg (linear_ordered_semiring (semiring (semiring (semiring empty)))) := sorry --non-trivial
lemma new_lemma_98193 (h1 : filter (add_left_cancel_monoid fun_info)) : filter.ne_bot h1 := sorry --non-trivial
lemma new_lemma_98194 (h1 : set (add_comm_semigroup fun_info -> char)) : set.separates_points h1 := sorry --non-trivial
lemma new_lemma_98195 (h0 : add_monoid (normed_comm_ring (has_neg (ring pos)))) : add_monoid.fg (normed_comm_ring (has_neg (ring pos))) := sorry --non-trivial
lemma new_lemma_98196 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : finset.nonempty (function.extfun_app (function.extfun_app h0 finset) (semigroup name)) := sorry --non-trivial
lemma new_lemma_98197 (h0 : functor.comp group boolean_algebra environment.implicit_infer_kind) : @group.fg.{0} (boolean_algebra.{0} environment.implicit_infer_kind) (@functor.comp.run.{0 0 0} group.{0} boolean_algebra.{0} environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_98198 (h0 : has_mem.mem ring has_emptyc.emptyc) : @strong_rank_condition.{0} (linear_ordered_semiring.{0} fun_info) (@function.extfun_app.{2 1} Type ring.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) ring.{0} h0) (linear_ordered_semiring.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_98199 (h0 : topological_space (canonically_ordered_comm_semiring (boolean_algebra (boolean_algebra pos)))) : path_connected_space (canonically_ordered_comm_semiring (boolean_algebra (boolean_algebra pos))) := sorry --non-trivial
lemma new_lemma_98200 (h0 : topological_space (ordered_comm_monoid (sub_neg_monoid real))) : preconnected_space (ordered_comm_monoid (sub_neg_monoid real)) := sorry --non-trivial
lemma new_lemma_98201 (h0 : group (canonically_ordered_monoid (finset (finset linarith.comp)))) : normalizer_condition (canonically_ordered_monoid (finset (finset linarith.comp))) := sorry --non-trivial
lemma new_lemma_98202 (h0 : function.extfun Type (functor.add_const (complete_lattice (left_cancel_monoid unsigned)))) : @is_atomistic.{0} (left_cancel_monoid.{0} unsigned) (@functor.add_const.run.{0 0} (complete_lattice.{0} (left_cancel_monoid.{0} unsigned)) unsigned (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (complete_lattice.{0} (left_cancel_monoid.{0} unsigned))) h0 unsigned))  := sorry --non-trivial
lemma new_lemma_98203 (h0 : functor.add_const (finset (has_nndist environment.implicit_infer_kind)) environment.implicit_infer_kind) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_98204 (h0 : ring (boolean_algebra name)) : strong_rank_condition (boolean_algebra name) := sorry --non-trivial
lemma new_lemma_98205 (h0 : topological_space (has_star (semiring empty))) : topological_space.separable_space (has_star (semiring empty)) := sorry --non-trivial
lemma new_lemma_98206 (h0 : topological_space (comm_group (comm_group linarith.comp))) : discrete_topology (comm_group (comm_group linarith.comp)) := sorry --non-trivial
lemma new_lemma_98207 (h0 : not (function.extfun Type topological_space -> false)) : @totally_disconnected_space.{0} real.angle (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) real.angle)  := sorry --non-trivial
lemma new_lemma_98208 (h0 : function.extfun Type ordered_add_comm_monoid) : @archimedean.{0} (simple_graph.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type ordered_add_comm_monoid.{0} h0 (simple_graph.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_98209 (h0 : functor.add_const (topological_space (add_comm_monoid pos)) Type) : @locally_compact_space.{0} (add_comm_monoid.{0} pos) (@functor.add_const.run.{0 1} (topological_space.{0} (add_comm_monoid.{0} pos)) Type h0)  := sorry --non-trivial
lemma new_lemma_98210 (h0 : set (has_ssubset reducibility_hints)) : set.finite h0 := sorry --non-trivial
lemma new_lemma_98211 (h0 : functor.add_const (topological_space (preorder num)) congr_arg_kind) : @t0_space.{0} (preorder.{0} num) (@functor.add_const.run.{0 0} (topological_space.{0} (preorder.{0} num)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_98212 (h0 : topological_space (canonically_ordered_comm_semiring empty)) : normal_space (canonically_ordered_comm_semiring empty) := sorry --non-trivial
lemma new_lemma_98213 (h0 : topological_space (with_one (random_gen (random_gen (has_inv (has_ssubset fun_info)))))) : totally_disconnected_space (with_one (random_gen (random_gen (has_inv (has_ssubset fun_info))))) := sorry --non-trivial
lemma new_lemma_98214 (h0 : topological_space (has_zero (boolean_algebra (has_add pos)))) : totally_separated_space (has_zero (boolean_algebra (has_add pos))) := sorry --non-trivial
lemma new_lemma_98215 (h0 : function.extfun Type ring) : @strong_rank_condition.{0} (bin_tree.{0} unsigned) (@function.extfun_app.{2 1} Type ring.{0} h0 (bin_tree.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_98216 (h0 : topological_space (has_nndist name)) : totally_disconnected_space (has_nndist name) := sorry --non-trivial
lemma new_lemma_98217 (h0 : group (has_zero pos)) : is_cyclic (has_zero pos) := sorry --non-trivial
lemma new_lemma_98218 (h0 : functor.add_const (ring (has_to_string Type)) name) : @is_principal_ideal_ring.{1} (has_to_string.{1} Type) (@functor.add_const.run.{1 0} (ring.{1} (has_to_string.{1} Type)) name h0)  := sorry --non-trivial
lemma new_lemma_98219 (h0 : topological_space (comm_ring to_additive.value_type)) : irreducible_space (comm_ring to_additive.value_type) := sorry --non-trivial
lemma new_lemma_98220 (h0 : functor.add_const (topological_space (complete_distrib_lattice empty)) congr_arg_kind) : @normal_space.{0} (complete_distrib_lattice.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (complete_distrib_lattice.{0} empty)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_98221 (h0 : topological_space (has_div char)) (h1 : add_group (has_div char)) : topological_add_group (has_div char) := sorry --non-trivial
lemma new_lemma_98222 (h0 : function.extfun Type cancel_comm_monoid_with_zero) : @unique_factorization_monoid.{0} (cancel_monoid.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type cancel_comm_monoid_with_zero.{0} h0 (cancel_monoid.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_98223 (h0 : functor.add_const (functor.add_const (ring Type) name) (ring name)) : @rank_condition.{1} Type (@functor.add_const.run.{1 0} (ring.{1} Type) name (@functor.add_const.run.{1 0} (functor.add_const.{1 0} (ring.{1} Type) name) (ring.{0} name) h0))  := sorry --non-trivial
lemma new_lemma_98224 (h0 : complete_lattice (id (with_bot (with_bot string_imp)))) : is_compactly_generated (id (with_bot (with_bot string_imp))) := sorry --non-trivial
lemma new_lemma_98225 (h0 : has_mem.mem add_group has_emptyc.emptyc) : @is_add_cyclic.{0} (has_top.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type add_group.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) add_group.{0} h0) (has_top.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_98226 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @is_add_cyclic.{1} (semigroup.{1} Type) (@function.extfun_app.{3 2} (Type 1) add_group.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 add_group.{1}) (semigroup.{1} Type))  := sorry --non-trivial
lemma new_lemma_98227 (h0 : functor.add_const (semiring (finset pos)) unsigned) : @is_noetherian_ring.{0} (finset.{0} pos) (@functor.add_const.run.{0 0} (semiring.{0} (finset.{0} pos)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_98228 (h0 : ring (normed_field (uniform_space (has_ssubset char)))) : is_domain (normed_field (uniform_space (has_ssubset char))) := sorry --non-trivial
lemma new_lemma_98229 (h0 : function.extfun Type complete_lattice) : @is_atomistic.{0} (has_top.{0} unsigned) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (has_top.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_98230 (h0 : functor.add_const (group (canonically_ordered_add_monoid congr_arg_kind)) unsigned) : @is_cyclic.{0} (canonically_ordered_add_monoid.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (group.{0} (canonically_ordered_add_monoid.{0} congr_arg_kind)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_98231 (h0 : function.extfun Type topological_space) : @totally_separated_space.{0} num (@function.extfun_app.{2 1} Type topological_space.{0} h0 num)  := sorry --non-trivial
lemma new_lemma_98232 (h0 : has_mem.mem ring has_emptyc.emptyc) : @is_domain.{0} (normed_group.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type ring.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) ring.{0} h0) (normed_group.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_98233 (h0 : topological_space (semigroup pos)) : totally_separated_space (semigroup pos) := sorry --non-trivial
lemma new_lemma_98234 (h0 : functor.add_const (ring (has_to_string unsigned)) unsigned) : @is_domain.{0} (has_to_string.{0} unsigned) (@functor.add_const.run.{0 0} (ring.{0} (has_to_string.{0} unsigned)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_98235 (h0 : functor.add_const (uniform_space (has_add pos)) Type) : @separated_space.{0} (has_add.{0} pos) (@functor.add_const.run.{0 1} (uniform_space.{0} (has_add.{0} pos)) Type h0)  := sorry --non-trivial
lemma new_lemma_98236 (h0 : uniform_space (has_top (has_norm (semiring unsigned)))) : complete_space (has_top (has_norm (semiring unsigned))) := sorry --non-trivial
lemma new_lemma_98237 (h5 : set (fun_info -> ereal)) : set.separates_points h5 := sorry --non-trivial
lemma new_lemma_98238 (h0 : function.extfun Type list) : list.nodup (function.extfun_app h0 (has_compl to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_98239 (h0 : topological_space (has_neg (ring (finset Type)))) : preirreducible_space (has_neg (ring (finset Type))) := sorry --non-trivial
lemma new_lemma_98240 (h0 : ring (has_emptyc (has_inv linarith.comp_source))) : is_domain (has_emptyc (has_inv linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_98241 (h0 : not (ring (id num) -> false)) : @strong_rank_condition.{0} (@id.{2} Type num) (@classical.by_contradiction'.{1} (ring.{0} (@id.{2} Type num)) h0)  := sorry --non-trivial
lemma new_lemma_98242 (h0 : group (add_cancel_monoid (ring linarith.comp))) : normalizer_condition (add_cancel_monoid (ring linarith.comp)) := sorry --non-trivial
lemma new_lemma_98243 (h0 : function.extfun Type topological_space) : @irreducible_space.{0} (has_zero.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_zero.{0} name))  := sorry --non-trivial
lemma new_lemma_98244 (h0 : function.extfun (finset Type) (has_mem.mem (with_bot linarith.comp_source))) : @discrete_topology.{0} (with_bot.{0} linarith.comp_source) (@finset.pi.empty.{1 0} Type topological_space.{0} (with_bot.{0} linarith.comp_source) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (with_bot.{0} linarith.comp_source)) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_98245 (h0 : topological_space (normed_comm_ring (option pos))) : discrete_topology (normed_comm_ring (option pos)) := sorry --non-trivial
lemma new_lemma_98246 (h0 : function.extfun (finset Type) (has_mem.mem (has_emptyc num))) : @totally_separated_space.{0} (has_emptyc.{0} num) (@finset.pi.empty.{1 0} Type topological_space.{0} (has_emptyc.{0} num) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (has_emptyc.{0} num)) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_98247 (h0 : functor.add_const (ordered_add_comm_monoid (boolean_algebra.core pos)) unsigned) : @archimedean.{0} (boolean_algebra.core.{0} pos) (@functor.add_const.run.{0 0} (ordered_add_comm_monoid.{0} (boolean_algebra.core.{0} pos)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_98248 (h0 : function.extfun Type topological_space) : @regular_space.{0} (canonically_ordered_comm_semiring.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (canonically_ordered_comm_semiring.{0} pos))  := sorry --non-trivial
lemma new_lemma_98249 (h0 : functor.add_const (uniform_space (free_add_monoid congr_arg_kind)) congr_arg_kind) : @separated_space.{0} (free_add_monoid.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (uniform_space.{0} (free_add_monoid.{0} congr_arg_kind)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_98250 (h0 : function.extfun Type topological_space) : @locally_compact_space.{0} (complete_semilattice_Sup.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (complete_semilattice_Sup.{0} num))  := sorry --non-trivial
lemma new_lemma_98251 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @unique_factorization_monoid.{0} (ring.{0} pos) (@function.extfun_app.{2 1} Type cancel_comm_monoid_with_zero.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 cancel_comm_monoid_with_zero.{0}) (ring.{0} pos))  := sorry --non-trivial
lemma new_lemma_98252 (h0 : not (topological_space (measure_theory.measure_space num) -> false)) : @locally_compact_space.{0} (measure_theory.measure_space.{0} num) (@classical.by_contradiction'.{1} (topological_space.{0} (measure_theory.measure_space.{0} num)) h0)  := sorry --non-trivial
lemma new_lemma_98253 (h0 : ring (add_right_cancel_monoid (has_top unsigned))) : rank_condition (add_right_cancel_monoid (has_top unsigned)) := sorry --non-trivial
lemma new_lemma_98254 (h0 : topological_space (semiring empty)) : path_connected_space (semiring empty) := sorry --non-trivial
lemma new_lemma_98255 (h0 : uniform_space (normed_group (random_gen (random_gen linarith.comp_source)))) : complete_space (normed_group (random_gen (random_gen linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_98256 (h0 : functor.add_const (uniform_space (is_R_or_C unsigned)) empty) : @complete_space.{0} (is_R_or_C.{0} unsigned) (@functor.add_const.run.{0 0} (uniform_space.{0} (is_R_or_C.{0} unsigned)) empty h0)  := sorry --non-trivial
lemma new_lemma_98257 (h0 : functor.add_const (topological_space (has_nndist environment.implicit_infer_kind)) linarith.comp) : @loc_path_connected_space.{0} (has_nndist.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (has_nndist.{0} environment.implicit_infer_kind)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_98258 (h0 : ring (has_neg pos)) : is_domain (has_neg pos) := sorry --non-trivial
lemma new_lemma_98259 (h0 : not (topological_space (plift congr_arg_kind) -> false)) : @preirreducible_space.{1} (plift.{1} congr_arg_kind) (@classical.by_contradiction'.{2} (topological_space.{1} (plift.{1} congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_98260 (h0 : function.extfun (finset (Type -> Type)) (has_mem.mem topological_space)) : @locally_compact_space.{0} (linear_ordered_add_comm_group.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) topological_space.{0} (@function.extfun_app.{2 0} (finset.{1} (Type → Type)) (@has_mem.mem.{1 1} (Type → Type) (finset.{1} (Type → Type)) (@finset.has_mem.{1} (Type → Type)) topological_space.{0}) h0 (@has_emptyc.emptyc.{1} (finset.{1} (Type → Type)) (@finset.has_emptyc.{1} (Type → Type))))) (linear_ordered_add_comm_group.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_98261 (h0 : function.extfun Type (functor.add_const (ring (semigroup empty)))) : @is_principal_ideal_ring.{0} (semigroup.{0} empty) (@functor.add_const.run.{0 0} (ring.{0} (semigroup.{0} empty)) empty (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (ring.{0} (semigroup.{0} empty))) h0 empty))  := sorry --non-trivial
lemma new_lemma_98262 (h0 h1 h2 : nat) : nat.less_than_or_equal h0 (geom_sum h1 h2) := sorry --non-trivial
lemma new_lemma_98263 (h0 : function.extfun Type topological_space) : @totally_disconnected_space.{0} (linear_ordered_comm_ring.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (linear_ordered_comm_ring.{0} num))  := sorry --non-trivial
lemma new_lemma_98264 (h0 : functor.comp group add_comm_monoid name) : @is_simple_group.{0} (add_comm_monoid.{0} name) (@functor.comp.run.{0 0 0} group.{0} add_comm_monoid.{0} name h0)  := sorry --non-trivial
lemma new_lemma_98265 (h0 : function.extfun Type monoid) : @monoid.fg.{0} (comm_group.{0} pos) (@function.extfun_app.{2 1} Type monoid.{0} h0 (comm_group.{0} pos))  := sorry --non-trivial
lemma new_lemma_98266 (h0 : topological_space (semigroup pos)) : loc_path_connected_space (semigroup pos) := sorry --non-trivial
lemma new_lemma_98267 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_domain.{0} (boolean_algebra.{0} real) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (boolean_algebra.{0} real))  := sorry --non-trivial
lemma new_lemma_98268 (h3 : not (topological_space (with_bot linarith.ineq) -> false)) : @totally_disconnected_space.{0} (with_bot.{0} linarith.ineq) (@classical.by_contradiction'.{1} (topological_space.{0} (with_bot.{0} linarith.ineq)) h3)  := sorry --non-trivial
lemma new_lemma_98269 (h0 : not (function.extfun Type topological_space -> false)) : @irreducible_space.{0} (add_group.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (add_group.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_98270 (h0 : functor.add_const (topological_space (add_cancel_monoid Type)) linarith.comp) : @discrete_topology.{1} (add_cancel_monoid.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (add_cancel_monoid.{1} Type)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_98271 (h0 : function.extfun nat fin) : @is_add_cyclic.{0} (normed_lattice_add_comm_group.{0} real) (@matrix.vec_empty.{0} (add_group.{0} (normed_lattice_add_comm_group.{0} real)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_98272 (h0 : topological_space (metric_space (has_union unsigned))) : normal_space (metric_space (has_union unsigned)) := sorry --non-trivial
lemma new_lemma_98273 (h1 : ring (has_ssubset to_additive.value_type)) : is_domain (has_ssubset to_additive.value_type) := sorry --non-trivial
lemma new_lemma_98274 (h0 : function.extfun (finset Type) (has_mem.mem (normed_group empty))) : @complete_lattice.is_Sup_finite_compact.{0} (normed_group.{0} empty) (@finset.pi.empty.{1 0} Type complete_lattice.{0} (normed_group.{0} empty) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (normed_group.{0} empty)) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_98275 (h0 : functor.add_const (topological_space (group_with_zero ennreal)) num) : @regular_space.{0} (group_with_zero.{0} ennreal) (@functor.add_const.run.{0 0} (topological_space.{0} (group_with_zero.{0} ennreal)) num h0)  := sorry --non-trivial
lemma new_lemma_98276 (h0 : functor.add_const (add_group (has_pos_part linarith.comp)) pos) : @is_add_cyclic.{0} (has_pos_part.{0} linarith.comp) (@functor.add_const.run.{0 0} (add_group.{0} (has_pos_part.{0} linarith.comp)) pos h0)  := sorry --non-trivial
lemma new_lemma_98277 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @archimedean.{0} (has_inter.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type ordered_add_comm_monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ordered_add_comm_monoid.{0}) (has_inter.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_98278 (h0 : group (add_comm_monoid (sub_neg_monoid real))) : normalizer_condition (add_comm_monoid (sub_neg_monoid real)) := sorry --non-trivial
lemma new_lemma_98279 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @preirreducible_space.{0} (with_one.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (with_one.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_98280 (h0 : functor.add_const (ring (semigroup linarith.comp)) pos) : @strong_rank_condition.{0} (semigroup.{0} linarith.comp) (@functor.add_const.run.{0 0} (ring.{0} (semigroup.{0} linarith.comp)) pos h0)  := sorry --non-trivial
lemma new_lemma_98281 (h1 : function.extfun (Type -> Type) (function.extfun Type)) : @irreducible_space.{0} (has_emptyc.{0} string_imp) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h1 topological_space.{0}) (has_emptyc.{0} string_imp))  := sorry --non-trivial
lemma new_lemma_98282 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @totally_separated_space.{0} (random_gen.{0} linarith.ineq) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (random_gen.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_98283 (h0 : function.extfun Type add_monoid) : @add_monoid.fg.{0} (has_neg.{0} empty) (@function.extfun_app.{2 1} Type add_monoid.{0} h0 (has_neg.{0} empty))  := sorry --non-trivial
lemma new_lemma_98284 (h0 : topological_space (with_one (has_norm (has_top to_additive.value_type)))) : discrete_topology (with_one (has_norm (has_top to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_98285 (h0 : functor.add_const (cancel_comm_monoid_with_zero (normed_comm_ring environment.implicit_infer_kind)) Type) : @unique_factorization_monoid.{0} (normed_comm_ring.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 1} (cancel_comm_monoid_with_zero.{0} (normed_comm_ring.{0} environment.implicit_infer_kind)) Type h0)  := sorry --non-trivial
lemma new_lemma_98286 (h0 : has_mem.mem (random_gen linarith.comp_source) has_emptyc.emptyc) : @complete_lattice.is_Sup_finite_compact.{0} (random_gen.{0} linarith.comp_source) (@finset.pi.empty.{1 0} Type complete_lattice.{0} (random_gen.{0} linarith.comp_source) h0)  := sorry --non-trivial
lemma new_lemma_98287 (h0 : functor.add_const (function.extfun (Type 1) topological_space) (has_neg pos)) : @totally_separated_space.{1} (ordered_comm_monoid.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) topological_space.{1}) (has_neg.{0} pos) h0) (ordered_comm_monoid.{1} Type))  := sorry --non-trivial
lemma new_lemma_98288 (h3 : char -> char -> Prop) : is_total char h3 := sorry --non-trivial
lemma new_lemma_98289 (h0 : functor.add_const (complete_lattice (ring name)) linarith.comp) : @complete_lattice.is_Sup_finite_compact.{0} (ring.{0} name) (@functor.add_const.run.{0 0} (complete_lattice.{0} (ring.{0} name)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_98290 (h0 : list (ring (has_neg pos))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_98291 (h0 : ordered_comm_monoid (has_nndist (comm_group Type))) : has_exists_mul_of_le (has_nndist (comm_group Type)) := sorry --non-trivial
lemma new_lemma_98292 (h0 : functor.add_const (topological_space (add_cancel_monoid linarith.comp)) pos) : @irreducible_space.{0} (add_cancel_monoid.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (add_cancel_monoid.{0} linarith.comp)) pos h0)  := sorry --non-trivial
lemma new_lemma_98293 (h0 : monoid (linear_ordered_add_comm_group (random_gen (random_gen to_additive.value_type)))) : monoid.fg (linear_ordered_add_comm_group (random_gen (random_gen to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_98294 (h1 : topological_space (mul_one_class (mul_one_class char))) : totally_disconnected_space (mul_one_class (mul_one_class char)) := sorry --non-trivial
lemma new_lemma_98295 (h0 : not (complete_lattice (simple_graph char) -> false)) : @complete_lattice.is_Sup_finite_compact.{0} (simple_graph.{0} char) (@classical.by_contradiction'.{1} (complete_lattice.{0} (simple_graph.{0} char)) h0)  := sorry --non-trivial
lemma new_lemma_98296 (h0 : topological_space (canonically_ordered_comm_semiring (cancel_monoid pos))) : loc_path_connected_space (canonically_ordered_comm_semiring (cancel_monoid pos)) := sorry --non-trivial
lemma new_lemma_98297 (h0 : functor.add_const (ring (has_neg environment.implicit_infer_kind)) pos) : @rank_condition.{0} (has_neg.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (ring.{0} (has_neg.{0} environment.implicit_infer_kind)) pos h0)  := sorry --non-trivial
lemma new_lemma_98298 (h0 : functor.add_const (topological_space (has_neg unsigned)) name) : @normal_space.{0} (has_neg.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (has_neg.{0} unsigned)) name h0)  := sorry --non-trivial
lemma new_lemma_98299 (h0 : fin has_zero.zero) : @totally_separated_space.{0} (normed_lattice_add_comm_group.{0} pos) (@matrix.vec_empty.{0} (topological_space.{0} (normed_lattice_add_comm_group.{0} pos)) h0)  := sorry --non-trivial
lemma new_lemma_98300 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @add_monoid.fg.{0} (normed_lattice_add_comm_group.{0} pos) (@function.extfun_app.{2 1} Type add_monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 add_monoid.{0}) (normed_lattice_add_comm_group.{0} pos))  := sorry --non-trivial
lemma new_lemma_98301 (h0 : functor.add_const (add_monoid (option empty)) congr_arg_kind) : @add_monoid.fg.{0} (option.{0} empty) (@functor.add_const.run.{0 0} (add_monoid.{0} (option.{0} empty)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_98302 (h0 : function.extfun (Type 1) ordered_comm_monoid) : @has_exists_mul_of_le.{1} (has_neg.{1} Type) (@function.extfun_app.{3 2} (Type 1) ordered_comm_monoid.{1} h0 (has_neg.{1} Type))  := sorry --non-trivial
lemma new_lemma_98303 (h0 : functor.add_const (ordered_comm_monoid (has_add environment.implicit_infer_kind)) pos) : @has_exists_mul_of_le.{0} (has_add.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (ordered_comm_monoid.{0} (has_add.{0} environment.implicit_infer_kind)) pos h0)  := sorry --non-trivial
lemma new_lemma_98304 (h0 : group (with_one (random_gen char))) : is_cyclic (with_one (random_gen char)) := sorry --non-trivial
lemma new_lemma_98305 (h0 : group (comm_ring (has_nnnorm (has_nnnorm to_additive.value_type)))) : group.fg (comm_ring (has_nnnorm (has_nnnorm to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_98306 (h0 : functor.add_const (complete_lattice (semigroup empty)) empty) : @is_atomistic.{0} (semigroup.{0} empty) (@functor.add_const.run.{0 0} (complete_lattice.{0} (semigroup.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_98307 (h0 : not (function.extfun Type topological_space -> false)) : @irreducible_space.{0} (measurable_space.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (measurable_space.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_98308 (h0 : functor.add_const (function.extfun Type topological_space) (has_Inf Type)) : @totally_disconnected_space.{0} (has_nndist.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type topological_space.{0}) (has_Inf.{1} Type) h0) (has_nndist.{0} pos))  := sorry --non-trivial
lemma new_lemma_98309 (h0 : topological_space (has_neg name)) : preconnected_space (has_neg name) := sorry --non-trivial
lemma new_lemma_98310 (h0 : list (normed_comm_ring (mul_one_class (semigroup environment.implicit_infer_kind)))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_98311 (h0 : functor.add_const (filter (mul_zero_class unsigned)) congr_arg_kind) : filter.ne_bot (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_98312 (h0 : group (has_norm (has_norm empty))) : group.fg (has_norm (has_norm empty)) := sorry --non-trivial
lemma new_lemma_98313 (h0 : topological_space (has_Inf (ring (ring (ordered_ring Type))))) : totally_separated_space (has_Inf (ring (ring (ordered_ring Type)))) := sorry --non-trivial
lemma new_lemma_98314 (h0 : function.extfun Type finset) : finset.nonempty (function.extfun_app h0 (boolean_algebra environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_98315 (h0 : cancel_comm_monoid_with_zero (has_star (has_top (semiring empty)))) : unique_factorization_monoid (has_star (has_top (semiring empty))) := sorry --non-trivial
lemma new_lemma_98316 (h0 : functor.add_const (function.extfun Type topological_space) Type) : @topological_space.separable_space.{0} (has_add.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type topological_space.{0}) Type h0) (has_add.{0} pos))  := sorry --non-trivial
lemma new_lemma_98317 (h0 : not (group (measurable_space empty) -> false)) : @is_cyclic.{0} (measurable_space.{0} empty) (@classical.by_contradiction'.{1} (group.{0} (measurable_space.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_98318 (h0 : ordered_add_comm_monoid (preorder (semiring (semiring empty)))) : archimedean (preorder (semiring (semiring empty))) := sorry --non-trivial
lemma new_lemma_98319 (h0 : function.extfun Type list) : list.nodup (function.extfun_app h0 (mul_zero_class name)) := sorry --non-trivial
lemma new_lemma_98320 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @preconnected_space.{0} (ordered_cancel_add_comm_monoid.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (ordered_cancel_add_comm_monoid.{0} pos))  := sorry --non-trivial
lemma new_lemma_98321 (h0 : group (has_pos_part (has_Inf real))) : is_cyclic (has_pos_part (has_Inf real)) := sorry --non-trivial
lemma new_lemma_98322 (h0 : functor.add_const (semiring (generalized_boolean_algebra linarith.comp)) (boolean_algebra.core linarith.comp)) : @is_noetherian_ring.{0} (generalized_boolean_algebra.{0} linarith.comp) (@functor.add_const.run.{0 0} (semiring.{0} (generalized_boolean_algebra.{0} linarith.comp)) (boolean_algebra.core.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_98323 (h0 : functor.add_const (finset (cancel_monoid Type)) linarith.comp) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_98324 (h0 : topological_space (id (linear_ordered_semiring unsigned))) : path_connected_space (id (linear_ordered_semiring unsigned)) := sorry --non-trivial
lemma new_lemma_98325 (h0 : function.extfun Type topological_space) : @discrete_topology.{0} (complete_distrib_lattice.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (complete_distrib_lattice.{0} empty))  := sorry --non-trivial
lemma new_lemma_98326 (h0 : function.extfun (nat -> Type) (function.extfun nat)) : @preirreducible_space.{0} (boolean_algebra.{0} pos) (@matrix.vec_empty.{0} (topological_space.{0} (boolean_algebra.{0} pos)) (@function.extfun_app.{1 1} nat fin (@function.extfun_app.{2 1} (nat → Type) (function.extfun.{1 1} nat) h0 fin) (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_98327 (h0 : topological_space (boolean_algebra (finset (has_to_string (has_add linarith.comp))))) : t0_space (boolean_algebra (finset (has_to_string (has_add linarith.comp)))) := sorry --non-trivial
lemma new_lemma_98328 (h0 : function.extfun Type uniform_space) : separated_space nnreal := sorry --non-trivial
lemma new_lemma_98329 (h0 : topological_space (has_zero (has_add name))) : preirreducible_space (has_zero (has_add name)) := sorry --non-trivial
lemma new_lemma_98330 (h0 : functor.add_const (topological_space (normed_comm_ring linarith.comp)) (has_zero linarith.comp)) : @discrete_topology.{0} (normed_comm_ring.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (normed_comm_ring.{0} linarith.comp)) (has_zero.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_98331 (h0 : functor.add_const (add_group (has_edist unsigned)) num) : @is_add_cyclic.{0} (has_edist.{0} unsigned) (@functor.add_const.run.{0 0} (add_group.{0} (has_edist.{0} unsigned)) num h0)  := sorry --non-trivial
lemma new_lemma_98332 (h0 : function.extfun Type add_group) : @is_add_cyclic.{0} (has_Sup.{0} empty) (@function.extfun_app.{2 1} Type add_group.{0} h0 (has_Sup.{0} empty))  := sorry --non-trivial
lemma new_lemma_98333 (h0 : topological_space (simple_graph (has_to_string (ring pos)))) : t1_space (simple_graph (has_to_string (ring pos))) := sorry --non-trivial
lemma new_lemma_98334 (h0 : function.extfun Type complete_lattice) : @is_compactly_generated.{0} (semigroup.{0} ennreal) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (semigroup.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_98335 (h0 : functor.add_const (list (canonically_ordered_comm_semiring pos)) Type) : list.nodup (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_98336 (h0 : function.extfun Type uniform_space) : @complete_space.{0} (encodable.{0} fun_info) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (encodable.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_98337 (h0 : topological_space (comm_group (finset (finset pos)))) : preirreducible_space (comm_group (finset (finset pos))) := sorry --non-trivial
lemma new_lemma_98338 (h0 : functor.add_const (ring (ring Type)) (has_add name)) : @strong_rank_condition.{1} (ring.{1} Type) (@functor.add_const.run.{1 0} (ring.{1} (ring.{1} Type)) (has_add.{0} name) h0)  := sorry --non-trivial
lemma new_lemma_98339 (h0 : function.extfun Type (functor.comp list boolean_algebra)) : list.nodup (functor.comp.run (functor.comp.run (function.extfun_app h0 name))) := sorry --non-trivial
lemma new_lemma_98340 (h0 : ring (uniform_space (topological_space reducibility_hints))) : rank_condition (uniform_space (topological_space reducibility_hints)) := sorry --non-trivial
lemma new_lemma_98341 (h0 : function.extfun (finset Type) (has_mem.mem (with_one fun_info))) : @discrete_topology.{0} (with_one.{0} fun_info) (@finset.pi.empty.{1 0} Type topological_space.{0} (with_one.{0} fun_info) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (with_one.{0} fun_info)) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_98342 (h0 : functor.add_const (topological_space (complete_distrib_lattice name)) linarith.comp) : @path_connected_space.{0} (complete_distrib_lattice.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (complete_distrib_lattice.{0} name)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_98343 (h1 : topological_space (with_one (random_gen (random_gen congr_arg_kind)))) : t0_space (with_one (random_gen (random_gen congr_arg_kind))) := sorry --non-trivial
lemma new_lemma_98344 (h1 : has_mem.mem (measurable_space num) has_emptyc.emptyc) : @is_add_cyclic.{0} (measurable_space.{0} num) (@finset.pi.empty.{1 0} Type add_group.{0} (measurable_space.{0} num) h1)  := sorry --non-trivial
lemma new_lemma_98345 (h0 : functor.add_const (topological_space (omega_complete_partial_order num)) empty) : @t0_space.{0} (omega_complete_partial_order.{0} num) (@functor.add_const.run.{0 0} (topological_space.{0} (omega_complete_partial_order.{0} num)) empty h0)  := sorry --non-trivial
lemma new_lemma_98346 (h0 : with_bot Prop) (h1 : ne h0 has_bot.bot) : id (with_bot.unbot h0 h1) := sorry --non-trivial
lemma new_lemma_98347 (h0 : not (list (with_one fun_info) -> false)) : list.nodup (classical.by_contradiction' h0) := sorry --non-trivial
lemma new_lemma_98348 (h0 : function.extfun Type topological_space) : @preconnected_space.{0} (has_bot.{0} ennreal) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_bot.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_98349 (h0 : monoid (complete_distrib_lattice (has_neg (has_neg name)))) : monoid.fg (complete_distrib_lattice (has_neg (has_neg name))) := sorry --non-trivial
lemma new_lemma_98350 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @group.fg.{0} (random_gen.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (random_gen.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_98351 (h0 : topological_space (semigroup (semigroup unsigned))) : totally_disconnected_space (semigroup (semigroup unsigned)) := sorry --non-trivial
lemma new_lemma_98352 (h0 : topological_space (simple_graph (ring (ring Type)))) : preirreducible_space (simple_graph (ring (ring Type))) := sorry --non-trivial
lemma new_lemma_98353 (h0 : functor.add_const (function.extfun (Type 1) group) Type) : @group.fg.{1} (has_to_string.{1} Type) (@function.extfun_app.{3 2} (Type 1) group.{1} (@functor.add_const.run.{2 1} (function.extfun.{3 2} (Type 1) group.{1}) Type h0) (has_to_string.{1} Type))  := sorry --non-trivial
lemma new_lemma_98354 (h0 : function.extfun Type finset) : finset.nonempty (function.extfun_app h0 (pseudo_metric_space congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_98355 (h0 : topological_space (left_cancel_monoid (has_well_founded num))) : loc_path_connected_space (left_cancel_monoid (has_well_founded num)) := sorry --non-trivial
lemma new_lemma_98356 (h0 : not (ring (plift unsigned) -> false)) : @is_domain.{1} (plift.{1} unsigned) (@classical.by_contradiction'.{2} (ring.{1} (plift.{1} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_98357 (h0 : linarith.comp -> linarith.comp -> linarith.comp) : left_cancelative h0 := sorry --non-trivial
lemma new_lemma_98358 (h0 : functor.add_const (complete_lattice (finset unsigned)) unsigned) : @complete_lattice.is_Sup_finite_compact.{0} (finset.{0} unsigned) (@functor.add_const.run.{0 0} (complete_lattice.{0} (finset.{0} unsigned)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_98359 (h1 : complete_lattice (with_zero linarith.comp_source)) : is_compactly_generated (with_zero linarith.comp_source) := sorry --non-trivial
lemma new_lemma_98360 (h0 : functor.add_const (topological_space (cancel_monoid ennreal)) (option num)) : @irreducible_space.{0} (cancel_monoid.{0} ennreal) (@functor.add_const.run.{0 0} (topological_space.{0} (cancel_monoid.{0} ennreal)) (option.{0} num) h0)  := sorry --non-trivial
lemma new_lemma_98361 (h0 : function.extfun (((Type -> Type) -> Type 1) -> Type 1) (function.extfun ((Type -> Type) -> Type 1))) : @rank_condition.{0} (distrib_lattice.{0} linarith.ineq) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) (@function.extfun_app.{3 2} ((Type → Type) → Type 1) (function.extfun.{2 2} (Type → Type)) (@function.extfun_app.{3 3} (((Type → Type) → Type 1) → Type 1) (function.extfun.{3 2} ((Type → Type) → Type 1)) h0 (function.extfun.{2 2} (Type → Type))) (function.extfun.{2 1} Type)) ring.{0}) (distrib_lattice.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_98362 (h0 : uniform_space (measurable_space (has_norm fun_info))) : complete_space (measurable_space (has_norm fun_info)) := sorry --non-trivial
lemma new_lemma_98363 (h2 : has_mem.mem (measurable_space congr_arg_kind) has_emptyc.emptyc) : @strong_rank_condition.{0} (measurable_space.{0} congr_arg_kind) (@finset.pi.empty.{1 0} Type ring.{0} (measurable_space.{0} congr_arg_kind) h2)  := sorry --non-trivial
lemma new_lemma_98364 (h0 : functor.add_const (group (has_Inf name)) Type) : @group.fg.{0} (has_Inf.{0} name) (@functor.add_const.run.{0 1} (group.{0} (has_Inf.{0} name)) Type h0)  := sorry --non-trivial
lemma new_lemma_98365 (h2 : add_group (distrib_lattice linarith.comp_source)) : is_add_cyclic (distrib_lattice linarith.comp_source) := sorry --non-trivial
lemma new_lemma_98366 (h0 : function.extfun Type semiring) : @is_noetherian_ring.{0} (comm_semigroup.{0} linarith.comp) (@function.extfun_app.{2 1} Type semiring.{0} h0 (comm_semigroup.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_98367 (h0 : not (topological_space (semi_normed_ring std_gen) -> false)) : @totally_disconnected_space.{0} (semi_normed_ring.{0} std_gen) (@classical.by_contradiction'.{1} (topological_space.{0} (semi_normed_ring.{0} std_gen)) h0)  := sorry --non-trivial
lemma new_lemma_98368 (h0 : ring (ring Type)) : rank_condition (ring Type) := sorry --non-trivial
lemma new_lemma_98369 (h0 : topological_space (has_Inf (ordered_ring linarith.comp))) : discrete_topology (has_Inf (ordered_ring linarith.comp)) := sorry --non-trivial
lemma new_lemma_98370 (h0 : functor.add_const (complete_lattice (semigroup name)) environment.implicit_infer_kind) : @is_atomistic.{0} (semigroup.{0} name) (@functor.add_const.run.{0 0} (complete_lattice.{0} (semigroup.{0} name)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_98371 (h0 : topological_space (has_nndist num)) : t0_space (has_nndist num) := sorry --non-trivial
lemma new_lemma_98372 (h0 : ring (has_pos_part (has_Inf (sub_neg_monoid Type)))) : strong_rank_condition (has_pos_part (has_Inf (sub_neg_monoid Type))) := sorry --non-trivial
lemma new_lemma_98373 (h0 : functor.add_const (topological_space (has_bot pos)) linarith.comp) : @regular_space.{0} (has_bot.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (has_bot.{0} pos)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_98374 (h0 : topological_space (linear_ordered_comm_group_with_zero to_additive.value_type)) : t0_space (linear_ordered_comm_group_with_zero to_additive.value_type) := sorry --non-trivial
lemma new_lemma_98375 (h0 : complete_lattice (has_Inf (has_neg Type))) : is_compactly_generated (has_Inf (has_neg Type)) := sorry --non-trivial
lemma new_lemma_98376 (h0 : ring (ordered_comm_monoid (sub_neg_monoid pos))) : strong_rank_condition (ordered_comm_monoid (sub_neg_monoid pos)) := sorry --non-trivial
lemma new_lemma_98377 (h0 : functor.add_const (semiring (add_comm_monoid linarith.comp)) name) : @is_noetherian_ring.{0} (add_comm_monoid.{0} linarith.comp) (@functor.add_const.run.{0 0} (semiring.{0} (add_comm_monoid.{0} linarith.comp)) name h0)  := sorry --non-trivial
lemma new_lemma_98378 (h0 : set (enat -> fun_info)) : set.separates_points h0 := sorry --non-trivial
lemma new_lemma_98379 (h0 : topological_space (add_right_cancel_monoid (semiring (semiring (semiring (semiring (semiring num))))))) : t0_space (add_right_cancel_monoid (semiring (semiring (semiring (semiring (semiring num)))))) := sorry --non-trivial
lemma new_lemma_98380 (h0 : topological_space (has_nndist (has_add (has_add pos)))) : locally_compact_space (has_nndist (has_add (has_add pos))) := sorry --non-trivial
lemma new_lemma_98381 (h0 : functor.add_const (ordered_add_comm_monoid (normed_linear_ordered_group unsigned)) num) : @archimedean.{0} (normed_linear_ordered_group.{0} unsigned) (@functor.add_const.run.{0 0} (ordered_add_comm_monoid.{0} (normed_linear_ordered_group.{0} unsigned)) num h0)  := sorry --non-trivial
lemma new_lemma_98382 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @t0_space.{0} (has_one.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_one.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_98383 (h0 : group (ordered_comm_ring (has_add real))) : is_simple_group (ordered_comm_ring (has_add real)) := sorry --non-trivial
lemma new_lemma_98384 (h0 : measurable_space string_imp) (h1 : filter string_imp) : filter.is_measurably_generated h1 := sorry --non-trivial
lemma new_lemma_98385 (h0 : topological_space (random_gen (random_gen linarith.ineq))) : totally_separated_space (random_gen (random_gen linarith.ineq)) := sorry --non-trivial
lemma new_lemma_98386 (h0 : function.extfun Type monoid) : @monoid.fg.{0} (has_zero.{0} pos) (@function.extfun_app.{2 1} Type monoid.{0} h0 (has_zero.{0} pos))  := sorry --non-trivial
lemma new_lemma_98387 (h0 : functor.add_const (ring (ordered_comm_ring linarith.comp)) (ring name)) : @is_domain.{0} (ordered_comm_ring.{0} linarith.comp) (@functor.add_const.run.{0 0} (ring.{0} (ordered_comm_ring.{0} linarith.comp)) (ring.{0} name) h0)  := sorry --non-trivial
lemma new_lemma_98388 (h0 : topological_space (semigroup (option (cancel_monoid (has_nndist (has_nndist pos)))))) : irreducible_space (semigroup (option (cancel_monoid (has_nndist (has_nndist pos))))) := sorry --non-trivial
lemma new_lemma_98389 (h0 : ring (topological_space (comm_ring reducibility_hints))) : rank_condition (topological_space (comm_ring reducibility_hints)) := sorry --non-trivial
lemma new_lemma_98390 (h0 : topological_space (finset (option (ordered_cancel_add_comm_monoid (option (option unsigned)))))) : normal_space (finset (option (ordered_cancel_add_comm_monoid (option (option unsigned))))) := sorry --non-trivial
lemma new_lemma_98391 (h0 : ordered_add_comm_monoid (ring (has_add (has_Inf linarith.comp)))) : archimedean (ring (has_add (has_Inf linarith.comp))) := sorry --non-trivial
lemma new_lemma_98392 (h0 : complete_lattice (ordered_comm_ring (has_Inf Type))) : is_atomistic (ordered_comm_ring (has_Inf Type)) := sorry --non-trivial
lemma new_lemma_98393 (h0 : ordered_add_comm_monoid (partial_order (option empty))) : archimedean (partial_order (option empty)) := sorry --non-trivial
lemma new_lemma_98394 (h0 : group (ordered_comm_ring (ordered_ring name))) : normalizer_condition (ordered_comm_ring (ordered_ring name)) := sorry --non-trivial
lemma new_lemma_98395 (h0 : topological_space (canonically_linear_ordered_monoid (has_Inf Type))) : t1_space (canonically_linear_ordered_monoid (has_Inf Type)) := sorry --non-trivial
lemma new_lemma_98396 (h0 : ring (finset (has_to_string Type))) : rank_condition (finset (has_to_string Type)) := sorry --non-trivial
lemma new_lemma_98397 (h0 : measurable_space (random_gen linarith.comp_source)) (h1 : has_div (random_gen linarith.comp_source)) : has_measurable_div₂ (random_gen linarith.comp_source) := sorry --non-trivial
lemma new_lemma_98398 (h0 : has_mem.mem (complete_semilattice_Sup char) has_emptyc.emptyc) : @t0_space.{0} (complete_semilattice_Sup.{0} char) (@finset.pi.empty.{1 0} Type topological_space.{0} (complete_semilattice_Sup.{0} char) h0)  := sorry --non-trivial
lemma new_lemma_98399 (h0 : function.extfun Type uniform_space) : @separated_space.{0} (non_assoc_semiring.{0} num) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (non_assoc_semiring.{0} num))  := sorry --non-trivial
lemma new_lemma_98400 (h0 : not (function.extfun Type uniform_space -> false)) : @separated_space.{0} (measurable_space.dynkin_system.{0} linarith.comp) (@function.extfun_app.{2 1} Type uniform_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type uniform_space.{0}) h0) (measurable_space.dynkin_system.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_98401 (h0 : add_monoid (has_to_string (has_neg Type))) : add_monoid.fg (has_to_string (has_neg Type)) := sorry --non-trivial
lemma new_lemma_98402 (h0 : list (distrib_lattice (has_nnnorm fun_info))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_98403 (h0 : functor.add_const Prop (comm_group (boolean_algebra (boolean_algebra linarith.comp)))) : functor.add_const.run h0 := sorry --non-trivial
lemma new_lemma_98404 (h0 : complete_lattice (has_emptyc to_additive.value_type)) : complete_lattice.is_Sup_finite_compact (has_emptyc to_additive.value_type) := sorry --non-trivial
lemma new_lemma_98405 (h0 : list (has_add (has_neg environment.implicit_infer_kind))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_98406 (h0 : uniform_space (ring unsigned)) : complete_space (ring unsigned) := sorry --non-trivial
lemma new_lemma_98407 (h0 : topological_space (has_nndist (boolean_algebra.core name))) : normal_space (has_nndist (boolean_algebra.core name)) := sorry --non-trivial
lemma new_lemma_98408 (h0 : complete_lattice (has_star (semiring (semiring (semiring (semiring (semiring empty))))))) : is_atomistic (has_star (semiring (semiring (semiring (semiring (semiring empty)))))) := sorry --non-trivial
lemma new_lemma_98409 (h0 : list (has_to_string ennreal)) : palindrome h0 := sorry --non-trivial
lemma new_lemma_98410 (h0 : ordered_add_comm_monoid (monoid ennreal)) : archimedean (monoid ennreal) := sorry --non-trivial
lemma new_lemma_98411 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_principal_ideal_ring.{0} (ordered_comm_monoid.{0} linarith.comp) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (ordered_comm_monoid.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_98412 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @t0_space.{0} (add_left_cancel_semigroup.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (add_left_cancel_semigroup.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_98413 (h0 : functor.add_const (add_monoid (has_pos_part linarith.comp)) (ring name)) : @add_monoid.fg.{0} (has_pos_part.{0} linarith.comp) (@functor.add_const.run.{0 0} (add_monoid.{0} (has_pos_part.{0} linarith.comp)) (ring.{0} name) h0)  := sorry --non-trivial
lemma new_lemma_98414 (h0 : function.extfun Type (functor.add_const (topological_space (partial_order unsigned)))) : @locally_compact_space.{0} (partial_order.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (partial_order.{0} unsigned)) congr_arg_kind (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (topological_space.{0} (partial_order.{0} unsigned))) h0 congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_98415 (h0 : filter (has_compl string_imp)) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_98416 (h0 : functor.add_const (add_monoid (complete_distrib_lattice empty)) empty) : @add_monoid.fg.{0} (complete_distrib_lattice.{0} empty) (@functor.add_const.run.{0 0} (add_monoid.{0} (complete_distrib_lattice.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_98417 (h2 : not (ring (denumerable fun_info) -> false)) : @is_domain.{0} (denumerable.{0} fun_info) (@classical.by_contradiction'.{1} (ring.{0} (denumerable.{0} fun_info)) h2)  := sorry --non-trivial
lemma new_lemma_98418 (h0 : ring (metric_space (has_top (has_norm (has_norm (random_gen linarith.comp)))))) : rank_condition (metric_space (has_top (has_norm (has_norm (random_gen linarith.comp))))) := sorry --non-trivial
lemma new_lemma_98419 (h0 : functor.add_const (add_comm_group (has_neg unsigned)) linarith.comp) (h1 : functor.add_const (has_norm (has_neg unsigned)) linarith.comp) : @normed_group.core.{0} (has_neg.{0} unsigned) (@functor.add_const.run.{0 0} (add_comm_group.{0} (has_neg.{0} unsigned)) linarith.comp h0) (@functor.add_const.run.{0 0} (has_norm.{0} (has_neg.{0} unsigned)) linarith.comp h1)  := sorry --non-trivial
lemma new_lemma_98420 (h0 : topological_space (cancel_monoid (option (option unsigned)))) : t0_space (cancel_monoid (option (option unsigned))) := sorry --non-trivial
lemma new_lemma_98421 (h0 : uniform_space (linear_ordered_comm_group (has_inv linarith.comp_source))) : complete_space (linear_ordered_comm_group (has_inv linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_98422 (h0 : function.extfun Type semiring) : @is_noetherian_ring.{0} (monoid.{0} unsigned) (@function.extfun_app.{2 1} Type semiring.{0} h0 (monoid.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_98423 (h0 : function.extfun Type topological_space) : @irreducible_space.{0} (option.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (option.{0} empty))  := sorry --non-trivial
lemma new_lemma_98424 (h0 : functor.add_const (list (generalized_boolean_algebra pos)) (ring Type)) : palindrome (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_98425 (h0 : topological_space (measure_theory.measure_space (mul_zero_class (mul_zero_class num)))) : irreducible_space (measure_theory.measure_space (mul_zero_class (mul_zero_class num))) := sorry --non-trivial
lemma new_lemma_98426 (h0 : topological_space (monoid_with_zero congr_arg_kind)) : preirreducible_space (monoid_with_zero congr_arg_kind) := sorry --non-trivial
lemma new_lemma_98427 (h0 : functor.add_const (function.extfun (Type 1) complete_lattice) Type) : @complete_lattice.is_Sup_finite_compact.{1} (ring.{1} Type) (@function.extfun_app.{3 2} (Type 1) complete_lattice.{1} (@functor.add_const.run.{2 1} (function.extfun.{3 2} (Type 1) complete_lattice.{1}) Type h0) (ring.{1} Type))  := sorry --non-trivial
lemma new_lemma_98428 (h0 : not (complete_lattice (has_compl char) -> false)) : @complete_lattice.is_Sup_finite_compact.{0} (has_compl.{0} char) (@classical.by_contradiction'.{1} (complete_lattice.{0} (has_compl.{0} char)) h0)  := sorry --non-trivial
lemma new_lemma_98429 (h0 : complete_lattice (monoid congr_arg_kind)) : is_atomistic (monoid congr_arg_kind) := sorry --non-trivial
lemma new_lemma_98430 (h0 : topological_space (normed_group (semiring unsigned))) : locally_compact_space (normed_group (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_98431 (h0 : functor.add_const (ring (boolean_algebra Type)) (ring Type)) : @rank_condition.{1} (boolean_algebra.{1} Type) (@functor.add_const.run.{1 1} (ring.{1} (boolean_algebra.{1} Type)) (ring.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_98432 (h0 : add_group (distrib_lattice (add_cancel_comm_monoid linarith.comp_source))) : is_add_cyclic (distrib_lattice (add_cancel_comm_monoid linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_98433 (h0 : topological_space (add_comm_monoid num)) : totally_separated_space (add_comm_monoid num) := sorry --non-trivial
lemma new_lemma_98434 (h0 : topological_space (add_cancel_monoid (ring (has_pos_part linarith.comp)))) : irreducible_space (add_cancel_monoid (ring (has_pos_part linarith.comp))) := sorry --non-trivial
lemma new_lemma_98435 (h0 : functor.add_const (group (has_Sup unsigned)) empty) : @is_cyclic.{0} (has_Sup.{0} unsigned) (@functor.add_const.run.{0 0} (group.{0} (has_Sup.{0} unsigned)) empty h0)  := sorry --non-trivial
lemma new_lemma_98436 (h0 : ring (add_cancel_comm_monoid (has_nnnorm string.iterator_imp))) : rank_condition (add_cancel_comm_monoid (has_nnnorm string.iterator_imp)) := sorry --non-trivial
lemma new_lemma_98437 (h0 : function.extfun Type topological_space) (h1 : set real) : is_seq_compact h1 := sorry --non-trivial
lemma new_lemma_98438 (h0 : complete_lattice (canonically_ordered_comm_semiring congr_arg_kind)) : complete_lattice.is_Sup_finite_compact (canonically_ordered_comm_semiring congr_arg_kind) := sorry --non-trivial
lemma new_lemma_98439 (h0 : topological_space (plift num)) : totally_disconnected_space (plift num) := sorry --non-trivial
lemma new_lemma_98440 (h0 : topological_space (linear_ordered_comm_ring (semiring (semiring (semiring congr_arg_kind))))) : path_connected_space (linear_ordered_comm_ring (semiring (semiring (semiring congr_arg_kind)))) := sorry --non-trivial
lemma new_lemma_98441 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : filter.ne_bot (function.extfun_app (function.extfun_app h0 filter) (comm_monoid empty)) := sorry --non-trivial
lemma new_lemma_98442 (h1 : complete_lattice (id (id (measurable_space congr_arg_kind)))) : complete_lattice.is_Sup_finite_compact (id (id (measurable_space congr_arg_kind))) := sorry --non-trivial
lemma new_lemma_98443 (h2 : measurable_space string.iterator_imp) (h3 : measure_theory.measure string.iterator_imp) : measure_theory.is_finite_measure h3 := sorry --non-trivial
lemma new_lemma_98444 (h0 : fin has_zero.zero) : @archimedean.{0} (normed_lattice_add_comm_group.{0} real) (@matrix.vec_empty.{0} (ordered_add_comm_monoid.{0} (normed_lattice_add_comm_group.{0} real)) h0)  := sorry --non-trivial
lemma new_lemma_98445 (h0 : functor.add_const (topological_space (generalized_boolean_algebra linarith.comp)) name) : @normal_space.{0} (generalized_boolean_algebra.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (generalized_boolean_algebra.{0} linarith.comp)) name h0)  := sorry --non-trivial
lemma new_lemma_98446 (h0 : function.extfun Type complete_lattice) : @complete_lattice.is_Sup_finite_compact.{0} (random_gen.{0} num) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (random_gen.{0} num))  := sorry --non-trivial
lemma new_lemma_98447 (h0 : has_mem.mem (linear_ordered_add_comm_group num) has_emptyc.emptyc) : @locally_compact_space.{0} (linear_ordered_add_comm_group.{0} num) (@finset.pi.empty.{1 0} Type topological_space.{0} (linear_ordered_add_comm_group.{0} num) h0)  := sorry --non-trivial
lemma new_lemma_98448 (h0 : ring (finset Type)) : strong_rank_condition (finset Type) := sorry --non-trivial
lemma new_lemma_98449 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @t0_space.{0} (add_semigroup.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (add_semigroup.{0} empty))  := sorry --non-trivial
lemma new_lemma_98450 (h0 : functor.add_const (ordered_add_comm_monoid (bin_tree empty)) (semiring (semiring (semiring empty)))) : @archimedean.{0} (bin_tree.{0} empty) (@functor.add_const.run.{0 0} (ordered_add_comm_monoid.{0} (bin_tree.{0} empty)) (semiring.{0} (semiring.{0} (semiring.{0} empty))) h0)  := sorry --non-trivial
lemma new_lemma_98451 (h0 : functor.add_const (uniform_space (boolean_algebra.core linarith.comp)) linarith.comp) : @separated_space.{0} (boolean_algebra.core.{0} linarith.comp) (@functor.add_const.run.{0 0} (uniform_space.{0} (boolean_algebra.core.{0} linarith.comp)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_98452 (h0 : not (ring (has_star empty) -> false)) : @strong_rank_condition.{0} (has_star.{0} empty) (@classical.by_contradiction'.{1} (ring.{0} (has_star.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_98453 (h0 : ring (normed_field environment.projection_info)) : strong_rank_condition (normed_field environment.projection_info) := sorry --non-trivial
lemma new_lemma_98454 (h0 : ring (semi_normed_comm_ring reducibility_hints)) : rank_condition (semi_normed_comm_ring reducibility_hints) := sorry --non-trivial
lemma new_lemma_98455 (h0 : functor.add_const (functor.add_const (complete_lattice (left_cancel_monoid empty)) empty) empty) : @is_atomistic.{0} (left_cancel_monoid.{0} empty) (@functor.add_const.run.{0 0} (complete_lattice.{0} (left_cancel_monoid.{0} empty)) empty (@functor.add_const.run.{0 0} (functor.add_const.{0 0} (complete_lattice.{0} (left_cancel_monoid.{0} empty)) empty) empty h0))  := sorry --non-trivial
lemma new_lemma_98456 (h0 : function.extfun Type topological_space) : @irreducible_space.{0} (boolean_algebra.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (boolean_algebra.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_98457 (h0 : cancel_comm_monoid_with_zero (generalized_boolean_algebra (has_Inf (has_Inf pos)))) : unique_factorization_monoid (generalized_boolean_algebra (has_Inf (has_Inf pos))) := sorry --non-trivial
lemma new_lemma_98458 (h0 : topological_space (boolean_algebra (has_add name))) : discrete_topology (boolean_algebra (has_add name)) := sorry --non-trivial
lemma new_lemma_98459 (h0 : monoid (comm_group (has_add (has_add name)))) : monoid.fg (comm_group (has_add (has_add name))) := sorry --non-trivial
lemma new_lemma_98460 (h0 : list (free_add_monoid (semiring (semiring (semiring unsigned))))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_98461 (h0 : topological_space (semigroup (finset name))) : preconnected_space (semigroup (finset name)) := sorry --non-trivial
lemma new_lemma_98462 (h0 : uniform_space (ring (has_neg (has_neg (add_cancel_monoid name))))) : complete_space (ring (has_neg (has_neg (add_cancel_monoid name)))) := sorry --non-trivial
lemma new_lemma_98463 (h0 : function.extfun Type complete_lattice) : @is_compactly_generated.{0} (has_norm.{0} string_imp) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (has_norm.{0} string_imp))  := sorry --non-trivial
lemma new_lemma_98464 (h0 : topological_space (canonically_ordered_monoid (has_bot name))) : regular_space (canonically_ordered_monoid (has_bot name)) := sorry --non-trivial
lemma new_lemma_98465 (h0 : ring (complete_semilattice_Sup (random_gen linarith.comp_source))) : rank_condition (complete_semilattice_Sup (random_gen linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_98466 (h0 : function.extfun Type ring) : @is_principal_ideal_ring.{0} (cancel_monoid.{0} (option.{0} empty)) (@function.extfun_app.{2 1} Type ring.{0} h0 (cancel_monoid.{0} (option.{0} empty)))  := sorry --non-trivial
lemma new_lemma_98467 (h0 : topological_space (has_neg (normed_comm_ring unsigned))) : totally_disconnected_space (has_neg (normed_comm_ring unsigned)) := sorry --non-trivial
lemma new_lemma_98468 (h0 : group (comm_group (has_add pos))) : normalizer_condition (comm_group (has_add pos)) := sorry --non-trivial
lemma new_lemma_98469 (h0 : ring (has_sub congr_arg_kind)) : is_principal_ideal_ring (has_sub congr_arg_kind) := sorry --non-trivial
lemma new_lemma_98470 (h0 : ordered_comm_monoid (has_pos_part (has_Inf (has_Inf (has_add (has_Inf pos)))))) : has_exists_mul_of_le (has_pos_part (has_Inf (has_Inf (has_add (has_Inf pos))))) := sorry --non-trivial
lemma new_lemma_98471 (h0 : topological_space (has_inv to_additive.value_type)) : irreducible_space (has_inv to_additive.value_type) := sorry --non-trivial
lemma new_lemma_98472 (h0 : cancel_comm_monoid_with_zero (option ennreal)) : unique_factorization_monoid (option ennreal) := sorry --non-trivial
lemma new_lemma_98473 (h0 : topological_space (canonically_ordered_comm_semiring (boolean_algebra.core pos))) : preconnected_space (canonically_ordered_comm_semiring (boolean_algebra.core pos)) := sorry --non-trivial
lemma new_lemma_98474 (h0 : set (char -> string.iterator_imp)) : set.separates_points h0 := sorry --non-trivial
lemma new_lemma_98475 (h0 : ring (canonically_ordered_comm_semiring Type)) : is_principal_ideal_ring (canonically_ordered_comm_semiring Type) := sorry --non-trivial
lemma new_lemma_98476 (h0 : functor.add_const (ring (semigroup name)) Type) : @is_domain.{0} (semigroup.{0} name) (@functor.add_const.run.{0 1} (ring.{0} (semigroup.{0} name)) Type h0)  := sorry --non-trivial
lemma new_lemma_98477 (h0 : cancel_comm_monoid_with_zero (has_neg (finset pos))) : unique_factorization_monoid (has_neg (finset pos)) := sorry --non-trivial
lemma new_lemma_98478 (h0 : has_lt (mul_one_class (add_comm_semigroup fun_info))) : no_max_order (mul_one_class (add_comm_semigroup fun_info)) := sorry --non-trivial
lemma new_lemma_98479 (h0 : monoid (comm_group (has_nndist (has_to_string Type)))) : monoid.fg (comm_group (has_nndist (has_to_string Type))) := sorry --non-trivial
lemma new_lemma_98480 (h0 : topological_space (semigroup (finset linarith.comp))) : path_connected_space (semigroup (finset linarith.comp)) := sorry --non-trivial
lemma new_lemma_98481 (h0 : function.extfun Type topological_space) : @path_connected_space.{0} (has_union.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_union.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_98482 (h0 : function.extfun Type complete_lattice) : @is_atomistic.{0} (free_add_monoid.{0} unsigned) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (free_add_monoid.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_98483 (h0 : functor.add_const (function.extfun Type topological_space) linarith.comp) : @t1_space.{0} (has_Inf.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) linarith.comp h0) (has_Inf.{0} pos))  := sorry --non-trivial
lemma new_lemma_98484 (h0 : group (has_nndist (has_neg pos))) : group.fg (has_nndist (has_neg pos)) := sorry --non-trivial
lemma new_lemma_98485 (h0 : ring (simple_graph enat)) : is_domain (simple_graph enat) := sorry --non-trivial
lemma new_lemma_98486 (h0 : complete_lattice (comm_group (comm_group (comm_group (comm_group pos))))) : is_compactly_generated (comm_group (comm_group (comm_group (comm_group pos)))) := sorry --non-trivial
lemma new_lemma_98487 (h0 : complete_lattice (simple_graph (has_ssubset linarith.comp_source))) : is_compactly_generated (simple_graph (has_ssubset linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_98488 (h0 : group (has_compl (has_nnnorm (random_gen char)))) : is_cyclic (has_compl (has_nnnorm (random_gen char))) := sorry --non-trivial
lemma new_lemma_98489 (h0 : monoid (has_norm linarith.ineq)) : monoid.fg (has_norm linarith.ineq) := sorry --non-trivial
lemma new_lemma_98490 (h0 : topological_space (boolean_algebra.core (has_add linarith.comp))) : locally_compact_space (boolean_algebra.core (has_add linarith.comp)) := sorry --non-trivial
lemma new_lemma_98491 (h0 : functor.add_const (cancel_comm_monoid_with_zero (has_add linarith.comp)) (has_neg pos)) : @unique_factorization_monoid.{0} (has_add.{0} linarith.comp) (@functor.add_const.run.{0 0} (cancel_comm_monoid_with_zero.{0} (has_add.{0} linarith.comp)) (has_neg.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_98492 (h0 : functor.add_const (ordered_comm_monoid (has_Inf linarith.comp)) Type) : @has_exists_mul_of_le.{0} (has_Inf.{0} linarith.comp) (@functor.add_const.run.{0 1} (ordered_comm_monoid.{0} (has_Inf.{0} linarith.comp)) Type h0)  := sorry --non-trivial
lemma new_lemma_98493 (h0 : topological_space (has_norm (random_gen num))) : path_connected_space (has_norm (random_gen num)) := sorry --non-trivial
lemma new_lemma_98494 (h0 : functor.add_const (topological_space (linear_ordered_comm_monoid_with_zero unsigned)) empty) : @loc_path_connected_space.{0} (linear_ordered_comm_monoid_with_zero.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (linear_ordered_comm_monoid_with_zero.{0} unsigned)) empty h0)  := sorry --non-trivial
lemma new_lemma_98495 (h3 : topological_space (normed_group fun_info)) : path_connected_space (normed_group fun_info) := sorry --non-trivial
lemma new_lemma_98496 (h0 : function.extfun (Type 1) topological_space) : @t1_space.{1} (plift.{1} empty) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} h0 (plift.{1} empty))  := sorry --non-trivial
lemma new_lemma_98497 (h0 : function.extfun Type filter) : filter.ne_bot (function.extfun_app h0 (with_bot linarith.comp)) := sorry --non-trivial
lemma new_lemma_98498 (h0 : has_mul (has_compl fun_info)) (h1 : topological_space (con (has_compl fun_info))) : path_connected_space (con (has_compl fun_info)) := sorry --non-trivial
lemma new_lemma_98499 (h0 : topological_space (simple_graph (ring linarith.comp))) : normal_space (simple_graph (ring linarith.comp)) := sorry --non-trivial
lemma new_lemma_98500 (h0 : filter (has_norm char)) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_98501 (h0 : list (boolean_algebra.core congr_arg_kind)) : palindrome h0 := sorry --non-trivial
lemma new_lemma_98502 (h0 : filter (has_dist (option unsigned))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_98503 (h0 : functor.add_const (functor.add_const (group nnreal) num) num) : @group.fg.{0} nnreal (@functor.add_const.run.{0 0} (group.{0} nnreal) num (@functor.add_const.run.{0 0} (functor.add_const.{0 0} (group.{0} nnreal) num) num h0))  := sorry --non-trivial
lemma new_lemma_98504 (h0 : ring (non_unital_non_assoc_semiring reducibility_hints)) : strong_rank_condition (non_unital_non_assoc_semiring reducibility_hints) := sorry --non-trivial
lemma new_lemma_98505 (h0 : topological_space (semigroup (comm_group ennreal))) : preconnected_space (semigroup (comm_group ennreal)) := sorry --non-trivial
lemma new_lemma_98506 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @t0_space.{0} (complete_distrib_lattice.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (complete_distrib_lattice.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_98507 (h0 : functor.add_const (ring (finset name)) name) : @is_principal_ideal_ring.{0} (finset.{0} name) (@functor.add_const.run.{0 0} (ring.{0} (finset.{0} name)) name h0)  := sorry --non-trivial
lemma new_lemma_98508 (h0 : functor.add_const (topological_space (add_cancel_monoid Type)) linarith.comp) : @normal_space.{1} (add_cancel_monoid.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (add_cancel_monoid.{1} Type)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_98509 (h0 : complete_lattice (id (random_gen fun_info))) : is_compactly_generated (id (random_gen fun_info)) := sorry --non-trivial
lemma new_lemma_98510 (h0 : topological_space (mul_zero_class (semiring num))) : totally_disconnected_space (mul_zero_class (semiring num)) := sorry --non-trivial
lemma new_lemma_98511 (h0 : complete_lattice (ordered_comm_monoid (semigroup (ring linarith.comp)))) : complete_lattice.is_Sup_finite_compact (ordered_comm_monoid (semigroup (ring linarith.comp))) := sorry --non-trivial
lemma new_lemma_98512 (h0 : functor.add_const (semiring (comm_group linarith.comp)) linarith.comp) : @is_noetherian_ring.{0} (comm_group.{0} linarith.comp) (@functor.add_const.run.{0 0} (semiring.{0} (comm_group.{0} linarith.comp)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_98513 (h0 : function.extfun (finset (Type -> Type)) (has_mem.mem topological_space)) : @path_connected_space.{0} (has_top.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type topological_space.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) topological_space.{0} (@function.extfun_app.{2 0} (finset.{1} (Type → Type)) (@has_mem.mem.{1 1} (Type → Type) (finset.{1} (Type → Type)) (@finset.has_mem.{1} (Type → Type)) topological_space.{0}) h0 (@has_emptyc.emptyc.{1} (finset.{1} (Type → Type)) (@finset.has_emptyc.{1} (Type → Type))))) (has_top.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_98514 (h0 : multiset (topological_space (has_div (mul_one_class (mul_one_class (mul_one_class enat)))))) (h1 : add_group (has_div (mul_one_class (mul_one_class (mul_one_class enat))))) : @topological_add_group.{0} (has_div.{0} (mul_one_class.{0} (mul_one_class.{0} (mul_one_class.{0} enat)))) (@multiset.inf.{0} (topological_space.{0} (has_div.{0} (mul_one_class.{0} (mul_one_class.{0} (mul_one_class.{0} enat))))) (@lattice.to_semilattice_inf.{0} (topological_space.{0} (has_div.{0} (mul_one_class.{0} (mul_one_class.{0} (mul_one_class.{0} enat))))) (@conditionally_complete_lattice.to_lattice.{0} (topological_space.{0} (has_div.{0} (mul_one_class.{0} (mul_one_class.{0} (mul_one_class.{0} enat))))) (@complete_lattice.to_conditionally_complete_lattice.{0} (topological_space.{0} (has_div.{0} (mul_one_class.{0} (mul_one_class.{0} (mul_one_class.{0} enat))))) (@topological_space.complete_lattice.{0} (has_div.{0} (mul_one_class.{0} (mul_one_class.{0} (mul_one_class.{0} enat)))))))) (@bounded_order.to_order_top.{0} (topological_space.{0} (has_div.{0} (mul_one_class.{0} (mul_one_class.{0} (mul_one_class.{0} enat))))) (@preorder.to_has_le.{0} (topological_space.{0} (has_div.{0} (mul_one_class.{0} (mul_one_class.{0} (mul_one_class.{0} enat))))) (@partial_order.to_preorder.{0} (topological_space.{0} (has_div.{0} (mul_one_class.{0} (mul_one_class.{0} (mul_one_class.{0} enat))))) (@semilattice_inf.to_partial_order.{0} (topological_space.{0} (has_div.{0} (mul_one_class.{0} (mul_one_class.{0} (mul_one_class.{0} enat))))) (@lattice.to_semilattice_inf.{0} (topological_space.{0} (has_div.{0} (mul_one_class.{0} (mul_one_class.{0} (mul_one_class.{0} enat))))) (@conditionally_complete_lattice.to_lattice.{0} (topological_space.{0} (has_div.{0} (mul_one_class.{0} (mul_one_class.{0} (mul_one_class.{0} enat))))) (@complete_lattice.to_conditionally_complete_lattice.{0} (topological_space.{0} (has_div.{0} (mul_one_class.{0} (mul_one_class.{0} (mul_one_class.{0} enat))))) (@topological_space.complete_lattice.{0} (has_div.{0} (mul_one_class.{0} (mul_one_class.{0} (mul_one_class.{0} enat))))))))))) (@complete_lattice.to_bounded_order.{0} (topological_space.{0} (has_div.{0} (mul_one_class.{0} (mul_one_class.{0} (mul_one_class.{0} enat))))) (@topological_space.complete_lattice.{0} (has_div.{0} (mul_one_class.{0} (mul_one_class.{0} (mul_one_class.{0} enat))))))) h0) h1  := sorry --non-trivial
lemma new_lemma_98515 (h0 : ring (semi_normed_ring (mul_one_class (semi_normed_ring linarith.comp_source)))) : rank_condition (semi_normed_ring (mul_one_class (semi_normed_ring linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_98516 (h1 : ring (random_gen to_additive.value_type)) : strong_rank_condition (random_gen to_additive.value_type) := sorry --non-trivial
lemma new_lemma_98517 (h0 : functor.add_const (topological_space (has_nndist environment.implicit_infer_kind)) Type) : @loc_path_connected_space.{0} (has_nndist.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 1} (topological_space.{0} (has_nndist.{0} environment.implicit_infer_kind)) Type h0)  := sorry --non-trivial
lemma new_lemma_98518 (h0 : not (cancel_comm_monoid_with_zero (left_cancel_semigroup num) -> false)) : @unique_factorization_monoid.{0} (left_cancel_semigroup.{0} num) (@classical.by_contradiction'.{1} (cancel_comm_monoid_with_zero.{0} (left_cancel_semigroup.{0} num)) h0)  := sorry --non-trivial
lemma new_lemma_98519 (h0 : functor.comp topological_space finset unsigned) : @preconnected_space.{0} (finset.{0} unsigned) (@functor.comp.run.{0 0 0} topological_space.{0} finset.{0} unsigned h0)  := sorry --non-trivial
lemma new_lemma_98520 (h0 : functor.add_const (functor.add_const (finset linarith.comp) environment.implicit_infer_kind) pos) : finset.nonempty (functor.add_const.run (functor.add_const.run h0)) := sorry --non-trivial
lemma new_lemma_98521 (h0 : group (with_bot (semiring (semiring (semiring (semiring (semiring (semiring unsigned)))))))) : group.fg (with_bot (semiring (semiring (semiring (semiring (semiring (semiring unsigned))))))) := sorry --non-trivial
lemma new_lemma_98522 (h0 : functor.add_const (cancel_comm_monoid_with_zero (canonically_ordered_comm_semiring linarith.comp)) (has_add Type)) : @unique_factorization_monoid.{0} (canonically_ordered_comm_semiring.{0} linarith.comp) (@functor.add_const.run.{0 1} (cancel_comm_monoid_with_zero.{0} (canonically_ordered_comm_semiring.{0} linarith.comp)) (has_add.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_98523 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @regular_space.{0} (canonically_ordered_comm_semiring.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (canonically_ordered_comm_semiring.{0} unsigned)) name (@functor.comp.run.{0 0 0} topological_space.{0} canonically_ordered_comm_semiring.{0} unsigned (@function.extfun_app.{2 1} Type (functor.comp.{0 0 0} topological_space.{0} canonically_ordered_comm_semiring.{0}) (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 (functor.comp.{0 0 0} topological_space.{0} canonically_ordered_comm_semiring.{0})) unsigned)))  := sorry --non-trivial
lemma new_lemma_98524 (h0 : functor.add_const (topological_space (bin_tree num)) (semiring (semiring num))) : @topological_space.separable_space.{0} (bin_tree.{0} num) (@functor.add_const.run.{0 0} (topological_space.{0} (bin_tree.{0} num)) (semiring.{0} (semiring.{0} num)) h0)  := sorry --non-trivial
lemma new_lemma_98525 (h0 : ring (ring (has_add (ring Type)))) : rank_condition (ring (has_add (ring Type))) := sorry --non-trivial
lemma new_lemma_98526 (h0 : complete_lattice (random_gen (random_gen fun_info))) : complete_lattice.is_Sup_finite_compact (random_gen (random_gen fun_info)) := sorry --non-trivial
lemma new_lemma_98527 (h0 : functor.add_const (add_monoid (normed_comm_ring name)) (has_nndist pos)) : @add_monoid.fg.{0} (normed_comm_ring.{0} name) (@functor.add_const.run.{0 0} (add_monoid.{0} (normed_comm_ring.{0} name)) (has_nndist.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_98528 (h0 : functor.add_const (topological_space (normed_comm_ring pos)) pos) : @t1_space.{0} (normed_comm_ring.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (normed_comm_ring.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_98529 (h0 : ring (is_R_or_C (semiring (semiring unsigned)))) : is_domain (is_R_or_C (semiring (semiring unsigned))) := sorry --non-trivial
lemma new_lemma_98530 (h0 : functor.add_const (function.extfun Type topological_space) pos) : @preirreducible_space.{0} (semigroup.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) pos h0) (semigroup.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_98531 (h0 : ordered_add_comm_monoid (ordered_comm_group (option (option (option ennreal))))) : archimedean (ordered_comm_group (option (option (option ennreal)))) := sorry --non-trivial
lemma new_lemma_98532 (h0 : functor.add_const (function.extfun Type ring) congr_arg_kind) : @is_domain.{0} nnreal (@function.extfun_app.{2 1} Type ring.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type ring.{0}) congr_arg_kind h0) nnreal)  := sorry --non-trivial
lemma new_lemma_98533 (h0 : topological_space (monoid num)) : totally_separated_space (monoid num) := sorry --non-trivial
lemma new_lemma_98534 (h0 : functor.add_const (function.extfun Type ring) name) : @is_principal_ideal_ring.{0} (has_Inf.{0} pos) (@function.extfun_app.{2 1} Type ring.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type ring.{0}) name h0) (has_Inf.{0} pos))  := sorry --non-trivial
lemma new_lemma_98535 (h0 : topological_space (has_norm (has_norm to_additive.value_type))) : t0_space (has_norm (has_norm to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_98536 (h0 : not (function.extfun Type topological_space -> false)) : @path_connected_space.{0} (complete_semilattice_Sup.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (complete_semilattice_Sup.{0} num))  := sorry --non-trivial
lemma new_lemma_98537 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_add_cyclic.{0} (normed_group.{0} linarith.ineq) (@function.extfun_app.{2 1} Type add_group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 add_group.{0}) (normed_group.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_98538 (h0 : function.extfun Type (functor.add_const (ring pos))) : @is_domain.{0} pos (@functor.add_const.run.{0 0} (ring.{0} pos) name (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (ring.{0} pos)) h0 name))  := sorry --non-trivial
lemma new_lemma_98539 (h0 : function.extfun Type list) : list.nodup (function.extfun_app h0 (has_to_string empty)) := sorry --non-trivial
lemma new_lemma_98540 (h0 : topological_space (generalized_boolean_algebra (has_add pos))) : path_connected_space (generalized_boolean_algebra (has_add pos)) := sorry --non-trivial
lemma new_lemma_98541 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @unique_factorization_monoid.{0} (has_pos_part.{0} real) (@function.extfun_app.{2 1} Type cancel_comm_monoid_with_zero.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 cancel_comm_monoid_with_zero.{0}) (has_pos_part.{0} real))  := sorry --non-trivial
lemma new_lemma_98542 (h1 : not (complete_lattice (measurable_space congr_arg_kind) -> false)) : complete_lattice.is_Sup_finite_compact (measurable_space congr_arg_kind) := sorry --non-trivial
lemma new_lemma_98543 (h0 : function.extfun Type topological_space) : @path_connected_space.{0} (bin_tree.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (bin_tree.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_98544 (h0 : finset (comm_monoid empty)) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_98545 (h2 : complete_lattice (nondiscrete_normed_field fun_info)) : complete_lattice.is_Sup_finite_compact (nondiscrete_normed_field fun_info) := sorry --non-trivial
lemma new_lemma_98546 (h0 : topological_space (free_add_monoid num)) : normal_space (free_add_monoid num) := sorry --non-trivial
lemma new_lemma_98547 (h0 : functor.add_const (topological_space (has_nndist empty)) unsigned) : @preirreducible_space.{0} (has_nndist.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (has_nndist.{0} empty)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_98548 (h0 : cancel_comm_monoid_with_zero (complete_distrib_lattice congr_arg_kind)) : unique_factorization_monoid (complete_distrib_lattice congr_arg_kind) := sorry --non-trivial
lemma new_lemma_98549 (h0 : function.extfun nat fin) : @complete_lattice.is_Sup_finite_compact.{1} (sub_neg_monoid.{1} Type) (@matrix.vec_empty.{1} (complete_lattice.{1} (sub_neg_monoid.{1} Type)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_98550 (h0 : functor.add_const (topological_space (ring empty)) (option num)) : @topological_space.separable_space.{0} (ring.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (ring.{0} empty)) (option.{0} num) h0)  := sorry --non-trivial
lemma new_lemma_98551 (h0 : has_mem.mem ring has_emptyc.emptyc) : @rank_condition.{0} (random_gen.{0} num) (@function.extfun_app.{2 1} Type ring.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) ring.{0} h0) (random_gen.{0} num))  := sorry --non-trivial
lemma new_lemma_98552 (h0 : topological_space (add_cancel_monoid (finset Type))) : totally_disconnected_space (add_cancel_monoid (finset Type)) := sorry --non-trivial
lemma new_lemma_98553 (h0 : set (mul_one_class string.iterator_imp -> std_gen)) : set.separates_points h0 := sorry --non-trivial
lemma new_lemma_98554 (h0 : topological_space (linear_ordered_comm_monoid_with_zero congr_arg_kind)) : preirreducible_space (linear_ordered_comm_monoid_with_zero congr_arg_kind) := sorry --non-trivial
lemma new_lemma_98555 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @unique_factorization_monoid.{0} (canonically_ordered_add_monoid.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type cancel_comm_monoid_with_zero.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 cancel_comm_monoid_with_zero.{0}) (canonically_ordered_add_monoid.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_98556 (h0 : functor.add_const (topological_space (mul_zero_class Type)) name) : @irreducible_space.{1} (mul_zero_class.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (mul_zero_class.{1} Type)) name h0)  := sorry --non-trivial
lemma new_lemma_98557 (h0 : topological_space (random_gen (random_gen linarith.comp_source))) : irreducible_space (random_gen (random_gen linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_98558 (h0 : add_group (fintype (random_gen (random_gen (comm_ring (random_gen to_additive.value_type)))))) : is_add_cyclic (fintype (random_gen (random_gen (comm_ring (random_gen to_additive.value_type))))) := sorry --non-trivial
lemma new_lemma_98559 (h1 : complete_lattice (has_div linarith.comp_source)) : is_compactly_generated (has_div linarith.comp_source) := sorry --non-trivial
lemma new_lemma_98560 (h0 : ring (has_compl (has_nnnorm char))) : rank_condition (has_compl (has_nnnorm char)) := sorry --non-trivial
lemma new_lemma_98561 (h0 : functor.add_const (topological_space (has_to_string unsigned)) Type) : @topological_space.separable_space.{0} (has_to_string.{0} unsigned) (@functor.add_const.run.{0 1} (topological_space.{0} (has_to_string.{0} unsigned)) Type h0)  := sorry --non-trivial
lemma new_lemma_98562 (h0 : ordered_cancel_add_comm_monoid ennreal -> ordered_cancel_add_comm_monoid ennreal -> Prop) : reflexive h0 := sorry --non-trivial
lemma new_lemma_98563 (h0 : finset (has_to_string (has_add name))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_98564 (h0 : function.extfun Type list) : palindrome (function.extfun_app h0 (linear_ordered_comm_monoid_with_zero empty)) := sorry --non-trivial
lemma new_lemma_98565 (h0 : functor.add_const (function.extfun Type topological_space) pos) : @topological_space.separable_space.{0} (semigroup.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) pos h0) (semigroup.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_98566 (h0 : uniform_space (normed_group (random_gen (random_gen to_additive.value_type)))) : complete_space (normed_group (random_gen (random_gen to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_98567 (h1 : complete_lattice (mul_one_class reducibility_hints)) : complete_lattice.is_Sup_finite_compact (mul_one_class reducibility_hints) := sorry --non-trivial
lemma new_lemma_98568 (h0 : list (has_neg (semigroup environment.implicit_infer_kind))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_98569 (h0 : fin has_zero.zero) : @is_compactly_generated.{0} (canonically_linear_ordered_monoid.{0} name) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@matrix.vec_empty.{1} (function.extfun.{2 1} Type complete_lattice.{0}) h0) (canonically_linear_ordered_monoid.{0} name))  := sorry --non-trivial
lemma new_lemma_98570 (h0 : group (add_cancel_monoid (has_to_string (has_add (has_add pos))))) : group.fg (add_cancel_monoid (has_to_string (has_add (has_add pos)))) := sorry --non-trivial
lemma new_lemma_98571 (h0 : complete_lattice (canonically_ordered_monoid (sub_neg_monoid Type))) : complete_lattice.is_Sup_finite_compact (canonically_ordered_monoid (sub_neg_monoid Type)) := sorry --non-trivial
lemma new_lemma_98572 (h0 : complete_lattice (linear_ordered_field (option congr_arg_kind))) : is_compactly_generated (linear_ordered_field (option congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_98573 (h0 : function.extfun (finset Type) (has_mem.mem (measurable_space unsigned))) : @add_monoid.fg.{0} (measurable_space.{0} unsigned) (@finset.pi.empty.{1 0} Type add_monoid.{0} (measurable_space.{0} unsigned) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (measurable_space.{0} unsigned)) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_98574 (h0 : functor.add_const (function.extfun Type topological_space) name) : @loc_path_connected_space.{0} (has_nndist.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) name h0) (has_nndist.{0} name))  := sorry --non-trivial
lemma new_lemma_98575 (h2 : complete_lattice (denumerable fun_info)) : complete_lattice.is_Sup_finite_compact (denumerable fun_info) := sorry --non-trivial
lemma new_lemma_98576 (h0 : functor.add_const (group (linear_ordered_cancel_comm_monoid empty)) unsigned) : @is_cyclic.{0} (linear_ordered_cancel_comm_monoid.{0} empty) (@functor.add_const.run.{0 0} (group.{0} (linear_ordered_cancel_comm_monoid.{0} empty)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_98577 (h0 : group (measurable_space linarith.comp_source)) : is_cyclic (measurable_space linarith.comp_source) := sorry --non-trivial
lemma new_lemma_98578 (h0 : functor.add_const (group (mul_zero_class environment.implicit_infer_kind)) Type) : @group.fg.{0} (mul_zero_class.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 1} (group.{0} (mul_zero_class.{0} environment.implicit_infer_kind)) Type h0)  := sorry --non-trivial
lemma new_lemma_98579 (h0 : uniform_space (finset (monoid_with_zero (option (option pos))))) : complete_space (finset (monoid_with_zero (option (option pos)))) := sorry --non-trivial
lemma new_lemma_98580 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : finset.nonempty (function.extfun_app (function.extfun_app h0 finset) (comm_group ennreal)) := sorry --non-trivial
lemma new_lemma_98581 (h0 : ring (complete_semilattice_Sup linarith.ineq)) : is_domain (complete_semilattice_Sup linarith.ineq) := sorry --non-trivial
lemma new_lemma_98582 (h0 : ring (has_ssubset (add_comm_semigroup environment.projection_info))) : strong_rank_condition (has_ssubset (add_comm_semigroup environment.projection_info)) := sorry --non-trivial
lemma new_lemma_98583 (h0 : functor.add_const (topological_space (has_zero unsigned)) ennreal) : @regular_space.{0} (has_zero.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (has_zero.{0} unsigned)) ennreal h0)  := sorry --non-trivial
lemma new_lemma_98584 (h0 : topological_space (has_norm (random_gen linarith.ineq))) : discrete_topology (has_norm (random_gen linarith.ineq)) := sorry --non-trivial
lemma new_lemma_98585 (h0 : not (add_group (has_compl reducibility_hints) -> false)) : @is_add_cyclic.{0} (has_compl.{0} reducibility_hints) (@classical.by_contradiction'.{1} (add_group.{0} (has_compl.{0} reducibility_hints)) h0)  := sorry --non-trivial
lemma new_lemma_98586 (h0 : topological_space (non_unital_non_assoc_semiring (distrib (mul_one_class enat)))) (h1 : preorder (non_unital_non_assoc_semiring (distrib (mul_one_class enat)))) : order_topology (non_unital_non_assoc_semiring (distrib (mul_one_class enat))) := sorry --non-trivial
lemma new_lemma_98587 (h0 : functor.add_const (topological_space (has_neg_part name)) unsigned) : @discrete_topology.{0} (has_neg_part.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (has_neg_part.{0} name)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_98588 (h0 : functor.add_const (filter (has_add name)) name) : countable_Inter_filter (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_98589 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @normal_space.{0} (linear_ordered_field.{0} ennreal) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (linear_ordered_field.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_98590 (h0 : set (has_ssubset linarith.ineq)) : set.subsingleton h0 := sorry --non-trivial
lemma new_lemma_98591 (h0 : functor.add_const (function.extfun Type topological_space) (has_Inf (has_pos_part pos))) : @sequential_space.{0} (semigroup.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) (has_Inf.{0} (has_pos_part.{0} pos)) h0) (semigroup.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_98592 (h0 : functor.add_const (topological_space (has_to_string Type)) name) : @normal_space.{1} (has_to_string.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (has_to_string.{1} Type)) name h0)  := sorry --non-trivial
lemma new_lemma_98593 (h0 : function.extfun Type ring) : @is_principal_ideal_ring.{0} (has_nndist.{0} num) (@function.extfun_app.{2 1} Type ring.{0} h0 (has_nndist.{0} num))  := sorry --non-trivial
lemma new_lemma_98594 (h0 : function.extfun Type filter) : filter.ne_bot (function.extfun_app h0 (non_assoc_semiring num)) := sorry --non-trivial
lemma new_lemma_98595 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @monoid.fg.{0} (has_add.{0} num) (@function.extfun_app.{2 1} Type monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 monoid.{0}) (has_add.{0} num))  := sorry --non-trivial
lemma new_lemma_98596 (h1 : ring (has_ssubset std_gen)) : rank_condition (has_ssubset std_gen) := sorry --non-trivial
lemma new_lemma_98597 (h0 : topological_space (complete_distrib_lattice (option (option empty)))) : totally_separated_space (complete_distrib_lattice (option (option empty))) := sorry --non-trivial
lemma new_lemma_98598 (h0 : add_monoid (non_assoc_semiring num)) : add_monoid.fg (non_assoc_semiring num) := sorry --non-trivial
lemma new_lemma_98599 (h0 : function.extfun Type complete_lattice) : @is_compactly_generated.{0} (add_cancel_monoid.{0} empty) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (add_cancel_monoid.{0} empty))  := sorry --non-trivial
lemma new_lemma_98600 (h0 : function.extfun Type complete_lattice) : @complete_lattice.is_Sup_finite_compact.{0} real (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 real)  := sorry --non-trivial
lemma new_lemma_98601 (h0 : function.extfun Type topological_space) : @normal_space.{0} (has_nndist.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_nndist.{0} num))  := sorry --non-trivial
lemma new_lemma_98602 (h5 : ring (mul_one_class enat)) : is_domain (mul_one_class enat) := sorry --non-trivial
lemma new_lemma_98603 (h0 : functor.add_const (ring (has_neg name)) environment.implicit_infer_kind) : @is_domain.{0} (has_neg.{0} name) (@functor.add_const.run.{0 0} (ring.{0} (has_neg.{0} name)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_98604 (h0 : topological_space (has_lt to_additive.value_type)) (h1 : preorder (has_lt to_additive.value_type)) : order_closed_topology (has_lt to_additive.value_type) := sorry --non-trivial
lemma new_lemma_98605 (h0 : function.extfun Type complete_lattice) : @is_atomistic.{0} (normed_lattice_add_comm_group.{0} real) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (normed_lattice_add_comm_group.{0} real))  := sorry --non-trivial
lemma new_lemma_98606 (h0 : functor.add_const (ring environment.implicit_infer_kind) (has_Inf (finset linarith.comp))) : @is_principal_ideal_ring.{0} environment.implicit_infer_kind (@functor.add_const.run.{0 0} (ring.{0} environment.implicit_infer_kind) (has_Inf.{0} (finset.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_98607 (h0 : functor.add_const (topological_space (boolean_algebra pos)) (ordered_ring (ordered_ring linarith.comp))) : @sequential_space.{0} (boolean_algebra.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (boolean_algebra.{0} pos)) (ordered_ring.{0} (ordered_ring.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_98608 (h0 : functor.add_const Prop (finset num)) : functor.add_const.run h0 := sorry --non-trivial
lemma new_lemma_98609 (h0 : functor.add_const (group (mul_zero_class Type)) name) : @is_cyclic.{1} (mul_zero_class.{1} Type) (@functor.add_const.run.{1 0} (group.{1} (mul_zero_class.{1} Type)) name h0)  := sorry --non-trivial
lemma new_lemma_98610 (h0 : topological_space (has_star num)) : totally_disconnected_space (has_star num) := sorry --non-trivial
lemma new_lemma_98611 (h0 : fin has_zero.zero) : @is_simple_group.{0} (has_nndist.{0} pos) (@matrix.vec_empty.{0} (group.{0} (has_nndist.{0} pos)) h0)  := sorry --non-trivial
lemma new_lemma_98612 (h0 : add_group (generalized_boolean_algebra (finset pos))) : is_add_cyclic (generalized_boolean_algebra (finset pos)) := sorry --non-trivial
lemma new_lemma_98613 (h1 : topological_space (with_zero (fintype char))) : t0_space (with_zero (fintype char)) := sorry --non-trivial
lemma new_lemma_98614 (h0 : function.extfun Type topological_space) : @totally_disconnected_space.{0} (linear_ordered_semiring.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (linear_ordered_semiring.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_98615 (h0 : topological_space (complete_semilattice_Sup (semiring unsigned))) : preirreducible_space (complete_semilattice_Sup (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_98616 (h0 : topological_space (has_add (option pos))) : sequential_space (has_add (option pos)) := sorry --non-trivial
lemma new_lemma_98617 (h0 : topological_space (with_bot (random_gen linarith.ineq))) : totally_separated_space (with_bot (random_gen linarith.ineq)) := sorry --non-trivial
lemma new_lemma_98618 (h0 : ring (semigroup (add_comm_monoid (has_add environment.implicit_infer_kind)))) : is_principal_ideal_ring (semigroup (add_comm_monoid (has_add environment.implicit_infer_kind))) := sorry --non-trivial
lemma new_lemma_98619 (h0 : group (denumerable (random_gen reducibility_hints))) : is_cyclic (denumerable (random_gen reducibility_hints)) := sorry --non-trivial
lemma new_lemma_98620 (h0 : functor.add_const (semiring (has_neg Type)) linarith.comp) : @is_noetherian_ring.{1} (has_neg.{1} Type) (@functor.add_const.run.{1 0} (semiring.{1} (has_neg.{1} Type)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_98621 (h0 : function.extfun (finset Type) (has_mem.mem (has_top linarith.comp))) : @is_add_cyclic.{0} (has_top.{0} linarith.comp) (@finset.pi.empty.{1 0} Type add_group.{0} (has_top.{0} linarith.comp) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (has_top.{0} linarith.comp)) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_98622 (h0 : not (has_mem.mem topological_space has_emptyc.emptyc -> false)) : @irreducible_space.{0} (with_bot.{0} fun_info) (@function.extfun_app.{2 1} Type topological_space.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) topological_space.{0} (@classical.by_contradiction'.{0} (@has_mem.mem.{1 1} (Type → Type) (finset.{1} (Type → Type)) (@finset.has_mem.{1} (Type → Type)) topological_space.{0} (@has_emptyc.emptyc.{1} (finset.{1} (Type → Type)) (@finset.has_emptyc.{1} (Type → Type)))) h0)) (with_bot.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_98623 (h2 : function.extfun Type complete_lattice) : @is_atomistic.{0} (with_one.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type complete_lattice.{0} h2 (with_one.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_98624 (h0 : complete_lattice (ring (option (option (option (option (option ennreal))))))) : is_atomistic (ring (option (option (option (option (option ennreal)))))) := sorry --non-trivial
lemma new_lemma_98625 (h0 : topological_space (has_add real)) : discrete_topology (has_add real) := sorry --non-trivial
lemma new_lemma_98626 (h0 : functor.add_const (complete_lattice (add_cancel_monoid linarith.comp)) Type) : @is_compactly_generated.{0} (add_cancel_monoid.{0} linarith.comp) (@functor.add_const.run.{0 1} (complete_lattice.{0} (add_cancel_monoid.{0} linarith.comp)) Type h0)  := sorry --non-trivial
lemma new_lemma_98627 (h0 : cancel_comm_monoid_with_zero (add_cancel_monoid name)) : unique_factorization_monoid (add_cancel_monoid name) := sorry --non-trivial
lemma new_lemma_98628 (h0 : add_monoid nnreal) : add_monoid.fg nnreal := sorry --non-trivial
lemma new_lemma_98629 (h0 : topological_space (has_bot (has_bot name))) : discrete_topology (has_bot (has_bot name)) := sorry --non-trivial
lemma new_lemma_98630 (h2 : complete_lattice (has_append char)) : is_compactly_generated (has_append char) := sorry --non-trivial
lemma new_lemma_98631 (h0 : topological_space (complete_semilattice_Sup (semiring unsigned))) : t0_space (complete_semilattice_Sup (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_98632 (h0 : uniform_space (random_gen unsigned)) : complete_space (random_gen unsigned) := sorry --non-trivial
lemma new_lemma_98633 (h0 : functor.add_const (ordered_comm_monoid (ring linarith.comp)) environment.implicit_infer_kind) : @has_exists_mul_of_le.{0} (ring.{0} linarith.comp) (@functor.add_const.run.{0 0} (ordered_comm_monoid.{0} (ring.{0} linarith.comp)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_98634 (h0 : topological_space (has_norm (semiring (semiring empty)))) : totally_separated_space (has_norm (semiring (semiring empty))) := sorry --non-trivial
lemma new_lemma_98635 (h0 : function.extfun Type topological_space) : @t0_space.{0} (comm_group.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (comm_group.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_98636 (h0 : list (linear_ordered_comm_monoid_with_zero (option unsigned))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_98637 (h0 : topological_space (has_union empty)) : totally_separated_space (has_union empty) := sorry --non-trivial
lemma new_lemma_98638 (h0 : set (add_comm_semigroup fun_info -> ereal)) : set.separates_points h0 := sorry --non-trivial
lemma new_lemma_98639 (h0 : functor.add_const (topological_space (boolean_algebra empty)) unsigned) : @discrete_topology.{0} (boolean_algebra.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (boolean_algebra.{0} empty)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_98640 (h0 : functor.add_const (ring (has_dist unsigned)) congr_arg_kind) : @rank_condition.{0} (has_dist.{0} unsigned) (@functor.add_const.run.{0 0} (ring.{0} (has_dist.{0} unsigned)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_98641 (h0 : filter (id (semiring (semiring congr_arg_kind)))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_98642 (h0 : topological_space (add_comm_monoid (has_bot real))) : path_connected_space (add_comm_monoid (has_bot real)) := sorry --non-trivial
lemma new_lemma_98643 (h1 : not (function.extfun Type topological_space -> false)) : @irreducible_space.{0} num (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h1) num)  := sorry --non-trivial
lemma new_lemma_98644 (h0 : fin has_zero.zero) : @is_cyclic.{0} (semi_normed_comm_ring.{0} linarith.comp_source) (@matrix.vec_empty.{0} (group.{0} (semi_normed_comm_ring.{0} linarith.comp_source)) h0)  := sorry --non-trivial
lemma new_lemma_98645 (h0 : uniform_space (semiring (has_norm (has_norm (has_norm empty))))) : complete_space (semiring (has_norm (has_norm (has_norm empty)))) := sorry --non-trivial
lemma new_lemma_98646 (h0 : functor.add_const (ring (complete_distrib_lattice linarith.comp)) pos) : @is_domain.{0} (complete_distrib_lattice.{0} linarith.comp) (@functor.add_const.run.{0 0} (ring.{0} (complete_distrib_lattice.{0} linarith.comp)) pos h0)  := sorry --non-trivial
lemma new_lemma_98647 (h0 : functor.add_const (topological_space (boolean_algebra.core pos)) Type) : @preconnected_space.{0} (boolean_algebra.core.{0} pos) (@functor.add_const.run.{0 1} (topological_space.{0} (boolean_algebra.core.{0} pos)) Type h0)  := sorry --non-trivial
lemma new_lemma_98648 (h0 : set (set (mul_one_class (mul_one_class linarith.comp_source)))) (h1 : set (mul_one_class (mul_one_class linarith.comp_source))) : measurable_space.dynkin_system.generate_has h0 h1 := sorry --non-trivial
lemma new_lemma_98649 (h0 : ring (ordered_cancel_add_comm_monoid num)) : is_domain (ordered_cancel_add_comm_monoid num) := sorry --non-trivial
lemma new_lemma_98650 (h0 : functor.add_const (finset (comm_group Type)) linarith.comp) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_98651 (h0 : not (function.extfun Type add_group -> false)) : @is_add_cyclic.{0} (@id.{2} Type to_additive.value_type) (@function.extfun_app.{2 1} Type add_group.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type add_group.{0}) h0) (@id.{2} Type to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_98652 (h0 : topological_space (random_gen (semiring (semiring unsigned)))) : normal_space (random_gen (semiring (semiring unsigned))) := sorry --non-trivial
lemma new_lemma_98653 (h0 : filter (boolean_algebra.core (finset Type))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_98654 (h0 : function.extfun Type topological_space) : @normal_space.{0} (with_bot.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (with_bot.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_98655 (h0 : ring (denumerable char)) : strong_rank_condition (denumerable char) := sorry --non-trivial
lemma new_lemma_98656 (h0 : functor.add_const (ring (add_cancel_monoid empty)) unsigned) : @rank_condition.{0} (add_cancel_monoid.{0} empty) (@functor.add_const.run.{0 0} (ring.{0} (add_cancel_monoid.{0} empty)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_98657 (h0 : topological_space (partial_order num)) : t1_space (partial_order num) := sorry --non-trivial
lemma new_lemma_98658 (h0 : functor.add_const (ring (boolean_algebra pos)) (ring Type)) : @is_principal_ideal_ring.{0} (boolean_algebra.{0} pos) (@functor.add_const.run.{0 1} (ring.{0} (boolean_algebra.{0} pos)) (ring.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_98659 (h0 : topological_space (complete_distrib_lattice unsigned)) : totally_separated_space (complete_distrib_lattice unsigned) := sorry --non-trivial
lemma new_lemma_98660 (h0 : topological_space (has_one fun_info)) : locally_compact_space (has_one fun_info) := sorry --non-trivial
lemma new_lemma_98661 (h0 : not (ring (topological_space reducibility_hints) -> false)) : @rank_condition.{0} (topological_space.{0} reducibility_hints) (@classical.by_contradiction'.{1} (ring.{0} (topological_space.{0} reducibility_hints)) h0)  := sorry --non-trivial
lemma new_lemma_98662 (h0 : ordered_comm_monoid (add_cancel_monoid (has_neg Type))) : has_exists_mul_of_le (add_cancel_monoid (has_neg Type)) := sorry --non-trivial
lemma new_lemma_98663 (h0 : functor.add_const (function.extfun (Type 1) group) pos) : @normalizer_condition.{1} (has_zero.{1} Type) (@function.extfun_app.{3 2} (Type 1) group.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) group.{1}) pos h0) (has_zero.{1} Type))  := sorry --non-trivial
lemma new_lemma_98664 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @path_connected_space.{0} (with_bot.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (with_bot.{0} empty))  := sorry --non-trivial
lemma new_lemma_98665 (h0 : ring (topological_space (has_inv string_imp))) : strong_rank_condition (topological_space (has_inv string_imp)) := sorry --non-trivial
lemma new_lemma_98666 (h4 : topological_space (add_comm_semigroup ereal)) (h5 : set (set (add_comm_semigroup ereal))) : topological_space.is_topological_basis h5 := sorry --non-trivial
lemma new_lemma_98667 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @monoid.fg.{0} (has_norm.{0} fun_info) (@function.extfun_app.{2 1} Type monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 monoid.{0}) (has_norm.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_98668 (h0 : topological_space (mul_zero_class (option name))) : totally_disconnected_space (mul_zero_class (option name)) := sorry --non-trivial
lemma new_lemma_98669 (h0 : not (complete_lattice (uniform_space linarith.comp_source) -> false)) : complete_lattice.is_Sup_finite_compact (uniform_space linarith.comp_source) := sorry --non-trivial
lemma new_lemma_98670 (h0 : function.extfun Type uniform_space) : @separated_space.{0} (ring.{0} name) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (ring.{0} name))  := sorry --non-trivial
lemma new_lemma_98671 (h0 : function.extfun Type topological_space) : @t0_space.{0} (semiring.{0} fun_info) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (semiring.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_98672 (h0 : functor.add_const (topological_space (left_cancel_semigroup empty)) empty) : @t0_space.{0} (left_cancel_semigroup.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (left_cancel_semigroup.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_98673 (h0 : topological_space (canonically_ordered_monoid (has_bot (has_Inf real)))) : t0_space (canonically_ordered_monoid (has_bot (has_Inf real))) := sorry --non-trivial
lemma new_lemma_98674 (h0 : group (normed_comm_ring num)) : is_cyclic (normed_comm_ring num) := sorry --non-trivial
lemma new_lemma_98675 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @has_exists_mul_of_le.{0} (has_pos_part.{0} pos) (@function.extfun_app.{2 1} Type ordered_comm_monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ordered_comm_monoid.{0}) (has_pos_part.{0} pos))  := sorry --non-trivial
lemma new_lemma_98676 (h0 : topological_space (canonically_linear_ordered_monoid (has_Inf Type))) : sequential_space (canonically_linear_ordered_monoid (has_Inf Type)) := sorry --non-trivial
lemma new_lemma_98677 (h0 : ring (has_append (has_nnnorm (has_ssubset fun_info)))) : is_domain (has_append (has_nnnorm (has_ssubset fun_info))) := sorry --non-trivial
lemma new_lemma_98678 (h0 : add_group (add_cancel_monoid (has_add (has_add (has_add name))))) : is_add_cyclic (add_cancel_monoid (has_add (has_add (has_add name)))) := sorry --non-trivial
lemma new_lemma_98679 (h0 : not (function.extfun Type ring -> false)) : @is_principal_ideal_ring.{0} (linear_ordered_comm_ring.{0} empty) (@function.extfun_app.{2 1} Type ring.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type ring.{0}) h0) (linear_ordered_comm_ring.{0} empty))  := sorry --non-trivial
lemma new_lemma_98680 (h0 : functor.add_const (function.extfun Type group) environment.implicit_infer_kind) : @group.fg.{0} (has_neg.{0} linarith.comp) (@function.extfun_app.{2 1} Type group.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type group.{0}) environment.implicit_infer_kind h0) (has_neg.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_98681 (h0 : not (function.extfun Type semiring -> false)) : @is_noetherian_ring.{0} linarith.comp (@function.extfun_app.{2 1} Type semiring.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type semiring.{0}) h0) linarith.comp)  := sorry --non-trivial
lemma new_lemma_98682 (h0 : semiring (ring (option ennreal))) : is_noetherian_ring (ring (option ennreal)) := sorry --non-trivial
lemma new_lemma_98683 (h0 : function.extfun (finset Type) (has_mem.mem (with_bot linarith.comp))) : @totally_disconnected_space.{0} (with_bot.{0} linarith.comp) (@finset.pi.empty.{1 0} Type topological_space.{0} (with_bot.{0} linarith.comp) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (with_bot.{0} linarith.comp)) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_98684 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @monoid.fg.{0} (has_top.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 monoid.{0}) (has_top.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_98685 (h0 : functor.add_const (complete_lattice (semigroup pos)) (mul_zero_class pos)) : @complete_lattice.is_Sup_finite_compact.{0} (semigroup.{0} pos) (@functor.add_const.run.{0 0} (complete_lattice.{0} (semigroup.{0} pos)) (mul_zero_class.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_98686 (h0 : functor.add_const (topological_space (ordered_comm_ring Type)) pos) : @loc_path_connected_space.{1} (ordered_comm_ring.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (ordered_comm_ring.{1} Type)) pos h0)  := sorry --non-trivial
lemma new_lemma_98687 (h0 : topological_space (nondiscrete_normed_field char)) : totally_disconnected_space (nondiscrete_normed_field char) := sorry --non-trivial
lemma new_lemma_98688 (h0 : topological_space (generalized_boolean_algebra (has_bot (has_neg real)))) : path_connected_space (generalized_boolean_algebra (has_bot (has_neg real))) := sorry --non-trivial
lemma new_lemma_98689 (h0 : add_monoid (has_to_string (add_comm_monoid unsigned))) : add_monoid.fg (has_to_string (add_comm_monoid unsigned)) := sorry --non-trivial
lemma new_lemma_98690 (h0 : ring (has_zero (finset pos))) : is_principal_ideal_ring (has_zero (finset pos)) := sorry --non-trivial
lemma new_lemma_98691 (h0 : function.extfun Type semiring) : @is_noetherian_ring.{0} (linear_ordered_comm_group.{0} ennreal) (@function.extfun_app.{2 1} Type semiring.{0} h0 (linear_ordered_comm_group.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_98692 (h0 : function.extfun Type finset) : finset.nonempty (function.extfun_app h0 (has_nndist linarith.comp)) := sorry --non-trivial
lemma new_lemma_98693 (h0 : group (has_bot (has_Inf pos))) : group.fg (has_bot (has_Inf pos)) := sorry --non-trivial
lemma new_lemma_98694 (h0 : function.extfun Type (functor.add_const (ring (has_dist empty)))) : @rank_condition.{0} (has_dist.{0} empty) (@functor.add_const.run.{0 0} (ring.{0} (has_dist.{0} empty)) (option.{0} empty) (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (ring.{0} (has_dist.{0} empty))) h0 (option.{0} empty)))  := sorry --non-trivial
lemma new_lemma_98695 (h0 : functor.add_const (uniform_space (linear_order empty)) (option (option empty))) : @complete_space.{0} (linear_order.{0} empty) (@functor.add_const.run.{0 0} (uniform_space.{0} (linear_order.{0} empty)) (option.{0} (option.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_98696 (h0 : functor.add_const (filter (add_comm_monoid pos)) unsigned) : filter.ne_bot (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_98697 (h0 : functor.add_const (topological_space (finset unsigned)) unsigned) : @totally_disconnected_space.{0} (finset.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (finset.{0} unsigned)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_98698 (h0 : semiring (cancel_monoid (option ennreal))) : is_noetherian_ring (cancel_monoid (option ennreal)) := sorry --non-trivial
lemma new_lemma_98699 (h0 : fin has_zero.zero) : @separated_space.{1} (complete_distrib_lattice.{1} Type) (@matrix.vec_empty.{1} (uniform_space.{1} (complete_distrib_lattice.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_98700 (h0 : functor.add_const (topological_space (has_Inf name)) pos) : @irreducible_space.{0} (has_Inf.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (has_Inf.{0} name)) pos h0)  := sorry --non-trivial
lemma new_lemma_98701 (h0 : not (function.extfun (finset Type) (has_mem.mem string_imp) -> false)) : @is_domain.{0} string_imp (@finset.pi.empty.{1 0} Type ring.{0} string_imp (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) string_imp) (@classical.by_contradiction'.{0} (function.extfun.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) string_imp)) h0) (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_98702 (h0 : topological_space (canonically_ordered_comm_semiring (has_add name))) : path_connected_space (canonically_ordered_comm_semiring (has_add name)) := sorry --non-trivial
lemma new_lemma_98703 (h2 : topological_space (non_unital_non_assoc_semiring linarith.comp_source)) : t0_space (non_unital_non_assoc_semiring linarith.comp_source) := sorry --non-trivial
lemma new_lemma_98704 (h0 : ring (has_to_string (finset name))) : is_principal_ideal_ring (has_to_string (finset name)) := sorry --non-trivial
lemma new_lemma_98705 (h0 : uniform_space (semi_normed_comm_ring (mul_one_class reducibility_hints))) : complete_space (semi_normed_comm_ring (mul_one_class reducibility_hints)) := sorry --non-trivial
lemma new_lemma_98706 (h0 : not (complete_lattice (has_lt linarith.comp_source) -> false)) : @complete_lattice.is_Sup_finite_compact.{0} (has_lt.{0} linarith.comp_source) (@classical.by_contradiction'.{1} (complete_lattice.{0} (has_lt.{0} linarith.comp_source)) h0)  := sorry --non-trivial
lemma new_lemma_98707 (h0 : add_monoid (non_assoc_semiring (option (option empty)))) : add_monoid.fg (non_assoc_semiring (option (option empty))) := sorry --non-trivial
lemma new_lemma_98708 (h0 : topological_space (comm_group environment.implicit_infer_kind)) : regular_space (comm_group environment.implicit_infer_kind) := sorry --non-trivial
lemma new_lemma_98709 (h0 : topological_space (fintype (semiring empty))) : path_connected_space (fintype (semiring empty)) := sorry --non-trivial
lemma new_lemma_98710 (h0 : semiring (add_comm_semigroup std_gen)) (h2 : add_comm_semigroup std_gen) : even h2 := sorry --non-trivial
lemma new_lemma_98711 (h0 : filter (metric_space (semiring unsigned))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_98712 (h0 : topological_space (normed_comm_ring (option ennreal))) : topological_space.separable_space (normed_comm_ring (option ennreal)) := sorry --non-trivial
lemma new_lemma_98713 (h0 : complete_lattice (normed_field (has_lt string.iterator_imp))) : complete_lattice.is_Sup_finite_compact (normed_field (has_lt string.iterator_imp)) := sorry --non-trivial
lemma new_lemma_98714 (h0 : group (has_bot (has_pos_part (sub_neg_monoid (has_add real))))) : is_cyclic (has_bot (has_pos_part (sub_neg_monoid (has_add real)))) := sorry --non-trivial
lemma new_lemma_98715 (h0 : function.extfun Type (functor.comp complete_lattice mul_zero_class)) : @is_compactly_generated.{0} (mul_zero_class.{0} name) (@functor.comp.run.{0 0 0} complete_lattice.{0} mul_zero_class.{0} name (@function.extfun_app.{2 1} Type (functor.comp.{0 0 0} complete_lattice.{0} mul_zero_class.{0}) h0 name))  := sorry --non-trivial
lemma new_lemma_98716 (h0 : ring (has_bot (has_Inf (has_add (has_Inf linarith.comp))))) : rank_condition (has_bot (has_Inf (has_add (has_Inf linarith.comp)))) := sorry --non-trivial
lemma new_lemma_98717 (h0 : function.extfun Type topological_space) : @discrete_topology.{0} (ring.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (ring.{0} num))  := sorry --non-trivial
lemma new_lemma_98718 (h0 : function.extfun Type ring) : @strong_rank_condition.{0} (has_top.{0} fun_info) (@function.extfun_app.{2 1} Type ring.{0} h0 (has_top.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_98719 (h0 : complete_lattice (has_top (random_gen string_imp))) : is_compactly_generated (has_top (random_gen string_imp)) := sorry --non-trivial
lemma new_lemma_98720 (h0 : topological_space (has_norm linarith.comp)) : totally_disconnected_space (has_norm linarith.comp) := sorry --non-trivial
lemma new_lemma_98721 (h0 : topological_space (has_to_string (has_nndist pos))) : loc_path_connected_space (has_to_string (has_nndist pos)) := sorry --non-trivial
lemma new_lemma_98722 (h0 : add_monoid (simple_graph congr_arg_kind)) : add_monoid.fg (simple_graph congr_arg_kind) := sorry --non-trivial
lemma new_lemma_98723 (h0 : topological_space (has_to_string (finset (ring (boolean_algebra pos))))) : path_connected_space (has_to_string (finset (ring (boolean_algebra pos)))) := sorry --non-trivial
lemma new_lemma_98724 (h0 : topological_space (ordered_ring num)) : discrete_topology (ordered_ring num) := sorry --non-trivial
lemma new_lemma_98725 (h0 : Prop) : id (id h0) := sorry --non-trivial
lemma new_lemma_98726 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @separated_space.{1} (has_neg.{1} Type) (@function.extfun_app.{3 2} (Type 1) uniform_space.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 uniform_space.{1}) (has_neg.{1} Type))  := sorry --non-trivial
lemma new_lemma_98727 (h0 : functor.add_const (topological_space (add_cancel_monoid name)) name) : @locally_compact_space.{0} (add_cancel_monoid.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (add_cancel_monoid.{0} name)) name h0)  := sorry --non-trivial
lemma new_lemma_98728 (h0 : group (complete_semilattice_Sup (with_one to_additive.value_type))) : is_cyclic (complete_semilattice_Sup (with_one to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_98729 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @loc_path_connected_space.{1} (ring.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 topological_space.{1}) (ring.{1} Type))  := sorry --non-trivial
lemma new_lemma_98730 (h0 : has_mem.mem (id linarith.ineq) has_emptyc.emptyc) : @strong_rank_condition.{0} (@id.{2} Type linarith.ineq) (@finset.pi.empty.{1 0} Type ring.{0} (@id.{2} Type linarith.ineq) h0)  := sorry --non-trivial
lemma new_lemma_98731 (h0 : functor.add_const (ordered_add_comm_monoid (ordered_comm_ring linarith.comp)) name) : @archimedean.{0} (ordered_comm_ring.{0} linarith.comp) (@functor.add_const.run.{0 0} (ordered_add_comm_monoid.{0} (ordered_comm_ring.{0} linarith.comp)) name h0)  := sorry --non-trivial
lemma new_lemma_98732 (h0 : functor.add_const (finset (plift empty)) (semiring num)) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_98733 (h0 : uniform_space (has_emptyc congr_arg_kind)) : separated_space (has_emptyc congr_arg_kind) := sorry --non-trivial
lemma new_lemma_98734 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @normalizer_condition.{0} (has_nndist.{0} unsigned) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (has_nndist.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_98735 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @irreducible_space.{0} (preorder.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (preorder.{0} empty))  := sorry --non-trivial
lemma new_lemma_98736 (h0 : ring (comm_ring reducibility_hints)) : is_domain (comm_ring reducibility_hints) := sorry --non-trivial
lemma new_lemma_98737 (h0 : function.extfun Type add_group) : @is_add_cyclic.{0} (add_cancel_comm_monoid.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type add_group.{0} h0 (add_cancel_comm_monoid.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_98738 (h2 : function.extfun Type group) : @group.fg.{0} (complete_semilattice_Sup.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type group.{0} h2 (complete_semilattice_Sup.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_98739 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @totally_separated_space.{0} (normed_linear_ordered_group.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (normed_linear_ordered_group.{0} empty))  := sorry --non-trivial
lemma new_lemma_98740 (h0 : not (ring (with_bot num) -> false)) : @rank_condition.{0} (with_bot.{0} num) (@classical.by_contradiction'.{1} (ring.{0} (with_bot.{0} num)) h0)  := sorry --non-trivial
lemma new_lemma_98741 (h0 : functor.add_const (uniform_space (mul_zero_class name)) Type) : @complete_space.{0} (mul_zero_class.{0} name) (@functor.add_const.run.{0 1} (uniform_space.{0} (mul_zero_class.{0} name)) Type h0)  := sorry --non-trivial
lemma new_lemma_98742 (h0 : topological_space (boolean_algebra.core (has_add (ordered_ring Type)))) : normal_space (boolean_algebra.core (has_add (ordered_ring Type))) := sorry --non-trivial
lemma new_lemma_98743 (h0 : ring nnreal) : is_domain nnreal := sorry --non-trivial
lemma new_lemma_98744 (h0 : topological_space (option (option (option pos)))) : discrete_topology (option (option (option pos))) := sorry --non-trivial
lemma new_lemma_98745 (h0 : topological_space (normed_comm_ring (option (option (option unsigned))))) : totally_separated_space (normed_comm_ring (option (option (option unsigned)))) := sorry --non-trivial
lemma new_lemma_98746 (h0 : fin has_zero.zero) : @normal_space.{0} (sub_neg_monoid.{0} (has_add.{0} linarith.comp)) (@matrix.vec_empty.{0} (topological_space.{0} (sub_neg_monoid.{0} (has_add.{0} linarith.comp))) h0)  := sorry --non-trivial
lemma new_lemma_98747 (h0 : list (normed_comm_ring (comm_group (comm_group (comm_group (has_add (comm_group (comm_group name)))))))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_98748 (h0 : add_monoid ennreal) : add_monoid.fg ennreal := sorry --non-trivial
lemma new_lemma_98749 (h0 : functor.comp complete_lattice mul_zero_class pos) : @is_atomistic.{0} (mul_zero_class.{0} pos) (@functor.comp.run.{0 0 0} complete_lattice.{0} mul_zero_class.{0} pos h0)  := sorry --non-trivial
lemma new_lemma_98750 (h0 : topological_space (ring (has_neg_part Type))) : preirreducible_space (ring (has_neg_part Type)) := sorry --non-trivial
lemma new_lemma_98751 (h0 : group (simple_graph name)) : group.fg (simple_graph name) := sorry --non-trivial
lemma new_lemma_98752 (h0 : topological_space (has_norm (random_gen linarith.ineq))) : irreducible_space (has_norm (random_gen linarith.ineq)) := sorry --non-trivial
lemma new_lemma_98753 (h0 : function.extfun Type topological_space) : @t0_space.{0} (boolean_algebra.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (boolean_algebra.{0} pos))  := sorry --non-trivial
lemma new_lemma_98754 (h1 : not (function.extfun Type uniform_space -> false)) : @separated_space.{0} congr_arg_kind (@function.extfun_app.{2 1} Type uniform_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type uniform_space.{0}) h1) congr_arg_kind)  := sorry --non-trivial
lemma new_lemma_98755 (h0 : prod (normed_comm_ring pos) (normed_comm_ring pos)) : id_rel h0 := sorry --non-trivial
lemma new_lemma_98756 (h0 : functor.add_const (topological_space (canonically_ordered_comm_semiring Type)) name) : @path_connected_space.{1} (canonically_ordered_comm_semiring.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (canonically_ordered_comm_semiring.{1} Type)) name h0)  := sorry --non-trivial
lemma new_lemma_98757 (h0 : function.extfun Type topological_space) : @loc_path_connected_space.{0} (semiring.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (semiring.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_98758 (h0 : list (semiring empty)) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_98759 (h0 : filter (ordered_comm_ring (has_add linarith.comp))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_98760 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @normal_space.{0} (has_neg.{0} ennreal) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_neg.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_98761 (h0 : topological_space (canonically_ordered_monoid (has_add (has_pos_part pos)))) : regular_space (canonically_ordered_monoid (has_add (has_pos_part pos))) := sorry --non-trivial
lemma new_lemma_98762 (h0 : fin has_zero.zero) : @topological_space.separable_space.{0} (add_comm_monoid.{0} real) (@matrix.vec_empty.{0} (topological_space.{0} (add_comm_monoid.{0} real)) h0)  := sorry --non-trivial
lemma new_lemma_98763 (h0 : list (ring (has_Inf Type))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_98764 (h0 : ring (random_gen (has_top empty))) : is_principal_ideal_ring (random_gen (has_top empty)) := sorry --non-trivial
lemma new_lemma_98765 (h1 : has_le enat) (h2 : enat) : is_bot h2 := sorry --non-trivial
lemma new_lemma_98766 (h0 : uniform_space (random_gen (semiring empty))) : complete_space (random_gen (semiring empty)) := sorry --non-trivial
lemma new_lemma_98767 (h0 : enat -> enat) (h1 : enat) : function.is_fixed_pt h0 h1 := sorry --non-trivial
lemma new_lemma_98768 (h0 : topological_space (boolean_algebra (has_bot real))) : topological_space.separable_space (boolean_algebra (has_bot real)) := sorry --non-trivial
lemma new_lemma_98769 (h0 : ring (has_le linarith.comp_source)) : rank_condition (has_le linarith.comp_source) := sorry --non-trivial
lemma new_lemma_98770 (h0 : ordered_add_comm_monoid (simple_graph unsigned)) : archimedean (simple_graph unsigned) := sorry --non-trivial
lemma new_lemma_98771 (h0 : functor.add_const (topological_space (pseudo_metric_space empty)) congr_arg_kind) : @preirreducible_space.{0} (pseudo_metric_space.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (pseudo_metric_space.{0} empty)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_98772 (h0 : ring (ring (ring pos))) : is_domain (ring (ring pos)) := sorry --non-trivial
lemma new_lemma_98773 (h0 : uniform_space (add_cancel_monoid (option empty))) : complete_space (add_cancel_monoid (option empty)) := sorry --non-trivial
lemma new_lemma_98774 (h0 : functor.add_const (group (add_comm_monoid linarith.comp)) pos) : @group.fg.{0} (add_comm_monoid.{0} linarith.comp) (@functor.add_const.run.{0 0} (group.{0} (add_comm_monoid.{0} linarith.comp)) pos h0)  := sorry --non-trivial
lemma new_lemma_98775 (h0 : uniform_space (has_nndist (option (option pos)))) : complete_space (has_nndist (option (option pos))) := sorry --non-trivial
lemma new_lemma_98776 (h0 : not (uniform_space (measurable_space unsigned) -> false)) : @separated_space.{0} (measurable_space.{0} unsigned) (@classical.by_contradiction'.{1} (uniform_space.{0} (measurable_space.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_98777 (h0 : function.extfun Type uniform_space) : @complete_space.{0} (semiring.{0} linarith.comp) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (semiring.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_98778 (h0 : list (has_zero (option (option (option pos))))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_98779 (h0 : list (add_comm_monoid (has_to_string pos))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_98780 (h0 : functor.add_const (topological_space (has_zero pos)) name) : @preconnected_space.{0} (has_zero.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (has_zero.{0} pos)) name h0)  := sorry --non-trivial
lemma new_lemma_98781 (h0 : has_lt (has_ssubset (mul_one_class string_imp))) : no_max_order (has_ssubset (mul_one_class string_imp)) := sorry --non-trivial
lemma new_lemma_98782 (h0 : topological_space (uniform_space (mul_one_class (mul_one_class (mul_one_class char))))) : t0_space (uniform_space (mul_one_class (mul_one_class (mul_one_class char)))) := sorry --non-trivial
lemma new_lemma_98783 (h0 : ring (complete_linear_order (has_top empty))) : rank_condition (complete_linear_order (has_top empty)) := sorry --non-trivial
lemma new_lemma_98784 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @archimedean.{0} (finset.{0} (option.{0} unsigned)) (@function.extfun_app.{2 1} Type ordered_add_comm_monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ordered_add_comm_monoid.{0}) (finset.{0} (option.{0} unsigned)))  := sorry --non-trivial
lemma new_lemma_98785 (h0 : functor.add_const (add_monoid (has_add pos)) environment.implicit_infer_kind) : @add_monoid.fg.{0} (has_add.{0} pos) (@functor.add_const.run.{0 0} (add_monoid.{0} (has_add.{0} pos)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_98786 (h0 : group (add_cancel_monoid empty)) : group.fg (add_cancel_monoid empty) := sorry --non-trivial
lemma new_lemma_98787 (h0 : function.extfun Type topological_space) : @totally_separated_space.{0} (left_cancel_monoid.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (left_cancel_monoid.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_98788 (h0 : complete_lattice (has_compl (mul_one_class enat))) : complete_lattice.is_Sup_finite_compact (has_compl (mul_one_class enat)) := sorry --non-trivial
lemma new_lemma_98789 (h0 : group (dlist (has_nnnorm (denumerable linarith.ineq)))) : group.fg (dlist (has_nnnorm (denumerable linarith.ineq))) := sorry --non-trivial
lemma new_lemma_98790 (h0 : not (group (linear_ordered_comm_ring empty) -> false)) : @group.fg.{0} (linear_ordered_comm_ring.{0} empty) (@classical.by_contradiction'.{1} (group.{0} (linear_ordered_comm_ring.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_98791 (h0 : filter fun_info) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_98792 (h0 : functor.add_const (filter (has_neg unsigned)) unsigned) : countable_Inter_filter (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_98793 (h0 : ring (semi_normed_comm_ring linarith.ineq)) : rank_condition (semi_normed_comm_ring linarith.ineq) := sorry --non-trivial
lemma new_lemma_98794 (h0 : finset (distrib_lattice num)) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_98795 (h0 : has_coe (nondiscrete_normed_field (add_comm_semigroup linarith.ineq)) Prop) (h1 : nondiscrete_normed_field (add_comm_semigroup linarith.ineq)) : @coe_b.{1 1} (nondiscrete_normed_field.{0} (add_comm_semigroup.{0} linarith.ineq)) Prop h0 h1  := sorry --non-trivial
lemma new_lemma_98796 (h0 : function.extfun Type topological_space) : @path_connected_space.{0} (ordered_cancel_add_comm_monoid.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (ordered_cancel_add_comm_monoid.{0} pos))  := sorry --non-trivial
lemma new_lemma_98797 (h0 : topological_space (comm_group (finset (has_nndist pos)))) : preirreducible_space (comm_group (finset (has_nndist pos))) := sorry --non-trivial
lemma new_lemma_98798 (h0 : group (has_neg (has_to_string linarith.comp))) : is_simple_group (has_neg (has_to_string linarith.comp)) := sorry --non-trivial
lemma new_lemma_98799 (h0 : filter (finset (has_neg linarith.comp))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_98800 (h0 : functor.add_const (group (has_nndist environment.implicit_infer_kind)) name) : @is_simple_group.{0} (has_nndist.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (group.{0} (has_nndist.{0} environment.implicit_infer_kind)) name h0)  := sorry --non-trivial
lemma new_lemma_98801 (h0 : functor.add_const (ring (comm_group name)) name) : @strong_rank_condition.{0} (comm_group.{0} name) (@functor.add_const.run.{0 0} (ring.{0} (comm_group.{0} name)) name h0)  := sorry --non-trivial
lemma new_lemma_98802 (h0 : semiring (has_Sup (option unsigned))) : is_noetherian_ring (has_Sup (option unsigned)) := sorry --non-trivial
lemma new_lemma_98803 (h0 : functor.add_const (topological_space (has_zero unsigned)) environment.implicit_infer_kind) : @locally_compact_space.{0} (has_zero.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (has_zero.{0} unsigned)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_98804 (h0 : list (complete_distrib_lattice ennreal)) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_98805 (h0 : function.extfun Type uniform_space) : @complete_space.{0} (has_union.{0} unsigned) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (has_union.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_98806 (h0 : functor.add_const (function.extfun Type ring) pos) : @is_principal_ideal_ring.{0} (has_add.{0} linarith.comp) (@function.extfun_app.{2 1} Type ring.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type ring.{0}) pos h0) (has_add.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_98807 (h0 : group (has_Inf (has_add (has_add (ring Type))))) : is_simple_group (has_Inf (has_add (has_add (ring Type)))) := sorry --non-trivial
lemma new_lemma_98808 (h0 : semiring (semigroup ennreal)) : is_noetherian_ring (semigroup ennreal) := sorry --non-trivial
lemma new_lemma_98809 (h0 : topological_space (linear_ordered_comm_group empty)) : totally_separated_space (linear_ordered_comm_group empty) := sorry --non-trivial
lemma new_lemma_98810 (h0 : add_group (mul_one_class reducibility_hints)) : is_add_cyclic (mul_one_class reducibility_hints) := sorry --non-trivial
lemma new_lemma_98811 (h0 : uniform_space (non_unital_non_assoc_semiring reducibility_hints)) : complete_space (non_unital_non_assoc_semiring reducibility_hints) := sorry --non-trivial
lemma new_lemma_98812 (h1 : uniform_space (id linarith.ineq)) : complete_space (id linarith.ineq) := sorry --non-trivial
lemma new_lemma_98813 (h0 : set (char -> add_comm_semigroup (add_comm_semigroup linarith.ineq))) : set.separates_points h0 := sorry --non-trivial
lemma new_lemma_98814 (h0 : function.extfun Type ring) : @strong_rank_condition.{0} (has_inter.{0} empty) (@function.extfun_app.{2 1} Type ring.{0} h0 (has_inter.{0} empty))  := sorry --non-trivial
lemma new_lemma_98815 (h0 : topological_space (has_lt (has_nnnorm (comm_ring linarith.comp_source)))) : t0_space (has_lt (has_nnnorm (comm_ring linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_98816 (h0 : has_mem.mem (random_gen (has_norm (semiring linarith.comp))) has_emptyc.emptyc) : @is_add_cyclic.{0} (random_gen.{0} (has_norm.{0} (semiring.{0} linarith.comp))) (@finset.pi.empty.{1 0} Type add_group.{0} (random_gen.{0} (has_norm.{0} (semiring.{0} linarith.comp))) h0)  := sorry --non-trivial
lemma new_lemma_98817 (h0 : topological_space (has_zero (has_to_string ennreal))) : preconnected_space (has_zero (has_to_string ennreal)) := sorry --non-trivial
lemma new_lemma_98818 (h0 : ordered_add_comm_monoid (add_cancel_monoid (has_neg (normed_comm_ring (finset (has_neg Type)))))) : archimedean (add_cancel_monoid (has_neg (normed_comm_ring (finset (has_neg Type))))) := sorry --non-trivial
lemma new_lemma_98819 (h0 : functor.add_const (ring (ordered_comm_ring Type)) Type) : @rank_condition.{1} (ordered_comm_ring.{1} Type) (@functor.add_const.run.{1 1} (ring.{1} (ordered_comm_ring.{1} Type)) Type h0)  := sorry --non-trivial
lemma new_lemma_98820 (h0 : monoid (has_nndist (comm_group pos))) : monoid.fg (has_nndist (comm_group pos)) := sorry --non-trivial
lemma new_lemma_98821 (h2 : group (comm_ring to_additive.value_type)) : is_cyclic (comm_ring to_additive.value_type) := sorry --non-trivial
lemma new_lemma_98822 (h0 : topological_space (ordered_comm_monoid (ring (boolean_algebra.core pos)))) : preconnected_space (ordered_comm_monoid (ring (boolean_algebra.core pos))) := sorry --non-trivial
lemma new_lemma_98823 (h0 : has_mem.mem linarith.comp_source has_emptyc.emptyc) : @is_cyclic.{0} linarith.comp_source (@finset.pi.empty.{1 0} Type group.{0} linarith.comp_source h0)  := sorry --non-trivial
lemma new_lemma_98824 (h0 : group (comm_group (has_add (finset linarith.comp)))) : normalizer_condition (comm_group (has_add (finset linarith.comp))) := sorry --non-trivial
lemma new_lemma_98825 (h0 : ring (has_ssubset string_imp)) : rank_condition (has_ssubset string_imp) := sorry --non-trivial
lemma new_lemma_98826 (h0 : functor.add_const (list (option num)) num) : list.nodup (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_98827 (h0 : functor.add_const (function.extfun (Type 1) uniform_space) pos) : @separated_space.{1} (boolean_algebra.{1} Type) (@function.extfun_app.{3 2} (Type 1) uniform_space.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) uniform_space.{1}) pos h0) (boolean_algebra.{1} Type))  := sorry --non-trivial
lemma new_lemma_98828 (h0 : functor.add_const (ring (has_to_string ennreal)) pos) : @is_principal_ideal_ring.{0} (has_to_string.{0} ennreal) (@functor.add_const.run.{0 0} (ring.{0} (has_to_string.{0} ennreal)) pos h0)  := sorry --non-trivial
lemma new_lemma_98829 (h0 : mul_one_class char -> mul_one_class char -> Prop) (h1 : list (mul_one_class char)) : list.sorted h0 h1 := sorry --non-trivial
lemma new_lemma_98830 (h0 : ordered_comm_monoid (cancel_monoid (cancel_monoid Type))) : has_exists_mul_of_le (cancel_monoid (cancel_monoid Type)) := sorry --non-trivial
lemma new_lemma_98831 (h0 h1 : pnat) (h2 : ulower (ulower pnat)) : pnat.coprime h0 (pnat.mod h1 (ulower.up (ulower.up h2))) := sorry --non-trivial
lemma new_lemma_98832 (h0 h1 : multiset (has_top (has_bot empty))) : multiset.subset h0 h1 := sorry --non-trivial
lemma new_lemma_98833 (h0 : filter (random_gen (has_nnnorm (has_nnnorm (has_nnnorm fun_info))))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_98834 (h0 : topological_space (has_to_string (has_neg_part name))) : preconnected_space (has_to_string (has_neg_part name)) := sorry --non-trivial
lemma new_lemma_98835 (h0 : topological_space (with_one (random_gen linarith.comp))) : irreducible_space (with_one (random_gen linarith.comp)) := sorry --non-trivial
lemma new_lemma_98836 (h0 : complete_lattice (random_gen (mul_one_class string_imp))) : is_compactly_generated (random_gen (mul_one_class string_imp)) := sorry --non-trivial
lemma new_lemma_98837 (h0 : topological_space (has_union (linear_ordered_semiring (linear_ordered_semiring (semiring num))))) : irreducible_space (has_union (linear_ordered_semiring (linear_ordered_semiring (semiring num)))) := sorry --non-trivial
lemma new_lemma_98838 (h0 : ring (normed_group (semiring (semiring (semiring empty))))) : rank_condition (normed_group (semiring (semiring (semiring empty)))) := sorry --non-trivial
lemma new_lemma_98839 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @preconnected_space.{0} auto.case_option (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) auto.case_option)  := sorry --non-trivial
lemma new_lemma_98840 (h0 : uniform_space (has_Inf (has_neg (has_neg pos)))) : separated_space (has_Inf (has_neg (has_neg pos))) := sorry --non-trivial
lemma new_lemma_98841 (h0 : function.extfun Type topological_space) : @path_connected_space.{0} (comm_monoid.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (comm_monoid.{0} empty))  := sorry --non-trivial
lemma new_lemma_98842 (h2 : topological_space (has_ssubset std_gen)) (h3 : preorder (has_ssubset std_gen)) : order_topology (has_ssubset std_gen) := sorry --non-trivial
lemma new_lemma_98843 (h0 : ring (add_comm_monoid (has_neg name))) : strong_rank_condition (add_comm_monoid (has_neg name)) := sorry --non-trivial
lemma new_lemma_98844 (h0 : functor.add_const (uniform_space (normed_comm_ring linarith.comp)) linarith.comp) : @complete_space.{0} (normed_comm_ring.{0} linarith.comp) (@functor.add_const.run.{0 0} (uniform_space.{0} (normed_comm_ring.{0} linarith.comp)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_98845 (h0 : ring (finset empty)) : rank_condition (finset empty) := sorry --non-trivial
lemma new_lemma_98846 (h0 : ordered_comm_monoid (canonically_linear_ordered_monoid (has_Inf pos))) : has_exists_mul_of_le (canonically_linear_ordered_monoid (has_Inf pos)) := sorry --non-trivial
lemma new_lemma_98847 (h1 : group (has_inv to_additive.value_type)) : is_cyclic (has_inv to_additive.value_type) := sorry --non-trivial
lemma new_lemma_98848 (h0 : filter (linear_ordered_field (has_neg congr_arg_kind))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_98849 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @irreducible_space.{0} (add_comm_monoid.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (add_comm_monoid.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_98850 (h0 : functor.add_const (topological_space (boolean_algebra environment.implicit_infer_kind)) name) : @discrete_topology.{0} (boolean_algebra.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (boolean_algebra.{0} environment.implicit_infer_kind)) name h0)  := sorry --non-trivial
lemma new_lemma_98851 (h0 : fin has_zero.zero) : @archimedean.{0} (complete_distrib_lattice.{0} pos) (@matrix.vec_empty.{0} (ordered_add_comm_monoid.{0} (complete_distrib_lattice.{0} pos)) h0)  := sorry --non-trivial
lemma new_lemma_98852 (h0 : add_monoid (has_to_string (add_cancel_monoid pos))) : add_monoid.fg (has_to_string (add_cancel_monoid pos)) := sorry --non-trivial
lemma new_lemma_98853 (h1 : topological_space (encodable (random_gen string_imp))) : path_connected_space (encodable (random_gen string_imp)) := sorry --non-trivial
lemma new_lemma_98854 (h0 : topological_space (add_cancel_monoid Type)) : loc_path_connected_space (add_cancel_monoid Type) := sorry --non-trivial
lemma new_lemma_98855 (h0 : add_group (has_union (has_union empty))) : is_add_cyclic (has_union (has_union empty)) := sorry --non-trivial
lemma new_lemma_98856 (h0 : ring (with_zero (has_nnnorm linarith.ineq))) : is_domain (with_zero (has_nnnorm linarith.ineq)) := sorry --non-trivial
lemma new_lemma_98857 (h0 : topological_space (normed_group linarith.ineq)) : t0_space (normed_group linarith.ineq) := sorry --non-trivial
lemma new_lemma_98858 (h0 : functor.add_const (ring (ring pos)) linarith.comp) : @strong_rank_condition.{0} (ring.{0} pos) (@functor.add_const.run.{0 0} (ring.{0} (ring.{0} pos)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_98859 (h0 : functor.add_const (add_monoid (preorder num)) congr_arg_kind) : @add_monoid.fg.{0} (preorder.{0} num) (@functor.add_const.run.{0 0} (add_monoid.{0} (preorder.{0} num)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_98860 (h0 : functor.add_const (ring (has_star empty)) congr_arg_kind) : @is_domain.{0} (has_star.{0} empty) (@functor.add_const.run.{0 0} (ring.{0} (has_star.{0} empty)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_98861 (h0 : add_monoid (ring (finset (has_add Type)))) : add_monoid.fg (ring (finset (has_add Type))) := sorry --non-trivial
lemma new_lemma_98862 (h0 : topological_space (canonically_linear_ordered_monoid (has_Inf (sub_neg_monoid real)))) : irreducible_space (canonically_linear_ordered_monoid (has_Inf (sub_neg_monoid real))) := sorry --non-trivial
lemma new_lemma_98863 (h1 : has_mem.mem (measurable_space string_imp) has_emptyc.emptyc) : @totally_separated_space.{0} (measurable_space.{0} string_imp) (@finset.pi.empty.{1 0} Type topological_space.{0} (measurable_space.{0} string_imp) h1)  := sorry --non-trivial
lemma new_lemma_98864 (h0 : topological_space (has_ssubset (mul_one_class enat))) (h1 : preorder (has_ssubset (mul_one_class enat))) : order_closed_topology (has_ssubset (mul_one_class enat)) := sorry --non-trivial
lemma new_lemma_98865 (h1 : ring (nondiscrete_normed_field environment.projection_info)) : is_domain (nondiscrete_normed_field environment.projection_info) := sorry --non-trivial
lemma new_lemma_98866 (h0 : topological_space (denumerable (has_top (has_nnnorm linarith.ineq)))) : totally_disconnected_space (denumerable (has_top (has_nnnorm linarith.ineq))) := sorry --non-trivial
lemma new_lemma_98867 (h0 : semiring (semigroup (finset (finset name)))) : is_noetherian_ring (semigroup (finset (finset name))) := sorry --non-trivial
lemma new_lemma_98868 (h0 : complete_lattice (has_to_string (comm_group Type))) : is_atomistic (has_to_string (comm_group Type)) := sorry --non-trivial
lemma new_lemma_98869 (h0 : not (complete_lattice (semi_normed_ring char) -> false)) : @complete_lattice.is_Sup_finite_compact.{0} (semi_normed_ring.{0} char) (@classical.by_contradiction'.{1} (complete_lattice.{0} (semi_normed_ring.{0} char)) h0)  := sorry --non-trivial
lemma new_lemma_98870 (h0 : add_group environment.projection_info) : is_add_cyclic environment.projection_info := sorry --non-trivial
lemma new_lemma_98871 (h0 : function.extfun Type topological_space) : @path_connected_space.{0} (canonically_ordered_comm_semiring.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (canonically_ordered_comm_semiring.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_98872 (h0 : functor.add_const (group (boolean_algebra.core unsigned)) num) : @is_cyclic.{0} (boolean_algebra.core.{0} unsigned) (@functor.add_const.run.{0 0} (group.{0} (boolean_algebra.core.{0} unsigned)) num h0)  := sorry --non-trivial
lemma new_lemma_98873 (h0 : functor.add_const (group (ordered_comm_ring linarith.comp)) pos) : @normalizer_condition.{0} (ordered_comm_ring.{0} linarith.comp) (@functor.add_const.run.{0 0} (group.{0} (ordered_comm_ring.{0} linarith.comp)) pos h0)  := sorry --non-trivial
lemma new_lemma_98874 (h0 : ring (add_group (semiring num))) : is_domain (add_group (semiring num)) := sorry --non-trivial
lemma new_lemma_98875 (h0 : uniform_space (normed_field (random_gen (has_nnnorm (has_nnnorm linarith.comp_source))))) : complete_space (normed_field (random_gen (has_nnnorm (has_nnnorm linarith.comp_source)))) := sorry --non-trivial
lemma new_lemma_98876 (h0 : filter (has_bot real)) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_98877 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : list.nodup (function.extfun_app (function.extfun_app h0 list) (has_pos_part real)) := sorry --non-trivial
lemma new_lemma_98878 (h1 : not (function.extfun Type filter -> false)) : filter.ne_bot (function.extfun_app (classical.by_contradiction' h1) (has_emptyc linarith.comp)) := sorry --non-trivial
lemma new_lemma_98879 (h0 : topological_space congr_arg_kind) : preirreducible_space congr_arg_kind := sorry --non-trivial
lemma new_lemma_98880 (h0 : topological_space (canonically_ordered_add_monoid empty)) : totally_disconnected_space (canonically_ordered_add_monoid empty) := sorry --non-trivial
lemma new_lemma_98881 (h0 : functor.add_const (ring (normed_comm_ring pos)) (has_neg (has_neg Type))) : @is_domain.{0} (normed_comm_ring.{0} pos) (@functor.add_const.run.{0 1} (ring.{0} (normed_comm_ring.{0} pos)) (has_neg.{1} (has_neg.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_98882 (h0 : function.extfun Type filter) : filter.ne_bot (function.extfun_app h0 (comm_group environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_98883 (h1 : add_comm_semigroup char) (h2 : sym2 (add_comm_semigroup char)) : sym2.mem h1 h2 := sorry --non-trivial
lemma new_lemma_98884 (h0 : ring (has_nnnorm (has_nnnorm (topological_space (has_top fun_info))))) : is_domain (has_nnnorm (has_nnnorm (topological_space (has_top fun_info)))) := sorry --non-trivial
lemma new_lemma_98885 (h0 : functor.add_const (filter (has_neg_part name)) name) : filter.ne_bot (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_98886 (h0 : function.extfun Type topological_space) : @totally_disconnected_space.{0} (has_to_string.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_to_string.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_98887 (h0 : ring (topological_space (has_nnnorm linarith.comp_source))) : rank_condition (topological_space (has_nnnorm linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_98888 (h0 : topological_space (add_cancel_monoid (has_Inf (has_Inf (ring pos))))) : sequential_space (add_cancel_monoid (has_Inf (has_Inf (ring pos)))) := sorry --non-trivial
lemma new_lemma_98889 (h0 : topological_space (boolean_algebra.core (has_add (has_add (has_add (has_add Type)))))) : t1_space (boolean_algebra.core (has_add (has_add (has_add (has_add Type))))) := sorry --non-trivial
lemma new_lemma_98890 (h0 : topological_space (ordered_comm_monoid (has_add pos))) : preirreducible_space (ordered_comm_monoid (has_add pos)) := sorry --non-trivial
lemma new_lemma_98891 (h0 : monoid (has_add (has_Inf (has_pos_part Type)))) : monoid.fg (has_add (has_Inf (has_pos_part Type))) := sorry --non-trivial
lemma new_lemma_98892 (h0 : topological_space (ordered_cancel_add_comm_monoid (option empty))) : loc_path_connected_space (ordered_cancel_add_comm_monoid (option empty)) := sorry --non-trivial
lemma new_lemma_98893 (h0 : functor.add_const (functor.add_const (cancel_comm_monoid_with_zero name) unsigned) unsigned) : @unique_factorization_monoid.{0} name (@functor.add_const.run.{0 0} (cancel_comm_monoid_with_zero.{0} name) unsigned (@functor.add_const.run.{0 0} (functor.add_const.{0 0} (cancel_comm_monoid_with_zero.{0} name) unsigned) unsigned h0))  := sorry --non-trivial
lemma new_lemma_98894 (h0 : monoid (has_dist ennreal)) : monoid.fg (has_dist ennreal) := sorry --non-trivial
lemma new_lemma_98895 (h0 : not (topological_space (with_one linarith.comp_source) -> false)) : @irreducible_space.{0} (with_one.{0} linarith.comp_source) (@classical.by_contradiction'.{1} (topological_space.{0} (with_one.{0} linarith.comp_source)) h0)  := sorry --non-trivial
lemma new_lemma_98896 (h0 : finset (add_cancel_monoid (has_pos_part (has_pos_part pos)))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_98897 (h0 : monoid (has_zero (finset (has_to_string (ring (has_to_string Type)))))) : monoid.fg (has_zero (finset (has_to_string (ring (has_to_string Type))))) := sorry --non-trivial
lemma new_lemma_98898 (h0 : group (has_top linarith.comp_source)) : normalizer_condition (has_top linarith.comp_source) := sorry --non-trivial
lemma new_lemma_98899 (h0 : functor.add_const (cancel_comm_monoid_with_zero (has_add pos)) (has_neg Type)) : @unique_factorization_monoid.{0} (has_add.{0} pos) (@functor.add_const.run.{0 1} (cancel_comm_monoid_with_zero.{0} (has_add.{0} pos)) (has_neg.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_98900 (h0 : function.extfun (finset Type) (has_mem.mem (has_norm num))) : @discrete_topology.{0} (has_norm.{0} num) (@finset.pi.empty.{1 0} Type topological_space.{0} (has_norm.{0} num) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (has_norm.{0} num)) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_98901 (h0 : functor.add_const (list (metric_space unsigned)) empty) : palindrome (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_98902 (h0 : function.extfun (finset (Type -> Type)) (has_mem.mem topological_space)) : irreducible_space empty := sorry --non-trivial
lemma new_lemma_98903 (h0 : not (has_mem.mem (random_gen to_additive.value_type) has_emptyc.emptyc -> false)) : @strong_rank_condition.{0} (random_gen.{0} to_additive.value_type) (@finset.pi.empty.{1 0} Type ring.{0} (random_gen.{0} to_additive.value_type) (@classical.by_contradiction'.{0} (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (random_gen.{0} to_additive.value_type) (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))) h0))  := sorry --non-trivial
lemma new_lemma_98904 (h0 : functor.add_const (functor.add_const (topological_space pos) Type) name) : @loc_path_connected_space.{0} pos (@functor.add_const.run.{0 1} (topological_space.{0} pos) Type (@functor.add_const.run.{0 0} (functor.add_const.{0 1} (topological_space.{0} pos) Type) name h0))  := sorry --non-trivial
lemma new_lemma_98905 (h0 : ring (with_zero fun_info)) : strong_rank_condition (with_zero fun_info) := sorry --non-trivial
lemma new_lemma_98906 (h0 : complete_lattice (has_neg_part (comm_group (has_add (has_add name))))) : is_compactly_generated (has_neg_part (comm_group (has_add (has_add name)))) := sorry --non-trivial
lemma new_lemma_98907 (h0 : group (normed_comm_ring (boolean_algebra linarith.comp))) : group.fg (normed_comm_ring (boolean_algebra linarith.comp)) := sorry --non-trivial
lemma new_lemma_98908 (h0 : group (add_left_cancel_monoid char)) : is_cyclic (add_left_cancel_monoid char) := sorry --non-trivial
lemma new_lemma_98909 (h0 : has_mem.mem (linear_ordered_semiring empty) has_emptyc.emptyc) : @discrete_topology.{0} (linear_ordered_semiring.{0} empty) (@finset.pi.empty.{1 0} Type topological_space.{0} (linear_ordered_semiring.{0} empty) h0)  := sorry --non-trivial
lemma new_lemma_98910 (h0 : not (ring (mul_zero_class unsigned) -> false)) : @is_principal_ideal_ring.{0} (mul_zero_class.{0} unsigned) (@classical.by_contradiction'.{1} (ring.{0} (mul_zero_class.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_98911 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @loc_path_connected_space.{0} (has_Sup.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_Sup.{0} empty))  := sorry --non-trivial
lemma new_lemma_98912 (h0 : fin has_zero.zero) : @path_connected_space.{1} (has_bot.{1} Type) (@matrix.vec_empty.{1} (topological_space.{1} (has_bot.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_98913 (h0 : function.extfun Type ring) : @is_principal_ideal_ring.{0} (canonically_ordered_comm_semiring.{0} ennreal) (@function.extfun_app.{2 1} Type ring.{0} h0 (canonically_ordered_comm_semiring.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_98914 (h0 : semiring (boolean_algebra (has_neg pos))) : is_noetherian_ring (boolean_algebra (has_neg pos)) := sorry --non-trivial
lemma new_lemma_98915 (h0 : functor.add_const (topological_space (ordered_ring unsigned)) num) : @loc_path_connected_space.{0} (ordered_ring.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (ordered_ring.{0} unsigned)) num h0)  := sorry --non-trivial
lemma new_lemma_98916 (h0 : with_bot (ring (add_left_cancel_monoid fun_info))) (h1 : ne h0 has_bot.bot) : @strong_rank_condition.{0} (add_left_cancel_monoid.{0} fun_info) (@with_bot.unbot.{0} (ring.{0} (add_left_cancel_monoid.{0} fun_info)) h0 h1)  := sorry --non-trivial
lemma new_lemma_98917 (h0 : topological_space string.iterator_imp) (h1 : set string.iterator_imp) : is_path_connected h1 := sorry --non-trivial
lemma new_lemma_98918 (h0 : group (complete_linear_order unsigned)) : group.fg (complete_linear_order unsigned) := sorry --non-trivial
lemma new_lemma_98919 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : finset.nonempty (function.extfun_app (function.extfun_app h0 finset) (ring name)) := sorry --non-trivial
lemma new_lemma_98920 (h0 : function.extfun Type group) : @normalizer_condition.{0} (simple_graph.{0} unsigned) (@function.extfun_app.{2 1} Type group.{0} h0 (simple_graph.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_98921 (h0 : function.extfun Type topological_space) : @sequential_space.{0} (has_pos_part.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_pos_part.{0} name))  := sorry --non-trivial
lemma new_lemma_98922 (h1 : not (ring (with_bot fun_info) -> false)) : @rank_condition.{0} (with_bot.{0} fun_info) (@classical.by_contradiction'.{1} (ring.{0} (with_bot.{0} fun_info)) h1)  := sorry --non-trivial
lemma new_lemma_98923 (h0 : uniform_space (has_star (option empty))) : separated_space (has_star (option empty)) := sorry --non-trivial
lemma new_lemma_98924 (h0 : topological_space (plift (has_edist (option (option unsigned))))) : irreducible_space (plift (has_edist (option (option unsigned)))) := sorry --non-trivial
lemma new_lemma_98925 (h0 : topological_space (has_nndist (finset (finset (finset (boolean_algebra.core pos)))))) : totally_disconnected_space (has_nndist (finset (finset (finset (boolean_algebra.core pos))))) := sorry --non-trivial
lemma new_lemma_98926 (h0 : function.extfun Type topological_space) : @sequential_space.{0} (has_neg.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_neg.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_98927 (h0 : finset (has_star (semiring (semiring unsigned)))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_98928 (h0 : functor.add_const (function.extfun (Type 1) topological_space) (has_neg (finset (finset pos)))) : @totally_disconnected_space.{1} (ring.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) topological_space.{1}) (has_neg.{0} (finset.{0} (finset.{0} pos))) h0) (ring.{1} Type))  := sorry --non-trivial
lemma new_lemma_98929 (h0 : filter (comm_group ennreal)) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_98930 (h0 : topological_space (finset (finset (finset (finset (has_to_string (finset linarith.comp))))))) : regular_space (finset (finset (finset (finset (has_to_string (finset linarith.comp)))))) := sorry --non-trivial
lemma new_lemma_98931 (h0 : functor.add_const (ring (preorder num)) num) : @is_principal_ideal_ring.{0} (preorder.{0} num) (@functor.add_const.run.{0 0} (ring.{0} (preorder.{0} num)) num h0)  := sorry --non-trivial
lemma new_lemma_98932 (h0 : function.extfun Type topological_space) : @topological_space.separable_space.{0} (add_comm_monoid.{0} ennreal) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (add_comm_monoid.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_98933 (h0 : filter (has_nndist (has_add (has_neg Type)))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_98934 (h0 : ordered_add_comm_monoid (linear_ordered_field congr_arg_kind)) : archimedean (linear_ordered_field congr_arg_kind) := sorry --non-trivial
lemma new_lemma_98935 (h0 : ring (has_bot (has_add real))) : is_domain (has_bot (has_add real)) := sorry --non-trivial
lemma new_lemma_98936 (h0 : uniform_space (ring (has_neg name))) : complete_space (ring (has_neg name)) := sorry --non-trivial
lemma new_lemma_98937 (h0 : group (ring unsigned)) : is_cyclic (ring unsigned) := sorry --non-trivial
lemma new_lemma_98938 (h0 : has_mem.mem (has_emptyc linarith.comp_source) has_emptyc.emptyc) : @monoid.fg.{0} (has_emptyc.{0} linarith.comp_source) (@finset.pi.empty.{1 0} Type monoid.{0} (has_emptyc.{0} linarith.comp_source) h0)  := sorry --non-trivial
lemma new_lemma_98939 (h0 : functor.add_const (topological_space (add_comm_monoid name)) name) : @normal_space.{0} (add_comm_monoid.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (add_comm_monoid.{0} name)) name h0)  := sorry --non-trivial
lemma new_lemma_98940 (h0 : ring (linear_ordered_comm_group (option (option (option (option ennreal)))))) : is_domain (linear_ordered_comm_group (option (option (option (option ennreal))))) := sorry --non-trivial
lemma new_lemma_98941 (h0 : complete_lattice (has_norm fun_info)) : complete_lattice.is_Sup_finite_compact (has_norm fun_info) := sorry --non-trivial
lemma new_lemma_98942 (h0 : functor.add_const (topological_space (simple_graph pos)) (boolean_algebra.core (has_add pos))) : @totally_disconnected_space.{0} (simple_graph.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (simple_graph.{0} pos)) (boolean_algebra.core.{0} (has_add.{0} pos)) h0)  := sorry --non-trivial
lemma new_lemma_98943 (h0 : function.extfun (finset Type) (has_mem.mem (with_bot fun_info))) : @is_add_cyclic.{0} (with_bot.{0} fun_info) (@finset.pi.empty.{1 0} Type add_group.{0} (with_bot.{0} fun_info) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (with_bot.{0} fun_info)) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_98944 (h0 : functor.add_const (uniform_space (ring name)) linarith.comp) : @separated_space.{0} (ring.{0} name) (@functor.add_const.run.{0 0} (uniform_space.{0} (ring.{0} name)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_98945 (h0 : function.extfun Type (functor.add_const (complete_lattice (semigroup unsigned)))) : @is_compactly_generated.{0} (semigroup.{0} unsigned) (@functor.add_const.run.{0 0} (complete_lattice.{0} (semigroup.{0} unsigned)) unsigned (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (complete_lattice.{0} (semigroup.{0} unsigned))) h0 unsigned))  := sorry --non-trivial
lemma new_lemma_98946 (h0 : functor.add_const (ordered_add_comm_monoid (complete_distrib_lattice name)) linarith.comp) : @archimedean.{0} (complete_distrib_lattice.{0} name) (@functor.add_const.run.{0 0} (ordered_add_comm_monoid.{0} (complete_distrib_lattice.{0} name)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_98947 (h0 : add_monoid (has_zero (ring pos))) : add_monoid.fg (has_zero (ring pos)) := sorry --non-trivial
lemma new_lemma_98948 (h0 : functor.add_const (add_monoid (finset environment.implicit_infer_kind)) pos) : @add_monoid.fg.{0} (finset.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (add_monoid.{0} (finset.{0} environment.implicit_infer_kind)) pos h0)  := sorry --non-trivial
lemma new_lemma_98949 (h0 : not (function.extfun (Type -> Type) (function.extfun Type) -> false)) : @path_connected_space.{0} (with_bot.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) (@classical.by_contradiction'.{2} (function.extfun.{2 2} (Type → Type) (function.extfun.{2 1} Type)) h0) topological_space.{0}) (with_bot.{0} num))  := sorry --non-trivial
lemma new_lemma_98950 (h0 : uniform_space (has_add (normed_comm_ring (boolean_algebra.core (boolean_algebra.core name))))) : complete_space (has_add (normed_comm_ring (boolean_algebra.core (boolean_algebra.core name)))) := sorry --non-trivial
lemma new_lemma_98951 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @has_exists_mul_of_le.{0} (has_Inf.{0} linarith.comp) (@function.extfun_app.{2 1} Type ordered_comm_monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ordered_comm_monoid.{0}) (has_Inf.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_98952 (h0 : function.extfun (finset (Type -> Type)) (has_mem.mem complete_lattice)) : @is_atomistic.{0} (random_gen.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) complete_lattice.{0} (@function.extfun_app.{2 0} (finset.{1} (Type → Type)) (@has_mem.mem.{1 1} (Type → Type) (finset.{1} (Type → Type)) (@finset.has_mem.{1} (Type → Type)) complete_lattice.{0}) h0 (@has_emptyc.emptyc.{1} (finset.{1} (Type → Type)) (@finset.has_emptyc.{1} (Type → Type))))) (random_gen.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_98953 (h0 : group (has_norm (has_inv (has_inv linarith.comp_source)))) : normalizer_condition (has_norm (has_inv (has_inv linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_98954 (h0 : functor.add_const (topological_space (comm_group name)) environment.implicit_infer_kind) : @preconnected_space.{0} (comm_group.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (comm_group.{0} name)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_98955 (h0 : functor.add_const (filter (comm_group linarith.comp)) linarith.comp) : filter.ne_bot (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_98956 (h0 : ring (add_comm_semigroup std_gen)) : strong_rank_condition (add_comm_semigroup std_gen) := sorry --non-trivial
lemma new_lemma_98957 (h0 : functor.add_const (topological_space (has_neg environment.implicit_infer_kind)) name) : @normal_space.{0} (has_neg.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (has_neg.{0} environment.implicit_infer_kind)) name h0)  := sorry --non-trivial
lemma new_lemma_98958 (h0 : functor.comp topological_space has_zero name) : @locally_compact_space.{0} (has_zero.{0} name) (@functor.comp.run.{0 0 0} topological_space.{0} has_zero.{0} name h0)  := sorry --non-trivial
lemma new_lemma_98959 (h0 : functor.add_const (complete_lattice (normed_group empty)) empty) : @is_compactly_generated.{0} (normed_group.{0} empty) (@functor.add_const.run.{0 0} (complete_lattice.{0} (normed_group.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_98960 (h0 : group (boolean_algebra (finset (has_pos_part (finset pos))))) : is_cyclic (boolean_algebra (finset (has_pos_part (finset pos)))) := sorry --non-trivial
lemma new_lemma_98961 (h0 : add_monoid (non_assoc_semiring (semiring (semiring congr_arg_kind)))) : add_monoid.fg (non_assoc_semiring (semiring (semiring congr_arg_kind))) := sorry --non-trivial
lemma new_lemma_98962 (h0 : functor.comp complete_lattice has_neg ennreal) : @is_atomistic.{0} (has_neg.{0} ennreal) (@functor.comp.run.{0 0 0} complete_lattice.{0} has_neg.{0} ennreal h0)  := sorry --non-trivial
lemma new_lemma_98963 (h0 : group (metric_space (semiring (semiring (semiring (semiring empty)))))) : group.fg (metric_space (semiring (semiring (semiring (semiring empty))))) := sorry --non-trivial
lemma new_lemma_98964 (h2 : uniform_space (distrib_lattice linarith.ineq)) : complete_space (distrib_lattice linarith.ineq) := sorry --non-trivial
lemma new_lemma_98965 (h0 : topological_space (semi_normed_ring enat)) : t0_space (semi_normed_ring enat) := sorry --non-trivial
lemma new_lemma_98966 (h0 : ring (add_left_cancel_monoid (has_nnnorm to_additive.value_type))) : rank_condition (add_left_cancel_monoid (has_nnnorm to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_98967 (h0 : topological_space (has_star (semiring (semiring empty)))) : loc_path_connected_space (has_star (semiring (semiring empty))) := sorry --non-trivial
lemma new_lemma_98968 (h0 : topological_space (comm_group linarith.comp)) : preconnected_space (comm_group linarith.comp) := sorry --non-trivial
lemma new_lemma_98969 (h0 : cancel_comm_monoid_with_zero (left_cancel_monoid (normed_linear_ordered_group unsigned))) : unique_factorization_monoid (left_cancel_monoid (normed_linear_ordered_group unsigned)) := sorry --non-trivial
lemma new_lemma_98970 (h0 : ring (option (semiring congr_arg_kind))) : rank_condition (option (semiring congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_98971 (h0 : ring (has_inv (comm_ring linarith.comp_source))) : strong_rank_condition (has_inv (comm_ring linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_98972 (h0 : functor.add_const (filter (canonically_ordered_comm_semiring pos)) (finset (has_add Type))) : countable_Inter_filter (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_98973 (h0 : not (ring (semi_normed_comm_ring reducibility_hints) -> false)) : @is_domain.{0} (semi_normed_comm_ring.{0} reducibility_hints) (@classical.by_contradiction'.{1} (ring.{0} (semi_normed_comm_ring.{0} reducibility_hints)) h0)  := sorry --non-trivial
lemma new_lemma_98974 (h0 : topological_space (semigroup (has_nndist Type))) : discrete_topology (semigroup (has_nndist Type)) := sorry --non-trivial
lemma new_lemma_98975 (h0 : topological_space (canonically_ordered_comm_semiring (boolean_algebra name))) : sequential_space (canonically_ordered_comm_semiring (boolean_algebra name)) := sorry --non-trivial
lemma new_lemma_98976 (h0 : topological_space (normed_group to_additive.value_type)) : totally_separated_space (normed_group to_additive.value_type) := sorry --non-trivial
lemma new_lemma_98977 (h0 : function.extfun Type topological_space) : @totally_disconnected_space.{0} (has_neg_part.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_neg_part.{0} pos))  := sorry --non-trivial
lemma new_lemma_98978 (h1 : list (has_top (has_norm (has_norm to_additive.value_type)))) : list.nodup h1 := sorry --non-trivial
lemma new_lemma_98979 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @locally_compact_space.{0} (has_ssubset.{0} char) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_ssubset.{0} char))  := sorry --non-trivial
lemma new_lemma_98980 (h0 : functor.add_const (function.extfun Type uniform_space) Type) : @separated_space.{0} (boolean_algebra.{0} name) (@function.extfun_app.{2 1} Type uniform_space.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type uniform_space.{0}) Type h0) (boolean_algebra.{0} name))  := sorry --non-trivial
lemma new_lemma_98981 (h0 : add_group (semigroup (comm_group pos))) : is_add_cyclic (semigroup (comm_group pos)) := sorry --non-trivial
lemma new_lemma_98982 (h0 : semiring (simple_graph (has_Inf linarith.comp))) : is_noetherian_ring (simple_graph (has_Inf linarith.comp)) := sorry --non-trivial
lemma new_lemma_98983 (h0 : complete_lattice (non_unital_non_assoc_semiring reducibility_hints)) : is_compactly_generated (non_unital_non_assoc_semiring reducibility_hints) := sorry --non-trivial
lemma new_lemma_98984 (h2 : add_group (random_gen to_additive.value_type)) : is_add_cyclic (random_gen to_additive.value_type) := sorry --non-trivial
lemma new_lemma_98985 (h0 : topological_space (non_unital_non_assoc_semiring (mul_one_class std_gen))) : totally_disconnected_space (non_unital_non_assoc_semiring (mul_one_class std_gen)) := sorry --non-trivial
lemma new_lemma_98986 (h0 : functor.add_const (functor.add_const (cancel_comm_monoid_with_zero (ring name)) name) linarith.comp) : @unique_factorization_monoid.{0} (ring.{0} name) (@functor.add_const.run.{0 0} (cancel_comm_monoid_with_zero.{0} (ring.{0} name)) name (@functor.add_const.run.{0 0} (functor.add_const.{0 0} (cancel_comm_monoid_with_zero.{0} (ring.{0} name)) name) linarith.comp h0))  := sorry --non-trivial
lemma new_lemma_98987 (h0 : topological_space (bin_tree empty)) : irreducible_space (bin_tree empty) := sorry --non-trivial
lemma new_lemma_98988 (h0 : uniform_space (semi_normed_ring linarith.comp_source)) (h1 : not (group (semi_normed_ring linarith.comp_source) -> false)) : @uniform_group.{0} (semi_normed_ring.{0} linarith.comp_source) h0 (@classical.by_contradiction'.{1} (group.{0} (semi_normed_ring.{0} linarith.comp_source)) h1)  := sorry --non-trivial
lemma new_lemma_98989 (h0 : topological_space (normed_comm_ring num)) : preconnected_space (normed_comm_ring num) := sorry --non-trivial
lemma new_lemma_98990 (h0 : topological_space (comm_ring (has_nnnorm (has_nnnorm linarith.ineq)))) : t0_space (comm_ring (has_nnnorm (has_nnnorm linarith.ineq))) := sorry --non-trivial
lemma new_lemma_98991 (h0 : fin has_zero.zero) : @normal_space.{1} (has_bot.{1} Type) (@matrix.vec_empty.{1} (topological_space.{1} (has_bot.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_98992 (h0 : complete_lattice (has_compl (mul_one_class string.iterator_imp))) : is_compactly_generated (has_compl (mul_one_class string.iterator_imp)) := sorry --non-trivial
lemma new_lemma_98993 (h0 : complete_lattice (encodable fun_info)) : is_compactly_generated (encodable fun_info) := sorry --non-trivial
lemma new_lemma_98994 (h1 : set (ereal -> mul_one_class char)) : set.separates_points h1 := sorry --non-trivial
lemma new_lemma_98995 (h0 : complete_lattice (linear_ordered_semiring (random_gen (has_norm num)))) : is_compactly_generated (linear_ordered_semiring (random_gen (has_norm num))) := sorry --non-trivial
lemma new_lemma_98996 (h0 : functor.add_const (group (ring name)) name) : @normalizer_condition.{0} (ring.{0} name) (@functor.add_const.run.{0 0} (group.{0} (ring.{0} name)) name h0)  := sorry --non-trivial
lemma new_lemma_98997 (h0 : complete_lattice (measurable_space (has_top (semiring linarith.comp)))) : complete_lattice.is_Sup_finite_compact (measurable_space (has_top (semiring linarith.comp))) := sorry --non-trivial
lemma new_lemma_98998 (h0 : function.extfun Prop (fun (x : Prop), to_additive.value_type)) (h1 : coe_sort (set.range (function.extfun_app h0))) : set.range_splitting (function.extfun_app h0) h1 := sorry --non-trivial
lemma new_lemma_98999 (h0 : function.extfun Type topological_space) : @preirreducible_space.{0} (non_assoc_semiring.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (non_assoc_semiring.{0} num))  := sorry --non-trivial
lemma new_lemma_99000 (h0 : functor.add_const (group (has_nndist ennreal)) name) : @normalizer_condition.{0} (has_nndist.{0} ennreal) (@functor.add_const.run.{0 0} (group.{0} (has_nndist.{0} ennreal)) name h0)  := sorry --non-trivial
lemma new_lemma_99001 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @path_connected_space.{1} (semigroup.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 topological_space.{1}) (semigroup.{1} Type))  := sorry --non-trivial
lemma new_lemma_99002 (h0 : add_monoid (has_zero (has_neg environment.implicit_infer_kind))) : add_monoid.fg (has_zero (has_neg environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_99003 (h0 : uniform_space (has_top congr_arg_kind)) : separated_space (has_top congr_arg_kind) := sorry --non-trivial
lemma new_lemma_99004 (h0 : complete_lattice (has_add char)) : complete_lattice.is_Sup_finite_compact (has_add char) := sorry --non-trivial
lemma new_lemma_99005 (h0 : functor.add_const (ring (ordered_ring num)) (semiring (semiring (semiring num)))) : @is_domain.{0} (ordered_ring.{0} num) (@functor.add_const.run.{0 0} (ring.{0} (ordered_ring.{0} num)) (semiring.{0} (semiring.{0} (semiring.{0} num))) h0)  := sorry --non-trivial
lemma new_lemma_99006 (h0 : topological_space (add_left_cancel_semigroup (semiring (semiring empty)))) : normal_space (add_left_cancel_semigroup (semiring (semiring empty))) := sorry --non-trivial
lemma new_lemma_99007 (h0 : functor.add_const Prop (metric_space unsigned)) : functor.add_const.run h0 := sorry --non-trivial
lemma new_lemma_99008 (h0 : functor.add_const (topological_space (canonically_ordered_monoid real)) (has_add linarith.comp)) : @locally_compact_space.{0} (canonically_ordered_monoid.{0} real) (@functor.add_const.run.{0 0} (topological_space.{0} (canonically_ordered_monoid.{0} real)) (has_add.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_99009 (h0 : function.extfun Type list) : list.nodup (function.extfun_app h0 (denumerable to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_99010 (h0 : complete_lattice (canonically_ordered_comm_semiring (option (option num)))) : complete_lattice.is_Sup_finite_compact (canonically_ordered_comm_semiring (option (option num))) := sorry --non-trivial
lemma new_lemma_99011 (h0 : topological_space (add_comm_monoid (normed_lattice_add_comm_group (has_bot real)))) : t0_space (add_comm_monoid (normed_lattice_add_comm_group (has_bot real))) := sorry --non-trivial
lemma new_lemma_99012 (h0 : false) : @Lim.{0} Prop sierpinski_space (@nonempty_of_inhabited.{1} Prop sort.inhabited.{0}) (@id.{1} (filter.{0} Prop) (@list.head.{0} (filter.{0} Prop) (@filter.inhabited.{0} Prop) (@false.elim.{1} (list.{0} (filter.{0} Prop)) (@id.{0} false h0))))  := sorry --trivial
lemma new_lemma_99013 (h0 : group (has_sub (has_top num))) : normalizer_condition (has_sub (has_top num)) := sorry --non-trivial
lemma new_lemma_99014 (h0 : has_mem.mem (semiring empty) has_emptyc.emptyc) : @normal_space.{0} (semiring.{0} empty) (@finset.pi.empty.{1 0} Type topological_space.{0} (semiring.{0} empty) h0)  := sorry --non-trivial
lemma new_lemma_99015 (h0 : uniform_space (normed_linear_ordered_group empty)) : complete_space (normed_linear_ordered_group empty) := sorry --non-trivial
lemma new_lemma_99016 (h0 : topological_space (semigroup (option (option pos)))) : sequential_space (semigroup (option (option pos))) := sorry --non-trivial
lemma new_lemma_99017 (h0 : function.extfun ((finset Type -> Prop) -> Prop) (function.extfun (finset Type -> Prop))) : @normalizer_condition.{0} (semiring.{0} linarith.ineq) (@finset.pi.empty.{1 0} Type group.{0} (semiring.{0} linarith.ineq) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (semiring.{0} linarith.ineq)) (@function.extfun_app.{2 0} (finset.{1} Type → Prop) (function.extfun.{2 0} (finset.{1} Type)) (@function.extfun_app.{2 0} ((finset.{1} Type → Prop) → Prop) (function.extfun.{2 0} (finset.{1} Type → Prop)) h0 (function.extfun.{2 0} (finset.{1} Type))) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (semiring.{0} linarith.ineq))) (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_99018 (h0 : prod (measure_theory.measure_space (semiring unsigned)) (measure_theory.measure_space (semiring unsigned))) : id_rel h0 := sorry --non-trivial
lemma new_lemma_99019 (h0 : not (list (has_nnnorm fun_info) -> false)) : list.nodup (classical.by_contradiction' h0) := sorry --non-trivial
lemma new_lemma_99020 (h0 : functor.add_const (topological_space (bin_tree num)) congr_arg_kind) : @discrete_topology.{0} (bin_tree.{0} num) (@functor.add_const.run.{0 0} (topological_space.{0} (bin_tree.{0} num)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_99021 (h0 : functor.add_const (topological_space (left_cancel_monoid empty)) unsigned) : @preirreducible_space.{0} (left_cancel_monoid.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (left_cancel_monoid.{0} empty)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_99022 (h0 : topological_space (metric_space empty)) : path_connected_space (metric_space empty) := sorry --non-trivial
lemma new_lemma_99023 (h0 : filter (has_top (canonically_linear_ordered_monoid (semiring linarith.comp)))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_99024 (h0 : not (topological_space (plift empty) -> false)) : @topological_space.separable_space.{1} (plift.{1} empty) (@classical.by_contradiction'.{2} (topological_space.{1} (plift.{1} empty)) h0)  := sorry --non-trivial
lemma new_lemma_99025 (h0 : functor.add_const (ring (has_nndist unsigned)) name) : @is_principal_ideal_ring.{0} (has_nndist.{0} unsigned) (@functor.add_const.run.{0 0} (ring.{0} (has_nndist.{0} unsigned)) name h0)  := sorry --non-trivial
lemma new_lemma_99026 (h0 : uniform_space (add_semigroup (option unsigned))) : separated_space (add_semigroup (option unsigned)) := sorry --non-trivial
lemma new_lemma_99027 (h0 : functor.add_const (ordered_add_comm_monoid (finset environment.implicit_infer_kind)) (finset linarith.comp)) : @archimedean.{0} (finset.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (ordered_add_comm_monoid.{0} (finset.{0} environment.implicit_infer_kind)) (finset.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_99028 (h0 : functor.add_const (filter (has_nndist linarith.comp)) environment.implicit_infer_kind) : countable_Inter_filter (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_99029 (h0 : cancel_comm_monoid_with_zero (partial_order (semiring (semiring congr_arg_kind)))) : unique_factorization_monoid (partial_order (semiring (semiring congr_arg_kind))) := sorry --non-trivial
lemma new_lemma_99030 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @totally_separated_space.{0} (monoid.{0} ennreal) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (monoid.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_99031 (h0 : uniform_space (ring (option unsigned))) : separated_space (ring (option unsigned)) := sorry --non-trivial
lemma new_lemma_99032 (h0 : group (comm_group (finset (finset (finset ennreal))))) : is_cyclic (comm_group (finset (finset (finset ennreal)))) := sorry --non-trivial
lemma new_lemma_99033 (h0 : function.extfun Type filter) : filter.ne_bot (function.extfun_app h0 (random_gen linarith.ineq)) := sorry --non-trivial
lemma new_lemma_99034 (h0 : not (add_group (semi_normed_ring (has_ssubset string_imp)) -> false)) : @is_add_cyclic.{0} (semi_normed_ring.{0} (has_ssubset.{0} string_imp)) (@classical.by_contradiction'.{1} (add_group.{0} (semi_normed_ring.{0} (has_ssubset.{0} string_imp))) h0)  := sorry --non-trivial
lemma new_lemma_99035 (h0 : complete_lattice (linear_ordered_semiring (semiring linarith.comp))) : is_compactly_generated (linear_ordered_semiring (semiring linarith.comp)) := sorry --non-trivial
lemma new_lemma_99036 (h0 : functor.comp topological_space has_neg_part pos) : @regular_space.{0} (has_neg_part.{0} pos) (@functor.comp.run.{0 0 0} topological_space.{0} has_neg_part.{0} pos h0)  := sorry --non-trivial
lemma new_lemma_99037 (h0 : group (normed_lattice_add_comm_group (has_Inf linarith.comp))) : is_simple_group (normed_lattice_add_comm_group (has_Inf linarith.comp)) := sorry --non-trivial
lemma new_lemma_99038 (h0 : prod (pseudo_metric_space unsigned) (pseudo_metric_space unsigned)) : id_rel h0 := sorry --non-trivial
lemma new_lemma_99039 (h0 : topological_space (has_neg (has_add unsigned))) : path_connected_space (has_neg (has_add unsigned)) := sorry --non-trivial
lemma new_lemma_99040 (h2 : ring (has_append (has_ssubset linarith.comp_source))) : strong_rank_condition (has_append (has_ssubset linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_99041 (h0 : function.extfun Type topological_space) : @totally_separated_space.{0} (has_inter.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_inter.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_99042 (h0 : topological_space (measurable_space.dynkin_system congr_arg_kind)) : loc_path_connected_space (measurable_space.dynkin_system congr_arg_kind) := sorry --non-trivial
lemma new_lemma_99043 (h1 : topological_space (semi_normed_comm_ring reducibility_hints)) : path_connected_space (semi_normed_comm_ring reducibility_hints) := sorry --non-trivial
lemma new_lemma_99044 (h0 : functor.add_const (topological_space (option num)) empty) : @irreducible_space.{0} (option.{0} num) (@functor.add_const.run.{0 0} (topological_space.{0} (option.{0} num)) empty h0)  := sorry --non-trivial
lemma new_lemma_99045 (h0 : topological_space (has_to_string num)) : t0_space (has_to_string num) := sorry --non-trivial
lemma new_lemma_99046 (h0 : topological_space (linear_ordered_field empty)) : preconnected_space (linear_ordered_field empty) := sorry --non-trivial
lemma new_lemma_99047 (h2 : topological_space environment.implicit_infer_kind) : path_connected_space environment.implicit_infer_kind := sorry --non-trivial
lemma new_lemma_99048 (h0 h1 : multiset (nondiscrete_normed_field ereal)) : multiset.disjoint h0 h1 := sorry --non-trivial
lemma new_lemma_99049 (h0 : topological_space (non_unital_non_assoc_semiring (mul_one_class reducibility_hints))) : path_connected_space (non_unital_non_assoc_semiring (mul_one_class reducibility_hints)) := sorry --non-trivial
lemma new_lemma_99050 (h0 : ring (complete_linear_order unsigned)) : is_domain (complete_linear_order unsigned) := sorry --non-trivial
lemma new_lemma_99051 (h0 : monoid (canonically_linear_ordered_monoid empty)) : monoid.fg (canonically_linear_ordered_monoid empty) := sorry --non-trivial
lemma new_lemma_99052 (h0 : set (set (normed_field linarith.comp_source))) (h1 : set (normed_field linarith.comp_source)) : measurable_space.dynkin_system.generate_has h0 h1 := sorry --non-trivial
lemma new_lemma_99053 (h0 : ring (boolean_algebra (boolean_algebra Type))) : strong_rank_condition (boolean_algebra (boolean_algebra Type)) := sorry --non-trivial
lemma new_lemma_99054 (h0 : comm_semiring environment.implicit_infer_kind) (h1 : add_group (linear_recurrence environment.implicit_infer_kind)) : is_add_cyclic (linear_recurrence environment.implicit_infer_kind) := sorry --non-trivial
lemma new_lemma_99055 (h0 : complete_lattice (linear_ordered_semiring (semiring (semiring linarith.comp)))) : is_atomistic (linear_ordered_semiring (semiring (semiring linarith.comp))) := sorry --non-trivial
lemma new_lemma_99056 (h0 : function.extfun Type (functor.comp group comm_group)) : @normalizer_condition.{0} (comm_group.{0} pos) (@functor.comp.run.{0 0 0} group.{0} comm_group.{0} pos (@functor.comp.run.{0 0 0} group.{0} comm_group.{0} pos (@function.extfun_app.{2 1} Type (functor.comp.{0 0 0} group.{0} comm_group.{0}) h0 pos)))  := sorry --non-trivial
lemma new_lemma_99057 (h0 : functor.add_const (ordered_comm_monoid (boolean_algebra linarith.comp)) (has_pos_part name)) : @has_exists_mul_of_le.{0} (boolean_algebra.{0} linarith.comp) (@functor.add_const.run.{0 0} (ordered_comm_monoid.{0} (boolean_algebra.{0} linarith.comp)) (has_pos_part.{0} name) h0)  := sorry --non-trivial
lemma new_lemma_99058 (h0 : topological_space (normed_lattice_add_comm_group (has_Inf pos))) : preconnected_space (normed_lattice_add_comm_group (has_Inf pos)) := sorry --non-trivial
lemma new_lemma_99059 (h0 : uniform_space (canonically_ordered_monoid (has_Inf (has_add (has_add Type))))) : separated_space (canonically_ordered_monoid (has_Inf (has_add (has_add Type)))) := sorry --non-trivial
lemma new_lemma_99060 (h0 : add_group (dlist (has_nnnorm linarith.comp_source))) : is_add_cyclic (dlist (has_nnnorm linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_99061 (h0 : add_group (add_right_cancel_monoid unsigned)) : is_add_cyclic (add_right_cancel_monoid unsigned) := sorry --non-trivial
lemma new_lemma_99062 (h0 : group (partial_order empty)) : group.fg (partial_order empty) := sorry --non-trivial
lemma new_lemma_99063 (h0 : ring (has_neg (finset pos))) : is_principal_ideal_ring (has_neg (finset pos)) := sorry --non-trivial
lemma new_lemma_99064 (h0 : group (has_nndist (semigroup Type))) : normalizer_condition (has_nndist (semigroup Type)) := sorry --non-trivial
lemma new_lemma_99065 (h3 h4 : multiset string.iterator) : multiset.subset h3 h4 := sorry --non-trivial
lemma new_lemma_99066 (h0 : semiring (add_group (semiring (semiring (semiring congr_arg_kind))))) : is_noetherian_ring (add_group (semiring (semiring (semiring congr_arg_kind)))) := sorry --non-trivial
lemma new_lemma_99067 (h0 : topological_space (add_cancel_monoid (finset (has_neg_part Type)))) : totally_separated_space (add_cancel_monoid (finset (has_neg_part Type))) := sorry --non-trivial
lemma new_lemma_99068 (h0 : monoid (complete_semilattice_Sup (has_inv to_additive.value_type))) : monoid.fg (complete_semilattice_Sup (has_inv to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_99069 (h0 : function.extfun Type ring) : @is_principal_ideal_ring.{0} (has_add.{0} real) (@function.extfun_app.{2 1} Type ring.{0} h0 (has_add.{0} real))  := sorry --non-trivial
lemma new_lemma_99070 (h0 : ring (boolean_algebra name)) : is_domain (boolean_algebra name) := sorry --non-trivial
lemma new_lemma_99071 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @monoid.fg.{0} (has_Inf.{0} linarith.comp) (@function.extfun_app.{2 1} Type monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 monoid.{0}) (has_Inf.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_99072 (h0 : functor.add_const (finset (monoid unsigned)) unsigned) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_99073 (h0 : group (has_nnnorm (with_one char))) : group.fg (has_nnnorm (with_one char)) := sorry --non-trivial
lemma new_lemma_99074 (h0 : not (function.extfun Type topological_space -> false)) : @totally_separated_space.{0} (linear_ordered_semiring.{0} fun_info) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (linear_ordered_semiring.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_99075 (h3 : set (uniform_space to_additive.value_type)) : set.finite h3 := sorry --non-trivial
lemma new_lemma_99076 (h0 : is_empty enat -> Prop) : zzz_forall h0 := sorry --non-trivial
lemma new_lemma_99077 (h0 : function.extfun Type topological_space) : @discrete_topology.{0} (linear_ordered_cancel_comm_monoid.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (linear_ordered_cancel_comm_monoid.{0} empty))  := sorry --non-trivial
lemma new_lemma_99078 (h0 : function.extfun Type ring) : @rank_condition.{0} (comm_group.{0} ennreal) (@function.extfun_app.{2 1} Type ring.{0} h0 (comm_group.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_99079 (h0 : add_group (has_top (semiring num))) : is_add_cyclic (has_top (semiring num)) := sorry --non-trivial
lemma new_lemma_99080 (h1 : complete_lattice (has_inv (random_gen string_imp))) : is_compactly_generated (has_inv (random_gen string_imp)) := sorry --non-trivial
lemma new_lemma_99081 (h0 : Prop -> Prop) : classical.epsilon (set_of h0) := sorry --non-trivial
lemma new_lemma_99082 (h0 : group (has_Inf pos)) : normalizer_condition (has_Inf pos) := sorry --non-trivial
lemma new_lemma_99083 (h0 : group (normed_group (has_inv (has_inv (random_gen string_imp))))) : group.fg (normed_group (has_inv (has_inv (random_gen string_imp)))) := sorry --non-trivial
lemma new_lemma_99084 (h0 : function.extfun Type finset) : finset.nonempty (function.extfun_app h0 ennreal) := sorry --non-trivial
lemma new_lemma_99085 (h0 : function.extfun Type group) : @is_simple_group.{0} (has_to_string.{0} unsigned) (@function.extfun_app.{2 1} Type group.{0} h0 (has_to_string.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_99086 (h0 : uniform_space (normed_field (has_nnnorm (has_lt linarith.ineq)))) : complete_space (normed_field (has_nnnorm (has_lt linarith.ineq))) := sorry --non-trivial
lemma new_lemma_99087 (h0 : functor.add_const (topological_space (complete_distrib_lattice empty)) (option empty)) : @irreducible_space.{0} (complete_distrib_lattice.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (complete_distrib_lattice.{0} empty)) (option.{0} empty) h0)  := sorry --non-trivial
lemma new_lemma_99088 (h0 : functor.add_const (ordered_comm_monoid (comm_group environment.implicit_infer_kind)) linarith.comp) : @has_exists_mul_of_le.{0} (comm_group.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (ordered_comm_monoid.{0} (comm_group.{0} environment.implicit_infer_kind)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_99089 (h0 : not (topological_space (complete_linear_order num) -> false)) : @path_connected_space.{0} (complete_linear_order.{0} num) (@classical.by_contradiction'.{1} (topological_space.{0} (complete_linear_order.{0} num)) h0)  := sorry --non-trivial
lemma new_lemma_99090 (h0 : functor.add_const (topological_space (comm_group name)) Type) : @normal_space.{0} (comm_group.{0} name) (@functor.add_const.run.{0 1} (topological_space.{0} (comm_group.{0} name)) Type h0)  := sorry --non-trivial
lemma new_lemma_99091 (h0 : topological_space (canonically_ordered_add_monoid unsigned)) : loc_path_connected_space (canonically_ordered_add_monoid unsigned) := sorry --non-trivial
lemma new_lemma_99092 (h1 : uniform_space (with_zero (random_gen linarith.ineq))) : complete_space (with_zero (random_gen linarith.ineq)) := sorry --non-trivial
lemma new_lemma_99093 (h0 : topological_space (has_lt (mul_one_class string.iterator_imp))) : t0_space (has_lt (mul_one_class string.iterator_imp)) := sorry --non-trivial
lemma new_lemma_99094 (h0 : topological_space (has_zero (has_add (has_add (has_add (has_add (has_add linarith.comp))))))) : loc_path_connected_space (has_zero (has_add (has_add (has_add (has_add (has_add linarith.comp)))))) := sorry --non-trivial
lemma new_lemma_99095 (h0 : function.extfun string_imp (fun (x : string_imp), string_imp)) (h1 : string_imp) : function.periodic_pts (function.extfun_app h0) h1 := sorry --non-trivial
lemma new_lemma_99096 (h0 : uniform_space (has_star (semiring (semiring empty)))) : complete_space (has_star (semiring (semiring empty))) := sorry --non-trivial
lemma new_lemma_99097 (h0 : function.extfun Type filter) : countable_Inter_filter (function.extfun_app h0 (has_neg linarith.comp)) := sorry --non-trivial
lemma new_lemma_99098 (h0 : functor.add_const (ring (pseudo_emetric_space Type)) linarith.comp) : @strong_rank_condition.{1} (pseudo_emetric_space.{1} Type) (@functor.add_const.run.{1 0} (ring.{1} (pseudo_emetric_space.{1} Type)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_99099 (h0 : ordered_comm_semiring linarith.comp) (h1 : function.extfun Type multiset) : multiset.mem h0 (function.extfun_app h1 (ordered_comm_semiring linarith.comp)) := sorry --non-trivial
lemma new_lemma_99100 (h2 : ring (distrib_lattice (has_nnnorm (linear_ordered_add_comm_group to_additive.value_type)))) : rank_condition (distrib_lattice (has_nnnorm (linear_ordered_add_comm_group to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_99101 (h0 : fin has_zero.zero) : @preirreducible_space.{0} (has_nndist.{0} linarith.comp) (@matrix.vec_empty.{0} (topological_space.{0} (has_nndist.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_99102 (h0 : cancel_comm_monoid_with_zero (add_right_cancel_monoid num)) : unique_factorization_monoid (add_right_cancel_monoid num) := sorry --non-trivial
lemma new_lemma_99103 : infinite string_imp := sorry --non-trivial
lemma new_lemma_99104 (h0 : ring (has_compl (random_gen string_imp))) : is_domain (has_compl (random_gen string_imp)) := sorry --non-trivial
lemma new_lemma_99105 (h0 : functor.add_const (cancel_comm_monoid_with_zero (has_zero environment.implicit_infer_kind)) linarith.comp) : @unique_factorization_monoid.{0} (has_zero.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (cancel_comm_monoid_with_zero.{0} (has_zero.{0} environment.implicit_infer_kind)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_99106 (h0 : not (topological_space (non_assoc_semiring unsigned) -> false)) : @t0_space.{0} (non_assoc_semiring.{0} unsigned) (@classical.by_contradiction'.{1} (topological_space.{0} (non_assoc_semiring.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_99107 (h0 : topological_space (has_zero (ring (boolean_algebra linarith.comp)))) : normal_space (has_zero (ring (boolean_algebra linarith.comp))) := sorry --non-trivial
lemma new_lemma_99108 (h0 : functor.add_const (topological_space (canonically_ordered_comm_semiring ennreal)) Type) : @normal_space.{0} (canonically_ordered_comm_semiring.{0} ennreal) (@functor.add_const.run.{0 1} (topological_space.{0} (canonically_ordered_comm_semiring.{0} ennreal)) Type h0)  := sorry --non-trivial
lemma new_lemma_99109 (h0 : functor.add_const (topological_space (add_cancel_monoid environment.implicit_infer_kind)) (has_Inf Type)) : @t1_space.{0} (add_cancel_monoid.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 1} (topological_space.{0} (add_cancel_monoid.{0} environment.implicit_infer_kind)) (has_Inf.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_99110 (h0 : functor.add_const (topological_space (ring unsigned)) linarith.comp) : @loc_path_connected_space.{0} (ring.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (ring.{0} unsigned)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_99111 (h1 : topological_space (normed_field (comm_ring char))) : t0_space (normed_field (comm_ring char)) := sorry --non-trivial
lemma new_lemma_99112 (h0 : functor.add_const (ring (canonically_ordered_comm_semiring Type)) unsigned) : @is_principal_ideal_ring.{1} (canonically_ordered_comm_semiring.{1} Type) (@functor.add_const.run.{1 0} (ring.{1} (canonically_ordered_comm_semiring.{1} Type)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_99113 (h0 : group (ring ennreal)) : group.fg (ring ennreal) := sorry --non-trivial
lemma new_lemma_99114 (h0 : group (has_zero (comm_group name))) : group.fg (has_zero (comm_group name)) := sorry --non-trivial
lemma new_lemma_99115 (h0 : list (comm_group ennreal)) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_99116 (h0 : topological_space (simple_graph (option (option num)))) : t1_space (simple_graph (option (option num))) := sorry --non-trivial
lemma new_lemma_99117 (h0 : function.extfun Type ordered_add_comm_monoid) : @archimedean.{0} (normed_linear_ordered_group.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type ordered_add_comm_monoid.{0} h0 (normed_linear_ordered_group.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_99118 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_noetherian_ring.{0} (linear_ordered_comm_group.{0} ennreal) (@function.extfun_app.{2 1} Type semiring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 semiring.{0}) (linear_ordered_comm_group.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_99119 (h0 : topological_space (finset (has_neg name))) : sequential_space (finset (has_neg name)) := sorry --non-trivial
lemma new_lemma_99120 (h0 : add_group (non_unital_non_assoc_semiring string_imp)) : is_add_cyclic (non_unital_non_assoc_semiring string_imp) := sorry --non-trivial
lemma new_lemma_99121 (h0 : not (filter (linear_ordered_semiring to_additive.value_type) -> false)) : filter.ne_bot (classical.by_contradiction' h0) := sorry --non-trivial
lemma new_lemma_99122 (h0 : functor.add_const (group (complete_distrib_lattice linarith.comp)) pos) : @group.fg.{0} (complete_distrib_lattice.{0} linarith.comp) (@functor.add_const.run.{0 0} (group.{0} (complete_distrib_lattice.{0} linarith.comp)) pos h0)  := sorry --non-trivial
lemma new_lemma_99123 (h0 : not (function.extfun (Type -> Type) (function.extfun Type) -> false)) : @monoid.fg.{0} (has_star.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) (@classical.by_contradiction'.{2} (function.extfun.{2 2} (Type → Type) (function.extfun.{2 1} Type)) h0) monoid.{0}) (has_star.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_99124 (h0 : functor.add_const (filter (ring environment.implicit_infer_kind)) name) : filter.ne_bot (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_99125 (h0 : function.extfun Type topological_space) : @regular_space.{0} (has_Inf.{0} (finset.{0} linarith.comp)) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_Inf.{0} (finset.{0} linarith.comp)))  := sorry --non-trivial
lemma new_lemma_99126 (h0 : topological_space (boolean_algebra (has_pos_part (has_add Type)))) : normal_space (boolean_algebra (has_pos_part (has_add Type))) := sorry --non-trivial
lemma new_lemma_99127 (h0 : uniform_space (has_to_string (has_to_string (finset Type)))) : complete_space (has_to_string (has_to_string (finset Type))) := sorry --non-trivial
lemma new_lemma_99128 (h0 : function.extfun Type uniform_space) : @complete_space.{0} (semigroup.{0} empty) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (semigroup.{0} empty))  := sorry --non-trivial
lemma new_lemma_99129 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @discrete_topology.{0} (has_zero.{0} (has_to_string.{0} pos)) (@functor.comp.run.{0 0 0} topological_space.{0} has_zero.{0} (has_to_string.{0} pos) (@function.extfun_app.{2 1} Type (functor.comp.{0 0 0} topological_space.{0} has_zero.{0}) (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 (functor.comp.{0 0 0} topological_space.{0} has_zero.{0})) (has_to_string.{0} pos)))  := sorry --non-trivial
lemma new_lemma_99130 (h0 : function.extfun Type topological_space) : @t1_space.{0} (boolean_algebra.core.{0} ennreal) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (boolean_algebra.core.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_99131 (h0 : fin has_zero.zero) : @irreducible_space.{0} (boolean_algebra.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} (@matrix.vec_empty.{1} (function.extfun.{2 1} Type topological_space.{0}) h0) (boolean_algebra.{0} name))  := sorry --non-trivial
lemma new_lemma_99132 (h0 : group (has_append (comm_ring to_additive.value_type))) : is_cyclic (has_append (comm_ring to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_99133 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @regular_space.{1} (canonically_ordered_comm_semiring.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 topological_space.{1}) (canonically_ordered_comm_semiring.{1} Type))  := sorry --non-trivial
lemma new_lemma_99134 (h0 : topological_space (add_comm_monoid (has_add (boolean_algebra (finset pos))))) : totally_disconnected_space (add_comm_monoid (has_add (boolean_algebra (finset pos)))) := sorry --non-trivial
lemma new_lemma_99135 (h0 : functor.add_const (ring (has_to_string pos)) linarith.comp) : @strong_rank_condition.{0} (has_to_string.{0} pos) (@functor.add_const.run.{0 0} (ring.{0} (has_to_string.{0} pos)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_99136 (h0 : function.extfun Type monoid) : @monoid.fg.{0} (canonically_ordered_comm_semiring.{0} (option.{0} unsigned)) (@function.extfun_app.{2 1} Type monoid.{0} h0 (canonically_ordered_comm_semiring.{0} (option.{0} unsigned)))  := sorry --non-trivial
lemma new_lemma_99137 (h0 : function.extfun Type topological_space) : locally_compact_space empty := sorry --non-trivial
lemma new_lemma_99138 (h0 : monoid (random_gen (has_inv (random_gen linarith.comp_source)))) : monoid.fg (random_gen (has_inv (random_gen linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_99139 (h0 : functor.add_const (topological_space (add_left_cancel_semigroup unsigned)) empty) : @path_connected_space.{0} (add_left_cancel_semigroup.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (add_left_cancel_semigroup.{0} unsigned)) empty h0)  := sorry --non-trivial
lemma new_lemma_99140 (h0 : ring (topological_space (with_zero fun_info))) : strong_rank_condition (topological_space (with_zero fun_info)) := sorry --non-trivial
lemma new_lemma_99141 (h0 : topological_space (semigroup (add_cancel_monoid (add_cancel_monoid name)))) (h1 : set (semigroup (add_cancel_monoid (add_cancel_monoid name)))) : is_seq_compact h1 := sorry --non-trivial
lemma new_lemma_99142 (h0 : function.extfun Type filter) : filter.ne_bot (function.extfun_app h0 to_additive.value_type) := sorry --non-trivial
lemma new_lemma_99143 (h0 : complete_lattice (distrib (random_gen reducibility_hints))) : is_compactly_generated (distrib (random_gen reducibility_hints)) := sorry --non-trivial
lemma new_lemma_99144 (h0 : topological_space (has_bot (has_add pos))) : locally_compact_space (has_bot (has_add pos)) := sorry --non-trivial
lemma new_lemma_99145 (h0 : function.extfun Type topological_space) : @irreducible_space.{0} (@id.{2} Type congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (@id.{2} Type congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_99146 (h0 : functor.add_const (group (has_neg pos)) pos) : @is_cyclic.{0} (has_neg.{0} pos) (@functor.add_const.run.{0 0} (group.{0} (has_neg.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_99147 (h0 : group (complete_semilattice_Sup to_additive.value_type)) : is_cyclic (complete_semilattice_Sup to_additive.value_type) := sorry --non-trivial
lemma new_lemma_99148 (h0 : topological_space (dlist (random_gen (random_gen char)))) : path_connected_space (dlist (random_gen (random_gen char))) := sorry --non-trivial
lemma new_lemma_99149 (h0 : uniform_space (normed_comm_ring (comm_group (comm_group pos)))) : complete_space (normed_comm_ring (comm_group (comm_group pos))) := sorry --non-trivial
lemma new_lemma_99150 (h0 : function.extfun Type (functor.comp ring cancel_monoid)) : @strong_rank_condition.{0} (cancel_monoid.{0} environment.implicit_infer_kind) (@functor.comp.run.{0 0 0} ring.{0} cancel_monoid.{0} environment.implicit_infer_kind (@function.extfun_app.{2 1} Type (functor.comp.{0 0 0} ring.{0} cancel_monoid.{0}) h0 environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_99151 (h1 : ring (uniform_space (mul_one_class (mul_one_class fun_info)))) : strong_rank_condition (uniform_space (mul_one_class (mul_one_class fun_info))) := sorry --non-trivial
lemma new_lemma_99152 (h1 : not (group (dlist string_imp) -> false)) : @is_cyclic.{0} (dlist.{0} string_imp) (@classical.by_contradiction'.{1} (group.{0} (dlist.{0} string_imp)) h1)  := sorry --non-trivial
lemma new_lemma_99153 (h0 : functor.add_const (topological_space (complete_distrib_lattice pos)) linarith.comp) : @locally_compact_space.{0} (complete_distrib_lattice.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (complete_distrib_lattice.{0} pos)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_99154 (h0 : function.extfun Type topological_space) : @totally_disconnected_space.{0} (with_one.{0} (random_gen.{0} (random_gen.{0} (random_gen.{0} (random_gen.{0} num))))) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (with_one.{0} (random_gen.{0} (random_gen.{0} (random_gen.{0} (random_gen.{0} num))))))  := sorry --non-trivial
lemma new_lemma_99155 (h0 : functor.add_const (topological_space (add_semigroup empty)) empty) : @path_connected_space.{0} (add_semigroup.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (add_semigroup.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_99156 (h0 : topological_space (has_to_string (has_add (semigroup environment.implicit_infer_kind)))) : sequential_space (has_to_string (has_add (semigroup environment.implicit_infer_kind))) := sorry --non-trivial
lemma new_lemma_99157 (h0 : functor.add_const (ordered_comm_monoid (canonically_linear_ordered_monoid unsigned)) unsigned) : @has_exists_mul_of_le.{0} (canonically_linear_ordered_monoid.{0} unsigned) (@functor.add_const.run.{0 0} (ordered_comm_monoid.{0} (canonically_linear_ordered_monoid.{0} unsigned)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_99158 (h0 : function.extfun Type topological_space) : @path_connected_space.{0} (canonically_linear_ordered_monoid.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (canonically_linear_ordered_monoid.{0} name))  := sorry --non-trivial
lemma new_lemma_99159 (h2 : add_group (comm_ring to_additive.value_type)) : is_add_cyclic (comm_ring to_additive.value_type) := sorry --non-trivial
lemma new_lemma_99160 (h0 : functor.add_const (topological_space (add_comm_monoid Type)) (finset environment.implicit_infer_kind)) : @irreducible_space.{1} (add_comm_monoid.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (add_comm_monoid.{1} Type)) (finset.{0} environment.implicit_infer_kind) h0)  := sorry --non-trivial
lemma new_lemma_99161 (h0 : topological_space (distrib_lattice (comm_ring string_imp))) : totally_disconnected_space (distrib_lattice (comm_ring string_imp)) := sorry --non-trivial
lemma new_lemma_99162 (h0 : monoid (with_bot (semiring (has_norm num)))) : monoid.fg (with_bot (semiring (has_norm num))) := sorry --non-trivial
lemma new_lemma_99163 (h0 : set (add_comm_semigroup ereal -> linarith.ineq)) : set.separates_points h0 := sorry --non-trivial
lemma new_lemma_99164 (h0 : not (function.extfun (Type -> Type) (function.extfun Type) -> false)) : @is_atomistic.{0} (random_gen.{0} fun_info) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) (@classical.by_contradiction'.{2} (function.extfun.{2 2} (Type → Type) (function.extfun.{2 1} Type)) h0) complete_lattice.{0}) (random_gen.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_99165 (h0 : topological_space (semi_normed_ring linarith.comp_source)) : totally_disconnected_space (semi_normed_ring linarith.comp_source) := sorry --non-trivial
lemma new_lemma_99166 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @preconnected_space.{0} (semigroup.{0} ennreal) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (semigroup.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_99167 (h0 : function.extfun Type topological_space) : @normal_space.{0} (linear_ordered_semiring.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (linear_ordered_semiring.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_99168 (h0 h1 : multiset (add_comm_semigroup (add_comm_semigroup char))) : multiset.disjoint h0 h1 := sorry --non-trivial
lemma new_lemma_99169 (h0 : ring (has_nnnorm (mul_one_class (mul_one_class (mul_one_class (has_ssubset linarith.ineq)))))) : is_domain (has_nnnorm (mul_one_class (mul_one_class (mul_one_class (has_ssubset linarith.ineq))))) := sorry --non-trivial
lemma new_lemma_99170 (h0 : filter (has_top (has_ssubset fun_info))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_99171 (h0 : function.extfun Type ring) : @rank_condition.{0} (simple_graph.{0} empty) (@function.extfun_app.{2 1} Type ring.{0} h0 (simple_graph.{0} empty))  := sorry --non-trivial
lemma new_lemma_99172 (h0 : group (comm_group (comm_group (comm_group unsigned)))) : group.fg (comm_group (comm_group (comm_group unsigned))) := sorry --non-trivial
lemma new_lemma_99173 (h0 : topological_space (complete_linear_order (has_top (has_top (has_top unsigned))))) : path_connected_space (complete_linear_order (has_top (has_top (has_top unsigned)))) := sorry --non-trivial
lemma new_lemma_99174 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @t1_space.{0} (boolean_algebra.core.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (boolean_algebra.core.{0} name))  := sorry --non-trivial
lemma new_lemma_99175 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_principal_ideal_ring.{0} (option.{0} empty) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (option.{0} empty))  := sorry --non-trivial
lemma new_lemma_99176 (h0 : list (has_nndist (option (option (option (option unsigned)))))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_99177 (h0 : not (topological_space (plift empty) -> false)) : @path_connected_space.{1} (plift.{1} empty) (@classical.by_contradiction'.{2} (topological_space.{1} (plift.{1} empty)) h0)  := sorry --non-trivial
lemma new_lemma_99178 (h0 : filter (add_group (has_norm linarith.comp))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_99179 (h0 : function.extfun Type complete_lattice) : @is_compactly_generated.{0} (has_to_string.{0} name) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (has_to_string.{0} name))  := sorry --non-trivial
lemma new_lemma_99180 (h0 : functor.add_const (topological_space (has_pos_part pos)) linarith.comp) : @discrete_topology.{0} (has_pos_part.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (has_pos_part.{0} pos)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_99181 (h0 : function.extfun Type complete_lattice) : @is_atomistic.{0} (linear_ordered_semiring.{0} fun_info) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (linear_ordered_semiring.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_99182 (h1 : group (normed_group (with_one to_additive.value_type))) : group.fg (normed_group (with_one to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_99183 (h0 : topological_space (has_nndist (has_add environment.implicit_infer_kind))) : path_connected_space (has_nndist (has_add environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_99184 (h0 : topological_space auto.case_option) : totally_separated_space auto.case_option := sorry --non-trivial
lemma new_lemma_99185 (h0 : group (linear_ordered_comm_ring unsigned)) : group.fg (linear_ordered_comm_ring unsigned) := sorry --non-trivial
lemma new_lemma_99186 (h0 : functor.add_const (topological_space (has_nndist name)) Type) : @locally_compact_space.{0} (has_nndist.{0} name) (@functor.add_const.run.{0 1} (topological_space.{0} (has_nndist.{0} name)) Type h0)  := sorry --non-trivial
lemma new_lemma_99187 (h0 : not (filter (has_norm linarith.comp_source) -> false)) : filter.ne_bot (classical.by_contradiction' h0) := sorry --non-trivial
lemma new_lemma_99188 (h0 : set (mul_one_class string.iterator_imp)) : set.finite h0 := sorry --non-trivial
lemma new_lemma_99189 (h0 : monoid (non_assoc_semiring (option empty))) : monoid.fg (non_assoc_semiring (option empty)) := sorry --non-trivial
lemma new_lemma_99190 (h0 : not (topological_space (has_ssubset to_additive.value_type) -> false)) : @t0_space.{0} (has_ssubset.{0} to_additive.value_type) (@classical.by_contradiction'.{1} (topological_space.{0} (has_ssubset.{0} to_additive.value_type)) h0)  := sorry --non-trivial
lemma new_lemma_99191 (h1 : ring linarith.comp_source) : strong_rank_condition linarith.comp_source := sorry --non-trivial
lemma new_lemma_99192 (h0 : topological_space (linear_ordered_field (option (option pos)))) : totally_separated_space (linear_ordered_field (option (option pos))) := sorry --non-trivial
lemma new_lemma_99193 (h0 : topological_space (pseudo_metric_space (option pos))) : loc_path_connected_space (pseudo_metric_space (option pos)) := sorry --non-trivial
lemma new_lemma_99194 (h0 : function.extfun Type ring) : @is_domain.{0} (measurable_space.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type ring.{0} h0 (measurable_space.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_99195 (h0 : topological_space (normed_group fun_info)) : t0_space (normed_group fun_info) := sorry --non-trivial
lemma new_lemma_99196 (h0 : prod (has_union (semiring num)) (has_union (semiring num))) : id_rel h0 := sorry --non-trivial
lemma new_lemma_99197 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @complete_lattice.is_Sup_finite_compact.{0} (add_semigroup.{0} empty) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (add_semigroup.{0} empty))  := sorry --non-trivial
lemma new_lemma_99198 (h0 : function.extfun Type ring) : @is_principal_ideal_ring.{0} (boolean_algebra.core.{0} empty) (@function.extfun_app.{2 1} Type ring.{0} h0 (boolean_algebra.core.{0} empty))  := sorry --non-trivial
lemma new_lemma_99199 (h0 : ring (comm_group (semigroup pos))) : is_domain (comm_group (semigroup pos)) := sorry --non-trivial
lemma new_lemma_99200 (h0 : functor.add_const (topological_space (add_cancel_monoid empty)) empty) : @path_connected_space.{0} (add_cancel_monoid.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (add_cancel_monoid.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_99201 (h0 : topological_space (has_norm string_imp) -> topological_space (has_norm string_imp) -> Prop) : irreflexive h0 := sorry --non-trivial
lemma new_lemma_99202 (h0 : add_group (add_cancel_comm_monoid (random_gen (random_gen string_imp)))) : is_add_cyclic (add_cancel_comm_monoid (random_gen (random_gen string_imp))) := sorry --non-trivial
lemma new_lemma_99203 (h0 : topological_space (linear_ordered_comm_ring (has_top (semiring empty)))) : path_connected_space (linear_ordered_comm_ring (has_top (semiring empty))) := sorry --non-trivial
lemma new_lemma_99204 (h0 : topological_space (ring (has_nndist name))) : irreducible_space (ring (has_nndist name)) := sorry --non-trivial
lemma new_lemma_99205 (h0 : topological_space (has_pos_part (has_pos_part pos))) : sequential_space (has_pos_part (has_pos_part pos)) := sorry --non-trivial
lemma new_lemma_99206 (h0 : ring (has_nndist (option num))) : is_principal_ideal_ring (has_nndist (option num)) := sorry --non-trivial
lemma new_lemma_99207 (h0 : function.extfun Type group) : @group.fg.{0} (has_ssubset.{0} string_imp) (@function.extfun_app.{2 1} Type group.{0} h0 (has_ssubset.{0} string_imp))  := sorry --non-trivial
lemma new_lemma_99208 (h0 : function.extfun Type topological_space) : @preconnected_space.{0} (canonically_linear_ordered_monoid.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (canonically_linear_ordered_monoid.{0} num))  := sorry --non-trivial
lemma new_lemma_99209 (h0 : topological_space (measure_theory.measure_space unsigned)) : locally_compact_space (measure_theory.measure_space unsigned) := sorry --non-trivial
lemma new_lemma_99210 (h0 : fin has_zero.zero) : @rank_condition.{0} (canonically_ordered_monoid.{0} pos) (@function.extfun_app.{2 1} Type ring.{0} (@matrix.vec_empty.{1} (function.extfun.{2 1} Type ring.{0}) h0) (canonically_ordered_monoid.{0} pos))  := sorry --non-trivial
lemma new_lemma_99211 (h0 : ring (add_left_cancel_semigroup unsigned)) : rank_condition (add_left_cancel_semigroup unsigned) := sorry --non-trivial
lemma new_lemma_99212 (h0 : functor.add_const (add_monoid (has_to_string name)) environment.implicit_infer_kind) : @add_monoid.fg.{0} (has_to_string.{0} name) (@functor.add_const.run.{0 0} (add_monoid.{0} (has_to_string.{0} name)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_99213 (h1 : group (random_gen num)) : is_cyclic (random_gen num) := sorry --non-trivial
lemma new_lemma_99214 (h0 : function.extfun Type ring) : @is_principal_ideal_ring.{0} (canonically_ordered_monoid.{0} name) (@function.extfun_app.{2 1} Type ring.{0} h0 (canonically_ordered_monoid.{0} name))  := sorry --non-trivial
lemma new_lemma_99215 (h0 : topological_space (normed_lattice_add_comm_group (sub_neg_monoid pos))) : sequential_space (normed_lattice_add_comm_group (sub_neg_monoid pos)) := sorry --non-trivial
lemma new_lemma_99216 (h0 : ring (semi_normed_ring linarith.ineq)) : is_domain (semi_normed_ring linarith.ineq) := sorry --non-trivial
lemma new_lemma_99217 (h0 : filter (add_cancel_monoid (finset linarith.comp))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_99218 (h0 : function.extfun Type ring) : @rank_condition.{0} (sub_neg_monoid.{0} linarith.comp) (@function.extfun_app.{2 1} Type ring.{0} h0 (sub_neg_monoid.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_99219 (h0 : not (group (encodable fun_info) -> false)) : @is_cyclic.{0} (encodable.{0} fun_info) (@classical.by_contradiction'.{1} (group.{0} (encodable.{0} fun_info)) h0)  := sorry --non-trivial
lemma new_lemma_99220 (h0 : function.extfun ((Type -> Type) -> Type 1) (function.extfun (Type -> Type))) : @strong_rank_condition.{0} (comm_monoid.{0} empty) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) (@function.extfun_app.{3 2} ((Type → Type) → Type 1) (function.extfun.{2 2} (Type → Type)) h0 (function.extfun.{2 1} Type)) ring.{0}) (comm_monoid.{0} empty))  := sorry --non-trivial
lemma new_lemma_99221 (h0 : monoid (plift (has_top congr_arg_kind))) : monoid.fg (plift (has_top congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_99222 (h0 : group (complete_semilattice_Sup linarith.comp)) : normalizer_condition (complete_semilattice_Sup linarith.comp) := sorry --non-trivial
lemma new_lemma_99223 (h0 : fin has_zero.zero) : @discrete_topology.{0} (canonically_linear_ordered_monoid.{0} real) (@function.extfun_app.{2 1} Type topological_space.{0} (@matrix.vec_empty.{1} (function.extfun.{2 1} Type topological_space.{0}) h0) (canonically_linear_ordered_monoid.{0} real))  := sorry --non-trivial
lemma new_lemma_99224 (h0 : topological_space (linear_ordered_comm_ring congr_arg_kind)) : totally_disconnected_space (linear_ordered_comm_ring congr_arg_kind) := sorry --non-trivial
lemma new_lemma_99225 (h0 : function.extfun (finset Type) (has_mem.mem (measurable_space num))) : @irreducible_space.{0} (measurable_space.{0} num) (@finset.pi.empty.{1 0} Type topological_space.{0} (measurable_space.{0} num) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (measurable_space.{0} num)) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_99226 (h1 : function.extfun Type topological_space) : @irreducible_space.{0} (has_top.{0} linarith.ineq) (@function.extfun_app.{2 1} Type topological_space.{0} h1 (has_top.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_99227 (h0 : ring (boolean_algebra (has_to_string Type))) : is_domain (boolean_algebra (has_to_string Type)) := sorry --non-trivial
lemma new_lemma_99228 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @has_exists_mul_of_le.{1} (ordered_comm_monoid.{1} Type) (@function.extfun_app.{3 2} (Type 1) ordered_comm_monoid.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 ordered_comm_monoid.{1}) (ordered_comm_monoid.{1} Type))  := sorry --non-trivial
lemma new_lemma_99229 (h1 : measurable_space (normed_field string_imp)) (h2 : ring (mul_one_class (measure_theory.measure (normed_field string_imp)))) : strong_rank_condition (mul_one_class (measure_theory.measure (normed_field string_imp))) := sorry --non-trivial
lemma new_lemma_99230 (h0 : complete_lattice (uniform_space (mul_one_class (has_nnnorm char)))) : complete_lattice.is_Sup_finite_compact (uniform_space (mul_one_class (has_nnnorm char))) := sorry --non-trivial
lemma new_lemma_99231 (h0 : filter (has_add unsigned)) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_99232 (h0 : group (add_group (has_norm (has_union linarith.comp)))) : group.fg (add_group (has_norm (has_union linarith.comp))) := sorry --non-trivial
lemma new_lemma_99233 (h0 : ring (generalized_boolean_algebra (ring pos))) : is_domain (generalized_boolean_algebra (ring pos)) := sorry --non-trivial
lemma new_lemma_99234 (h0 : topological_space (encodable (has_ssubset fun_info))) : t0_space (encodable (has_ssubset fun_info)) := sorry --non-trivial
lemma new_lemma_99235 (h0 : group (add_cancel_monoid linarith.comp)) : is_cyclic (add_cancel_monoid linarith.comp) := sorry --non-trivial
lemma new_lemma_99236 (h0 : functor.add_const (ordered_add_comm_monoid (has_dist empty)) empty) : @archimedean.{0} (has_dist.{0} empty) (@functor.add_const.run.{0 0} (ordered_add_comm_monoid.{0} (has_dist.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_99237 (h0 : ring (measure_theory.measure_space (semiring unsigned))) : is_principal_ideal_ring (measure_theory.measure_space (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_99238 (h0 : add_group (semiring (has_norm (has_norm empty)))) : is_add_cyclic (semiring (has_norm (has_norm empty))) := sorry --non-trivial
lemma new_lemma_99239 (h0 : functor.add_const (function.extfun (Type 1) topological_space) pos) : @loc_path_connected_space.{1} (has_zero.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) topological_space.{1}) pos h0) (has_zero.{1} Type))  := sorry --non-trivial
lemma new_lemma_99240 (h0 : function.extfun Type topological_space) : @t1_space.{0} (add_comm_monoid.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (add_comm_monoid.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_99241 (h0 : functor.add_const (topological_space (left_cancel_semigroup num)) num) : @totally_disconnected_space.{0} (left_cancel_semigroup.{0} num) (@functor.add_const.run.{0 0} (topological_space.{0} (left_cancel_semigroup.{0} num)) num h0)  := sorry --non-trivial
lemma new_lemma_99242 (h0 : function.extfun Type ordered_add_comm_monoid) : @archimedean.{0} (semigroup.{0} unsigned) (@function.extfun_app.{2 1} Type ordered_add_comm_monoid.{0} h0 (semigroup.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_99243 (h0 : function.extfun Type finset) : finset.nonempty (function.extfun_app h0 (boolean_algebra.core congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_99244 (h1 : ring (has_div enat)) : is_domain (has_div enat) := sorry --non-trivial
lemma new_lemma_99245 (h0 : complete_lattice (simple_graph (ring (ring pos)))) : complete_lattice.is_Sup_finite_compact (simple_graph (ring (ring pos))) := sorry --non-trivial
lemma new_lemma_99246 (h0 : function.extfun Type topological_space) : @irreducible_space.{0} (has_dist.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_dist.{0} empty))  := sorry --non-trivial
lemma new_lemma_99247 (h0 : has_add (add_cancel_comm_monoid char)) (h1 : add_con (add_cancel_comm_monoid char)) (h2 : group (add_con.quotient h1)) : is_cyclic (add_con.quotient h1) := sorry --non-trivial
lemma new_lemma_99248 (h0 : ring (add_comm_monoid (comm_group name))) : is_principal_ideal_ring (add_comm_monoid (comm_group name)) := sorry --non-trivial
lemma new_lemma_99249 (h0 : ring (measurable_space (semiring (semiring (has_top (semiring empty)))))) : is_domain (measurable_space (semiring (semiring (has_top (semiring empty))))) := sorry --non-trivial
lemma new_lemma_99250 (h0 : group (is_R_or_C empty)) : is_cyclic (is_R_or_C empty) := sorry --non-trivial
lemma new_lemma_99251 (h0 : topological_space (semi_normed_comm_ring (complete_semilattice_Sup linarith.ineq))) : t0_space (semi_normed_comm_ring (complete_semilattice_Sup linarith.ineq)) := sorry --non-trivial
lemma new_lemma_99252 (h0 : functor.add_const (add_group (linear_ordered_comm_monoid_with_zero empty)) (semiring empty)) : @is_add_cyclic.{0} (linear_ordered_comm_monoid_with_zero.{0} empty) (@functor.add_const.run.{0 0} (add_group.{0} (linear_ordered_comm_monoid_with_zero.{0} empty)) (semiring.{0} empty) h0)  := sorry --non-trivial
lemma new_lemma_99253 (h0 : functor.add_const (function.extfun Type group) Type) : @is_cyclic.{0} (canonically_ordered_comm_semiring.{0} linarith.comp) (@function.extfun_app.{2 1} Type group.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type group.{0}) Type h0) (canonically_ordered_comm_semiring.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_99254 (h0 : functor.add_const (complete_lattice (canonically_ordered_comm_semiring (has_add pos))) Type) : @is_compactly_generated.{0} (canonically_ordered_comm_semiring.{0} (has_add.{0} pos)) (@functor.add_const.run.{0 1} (complete_lattice.{0} (canonically_ordered_comm_semiring.{0} (has_add.{0} pos))) Type h0)  := sorry --non-trivial
lemma new_lemma_99255 (h0 : uniform_space (pseudo_metric_space (option (option (option empty))))) : separated_space (pseudo_metric_space (option (option (option empty)))) := sorry --non-trivial
lemma new_lemma_99256 (h0 : prod enat enat) : set.diagonal enat h0 := sorry --non-trivial
lemma new_lemma_99257 (h0 : topological_space (option unsigned)) : preconnected_space (option unsigned) := sorry --non-trivial
lemma new_lemma_99258 (h0 : functor.add_const (function.extfun (Type 1) topological_space) name) : @preconnected_space.{1} (add_cancel_monoid.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) topological_space.{1}) name h0) (add_cancel_monoid.{1} Type))  := sorry --non-trivial
lemma new_lemma_99259 (h0 : ring (generalized_boolean_algebra (ring (ring linarith.comp)))) : is_domain (generalized_boolean_algebra (ring (ring linarith.comp))) := sorry --non-trivial
lemma new_lemma_99260 (h0 : has_lt (has_ssubset ordering)) : no_max_order (has_ssubset ordering) := sorry --non-trivial
lemma new_lemma_99261 (h0 : ordered_add_comm_monoid (ordered_comm_monoid (ring (ring pos)))) : archimedean (ordered_comm_monoid (ring (ring pos))) := sorry --non-trivial
lemma new_lemma_99262 (h0 : not (topological_space (has_union empty) -> false)) : @irreducible_space.{0} (has_union.{0} empty) (@classical.by_contradiction'.{1} (topological_space.{0} (has_union.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_99263 (h0 : list (semi_normed_comm_ring (has_ssubset (random_gen fun_info)))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_99264 (h0 : topological_space (has_one (with_one (semiring empty)))) : normal_space (has_one (with_one (semiring empty))) := sorry --non-trivial
lemma new_lemma_99265 (h0 : not (group (normed_group linarith.ineq) -> false)) : @group.fg.{0} (normed_group.{0} linarith.ineq) (@classical.by_contradiction'.{1} (group.{0} (normed_group.{0} linarith.ineq)) h0)  := sorry --non-trivial
lemma new_lemma_99266 (h0 : ring (semigroup (ring linarith.comp))) : is_domain (semigroup (ring linarith.comp)) := sorry --non-trivial
lemma new_lemma_99267 (h0 : function.extfun Type list) : list.nodup (function.extfun_app h0 (add_left_cancel_semigroup unsigned)) := sorry --non-trivial
lemma new_lemma_99268 (h0 : functor.add_const (topological_space (bin_tree num)) num) : @locally_compact_space.{0} (bin_tree.{0} num) (@functor.add_const.run.{0 0} (topological_space.{0} (bin_tree.{0} num)) num h0)  := sorry --non-trivial
lemma new_lemma_99269 (h0 : not (add_group (comm_ring fun_info) -> false)) : @is_add_cyclic.{0} (comm_ring.{0} fun_info) (@classical.by_contradiction'.{1} (add_group.{0} (comm_ring.{0} fun_info)) h0)  := sorry --non-trivial
lemma new_lemma_99270 (h0 : ring (distrib_lattice (has_norm (random_gen fun_info)))) : is_domain (distrib_lattice (has_norm (random_gen fun_info))) := sorry --non-trivial
lemma new_lemma_99271 (h0 : ordered_comm_monoid (simple_graph linarith.comp)) : has_exists_mul_of_le (simple_graph linarith.comp) := sorry --non-trivial
lemma new_lemma_99272 (h0 : uniform_space (fintype fun_info)) : complete_space (fintype fun_info) := sorry --non-trivial
lemma new_lemma_99273 (h0 : ring (boolean_algebra name)) : rank_condition (boolean_algebra name) := sorry --non-trivial
lemma new_lemma_99274 (h0 : function.extfun Type topological_space) : @t0_space.{0} (ordered_ring.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (ordered_ring.{0} empty))  := sorry --non-trivial
lemma new_lemma_99275 (h0 : add_monoid (semiring string_imp)) : add_monoid.fg (semiring string_imp) := sorry --non-trivial
lemma new_lemma_99276 (h0 : functor.add_const (ordered_comm_monoid (canonically_ordered_comm_semiring name)) Type) : @has_exists_mul_of_le.{0} (canonically_ordered_comm_semiring.{0} name) (@functor.add_const.run.{0 1} (ordered_comm_monoid.{0} (canonically_ordered_comm_semiring.{0} name)) Type h0)  := sorry --non-trivial
lemma new_lemma_99277 (h0 : finset (boolean_algebra (has_add name))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_99278 (h0 : function.extfun Type topological_space) : @irreducible_space.{0} (random_gen.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (random_gen.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_99279 (h0 : ring (non_assoc_semiring (semiring unsigned))) : is_domain (non_assoc_semiring (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_99280 (h0 : not (filter (dlist linarith.ineq) -> false)) : filter.ne_bot (classical.by_contradiction' h0) := sorry --non-trivial
lemma new_lemma_99281 (h0 : topological_space (has_top (add_group_with_zero_nhd num))) : irreducible_space (has_top (add_group_with_zero_nhd num)) := sorry --non-trivial
lemma new_lemma_99282 (h0 : function.extfun Type (functor.comp topological_space boolean_algebra)) : @t1_space.{0} (boolean_algebra.{0} environment.implicit_infer_kind) (@functor.comp.run.{0 0 0} topological_space.{0} boolean_algebra.{0} environment.implicit_infer_kind (@function.extfun_app.{2 1} Type (functor.comp.{0 0 0} topological_space.{0} boolean_algebra.{0}) h0 environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_99283 (h0 : add_monoid (has_pos_part (has_add real))) : add_monoid.fg (has_pos_part (has_add real)) := sorry --non-trivial
lemma new_lemma_99284 (h0 : functor.add_const (topological_space (has_add pos)) (has_neg Type)) : @t1_space.{0} (has_add.{0} pos) (@functor.add_const.run.{0 1} (topological_space.{0} (has_add.{0} pos)) (has_neg.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_99285 (h0 : topological_space (canonically_linear_ordered_monoid (option (option ennreal)))) : totally_disconnected_space (canonically_linear_ordered_monoid (option (option ennreal))) := sorry --non-trivial
lemma new_lemma_99286 (h0 : topological_space (id (has_norm (has_norm (has_norm (has_norm (has_norm empty))))))) : t0_space (id (has_norm (has_norm (has_norm (has_norm (has_norm empty)))))) := sorry --non-trivial
lemma new_lemma_99287 (h1 : function.extfun Type group) : @normalizer_condition.{0} (has_top.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type group.{0} h1 (has_top.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_99288 (h1 : uniform_space (encodable string_imp)) : complete_space (encodable string_imp) := sorry --non-trivial
lemma new_lemma_99289 (h0 : monoid (linear_ordered_semiring (has_norm num))) : monoid.fg (linear_ordered_semiring (has_norm num)) := sorry --non-trivial
lemma new_lemma_99290 (h0 : not (function.extfun Type topological_space -> false)) : @totally_separated_space.{0} (with_bot.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (with_bot.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_99291 (h0 : monoid (has_to_string (has_inv linarith.comp_source))) : monoid.fg (has_to_string (has_inv linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_99292 (h0 : ring (id empty)) : strong_rank_condition (id empty) := sorry --non-trivial
lemma new_lemma_99293 (h0 : set (has_le (has_le to_additive.value_type))) : set.subsingleton h0 := sorry --non-trivial
lemma new_lemma_99294 (h0 : semiring (add_comm_monoid (boolean_algebra.core environment.implicit_infer_kind))) : is_noetherian_ring (add_comm_monoid (boolean_algebra.core environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_99295 (h0 : group (id (has_inv (random_gen (random_gen linarith.ineq))))) : normalizer_condition (id (has_inv (random_gen (random_gen linarith.ineq)))) := sorry --non-trivial
lemma new_lemma_99296 (h0 : function.extfun Type ring) : @rank_condition.{0} (normed_group.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type ring.{0} h0 (normed_group.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_99297 (h0 : ring (normed_linear_ordered_group congr_arg_kind)) : is_domain (normed_linear_ordered_group congr_arg_kind) := sorry --non-trivial
lemma new_lemma_99298 (h1 : function.extfun (Type -> Type) (function.extfun Type)) : @totally_separated_space.{0} (with_bot.{0} linarith.ineq) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h1 topological_space.{0}) (with_bot.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_99299 (h0 : functor.add_const (function.extfun (Type 1) topological_space) name) : @discrete_topology.{1} (has_to_string.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) topological_space.{1}) name h0) (has_to_string.{1} Type))  := sorry --non-trivial
lemma new_lemma_99300 (h0 : topological_space (comm_group (cancel_monoid (has_to_string ennreal)))) : t1_space (comm_group (cancel_monoid (has_to_string ennreal))) := sorry --non-trivial
lemma new_lemma_99301 (h0 : functor.add_const (add_monoid (has_add environment.implicit_infer_kind)) Type) : @add_monoid.fg.{0} (has_add.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 1} (add_monoid.{0} (has_add.{0} environment.implicit_infer_kind)) Type h0)  := sorry --non-trivial
lemma new_lemma_99302 (h0 : function.extfun (finset Type) (has_mem.mem (has_norm linarith.ineq))) : @complete_space.{0} (has_norm.{0} linarith.ineq) (@finset.pi.empty.{1 0} Type uniform_space.{0} (has_norm.{0} linarith.ineq) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (has_norm.{0} linarith.ineq)) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_99303 (h0 : functor.add_const (function.extfun Type ring) pos) : @strong_rank_condition.{0} (add_cancel_monoid.{0} pos) (@function.extfun_app.{2 1} Type ring.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type ring.{0}) pos h0) (add_cancel_monoid.{0} pos))  := sorry --non-trivial
lemma new_lemma_99304 (h0 : function.extfun Type monoid) : @monoid.fg.{0} (has_nndist.{0} ennreal) (@function.extfun_app.{2 1} Type monoid.{0} h0 (has_nndist.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_99305 (h0 : add_monoid (finset unsigned)) : add_monoid.fg (finset unsigned) := sorry --non-trivial
lemma new_lemma_99306 (h0 : semiring (has_add (finset (has_neg Type)))) : is_noetherian_ring (has_add (finset (has_neg Type))) := sorry --non-trivial
lemma new_lemma_99307 (h0 : topological_space (has_to_string (has_add unsigned))) : locally_compact_space (has_to_string (has_add unsigned)) := sorry --non-trivial
lemma new_lemma_99308 (h0 : measurable_space (mul_one_class enat)) (h1 : measure_theory.measure (mul_one_class enat)) : measure_theory.is_finite_measure h1 := sorry --non-trivial
lemma new_lemma_99309 (h1 : topological_space (semiring linarith.comp_source)) : irreducible_space (semiring linarith.comp_source) := sorry --non-trivial
lemma new_lemma_99310 (h0 : functor.add_const (topological_space (has_add Type)) pos) : @totally_separated_space.{1} (has_add.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (has_add.{1} Type)) pos h0)  := sorry --non-trivial
lemma new_lemma_99311 (h0 : complete_lattice (with_bot (random_gen (has_inv (has_inv fun_info))))) : is_compactly_generated (with_bot (random_gen (has_inv (has_inv fun_info)))) := sorry --non-trivial
lemma new_lemma_99312 (h0 : functor.add_const (group (as_linear_order empty)) empty) : @normalizer_condition.{0} (as_linear_order.{0} empty) (@functor.add_const.run.{0 0} (group.{0} (as_linear_order.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_99313 (h0 : function.extfun (nat -> Type) (function.extfun nat)) : @has_exists_mul_of_le.{1} (sub_neg_monoid.{1} Type) (@matrix.vec_empty.{1} (ordered_comm_monoid.{1} (sub_neg_monoid.{1} Type)) (@function.extfun_app.{1 1} nat fin (@function.extfun_app.{2 1} (nat → Type) (function.extfun.{1 1} nat) h0 fin) (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_99314 (h0 : complete_lattice (has_add (option ennreal))) : complete_lattice.is_Sup_finite_compact (has_add (option ennreal)) := sorry --non-trivial
lemma new_lemma_99315 (h0 : function.extfun Type topological_space) : @locally_compact_space.{0} (add_comm_monoid.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (add_comm_monoid.{0} pos))  := sorry --non-trivial
lemma new_lemma_99316 (h0 : filter (has_to_string (has_neg (has_add (mul_zero_class (has_neg (mul_zero_class Type))))))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_99317 (h0 : uniform_space (has_nndist (has_add (has_zero pos)))) : separated_space (has_nndist (has_add (has_zero pos))) := sorry --non-trivial
lemma new_lemma_99318 (h0 : functor.add_const (function.extfun Type ring) pos) : @is_domain.{0} (finset.{0} name) (@function.extfun_app.{2 1} Type ring.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type ring.{0}) pos h0) (finset.{0} name))  := sorry --non-trivial
lemma new_lemma_99319 (h0 : function.extfun Type topological_space) : @t0_space.{0} (linear_ordered_add_comm_group.{0} fun_info) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (linear_ordered_add_comm_group.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_99320 (h0 : not (topological_space (semiring linarith.comp_source) -> false)) : @locally_compact_space.{0} (semiring.{0} linarith.comp_source) (@classical.by_contradiction'.{1} (topological_space.{0} (semiring.{0} linarith.comp_source)) h0)  := sorry --non-trivial
lemma new_lemma_99321 (h1 : complete_lattice (linear_ordered_comm_group_with_zero linarith.ineq)) : complete_lattice.is_Sup_finite_compact (linear_ordered_comm_group_with_zero linarith.ineq) := sorry --non-trivial
lemma new_lemma_99322 (h0 : function.extfun Type topological_space) : @locally_compact_space.{0} (bin_tree.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (bin_tree.{0} num))  := sorry --non-trivial
lemma new_lemma_99323 (h0 : functor.add_const (group (cancel_monoid Type)) pos) : @normalizer_condition.{1} (cancel_monoid.{1} Type) (@functor.add_const.run.{1 0} (group.{1} (cancel_monoid.{1} Type)) pos h0)  := sorry --non-trivial
lemma new_lemma_99324 (h0 : functor.add_const (complete_lattice (mul_zero_class num)) num) : @complete_lattice.is_Sup_finite_compact.{0} (mul_zero_class.{0} num) (@functor.add_const.run.{0 0} (complete_lattice.{0} (mul_zero_class.{0} num)) num h0)  := sorry --non-trivial
lemma new_lemma_99325 (h0 : functor.add_const (cancel_comm_monoid_with_zero (group_with_zero num)) ennreal) : @unique_factorization_monoid.{0} (group_with_zero.{0} num) (@functor.add_const.run.{0 0} (cancel_comm_monoid_with_zero.{0} (group_with_zero.{0} num)) ennreal h0)  := sorry --non-trivial
lemma new_lemma_99326 (h0 : has_neg (has_le string.iterator_imp)) (h1 : measurable_space (has_le string.iterator_imp)) : has_measurable_neg (has_le string.iterator_imp) := sorry --non-trivial
lemma new_lemma_99327 (h0 : functor.add_const (ordered_add_comm_monoid (has_pos_part pos)) Type) : @archimedean.{0} (has_pos_part.{0} pos) (@functor.add_const.run.{0 1} (ordered_add_comm_monoid.{0} (has_pos_part.{0} pos)) Type h0)  := sorry --non-trivial
lemma new_lemma_99328 (h0 : functor.add_const (ring (add_cancel_monoid environment.implicit_infer_kind)) Type) : @is_domain.{0} (add_cancel_monoid.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 1} (ring.{0} (add_cancel_monoid.{0} environment.implicit_infer_kind)) Type h0)  := sorry --non-trivial
lemma new_lemma_99329 (h0 : functor.add_const (topological_space (finset Type)) linarith.comp) : @totally_disconnected_space.{1} (finset.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (finset.{1} Type)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_99330 (h0 : group (has_sub (semiring empty))) : normalizer_condition (has_sub (semiring empty)) := sorry --non-trivial
lemma new_lemma_99331 (h0 : filter (complete_distrib_lattice (add_comm_monoid Type))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_99332 (h0 : topological_space (normed_group (with_one (denumerable to_additive.value_type)))) : t0_space (normed_group (with_one (denumerable to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_99333 (h0 : list (preorder unsigned)) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_99334 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @loc_path_connected_space.{0} (has_to_string.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_to_string.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_99335 (h0 : topological_space (simple_graph linarith.comp_source)) : path_connected_space (simple_graph linarith.comp_source) := sorry --non-trivial
lemma new_lemma_99336 (h0 : ordered_comm_monoid (ordered_cancel_add_comm_monoid (option pos))) : has_exists_mul_of_le (ordered_cancel_add_comm_monoid (option pos)) := sorry --non-trivial
lemma new_lemma_99337 (h0 : topological_space (canonically_ordered_monoid (has_add (has_neg name)))) : preirreducible_space (canonically_ordered_monoid (has_add (has_neg name))) := sorry --non-trivial
lemma new_lemma_99338 (h0 : function.extfun (Type 1) complete_lattice) : @is_compactly_generated.{1} (has_neg.{1} Type) (@function.extfun_app.{3 2} (Type 1) complete_lattice.{1} h0 (has_neg.{1} Type))  := sorry --non-trivial
lemma new_lemma_99339 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_domain.{0} (semiring.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (semiring.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_99340 (h0 : function.extfun Type topological_space) : @totally_disconnected_space.{0} (measure_theory.measure_space.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (measure_theory.measure_space.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_99341 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @is_atomistic.{1} (complete_distrib_lattice.{1} Type) (@function.extfun_app.{3 2} (Type 1) complete_lattice.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 complete_lattice.{1}) (complete_distrib_lattice.{1} Type))  := sorry --non-trivial
lemma new_lemma_99342 (h0 : group (has_neg (finset (finset Type)))) : group.fg (has_neg (finset (finset Type))) := sorry --non-trivial
lemma new_lemma_99343 (h0 : functor.add_const (ring pos) name) : @strong_rank_condition.{0} pos (@functor.add_const.run.{0 0} (ring.{0} pos) name h0)  := sorry --non-trivial
lemma new_lemma_99344 (h0 : complete_lattice (linear_ordered_comm_group (option (option ennreal)))) : complete_lattice.is_Sup_finite_compact (linear_ordered_comm_group (option (option ennreal))) := sorry --non-trivial
lemma new_lemma_99345 (h0 : not (function.extfun Type uniform_space -> false)) : @complete_space.{0} (has_emptyc.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type uniform_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type uniform_space.{0}) h0) (has_emptyc.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_99346 (h0 : group (id (random_gen (random_gen (random_gen linarith.ineq))))) : group.fg (id (random_gen (random_gen (random_gen linarith.ineq)))) := sorry --non-trivial
lemma new_lemma_99347 (h0 : functor.add_const (topological_space (has_zero environment.implicit_infer_kind)) Type) : @path_connected_space.{0} (has_zero.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 1} (topological_space.{0} (has_zero.{0} environment.implicit_infer_kind)) Type h0)  := sorry --non-trivial
lemma new_lemma_99348 (h0 : ring (semigroup (option empty))) : is_domain (semigroup (option empty)) := sorry --non-trivial
lemma new_lemma_99349 (h0 : monoid (random_gen to_additive.value_type)) : monoid.fg (random_gen to_additive.value_type) := sorry --non-trivial
lemma new_lemma_99350 (h0 : functor.add_const (complete_lattice (linear_ordered_comm_ring num)) num) : @complete_lattice.is_Sup_finite_compact.{0} (linear_ordered_comm_ring.{0} num) (@functor.add_const.run.{0 0} (complete_lattice.{0} (linear_ordered_comm_ring.{0} num)) num h0)  := sorry --non-trivial
lemma new_lemma_99351 (h0 : topological_space (ordered_comm_ring (has_Inf (has_bot (has_Inf real))))) : preirreducible_space (ordered_comm_ring (has_Inf (has_bot (has_Inf real)))) := sorry --non-trivial
lemma new_lemma_99352 (h0 : functor.add_const (topological_space (semigroup empty)) empty) : @path_connected_space.{0} (semigroup.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (semigroup.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_99353 (h0 : ordered_comm_monoid (has_to_string (has_Inf linarith.comp))) : has_exists_mul_of_le (has_to_string (has_Inf linarith.comp)) := sorry --non-trivial
lemma new_lemma_99354 (h0 : ordered_comm_monoid (finset (finset name))) : has_exists_mul_of_le (finset (finset name)) := sorry --non-trivial
lemma new_lemma_99355 (h0 : topological_space (filter (option unsigned))) : t1_space (filter (option unsigned)) := sorry --non-trivial
lemma new_lemma_99356 (h0 : uniform_space (has_add (add_left_cancel_monoid (has_nnnorm linarith.comp_source)))) : complete_space (has_add (add_left_cancel_monoid (has_nnnorm linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_99357 (h0 : topological_space (has_bot (has_add name))) : topological_space.separable_space (has_bot (has_add name)) := sorry --non-trivial
lemma new_lemma_99358 (h0 : functor.add_const (topological_space (semigroup environment.implicit_infer_kind)) Type) : @irreducible_space.{0} (semigroup.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 1} (topological_space.{0} (semigroup.{0} environment.implicit_infer_kind)) Type h0)  := sorry --non-trivial
lemma new_lemma_99359 (h0 : ring (has_norm empty)) : is_domain (has_norm empty) := sorry --non-trivial
lemma new_lemma_99360 (h0 : function.extfun Type semiring) : @is_noetherian_ring.{0} (linear_order.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type semiring.{0} h0 (linear_order.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_99361 (h0 : functor.add_const (function.extfun Type group) (option pos)) : @is_simple_group.{0} (has_neg.{0} pos) (@function.extfun_app.{2 1} Type group.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type group.{0}) (option.{0} pos) h0) (has_neg.{0} pos))  := sorry --non-trivial
lemma new_lemma_99362 (h0 : topological_space (boolean_algebra.core (ordered_ring pos))) : t0_space (boolean_algebra.core (ordered_ring pos)) := sorry --non-trivial
lemma new_lemma_99363 (h0 : ring (random_gen (mul_one_class char))) : rank_condition (random_gen (mul_one_class char)) := sorry --non-trivial
lemma new_lemma_99364 (h0 : uniform_space (has_nndist empty)) : separated_space (has_nndist empty) := sorry --non-trivial
lemma new_lemma_99365 (h0 : function.extfun Type (functor.comp ring mul_zero_class)) : @strong_rank_condition.{0} (mul_zero_class.{0} ennreal) (@functor.comp.run.{0 0 0} ring.{0} mul_zero_class.{0} ennreal (@function.extfun_app.{2 1} Type (functor.comp.{0 0 0} ring.{0} mul_zero_class.{0}) h0 ennreal))  := sorry --non-trivial
lemma new_lemma_99366 (h0 : has_mem.mem (normed_group fun_info) has_emptyc.emptyc) : @totally_disconnected_space.{0} (normed_group.{0} fun_info) (@finset.pi.empty.{1 0} Type topological_space.{0} (normed_group.{0} fun_info) h0)  := sorry --non-trivial
lemma new_lemma_99367 (h0 : topological_space (comm_monoid num)) : normal_space (comm_monoid num) := sorry --non-trivial
lemma new_lemma_99368 (h0 : not (function.extfun (Type -> Type) (function.extfun Type) -> false)) : @locally_compact_space.{0} (has_emptyc.{0} fun_info) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) (@classical.by_contradiction'.{2} (function.extfun.{2 2} (Type → Type) (function.extfun.{2 1} Type)) h0) topological_space.{0}) (has_emptyc.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_99369 (h0 : function.extfun Type (functor.comp topological_space has_neg)) : @t1_space.{0} (has_neg.{0} pos) (@functor.comp.run.{0 0 0} topological_space.{0} has_neg.{0} pos (@function.extfun_app.{2 1} Type (functor.comp.{0 0 0} topological_space.{0} has_neg.{0}) h0 pos))  := sorry --non-trivial
lemma new_lemma_99370 (h0 : functor.add_const (filter Type) linarith.comp) : filter.ne_bot (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_99371 (h0 : not (topological_space (option num) -> false)) : @preirreducible_space.{0} (option.{0} num) (@classical.by_contradiction'.{1} (topological_space.{0} (option.{0} num)) h0)  := sorry --non-trivial
lemma new_lemma_99372 (h0 : functor.add_const (topological_space (semigroup Type)) Type) : @irreducible_space.{1} (semigroup.{1} Type) (@functor.add_const.run.{1 1} (topological_space.{1} (semigroup.{1} Type)) Type h0)  := sorry --non-trivial
lemma new_lemma_99373 (h0 : has_mem.mem (has_emptyc num) has_emptyc.emptyc) : filter.ne_bot (finset.pi.empty filter (has_emptyc num) h0) := sorry --non-trivial
lemma new_lemma_99374 (h0 : prod (linear_ordered_cancel_comm_monoid congr_arg_kind) (linear_ordered_cancel_comm_monoid congr_arg_kind)) : id_rel h0 := sorry --non-trivial
lemma new_lemma_99375 (h0 : filter (complete_distrib_lattice environment.implicit_infer_kind)) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_99376 (h0 : filter (canonically_linear_ordered_monoid (option name))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_99377 (h0 : functor.add_const (function.extfun Type topological_space) Type) : @t0_space.{0} (add_cancel_monoid.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type topological_space.{0}) Type h0) (add_cancel_monoid.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_99378 (h0 : has_mem.mem (metric_space linarith.comp) has_emptyc.emptyc) : @preirreducible_space.{0} (metric_space.{0} linarith.comp) (@finset.pi.empty.{1 0} Type topological_space.{0} (metric_space.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_99379 (h0 : complete_lattice (has_ssubset (random_gen to_additive.value_type))) : complete_lattice.is_Sup_finite_compact (has_ssubset (random_gen to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_99380 (h1 : ring (normed_group (denumerable (denumerable linarith.ineq)))) : rank_condition (normed_group (denumerable (denumerable linarith.ineq))) := sorry --non-trivial
lemma new_lemma_99381 (h0 : function.extfun Type (functor.add_const (functor.add_const Prop Type))) : functor.add_const.run (functor.add_const.run (function.extfun_app h0 pos)) := sorry --non-trivial
lemma new_lemma_99382 (h2 : topological_space (has_div (mul_one_class (mul_one_class char)))) : path_connected_space (has_div (mul_one_class (mul_one_class char))) := sorry --non-trivial
lemma new_lemma_99383 (h0 : complete_lattice (finset name)) : complete_lattice.is_Sup_finite_compact (finset name) := sorry --non-trivial
lemma new_lemma_99384 (h0 : fin has_zero.zero) : @is_cyclic.{0} (boolean_algebra.{0} real) (@matrix.vec_empty.{0} (group.{0} (boolean_algebra.{0} real)) h0)  := sorry --non-trivial
lemma new_lemma_99385 (h1 : topological_space (has_compl string_imp)) : locally_compact_space (has_compl string_imp) := sorry --non-trivial
lemma new_lemma_99386 (h0 : functor.add_const (function.extfun Type uniform_space) pos) : @separated_space.{0} (mul_zero_class.{0} pos) (@function.extfun_app.{2 1} Type uniform_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type uniform_space.{0}) pos h0) (mul_zero_class.{0} pos))  := sorry --non-trivial
lemma new_lemma_99387 (h0 : topological_space (add_monoid linarith.comp_source)) : path_connected_space (add_monoid linarith.comp_source) := sorry --non-trivial
lemma new_lemma_99388 (h1 : topological_space (has_top (random_gen string_imp))) : totally_separated_space (has_top (random_gen string_imp)) := sorry --non-trivial
lemma new_lemma_99389 (h0 : functor.add_const (filter (complete_distrib_lattice pos)) (ring pos)) : countable_Inter_filter (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_99390 (h0 : topological_space (cancel_monoid name)) : topological_space.separable_space (cancel_monoid name) := sorry --non-trivial
lemma new_lemma_99391 (h0 : ring (with_bot (random_gen linarith.comp_source))) : is_domain (with_bot (random_gen linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_99392 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @unique_factorization_monoid.{0} (canonically_ordered_comm_semiring.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type cancel_comm_monoid_with_zero.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 cancel_comm_monoid_with_zero.{0}) (canonically_ordered_comm_semiring.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_99393 (h0 : topological_space (random_gen (has_top to_additive.value_type))) : discrete_topology (random_gen (has_top to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_99394 (h0 : has_mem.mem (has_emptyc fun_info) has_emptyc.emptyc) : @rank_condition.{0} (has_emptyc.{0} fun_info) (@finset.pi.empty.{1 0} Type ring.{0} (has_emptyc.{0} fun_info) h0)  := sorry --non-trivial
lemma new_lemma_99395 (h0 : functor.add_const (group (semigroup name)) name) : @is_simple_group.{0} (semigroup.{0} name) (@functor.add_const.run.{0 0} (group.{0} (semigroup.{0} name)) name h0)  := sorry --non-trivial
lemma new_lemma_99396 (h0 : ring (has_dist congr_arg_kind)) : is_principal_ideal_ring (has_dist congr_arg_kind) := sorry --non-trivial
lemma new_lemma_99397 (h0 : monoid (has_well_founded empty)) : monoid.fg (has_well_founded empty) := sorry --non-trivial
lemma new_lemma_99398 (h0 : uniform_space (normed_group (has_top fun_info))) : complete_space (normed_group (has_top fun_info)) := sorry --non-trivial
lemma new_lemma_99399 (h0 : group (semi_normed_comm_ring (random_gen string_imp))) : group.fg (semi_normed_comm_ring (random_gen string_imp)) := sorry --non-trivial
lemma new_lemma_99400 (h0 : functor.add_const (ordered_add_comm_monoid (has_star empty)) empty) : @archimedean.{0} (has_star.{0} empty) (@functor.add_const.run.{0 0} (ordered_add_comm_monoid.{0} (has_star.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_99401 (h1 : uniform_space (nondiscrete_normed_field reducibility_hints)) : complete_space (nondiscrete_normed_field reducibility_hints) := sorry --non-trivial
lemma new_lemma_99402 (h0 : topological_space (ring (sub_neg_monoid real))) : topological_space.separable_space (ring (sub_neg_monoid real)) := sorry --non-trivial
lemma new_lemma_99403 (h0 : fin has_zero.zero) : @is_atomistic.{0} (linear_ordered_comm_ring.{0} (option.{0} unsigned)) (@matrix.vec_empty.{0} (complete_lattice.{0} (linear_ordered_comm_ring.{0} (option.{0} unsigned))) h0)  := sorry --non-trivial
lemma new_lemma_99404 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_domain.{0} (has_ssubset.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (has_ssubset.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_99405 (h0 : filter (has_add (finset linarith.comp))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_99406 (h0 : topological_space (has_one (has_top (semiring (semiring num))))) : irreducible_space (has_one (has_top (semiring (semiring num)))) := sorry --non-trivial
lemma new_lemma_99407 (h0 : functor.add_const (functor.add_const (functor.add_const Prop empty) num) empty) : functor.add_const.run (functor.add_const.run (functor.add_const.run h0)) := sorry --non-trivial
lemma new_lemma_99408 (h0 : uniform_space (normed_linear_ordered_group num)) : complete_space (normed_linear_ordered_group num) := sorry --non-trivial
lemma new_lemma_99409 (h0 : functor.add_const (topological_space (has_add environment.implicit_infer_kind)) name) : @sequential_space.{0} (has_add.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (has_add.{0} environment.implicit_infer_kind)) name h0)  := sorry --non-trivial
lemma new_lemma_99410 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @path_connected_space.{0} (has_top.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_top.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_99411 (h0 : function.extfun nat fin) : @locally_compact_space.{0} (ordered_comm_monoid.{0} linarith.comp) (@matrix.vec_empty.{0} (topological_space.{0} (ordered_comm_monoid.{0} linarith.comp)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_99412 (h0 : empty -> Prop) : exists_unique h0 := sorry --non-trivial
lemma new_lemma_99413 (h0 : topological_space (has_Inf Type)) : totally_disconnected_space (has_Inf Type) := sorry --non-trivial
lemma new_lemma_99414 (h0 : complete_lattice (complete_semilattice_Sup fun_info)) : complete_lattice.is_Sup_finite_compact (complete_semilattice_Sup fun_info) := sorry --non-trivial
lemma new_lemma_99415 (h0 : ring (canonically_ordered_monoid (has_pos_part (has_add linarith.comp)))) : strong_rank_condition (canonically_ordered_monoid (has_pos_part (has_add linarith.comp))) := sorry --non-trivial
lemma new_lemma_99416 (h0 : has_mem.mem ring has_emptyc.emptyc) : @rank_condition.{0} (comm_semigroup.{0} linarith.comp) (@function.extfun_app.{2 1} Type ring.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) ring.{0} h0) (comm_semigroup.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_99417 (h0 : uniform_space (comm_group (comm_group (comm_group name)))) : separated_space (comm_group (comm_group (comm_group name))) := sorry --non-trivial
lemma new_lemma_99418 (h0 : complete_lattice (fintype char)) : complete_lattice.is_Sup_finite_compact (fintype char) := sorry --non-trivial
lemma new_lemma_99419 (h0 : complete_lattice (semiring (semiring congr_arg_kind))) : is_atomistic (semiring (semiring congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_99420 (h0 : ring (has_bot Type)) : is_principal_ideal_ring (has_bot Type) := sorry --non-trivial
lemma new_lemma_99421 (h0 : function.extfun Type topological_space) : discrete_topology real := sorry --non-trivial
lemma new_lemma_99422 (h0 : functor.comp add_group cancel_monoid Type) : @is_add_cyclic.{1} (cancel_monoid.{1} Type) (@functor.comp.run.{1 1 1} add_group.{1} cancel_monoid.{1} Type h0)  := sorry --non-trivial
lemma new_lemma_99423 (h0 : fin has_zero.zero) : @is_principal_ideal_ring.{1} (boolean_algebra.{1} Type) (@matrix.vec_empty.{1} (ring.{1} (boolean_algebra.{1} Type)) (@matrix.vec_empty.{0} (fin (@has_zero.zero.{0} nat nat.has_zero)) h0))  := sorry --non-trivial
lemma new_lemma_99424 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_add_cyclic.{0} (linear_ordered_comm_group.{0} ennreal) (@function.extfun_app.{2 1} Type add_group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 add_group.{0}) (linear_ordered_comm_group.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_99425 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @rank_condition.{1} (canonically_linear_ordered_monoid.{1} Type) (@function.extfun_app.{3 2} (Type 1) ring.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 ring.{1}) (canonically_linear_ordered_monoid.{1} Type))  := sorry --non-trivial
lemma new_lemma_99426 (h0 : monoid (semiring (semiring num))) : monoid.fg (semiring (semiring num)) := sorry --non-trivial
lemma new_lemma_99427 (h0 : function.extfun Type complete_lattice) : @complete_lattice.is_Sup_finite_compact.{0} (complete_distrib_lattice.{0} pos) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (complete_distrib_lattice.{0} pos))  := sorry --non-trivial
lemma new_lemma_99428 (h0 : monoid (with_one congr_arg_kind)) : monoid.fg (with_one congr_arg_kind) := sorry --non-trivial
lemma new_lemma_99429 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @totally_disconnected_space.{0} (normed_lattice_add_comm_group.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (normed_lattice_add_comm_group.{0} empty))  := sorry --non-trivial
lemma new_lemma_99430 (h0 : functor.add_const (function.extfun (Type 1) ordered_add_comm_monoid) pos) : @archimedean.{1} (boolean_algebra.{1} Type) (@function.extfun_app.{3 2} (Type 1) ordered_add_comm_monoid.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) ordered_add_comm_monoid.{1}) pos h0) (boolean_algebra.{1} Type))  := sorry --non-trivial
lemma new_lemma_99431 (h0 : functor.add_const (filter (comm_group name)) linarith.comp) : filter.ne_bot (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_99432 (h0 : group (canonically_ordered_add_monoid empty)) : normalizer_condition (canonically_ordered_add_monoid empty) := sorry --non-trivial
lemma new_lemma_99433 (h1 : add_group (distrib (has_nnnorm (has_nnnorm (has_nnnorm (has_nnnorm char)))))) : is_add_cyclic (distrib (has_nnnorm (has_nnnorm (has_nnnorm (has_nnnorm char))))) := sorry --non-trivial
lemma new_lemma_99434 (h0 : function.extfun Type topological_space) : @locally_compact_space.{0} (with_one.{0} char) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (with_one.{0} char))  := sorry --non-trivial
lemma new_lemma_99435 (h0 : not (function.extfun Type group -> false)) : @normalizer_condition.{0} (has_top.{0} num) (@function.extfun_app.{2 1} Type group.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type group.{0}) h0) (has_top.{0} num))  := sorry --non-trivial
lemma new_lemma_99436 (h0 : ring (monoid (option (option (option (option (option (option empty)))))))) : is_principal_ideal_ring (monoid (option (option (option (option (option (option empty))))))) := sorry --non-trivial
lemma new_lemma_99437 (h0 : add_group std_gen) (h1 : add_subgroup std_gen) : add_subgroup.is_commutative h1 := sorry --non-trivial
lemma new_lemma_99438 (h0 : group (normed_lattice_add_comm_group (sub_neg_monoid real))) : is_cyclic (normed_lattice_add_comm_group (sub_neg_monoid real)) := sorry --non-trivial
lemma new_lemma_99439 (h1 : uniform_space (id num)) : complete_space (id num) := sorry --non-trivial
lemma new_lemma_99440 (h0 : not (ring (metric_space string_imp) -> false)) : @strong_rank_condition.{0} (metric_space.{0} string_imp) (@classical.by_contradiction'.{1} (ring.{0} (metric_space.{0} string_imp)) h0)  := sorry --non-trivial
lemma new_lemma_99441 (h3 : function.extfun Type topological_space) : @totally_disconnected_space.{0} (with_bot.{0} linarith.ineq) (@function.extfun_app.{2 1} Type topological_space.{0} h3 (with_bot.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_99442 (h0 : function.extfun Type topological_space) : @normal_space.{0} (linear_ordered_field.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (linear_ordered_field.{0} empty))  := sorry --non-trivial
lemma new_lemma_99443 (h0 : monoid (with_one linarith.comp)) : monoid.fg (with_one linarith.comp) := sorry --non-trivial
lemma new_lemma_99444 (h0 : add_group (boolean_algebra (finset environment.implicit_infer_kind))) : is_add_cyclic (boolean_algebra (finset environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_99445 (h0 : uniform_space (has_div reducibility_hints)) : complete_space (has_div reducibility_hints) := sorry --non-trivial
lemma new_lemma_99446 (h0 : group (canonically_linear_ordered_monoid (sub_neg_monoid (sub_neg_monoid (sub_neg_monoid pos))))) : group.fg (canonically_linear_ordered_monoid (sub_neg_monoid (sub_neg_monoid (sub_neg_monoid pos)))) := sorry --non-trivial
lemma new_lemma_99447 (h0 : functor.add_const (ring (complete_distrib_lattice Type)) linarith.comp) : @rank_condition.{1} (complete_distrib_lattice.{1} Type) (@functor.add_const.run.{1 0} (ring.{1} (complete_distrib_lattice.{1} Type)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_99448 (h0 : not (function.extfun Type add_monoid -> false)) : @add_monoid.fg.{0} (linear_ordered_semiring.{0} unsigned) (@id.{1} (add_monoid.{0} (linear_ordered_semiring.{0} unsigned)) (@function.extfun_app.{2 1} Type add_monoid.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type add_monoid.{0}) h0) (linear_ordered_semiring.{0} unsigned)))  := sorry --non-trivial
lemma new_lemma_99449 (h0 : group (cancel_monoid (comm_group (comm_group (comm_group name))))) : group.fg (cancel_monoid (comm_group (comm_group (comm_group name)))) := sorry --non-trivial
lemma new_lemma_99450 (h0 : not (complete_lattice (measurable_space linarith.comp) -> false)) : is_atomistic (measurable_space linarith.comp) := sorry --non-trivial
lemma new_lemma_99451 (h0 : functor.comp group has_neg Type) : @normalizer_condition.{1} (has_neg.{1} Type) (@functor.comp.run.{1 1 1} group.{1} has_neg.{1} Type h0)  := sorry --non-trivial
lemma new_lemma_99452 (h0 : group (add_cancel_monoid (semiring empty))) : normalizer_condition (add_cancel_monoid (semiring empty)) := sorry --non-trivial
lemma new_lemma_99453 (h1 : ring (with_one fun_info)) : is_domain (with_one fun_info) := sorry --non-trivial
lemma new_lemma_99454 (h0 : functor.comp topological_space mul_zero_class ennreal) : @t0_space.{0} (mul_zero_class.{0} ennreal) (@functor.comp.run.{0 0 0} topological_space.{0} mul_zero_class.{0} ennreal h0)  := sorry --non-trivial
lemma new_lemma_99455 (h0 : topological_space (has_Inf (has_pos_part linarith.comp))) : preirreducible_space (has_Inf (has_pos_part linarith.comp)) := sorry --non-trivial
lemma new_lemma_99456 (h0 : function.extfun Type uniform_space) : @separated_space.{0} (add_left_cancel_semigroup.{0} unsigned) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (add_left_cancel_semigroup.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_99457 (h0 : topological_space (simple_graph (ring Type))) : sequential_space (simple_graph (ring Type)) := sorry --non-trivial
lemma new_lemma_99458 (h0 : topological_space (ring (option ennreal))) : loc_path_connected_space (ring (option ennreal)) := sorry --non-trivial
lemma new_lemma_99459 (h2 h3 : multiset (has_ssubset linarith.ineq)) : multiset.subset h2 h3 := sorry --non-trivial
lemma new_lemma_99460 (h0 : function.extfun Type topological_space) : @locally_compact_space.{0} (has_top.{0} linarith.ineq) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_top.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_99461 (h0 : functor.add_const (ordered_add_comm_monoid (boolean_algebra.core Type)) name) : @archimedean.{1} (boolean_algebra.core.{1} Type) (@functor.add_const.run.{1 0} (ordered_add_comm_monoid.{1} (boolean_algebra.core.{1} Type)) name h0)  := sorry --non-trivial
lemma new_lemma_99462 (h0 : functor.add_const (topological_space (ordered_ring unsigned)) (semiring congr_arg_kind)) : @irreducible_space.{0} (ordered_ring.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (ordered_ring.{0} unsigned)) (semiring.{0} congr_arg_kind) h0)  := sorry --non-trivial
lemma new_lemma_99463 (h0 : group (id (has_top linarith.ineq))) : normalizer_condition (id (has_top linarith.ineq)) := sorry --non-trivial
lemma new_lemma_99464 (h0 : function.extfun Type ring) : @is_principal_ideal_ring.{0} (canonically_ordered_add_monoid.{0} num) (@function.extfun_app.{2 1} Type ring.{0} h0 (canonically_ordered_add_monoid.{0} num))  := sorry --non-trivial
lemma new_lemma_99465 (h0 : topological_space (has_Inf (has_add (has_add Type)))) : locally_compact_space (has_Inf (has_add (has_add Type))) := sorry --non-trivial
lemma new_lemma_99466 (h2 : ring (add_comm_semigroup linarith.ineq)) : strong_rank_condition (add_comm_semigroup linarith.ineq) := sorry --non-trivial
lemma new_lemma_99467 (h0 : topological_space (boolean_algebra (has_Inf (has_neg Type)))) : totally_disconnected_space (boolean_algebra (has_Inf (has_neg Type))) := sorry --non-trivial
lemma new_lemma_99468 (h0 : functor.add_const (function.extfun Type group) pos) : @is_cyclic.{0} (ring.{0} pos) (@function.extfun_app.{2 1} Type group.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type group.{0}) pos h0) (ring.{0} pos))  := sorry --non-trivial
lemma new_lemma_99469 (h0 : topological_space (ordered_comm_monoid (has_add (has_add real)))) : preconnected_space (ordered_comm_monoid (has_add (has_add real))) := sorry --non-trivial
lemma new_lemma_99470 (h0 : function.extfun Type (functor.add_const (topological_space nnreal))) : t0_space nnreal := sorry --non-trivial
lemma new_lemma_99471 (h0 : topological_space (ordered_comm_monoid (has_Inf real))) : t1_space (ordered_comm_monoid (has_Inf real)) := sorry --non-trivial
lemma new_lemma_99472 (h0 : topological_space (has_neg Type)) : preconnected_space (has_neg Type) := sorry --non-trivial
lemma new_lemma_99473 (h0 : monoid (ring (finset linarith.comp))) : monoid.fg (ring (finset linarith.comp)) := sorry --non-trivial
lemma new_lemma_99474 (h0 : topological_space (plift (semiring empty))) : irreducible_space (plift (semiring empty)) := sorry --non-trivial
lemma new_lemma_99475 (h0 : topological_space (left_cancel_semigroup (option unsigned))) : t0_space (left_cancel_semigroup (option unsigned)) := sorry --non-trivial
lemma new_lemma_99476 (h0 : ordered_add_comm_monoid (generalized_boolean_algebra linarith.comp)) : archimedean (generalized_boolean_algebra linarith.comp) := sorry --non-trivial
lemma new_lemma_99477 (h0 : group (canonically_linear_ordered_monoid (option (option unsigned)))) : normalizer_condition (canonically_linear_ordered_monoid (option (option unsigned))) := sorry --non-trivial
lemma new_lemma_99478 (h0 : topological_space (normed_comm_ring (boolean_algebra.core Type))) : totally_disconnected_space (normed_comm_ring (boolean_algebra.core Type)) := sorry --non-trivial
lemma new_lemma_99479 (h0 : topological_space (option num)) : t1_space (option num) := sorry --non-trivial
lemma new_lemma_99480 (h0 : uniform_space (has_Inf linarith.comp)) : separated_space (has_Inf linarith.comp) := sorry --non-trivial
lemma new_lemma_99481 (h0 : topological_space (normed_comm_ring (has_neg (has_add environment.implicit_infer_kind)))) : preirreducible_space (normed_comm_ring (has_neg (has_add environment.implicit_infer_kind))) := sorry --non-trivial
lemma new_lemma_99482 (h0 : functor.add_const (topological_space (canonically_ordered_comm_semiring unsigned)) name) : @irreducible_space.{0} (canonically_ordered_comm_semiring.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (canonically_ordered_comm_semiring.{0} unsigned)) name h0)  := sorry --non-trivial
lemma new_lemma_99483 (h0 : function.extfun Type topological_space) : @topological_space.separable_space.{0} (has_add.{0} (has_Inf.{0} linarith.comp)) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_add.{0} (has_Inf.{0} linarith.comp)))  := sorry --non-trivial
lemma new_lemma_99484 (h0 : has_mem.mem (with_one fun_info) has_emptyc.emptyc) : @group.fg.{0} (with_one.{0} fun_info) (@finset.pi.empty.{1 0} Type group.{0} (with_one.{0} fun_info) h0)  := sorry --non-trivial
lemma new_lemma_99485 (h0 : ring (has_zero (has_zero (has_neg (has_zero (finset linarith.comp)))))) : rank_condition (has_zero (has_zero (has_neg (has_zero (finset linarith.comp))))) := sorry --non-trivial
lemma new_lemma_99486 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @t1_space.{1} (add_cancel_monoid.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 topological_space.{1}) (add_cancel_monoid.{1} Type))  := sorry --non-trivial
lemma new_lemma_99487 (h0 : add_group (has_norm (semiring (semiring num)))) : is_add_cyclic (has_norm (semiring (semiring num))) := sorry --non-trivial
lemma new_lemma_99488 (h0 : functor.add_const (topological_space (ordered_cancel_add_comm_monoid ennreal)) ennreal) : @irreducible_space.{0} (ordered_cancel_add_comm_monoid.{0} ennreal) (@functor.add_const.run.{0 0} (topological_space.{0} (ordered_cancel_add_comm_monoid.{0} ennreal)) ennreal h0)  := sorry --non-trivial
lemma new_lemma_99489 (h0 : monoid (has_bot (has_add (has_Inf pos)))) : monoid.fg (has_bot (has_add (has_Inf pos))) := sorry --non-trivial
lemma new_lemma_99490 (h0 : group (with_bot (semiring (semiring linarith.comp)))) : is_cyclic (with_bot (semiring (semiring linarith.comp))) := sorry --non-trivial
lemma new_lemma_99491 (h0 : function.extfun Type add_group) : @is_add_cyclic.{0} (preorder.{0} empty) (@function.extfun_app.{2 1} Type add_group.{0} h0 (preorder.{0} empty))  := sorry --non-trivial
lemma new_lemma_99492 (h0 : functor.add_const (function.extfun (Type 1) list) Type) : list.nodup (function.extfun_app (functor.add_const.run h0) (semigroup Type)) := sorry --non-trivial
lemma new_lemma_99493 (h0 : add_group (has_norm (random_gen congr_arg_kind))) : is_add_cyclic (has_norm (random_gen congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_99494 (h0 : filter (ordered_comm_ring (has_pos_part linarith.comp))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_99495 (h0 : ring (normed_group (has_norm (has_top (has_top (has_top congr_arg_kind)))))) : rank_condition (normed_group (has_norm (has_top (has_top (has_top congr_arg_kind))))) := sorry --non-trivial
lemma new_lemma_99496 (h0 : set (distrib enat)) : set.subsingleton h0 := sorry --non-trivial
lemma new_lemma_99497 (h0 : functor.add_const (functor.add_const (complete_lattice real.angle) empty) num) : @complete_lattice.is_Sup_finite_compact.{0} real.angle (@functor.add_const.run.{0 0} (complete_lattice.{0} real.angle) empty (@functor.add_const.run.{0 0} (functor.add_const.{0 0} (complete_lattice.{0} real.angle) empty) num h0))  := sorry --non-trivial
lemma new_lemma_99498 (h0 : not (topological_space (has_ssubset char) -> false)) : @totally_disconnected_space.{0} (has_ssubset.{0} char) (@classical.by_contradiction'.{1} (topological_space.{0} (has_ssubset.{0} char)) h0)  := sorry --non-trivial
lemma new_lemma_99499 (h1 : complete_lattice (simple_graph (has_neg linarith.ineq))) : is_compactly_generated (simple_graph (has_neg linarith.ineq)) := sorry --non-trivial
lemma new_lemma_99500 (h0 : functor.add_const (ring (ordered_comm_ring pos)) pos) : @strong_rank_condition.{0} (ordered_comm_ring.{0} pos) (@functor.add_const.run.{0 0} (ring.{0} (ordered_comm_ring.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_99501 (h0 : ring (semigroup (ring (finset Type)))) : is_domain (semigroup (ring (finset Type))) := sorry --non-trivial
lemma new_lemma_99502 (h0 : group (add_group (semiring (semiring (add_group empty))))) : normalizer_condition (add_group (semiring (semiring (add_group empty)))) := sorry --non-trivial
lemma new_lemma_99503 (h0 : topological_space (has_Inf (has_pos_part (has_add pos)))) : normal_space (has_Inf (has_pos_part (has_add pos))) := sorry --non-trivial
lemma new_lemma_99504 (h0 : group (has_nnnorm linarith.ineq)) : group.fg (has_nnnorm linarith.ineq) := sorry --non-trivial
lemma new_lemma_99505 (h0 : topological_space (cancel_monoid (boolean_algebra (boolean_algebra.core name)))) : preconnected_space (cancel_monoid (boolean_algebra (boolean_algebra.core name))) := sorry --non-trivial
lemma new_lemma_99506 (h0 : ring (add_group num)) : is_domain (add_group num) := sorry --non-trivial
lemma new_lemma_99507 (h0 : functor.add_const (ordered_add_comm_monoid (has_nndist unsigned)) (ring pos)) : @archimedean.{0} (has_nndist.{0} unsigned) (@functor.add_const.run.{0 0} (ordered_add_comm_monoid.{0} (has_nndist.{0} unsigned)) (ring.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_99508 (h0 : functor.add_const (topological_space (boolean_algebra name)) Type) : @preconnected_space.{0} (boolean_algebra.{0} name) (@functor.add_const.run.{0 1} (topological_space.{0} (boolean_algebra.{0} name)) Type h0)  := sorry --non-trivial
lemma new_lemma_99509 (h0 : complete_lattice (simple_graph (mul_one_class (mul_one_class char)))) : is_compactly_generated (simple_graph (mul_one_class (mul_one_class char))) := sorry --non-trivial
lemma new_lemma_99510 (h0 : topological_space (random_gen (random_gen reducibility_hints))) : t0_space (random_gen (random_gen reducibility_hints)) := sorry --non-trivial
lemma new_lemma_99511 (h0 : functor.add_const (cancel_comm_monoid_with_zero (has_zero pos)) (finset environment.implicit_infer_kind)) : @unique_factorization_monoid.{0} (has_zero.{0} pos) (@functor.add_const.run.{0 0} (cancel_comm_monoid_with_zero.{0} (has_zero.{0} pos)) (finset.{0} environment.implicit_infer_kind) h0)  := sorry --non-trivial
lemma new_lemma_99512 (h0 : semiring (boolean_algebra.core (option name))) : is_noetherian_ring (boolean_algebra.core (option name)) := sorry --non-trivial
lemma new_lemma_99513 (h0 : functor.add_const (ordered_add_comm_monoid (semigroup Type)) linarith.comp) : @archimedean.{1} (semigroup.{1} Type) (@functor.add_const.run.{1 0} (ordered_add_comm_monoid.{1} (semigroup.{1} Type)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_99514 (h0 : function.extfun Type group) : @group.fg.{0} (linear_ordered_field.{0} name) (@function.extfun_app.{2 1} Type group.{0} h0 (linear_ordered_field.{0} name))  := sorry --non-trivial
lemma new_lemma_99515 (h0 : functor.add_const (function.extfun Type topological_space) name) : @path_connected_space.{0} (has_Inf.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) name h0) (has_Inf.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_99516 (h0 : functor.add_const (topological_space (comm_group environment.implicit_infer_kind)) (has_neg linarith.comp)) : @regular_space.{0} (comm_group.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (comm_group.{0} environment.implicit_infer_kind)) (has_neg.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_99517 (h0 : add_monoid (id (id congr_arg_kind))) : add_monoid.fg (id (id congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_99518 (h0 : finset (measurable_space.dynkin_system congr_arg_kind)) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_99519 (h0 : function.extfun Type topological_space) : @t1_space.{0} (semiring.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (semiring.{0} num))  := sorry --non-trivial
lemma new_lemma_99520 (h0 : topological_space (linear_ordered_comm_ring (semiring (has_top (semiring empty))))) : preirreducible_space (linear_ordered_comm_ring (semiring (has_top (semiring empty)))) := sorry --non-trivial
lemma new_lemma_99521 (h0 : functor.comp group boolean_algebra Type) : @is_cyclic.{1} (boolean_algebra.{1} Type) (@functor.comp.run.{1 1 1} group.{1} boolean_algebra.{1} Type h0)  := sorry --non-trivial
lemma new_lemma_99522 (h0 : topological_space (mul_zero_class (finset name))) : regular_space (mul_zero_class (finset name)) := sorry --non-trivial
lemma new_lemma_99523 (h0 : complete_lattice (has_top linarith.ineq)) : complete_lattice.is_Sup_finite_compact (has_top linarith.ineq) := sorry --non-trivial
lemma new_lemma_99524 (h0 : topological_space (has_add pos)) : sequential_space (has_add pos) := sorry --non-trivial
lemma new_lemma_99525 (h0 : functor.add_const (group (cancel_monoid pos)) pos) : @group.fg.{0} (cancel_monoid.{0} pos) (@functor.add_const.run.{0 0} (group.{0} (cancel_monoid.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_99526 (h0 : functor.add_const (cancel_comm_monoid_with_zero (ring empty)) unsigned) : @unique_factorization_monoid.{0} (ring.{0} empty) (@functor.add_const.run.{0 0} (cancel_comm_monoid_with_zero.{0} (ring.{0} empty)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_99527 (h0 : complete_lattice (non_unital_non_assoc_semiring (has_lt (random_gen (has_lt char))))) : is_compactly_generated (non_unital_non_assoc_semiring (has_lt (random_gen (has_lt char)))) := sorry --non-trivial
lemma new_lemma_99528 (h0 : function.extfun Type topological_space) : @t0_space.{0} (semiring.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (semiring.{0} num))  := sorry --non-trivial
lemma new_lemma_99529 (h0 : function.extfun Type (functor.add_const (complete_lattice auto.case_option))) : @complete_lattice.is_Sup_finite_compact.{0} auto.case_option (@functor.add_const.run.{0 0} (complete_lattice.{0} auto.case_option) empty (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (complete_lattice.{0} auto.case_option)) h0 empty))  := sorry --non-trivial
lemma new_lemma_99530 (h0 : fin has_zero.zero) : @normal_space.{0} (has_pos_part.{0} real) (@function.extfun_app.{2 1} Type topological_space.{0} (@matrix.vec_empty.{1} (function.extfun.{2 1} Type topological_space.{0}) h0) (has_pos_part.{0} real))  := sorry --non-trivial
lemma new_lemma_99531 (h0 : functor.add_const Prop (finset linarith.comp)) : functor.add_const.run h0 := sorry --non-trivial
lemma new_lemma_99532 (h0 : topological_space (complete_distrib_lattice (finset pos))) : path_connected_space (complete_distrib_lattice (finset pos)) := sorry --non-trivial
lemma new_lemma_99533 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_add_cyclic.{0} (has_Sup.{0} empty) (@function.extfun_app.{2 1} Type add_group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 add_group.{0}) (has_Sup.{0} empty))  := sorry --non-trivial
lemma new_lemma_99534 (h0 : functor.add_const (topological_space (measure_theory.measure_space num)) num) : @locally_compact_space.{0} (measure_theory.measure_space.{0} num) (@functor.add_const.run.{0 0} (topological_space.{0} (measure_theory.measure_space.{0} num)) num h0)  := sorry --non-trivial
lemma new_lemma_99535 (h0 : function.extfun Type topological_space) : @preirreducible_space.{0} (has_Inf.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_Inf.{0} name))  := sorry --non-trivial
lemma new_lemma_99536 (h1 : not (topological_space (has_ssubset reducibility_hints) -> false)) : @totally_disconnected_space.{0} (has_ssubset.{0} reducibility_hints) (@classical.by_contradiction'.{1} (topological_space.{0} (has_ssubset.{0} reducibility_hints)) h1)  := sorry --non-trivial
lemma new_lemma_99537 (h0 : functor.add_const (list (add_cancel_monoid Type)) (has_pos_part linarith.comp)) : palindrome (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_99538 (h0 : function.extfun (Type 1) ring) : @strong_rank_condition.{1} (add_cancel_monoid.{1} Type) (@function.extfun_app.{3 2} (Type 1) ring.{1} h0 (add_cancel_monoid.{1} Type))  := sorry --non-trivial
lemma new_lemma_99539 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @add_monoid.fg.{0} (sub_neg_monoid.{0} name) (@function.extfun_app.{2 1} Type add_monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 add_monoid.{0}) (sub_neg_monoid.{0} name))  := sorry --non-trivial
lemma new_lemma_99540 (h0 : function.extfun Type (functor.comp topological_space has_to_string)) : @discrete_topology.{0} (has_to_string.{0} unsigned) (@functor.comp.run.{0 0 0} topological_space.{0} has_to_string.{0} unsigned (@function.extfun_app.{2 1} Type (functor.comp.{0 0 0} topological_space.{0} has_to_string.{0}) h0 unsigned))  := sorry --non-trivial
lemma new_lemma_99541 (h0 : function.extfun Type topological_space) : @loc_path_connected_space.{0} (comm_semigroup.{0} real) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (comm_semigroup.{0} real))  := sorry --non-trivial
lemma new_lemma_99542 (h0 : functor.add_const (functor.add_const (ring pos) linarith.comp) pos) : @rank_condition.{0} pos (@functor.add_const.run.{0 0} (ring.{0} pos) linarith.comp (@functor.add_const.run.{0 0} (functor.add_const.{0 0} (ring.{0} pos) linarith.comp) pos h0))  := sorry --non-trivial
lemma new_lemma_99543 (h0 : group (complete_semilattice_Sup (semiring congr_arg_kind))) : group.fg (complete_semilattice_Sup (semiring congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_99544 (h0 : function.extfun Type complete_lattice) : @complete_lattice.is_Sup_finite_compact.{0} (distrib_lattice.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (distrib_lattice.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_99545 (h0 : functor.add_const (topological_space (option unsigned)) num) : @normal_space.{0} (option.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (option.{0} unsigned)) num h0)  := sorry --non-trivial
lemma new_lemma_99546 (h0 : group (has_union (has_top unsigned))) : normalizer_condition (has_union (has_top unsigned)) := sorry --non-trivial
lemma new_lemma_99547 (h0 : topological_space (mul_one_class (mul_one_class ereal))) (h1 : preorder (mul_one_class (mul_one_class ereal))) : order_topology (mul_one_class (mul_one_class ereal)) := sorry --non-trivial
lemma new_lemma_99548 (h0 : function.extfun Type filter) : filter.ne_bot (function.extfun_app h0 (left_cancel_monoid empty)) := sorry --non-trivial
lemma new_lemma_99549 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : countable_Inter_filter (function.extfun_app (function.extfun_app h0 filter) (add_comm_monoid name)) := sorry --non-trivial
lemma new_lemma_99550 (h0 : topological_space (add_comm_monoid (has_pos_part (sub_neg_monoid real)))) : regular_space (add_comm_monoid (has_pos_part (sub_neg_monoid real))) := sorry --non-trivial
lemma new_lemma_99551 (h0 : group (semigroup (semiring num))) : group.fg (semigroup (semiring num)) := sorry --non-trivial
lemma new_lemma_99552 (h0 : functor.add_const (topological_space (canonically_linear_ordered_monoid pos)) real) : @topological_space.separable_space.{0} (canonically_linear_ordered_monoid.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (canonically_linear_ordered_monoid.{0} pos)) real h0)  := sorry --non-trivial
lemma new_lemma_99553 (h0 : topological_space (normed_group (has_norm (has_norm fun_info)))) : path_connected_space (normed_group (has_norm (has_norm fun_info))) := sorry --non-trivial
lemma new_lemma_99554 (h0 : functor.add_const (topological_space (has_nndist unsigned)) (has_neg linarith.comp)) : @sequential_space.{0} (has_nndist.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (has_nndist.{0} unsigned)) (has_neg.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_99555 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @group.fg.{0} (has_compl.{0} char) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (has_compl.{0} char))  := sorry --non-trivial
lemma new_lemma_99556 (h1 : std_gen -> Prop) (h3 : filter std_gen) : filter.eventually h1 h3 := sorry --non-trivial
lemma new_lemma_99557 (h0 : topological_space (ring linarith.comp)) : discrete_topology (ring linarith.comp) := sorry --non-trivial
lemma new_lemma_99558 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @has_exists_mul_of_le.{0} environment.implicit_infer_kind (@function.extfun_app.{2 1} Type ordered_comm_monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ordered_comm_monoid.{0}) environment.implicit_infer_kind)  := sorry --non-trivial
lemma new_lemma_99559 (h0 : functor.add_const (prod (non_assoc_semiring empty) (non_assoc_semiring empty)) num) : id_rel (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_99560 (h0 : topological_space (has_star unsigned)) : t0_space (has_star unsigned) := sorry --non-trivial
lemma new_lemma_99561 (h0 : topological_space (add_left_cancel_semigroup (option empty))) : discrete_topology (add_left_cancel_semigroup (option empty)) := sorry --non-trivial
lemma new_lemma_99562 (h0 : functor.add_const (group (add_cancel_monoid environment.implicit_infer_kind)) (has_Inf (finset Type))) : @is_cyclic.{0} (add_cancel_monoid.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 1} (group.{0} (add_cancel_monoid.{0} environment.implicit_infer_kind)) (has_Inf.{1} (finset.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_99563 (h0 : topological_space (has_to_string (ring (has_pos_part (has_pos_part Type))))) : sequential_space (has_to_string (ring (has_pos_part (has_pos_part Type)))) := sorry --non-trivial
lemma new_lemma_99564 (h0 : uniform_space (cancel_monoid pos)) : separated_space (cancel_monoid pos) := sorry --non-trivial
lemma new_lemma_99565 (h0 : group (canonically_ordered_monoid (has_add linarith.comp))) : is_cyclic (canonically_ordered_monoid (has_add linarith.comp)) := sorry --non-trivial
lemma new_lemma_99566 (h1 : ring (semi_normed_ring char)) : rank_condition (semi_normed_ring char) := sorry --non-trivial
lemma new_lemma_99567 (h0 : topological_space (ordered_comm_monoid (has_Inf (has_add linarith.comp)))) : sequential_space (ordered_comm_monoid (has_Inf (has_add linarith.comp))) := sorry --non-trivial
lemma new_lemma_99568 (h0 : not (complete_lattice (partial_order unsigned) -> false)) : @is_atomistic.{0} (partial_order.{0} unsigned) (@classical.by_contradiction'.{1} (complete_lattice.{0} (partial_order.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_99569 (h0 : group (has_to_string (has_add (comm_group Type)))) : is_simple_group (has_to_string (has_add (comm_group Type))) := sorry --non-trivial
lemma new_lemma_99570 (h0 : list (has_Inf (has_add (has_add (has_add linarith.comp))))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_99571 (h0 : not (topological_space (has_emptyc fun_info) -> false)) : @totally_separated_space.{0} (has_emptyc.{0} fun_info) (@classical.by_contradiction'.{1} (topological_space.{0} (has_emptyc.{0} fun_info)) h0)  := sorry --non-trivial
lemma new_lemma_99572 (h0 : function.extfun Type topological_space) : @t1_space.{0} (left_cancel_monoid.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (left_cancel_monoid.{0} empty))  := sorry --non-trivial
lemma new_lemma_99573 (h0 : topological_space (option (option (has_nndist (option (option name)))))) : loc_path_connected_space (option (option (has_nndist (option (option name))))) := sorry --non-trivial
lemma new_lemma_99574 (h0 : topological_space (with_one (has_inv (has_top linarith.ineq)))) : totally_disconnected_space (with_one (has_inv (has_top linarith.ineq))) := sorry --non-trivial
lemma new_lemma_99575 (h0 : add_monoid (comm_group (comm_group Type))) : add_monoid.fg (comm_group (comm_group Type)) := sorry --non-trivial
lemma new_lemma_99576 (h0 : functor.add_const (complete_lattice (monoid_with_zero congr_arg_kind)) num) : @complete_lattice.is_Sup_finite_compact.{0} (monoid_with_zero.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (complete_lattice.{0} (monoid_with_zero.{0} congr_arg_kind)) num h0)  := sorry --non-trivial
lemma new_lemma_99577 (h0 : not (function.extfun (Type -> Type) (function.extfun Type) -> false)) (h1 : function.extfun Type id) : @is_max.{0} (@id.{2} Type num) (@function.extfun_app.{2 1} Type has_le.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) (@classical.by_contradiction'.{2} (function.extfun.{2 2} (Type → Type) (function.extfun.{2 1} Type)) h0) has_le.{0}) (@id.{2} Type num)) (@function.extfun_app.{2 1} Type (@id.{2} Type) h1 num)  := sorry --non-trivial
lemma new_lemma_99578 (h0 : ordered_comm_monoid (simple_graph (ring pos))) : has_exists_mul_of_le (simple_graph (ring pos)) := sorry --non-trivial
lemma new_lemma_99579 (h0 : functor.add_const (complete_lattice (generalized_boolean_algebra pos)) linarith.comp) : @is_compactly_generated.{0} (generalized_boolean_algebra.{0} pos) (@functor.add_const.run.{0 0} (complete_lattice.{0} (generalized_boolean_algebra.{0} pos)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_99580 (h0 : topological_space (partial_order (semiring (semiring unsigned)))) : loc_path_connected_space (partial_order (semiring (semiring unsigned))) := sorry --non-trivial
lemma new_lemma_99581 (h0 : add_group (has_inv (random_gen (random_gen (random_gen (random_gen (random_gen string_imp))))))) : is_add_cyclic (has_inv (random_gen (random_gen (random_gen (random_gen (random_gen string_imp)))))) := sorry --non-trivial
lemma new_lemma_99582 (h0 : ring (uniform_space (add_comm_semigroup linarith.ineq))) : rank_condition (uniform_space (add_comm_semigroup linarith.ineq)) := sorry --non-trivial
lemma new_lemma_99583 (h0 : function.extfun nat fin) : @normal_space.{0} (ring.{0} real) (@matrix.vec_empty.{0} (topological_space.{0} (ring.{0} real)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_99584 (h0 : function.extfun Type topological_space) : @loc_path_connected_space.{0} (pseudo_metric_space.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (pseudo_metric_space.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_99585 (h0 : complete_lattice (has_star (semiring empty))) : is_atomistic (has_star (semiring empty)) := sorry --non-trivial
lemma new_lemma_99586 (h0 : complete_lattice (ring (finset (has_neg (has_neg (ring pos)))))) : is_compactly_generated (ring (finset (has_neg (has_neg (ring pos))))) := sorry --non-trivial
lemma new_lemma_99587 (h0 : ordered_comm_monoid (add_comm_monoid (has_bot pos))) : has_exists_mul_of_le (add_comm_monoid (has_bot pos)) := sorry --non-trivial
lemma new_lemma_99588 (h0 : complete_lattice (has_compl (mul_one_class (has_sdiff reducibility_hints)))) : is_compactly_generated (has_compl (mul_one_class (has_sdiff reducibility_hints))) := sorry --non-trivial
lemma new_lemma_99589 (h0 : fin has_zero.zero) : @archimedean.{1} (ordered_comm_ring.{1} Type) (@matrix.vec_empty.{1} (ordered_add_comm_monoid.{1} (ordered_comm_ring.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_99590 (h0 : ring (finset (has_nndist environment.implicit_infer_kind))) : is_principal_ideal_ring (finset (has_nndist environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_99591 (h0 : topological_space (ordered_comm_monoid (has_Inf pos))) : totally_separated_space (ordered_comm_monoid (has_Inf pos)) := sorry --non-trivial
lemma new_lemma_99592 (h0 : function.extfun (finset (Type -> Type)) (has_mem.mem complete_lattice)) : complete_lattice.is_Sup_finite_compact (measurable_space num) := sorry --non-trivial
lemma new_lemma_99593 (h0 : uniform_space (normed_lattice_add_comm_group (has_neg (has_neg (has_neg name))))) : complete_space (normed_lattice_add_comm_group (has_neg (has_neg (has_neg name)))) := sorry --non-trivial
lemma new_lemma_99594 (h0 : function.extfun Type complete_lattice) : @is_compactly_generated.{0} (with_zero.{0} fun_info) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (with_zero.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_99595 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_cyclic.{0} (add_cancel_monoid.{0} unsigned) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (add_cancel_monoid.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_99596 (h0 : ring (has_nndist (has_to_string Type))) : strong_rank_condition (has_nndist (has_to_string Type)) := sorry --non-trivial
lemma new_lemma_99597 (h0 : topological_space (canonically_ordered_comm_semiring unsigned)) : t0_space (canonically_ordered_comm_semiring unsigned) := sorry --non-trivial
lemma new_lemma_99598 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_noetherian_ring.{0} (add_cancel_monoid.{0} empty) (@function.extfun_app.{2 1} Type semiring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 semiring.{0}) (add_cancel_monoid.{0} empty))  := sorry --non-trivial
lemma new_lemma_99599 (h0 : function.extfun Type complete_lattice) : @is_atomistic.{0} bool (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 bool)  := sorry --non-trivial
lemma new_lemma_99600 (h0 : topological_space (has_top (semiring (semiring congr_arg_kind)))) : normal_space (has_top (semiring (semiring congr_arg_kind))) := sorry --non-trivial
lemma new_lemma_99601 (h0 : set (has_nnnorm environment.projection_info)) : set.finite h0 := sorry --non-trivial
lemma new_lemma_99602 (h0 : topological_space (add_cancel_monoid (ring pos))) : topological_space.separable_space (add_cancel_monoid (ring pos)) := sorry --non-trivial
lemma new_lemma_99603 (h0 : group (normed_group fun_info)) : is_cyclic (normed_group fun_info) := sorry --non-trivial
lemma new_lemma_99604 (h0 : function.extfun Type add_group) : @is_add_cyclic.{0} (boolean_algebra.core.{0} (has_neg.{0} real)) (@function.extfun_app.{2 1} Type add_group.{0} h0 (boolean_algebra.core.{0} (has_neg.{0} real)))  := sorry --non-trivial
lemma new_lemma_99605 (h0 : finset (has_to_string (finset (finset Type)))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_99606 (h0 : topological_space (canonically_linear_ordered_monoid (cancel_monoid unsigned))) : totally_separated_space (canonically_linear_ordered_monoid (cancel_monoid unsigned)) := sorry --non-trivial
lemma new_lemma_99607 (h0 : topological_space (has_zero (finset (ring linarith.comp)))) : t1_space (has_zero (finset (ring linarith.comp))) := sorry --non-trivial
lemma new_lemma_99608 (h0 : topological_space (finset (finset (finset ennreal)))) : preirreducible_space (finset (finset (finset ennreal))) := sorry --non-trivial
lemma new_lemma_99609 (h0 : not (filter (with_bot num) -> false)) : filter.ne_bot (classical.by_contradiction' h0) := sorry --non-trivial
lemma new_lemma_99610 (h0 : functor.add_const (list (bin_tree empty)) empty) : palindrome (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_99611 (h0 : add_group (add_comm_monoid num)) : is_add_cyclic (add_comm_monoid num) := sorry --non-trivial
lemma new_lemma_99612 (h0 : functor.add_const (group (semigroup Type)) Type) : @normalizer_condition.{1} (semigroup.{1} Type) (@functor.add_const.run.{1 1} (group.{1} (semigroup.{1} Type)) Type h0)  := sorry --non-trivial
lemma new_lemma_99613 (h0 : functor.add_const (topological_space (ordered_ring empty)) num) : @t1_space.{0} (ordered_ring.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (ordered_ring.{0} empty)) num h0)  := sorry --non-trivial
lemma new_lemma_99614 (h0 : function.extfun Type topological_space) : @path_connected_space.{0} (normed_group.{0} char) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (normed_group.{0} char))  := sorry --non-trivial
lemma new_lemma_99615 (h0 : monoid (with_one (random_gen (random_gen (random_gen (has_top fun_info)))))) : monoid.fg (with_one (random_gen (random_gen (random_gen (has_top fun_info))))) := sorry --non-trivial
lemma new_lemma_99616 (h0 : not (function.extfun Type topological_space -> false)) : @path_connected_space.{0} (semiring.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (semiring.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_99617 (h0 : ring (cancel_monoid (option pos))) : is_domain (cancel_monoid (option pos)) := sorry --non-trivial
lemma new_lemma_99618 (h0 : topological_space (canonically_ordered_comm_semiring (cancel_monoid (ring (has_to_string pos))))) : path_connected_space (canonically_ordered_comm_semiring (cancel_monoid (ring (has_to_string pos)))) := sorry --non-trivial
lemma new_lemma_99619 (h0 : not (ring (with_bot unsigned) -> false)) : @is_principal_ideal_ring.{0} (with_bot.{0} unsigned) (@classical.by_contradiction'.{1} (ring.{0} (with_bot.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_99620 (h0 : topological_space (comm_group (option (option pos)))) : t0_space (comm_group (option (option pos))) := sorry --non-trivial
lemma new_lemma_99621 (h1 : group (denumerable to_additive.value_type)) : is_cyclic (denumerable to_additive.value_type) := sorry --non-trivial
lemma new_lemma_99622 (h0 : list (has_zero unsigned)) : palindrome h0 := sorry --non-trivial
lemma new_lemma_99623 (h0 : function.extfun Type complete_lattice) : @is_atomistic.{0} (normed_linear_ordered_group.{0} unsigned) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (normed_linear_ordered_group.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_99624 (h0 : function.extfun Type ring) : @rank_condition.{0} (@id.{2} Type congr_arg_kind) (@function.extfun_app.{2 1} Type ring.{0} h0 (@id.{2} Type congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_99625 (h0 : filter (semi_normed_ring linarith.comp_source)) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_99626 (h0 : functor.add_const (complete_lattice (generalized_boolean_algebra linarith.comp)) linarith.comp) : @complete_lattice.is_Sup_finite_compact.{0} (generalized_boolean_algebra.{0} linarith.comp) (@functor.add_const.run.{0 0} (complete_lattice.{0} (generalized_boolean_algebra.{0} linarith.comp)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_99627 (h0 : topological_space (has_emptyc linarith.ineq)) : t0_space (has_emptyc linarith.ineq) := sorry --non-trivial
lemma new_lemma_99628 (h0 : functor.add_const (add_monoid (has_zero name)) Type) : @add_monoid.fg.{0} (has_zero.{0} name) (@functor.add_const.run.{0 1} (add_monoid.{0} (has_zero.{0} name)) Type h0)  := sorry --non-trivial
lemma new_lemma_99629 (h0 : semiring (semigroup (has_neg (ring pos)))) : is_noetherian_ring (semigroup (has_neg (ring pos))) := sorry --non-trivial
lemma new_lemma_99630 (h0 : environment.projection_info -> environment.projection_info -> Prop) : is_per environment.projection_info h0 := sorry --non-trivial
lemma new_lemma_99631 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @strong_rank_condition.{0} (comm_monoid.{0} empty) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (comm_monoid.{0} empty))  := sorry --non-trivial
lemma new_lemma_99632 (h0 : group (comm_semigroup (has_add real))) : group.fg (comm_semigroup (has_add real)) := sorry --non-trivial
lemma new_lemma_99633 (h0 : simple_graph ereal) (h1 : sym2 ereal) : nonempty (subsingleton (simple_graph.edge_set h0 h1)) := sorry --non-trivial
lemma new_lemma_99634 (h0 : ring (ring unsigned)) : rank_condition (ring unsigned) := sorry --non-trivial
lemma new_lemma_99635 (h0 : functor.add_const (topological_space (has_neg Type)) (ring (has_neg (has_neg Type)))) : @irreducible_space.{1} (has_neg.{1} Type) (@functor.add_const.run.{1 1} (topological_space.{1} (has_neg.{1} Type)) (ring.{1} (has_neg.{1} (has_neg.{1} Type))) h0)  := sorry --non-trivial
lemma new_lemma_99636 (h0 : uniform_space (add_cancel_monoid (boolean_algebra linarith.comp))) : complete_space (add_cancel_monoid (boolean_algebra linarith.comp)) := sorry --non-trivial
lemma new_lemma_99637 (h0 : ring (has_sub unsigned)) : is_principal_ideal_ring (has_sub unsigned) := sorry --non-trivial
lemma new_lemma_99638 (h0 : functor.add_const (group (finset Type)) Type) : @is_simple_group.{1} (finset.{1} Type) (@functor.add_const.run.{1 1} (group.{1} (finset.{1} Type)) Type h0)  := sorry --non-trivial
lemma new_lemma_99639 (h0 : functor.add_const (ordered_comm_monoid (ring Type)) (boolean_algebra linarith.comp)) : @has_exists_mul_of_le.{1} (ring.{1} Type) (@functor.add_const.run.{1 0} (ordered_comm_monoid.{1} (ring.{1} Type)) (boolean_algebra.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_99640 (h0 : list (is_R_or_C (semiring empty))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_99641 (h0 : ring (semigroup (has_neg pos))) : rank_condition (semigroup (has_neg pos)) := sorry --non-trivial
lemma new_lemma_99642 (h0 : topological_space (canonically_ordered_monoid (has_Inf real))) : preirreducible_space (canonically_ordered_monoid (has_Inf real)) := sorry --non-trivial
lemma new_lemma_99643 (h0 : measurable_space (has_compl (mul_one_class linarith.comp_source))) (h1 : filter (has_compl (mul_one_class linarith.comp_source))) : filter.is_measurably_generated h1 := sorry --non-trivial
lemma new_lemma_99644 (h1 : ordered_comm_monoid (topological_space (random_gen char))) : has_exists_mul_of_le (topological_space (random_gen char)) := sorry --non-trivial
lemma new_lemma_99645 (h0 : topological_space (measurable_space (semiring num))) : totally_separated_space (measurable_space (semiring num)) := sorry --non-trivial
lemma new_lemma_99646 (h2 : has_neg (add_comm_semigroup reducibility_hints)) (h3 : measurable_space (add_comm_semigroup reducibility_hints)) : has_measurable_neg (add_comm_semigroup reducibility_hints) := sorry --non-trivial
lemma new_lemma_99647 (h0 : functor.add_const (group (canonically_ordered_comm_semiring pos)) pos) : @is_simple_group.{0} (canonically_ordered_comm_semiring.{0} pos) (@functor.add_const.run.{0 0} (group.{0} (canonically_ordered_comm_semiring.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_99648 (h0 : not (function.extfun Type topological_space -> false)) : @normal_space.{0} (has_one.{0} fun_info) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (has_one.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_99649 (h0 : list (has_norm (comm_ring linarith.ineq))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_99650 (h0 : functor.add_const (add_group (filter empty)) empty) : @is_add_cyclic.{0} (filter.{0} empty) (@functor.add_const.run.{0 0} (add_group.{0} (filter.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_99651 (h0 : add_group (denumerable (comm_ring (comm_ring linarith.comp_source)))) : is_add_cyclic (denumerable (comm_ring (comm_ring linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_99652 (h0 : group (normed_comm_ring (cancel_monoid (cancel_monoid (cancel_monoid pos))))) : group.fg (normed_comm_ring (cancel_monoid (cancel_monoid (cancel_monoid pos)))) := sorry --non-trivial
lemma new_lemma_99653 (h0 : function.extfun (((Type -> Type) -> Type 1) -> Type 1) (function.extfun ((Type -> Type) -> Type 1))) : @is_compactly_generated.{0} (has_norm.{0} linarith.ineq) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) (@function.extfun_app.{3 2} ((Type → Type) → Type 1) (function.extfun.{2 2} (Type → Type)) (@function.extfun_app.{3 3} (((Type → Type) → Type 1) → Type 1) (function.extfun.{3 2} ((Type → Type) → Type 1)) h0 (function.extfun.{2 2} (Type → Type))) (function.extfun.{2 1} Type)) complete_lattice.{0}) (has_norm.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_99654 (h0 : filter (distrib linarith.ineq)) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_99655 (h0 : group (partial_order empty) -> Prop) (h1 : Exists (fun (x : group (partial_order empty)), h0 x)) : @is_cyclic.{0} (partial_order.{0} empty) (@classical.some.{1} (group.{0} (partial_order.{0} empty)) h0 h1)  := sorry --non-trivial
lemma new_lemma_99656 (h0 : topological_space (denumerable (has_ssubset char))) : totally_disconnected_space (denumerable (has_ssubset char)) := sorry --non-trivial
lemma new_lemma_99657 (h0 : topological_space (has_zero (option ennreal))) : t1_space (has_zero (option ennreal)) := sorry --non-trivial
lemma new_lemma_99658 (h0 : monoid (has_neg (option ennreal))) : monoid.fg (has_neg (option ennreal)) := sorry --non-trivial
lemma new_lemma_99659 (h0 : topological_space (has_inter ennreal)) : locally_compact_space (has_inter ennreal) := sorry --non-trivial
lemma new_lemma_99660 (h0 : not (list (normed_group congr_arg_kind) -> false)) : list.nodup (classical.by_contradiction' h0) := sorry --non-trivial
lemma new_lemma_99661 (h0 : function.extfun Type (functor.comp add_group has_neg)) : @is_add_cyclic.{0} (has_neg.{0} unsigned) (@functor.comp.run.{0 0 0} add_group.{0} has_neg.{0} unsigned (@function.extfun_app.{2 1} Type (functor.comp.{0 0 0} add_group.{0} has_neg.{0}) h0 unsigned))  := sorry --non-trivial
lemma new_lemma_99662 (h0 : function.extfun (Type 1) uniform_space) : @separated_space.{1} (ring.{1} Type) (@function.extfun_app.{3 2} (Type 1) uniform_space.{1} h0 (ring.{1} Type))  := sorry --non-trivial
lemma new_lemma_99663 (h0 : function.extfun Type topological_space) : @totally_separated_space.{0} (measurable_space.{0} (has_top.{0} (has_top.{0} (has_top.{0} congr_arg_kind)))) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (measurable_space.{0} (has_top.{0} (has_top.{0} (has_top.{0} congr_arg_kind)))))  := sorry --non-trivial
lemma new_lemma_99664 (h0 : topological_space (add_cancel_comm_monoid congr_arg_kind)) : t1_space (add_cancel_comm_monoid congr_arg_kind) := sorry --non-trivial
lemma new_lemma_99665 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @complete_lattice.is_Sup_finite_compact.{0} (semi_normed_comm_ring.{0} linarith.ineq) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (semi_normed_comm_ring.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_99666 (h0 : list (linear_ordered_field pos)) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_99667 (h0 : topological_space (semiring (has_norm (random_gen linarith.comp_source)))) : discrete_topology (semiring (has_norm (random_gen linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_99668 (h0 : topological_space (has_to_string (comm_group unsigned))) : locally_compact_space (has_to_string (comm_group unsigned)) := sorry --non-trivial
lemma new_lemma_99669 (h0 : semiring (ring (finset pos))) : is_noetherian_ring (ring (finset pos)) := sorry --non-trivial
lemma new_lemma_99670 (h0 : uniform_space (mul_zero_class (has_nndist Type))) : separated_space (mul_zero_class (has_nndist Type)) := sorry --non-trivial
lemma new_lemma_99671 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_principal_ideal_ring.{0} (normed_comm_ring.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (normed_comm_ring.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_99672 (h0 : functor.add_const (function.extfun Type topological_space) Type) : @topological_space.separable_space.{0} (has_nndist.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type topological_space.{0}) Type h0) (has_nndist.{0} pos))  := sorry --non-trivial
lemma new_lemma_99673 (h1 : not (ring (semi_normed_comm_ring string.iterator_imp) -> false)) : @rank_condition.{0} (semi_normed_comm_ring.{0} string.iterator_imp) (@classical.by_contradiction'.{1} (ring.{0} (semi_normed_comm_ring.{0} string.iterator_imp)) h1)  := sorry --non-trivial
lemma new_lemma_99674 (h0 : group (has_nndist (has_nndist (has_nndist pos)))) : normalizer_condition (has_nndist (has_nndist (has_nndist pos))) := sorry --non-trivial
lemma new_lemma_99675 (h0 : topological_space (with_one num)) : totally_disconnected_space (with_one num) := sorry --non-trivial
lemma new_lemma_99676 (h0 : group (linear_ordered_comm_ring linarith.comp_source)) : is_cyclic (linear_ordered_comm_ring linarith.comp_source) := sorry --non-trivial
lemma new_lemma_99677 (h0 : group (has_zero (option (option pos)))) : is_cyclic (has_zero (option (option pos))) := sorry --non-trivial
lemma new_lemma_99678 (h0 : ring (has_pos_part linarith.comp)) : is_principal_ideal_ring (has_pos_part linarith.comp) := sorry --non-trivial
lemma new_lemma_99679 (h0 : function.extfun Type complete_lattice) : @is_compactly_generated.{0} (measure_theory.measure_space.{0} num) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (measure_theory.measure_space.{0} num))  := sorry --non-trivial
lemma new_lemma_99680 (h0 : topological_space (boolean_algebra (has_add pos))) : sequential_space (boolean_algebra (has_add pos)) := sorry --non-trivial
lemma new_lemma_99681 (h0 : uniform_space (id (semiring (has_top empty)))) : separated_space (id (semiring (has_top empty))) := sorry --non-trivial
lemma new_lemma_99682 (h0 : functor.comp topological_space mul_zero_class (has_nndist environment.implicit_infer_kind)) : @discrete_topology.{0} (mul_zero_class.{0} (has_nndist.{0} environment.implicit_infer_kind)) (@functor.comp.run.{0 0 0} topological_space.{0} mul_zero_class.{0} (has_nndist.{0} environment.implicit_infer_kind) h0)  := sorry --non-trivial
lemma new_lemma_99683 (h0 : topological_space (add_cancel_comm_monoid linarith.ineq)) : t0_space (add_cancel_comm_monoid linarith.ineq) := sorry --non-trivial
lemma new_lemma_99684 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @discrete_topology.{0} (has_neg_part.{0} ennreal) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_neg_part.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_99685 (h0 : function.extfun Type finset) : finset.nonempty (function.extfun_app h0 (has_pos_part pos)) := sorry --non-trivial
lemma new_lemma_99686 (h0 : function.extfun (Type 1) ordered_add_comm_monoid) : @archimedean.{1} (ring.{1} Type) (@function.extfun_app.{3 2} (Type 1) ordered_add_comm_monoid.{1} h0 (ring.{1} Type))  := sorry --non-trivial
lemma new_lemma_99687 (h0 : functor.comp (functor.add_const (ring (has_to_string ennreal))) option unsigned) : @is_principal_ideal_ring.{0} (has_to_string.{0} ennreal) (@functor.add_const.run.{0 0} (ring.{0} (has_to_string.{0} ennreal)) (option.{0} unsigned) (@functor.comp.run.{0 0 0} (functor.add_const.{0 0} (ring.{0} (has_to_string.{0} ennreal))) option.{0} unsigned h0))  := sorry --non-trivial
lemma new_lemma_99688 (h0 : group (has_bot (semiring empty))) : normalizer_condition (has_bot (semiring empty)) := sorry --non-trivial
lemma new_lemma_99689 (h0 : topological_space (has_to_string (has_Inf linarith.comp))) : discrete_topology (has_to_string (has_Inf linarith.comp)) := sorry --non-trivial
lemma new_lemma_99690 (h0 : functor.add_const (ring (finset Type)) (has_add name)) : @is_principal_ideal_ring.{1} (finset.{1} Type) (@functor.add_const.run.{1 0} (ring.{1} (finset.{1} Type)) (has_add.{0} name) h0)  := sorry --non-trivial
lemma new_lemma_99691 (h0 : complete_lattice (plift (has_top empty))) : complete_lattice.is_Sup_finite_compact (plift (has_top empty)) := sorry --non-trivial
lemma new_lemma_99692 (h0 : not (topological_space (dlist fun_info) -> false)) : @t0_space.{0} (dlist.{0} fun_info) (@classical.by_contradiction'.{1} (topological_space.{0} (dlist.{0} fun_info)) h0)  := sorry --non-trivial
lemma new_lemma_99693 (h0 : ring (finset (finset name))) : is_domain (finset (finset name)) := sorry --non-trivial
lemma new_lemma_99694 (h0 : complete_lattice (finset (option (option (option unsigned))))) : is_compactly_generated (finset (option (option (option unsigned)))) := sorry --non-trivial
lemma new_lemma_99695 (h0 : uniform_space (has_Inf (has_add (has_add name)))) : complete_space (has_Inf (has_add (has_add name))) := sorry --non-trivial
lemma new_lemma_99696 (h0 : list (with_one (has_inv (has_inv fun_info)))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_99697 (h0 : filter (ring (normed_comm_ring (normed_comm_ring pos)))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_99698 (h0 : ring (has_emptyc congr_arg_kind)) : strong_rank_condition (has_emptyc congr_arg_kind) := sorry --non-trivial
lemma new_lemma_99699 (h0 : function.extfun Type list) : list.nodup (function.extfun_app h0 (has_inter empty)) := sorry --non-trivial
lemma new_lemma_99700 (h0 : topological_space (has_Inf (has_Inf Type))) : totally_separated_space (has_Inf (has_Inf Type)) := sorry --non-trivial
lemma new_lemma_99701 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @separated_space.{0} (simple_graph.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type uniform_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 uniform_space.{0}) (simple_graph.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_99702 (h0 : functor.add_const (function.extfun Type topological_space) environment.implicit_infer_kind) : @t0_space.{0} (has_add.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) environment.implicit_infer_kind h0) (has_add.{0} pos))  := sorry --non-trivial
lemma new_lemma_99703 (h0 : topological_space (sub_neg_monoid (has_add Type))) : t1_space (sub_neg_monoid (has_add Type)) := sorry --non-trivial
lemma new_lemma_99704 (h0 : functor.add_const (complete_lattice (has_neg_part environment.implicit_infer_kind)) pos) : @is_compactly_generated.{0} (has_neg_part.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (complete_lattice.{0} (has_neg_part.{0} environment.implicit_infer_kind)) pos h0)  := sorry --non-trivial
lemma new_lemma_99705 (h6 : not (uniform_space (topological_space string_imp) -> false)) : @complete_space.{0} (topological_space.{0} string_imp) (@classical.by_contradiction'.{1} (uniform_space.{0} (topological_space.{0} string_imp)) h6)  := sorry --non-trivial
lemma new_lemma_99706 (h0 : topological_space (rel congr_arg_kind to_additive.value_type)) : preirreducible_space (rel congr_arg_kind to_additive.value_type) := sorry --non-trivial
lemma new_lemma_99707 (h0 : add_monoid (free_add_monoid empty)) : add_monoid.fg (free_add_monoid empty) := sorry --non-trivial
lemma new_lemma_99708 (h0 : finset char -> finset char -> Prop) : is_total (finset char) h0 := sorry --non-trivial
lemma new_lemma_99709 (h0 : functor.add_const (complete_lattice (comm_group Type)) environment.implicit_infer_kind) : @is_compactly_generated.{1} (comm_group.{1} Type) (@functor.add_const.run.{1 0} (complete_lattice.{1} (comm_group.{1} Type)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_99710 (h0 : topological_space (ring (has_neg (has_neg Type)))) : totally_disconnected_space (ring (has_neg (has_neg Type))) := sorry --non-trivial
lemma new_lemma_99711 (h0 : functor.add_const (ring (has_to_string name)) name) : @is_principal_ideal_ring.{0} (has_to_string.{0} name) (@functor.add_const.run.{0 0} (ring.{0} (has_to_string.{0} name)) name h0)  := sorry --non-trivial
lemma new_lemma_99712 (h0 : topological_space (semigroup (has_neg_part environment.implicit_infer_kind))) : irreducible_space (semigroup (has_neg_part environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_99713 (h0 : topological_space (is_R_or_C (semiring num))) : preirreducible_space (is_R_or_C (semiring num)) := sorry --non-trivial
lemma new_lemma_99714 (h0 : function.extfun Type group) : @group.fg.{0} (has_to_string.{0} num) (@function.extfun_app.{2 1} Type group.{0} h0 (has_to_string.{0} num))  := sorry --non-trivial
lemma new_lemma_99715 (h0 : function.extfun Type group) : @group.fg.{0} (has_to_string.{0} pos) (@function.extfun_app.{2 1} Type group.{0} h0 (has_to_string.{0} pos))  := sorry --non-trivial
lemma new_lemma_99716 (h0 : function.extfun Type topological_space) : @totally_separated_space.{0} (canonically_ordered_comm_semiring.{0} ennreal) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (canonically_ordered_comm_semiring.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_99717 (h0 : function.extfun (nat -> Type) (function.extfun nat)) : @totally_disconnected_space.{0} (generalized_boolean_algebra.{0} real) (@matrix.vec_empty.{0} (topological_space.{0} (generalized_boolean_algebra.{0} real)) (@function.extfun_app.{1 1} nat fin (@function.extfun_app.{2 1} (nat → Type) (function.extfun.{1 1} nat) h0 fin) (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_99718 (h0 : complete_lattice (has_zero (option congr_arg_kind))) : complete_lattice.is_Sup_finite_compact (has_zero (option congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_99719 (h0 : function.extfun Type topological_space) : @topological_space.separable_space.{0} (linear_ordered_cancel_comm_monoid.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (linear_ordered_cancel_comm_monoid.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_99720 (h0 : functor.add_const (ordered_add_comm_monoid (finset name)) pos) : @archimedean.{0} (finset.{0} name) (@functor.add_const.run.{0 0} (ordered_add_comm_monoid.{0} (finset.{0} name)) pos h0)  := sorry --non-trivial
lemma new_lemma_99721 (h1 : list (uniform_space fun_info)) (h2 : nat) : @complete_space.{0} fun_info (@list.inth.{0} (uniform_space.{0} fun_info) (@inhabited_uniform_space.{0} fun_info) h1 h2)  := sorry --non-trivial
lemma new_lemma_99722 (h0 : functor.add_const (cancel_comm_monoid_with_zero (has_add name)) name) : @unique_factorization_monoid.{0} (has_add.{0} name) (@functor.add_const.run.{0 0} (cancel_comm_monoid_with_zero.{0} (has_add.{0} name)) name h0)  := sorry --non-trivial
lemma new_lemma_99723 (h0 : group (add_cancel_monoid (has_add (ring linarith.comp)))) : is_cyclic (add_cancel_monoid (has_add (ring linarith.comp))) := sorry --non-trivial
lemma new_lemma_99724 (h0 : ring (with_bot (has_inv linarith.comp_source))) : is_domain (with_bot (has_inv linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_99725 (h0 : ring (omega_complete_partial_order empty)) : is_principal_ideal_ring (omega_complete_partial_order empty) := sorry --non-trivial
lemma new_lemma_99726 (h0 : function.extfun Type ring) : @strong_rank_condition.{0} (boolean_algebra.core.{0} unsigned) (@function.extfun_app.{2 1} Type ring.{0} h0 (boolean_algebra.core.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_99727 (h0 : topological_space (generalized_boolean_algebra (has_Inf Type))) : irreducible_space (generalized_boolean_algebra (has_Inf Type)) := sorry --non-trivial
lemma new_lemma_99728 (h0 : topological_space unsigned) : topological_space.separable_space unsigned := sorry --non-trivial
lemma new_lemma_99729 (h0 : functor.add_const (group (normed_comm_ring pos)) linarith.comp) : @group.fg.{0} (normed_comm_ring.{0} pos) (@functor.add_const.run.{0 0} (group.{0} (normed_comm_ring.{0} pos)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_99730 (h0 : complete_lattice (has_top (has_norm unsigned))) : is_compactly_generated (has_top (has_norm unsigned)) := sorry --non-trivial
lemma new_lemma_99731 (h0 : ring (distrib_lattice (random_gen linarith.comp_source))) : rank_condition (distrib_lattice (random_gen linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_99732 (h0 : ulower Prop) (h1 : list Prop) : @list.ilast'.{0} Prop (@ulower.up.{0} Prop encodable.Prop h0) h1  := sorry --non-trivial
lemma new_lemma_99733 (h0 : functor.add_const (topological_space (complete_distrib_lattice name)) name) : @totally_disconnected_space.{0} (complete_distrib_lattice.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (complete_distrib_lattice.{0} name)) name h0)  := sorry --non-trivial
lemma new_lemma_99734 (h0 : topological_space (has_neg (has_add unsigned))) : t1_space (has_neg (has_add unsigned)) := sorry --non-trivial
lemma new_lemma_99735 (h0 : ring (has_neg (has_add name))) : is_domain (has_neg (has_add name)) := sorry --non-trivial
lemma new_lemma_99736 (h0 : fin has_zero.zero) : @is_compactly_generated.{0} (generalized_boolean_algebra.{0} (has_Inf.{0} pos)) (@matrix.vec_empty.{0} (complete_lattice.{0} (generalized_boolean_algebra.{0} (has_Inf.{0} pos))) h0)  := sorry --non-trivial
lemma new_lemma_99737 (h0 : has_mem.mem group has_emptyc.emptyc) : @is_cyclic.{0} (has_norm.{0} fun_info) (@function.extfun_app.{2 1} Type group.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) group.{0} h0) (has_norm.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_99738 (h0 : semiring (sub_neg_monoid (finset name))) : is_noetherian_ring (sub_neg_monoid (finset name)) := sorry --non-trivial
lemma new_lemma_99739 (h0 : functor.add_const (ring (semigroup linarith.comp)) (has_add Type)) : @is_principal_ideal_ring.{0} (semigroup.{0} linarith.comp) (@functor.add_const.run.{0 1} (ring.{0} (semigroup.{0} linarith.comp)) (has_add.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_99740 (h0 : filter (complete_distrib_lattice Type)) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_99741 (h1 : set (has_lt char)) : set.subsingleton h1 := sorry --non-trivial
lemma new_lemma_99742 (h0 : functor.add_const (topological_space (generalized_boolean_algebra linarith.comp)) (ring Type)) : @t0_space.{0} (generalized_boolean_algebra.{0} linarith.comp) (@functor.add_const.run.{0 1} (topological_space.{0} (generalized_boolean_algebra.{0} linarith.comp)) (ring.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_99743 (h0 : topological_space (ring environment.implicit_infer_kind)) : topological_space.separable_space (ring environment.implicit_infer_kind) := sorry --non-trivial
lemma new_lemma_99744 (h0 : ordered_comm_monoid (has_nndist (has_to_string pos))) : has_exists_mul_of_le (has_nndist (has_to_string pos)) := sorry --non-trivial
lemma new_lemma_99745 (h0 : not (complete_lattice (left_cancel_semigroup empty) -> false)) : @complete_lattice.is_Sup_finite_compact.{0} (left_cancel_semigroup.{0} empty) (@classical.by_contradiction'.{1} (complete_lattice.{0} (left_cancel_semigroup.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_99746 (h0 : functor.add_const (topological_space (canonically_ordered_comm_semiring empty)) empty) : @t0_space.{0} (canonically_ordered_comm_semiring.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (canonically_ordered_comm_semiring.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_99747 (h0 : functor.add_const (function.extfun (Type 1) filter) Type) : filter.ne_bot (function.extfun_app (functor.add_const.run h0) (has_add Type)) := sorry --non-trivial
lemma new_lemma_99748 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @t1_space.{0} (has_neg.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_neg.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_99749 (h0 : functor.add_const (topological_space (comm_group ennreal)) (option pos)) : @preconnected_space.{0} (comm_group.{0} ennreal) (@functor.add_const.run.{0 0} (topological_space.{0} (comm_group.{0} ennreal)) (option.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_99750 (h1 : topological_space (measurable_space (with_bot linarith.comp_source))) : totally_disconnected_space (measurable_space (with_bot linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_99751 (h0 : ring (free_add_monoid empty)) (h1 : semiring (subring (free_add_monoid empty))) : is_noetherian_ring (subring (free_add_monoid empty)) := sorry --non-trivial
lemma new_lemma_99752 (h0 : functor.add_const (function.extfun (Type 1) monoid) environment.implicit_infer_kind) : @monoid.fg.{1} (has_zero.{1} Type) (@function.extfun_app.{3 2} (Type 1) monoid.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) monoid.{1}) environment.implicit_infer_kind h0) (has_zero.{1} Type))  := sorry --non-trivial
lemma new_lemma_99753 (h0 : functor.comp topological_space complete_distrib_lattice name) : @preconnected_space.{0} (complete_distrib_lattice.{0} name) (@functor.comp.run.{0 0 0} topological_space.{0} complete_distrib_lattice.{0} name h0)  := sorry --non-trivial
lemma new_lemma_99754 (h0 : complete_lattice (normed_comm_ring linarith.comp)) : is_atomistic (normed_comm_ring linarith.comp) := sorry --non-trivial
lemma new_lemma_99755 (h0 : prod (has_inter (option (option (option unsigned)))) (has_inter (option (option (option unsigned))))) : id_rel h0 := sorry --non-trivial
lemma new_lemma_99756 (h0 : functor.add_const (topological_space (add_cancel_monoid Type)) linarith.comp) : @totally_disconnected_space.{1} (add_cancel_monoid.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (add_cancel_monoid.{1} Type)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_99757 (h0 : fin has_zero.zero) : @is_simple_group.{1} (ordered_comm_monoid.{1} Type) (@matrix.vec_empty.{1} (group.{1} (ordered_comm_monoid.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_99758 (h0 : functor.add_const (topological_space (boolean_algebra.core linarith.comp)) name) : @topological_space.separable_space.{0} (boolean_algebra.core.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (boolean_algebra.core.{0} linarith.comp)) name h0)  := sorry --non-trivial
lemma new_lemma_99759 (h0 : group (ring (has_add Type))) : normalizer_condition (ring (has_add Type)) := sorry --non-trivial
lemma new_lemma_99760 (h0 : functor.add_const (ring (has_to_string name)) unsigned) : @is_principal_ideal_ring.{0} (has_to_string.{0} name) (@functor.add_const.run.{0 0} (ring.{0} (has_to_string.{0} name)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_99761 (h0 : function.extfun (nat -> Type) (function.extfun nat)) : @normalizer_condition.{0} (complete_distrib_lattice.{0} name) (@matrix.vec_empty.{0} (group.{0} (complete_distrib_lattice.{0} name)) (@function.extfun_app.{1 1} nat fin (@function.extfun_app.{2 1} (nat → Type) (function.extfun.{1 1} nat) h0 fin) (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_99762 (h0 : functor.add_const (functor.add_const (topological_space Type) environment.implicit_infer_kind) Type) : @path_connected_space.{1} Type (@functor.add_const.run.{1 0} (topological_space.{1} Type) environment.implicit_infer_kind (@functor.add_const.run.{1 1} (functor.add_const.{1 0} (topological_space.{1} Type) environment.implicit_infer_kind) Type h0))  := sorry --non-trivial
lemma new_lemma_99763 (h0 : uniform_space (comm_group (add_cancel_monoid (add_cancel_monoid pos)))) : complete_space (comm_group (add_cancel_monoid (add_cancel_monoid pos))) := sorry --non-trivial
lemma new_lemma_99764 (h0 : function.extfun Type group) : @is_simple_group.{0} (generalized_boolean_algebra.{0} real) (@function.extfun_app.{2 1} Type group.{0} h0 (generalized_boolean_algebra.{0} real))  := sorry --non-trivial
lemma new_lemma_99765 (h0 : functor.add_const (topological_space (boolean_algebra linarith.comp)) (ring (has_zero (has_neg Type)))) : @totally_disconnected_space.{0} (boolean_algebra.{0} linarith.comp) (@functor.add_const.run.{0 1} (topological_space.{0} (boolean_algebra.{0} linarith.comp)) (ring.{1} (has_zero.{1} (has_neg.{1} Type))) h0)  := sorry --non-trivial
lemma new_lemma_99766 (h0 : topological_space (has_to_string (finset name))) : normal_space (has_to_string (finset name)) := sorry --non-trivial
lemma new_lemma_99767 (h0 : not (topological_space (random_gen unsigned) -> false)) : @normal_space.{0} (random_gen.{0} unsigned) (@classical.by_contradiction'.{1} (topological_space.{0} (random_gen.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_99768 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @is_principal_ideal_ring.{1} (normed_comm_ring.{1} Type) (@function.extfun_app.{3 2} (Type 1) ring.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 ring.{1}) (normed_comm_ring.{1} Type))  := sorry --non-trivial
lemma new_lemma_99769 (h0 : group (has_to_string (has_to_string linarith.comp))) : is_simple_group (has_to_string (has_to_string linarith.comp)) := sorry --non-trivial
lemma new_lemma_99770 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @t0_space.{0} (distrib_lattice.{0} fun_info) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (distrib_lattice.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_99771 (h0 : functor.add_const (function.extfun Type semiring) (finset name)) : @is_noetherian_ring.{0} (semigroup.{0} name) (@function.extfun_app.{2 1} Type semiring.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type semiring.{0}) (finset.{0} name) h0) (semigroup.{0} name))  := sorry --non-trivial
lemma new_lemma_99772 (h0 h1 : Prop) : @symm_diff.{0} Prop (@semilattice_sup.to_has_sup.{0} Prop (@lattice.to_semilattice_sup.{0} Prop (@conditionally_complete_lattice.to_lattice.{0} Prop (@complete_lattice.to_conditionally_complete_lattice.{0} Prop Prop.complete_lattice)))) (@generalized_boolean_algebra.to_has_sdiff.{0} Prop (@boolean_algebra.to_generalized_boolean_algebra.{0} Prop Prop.boolean_algebra)) h0 h1  := sorry --non-trivial
lemma new_lemma_99773 (h0 : Prop) (h3 : list Prop) : list.ilast' h0 h3 := sorry --non-trivial
lemma new_lemma_99774 (h0 : Prop -> has_top num) (h1 : coe_sort (set.range h0)) : set.range_splitting h0 h1 := sorry --non-trivial
lemma new_lemma_99775 (h0 : monoid (has_top (has_norm congr_arg_kind))) : monoid.fg (has_top (has_norm congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_99776 (h0 : not (list (comm_ring linarith.comp_source) -> false)) : list.nodup (classical.by_contradiction' h0) := sorry --non-trivial
lemma new_lemma_99777 (h0 : functor.add_const (group (add_comm_monoid environment.implicit_infer_kind)) pos) : @group.fg.{0} (add_comm_monoid.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (group.{0} (add_comm_monoid.{0} environment.implicit_infer_kind)) pos h0)  := sorry --non-trivial
lemma new_lemma_99778 (h0 : topological_space (left_cancel_monoid (semiring (semiring congr_arg_kind)))) : totally_separated_space (left_cancel_monoid (semiring (semiring congr_arg_kind))) := sorry --non-trivial
lemma new_lemma_99779 (h0 : topological_space (id (has_norm unsigned))) : t0_space (id (has_norm unsigned)) := sorry --non-trivial
lemma new_lemma_99780 (h0 : ring (has_append (has_ssubset fun_info))) : is_domain (has_append (has_ssubset fun_info)) := sorry --non-trivial
lemma new_lemma_99781 (h0 : complete_lattice (random_gen (semiring unsigned))) : is_atomistic (random_gen (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_99782 (h0 : functor.add_const (topological_space (complete_distrib_lattice linarith.comp)) Type) : @irreducible_space.{0} (complete_distrib_lattice.{0} linarith.comp) (@functor.add_const.run.{0 1} (topological_space.{0} (complete_distrib_lattice.{0} linarith.comp)) Type h0)  := sorry --non-trivial
lemma new_lemma_99783 (h0 : add_group (has_compl (uniform_space fun_info))) : is_add_cyclic (has_compl (uniform_space fun_info)) := sorry --non-trivial
lemma new_lemma_99784 (h0 : not (complete_lattice (simple_graph unsigned) -> false)) : @complete_lattice.is_Sup_finite_compact.{0} (simple_graph.{0} unsigned) (@classical.by_contradiction'.{1} (complete_lattice.{0} (simple_graph.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_99785 (h0 : topological_space (simple_graph (option unsigned))) : path_connected_space (simple_graph (option unsigned)) := sorry --non-trivial
lemma new_lemma_99786 (h0 : topological_space (has_add (finset (has_add Type)))) : loc_path_connected_space (has_add (finset (has_add Type))) := sorry --non-trivial
lemma new_lemma_99787 (h0 : topological_space (has_add (ordered_comm_ring (canonically_linear_ordered_monoid real)))) : path_connected_space (has_add (ordered_comm_ring (canonically_linear_ordered_monoid real))) := sorry --non-trivial
lemma new_lemma_99788 (h0 : uniform_space (canonically_linear_ordered_monoid (finset (finset pos)))) : separated_space (canonically_linear_ordered_monoid (finset (finset pos))) := sorry --non-trivial
lemma new_lemma_99789 (h0 : uniform_space (with_one (semiring congr_arg_kind))) : complete_space (with_one (semiring congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_99790 (h0 : finset (boolean_algebra.core num)) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_99791 (h0 : fin has_zero.zero) : @path_connected_space.{0} (finset.{0} name) (@matrix.vec_empty.{0} (topological_space.{0} (finset.{0} name)) h0)  := sorry --non-trivial
lemma new_lemma_99792 (h1 : uniform_space (id congr_arg_kind)) : complete_space (id congr_arg_kind) := sorry --non-trivial
lemma new_lemma_99793 (h0 : has_mem.mem (has_top fun_info) has_emptyc.emptyc) : list.nodup (finset.pi.empty list (has_top fun_info) h0) := sorry --non-trivial
lemma new_lemma_99794 (h1 : complete_lattice (has_ssubset string_imp)) : is_compactly_generated (has_ssubset string_imp) := sorry --non-trivial
lemma new_lemma_99795 (h0 : topological_space (pseudo_metric_space (has_to_string (has_add unsigned)))) : sequential_space (pseudo_metric_space (has_to_string (has_add unsigned))) := sorry --non-trivial
lemma new_lemma_99796 (h0 : fin has_zero.zero) : @Lim.{0} Prop sierpinski_space (@nonempty_of_inhabited.{1} Prop sort.inhabited.{0}) (@list.head.{0} (filter.{0} Prop) (@filter.inhabited.{0} Prop) (@id.{1} (list.{0} (filter.{0} Prop)) (@matrix.vec_empty.{0} (list.{0} (filter.{0} Prop)) (@id.{1} (fin (@has_zero.zero.{0} nat nat.has_zero)) h0))))  := sorry --non-trivial
lemma new_lemma_99797 (h1 : not (function.extfun Type topological_space -> false)) : @discrete_topology.{0} (has_emptyc.{0} fun_info) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h1) (has_emptyc.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_99798 (h0 : semiring (left_cancel_semigroup num)) : is_noetherian_ring (left_cancel_semigroup num) := sorry --non-trivial
lemma new_lemma_99799 (h0 : uniform_space (with_one to_additive.value_type)) : complete_space (with_one to_additive.value_type) := sorry --non-trivial
lemma new_lemma_99800 (h0 : not (group (semi_normed_comm_ring linarith.ineq) -> false)) : @is_cyclic.{0} (semi_normed_comm_ring.{0} linarith.ineq) (@classical.by_contradiction'.{1} (group.{0} (semi_normed_comm_ring.{0} linarith.ineq)) h0)  := sorry --non-trivial
lemma new_lemma_99801 (h0 : complete_lattice (distrib (mul_one_class string.iterator_imp))) : complete_lattice.is_Sup_finite_compact (distrib (mul_one_class string.iterator_imp)) := sorry --non-trivial
lemma new_lemma_99802 (h0 : topological_space (has_nndist (normed_comm_ring environment.implicit_infer_kind))) : discrete_topology (has_nndist (normed_comm_ring environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_99803 (h0 : topological_space (add_right_cancel_monoid (semiring num))) : t0_space (add_right_cancel_monoid (semiring num)) := sorry --non-trivial
lemma new_lemma_99804 (h1 : topological_space (has_top string_imp)) : path_connected_space (has_top string_imp) := sorry --non-trivial
lemma new_lemma_99805 (h0 : cancel_comm_monoid_with_zero (boolean_algebra (comm_group (has_neg_part Type)))) : unique_factorization_monoid (boolean_algebra (comm_group (has_neg_part Type))) := sorry --non-trivial
lemma new_lemma_99806 (h0 : function.extfun Type topological_space) : @totally_separated_space.{0} (normed_comm_ring.{0} ennreal) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (normed_comm_ring.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_99807 (h0 : functor.add_const (topological_space (add_cancel_monoid linarith.comp)) name) : @discrete_topology.{0} (add_cancel_monoid.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (add_cancel_monoid.{0} linarith.comp)) name h0)  := sorry --non-trivial
lemma new_lemma_99808 (h0 : add_monoid (canonically_linear_ordered_monoid (has_Inf pos))) : add_monoid.fg (canonically_linear_ordered_monoid (has_Inf pos)) := sorry --non-trivial
lemma new_lemma_99809 (h0 : not (topological_space (has_compl to_additive.value_type) -> false)) : @path_connected_space.{0} (has_compl.{0} to_additive.value_type) (@classical.by_contradiction'.{1} (topological_space.{0} (has_compl.{0} to_additive.value_type)) h0)  := sorry --non-trivial
lemma new_lemma_99810 (h0 : complete_lattice (has_neg (has_pos_part Type))) : is_compactly_generated (has_neg (has_pos_part Type)) := sorry --non-trivial
lemma new_lemma_99811 (h1 : set (mul_one_class char -> std_gen)) : set.separates_points h1 := sorry --non-trivial
lemma new_lemma_99812 (h0 : prod (ordered_cancel_add_comm_monoid congr_arg_kind) (ordered_cancel_add_comm_monoid congr_arg_kind)) : id_rel h0 := sorry --non-trivial
lemma new_lemma_99813 (h0 : group (finset ennreal)) : group.fg (finset ennreal) := sorry --non-trivial
lemma new_lemma_99814 (h0 : filter (pseudo_metric_space (finset (finset name)))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_99815 (h0 : add_group (dlist (linear_ordered_add_comm_group linarith.ineq))) : is_add_cyclic (dlist (linear_ordered_add_comm_group linarith.ineq)) := sorry --non-trivial
lemma new_lemma_99816 (h0 : ring linarith.comp_source) (h1 : ring (subring linarith.comp_source)) : strong_rank_condition (subring linarith.comp_source) := sorry --non-trivial
lemma new_lemma_99817 (h0 : function.extfun Type topological_space) : @normal_space.{0} (boolean_algebra.core.{0} ennreal) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (boolean_algebra.core.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_99818 (h0 : uniform_space linarith.ineq) : complete_space linarith.ineq := sorry --non-trivial
lemma new_lemma_99819 (h1 : ring (normed_field environment.projection_info)) : is_domain (normed_field environment.projection_info) := sorry --non-trivial
lemma new_lemma_99820 (h0 : topological_space (has_Inf (ring (has_add (has_add (has_add pos)))))) : totally_disconnected_space (has_Inf (ring (has_add (has_add (has_add pos))))) := sorry --non-trivial
lemma new_lemma_99821 (h1 : complete_lattice (complete_semilattice_Sup to_additive.value_type)) : is_compactly_generated (complete_semilattice_Sup to_additive.value_type) := sorry --non-trivial
lemma new_lemma_99822 (h0 : group (comm_group (option name))) : is_simple_group (comm_group (option name)) := sorry --non-trivial
lemma new_lemma_99823 (h0 : topological_space (has_one (semiring num))) : preirreducible_space (has_one (semiring num)) := sorry --non-trivial
lemma new_lemma_99824 (h0 : ring (has_mul enat)) : strong_rank_condition (has_mul enat) := sorry --non-trivial
lemma new_lemma_99825 (h0 : functor.add_const (topological_space (complete_distrib_lattice Type)) pos) : @totally_separated_space.{1} (complete_distrib_lattice.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (complete_distrib_lattice.{1} Type)) pos h0)  := sorry --non-trivial
lemma new_lemma_99826 (h0 : functor.add_const (add_group (simple_graph pos)) name) : @is_add_cyclic.{0} (simple_graph.{0} pos) (@functor.add_const.run.{0 0} (add_group.{0} (simple_graph.{0} pos)) name h0)  := sorry --non-trivial
lemma new_lemma_99827 (h0 : topological_space (with_one (has_nnnorm linarith.ineq))) : path_connected_space (with_one (has_nnnorm linarith.ineq)) := sorry --non-trivial
lemma new_lemma_99828 (h0 : topological_space (semigroup (comm_group Type))) : t0_space (semigroup (comm_group Type)) := sorry --non-trivial
lemma new_lemma_99829 (h0 : topological_space (has_bot (has_add pos))) : preirreducible_space (has_bot (has_add pos)) := sorry --non-trivial
lemma new_lemma_99830 (h0 : topological_space (has_neg (ring pos))) : topological_space.separable_space (has_neg (ring pos)) := sorry --non-trivial
lemma new_lemma_99831 (h0 : functor.add_const (topological_space (has_Inf linarith.comp)) (has_Inf pos)) : @totally_separated_space.{0} (has_Inf.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (has_Inf.{0} linarith.comp)) (has_Inf.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_99832 (h0 : functor.add_const (ring (has_edist unsigned)) empty) : @is_domain.{0} (has_edist.{0} unsigned) (@functor.add_const.run.{0 0} (ring.{0} (has_edist.{0} unsigned)) empty h0)  := sorry --non-trivial
lemma new_lemma_99833 (h0 : topological_space (has_norm (has_top (random_gen (has_top linarith.comp_source))))) : path_connected_space (has_norm (has_top (random_gen (has_top linarith.comp_source)))) := sorry --non-trivial
lemma new_lemma_99834 (h0 : not (finset (mul_zero_class unsigned) -> false)) : finset.nonempty (classical.by_contradiction' h0) := sorry --non-trivial
lemma new_lemma_99835 (h0 : topological_space (finset pos)) : loc_path_connected_space (finset pos) := sorry --non-trivial
lemma new_lemma_99836 (h0 : complete_lattice (measure_theory.measure_space (option empty))) : complete_lattice.is_Sup_finite_compact (measure_theory.measure_space (option empty)) := sorry --non-trivial
lemma new_lemma_99837 (h1 : monoid (measurable_space (semiring (semiring (semiring (semiring congr_arg_kind)))))) : monoid.fg (measurable_space (semiring (semiring (semiring (semiring congr_arg_kind))))) := sorry --non-trivial
lemma new_lemma_99838 (h0 : topological_space (normed_comm_ring (has_to_string (has_to_string congr_arg_kind)))) : loc_path_connected_space (normed_comm_ring (has_to_string (has_to_string congr_arg_kind))) := sorry --non-trivial
lemma new_lemma_99839 (h0 : complete_lattice (group_with_zero ennreal)) : is_atomistic (group_with_zero ennreal) := sorry --non-trivial
lemma new_lemma_99840 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @archimedean.{0} (has_pos_part.{0} real) (@function.extfun_app.{2 1} Type ordered_add_comm_monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ordered_add_comm_monoid.{0}) (has_pos_part.{0} real))  := sorry --non-trivial
lemma new_lemma_99841 (h0 : function.extfun Type ring) : @is_domain.{0} (bin_tree.{0} num) (@function.extfun_app.{2 1} Type ring.{0} h0 (bin_tree.{0} num))  := sorry --non-trivial
lemma new_lemma_99842 (h0 : topological_space (canonically_ordered_monoid real)) : totally_separated_space (canonically_ordered_monoid real) := sorry --non-trivial
lemma new_lemma_99843 (h0 : functor.add_const (topological_space (linear_ordered_comm_monoid_with_zero unsigned)) (option unsigned)) : @t0_space.{0} (linear_ordered_comm_monoid_with_zero.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (linear_ordered_comm_monoid_with_zero.{0} unsigned)) (option.{0} unsigned) h0)  := sorry --non-trivial
lemma new_lemma_99844 (h1 : set (mul_one_class (add_comm_semigroup ereal) -> mul_one_class std_gen)) : set.separates_points h1 := sorry --non-trivial
lemma new_lemma_99845 (h1 : group (measurable_space empty)) : is_cyclic (measurable_space empty) := sorry --non-trivial
lemma new_lemma_99846 (h1 : topological_space (has_top num)) : totally_separated_space (has_top num) := sorry --non-trivial
lemma new_lemma_99847 (h0 : topological_space (generalized_boolean_algebra num)) : preconnected_space (generalized_boolean_algebra num) := sorry --non-trivial
lemma new_lemma_99848 (h0 : filter (add_comm_monoid (comm_group (comm_group (comm_group unsigned))))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_99849 (h0 : ordered_comm_monoid (canonically_ordered_monoid real)) : has_exists_mul_of_le (canonically_ordered_monoid real) := sorry --non-trivial
lemma new_lemma_99850 (h0 : group (has_emptyc (has_inv linarith.ineq))) : normalizer_condition (has_emptyc (has_inv linarith.ineq)) := sorry --non-trivial
lemma new_lemma_99851 (h0 : cancel_comm_monoid_with_zero (ordered_ring empty)) : unique_factorization_monoid (ordered_ring empty) := sorry --non-trivial
lemma new_lemma_99852 (h0 : group (has_zero (has_to_string Type))) : group.fg (has_zero (has_to_string Type)) := sorry --non-trivial
lemma new_lemma_99853 (h0 : topological_space (semiring (has_top to_additive.value_type))) : irreducible_space (semiring (has_top to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_99854 (h0 : topological_space (linear_ordered_add_comm_group (has_ssubset to_additive.value_type))) : irreducible_space (linear_ordered_add_comm_group (has_ssubset to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_99855 (h0 : functor.add_const (topological_space (semigroup linarith.comp)) (finset pos)) : @path_connected_space.{0} (semigroup.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (semigroup.{0} linarith.comp)) (finset.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_99856 (h0 : monoid (add_cancel_monoid (finset linarith.comp))) : monoid.fg (add_cancel_monoid (finset linarith.comp)) := sorry --non-trivial
lemma new_lemma_99857 (h0 : functor.add_const (cancel_comm_monoid_with_zero (has_star congr_arg_kind)) (semiring (semiring empty))) : @unique_factorization_monoid.{0} (has_star.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (cancel_comm_monoid_with_zero.{0} (has_star.{0} congr_arg_kind)) (semiring.{0} (semiring.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_99858 (h0 : functor.add_const (complete_lattice (has_zero name)) (comm_group (comm_group Type))) : @is_atomistic.{0} (has_zero.{0} name) (@functor.add_const.run.{0 1} (complete_lattice.{0} (has_zero.{0} name)) (comm_group.{1} (comm_group.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_99859 (h1 : ring (has_ssubset (normed_field (add_comm_semigroup reducibility_hints)))) : strong_rank_condition (has_ssubset (normed_field (add_comm_semigroup reducibility_hints))) := sorry --non-trivial
lemma new_lemma_99860 (h0 : functor.add_const (function.extfun (Type 1) group) Type) : @normalizer_condition.{1} (has_add.{1} Type) (@function.extfun_app.{3 2} (Type 1) group.{1} (@functor.add_const.run.{2 1} (function.extfun.{3 2} (Type 1) group.{1}) Type h0) (has_add.{1} Type))  := sorry --non-trivial
lemma new_lemma_99861 (h0 : functor.add_const (ring (ordered_ring unsigned)) unsigned) : @is_principal_ideal_ring.{0} (ordered_ring.{0} unsigned) (@functor.add_const.run.{0 0} (ring.{0} (ordered_ring.{0} unsigned)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_99862 (h0 : topological_space (has_zero (has_add (finset pos)))) : normal_space (has_zero (has_add (finset pos))) := sorry --non-trivial
lemma new_lemma_99863 (h0 : function.extfun Type topological_space) : @sequential_space.{0} (boolean_algebra.core.{0} (has_neg.{0} ennreal)) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (boolean_algebra.core.{0} (has_neg.{0} ennreal)))  := sorry --non-trivial
lemma new_lemma_99864 (h0 : functor.add_const (group (normed_comm_ring pos)) pos) : @is_simple_group.{0} (normed_comm_ring.{0} pos) (@functor.add_const.run.{0 0} (group.{0} (normed_comm_ring.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_99865 (h0 : add_group (has_star (ordered_cancel_comm_monoid num))) : is_add_cyclic (has_star (ordered_cancel_comm_monoid num)) := sorry --non-trivial
lemma new_lemma_99866 (h0 : topological_space (has_add (ring pos))) : discrete_topology (has_add (ring pos)) := sorry --non-trivial
lemma new_lemma_99867 (h0 : add_monoid (partial_order (semiring (semiring (semiring empty))))) : add_monoid.fg (partial_order (semiring (semiring (semiring empty)))) := sorry --non-trivial
lemma new_lemma_99868 (h0 : function.extfun Type topological_space) : @loc_path_connected_space.{0} (ordered_comm_ring.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (ordered_comm_ring.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_99869 (h0 : group (with_bot (has_norm (has_top fun_info)))) : is_cyclic (with_bot (has_norm (has_top fun_info))) := sorry --non-trivial
lemma new_lemma_99870 (h0 : functor.add_const (topological_space (ordered_comm_monoid Type)) Type) : @t1_space.{1} (ordered_comm_monoid.{1} Type) (@functor.add_const.run.{1 1} (topological_space.{1} (ordered_comm_monoid.{1} Type)) Type h0)  := sorry --non-trivial
lemma new_lemma_99871 (h0 : group (boolean_algebra (normed_comm_ring (has_pos_part (has_Inf Type))))) : is_simple_group (boolean_algebra (normed_comm_ring (has_pos_part (has_Inf Type)))) := sorry --non-trivial
lemma new_lemma_99872 (h0 : ring (with_bot (has_norm linarith.comp))) : is_domain (with_bot (has_norm linarith.comp)) := sorry --non-trivial
lemma new_lemma_99873 (h0 : topological_space (add_right_cancel_monoid (semiring congr_arg_kind))) : discrete_topology (add_right_cancel_monoid (semiring congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_99874 (h0 : topological_space (has_edist empty)) : totally_separated_space (has_edist empty) := sorry --non-trivial
lemma new_lemma_99875 (h0 : function.extfun Type topological_space) : @path_connected_space.{0} (has_neg.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_neg.{0} name))  := sorry --non-trivial
lemma new_lemma_99876 (h0 : group (complete_semilattice_Sup linarith.ineq)) : is_cyclic (complete_semilattice_Sup linarith.ineq) := sorry --non-trivial
lemma new_lemma_99877 (h0 : group (has_union congr_arg_kind)) : group.fg (has_union congr_arg_kind) := sorry --non-trivial
lemma new_lemma_99878 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @separated_space.{0} (complete_linear_order.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type uniform_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 uniform_space.{0}) (complete_linear_order.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_99879 (h0 : not (ring (linear_ordered_comm_group_with_zero linarith.ineq) -> false)) : @rank_condition.{0} (linear_ordered_comm_group_with_zero.{0} linarith.ineq) (@classical.by_contradiction'.{1} (ring.{0} (linear_ordered_comm_group_with_zero.{0} linarith.ineq)) h0)  := sorry --non-trivial
lemma new_lemma_99880 (h0 : topological_space (topological_space (has_nnnorm (has_nnnorm linarith.ineq)))) : path_connected_space (topological_space (has_nnnorm (has_nnnorm linarith.ineq))) := sorry --non-trivial
lemma new_lemma_99881 (h0 : functor.add_const (topological_space (has_to_string pos)) Type) : @preirreducible_space.{0} (has_to_string.{0} pos) (@functor.add_const.run.{0 1} (topological_space.{0} (has_to_string.{0} pos)) Type h0)  := sorry --non-trivial
lemma new_lemma_99882 (h0 : function.extfun Type ring) : @strong_rank_condition.{0} (semigroup.{0} pos) (@function.extfun_app.{2 1} Type ring.{0} h0 (semigroup.{0} pos))  := sorry --non-trivial
lemma new_lemma_99883 (h0 : not (ring (has_append reducibility_hints) -> false)) : @rank_condition.{0} (has_append.{0} reducibility_hints) (@classical.by_contradiction'.{1} (ring.{0} (has_append.{0} reducibility_hints)) h0)  := sorry --non-trivial
lemma new_lemma_99884 (h1 : complete_lattice (has_add (comm_ring to_additive.value_type))) : complete_lattice.is_Sup_finite_compact (has_add (comm_ring to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_99885 (h0 h1 : multiset (non_unital_non_assoc_semiring (semi_normed_comm_ring string.iterator_imp))) : multiset.disjoint h0 h1 := sorry --non-trivial
lemma new_lemma_99886 (h0 : function.extfun Type list) : list.nodup (function.extfun_app h0 (monoid_with_zero ennreal)) := sorry --non-trivial
lemma new_lemma_99887 (h0 : functor.add_const (topological_space (has_nndist pos)) (has_neg name)) : @t0_space.{0} (has_nndist.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (has_nndist.{0} pos)) (has_neg.{0} name) h0)  := sorry --non-trivial
lemma new_lemma_99888 (h0 : topological_space (has_bot (ordered_comm_monoid (has_bot (has_Inf (has_Inf Type)))))) : totally_disconnected_space (has_bot (ordered_comm_monoid (has_bot (has_Inf (has_Inf Type))))) := sorry --non-trivial
lemma new_lemma_99889 (h0 : ring (has_inv (random_gen (random_gen string_imp)))) : is_domain (has_inv (random_gen (random_gen string_imp))) := sorry --non-trivial
lemma new_lemma_99890 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @normal_space.{0} (measurable_space.{0} (metric_space.{0} unsigned)) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (measurable_space.{0} (metric_space.{0} unsigned)))  := sorry --non-trivial
lemma new_lemma_99891 (h0 : topological_space (ordered_comm_group empty)) : totally_separated_space (ordered_comm_group empty) := sorry --non-trivial
lemma new_lemma_99892 (h0 : prod (finset num) (finset num)) : id_rel h0 := sorry --non-trivial
lemma new_lemma_99893 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : list.nodup (function.extfun_app (function.extfun_app h0 list) (has_pos_part name)) := sorry --non-trivial
lemma new_lemma_99894 (h0 : functor.add_const (topological_space (complete_distrib_lattice pos)) real) : @preirreducible_space.{0} (complete_distrib_lattice.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (complete_distrib_lattice.{0} pos)) real h0)  := sorry --non-trivial
lemma new_lemma_99895 (h1 : add_group (semi_normed_comm_ring (has_nnnorm reducibility_hints))) : is_add_cyclic (semi_normed_comm_ring (has_nnnorm reducibility_hints)) := sorry --non-trivial
lemma new_lemma_99896 (h0 : topological_space (ordered_comm_monoid (has_add linarith.comp))) : loc_path_connected_space (ordered_comm_monoid (has_add linarith.comp)) := sorry --non-trivial
lemma new_lemma_99897 (h0 : function.extfun (finset (Type -> Type)) (has_mem.mem add_group)) : @is_add_cyclic.{0} (semiring.{0} empty) (@function.extfun_app.{2 1} Type add_group.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) add_group.{0} (@function.extfun_app.{2 0} (finset.{1} (Type → Type)) (@has_mem.mem.{1 1} (Type → Type) (finset.{1} (Type → Type)) (@finset.has_mem.{1} (Type → Type)) add_group.{0}) h0 (@has_emptyc.emptyc.{1} (finset.{1} (Type → Type)) (@finset.has_emptyc.{1} (Type → Type))))) (semiring.{0} empty))  := sorry --non-trivial
lemma new_lemma_99898 (h0 : topological_space (has_bot (sub_neg_monoid name))) : regular_space (has_bot (sub_neg_monoid name)) := sorry --non-trivial
lemma new_lemma_99899 (h0 : functor.add_const (topological_space (has_to_string pos)) linarith.comp) : @preirreducible_space.{0} (has_to_string.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (has_to_string.{0} pos)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_99900 (h0 : ring (option (ordered_cancel_comm_monoid pos))) : strong_rank_condition (option (ordered_cancel_comm_monoid pos)) := sorry --non-trivial
lemma new_lemma_99901 (h0 : functor.comp uniform_space has_to_string Type) : @separated_space.{1} (has_to_string.{1} Type) (@functor.comp.run.{1 1 1} uniform_space.{1} has_to_string.{1} Type h0)  := sorry --non-trivial
lemma new_lemma_99902 (h0 : functor.add_const (topological_space (add_cancel_monoid Type)) (comm_group name)) : @path_connected_space.{1} (add_cancel_monoid.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (add_cancel_monoid.{1} Type)) (comm_group.{0} name) h0)  := sorry --non-trivial
lemma new_lemma_99903 (h0 : topological_space (boolean_algebra.core (has_neg linarith.comp))) : t1_space (boolean_algebra.core (has_neg linarith.comp)) := sorry --non-trivial
lemma new_lemma_99904 (h0 : topological_space (canonically_ordered_comm_semiring ennreal)) : loc_path_connected_space (canonically_ordered_comm_semiring ennreal) := sorry --non-trivial
lemma new_lemma_99905 (h0 : function.extfun Type topological_space) : @loc_path_connected_space.{0} (has_inter.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_inter.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_99906 (h0 : topological_space empty) : totally_disconnected_space empty := sorry --non-trivial
lemma new_lemma_99907 (h0 : topological_space (complete_distrib_lattice (ring (has_add pos)))) : irreducible_space (complete_distrib_lattice (ring (has_add pos))) := sorry --non-trivial
lemma new_lemma_99908 (h0 : topological_space (has_nndist (comm_group pos))) : totally_separated_space (has_nndist (comm_group pos)) := sorry --non-trivial
lemma new_lemma_99909 (h0 : ring (metric_space linarith.ineq)) : is_domain (metric_space linarith.ineq) := sorry --non-trivial
lemma new_lemma_99910 (h1 : ring (dlist (random_gen (random_gen string_imp)))) : strong_rank_condition (dlist (random_gen (random_gen string_imp))) := sorry --non-trivial
lemma new_lemma_99911 (h0 : functor.add_const (complete_lattice (cancel_monoid ennreal)) (has_add pos)) : @is_compactly_generated.{0} (cancel_monoid.{0} ennreal) (@functor.add_const.run.{0 0} (complete_lattice.{0} (cancel_monoid.{0} ennreal)) (has_add.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_99912 (h0 : functor.add_const (topological_space (boolean_algebra.core name)) (option pos)) : @t0_space.{0} (boolean_algebra.core.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (boolean_algebra.core.{0} name)) (option.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_99913 (h0 : not (function.extfun Type complete_lattice -> false)) : @is_atomistic.{0} (normed_group.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type complete_lattice.{0}) h0) (normed_group.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_99914 (h0 : not (topological_space (linear_ordered_semiring linarith.comp_source) -> false)) : @totally_separated_space.{0} (linear_ordered_semiring.{0} linarith.comp_source) (@classical.by_contradiction'.{1} (topological_space.{0} (linear_ordered_semiring.{0} linarith.comp_source)) h0)  := sorry --non-trivial
lemma new_lemma_99915 (h0 : topological_space (add_cancel_comm_monoid empty)) : topological_space.separable_space (add_cancel_comm_monoid empty) := sorry --non-trivial
lemma new_lemma_99916 (h0 : topological_space (topological_space (random_gen char))) : locally_compact_space (topological_space (random_gen char)) := sorry --non-trivial
lemma new_lemma_99917 (h0 : complete_lattice (linear_ordered_cancel_comm_monoid congr_arg_kind)) : is_atomistic (linear_ordered_cancel_comm_monoid congr_arg_kind) := sorry --non-trivial
lemma new_lemma_99918 (h0 : ring (semiring (semiring (semiring (semiring unsigned))))) : is_domain (semiring (semiring (semiring (semiring unsigned)))) := sorry --non-trivial
lemma new_lemma_99919 (h0 : functor.add_const (topological_space (comm_group pos)) name) : @discrete_topology.{0} (comm_group.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (comm_group.{0} pos)) name h0)  := sorry --non-trivial
lemma new_lemma_99920 (h0 : functor.add_const (topological_space (generalized_boolean_algebra name)) pos) : @t0_space.{0} (generalized_boolean_algebra.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (generalized_boolean_algebra.{0} name)) pos h0)  := sorry --non-trivial
lemma new_lemma_99921 (h0 : function.extfun nat fin) : @is_cyclic.{0} (complete_distrib_lattice.{0} real) (@matrix.vec_empty.{0} (group.{0} (complete_distrib_lattice.{0} real)) (@matrix.vec_empty.{0} (fin (@has_zero.zero.{0} nat nat.has_zero)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero))))  := sorry --non-trivial
lemma new_lemma_99922 (h0 : functor.add_const (list auto.case_option) (option (option unsigned))) : list.nodup (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_99923 (h0 : not (add_group (with_one (has_nnnorm linarith.ineq)) -> false)) : @is_add_cyclic.{0} (with_one.{0} (has_nnnorm.{0} linarith.ineq)) (@classical.by_contradiction'.{1} (add_group.{0} (with_one.{0} (has_nnnorm.{0} linarith.ineq))) h0)  := sorry --non-trivial
lemma new_lemma_99924 (h0 : topological_space (with_one linarith.ineq)) : totally_separated_space (with_one linarith.ineq) := sorry --non-trivial
lemma new_lemma_99925 (h0 : functor.add_const (functor.add_const (uniform_space (has_zero linarith.comp)) name) pos) : @complete_space.{0} (has_zero.{0} linarith.comp) (@functor.add_const.run.{0 0} (uniform_space.{0} (has_zero.{0} linarith.comp)) name (@functor.add_const.run.{0 0} (functor.add_const.{0 0} (uniform_space.{0} (has_zero.{0} linarith.comp)) name) pos h0))  := sorry --non-trivial
lemma new_lemma_99926 (h0 : topological_space (comm_group (option pos))) : t1_space (comm_group (option pos)) := sorry --non-trivial
lemma new_lemma_99927 (h0 : functor.add_const Prop (has_zero name)) : functor.add_const.run h0 := sorry --non-trivial
lemma new_lemma_99928 (h0 : functor.add_const (add_group (has_to_string pos)) num) : @is_add_cyclic.{0} (has_to_string.{0} pos) (@functor.add_const.run.{0 0} (add_group.{0} (has_to_string.{0} pos)) num h0)  := sorry --non-trivial
lemma new_lemma_99929 (h0 : ring (has_add (has_ssubset linarith.comp_source))) : is_domain (has_add (has_ssubset linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_99930 (h0 : functor.add_const (topological_space (boolean_algebra real)) pos) : @discrete_topology.{0} (boolean_algebra.{0} real) (@functor.add_const.run.{0 0} (topological_space.{0} (boolean_algebra.{0} real)) pos h0)  := sorry --non-trivial
lemma new_lemma_99931 (h0 : functor.add_const (function.extfun (Type 1) add_group) pos) : @is_add_cyclic.{1} (add_cancel_monoid.{1} Type) (@function.extfun_app.{3 2} (Type 1) add_group.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) add_group.{1}) pos h0) (add_cancel_monoid.{1} Type))  := sorry --non-trivial
lemma new_lemma_99932 (h1 : group (with_one (random_gen string_imp))) : is_simple_group (with_one (random_gen string_imp)) := sorry --non-trivial
lemma new_lemma_99933 (h0 : topological_space (simple_graph unsigned)) : normal_space (simple_graph unsigned) := sorry --non-trivial
lemma new_lemma_99934 (h0 : uniform_space (canonically_linear_ordered_monoid (has_add linarith.comp))) : complete_space (canonically_linear_ordered_monoid (has_add linarith.comp)) := sorry --non-trivial
lemma new_lemma_99935 (h0 : topological_space (mul_zero_class (semiring empty))) : t0_space (mul_zero_class (semiring empty)) := sorry --non-trivial
lemma new_lemma_99936 (h0 : topological_space (generalized_boolean_algebra (has_bot pos))) : preirreducible_space (generalized_boolean_algebra (has_bot pos)) := sorry --non-trivial
lemma new_lemma_99937 (h0 : topological_space (has_neg_part (ring ennreal))) : regular_space (has_neg_part (ring ennreal)) := sorry --non-trivial
lemma new_lemma_99938 (h0 : ring (has_inv (has_nnnorm (random_gen (random_gen char))))) : rank_condition (has_inv (has_nnnorm (random_gen (random_gen char)))) := sorry --non-trivial
lemma new_lemma_99939 (h0 : group pos) : normalizer_condition pos := sorry --non-trivial
lemma new_lemma_99940 (h0 : not (function.extfun Type filter -> false)) : filter.ne_bot (function.extfun_app (classical.by_contradiction' h0) (measurable_space empty)) := sorry --non-trivial
lemma new_lemma_99941 (h0 : fin has_zero.zero) : @rank_condition.{0} (ordered_comm_ring.{0} name) (@function.extfun_app.{2 1} Type ring.{0} (@matrix.vec_empty.{1} (function.extfun.{2 1} Type ring.{0}) h0) (ordered_comm_ring.{0} name))  := sorry --non-trivial
lemma new_lemma_99942 (h0 : topological_space (has_neg (has_neg_part (has_neg_part (has_neg_part pos))))) : totally_separated_space (has_neg (has_neg_part (has_neg_part (has_neg_part pos)))) := sorry --non-trivial
lemma new_lemma_99943 (h0 : has_mem.mem (metric_space linarith.comp) has_emptyc.emptyc) : @irreducible_space.{0} (metric_space.{0} linarith.comp) (@finset.pi.empty.{1 0} Type topological_space.{0} (metric_space.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_99944 (h0 : filter (linear_order (option (option (option empty))))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_99945 (h0 : topological_space (has_neg (has_neg_part Type))) : preconnected_space (has_neg (has_neg_part Type)) := sorry --non-trivial
lemma new_lemma_99946 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @normalizer_condition.{0} (has_add.{0} unsigned) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (has_add.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_99947 (h0 : measurable_space enat) (h1 : measure_theory.measure enat) : measure_theory.has_no_atoms h1 := sorry --non-trivial
lemma new_lemma_99948 (h0 : finset (simple_graph pos)) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_99949 (h1 : function.extfun Type topological_space) : @totally_separated_space.{0} (linear_ordered_semiring.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} h1 (linear_ordered_semiring.{0} num))  := sorry --non-trivial
lemma new_lemma_99950 (h0 : group (generalized_boolean_algebra (has_bot (has_Inf (has_bot (ordered_comm_monoid Type)))))) : is_cyclic (generalized_boolean_algebra (has_bot (has_Inf (has_bot (ordered_comm_monoid Type))))) := sorry --non-trivial
lemma new_lemma_99951 (h2 : ring (has_nnnorm (has_ssubset char))) : strong_rank_condition (has_nnnorm (has_ssubset char)) := sorry --non-trivial
lemma new_lemma_99952 (h0 : topological_space (has_star unsigned)) : preirreducible_space (has_star unsigned) := sorry --non-trivial
lemma new_lemma_99953 (h0 : ring (has_zero (finset linarith.comp))) : strong_rank_condition (has_zero (finset linarith.comp)) := sorry --non-trivial
lemma new_lemma_99954 (h0 : functor.add_const (uniform_space (semigroup empty)) empty) : @complete_space.{0} (semigroup.{0} empty) (@functor.add_const.run.{0 0} (uniform_space.{0} (semigroup.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_99955 (h0 : function.extfun Type complete_lattice) : @is_compactly_generated.{0} (dlist.{0} string_imp) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (dlist.{0} string_imp))  := sorry --non-trivial
lemma new_lemma_99956 (h0 : topological_space (ordered_cancel_add_comm_monoid num)) : locally_compact_space (ordered_cancel_add_comm_monoid num) := sorry --non-trivial
lemma new_lemma_99957 (h0 : ring (denumerable (random_gen (has_ssubset (random_gen fun_info))))) : is_domain (denumerable (random_gen (has_ssubset (random_gen fun_info)))) := sorry --non-trivial
lemma new_lemma_99958 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @regular_space.{0} (has_add.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_add.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_99959 (h0 : topological_space (complete_distrib_lattice (has_add name))) : t0_space (complete_distrib_lattice (has_add name)) := sorry --non-trivial
lemma new_lemma_99960 (h0 : function.extfun Type ring) : @rank_condition.{0} (complete_semilattice_Sup.{0} unsigned) (@function.extfun_app.{2 1} Type ring.{0} h0 (complete_semilattice_Sup.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_99961 (h0 : list (as_linear_order (option (option empty)))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_99962 (h0 : function.extfun Type group) : @is_cyclic.{0} (filter.{0} num) (@function.extfun_app.{2 1} Type group.{0} h0 (filter.{0} num))  := sorry --non-trivial
lemma new_lemma_99963 (h0 : function.extfun (Type 1) add_group) : @is_add_cyclic.{1} (add_cancel_monoid.{1} Type) (@function.extfun_app.{3 2} (Type 1) add_group.{1} h0 (add_cancel_monoid.{1} Type))  := sorry --non-trivial
lemma new_lemma_99964 (h0 : topological_space (boolean_algebra.core (option ennreal))) : totally_disconnected_space (boolean_algebra.core (option ennreal)) := sorry --non-trivial
lemma new_lemma_99965 (h0 : ring (metric_space (semiring num))) : strong_rank_condition (metric_space (semiring num)) := sorry --non-trivial
lemma new_lemma_99966 (h0 : topological_space (with_bot (has_top (has_norm (has_norm linarith.comp_source))))) : locally_compact_space (with_bot (has_top (has_norm (has_norm linarith.comp_source)))) := sorry --non-trivial
lemma new_lemma_99967 (h0 : functor.add_const (add_monoid (has_to_string Type)) (has_neg linarith.comp)) : @add_monoid.fg.{1} (has_to_string.{1} Type) (@functor.add_const.run.{1 0} (add_monoid.{1} (has_to_string.{1} Type)) (has_neg.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_99968 (h0 : function.extfun Type topological_space) : @topological_space.separable_space.{0} (has_to_string.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_to_string.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_99969 (h0 : functor.add_const (function.extfun (Type 1) topological_space) pos) : @topological_space.separable_space.{1} (ordered_comm_monoid.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) topological_space.{1}) pos h0) (ordered_comm_monoid.{1} Type))  := sorry --non-trivial
lemma new_lemma_99970 (h0 : not (function.extfun Type group -> false)) : @normalizer_condition.{0} (has_top.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type group.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type group.{0}) h0) (has_top.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_99971 (h0 : group (has_norm char)) : is_cyclic (has_norm char) := sorry --non-trivial
lemma new_lemma_99972 (h0 : ordered_comm_monoid (has_nndist (boolean_algebra.core Type))) : has_exists_mul_of_le (has_nndist (boolean_algebra.core Type)) := sorry --non-trivial
lemma new_lemma_99973 (h0 : topological_space (comm_semigroup (sub_neg_monoid pos))) : t0_space (comm_semigroup (sub_neg_monoid pos)) := sorry --non-trivial
lemma new_lemma_99974 (h0 : functor.add_const (function.extfun Type topological_space) (finset pos)) : @totally_disconnected_space.{0} (add_cancel_monoid.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) (finset.{0} pos) h0) (add_cancel_monoid.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_99975 (h0 : functor.comp uniform_space has_to_string name) : @complete_space.{0} (has_to_string.{0} name) (@functor.comp.run.{0 0 0} uniform_space.{0} has_to_string.{0} name h0)  := sorry --non-trivial
lemma new_lemma_99976 (h0 : function.extfun Type topological_space) : @loc_path_connected_space.{0} (normed_comm_ring.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (normed_comm_ring.{0} pos))  := sorry --non-trivial
lemma new_lemma_99977 (h0 : functor.add_const (topological_space environment.implicit_infer_kind) environment.implicit_infer_kind) : @discrete_topology.{0} environment.implicit_infer_kind (@functor.add_const.run.{0 0} (topological_space.{0} environment.implicit_infer_kind) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_99978 (h0 : functor.add_const (functor.add_const (topological_space pos) linarith.comp) linarith.comp) : @locally_compact_space.{0} pos (@functor.add_const.run.{0 0} (topological_space.{0} pos) linarith.comp (@functor.add_const.run.{0 0} (functor.add_const.{0 0} (topological_space.{0} pos) linarith.comp) linarith.comp h0))  := sorry --non-trivial
lemma new_lemma_99979 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_add_cyclic.{0} (generalized_boolean_algebra.{0} name) (@function.extfun_app.{2 1} Type add_group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 add_group.{0}) (generalized_boolean_algebra.{0} name))  := sorry --non-trivial
lemma new_lemma_99980 (h0 : topological_space (semiring (has_top num))) : discrete_topology (semiring (has_top num)) := sorry --non-trivial
lemma new_lemma_99981 (h0 : topological_space (with_bot linarith.comp)) : totally_disconnected_space (with_bot linarith.comp) := sorry --non-trivial
lemma new_lemma_99982 (h0 : topological_space (has_pos_part (has_pos_part linarith.comp))) : sequential_space (has_pos_part (has_pos_part linarith.comp)) := sorry --non-trivial
lemma new_lemma_99983 (h0 : topological_space (semiring (has_top congr_arg_kind))) : preirreducible_space (semiring (has_top congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_99984 (h0 : topological_space (comm_group (has_add (has_add name)))) : loc_path_connected_space (comm_group (has_add (has_add name))) := sorry --non-trivial
lemma new_lemma_99985 (h0 : monoid (normed_comm_ring (comm_group name))) : monoid.fg (normed_comm_ring (comm_group name)) := sorry --non-trivial
lemma new_lemma_99986 (h0 : ring (has_zero (option unsigned))) : is_domain (has_zero (option unsigned)) := sorry --non-trivial
lemma new_lemma_99987 (h0 : function.extfun Type complete_lattice) : @complete_lattice.is_Sup_finite_compact.{0} znum (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 znum)  := sorry --non-trivial
lemma new_lemma_99988 (h0 : not (complete_lattice (mul_zero_class congr_arg_kind) -> false)) : @is_atomistic.{0} (mul_zero_class.{0} congr_arg_kind) (@classical.by_contradiction'.{1} (complete_lattice.{0} (mul_zero_class.{0} congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_99989 (h0 : topological_space (has_Inf (has_Inf Type))) : regular_space (has_Inf (has_Inf Type)) := sorry --non-trivial
lemma new_lemma_99990 (h0 : functor.add_const (ordered_add_comm_monoid (cancel_monoid pos)) (option unsigned)) : @archimedean.{0} (cancel_monoid.{0} pos) (@functor.add_const.run.{0 0} (ordered_add_comm_monoid.{0} (cancel_monoid.{0} pos)) (option.{0} unsigned) h0)  := sorry --non-trivial
lemma new_lemma_99991 (h0 : add_monoid (normed_group (semiring linarith.comp))) : add_monoid.fg (normed_group (semiring linarith.comp)) := sorry --non-trivial
lemma new_lemma_99992 (h0 : filter (has_neg (option empty))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_99993 (h0 : function.extfun Type uniform_space) : @separated_space.{0} (normed_comm_ring.{0} empty) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (normed_comm_ring.{0} empty))  := sorry --non-trivial
lemma new_lemma_99994 (h0 : function.extfun Type topological_space) : @totally_separated_space.{0} (finset.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (finset.{0} name))  := sorry --non-trivial
lemma new_lemma_99995 (h0 : not (function.extfun Type uniform_space -> false)) : @complete_space.{0} (add_right_cancel_monoid.{0} num) (@function.extfun_app.{2 1} Type uniform_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type uniform_space.{0}) h0) (add_right_cancel_monoid.{0} num))  := sorry --non-trivial
lemma new_lemma_99996 (h0 : functor.add_const (functor.add_const (complete_lattice environment.implicit_infer_kind) pos) pos) : @complete_lattice.is_Sup_finite_compact.{0} environment.implicit_infer_kind (@functor.add_const.run.{0 0} (complete_lattice.{0} environment.implicit_infer_kind) pos (@functor.add_const.run.{0 0} (functor.add_const.{0 0} (complete_lattice.{0} environment.implicit_infer_kind) pos) pos h0))  := sorry --non-trivial
lemma new_lemma_99997 (h0 : add_monoid (has_bot pos)) : add_monoid.fg (has_bot pos) := sorry --non-trivial
lemma new_lemma_99998 (h0 : list (normed_comm_ring (has_add name))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_99999 (h0 : functor.add_const (ring (has_nndist pos)) pos) : @is_principal_ideal_ring.{0} (has_nndist.{0} pos) (@functor.add_const.run.{0 0} (ring.{0} (has_nndist.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_100000 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @totally_separated_space.{0} (ordered_comm_monoid.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (ordered_comm_monoid.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_100001 (h0 : topological_space (add_cancel_monoid (has_add (has_to_string name)))) : t1_space (add_cancel_monoid (has_add (has_to_string name))) := sorry --non-trivial
lemma new_lemma_100002 (h0 : functor.add_const (ring (has_nndist linarith.comp)) environment.implicit_infer_kind) : @is_principal_ideal_ring.{0} (has_nndist.{0} linarith.comp) (@functor.add_const.run.{0 0} (ring.{0} (has_nndist.{0} linarith.comp)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_100003 (h0 : ordered_comm_monoid (has_neg_part (has_to_string Type))) : has_exists_mul_of_le (has_neg_part (has_to_string Type)) := sorry --non-trivial
lemma new_lemma_100004 (h0 : functor.add_const (function.extfun Type ring) Type) : @strong_rank_condition.{0} (normed_comm_ring.{0} pos) (@function.extfun_app.{2 1} Type ring.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type ring.{0}) Type h0) (normed_comm_ring.{0} pos))  := sorry --non-trivial
lemma new_lemma_100005 (h0 : function.extfun Type add_group) : @is_add_cyclic.{0} (semiring.{0} empty) (@function.extfun_app.{2 1} Type add_group.{0} h0 (semiring.{0} empty))  := sorry --non-trivial
lemma new_lemma_100006 (h0 : ring (omega_complete_partial_order unsigned)) : is_domain (omega_complete_partial_order unsigned) := sorry --non-trivial
lemma new_lemma_100007 (h1 : topological_space (complete_semilattice_Sup congr_arg_kind)) : path_connected_space (complete_semilattice_Sup congr_arg_kind) := sorry --non-trivial
lemma new_lemma_100008 (h0 : topological_space (dlist (random_gen string_imp))) : t0_space (dlist (random_gen string_imp)) := sorry --non-trivial
lemma new_lemma_100009 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @path_connected_space.{0} (measure_theory.measure_space.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (measure_theory.measure_space.{0} num))  := sorry --non-trivial
lemma new_lemma_100010 (h0 : filter (ring (has_neg Type))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_100011 (h0 : functor.add_const (topological_space (complete_distrib_lattice Type)) pos) : @normal_space.{1} (complete_distrib_lattice.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (complete_distrib_lattice.{1} Type)) pos h0)  := sorry --non-trivial
lemma new_lemma_100012 (h0 : ordered_add_comm_monoid (ordered_comm_monoid (has_add pos))) : archimedean (ordered_comm_monoid (has_add pos)) := sorry --non-trivial
lemma new_lemma_100013 (h0 : functor.add_const (topological_space (normed_comm_ring pos)) linarith.comp) : @totally_separated_space.{0} (normed_comm_ring.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (normed_comm_ring.{0} pos)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_100014 (h0 : filter (has_neg (has_nndist (has_add environment.implicit_infer_kind)))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_100015 (h0 : list (bin_tree (ordered_cancel_comm_monoid unsigned))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_100016 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @locally_compact_space.{0} (measurable_space.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (measurable_space.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_100017 (h0 : functor.add_const (topological_space (has_neg unsigned)) Type) : @t0_space.{0} (has_neg.{0} unsigned) (@functor.add_const.run.{0 1} (topological_space.{0} (has_neg.{0} unsigned)) Type h0)  := sorry --non-trivial
lemma new_lemma_100018 (h0 : not (ring (with_one to_additive.value_type) -> false)) : @rank_condition.{0} (with_one.{0} to_additive.value_type) (@classical.by_contradiction'.{1} (ring.{0} (with_one.{0} to_additive.value_type)) h0)  := sorry --non-trivial
lemma new_lemma_100019 (h0 : ring (linear_ordered_comm_group (option (option (option empty))))) : rank_condition (linear_ordered_comm_group (option (option (option empty)))) := sorry --non-trivial
lemma new_lemma_100020 (h0 : ring (semi_normed_comm_ring (has_nnnorm (has_nnnorm string.iterator_imp)))) : rank_condition (semi_normed_comm_ring (has_nnnorm (has_nnnorm string.iterator_imp))) := sorry --non-trivial
lemma new_lemma_100021 (h0 : uniform_space unsigned) : complete_space unsigned := sorry --non-trivial
lemma new_lemma_100022 (h1 : function.extfun Type topological_space) : @preirreducible_space.{0} (measurable_space.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} h1 (measurable_space.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_100023 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @t1_space.{0} (canonically_ordered_add_monoid.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (canonically_ordered_add_monoid.{0} empty))  := sorry --non-trivial
lemma new_lemma_100024 (h0 : not (function.extfun Type topological_space -> false)) : @normal_space.{0} (has_one.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (has_one.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_100025 (h0 : complete_lattice (has_pos_part name)) : is_atomistic (has_pos_part name) := sorry --non-trivial
lemma new_lemma_100026 (h0 : topological_space (comm_ring (normed_lattice_add_comm_group to_additive.value_type))) : locally_compact_space (comm_ring (normed_lattice_add_comm_group to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_100027 (h0 : functor.add_const (complete_lattice (semigroup pos)) name) : @is_atomistic.{0} (semigroup.{0} pos) (@functor.add_const.run.{0 0} (complete_lattice.{0} (semigroup.{0} pos)) name h0)  := sorry --non-trivial
lemma new_lemma_100028 (h0 : uniform_space (cancel_monoid (comm_group (comm_group name)))) : separated_space (cancel_monoid (comm_group (comm_group name))) := sorry --non-trivial
lemma new_lemma_100029 (h0 : functor.add_const (function.extfun (Type 1) uniform_space) Type) : @complete_space.{1} (has_Inf.{1} Type) (@function.extfun_app.{3 2} (Type 1) uniform_space.{1} (@functor.add_const.run.{2 1} (function.extfun.{3 2} (Type 1) uniform_space.{1}) Type h0) (has_Inf.{1} Type))  := sorry --non-trivial
lemma new_lemma_100030 (h1 : ring (denumerable (has_inv (has_norm string_imp)))) : is_domain (denumerable (has_inv (has_norm string_imp))) := sorry --non-trivial
lemma new_lemma_100031 (h0 : functor.add_const (fin has_zero.zero) real) : @is_noetherian_ring.{1} (has_bot.{1} Type) (@matrix.vec_empty.{1} (semiring.{1} (has_bot.{1} Type)) (@functor.add_const.run.{0 0} (fin (@has_zero.zero.{0} nat nat.has_zero)) real h0))  := sorry --non-trivial
lemma new_lemma_100032 (h0 : function.extfun Type topological_space) : @totally_separated_space.{0} (measurable_space.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (measurable_space.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_100033 (h0 : ring (linear_ordered_field (option empty))) : is_domain (linear_ordered_field (option empty)) := sorry --non-trivial
lemma new_lemma_100034 (h0 : not (complete_lattice (linear_ordered_semiring linarith.comp_source) -> false)) : @is_compactly_generated.{0} (linear_ordered_semiring.{0} linarith.comp_source) (@classical.by_contradiction'.{1} (complete_lattice.{0} (linear_ordered_semiring.{0} linarith.comp_source)) h0)  := sorry --non-trivial
lemma new_lemma_100035 (h0 : topological_space (id (semiring empty))) : t0_space (id (semiring empty)) := sorry --non-trivial
lemma new_lemma_100036 (h0 : functor.add_const (finset (left_cancel_monoid empty)) (semiring num)) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_100037 (h0 : ring (normed_field string.iterator_imp)) : strong_rank_condition (normed_field string.iterator_imp) := sorry --non-trivial
lemma new_lemma_100038 (h0 : function.extfun Type cancel_comm_monoid_with_zero) : @unique_factorization_monoid.{0} (group_with_zero.{0} ennreal) (@function.extfun_app.{2 1} Type cancel_comm_monoid_with_zero.{0} h0 (group_with_zero.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_100039 (h0 : prod (add_comm_semigroup std_gen) (add_comm_semigroup std_gen)) : set.diagonal (add_comm_semigroup std_gen) h0 := sorry --non-trivial
lemma new_lemma_100040 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @path_connected_space.{0} (measurable_space.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (measurable_space.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_100041 (h0 : not (has_mem.mem group has_emptyc.emptyc -> false)) : @normalizer_condition.{0} (semiring.{0} linarith.ineq) (@function.extfun_app.{2 1} Type group.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) group.{0} (@classical.by_contradiction'.{0} (@has_mem.mem.{1 1} (Type → Type) (finset.{1} (Type → Type)) (@finset.has_mem.{1} (Type → Type)) group.{0} (@has_emptyc.emptyc.{1} (finset.{1} (Type → Type)) (@finset.has_emptyc.{1} (Type → Type)))) h0)) (semiring.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_100042 (h0 : topological_space (has_sub empty)) : normal_space (has_sub empty) := sorry --non-trivial
lemma new_lemma_100043 (h0 : measurable_space (random_gen (has_inv to_additive.value_type)) -> Prop) : Exists h0 := sorry --non-trivial
lemma new_lemma_100044 (h0 : functor.add_const (topological_space (boolean_algebra.core Type)) linarith.comp) : @t1_space.{1} (boolean_algebra.core.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (boolean_algebra.core.{1} Type)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_100045 (h0 : functor.add_const (group (generalized_boolean_algebra pos)) (finset pos)) : @is_simple_group.{0} (generalized_boolean_algebra.{0} pos) (@functor.add_const.run.{0 0} (group.{0} (generalized_boolean_algebra.{0} pos)) (finset.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_100046 (h0 : function.extfun Type topological_space) : @totally_separated_space.{0} (has_nndist.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_nndist.{0} num))  := sorry --non-trivial
lemma new_lemma_100047 (h0 : functor.add_const (function.extfun Type complete_lattice) pos) : @complete_lattice.is_Sup_finite_compact.{0} (complete_distrib_lattice.{0} linarith.comp) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type complete_lattice.{0}) pos h0) (complete_distrib_lattice.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_100048 (h0 : topological_space (generalized_boolean_algebra (ring name))) : irreducible_space (generalized_boolean_algebra (ring name)) := sorry --non-trivial
lemma new_lemma_100049 (h0 : complete_lattice (option (option (option empty)))) : complete_lattice.is_Sup_finite_compact (option (option (option empty))) := sorry --non-trivial
lemma new_lemma_100050 (h0 : list (has_top (has_inv string_imp))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_100051 (h0 : semiring (has_nnnorm fun_info)) (h1 : ideal (has_nnnorm fun_info)) : ideal.is_prime h1 := sorry --non-trivial
lemma new_lemma_100052 (h0 : functor.add_const (cancel_comm_monoid_with_zero auto.case_option) num) : @unique_factorization_monoid.{0} auto.case_option (@functor.add_const.run.{0 0} (cancel_comm_monoid_with_zero.{0} auto.case_option) num h0)  := sorry --non-trivial
lemma new_lemma_100053 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_noetherian_ring.{0} (add_cancel_monoid.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type semiring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 semiring.{0}) (add_cancel_monoid.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_100054 (h1 : filter (distrib to_additive.value_type)) : filter.ne_bot h1 := sorry --non-trivial
lemma new_lemma_100055 (h1 : uniform_space (semiring to_additive.value_type)) : separated_space (semiring to_additive.value_type) := sorry --non-trivial
lemma new_lemma_100056 (h0 : functor.add_const (add_group (has_nndist linarith.comp)) environment.implicit_infer_kind) : @is_add_cyclic.{0} (has_nndist.{0} linarith.comp) (@functor.add_const.run.{0 0} (add_group.{0} (has_nndist.{0} linarith.comp)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_100057 (h0 : functor.add_const (list (cancel_monoid unsigned)) unsigned) : palindrome (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_100058 (h0 : ring (add_comm_monoid (semigroup (semigroup environment.implicit_infer_kind)))) : is_domain (add_comm_monoid (semigroup (semigroup environment.implicit_infer_kind))) := sorry --non-trivial
lemma new_lemma_100059 (h0 : functor.add_const (topological_space (partial_order unsigned)) congr_arg_kind) : @discrete_topology.{0} (partial_order.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (partial_order.{0} unsigned)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_100060 (h0 : ordered_add_comm_monoid (add_cancel_monoid (finset (finset (finset linarith.comp))))) : archimedean (add_cancel_monoid (finset (finset (finset linarith.comp)))) := sorry --non-trivial
lemma new_lemma_100061 (h0 : functor.add_const (topological_space (boolean_algebra.core pos)) Type) : @preirreducible_space.{0} (boolean_algebra.core.{0} pos) (@functor.add_const.run.{0 1} (topological_space.{0} (boolean_algebra.core.{0} pos)) Type h0)  := sorry --non-trivial
lemma new_lemma_100062 (h0 : not (function.extfun Type ring -> false)) : @is_principal_ideal_ring.{0} (measure_theory.measure_space.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type ring.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type ring.{0}) h0) (measure_theory.measure_space.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_100063 (h0 : topological_space (has_lt string.iterator_imp)) : totally_disconnected_space (has_lt string.iterator_imp) := sorry --non-trivial
lemma new_lemma_100064 (h0 : topological_space (boolean_algebra (has_add linarith.comp))) : sequential_space (boolean_algebra (has_add linarith.comp)) := sorry --non-trivial
lemma new_lemma_100065 (h0 : function.extfun Type topological_space) : @discrete_topology.{0} (ordered_cancel_add_comm_monoid.{0} ennreal) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (ordered_cancel_add_comm_monoid.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_100066 (h0 : topological_space (boolean_algebra.core (boolean_algebra environment.implicit_infer_kind))) : locally_compact_space (boolean_algebra.core (boolean_algebra environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_100067 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_atomistic.{0} (distrib_lattice.{0} string_imp) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (distrib_lattice.{0} string_imp))  := sorry --non-trivial
lemma new_lemma_100068 (h0 : topological_space (bin_tree (semiring num))) : topological_space.separable_space (bin_tree (semiring num)) := sorry --non-trivial
lemma new_lemma_100069 (h0 : functor.add_const (filter (comm_group name)) (has_to_string Type)) : countable_Inter_filter (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_100070 (h0 : cancel_comm_monoid_with_zero (measure_theory.measure_space (has_top empty))) : unique_factorization_monoid (measure_theory.measure_space (has_top empty)) := sorry --non-trivial
lemma new_lemma_100071 (h0 : add_monoid (normed_lattice_add_comm_group (has_scalar Type (ordered_comm_monoid linarith.comp)))) : add_monoid.fg (normed_lattice_add_comm_group (has_scalar Type (ordered_comm_monoid linarith.comp))) := sorry --non-trivial
lemma new_lemma_100072 (h0 : uniform_space (ordered_comm_group (option empty))) : complete_space (ordered_comm_group (option empty)) := sorry --non-trivial
lemma new_lemma_100073 (h0 : group (normed_linear_ordered_group (semiring (semiring empty)))) : normalizer_condition (normed_linear_ordered_group (semiring (semiring empty))) := sorry --non-trivial
lemma new_lemma_100074 (h0 : not (topological_space (with_one to_additive.value_type) -> false)) : @irreducible_space.{0} (with_one.{0} to_additive.value_type) (@classical.by_contradiction'.{1} (topological_space.{0} (with_one.{0} to_additive.value_type)) h0)  := sorry --non-trivial
lemma new_lemma_100075 (h0 : functor.add_const (ring (boolean_algebra.core name)) Type) : @strong_rank_condition.{0} (boolean_algebra.core.{0} name) (@functor.add_const.run.{0 1} (ring.{0} (boolean_algebra.core.{0} name)) Type h0)  := sorry --non-trivial
lemma new_lemma_100076 (h0 : topological_space (measurable_space fun_info)) : irreducible_space (measurable_space fun_info) := sorry --non-trivial
lemma new_lemma_100077 (h0 : filter (topological_space (linear_ordered_add_comm_group (denumerable linarith.ineq)))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_100078 (h2 : ring (has_append fun_info)) : rank_condition (has_append fun_info) := sorry --non-trivial
lemma new_lemma_100079 (h0 : topological_space (has_compl (mul_one_class reducibility_hints))) : path_connected_space (has_compl (mul_one_class reducibility_hints)) := sorry --non-trivial
lemma new_lemma_100080 (h0 : topological_space (ordered_ring num)) : loc_path_connected_space (ordered_ring num) := sorry --non-trivial
lemma new_lemma_100081 (h0 : functor.add_const (complete_lattice (has_neg linarith.comp)) Type) : @is_compactly_generated.{0} (has_neg.{0} linarith.comp) (@functor.add_const.run.{0 1} (complete_lattice.{0} (has_neg.{0} linarith.comp)) Type h0)  := sorry --non-trivial
lemma new_lemma_100082 (h0 : topological_space (has_to_string (option (option (option (option (option ennreal))))))) : preirreducible_space (has_to_string (option (option (option (option (option ennreal)))))) := sorry --non-trivial
lemma new_lemma_100083 (h0 : topological_space (linear_ordered_field (option ennreal))) : normal_space (linear_ordered_field (option ennreal)) := sorry --non-trivial
lemma new_lemma_100084 (h0 : functor.add_const (topological_space (has_add linarith.comp)) (ring Type)) : @discrete_topology.{0} (has_add.{0} linarith.comp) (@functor.add_const.run.{0 1} (topological_space.{0} (has_add.{0} linarith.comp)) (ring.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_100085 (h0 : functor.add_const (topological_space (canonically_ordered_monoid pos)) linarith.comp) : @irreducible_space.{0} (canonically_ordered_monoid.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (canonically_ordered_monoid.{0} pos)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_100086 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_cyclic.{0} (monoid_with_zero.{0} ennreal) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (monoid_with_zero.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_100087 (h0 : has_mem.mem (has_norm num) has_emptyc.emptyc) : @monoid.fg.{0} (has_norm.{0} num) (@finset.pi.empty.{1 0} Type monoid.{0} (has_norm.{0} num) h0)  := sorry --non-trivial
lemma new_lemma_100088 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @archimedean.{0} (has_pos_part.{0} linarith.comp) (@function.extfun_app.{2 1} Type ordered_add_comm_monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ordered_add_comm_monoid.{0}) (has_pos_part.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_100089 (h0 : function.extfun Type topological_space) : @totally_disconnected_space.{0} (has_zero.{0} ennreal) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_zero.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_100090 (h0 : group (generalized_boolean_algebra (has_bot name))) : is_cyclic (generalized_boolean_algebra (has_bot name)) := sorry --non-trivial
lemma new_lemma_100091 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @normal_space.{0} (normed_comm_ring.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (normed_comm_ring.{0} pos))  := sorry --non-trivial
lemma new_lemma_100092 (h0 : topological_space (group_with_zero ennreal)) : totally_separated_space (group_with_zero ennreal) := sorry --non-trivial
lemma new_lemma_100093 (h0 : complete_lattice (has_norm (has_ssubset (has_ssubset linarith.ineq)))) : is_compactly_generated (has_norm (has_ssubset (has_ssubset linarith.ineq))) := sorry --non-trivial
lemma new_lemma_100094 (h0 : topological_space (comm_group (has_add name))) : normal_space (comm_group (has_add name)) := sorry --non-trivial
lemma new_lemma_100095 (h0 : function.extfun Type complete_lattice) : @complete_lattice.is_Sup_finite_compact.{0} (has_add.{0} pos) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (has_add.{0} pos))  := sorry --non-trivial
lemma new_lemma_100096 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : list.nodup (function.extfun_app (function.extfun_app h0 list) (has_zero pos)) := sorry --non-trivial
lemma new_lemma_100097 (h1 : function.extfun Type topological_space) : @t0_space.{0} (with_bot.{0} fun_info) (@function.extfun_app.{2 1} Type topological_space.{0} h1 (with_bot.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_100098 (h0 : function.extfun nat fin) : @is_compactly_generated.{0} (ordered_comm_ring.{0} name) (@matrix.vec_empty.{0} (complete_lattice.{0} (ordered_comm_ring.{0} name)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_100099 (h0 : filter (has_inv (random_gen (random_gen to_additive.value_type)))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_100100 (h0 : functor.add_const (topological_space (ring pos)) environment.implicit_infer_kind) : @discrete_topology.{0} (ring.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (ring.{0} pos)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_100101 (h0 : functor.add_const (group (linear_ordered_cancel_comm_monoid empty)) (option empty)) : @normalizer_condition.{0} (linear_ordered_cancel_comm_monoid.{0} empty) (@functor.add_const.run.{0 0} (group.{0} (linear_ordered_cancel_comm_monoid.{0} empty)) (option.{0} empty) h0)  := sorry --non-trivial
lemma new_lemma_100102 (h0 : topological_space (non_assoc_semiring (semiring congr_arg_kind))) : totally_separated_space (non_assoc_semiring (semiring congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_100103 (h0 : topological_space (normed_comm_ring (option empty))) : t0_space (normed_comm_ring (option empty)) := sorry --non-trivial
lemma new_lemma_100104 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : list.nodup (function.extfun_app (function.extfun_app h0 list) (has_ssubset to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_100105 (h0 : add_group (complete_semilattice_Sup unsigned)) : is_add_cyclic (complete_semilattice_Sup unsigned) := sorry --non-trivial
lemma new_lemma_100106 (h0 : ring (has_one (semiring (semiring congr_arg_kind)))) : rank_condition (has_one (semiring (semiring congr_arg_kind))) := sorry --non-trivial
lemma new_lemma_100107 (h0 : group (complete_distrib_lattice (has_Inf (has_Inf real)))) : is_simple_group (complete_distrib_lattice (has_Inf (has_Inf real))) := sorry --non-trivial
lemma new_lemma_100108 (h0 : not (group (with_zero char) -> false)) : @is_cyclic.{0} (with_zero.{0} char) (@classical.by_contradiction'.{1} (group.{0} (with_zero.{0} char)) h0)  := sorry --non-trivial
lemma new_lemma_100109 (h0 : function.extfun Type complete_lattice) : @is_atomistic.{0} (measurable_space.dynkin_system.{0} empty) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (measurable_space.dynkin_system.{0} empty))  := sorry --non-trivial
lemma new_lemma_100110 (h1 : add_group (semi_normed_comm_ring std_gen)) : is_add_cyclic (semi_normed_comm_ring std_gen) := sorry --non-trivial
lemma new_lemma_100111 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @totally_separated_space.{0} (pseudo_metric_space.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (pseudo_metric_space.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_100112 (h0 : add_monoid (add_semigroup (option (option empty)))) : add_monoid.fg (add_semigroup (option (option empty))) := sorry --non-trivial
lemma new_lemma_100113 (h0 : function.extfun Type ordered_add_comm_monoid) : @archimedean.{0} (filter.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type ordered_add_comm_monoid.{0} h0 (filter.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_100114 (h0 : semiring (add_cancel_monoid name)) : is_noetherian_ring (add_cancel_monoid name) := sorry --non-trivial
lemma new_lemma_100115 (h0 : add_monoid (finset (has_to_string environment.implicit_infer_kind))) : add_monoid.fg (finset (has_to_string environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_100116 (h1 : function.extfun (Type -> Type) (function.extfun Type)) : @complete_space.{0} (has_emptyc.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type uniform_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h1 uniform_space.{0}) (has_emptyc.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_100117 (h0 : topological_space (free_add_monoid (semiring unsigned))) : t1_space (free_add_monoid (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_100118 (h0 : uniform_space (complete_semilattice_Sup (semiring unsigned))) : separated_space (complete_semilattice_Sup (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_100119 (h0 : functor.add_const (function.extfun Type ring) environment.implicit_infer_kind) : @is_domain.{0} (has_to_string.{0} name) (@function.extfun_app.{2 1} Type ring.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type ring.{0}) environment.implicit_infer_kind h0) (has_to_string.{0} name))  := sorry --non-trivial
lemma new_lemma_100120 (h0 : semiring (finset name)) : is_noetherian_ring (finset name) := sorry --non-trivial
lemma new_lemma_100121 (h0 : fin has_zero.zero) : @normalizer_condition.{1} (normed_lattice_add_comm_group.{1} Type) (@matrix.vec_empty.{1} (group.{1} (normed_lattice_add_comm_group.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_100122 (h0 : topological_space (non_assoc_semiring empty)) : normal_space (non_assoc_semiring empty) := sorry --non-trivial
lemma new_lemma_100123 (h0 : functor.comp topological_space ring name) : @t1_space.{0} (ring.{0} name) (@functor.comp.run.{0 0 0} topological_space.{0} ring.{0} name h0)  := sorry --non-trivial
lemma new_lemma_100124 (h0 : topological_space (has_pos_part (has_Inf Type))) : path_connected_space (has_pos_part (has_Inf Type)) := sorry --non-trivial
lemma new_lemma_100125 (h0 : uniform_space (add_group (ordered_cancel_comm_monoid empty))) : complete_space (add_group (ordered_cancel_comm_monoid empty)) := sorry --non-trivial
lemma new_lemma_100126 (h0 : group (with_bot (semiring unsigned))) : normalizer_condition (with_bot (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_100127 (h0 : topological_space (has_zero (has_neg_part unsigned))) : normal_space (has_zero (has_neg_part unsigned)) := sorry --non-trivial
lemma new_lemma_100128 (h0 : ordered_add_comm_monoid (left_cancel_monoid (ordered_ring empty))) : archimedean (left_cancel_monoid (ordered_ring empty)) := sorry --non-trivial
lemma new_lemma_100129 (h0 : topological_space (complete_distrib_lattice (ordered_comm_monoid (has_bot real)))) : locally_compact_space (complete_distrib_lattice (ordered_comm_monoid (has_bot real))) := sorry --non-trivial
lemma new_lemma_100130 (h0 h1 : list (comm_ring (has_nnnorm string_imp))) : list.subset h0 h1 := sorry --non-trivial
lemma new_lemma_100131 (h0 : functor.add_const (ordered_comm_monoid (comm_group Type)) name) : @has_exists_mul_of_le.{1} (comm_group.{1} Type) (@functor.add_const.run.{1 0} (ordered_comm_monoid.{1} (comm_group.{1} Type)) name h0)  := sorry --non-trivial
lemma new_lemma_100132 (h0 : uniform_space (has_norm (semiring (has_top congr_arg_kind)))) : separated_space (has_norm (semiring (has_top congr_arg_kind))) := sorry --non-trivial
lemma new_lemma_100133 (h1 : not (topological_space (denumerable (comm_ring linarith.comp_source)) -> false)) : @path_connected_space.{0} (denumerable.{0} (comm_ring.{0} linarith.comp_source)) (@classical.by_contradiction'.{1} (topological_space.{0} (denumerable.{0} (comm_ring.{0} linarith.comp_source))) h1)  := sorry --non-trivial
lemma new_lemma_100134 (h0 : topological_space (linear_ordered_field unsigned)) : normal_space (linear_ordered_field unsigned) := sorry --non-trivial
lemma new_lemma_100135 (h0 : function.extfun Type complete_lattice) : @is_compactly_generated.{0} (finset.{0} name) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (finset.{0} name))  := sorry --non-trivial
lemma new_lemma_100136 (h0 : topological_space (add_cancel_comm_monoid (comm_ring to_additive.value_type))) : t0_space (add_cancel_comm_monoid (comm_ring to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_100137 (h0 : topological_space (has_dist (option (option (option (option ennreal)))))) : t1_space (has_dist (option (option (option (option ennreal))))) := sorry --non-trivial
lemma new_lemma_100138 (h0 : topological_space (boolean_algebra (has_Inf linarith.comp))) : t0_space (boolean_algebra (has_Inf linarith.comp)) := sorry --non-trivial
lemma new_lemma_100139 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_noetherian_ring.{0} (has_pos_part.{0} name) (@function.extfun_app.{2 1} Type semiring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 semiring.{0}) (has_pos_part.{0} name))  := sorry --non-trivial
lemma new_lemma_100140 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @irreducible_space.{0} (ring.{0} ennreal) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (ring.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_100141 (h0 : not (ring (has_inv linarith.comp_source) -> false)) : @rank_condition.{0} (has_inv.{0} linarith.comp_source) (@classical.by_contradiction'.{1} (ring.{0} (has_inv.{0} linarith.comp_source)) h0)  := sorry --non-trivial
lemma new_lemma_100142 (h0 : uniform_space (semiring (has_top (has_top (has_top congr_arg_kind))))) : separated_space (semiring (has_top (has_top (has_top congr_arg_kind)))) := sorry --non-trivial
lemma new_lemma_100143 (h0 : topological_space (complete_semilattice_Sup fun_info)) : totally_disconnected_space (complete_semilattice_Sup fun_info) := sorry --non-trivial
lemma new_lemma_100144 (h0 : topological_space (omega_complete_partial_order (option (option (option unsigned))))) : path_connected_space (omega_complete_partial_order (option (option (option unsigned)))) := sorry --non-trivial
lemma new_lemma_100145 (h0 : function.extfun Type cancel_comm_monoid_with_zero) : @unique_factorization_monoid.{0} (add_cancel_monoid.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type cancel_comm_monoid_with_zero.{0} h0 (add_cancel_monoid.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_100146 (h1 : group (comm_ring to_additive.value_type)) : is_cyclic (comm_ring to_additive.value_type) := sorry --non-trivial
lemma new_lemma_100147 (h0 : uniform_space (add_cancel_monoid (option unsigned))) : complete_space (add_cancel_monoid (option unsigned)) := sorry --non-trivial
lemma new_lemma_100148 (h0 : functor.add_const (monoid (preorder num)) (option empty)) : @monoid.fg.{0} (preorder.{0} num) (@functor.add_const.run.{0 0} (monoid.{0} (preorder.{0} num)) (option.{0} empty) h0)  := sorry --non-trivial
lemma new_lemma_100149 (h0 : complete_lattice (canonically_ordered_monoid (has_Inf (has_pos_part Type)))) : is_compactly_generated (canonically_ordered_monoid (has_Inf (has_pos_part Type))) := sorry --non-trivial
lemma new_lemma_100150 (h0 : topological_space (mul_one_class congr_arg_kind)) : totally_disconnected_space (mul_one_class congr_arg_kind) := sorry --non-trivial
lemma new_lemma_100151 (h0 : topological_space (has_zero (finset (has_to_string Type)))) : loc_path_connected_space (has_zero (finset (has_to_string Type))) := sorry --non-trivial
lemma new_lemma_100152 (h0 : function.extfun Type (functor.add_const (topological_space (complete_distrib_lattice num)))) : @irreducible_space.{0} (complete_distrib_lattice.{0} num) (@functor.add_const.run.{0 0} (topological_space.{0} (complete_distrib_lattice.{0} num)) num (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (topological_space.{0} (complete_distrib_lattice.{0} num))) h0 num))  := sorry --non-trivial
lemma new_lemma_100153 (h0 : semiring (add_cancel_monoid (has_zero Type))) : is_noetherian_ring (add_cancel_monoid (has_zero Type)) := sorry --non-trivial
lemma new_lemma_100154 (h0 : ring (has_nnnorm (metric_space to_additive.value_type))) : strong_rank_condition (has_nnnorm (metric_space to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_100155 (h0 : function.extfun Type ring) : @is_principal_ideal_ring.{0} (finset.{0} num) (@function.extfun_app.{2 1} Type ring.{0} h0 (finset.{0} num))  := sorry --non-trivial
lemma new_lemma_100156 (h1 : (char -> char) -> (char -> char) -> Prop) (h2 : char -> char) : set.separates_points (eqv_gen h1 h2) := sorry --non-trivial
lemma new_lemma_100157 (h0 : ring (with_one (random_gen fun_info))) : is_domain (with_one (random_gen fun_info)) := sorry --non-trivial
lemma new_lemma_100158 (h0 : topological_space (has_dist (option (option empty)))) : irreducible_space (has_dist (option (option empty))) := sorry --non-trivial
lemma new_lemma_100159 (h0 : function.extfun Type finset) : finset.nonempty (function.extfun_app h0 pos) := sorry --non-trivial
lemma new_lemma_100160 (h0 : functor.add_const (topological_space (has_nndist environment.implicit_infer_kind)) (has_neg linarith.comp)) : @irreducible_space.{0} (has_nndist.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (has_nndist.{0} environment.implicit_infer_kind)) (has_neg.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_100161 (h0 : not (group (linear_ordered_semiring fun_info) -> false)) : @normalizer_condition.{0} (linear_ordered_semiring.{0} fun_info) (@classical.by_contradiction'.{1} (group.{0} (linear_ordered_semiring.{0} fun_info)) h0)  := sorry --non-trivial
lemma new_lemma_100162 (h0 : finset (complete_distrib_lattice Type)) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_100163 (h0 : function.extfun Type topological_space) : @preirreducible_space.{0} (pseudo_metric_space.{0} (option.{0} unsigned)) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (pseudo_metric_space.{0} (option.{0} unsigned)))  := sorry --non-trivial
lemma new_lemma_100164 (h0 : functor.add_const (group (complete_distrib_lattice name)) environment.implicit_infer_kind) : @normalizer_condition.{0} (complete_distrib_lattice.{0} name) (@functor.add_const.run.{0 0} (group.{0} (complete_distrib_lattice.{0} name)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_100165 (h0 : ring (mul_zero_class environment.implicit_infer_kind)) : is_domain (mul_zero_class environment.implicit_infer_kind) := sorry --non-trivial
lemma new_lemma_100166 (h0 : functor.add_const (ring (has_pos_part pos)) pos) : @rank_condition.{0} (has_pos_part.{0} pos) (@functor.add_const.run.{0 0} (ring.{0} (has_pos_part.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_100167 (h0 : function.extfun Type topological_space) : @locally_compact_space.{0} (measure_theory.measure_space.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (measure_theory.measure_space.{0} num))  := sorry --non-trivial
lemma new_lemma_100168 (h0 : filter (normed_group empty)) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_100169 (h0 : filter (has_norm linarith.ineq)) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_100170 (h0 : not (ring (measurable_space linarith.comp_source) -> false)) : @strong_rank_condition.{0} (measurable_space.{0} linarith.comp_source) (@classical.by_contradiction'.{1} (ring.{0} (measurable_space.{0} linarith.comp_source)) h0)  := sorry --non-trivial
lemma new_lemma_100171 (h0 : function.extfun Type filter) : filter.ne_bot (function.extfun_app h0 (linear_ordered_field congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_100172 (h0 : functor.add_const (uniform_space (has_zero pos)) (ring (ring environment.implicit_infer_kind))) : @complete_space.{0} (has_zero.{0} pos) (@functor.add_const.run.{0 0} (uniform_space.{0} (has_zero.{0} pos)) (ring.{0} (ring.{0} environment.implicit_infer_kind)) h0)  := sorry --non-trivial
lemma new_lemma_100173 (h0 : functor.add_const (monoid (add_cancel_monoid unsigned)) (option unsigned)) : @monoid.fg.{0} (add_cancel_monoid.{0} unsigned) (@functor.add_const.run.{0 0} (monoid.{0} (add_cancel_monoid.{0} unsigned)) (option.{0} unsigned) h0)  := sorry --non-trivial
lemma new_lemma_100174 (h0 : topological_space (boolean_algebra.core (has_add (finset ennreal)))) : totally_separated_space (boolean_algebra.core (has_add (finset ennreal))) := sorry --non-trivial
lemma new_lemma_100175 (h0 : topological_space (comm_group (normed_comm_ring name))) : sequential_space (comm_group (normed_comm_ring name)) := sorry --non-trivial
lemma new_lemma_100176 (h0 : functor.comp topological_space canonically_ordered_comm_semiring name) : @sequential_space.{0} (canonically_ordered_comm_semiring.{0} name) (@functor.comp.run.{0 0 0} topological_space.{0} canonically_ordered_comm_semiring.{0} name h0)  := sorry --non-trivial
lemma new_lemma_100177 (h0 : functor.add_const (topological_space (add_cancel_monoid pos)) linarith.comp) : @t1_space.{0} (add_cancel_monoid.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (add_cancel_monoid.{0} pos)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_100178 (h0 : uniform_space (has_neg (has_neg_part (boolean_algebra (boolean_algebra linarith.comp))))) : complete_space (has_neg (has_neg_part (boolean_algebra (boolean_algebra linarith.comp)))) := sorry --non-trivial
lemma new_lemma_100179 (h0 : function.extfun (finset Type) (has_mem.mem (semiring fun_info))) : @rank_condition.{0} (semiring.{0} fun_info) (@finset.pi.empty.{1 0} Type ring.{0} (semiring.{0} fun_info) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (semiring.{0} fun_info)) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_100180 (h2 : topological_space (encodable (has_ssubset (has_ssubset to_additive.value_type)))) : path_connected_space (encodable (has_ssubset (has_ssubset to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_100181 (h0 : function.extfun Type topological_space) : @sequential_space.{0} (has_to_string.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_to_string.{0} pos))  := sorry --non-trivial
lemma new_lemma_100182 (h0 : topological_space (linear_ordered_comm_group_with_zero to_additive.value_type)) : totally_disconnected_space (linear_ordered_comm_group_with_zero to_additive.value_type) := sorry --non-trivial
lemma new_lemma_100183 (h0 : group (has_nnnorm (random_gen (has_nnnorm to_additive.value_type)))) : is_cyclic (has_nnnorm (random_gen (has_nnnorm to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_100184 (h0 : function.extfun Type topological_space) : @normal_space.{0} (complete_linear_order.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (complete_linear_order.{0} num))  := sorry --non-trivial
lemma new_lemma_100185 (h0 : uniform_space (has_zero (has_neg linarith.comp))) : separated_space (has_zero (has_neg linarith.comp)) := sorry --non-trivial
lemma new_lemma_100186 (h0 : not (function.extfun Type topological_space -> false)) : @preirreducible_space.{0} (measurable_space.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (measurable_space.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_100187 (h0 : ring (simple_graph char)) : strong_rank_condition (simple_graph char) := sorry --non-trivial
lemma new_lemma_100188 (h0 : functor.add_const (list (has_add pos)) (has_add linarith.comp)) : list.nodup (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_100189 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @complete_lattice.is_Sup_finite_compact.{0} (semiring.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (semiring.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_100190 (h0 : has_mem.mem (measurable_space (has_norm num)) has_emptyc.emptyc) : @strong_rank_condition.{0} (measurable_space.{0} (has_norm.{0} num)) (@finset.pi.empty.{1 0} Type ring.{0} (measurable_space.{0} (has_norm.{0} num)) h0)  := sorry --non-trivial
lemma new_lemma_100191 (h3 : topological_space (add_comm_semigroup std_gen)) (h4 : set (add_comm_semigroup std_gen)) : is_path_connected h4 := sorry --non-trivial
lemma new_lemma_100192 (h0 : not (ring (normed_group linarith.comp_source) -> false)) : @is_domain.{0} (normed_group.{0} linarith.comp_source) (@classical.by_contradiction'.{1} (ring.{0} (normed_group.{0} linarith.comp_source)) h0)  := sorry --non-trivial
lemma new_lemma_100193 (h1 : complete_lattice (comm_ring (metric_space to_additive.value_type))) : is_compactly_generated (comm_ring (metric_space to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_100194 (h0 : semiring (has_neg Type)) (h1 : ring (polynomial (has_neg Type))) : is_principal_ideal_ring (polynomial (has_neg Type)) := sorry --non-trivial
lemma new_lemma_100195 (h0 : topological_space (has_neg (semigroup ennreal))) : locally_compact_space (has_neg (semigroup ennreal)) := sorry --non-trivial
lemma new_lemma_100196 (h0 : not (complete_lattice (emetric_space congr_arg_kind) -> false)) : @complete_lattice.is_Sup_finite_compact.{0} (emetric_space.{0} congr_arg_kind) (@classical.by_contradiction'.{1} (complete_lattice.{0} (emetric_space.{0} congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_100197 (h0 : function.extfun Type uniform_space) : @complete_space.{0} znum (@function.extfun_app.{2 1} Type uniform_space.{0} h0 znum)  := sorry --non-trivial
lemma new_lemma_100198 (h0 : uniform_space (has_sub congr_arg_kind)) : separated_space (has_sub congr_arg_kind) := sorry --non-trivial
lemma new_lemma_100199 (h0 : not (cancel_comm_monoid_with_zero (metric_space unsigned) -> false)) : @unique_factorization_monoid.{0} (metric_space.{0} unsigned) (@classical.by_contradiction'.{1} (cancel_comm_monoid_with_zero.{0} (metric_space.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_100200 (h0 : function.extfun Type topological_space) : @path_connected_space.{0} (has_norm.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_norm.{0} num))  := sorry --non-trivial
lemma new_lemma_100201 (h0 : functor.add_const (ring (ring linarith.comp)) (has_neg pos)) : @is_domain.{0} (ring.{0} linarith.comp) (@functor.add_const.run.{0 0} (ring.{0} (ring.{0} linarith.comp)) (has_neg.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_100202 (h0 : function.extfun Type topological_space) : @preirreducible_space.{0} (has_add.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_add.{0} pos))  := sorry --non-trivial
lemma new_lemma_100203 (h0 : functor.comp topological_space canonically_ordered_comm_semiring unsigned) : @topological_space.separable_space.{0} (canonically_ordered_comm_semiring.{0} unsigned) (@functor.comp.run.{0 0 0} topological_space.{0} canonically_ordered_comm_semiring.{0} unsigned h0)  := sorry --non-trivial
lemma new_lemma_100204 (h0 : complete_lattice (finset (has_Inf linarith.comp))) : is_compactly_generated (finset (has_Inf linarith.comp)) := sorry --non-trivial
lemma new_lemma_100205 (h0 : functor.add_const (list Type) pos) : list.nodup (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_100206 (h0 : function.extfun Type group) : @normalizer_condition.{0} (linear_ordered_comm_group.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type group.{0} h0 (linear_ordered_comm_group.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_100207 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @totally_disconnected_space.{0} (has_zero.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_zero.{0} pos))  := sorry --non-trivial
lemma new_lemma_100208 (h0 : function.extfun Type (functor.add_const (topological_space pos))) : @preconnected_space.{0} pos (@functor.add_const.run.{0 0} (topological_space.{0} pos) linarith.comp (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (topological_space.{0} pos)) h0 linarith.comp))  := sorry --non-trivial
lemma new_lemma_100209 (h0 : add_monoid (add_cancel_monoid (has_add Type))) : add_monoid.fg (add_cancel_monoid (has_add Type)) := sorry --non-trivial
lemma new_lemma_100210 (h0 : list (linear_ordered_add_comm_group (with_bot string_imp))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_100211 (h1 : ring (non_unital_non_assoc_semiring to_additive.value_type)) : strong_rank_condition (non_unital_non_assoc_semiring to_additive.value_type) := sorry --non-trivial
lemma new_lemma_100212 (h0 : ordered_add_comm_monoid (has_Sup (semiring (semiring empty)))) : archimedean (has_Sup (semiring (semiring empty))) := sorry --non-trivial
lemma new_lemma_100213 (h0 : function.extfun Type (functor.add_const (ordered_add_comm_monoid (left_cancel_monoid empty)))) : @archimedean.{0} (left_cancel_monoid.{0} empty) (@functor.add_const.run.{0 0} (ordered_add_comm_monoid.{0} (left_cancel_monoid.{0} empty)) empty (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (ordered_add_comm_monoid.{0} (left_cancel_monoid.{0} empty))) h0 empty))  := sorry --non-trivial
lemma new_lemma_100214 (h0 : ordered_comm_monoid (has_nndist (finset (finset pos)))) : has_exists_mul_of_le (has_nndist (finset (finset pos))) := sorry --non-trivial
lemma new_lemma_100215 (h0 : not (function.extfun Type topological_space -> false)) : @locally_compact_space.{0} linarith.comp_source (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) linarith.comp_source)  := sorry --non-trivial
lemma new_lemma_100216 (h0 : functor.add_const (cancel_comm_monoid_with_zero (add_cancel_monoid linarith.comp)) linarith.comp) : @unique_factorization_monoid.{0} (add_cancel_monoid.{0} linarith.comp) (@functor.add_const.run.{0 0} (cancel_comm_monoid_with_zero.{0} (add_cancel_monoid.{0} linarith.comp)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_100217 (h0 : topological_space char) (h1 : set (set char)) : topological_space.is_topological_basis h1 := sorry --non-trivial
lemma new_lemma_100218 (h0 : function.extfun (finset Type) (has_mem.mem string_imp)) : @locally_compact_space.{0} string_imp (@finset.pi.empty.{1 0} Type topological_space.{0} string_imp (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) string_imp) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_100219 (h0 : functor.add_const (topological_space (boolean_algebra pos)) linarith.comp) : @normal_space.{0} (boolean_algebra.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (boolean_algebra.{0} pos)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_100220 (h0 : prod environment.implicit_infer_kind environment.implicit_infer_kind) : set.diagonal environment.implicit_infer_kind h0 := sorry --non-trivial
lemma new_lemma_100221 (h0 : topological_space (has_zero unsigned)) : totally_disconnected_space (has_zero unsigned) := sorry --non-trivial
lemma new_lemma_100222 (h0 : not (topological_space (has_lt char) -> false)) : @totally_disconnected_space.{0} (has_lt.{0} char) (@classical.by_contradiction'.{1} (topological_space.{0} (has_lt.{0} char)) h0)  := sorry --non-trivial
lemma new_lemma_100223 (h0 : functor.add_const (function.extfun Type ring) name) : @strong_rank_condition.{0} (add_comm_monoid.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type ring.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type ring.{0}) name h0) (add_comm_monoid.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_100224 (h0 : topological_space (sub_neg_monoid (ordered_comm_monoid Type))) : totally_separated_space (sub_neg_monoid (ordered_comm_monoid Type)) := sorry --non-trivial
lemma new_lemma_100225 (h0 : functor.add_const (ring (has_zero pos)) (ring environment.implicit_infer_kind)) : @strong_rank_condition.{0} (has_zero.{0} pos) (@functor.add_const.run.{0 0} (ring.{0} (has_zero.{0} pos)) (ring.{0} environment.implicit_infer_kind) h0)  := sorry --non-trivial
lemma new_lemma_100226 (h0 : group (has_pos_part Type)) (h1 : subgroup (has_pos_part Type)) : subgroup.saturated h1 := sorry --non-trivial
lemma new_lemma_100227 (h0 : ring (non_unital_non_assoc_semiring to_additive.value_type)) : rank_condition (non_unital_non_assoc_semiring to_additive.value_type) := sorry --non-trivial
lemma new_lemma_100228 (h0 : functor.add_const (filter (has_to_string unsigned)) environment.implicit_infer_kind) : filter.ne_bot (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_100229 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @irreducible_space.{0} (has_one.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_one.{0} empty))  := sorry --non-trivial
lemma new_lemma_100230 (h0 : function.extfun Type topological_space) : @regular_space.{0} (has_pos_part.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_pos_part.{0} name))  := sorry --non-trivial
lemma new_lemma_100231 (h0 : add_group (finset (has_neg pos))) : is_add_cyclic (finset (has_neg pos)) := sorry --non-trivial
lemma new_lemma_100232 (h0 : finset (pseudo_metric_space (option (option (option (option num)))))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_100233 (h1 : group (add_right_cancel_monoid to_additive.value_type)) : is_cyclic (add_right_cancel_monoid to_additive.value_type) := sorry --non-trivial
lemma new_lemma_100234 (h0 : finset (finset unsigned)) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_100235 (h0 : functor.add_const (finset (finset pos)) (finset pos)) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_100236 (h0 : not (topological_space (non_unital_non_assoc_semiring enat) -> false)) : @t0_space.{0} (non_unital_non_assoc_semiring.{0} enat) (@classical.by_contradiction'.{1} (topological_space.{0} (non_unital_non_assoc_semiring.{0} enat)) h0)  := sorry --non-trivial
lemma new_lemma_100237 (h0 : function.extfun (Type 1) topological_space) : @locally_compact_space.{1} (ring.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} h0 (ring.{1} Type))  := sorry --non-trivial
lemma new_lemma_100238 (h0 : not (preorder fun_info -> false) -> preorder fun_info) (h1 : nonempty (preorder fun_info)) (h2 : set fun_info) : @set.is_pwo.{0} fun_info (@classical.choice_of_by_contradiction'.{1} (preorder.{0} fun_info) h0 h1) h2  := sorry --non-trivial
lemma new_lemma_100239 (h0 : function.extfun Type topological_space) : @t0_space.{0} (ordered_comm_ring.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (ordered_comm_ring.{0} name))  := sorry --non-trivial
lemma new_lemma_100240 (h0 : topological_space (finset (has_neg (finset Type)))) : loc_path_connected_space (finset (has_neg (finset Type))) := sorry --non-trivial
lemma new_lemma_100241 (h0 : functor.add_const (complete_lattice (plift empty)) empty) : @complete_lattice.is_Sup_finite_compact.{1} (plift.{1} empty) (@functor.add_const.run.{1 0} (complete_lattice.{1} (plift.{1} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_100242 (h0 : not (function.extfun Type complete_lattice -> false)) : @is_atomistic.{0} (random_gen.{0} linarith.ineq) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type complete_lattice.{0}) h0) (random_gen.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_100243 (h0 : functor.add_const (complete_lattice (has_neg_part pos)) pos) : @is_compactly_generated.{0} (has_neg_part.{0} pos) (@functor.add_const.run.{0 0} (complete_lattice.{0} (has_neg_part.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_100244 (h0 : string_imp -> Prop) (h1 : ring (derive_fintype.finset_in h0)) : is_domain (derive_fintype.finset_in h0) := sorry --non-trivial
lemma new_lemma_100245 (h0 : not (function.extfun Type group -> false)) : @group.fg.{0} (distrib_lattice.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type group.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type group.{0}) h0) (distrib_lattice.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_100246 (h0 : add_monoid (normed_lattice_add_comm_group (has_Inf (has_Inf pos)))) : add_monoid.fg (normed_lattice_add_comm_group (has_Inf (has_Inf pos))) := sorry --non-trivial
lemma new_lemma_100247 (h0 : fin has_zero.zero) : @preconnected_space.{0} (normed_lattice_add_comm_group.{0} real) (@function.extfun_app.{2 1} Type topological_space.{0} (@matrix.vec_empty.{1} (function.extfun.{2 1} Type topological_space.{0}) (@function.extfun_app.{1 1} nat fin (@matrix.vec_empty.{0} (function.extfun.{1 1} nat fin) (@matrix.vec_empty.{0} (fin (@has_zero.zero.{0} nat nat.has_zero)) h0)) (@has_zero.zero.{0} nat nat.has_zero))) (normed_lattice_add_comm_group.{0} real))  := sorry --non-trivial
lemma new_lemma_100248 (h0 : function.extfun Type complete_lattice) : @is_atomistic.{0} (finset.{0} ennreal) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (finset.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_100249 (h0 : topological_space (ring (option (option ennreal)))) : preconnected_space (ring (option (option ennreal))) := sorry --non-trivial
lemma new_lemma_100250 (h0 : uniform_space (ring (has_neg (ring pos)))) : separated_space (ring (has_neg (ring pos))) := sorry --non-trivial
lemma new_lemma_100251 (h0 : function.extfun Type topological_space) : @sequential_space.{0} (generalized_boolean_algebra.{0} real) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (generalized_boolean_algebra.{0} real))  := sorry --non-trivial
lemma new_lemma_100252 (h0 : uniform_space (linear_ordered_add_comm_group (linear_ordered_add_comm_group char))) : complete_space (linear_ordered_add_comm_group (linear_ordered_add_comm_group char)) := sorry --non-trivial
lemma new_lemma_100253 (h0 : function.extfun Type topological_space) : @topological_space.separable_space.{0} (bin_tree.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (bin_tree.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_100254 (h0 : semiring (measure_theory.measure_space (semiring num))) : is_noetherian_ring (measure_theory.measure_space (semiring num)) := sorry --non-trivial
lemma new_lemma_100255 (h0 : function.extfun Type (functor.comp topological_space has_nndist)) : @irreducible_space.{0} (has_nndist.{0} pos) (@functor.comp.run.{0 0 0} topological_space.{0} has_nndist.{0} pos (@function.extfun_app.{2 1} Type (functor.comp.{0 0 0} topological_space.{0} has_nndist.{0}) h0 pos))  := sorry --non-trivial
lemma new_lemma_100256 (h1 : to_additive.value_type -> to_additive.value_type -> bool) : is_dec_refl h1 := sorry --non-trivial
lemma new_lemma_100257 (h0 : function.extfun Type filter) : filter.ne_bot (function.extfun_app h0 (ordered_comm_group name)) := sorry --non-trivial
lemma new_lemma_100258 (h0 : functor.add_const (topological_space (has_to_string pos)) linarith.comp) : @totally_disconnected_space.{0} (has_to_string.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (has_to_string.{0} pos)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_100259 (h0 : function.extfun Type ring) : @strong_rank_condition.{0} (has_bot.{0} name) (@function.extfun_app.{2 1} Type ring.{0} h0 (has_bot.{0} name))  := sorry --non-trivial
lemma new_lemma_100260 (h0 : topological_space (boolean_algebra (boolean_algebra environment.implicit_infer_kind))) : totally_separated_space (boolean_algebra (boolean_algebra environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_100261 (h0 : topological_space (cancel_monoid string.iterator_imp)) : t0_space (cancel_monoid string.iterator_imp) := sorry --non-trivial
lemma new_lemma_100262 (h0 : topological_space (plift (semiring empty))) : path_connected_space (plift (semiring empty)) := sorry --non-trivial
lemma new_lemma_100263 (h0 : functor.add_const (ordered_add_comm_monoid (has_pos_part pos)) (has_Inf name)) : @archimedean.{0} (has_pos_part.{0} pos) (@functor.add_const.run.{0 0} (ordered_add_comm_monoid.{0} (has_pos_part.{0} pos)) (has_Inf.{0} name) h0)  := sorry --non-trivial
lemma new_lemma_100264 (h0 : topological_space (left_cancel_monoid (option empty))) : irreducible_space (left_cancel_monoid (option empty)) := sorry --non-trivial
lemma new_lemma_100265 (h1 : ring (encodable linarith.ineq)) : rank_condition (encodable linarith.ineq) := sorry --non-trivial
lemma new_lemma_100266 (h1 : has_neg string.iterator) (h2 : measurable_space string.iterator) : has_measurable_neg string.iterator := sorry --non-trivial
lemma new_lemma_100267 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_cyclic.{0} unsigned (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) unsigned)  := sorry --non-trivial
lemma new_lemma_100268 (h2 : complete_lattice (normed_field linarith.comp_source)) : is_compactly_generated (normed_field linarith.comp_source) := sorry --non-trivial
lemma new_lemma_100269 (h0 : ring (has_inter (option (option ennreal)))) : is_principal_ideal_ring (has_inter (option (option ennreal))) := sorry --non-trivial
lemma new_lemma_100270 (h0 : topological_space (bin_tree (semiring num))) : t0_space (bin_tree (semiring num)) := sorry --non-trivial
lemma new_lemma_100271 (h0 : group (measure_theory.measure_space empty)) : is_cyclic (measure_theory.measure_space empty) := sorry --non-trivial
lemma new_lemma_100272 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_noetherian_ring.{0} (group_with_zero.{0} num) (@function.extfun_app.{2 1} Type semiring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 semiring.{0}) (group_with_zero.{0} num))  := sorry --non-trivial
lemma new_lemma_100273 (h0 : list (ordered_semiring pos)) : palindrome h0 := sorry --non-trivial
lemma new_lemma_100274 (h0 : functor.add_const (list (add_comm_monoid name)) pos) : list.nodup (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_100275 (h0 : topological_space (cancel_monoid (has_add (boolean_algebra.core name)))) : preconnected_space (cancel_monoid (has_add (boolean_algebra.core name))) := sorry --non-trivial
lemma new_lemma_100276 (h0 : not (function.extfun Type complete_lattice -> false)) : @complete_lattice.is_Sup_finite_compact.{0} congr_arg_kind (@function.extfun_app.{2 1} Type complete_lattice.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type complete_lattice.{0}) h0) congr_arg_kind)  := sorry --non-trivial
lemma new_lemma_100277 (h0 : cancel_comm_monoid_with_zero (measure_theory.measure_space (semiring unsigned))) : unique_factorization_monoid (measure_theory.measure_space (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_100278 (h0 : complete_lattice (has_inter (option empty))) : is_atomistic (has_inter (option empty)) := sorry --non-trivial
lemma new_lemma_100279 (h0 : filter (has_add environment.implicit_infer_kind)) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_100280 (h0 : ring (normed_field reducibility_hints)) : invariant_basis_number (normed_field reducibility_hints) := sorry --non-trivial
lemma new_lemma_100281 (h0 : complete_lattice (has_nndist (finset name))) : is_compactly_generated (has_nndist (finset name)) := sorry --non-trivial
lemma new_lemma_100282 (h0 : topological_space (semiring (option (option unsigned)))) : t1_space (semiring (option (option unsigned))) := sorry --non-trivial
lemma new_lemma_100283 (h0 : functor.add_const (topological_space (has_neg pos)) linarith.comp) : @preconnected_space.{0} (has_neg.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (has_neg.{0} pos)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_100284 (h1 : uniform_space (non_unital_non_assoc_semiring reducibility_hints)) : complete_space (non_unital_non_assoc_semiring reducibility_hints) := sorry --non-trivial
lemma new_lemma_100285 (h0 : topological_space (has_pos_part (boolean_algebra (has_pos_part Type)))) : preirreducible_space (has_pos_part (boolean_algebra (has_pos_part Type))) := sorry --non-trivial
lemma new_lemma_100286 (h1 : group (fintype char)) : is_cyclic (fintype char) := sorry --non-trivial
lemma new_lemma_100287 (h0 : add_monoid (add_left_cancel_monoid num)) : add_monoid.fg (add_left_cancel_monoid num) := sorry --non-trivial
lemma new_lemma_100288 (h0 : add_group (has_add real)) : is_add_cyclic (has_add real) := sorry --non-trivial
lemma new_lemma_100289 (h0 : functor.add_const (function.extfun Type ordered_comm_monoid) linarith.comp) : @has_exists_mul_of_le.{0} (ring.{0} pos) (@function.extfun_app.{2 1} Type ordered_comm_monoid.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type ordered_comm_monoid.{0}) linarith.comp h0) (ring.{0} pos))  := sorry --non-trivial
lemma new_lemma_100290 (h0 : ring nnreal) : rank_condition nnreal := sorry --non-trivial
lemma new_lemma_100291 (h0 : not (complete_lattice (add_right_cancel_monoid linarith.ineq) -> false)) : @complete_lattice.is_Sup_finite_compact.{0} (add_right_cancel_monoid.{0} linarith.ineq) (@classical.by_contradiction'.{1} (complete_lattice.{0} (add_right_cancel_monoid.{0} linarith.ineq)) h0)  := sorry --non-trivial
lemma new_lemma_100292 (h1 : linarith.comp_source -> Prop) (h2 : complete_lattice (derive_fintype.finset_in h1)) : complete_lattice.is_Sup_finite_compact (derive_fintype.finset_in h1) := sorry --non-trivial
lemma new_lemma_100293 (h0 : cancel_comm_monoid_with_zero (normed_comm_ring environment.implicit_infer_kind)) : unique_factorization_monoid (normed_comm_ring environment.implicit_infer_kind) := sorry --non-trivial
lemma new_lemma_100294 (h0 : add_monoid (has_norm (has_top empty))) : add_monoid.fg (has_norm (has_top empty)) := sorry --non-trivial
lemma new_lemma_100295 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @rank_condition.{0} (add_cancel_monoid.{0} empty) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (add_cancel_monoid.{0} empty))  := sorry --non-trivial
lemma new_lemma_100296 (h0 : semiring (has_Inf real)) : is_noetherian_ring (has_Inf real) := sorry --non-trivial
lemma new_lemma_100297 (h0 : functor.add_const (list (ring linarith.comp)) name) : list.nodup (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_100298 (h0 : topological_space (has_add Type)) : locally_compact_space (has_add Type) := sorry --non-trivial
lemma new_lemma_100299 (h0 : add_monoid (cancel_monoid Type)) : add_monoid.fg (cancel_monoid Type) := sorry --non-trivial
lemma new_lemma_100300 (h0 : finset (has_pos_part (ring pos))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_100301 (h0 : functor.add_const (topological_space (generalized_boolean_algebra pos)) (has_neg name)) : @totally_separated_space.{0} (generalized_boolean_algebra.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (generalized_boolean_algebra.{0} pos)) (has_neg.{0} name) h0)  := sorry --non-trivial
lemma new_lemma_100302 (h0 : not (group (semi_normed_comm_ring reducibility_hints) -> false)) : @is_cyclic.{0} (semi_normed_comm_ring.{0} reducibility_hints) (@classical.by_contradiction'.{1} (group.{0} (semi_normed_comm_ring.{0} reducibility_hints)) h0)  := sorry --non-trivial
lemma new_lemma_100303 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @path_connected_space.{0} (normed_group.{0} (has_ssubset.{0} string_imp)) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (normed_group.{0} (has_ssubset.{0} string_imp)))  := sorry --non-trivial
lemma new_lemma_100304 (h0 : list (complete_semilattice_Sup (has_top fun_info))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_100305 (h0 : add_monoid (has_neg (has_to_string linarith.comp))) : add_monoid.fg (has_neg (has_to_string linarith.comp)) := sorry --non-trivial
lemma new_lemma_100306 (h0 : function.extfun Type topological_space) : @normal_space.{0} (non_assoc_semiring.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (non_assoc_semiring.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_100307 (h0 : group (has_Inf (has_neg name))) : normalizer_condition (has_Inf (has_neg name)) := sorry --non-trivial
lemma new_lemma_100308 (h0 : function.extfun Type topological_space) : @totally_separated_space.{0} (add_cancel_comm_monoid.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (add_cancel_comm_monoid.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_100309 (h0 : not (has_mem.mem (has_emptyc linarith.ineq) has_emptyc.emptyc -> false)) : @path_connected_space.{0} (has_emptyc.{0} linarith.ineq) (@finset.pi.empty.{1 0} Type topological_space.{0} (has_emptyc.{0} linarith.ineq) (@classical.by_contradiction'.{0} (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (has_emptyc.{0} linarith.ineq) (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))) h0))  := sorry --non-trivial
lemma new_lemma_100310 (h0 : topological_space (semi_normed_comm_ring (has_nnnorm char))) : t0_space (semi_normed_comm_ring (has_nnnorm char)) := sorry --non-trivial
lemma new_lemma_100311 (h0 : ring (has_nnnorm (mul_one_class (has_to_string char)))) : is_domain (has_nnnorm (mul_one_class (has_to_string char))) := sorry --non-trivial
lemma new_lemma_100312 (h0 : not (topological_space (has_inv linarith.comp_source) -> false)) : @path_connected_space.{0} (has_inv.{0} linarith.comp_source) (@classical.by_contradiction'.{1} (topological_space.{0} (has_inv.{0} linarith.comp_source)) h0)  := sorry --non-trivial
lemma new_lemma_100313 (h0 : functor.add_const (function.extfun (Type 1) group) environment.implicit_infer_kind) : @is_simple_group.{1} (has_zero.{1} Type) (@function.extfun_app.{3 2} (Type 1) group.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) group.{1}) environment.implicit_infer_kind h0) (has_zero.{1} Type))  := sorry --non-trivial
lemma new_lemma_100314 (h0 : finset (simple_graph (generalized_boolean_algebra (ordered_comm_ring (has_Inf (ring pos)))))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_100315 (h0 : topological_space (normed_comm_ring (comm_group (comm_group (comm_group Type))))) : regular_space (normed_comm_ring (comm_group (comm_group (comm_group Type)))) := sorry --non-trivial
lemma new_lemma_100316 (h1 : ring (has_top (has_inv (random_gen linarith.ineq)))) : rank_condition (has_top (has_inv (random_gen linarith.ineq))) := sorry --non-trivial
lemma new_lemma_100317 (h0 : has_mem.mem ring has_emptyc.emptyc) : @is_domain.{0} empty (@function.extfun_app.{2 1} Type ring.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) ring.{0} h0) empty)  := sorry --non-trivial
lemma new_lemma_100318 (h0 : functor.comp topological_space canonically_ordered_comm_semiring Type) : @topological_space.separable_space.{1} (canonically_ordered_comm_semiring.{1} Type) (@functor.comp.run.{1 1 1} topological_space.{1} canonically_ordered_comm_semiring.{1} Type h0)  := sorry --non-trivial
lemma new_lemma_100319 (h0 : group (has_bot (has_Inf (has_Inf (has_Inf pos))))) : group.fg (has_bot (has_Inf (has_Inf (has_Inf pos)))) := sorry --non-trivial
lemma new_lemma_100320 (h0 : semiring (has_norm (random_gen to_additive.value_type))) (h1 : ideal (has_norm (random_gen to_additive.value_type))) : ideal.is_prime h1 := sorry --non-trivial
lemma new_lemma_100321 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @normal_space.{0} (canonically_linear_ordered_monoid.{0} ennreal) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (canonically_linear_ordered_monoid.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_100322 (h0 : finset (partial_order (semiring (semiring num)))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_100323 (h1 : not (add_group (distrib char) -> false)) : @is_add_cyclic.{0} (distrib.{0} char) (@classical.by_contradiction'.{1} (add_group.{0} (distrib.{0} char)) h1)  := sorry --non-trivial
lemma new_lemma_100324 (h0 : not (ring (denumerable reducibility_hints) -> false)) : @rank_condition.{0} (denumerable.{0} reducibility_hints) (@classical.by_contradiction'.{1} (ring.{0} (denumerable.{0} reducibility_hints)) h0)  := sorry --non-trivial
lemma new_lemma_100325 (h0 : ordered_add_comm_monoid (non_assoc_semiring (semiring unsigned))) : archimedean (non_assoc_semiring (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_100326 (h0 : not (ring (linear_ordered_add_comm_group linarith.comp_source) -> false)) : @strong_rank_condition.{0} (linear_ordered_add_comm_group.{0} linarith.comp_source) (@classical.by_contradiction'.{1} (ring.{0} (linear_ordered_add_comm_group.{0} linarith.comp_source)) h0)  := sorry --non-trivial
lemma new_lemma_100327 (h0 : functor.add_const (finset (ordered_ring empty)) unsigned) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_100328 (h5 h6 : multiset char) : multiset.disjoint h5 h6 := sorry --non-trivial
lemma new_lemma_100329 (h0 : topological_space (has_ssubset (mul_one_class environment.projection_info))) : totally_disconnected_space (has_ssubset (mul_one_class environment.projection_info)) := sorry --non-trivial
lemma new_lemma_100330 (h0 : functor.add_const (topological_space (has_neg name)) linarith.comp) : @preirreducible_space.{0} (has_neg.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (has_neg.{0} name)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_100331 (h0 : functor.add_const (semiring (left_cancel_monoid num)) (semiring empty)) : @is_noetherian_ring.{0} (left_cancel_monoid.{0} num) (@functor.add_const.run.{0 0} (semiring.{0} (left_cancel_monoid.{0} num)) (semiring.{0} empty) h0)  := sorry --non-trivial
lemma new_lemma_100332 (h0 : functor.add_const (group (has_nndist linarith.comp)) Type) : @normalizer_condition.{0} (has_nndist.{0} linarith.comp) (@functor.add_const.run.{0 1} (group.{0} (has_nndist.{0} linarith.comp)) Type h0)  := sorry --non-trivial
lemma new_lemma_100333 (h0 : preorder (has_append linarith.comp_source)) (h1 : pred_order (has_append linarith.comp_source)) : is_pred_archimedean (has_append linarith.comp_source) := sorry --non-trivial
lemma new_lemma_100334 (h0 : function.extfun Type ring) : @rank_condition.{0} (random_gen.{0} unsigned) (@function.extfun_app.{2 1} Type ring.{0} h0 (random_gen.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_100335 (h0 : add_group (add_left_cancel_monoid linarith.comp_source)) : is_add_cyclic (add_left_cancel_monoid linarith.comp_source) := sorry --non-trivial
lemma new_lemma_100336 (h0 : function.extfun Type topological_space) : @totally_separated_space.{0} (option.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (option.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_100337 (h0 : function.extfun Type topological_space) : @t0_space.{0} to_additive.value_type (@function.extfun_app.{2 1} Type topological_space.{0} h0 to_additive.value_type)  := sorry --non-trivial
lemma new_lemma_100338 (h0 : topological_space (ordered_comm_monoid (has_pos_part Type))) : totally_separated_space (ordered_comm_monoid (has_pos_part Type)) := sorry --non-trivial
lemma new_lemma_100339 (h2 : not (ring (has_append fun_info) -> false)) : @strong_rank_condition.{0} (has_append.{0} fun_info) (@classical.by_contradiction'.{1} (ring.{0} (has_append.{0} fun_info)) h2)  := sorry --non-trivial
lemma new_lemma_100340 (h0 : functor.add_const (complete_lattice (normed_linear_ordered_group empty)) num) : @is_compactly_generated.{0} (normed_linear_ordered_group.{0} empty) (@functor.add_const.run.{0 0} (complete_lattice.{0} (normed_linear_ordered_group.{0} empty)) num h0)  := sorry --non-trivial
lemma new_lemma_100341 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : list.nodup (function.extfun_app (function.extfun_app h0 list) (has_top fun_info)) := sorry --non-trivial
lemma new_lemma_100342 (h0 : functor.add_const (ordered_comm_monoid (boolean_algebra Type)) environment.implicit_infer_kind) : @has_exists_mul_of_le.{1} (boolean_algebra.{1} Type) (@functor.add_const.run.{1 0} (ordered_comm_monoid.{1} (boolean_algebra.{1} Type)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_100343 (h0 : topological_space (has_append (random_gen linarith.ineq))) : t0_space (has_append (random_gen linarith.ineq)) := sorry --non-trivial
lemma new_lemma_100344 (h0 : topological_space (canonically_ordered_monoid Type)) : totally_disconnected_space (canonically_ordered_monoid Type) := sorry --non-trivial
lemma new_lemma_100345 (h0 : functor.add_const (complete_lattice (left_cancel_monoid empty)) congr_arg_kind) : @complete_lattice.is_Sup_finite_compact.{0} (left_cancel_monoid.{0} empty) (@functor.add_const.run.{0 0} (complete_lattice.{0} (left_cancel_monoid.{0} empty)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_100346 (h0 : topological_space (ordered_comm_monoid linarith.comp)) : discrete_topology (ordered_comm_monoid linarith.comp) := sorry --non-trivial
lemma new_lemma_100347 (h0 : uniform_space (has_union unsigned)) : separated_space (has_union unsigned) := sorry --non-trivial
lemma new_lemma_100348 (h0 : topological_space (add_comm_semigroup char)) : noncompact_space (add_comm_semigroup char) := sorry --non-trivial
lemma new_lemma_100349 (h0 : functor.add_const (complete_lattice (finset name)) name) : @is_atomistic.{0} (finset.{0} name) (@functor.add_const.run.{0 0} (complete_lattice.{0} (finset.{0} name)) name h0)  := sorry --non-trivial
lemma new_lemma_100350 (h0 : topological_space (has_le (mul_one_class string.iterator_imp))) : totally_disconnected_space (has_le (mul_one_class string.iterator_imp)) := sorry --non-trivial
lemma new_lemma_100351 (h0 : function.extfun Type ring) : @rank_condition.{0} (has_norm.{0} fun_info) (@function.extfun_app.{2 1} Type ring.{0} h0 (has_norm.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_100352 (h0 : function.extfun Type topological_space) : @preirreducible_space.{0} (has_to_string.{0} ennreal) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_to_string.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_100353 (h0 : filter (with_bot (random_gen (random_gen fun_info)))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_100354 (h2 : topological_space (normed_field (uniform_space (comm_ring linarith.ineq)))) : t0_space (normed_field (uniform_space (comm_ring linarith.ineq))) := sorry --non-trivial
lemma new_lemma_100355 (h0 : cancel_comm_monoid_with_zero (has_to_string (has_neg Type))) : unique_factorization_monoid (has_to_string (has_neg Type)) := sorry --non-trivial
lemma new_lemma_100356 (h0 : topological_space (has_ssubset (has_inv to_additive.value_type))) : totally_disconnected_space (has_ssubset (has_inv to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_100357 (h0 : cancel_comm_monoid_with_zero (has_to_string (finset (has_pos_part linarith.comp)))) : unique_factorization_monoid (has_to_string (finset (has_pos_part linarith.comp))) := sorry --non-trivial
lemma new_lemma_100358 (h0 : topological_space (finset (has_add pos))) : t0_space (finset (has_add pos)) := sorry --non-trivial
lemma new_lemma_100359 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @topological_space.separable_space.{0} (canonically_ordered_comm_semiring.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (canonically_ordered_comm_semiring.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_100360 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @sequential_space.{1} (comm_group.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 topological_space.{1}) (comm_group.{1} Type))  := sorry --non-trivial
lemma new_lemma_100361 (h0 : functor.add_const (add_monoid (add_comm_monoid pos)) environment.implicit_infer_kind) : @add_monoid.fg.{0} (add_comm_monoid.{0} pos) (@functor.add_const.run.{0 0} (add_monoid.{0} (add_comm_monoid.{0} pos)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_100362 (h1 : ring (has_zero char)) : rank_condition (has_zero char) := sorry --non-trivial
lemma new_lemma_100363 (h0 : functor.add_const (add_group (add_cancel_monoid name)) name) : @is_add_cyclic.{0} (add_cancel_monoid.{0} name) (@functor.add_const.run.{0 0} (add_group.{0} (add_cancel_monoid.{0} name)) name h0)  := sorry --non-trivial
lemma new_lemma_100364 (h0 : topological_space (ordered_comm_monoid (has_add name))) : t0_space (ordered_comm_monoid (has_add name)) := sorry --non-trivial
lemma new_lemma_100365 (h0 : uniform_space (monoid_with_zero (option (option pos)))) : separated_space (monoid_with_zero (option (option pos))) := sorry --non-trivial
lemma new_lemma_100366 (h0 : not (add_group (linear_ordered_add_comm_group (has_nnnorm linarith.ineq)) -> false)) : @is_add_cyclic.{0} (linear_ordered_add_comm_group.{0} (has_nnnorm.{0} linarith.ineq)) (@classical.by_contradiction'.{1} (add_group.{0} (linear_ordered_add_comm_group.{0} (has_nnnorm.{0} linarith.ineq))) h0)  := sorry --non-trivial
lemma new_lemma_100367 (h0 : group (add_semigroup (semiring (semiring empty)))) : normalizer_condition (add_semigroup (semiring (semiring empty))) := sorry --non-trivial
lemma new_lemma_100368 (h0 : functor.add_const (ring (ring name)) Type) : @is_domain.{0} (ring.{0} name) (@functor.add_const.run.{0 1} (ring.{0} (ring.{0} name)) Type h0)  := sorry --non-trivial
lemma new_lemma_100369 (h0 : function.extfun Type add_monoid) : @add_monoid.fg.{0} (measurable_space.{0} linarith.comp) (@function.extfun_app.{2 1} Type add_monoid.{0} h0 (measurable_space.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_100370 (h0 : fin has_zero.zero) : @preirreducible_space.{0} (has_add.{0} pos) (@matrix.vec_empty.{0} (topological_space.{0} (has_add.{0} pos)) h0)  := sorry --non-trivial
lemma new_lemma_100371 (h0 : topological_space linarith.comp_source) : normal_space linarith.comp_source := sorry --non-trivial
lemma new_lemma_100372 (h0 : functor.add_const (function.extfun Type topological_space) linarith.comp) : @preconnected_space.{0} (has_to_string.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) linarith.comp h0) (has_to_string.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_100373 (h0 : topological_space (ordered_comm_ring (has_neg linarith.comp))) : preconnected_space (ordered_comm_ring (has_neg linarith.comp)) := sorry --non-trivial
lemma new_lemma_100374 (h1 : group (with_one fun_info)) : normalizer_condition (with_one fun_info) := sorry --non-trivial
lemma new_lemma_100375 (h0 : function.extfun Type topological_space) : @totally_disconnected_space.{0} (as_linear_order.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (as_linear_order.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_100376 (h0 : ring (canonically_linear_ordered_monoid name)) : strong_rank_condition (canonically_linear_ordered_monoid name) := sorry --non-trivial
lemma new_lemma_100377 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @locally_compact_space.{0} (cancel_monoid.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (cancel_monoid.{0} empty))  := sorry --non-trivial
lemma new_lemma_100378 (h0 : functor.add_const (ring (has_add environment.implicit_infer_kind)) Type) : @strong_rank_condition.{0} (has_add.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 1} (ring.{0} (has_add.{0} environment.implicit_infer_kind)) Type h0)  := sorry --non-trivial
lemma new_lemma_100379 (h0 : semiring (preorder empty) -> semiring (preorder empty) -> Prop) : is_strict_order (semiring (preorder empty)) h0 := sorry --non-trivial
lemma new_lemma_100380 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_cyclic.{0} (has_to_string.{0} name) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (has_to_string.{0} name))  := sorry --non-trivial
lemma new_lemma_100381 (h0 : topological_space (has_to_string (has_nndist (has_pos_part (has_to_string pos))))) : topological_space.separable_space (has_to_string (has_nndist (has_pos_part (has_to_string pos)))) := sorry --non-trivial
lemma new_lemma_100382 (h0 : functor.add_const (group (has_to_string name)) name) : @group.fg.{0} (has_to_string.{0} name) (@functor.add_const.run.{0 0} (group.{0} (has_to_string.{0} name)) name h0)  := sorry --non-trivial
lemma new_lemma_100383 (h0 : function.extfun Type topological_space) : @t0_space.{0} (canonically_ordered_comm_semiring.{0} ennreal) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (canonically_ordered_comm_semiring.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_100384 (h0 : not (ring (option congr_arg_kind) -> false)) : @rank_condition.{0} (option.{0} congr_arg_kind) (@classical.by_contradiction'.{1} (ring.{0} (option.{0} congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_100385 (h0 : complete_lattice (semiring to_additive.value_type)) : complete_lattice.is_Sup_finite_compact (semiring to_additive.value_type) := sorry --non-trivial
lemma new_lemma_100386 (h0 : set (random_gen char)) : set.subsingleton h0 := sorry --non-trivial
lemma new_lemma_100387 (h0 : functor.add_const (topological_space (add_comm_monoid name)) Type) : @t1_space.{0} (add_comm_monoid.{0} name) (@functor.add_const.run.{0 1} (topological_space.{0} (add_comm_monoid.{0} name)) Type h0)  := sorry --non-trivial
lemma new_lemma_100388 (h0 : topological_space (normed_comm_ring linarith.comp)) : loc_path_connected_space (normed_comm_ring linarith.comp) := sorry --non-trivial
lemma new_lemma_100389 (h0 : fin has_zero.zero) : @normal_space.{0} (has_bot.{0} real) (@matrix.vec_empty.{0} (topological_space.{0} (has_bot.{0} real)) (@matrix.vec_empty.{0} (fin (@has_zero.zero.{0} nat nat.has_zero)) (@matrix.vec_empty.{0} (fin (@has_zero.zero.{0} nat nat.has_zero)) (@matrix.vec_empty.{0} (fin (@has_zero.zero.{0} nat nat.has_zero)) h0))))  := sorry --non-trivial
lemma new_lemma_100390 (h0 : add_group (comm_group pos)) : is_add_cyclic (comm_group pos) := sorry --non-trivial
lemma new_lemma_100391 (h0 : topological_space (sub_neg_monoid (has_Inf (has_Inf name)))) : path_connected_space (sub_neg_monoid (has_Inf (has_Inf name))) := sorry --non-trivial
lemma new_lemma_100392 (h0 : functor.add_const (topological_space (has_zero environment.implicit_infer_kind)) environment.implicit_infer_kind) : @sequential_space.{0} (has_zero.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (has_zero.{0} environment.implicit_infer_kind)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_100393 (h0 : functor.add_const (ordered_add_comm_monoid (finset linarith.comp)) (has_to_string (has_to_string unsigned))) : @archimedean.{0} (finset.{0} linarith.comp) (@functor.add_const.run.{0 0} (ordered_add_comm_monoid.{0} (finset.{0} linarith.comp)) (has_to_string.{0} (has_to_string.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_100394 (h1 : not (monoid (normed_group to_additive.value_type) -> false)) : @monoid.fg.{0} (normed_group.{0} to_additive.value_type) (@classical.by_contradiction'.{1} (monoid.{0} (normed_group.{0} to_additive.value_type)) h1)  := sorry --non-trivial
lemma new_lemma_100395 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_atomistic.{0} (has_edist.{0} empty) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (has_edist.{0} empty))  := sorry --non-trivial
lemma new_lemma_100396 (h0 : fin has_zero.zero) : @t1_space.{0} (ordered_comm_monoid.{0} pos) (@matrix.vec_empty.{0} (topological_space.{0} (ordered_comm_monoid.{0} pos)) h0)  := sorry --non-trivial
lemma new_lemma_100397 (h0 : function.extfun Type complete_lattice) : @is_atomistic.{0} (canonically_ordered_monoid.{0} pos) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (canonically_ordered_monoid.{0} pos))  := sorry --non-trivial
lemma new_lemma_100398 (h0 : topological_space fun_info) : t0_space fun_info := sorry --non-trivial
lemma new_lemma_100399 (h0 : not (ring (has_compl reducibility_hints) -> false)) : @rank_condition.{0} (has_compl.{0} reducibility_hints) (@classical.by_contradiction'.{1} (ring.{0} (has_compl.{0} reducibility_hints)) h0)  := sorry --non-trivial
lemma new_lemma_100400 (h0 : semiring (add_group (add_group linarith.comp))) : is_noetherian_ring (add_group (add_group linarith.comp)) := sorry --non-trivial
lemma new_lemma_100401 (h0 : function.extfun Type topological_space) : @t0_space.{0} (pseudo_metric_space.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (pseudo_metric_space.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_100402 (h0 : function.extfun Type add_monoid) : @add_monoid.fg.{0} (boolean_algebra.core.{0} pos) (@function.extfun_app.{2 1} Type add_monoid.{0} h0 (boolean_algebra.core.{0} pos))  := sorry --non-trivial
lemma new_lemma_100403 (h5 : ring (topological_space linarith.comp_source)) : is_domain (topological_space linarith.comp_source) := sorry --non-trivial
lemma new_lemma_100404 (h0 : ring (distrib (random_gen (random_gen char)))) : strong_rank_condition (distrib (random_gen (random_gen char))) := sorry --non-trivial
lemma new_lemma_100405 (h0 : function.extfun Type topological_space) : @loc_path_connected_space.{0} name (@function.extfun_app.{2 1} Type topological_space.{0} h0 name)  := sorry --non-trivial
lemma new_lemma_100406 (h1 : topological_space (normed_group linarith.ineq)) : locally_compact_space (normed_group linarith.ineq) := sorry --non-trivial
lemma new_lemma_100407 (h0 : functor.add_const (ordered_add_comm_monoid (ring linarith.comp)) (ring (has_neg name))) : @archimedean.{0} (ring.{0} linarith.comp) (@functor.add_const.run.{0 0} (ordered_add_comm_monoid.{0} (ring.{0} linarith.comp)) (ring.{0} (has_neg.{0} name)) h0)  := sorry --non-trivial
lemma new_lemma_100408 (h0 : functor.add_const (cancel_comm_monoid_with_zero (ordered_ring empty)) num) : @unique_factorization_monoid.{0} (ordered_ring.{0} empty) (@functor.add_const.run.{0 0} (cancel_comm_monoid_with_zero.{0} (ordered_ring.{0} empty)) num h0)  := sorry --non-trivial
lemma new_lemma_100409 (h0 : functor.add_const (topological_space (has_to_string pos)) environment.implicit_infer_kind) : @locally_compact_space.{0} (has_to_string.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (has_to_string.{0} pos)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_100410 (h0 : functor.add_const (group (comm_group environment.implicit_infer_kind)) (has_nndist (finset Type))) : @is_simple_group.{0} (comm_group.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 1} (group.{0} (comm_group.{0} environment.implicit_infer_kind)) (has_nndist.{1} (finset.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_100411 (h0 : topological_space (mul_zero_class pos)) : irreducible_space (mul_zero_class pos) := sorry --non-trivial
lemma new_lemma_100412 (h0 : functor.add_const (function.extfun (Type 1) monoid) Type) : @monoid.fg.{1} (has_add.{1} Type) (@function.extfun_app.{3 2} (Type 1) monoid.{1} (@functor.add_const.run.{2 1} (function.extfun.{3 2} (Type 1) monoid.{1}) Type h0) (has_add.{1} Type))  := sorry --non-trivial
lemma new_lemma_100413 (h0 : complete_lattice (boolean_algebra (has_add (comm_group unsigned)))) : is_atomistic (boolean_algebra (has_add (comm_group unsigned))) := sorry --non-trivial
lemma new_lemma_100414 (h0 : topological_space (has_zero name)) : t1_space (has_zero name) := sorry --non-trivial
lemma new_lemma_100415 (h0 : topological_space (canonically_ordered_monoid (has_Inf pos))) : preirreducible_space (canonically_ordered_monoid (has_Inf pos)) := sorry --non-trivial
lemma new_lemma_100416 (h1 : add_group (normed_field (normed_field reducibility_hints))) : is_add_cyclic (normed_field (normed_field reducibility_hints)) := sorry --non-trivial
lemma new_lemma_100417 (h0 : functor.comp ring mul_zero_class Type) : @is_domain.{1} (mul_zero_class.{1} Type) (@functor.comp.run.{1 1 1} ring.{1} mul_zero_class.{1} Type h0)  := sorry --non-trivial
lemma new_lemma_100418 (h0 : ring (simple_graph (boolean_algebra.core linarith.comp))) : is_domain (simple_graph (boolean_algebra.core linarith.comp)) := sorry --non-trivial
lemma new_lemma_100419 (h0 : uniform_space (has_norm (has_top unsigned))) : separated_space (has_norm (has_top unsigned)) := sorry --non-trivial
lemma new_lemma_100420 (h0 : functor.add_const (group (add_comm_monoid name)) name) : @normalizer_condition.{0} (add_comm_monoid.{0} name) (@functor.add_const.run.{0 0} (group.{0} (add_comm_monoid.{0} name)) name h0)  := sorry --non-trivial
lemma new_lemma_100421 (h0 : fin has_zero.zero) : @is_cyclic.{0} (ring.{0} real) (@matrix.vec_empty.{0} (group.{0} (ring.{0} real)) h0)  := sorry --non-trivial
lemma new_lemma_100422 (h0 : ring (with_bot string_imp)) : rank_condition (with_bot string_imp) := sorry --non-trivial
lemma new_lemma_100423 (h0 : ring (measurable_space.dynkin_system (semiring (semiring unsigned)))) : rank_condition (measurable_space.dynkin_system (semiring (semiring unsigned))) := sorry --non-trivial
lemma new_lemma_100424 (h0 : topological_space (has_neg unsigned)) : discrete_topology (has_neg unsigned) := sorry --non-trivial
lemma new_lemma_100425 (h0 : function.extfun (finset Type) (has_mem.mem (random_gen num))) : @monoid.fg.{0} (random_gen.{0} num) (@finset.pi.empty.{1 0} Type monoid.{0} (random_gen.{0} num) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (random_gen.{0} num)) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_100426 (h0 : monoid (id (has_top (semiring (has_top empty))))) : monoid.fg (id (has_top (semiring (has_top empty)))) := sorry --non-trivial
lemma new_lemma_100427 (h0 : functor.add_const (complete_lattice (normed_comm_ring ennreal)) num) : @complete_lattice.is_Sup_finite_compact.{0} (normed_comm_ring.{0} ennreal) (@functor.add_const.run.{0 0} (complete_lattice.{0} (normed_comm_ring.{0} ennreal)) num h0)  := sorry --non-trivial
lemma new_lemma_100428 (h0 : function.extfun Type topological_space) : @sequential_space.{0} (ordered_comm_monoid.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (ordered_comm_monoid.{0} name))  := sorry --non-trivial
lemma new_lemma_100429 (h0 : set (has_lt (mul_one_class linarith.comp_source))) : set.finite h0 := sorry --non-trivial
lemma new_lemma_100430 (h0 : uniform_space (cancel_monoid (cancel_monoid environment.implicit_infer_kind))) : separated_space (cancel_monoid (cancel_monoid environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_100431 (h0 : functor.add_const (list (linear_ordered_field empty)) empty) : palindrome (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_100432 (h0 : complete_lattice (boolean_algebra (has_neg (has_neg linarith.comp)))) : is_compactly_generated (boolean_algebra (has_neg (has_neg linarith.comp))) := sorry --non-trivial
lemma new_lemma_100433 (h0 : function.extfun Type (functor.add_const (group pos))) : @is_simple_group.{0} pos (@functor.add_const.run.{0 0} (group.{0} pos) unsigned (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (group.{0} pos)) h0 unsigned))  := sorry --non-trivial
lemma new_lemma_100434 (h0 : function.extfun nat fin) : @is_domain.{0} (has_bot.{0} linarith.comp) (@matrix.vec_empty.{0} (ring.{0} (has_bot.{0} linarith.comp)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_100435 (h0 : topological_space (has_to_string (has_neg linarith.comp))) : path_connected_space (has_to_string (has_neg linarith.comp)) := sorry --non-trivial
lemma new_lemma_100436 (h2 : ring (has_div to_additive.value_type)) : rank_condition (has_div to_additive.value_type) := sorry --non-trivial
lemma new_lemma_100437 (h0 : functor.add_const (group (plift congr_arg_kind)) num) : @group.fg.{1} (plift.{1} congr_arg_kind) (@functor.add_const.run.{1 0} (group.{1} (plift.{1} congr_arg_kind)) num h0)  := sorry --non-trivial
lemma new_lemma_100438 (h0 : complete_lattice (partial_order (semiring num))) : is_compactly_generated (partial_order (semiring num)) := sorry --non-trivial
lemma new_lemma_100439 (h0 : group (plift (has_norm empty))) : group.fg (plift (has_norm empty)) := sorry --non-trivial
lemma new_lemma_100440 (h0 : fin has_zero.zero) : @add_monoid.fg.{0} (has_Inf.{0} real) (@matrix.vec_empty.{0} (add_monoid.{0} (has_Inf.{0} real)) h0)  := sorry --non-trivial
lemma new_lemma_100441 (h0 : functor.add_const (finset (add_cancel_monoid pos)) environment.implicit_infer_kind) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_100442 (h2 : complete_lattice (has_compl char)) : is_compactly_generated (has_compl char) := sorry --non-trivial
lemma new_lemma_100443 (h0 : functor.add_const (list (ring name)) Type) : palindrome (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_100444 (h0 : not (ring (add_cancel_comm_monoid reducibility_hints) -> false)) : @strong_rank_condition.{0} (add_cancel_comm_monoid.{0} reducibility_hints) (@classical.by_contradiction'.{1} (ring.{0} (add_cancel_comm_monoid.{0} reducibility_hints)) h0)  := sorry --non-trivial
lemma new_lemma_100445 (h0 : function.extfun Type (functor.add_const (topological_space (measurable_space.dynkin_system unsigned)))) : @loc_path_connected_space.{0} (measurable_space.dynkin_system.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (measurable_space.dynkin_system.{0} unsigned)) congr_arg_kind (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (topological_space.{0} (measurable_space.dynkin_system.{0} unsigned))) h0 congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_100446 (h0 : group (mul_zero_class pos)) : normalizer_condition (mul_zero_class pos) := sorry --non-trivial
lemma new_lemma_100447 (h0 : topological_space (semi_normed_comm_ring fun_info)) : irreducible_space (semi_normed_comm_ring fun_info) := sorry --non-trivial
lemma new_lemma_100448 (h0 : topological_space (has_top linarith.comp)) : irreducible_space (has_top linarith.comp) := sorry --non-trivial
lemma new_lemma_100449 (h0 : uniform_space (add_cancel_monoid (has_add (has_zero environment.implicit_infer_kind)))) : complete_space (add_cancel_monoid (has_add (has_zero environment.implicit_infer_kind))) := sorry --non-trivial
lemma new_lemma_100450 (h0 : ring (cancel_monoid (boolean_algebra.core environment.implicit_infer_kind))) : is_domain (cancel_monoid (boolean_algebra.core environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_100451 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @loc_path_connected_space.{0} auto.case_option (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) auto.case_option)  := sorry --non-trivial
lemma new_lemma_100452 (h0 : fin has_zero.zero) : @is_cyclic.{0} (sub_neg_monoid.{0} real) (@function.extfun_app.{2 1} Type group.{0} (@matrix.vec_empty.{1} (function.extfun.{2 1} Type group.{0}) h0) (sub_neg_monoid.{0} real))  := sorry --non-trivial
lemma new_lemma_100453 (h0 : ordered_comm_monoid (cancel_monoid (boolean_algebra environment.implicit_infer_kind))) : has_exists_mul_of_le (cancel_monoid (boolean_algebra environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_100454 (h0 : ring (semi_normed_ring string.iterator_imp)) : is_domain (semi_normed_ring string.iterator_imp) := sorry --non-trivial
lemma new_lemma_100455 (h0 : ordered_add_comm_monoid (has_to_string (complete_distrib_lattice pos))) : archimedean (has_to_string (complete_distrib_lattice pos)) := sorry --non-trivial
lemma new_lemma_100456 (h0 : monoid (has_to_string (finset pos))) : monoid.fg (has_to_string (finset pos)) := sorry --non-trivial
lemma new_lemma_100457 (h0 : topological_space (add_left_cancel_semigroup (option unsigned))) : normal_space (add_left_cancel_semigroup (option unsigned)) := sorry --non-trivial
lemma new_lemma_100458 (h0 : prod (has_neg (option unsigned)) (has_neg (option unsigned))) : id_rel h0 := sorry --non-trivial
lemma new_lemma_100459 (h0 : functor.add_const (topological_space (add_comm_monoid name)) (boolean_algebra pos)) : @t1_space.{0} (add_comm_monoid.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (add_comm_monoid.{0} name)) (boolean_algebra.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_100460 (h0 : function.extfun Type complete_lattice) : @complete_lattice.is_Sup_finite_compact.{0} (linear_ordered_semiring.{0} empty) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (linear_ordered_semiring.{0} empty))  := sorry --non-trivial
lemma new_lemma_100461 (h0 : group (has_norm (has_nnnorm linarith.comp_source))) : group.fg (has_norm (has_nnnorm linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_100462 (h0 : functor.add_const (list (boolean_algebra pos)) Type) : list.nodup (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_100463 (h0 : fin has_zero.zero) : @preirreducible_space.{0} (comm_semigroup.{0} pos) (@matrix.vec_empty.{0} (topological_space.{0} (comm_semigroup.{0} pos)) h0)  := sorry --non-trivial
lemma new_lemma_100464 (h0 : functor.add_const (topological_space (finset Type)) (finset environment.implicit_infer_kind)) : @discrete_topology.{1} (finset.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (finset.{1} Type)) (finset.{0} environment.implicit_infer_kind) h0)  := sorry --non-trivial
lemma new_lemma_100465 (h0 : function.extfun Type topological_space) : @normal_space.{0} (has_one.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_one.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_100466 (h0 : group (has_neg environment.implicit_infer_kind)) : is_simple_group (has_neg environment.implicit_infer_kind) := sorry --non-trivial
lemma new_lemma_100467 (h0 : function.extfun Type list) : palindrome (function.extfun_app h0 (group_with_zero ennreal)) := sorry --non-trivial
lemma new_lemma_100468 (h0 : uniform_space (boolean_algebra.core (has_neg Type))) : separated_space (boolean_algebra.core (has_neg Type)) := sorry --non-trivial
lemma new_lemma_100469 (h2 : function.extfun Type add_group) : @is_add_cyclic.{0} (with_one.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type add_group.{0} h2 (with_one.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_100470 (h0 : ring (ordered_comm_ring (ordered_comm_monoid real))) : rank_condition (ordered_comm_ring (ordered_comm_monoid real)) := sorry --non-trivial
lemma new_lemma_100471 (h0 : ring (semiring (has_norm (has_top (semiring unsigned))))) : rank_condition (semiring (has_norm (has_top (semiring unsigned)))) := sorry --non-trivial
lemma new_lemma_100472 (h0 : measurable_space (add_comm_semigroup ereal)) (h1 : measure_theory.measure (add_comm_semigroup ereal)) : measure_theory.is_finite_measure h1 := sorry --non-trivial
lemma new_lemma_100473 (h0 : topological_space (ring (add_comm_monoid Type))) : t1_space (ring (add_comm_monoid Type)) := sorry --non-trivial
lemma new_lemma_100474 (h0 : functor.add_const (finset (boolean_algebra linarith.comp)) Type) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_100475 (h0 : topological_space (with_one congr_arg_kind)) : totally_disconnected_space (with_one congr_arg_kind) := sorry --non-trivial
lemma new_lemma_100476 (h0 : functor.add_const (topological_space (has_add Type)) environment.implicit_infer_kind) : @sequential_space.{1} (has_add.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (has_add.{1} Type)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_100477 (h0 : function.extfun Type filter) : filter.ne_bot (function.extfun_app h0 (has_emptyc congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_100478 (h0 : function.extfun Type ring) : @is_domain.{0} (with_zero.{0} linarith.ineq) (@function.extfun_app.{2 1} Type ring.{0} h0 (with_zero.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_100479 (h0 : functor.add_const (topological_space (boolean_algebra name)) Type) : @totally_separated_space.{0} (boolean_algebra.{0} name) (@functor.add_const.run.{0 1} (topological_space.{0} (boolean_algebra.{0} name)) Type h0)  := sorry --non-trivial
lemma new_lemma_100480 (h0 : function.extfun Type uniform_space) : @separated_space.{0} (boolean_algebra.{0} real) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (boolean_algebra.{0} real))  := sorry --non-trivial
lemma new_lemma_100481 (h0 : topological_space (linear_ordered_comm_group (option (option (option empty))))) : normal_space (linear_ordered_comm_group (option (option (option empty)))) := sorry --non-trivial
lemma new_lemma_100482 (h0 : topological_space (pseudo_metric_space ennreal)) : t0_space (pseudo_metric_space ennreal) := sorry --non-trivial
lemma new_lemma_100483 (h0 : not (has_mem.mem (semiring linarith.comp_source) has_emptyc.emptyc -> false)) : @complete_lattice.is_Sup_finite_compact.{0} (semiring.{0} linarith.comp_source) (@finset.pi.empty.{1 0} Type complete_lattice.{0} (semiring.{0} linarith.comp_source) (@classical.by_contradiction'.{0} (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (semiring.{0} linarith.comp_source) (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))) h0))  := sorry --non-trivial
lemma new_lemma_100484 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_compactly_generated.{0} (@id.{2} Type fun_info) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (@id.{2} Type fun_info))  := sorry --non-trivial
lemma new_lemma_100485 (h0 : topological_space (with_one (semiring (semiring unsigned)))) : totally_disconnected_space (with_one (semiring (semiring unsigned))) := sorry --non-trivial
lemma new_lemma_100486 (h0 : fin has_zero.zero) : @separated_space.{0} (has_Inf.{0} pos) (@matrix.vec_empty.{0} (uniform_space.{0} (has_Inf.{0} pos)) (@matrix.vec_empty.{0} (fin (@has_zero.zero.{0} nat nat.has_zero)) h0))  := sorry --non-trivial
lemma new_lemma_100487 (h0 : not (topological_space (linear_ordered_comm_group_with_zero linarith.ineq) -> false)) : @totally_disconnected_space.{0} (linear_ordered_comm_group_with_zero.{0} linarith.ineq) (@classical.by_contradiction'.{1} (topological_space.{0} (linear_ordered_comm_group_with_zero.{0} linarith.ineq)) h0)  := sorry --non-trivial
lemma new_lemma_100488 (h0 : functor.add_const (group (has_Inf Type)) (ring linarith.comp)) : @normalizer_condition.{1} (has_Inf.{1} Type) (@functor.add_const.run.{1 0} (group.{1} (has_Inf.{1} Type)) (ring.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_100489 (h0 : group (ordered_comm_monoid (finset (has_add pos)))) : normalizer_condition (ordered_comm_monoid (finset (has_add pos))) := sorry --non-trivial
lemma new_lemma_100490 (h0 : ordered_comm_monoid (has_to_string (has_add Type))) : has_exists_mul_of_le (has_to_string (has_add Type)) := sorry --non-trivial
lemma new_lemma_100491 (h0 : functor.add_const (topological_space (has_edist unsigned)) empty) : @topological_space.separable_space.{0} (has_edist.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (has_edist.{0} unsigned)) empty h0)  := sorry --non-trivial
lemma new_lemma_100492 (h0 : not (has_mem.mem num has_emptyc.emptyc -> false)) : @group.fg.{0} num (@finset.pi.empty.{1 0} Type group.{0} num (@classical.by_contradiction'.{0} (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) num (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))) h0))  := sorry --non-trivial
lemma new_lemma_100493 (h0 : functor.add_const (monoid (ring Type)) Type) : @monoid.fg.{1} (ring.{1} Type) (@functor.add_const.run.{1 1} (monoid.{1} (ring.{1} Type)) Type h0)  := sorry --non-trivial
lemma new_lemma_100494 (h0 : topological_space (linear_ordered_semiring (random_gen linarith.comp_source))) : discrete_topology (linear_ordered_semiring (random_gen linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_100495 (h0 : function.extfun (finset Type) (has_mem.mem (linear_ordered_add_comm_group linarith.comp_source))) : @is_atomistic.{0} (linear_ordered_add_comm_group.{0} linarith.comp_source) (@finset.pi.empty.{1 0} Type complete_lattice.{0} (linear_ordered_add_comm_group.{0} linarith.comp_source) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (linear_ordered_add_comm_group.{0} linarith.comp_source)) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_100496 (h1 h2 : list fun_info) : list.is_infix h1 h2 := sorry --non-trivial
lemma new_lemma_100497 (h0 : functor.add_const (topological_space (has_zero unsigned)) pos) : @regular_space.{0} (has_zero.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (has_zero.{0} unsigned)) pos h0)  := sorry --non-trivial
lemma new_lemma_100498 (h0 : complete_lattice (has_compl fun_info)) : is_compactly_generated (has_compl fun_info) := sorry --non-trivial
lemma new_lemma_100499 (h2 : semiring (nondiscrete_normed_field linarith.ineq)) (h3 : ideal (nondiscrete_normed_field linarith.ineq)) : ideal.is_prime h3 := sorry --non-trivial
lemma new_lemma_100500 (h0 : not (topological_space (has_compl to_additive.value_type) -> false)) : @locally_compact_space.{0} (has_compl.{0} to_additive.value_type) (@classical.by_contradiction'.{1} (topological_space.{0} (has_compl.{0} to_additive.value_type)) h0)  := sorry --non-trivial
lemma new_lemma_100501 (h0 : topological_space (add_semigroup (option empty))) : irreducible_space (add_semigroup (option empty)) := sorry --non-trivial
lemma new_lemma_100502 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @rank_condition.{0} (finset.{0} name) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (finset.{0} name))  := sorry --non-trivial
lemma new_lemma_100503 (h0 : add_group (complete_semilattice_Sup linarith.comp)) : is_add_cyclic (complete_semilattice_Sup linarith.comp) := sorry --non-trivial
lemma new_lemma_100504 (h0 : function.extfun Type topological_space) : @path_connected_space.{0} (boolean_algebra.core.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (boolean_algebra.core.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_100505 (h0 : topological_space (preorder unsigned)) : discrete_topology (preorder unsigned) := sorry --non-trivial
lemma new_lemma_100506 (h0 : not (has_mem.mem (measurable_space linarith.comp) has_emptyc.emptyc -> false)) : @normalizer_condition.{0} (measurable_space.{0} linarith.comp) (@finset.pi.empty.{1 0} Type group.{0} (measurable_space.{0} linarith.comp) (@classical.by_contradiction'.{0} (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (measurable_space.{0} linarith.comp) (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))) h0))  := sorry --non-trivial
lemma new_lemma_100507 (h0 : functor.add_const (monoid (complete_distrib_lattice congr_arg_kind)) empty) : @monoid.fg.{0} (complete_distrib_lattice.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (monoid.{0} (complete_distrib_lattice.{0} congr_arg_kind)) empty h0)  := sorry --non-trivial
lemma new_lemma_100508 (h0 : add_group (normed_comm_ring (finset (finset pos)))) : is_add_cyclic (normed_comm_ring (finset (finset pos))) := sorry --non-trivial
lemma new_lemma_100509 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @preirreducible_space.{0} (boolean_algebra.{0} real) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (boolean_algebra.{0} real))  := sorry --non-trivial
lemma new_lemma_100510 (h0 : functor.add_const (add_group (simple_graph Type)) Type) : @is_add_cyclic.{1} (simple_graph.{1} Type) (@functor.add_const.run.{1 1} (add_group.{1} (simple_graph.{1} Type)) Type h0)  := sorry --non-trivial
lemma new_lemma_100511 (h0 : topological_space (ordered_comm_ring (has_neg (has_Inf linarith.comp)))) : locally_compact_space (ordered_comm_ring (has_neg (has_Inf linarith.comp))) := sorry --non-trivial
lemma new_lemma_100512 (h0 : topological_space (semi_normed_comm_ring (has_ssubset fun_info))) : t0_space (semi_normed_comm_ring (has_ssubset fun_info)) := sorry --non-trivial
lemma new_lemma_100513 (h0 : functor.add_const (group (has_nndist pos)) Type) : @normalizer_condition.{0} (has_nndist.{0} pos) (@functor.add_const.run.{0 1} (group.{0} (has_nndist.{0} pos)) Type h0)  := sorry --non-trivial
lemma new_lemma_100514 (h0 : topological_space (add_comm_monoid (has_neg pos))) : locally_compact_space (add_comm_monoid (has_neg pos)) := sorry --non-trivial
lemma new_lemma_100515 (h0 : functor.add_const (topological_space (boolean_algebra environment.implicit_infer_kind)) Type) : @normal_space.{0} (boolean_algebra.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 1} (topological_space.{0} (boolean_algebra.{0} environment.implicit_infer_kind)) Type h0)  := sorry --non-trivial
lemma new_lemma_100516 (h0 : list (linear_ordered_cancel_comm_monoid (option empty))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_100517 (h0 : filter (add_cancel_monoid Type)) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_100518 (h0 : topological_space (add_comm_monoid name)) : path_connected_space (add_comm_monoid name) := sorry --non-trivial
lemma new_lemma_100519 (h0 : group (add_group (semiring (semiring congr_arg_kind)))) : group.fg (add_group (semiring (semiring congr_arg_kind))) := sorry --non-trivial
lemma new_lemma_100520 (h0 : functor.add_const (ring (ordered_comm_ring Type)) Type) : @strong_rank_condition.{1} (ordered_comm_ring.{1} Type) (@functor.add_const.run.{1 1} (ring.{1} (ordered_comm_ring.{1} Type)) Type h0)  := sorry --non-trivial
lemma new_lemma_100521 (h0 : function.extfun Type add_monoid) : @add_monoid.fg.{0} (add_cancel_monoid.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type add_monoid.{0} h0 (add_cancel_monoid.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_100522 (h0 : not (ring (semiring unsigned) -> false)) : @is_principal_ideal_ring.{0} (semiring.{0} unsigned) (@classical.by_contradiction'.{1} (ring.{0} (semiring.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_100523 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @loc_path_connected_space.{0} (linear_ordered_field.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (linear_ordered_field.{0} empty))  := sorry --non-trivial
lemma new_lemma_100524 (h0 : ring (add_group (semiring (semiring congr_arg_kind)))) : rank_condition (add_group (semiring (semiring congr_arg_kind))) := sorry --non-trivial
lemma new_lemma_100525 (h1 : add_monoid fun_info) : add_monoid.fg fun_info := sorry --non-trivial
lemma new_lemma_100526 (h0 : ring (with_bot (random_gen (random_gen linarith.comp_source)))) : rank_condition (with_bot (random_gen (random_gen linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_100527 (h0 : ring (has_lt string.iterator_imp)) : strong_rank_condition (has_lt string.iterator_imp) := sorry --non-trivial
lemma new_lemma_100528 (h0 : functor.add_const (functor.add_const (monoid pos) environment.implicit_infer_kind) environment.implicit_infer_kind) : @monoid.fg.{0} pos (@functor.add_const.run.{0 0} (monoid.{0} pos) environment.implicit_infer_kind (@functor.add_const.run.{0 0} (functor.add_const.{0 0} (monoid.{0} pos) environment.implicit_infer_kind) environment.implicit_infer_kind h0))  := sorry --non-trivial
lemma new_lemma_100529 (h0 : topological_space (simple_graph (mul_one_class fun_info))) : t0_space (simple_graph (mul_one_class fun_info)) := sorry --non-trivial
lemma new_lemma_100530 (h0 : function.extfun Type complete_lattice) : @is_compactly_generated.{0} (non_assoc_semiring.{0} num) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (non_assoc_semiring.{0} num))  := sorry --non-trivial
lemma new_lemma_100531 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @totally_disconnected_space.{0} name (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) name)  := sorry --non-trivial
lemma new_lemma_100532 (h0 : functor.add_const (filter (boolean_algebra.core name)) (finset pos)) : filter.ne_bot (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_100533 (h0 : ring (with_bot (has_top congr_arg_kind))) : is_domain (with_bot (has_top congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_100534 (h0 : finset (finset (semigroup pos))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_100535 (h0 : complete_lattice (comm_group empty)) : is_compactly_generated (comm_group empty) := sorry --non-trivial
lemma new_lemma_100536 (h0 : group (random_gen linarith.comp_source)) : is_cyclic (random_gen linarith.comp_source) := sorry --non-trivial
lemma new_lemma_100537 (h0 : functor.add_const (function.extfun (Type 1) topological_space) name) : @preirreducible_space.{1} (add_cancel_monoid.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) topological_space.{1}) name h0) (add_cancel_monoid.{1} Type))  := sorry --non-trivial
lemma new_lemma_100538 (h0 : add_monoid (random_gen (has_top linarith.comp))) : add_monoid.fg (random_gen (has_top linarith.comp)) := sorry --non-trivial
lemma new_lemma_100539 (h0 : ring (linear_ordered_cancel_comm_monoid (semiring empty))) : is_domain (linear_ordered_cancel_comm_monoid (semiring empty)) := sorry --non-trivial
lemma new_lemma_100540 (h0 : has_neg (has_compl enat)) (h1 : measurable_space (has_compl enat)) : has_measurable_neg (has_compl enat) := sorry --non-trivial
lemma new_lemma_100541 (h0 : topological_space (boolean_algebra environment.implicit_infer_kind)) : totally_disconnected_space (boolean_algebra environment.implicit_infer_kind) := sorry --non-trivial
lemma new_lemma_100542 (h0 : semiring (generalized_boolean_algebra (has_Inf (has_add (has_Inf linarith.comp))))) : is_noetherian_ring (generalized_boolean_algebra (has_Inf (has_add (has_Inf linarith.comp)))) := sorry --non-trivial
lemma new_lemma_100543 (h0 : topological_space (boolean_algebra (has_Inf Type))) : topological_space.separable_space (boolean_algebra (has_Inf Type)) := sorry --non-trivial
lemma new_lemma_100544 (h0 : topological_space (canonically_ordered_monoid (has_add real))) : topological_space.separable_space (canonically_ordered_monoid (has_add real)) := sorry --non-trivial
lemma new_lemma_100545 (h0 : uniform_space (semiring fun_info)) : separated_space (semiring fun_info) := sorry --non-trivial
lemma new_lemma_100546 (h0 : filter (add_right_cancel_monoid empty)) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_100547 (h0 : topological_space (normed_linear_ordered_group (option unsigned))) : loc_path_connected_space (normed_linear_ordered_group (option unsigned)) := sorry --non-trivial
lemma new_lemma_100548 (h0 : list ennreal) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_100549 (h0 : functor.add_const (list (semigroup Type)) environment.implicit_infer_kind) : palindrome (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_100550 (h0 : not (ring (add_cancel_comm_monoid char) -> false)) : @rank_condition.{0} (add_cancel_comm_monoid.{0} char) (@classical.by_contradiction'.{1} (ring.{0} (add_cancel_comm_monoid.{0} char)) h0)  := sorry --non-trivial
lemma new_lemma_100551 (h0 : ring (canonically_ordered_add_monoid (option empty))) : is_principal_ideal_ring (canonically_ordered_add_monoid (option empty)) := sorry --non-trivial
lemma new_lemma_100552 (h0 : functor.add_const (topological_space (semigroup Type)) (boolean_algebra.core linarith.comp)) : @topological_space.separable_space.{1} (semigroup.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (semigroup.{1} Type)) (boolean_algebra.core.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_100553 (h0 : fin has_zero.zero) : @normal_space.{0} (ordered_comm_monoid.{0} pos) (@matrix.vec_empty.{0} (topological_space.{0} (ordered_comm_monoid.{0} pos)) h0)  := sorry --non-trivial
lemma new_lemma_100554 (h0 : topological_space (has_to_string (option unsigned))) : preconnected_space (has_to_string (option unsigned)) := sorry --non-trivial
lemma new_lemma_100555 (h0 : function.extfun Type add_monoid) : @add_monoid.fg.{0} (complete_distrib_lattice.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type add_monoid.{0} h0 (complete_distrib_lattice.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_100556 (h0 : group (has_add (mul_one_class pos))) : is_simple_group (has_add (mul_one_class pos)) := sorry --non-trivial
lemma new_lemma_100557 (h0 : functor.add_const (topological_space (complete_distrib_lattice ennreal)) pos) : @preirreducible_space.{0} (complete_distrib_lattice.{0} ennreal) (@functor.add_const.run.{0 0} (topological_space.{0} (complete_distrib_lattice.{0} ennreal)) pos h0)  := sorry --non-trivial
lemma new_lemma_100558 (h0 : topological_space (cancel_monoid pos)) : preconnected_space (cancel_monoid pos) := sorry --non-trivial
lemma new_lemma_100559 (h0 : ring (has_to_string (random_gen (has_top fun_info)))) : is_domain (has_to_string (random_gen (has_top fun_info))) := sorry --non-trivial
lemma new_lemma_100560 (h0 : prod (semigroup (option unsigned)) (semigroup (option unsigned))) : id_rel h0 := sorry --non-trivial
lemma new_lemma_100561 (h0 : function.extfun (Type 1) (functor.comp topological_space normed_comm_ring)) : @path_connected_space.{1} (normed_comm_ring.{1} Type) (@functor.comp.run.{1 1 1} topological_space.{1} normed_comm_ring.{1} Type (@function.extfun_app.{3 2} (Type 1) (functor.comp.{1 1 1} topological_space.{1} normed_comm_ring.{1}) h0 Type))  := sorry --non-trivial
lemma new_lemma_100562 (h0 : topological_space (add_comm_monoid (has_add (finset linarith.comp)))) : totally_separated_space (add_comm_monoid (has_add (finset linarith.comp))) := sorry --non-trivial
lemma new_lemma_100563 (h0 : add_group (semi_normed_ring (mul_one_class (mul_one_class reducibility_hints)))) : is_add_cyclic (semi_normed_ring (mul_one_class (mul_one_class reducibility_hints))) := sorry --non-trivial
lemma new_lemma_100564 (h0 : group (boolean_algebra (normed_comm_ring (finset pos)))) : is_cyclic (boolean_algebra (normed_comm_ring (finset pos))) := sorry --non-trivial
lemma new_lemma_100565 (h0 : random_gen (with_one (has_top linarith.comp_source)) -> Prop) : exists_unique h0 := sorry --non-trivial
lemma new_lemma_100566 (h0 : not (topological_space (normed_group num) -> false)) : @path_connected_space.{0} (normed_group.{0} num) (@classical.by_contradiction'.{1} (topological_space.{0} (normed_group.{0} num)) h0)  := sorry --non-trivial
lemma new_lemma_100567 (h0 : list (dlist (has_ssubset (random_gen linarith.ineq)))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_100568 (h0 : functor.add_const (function.extfun Type topological_space) pos) : @regular_space.{0} (normed_comm_ring.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) pos h0) (normed_comm_ring.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_100569 (h0 : complete_lattice (has_nndist (option congr_arg_kind))) : is_compactly_generated (has_nndist (option congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_100570 (h0 : ring (canonically_ordered_monoid (finset Type))) : is_domain (canonically_ordered_monoid (finset Type)) := sorry --non-trivial
lemma new_lemma_100571 (h0 : function.extfun (finset (Type -> Type)) (has_mem.mem complete_lattice)) : @complete_lattice.is_Sup_finite_compact.{0} (normed_group.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) complete_lattice.{0} (@function.extfun_app.{2 0} (finset.{1} (Type → Type)) (@has_mem.mem.{1 1} (Type → Type) (finset.{1} (Type → Type)) (@finset.has_mem.{1} (Type → Type)) complete_lattice.{0}) h0 (@has_emptyc.emptyc.{1} (finset.{1} (Type → Type)) (@finset.has_emptyc.{1} (Type → Type))))) (normed_group.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_100572 (h0 : topological_space (semigroup (mul_one_class environment.implicit_infer_kind))) : t0_space (semigroup (mul_one_class environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_100573 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @sequential_space.{0} (finset.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (finset.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_100574 (h0 : functor.add_const (ordered_add_comm_monoid (semigroup pos)) linarith.comp) : @archimedean.{0} (semigroup.{0} pos) (@functor.add_const.run.{0 0} (ordered_add_comm_monoid.{0} (semigroup.{0} pos)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_100575 (h0 : uniform_space (distrib (has_nnnorm linarith.comp_source))) : complete_space (distrib (has_nnnorm linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_100576 (h0 : function.extfun Type topological_space) : @t0_space.{0} (has_Sup.{0} (partial_order.{0} empty)) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_Sup.{0} (partial_order.{0} empty)))  := sorry --non-trivial
lemma new_lemma_100577 (h0 : ordered_add_comm_monoid (ordered_ring (option unsigned))) : archimedean (ordered_ring (option unsigned)) := sorry --non-trivial
lemma new_lemma_100578 (h0 : fin has_zero.zero) : @discrete_topology.{0} (canonically_linear_ordered_monoid.{0} pos) (@matrix.vec_empty.{0} (topological_space.{0} (canonically_linear_ordered_monoid.{0} pos)) h0)  := sorry --non-trivial
lemma new_lemma_100579 (h7 : set (add_comm_semigroup string.iterator_imp -> fun_info)) : set.separates_points h7 := sorry --non-trivial
lemma new_lemma_100580 (h0 : topological_space (has_to_string (option unsigned))) : topological_space.separable_space (has_to_string (option unsigned)) := sorry --non-trivial
lemma new_lemma_100581 (h0 : ordered_add_comm_monoid (has_bot (has_Inf real))) : archimedean (has_bot (has_Inf real)) := sorry --non-trivial
lemma new_lemma_100582 (h0 : function.extfun Type semiring) : @is_noetherian_ring.{0} (canonically_ordered_add_monoid.{0} unsigned) (@function.extfun_app.{2 1} Type semiring.{0} h0 (canonically_ordered_add_monoid.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_100583 (h0 : add_group (semigroup (has_pos_part Type))) : is_add_cyclic (semigroup (has_pos_part Type)) := sorry --non-trivial
lemma new_lemma_100584 (h0 : group (complete_distrib_lattice (finset Type))) : normalizer_condition (complete_distrib_lattice (finset Type)) := sorry --non-trivial
lemma new_lemma_100585 (h0 : topological_space (normed_comm_ring (has_add pos))) : totally_separated_space (normed_comm_ring (has_add pos)) := sorry --non-trivial
lemma new_lemma_100586 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @group.fg.{0} (has_emptyc.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (has_emptyc.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_100587 (h3 : add_group (semi_normed_ring to_additive.value_type)) : is_add_cyclic (semi_normed_ring to_additive.value_type) := sorry --non-trivial
lemma new_lemma_100588 (h0 : not (ring (has_sub num) -> false)) : @rank_condition.{0} (has_sub.{0} num) (@classical.by_contradiction'.{1} (ring.{0} (has_sub.{0} num)) h0)  := sorry --non-trivial
lemma new_lemma_100589 (h0 : topological_space (normed_group (has_top linarith.comp_source))) : totally_disconnected_space (normed_group (has_top linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_100590 (h0 : topological_space (complete_linear_order unsigned)) : normal_space (complete_linear_order unsigned) := sorry --non-trivial
lemma new_lemma_100591 (h0 : uniform_space (linear_ordered_comm_group_with_zero (has_lt (has_nnnorm char)))) : complete_space (linear_ordered_comm_group_with_zero (has_lt (has_nnnorm char))) := sorry --non-trivial
lemma new_lemma_100592 (h0 : add_group (mul_one_class string_imp)) : is_add_cyclic (mul_one_class string_imp) := sorry --non-trivial
lemma new_lemma_100593 (h0 : ring (random_gen (random_gen (random_gen linarith.ineq)))) : strong_rank_condition (random_gen (random_gen (random_gen linarith.ineq))) := sorry --non-trivial
lemma new_lemma_100594 (h0 : topological_space (random_gen (semiring (semiring linarith.comp)))) : path_connected_space (random_gen (semiring (semiring linarith.comp))) := sorry --non-trivial
lemma new_lemma_100595 (h1 : complete_lattice (distrib linarith.comp_source)) : complete_lattice.is_Sup_finite_compact (distrib linarith.comp_source) := sorry --non-trivial
lemma new_lemma_100596 (h0 : functor.add_const (topological_space (left_cancel_monoid congr_arg_kind)) num) : @discrete_topology.{0} (left_cancel_monoid.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (left_cancel_monoid.{0} congr_arg_kind)) num h0)  := sorry --non-trivial
lemma new_lemma_100597 (h0 : semiring (simple_graph (boolean_algebra.core (has_pos_part (ring (ring pos)))))) : is_noetherian_ring (simple_graph (boolean_algebra.core (has_pos_part (ring (ring pos))))) := sorry --non-trivial
lemma new_lemma_100598 (h1 : uniform_space (has_top congr_arg_kind)) : separated_space (has_top congr_arg_kind) := sorry --non-trivial
lemma new_lemma_100599 (h0 : topological_space (canonically_ordered_comm_semiring unsigned)) : preirreducible_space (canonically_ordered_comm_semiring unsigned) := sorry --non-trivial
lemma new_lemma_100600 (h0 : complete_lattice (pseudo_metric_space (has_nndist (ring name)))) : is_compactly_generated (pseudo_metric_space (has_nndist (ring name))) := sorry --non-trivial
lemma new_lemma_100601 (h0 : functor.add_const (topological_space (boolean_algebra linarith.comp)) (has_neg Type)) : @locally_compact_space.{0} (boolean_algebra.{0} linarith.comp) (@functor.add_const.run.{0 1} (topological_space.{0} (boolean_algebra.{0} linarith.comp)) (has_neg.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_100602 (h0 : filter (add_left_cancel_monoid (has_inv char))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_100603 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @path_connected_space.{0} (has_top.{0} fun_info) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_top.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_100604 (h1 h2 : multiset (has_ssubset std_gen)) : multiset.subset h1 h2 := sorry --non-trivial
lemma new_lemma_100605 (h0 : functor.add_const (monoid (canonically_ordered_comm_semiring environment.implicit_infer_kind)) name) : @monoid.fg.{0} (canonically_ordered_comm_semiring.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (monoid.{0} (canonically_ordered_comm_semiring.{0} environment.implicit_infer_kind)) name h0)  := sorry --non-trivial
lemma new_lemma_100606 (h0 : ring (has_top (random_gen char))) : strong_rank_condition (has_top (random_gen char)) := sorry --non-trivial
lemma new_lemma_100607 (h0 : uniform_space (boolean_algebra name)) : separated_space (boolean_algebra name) := sorry --non-trivial
lemma new_lemma_100608 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : palindrome (function.extfun_app (function.extfun_app h0 list) (semigroup unsigned)) := sorry --non-trivial
lemma new_lemma_100609 (h0 : topological_space (complete_distrib_lattice (has_neg name))) : discrete_topology (complete_distrib_lattice (has_neg name)) := sorry --non-trivial
lemma new_lemma_100610 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_compactly_generated.{0} (sub_neg_monoid.{0} linarith.comp) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (sub_neg_monoid.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_100611 (h0 : functor.add_const (topological_space (bin_tree num)) empty) : @totally_separated_space.{0} (bin_tree.{0} num) (@functor.add_const.run.{0 0} (topological_space.{0} (bin_tree.{0} num)) empty h0)  := sorry --non-trivial
lemma new_lemma_100612 (h0 : functor.comp ring mul_zero_class environment.implicit_infer_kind) : @is_domain.{0} (mul_zero_class.{0} environment.implicit_infer_kind) (@functor.comp.run.{0 0 0} ring.{0} mul_zero_class.{0} environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_100613 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : list.nodup (function.extfun_app (function.extfun_app h0 list) (cancel_monoid congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_100614 (h0 : functor.add_const (topological_space (normed_comm_ring linarith.comp)) environment.implicit_infer_kind) : @totally_disconnected_space.{0} (normed_comm_ring.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (normed_comm_ring.{0} linarith.comp)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_100615 (h0 : finset (boolean_algebra.core (boolean_algebra.core name))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_100616 (h0 : topological_space (has_norm unsigned)) : locally_compact_space (has_norm unsigned) := sorry --non-trivial
lemma new_lemma_100617 (h0 : not (group (measurable_space linarith.comp) -> false)) : @is_cyclic.{0} (measurable_space.{0} linarith.comp) (@classical.by_contradiction'.{1} (group.{0} (measurable_space.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_100618 (h0 : monoid (canonically_ordered_monoid (sub_neg_monoid real))) : monoid.fg (canonically_ordered_monoid (sub_neg_monoid real)) := sorry --non-trivial
lemma new_lemma_100619 (h0 : topological_space (has_top (has_top (has_top congr_arg_kind)))) : discrete_topology (has_top (has_top (has_top congr_arg_kind))) := sorry --non-trivial
lemma new_lemma_100620 (h0 : functor.add_const (monoid (canonically_ordered_comm_semiring linarith.comp)) Type) : @monoid.fg.{0} (canonically_ordered_comm_semiring.{0} linarith.comp) (@functor.add_const.run.{0 1} (monoid.{0} (canonically_ordered_comm_semiring.{0} linarith.comp)) Type h0)  := sorry --non-trivial
lemma new_lemma_100621 (h0 : add_monoid (mul_zero_class (finset pos))) : add_monoid.fg (mul_zero_class (finset pos)) := sorry --non-trivial
lemma new_lemma_100622 (h0 : function.extfun Type group) : @normalizer_condition.{0} (random_gen.{0} fun_info) (@function.extfun_app.{2 1} Type group.{0} h0 (random_gen.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_100623 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : t1_space real := sorry --non-trivial
lemma new_lemma_100624 (h0 : function.extfun (finset (Type -> Type)) (has_mem.mem topological_space)) : @irreducible_space.{0} (has_norm.{0} linarith.ineq) (@function.extfun_app.{2 1} Type topological_space.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) topological_space.{0} (@function.extfun_app.{2 0} (finset.{1} (Type → Type)) (@has_mem.mem.{1 1} (Type → Type) (finset.{1} (Type → Type)) (@finset.has_mem.{1} (Type → Type)) topological_space.{0}) h0 (@has_emptyc.emptyc.{1} (finset.{1} (Type → Type)) (@finset.has_emptyc.{1} (Type → Type))))) (has_norm.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_100625 (h3 : not (topological_space linarith.comp_source -> false)) : @path_connected_space.{0} linarith.comp_source (@classical.by_contradiction'.{1} (topological_space.{0} linarith.comp_source) h3)  := sorry --non-trivial
lemma new_lemma_100626 (h0 : functor.add_const (add_group (has_nndist name)) (finset environment.implicit_infer_kind)) : @is_add_cyclic.{0} (has_nndist.{0} name) (@functor.add_const.run.{0 0} (add_group.{0} (has_nndist.{0} name)) (finset.{0} environment.implicit_infer_kind) h0)  := sorry --non-trivial
lemma new_lemma_100627 (h0 : functor.add_const (ring (complete_distrib_lattice unsigned)) empty) : @strong_rank_condition.{0} (complete_distrib_lattice.{0} unsigned) (@functor.add_const.run.{0 0} (ring.{0} (complete_distrib_lattice.{0} unsigned)) empty h0)  := sorry --non-trivial
lemma new_lemma_100628 (h0 : complete_lattice (ring (option (option pos)))) : complete_lattice.is_Sup_finite_compact (ring (option (option pos))) := sorry --non-trivial
lemma new_lemma_100629 (h0 : functor.add_const (filter (add_comm_monoid Type)) (has_add (has_to_string (has_add unsigned)))) : countable_Inter_filter (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_100630 (h0 : function.extfun Type ring) : @is_domain.{0} (linear_ordered_comm_monoid_with_zero.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type ring.{0} h0 (linear_ordered_comm_monoid_with_zero.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_100631 (h0 : filter (random_gen (linear_ordered_add_comm_group char))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_100632 (h0 : fin has_zero.zero) : @loc_path_connected_space.{0} (has_bot.{0} pos) (@matrix.vec_empty.{0} (topological_space.{0} (has_bot.{0} pos)) h0)  := sorry --non-trivial
lemma new_lemma_100633 (h0 : topological_space (add_left_cancel_monoid (has_nnnorm char))) : t0_space (add_left_cancel_monoid (has_nnnorm char)) := sorry --non-trivial
lemma new_lemma_100634 (h0 : topological_space (comm_group environment.implicit_infer_kind)) : locally_compact_space (comm_group environment.implicit_infer_kind) := sorry --non-trivial
lemma new_lemma_100635 (h0 : group (has_nndist (option (option unsigned)))) : normalizer_condition (has_nndist (option (option unsigned))) := sorry --non-trivial
lemma new_lemma_100636 (h0 : complete_lattice (add_group (semiring unsigned))) : is_atomistic (add_group (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_100637 (h0 : topological_space (has_Sup num)) : preirreducible_space (has_Sup num) := sorry --non-trivial
lemma new_lemma_100638 (h0 : functor.add_const (group (is_R_or_C congr_arg_kind)) congr_arg_kind) : @is_cyclic.{0} (is_R_or_C.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (group.{0} (is_R_or_C.{0} congr_arg_kind)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_100639 (h0 : filter (add_comm_monoid unsigned)) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_100640 (h0 : complete_lattice (mul_one_class ereal)) : complete_lattice.is_Sup_finite_compact (mul_one_class ereal) := sorry --non-trivial
lemma new_lemma_100641 (h0 : function.extfun Type topological_space) : @discrete_topology.{0} (has_top.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_top.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_100642 (h0 : group (bin_tree unsigned)) : group.fg (bin_tree unsigned) := sorry --non-trivial
lemma new_lemma_100643 (h0 : add_group (add_right_cancel_monoid empty)) (h1 : not (add_subgroup (add_right_cancel_monoid empty) -> false)) : add_subgroup.normal (classical.by_contradiction' h1) := sorry --non-trivial
lemma new_lemma_100644 (h4 : topological_space char) (h5 : preorder char) : order_topology char := sorry --non-trivial
lemma new_lemma_100645 (h0 : topological_space (has_to_string (has_add (has_add name)))) : t1_space (has_to_string (has_add (has_add name))) := sorry --non-trivial
lemma new_lemma_100646 (h2 : functor.comp uniform_space random_gen to_additive.value_type) : @complete_space.{0} (random_gen.{0} to_additive.value_type) (@functor.comp.run.{0 0 0} uniform_space.{0} random_gen.{0} to_additive.value_type h2)  := sorry --non-trivial
lemma new_lemma_100647 (h0 : functor.add_const (topological_space (add_cancel_monoid unsigned)) name) : @path_connected_space.{0} (add_cancel_monoid.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (add_cancel_monoid.{0} unsigned)) name h0)  := sorry --non-trivial
lemma new_lemma_100648 (h0 : topological_space (has_add linarith.comp)) : locally_compact_space (has_add linarith.comp) := sorry --non-trivial
lemma new_lemma_100649 (h1 : has_neg (linear_ordered_comm_group_with_zero linarith.ineq)) (h2 : measurable_space (linear_ordered_comm_group_with_zero linarith.ineq)) : has_measurable_neg (linear_ordered_comm_group_with_zero linarith.ineq) := sorry --non-trivial
lemma new_lemma_100650 (h0 : list (has_neg_part (finset (has_add (has_add (has_add environment.implicit_infer_kind)))))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_100651 (h0 : function.extfun (multiset Type) (has_mem.mem (denumerable to_additive.value_type))) : @irreducible_space.{0} (denumerable.{0} to_additive.value_type) (@multiset.pi.empty.{1 0} Type topological_space.{0} (denumerable.{0} to_additive.value_type) (@function.extfun_app.{2 0} (multiset.{1} Type) (@has_mem.mem.{1 1} Type (multiset.{1} Type) (@multiset.has_mem.{1} Type) (denumerable.{0} to_additive.value_type)) h0 (@has_zero.zero.{1} (multiset.{1} Type) (@multiset.has_zero.{1} Type))))  := sorry --non-trivial
lemma new_lemma_100652 (h0 : monoid (boolean_algebra (has_add pos))) : monoid.fg (boolean_algebra (has_add pos)) := sorry --non-trivial
lemma new_lemma_100653 (h0 : not (function.extfun Type group -> false)) : @normalizer_condition.{0} (@id.{2} Type num) (@function.extfun_app.{2 1} Type group.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type group.{0}) h0) (@id.{2} Type num))  := sorry --non-trivial
lemma new_lemma_100654 (h0 : uniform_space (partial_order (semiring num))) : separated_space (partial_order (semiring num)) := sorry --non-trivial
lemma new_lemma_100655 (h0 : functor.add_const (cancel_comm_monoid_with_zero (left_cancel_semigroup num)) num) : @unique_factorization_monoid.{0} (left_cancel_semigroup.{0} num) (@functor.add_const.run.{0 0} (cancel_comm_monoid_with_zero.{0} (left_cancel_semigroup.{0} num)) num h0)  := sorry --non-trivial
lemma new_lemma_100656 (h0 : set (add_comm_semigroup fun_info)) : set.finite h0 := sorry --non-trivial
lemma new_lemma_100657 (h0 : ordered_add_comm_monoid (semigroup (semiring (semiring empty)))) : archimedean (semigroup (semiring (semiring empty))) := sorry --non-trivial
lemma new_lemma_100658 (h0 : functor.comp topological_space finset ennreal) : @preirreducible_space.{0} (finset.{0} ennreal) (@functor.comp.run.{0 0 0} topological_space.{0} finset.{0} ennreal h0)  := sorry --non-trivial
lemma new_lemma_100659 (h0 : functor.add_const (semiring (has_neg environment.implicit_infer_kind)) pos) : @is_noetherian_ring.{0} (has_neg.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (semiring.{0} (has_neg.{0} environment.implicit_infer_kind)) pos h0)  := sorry --non-trivial
lemma new_lemma_100660 (h1 : not (complete_lattice (dlist char) -> false)) : @complete_lattice.is_Sup_finite_compact.{0} (dlist.{0} char) (@classical.by_contradiction'.{1} (complete_lattice.{0} (dlist.{0} char)) h1)  := sorry --non-trivial
lemma new_lemma_100661 (h0 : complete_lattice (normed_comm_ring (add_comm_monoid Type))) : is_atomistic (normed_comm_ring (add_comm_monoid Type)) := sorry --non-trivial
lemma new_lemma_100662 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_noetherian_ring.{0} (boolean_algebra.{0} real) (@function.extfun_app.{2 1} Type semiring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 semiring.{0}) (boolean_algebra.{0} real))  := sorry --non-trivial
lemma new_lemma_100663 (h0 : function.extfun nat fin) : @archimedean.{0} (has_pos_part.{0} name) (@matrix.vec_empty.{0} (ordered_add_comm_monoid.{0} (has_pos_part.{0} name)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_100664 (h1 : topological_space (random_gen reducibility_hints)) : t0_space (random_gen reducibility_hints) := sorry --non-trivial
lemma new_lemma_100665 (h0 : functor.add_const (uniform_space (semigroup Type)) (add_comm_monoid environment.implicit_infer_kind)) : @complete_space.{1} (semigroup.{1} Type) (@functor.add_const.run.{1 0} (uniform_space.{1} (semigroup.{1} Type)) (add_comm_monoid.{0} environment.implicit_infer_kind) h0)  := sorry --non-trivial
lemma new_lemma_100666 (h0 : functor.add_const (function.extfun Type finset) linarith.comp) : finset.nonempty (function.extfun_app (functor.add_const.run h0) (has_nndist linarith.comp)) := sorry --non-trivial
lemma new_lemma_100667 (h1 : set (char -> std_gen)) : set.separates_points h1 := sorry --non-trivial
lemma new_lemma_100668 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @strong_rank_condition.{0} (pseudo_metric_space.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (pseudo_metric_space.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_100669 (h0 : functor.add_const (ordered_comm_monoid (ring name)) (has_add pos)) : @has_exists_mul_of_le.{0} (ring.{0} name) (@functor.add_const.run.{0 0} (ordered_comm_monoid.{0} (ring.{0} name)) (has_add.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_100670 (h0 : function.extfun Type ring) : strong_rank_condition real := sorry --non-trivial
lemma new_lemma_100671 (h1 : complete_lattice (random_gen to_additive.value_type)) : is_compactly_generated (random_gen to_additive.value_type) := sorry --non-trivial
lemma new_lemma_100672 (h0 : topological_space (has_bot (has_add real))) : discrete_topology (has_bot (has_add real)) := sorry --non-trivial
lemma new_lemma_100673 (h0 : topological_space (has_zero (option num))) : t0_space (has_zero (option num)) := sorry --non-trivial
lemma new_lemma_100674 (h0 : complete_lattice (semi_normed_comm_ring enat)) : complete_lattice.is_Sup_finite_compact (semi_normed_comm_ring enat) := sorry --non-trivial
lemma new_lemma_100675 (h0 : function.extfun Type uniform_space) : @complete_space.{0} (measurable_space.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (measurable_space.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_100676 (h0 : filter (add_cancel_monoid (add_comm_monoid Type))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_100677 (h0 : topological_space (canonically_linear_ordered_monoid (has_neg name))) : irreducible_space (canonically_linear_ordered_monoid (has_neg name)) := sorry --non-trivial
lemma new_lemma_100678 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_add_cyclic.{0} (has_add.{0} pos) (@function.extfun_app.{2 1} Type add_group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 add_group.{0}) (has_add.{0} pos))  := sorry --non-trivial
lemma new_lemma_100679 (h1 : ring (semiring num)) : is_domain (semiring num) := sorry --non-trivial
lemma new_lemma_100680 (h0 : ring (dlist char)) : strong_rank_condition (dlist char) := sorry --non-trivial
lemma new_lemma_100681 (h0 : group (canonically_linear_ordered_monoid (has_pos_part linarith.comp))) : group.fg (canonically_linear_ordered_monoid (has_pos_part linarith.comp)) := sorry --non-trivial
lemma new_lemma_100682 (h0 : functor.add_const (add_monoid (finset name)) Type) : @add_monoid.fg.{0} (finset.{0} name) (@functor.add_const.run.{0 1} (add_monoid.{0} (finset.{0} name)) Type h0)  := sorry --non-trivial
lemma new_lemma_100683 (h0 : functor.add_const (finset (has_Inf pos)) (ring name)) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_100684 (h0 : group (has_nnnorm (semi_normed_ring linarith.comp_source))) : is_cyclic (has_nnnorm (semi_normed_ring linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_100685 (h0 : topological_space (add_left_cancel_semigroup unsigned)) : preirreducible_space (add_left_cancel_semigroup unsigned) := sorry --non-trivial
lemma new_lemma_100686 (h1 : topological_space (has_inv (random_gen string_imp))) : t0_space (has_inv (random_gen string_imp)) := sorry --non-trivial
lemma new_lemma_100687 (h0 : not (topological_space (has_top empty) -> false)) : @totally_separated_space.{0} (has_top.{0} empty) (@classical.by_contradiction'.{1} (topological_space.{0} (has_top.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_100688 (h0 : semiring (semigroup empty)) : is_noetherian_ring (semigroup empty) := sorry --non-trivial
lemma new_lemma_100689 (h0 : topological_space (option unsigned)) : totally_separated_space (option unsigned) := sorry --non-trivial
lemma new_lemma_100690 (h0 : list (has_inter unsigned)) : palindrome h0 := sorry --non-trivial
lemma new_lemma_100691 (h0 : function.extfun Type (functor.add_const (functor.add_const Prop ennreal))) : functor.add_const.run (functor.add_const.run (function.extfun_app h0 unsigned)) := sorry --non-trivial
lemma new_lemma_100692 (h0 : topological_space (normed_comm_ring (boolean_algebra (has_neg linarith.comp)))) : regular_space (normed_comm_ring (boolean_algebra (has_neg linarith.comp))) := sorry --non-trivial
lemma new_lemma_100693 (h0 : topological_space (has_nndist (finset ennreal))) : sequential_space (has_nndist (finset ennreal)) := sorry --non-trivial
lemma new_lemma_100694 (h0 : filter (monoid_with_zero ennreal)) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_100695 (h0 : functor.add_const (topological_space (normed_comm_ring ennreal)) ennreal) : @discrete_topology.{0} (normed_comm_ring.{0} ennreal) (@functor.add_const.run.{0 0} (topological_space.{0} (normed_comm_ring.{0} ennreal)) ennreal h0)  := sorry --non-trivial
lemma new_lemma_100696 (h0 : function.extfun (Type 1) topological_space) : @path_connected_space.{1} (has_neg.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} h0 (has_neg.{1} Type))  := sorry --non-trivial
lemma new_lemma_100697 (h0 : complete_lattice (has_norm (has_inv (random_gen linarith.comp_source)))) : is_atomistic (has_norm (has_inv (random_gen linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_100698 (h0 : not (uniform_space (with_zero linarith.comp_source) -> false)) : @complete_space.{0} (with_zero.{0} linarith.comp_source) (@classical.by_contradiction'.{1} (uniform_space.{0} (with_zero.{0} linarith.comp_source)) h0)  := sorry --non-trivial
lemma new_lemma_100699 (h0 : fin has_zero.zero) : @rank_condition.{0} (generalized_boolean_algebra.{0} real) (@function.extfun_app.{2 1} Type ring.{0} (@matrix.vec_empty.{1} (function.extfun.{2 1} Type ring.{0}) h0) (generalized_boolean_algebra.{0} real))  := sorry --non-trivial
lemma new_lemma_100700 (h0 : function.extfun Type add_group) : @is_add_cyclic.{0} (ordered_ring.{0} unsigned) (@function.extfun_app.{2 1} Type add_group.{0} h0 (ordered_ring.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_100701 (h0 : functor.comp group normed_comm_ring pos) : @is_cyclic.{0} (normed_comm_ring.{0} pos) (@functor.comp.run.{0 0 0} group.{0} normed_comm_ring.{0} pos h0)  := sorry --non-trivial
lemma new_lemma_100702 (h0 : topological_space (has_nndist (has_inter (mul_one_class linarith.comp)))) : preirreducible_space (has_nndist (has_inter (mul_one_class linarith.comp))) := sorry --non-trivial
lemma new_lemma_100703 (h0 : functor.add_const (uniform_space (canonically_ordered_comm_semiring pos)) linarith.comp) : @complete_space.{0} (canonically_ordered_comm_semiring.{0} pos) (@functor.add_const.run.{0 0} (uniform_space.{0} (canonically_ordered_comm_semiring.{0} pos)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_100704 (h0 : set (semi_normed_ring string_imp)) : set.subsingleton h0 := sorry --non-trivial
lemma new_lemma_100705 (h0 : set (has_nnnorm (mul_one_class linarith.ineq))) : set.subsingleton h0 := sorry --non-trivial
lemma new_lemma_100706 (h0 : has_mem.mem (random_gen congr_arg_kind) has_emptyc.emptyc) : @t0_space.{0} (random_gen.{0} congr_arg_kind) (@finset.pi.empty.{1 0} Type topological_space.{0} (random_gen.{0} congr_arg_kind) h0)  := sorry --non-trivial
lemma new_lemma_100707 (h0 : uniform_space (has_ssubset ereal)) : complete_space (has_ssubset ereal) := sorry --non-trivial
lemma new_lemma_100708 (h0 : function.extfun Type topological_space) : @path_connected_space.{0} (semiring.{0} linarith.ineq) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (semiring.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_100709 (h0 : topological_space (canonically_ordered_monoid (finset pos))) : regular_space (canonically_ordered_monoid (finset pos)) := sorry --non-trivial
lemma new_lemma_100710 (h0 : functor.add_const (topological_space (ordered_comm_ring real)) Type) : @discrete_topology.{0} (ordered_comm_ring.{0} real) (@functor.add_const.run.{0 1} (topological_space.{0} (ordered_comm_ring.{0} real)) Type h0)  := sorry --non-trivial
lemma new_lemma_100711 (h0 : topological_space (add_comm_monoid (has_to_string pos))) : path_connected_space (add_comm_monoid (has_to_string pos)) := sorry --non-trivial
lemma new_lemma_100712 (h0 : not (ring (measurable_space.dynkin_system empty) -> false)) : @is_principal_ideal_ring.{0} (measurable_space.dynkin_system.{0} empty) (@classical.by_contradiction'.{1} (ring.{0} (measurable_space.dynkin_system.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_100713 (h0 : fin has_zero.zero) : @complete_lattice.is_Sup_finite_compact.{1} (ordered_comm_ring.{1} Type) (@matrix.vec_empty.{1} (complete_lattice.{1} (ordered_comm_ring.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_100714 (h0 : function.extfun Type ring) : @is_principal_ideal_ring.{0} (cancel_monoid.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type ring.{0} h0 (cancel_monoid.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_100715 (h0 : topological_space (add_comm_monoid (option empty))) : topological_space.separable_space (add_comm_monoid (option empty)) := sorry --non-trivial
lemma new_lemma_100716 (h0 : ring (normed_group (has_inv (normed_group fun_info)))) : is_domain (normed_group (has_inv (normed_group fun_info))) := sorry --non-trivial
lemma new_lemma_100717 (h0 : not (complete_lattice (add_right_cancel_monoid empty) -> false)) : @is_compactly_generated.{0} (add_right_cancel_monoid.{0} empty) (@classical.by_contradiction'.{1} (complete_lattice.{0} (add_right_cancel_monoid.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_100718 (h0 : topological_space (with_one (random_gen (random_gen (random_gen fun_info))))) : path_connected_space (with_one (random_gen (random_gen (random_gen fun_info)))) := sorry --non-trivial
lemma new_lemma_100719 (h0 : list (has_neg (has_Inf (has_Inf linarith.comp)))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_100720 (h0 : not (topological_space (linear_ordered_comm_group_with_zero (mul_one_class char)) -> false)) : @totally_disconnected_space.{0} (linear_ordered_comm_group_with_zero.{0} (mul_one_class.{0} char)) (@classical.by_contradiction'.{1} (topological_space.{0} (linear_ordered_comm_group_with_zero.{0} (mul_one_class.{0} char))) h0)  := sorry --non-trivial
lemma new_lemma_100721 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @unique_factorization_monoid.{0} (pseudo_metric_space.{0} pos) (@function.extfun_app.{2 1} Type cancel_comm_monoid_with_zero.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 cancel_comm_monoid_with_zero.{0}) (pseudo_metric_space.{0} pos))  := sorry --non-trivial
lemma new_lemma_100722 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_cyclic.{0} (linear_ordered_semiring.{0} unsigned) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (linear_ordered_semiring.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_100723 (h0 : add_group (ordered_comm_monoid name)) : is_add_cyclic (ordered_comm_monoid name) := sorry --non-trivial
lemma new_lemma_100724 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @is_principal_ideal_ring.{1} (generalized_boolean_algebra.{1} Type) (@function.extfun_app.{3 2} (Type 1) ring.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 ring.{1}) (generalized_boolean_algebra.{1} Type))  := sorry --non-trivial
lemma new_lemma_100725 (h0 : functor.add_const (topological_space (has_to_string ennreal)) pos) : @regular_space.{0} (has_to_string.{0} ennreal) (@functor.add_const.run.{0 0} (topological_space.{0} (has_to_string.{0} ennreal)) pos h0)  := sorry --non-trivial
lemma new_lemma_100726 (h0 : not (topological_space (has_append linarith.ineq) -> false)) : @t0_space.{0} (has_append.{0} linarith.ineq) (@classical.by_contradiction'.{1} (topological_space.{0} (has_append.{0} linarith.ineq)) h0)  := sorry --non-trivial
lemma new_lemma_100727 (h0 : filter (with_one (random_gen (random_gen to_additive.value_type)))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_100728 (h0 : functor.add_const (topological_space (ordered_comm_monoid linarith.comp)) pos) : @discrete_topology.{0} (ordered_comm_monoid.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (ordered_comm_monoid.{0} linarith.comp)) pos h0)  := sorry --non-trivial
lemma new_lemma_100729 (h0 : topological_space (normed_comm_ring (has_neg (ring nnreal)))) : t1_space (normed_comm_ring (has_neg (ring nnreal))) := sorry --non-trivial
lemma new_lemma_100730 (h0 : functor.add_const (topological_space (ordered_comm_monoid linarith.comp)) pos) : @loc_path_connected_space.{0} (ordered_comm_monoid.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (ordered_comm_monoid.{0} linarith.comp)) pos h0)  := sorry --non-trivial
lemma new_lemma_100731 (h1 : not (group (comm_ring char) -> false)) : @is_cyclic.{0} (comm_ring.{0} char) (@classical.by_contradiction'.{1} (group.{0} (comm_ring.{0} char)) h1)  := sorry --non-trivial
lemma new_lemma_100732 (h0 : function.extfun Type complete_lattice) : @is_compactly_generated.{0} (@id.{2} Type congr_arg_kind) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (@id.{2} Type congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_100733 (h0 : function.extfun (complete_linear_order congr_arg_kind) (fun (x : complete_linear_order congr_arg_kind), Prop)) : set.subsingleton (function.extfun_app h0) := sorry --non-trivial
lemma new_lemma_100734 (h0 : fin has_zero.zero) : @monoid.fg.{0} (normed_lattice_add_comm_group.{0} name) (@function.extfun_app.{2 1} Type monoid.{0} (@matrix.vec_empty.{1} (function.extfun.{2 1} Type monoid.{0}) h0) (normed_lattice_add_comm_group.{0} name))  := sorry --non-trivial
lemma new_lemma_100735 (h0 : functor.add_const (topological_space (semigroup linarith.comp)) environment.implicit_infer_kind) : @preirreducible_space.{0} (semigroup.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (semigroup.{0} linarith.comp)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_100736 (h2 : topological_space (distrib to_additive.value_type)) : totally_disconnected_space (distrib to_additive.value_type) := sorry --non-trivial
lemma new_lemma_100737 (h0 : functor.add_const (function.extfun Type topological_space) Type) : @normal_space.{0} (has_add.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type topological_space.{0}) Type h0) (has_add.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_100738 (h0 : topological_space (has_zero (boolean_algebra linarith.comp))) : regular_space (has_zero (boolean_algebra linarith.comp)) := sorry --non-trivial
lemma new_lemma_100739 (h0 : functor.add_const (function.extfun (Type 1) topological_space) (ring pos)) : @totally_disconnected_space.{1} (add_comm_monoid.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) topological_space.{1}) (ring.{0} pos) h0) (add_comm_monoid.{1} Type))  := sorry --non-trivial
lemma new_lemma_100740 (h0 : topological_space (finset (option (option ennreal)))) : totally_separated_space (finset (option (option ennreal))) := sorry --non-trivial
lemma new_lemma_100741 (h0 : functor.add_const (topological_space (add_comm_monoid name)) pos) : @preconnected_space.{0} (add_comm_monoid.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (add_comm_monoid.{0} name)) pos h0)  := sorry --non-trivial
lemma new_lemma_100742 (h1 : cancel_comm_monoid_with_zero (nondiscrete_normed_field (mul_one_class string.iterator_imp))) (h2 : add_group (gcd_monoid (nondiscrete_normed_field (mul_one_class string.iterator_imp)))) : is_add_cyclic (gcd_monoid (nondiscrete_normed_field (mul_one_class string.iterator_imp))) := sorry --non-trivial
lemma new_lemma_100743 (h0 : topological_space (ordered_comm_ring (has_Inf name))) : loc_path_connected_space (ordered_comm_ring (has_Inf name)) := sorry --non-trivial
lemma new_lemma_100744 (h0 : functor.add_const (complete_lattice (add_cancel_monoid Type)) (has_zero Type)) : @is_compactly_generated.{1} (add_cancel_monoid.{1} Type) (@functor.add_const.run.{1 1} (complete_lattice.{1} (add_cancel_monoid.{1} Type)) (has_zero.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_100745 (h0 : not (semiring (has_star num) -> false)) : @is_noetherian_ring.{0} (has_star.{0} num) (@classical.by_contradiction'.{1} (semiring.{0} (has_star.{0} num)) h0)  := sorry --non-trivial
lemma new_lemma_100746 (h1 : uniform_space (id (random_gen (random_gen linarith.comp_source)))) : complete_space (id (random_gen (random_gen linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_100747 (h0 : functor.comp topological_space complete_distrib_lattice linarith.comp) : @irreducible_space.{0} (complete_distrib_lattice.{0} linarith.comp) (@functor.comp.run.{0 0 0} topological_space.{0} complete_distrib_lattice.{0} linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_100748 (h0 : complete_lattice (has_neg_part (finset name))) : is_atomistic (has_neg_part (finset name)) := sorry --non-trivial
lemma new_lemma_100749 (h0 : add_monoid (has_Sup (complete_distrib_lattice num))) : add_monoid.fg (has_Sup (complete_distrib_lattice num)) := sorry --non-trivial
lemma new_lemma_100750 (h0 : functor.add_const (list (mul_zero_class empty)) num) : list.nodup (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_100751 (h0 : cancel_comm_monoid_with_zero (canonically_ordered_monoid (has_Inf Type))) : unique_factorization_monoid (canonically_ordered_monoid (has_Inf Type)) := sorry --non-trivial
lemma new_lemma_100752 (h0 : functor.add_const (topological_space (has_nndist pos)) Type) : @normal_space.{0} (has_nndist.{0} pos) (@functor.add_const.run.{0 1} (topological_space.{0} (has_nndist.{0} pos)) Type h0)  := sorry --non-trivial
lemma new_lemma_100753 (h0 : finset (pseudo_metric_space ennreal)) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_100754 (h0 : functor.add_const (function.extfun Type topological_space) name) : @path_connected_space.{0} (boolean_algebra.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) name h0) (boolean_algebra.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_100755 (h0 : functor.add_const (ring (ring name)) Type) : @is_principal_ideal_ring.{0} (ring.{0} name) (@functor.add_const.run.{0 1} (ring.{0} (ring.{0} name)) Type h0)  := sorry --non-trivial
lemma new_lemma_100756 (h0 : functor.add_const (complete_lattice (measurable_space.dynkin_system congr_arg_kind)) unsigned) : @is_atomistic.{0} (measurable_space.dynkin_system.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (complete_lattice.{0} (measurable_space.dynkin_system.{0} congr_arg_kind)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_100757 (h0 : semiring (add_comm_semigroup linarith.ineq)) (h4 : add_comm_semigroup linarith.ineq) : even h4 := sorry --non-trivial
lemma new_lemma_100758 (h0 : complete_lattice (generalized_boolean_algebra (boolean_algebra linarith.comp))) : is_compactly_generated (generalized_boolean_algebra (boolean_algebra linarith.comp)) := sorry --non-trivial
lemma new_lemma_100759 (h0 : functor.add_const (function.extfun Type topological_space) pos) : @topological_space.separable_space.{0} (semigroup.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) pos h0) (semigroup.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_100760 (h0 : group (add_cancel_comm_monoid (topological_space linarith.ineq))) : is_cyclic (add_cancel_comm_monoid (topological_space linarith.ineq)) := sorry --non-trivial
lemma new_lemma_100761 (h0 : fin has_zero.zero) : @is_domain.{0} (canonically_linear_ordered_monoid.{0} linarith.comp) (@matrix.vec_empty.{0} (ring.{0} (canonically_linear_ordered_monoid.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_100762 (h0 : functor.add_const (group (finset linarith.comp)) (ring (finset Type))) : @is_cyclic.{0} (finset.{0} linarith.comp) (@functor.add_const.run.{0 1} (group.{0} (finset.{0} linarith.comp)) (ring.{1} (finset.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_100763 (h2 : group to_additive.value_type) : is_cyclic to_additive.value_type := sorry --non-trivial
lemma new_lemma_100764 (h1 : topological_space (normed_field (topological_space (random_gen fun_info)))) : totally_disconnected_space (normed_field (topological_space (random_gen fun_info))) := sorry --non-trivial
lemma new_lemma_100765 (h0 : functor.add_const (fin has_zero.zero) (has_add pos)) : @regular_space.{1} (ordered_comm_monoid.{1} Type) (@matrix.vec_empty.{1} (topological_space.{1} (ordered_comm_monoid.{1} Type)) (@functor.add_const.run.{0 0} (fin (@has_zero.zero.{0} nat nat.has_zero)) (has_add.{0} pos) h0))  := sorry --non-trivial
lemma new_lemma_100766 (h0 : ring (linear_ordered_comm_ring (semiring (semiring empty)))) : strong_rank_condition (linear_ordered_comm_ring (semiring (semiring empty))) := sorry --non-trivial
lemma new_lemma_100767 (h0 : functor.add_const (group (cancel_monoid Type)) linarith.comp) : @normalizer_condition.{1} (cancel_monoid.{1} Type) (@functor.add_const.run.{1 0} (group.{1} (cancel_monoid.{1} Type)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_100768 (h0 : group (boolean_algebra.core congr_arg_kind)) : is_simple_group (boolean_algebra.core congr_arg_kind) := sorry --non-trivial
lemma new_lemma_100769 (h0 : topological_space (has_nndist (has_to_string (has_to_string name)))) : normal_space (has_nndist (has_to_string (has_to_string name))) := sorry --non-trivial
lemma new_lemma_100770 (h2 : topological_space (add_left_cancel_monoid (add_left_cancel_monoid to_additive.value_type))) : path_connected_space (add_left_cancel_monoid (add_left_cancel_monoid to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_100771 (h0 : group (has_norm (random_gen (random_gen (random_gen (random_gen char)))))) : group.fg (has_norm (random_gen (random_gen (random_gen (random_gen char))))) := sorry --non-trivial
lemma new_lemma_100772 (h0 : topological_space (semigroup pos)) : normal_space (semigroup pos) := sorry --non-trivial
lemma new_lemma_100773 (h0 : functor.add_const (complete_lattice (has_neg linarith.comp)) (has_nndist Type)) : @is_atomistic.{0} (has_neg.{0} linarith.comp) (@functor.add_const.run.{0 1} (complete_lattice.{0} (has_neg.{0} linarith.comp)) (has_nndist.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_100774 (h0 : complete_lattice (comm_group ennreal)) : is_compactly_generated (comm_group ennreal) := sorry --non-trivial
lemma new_lemma_100775 (h0 : functor.add_const (list (normed_comm_ring pos)) (has_neg pos)) : list.nodup (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_100776 (h0 : semiring (has_to_string (has_add linarith.comp))) : is_noetherian_ring (has_to_string (has_add linarith.comp)) := sorry --non-trivial
lemma new_lemma_100777 (h0 : finset (mul_zero_class (has_nndist (finset ennreal)))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_100778 (h0 : cancel_comm_monoid_with_zero (has_to_string name)) : unique_factorization_monoid (has_to_string name) := sorry --non-trivial
lemma new_lemma_100779 (h0 : function.extfun (Type 1) group) : @is_cyclic.{1} (comm_group.{1} Type) (@function.extfun_app.{3 2} (Type 1) group.{1} h0 (comm_group.{1} Type))  := sorry --non-trivial
lemma new_lemma_100780 (h0 : ring (semi_normed_ring (has_nnnorm (comm_ring char)))) : is_domain (semi_normed_ring (has_nnnorm (comm_ring char))) := sorry --non-trivial
lemma new_lemma_100781 (h0 : ring (pseudo_metric_space (option (option (option (option (option ennreal))))))) : strong_rank_condition (pseudo_metric_space (option (option (option (option (option ennreal)))))) := sorry --non-trivial
lemma new_lemma_100782 (h0 : add_group (cancel_monoid (finset ennreal))) : is_add_cyclic (cancel_monoid (finset ennreal)) := sorry --non-trivial
lemma new_lemma_100783 (h0 : functor.add_const (function.extfun Type complete_lattice) linarith.comp) : @is_compactly_generated.{0} (boolean_algebra.{0} pos) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type complete_lattice.{0}) linarith.comp h0) (boolean_algebra.{0} pos))  := sorry --non-trivial
lemma new_lemma_100784 (h0 : topological_space (has_neg (finset linarith.comp))) : normal_space (has_neg (finset linarith.comp)) := sorry --non-trivial
lemma new_lemma_100785 (h0 : uniform_space (distrib (has_nnnorm string.iterator_imp))) : complete_space (distrib (has_nnnorm string.iterator_imp)) := sorry --non-trivial
lemma new_lemma_100786 (h0 : topological_space (has_add (ring pos))) : loc_path_connected_space (has_add (ring pos)) := sorry --non-trivial
lemma new_lemma_100787 (h0 : functor.add_const (topological_space (has_star unsigned)) (option (option (option (option empty))))) : @locally_compact_space.{0} (has_star.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (has_star.{0} unsigned)) (option.{0} (option.{0} (option.{0} (option.{0} empty)))) h0)  := sorry --non-trivial
lemma new_lemma_100788 (h0 : functor.add_const (monoid (add_cancel_monoid linarith.comp)) Type) : @monoid.fg.{0} (add_cancel_monoid.{0} linarith.comp) (@functor.add_const.run.{0 1} (monoid.{0} (add_cancel_monoid.{0} linarith.comp)) Type h0)  := sorry --non-trivial
lemma new_lemma_100789 (h0 : functor.add_const (list (normed_comm_ring Type)) linarith.comp) : palindrome (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_100790 (h0 : not (topological_space (normed_group to_additive.value_type) -> false)) : @path_connected_space.{0} (normed_group.{0} to_additive.value_type) (@classical.by_contradiction'.{1} (topological_space.{0} (normed_group.{0} to_additive.value_type)) h0)  := sorry --non-trivial
lemma new_lemma_100791 (h0 : not (topological_space (has_append linarith.comp_source) -> false)) : @t0_space.{0} (has_append.{0} linarith.comp_source) (@classical.by_contradiction'.{1} (topological_space.{0} (has_append.{0} linarith.comp_source)) h0)  := sorry --non-trivial
lemma new_lemma_100792 (h0 : functor.add_const (topological_space (boolean_algebra Type)) (has_zero (has_zero Type))) : @locally_compact_space.{1} (boolean_algebra.{1} Type) (@functor.add_const.run.{1 1} (topological_space.{1} (boolean_algebra.{1} Type)) (has_zero.{1} (has_zero.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_100793 (h0 : ring (add_comm_monoid (finset Type))) : is_principal_ideal_ring (add_comm_monoid (finset Type)) := sorry --non-trivial
lemma new_lemma_100794 (h0 : functor.add_const (topological_space (boolean_algebra Type)) pos) : @t0_space.{1} (boolean_algebra.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (boolean_algebra.{1} Type)) pos h0)  := sorry --non-trivial
lemma new_lemma_100795 (h0 : complete_lattice (has_top linarith.comp)) : is_compactly_generated (has_top linarith.comp) := sorry --non-trivial
lemma new_lemma_100796 (h0 : functor.add_const (cancel_comm_monoid_with_zero (normed_comm_ring Type)) unsigned) : @unique_factorization_monoid.{1} (normed_comm_ring.{1} Type) (@functor.add_const.run.{1 0} (cancel_comm_monoid_with_zero.{1} (normed_comm_ring.{1} Type)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_100797 (h0 : topological_space (canonically_linear_ordered_monoid (has_add (option pos)))) : normal_space (canonically_linear_ordered_monoid (has_add (option pos))) := sorry --non-trivial
lemma new_lemma_100798 (h1 : add_group (topological_space (has_nnnorm to_additive.value_type))) : is_add_cyclic (topological_space (has_nnnorm to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_100799 (h0 : topological_space (distrib string_imp)) : totally_disconnected_space (distrib string_imp) := sorry --non-trivial
lemma new_lemma_100800 (h0 : functor.add_const (list (boolean_algebra.core name)) name) : list.nodup (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_100801 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @path_connected_space.{0} (monoid.{0} (option.{0} unsigned)) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (monoid.{0} (option.{0} unsigned)))  := sorry --non-trivial
lemma new_lemma_100802 (h0 : functor.add_const (cancel_comm_monoid_with_zero (has_nndist pos)) ennreal) : @unique_factorization_monoid.{0} (has_nndist.{0} pos) (@functor.add_const.run.{0 0} (cancel_comm_monoid_with_zero.{0} (has_nndist.{0} pos)) ennreal h0)  := sorry --non-trivial
lemma new_lemma_100803 (h0 : group (linear_ordered_cancel_comm_monoid unsigned)) : normalizer_condition (linear_ordered_cancel_comm_monoid unsigned) := sorry --non-trivial
lemma new_lemma_100804 (h0 : add_group (has_nnnorm (has_nnnorm linarith.ineq))) : is_add_cyclic (has_nnnorm (has_nnnorm linarith.ineq)) := sorry --non-trivial
lemma new_lemma_100805 (h0 : topological_space (has_add (has_neg (has_neg linarith.comp)))) : totally_separated_space (has_add (has_neg (has_neg linarith.comp))) := sorry --non-trivial
lemma new_lemma_100806 (h0 : functor.add_const (topological_space (complete_distrib_lattice name)) linarith.comp) : @regular_space.{0} (complete_distrib_lattice.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (complete_distrib_lattice.{0} name)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_100807 (h1 : not (ring (random_gen linarith.ineq) -> false)) : @strong_rank_condition.{0} (random_gen.{0} linarith.ineq) (@classical.by_contradiction'.{1} (ring.{0} (random_gen.{0} linarith.ineq)) h1)  := sorry --non-trivial
lemma new_lemma_100808 (h0 : add_group (with_zero char)) : is_add_cyclic (with_zero char) := sorry --non-trivial
lemma new_lemma_100809 (h0 : function.extfun Type finset) : finset.nonempty (function.extfun_app h0 (has_nndist unsigned)) := sorry --non-trivial
lemma new_lemma_100810 (h0 : function.extfun Type filter) : filter.ne_bot (function.extfun_app h0 (dlist string_imp)) := sorry --non-trivial
lemma new_lemma_100811 (h0 : functor.add_const (topological_space (canonically_ordered_comm_semiring name)) unsigned) : @totally_separated_space.{0} (canonically_ordered_comm_semiring.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (canonically_ordered_comm_semiring.{0} name)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_100812 (h0 : complete_lattice (add_group num)) : is_compactly_generated (add_group num) := sorry --non-trivial
lemma new_lemma_100813 (h1 : uniform_space (random_gen (has_nnnorm reducibility_hints))) : complete_space (random_gen (has_nnnorm reducibility_hints)) := sorry --non-trivial
lemma new_lemma_100814 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @discrete_topology.{0} (has_norm.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_norm.{0} empty))  := sorry --non-trivial
lemma new_lemma_100815 (h3 : functor.comp ring non_unital_non_assoc_semiring to_additive.value_type) : @rank_condition.{0} (non_unital_non_assoc_semiring.{0} to_additive.value_type) (@functor.comp.run.{0 0 0} ring.{0} non_unital_non_assoc_semiring.{0} to_additive.value_type h3)  := sorry --non-trivial
lemma new_lemma_100816 (h0 : monoid (has_inter (comm_monoid empty))) : monoid.fg (has_inter (comm_monoid empty)) := sorry --non-trivial
lemma new_lemma_100817 (h0 : ring (semigroup (has_add (has_nndist Type)))) : is_domain (semigroup (has_add (has_nndist Type))) := sorry --non-trivial
lemma new_lemma_100818 (h0 : functor.add_const (functor.add_const (ring linarith.comp) linarith.comp) (has_neg (has_neg name))) : @is_domain.{0} linarith.comp (@functor.add_const.run.{0 0} (ring.{0} linarith.comp) linarith.comp (@functor.add_const.run.{0 0} (functor.add_const.{0 0} (ring.{0} linarith.comp) linarith.comp) (has_neg.{0} (has_neg.{0} name)) h0))  := sorry --non-trivial
lemma new_lemma_100819 (h0 : ring (complete_distrib_lattice unsigned) -> Prop) (h1 : Exists (fun (x : ring (complete_distrib_lattice unsigned)), h0 x)) : @strong_rank_condition.{0} (complete_distrib_lattice.{0} unsigned) (@classical.some.{1} (ring.{0} (complete_distrib_lattice.{0} unsigned)) h0 h1)  := sorry --non-trivial
lemma new_lemma_100820 (h0 : functor.add_const (group (boolean_algebra linarith.comp)) linarith.comp) : @is_simple_group.{0} (boolean_algebra.{0} linarith.comp) (@functor.add_const.run.{0 0} (group.{0} (boolean_algebra.{0} linarith.comp)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_100821 (h0 : topological_space (add_semigroup unsigned)) : t0_space (add_semigroup unsigned) := sorry --non-trivial
lemma new_lemma_100822 (h0 : filter (linear_ordered_add_comm_group fun_info)) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_100823 (h0 : ring (distrib (mul_one_class fun_info))) : rank_condition (distrib (mul_one_class fun_info)) := sorry --non-trivial
lemma new_lemma_100824 (h0 : ring (normed_group (has_norm linarith.comp))) : strong_rank_condition (normed_group (has_norm linarith.comp)) := sorry --non-trivial
lemma new_lemma_100825 (h2 : filter (div_inv_monoid fun_info)) : filter.ne_bot h2 := sorry --non-trivial
lemma new_lemma_100826 (h0 : functor.add_const (ring (finset Type)) pos) : @is_domain.{1} (finset.{1} Type) (@functor.add_const.run.{1 0} (ring.{1} (finset.{1} Type)) pos h0)  := sorry --non-trivial
lemma new_lemma_100827 (h0 : finset (has_to_string (has_neg (ring (ring (has_add (ring Type))))))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_100828 (h0 : function.extfun Type topological_space) : @t1_space.{0} (group_with_zero.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (group_with_zero.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_100829 (h0 : functor.add_const (complete_lattice (add_cancel_monoid Type)) (has_neg_part pos)) : @is_compactly_generated.{1} (add_cancel_monoid.{1} Type) (@functor.add_const.run.{1 0} (complete_lattice.{1} (add_cancel_monoid.{1} Type)) (has_neg_part.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_100830 (h0 : complete_lattice (non_unital_non_assoc_semiring (mul_one_class fun_info))) : complete_lattice.is_Sup_finite_compact (non_unital_non_assoc_semiring (mul_one_class fun_info)) := sorry --non-trivial
lemma new_lemma_100831 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_atomistic.{0} (has_emptyc.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (has_emptyc.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_100832 (h2 : ring congr_arg_kind) : strong_rank_condition congr_arg_kind := sorry --non-trivial
lemma new_lemma_100833 (h0 : ring (ordered_comm_ring (canonically_linear_ordered_monoid name))) : strong_rank_condition (ordered_comm_ring (canonically_linear_ordered_monoid name)) := sorry --non-trivial
lemma new_lemma_100834 (h0 : topological_space (partial_order num)) : discrete_topology (partial_order num) := sorry --non-trivial
lemma new_lemma_100835 (h0 : ordered_comm_monoid real) : has_exists_mul_of_le real := sorry --non-trivial
lemma new_lemma_100836 (h0 : functor.add_const (ring (has_nndist pos)) name) : @rank_condition.{0} (has_nndist.{0} pos) (@functor.add_const.run.{0 0} (ring.{0} (has_nndist.{0} pos)) name h0)  := sorry --non-trivial
lemma new_lemma_100837 (h0 : complete_lattice (canonically_ordered_add_monoid (option empty))) : complete_lattice.is_Sup_finite_compact (canonically_ordered_add_monoid (option empty)) := sorry --non-trivial
lemma new_lemma_100838 (h0 : ring (has_add string_imp)) : rank_condition (has_add string_imp) := sorry --non-trivial
lemma new_lemma_100839 (h0 : filter (normed_group (random_gen linarith.ineq))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_100840 (h0 : topological_space (has_nndist (comm_group (has_add unsigned)))) : locally_compact_space (has_nndist (comm_group (has_add unsigned))) := sorry --non-trivial
lemma new_lemma_100841 (h1 : function.extfun Type monoid) : @monoid.fg.{0} string_imp (@function.extfun_app.{2 1} Type monoid.{0} h1 string_imp)  := sorry --non-trivial
lemma new_lemma_100842 (h0 : function.extfun Type topological_space) : @locally_compact_space.{0} (add_cancel_monoid.{0} ennreal) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (add_cancel_monoid.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_100843 (h0 : set (set (simple_graph char))) (h1 : set (simple_graph char)) : measurable_space.dynkin_system.generate_has h0 h1 := sorry --non-trivial
lemma new_lemma_100844 (h0 : group (complete_linear_order (semiring (semiring (semiring empty))))) : normalizer_condition (complete_linear_order (semiring (semiring (semiring empty)))) := sorry --non-trivial
lemma new_lemma_100845 (h0 : topological_space (pseudo_metric_space pos)) : path_connected_space (pseudo_metric_space pos) := sorry --non-trivial
lemma new_lemma_100846 (h0 : topological_space (normed_group congr_arg_kind)) : normal_space (normed_group congr_arg_kind) := sorry --non-trivial
lemma new_lemma_100847 (h0 : ring (has_Inf (finset pos))) : rank_condition (has_Inf (finset pos)) := sorry --non-trivial
lemma new_lemma_100848 (h0 : topological_space (finset (ring Type))) : regular_space (finset (ring Type)) := sorry --non-trivial
lemma new_lemma_100849 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_domain.{0} (canonically_linear_ordered_monoid.{0} real) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (canonically_linear_ordered_monoid.{0} real))  := sorry --non-trivial
lemma new_lemma_100850 (h0 : function.extfun Type (functor.add_const (topological_space (add_left_cancel_semigroup empty)))) : @normal_space.{0} (add_left_cancel_semigroup.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (add_left_cancel_semigroup.{0} empty)) empty (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (topological_space.{0} (add_left_cancel_semigroup.{0} empty))) h0 empty))  := sorry --non-trivial
lemma new_lemma_100851 (h0 : list (comm_group (has_nndist unsigned))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_100852 (h0 : topological_space (has_nndist (has_add linarith.comp))) : locally_compact_space (has_nndist (has_add linarith.comp)) := sorry --non-trivial
lemma new_lemma_100853 (h0 : fin has_zero.zero) : @has_exists_mul_of_le.{0} (has_nndist.{0} linarith.comp) (@matrix.vec_empty.{0} (ordered_comm_monoid.{0} (has_nndist.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_100854 (h0 : topological_space (normed_comm_ring (option (ring unsigned)))) : totally_disconnected_space (normed_comm_ring (option (ring unsigned))) := sorry --non-trivial
lemma new_lemma_100855 (h0 : function.extfun (Type 1) (functor.add_const (topological_space (has_Inf name)))) : @preirreducible_space.{0} (has_Inf.{0} name) (@functor.add_const.run.{0 1} (topological_space.{0} (has_Inf.{0} name)) Type (@function.extfun_app.{3 1} (Type 1) (functor.add_const.{0 1} (topological_space.{0} (has_Inf.{0} name))) h0 Type))  := sorry --non-trivial
lemma new_lemma_100856 (h0 : function.extfun (Type 1) filter) : countable_Inter_filter (function.extfun_app h0 (add_cancel_monoid Type)) := sorry --non-trivial
lemma new_lemma_100857 (h0 : complete_lattice (canonically_linear_ordered_monoid (option unsigned))) : is_atomistic (canonically_linear_ordered_monoid (option unsigned)) := sorry --non-trivial
lemma new_lemma_100858 (h0 : list (has_neg (ring (ring (ring linarith.comp))))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_100859 (h0 : complete_lattice (monoid_with_zero ennreal)) : complete_lattice.is_Sup_finite_compact (monoid_with_zero ennreal) := sorry --non-trivial
lemma new_lemma_100860 (h1 : function.extfun Type complete_lattice) : @is_compactly_generated.{0} (complete_semilattice_Sup.{0} linarith.ineq) (@function.extfun_app.{2 1} Type complete_lattice.{0} h1 (complete_semilattice_Sup.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_100861 (h0 : function.extfun Type ring) : @strong_rank_condition.{0} (complete_distrib_lattice.{0} ennreal) (@function.extfun_app.{2 1} Type ring.{0} h0 (complete_distrib_lattice.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_100862 (h0 : group (mul_zero_class (semiring (semiring num)))) : is_cyclic (mul_zero_class (semiring (semiring num))) := sorry --non-trivial
lemma new_lemma_100863 (h1 : set (nondiscrete_normed_field linarith.ineq -> ereal)) : set.separates_points h1 := sorry --non-trivial
lemma new_lemma_100864 (h0 : functor.comp topological_space has_zero unsigned) : @preirreducible_space.{0} (has_zero.{0} unsigned) (@functor.comp.run.{0 0 0} topological_space.{0} has_zero.{0} unsigned h0)  := sorry --non-trivial
lemma new_lemma_100865 (h0 : topological_space (measurable_space.dynkin_system (semiring (semiring (semiring num))))) : totally_separated_space (measurable_space.dynkin_system (semiring (semiring (semiring num)))) := sorry --non-trivial
lemma new_lemma_100866 (h2 : topological_space (mul_one_class (add_comm_semigroup linarith.ineq))) : path_connected_space (mul_one_class (add_comm_semigroup linarith.ineq)) := sorry --non-trivial
lemma new_lemma_100867 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @t0_space.{0} (pseudo_metric_space.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (pseudo_metric_space.{0} pos))  := sorry --non-trivial
lemma new_lemma_100868 (h0 : function.extfun (Type 1) (functor.add_const (complete_lattice (has_pos_part linarith.comp)))) : @complete_lattice.is_Sup_finite_compact.{0} (has_pos_part.{0} linarith.comp) (@functor.add_const.run.{0 1} (complete_lattice.{0} (has_pos_part.{0} linarith.comp)) Type (@function.extfun_app.{3 1} (Type 1) (functor.add_const.{0 1} (complete_lattice.{0} (has_pos_part.{0} linarith.comp))) h0 Type))  := sorry --non-trivial
lemma new_lemma_100869 (h0 : functor.add_const (topological_space (has_nndist name)) unsigned) : @topological_space.separable_space.{0} (has_nndist.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (has_nndist.{0} name)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_100870 (h0 : ring (has_compl enat)) : is_domain (has_compl enat) := sorry --non-trivial
lemma new_lemma_100871 (h0 : topological_space (simple_graph (mul_one_class linarith.ineq))) : path_connected_space (simple_graph (mul_one_class linarith.ineq)) := sorry --non-trivial
lemma new_lemma_100872 (h0 : functor.add_const (topological_space (boolean_algebra.core environment.implicit_infer_kind)) Type) : @locally_compact_space.{0} (boolean_algebra.core.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 1} (topological_space.{0} (boolean_algebra.core.{0} environment.implicit_infer_kind)) Type h0)  := sorry --non-trivial
lemma new_lemma_100873 (h0 : complete_lattice (measurable_space (semiring empty))) : is_compactly_generated (measurable_space (semiring empty)) := sorry --non-trivial
lemma new_lemma_100874 (h0 : ring (measurable_space (metric_space (metric_space num)))) : rank_condition (measurable_space (metric_space (metric_space num))) := sorry --non-trivial
lemma new_lemma_100875 (h0 : functor.add_const (finset (has_zero environment.implicit_infer_kind)) name) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_100876 (h0 : function.extfun (Type 1) topological_space) : @discrete_topology.{1} (ring.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} h0 (ring.{1} Type))  := sorry --non-trivial
lemma new_lemma_100877 (h0 : not (function.extfun Type complete_lattice -> false)) : @complete_lattice.is_Sup_finite_compact.{0} (add_monoid.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type complete_lattice.{0}) h0) (add_monoid.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_100878 (h0 : functor.add_const (topological_space (has_star unsigned)) num) : @normal_space.{0} (has_star.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (has_star.{0} unsigned)) num h0)  := sorry --non-trivial
lemma new_lemma_100879 (h0 : complete_lattice (has_ssubset string.iterator_imp)) : is_compactly_generated (has_ssubset string.iterator_imp) := sorry --non-trivial
lemma new_lemma_100880 (h0 : function.extfun Type topological_space) : @path_connected_space.{0} (finset.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (finset.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_100881 (h0 : ring (normed_comm_ring ennreal)) : rank_condition (normed_comm_ring ennreal) := sorry --non-trivial
lemma new_lemma_100882 (h0 : not (complete_lattice linarith.comp_source -> false)) : @is_compactly_generated.{0} linarith.comp_source (@classical.by_contradiction'.{1} (complete_lattice.{0} linarith.comp_source) h0)  := sorry --non-trivial
lemma new_lemma_100883 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @group.fg.{0} (cancel_monoid.{0} num) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (cancel_monoid.{0} num))  := sorry --non-trivial
lemma new_lemma_100884 (h0 : function.extfun Type topological_space) : @t1_space.{0} (generalized_boolean_algebra.{0} real) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (generalized_boolean_algebra.{0} real))  := sorry --non-trivial
lemma new_lemma_100885 (h0 : topological_space (linear_order unsigned)) : t1_space (linear_order unsigned) := sorry --non-trivial
lemma new_lemma_100886 (h0 : add_group (ring num) -> Prop) (h1 : Exists (fun (x : add_group (ring num)), h0 x)) : @is_add_cyclic.{0} (ring.{0} num) (@classical.some.{1} (add_group.{0} (ring.{0} num)) h0 h1)  := sorry --non-trivial
lemma new_lemma_100887 (h0 : topological_space (add_right_cancel_monoid (semiring (semiring (semiring empty))))) : preirreducible_space (add_right_cancel_monoid (semiring (semiring (semiring empty)))) := sorry --non-trivial
lemma new_lemma_100888 (h0 : thunk (fin has_zero.zero)) : @Lim.{0} Prop sierpinski_space (@nonempty_of_inhabited.{1} Prop sort.inhabited.{0}) (@matrix.vec_empty.{0} (filter.{0} Prop) (@trace_call_stack.{0} (fin (@has_zero.zero.{0} nat nat.has_zero)) h0))  := sorry --non-trivial
lemma new_lemma_100889 (h0 : group (has_nndist (option (finset (semigroup pos))))) : is_simple_group (has_nndist (option (finset (semigroup pos)))) := sorry --non-trivial
lemma new_lemma_100890 (h0 : topological_space (normed_comm_ring (finset (finset pos)))) : regular_space (normed_comm_ring (finset (finset pos))) := sorry --non-trivial
lemma new_lemma_100891 (h0 : complete_lattice (has_norm (has_ssubset linarith.ineq))) : is_compactly_generated (has_norm (has_ssubset linarith.ineq)) := sorry --non-trivial
lemma new_lemma_100892 (h0 : topological_space (normed_comm_ring (semigroup (finset pos)))) : preirreducible_space (normed_comm_ring (semigroup (finset pos))) := sorry --non-trivial
lemma new_lemma_100893 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @totally_disconnected_space.{0} (canonically_linear_ordered_monoid.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (canonically_linear_ordered_monoid.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_100894 (h0 : list (comm_group (has_add name))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_100895 (h0 : function.extfun Type list) : list.nodup (function.extfun_app h0 (add_group congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_100896 (h0 : functor.add_const (list (normed_comm_ring Type)) pos) : list.nodup (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_100897 (h0 : function.extfun Type group) : @group.fg.{0} (random_gen.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type group.{0} h0 (random_gen.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_100898 (h0 : ring (left_cancel_semigroup (semiring (semiring (semiring empty))))) : is_domain (left_cancel_semigroup (semiring (semiring (semiring empty)))) := sorry --non-trivial
lemma new_lemma_100899 (h0 : add_group (ring (boolean_algebra (boolean_algebra.core Type)))) : is_add_cyclic (ring (boolean_algebra (boolean_algebra.core Type))) := sorry --non-trivial
lemma new_lemma_100900 (h0 : group (random_gen (denumerable fun_info))) : group.fg (random_gen (denumerable fun_info)) := sorry --non-trivial
lemma new_lemma_100901 (h0 h1 : non_unital_non_assoc_semiring enat -> non_unital_non_assoc_semiring enat) : function.commute h0 h1 := sorry --non-trivial
lemma new_lemma_100902 (h0 : add_group (has_compl (mul_one_class char))) : is_add_cyclic (has_compl (mul_one_class char)) := sorry --non-trivial
lemma new_lemma_100903 (h1 : add_group (topological_space linarith.ineq)) : is_add_cyclic (topological_space linarith.ineq) := sorry --non-trivial
lemma new_lemma_100904 (h0 : ring (with_one (random_gen (random_gen string_imp)))) : is_domain (with_one (random_gen (random_gen string_imp))) := sorry --non-trivial
lemma new_lemma_100905 (h0 : functor.add_const (filter auto.case_option) num) : countable_Inter_filter (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_100906 (h1 : filter (with_zero string_imp)) : filter.ne_bot h1 := sorry --non-trivial
lemma new_lemma_100907 (h5 : topological_space char) (h6 : preorder char) : order_topology char := sorry --non-trivial
lemma new_lemma_100908 (h0 : function.extfun (finset Type) (has_mem.mem (random_gen congr_arg_kind))) : @complete_lattice.is_Sup_finite_compact.{0} (random_gen.{0} congr_arg_kind) (@finset.pi.empty.{1 0} Type complete_lattice.{0} (random_gen.{0} congr_arg_kind) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (random_gen.{0} congr_arg_kind)) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_100909 (h0 : topological_space (semiring (semiring (semiring (semiring (semiring unsigned)))))) : t0_space (semiring (semiring (semiring (semiring (semiring unsigned))))) := sorry --non-trivial
lemma new_lemma_100910 (h0 : complete_lattice (topological_space (random_gen occurrences))) : is_compactly_generated (topological_space (random_gen occurrences)) := sorry --non-trivial
lemma new_lemma_100911 (h0 : ring (has_pos_part (ordered_comm_ring linarith.comp))) : is_domain (has_pos_part (ordered_comm_ring linarith.comp)) := sorry --non-trivial
lemma new_lemma_100912 (h0 : not (ring (has_ssubset string.iterator_imp) -> false)) : @is_domain.{0} (has_ssubset.{0} string.iterator_imp) (@classical.by_contradiction'.{1} (ring.{0} (has_ssubset.{0} string.iterator_imp)) h0)  := sorry --non-trivial
lemma new_lemma_100913 (h0 : topological_space (has_append (has_inv linarith.comp_source))) : t0_space (has_append (has_inv linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_100914 (h2 h3 : multiset linarith.ineq) : multiset.le h2 h3 := sorry --non-trivial
lemma new_lemma_100915 (h0 : topological_space (has_edist empty)) : preirreducible_space (has_edist empty) := sorry --non-trivial
lemma new_lemma_100916 (h0 : has_mem.mem linarith.comp_source has_emptyc.emptyc) : @is_domain.{0} linarith.comp_source (@finset.pi.empty.{1 0} Type ring.{0} linarith.comp_source h0)  := sorry --non-trivial
lemma new_lemma_100917 (h0 : functor.add_const (add_monoid (has_zero Type)) environment.implicit_infer_kind) : @add_monoid.fg.{1} (has_zero.{1} Type) (@functor.add_const.run.{1 0} (add_monoid.{1} (has_zero.{1} Type)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_100918 (h0 : has_pos_part real -> has_pos_part real -> Prop) : is_antisymm (has_pos_part real) h0 := sorry --non-trivial
lemma new_lemma_100919 (h0 : not (uniform_space (denumerable linarith.ineq) -> false)) : @complete_space.{0} (denumerable.{0} linarith.ineq) (@classical.by_contradiction'.{1} (uniform_space.{0} (denumerable.{0} linarith.ineq)) h0)  := sorry --non-trivial
lemma new_lemma_100920 (h0 : topological_space (has_zero (finset (finset (finset linarith.comp))))) : loc_path_connected_space (has_zero (finset (finset (finset linarith.comp)))) := sorry --non-trivial
lemma new_lemma_100921 (h0 : function.extfun Type topological_space) : @path_connected_space.{0} (cancel_monoid.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (cancel_monoid.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_100922 (h0 : uniform_space (has_add environment.implicit_infer_kind)) : complete_space (has_add environment.implicit_infer_kind) := sorry --non-trivial
lemma new_lemma_100923 (h2 : topological_space std_gen) (h3 : has_zero char) (h4 : std_gen -> char) : is_path_connected (function.support h4) := sorry --non-trivial
lemma new_lemma_100924 (h0 : function.extfun Type topological_space) : @topological_space.separable_space.{0} (has_inter.{0} ennreal) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_inter.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_100925 (h0 : nat -> Prop -> Prop) (h1 : not (nat -> false)) (h2 : Prop) : nat.repeat h0 (classical.by_contradiction' h1) h2 := sorry --non-trivial
lemma new_lemma_100926 (h0 : ring (normed_comm_ring environment.implicit_infer_kind)) : is_principal_ideal_ring (normed_comm_ring environment.implicit_infer_kind) := sorry --non-trivial
lemma new_lemma_100927 (h0 : functor.add_const (add_group (has_to_string Type)) (has_neg_part (has_neg_part (has_neg_part Type)))) : @is_add_cyclic.{1} (has_to_string.{1} Type) (@functor.add_const.run.{1 1} (add_group.{1} (has_to_string.{1} Type)) (has_neg_part.{1} (has_neg_part.{1} (has_neg_part.{1} Type))) h0)  := sorry --non-trivial
lemma new_lemma_100928 (h0 : not (function.extfun Type complete_lattice -> false)) : @complete_lattice.is_Sup_finite_compact.{0} (has_norm.{0} unsigned) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type complete_lattice.{0}) h0) (has_norm.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_100929 (h0 : not (topological_space (partial_order unsigned) -> false)) : @totally_separated_space.{0} (partial_order.{0} unsigned) (@classical.by_contradiction'.{1} (topological_space.{0} (partial_order.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_100930 (h0 : prod (semigroup empty) (semigroup empty)) : id_rel h0 := sorry --non-trivial
lemma new_lemma_100931 (h0 : add_monoid (boolean_algebra (has_to_string (ring (ring linarith.comp))))) : add_monoid.fg (boolean_algebra (has_to_string (ring (ring linarith.comp)))) := sorry --non-trivial
lemma new_lemma_100932 (h0 : functor.add_const (function.extfun (Type 1) ring) linarith.comp) : @rank_condition.{1} (boolean_algebra.{1} Type) (@function.extfun_app.{3 2} (Type 1) ring.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) ring.{1}) linarith.comp h0) (boolean_algebra.{1} Type))  := sorry --non-trivial
lemma new_lemma_100933 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_noetherian_ring.{0} (semigroup.{0} (semiring.{0} (semiring.{0} empty))) (@function.extfun_app.{2 1} Type semiring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 semiring.{0}) (semigroup.{0} (semiring.{0} (semiring.{0} empty))))  := sorry --non-trivial
lemma new_lemma_100934 (h0 : not (finset (bin_tree congr_arg_kind) -> false)) : finset.nonempty (classical.by_contradiction' h0) := sorry --non-trivial
lemma new_lemma_100935 (h0 : topological_space (cancel_monoid (option name))) : loc_path_connected_space (cancel_monoid (option name)) := sorry --non-trivial
lemma new_lemma_100936 (h0 : ring (measurable_space (has_top linarith.comp_source))) : is_domain (measurable_space (has_top linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_100937 (h0 : function.extfun Type list) : palindrome (function.extfun_app h0 (has_zero pos)) := sorry --non-trivial
lemma new_lemma_100938 (h2 : not (ring reducibility_hints -> false)) : @strong_rank_condition.{0} reducibility_hints (@classical.by_contradiction'.{1} (ring.{0} reducibility_hints) h2)  := sorry --non-trivial
lemma new_lemma_100939 (h0 : function.extfun Type topological_space) : @totally_disconnected_space.{0} (canonically_ordered_comm_semiring.{0} ennreal) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (canonically_ordered_comm_semiring.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_100940 (h0 : not (list (has_top fun_info) -> false)) : list.nodup (classical.by_contradiction' h0) := sorry --non-trivial
lemma new_lemma_100941 (h0 : functor.add_const (topological_space (boolean_algebra.core unsigned)) environment.implicit_infer_kind) : @preirreducible_space.{0} (boolean_algebra.core.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (boolean_algebra.core.{0} unsigned)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_100942 (h0 : group (has_zero (option ennreal))) : normalizer_condition (has_zero (option ennreal)) := sorry --non-trivial
lemma new_lemma_100943 (h0 : measurable_space (finset ennreal)) (h1 : list (measure_theory.measure (finset ennreal))) : list.nodup h1 := sorry --non-trivial
lemma new_lemma_100944 (h0 : functor.add_const (topological_space (finset unsigned)) (option empty)) : @irreducible_space.{0} (finset.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (finset.{0} unsigned)) (option.{0} empty) h0)  := sorry --non-trivial
lemma new_lemma_100945 (h0 : topological_space (has_one (has_top empty))) : totally_disconnected_space (has_one (has_top empty)) := sorry --non-trivial
lemma new_lemma_100946 (h0 : list (has_Inf (has_Inf (has_Inf (has_Inf (has_Inf (has_pos_part pos))))))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_100947 (h0 : function.extfun Type (functor.add_const (topological_space (has_bot empty)))) : @loc_path_connected_space.{0} (has_bot.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (has_bot.{0} empty)) empty (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (topological_space.{0} (has_bot.{0} empty))) h0 empty))  := sorry --non-trivial
lemma new_lemma_100948 (h0 : semiring (has_to_string (has_nndist Type))) : is_noetherian_ring (has_to_string (has_nndist Type)) := sorry --non-trivial
lemma new_lemma_100949 (h0 : topological_space (add_left_cancel_monoid reducibility_hints)) : path_connected_space (add_left_cancel_monoid reducibility_hints) := sorry --non-trivial
lemma new_lemma_100950 (h0 : function.extfun Type topological_space) : @locally_compact_space.{0} (linear_ordered_comm_monoid_with_zero.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (linear_ordered_comm_monoid_with_zero.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_100951 (h1 : ring (has_nnnorm linarith.comp_source)) : rank_condition (has_nnnorm linarith.comp_source) := sorry --non-trivial
lemma new_lemma_100952 (h0 : topological_space (random_gen (has_top fun_info))) : t0_space (random_gen (has_top fun_info)) := sorry --non-trivial
lemma new_lemma_100953 (h0 : add_group (with_bot (comm_ring fun_info))) : is_add_cyclic (with_bot (comm_ring fun_info)) := sorry --non-trivial
lemma new_lemma_100954 (h0 : complete_lattice (has_div (has_compl (mul_one_class (mul_one_class enat))))) : is_compactly_generated (has_div (has_compl (mul_one_class (mul_one_class enat)))) := sorry --non-trivial
lemma new_lemma_100955 (h0 : has_lt (distrib std_gen)) : no_max_order (distrib std_gen) := sorry --non-trivial
lemma new_lemma_100956 (h0 : functor.add_const (add_monoid (has_neg Type)) name) : @add_monoid.fg.{1} (has_neg.{1} Type) (@functor.add_const.run.{1 0} (add_monoid.{1} (has_neg.{1} Type)) name h0)  := sorry --non-trivial
lemma new_lemma_100957 (h0 : topological_space (has_add (has_add real))) : normal_space (has_add (has_add real)) := sorry --non-trivial
lemma new_lemma_100958 (h0 : not (multiset (mul_one_class string_imp) -> false)) (h1 : multiset (mul_one_class string_imp)) : multiset.disjoint (classical.by_contradiction' h0) h1 := sorry --non-trivial
lemma new_lemma_100959 (h0 : complete_lattice (has_sub (semiring congr_arg_kind))) : is_compactly_generated (has_sub (semiring congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_100960 (h0 : topological_space (linear_ordered_semiring (has_top num))) : totally_disconnected_space (linear_ordered_semiring (has_top num)) := sorry --non-trivial
lemma new_lemma_100961 (h0 : not (topological_space (group_with_zero unsigned) -> false)) : @irreducible_space.{0} (group_with_zero.{0} unsigned) (@classical.by_contradiction'.{1} (topological_space.{0} (group_with_zero.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_100962 (h0 : monoid (finset (has_add (has_add Type)))) : monoid.fg (finset (has_add (has_add Type))) := sorry --non-trivial
lemma new_lemma_100963 (h0 : function.extfun Type topological_space) : @irreducible_space.{0} (group_with_zero.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (group_with_zero.{0} num))  := sorry --non-trivial
lemma new_lemma_100964 (h0 : set (set std_gen)) (h1 : set std_gen) : measurable_space.dynkin_system.generate_has h0 h1 := sorry --non-trivial
lemma new_lemma_100965 (h0 : topological_space (option (semiring (semiring congr_arg_kind)))) : preirreducible_space (option (semiring (semiring congr_arg_kind))) := sorry --non-trivial
lemma new_lemma_100966 (h0 : functor.add_const (topological_space (comm_group pos)) environment.implicit_infer_kind) : @irreducible_space.{0} (comm_group.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (comm_group.{0} pos)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_100967 (h0 : complete_lattice (ordered_comm_semiring to_additive.value_type)) : is_compactly_generated (ordered_comm_semiring to_additive.value_type) := sorry --non-trivial
lemma new_lemma_100968 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_simple_group.{0} (add_cancel_monoid.{0} pos) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (add_cancel_monoid.{0} pos))  := sorry --non-trivial
lemma new_lemma_100969 (h0 : uniform_space (comm_semigroup (has_add (sub_neg_monoid real)))) : complete_space (comm_semigroup (has_add (sub_neg_monoid real))) := sorry --non-trivial
lemma new_lemma_100970 (h0 : ring (has_dist ennreal)) : is_domain (has_dist ennreal) := sorry --non-trivial
lemma new_lemma_100971 (h0 : function.extfun Type topological_space) : @topological_space.separable_space.{0} znum (@function.extfun_app.{2 1} Type topological_space.{0} h0 znum)  := sorry --non-trivial
lemma new_lemma_100972 (h0 : topological_space (ordered_comm_monoid (ring (has_neg Type)))) : topological_space.separable_space (ordered_comm_monoid (ring (has_neg Type))) := sorry --non-trivial
lemma new_lemma_100973 (h0 : topological_space (complete_distrib_lattice (option (option empty)))) : irreducible_space (complete_distrib_lattice (option (option empty))) := sorry --non-trivial
lemma new_lemma_100974 (h0 : group (comm_ring (has_compl string_imp))) : is_cyclic (comm_ring (has_compl string_imp)) := sorry --non-trivial
lemma new_lemma_100975 (h0 : ring (has_nnnorm (mul_one_class enat))) : rank_condition (has_nnnorm (mul_one_class enat)) := sorry --non-trivial
lemma new_lemma_100976 (h0 : monoid (is_R_or_C congr_arg_kind)) : monoid.fg (is_R_or_C congr_arg_kind) := sorry --non-trivial
lemma new_lemma_100977 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_simple_group.{0} (canonically_linear_ordered_monoid.{0} real) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (canonically_linear_ordered_monoid.{0} real))  := sorry --non-trivial
lemma new_lemma_100978 (h0 : topological_space (has_norm string_imp)) : locally_compact_space (has_norm string_imp) := sorry --non-trivial
lemma new_lemma_100979 (h0 : group (measurable_space (has_inv (random_gen (random_gen (has_inv linarith.ineq)))))) : group.fg (measurable_space (has_inv (random_gen (random_gen (has_inv linarith.ineq))))) := sorry --non-trivial
lemma new_lemma_100980 (h0 : functor.add_const (ring (add_cancel_monoid name)) (finset pos)) : @is_principal_ideal_ring.{0} (add_cancel_monoid.{0} name) (@functor.add_const.run.{0 0} (ring.{0} (add_cancel_monoid.{0} name)) (finset.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_100981 (h0 : add_group (canonically_ordered_comm_semiring empty)) : is_add_cyclic (canonically_ordered_comm_semiring empty) := sorry --non-trivial
lemma new_lemma_100982 (h0 : topological_space (ordered_comm_ring pos)) : preconnected_space (ordered_comm_ring pos) := sorry --non-trivial
lemma new_lemma_100983 (h0 : functor.add_const (finset (as_linear_order unsigned)) empty) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_100984 (h0 : ring (has_add (add_cancel_monoid (has_pos_part (has_neg (has_add Type)))))) : rank_condition (has_add (add_cancel_monoid (has_pos_part (has_neg (has_add Type))))) := sorry --non-trivial
lemma new_lemma_100985 (h0 : complete_lattice (has_Inf (finset Type))) : complete_lattice.is_Sup_finite_compact (has_Inf (finset Type)) := sorry --non-trivial
lemma new_lemma_100986 (h0 : add_group (linear_ordered_field (option (option pos)))) : is_add_cyclic (linear_ordered_field (option (option pos))) := sorry --non-trivial
lemma new_lemma_100987 (h0 : function.extfun Type list) : palindrome (function.extfun_app h0 (complete_distrib_lattice environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_100988 (h0 : uniform_space (canonically_linear_ordered_monoid (has_pos_part (has_add real)))) : complete_space (canonically_linear_ordered_monoid (has_pos_part (has_add real))) := sorry --non-trivial
lemma new_lemma_100989 (h0 : list (with_one (random_gen linarith.ineq))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_100990 (h0 : functor.add_const (filter (has_to_string environment.implicit_infer_kind)) pos) : countable_Inter_filter (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_100991 (h0 : topological_space (ring empty)) : preirreducible_space (ring empty) := sorry --non-trivial
lemma new_lemma_100992 (h0 : add_group (plift (option (option (option (option unsigned)))))) : is_add_cyclic (plift (option (option (option (option unsigned))))) := sorry --non-trivial
lemma new_lemma_100993 (h0 : function.extfun Type add_monoid) : @add_monoid.fg.{0} (has_Sup.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type add_monoid.{0} h0 (has_Sup.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_100994 (h2 : topological_space (nondiscrete_normed_field linarith.ineq)) (h3 : add_group (nondiscrete_normed_field linarith.ineq)) : topological_add_group (nondiscrete_normed_field linarith.ineq) := sorry --non-trivial
lemma new_lemma_100995 (h0 : topological_space (has_nndist (option (option (option pos))))) : totally_disconnected_space (has_nndist (option (option (option pos)))) := sorry --non-trivial
lemma new_lemma_100996 (h0 : topological_space (has_neg (has_neg name))) : topological_space.separable_space (has_neg (has_neg name)) := sorry --non-trivial
lemma new_lemma_100997 (h1 : has_mem.mem (measurable_space fun_info) has_emptyc.emptyc) : @irreducible_space.{0} (measurable_space.{0} fun_info) (@finset.pi.empty.{1 0} Type topological_space.{0} (measurable_space.{0} fun_info) h1)  := sorry --non-trivial
lemma new_lemma_100998 (h0 : ring (non_unital_non_assoc_semiring (mul_one_class (mul_one_class fun_info)))) : is_domain (non_unital_non_assoc_semiring (mul_one_class (mul_one_class fun_info))) := sorry --non-trivial
lemma new_lemma_100999 (h0 : function.extfun Type (functor.add_const (finset (ring pos)))) : finset.nonempty (functor.add_const.run (function.extfun_app h0 name)) := sorry --non-trivial
lemma new_lemma_101000 (h0 : functor.add_const (filter (sub_neg_monoid pos)) pos) : countable_Inter_filter (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_101001 (h0 : group (has_union (add_group empty))) : group.fg (has_union (add_group empty)) := sorry --non-trivial
lemma new_lemma_101002 (h0 : function.extfun Type ring) : @strong_rank_condition.{0} (has_pos_part.{0} linarith.comp) (@function.extfun_app.{2 1} Type ring.{0} h0 (has_pos_part.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_101003 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @sequential_space.{0} (has_pos_part.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_pos_part.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_101004 (h0 : add_monoid (complete_distrib_lattice (has_Inf Type))) : add_monoid.fg (complete_distrib_lattice (has_Inf Type)) := sorry --non-trivial
lemma new_lemma_101005 (h0 : topological_space (has_to_string (has_to_string unsigned))) : totally_separated_space (has_to_string (has_to_string unsigned)) := sorry --non-trivial
lemma new_lemma_101006 (h0 : monoid (with_one (has_inv linarith.comp_source))) : monoid.fg (with_one (has_inv linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_101007 (h0 : topological_space (has_neg name)) : discrete_topology (has_neg name) := sorry --non-trivial
lemma new_lemma_101008 (h0 : ring (has_sub (semiring unsigned))) : is_domain (has_sub (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_101009 (h0 : topological_space (normed_group (random_gen num))) : preirreducible_space (normed_group (random_gen num)) := sorry --non-trivial
lemma new_lemma_101010 (h0 : denumerable (random_gen string_imp) -> denumerable (random_gen string_imp) -> Prop) (h1 : set (denumerable (random_gen string_imp))) : directed_on h0 h1 := sorry --non-trivial
lemma new_lemma_101011 (h0 : add_group (semiring congr_arg_kind)) : is_add_cyclic (semiring congr_arg_kind) := sorry --non-trivial
lemma new_lemma_101012 (h0 : list (has_add (mul_one_class Type))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_101013 (h0 : function.extfun Type ring) : @is_domain.{0} (non_assoc_semiring.{0} empty) (@function.extfun_app.{2 1} Type ring.{0} h0 (non_assoc_semiring.{0} empty))  := sorry --non-trivial
lemma new_lemma_101014 (h0 : function.extfun Type (functor.add_const (ring ennreal))) : @strong_rank_condition.{0} ennreal (@functor.add_const.run.{0 0} (ring.{0} ennreal) num (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (ring.{0} ennreal)) h0 num))  := sorry --non-trivial
lemma new_lemma_101015 (h0 : ring (has_add (sub_neg_monoid (boolean_algebra (has_Inf real))))) : strong_rank_condition (has_add (sub_neg_monoid (boolean_algebra (has_Inf real)))) := sorry --non-trivial
lemma new_lemma_101016 (h0 : group (linear_ordered_add_comm_group (has_nnnorm fun_info))) : is_cyclic (linear_ordered_add_comm_group (has_nnnorm fun_info)) := sorry --non-trivial
lemma new_lemma_101017 (h0 : topological_space (comm_group (has_add Type))) : path_connected_space (comm_group (has_add Type)) := sorry --non-trivial
lemma new_lemma_101018 (h0 : topological_space (boolean_algebra.core (has_neg linarith.comp))) : loc_path_connected_space (boolean_algebra.core (has_neg linarith.comp)) := sorry --non-trivial
lemma new_lemma_101019 (h0 : ring (measurable_space (has_norm congr_arg_kind))) : is_domain (measurable_space (has_norm congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_101020 (h0 : mul_zero_class (partial_order unsigned) -> mul_zero_class (partial_order unsigned) -> Prop) : is_strict_order (mul_zero_class (partial_order unsigned)) h0 := sorry --non-trivial
lemma new_lemma_101021 (h0 : complete_lattice (has_top congr_arg_kind)) : complete_lattice.is_Sup_finite_compact (has_top congr_arg_kind) := sorry --non-trivial
lemma new_lemma_101022 (h0 : group (boolean_algebra (has_neg linarith.comp))) : is_simple_group (boolean_algebra (has_neg linarith.comp)) := sorry --non-trivial
lemma new_lemma_101023 (h0 : fin has_zero.zero) : @archimedean.{0} (normed_lattice_add_comm_group.{0} pos) (@function.extfun_app.{2 1} Type ordered_add_comm_monoid.{0} (@matrix.vec_empty.{1} (function.extfun.{2 1} Type ordered_add_comm_monoid.{0}) h0) (normed_lattice_add_comm_group.{0} pos))  := sorry --non-trivial
lemma new_lemma_101024 (h0 : cancel_comm_monoid_with_zero (complete_linear_order (has_top empty))) : unique_factorization_monoid (complete_linear_order (has_top empty)) := sorry --non-trivial
lemma new_lemma_101025 (h0 : complete_lattice (complete_distrib_lattice (boolean_algebra environment.implicit_infer_kind))) : is_atomistic (complete_distrib_lattice (boolean_algebra environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_101026 (h0 : function.extfun Type topological_space) : @normal_space.{0} (comm_semigroup.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (comm_semigroup.{0} name))  := sorry --non-trivial
lemma new_lemma_101027 (h0 : function.extfun Type complete_lattice) : @is_atomistic.{0} (bin_tree.{0} num) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (bin_tree.{0} num))  := sorry --non-trivial
lemma new_lemma_101028 (h1 : not (ring (has_append char) -> false)) : @rank_condition.{0} (has_append.{0} char) (@classical.by_contradiction'.{1} (ring.{0} (has_append.{0} char)) h1)  := sorry --non-trivial
lemma new_lemma_101029 (h0 : filter (linear_ordered_field ennreal)) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_101030 (h0 : topological_space (canonically_linear_ordered_monoid (has_neg (has_Inf name)))) : t1_space (canonically_linear_ordered_monoid (has_neg (has_Inf name))) := sorry --non-trivial
lemma new_lemma_101031 (h0 : topological_space (has_one fun_info)) : discrete_topology (has_one fun_info) := sorry --non-trivial
lemma new_lemma_101032 (h0 : set (add_comm_semigroup enat -> ereal)) : set.separates_points h0 := sorry --non-trivial
lemma new_lemma_101033 (h0 : not (complete_lattice (add_cancel_comm_monoid linarith.comp_source) -> false)) : @complete_lattice.is_Sup_finite_compact.{0} (add_cancel_comm_monoid.{0} linarith.comp_source) (@classical.by_contradiction'.{1} (complete_lattice.{0} (add_cancel_comm_monoid.{0} linarith.comp_source)) h0)  := sorry --non-trivial
lemma new_lemma_101034 (h0 : prod (cancel_monoid unsigned) (cancel_monoid unsigned)) : id_rel h0 := sorry --non-trivial
lemma new_lemma_101035 (h0 : topological_space (dlist (comm_ring linarith.ineq))) : t0_space (dlist (comm_ring linarith.ineq)) := sorry --non-trivial
lemma new_lemma_101036 (h0 : function.extfun Type topological_space) : @loc_path_connected_space.{0} (complete_distrib_lattice.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (complete_distrib_lattice.{0} num))  := sorry --non-trivial
lemma new_lemma_101037 (h0 : list (pseudo_metric_space (option (option empty)))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_101038 (h0 : group (normed_group (random_gen (random_gen (has_top to_additive.value_type))))) : is_cyclic (normed_group (random_gen (random_gen (has_top to_additive.value_type)))) := sorry --non-trivial
lemma new_lemma_101039 (h3 : ring (dlist fun_info)) : rank_condition (dlist fun_info) := sorry --non-trivial
lemma new_lemma_101040 (h0 : functor.add_const (topological_space (left_cancel_monoid congr_arg_kind)) (semiring (semiring (semiring empty)))) : @topological_space.separable_space.{0} (left_cancel_monoid.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (left_cancel_monoid.{0} congr_arg_kind)) (semiring.{0} (semiring.{0} (semiring.{0} empty))) h0)  := sorry --non-trivial
lemma new_lemma_101041 (h0 : preorder fun_info) (h1 : set fun_info) : set.is_pwo h1 := sorry --non-trivial
lemma new_lemma_101042 (h0 : functor.add_const (add_group (has_nndist pos)) (has_pos_part (has_Inf (has_pos_part linarith.comp)))) : @is_add_cyclic.{0} (has_nndist.{0} pos) (@functor.add_const.run.{0 0} (add_group.{0} (has_nndist.{0} pos)) (has_pos_part.{0} (has_Inf.{0} (has_pos_part.{0} linarith.comp))) h0)  := sorry --non-trivial
lemma new_lemma_101043 (h0 : list (partial_order (semigroup unsigned))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_101044 (h0 : topological_space (preorder unsigned)) : normal_space (preorder unsigned) := sorry --non-trivial
lemma new_lemma_101045 (h0 : ring (normed_field (metric_space char))) : rank_condition (normed_field (metric_space char)) := sorry --non-trivial
lemma new_lemma_101046 (h0 : monoid (id (random_gen (comm_ring (random_gen to_additive.value_type))))) : monoid.fg (id (random_gen (comm_ring (random_gen to_additive.value_type)))) := sorry --non-trivial
lemma new_lemma_101047 (h0 : functor.add_const (topological_space (has_Inf pos)) (has_neg name)) : @t0_space.{0} (has_Inf.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (has_Inf.{0} pos)) (has_neg.{0} name) h0)  := sorry --non-trivial
lemma new_lemma_101048 (h0 : finset (mul_zero_class (finset name))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_101049 (h0 : ulower (ulower pnat)) (h1 : pnat) : pnat.coprime (ulower.up (ulower.up h0)) h1 := sorry --non-trivial
lemma new_lemma_101050 (h0 : function.extfun Type topological_space) : @normal_space.{0} (canonically_ordered_monoid.{0} real) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (canonically_ordered_monoid.{0} real))  := sorry --non-trivial
lemma new_lemma_101051 (h0 : function.extfun Type topological_space) : @totally_disconnected_space.{0} (normed_comm_ring.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (normed_comm_ring.{0} pos))  := sorry --non-trivial
lemma new_lemma_101052 (h0 : functor.add_const (topological_space (add_group congr_arg_kind)) num) : @irreducible_space.{0} (add_group.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (add_group.{0} congr_arg_kind)) num h0)  := sorry --non-trivial
lemma new_lemma_101053 (h0 : list (free_add_monoid (option unsigned))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_101054 (h0 : functor.add_const (topological_space auto.case_option) empty) : @discrete_topology.{0} auto.case_option (@functor.add_const.run.{0 0} (topological_space.{0} auto.case_option) empty h0)  := sorry --non-trivial
lemma new_lemma_101055 (h0 : topological_space (add_comm_monoid (sub_neg_monoid pos))) : totally_disconnected_space (add_comm_monoid (sub_neg_monoid pos)) := sorry --non-trivial
lemma new_lemma_101056 (h0 : function.extfun Type topological_space) : @irreducible_space.{0} (simple_graph.{0} (option.{0} (option.{0} empty))) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (simple_graph.{0} (option.{0} (option.{0} empty))))  := sorry --non-trivial
lemma new_lemma_101057 (h0 : complete_lattice (monoid_with_zero (option unsigned))) : is_compactly_generated (monoid_with_zero (option unsigned)) := sorry --non-trivial
lemma new_lemma_101058 (h0 : complete_lattice (semi_normed_ring to_additive.value_type)) : complete_lattice.is_Sup_finite_compact (semi_normed_ring to_additive.value_type) := sorry --non-trivial
lemma new_lemma_101059 (h0 : functor.add_const (function.extfun (Type 1) topological_space) pos) : @path_connected_space.{1} (complete_distrib_lattice.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) topological_space.{1}) pos h0) (complete_distrib_lattice.{1} Type))  := sorry --non-trivial
lemma new_lemma_101060 (h0 : complete_lattice (normed_group (random_gen fun_info))) : is_compactly_generated (normed_group (random_gen fun_info)) := sorry --non-trivial
lemma new_lemma_101061 (h0 : topological_space (denumerable (has_to_string char))) : totally_disconnected_space (denumerable (has_to_string char)) := sorry --non-trivial
lemma new_lemma_101062 (h0 : function.extfun Type topological_space) : @topological_space.separable_space.{0} (linear_ordered_comm_monoid_with_zero.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (linear_ordered_comm_monoid_with_zero.{0} empty))  := sorry --non-trivial
lemma new_lemma_101063 (h0 : has_mem.mem (has_emptyc num) has_emptyc.emptyc) : @separated_space.{0} (has_emptyc.{0} num) (@finset.pi.empty.{1 0} Type uniform_space.{0} (has_emptyc.{0} num) h0)  := sorry --non-trivial
lemma new_lemma_101064 (h0 : functor.add_const (topological_space (comm_group name)) (has_neg linarith.comp)) : @regular_space.{0} (comm_group.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (comm_group.{0} name)) (has_neg.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_101065 (h0 : topological_space (normed_lattice_add_comm_group (ordered_comm_ring Type))) : path_connected_space (normed_lattice_add_comm_group (ordered_comm_ring Type)) := sorry --non-trivial
lemma new_lemma_101066 (h0 : uniform_space (ordered_comm_semiring (random_gen (random_gen char)))) : complete_space (ordered_comm_semiring (random_gen (random_gen char))) := sorry --non-trivial
lemma new_lemma_101067 (h0 : set (linear_ordered_comm_group_with_zero fun_info)) : set.subsingleton h0 := sorry --non-trivial
lemma new_lemma_101068 (h0 : ring (boolean_algebra (add_comm_monoid unsigned))) : rank_condition (boolean_algebra (add_comm_monoid unsigned)) := sorry --non-trivial
lemma new_lemma_101069 (h4 : add_group (add_comm_semigroup char)) : is_add_cyclic (add_comm_semigroup char) := sorry --non-trivial
lemma new_lemma_101070 (h0 : ring (group_with_zero ennreal)) : strong_rank_condition (group_with_zero ennreal) := sorry --non-trivial
lemma new_lemma_101071 (h0 : fin has_zero.zero) : @is_atomistic.{0} (sub_neg_monoid.{0} real) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@matrix.vec_empty.{1} (function.extfun.{2 1} Type complete_lattice.{0}) h0) (sub_neg_monoid.{0} real))  := sorry --non-trivial
lemma new_lemma_101072 (h0 : ring (has_nnnorm to_additive.value_type)) : strong_rank_condition (has_nnnorm to_additive.value_type) := sorry --non-trivial
lemma new_lemma_101073 (h0 : ring (id (semiring (semiring num)))) : is_domain (id (semiring (semiring num))) := sorry --non-trivial
lemma new_lemma_101074 (h0 : functor.add_const (topological_space (canonically_ordered_comm_semiring environment.implicit_infer_kind)) Type) : @preirreducible_space.{0} (canonically_ordered_comm_semiring.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 1} (topological_space.{0} (canonically_ordered_comm_semiring.{0} environment.implicit_infer_kind)) Type h0)  := sorry --non-trivial
lemma new_lemma_101075 (h0 : filter (add_cancel_monoid (has_nndist linarith.comp))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_101076 (h0 : topological_space (has_nndist unsigned)) : loc_path_connected_space (has_nndist unsigned) := sorry --non-trivial
lemma new_lemma_101077 (h0 : group (semigroup (finset (has_neg linarith.comp)))) : is_simple_group (semigroup (finset (has_neg linarith.comp))) := sorry --non-trivial
lemma new_lemma_101078 (h0 : topological_space (has_to_string (has_to_string pos))) : t1_space (has_to_string (has_to_string pos)) := sorry --non-trivial
lemma new_lemma_101079 (h0 : topological_space (ring ennreal)) : t1_space (ring ennreal) := sorry --non-trivial
lemma new_lemma_101080 (h0 : functor.add_const (function.extfun Type group) environment.implicit_infer_kind) : @group.fg.{0} (has_add.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type group.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type group.{0}) environment.implicit_infer_kind h0) (has_add.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_101081 (h0 : topological_space (semiring to_additive.value_type)) : t0_space (semiring to_additive.value_type) := sorry --non-trivial
lemma new_lemma_101082 (h1 : topological_space auto.case_option) : path_connected_space auto.case_option := sorry --non-trivial
lemma new_lemma_101083 (h0 : topological_space (boolean_algebra (has_to_string (has_Inf Type)))) : totally_disconnected_space (boolean_algebra (has_to_string (has_Inf Type))) := sorry --non-trivial
lemma new_lemma_101084 (h0 : has_mem.mem complete_lattice has_emptyc.emptyc) : @is_atomistic.{0} linarith.comp (@function.extfun_app.{2 1} Type complete_lattice.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) complete_lattice.{0} h0) linarith.comp)  := sorry --non-trivial
lemma new_lemma_101085 (h0 : has_mem.mem (semiring (random_gen num)) has_emptyc.emptyc) : @separated_space.{0} (semiring.{0} (random_gen.{0} num)) (@finset.pi.empty.{1 0} Type uniform_space.{0} (semiring.{0} (random_gen.{0} num)) h0)  := sorry --non-trivial
lemma new_lemma_101086 (h0 : has_neg environment.projection_info) (h1 : measurable_space environment.projection_info) : has_measurable_neg environment.projection_info := sorry --non-trivial
lemma new_lemma_101087 (h0 : ring (linear_order (mul_one_class string.iterator_imp))) : strong_rank_condition (linear_order (mul_one_class string.iterator_imp)) := sorry --non-trivial
lemma new_lemma_101088 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @unique_factorization_monoid.{0} (add_group.{0} empty) (@function.extfun_app.{2 1} Type cancel_comm_monoid_with_zero.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 cancel_comm_monoid_with_zero.{0}) (add_group.{0} empty))  := sorry --non-trivial
lemma new_lemma_101089 (h0 : group (has_pos_part (has_add (boolean_algebra.core Type)))) : normalizer_condition (has_pos_part (has_add (boolean_algebra.core Type))) := sorry --non-trivial
lemma new_lemma_101090 (h0 : function.extfun (Type 1) topological_space) : @totally_separated_space.{1} (has_pos_part.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} h0 (has_pos_part.{1} Type))  := sorry --non-trivial
lemma new_lemma_101091 (h0 : fin has_zero.zero) : @strong_rank_condition.{0} (has_bot.{0} linarith.comp) (@matrix.vec_empty.{0} (ring.{0} (has_bot.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_101092 (h0 : topological_space (has_pos_part (has_pos_part linarith.comp))) : t1_space (has_pos_part (has_pos_part linarith.comp)) := sorry --non-trivial
lemma new_lemma_101093 (h0 : topological_space (with_bot (random_gen empty))) : discrete_topology (with_bot (random_gen empty)) := sorry --non-trivial
lemma new_lemma_101094 (h0 : function.extfun (Type 1) group) : @is_cyclic.{1} (cancel_monoid.{1} Type) (@function.extfun_app.{3 2} (Type 1) group.{1} h0 (cancel_monoid.{1} Type))  := sorry --non-trivial
lemma new_lemma_101095 (h0 : topological_space (complete_semilattice_Sup (has_top (has_top fun_info)))) : totally_disconnected_space (complete_semilattice_Sup (has_top (has_top fun_info))) := sorry --non-trivial
lemma new_lemma_101096 (h0 : complete_lattice (normed_group (has_top num))) : is_atomistic (normed_group (has_top num)) := sorry --non-trivial
lemma new_lemma_101097 (h0 : group (complete_semilattice_Sup (random_gen linarith.ineq))) : normalizer_condition (complete_semilattice_Sup (random_gen linarith.ineq)) := sorry --non-trivial
lemma new_lemma_101098 (h0 : has_mem.mem (complete_semilattice_Sup (has_norm (has_norm empty))) has_emptyc.emptyc) : @is_atomistic.{0} (complete_semilattice_Sup.{0} (has_norm.{0} (has_norm.{0} empty))) (@finset.pi.empty.{1 0} Type complete_lattice.{0} (complete_semilattice_Sup.{0} (has_norm.{0} (has_norm.{0} empty))) h0)  := sorry --non-trivial
lemma new_lemma_101099 (h0 : function.extfun Type uniform_space) : @separated_space.{0} (has_norm.{0} fun_info) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (has_norm.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_101100 (h0 : functor.add_const (ring (ordered_comm_ring Type)) pos) : @strong_rank_condition.{1} (ordered_comm_ring.{1} Type) (@functor.add_const.run.{1 0} (ring.{1} (ordered_comm_ring.{1} Type)) pos h0)  := sorry --non-trivial
lemma new_lemma_101101 (h0 : topological_space (has_zero num)) : path_connected_space (has_zero num) := sorry --non-trivial
lemma new_lemma_101102 (h0 : topological_space (non_assoc_semiring (semiring unsigned))) : t0_space (non_assoc_semiring (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_101103 (h0 : add_comm_semigroup (add_comm_semigroup std_gen) -> add_comm_semigroup (add_comm_semigroup std_gen)) (h1 : add_comm_semigroup (add_comm_semigroup std_gen)) : function.periodic_pts h0 h1 := sorry --non-trivial
lemma new_lemma_101104 (h0 : topological_space (canonically_linear_ordered_monoid (has_Inf real))) : loc_path_connected_space (canonically_linear_ordered_monoid (has_Inf real)) := sorry --non-trivial
lemma new_lemma_101105 (h0 : fin has_zero.zero) : @is_compactly_generated.{0} (ordered_comm_monoid.{0} real) (@matrix.vec_empty.{0} (complete_lattice.{0} (ordered_comm_monoid.{0} real)) h0)  := sorry --non-trivial
lemma new_lemma_101106 (h0 : rel (lex unsigned) unsigned) (h1 : functor.add_const (functor.add_const (lex unsigned) unsigned) unsigned) : rel.dom h0 (functor.add_const.run (functor.add_const.run h1)) := sorry --non-trivial
lemma new_lemma_101107 (h0 : topological_space (add_group (semiring empty))) : t0_space (add_group (semiring empty)) := sorry --non-trivial
lemma new_lemma_101108 (h0 : not (function.extfun Type topological_space -> false)) : @t0_space.{0} (with_bot.{0} fun_info) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (with_bot.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_101109 (h0 : set (group char)) : set.finite h0 := sorry --non-trivial
lemma new_lemma_101110 (h0 : semiring (linear_ordered_field (option unsigned))) : is_noetherian_ring (linear_ordered_field (option unsigned)) := sorry --non-trivial
lemma new_lemma_101111 (h0 : functor.add_const (functor.add_const (function.extfun Type monoid) pos) (ring (has_neg Type))) : @monoid.fg.{0} (has_add.{0} name) (@function.extfun_app.{2 1} Type monoid.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type monoid.{0}) pos (@functor.add_const.run.{1 1} (functor.add_const.{1 0} (function.extfun.{2 1} Type monoid.{0}) pos) (ring.{1} (has_neg.{1} Type)) h0)) (has_add.{0} name))  := sorry --non-trivial
lemma new_lemma_101112 (h0 : monoid (linear_ordered_field (option unsigned))) : monoid.fg (linear_ordered_field (option unsigned)) := sorry --non-trivial
lemma new_lemma_101113 (h0 : functor.add_const (ring (normed_comm_ring linarith.comp)) (has_Inf (finset Type))) : @strong_rank_condition.{0} (normed_comm_ring.{0} linarith.comp) (@functor.add_const.run.{0 1} (ring.{0} (normed_comm_ring.{0} linarith.comp)) (has_Inf.{1} (finset.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_101114 (h0 : filter (ring (has_pos_part name))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_101115 (h0 : functor.add_const (list (free_add_monoid empty)) empty) : palindrome (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_101116 (h0 : topological_space (has_zero (has_add pos))) : locally_compact_space (has_zero (has_add pos)) := sorry --non-trivial
lemma new_lemma_101117 (h0 : topological_space (has_bot (ordered_comm_monoid real))) : irreducible_space (has_bot (ordered_comm_monoid real)) := sorry --non-trivial
lemma new_lemma_101118 (h0 : uniform_space (ordered_comm_ring linarith.comp)) : separated_space (ordered_comm_ring linarith.comp) := sorry --non-trivial
lemma new_lemma_101119 (h0 : topological_space (add_cancel_monoid congr_arg_kind)) : t1_space (add_cancel_monoid congr_arg_kind) := sorry --non-trivial
lemma new_lemma_101120 (h0 : complete_lattice (distrib linarith.comp_source)) : complete_lattice.is_Sup_finite_compact (distrib linarith.comp_source) := sorry --non-trivial
lemma new_lemma_101121 (h0 : group (has_Inf (ring linarith.comp))) : group.fg (has_Inf (ring linarith.comp)) := sorry --non-trivial
lemma new_lemma_101122 (h0 : functor.add_const (cancel_comm_monoid_with_zero (semigroup name)) (boolean_algebra name)) : @unique_factorization_monoid.{0} (semigroup.{0} name) (@functor.add_const.run.{0 0} (cancel_comm_monoid_with_zero.{0} (semigroup.{0} name)) (boolean_algebra.{0} name) h0)  := sorry --non-trivial
lemma new_lemma_101123 (h0 : ring (has_ssubset (has_nnnorm char))) : rank_condition (has_ssubset (has_nnnorm char)) := sorry --non-trivial
lemma new_lemma_101124 (h0 : functor.add_const (topological_space (has_nndist pos)) ennreal) : @topological_space.separable_space.{0} (has_nndist.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (has_nndist.{0} pos)) ennreal h0)  := sorry --non-trivial
lemma new_lemma_101125 (h0 : group (has_bot (has_bot (has_bot (has_Inf (comm_semigroup real)))))) : is_simple_group (has_bot (has_bot (has_bot (has_Inf (comm_semigroup real))))) := sorry --non-trivial
lemma new_lemma_101126 (h1 : complete_lattice (has_compl reducibility_hints)) : is_compactly_generated (has_compl reducibility_hints) := sorry --non-trivial
lemma new_lemma_101127 (h3 : add_group reducibility_hints) : is_add_cyclic reducibility_hints := sorry --non-trivial
lemma new_lemma_101128 (h0 : filter (canonically_ordered_comm_semiring (has_nndist Type))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_101129 (h0 : topological_space (has_add (has_add name))) : irreducible_space (has_add (has_add name)) := sorry --non-trivial
lemma new_lemma_101130 (h0 : functor.add_const (ordered_comm_monoid (ordered_comm_ring linarith.comp)) Type) : @has_exists_mul_of_le.{0} (ordered_comm_ring.{0} linarith.comp) (@functor.add_const.run.{0 1} (ordered_comm_monoid.{0} (ordered_comm_ring.{0} linarith.comp)) Type h0)  := sorry --non-trivial
lemma new_lemma_101131 (h0 : not (topological_space (semi_normed_comm_ring (random_gen string.iterator_imp)) -> false)) : @t0_space.{0} (semi_normed_comm_ring.{0} (random_gen.{0} string.iterator_imp)) (@classical.by_contradiction'.{1} (topological_space.{0} (semi_normed_comm_ring.{0} (random_gen.{0} string.iterator_imp))) h0)  := sorry --non-trivial
lemma new_lemma_101132 (h0 : ring (simple_graph fun_info)) : strong_rank_condition (simple_graph fun_info) := sorry --non-trivial
lemma new_lemma_101133 (h0 : functor.add_const (list (canonically_ordered_comm_semiring name)) name) : palindrome (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_101134 (h0 : set.set_semiring (id linarith.comp_source)) (h1 : id linarith.comp_source) : set.set_semiring.down h0 h1 := sorry --non-trivial
lemma new_lemma_101135 (h0 : uniform_space (plift unsigned)) : complete_space (plift unsigned) := sorry --non-trivial
lemma new_lemma_101136 (h0 : function.extfun nat fin) : @monoid.fg.{0} (complete_distrib_lattice.{0} linarith.comp) (@matrix.vec_empty.{0} (monoid.{0} (complete_distrib_lattice.{0} linarith.comp)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_101137 (h0 : topological_space (linear_ordered_comm_group (option ennreal))) : path_connected_space (linear_ordered_comm_group (option ennreal)) := sorry --non-trivial
lemma new_lemma_101138 (h0 : function.extfun Type list) : list.nodup (function.extfun_app h0 (as_linear_order (option unsigned))) := sorry --non-trivial
lemma new_lemma_101139 (h0 : function.extfun Type topological_space) : @preirreducible_space.{0} (has_to_string.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_to_string.{0} name))  := sorry --non-trivial
lemma new_lemma_101140 (h0 : set (set (linear_ordered_comm_group_with_zero string.iterator_imp))) (h1 : set (linear_ordered_comm_group_with_zero string.iterator_imp)) : measurable_space.dynkin_system.generate_has h0 h1 := sorry --non-trivial
lemma new_lemma_101141 (h0 : functor.add_const (function.extfun (Type 1) group) Type) : @is_simple_group.{1} (comm_group.{1} Type) (@function.extfun_app.{3 2} (Type 1) group.{1} (@functor.add_const.run.{2 1} (function.extfun.{3 2} (Type 1) group.{1}) Type h0) (comm_group.{1} Type))  := sorry --non-trivial
lemma new_lemma_101142 (h0 : function.extfun Type topological_space) : @preconnected_space.{0} (normed_lattice_add_comm_group.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (normed_lattice_add_comm_group.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_101143 (h0 : complete_lattice (has_zero (cancel_monoid (has_nndist ennreal)))) : is_compactly_generated (has_zero (cancel_monoid (has_nndist ennreal))) := sorry --non-trivial
lemma new_lemma_101144 (h0 : group real) : normalizer_condition real := sorry --non-trivial
lemma new_lemma_101145 (h0 : functor.add_const (list (has_neg environment.implicit_infer_kind)) (finset name)) : palindrome (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_101146 (h0 : group (has_ssubset (has_nnnorm reducibility_hints))) : is_cyclic (has_ssubset (has_nnnorm reducibility_hints)) := sorry --non-trivial
lemma new_lemma_101147 (h0 : topological_space (random_gen (mul_one_class fun_info))) : totally_disconnected_space (random_gen (mul_one_class fun_info)) := sorry --non-trivial
lemma new_lemma_101148 (h0 : functor.add_const (topological_space (semigroup congr_arg_kind)) num) : @discrete_topology.{0} (semigroup.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (semigroup.{0} congr_arg_kind)) num h0)  := sorry --non-trivial
lemma new_lemma_101149 (h0 : ring (add_cancel_monoid (option (option (option empty))))) : strong_rank_condition (add_cancel_monoid (option (option (option empty)))) := sorry --non-trivial
lemma new_lemma_101150 (h0 : functor.add_const (topological_space (normed_comm_ring unsigned)) (ring linarith.comp)) : @path_connected_space.{0} (normed_comm_ring.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (normed_comm_ring.{0} unsigned)) (ring.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_101151 (h0 : function.extfun Type complete_lattice) : @is_compactly_generated.{0} (random_gen.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (random_gen.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_101152 (h0 : topological_space (normed_comm_ring (has_to_string name))) : totally_disconnected_space (normed_comm_ring (has_to_string name)) := sorry --non-trivial
lemma new_lemma_101153 (h1 : ring (denumerable to_additive.value_type)) : rank_condition (denumerable to_additive.value_type) := sorry --non-trivial
lemma new_lemma_101154 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @has_exists_mul_of_le.{0} (has_nndist.{0} pos) (@function.extfun_app.{2 1} Type ordered_comm_monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ordered_comm_monoid.{0}) (has_nndist.{0} pos))  := sorry --non-trivial
lemma new_lemma_101155 (h0 : function.extfun nat fin) : @t0_space.{0} (generalized_boolean_algebra.{0} real) (@matrix.vec_empty.{0} (topological_space.{0} (generalized_boolean_algebra.{0} real)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_101156 (h0 : topological_space (has_zero (finset (finset environment.implicit_infer_kind)))) : regular_space (has_zero (finset (finset environment.implicit_infer_kind))) := sorry --non-trivial
lemma new_lemma_101157 (h0 : functor.add_const (add_monoid (add_group num)) empty) : @add_monoid.fg.{0} (add_group.{0} num) (@functor.add_const.run.{0 0} (add_monoid.{0} (add_group.{0} num)) empty h0)  := sorry --non-trivial
lemma new_lemma_101158 (h1 : set (enat -> mul_one_class std_gen)) : set.separates_points h1 := sorry --non-trivial
lemma new_lemma_101159 (h0 : monoid (distrib_lattice (random_gen (has_inv linarith.comp_source)))) : monoid.fg (distrib_lattice (random_gen (has_inv linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_101160 (h0 : complete_lattice (has_to_string (has_add ennreal))) : is_compactly_generated (has_to_string (has_add ennreal)) := sorry --non-trivial
lemma new_lemma_101161 (h0 : functor.add_const (semiring (has_nndist linarith.comp)) pos) : @is_noetherian_ring.{0} (has_nndist.{0} linarith.comp) (@functor.add_const.run.{0 0} (semiring.{0} (has_nndist.{0} linarith.comp)) pos h0)  := sorry --non-trivial
lemma new_lemma_101162 (h0 : list (semigroup (finset environment.implicit_infer_kind))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_101163 (h0 : function.extfun Type ring) : @strong_rank_condition.{0} (linear_order.{0} empty) (@function.extfun_app.{2 1} Type ring.{0} h0 (linear_order.{0} empty))  := sorry --non-trivial
lemma new_lemma_101164 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : filter.ne_bot (function.extfun_app (function.extfun_app h0 filter) (preorder empty)) := sorry --non-trivial
lemma new_lemma_101165 (h0 : filter (has_to_string (option (option ennreal)))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_101166 (h0 : fin has_zero.zero) (h1 : fin (nat.succ (matrix.vec_empty h0)) -> Prop) (h2 : fin (matrix.vec_empty h0)) : matrix.vec_tail h1 h2 := sorry --non-trivial
lemma new_lemma_101167 (h0 : functor.add_const (function.extfun (Type 1) filter) Type) : filter.ne_bot (function.extfun_app (functor.add_const.run h0) (finset Type)) := sorry --non-trivial
lemma new_lemma_101168 (h0 : finset (add_cancel_monoid (has_neg_part name))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_101169 (h0 : functor.add_const (topological_space (simple_graph name)) (finset (has_Inf (finset (has_add name))))) : @preconnected_space.{0} (simple_graph.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (simple_graph.{0} name)) (finset.{0} (has_Inf.{0} (finset.{0} (has_add.{0} name)))) h0)  := sorry --non-trivial
lemma new_lemma_101170 (h0 : topological_space (with_bot (has_top (has_top linarith.comp_source)))) : path_connected_space (with_bot (has_top (has_top linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_101171 (h0 : topological_space (monoid ennreal)) : irreducible_space (monoid ennreal) := sorry --non-trivial
lemma new_lemma_101172 (h0 : not (topological_space (with_bot linarith.comp_source) -> false)) : @t0_space.{0} (with_bot.{0} linarith.comp_source) (@classical.by_contradiction'.{1} (topological_space.{0} (with_bot.{0} linarith.comp_source)) h0)  := sorry --non-trivial
lemma new_lemma_101173 (h0 : group (has_top name)) : is_cyclic (has_top name) := sorry --non-trivial
lemma new_lemma_101174 (h0 : has_mem.mem (with_one linarith.comp) has_emptyc.emptyc) : @group.fg.{0} (with_one.{0} linarith.comp) (@finset.pi.empty.{1 0} Type group.{0} (with_one.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_101175 (h0 : ring (normed_field std_gen)) : rank_condition (normed_field std_gen) := sorry --non-trivial
lemma new_lemma_101176 (h0 : function.extfun Type group) : @is_cyclic.{0} (random_gen.{0} (with_bot.{0} linarith.comp_source)) (@function.extfun_app.{2 1} Type group.{0} h0 (random_gen.{0} (with_bot.{0} linarith.comp_source)))  := sorry --non-trivial
lemma new_lemma_101177 (h0 : not (ring (linear_ordered_add_comm_group char) -> false)) : @rank_condition.{0} (linear_ordered_add_comm_group.{0} char) (@classical.by_contradiction'.{1} (ring.{0} (linear_ordered_add_comm_group.{0} char)) h0)  := sorry --non-trivial
lemma new_lemma_101178 (h0 : complete_lattice (random_gen (has_nnnorm char)) -> Prop) (h1 : not (Exists (fun (x : complete_lattice (random_gen (has_nnnorm char))), h0 x) -> false)) : @complete_lattice.is_Sup_finite_compact.{0} (random_gen.{0} (has_nnnorm.{0} char)) (@classical.some.{1} (complete_lattice.{0} (random_gen.{0} (has_nnnorm.{0} char))) h0 (@classical.by_contradiction'.{0} (@Exists.{1} (complete_lattice.{0} (random_gen.{0} (has_nnnorm.{0} char))) (λ (x : complete_lattice.{0} (random_gen.{0} (has_nnnorm.{0} char))), h0 x)) h1))  := sorry --non-trivial
lemma new_lemma_101179 (h0 : functor.add_const (complete_lattice (free_add_monoid unsigned)) empty) : @complete_lattice.is_Sup_finite_compact.{0} (free_add_monoid.{0} unsigned) (@functor.add_const.run.{0 0} (complete_lattice.{0} (free_add_monoid.{0} unsigned)) empty h0)  := sorry --non-trivial
lemma new_lemma_101180 (h1 : ring (has_emptyc to_additive.value_type)) : is_domain (has_emptyc to_additive.value_type) := sorry --non-trivial
lemma new_lemma_101181 (h0 : functor.add_const (semiring (ordered_comm_monoid linarith.comp)) linarith.comp) : @is_noetherian_ring.{0} (ordered_comm_monoid.{0} linarith.comp) (@functor.add_const.run.{0 0} (semiring.{0} (ordered_comm_monoid.{0} linarith.comp)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_101182 (h0 : not (topological_space (linear_ordered_comm_group_with_zero char) -> false)) : @totally_disconnected_space.{0} (linear_ordered_comm_group_with_zero.{0} char) (@classical.by_contradiction'.{1} (topological_space.{0} (linear_ordered_comm_group_with_zero.{0} char)) h0)  := sorry --non-trivial
lemma new_lemma_101183 (h0 : set (semi_normed_ring (mul_one_class (normed_field linarith.ineq)))) : set.finite h0 := sorry --non-trivial
lemma new_lemma_101184 (h0 : add_group (has_to_string (canonically_ordered_comm_semiring pos))) : is_add_cyclic (has_to_string (canonically_ordered_comm_semiring pos)) := sorry --non-trivial
lemma new_lemma_101185 (h0 : topological_space (generalized_boolean_algebra (finset (has_add pos)))) : totally_disconnected_space (generalized_boolean_algebra (finset (has_add pos))) := sorry --non-trivial
lemma new_lemma_101186 (h0 : functor.add_const (semiring (semigroup Type)) pos) : @is_noetherian_ring.{1} (semigroup.{1} Type) (@functor.add_const.run.{1 0} (semiring.{1} (semigroup.{1} Type)) pos h0)  := sorry --non-trivial
lemma new_lemma_101187 (h0 : set char) (h1 : filter char) : filter.frequently (upper_bounds h0) h1 := sorry --non-trivial
lemma new_lemma_101188 (h0 : function.extfun Type (functor.add_const (list (preorder empty)))) : palindrome (functor.add_const.run (function.extfun_app h0 empty)) := sorry --non-trivial
lemma new_lemma_101189 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_domain.{0} (canonically_linear_ordered_monoid.{0} unsigned) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (canonically_linear_ordered_monoid.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_101190 (h0 : functor.add_const (function.extfun Type ordered_add_comm_monoid) name) : @archimedean.{0} (has_to_string.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type ordered_add_comm_monoid.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type ordered_add_comm_monoid.{0}) name h0) (has_to_string.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_101191 (h1 : uniform_space (fintype linarith.ineq)) : complete_space (fintype linarith.ineq) := sorry --non-trivial
lemma new_lemma_101192 (h0 : has_mem.mem group has_emptyc.emptyc) : @normalizer_condition.{0} (random_gen.{0} num) (@function.extfun_app.{2 1} Type group.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) group.{0} h0) (random_gen.{0} num))  := sorry --non-trivial
lemma new_lemma_101193 (h0 : uniform_space (generalized_boolean_algebra (sub_neg_monoid (has_add (has_bot Type))))) : complete_space (generalized_boolean_algebra (sub_neg_monoid (has_add (has_bot Type)))) := sorry --non-trivial
lemma new_lemma_101194 (h0 : ring (boolean_algebra.core (ordered_ring Type))) : is_principal_ideal_ring (boolean_algebra.core (ordered_ring Type)) := sorry --non-trivial
lemma new_lemma_101195 (h0 : ordered_comm_monoid (linear_ordered_field (option ennreal))) : has_exists_mul_of_le (linear_ordered_field (option ennreal)) := sorry --non-trivial
lemma new_lemma_101196 (h0 : filter (preorder (semiring (semiring (semiring unsigned))))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_101197 (h0 : complete_lattice (topological_space (random_gen string_imp))) : complete_lattice.is_Sup_finite_compact (topological_space (random_gen string_imp)) := sorry --non-trivial
lemma new_lemma_101198 (h0 : functor.add_const (fin has_zero.zero) name) : @rank_condition.{0} (has_bot.{0} real) (@function.extfun_app.{2 1} Type ring.{0} (@matrix.vec_empty.{1} (function.extfun.{2 1} Type ring.{0}) (@functor.add_const.run.{0 0} (fin (@has_zero.zero.{0} nat nat.has_zero)) name h0)) (has_bot.{0} real))  := sorry --non-trivial
lemma new_lemma_101199 (h0 : functor.add_const (semiring (ring linarith.comp)) linarith.comp) : @is_noetherian_ring.{0} (ring.{0} linarith.comp) (@functor.add_const.run.{0 0} (semiring.{0} (ring.{0} linarith.comp)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_101200 (h0 : topological_space (has_union (semiring (has_norm linarith.comp)))) : irreducible_space (has_union (semiring (has_norm linarith.comp))) := sorry --non-trivial
lemma new_lemma_101201 (h0 : ring (has_nndist (finset (finset linarith.comp)))) : strong_rank_condition (has_nndist (finset (finset linarith.comp))) := sorry --non-trivial
lemma new_lemma_101202 (h0 : group (add_comm_monoid (comm_group (comm_group pos)))) : is_simple_group (add_comm_monoid (comm_group (comm_group pos))) := sorry --non-trivial
lemma new_lemma_101203 (h0 : std_gen -> std_gen -> Prop) : is_total std_gen h0 := sorry --non-trivial
lemma new_lemma_101204 (h0 : functor.add_const (cancel_comm_monoid_with_zero (generalized_boolean_algebra linarith.comp)) linarith.comp) : @unique_factorization_monoid.{0} (generalized_boolean_algebra.{0} linarith.comp) (@functor.add_const.run.{0 0} (cancel_comm_monoid_with_zero.{0} (generalized_boolean_algebra.{0} linarith.comp)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_101205 (h0 : functor.add_const (filter (boolean_algebra.core name)) linarith.comp) : filter.ne_bot (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_101206 (h0 : topological_space (non_assoc_semiring (semiring congr_arg_kind))) : irreducible_space (non_assoc_semiring (semiring congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_101207 (h0 : topological_space (add_cancel_comm_monoid to_additive.value_type)) : t0_space (add_cancel_comm_monoid to_additive.value_type) := sorry --non-trivial
lemma new_lemma_101208 (h0 : function.extfun Type topological_space) : @t0_space.{0} (add_cancel_comm_monoid.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (add_cancel_comm_monoid.{0} empty))  := sorry --non-trivial
lemma new_lemma_101209 (h0 : add_monoid (has_star (semiring congr_arg_kind))) : add_monoid.fg (has_star (semiring congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_101210 (h0 : ordered_add_comm_monoid (canonically_ordered_comm_semiring (has_add (has_add (has_add ennreal))))) : archimedean (canonically_ordered_comm_semiring (has_add (has_add (has_add ennreal)))) := sorry --non-trivial
lemma new_lemma_101211 (h0 : not (function.extfun Type topological_space -> false)) : @topological_space.separable_space.{0} (option.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (option.{0} empty))  := sorry --non-trivial
lemma new_lemma_101212 (h0 : functor.add_const (add_group (ordered_comm_ring name)) Type) : @is_add_cyclic.{0} (ordered_comm_ring.{0} name) (@functor.add_const.run.{0 1} (add_group.{0} (ordered_comm_ring.{0} name)) Type h0)  := sorry --non-trivial
lemma new_lemma_101213 (h0 : prod (has_nndist (option (option (option (option num))))) (has_nndist (option (option (option (option num)))))) : id_rel h0 := sorry --non-trivial
lemma new_lemma_101214 (h0 : not (topological_space (measure_theory.measure_space unsigned) -> false)) : @path_connected_space.{0} (measure_theory.measure_space.{0} unsigned) (@classical.by_contradiction'.{1} (topological_space.{0} (measure_theory.measure_space.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_101215 (h0 : topological_space (has_bot (has_bot (option unsigned)))) : loc_path_connected_space (has_bot (has_bot (option unsigned))) := sorry --non-trivial
lemma new_lemma_101216 (h0 : Exists (fun (x : nat), has_lt.lt has_zero.zero x)) (h1 : pnat) : pnat.coprime (classical.subtype_of_exists h0) h1 := sorry --non-trivial
lemma new_lemma_101217 (h0 : functor.add_const (group (add_cancel_monoid name)) pos) : @group.fg.{0} (add_cancel_monoid.{0} name) (@functor.add_const.run.{0 0} (group.{0} (add_cancel_monoid.{0} name)) pos h0)  := sorry --non-trivial
lemma new_lemma_101218 (h0 : function.extfun Type finset) : finset.nonempty (function.extfun_app h0 (normed_comm_ring num)) := sorry --non-trivial
lemma new_lemma_101219 (h0 : not (group linarith.comp -> false)) : @is_cyclic.{0} linarith.comp (@classical.by_contradiction'.{1} (group.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_101220 (h0 : functor.add_const (topological_space (boolean_algebra.core name)) (has_neg (has_neg linarith.comp))) : @sequential_space.{0} (boolean_algebra.core.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (boolean_algebra.core.{0} name)) (has_neg.{0} (has_neg.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_101221 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : list.nodup (function.extfun_app (function.extfun_app h0 list) (add_cancel_monoid Type)) := sorry --non-trivial
lemma new_lemma_101222 (h0 : function.extfun Type filter) : filter.ne_bot (function.extfun_app h0 (has_ssubset linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_101223 (h0 : function.extfun (finset Type) (has_mem.mem linarith.comp)) : @is_domain.{0} linarith.comp (@finset.pi.empty.{1 0} Type ring.{0} linarith.comp (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) linarith.comp) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_101224 (h0 : topological_space (fintype (has_ssubset linarith.comp_source))) : path_connected_space (fintype (has_ssubset linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_101225 (h0 : filter (boolean_algebra Type)) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_101226 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : finset.nonempty (function.extfun_app (function.extfun_app h0 finset) (boolean_algebra Type)) := sorry --non-trivial
lemma new_lemma_101227 (h0 : ordered_comm_monoid (normed_comm_ring (has_to_string (has_add name)))) : has_exists_mul_of_le (normed_comm_ring (has_to_string (has_add name))) := sorry --non-trivial
lemma new_lemma_101228 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @totally_disconnected_space.{0} (has_pos_part.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_pos_part.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_101229 (h0 : topological_space (complete_distrib_lattice (has_add environment.implicit_infer_kind))) : normal_space (complete_distrib_lattice (has_add environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_101230 (h0 : topological_space (encodable fun_info)) : locally_compact_space (encodable fun_info) := sorry --non-trivial
lemma new_lemma_101231 (h0 : pnat) (h1 : ulower (ulower pnat)) : id (pnat.coprime h0 (ulower.up (ulower.up h1))) := sorry --non-trivial
lemma new_lemma_101232 (h0 : topological_space (ring (has_Inf (has_add (has_add Type))))) : totally_disconnected_space (ring (has_Inf (has_add (has_add Type)))) := sorry --non-trivial
lemma new_lemma_101233 (h0 : topological_space (has_add (has_star ennreal))) : discrete_topology (has_add (has_star ennreal)) := sorry --non-trivial
lemma new_lemma_101234 (h0 : function.extfun Type complete_lattice) : @is_atomistic.{0} (boolean_algebra.core.{0} unsigned) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (boolean_algebra.core.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_101235 (h0 : function.extfun Type uniform_space) : @separated_space.{0} (comm_monoid.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (comm_monoid.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_101236 (h0 : function.extfun (Type 1) topological_space) : @sequential_space.{1} (generalized_boolean_algebra.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} h0 (generalized_boolean_algebra.{1} Type))  := sorry --non-trivial
lemma new_lemma_101237 (h0 : function.extfun Type uniform_space) : @complete_space.{0} (has_norm.{0} fun_info) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (has_norm.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_101238 (h0 : functor.add_const (topological_space (has_nndist linarith.comp)) pos) : @irreducible_space.{0} (has_nndist.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (has_nndist.{0} linarith.comp)) pos h0)  := sorry --non-trivial
lemma new_lemma_101239 (h0 : functor.add_const (topological_space (cancel_monoid unsigned)) Type) : @t1_space.{0} (cancel_monoid.{0} unsigned) (@functor.add_const.run.{0 1} (topological_space.{0} (cancel_monoid.{0} unsigned)) Type h0)  := sorry --non-trivial
lemma new_lemma_101240 (h0 : ring (bin_tree environment.projection_info)) : strong_rank_condition (bin_tree environment.projection_info) := sorry --non-trivial
lemma new_lemma_101241 (h0 : set (distrib (mul_one_class string.iterator_imp))) : set.finite h0 := sorry --non-trivial
lemma new_lemma_101242 (h0 : not (topological_space (denumerable fun_info) -> false)) : @path_connected_space.{0} (denumerable.{0} fun_info) (@classical.by_contradiction'.{1} (topological_space.{0} (denumerable.{0} fun_info)) h0)  := sorry --non-trivial
lemma new_lemma_101243 (h0 : fin has_zero.zero) : @is_cyclic.{0} (comm_semigroup.{0} pos) (@matrix.vec_empty.{0} (group.{0} (comm_semigroup.{0} pos)) h0)  := sorry --non-trivial
lemma new_lemma_101244 (h0 : functor.add_const (function.extfun Type topological_space) Type) : @loc_path_connected_space.{0} (boolean_algebra.core.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type topological_space.{0}) Type h0) (boolean_algebra.core.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_101245 (h0 : fin has_zero.zero) : @archimedean.{1} (has_add.{1} Type) (@matrix.vec_empty.{1} (ordered_add_comm_monoid.{1} (has_add.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_101246 (h0 : topological_space (has_emptyc linarith.ineq)) : totally_disconnected_space (has_emptyc linarith.ineq) := sorry --non-trivial
lemma new_lemma_101247 (h0 : topological_space (cancel_monoid (has_add name))) : topological_space.separable_space (cancel_monoid (has_add name)) := sorry --non-trivial
lemma new_lemma_101248 (h0 : not (function.extfun Type topological_space -> false)) : @path_connected_space.{0} (with_one.{0} linarith.ineq) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (with_one.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_101249 (h0 : ring (ordered_cancel_add_comm_monoid (option empty))) : is_principal_ideal_ring (ordered_cancel_add_comm_monoid (option empty)) := sorry --non-trivial
lemma new_lemma_101250 (h0 : topological_space (has_nndist (has_to_string (has_neg (has_to_string linarith.comp))))) : irreducible_space (has_nndist (has_to_string (has_neg (has_to_string linarith.comp)))) := sorry --non-trivial
lemma new_lemma_101251 (h0 : not (add_group (has_lt to_additive.value_type) -> false)) : @is_add_cyclic.{0} (has_lt.{0} to_additive.value_type) (@classical.by_contradiction'.{1} (add_group.{0} (has_lt.{0} to_additive.value_type)) h0)  := sorry --non-trivial
lemma new_lemma_101252 (h0 : ring (finset congr_arg_kind)) : rank_condition (finset congr_arg_kind) := sorry --non-trivial
lemma new_lemma_101253 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @t1_space.{1} (ring.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 topological_space.{1}) (ring.{1} Type))  := sorry --non-trivial
lemma new_lemma_101254 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @is_atomistic.{1} (plift.{1} empty) (@function.extfun_app.{3 2} (Type 1) complete_lattice.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 complete_lattice.{1}) (plift.{1} empty))  := sorry --non-trivial
lemma new_lemma_101255 (h0 : functor.add_const (function.extfun Type topological_space) pos) : @t1_space.{0} (has_add.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) pos h0) (has_add.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_101256 (h0 : not (function.extfun Type ring -> false)) : @strong_rank_condition.{0} unsigned (@function.extfun_app.{2 1} Type ring.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type ring.{0}) h0) unsigned)  := sorry --non-trivial
lemma new_lemma_101257 (h0 : function.extfun Type (functor.comp topological_space ring)) : @path_connected_space.{0} (ring.{0} unsigned) (@functor.comp.run.{0 0 0} topological_space.{0} ring.{0} unsigned (@function.extfun_app.{2 1} Type (functor.comp.{0 0 0} topological_space.{0} ring.{0}) h0 unsigned))  := sorry --non-trivial
lemma new_lemma_101258 (h1 : ring (with_one (measure_theory.measure_space char))) : rank_condition (with_one (measure_theory.measure_space char)) := sorry --non-trivial
lemma new_lemma_101259 (h0 : fin has_zero.zero) : @is_compactly_generated.{0} real (@function.extfun_app.{2 1} Type complete_lattice.{0} (@matrix.vec_empty.{1} (function.extfun.{2 1} Type complete_lattice.{0}) h0) real)  := sorry --non-trivial
lemma new_lemma_101260 (h1 : filter (add_monoid fun_info)) : filter.ne_bot h1 := sorry --non-trivial
lemma new_lemma_101261 (h0 : function.extfun Type complete_lattice) : @is_atomistic.{0} linarith.comp_source (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 linarith.comp_source)  := sorry --non-trivial
lemma new_lemma_101262 (h0 : monoid (ordered_cancel_add_comm_monoid unsigned)) : monoid.fg (ordered_cancel_add_comm_monoid unsigned) := sorry --non-trivial
lemma new_lemma_101263 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @irreducible_space.{1} (canonically_ordered_comm_semiring.{1} (has_add.{1} Type)) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 topological_space.{1}) (canonically_ordered_comm_semiring.{1} (has_add.{1} Type)))  := sorry --non-trivial
lemma new_lemma_101264 (h0 : topological_space (has_zero (has_add name))) : totally_separated_space (has_zero (has_add name)) := sorry --non-trivial
lemma new_lemma_101265 (h0 : filter (comm_ring (has_ssubset (has_ssubset (has_ssubset string_imp))))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_101266 (h0 : prod (boolean_algebra.core (has_to_string congr_arg_kind)) (boolean_algebra.core (has_to_string congr_arg_kind))) : id_rel h0 := sorry --non-trivial
lemma new_lemma_101267 (h0 : function.extfun Type topological_space) : @discrete_topology.{0} (comm_group.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (comm_group.{0} name))  := sorry --non-trivial
lemma new_lemma_101268 (h0 : list (boolean_algebra.core (has_neg (has_neg (has_neg (has_neg linarith.comp)))))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_101269 (h0 : functor.add_const (function.extfun (Type 1) topological_space) (has_Inf linarith.comp)) : @path_connected_space.{1} Type (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) topological_space.{1}) (has_Inf.{0} linarith.comp) h0) Type)  := sorry --non-trivial
lemma new_lemma_101270 (h0 : measurable_space (boolean_algebra.core pos)) (h1 : has_div (boolean_algebra.core pos)) : has_measurable_div₂ (boolean_algebra.core pos) := sorry --non-trivial
lemma new_lemma_101271 (h0 : finset (has_to_string ennreal)) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_101272 (h1 : topological_space (encodable to_additive.value_type)) : path_connected_space (encodable to_additive.value_type) := sorry --non-trivial
lemma new_lemma_101273 (h2 : topological_space (has_norm num)) : totally_disconnected_space (has_norm num) := sorry --non-trivial
lemma new_lemma_101274 (h0 : set (add_comm_semigroup (mul_one_class environment.implicit_infer_kind) -> add_comm_semigroup ereal)) : set.separates_points h0 := sorry --non-trivial
lemma new_lemma_101275 (h0 : add_monoid (plift (has_top unsigned))) : add_monoid.fg (plift (has_top unsigned)) := sorry --non-trivial
lemma new_lemma_101276 (h0 : topological_space (id (semiring empty))) : totally_separated_space (id (semiring empty)) := sorry --non-trivial
lemma new_lemma_101277 (h0 : topological_space (boolean_algebra (has_add environment.implicit_infer_kind))) : sequential_space (boolean_algebra (has_add environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_101278 (h0 : not (add_group (linear_ordered_semiring linarith.comp) -> false)) : @is_add_cyclic.{0} (linear_ordered_semiring.{0} linarith.comp) (@classical.by_contradiction'.{1} (add_group.{0} (linear_ordered_semiring.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_101279 (h1 : complete_lattice (with_bot linarith.comp_source)) : is_compactly_generated (with_bot linarith.comp_source) := sorry --non-trivial
lemma new_lemma_101280 (h0 : functor.comp list ring Type) : list.nodup (functor.comp.run h0) := sorry --non-trivial
lemma new_lemma_101281 (h0 : fin has_zero.zero) : @has_exists_mul_of_le.{0} (sub_neg_monoid.{0} linarith.comp) (@matrix.vec_empty.{0} (ordered_comm_monoid.{0} (sub_neg_monoid.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_101282 (h0 : not (add_monoid (with_one fun_info) -> false)) : @add_monoid.fg.{0} (with_one.{0} fun_info) (@classical.by_contradiction'.{1} (add_monoid.{0} (with_one.{0} fun_info)) h0)  := sorry --non-trivial
lemma new_lemma_101283 (h0 : fin has_zero.zero) : @path_connected_space.{1} (generalized_boolean_algebra.{1} Type) (@matrix.vec_empty.{1} (topological_space.{1} (generalized_boolean_algebra.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_101284 (h0 : topological_space (semigroup (has_nndist (cancel_monoid (finset name))))) : preconnected_space (semigroup (has_nndist (cancel_monoid (finset name)))) := sorry --non-trivial
lemma new_lemma_101285 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @path_connected_space.{0} (random_gen.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (random_gen.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_101286 (h0 : topological_space (add_left_cancel_monoid (has_nnnorm (has_inv linarith.comp_source)))) : path_connected_space (add_left_cancel_monoid (has_nnnorm (has_inv linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_101287 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @normalizer_condition.{0} num (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) num)  := sorry --non-trivial
lemma new_lemma_101288 (h0 : not (function.extfun (Type -> Type) (function.extfun Type) -> false)) : @discrete_topology.{0} unsigned (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) (@classical.by_contradiction'.{2} (function.extfun.{2 2} (Type → Type) (function.extfun.{2 1} Type)) h0) topological_space.{0}) unsigned)  := sorry --non-trivial
lemma new_lemma_101289 (h0 : ring (has_nndist (has_neg pos))) : strong_rank_condition (has_nndist (has_neg pos)) := sorry --non-trivial
lemma new_lemma_101290 (h0 : functor.add_const (topological_space (plift empty)) congr_arg_kind) : @path_connected_space.{1} (plift.{1} empty) (@functor.add_const.run.{1 0} (topological_space.{1} (plift.{1} empty)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_101291 (h0 : has_neg (simple_graph char)) (h2 : measurable_space (simple_graph char)) : has_measurable_neg (simple_graph char) := sorry --non-trivial
lemma new_lemma_101292 (h0 : fin has_zero.zero) : @archimedean.{0} (has_bot.{0} linarith.comp) (@matrix.vec_empty.{0} (ordered_add_comm_monoid.{0} (has_bot.{0} linarith.comp)) (@matrix.vec_empty.{0} (fin (@has_zero.zero.{0} nat nat.has_zero)) h0))  := sorry --non-trivial
lemma new_lemma_101293 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @locally_compact_space.{0} (measurable_space.{0} fun_info) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (measurable_space.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_101294 (h0 : functor.add_const (list (has_neg name)) name) : palindrome (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_101295 (h0 : functor.add_const (function.extfun (Type 1) topological_space) Type) : @preconnected_space.{1} (normed_comm_ring.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@functor.add_const.run.{2 1} (function.extfun.{3 2} (Type 1) topological_space.{1}) Type h0) (normed_comm_ring.{1} Type))  := sorry --non-trivial
lemma new_lemma_101296 (h0 : not (function.extfun Type topological_space -> false)) : @irreducible_space.{0} (has_union.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (has_union.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_101297 (h0 : functor.comp topological_space has_nndist Type) : @preconnected_space.{1} (has_nndist.{1} Type) (@functor.comp.run.{1 1 1} topological_space.{1} has_nndist.{1} Type h0)  := sorry --non-trivial
lemma new_lemma_101298 (h0 : functor.add_const (function.extfun (Type 1) uniform_space) pos) : @separated_space.{1} (complete_distrib_lattice.{1} Type) (@function.extfun_app.{3 2} (Type 1) uniform_space.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) uniform_space.{1}) pos h0) (complete_distrib_lattice.{1} Type))  := sorry --non-trivial
lemma new_lemma_101299 (h0 : topological_space (sub_neg_monoid (has_bot (has_neg real)))) : path_connected_space (sub_neg_monoid (has_bot (has_neg real))) := sorry --non-trivial
lemma new_lemma_101300 (h0 : ring (distrib_lattice (random_gen (random_gen linarith.comp_source)))) : is_domain (distrib_lattice (random_gen (random_gen linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_101301 (h0 : function.extfun Type filter) : countable_Inter_filter (function.extfun_app h0 (has_nndist name)) := sorry --non-trivial
lemma new_lemma_101302 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @has_exists_mul_of_le.{0} (comm_semigroup.{0} name) (@function.extfun_app.{2 1} Type ordered_comm_monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ordered_comm_monoid.{0}) (comm_semigroup.{0} name))  := sorry --non-trivial
lemma new_lemma_101303 (h0 : ring (semi_normed_comm_ring to_additive.value_type)) : rank_condition (semi_normed_comm_ring to_additive.value_type) := sorry --non-trivial
lemma new_lemma_101304 (h0 : group (linear_order empty)) : is_cyclic (linear_order empty) := sorry --non-trivial
lemma new_lemma_101305 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @monoid.fg.{0} (@id.{2} Type linarith.comp_source) (@function.extfun_app.{2 1} Type monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 monoid.{0}) (@id.{2} Type linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_101306 (h0 : complete_lattice (has_nndist (mul_zero_class (has_nndist ennreal)))) : complete_lattice.is_Sup_finite_compact (has_nndist (mul_zero_class (has_nndist ennreal))) := sorry --non-trivial
lemma new_lemma_101307 (h0 : topological_space (comm_group (has_zero pos))) : loc_path_connected_space (comm_group (has_zero pos)) := sorry --non-trivial
lemma new_lemma_101308 (h0 : ring (has_neg (has_add (finset (ring (finset Type)))))) : rank_condition (has_neg (has_add (finset (ring (finset Type))))) := sorry --non-trivial
lemma new_lemma_101309 (h0 : add_group (comm_ring (has_nnnorm fun_info))) : is_add_cyclic (comm_ring (has_nnnorm fun_info)) := sorry --non-trivial
lemma new_lemma_101310 (h1 : topological_space (topological_space (has_nnnorm linarith.ineq))) : totally_disconnected_space (topological_space (has_nnnorm linarith.ineq)) := sorry --non-trivial
lemma new_lemma_101311 (h0 : prod (left_cancel_monoid (ordered_ring congr_arg_kind)) (left_cancel_monoid (ordered_ring congr_arg_kind))) : id_rel h0 := sorry --non-trivial
lemma new_lemma_101312 (h0 : topological_space (add_cancel_comm_monoid empty)) : t0_space (add_cancel_comm_monoid empty) := sorry --non-trivial
lemma new_lemma_101313 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @preirreducible_space.{0} (mul_zero_class.{0} ennreal) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (mul_zero_class.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_101314 (h0 : functor.add_const (complete_lattice (canonically_ordered_comm_semiring pos)) Type) : @is_compactly_generated.{0} (canonically_ordered_comm_semiring.{0} pos) (@functor.add_const.run.{0 1} (complete_lattice.{0} (canonically_ordered_comm_semiring.{0} pos)) Type h0)  := sorry --non-trivial
lemma new_lemma_101315 (h0 : topological_space (normed_comm_ring empty)) : normal_space (normed_comm_ring empty) := sorry --non-trivial
lemma new_lemma_101316 (h0 : topological_space (has_emptyc (has_norm empty))) : path_connected_space (has_emptyc (has_norm empty)) := sorry --non-trivial
lemma new_lemma_101317 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @path_connected_space.{0} (random_gen.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (random_gen.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_101318 (h0 : not (filter (has_append char) -> false)) : filter.ne_bot (classical.by_contradiction' h0) := sorry --non-trivial
lemma new_lemma_101319 (h0 : not (ring (semi_normed_comm_ring linarith.ineq) -> false)) : @rank_condition.{0} (semi_normed_comm_ring.{0} linarith.ineq) (@classical.by_contradiction'.{1} (ring.{0} (semi_normed_comm_ring.{0} linarith.ineq)) h0)  := sorry --non-trivial
lemma new_lemma_101320 (h0 : complete_lattice (has_neg_part (finset name))) : is_compactly_generated (has_neg_part (finset name)) := sorry --non-trivial
lemma new_lemma_101321 (h0 : has_mem.mem add_group has_emptyc.emptyc) : @is_add_cyclic.{0} string_imp (@function.extfun_app.{2 1} Type add_group.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) add_group.{0} h0) string_imp)  := sorry --non-trivial
lemma new_lemma_101322 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_domain.{0} (has_nndist.{0} empty) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (has_nndist.{0} empty))  := sorry --non-trivial
lemma new_lemma_101323 (h0 : monoid (has_pos_part Type)) : monoid.fg (has_pos_part Type) := sorry --non-trivial
lemma new_lemma_101324 (h0 : ring (has_add (ring (ring Type)))) : is_principal_ideal_ring (has_add (ring (ring Type))) := sorry --non-trivial
lemma new_lemma_101325 (h0 : functor.add_const (function.extfun Type ring) pos) : @rank_condition.{0} (boolean_algebra.{0} pos) (@function.extfun_app.{2 1} Type ring.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type ring.{0}) pos h0) (boolean_algebra.{0} pos))  := sorry --non-trivial
lemma new_lemma_101326 (h0 : topological_space (finset (ring Type))) : preconnected_space (finset (ring Type)) := sorry --non-trivial
lemma new_lemma_101327 (h3 : ring (add_cancel_comm_monoid to_additive.value_type)) : is_domain (add_cancel_comm_monoid to_additive.value_type) := sorry --non-trivial
lemma new_lemma_101328 (h0 : set (add_comm_semigroup enat -> std_gen)) : set.separates_points h0 := sorry --non-trivial
lemma new_lemma_101329 (h0 : function.extfun Type uniform_space) : @complete_space.{0} (linear_ordered_add_comm_group.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (linear_ordered_add_comm_group.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_101330 (h0 : function.extfun Type uniform_space) : @complete_space.{0} auto.case_option (@function.extfun_app.{2 1} Type uniform_space.{0} h0 auto.case_option)  := sorry --non-trivial
lemma new_lemma_101331 (h0 : prod (free_add_monoid congr_arg_kind) (free_add_monoid congr_arg_kind)) : id_rel h0 := sorry --non-trivial
lemma new_lemma_101332 (h0 : functor.add_const (function.extfun nat fin) Type) : @t0_space.{1} (sub_neg_monoid.{1} Type) (@matrix.vec_empty.{1} (topological_space.{1} (sub_neg_monoid.{1} Type)) (@function.extfun_app.{1 1} nat fin (@functor.add_const.run.{0 1} (function.extfun.{1 1} nat fin) Type h0) (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_101333 (h0 : function.extfun Type monoid) : @monoid.fg.{0} (comm_group.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type monoid.{0} h0 (comm_group.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_101334 (h0 : functor.add_const (complete_lattice (has_Sup empty)) congr_arg_kind) : @is_compactly_generated.{0} (has_Sup.{0} empty) (@functor.add_const.run.{0 0} (complete_lattice.{0} (has_Sup.{0} empty)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_101335 (h0 : topological_space (has_add (semigroup (finset environment.implicit_infer_kind)))) : totally_separated_space (has_add (semigroup (finset environment.implicit_infer_kind))) := sorry --non-trivial
lemma new_lemma_101336 (h0 : ordered_add_comm_monoid (finset empty)) : archimedean (finset empty) := sorry --non-trivial
lemma new_lemma_101337 (h0 : functor.add_const (ring (add_cancel_monoid name)) pos) : @rank_condition.{0} (add_cancel_monoid.{0} name) (@functor.add_const.run.{0 0} (ring.{0} (add_cancel_monoid.{0} name)) pos h0)  := sorry --non-trivial
lemma new_lemma_101338 (h0 : functor.add_const (topological_space (ordered_comm_ring linarith.comp)) linarith.comp) : @regular_space.{0} (ordered_comm_ring.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (ordered_comm_ring.{0} linarith.comp)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_101339 (h0 : not (function.extfun Type complete_lattice -> false)) : @complete_lattice.is_Sup_finite_compact.{0} (with_one.{0} fun_info) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type complete_lattice.{0}) h0) (with_one.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_101340 (h0 : functor.add_const (finset (semigroup environment.implicit_infer_kind)) (has_nndist linarith.comp)) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_101341 (h0 : ring (non_unital_non_assoc_semiring linarith.ineq) -> Prop) (h1 : Exists (fun (x : ring (non_unital_non_assoc_semiring linarith.ineq)), h0 x)) : @strong_rank_condition.{0} (non_unital_non_assoc_semiring.{0} linarith.ineq) (@classical.some.{1} (ring.{0} (non_unital_non_assoc_semiring.{0} linarith.ineq)) h0 h1)  := sorry --non-trivial
lemma new_lemma_101342 (h0 : functor.add_const (uniform_space (boolean_algebra.core unsigned)) linarith.comp) : @separated_space.{0} (boolean_algebra.core.{0} unsigned) (@functor.add_const.run.{0 0} (uniform_space.{0} (boolean_algebra.core.{0} unsigned)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_101343 (h0 : functor.add_const (topological_space (has_add name)) Type) : @regular_space.{0} (has_add.{0} name) (@functor.add_const.run.{0 1} (topological_space.{0} (has_add.{0} name)) Type h0)  := sorry --non-trivial
lemma new_lemma_101344 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @group.fg.{0} (complete_linear_order.{0} empty) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (complete_linear_order.{0} empty))  := sorry --non-trivial
lemma new_lemma_101345 (h0 : complete_lattice (with_bot (semiring (semiring (semiring congr_arg_kind))))) : complete_lattice.is_Sup_finite_compact (with_bot (semiring (semiring (semiring congr_arg_kind)))) := sorry --non-trivial
lemma new_lemma_101346 (h0 : group nnreal) : is_cyclic nnreal := sorry --non-trivial
lemma new_lemma_101347 (h0 : complete_lattice (option (semiring unsigned))) : is_atomistic (option (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_101348 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @add_monoid.fg.{0} (normed_group.{0} unsigned) (@function.extfun_app.{2 1} Type add_monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 add_monoid.{0}) (normed_group.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_101349 (h0 : topological_space (ordered_comm_ring (has_Inf linarith.comp))) : preirreducible_space (ordered_comm_ring (has_Inf linarith.comp)) := sorry --non-trivial
lemma new_lemma_101350 (h0 : functor.add_const (topological_space (ordered_comm_ring Type)) linarith.comp) : @totally_separated_space.{1} (ordered_comm_ring.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (ordered_comm_ring.{1} Type)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_101351 (h0 : topological_space (finset (has_Inf real))) : normal_space (finset (has_Inf real)) := sorry --non-trivial
lemma new_lemma_101352 (h1 : add_group (normed_field environment.projection_info)) : is_add_cyclic (normed_field environment.projection_info) := sorry --non-trivial
lemma new_lemma_101353 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @path_connected_space.{0} (has_neg.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_neg.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_101354 (h0 : function.extfun Type topological_space) : @locally_compact_space.{0} (has_Inf.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_Inf.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_101355 (h0 : functor.add_const (topological_space (boolean_algebra.core name)) name) : @totally_separated_space.{0} (boolean_algebra.core.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (boolean_algebra.core.{0} name)) name h0)  := sorry --non-trivial
lemma new_lemma_101356 (h0 : ring (semi_normed_comm_ring (random_gen (random_gen linarith.comp_source)))) : strong_rank_condition (semi_normed_comm_ring (random_gen (random_gen linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_101357 (h0 : function.extfun (nat -> Type) (function.extfun nat)) : @normalizer_condition.{0} (has_bot.{0} real) (@matrix.vec_empty.{0} (group.{0} (has_bot.{0} real)) (@function.extfun_app.{1 1} nat fin (@function.extfun_app.{2 1} (nat → Type) (function.extfun.{1 1} nat) h0 fin) (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_101358 (h0 : function.extfun Type topological_space) : @totally_disconnected_space.{0} (has_ssubset.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_ssubset.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_101359 (h0 : functor.add_const (complete_lattice (boolean_algebra name)) linarith.comp) : @is_compactly_generated.{0} (boolean_algebra.{0} name) (@functor.add_const.run.{0 0} (complete_lattice.{0} (boolean_algebra.{0} name)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_101360 (h0 : semiring (monoid_with_zero num)) : is_noetherian_ring (monoid_with_zero num) := sorry --non-trivial
lemma new_lemma_101361 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : infinite.{0} (option.{0} (@floor_semiring.{0} (add_comm_monoid.{0} empty) (@function.extfun_app.{2 1} Type ordered_semiring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ordered_semiring.{0}) (add_comm_monoid.{0} empty))))  := sorry --non-trivial
lemma new_lemma_101362 (h0 : ring (random_gen (comm_ring reducibility_hints))) : is_domain (random_gen (comm_ring reducibility_hints)) := sorry --non-trivial
lemma new_lemma_101363 (h0 : ring num) : strong_rank_condition num := sorry --non-trivial
lemma new_lemma_101364 (h0 : add_group (omega_complete_partial_order (option empty))) : is_add_cyclic (omega_complete_partial_order (option empty)) := sorry --non-trivial
lemma new_lemma_101365 (h0 : function.extfun (finset (Type -> Type)) (has_mem.mem topological_space)) : @totally_disconnected_space.{0} (random_gen.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) topological_space.{0} (@function.extfun_app.{2 0} (finset.{1} (Type → Type)) (@has_mem.mem.{1 1} (Type → Type) (finset.{1} (Type → Type)) (@finset.has_mem.{1} (Type → Type)) topological_space.{0}) h0 (@has_emptyc.emptyc.{1} (finset.{1} (Type → Type)) (@finset.has_emptyc.{1} (Type → Type))))) (random_gen.{0} num))  := sorry --non-trivial
lemma new_lemma_101366 (h0 : group (add_group (semiring (semiring congr_arg_kind)))) : is_cyclic (add_group (semiring (semiring congr_arg_kind))) := sorry --non-trivial
lemma new_lemma_101367 (h0 : functor.add_const (function.extfun Type ring) (ring Type)) : @strong_rank_condition.{0} (has_nndist.{0} name) (@function.extfun_app.{2 1} Type ring.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type ring.{0}) (ring.{1} Type) h0) (has_nndist.{0} name))  := sorry --non-trivial
lemma new_lemma_101368 (h0 : functor.add_const (topological_space (comm_group unsigned)) Type) : @normal_space.{0} (comm_group.{0} unsigned) (@functor.add_const.run.{0 1} (topological_space.{0} (comm_group.{0} unsigned)) Type h0)  := sorry --non-trivial
lemma new_lemma_101369 (h0 : ring (group_with_zero ennreal)) : is_principal_ideal_ring (group_with_zero ennreal) := sorry --non-trivial
lemma new_lemma_101370 (h0 : function.extfun Type filter) : countable_Inter_filter (function.extfun_app h0 (cancel_monoid environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_101371 (h0 : ring (has_top (random_gen (random_gen (random_gen linarith.ineq))))) : rank_condition (has_top (random_gen (random_gen (random_gen linarith.ineq)))) := sorry --non-trivial
lemma new_lemma_101372 (h0 : topological_space (has_nndist (finset Type))) : normal_space (has_nndist (finset Type)) := sorry --non-trivial
lemma new_lemma_101373 (h0 : function.extfun (finset Type) (has_mem.mem (measurable_space empty))) : @add_monoid.fg.{0} (measurable_space.{0} empty) (@finset.pi.empty.{1 0} Type add_monoid.{0} (measurable_space.{0} empty) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (measurable_space.{0} empty)) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_101374 (h0 : cancel_comm_monoid_with_zero (mul_zero_class (option (option empty)))) : unique_factorization_monoid (mul_zero_class (option (option empty))) := sorry --non-trivial
lemma new_lemma_101375 (h0 : functor.add_const (topological_space (cancel_monoid pos)) Type) : @t1_space.{0} (cancel_monoid.{0} pos) (@functor.add_const.run.{0 1} (topological_space.{0} (cancel_monoid.{0} pos)) Type h0)  := sorry --non-trivial
lemma new_lemma_101376 (h0 : ordered_add_comm_monoid (ordered_comm_monoid (has_Inf (boolean_algebra.core linarith.comp)))) : archimedean (ordered_comm_monoid (has_Inf (boolean_algebra.core linarith.comp))) := sorry --non-trivial
lemma new_lemma_101377 (h0 : set (nondiscrete_normed_field fun_info)) : set.finite h0 := sorry --non-trivial
lemma new_lemma_101378 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @irreducible_space.{0} (normed_group.{0} (comm_ring.{0} linarith.ineq)) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (normed_group.{0} (comm_ring.{0} linarith.ineq)))  := sorry --non-trivial
lemma new_lemma_101379 (h0 : group (has_norm (has_top (has_top linarith.ineq)))) (h1 : subgroup (has_norm (has_top (has_top linarith.ineq)))) : subgroup.saturated h1 := sorry --non-trivial
lemma new_lemma_101380 (h0 : ordered_comm_monoid (has_edist (comm_group (has_add ennreal)))) : has_exists_mul_of_le (has_edist (comm_group (has_add ennreal))) := sorry --non-trivial
lemma new_lemma_101381 (h0 : topological_space (has_zero ennreal)) : topological_space.separable_space (has_zero ennreal) := sorry --non-trivial
lemma new_lemma_101382 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : list.nodup (function.extfun_app (function.extfun_app h0 list) (encodable fun_info)) := sorry --non-trivial
lemma new_lemma_101383 (h0 : topological_space (has_Inf (has_neg (has_add (has_add (finset pos)))))) : totally_disconnected_space (has_Inf (has_neg (has_add (has_add (finset pos))))) := sorry --non-trivial
lemma new_lemma_101384 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_cyclic.{0} (encodable.{0} fun_info) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (encodable.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_101385 (h0 : functor.add_const (cancel_comm_monoid_with_zero (comm_group Type)) linarith.comp) : @unique_factorization_monoid.{1} (comm_group.{1} Type) (@functor.add_const.run.{1 0} (cancel_comm_monoid_with_zero.{1} (comm_group.{1} Type)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_101386 (h0 : cancel_monoid (add_comm_monoid pos) -> cancel_monoid (add_comm_monoid pos) -> Prop) : is_symm (cancel_monoid (add_comm_monoid pos)) h0 := sorry --non-trivial
lemma new_lemma_101387 (h0 : function.extfun Type topological_space) : @totally_disconnected_space.{0} (random_gen.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (random_gen.{0} empty))  := sorry --non-trivial
lemma new_lemma_101388 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_cyclic.{0} (normed_comm_ring.{0} pos) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (normed_comm_ring.{0} pos))  := sorry --non-trivial
lemma new_lemma_101389 (h1 : topological_space (id (random_gen linarith.comp_source))) : t0_space (id (random_gen linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_101390 (h0 : topological_space (normed_group (semiring (semiring congr_arg_kind)))) : totally_disconnected_space (normed_group (semiring (semiring congr_arg_kind))) := sorry --non-trivial
lemma new_lemma_101391 (h0 : functor.add_const (function.extfun Type topological_space) pos) : @t1_space.{0} (add_cancel_monoid.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) pos h0) (add_cancel_monoid.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_101392 (h0 : function.extfun Type topological_space) : @loc_path_connected_space.{0} (ordered_cancel_add_comm_monoid.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (ordered_cancel_add_comm_monoid.{0} num))  := sorry --non-trivial
lemma new_lemma_101393 (h0 : topological_space (boolean_algebra (has_Inf (has_Inf (ring Type))))) : preirreducible_space (boolean_algebra (has_Inf (has_Inf (ring Type)))) := sorry --non-trivial
lemma new_lemma_101394 (h0 : functor.add_const (group (monoid empty)) empty) : @is_cyclic.{0} (monoid.{0} empty) (@functor.add_const.run.{0 0} (group.{0} (monoid.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_101395 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @topological_space.separable_space.{0} (has_bot.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_bot.{0} empty))  := sorry --non-trivial
lemma new_lemma_101396 (h0 : topological_space (canonically_linear_ordered_monoid (has_Inf Type))) : t0_space (canonically_linear_ordered_monoid (has_Inf Type)) := sorry --non-trivial
lemma new_lemma_101397 (h0 : function.extfun (Type 1) ring) : @is_domain.{1} (canonically_linear_ordered_monoid.{1} Type) (@function.extfun_app.{3 2} (Type 1) ring.{1} h0 (canonically_linear_ordered_monoid.{1} Type))  := sorry --non-trivial
lemma new_lemma_101398 (h0 : complete_lattice (linear_ordered_semiring (has_norm num))) : complete_lattice.is_Sup_finite_compact (linear_ordered_semiring (has_norm num)) := sorry --non-trivial
lemma new_lemma_101399 (h0 : functor.comp monoid has_neg unsigned) : @monoid.fg.{0} (has_neg.{0} unsigned) (@functor.comp.run.{0 0 0} monoid.{0} has_neg.{0} unsigned h0)  := sorry --non-trivial
lemma new_lemma_101400 (h0 : group (has_pos_part (has_Inf real))) : is_simple_group (has_pos_part (has_Inf real)) := sorry --non-trivial
lemma new_lemma_101401 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @unique_factorization_monoid.{1} (canonically_ordered_comm_semiring.{1} Type) (@function.extfun_app.{3 2} (Type 1) cancel_comm_monoid_with_zero.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 cancel_comm_monoid_with_zero.{1}) (canonically_ordered_comm_semiring.{1} Type))  := sorry --non-trivial
lemma new_lemma_101402 (h0 : topological_space (normed_group (has_inv (has_top linarith.comp_source)))) : t0_space (normed_group (has_inv (has_top linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_101403 (h0 : prod (add_cancel_monoid ennreal) (add_cancel_monoid ennreal)) : id_rel h0 := sorry --non-trivial
lemma new_lemma_101404 (h0 : add_monoid (left_cancel_semigroup (mul_zero_class num))) : add_monoid.fg (left_cancel_semigroup (mul_zero_class num)) := sorry --non-trivial
lemma new_lemma_101405 (h0 : topological_space (cancel_monoid (ring (ring (ring name))))) : normal_space (cancel_monoid (ring (ring (ring name)))) := sorry --non-trivial
lemma new_lemma_101406 (h0 : functor.add_const (list (ordered_comm_monoid Type)) (ring (has_Inf (has_neg Type)))) : list.nodup (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_101407 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @group.fg.{0} (left_cancel_monoid.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (left_cancel_monoid.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_101408 (h0 : ordered_comm_monoid (boolean_algebra (has_pos_part Type))) : has_exists_mul_of_le (boolean_algebra (has_pos_part Type)) := sorry --non-trivial
lemma new_lemma_101409 (h0 : function.extfun Type topological_space) : @topological_space.separable_space.{0} (semigroup.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (semigroup.{0} pos))  := sorry --non-trivial
lemma new_lemma_101410 (h0 : semiring (with_one congr_arg_kind)) : is_noetherian_ring (with_one congr_arg_kind) := sorry --non-trivial
lemma new_lemma_101411 (h0 : function.extfun Type (functor.add_const (cancel_comm_monoid_with_zero auto.case_option))) : @unique_factorization_monoid.{0} auto.case_option (@functor.add_const.run.{0 0} (cancel_comm_monoid_with_zero.{0} auto.case_option) empty (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (cancel_comm_monoid_with_zero.{0} auto.case_option)) h0 empty))  := sorry --non-trivial
lemma new_lemma_101412 (h0 : uniform_space (has_to_string (has_neg linarith.comp))) : separated_space (has_to_string (has_neg linarith.comp)) := sorry --non-trivial
lemma new_lemma_101413 (h0 : ring (with_bot (semiring (semiring (semiring (semiring unsigned)))))) : strong_rank_condition (with_bot (semiring (semiring (semiring (semiring unsigned))))) := sorry --non-trivial
lemma new_lemma_101414 (h0 : topological_space (has_bot unsigned)) : preirreducible_space (has_bot unsigned) := sorry --non-trivial
lemma new_lemma_101415 (h1 : not (topological_space (has_top linarith.comp_source) -> false)) : @locally_compact_space.{0} (has_top.{0} linarith.comp_source) (@classical.by_contradiction'.{1} (topological_space.{0} (has_top.{0} linarith.comp_source)) h1)  := sorry --non-trivial
lemma new_lemma_101416 (h0 : uniform_space (normed_comm_ring (finset linarith.comp))) : separated_space (normed_comm_ring (finset linarith.comp)) := sorry --non-trivial
lemma new_lemma_101417 (h0 : topological_space (sub_neg_monoid name)) : totally_disconnected_space (sub_neg_monoid name) := sorry --non-trivial
lemma new_lemma_101418 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @irreducible_space.{0} (complete_semilattice_Sup.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (complete_semilattice_Sup.{0} num))  := sorry --non-trivial
lemma new_lemma_101419 (h1 : not (topological_space (linear_ordered_add_comm_group fun_info) -> false)) : @totally_disconnected_space.{0} (linear_ordered_add_comm_group.{0} fun_info) (@classical.by_contradiction'.{1} (topological_space.{0} (linear_ordered_add_comm_group.{0} fun_info)) h1)  := sorry --non-trivial
lemma new_lemma_101420 (h0 : ring (denumerable (has_inv (has_inv fun_info)))) : rank_condition (denumerable (has_inv (has_inv fun_info))) := sorry --non-trivial
lemma new_lemma_101421 (h0 : function.extfun Type ring) : @strong_rank_condition.{0} (complete_semilattice_Sup.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type ring.{0} h0 (complete_semilattice_Sup.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_101422 (h0 : group (denumerable (denumerable to_additive.value_type))) : is_cyclic (denumerable (denumerable to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_101423 (h0 : functor.add_const (cancel_comm_monoid_with_zero (has_nndist pos)) linarith.comp) : @unique_factorization_monoid.{0} (has_nndist.{0} pos) (@functor.add_const.run.{0 0} (cancel_comm_monoid_with_zero.{0} (has_nndist.{0} pos)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_101424 (h0 : topological_space (cancel_monoid num)) : irreducible_space (cancel_monoid num) := sorry --non-trivial
lemma new_lemma_101425 (h0 : group (has_nndist (option (option ennreal)))) : is_cyclic (has_nndist (option (option ennreal))) := sorry --non-trivial
lemma new_lemma_101426 (h0 : topological_space (normed_comm_ring (ring (ring linarith.comp)))) : irreducible_space (normed_comm_ring (ring (ring linarith.comp))) := sorry --non-trivial
lemma new_lemma_101427 (h0 : group (with_bot (random_gen (comm_ring to_additive.value_type)))) : is_cyclic (with_bot (random_gen (comm_ring to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_101428 (h0 : topological_space (cancel_monoid (option name))) : preirreducible_space (cancel_monoid (option name)) := sorry --non-trivial
lemma new_lemma_101429 (h0 : topological_space (mul_zero_class (has_nndist ennreal))) : normal_space (mul_zero_class (has_nndist ennreal)) := sorry --non-trivial
lemma new_lemma_101430 (h0 : ring (has_zero name)) : is_domain (has_zero name) := sorry --non-trivial
lemma new_lemma_101431 (h0 : fin has_zero.zero) : @discrete_topology.{1} (sub_neg_monoid.{1} Type) (@matrix.vec_empty.{1} (topological_space.{1} (sub_neg_monoid.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_101432 (h0 : fin has_zero.zero) : @is_cyclic.{0} (sub_neg_monoid.{0} pos) (@function.extfun_app.{2 1} Type group.{0} (@matrix.vec_empty.{1} (function.extfun.{2 1} Type group.{0}) h0) (sub_neg_monoid.{0} pos))  := sorry --non-trivial
lemma new_lemma_101433 (h0 : group (complete_distrib_lattice (add_comm_monoid unsigned))) : is_cyclic (complete_distrib_lattice (add_comm_monoid unsigned)) := sorry --non-trivial
lemma new_lemma_101434 (h0 : function.extfun Type filter) : countable_Inter_filter (function.extfun_app h0 (as_linear_order unsigned)) := sorry --non-trivial
lemma new_lemma_101435 (h0 : functor.add_const (filter (canonically_ordered_monoid real)) (has_add (has_add Type))) : countable_Inter_filter (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_101436 (h0 : topological_space (plift (option unsigned))) : discrete_topology (plift (option unsigned)) := sorry --non-trivial
lemma new_lemma_101437 (h0 : functor.add_const (topological_space (left_cancel_monoid num)) num) : @irreducible_space.{0} (left_cancel_monoid.{0} num) (@functor.add_const.run.{0 0} (topological_space.{0} (left_cancel_monoid.{0} num)) num h0)  := sorry --non-trivial
lemma new_lemma_101438 (h0 : group (ordered_comm_ring (has_add Type))) : normalizer_condition (ordered_comm_ring (has_add Type)) := sorry --non-trivial
lemma new_lemma_101439 (h0 : uniform_space (div_inv_monoid congr_arg_kind)) : separated_space (div_inv_monoid congr_arg_kind) := sorry --non-trivial
lemma new_lemma_101440 (h0 : functor.add_const (function.extfun Type ring) (has_add name)) : @is_domain.{0} (ordered_comm_monoid.{0} linarith.comp) (@function.extfun_app.{2 1} Type ring.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type ring.{0}) (has_add.{0} name) h0) (ordered_comm_monoid.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_101441 (h0 : functor.add_const (ring (has_zero Type)) (has_neg pos)) : @is_domain.{1} (has_zero.{1} Type) (@functor.add_const.run.{1 0} (ring.{1} (has_zero.{1} Type)) (has_neg.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_101442 (h0 : has_mem.mem complete_lattice has_emptyc.emptyc) : @complete_lattice.is_Sup_finite_compact.{0} (complete_semilattice_Sup.{0} linarith.comp) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) complete_lattice.{0} h0) (complete_semilattice_Sup.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_101443 (h0 : topological_space (finset (has_to_string (finset pos)))) : t1_space (finset (has_to_string (finset pos))) := sorry --non-trivial
lemma new_lemma_101444 (h0 : fin has_zero.zero) : @sequential_space.{0} (boolean_algebra.{0} pos) (@matrix.vec_empty.{0} (topological_space.{0} (boolean_algebra.{0} pos)) (@matrix.vec_empty.{0} (fin (@has_zero.zero.{0} nat nat.has_zero)) (@matrix.vec_empty.{0} (fin (@has_zero.zero.{0} nat nat.has_zero)) h0)))  := sorry --non-trivial
lemma new_lemma_101445 (h1 : filter (has_emptyc linarith.ineq)) : filter.ne_bot h1 := sorry --non-trivial
lemma new_lemma_101446 (h0 : functor.add_const (topological_space (left_cancel_monoid num)) unsigned) : @totally_disconnected_space.{0} (left_cancel_monoid.{0} num) (@functor.add_const.run.{0 0} (topological_space.{0} (left_cancel_monoid.{0} num)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_101447 (h0 : ring (random_gen (has_top congr_arg_kind))) : is_domain (random_gen (has_top congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_101448 (h0 : nat) (h1 h2 : fin h0) : fin.lt (id (id h1)) h2 := sorry --non-trivial
lemma new_lemma_101449 (h0 : topological_space (semigroup (semigroup name))) : t1_space (semigroup (semigroup name)) := sorry --non-trivial
lemma new_lemma_101450 (h0 : complete_lattice (id (random_gen linarith.ineq))) : is_atomistic (id (random_gen linarith.ineq)) := sorry --non-trivial
lemma new_lemma_101451 (h0 : functor.add_const (ordered_comm_monoid (has_neg Type)) environment.implicit_infer_kind) : @has_exists_mul_of_le.{1} (has_neg.{1} Type) (@functor.add_const.run.{1 0} (ordered_comm_monoid.{1} (has_neg.{1} Type)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_101452 (h0 : uniform_space (ordered_ring (option (option (option (option (option unsigned))))))) : separated_space (ordered_ring (option (option (option (option (option unsigned)))))) := sorry --non-trivial
lemma new_lemma_101453 (h0 : functor.add_const (topological_space (boolean_algebra.core Type)) Type) : @preirreducible_space.{1} (boolean_algebra.core.{1} Type) (@functor.add_const.run.{1 1} (topological_space.{1} (boolean_algebra.core.{1} Type)) Type h0)  := sorry --non-trivial
lemma new_lemma_101454 (h0 : topological_space (has_bot (sub_neg_monoid (has_pos_part (sub_neg_monoid real))))) : preconnected_space (has_bot (sub_neg_monoid (has_pos_part (sub_neg_monoid real)))) := sorry --non-trivial
lemma new_lemma_101455 (h0 : functor.add_const (topological_space pos) (option (option pos))) : @preconnected_space.{0} pos (@functor.add_const.run.{0 0} (topological_space.{0} pos) (option.{0} (option.{0} pos)) h0)  := sorry --non-trivial
lemma new_lemma_101456 (h0 : functor.comp topological_space complete_distrib_lattice unsigned) : @sequential_space.{0} (complete_distrib_lattice.{0} unsigned) (@functor.comp.run.{0 0 0} topological_space.{0} complete_distrib_lattice.{0} unsigned h0)  := sorry --non-trivial
lemma new_lemma_101457 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @preirreducible_space.{0} (cancel_monoid.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (cancel_monoid.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_101458 (h0 : topological_space (has_compl (mul_one_class (mul_one_class linarith.ineq)))) : t0_space (has_compl (mul_one_class (mul_one_class linarith.ineq))) := sorry --non-trivial
lemma new_lemma_101459 (h0 : topological_space (with_bot linarith.comp_source)) : locally_compact_space (with_bot linarith.comp_source) := sorry --non-trivial
lemma new_lemma_101460 (h0 : topological_space (boolean_algebra.core Type)) : path_connected_space (boolean_algebra.core Type) := sorry --non-trivial
lemma new_lemma_101461 (h0 : not (function.extfun Type ring -> false)) : @rank_condition.{0} (normed_group.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type ring.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type ring.{0}) h0) (normed_group.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_101462 (h0 : functor.add_const (complete_lattice (has_nndist Type)) name) : @is_compactly_generated.{1} (has_nndist.{1} Type) (@functor.add_const.run.{1 0} (complete_lattice.{1} (has_nndist.{1} Type)) name h0)  := sorry --non-trivial
lemma new_lemma_101463 (h0 : functor.add_const (ring (has_nndist Type)) name) : @is_principal_ideal_ring.{1} (has_nndist.{1} Type) (@functor.add_const.run.{1 0} (ring.{1} (has_nndist.{1} Type)) name h0)  := sorry --non-trivial
lemma new_lemma_101464 (h0 : topological_space (generalized_boolean_algebra (has_add (has_add pos)))) : regular_space (generalized_boolean_algebra (has_add (has_add pos))) := sorry --non-trivial
lemma new_lemma_101465 (h0 : topological_space (comm_group (has_nndist environment.implicit_infer_kind))) : topological_space.separable_space (comm_group (has_nndist environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_101466 (h0 : has_coe (mul_one_class (mul_one_class enat)) Prop) (h1 : mul_one_class (mul_one_class enat)) : @coe_b.{1 1} (mul_one_class.{0} (mul_one_class.{0} enat)) Prop h0 h1  := sorry --non-trivial
lemma new_lemma_101467 (h0 : function.extfun Type topological_space) : @preconnected_space.{0} (has_to_string.{0} (semigroup.{0} pos)) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_to_string.{0} (semigroup.{0} pos)))  := sorry --non-trivial
lemma new_lemma_101468 (h0 : not (function.extfun Type group -> false)) : @normalizer_condition.{0} (metric_space.{0} num) (@function.extfun_app.{2 1} Type group.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type group.{0}) h0) (metric_space.{0} num))  := sorry --non-trivial
lemma new_lemma_101469 (h1 : ring (has_ssubset (comm_ring (comm_ring linarith.comp_source)))) : rank_condition (has_ssubset (comm_ring (comm_ring linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_101470 (h0 : functor.add_const (ring (semigroup pos)) environment.implicit_infer_kind) : @is_principal_ideal_ring.{0} (semigroup.{0} pos) (@functor.add_const.run.{0 0} (ring.{0} (semigroup.{0} pos)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_101471 (h0 : ring (mul_one_class (semiring environment.projection_info))) : strong_rank_condition (mul_one_class (semiring environment.projection_info)) := sorry --non-trivial
lemma new_lemma_101472 (h0 : complete_lattice (linear_ordered_semiring linarith.ineq)) : complete_lattice.is_Sup_finite_compact (linear_ordered_semiring linarith.ineq) := sorry --non-trivial
lemma new_lemma_101473 (h0 : not (function.extfun (finset Type) (has_mem.mem (has_top empty)) -> false)) : @totally_separated_space.{0} (has_top.{0} empty) (@finset.pi.empty.{1 0} Type topological_space.{0} (has_top.{0} empty) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (has_top.{0} empty)) (@classical.by_contradiction'.{0} (function.extfun.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (has_top.{0} empty))) h0) (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_101474 (h0 : functor.add_const (function.extfun (Type 1) topological_space) (comm_group Type)) : @path_connected_space.{1} (boolean_algebra.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@functor.add_const.run.{2 1} (function.extfun.{3 2} (Type 1) topological_space.{1}) (comm_group.{1} Type) h0) (boolean_algebra.{1} Type))  := sorry --non-trivial
lemma new_lemma_101475 (h0 : functor.add_const (group (normed_comm_ring pos)) environment.implicit_infer_kind) : @normalizer_condition.{0} (normed_comm_ring.{0} pos) (@functor.add_const.run.{0 0} (group.{0} (normed_comm_ring.{0} pos)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_101476 (h0 : topological_space (has_norm (random_gen congr_arg_kind))) : path_connected_space (has_norm (random_gen congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_101477 (h0 : not (add_group (denumerable linarith.ineq) -> false)) : @is_add_cyclic.{0} (denumerable.{0} linarith.ineq) (@classical.by_contradiction'.{1} (add_group.{0} (denumerable.{0} linarith.ineq)) h0)  := sorry --non-trivial
lemma new_lemma_101478 (h0 : complete_lattice (cancel_monoid (has_add (normed_comm_ring Type)))) : complete_lattice.is_Sup_finite_compact (cancel_monoid (has_add (normed_comm_ring Type))) := sorry --non-trivial
lemma new_lemma_101479 (h0 : not (semiring (measurable_space unsigned) -> false)) : @is_noetherian_ring.{0} (measurable_space.{0} unsigned) (@classical.by_contradiction'.{1} (semiring.{0} (measurable_space.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_101480 (h0 : functor.add_const (topological_space (generalized_boolean_algebra real)) real) : @discrete_topology.{0} (generalized_boolean_algebra.{0} real) (@functor.add_const.run.{0 0} (topological_space.{0} (generalized_boolean_algebra.{0} real)) real h0)  := sorry --non-trivial
lemma new_lemma_101481 (h0 : ring (canonically_ordered_comm_semiring (has_neg Type))) : is_domain (canonically_ordered_comm_semiring (has_neg Type)) := sorry --non-trivial
lemma new_lemma_101482 (h0 : topological_space (semigroup (has_add (ring (has_add (ring (ring Type))))))) : totally_separated_space (semigroup (has_add (ring (has_add (ring (ring Type)))))) := sorry --non-trivial
lemma new_lemma_101483 (h3 : set (has_div linarith.ineq)) : set.subsingleton h3 := sorry --non-trivial
lemma new_lemma_101484 (h0 : complete_lattice (denumerable (has_ssubset (has_ssubset linarith.comp_source)))) : is_compactly_generated (denumerable (has_ssubset (has_ssubset linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_101485 (h0 : group (partial_order (semiring num))) : is_cyclic (partial_order (semiring num)) := sorry --non-trivial
lemma new_lemma_101486 (h0 : ring (complete_semilattice_Inf linarith.ineq)) : strong_rank_condition (complete_semilattice_Inf linarith.ineq) := sorry --non-trivial
lemma new_lemma_101487 (h0 : group (has_add (ring environment.implicit_infer_kind))) : group.fg (has_add (ring environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_101488 (h0 : functor.add_const (uniform_space (has_to_string unsigned)) pos) : @complete_space.{0} (has_to_string.{0} unsigned) (@functor.add_const.run.{0 0} (uniform_space.{0} (has_to_string.{0} unsigned)) pos h0)  := sorry --non-trivial
lemma new_lemma_101489 (h0 : topological_space (normed_lattice_add_comm_group (has_add (has_add Type)))) : preconnected_space (normed_lattice_add_comm_group (has_add (has_add Type))) := sorry --non-trivial
lemma new_lemma_101490 (h0 : add_monoid (linear_ordered_field (option num))) : add_monoid.fg (linear_ordered_field (option num)) := sorry --non-trivial
lemma new_lemma_101491 (h0 : function.extfun Type group) : @group.fg.{0} (add_group.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type group.{0} h0 (add_group.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_101492 (h0 : topological_space (distrib (has_nnnorm char))) : totally_disconnected_space (distrib (has_nnnorm char)) := sorry --non-trivial
lemma new_lemma_101493 (h0 : finset (comm_group (option (option (measurable_space.dynkin_system pos))))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_101494 (h0 : topological_space (has_sub unsigned)) : locally_compact_space (has_sub unsigned) := sorry --non-trivial
lemma new_lemma_101495 (h0 : topological_space (has_star (semiring unsigned))) : locally_compact_space (has_star (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_101496 (h0 : topological_space (has_neg (finset name))) : t1_space (has_neg (finset name)) := sorry --non-trivial
lemma new_lemma_101497 (h0 : topological_space (has_nnnorm (random_gen (has_nnnorm fun_info)))) : locally_compact_space (has_nnnorm (random_gen (has_nnnorm fun_info))) := sorry --non-trivial
lemma new_lemma_101498 (h0 : ring (linear_ordered_add_comm_group (random_gen (random_gen (comm_ring fun_info))))) : is_domain (linear_ordered_add_comm_group (random_gen (random_gen (comm_ring fun_info)))) := sorry --non-trivial
lemma new_lemma_101499 (h0 : topological_space (simple_graph linarith.comp)) : locally_compact_space (simple_graph linarith.comp) := sorry --non-trivial
lemma new_lemma_101500 (h0 : ring (boolean_algebra (has_add (has_neg linarith.comp)))) : is_principal_ideal_ring (boolean_algebra (has_add (has_neg linarith.comp))) := sorry --non-trivial
lemma new_lemma_101501 (h0 : topological_space (as_linear_order congr_arg_kind)) : totally_separated_space (as_linear_order congr_arg_kind) := sorry --non-trivial
lemma new_lemma_101502 (h0 : function.extfun Type topological_space) : @preirreducible_space.{0} (is_R_or_C.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (is_R_or_C.{0} empty))  := sorry --non-trivial
lemma new_lemma_101503 (h1 : with_bot Prop) (h2 : ne h1 has_bot.bot) : with_bot.unbot h1 h2 := sorry --non-trivial
lemma new_lemma_101504 (h0 : topological_space (denumerable (has_ssubset linarith.ineq))) : locally_compact_space (denumerable (has_ssubset linarith.ineq)) := sorry --non-trivial
lemma new_lemma_101505 (h1 : group (comm_ring (comm_monoid (random_gen string_imp)))) : group.fg (comm_ring (comm_monoid (random_gen string_imp))) := sorry --non-trivial
lemma new_lemma_101506 (h0 : not (complete_lattice (measure_theory.measure_space empty) -> false)) : @complete_lattice.is_Sup_finite_compact.{0} (measure_theory.measure_space.{0} empty) (@classical.by_contradiction'.{1} (complete_lattice.{0} (measure_theory.measure_space.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_101507 (h0 : add_monoid (linear_ordered_cancel_comm_monoid (option empty))) : add_monoid.fg (linear_ordered_cancel_comm_monoid (option empty)) := sorry --non-trivial
lemma new_lemma_101508 (h0 : function.extfun (finset (Type -> Type)) (has_mem.mem group)) : @normalizer_condition.{0} (@id.{2} Type linarith.comp) (@function.extfun_app.{2 1} Type group.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) group.{0} (@function.extfun_app.{2 0} (finset.{1} (Type → Type)) (@has_mem.mem.{1 1} (Type → Type) (finset.{1} (Type → Type)) (@finset.has_mem.{1} (Type → Type)) group.{0}) h0 (@has_emptyc.emptyc.{1} (finset.{1} (Type → Type)) (@finset.has_emptyc.{1} (Type → Type))))) (@id.{2} Type linarith.comp))  := sorry --non-trivial
lemma new_lemma_101509 (h0 : ring (add_right_cancel_monoid (option (option unsigned)))) : is_principal_ideal_ring (add_right_cancel_monoid (option (option unsigned))) := sorry --non-trivial
lemma new_lemma_101510 (h0 : function.extfun Type ring) : @is_domain.{0} (distrib_lattice.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type ring.{0} h0 (distrib_lattice.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_101511 (h0 : complete_lattice (has_append string_imp)) : is_compactly_generated (has_append string_imp) := sorry --non-trivial
lemma new_lemma_101512 (h0 : not (topological_space (distrib_lattice to_additive.value_type) -> false)) : @path_connected_space.{0} (distrib_lattice.{0} to_additive.value_type) (@classical.by_contradiction'.{1} (topological_space.{0} (distrib_lattice.{0} to_additive.value_type)) h0)  := sorry --non-trivial
lemma new_lemma_101513 (h3 : ring linarith.comp_source) : strong_rank_condition linarith.comp_source := sorry --non-trivial
lemma new_lemma_101514 (h0 : not (measurable_space (linear_ordered_semiring linarith.comp) -> false)) (h1 : has_add (linear_ordered_semiring linarith.comp)) : @has_measurable_add.{0} (linear_ordered_semiring.{0} linarith.comp) (@classical.by_contradiction'.{1} (measurable_space.{0} (linear_ordered_semiring.{0} linarith.comp)) h0) h1  := sorry --non-trivial
lemma new_lemma_101515 (h0 : topological_space (with_bot (has_top num))) : preirreducible_space (with_bot (has_top num)) := sorry --non-trivial
lemma new_lemma_101516 (h1 : topological_space (linear_ordered_add_comm_group fun_info)) : totally_disconnected_space (linear_ordered_add_comm_group fun_info) := sorry --non-trivial
lemma new_lemma_101517 (h0 : group (cancel_monoid (boolean_algebra.core pos))) : group.fg (cancel_monoid (boolean_algebra.core pos)) := sorry --non-trivial
lemma new_lemma_101518 (h0 : functor.add_const (complete_lattice (canonically_linear_ordered_monoid ennreal)) num) : @is_atomistic.{0} (canonically_linear_ordered_monoid.{0} ennreal) (@functor.add_const.run.{0 0} (complete_lattice.{0} (canonically_linear_ordered_monoid.{0} ennreal)) num h0)  := sorry --non-trivial
lemma new_lemma_101519 (h0 : functor.add_const (functor.add_const (topological_space Type) linarith.comp) linarith.comp) : @topological_space.separable_space.{1} Type (@functor.add_const.run.{1 0} (topological_space.{1} Type) linarith.comp (@functor.add_const.run.{1 0} (functor.add_const.{1 0} (topological_space.{1} Type) linarith.comp) linarith.comp h0))  := sorry --non-trivial
lemma new_lemma_101520 (h0 : uniform_space (has_neg num)) : separated_space (has_neg num) := sorry --non-trivial
lemma new_lemma_101521 (h0 : topological_space (metric_space linarith.comp)) : discrete_topology (metric_space linarith.comp) := sorry --non-trivial
lemma new_lemma_101522 (h0 : list (add_cancel_monoid (semigroup (ring (has_neg linarith.comp))))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_101523 (h0 : topological_space (has_edist congr_arg_kind)) : irreducible_space (has_edist congr_arg_kind) := sorry --non-trivial
lemma new_lemma_101524 (h0 : functor.add_const (cancel_comm_monoid_with_zero (boolean_algebra Type)) linarith.comp) : @unique_factorization_monoid.{1} (boolean_algebra.{1} Type) (@functor.add_const.run.{1 0} (cancel_comm_monoid_with_zero.{1} (boolean_algebra.{1} Type)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_101525 (h0 : filter (fintype char)) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_101526 (h0 : topological_space (comm_group Type)) : sequential_space (comm_group Type) := sorry --non-trivial
lemma new_lemma_101527 (h0 : not (function.extfun (Type -> Type) (function.extfun Type) -> false)) : @complete_lattice.is_Sup_finite_compact.{0} (has_emptyc.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) (@classical.by_contradiction'.{2} (function.extfun.{2 2} (Type → Type) (function.extfun.{2 1} Type)) h0) complete_lattice.{0}) (has_emptyc.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_101528 (h0 : monoid (id (semiring (linear_ordered_semiring (has_top (has_top (semiring linarith.comp))))))) : monoid.fg (id (semiring (linear_ordered_semiring (has_top (has_top (semiring linarith.comp)))))) := sorry --non-trivial
lemma new_lemma_101529 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @group.fg.{0} (comm_ring.{0} linarith.ineq) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (comm_ring.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_101530 (h0 : add_monoid (has_nndist (has_nndist name))) : add_monoid.fg (has_nndist (has_nndist name)) := sorry --non-trivial
lemma new_lemma_101531 (h0 : group (with_bot (semiring linarith.comp))) : is_cyclic (with_bot (semiring linarith.comp)) := sorry --non-trivial
lemma new_lemma_101532 (h0 : functor.add_const (topological_space (cancel_monoid ennreal)) pos) : @topological_space.separable_space.{0} (cancel_monoid.{0} ennreal) (@functor.add_const.run.{0 0} (topological_space.{0} (cancel_monoid.{0} ennreal)) pos h0)  := sorry --non-trivial
lemma new_lemma_101533 (h0 : function.extfun Type ring) : @is_domain.{0} linarith.comp (@function.extfun_app.{2 1} Type ring.{0} h0 linarith.comp)  := sorry --non-trivial
lemma new_lemma_101534 (h0 : topological_space (generalized_boolean_algebra linarith.comp)) : loc_path_connected_space (generalized_boolean_algebra linarith.comp) := sorry --non-trivial
lemma new_lemma_101535 (h0 : topological_space (has_pos_part (has_Inf (has_pos_part pos)))) : t0_space (has_pos_part (has_Inf (has_pos_part pos))) := sorry --non-trivial
lemma new_lemma_101536 (h0 : topological_space (has_ssubset linarith.comp_source)) (h1 : add_group (has_ssubset linarith.comp_source)) : topological_add_group (has_ssubset linarith.comp_source) := sorry --non-trivial
lemma new_lemma_101537 (h0 : uniform_space (add_comm_monoid congr_arg_kind)) : separated_space (add_comm_monoid congr_arg_kind) := sorry --non-trivial
lemma new_lemma_101538 (h0 : ring (has_append string_imp)) : rank_condition (has_append string_imp) := sorry --non-trivial
lemma new_lemma_101539 (h0 : group (ordered_cancel_add_comm_monoid (option pos))) : is_cyclic (ordered_cancel_add_comm_monoid (option pos)) := sorry --non-trivial
lemma new_lemma_101540 (h0 : function.extfun Type add_group) : @is_add_cyclic.{0} (canonically_ordered_add_monoid.{0} empty) (@function.extfun_app.{2 1} Type add_group.{0} h0 (canonically_ordered_add_monoid.{0} empty))  := sorry --non-trivial
lemma new_lemma_101541 (h0 : ring (topological_space (random_gen char))) : rank_condition (topological_space (random_gen char)) := sorry --non-trivial
lemma new_lemma_101542 (h1 : add_group (distrib linarith.ineq)) : is_add_cyclic (distrib linarith.ineq) := sorry --non-trivial
lemma new_lemma_101543 (h0 : functor.add_const (function.extfun Type cancel_comm_monoid_with_zero) name) : @unique_factorization_monoid.{0} (has_Inf.{0} pos) (@function.extfun_app.{2 1} Type cancel_comm_monoid_with_zero.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type cancel_comm_monoid_with_zero.{0}) name h0) (has_Inf.{0} pos))  := sorry --non-trivial
lemma new_lemma_101544 (h0 : not (group (has_top linarith.ineq) -> false)) : @is_cyclic.{0} (has_top.{0} linarith.ineq) (@classical.by_contradiction'.{1} (group.{0} (has_top.{0} linarith.ineq)) h0)  := sorry --non-trivial
lemma new_lemma_101545 (h0 : functor.add_const (add_group (boolean_algebra ennreal)) name) : @is_add_cyclic.{0} (boolean_algebra.{0} ennreal) (@functor.add_const.run.{0 0} (add_group.{0} (boolean_algebra.{0} ennreal)) name h0)  := sorry --non-trivial
lemma new_lemma_101546 (h0 : fin has_zero.zero) : @t0_space.{0} (has_pos_part.{0} real) (@matrix.vec_empty.{0} (topological_space.{0} (has_pos_part.{0} real)) h0)  := sorry --non-trivial
lemma new_lemma_101547 (h0 : topological_space (boolean_algebra.core (ring unsigned))) : regular_space (boolean_algebra.core (ring unsigned)) := sorry --non-trivial
lemma new_lemma_101548 (h0 : functor.add_const (function.extfun Type topological_space) name) : @path_connected_space.{0} (has_pos_part.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) name h0) (has_pos_part.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_101549 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @add_monoid.fg.{0} (has_Inf.{0} name) (@function.extfun_app.{2 1} Type add_monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 add_monoid.{0}) (has_Inf.{0} name))  := sorry --non-trivial
lemma new_lemma_101550 (h0 : topological_space (semigroup (has_neg_part environment.implicit_infer_kind))) : t1_space (semigroup (has_neg_part environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_101551 (h0 : ring (topological_space (comm_ring reducibility_hints))) : is_domain (topological_space (comm_ring reducibility_hints)) := sorry --non-trivial
lemma new_lemma_101552 (h0 : list (boolean_algebra.core (has_add unsigned))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_101553 (h1 : function.extfun Type group) : @normalizer_condition.{0} (with_one.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type group.{0} h1 (with_one.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_101554 (h0 : ring (boolean_algebra.core (option name))) : is_principal_ideal_ring (boolean_algebra.core (option name)) := sorry --non-trivial
lemma new_lemma_101555 (h0 : ordered_add_comm_monoid (has_neg_part (has_neg_part (has_nndist name)))) : archimedean (has_neg_part (has_neg_part (has_nndist name))) := sorry --non-trivial
lemma new_lemma_101556 (h0 : ring (has_neg_part (has_to_string pos))) : strong_rank_condition (has_neg_part (has_to_string pos)) := sorry --non-trivial
lemma new_lemma_101557 (h0 : add_monoid (semigroup (has_add pos))) : add_monoid.fg (semigroup (has_add pos)) := sorry --non-trivial
lemma new_lemma_101558 (h0 : functor.add_const (topological_space (boolean_algebra.core pos)) name) : @locally_compact_space.{0} (boolean_algebra.core.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (boolean_algebra.core.{0} pos)) name h0)  := sorry --non-trivial
lemma new_lemma_101559 (h0 : function.extfun (random_gen (has_inv fun_info)) (fun (x : random_gen (has_inv fun_info)), Prop)) : Exists (function.extfun_app h0) := sorry --non-trivial
lemma new_lemma_101560 (h0 : functor.add_const (topological_space (has_to_string Type)) pos) : @t0_space.{1} (has_to_string.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (has_to_string.{1} Type)) pos h0)  := sorry --non-trivial
lemma new_lemma_101561 (h0 : topological_space (has_inner (random_gen fun_info) (has_inv to_additive.value_type))) : locally_compact_space (has_inner (random_gen fun_info) (has_inv to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_101562 (h0 : topological_space (topological_space to_additive.value_type)) : t0_space (topological_space to_additive.value_type) := sorry --non-trivial
lemma new_lemma_101563 (h0 : functor.add_const (function.extfun (Type 1) topological_space) (has_Inf Type)) : @locally_compact_space.{1} (semigroup.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@functor.add_const.run.{2 1} (function.extfun.{3 2} (Type 1) topological_space.{1}) (has_Inf.{1} Type) h0) (semigroup.{1} Type))  := sorry --non-trivial
lemma new_lemma_101564 (h0 : group (complete_distrib_lattice (ring linarith.comp))) : group.fg (complete_distrib_lattice (ring linarith.comp)) := sorry --non-trivial
lemma new_lemma_101565 (h0 : group (normed_group (has_inv (random_gen linarith.comp_source)))) : normalizer_condition (normed_group (has_inv (random_gen linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_101566 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : filter.ne_bot (function.extfun_app (function.extfun_app h0 filter) (ring Type)) := sorry --non-trivial
lemma new_lemma_101567 (h0 : function.extfun Type group) : @group.fg.{0} (metric_space.{0} unsigned) (@function.extfun_app.{2 1} Type group.{0} h0 (metric_space.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_101568 (h0 : uniform_space (normed_comm_ring (has_add pos))) : separated_space (normed_comm_ring (has_add pos)) := sorry --non-trivial
lemma new_lemma_101569 (h0 : functor.add_const (topological_space (boolean_algebra environment.implicit_infer_kind)) linarith.comp) : @regular_space.{0} (boolean_algebra.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (boolean_algebra.{0} environment.implicit_infer_kind)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_101570 (h0 : add_group (with_bot unsigned)) : is_add_cyclic (with_bot unsigned) := sorry --non-trivial
lemma new_lemma_101571 (h0 : function.extfun (finset ((Type -> Type) -> Type 1)) (has_mem.mem (function.extfun Type))) : @totally_disconnected_space.{0} (with_bot.{0} linarith.ineq) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) (@finset.pi.empty.{2 1} ((Type → Type) → Type 1) (function.extfun.{2 2} (Type → Type)) (function.extfun.{2 1} Type) (@function.extfun_app.{3 0} (finset.{2} ((Type → Type) → Type 1)) (@has_mem.mem.{2 2} ((Type → Type) → Type 1) (finset.{2} ((Type → Type) → Type 1)) (@finset.has_mem.{2} ((Type → Type) → Type 1)) (function.extfun.{2 1} Type)) h0 (@has_emptyc.emptyc.{2} (finset.{2} ((Type → Type) → Type 1)) (@finset.has_emptyc.{2} ((Type → Type) → Type 1))))) topological_space.{0}) (with_bot.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_101572 (h0 : list (normed_comm_ring empty)) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_101573 (h0 : topological_space (normed_comm_ring (boolean_algebra.core pos))) : sequential_space (normed_comm_ring (boolean_algebra.core pos)) := sorry --non-trivial
lemma new_lemma_101574 (h0 : functor.add_const (uniform_space (add_comm_monoid environment.implicit_infer_kind)) linarith.comp) : @separated_space.{0} (add_comm_monoid.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (uniform_space.{0} (add_comm_monoid.{0} environment.implicit_infer_kind)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_101575 (h0 : function.extfun Type topological_space) : @discrete_topology.{0} (has_emptyc.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_emptyc.{0} num))  := sorry --non-trivial
lemma new_lemma_101576 (h1 : topological_space (simple_graph linarith.comp_source)) : totally_disconnected_space (simple_graph linarith.comp_source) := sorry --non-trivial
lemma new_lemma_101577 (h0 : functor.add_const (ordered_add_comm_monoid (comm_group unsigned)) name) : @archimedean.{0} (comm_group.{0} unsigned) (@functor.add_const.run.{0 0} (ordered_add_comm_monoid.{0} (comm_group.{0} unsigned)) name h0)  := sorry --non-trivial
lemma new_lemma_101578 (h0 : function.extfun Type group) : @is_simple_group.{0} (linear_ordered_field.{0} ennreal) (@function.extfun_app.{2 1} Type group.{0} h0 (linear_ordered_field.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_101579 (h1 : add_group (has_norm (has_norm num))) : is_add_cyclic (has_norm (has_norm num)) := sorry --non-trivial
lemma new_lemma_101580 (h0 : functor.add_const Prop name) : functor.add_const.run h0 := sorry --non-trivial
lemma new_lemma_101581 (h0 : not (add_group unsigned -> false)) : @is_add_cyclic.{0} unsigned (@classical.by_contradiction'.{1} (add_group.{0} unsigned) h0)  := sorry --non-trivial
lemma new_lemma_101582 (h0 : ordered_add_comm_monoid (canonically_linear_ordered_monoid (has_pos_part Type))) : archimedean (canonically_linear_ordered_monoid (has_pos_part Type)) := sorry --non-trivial
lemma new_lemma_101583 (h0 : ring (add_comm_monoid ennreal)) : rank_condition (add_comm_monoid ennreal) := sorry --non-trivial
lemma new_lemma_101584 (h0 : group (normed_linear_ordered_group (option unsigned))) : normalizer_condition (normed_linear_ordered_group (option unsigned)) := sorry --non-trivial
lemma new_lemma_101585 (h0 h1 : multiset (has_nnnorm (mul_one_class char))) : multiset.subset h0 h1 := sorry --non-trivial
lemma new_lemma_101586 (h0 : topological_space (normed_group (semiring unsigned))) : irreducible_space (normed_group (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_101587 (h0 : functor.add_const (topological_space (add_comm_monoid linarith.comp)) (has_zero pos)) : @t1_space.{0} (add_comm_monoid.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (add_comm_monoid.{0} linarith.comp)) (has_zero.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_101588 (h0 : ring (has_bot (has_Inf pos))) : strong_rank_condition (has_bot (has_Inf pos)) := sorry --non-trivial
lemma new_lemma_101589 (h0 : topological_space (has_pos_part (generalized_boolean_algebra Type))) : locally_compact_space (has_pos_part (generalized_boolean_algebra Type)) := sorry --non-trivial
lemma new_lemma_101590 (h0 : topological_space (ordered_comm_monoid pos)) : sequential_space (ordered_comm_monoid pos) := sorry --non-trivial
lemma new_lemma_101591 (h0 : function.extfun Type topological_space) : @t0_space.{0} (has_union.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_union.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_101592 (h0 : topological_space (add_comm_monoid (has_add (comm_group (comm_group (has_neg_part unsigned)))))) : normal_space (add_comm_monoid (has_add (comm_group (comm_group (has_neg_part unsigned))))) := sorry --non-trivial
lemma new_lemma_101593 (h0 : set (has_nnnorm string.iterator_imp)) : set.finite h0 := sorry --non-trivial
lemma new_lemma_101594 (h0 : topological_space (has_zero (finset (has_nndist (finset (finset name)))))) : discrete_topology (has_zero (finset (has_nndist (finset (finset name))))) := sorry --non-trivial
lemma new_lemma_101595 (h0 : topological_space (free_add_monoid unsigned)) : t0_space (free_add_monoid unsigned) := sorry --non-trivial
lemma new_lemma_101596 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @normalizer_condition.{0} (has_add.{0} linarith.comp) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (has_add.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_101597 (h0 : functor.add_const (topological_space (has_star unsigned)) empty) : @totally_disconnected_space.{0} (has_star.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (has_star.{0} unsigned)) empty h0)  := sorry --non-trivial
lemma new_lemma_101598 (h0 : functor.add_const (ring (normed_comm_ring pos)) linarith.comp) : @rank_condition.{0} (normed_comm_ring.{0} pos) (@functor.add_const.run.{0 0} (ring.{0} (normed_comm_ring.{0} pos)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_101599 (h0 : functor.add_const (ordered_add_comm_monoid Type) Type) : @archimedean.{1} Type (@functor.add_const.run.{1 1} (ordered_add_comm_monoid.{1} Type) Type h0)  := sorry --non-trivial
lemma new_lemma_101600 (h0 : list (div_inv_monoid fun_info)) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_101601 (h0 : measurable_space fun_info) (h1 : has_inf fun_info -> enat) (h2 : coe_sort (set.range h1)) : @has_measurable_inf.{0} fun_info h0 (@set.range_splitting.{0 0} (has_inf.{0} fun_info) enat h1 h2)  := sorry --non-trivial
lemma new_lemma_101602 (h0 : functor.add_const (filter (has_to_string linarith.comp)) Type) : filter.ne_bot (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_101603 (h1 : ring (nondiscrete_normed_field string.iterator_imp)) : rank_condition (nondiscrete_normed_field string.iterator_imp) := sorry --non-trivial
lemma new_lemma_101604 (h0 : function.extfun Type complete_lattice) : @complete_lattice.is_Sup_finite_compact.{0} (has_to_string.{0} empty) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (has_to_string.{0} empty))  := sorry --non-trivial
lemma new_lemma_101605 (h0 : functor.add_const (add_group (ordered_comm_ring name)) pos) : @is_add_cyclic.{0} (ordered_comm_ring.{0} name) (@functor.add_const.run.{0 0} (add_group.{0} (ordered_comm_ring.{0} name)) pos h0)  := sorry --non-trivial
lemma new_lemma_101606 (h1 : group (has_emptyc congr_arg_kind)) : normalizer_condition (has_emptyc congr_arg_kind) := sorry --non-trivial
lemma new_lemma_101607 (h0 : functor.add_const (ring (semiring congr_arg_kind)) unsigned) : @rank_condition.{0} (semiring.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (ring.{0} (semiring.{0} congr_arg_kind)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_101608 (h0 : functor.add_const (add_monoid (free_add_monoid num)) empty) : add_monoid.fg (free_add_monoid num) := sorry --non-trivial
lemma new_lemma_101609 (h0 : uniform_space (has_div (mul_one_class string.iterator_imp))) : complete_space (has_div (mul_one_class string.iterator_imp)) := sorry --non-trivial
lemma new_lemma_101610 (h0 : topological_space (has_to_string (has_to_string pos))) : normal_space (has_to_string (has_to_string pos)) := sorry --non-trivial
lemma new_lemma_101611 (h0 : function.extfun Type complete_lattice) : @is_compactly_generated.{0} (canonically_linear_ordered_monoid.{0} unsigned) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (canonically_linear_ordered_monoid.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_101612 (h0 : ring (normed_lattice_add_comm_group (has_add pos))) : strong_rank_condition (normed_lattice_add_comm_group (has_add pos)) := sorry --non-trivial
lemma new_lemma_101613 (h0 : function.extfun Type ring) : @is_domain.{0} (random_gen.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type ring.{0} h0 (random_gen.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_101614 (h0 : add_comm_monoid (monoid (option (option empty))) -> add_comm_monoid (monoid (option (option empty))) -> Prop) : is_per (add_comm_monoid (monoid (option (option empty)))) h0 := sorry --non-trivial
lemma new_lemma_101615 (h0 : topological_space (pseudo_metric_space num)) : t1_space (pseudo_metric_space num) := sorry --non-trivial
lemma new_lemma_101616 (h0 : not (ring (has_div reducibility_hints) -> false)) : @rank_condition.{0} (has_div.{0} reducibility_hints) (@classical.by_contradiction'.{1} (ring.{0} (has_div.{0} reducibility_hints)) h0)  := sorry --non-trivial
lemma new_lemma_101617 (h2 : Prop) : set.separates_points (id (fun (h0 : enat -> add_comm_semigroup std_gen), h2)) := sorry --non-trivial
lemma new_lemma_101618 (h0 : not (function.extfun Type topological_space -> false)) : @irreducible_space.{0} linarith.comp_source (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) linarith.comp_source)  := sorry --non-trivial
lemma new_lemma_101619 (h0 : group (semigroup empty)) : normalizer_condition (semigroup empty) := sorry --non-trivial
lemma new_lemma_101620 (h0 : function.extfun nat fin) : @strong_rank_condition.{0} (comm_semigroup.{0} environment.implicit_infer_kind) (@matrix.vec_empty.{0} (ring.{0} (comm_semigroup.{0} environment.implicit_infer_kind)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_101621 (h0 : functor.add_const (topological_space (has_neg_part unsigned)) pos) : @preirreducible_space.{0} (has_neg_part.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (has_neg_part.{0} unsigned)) pos h0)  := sorry --non-trivial
lemma new_lemma_101622 (h0 : function.extfun Type (functor.comp ordered_add_comm_monoid canonically_linear_ordered_monoid)) : @archimedean.{0} (canonically_linear_ordered_monoid.{0} pos) (@functor.comp.run.{0 0 0} ordered_add_comm_monoid.{0} canonically_linear_ordered_monoid.{0} pos (@function.extfun_app.{2 1} Type (functor.comp.{0 0 0} ordered_add_comm_monoid.{0} canonically_linear_ordered_monoid.{0}) h0 pos))  := sorry --non-trivial
lemma new_lemma_101623 (h0 : ring (has_add (has_Inf (has_Inf (has_Inf Type))))) : rank_condition (has_add (has_Inf (has_Inf (has_Inf Type)))) := sorry --non-trivial
lemma new_lemma_101624 (h0 : topological_space (add_cancel_monoid (boolean_algebra.core environment.implicit_infer_kind))) : locally_compact_space (add_cancel_monoid (boolean_algebra.core environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_101625 (h0 : complete_lattice (has_add (has_to_string (has_neg_part (complete_distrib_lattice (finset pos)))))) : is_atomistic (has_add (has_to_string (has_neg_part (complete_distrib_lattice (finset pos))))) := sorry --non-trivial
lemma new_lemma_101626 (h0 : topological_space (non_unital_non_assoc_semiring (has_compl linarith.comp_source))) : totally_disconnected_space (non_unital_non_assoc_semiring (has_compl linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_101627 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_atomistic.{0} (random_gen.{0} linarith.ineq) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (random_gen.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_101628 (h0 : ring (plift num)) : is_principal_ideal_ring (plift num) := sorry --non-trivial
lemma new_lemma_101629 (h0 : topological_space (semigroup (has_neg_part Type))) : totally_disconnected_space (semigroup (has_neg_part Type)) := sorry --non-trivial
lemma new_lemma_101630 (h0 : topological_space (boolean_algebra (has_nndist (has_add pos)))) : discrete_topology (boolean_algebra (has_nndist (has_add pos))) := sorry --non-trivial
lemma new_lemma_101631 (h0 : functor.add_const (ring (add_cancel_monoid linarith.comp)) linarith.comp) : @rank_condition.{0} (add_cancel_monoid.{0} linarith.comp) (@functor.add_const.run.{0 0} (ring.{0} (add_cancel_monoid.{0} linarith.comp)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_101632 (h0 : fin has_zero.zero) : @discrete_topology.{1} (generalized_boolean_algebra.{1} Type) (@matrix.vec_empty.{1} (topological_space.{1} (generalized_boolean_algebra.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_101633 (h0 : topological_space (metric_space (semiring (semiring empty)))) : locally_compact_space (metric_space (semiring (semiring empty))) := sorry --non-trivial
lemma new_lemma_101634 (h0 : function.extfun (finset Type) (has_mem.mem fun_info)) : @totally_disconnected_space.{0} fun_info (@finset.pi.empty.{1 0} Type topological_space.{0} fun_info (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) fun_info) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_101635 (h0 : topological_space (normed_comm_ring (metric_space (mul_one_class (has_pos_part Type))))) : preirreducible_space (normed_comm_ring (metric_space (mul_one_class (has_pos_part Type)))) := sorry --non-trivial
lemma new_lemma_101636 (h0 : uniform_space (canonically_ordered_comm_semiring (option (option unsigned)))) : complete_space (canonically_ordered_comm_semiring (option (option unsigned))) := sorry --non-trivial
lemma new_lemma_101637 (h0 : topological_space (denumerable (has_nnnorm linarith.comp_source))) : t0_space (denumerable (has_nnnorm linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_101638 (h0 : function.extfun Type topological_space) : @path_connected_space.{0} (simple_graph.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (simple_graph.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_101639 (h0 : functor.add_const (list (comm_group Type)) name) : palindrome (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_101640 (h0 : function.extfun Type add_group) : @is_add_cyclic.{0} (has_bot.{0} empty) (@function.extfun_app.{2 1} Type add_group.{0} h0 (has_bot.{0} empty))  := sorry --non-trivial
lemma new_lemma_101641 (h0 : not (function.extfun Type topological_space -> false)) : @normal_space.{0} (has_union.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (has_union.{0} num))  := sorry --non-trivial
lemma new_lemma_101642 (h0 : group (with_bot (with_bot linarith.comp))) : normalizer_condition (with_bot (with_bot linarith.comp)) := sorry --non-trivial
lemma new_lemma_101643 (h0 : not (uniform_space (has_lt linarith.comp_source) -> false)) : @complete_space.{0} (has_lt.{0} linarith.comp_source) (@classical.by_contradiction'.{1} (uniform_space.{0} (has_lt.{0} linarith.comp_source)) h0)  := sorry --non-trivial
lemma new_lemma_101644 (h0 : measurable_space (nondiscrete_normed_field ereal)) (h1 : measure_theory.measure (nondiscrete_normed_field ereal)) : measure_theory.is_finite_measure h1 := sorry --non-trivial
lemma new_lemma_101645 (h0 : function.extfun Type semiring) : @is_noetherian_ring.{0} (canonically_ordered_comm_semiring.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type semiring.{0} h0 (canonically_ordered_comm_semiring.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_101646 (h0 : measurable_space (distrib linarith.comp_source)) (h1 : filter (distrib linarith.comp_source)) : filter.is_measurably_generated h1 := sorry --non-trivial
lemma new_lemma_101647 (h0 : group (semiring (semiring (semiring unsigned)))) : group.fg (semiring (semiring (semiring unsigned))) := sorry --non-trivial
lemma new_lemma_101648 (h0 : topological_space (canonically_linear_ordered_monoid (option (option (option pos))))) : discrete_topology (canonically_linear_ordered_monoid (option (option (option pos)))) := sorry --non-trivial
lemma new_lemma_101649 (h0 : group (complete_distrib_lattice (cancel_monoid pos))) : is_simple_group (complete_distrib_lattice (cancel_monoid pos)) := sorry --non-trivial
lemma new_lemma_101650 (h0 : ring (has_one (semiring empty))) : is_domain (has_one (semiring empty)) := sorry --non-trivial
lemma new_lemma_101651 (h0 : topological_space (option (option ennreal))) : t0_space (option (option ennreal)) := sorry --non-trivial
lemma new_lemma_101652 (h0 : topological_space (random_gen (random_gen (random_gen to_additive.value_type)))) : t0_space (random_gen (random_gen (random_gen to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_101653 (h1 : topological_space (measurable_space linarith.comp)) : totally_disconnected_space (measurable_space linarith.comp) := sorry --non-trivial
lemma new_lemma_101654 (h0 : list (option unsigned)) : palindrome h0 := sorry --non-trivial
lemma new_lemma_101655 (h0 : topological_space (non_assoc_semiring (option (option unsigned)))) : totally_separated_space (non_assoc_semiring (option (option unsigned))) := sorry --non-trivial
lemma new_lemma_101656 (h0 : topological_space (add_cancel_monoid (has_neg linarith.comp))) : locally_compact_space (add_cancel_monoid (has_neg linarith.comp)) := sorry --non-trivial
lemma new_lemma_101657 (h0 : function.extfun Type topological_space) : @topological_space.separable_space.{0} (omega_complete_partial_order.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (omega_complete_partial_order.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_101658 (h0 : topological_space (ring (has_pos_part (normed_comm_ring linarith.comp)))) : path_connected_space (ring (has_pos_part (normed_comm_ring linarith.comp))) := sorry --non-trivial
lemma new_lemma_101659 (h2 : group (complete_semilattice_Sup congr_arg_kind)) : normalizer_condition (complete_semilattice_Sup congr_arg_kind) := sorry --non-trivial
lemma new_lemma_101660 (h0 : filter (semigroup (option (option ennreal)))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_101661 (h0 : function.extfun Type topological_space) : @sequential_space.{0} (has_add.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_add.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_101662 (h0 : not (function.extfun Type uniform_space -> false)) : @complete_space.{0} (free_add_monoid.{0} unsigned) (@function.extfun_app.{2 1} Type uniform_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type uniform_space.{0}) h0) (free_add_monoid.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_101663 (h0 : monoid (has_inter (has_to_string (has_to_string ennreal)))) : monoid.fg (has_inter (has_to_string (has_to_string ennreal))) := sorry --non-trivial
lemma new_lemma_101664 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @regular_space.{0} (simple_graph.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (simple_graph.{0} pos))  := sorry --non-trivial
lemma new_lemma_101665 (h0 : topological_space (distrib (has_nnnorm (has_nnnorm linarith.ineq)))) : path_connected_space (distrib (has_nnnorm (has_nnnorm linarith.ineq))) := sorry --non-trivial
lemma new_lemma_101666 (h0 : filter (linear_ordered_semiring (semilattice_inf linarith.comp))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_101667 (h1 : not (ring (denumerable char) -> false)) : @strong_rank_condition.{0} (denumerable.{0} char) (@classical.by_contradiction'.{1} (ring.{0} (denumerable.{0} char)) h1)  := sorry --non-trivial
lemma new_lemma_101668 (h0 : topological_space (add_comm_monoid unsigned)) : preirreducible_space (add_comm_monoid unsigned) := sorry --non-trivial
lemma new_lemma_101669 (h0 : topological_space (canonically_ordered_monoid (has_nndist Type))) : preirreducible_space (canonically_ordered_monoid (has_nndist Type)) := sorry --non-trivial
lemma new_lemma_101670 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @normalizer_condition.{0} (mul_zero_class.{0} empty) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (mul_zero_class.{0} empty))  := sorry --non-trivial
lemma new_lemma_101671 (h0 : group (add_comm_monoid real)) : group.fg (add_comm_monoid real) := sorry --non-trivial
lemma new_lemma_101672 (h0 : ring (complete_semilattice_Sup (has_inv (comm_ring (comm_ring linarith.ineq))))) : is_domain (complete_semilattice_Sup (has_inv (comm_ring (comm_ring linarith.ineq)))) := sorry --non-trivial
lemma new_lemma_101673 (h0 : function.extfun Type group) : @normalizer_condition.{0} (has_neg.{0} linarith.comp) (@function.extfun_app.{2 1} Type group.{0} h0 (has_neg.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_101674 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @topological_space.separable_space.{1} (finset.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 topological_space.{1}) (finset.{1} Type))  := sorry --non-trivial
lemma new_lemma_101675 (h0 : ring (add_comm_monoid (has_to_string (comm_group (comm_group Type))))) : is_domain (add_comm_monoid (has_to_string (comm_group (comm_group Type)))) := sorry --non-trivial
lemma new_lemma_101676 (h0 : semiring (has_bot (has_add (has_add (has_bot (has_bot real)))))) : is_noetherian_ring (has_bot (has_add (has_add (has_bot (has_bot real))))) := sorry --non-trivial
lemma new_lemma_101677 (h0 : not (ring (has_top to_additive.value_type) -> false)) : @strong_rank_condition.{0} (has_top.{0} to_additive.value_type) (@classical.by_contradiction'.{1} (ring.{0} (has_top.{0} to_additive.value_type)) h0)  := sorry --non-trivial
lemma new_lemma_101678 (h7 : set (linarith.ineq -> char)) : set.separates_points h7 := sorry --non-trivial
lemma new_lemma_101679 (h0 : ring (linear_ordered_comm_group (option (option ennreal)))) : rank_condition (linear_ordered_comm_group (option (option ennreal))) := sorry --non-trivial
lemma new_lemma_101680 (h0 : topological_space (add_cancel_monoid (has_neg_part pos))) : irreducible_space (add_cancel_monoid (has_neg_part pos)) := sorry --non-trivial
lemma new_lemma_101681 (h0 : ring (add_cancel_monoid (mul_one_class pos))) : is_domain (add_cancel_monoid (mul_one_class pos)) := sorry --non-trivial
lemma new_lemma_101682 (h0 : function.extfun (Type 1) list) : list.nodup (function.extfun_app h0 (boolean_algebra Type)) := sorry --non-trivial
lemma new_lemma_101683 (h0 : function.extfun (finset (Type -> Type)) (has_mem.mem monoid)) : @monoid.fg.{0} (linear_ordered_semiring.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type monoid.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) monoid.{0} (@function.extfun_app.{2 0} (finset.{1} (Type → Type)) (@has_mem.mem.{1 1} (Type → Type) (finset.{1} (Type → Type)) (@finset.has_mem.{1} (Type → Type)) monoid.{0}) h0 (@has_emptyc.emptyc.{1} (finset.{1} (Type → Type)) (@finset.has_emptyc.{1} (Type → Type))))) (linear_ordered_semiring.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_101684 (h0 : function.extfun Type topological_space) : @t0_space.{0} (has_ssubset.{0} fun_info) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_ssubset.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_101685 (h0 : function.extfun nat fin) : @totally_separated_space.{0} (complete_distrib_lattice.{0} linarith.comp) (@matrix.vec_empty.{0} (topological_space.{0} (complete_distrib_lattice.{0} linarith.comp)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_101686 (h0 : function.extfun Type ring) : @rank_condition.{0} (has_union.{0} linarith.comp) (@function.extfun_app.{2 1} Type ring.{0} h0 (has_union.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_101687 (h0 : topological_space (add_cancel_monoid (option (option (option (option (option ennreal))))))) : preconnected_space (add_cancel_monoid (option (option (option (option (option ennreal)))))) := sorry --non-trivial
lemma new_lemma_101688 (h0 : not (cancel_comm_monoid_with_zero (metric_space empty) -> false)) : @unique_factorization_monoid.{0} (metric_space.{0} empty) (@classical.by_contradiction'.{1} (cancel_comm_monoid_with_zero.{0} (metric_space.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_101689 (h0 : ring (finset (ring ennreal))) : is_principal_ideal_ring (finset (ring ennreal)) := sorry --non-trivial
lemma new_lemma_101690 (h0 : topological_space (dlist linarith.ineq)) : totally_disconnected_space (dlist linarith.ineq) := sorry --non-trivial
lemma new_lemma_101691 (h0 : group (ring (option empty))) : normalizer_condition (ring (option empty)) := sorry --non-trivial
lemma new_lemma_101692 (h1 : group (has_append (random_gen char))) : is_cyclic (has_append (random_gen char)) := sorry --non-trivial
lemma new_lemma_101693 (h1 : uniform_space (add_monoid char)) : complete_space (add_monoid char) := sorry --non-trivial
lemma new_lemma_101694 (h0 : topological_space (mul_zero_class (option (option pos)))) : normal_space (mul_zero_class (option (option pos))) := sorry --non-trivial
lemma new_lemma_101695 (h0 : group (encodable (random_gen (random_gen (random_gen (random_gen (random_gen string_imp))))))) : group.fg (encodable (random_gen (random_gen (random_gen (random_gen (random_gen string_imp)))))) := sorry --non-trivial
lemma new_lemma_101696 (h3 : topological_space (random_gen (mul_one_class linarith.comp_source))) : totally_disconnected_space (random_gen (mul_one_class linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_101697 (h0 : topological_space (add_cancel_monoid (option ennreal))) : path_connected_space (add_cancel_monoid (option ennreal)) := sorry --non-trivial
lemma new_lemma_101698 (h0 : topological_space (finset (finset (complete_distrib_lattice (finset Type))))) : topological_space.separable_space (finset (finset (complete_distrib_lattice (finset Type)))) := sorry --non-trivial
lemma new_lemma_101699 (h0 : functor.add_const (function.extfun Type topological_space) linarith.comp) : @regular_space.{0} (has_Inf.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) linarith.comp h0) (has_Inf.{0} name))  := sorry --non-trivial
lemma new_lemma_101700 (h0 : prod (add_left_cancel_semigroup unsigned) (add_left_cancel_semigroup unsigned)) : id_rel h0 := sorry --non-trivial
lemma new_lemma_101701 (h0 : function.extfun Type topological_space) : @discrete_topology.{0} (linear_ordered_cancel_comm_monoid.{0} (option.{0} unsigned)) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (linear_ordered_cancel_comm_monoid.{0} (option.{0} unsigned)))  := sorry --non-trivial
lemma new_lemma_101702 (h0 : group (generalized_boolean_algebra (has_Inf Type))) : is_simple_group (generalized_boolean_algebra (has_Inf Type)) := sorry --non-trivial
lemma new_lemma_101703 (h0 : group (linear_ordered_semiring (has_top congr_arg_kind))) : normalizer_condition (linear_ordered_semiring (has_top congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_101704 (h0 : not (filter (lex to_additive.value_type) -> false)) : filter.ne_bot (classical.by_contradiction' h0) := sorry --non-trivial
lemma new_lemma_101705 (h0 : topological_space (has_one (has_norm empty))) : totally_separated_space (has_one (has_norm empty)) := sorry --non-trivial
lemma new_lemma_101706 (h0 : set (has_compl (has_compl string_imp))) : set.subsingleton h0 := sorry --non-trivial
lemma new_lemma_101707 (h0 : functor.add_const (ring (finset name)) Type) : @strong_rank_condition.{0} (finset.{0} name) (@functor.add_const.run.{0 1} (ring.{0} (finset.{0} name)) Type h0)  := sorry --non-trivial
lemma new_lemma_101708 (h0 : group (has_inv (with_bot string_imp))) : normalizer_condition (has_inv (with_bot string_imp)) := sorry --non-trivial
lemma new_lemma_101709 (h0 : complete_lattice (partial_order (has_top empty))) : is_atomistic (partial_order (has_top empty)) := sorry --non-trivial
lemma new_lemma_101710 (h0 : functor.add_const (function.extfun (Type 1) topological_space) name) : @discrete_topology.{1} (simple_graph.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) topological_space.{1}) name h0) (simple_graph.{1} Type))  := sorry --non-trivial
lemma new_lemma_101711 (h0 : not (uniform_space (uniform_space string_imp) -> false)) : @complete_space.{0} (uniform_space.{0} string_imp) (@classical.by_contradiction'.{1} (uniform_space.{0} (uniform_space.{0} string_imp)) h0)  := sorry --non-trivial
lemma new_lemma_101712 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @preirreducible_space.{0} (normed_comm_ring.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (normed_comm_ring.{0} num))  := sorry --non-trivial
lemma new_lemma_101713 (h0 : topological_space (has_add (has_Inf (has_pos_part Type)))) : regular_space (has_add (has_Inf (has_pos_part Type))) := sorry --non-trivial
lemma new_lemma_101714 (h0 : ring (random_gen char)) (h1 : punit) : is_domain (random_gen char) := sorry --non-trivial
lemma new_lemma_101715 (h0 : add_group (add_cancel_monoid (has_nndist Type))) : is_add_cyclic (add_cancel_monoid (has_nndist Type)) := sorry --non-trivial
lemma new_lemma_101716 (h0 : uniform_space (generalized_boolean_algebra pos)) : separated_space (generalized_boolean_algebra pos) := sorry --non-trivial
lemma new_lemma_101717 (h0 : function.extfun Type filter) : filter.ne_bot (function.extfun_app h0 (has_ssubset fun_info)) := sorry --non-trivial
lemma new_lemma_101718 (h1 : group (random_gen char)) : is_cyclic (random_gen char) := sorry --non-trivial
lemma new_lemma_101719 (h0 : functor.add_const (topological_space (has_neg Type)) (semigroup name)) : @totally_separated_space.{1} (has_neg.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (has_neg.{1} Type)) (semigroup.{0} name) h0)  := sorry --non-trivial
lemma new_lemma_101720 (h0 : complete_lattice (linear_ordered_add_comm_group (has_top linarith.comp_source))) : is_compactly_generated (linear_ordered_add_comm_group (has_top linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_101721 (h0 : finset (simple_graph congr_arg_kind)) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_101722 (h1 : topological_space (has_top (has_norm linarith.comp_source))) : irreducible_space (has_top (has_norm linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_101723 (h0 : topological_space (has_compl to_additive.value_type)) (h1 : preorder (has_compl to_additive.value_type)) : order_topology (has_compl to_additive.value_type) := sorry --non-trivial
lemma new_lemma_101724 (h0 : function.extfun Type topological_space) : @totally_disconnected_space.{0} (has_star.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_star.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_101725 (h1 : group (has_add char)) : is_cyclic (has_add char) := sorry --non-trivial
lemma new_lemma_101726 (h0 : topological_space (semigroup (ring (has_pos_part Type)))) : sequential_space (semigroup (ring (has_pos_part Type))) := sorry --non-trivial
lemma new_lemma_101727 (h3 : not (topological_space (has_norm linarith.ineq) -> false)) : @t0_space.{0} (has_norm.{0} linarith.ineq) (@classical.by_contradiction'.{1} (topological_space.{0} (has_norm.{0} linarith.ineq)) h3)  := sorry --non-trivial
lemma new_lemma_101728 (h0 : cancel_comm_monoid_with_zero (has_add (has_add Type))) : unique_factorization_monoid (has_add (has_add Type)) := sorry --non-trivial
lemma new_lemma_101729 (h0 : topological_space (generalized_boolean_algebra (has_add (has_add name)))) : preconnected_space (generalized_boolean_algebra (has_add (has_add name))) := sorry --non-trivial
lemma new_lemma_101730 (h0 : functor.add_const (topological_space (ordered_comm_ring Type)) linarith.comp) : @preconnected_space.{1} (ordered_comm_ring.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (ordered_comm_ring.{1} Type)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_101731 (h0 : topological_space (has_one (semiring (has_norm (semiring linarith.comp))))) : irreducible_space (has_one (semiring (has_norm (semiring linarith.comp)))) := sorry --non-trivial
lemma new_lemma_101732 (h0 : group (has_pos_part (has_Inf Type))) : is_cyclic (has_pos_part (has_Inf Type)) := sorry --non-trivial
lemma new_lemma_101733 (h0 : topological_space (normed_comm_ring (finset (has_pos_part (finset linarith.comp))))) : totally_separated_space (normed_comm_ring (finset (has_pos_part (finset linarith.comp)))) := sorry --non-trivial
lemma new_lemma_101734 (h0 : complete_lattice (linear_ordered_comm_ring unsigned)) : is_atomistic (linear_ordered_comm_ring unsigned) := sorry --non-trivial
lemma new_lemma_101735 (h0 : functor.add_const (complete_lattice (has_add unsigned)) name) : @is_compactly_generated.{0} (has_add.{0} unsigned) (@functor.add_const.run.{0 0} (complete_lattice.{0} (has_add.{0} unsigned)) name h0)  := sorry --non-trivial
lemma new_lemma_101736 (h0 : topological_space (has_top (semiring unsigned))) : topological_space.separable_space (has_top (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_101737 (h0 : functor.add_const (topological_space (has_pos_part linarith.comp)) linarith.comp) : @irreducible_space.{0} (has_pos_part.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (has_pos_part.{0} linarith.comp)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_101738 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @t0_space.{0} (simple_graph.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (simple_graph.{0} pos))  := sorry --non-trivial
lemma new_lemma_101739 (h0 : functor.add_const (list (boolean_algebra environment.implicit_infer_kind)) environment.implicit_infer_kind) : palindrome (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_101740 (h0 : fin has_zero.zero) : @preirreducible_space.{1} (has_add.{1} Type) (@matrix.vec_empty.{1} (topological_space.{1} (has_add.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_101741 (h0 : topological_space ereal) (h1 : set (string.iterator_imp -> compact_exhaustion ereal)) : set.separates_points h1 := sorry --non-trivial
lemma new_lemma_101742 (h0 : function.extfun Type add_monoid) : @add_monoid.fg.{0} (has_one.{0} empty) (@function.extfun_app.{2 1} Type add_monoid.{0} h0 (has_one.{0} empty))  := sorry --non-trivial
lemma new_lemma_101743 (h0 : functor.add_const (complete_lattice (ordered_ring unsigned)) unsigned) : @is_compactly_generated.{0} (ordered_ring.{0} unsigned) (@functor.add_const.run.{0 0} (complete_lattice.{0} (ordered_ring.{0} unsigned)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_101744 (h0 : cancel_comm_monoid_with_zero (metric_space (semiring (semiring (semiring num))))) : unique_factorization_monoid (metric_space (semiring (semiring (semiring num)))) := sorry --non-trivial
lemma new_lemma_101745 (h0 : functor.add_const (group (add_comm_monoid pos)) (has_to_string (has_neg Type))) : @group.fg.{0} (add_comm_monoid.{0} pos) (@functor.add_const.run.{0 1} (group.{0} (add_comm_monoid.{0} pos)) (has_to_string.{1} (has_neg.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_101746 (h0 : add_group (add_cancel_monoid (finset ennreal))) : is_add_cyclic (add_cancel_monoid (finset ennreal)) := sorry --non-trivial
lemma new_lemma_101747 (h0 : semiring (with_bot (has_top linarith.comp))) : is_noetherian_ring (with_bot (has_top linarith.comp)) := sorry --non-trivial
lemma new_lemma_101748 (h0 : function.extfun Type ring) : @is_domain.{0} (semiring.{0} empty) (@function.extfun_app.{2 1} Type ring.{0} h0 (semiring.{0} empty))  := sorry --non-trivial
lemma new_lemma_101749 (h0 : function.extfun (Type 1) uniform_space) : @separated_space.{1} (ordered_comm_monoid.{1} Type) (@function.extfun_app.{3 2} (Type 1) uniform_space.{1} h0 (ordered_comm_monoid.{1} Type))  := sorry --non-trivial
lemma new_lemma_101750 (h0 : complete_lattice (has_le (uniform_space enat))) : complete_lattice.is_Sup_finite_compact (has_le (uniform_space enat)) := sorry --non-trivial
lemma new_lemma_101751 (h0 : functor.add_const (function.extfun Type ring) Type) : @rank_condition.{0} (normed_comm_ring.{0} pos) (@function.extfun_app.{2 1} Type ring.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type ring.{0}) Type h0) (normed_comm_ring.{0} pos))  := sorry --non-trivial
lemma new_lemma_101752 (h0 : not (function.extfun (Type -> Type) (function.extfun Type) -> false)) : @group.fg.{0} (has_norm.{0} fun_info) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) (@classical.by_contradiction'.{2} (function.extfun.{2 2} (Type → Type) (function.extfun.{2 1} Type)) h0) group.{0}) (has_norm.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_101753 (h1 : topological_space (complete_semilattice_Sup (with_one fun_info))) : irreducible_space (complete_semilattice_Sup (with_one fun_info)) := sorry --non-trivial
lemma new_lemma_101754 (h0 : functor.add_const (finset (finset pos)) Type) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_101755 (h0 : fin has_zero.zero) : @strong_rank_condition.{0} (has_add.{0} name) (@matrix.vec_empty.{0} (ring.{0} (has_add.{0} name)) h0)  := sorry --non-trivial
lemma new_lemma_101756 (h0 : set (linarith.ineq -> enat)) : set.separates_points h0 := sorry --non-trivial
lemma new_lemma_101757 (h0 : list (linear_ordered_field empty)) : palindrome h0 := sorry --non-trivial
lemma new_lemma_101758 (h0 : topological_space (pseudo_metric_space num)) : totally_separated_space (pseudo_metric_space num) := sorry --non-trivial
lemma new_lemma_101759 (h0 : topological_space (has_nndist environment.implicit_infer_kind)) : sequential_space (has_nndist environment.implicit_infer_kind) := sorry --non-trivial
lemma new_lemma_101760 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @locally_compact_space.{0} (ring.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (ring.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_101761 (h0 : topological_space (canonically_ordered_comm_semiring (order_dual Type))) : discrete_topology (canonically_ordered_comm_semiring (order_dual Type)) := sorry --non-trivial
lemma new_lemma_101762 (h0 : uniform_space (has_to_string (has_add (semigroup (add_comm_monoid unsigned))))) : separated_space (has_to_string (has_add (semigroup (add_comm_monoid unsigned)))) := sorry --non-trivial
lemma new_lemma_101763 (h0 : ring (cancel_monoid (has_add environment.implicit_infer_kind))) : is_domain (cancel_monoid (has_add environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_101764 (h0 : functor.add_const (ring (has_nndist name)) Type) : @strong_rank_condition.{0} (has_nndist.{0} name) (@functor.add_const.run.{0 1} (ring.{0} (has_nndist.{0} name)) Type h0)  := sorry --non-trivial
lemma new_lemma_101765 (h0 : function.extfun Type (functor.add_const (group (ordered_ring empty)))) : @is_cyclic.{0} (ordered_ring.{0} empty) (@functor.add_const.run.{0 0} (group.{0} (ordered_ring.{0} empty)) empty (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (group.{0} (ordered_ring.{0} empty))) h0 empty))  := sorry --non-trivial
lemma new_lemma_101766 (h0 : function.extfun (finset Type) (has_mem.mem (normed_group fun_info))) : @t0_space.{0} (normed_group.{0} fun_info) (@finset.pi.empty.{1 0} Type topological_space.{0} (normed_group.{0} fun_info) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (normed_group.{0} fun_info)) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_101767 (h0 : function.extfun Type topological_space) : @totally_separated_space.{0} (normed_lattice_add_comm_group.{0} real) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (normed_lattice_add_comm_group.{0} real))  := sorry --non-trivial
lemma new_lemma_101768 (h0 : functor.add_const (filter (semigroup name)) name) : countable_Inter_filter (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_101769 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @totally_separated_space.{0} (normed_group.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (normed_group.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_101770 (h0 : complete_lattice (complete_semilattice_Sup num)) : complete_lattice.is_Sup_finite_compact (complete_semilattice_Sup num) := sorry --non-trivial
lemma new_lemma_101771 (h0 : function.extfun Type complete_lattice) : @is_compactly_generated.{0} (linear_ordered_field.{0} pos) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (linear_ordered_field.{0} pos))  := sorry --non-trivial
lemma new_lemma_101772 (h0 : functor.comp topological_space add_cancel_monoid pos) : @regular_space.{0} (add_cancel_monoid.{0} pos) (@functor.comp.run.{0 0 0} topological_space.{0} add_cancel_monoid.{0} pos h0)  := sorry --non-trivial
lemma new_lemma_101773 (h0 : ring (canonically_ordered_comm_semiring (has_bot real))) : is_principal_ideal_ring (canonically_ordered_comm_semiring (has_bot real)) := sorry --non-trivial
lemma new_lemma_101774 (h0 : functor.add_const (group (boolean_algebra name)) pos) : @normalizer_condition.{0} (boolean_algebra.{0} name) (@functor.add_const.run.{0 0} (group.{0} (boolean_algebra.{0} name)) pos h0)  := sorry --non-trivial
lemma new_lemma_101775 (h0 : fin has_zero.zero) : @separated_space.{0} (ordered_comm_monoid.{0} linarith.comp) (@matrix.vec_empty.{0} (uniform_space.{0} (ordered_comm_monoid.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_101776 (h0 : has_mul (cancel_monoid Type)) (h1 : function.extfun (Type 1) cancel_monoid) : is_right_regular (function.extfun_app h1 Type) := sorry --non-trivial
lemma new_lemma_101777 (h0 : functor.add_const (topological_space (boolean_algebra.core name)) linarith.comp) : @locally_compact_space.{0} (boolean_algebra.core.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (boolean_algebra.core.{0} name)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_101778 (h0 : uniform_space (has_inter num)) : separated_space (has_inter num) := sorry --non-trivial
lemma new_lemma_101779 (h0 : prod (has_star unsigned) (has_star unsigned)) : id_rel h0 := sorry --non-trivial
lemma new_lemma_101780 (h0 : function.extfun Type (functor.comp uniform_space semigroup)) : @separated_space.{0} (semigroup.{0} name) (@functor.comp.run.{0 0 0} uniform_space.{0} semigroup.{0} name (@function.extfun_app.{2 1} Type (functor.comp.{0 0 0} uniform_space.{0} semigroup.{0}) h0 name))  := sorry --non-trivial
lemma new_lemma_101781 (h3 : ring (normed_field to_additive.value_type)) : is_domain (normed_field to_additive.value_type) := sorry --non-trivial
lemma new_lemma_101782 (h2 : complete_lattice (encodable fun_info)) : is_compactly_generated (encodable fun_info) := sorry --non-trivial
lemma new_lemma_101783 (h0 : functor.add_const (group (boolean_algebra linarith.comp)) pos) : @is_simple_group.{0} (boolean_algebra.{0} linarith.comp) (@functor.add_const.run.{0 0} (group.{0} (boolean_algebra.{0} linarith.comp)) pos h0)  := sorry --non-trivial
lemma new_lemma_101784 (h0 : topological_space (linear_ordered_comm_monoid_with_zero (semiring empty))) : normal_space (linear_ordered_comm_monoid_with_zero (semiring empty)) := sorry --non-trivial
lemma new_lemma_101785 (h0 : topological_space (left_cancel_monoid (semiring (semiring num)))) : normal_space (left_cancel_monoid (semiring (semiring num))) := sorry --non-trivial
lemma new_lemma_101786 (h1 : not (group (has_emptyc num) -> false)) : @is_cyclic.{0} (has_emptyc.{0} num) (@classical.by_contradiction'.{1} (group.{0} (has_emptyc.{0} num)) h1)  := sorry --non-trivial
lemma new_lemma_101787 (h0 : ring (has_to_string ennreal)) : is_domain (has_to_string ennreal) := sorry --non-trivial
lemma new_lemma_101788 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @strong_rank_condition.{0} (complete_semilattice_Sup.{0} char) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (complete_semilattice_Sup.{0} char))  := sorry --non-trivial
lemma new_lemma_101789 (h0 : function.extfun Type (functor.comp ring has_nndist)) : @strong_rank_condition.{0} (has_nndist.{0} pos) (@functor.comp.run.{0 0 0} ring.{0} has_nndist.{0} pos (@function.extfun_app.{2 1} Type (functor.comp.{0 0 0} ring.{0} has_nndist.{0}) h0 pos))  := sorry --non-trivial
lemma new_lemma_101790 (h0 : functor.add_const (finset (boolean_algebra environment.implicit_infer_kind)) environment.implicit_infer_kind) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_101791 (h0 : ring (id (semiring (random_gen (random_gen empty))))) : strong_rank_condition (id (semiring (random_gen (random_gen empty)))) := sorry --non-trivial
lemma new_lemma_101792 (h0 : topological_space (dlist (has_nnnorm (random_gen string_imp)))) : t0_space (dlist (has_nnnorm (random_gen string_imp))) := sorry --non-trivial
lemma new_lemma_101793 (h0 : filter (has_neg (has_neg Type))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_101794 (h0 : not (semiring (complete_linear_order empty) -> false)) : @is_noetherian_ring.{0} (complete_linear_order.{0} empty) (@classical.by_contradiction'.{1} (semiring.{0} (complete_linear_order.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_101795 (h1 : topological_space (random_gen to_additive.value_type)) : path_connected_space (random_gen to_additive.value_type) := sorry --non-trivial
lemma new_lemma_101796 (h0 : ring (has_div enat)) : is_domain (has_div enat) := sorry --non-trivial
lemma new_lemma_101797 (h0 : group (monoid_with_zero (option (option (option (option unsigned)))))) : normalizer_condition (monoid_with_zero (option (option (option (option unsigned))))) := sorry --non-trivial
lemma new_lemma_101798 (h0 : uniform_space (add_cancel_monoid (add_cancel_monoid name))) : complete_space (add_cancel_monoid (add_cancel_monoid name)) := sorry --non-trivial
lemma new_lemma_101799 (h0 : topological_space (has_norm (semiring (linear_ordered_semiring empty)))) : preirreducible_space (has_norm (semiring (linear_ordered_semiring empty))) := sorry --non-trivial
lemma new_lemma_101800 (h0 : ring (has_top (random_gen (random_gen (random_gen (random_gen string_imp)))))) : is_domain (has_top (random_gen (random_gen (random_gen (random_gen string_imp))))) := sorry --non-trivial
lemma new_lemma_101801 (h0 : functor.add_const (topological_space (add_left_cancel_semigroup congr_arg_kind)) (option empty)) : @loc_path_connected_space.{0} (add_left_cancel_semigroup.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (add_left_cancel_semigroup.{0} congr_arg_kind)) (option.{0} empty) h0)  := sorry --non-trivial
lemma new_lemma_101802 (h0 : ring (normed_field reducibility_hints)) : strong_rank_condition (normed_field reducibility_hints) := sorry --non-trivial
lemma new_lemma_101803 (h0 : function.extfun Type ring) : @strong_rank_condition.{0} (add_cancel_monoid.{0} linarith.comp) (@function.extfun_app.{2 1} Type ring.{0} h0 (add_cancel_monoid.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_101804 (h0 : topological_space (add_comm_monoid (ring Type))) : regular_space (add_comm_monoid (ring Type)) := sorry --non-trivial
lemma new_lemma_101805 (h0 : uniform_space (has_one (semiring (semiring (semiring empty))))) : complete_space (has_one (semiring (semiring (semiring empty)))) := sorry --non-trivial
lemma new_lemma_101806 (h0 : semiring (has_add (ring Type))) : is_noetherian_ring (has_add (ring Type)) := sorry --non-trivial
lemma new_lemma_101807 (h0 : fin has_zero.zero) : @path_connected_space.{0} (simple_graph.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} (@matrix.vec_empty.{1} (function.extfun.{2 1} Type topological_space.{0}) h0) (simple_graph.{0} name))  := sorry --non-trivial
lemma new_lemma_101808 (h0 : functor.add_const (function.extfun (Type 1) uniform_space) linarith.comp) : @complete_space.{1} (has_to_string.{1} Type) (@function.extfun_app.{3 2} (Type 1) uniform_space.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) uniform_space.{1}) linarith.comp h0) (has_to_string.{1} Type))  := sorry --non-trivial
lemma new_lemma_101809 (h0 : ring (canonically_ordered_monoid (has_Inf pos))) : strong_rank_condition (canonically_ordered_monoid (has_Inf pos)) := sorry --non-trivial
lemma new_lemma_101810 (h0 : functor.add_const (functor.add_const (filter Type) pos) Type) : countable_Inter_filter (functor.add_const.run (functor.add_const.run h0)) := sorry --non-trivial
lemma new_lemma_101811 (h0 : function.extfun Type filter) : filter.ne_bot (function.extfun_app h0 (filter num)) := sorry --non-trivial
lemma new_lemma_101812 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @sequential_space.{0} (generalized_boolean_algebra.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (generalized_boolean_algebra.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_101813 (h0 : topological_space (complete_distrib_lattice (option empty))) : t0_space (complete_distrib_lattice (option empty)) := sorry --non-trivial
lemma new_lemma_101814 (h0 : group (boolean_algebra.core environment.implicit_infer_kind)) : is_cyclic (boolean_algebra.core environment.implicit_infer_kind) := sorry --non-trivial
lemma new_lemma_101815 (h0 : topological_space (boolean_algebra.core (option (option unsigned)))) : loc_path_connected_space (boolean_algebra.core (option (option unsigned))) := sorry --non-trivial
lemma new_lemma_101816 (h0 : functor.add_const (topological_space (comm_group pos)) pos) : @irreducible_space.{0} (comm_group.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (comm_group.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_101817 (h0 : group (normed_group (has_top to_additive.value_type))) : is_cyclic (normed_group (has_top to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_101818 (h0 : functor.add_const (topological_space (group_with_zero ennreal)) ennreal) : @discrete_topology.{0} (group_with_zero.{0} ennreal) (@functor.add_const.run.{0 0} (topological_space.{0} (group_with_zero.{0} ennreal)) ennreal h0)  := sorry --non-trivial
lemma new_lemma_101819 (h0 : functor.add_const (list (normed_comm_ring environment.implicit_infer_kind)) environment.implicit_infer_kind) : palindrome (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_101820 (h0 : functor.add_const (ordered_comm_monoid (add_cancel_monoid pos)) (has_nndist (has_neg name))) : @has_exists_mul_of_le.{0} (add_cancel_monoid.{0} pos) (@functor.add_const.run.{0 0} (ordered_comm_monoid.{0} (add_cancel_monoid.{0} pos)) (has_nndist.{0} (has_neg.{0} name)) h0)  := sorry --non-trivial
lemma new_lemma_101821 (h0 : add_group (denumerable (has_nnnorm (random_gen (random_gen char))))) : is_add_cyclic (denumerable (has_nnnorm (random_gen (random_gen char)))) := sorry --non-trivial
lemma new_lemma_101822 (h0 : functor.add_const (semiring (canonically_ordered_comm_semiring linarith.comp)) (has_neg Type)) : @is_noetherian_ring.{0} (canonically_ordered_comm_semiring.{0} linarith.comp) (@functor.add_const.run.{0 1} (semiring.{0} (canonically_ordered_comm_semiring.{0} linarith.comp)) (has_neg.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_101823 (h0 : not (topological_space (ordered_comm_semiring linarith.comp_source) -> false)) : @totally_disconnected_space.{0} (ordered_comm_semiring.{0} linarith.comp_source) (@classical.by_contradiction'.{1} (topological_space.{0} (ordered_comm_semiring.{0} linarith.comp_source)) h0)  := sorry --non-trivial
lemma new_lemma_101824 (h0 : prod (has_dist ennreal) (has_dist ennreal)) : id_rel h0 := sorry --non-trivial
lemma new_lemma_101825 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @loc_path_connected_space.{0} (as_linear_order.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (as_linear_order.{0} empty))  := sorry --non-trivial
lemma new_lemma_101826 (h1 : complete_lattice (comm_ring string_imp)) : is_compactly_generated (comm_ring string_imp) := sorry --non-trivial
lemma new_lemma_101827 (h0 : function.extfun Type topological_space) : @t1_space.{0} (sub_neg_monoid.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (sub_neg_monoid.{0} name))  := sorry --non-trivial
lemma new_lemma_101828 (h0 : topological_space (metric_space (add_right_cancel_monoid linarith.comp))) : normal_space (metric_space (add_right_cancel_monoid linarith.comp)) := sorry --non-trivial
lemma new_lemma_101829 (h0 : topological_space (linear_ordered_field name)) : preirreducible_space (linear_ordered_field name) := sorry --non-trivial
lemma new_lemma_101830 (h0 : topological_space (ring ennreal)) : sequential_space (ring ennreal) := sorry --non-trivial
lemma new_lemma_101831 (h0 : topological_space (semigroup (has_neg (has_to_string Type)))) : t0_space (semigroup (has_neg (has_to_string Type))) := sorry --non-trivial
lemma new_lemma_101832 (h0 : topological_space (add_cancel_monoid (has_Inf pos))) : t0_space (add_cancel_monoid (has_Inf pos)) := sorry --non-trivial
lemma new_lemma_101833 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @rank_condition.{0} (@id.{2} Type empty) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (@id.{2} Type empty))  := sorry --non-trivial
lemma new_lemma_101834 (h0 : functor.add_const Prop (has_neg (has_add (has_to_string (semigroup name))))) : functor.add_const.run h0 := sorry --non-trivial
lemma new_lemma_101835 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : finset.nonempty (function.extfun_app (function.extfun_app h0 finset) (group_with_zero unsigned)) := sorry --non-trivial
lemma new_lemma_101836 (h0 : functor.add_const (topological_space (ordered_comm_group unsigned)) empty) : @loc_path_connected_space.{0} (ordered_comm_group.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (ordered_comm_group.{0} unsigned)) empty h0)  := sorry --non-trivial
lemma new_lemma_101837 (h0 : list (random_gen (with_bot (with_bot to_additive.value_type)))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_101838 (h0 : topological_space (semiring (random_gen (has_top linarith.comp_source)))) : locally_compact_space (semiring (random_gen (has_top linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_101839 (h0 : has_mem.mem (normed_group empty) has_emptyc.emptyc) : @is_domain.{0} (normed_group.{0} empty) (@finset.pi.empty.{1 0} Type ring.{0} (normed_group.{0} empty) h0)  := sorry --non-trivial
lemma new_lemma_101840 (h0 : list (has_neg (has_Inf pos))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_101841 (h0 : functor.add_const (topological_space (boolean_algebra.core unsigned)) pos) : @totally_separated_space.{0} (boolean_algebra.core.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (boolean_algebra.core.{0} unsigned)) pos h0)  := sorry --non-trivial
lemma new_lemma_101842 (h0 : functor.add_const (functor.add_const (topological_space Type) linarith.comp) (normed_comm_ring linarith.comp)) : @totally_separated_space.{1} Type (@functor.add_const.run.{1 0} (topological_space.{1} Type) linarith.comp (@functor.add_const.run.{1 0} (functor.add_const.{1 0} (topological_space.{1} Type) linarith.comp) (normed_comm_ring.{0} linarith.comp) h0))  := sorry --non-trivial
lemma new_lemma_101843 (h0 : ring (ring congr_arg_kind)) : is_domain (ring congr_arg_kind) := sorry --non-trivial
lemma new_lemma_101844 (h0 : function.extfun Type (functor.comp topological_space has_neg)) : @locally_compact_space.{0} (has_neg.{0} environment.implicit_infer_kind) (@functor.comp.run.{0 0 0} topological_space.{0} has_neg.{0} environment.implicit_infer_kind (@function.extfun_app.{2 1} Type (functor.comp.{0 0 0} topological_space.{0} has_neg.{0}) h0 environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_101845 (h0 : topological_space (comm_monoid congr_arg_kind)) : t0_space (comm_monoid congr_arg_kind) := sorry --non-trivial
lemma new_lemma_101846 (h0 : ring (has_sub unsigned)) : is_domain (has_sub unsigned) := sorry --non-trivial
lemma new_lemma_101847 (h0 : group (has_add (has_neg pos))) : normalizer_condition (has_add (has_neg pos)) := sorry --non-trivial
lemma new_lemma_101848 (h0 : function.extfun Type complete_lattice) : @is_compactly_generated.{0} (has_add.{0} ennreal) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (has_add.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_101849 (h0 : topological_space (monoid_with_zero (option unsigned))) : preconnected_space (monoid_with_zero (option unsigned)) := sorry --non-trivial
lemma new_lemma_101850 (h0 : topological_space (linear_ordered_add_comm_group (has_top (has_top (has_top fun_info))))) : irreducible_space (linear_ordered_add_comm_group (has_top (has_top (has_top fun_info)))) := sorry --non-trivial
lemma new_lemma_101851 (h0 : finset (boolean_algebra (has_Inf (ordered_comm_monoid (sub_neg_monoid pos))))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_101852 (h0 : complete_lattice (cancel_monoid (finset Type))) : is_atomistic (cancel_monoid (finset Type)) := sorry --non-trivial
lemma new_lemma_101853 (h0 : complete_lattice (has_Inf pos)) : is_compactly_generated (has_Inf pos) := sorry --non-trivial
lemma new_lemma_101854 (h0 : functor.add_const (topological_space (has_to_string linarith.comp)) pos) : @locally_compact_space.{0} (has_to_string.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (has_to_string.{0} linarith.comp)) pos h0)  := sorry --non-trivial
lemma new_lemma_101855 (h0 : monoid (metric_space (has_top (semiring num)))) : monoid.fg (metric_space (has_top (semiring num))) := sorry --non-trivial
lemma new_lemma_101856 (h0 : function.extfun Type ring) : @rank_condition.{0} unsigned (@function.extfun_app.{2 1} Type ring.{0} h0 unsigned)  := sorry --non-trivial
lemma new_lemma_101857 (h0 : complete_lattice (has_nndist (has_to_string pos))) : is_atomistic (has_nndist (has_to_string pos)) := sorry --non-trivial
lemma new_lemma_101858 (h1 : complete_lattice (dlist (random_gen (random_gen string_imp)))) : complete_lattice.is_Sup_finite_compact (dlist (random_gen (random_gen string_imp))) := sorry --non-trivial
lemma new_lemma_101859 (h0 : topological_space (has_pos_part (has_neg (sub_neg_monoid name)))) : t1_space (has_pos_part (has_neg (sub_neg_monoid name))) := sorry --non-trivial
lemma new_lemma_101860 (h0 : group (ordered_comm_monoid (has_Inf (finset (simple_graph (has_pos_part Type)))))) : normalizer_condition (ordered_comm_monoid (has_Inf (finset (simple_graph (has_pos_part Type))))) := sorry --non-trivial
lemma new_lemma_101861 (h0 : functor.add_const (list (normed_linear_ordered_group unsigned)) unsigned) : list.nodup (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_101862 (h0 : ring (has_zero (normed_comm_ring pos))) : strong_rank_condition (has_zero (normed_comm_ring pos)) := sorry --non-trivial
lemma new_lemma_101863 (h0 : functor.add_const (ordered_add_comm_monoid (generalized_boolean_algebra pos)) Type) : @archimedean.{0} (generalized_boolean_algebra.{0} pos) (@functor.add_const.run.{0 1} (ordered_add_comm_monoid.{0} (generalized_boolean_algebra.{0} pos)) Type h0)  := sorry --non-trivial
lemma new_lemma_101864 (h0 : unsigned -> linarith.comp -> Prop) : relator.right_unique h0 := sorry --non-trivial
lemma new_lemma_101865 (h0 : uniform_space (normed_lattice_add_comm_group (has_add (has_add pos)))) : separated_space (normed_lattice_add_comm_group (has_add (has_add pos))) := sorry --non-trivial
lemma new_lemma_101866 (h0 : add_monoid (add_cancel_monoid (finset Type))) : add_monoid.fg (add_cancel_monoid (finset Type)) := sorry --non-trivial
lemma new_lemma_101867 (h0 : group (has_zero (has_add (has_neg Type)))) : normalizer_condition (has_zero (has_add (has_neg Type))) := sorry --non-trivial
lemma new_lemma_101868 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @complete_lattice.is_Sup_finite_compact.{0} (add_group.{0} linarith.comp) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (add_group.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_101869 (h0 : ring (uniform_space (metric_space (random_gen (random_gen (metric_space char)))))) : is_domain (uniform_space (metric_space (random_gen (random_gen (metric_space char))))) := sorry --non-trivial
lemma new_lemma_101870 (h0 : complete_lattice (bin_tree empty)) : complete_lattice.is_Sup_finite_compact (bin_tree empty) := sorry --non-trivial
lemma new_lemma_101871 (h0 : topological_space (has_to_string (has_nndist Type))) : preconnected_space (has_to_string (has_nndist Type)) := sorry --non-trivial
lemma new_lemma_101872 (h1 : not (filter (measurable_space fun_info) -> false)) : filter.ne_bot (classical.by_contradiction' h1) := sorry --non-trivial
lemma new_lemma_101873 (h0 : function.extfun Type topological_space) : @irreducible_space.{0} (pseudo_metric_space.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (pseudo_metric_space.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_101874 (h0 : topological_space (has_neg_part (has_add name))) : loc_path_connected_space (has_neg_part (has_add name)) := sorry --non-trivial
lemma new_lemma_101875 (h0 : topological_space (ring environment.implicit_infer_kind)) : discrete_topology (ring environment.implicit_infer_kind) := sorry --non-trivial
lemma new_lemma_101876 (h1 : function.extfun Type topological_space) : @totally_separated_space.{0} string_imp (@function.extfun_app.{2 1} Type topological_space.{0} h1 string_imp)  := sorry --non-trivial
lemma new_lemma_101877 (h0 : functor.add_const (topological_space (add_comm_monoid unsigned)) linarith.comp) : @topological_space.separable_space.{0} (add_comm_monoid.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (add_comm_monoid.{0} unsigned)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_101878 (h0 : measurable_space std_gen) (h1 : not (measure_theory.measure std_gen -> false) -> measure_theory.measure std_gen) (h2 : nonempty (measure_theory.measure std_gen)) : measure_theory.is_finite_measure (classical.choice_of_by_contradiction' h1 h2) := sorry --non-trivial
lemma new_lemma_101879 (h0 : complete_lattice (distrib (mul_one_class fun_info))) : is_compactly_generated (distrib (mul_one_class fun_info)) := sorry --non-trivial
lemma new_lemma_101880 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @has_exists_mul_of_le.{0} (boolean_algebra.core.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type ordered_comm_monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ordered_comm_monoid.{0}) (boolean_algebra.core.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_101881 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @regular_space.{0} linarith.comp (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) linarith.comp)  := sorry --non-trivial
lemma new_lemma_101882 (h0 : complete_lattice (normed_comm_ring ennreal)) : complete_lattice.is_Sup_finite_compact (normed_comm_ring ennreal) := sorry --non-trivial
lemma new_lemma_101883 (h0 : complete_lattice (normed_comm_ring (comm_group Type))) : complete_lattice.is_Sup_finite_compact (normed_comm_ring (comm_group Type)) := sorry --non-trivial
lemma new_lemma_101884 (h0 : functor.add_const (group znum) unsigned) : @normalizer_condition.{0} znum (@functor.add_const.run.{0 0} (group.{0} znum) unsigned h0)  := sorry --non-trivial
lemma new_lemma_101885 (h0 : group (normed_group (has_inv fun_info))) : normalizer_condition (normed_group (has_inv fun_info)) := sorry --non-trivial
lemma new_lemma_101886 (h0 : functor.add_const (topological_space (finset linarith.comp)) linarith.comp) : @irreducible_space.{0} (finset.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (finset.{0} linarith.comp)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_101887 (h1 : function.extfun Type ring) : @rank_condition.{0} (random_gen.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type ring.{0} h1 (random_gen.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_101888 (h0 : ring (has_neg (has_neg linarith.comp))) : strong_rank_condition (has_neg (has_neg linarith.comp)) := sorry --non-trivial
lemma new_lemma_101889 (h0 : topological_space (linear_ordered_comm_group unsigned)) : normal_space (linear_ordered_comm_group unsigned) := sorry --non-trivial
lemma new_lemma_101890 (h0 : filter (has_neg (ring (has_add name)))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_101891 (h1 : ring (topological_space (metric_space to_additive.value_type))) : is_domain (topological_space (metric_space to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_101892 (h0 : ring (has_zero (finset environment.implicit_infer_kind))) : rank_condition (has_zero (finset environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_101893 (h0 : group (with_bot (semiring linarith.comp_source))) : normalizer_condition (with_bot (semiring linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_101894 (h0 : function.extfun Type topological_space) : @t0_space.{0} (has_nnnorm.{0} char) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_nnnorm.{0} char))  := sorry --non-trivial
lemma new_lemma_101895 (h0 : ring (distrib_lattice (random_gen (has_nnnorm to_additive.value_type)))) : strong_rank_condition (distrib_lattice (random_gen (has_nnnorm to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_101896 (h1 : ring (with_zero fun_info)) : is_domain (with_zero fun_info) := sorry --non-trivial
lemma new_lemma_101897 (h0 : functor.add_const (topological_space (add_comm_monoid pos)) environment.implicit_infer_kind) : @path_connected_space.{0} (add_comm_monoid.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (add_comm_monoid.{0} pos)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_101898 (h0 : topological_space (simple_graph (option (option unsigned)))) : irreducible_space (simple_graph (option (option unsigned))) := sorry --non-trivial
lemma new_lemma_101899 (h0 : add_group (normed_group empty)) : is_add_cyclic (normed_group empty) := sorry --non-trivial
lemma new_lemma_101900 (h0 : functor.add_const (topological_space (has_dist empty)) (option empty)) : @loc_path_connected_space.{0} (has_dist.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (has_dist.{0} empty)) (option.{0} empty) h0)  := sorry --non-trivial
lemma new_lemma_101901 (h0 : topological_space (semi_normed_ring string_imp)) : t0_space (semi_normed_ring string_imp) := sorry --non-trivial
lemma new_lemma_101902 (h0 : function.extfun Type add_group) : @is_add_cyclic.{0} (has_one.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type add_group.{0} h0 (has_one.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_101903 (h0 : function.extfun (finset Type -> Prop) (function.extfun (finset Type))) : @is_compactly_generated.{0} real.angle (@finset.pi.empty.{1 0} Type complete_lattice.{0} real.angle (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) real.angle) (@function.extfun_app.{2 0} (finset.{1} Type → Prop) (function.extfun.{2 0} (finset.{1} Type)) h0 (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) real.angle)) (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_101904 (h0 : functor.add_const (ring (finset ennreal)) ennreal) : @rank_condition.{0} (finset.{0} ennreal) (@functor.add_const.run.{0 0} (ring.{0} (finset.{0} ennreal)) ennreal h0)  := sorry --non-trivial
lemma new_lemma_101905 (h0 : topological_space (random_gen (linear_ordered_semiring (with_one empty)))) : locally_compact_space (random_gen (linear_ordered_semiring (with_one empty))) := sorry --non-trivial
lemma new_lemma_101906 (h0 : functor.add_const (complete_lattice (has_to_string Type)) pos) : @complete_lattice.is_Sup_finite_compact.{1} (has_to_string.{1} Type) (@functor.add_const.run.{1 0} (complete_lattice.{1} (has_to_string.{1} Type)) pos h0)  := sorry --non-trivial
lemma new_lemma_101907 (h0 : functor.add_const (function.extfun Type complete_lattice) (mul_zero_class Type)) : @complete_lattice.is_Sup_finite_compact.{0} (complete_distrib_lattice.{0} pos) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type complete_lattice.{0}) (mul_zero_class.{1} Type) h0) (complete_distrib_lattice.{0} pos))  := sorry --non-trivial
lemma new_lemma_101908 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @totally_separated_space.{0} (finset.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (finset.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_101909 (h0 : function.extfun Type ring) : @is_principal_ideal_ring.{0} (has_to_string.{0} num) (@function.extfun_app.{2 1} Type ring.{0} h0 (has_to_string.{0} num))  := sorry --non-trivial
lemma new_lemma_101910 (h0 : function.extfun Type (functor.comp complete_lattice has_nndist)) : @is_compactly_generated.{0} (has_nndist.{0} pos) (@functor.comp.run.{0 0 0} complete_lattice.{0} has_nndist.{0} pos (@function.extfun_app.{2 1} Type (functor.comp.{0 0 0} complete_lattice.{0} has_nndist.{0}) h0 pos))  := sorry --non-trivial
lemma new_lemma_101911 (h0 : filter (has_add pos)) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_101912 (h0 : ring (linear_ordered_comm_ring empty)) : is_domain (linear_ordered_comm_ring empty) := sorry --non-trivial
lemma new_lemma_101913 (h0 : function.extfun Type (functor.add_const (function.extfun Type group))) : @group.fg.{0} (add_comm_monoid.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type group.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type group.{0}) environment.implicit_infer_kind (@function.extfun_app.{2 2} Type (functor.add_const.{1 0} (function.extfun.{2 1} Type group.{0})) h0 environment.implicit_infer_kind)) (add_comm_monoid.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_101914 (h0 : ring (with_one (semiring (random_gen linarith.comp)))) : is_domain (with_one (semiring (random_gen linarith.comp))) := sorry --non-trivial
lemma new_lemma_101915 (h0 : group (linear_ordered_comm_monoid_with_zero (option (option unsigned)))) : normalizer_condition (linear_ordered_comm_monoid_with_zero (option (option unsigned))) := sorry --non-trivial
lemma new_lemma_101916 (h0 : topological_space (plift empty)) : locally_compact_space (plift empty) := sorry --non-trivial
lemma new_lemma_101917 (h0 : ordered_comm_monoid (generalized_boolean_algebra name)) : has_exists_mul_of_le (generalized_boolean_algebra name) := sorry --non-trivial
lemma new_lemma_101918 (h0 : functor.add_const (complete_lattice (linear_ordered_cancel_comm_monoid unsigned)) unsigned) : @is_compactly_generated.{0} (linear_ordered_cancel_comm_monoid.{0} unsigned) (@functor.add_const.run.{0 0} (complete_lattice.{0} (linear_ordered_cancel_comm_monoid.{0} unsigned)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_101919 (h0 : functor.comp cancel_comm_monoid_with_zero add_comm_monoid unsigned) : @unique_factorization_monoid.{0} (add_comm_monoid.{0} unsigned) (@functor.comp.run.{0 0 0} cancel_comm_monoid_with_zero.{0} add_comm_monoid.{0} unsigned h0)  := sorry --non-trivial
lemma new_lemma_101920 (h0 : topological_space (finset (has_add environment.implicit_infer_kind))) : totally_disconnected_space (finset (has_add environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_101921 (h0 : option unsigned -> option unsigned -> Prop) : is_symm (option unsigned) h0 := sorry --non-trivial
lemma new_lemma_101922 (h0 : complete_lattice (comm_semigroup (sub_neg_monoid (has_bot Type)))) : is_atomistic (comm_semigroup (sub_neg_monoid (has_bot Type))) := sorry --non-trivial
lemma new_lemma_101923 (h0 : functor.add_const (function.extfun Type monoid) name) : @monoid.fg.{0} (has_Inf.{0} pos) (@function.extfun_app.{2 1} Type monoid.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type monoid.{0}) name h0) (has_Inf.{0} pos))  := sorry --non-trivial
lemma new_lemma_101924 (h0 : functor.add_const (topological_space (has_zero ennreal)) unsigned) : @preconnected_space.{0} (has_zero.{0} ennreal) (@functor.add_const.run.{0 0} (topological_space.{0} (has_zero.{0} ennreal)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_101925 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_compactly_generated.{0} to_additive.value_type (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) to_additive.value_type)  := sorry --non-trivial
lemma new_lemma_101926 (h0 : function.extfun Type topological_space) : @discrete_topology.{0} (boolean_algebra.{0} real) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (boolean_algebra.{0} real))  := sorry --non-trivial
lemma new_lemma_101927 (h0 : functor.add_const (ring (boolean_algebra Type)) pos) : @rank_condition.{1} (boolean_algebra.{1} Type) (@functor.add_const.run.{1 0} (ring.{1} (boolean_algebra.{1} Type)) pos h0)  := sorry --non-trivial
lemma new_lemma_101928 (h0 : functor.add_const (function.extfun Type topological_space) Type) : @path_connected_space.{0} (has_zero.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type topological_space.{0}) Type h0) (has_zero.{0} pos))  := sorry --non-trivial
lemma new_lemma_101929 (h0 : pfun enat Prop) (h1 : coe_sort (pfun.dom h0)) : pfun.as_subtype h0 h1 := sorry --non-trivial
lemma new_lemma_101930 (h0 : complete_lattice (free_add_monoid empty)) : complete_lattice.is_Sup_finite_compact (free_add_monoid empty) := sorry --non-trivial
lemma new_lemma_101931 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_add_cyclic.{0} (with_one.{0} num) (@function.extfun_app.{2 1} Type add_group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 add_group.{0}) (with_one.{0} num))  := sorry --non-trivial
lemma new_lemma_101932 (h0 : topological_space (preorder (semiring unsigned))) : topological_space.separable_space (preorder (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_101933 (h0 : group (id (random_gen (random_gen (has_inv fun_info))))) : is_cyclic (id (random_gen (random_gen (has_inv fun_info)))) := sorry --non-trivial
lemma new_lemma_101934 (h0 : topological_space (filter char)) (h1 : topological_space.second_countable_topology (filter char)) : nonempty (topological_space.countable_basis (filter char) filter.ne_bot) := sorry --non-trivial
lemma new_lemma_101935 (h0 : topological_space (comm_semigroup real)) : loc_path_connected_space (comm_semigroup real) := sorry --non-trivial
lemma new_lemma_101936 (h0 : function.extfun Type uniform_space) : @complete_space.{0} (has_emptyc.{0} linarith.comp) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (has_emptyc.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_101937 (h1 : has_lt linarith.comp_source) : no_max_order linarith.comp_source := sorry --non-trivial
lemma new_lemma_101938 (h1 : topological_space (add_monoid (comm_ring linarith.comp_source))) : path_connected_space (add_monoid (comm_ring linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_101939 (h0 : not (function.extfun Type topological_space -> false)) : @totally_disconnected_space.{0} (div_inv_monoid.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (div_inv_monoid.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_101940 (h0 : topological_space (normed_group unsigned)) : normal_space (normed_group unsigned) := sorry --non-trivial
lemma new_lemma_101941 (h0 : function.extfun ((Type -> Type) -> Type 1) (function.extfun (Type -> Type))) : @locally_compact_space.{0} (measurable_space.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) (@function.extfun_app.{3 2} ((Type → Type) → Type 1) (function.extfun.{2 2} (Type → Type)) h0 (function.extfun.{2 1} Type)) topological_space.{0}) (measurable_space.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_101942 (h0 : ring (has_append (comm_ring fun_info))) : rank_condition (has_append (comm_ring fun_info)) := sorry --non-trivial
lemma new_lemma_101943 (h0 : not (topological_space (has_inv linarith.ineq) -> false)) : @t0_space.{0} (has_inv.{0} linarith.ineq) (@classical.by_contradiction'.{1} (topological_space.{0} (has_inv.{0} linarith.ineq)) h0)  := sorry --non-trivial
lemma new_lemma_101944 (h0 : topological_space (has_union (semiring unsigned))) : totally_disconnected_space (has_union (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_101945 (h0 : group (has_sub empty)) : group.fg (has_sub empty) := sorry --non-trivial
lemma new_lemma_101946 (h0 : not (function.extfun (Type -> Type) (function.extfun Type) -> false)) : @complete_space.{0} (semiring.{0} fun_info) (@function.extfun_app.{2 1} Type uniform_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) (@classical.by_contradiction'.{2} (function.extfun.{2 2} (Type → Type) (function.extfun.{2 1} Type)) h0) uniform_space.{0}) (semiring.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_101947 (h0 : topological_space (add_group (linear_ordered_semiring empty))) : locally_compact_space (add_group (linear_ordered_semiring empty)) := sorry --non-trivial
lemma new_lemma_101948 (h0 : topological_space (plift (semiring (semiring unsigned)))) : t0_space (plift (semiring (semiring unsigned))) := sorry --non-trivial
lemma new_lemma_101949 (h0 : complete_lattice (add_comm_semigroup char)) : is_compactly_generated (add_comm_semigroup char) := sorry --non-trivial
lemma new_lemma_101950 (h0 : ring (add_comm_semigroup (add_comm_semigroup fun_info))) : strong_rank_condition (add_comm_semigroup (add_comm_semigroup fun_info)) := sorry --non-trivial
lemma new_lemma_101951 (h0 : functor.add_const (ring (has_zero name)) Type) : @is_principal_ideal_ring.{0} (has_zero.{0} name) (@functor.add_const.run.{0 1} (ring.{0} (has_zero.{0} name)) Type h0)  := sorry --non-trivial
lemma new_lemma_101952 (h0 : topological_space (add_comm_monoid name)) : discrete_topology (add_comm_monoid name) := sorry --non-trivial
lemma new_lemma_101953 (h0 : not (topological_space (has_div linarith.ineq) -> false)) : @path_connected_space.{0} (has_div.{0} linarith.ineq) (@classical.by_contradiction'.{1} (topological_space.{0} (has_div.{0} linarith.ineq)) h0)  := sorry --non-trivial
lemma new_lemma_101954 (h0 : not (filter (add_right_cancel_monoid empty) -> false)) : filter.ne_bot (classical.by_contradiction' h0) := sorry --non-trivial
lemma new_lemma_101955 (h0 : topological_space enat) (h1 : set (set enat)) : topological_space.is_topological_basis h1 := sorry --non-trivial
lemma new_lemma_101956 (h0 : topological_space (canonically_ordered_monoid real)) : loc_path_connected_space (canonically_ordered_monoid real) := sorry --non-trivial
lemma new_lemma_101957 (h0 : functor.add_const (ring (has_zero unsigned)) pos) : @rank_condition.{0} (has_zero.{0} unsigned) (@functor.add_const.run.{0 0} (ring.{0} (has_zero.{0} unsigned)) pos h0)  := sorry --non-trivial
lemma new_lemma_101958 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @totally_separated_space.{0} (add_cancel_monoid.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (add_cancel_monoid.{0} pos))  := sorry --non-trivial
lemma new_lemma_101959 (h0 : functor.add_const (topological_space (ring name)) unsigned) : @totally_disconnected_space.{0} (ring.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (ring.{0} name)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_101960 (h0 : functor.comp topological_space has_to_string name) : @irreducible_space.{0} (has_to_string.{0} name) (@functor.comp.run.{0 0 0} topological_space.{0} has_to_string.{0} name h0)  := sorry --non-trivial
lemma new_lemma_101961 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @complete_lattice.is_Sup_finite_compact.{0} (linear_ordered_comm_group.{0} unsigned) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (linear_ordered_comm_group.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_101962 (h1 : function.extfun Type complete_lattice) : @is_compactly_generated.{0} (normed_group.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type complete_lattice.{0} h1 (normed_group.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_101963 (h0 : complete_lattice (has_nnnorm (has_top char))) : is_compactly_generated (has_nnnorm (has_top char)) := sorry --non-trivial
lemma new_lemma_101964 (h0 : fin has_zero.zero) : @is_add_cyclic.{0} (boolean_algebra.{0} real) (@matrix.vec_empty.{0} (add_group.{0} (boolean_algebra.{0} real)) h0)  := sorry --non-trivial
lemma new_lemma_101965 (h0 : ring (ordered_semiring (canonically_linear_ordered_add_monoid Type))) : strong_rank_condition (ordered_semiring (canonically_linear_ordered_add_monoid Type)) := sorry --non-trivial
lemma new_lemma_101966 (h0 : functor.add_const (group (has_neg name)) Type) : @is_cyclic.{0} (has_neg.{0} name) (@functor.add_const.run.{0 1} (group.{0} (has_neg.{0} name)) Type h0)  := sorry --non-trivial
lemma new_lemma_101967 (h0 : functor.add_const (function.extfun (Type 1) topological_space) Type) : @locally_compact_space.{1} (finset.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@functor.add_const.run.{2 1} (function.extfun.{3 2} (Type 1) topological_space.{1}) Type h0) (finset.{1} Type))  := sorry --non-trivial
lemma new_lemma_101968 (h0 : ordered_add_comm_monoid (add_cancel_monoid (finset pos))) : archimedean (add_cancel_monoid (finset pos)) := sorry --non-trivial
lemma new_lemma_101969 (h0 : complete_lattice (complete_linear_order (option (option num)))) : is_atomistic (complete_linear_order (option (option num))) := sorry --non-trivial
lemma new_lemma_101970 (h0 : ring (non_unital_non_assoc_semiring (has_nnnorm (has_nnnorm ereal)))) : is_domain (non_unital_non_assoc_semiring (has_nnnorm (has_nnnorm ereal))) := sorry --non-trivial
lemma new_lemma_101971 (h0 : function.extfun Type topological_space) : @sequential_space.{0} (simple_graph.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (simple_graph.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_101972 (h0 : functor.add_const (function.extfun (Type 1) semiring) linarith.comp) : @is_noetherian_ring.{1} (sub_neg_monoid.{1} Type) (@function.extfun_app.{3 2} (Type 1) semiring.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) semiring.{1}) linarith.comp h0) (sub_neg_monoid.{1} Type))  := sorry --non-trivial
lemma new_lemma_101973 (h1 : topological_space (with_one (has_nnnorm char))) : path_connected_space (with_one (has_nnnorm char)) := sorry --non-trivial
lemma new_lemma_101974 (h0 : function.extfun Type topological_space) : @t0_space.{0} (linear_ordered_comm_monoid_with_zero.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (linear_ordered_comm_monoid_with_zero.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_101975 (h0 : topological_space (cancel_monoid (comm_group (has_add (comm_group name))))) : totally_separated_space (cancel_monoid (comm_group (has_add (comm_group name)))) := sorry --non-trivial
lemma new_lemma_101976 (h0 : ring (metric_space linarith.comp_source)) : is_domain (metric_space linarith.comp_source) := sorry --non-trivial
lemma new_lemma_101977 (h0 : uniform_space (comm_group (has_neg linarith.comp))) : separated_space (comm_group (has_neg linarith.comp)) := sorry --non-trivial
lemma new_lemma_101978 (h0 : add_group (finset (has_Inf linarith.comp))) : is_add_cyclic (finset (has_Inf linarith.comp)) := sorry --non-trivial
lemma new_lemma_101979 (h0 : function.extfun nat fin) : @t1_space.{0} (normed_lattice_add_comm_group.{0} pos) (@matrix.vec_empty.{0} (topological_space.{0} (normed_lattice_add_comm_group.{0} pos)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_101980 (h0 : functor.add_const (function.extfun Type finset) Type) : finset.nonempty (function.extfun_app (functor.add_const.run h0) (simple_graph linarith.comp)) := sorry --non-trivial
lemma new_lemma_101981 (h2 : complete_lattice (has_div enat)) : is_compactly_generated (has_div enat) := sorry --non-trivial
lemma new_lemma_101982 (h0 : topological_space (has_inv (has_ssubset to_additive.value_type))) : t0_space (has_inv (has_ssubset to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_101983 (h0 : complete_lattice (has_neg_part (boolean_algebra (has_neg_part (has_add Type))))) : is_compactly_generated (has_neg_part (boolean_algebra (has_neg_part (has_add Type)))) := sorry --non-trivial
lemma new_lemma_101984 (h0 : ring (pseudo_metric_space empty)) : is_domain (pseudo_metric_space empty) := sorry --non-trivial
lemma new_lemma_101985 (h0 : functor.add_const (add_monoid (has_Inf pos)) pos) : @add_monoid.fg.{0} (has_Inf.{0} pos) (@functor.add_const.run.{0 0} (add_monoid.{0} (has_Inf.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_101986 (h4 : add_group (nondiscrete_normed_field (mul_one_class enat))) : is_add_cyclic (nondiscrete_normed_field (mul_one_class enat)) := sorry --non-trivial
lemma new_lemma_101987 (h0 : topological_space (normed_comm_ring (add_comm_monoid (has_add Type)))) : topological_space.separable_space (normed_comm_ring (add_comm_monoid (has_add Type))) := sorry --non-trivial
lemma new_lemma_101988 (h0 : functor.add_const (topological_space (generalized_boolean_algebra pos)) linarith.comp) : @loc_path_connected_space.{0} (generalized_boolean_algebra.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (generalized_boolean_algebra.{0} pos)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_101989 (h0 : functor.add_const (semiring (canonically_ordered_comm_semiring name)) unsigned) : @is_noetherian_ring.{0} (canonically_ordered_comm_semiring.{0} name) (@functor.add_const.run.{0 0} (semiring.{0} (canonically_ordered_comm_semiring.{0} name)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_101990 (h0 : list (comm_group (has_add (has_add (comm_group (has_neg_part (has_neg_part (has_neg_part Type)))))))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_101991 (h0 : not (ring (non_assoc_semiring unsigned) -> false)) : @strong_rank_condition.{0} (non_assoc_semiring.{0} unsigned) (@classical.by_contradiction'.{1} (ring.{0} (non_assoc_semiring.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_101992 (h0 : topological_space (add_comm_monoid (normed_comm_ring environment.implicit_infer_kind))) : preirreducible_space (add_comm_monoid (normed_comm_ring environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_101993 (h0 : not (function.extfun Type topological_space -> false)) : @discrete_topology.{0} (semiring.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (semiring.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_101994 (h0 : topological_space (has_pos_part (has_Inf real))) : regular_space (has_pos_part (has_Inf real)) := sorry --non-trivial
lemma new_lemma_101995 (h0 : function.extfun Type uniform_space) : @complete_space.{0} (add_left_cancel_semigroup.{0} unsigned) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (add_left_cancel_semigroup.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_101996 (h0 : ring (with_one (random_gen linarith.comp_source))) : rank_condition (with_one (random_gen linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_101997 (h0 : topological_space linarith.ineq) (h1 : punit) : path_connected_space linarith.ineq := sorry --non-trivial
lemma new_lemma_101998 (h0 : functor.add_const (complete_lattice (plift empty)) num) : @is_atomistic.{1} (plift.{1} empty) (@functor.add_const.run.{1 0} (complete_lattice.{1} (plift.{1} empty)) num h0)  := sorry --non-trivial
lemma new_lemma_101999 (h0 : topological_space (finset (add_comm_monoid environment.implicit_infer_kind))) : discrete_topology (finset (add_comm_monoid environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_102000 (h0 : function.extfun Type finset) : finset.nonempty (function.extfun_app h0 (left_cancel_monoid empty)) := sorry --non-trivial
lemma new_lemma_102001 (h0 : topological_space (dlist (has_nnnorm fun_info))) : path_connected_space (dlist (has_nnnorm fun_info)) := sorry --non-trivial
lemma new_lemma_102002 (h0 : set (enat -> add_comm_semigroup enat)) : set.separates_points h0 := sorry --non-trivial
lemma new_lemma_102003 (h1 : semiring (nondiscrete_normed_field std_gen)) (h2 : ideal (nondiscrete_normed_field std_gen)) : ideal.is_prime h2 := sorry --non-trivial
lemma new_lemma_102004 (h0 : ring (semiring congr_arg_kind)) : strong_rank_condition (semiring congr_arg_kind) := sorry --non-trivial
lemma new_lemma_102005 (h0 : topological_space (canonically_linear_ordered_monoid (has_Inf pos))) : preirreducible_space (canonically_linear_ordered_monoid (has_Inf pos)) := sorry --non-trivial
lemma new_lemma_102006 (h0 : functor.add_const (topological_space (comm_group linarith.comp)) Type) : @loc_path_connected_space.{0} (comm_group.{0} linarith.comp) (@functor.add_const.run.{0 1} (topological_space.{0} (comm_group.{0} linarith.comp)) Type h0)  := sorry --non-trivial
lemma new_lemma_102007 (h1 : complete_lattice (has_nnnorm (metric_space to_additive.value_type))) : is_compactly_generated (has_nnnorm (metric_space to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_102008 (h0 : functor.add_const (topological_space (add_comm_monoid environment.implicit_infer_kind)) pos) : @t1_space.{0} (add_comm_monoid.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (add_comm_monoid.{0} environment.implicit_infer_kind)) pos h0)  := sorry --non-trivial
lemma new_lemma_102009 (h0 : functor.add_const (function.extfun (Type 1) topological_space) (has_neg pos)) : @sequential_space.{1} (semigroup.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) topological_space.{1}) (has_neg.{0} pos) h0) (semigroup.{1} Type))  := sorry --non-trivial
lemma new_lemma_102010 (h0 : group (complete_distrib_lattice Type)) : is_cyclic (complete_distrib_lattice Type) := sorry --non-trivial
lemma new_lemma_102011 (h0 : add_group (sub_neg_monoid (has_neg real))) : is_add_cyclic (sub_neg_monoid (has_neg real)) := sorry --non-trivial
lemma new_lemma_102012 (h0 : topological_space (add_left_cancel_monoid (has_nnnorm fun_info))) : t0_space (add_left_cancel_monoid (has_nnnorm fun_info)) := sorry --non-trivial
lemma new_lemma_102013 (h2 : ring (with_zero linarith.ineq)) : is_domain (with_zero linarith.ineq) := sorry --non-trivial
lemma new_lemma_102014 (h0 : add_group (semi_normed_ring char)) : is_add_cyclic (semi_normed_ring char) := sorry --non-trivial
lemma new_lemma_102015 (h0 : not (group (measurable_space to_additive.value_type) -> false)) : @normalizer_condition.{0} (measurable_space.{0} to_additive.value_type) (@classical.by_contradiction'.{1} (group.{0} (measurable_space.{0} to_additive.value_type)) h0)  := sorry --non-trivial
lemma new_lemma_102016 (h0 : ring (linear_ordered_semiring (has_norm linarith.comp_source))) : strong_rank_condition (linear_ordered_semiring (has_norm linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_102017 (h0 : topological_space (ordered_comm_ring (sub_neg_monoid pos))) : totally_disconnected_space (ordered_comm_ring (sub_neg_monoid pos)) := sorry --non-trivial
lemma new_lemma_102018 (h0 : complete_lattice (has_append char) -> Prop) (h1 : Exists (fun (x : complete_lattice (has_append char)), h0 x)) : @complete_lattice.is_Sup_finite_compact.{0} (has_append.{0} char) (@classical.some.{1} (complete_lattice.{0} (has_append.{0} char)) h0 h1)  := sorry --non-trivial
lemma new_lemma_102019 (h0 : group (boolean_algebra environment.implicit_infer_kind)) : is_cyclic (boolean_algebra environment.implicit_infer_kind) := sorry --non-trivial
lemma new_lemma_102020 (h0 : ring (canonically_linear_ordered_monoid (has_to_string num))) : is_domain (canonically_linear_ordered_monoid (has_to_string num)) := sorry --non-trivial
lemma new_lemma_102021 (h0 : topological_space (has_nndist (has_zero linarith.comp))) : preirreducible_space (has_nndist (has_zero linarith.comp)) := sorry --non-trivial
lemma new_lemma_102022 (h0 : uniform_space (ordered_ring congr_arg_kind)) : complete_space (ordered_ring congr_arg_kind) := sorry --non-trivial
lemma new_lemma_102023 (h0 : functor.add_const (topological_space (normed_linear_ordered_group unsigned)) (option empty)) : @discrete_topology.{0} (normed_linear_ordered_group.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (normed_linear_ordered_group.{0} unsigned)) (option.{0} empty) h0)  := sorry --non-trivial
lemma new_lemma_102024 (h0 : ordered_comm_monoid (normed_comm_ring (option (option unsigned)))) : has_exists_mul_of_le (normed_comm_ring (option (option unsigned))) := sorry --non-trivial
lemma new_lemma_102025 (h0 : list (has_inv (has_ssubset (random_gen (has_nnnorm fun_info))))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_102026 (h0 : complete_lattice (has_emptyc to_additive.value_type)) : is_compactly_generated (has_emptyc to_additive.value_type) := sorry --non-trivial
lemma new_lemma_102027 (h1 : uniform_space (comm_ring linarith.comp_source)) : complete_space (comm_ring linarith.comp_source) := sorry --non-trivial
lemma new_lemma_102028 (h0 : functor.add_const (finset (normed_comm_ring empty)) empty) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_102029 (h1 : complete_lattice (denumerable linarith.comp_source)) : is_compactly_generated (denumerable linarith.comp_source) := sorry --non-trivial
lemma new_lemma_102030 (h0 : function.extfun Type topological_space) : @t0_space.{0} (has_union.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_union.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_102031 (h0 : ring (topological_space (has_ssubset char))) : is_domain (topological_space (has_ssubset char)) := sorry --non-trivial
lemma new_lemma_102032 (h0 : functor.add_const (topological_space (has_to_string pos)) environment.implicit_infer_kind) : @t1_space.{0} (has_to_string.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (has_to_string.{0} pos)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_102033 (h0 : fin has_zero.zero) : @id.{1} Prop (@id.{1} Prop (@ulower.up.{0} Prop encodable.Prop (@matrix.vec_empty.{0} (@ulower.{0} Prop encodable.Prop) h0)))  := sorry --non-trivial
lemma new_lemma_102034 (h0 : functor.add_const (topological_space (semigroup linarith.comp)) linarith.comp) : @normal_space.{0} (semigroup.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (semigroup.{0} linarith.comp)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_102035 (h0 : not (complete_lattice (distrib (mul_one_class reducibility_hints)) -> false)) : @complete_lattice.is_Sup_finite_compact.{0} (distrib.{0} (mul_one_class.{0} reducibility_hints)) (@classical.by_contradiction'.{1} (complete_lattice.{0} (distrib.{0} (mul_one_class.{0} reducibility_hints))) h0)  := sorry --non-trivial
lemma new_lemma_102036 (h0 : functor.add_const (topological_space (has_add Type)) Type) : @path_connected_space.{1} (has_add.{1} Type) (@functor.add_const.run.{1 1} (topological_space.{1} (has_add.{1} Type)) Type h0)  := sorry --non-trivial
lemma new_lemma_102037 (h0 : topological_space (with_one (id congr_arg_kind))) : preirreducible_space (with_one (id congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_102038 (h0 : topological_space (finset (option (option pos)))) : irreducible_space (finset (option (option pos))) := sorry --non-trivial
lemma new_lemma_102039 (h1 : topological_space (fintype (comm_ring (has_ssubset linarith.ineq)))) : t0_space (fintype (comm_ring (has_ssubset linarith.ineq))) := sorry --non-trivial
lemma new_lemma_102040 (h0 : topological_space (left_cancel_monoid (semiring (semiring empty)))) : totally_separated_space (left_cancel_monoid (semiring (semiring empty))) := sorry --non-trivial
lemma new_lemma_102041 (h0 : functor.add_const (ordered_add_comm_monoid (add_comm_monoid Type)) linarith.comp) : @archimedean.{1} (add_comm_monoid.{1} Type) (@functor.add_const.run.{1 0} (ordered_add_comm_monoid.{1} (add_comm_monoid.{1} Type)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_102042 (h0 : functor.add_const (topological_space (has_bot Type)) Type) : @totally_separated_space.{1} (has_bot.{1} Type) (@functor.add_const.run.{1 1} (topological_space.{1} (has_bot.{1} Type)) Type h0)  := sorry --non-trivial
lemma new_lemma_102043 (h0 : ring (mul_zero_class (semiring unsigned))) : rank_condition (mul_zero_class (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_102044 (h0 : functor.add_const (function.extfun Type uniform_space) Type) : @complete_space.{0} (has_zero.{0} linarith.comp) (@function.extfun_app.{2 1} Type uniform_space.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type uniform_space.{0}) Type h0) (has_zero.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_102045 (h0 : function.extfun Type topological_space) : @path_connected_space.{0} (comm_ring.{0} linarith.ineq) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (comm_ring.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_102046 (h0 : topological_space (boolean_algebra.core unsigned)) : normal_space (boolean_algebra.core unsigned) := sorry --non-trivial
lemma new_lemma_102047 (h0 : topological_space (id (random_gen to_additive.value_type))) : totally_separated_space (id (random_gen to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_102048 (h0 : functor.add_const (group (has_Inf Type)) name) : @group.fg.{1} (has_Inf.{1} Type) (@functor.add_const.run.{1 0} (group.{1} (has_Inf.{1} Type)) name h0)  := sorry --non-trivial
lemma new_lemma_102049 (h0 : functor.add_const (topological_space (has_neg_part unsigned)) environment.implicit_infer_kind) : @topological_space.separable_space.{0} (has_neg_part.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (has_neg_part.{0} unsigned)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_102050 (h2 : function.extfun (Type -> Type) (function.extfun Type)) : @t0_space.{0} (with_one.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h2 topological_space.{0}) (with_one.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_102051 (h0 : ring (dlist (random_gen (has_nnnorm fun_info)))) : rank_condition (dlist (random_gen (has_nnnorm fun_info))) := sorry --non-trivial
lemma new_lemma_102052 (h0 : uniform_space (measurable_space unsigned)) : separated_space (measurable_space unsigned) := sorry --non-trivial
lemma new_lemma_102053 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @archimedean.{0} (has_Inf.{0} name) (@function.extfun_app.{2 1} Type ordered_add_comm_monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ordered_add_comm_monoid.{0}) (has_Inf.{0} name))  := sorry --non-trivial
lemma new_lemma_102054 (h0 : topological_space (normed_group (semiring (semiring unsigned)))) : preirreducible_space (normed_group (semiring (semiring unsigned))) := sorry --non-trivial
lemma new_lemma_102055 (h0 : semiring (complete_semilattice_Sup num)) : is_noetherian_ring (complete_semilattice_Sup num) := sorry --non-trivial
lemma new_lemma_102056 (h0 : topological_space (normed_lattice_add_comm_group (has_add (has_add linarith.comp)))) : preconnected_space (normed_lattice_add_comm_group (has_add (has_add linarith.comp))) := sorry --non-trivial
lemma new_lemma_102057 (h0 : function.extfun Type (functor.add_const (ordered_add_comm_monoid (has_Sup unsigned)))) : @archimedean.{0} (has_Sup.{0} unsigned) (@functor.add_const.run.{0 0} (ordered_add_comm_monoid.{0} (has_Sup.{0} unsigned)) unsigned (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (ordered_add_comm_monoid.{0} (has_Sup.{0} unsigned))) h0 unsigned))  := sorry --non-trivial
lemma new_lemma_102058 (h0 : topological_space (has_Inf (has_add (has_Inf pos)))) : t0_space (has_Inf (has_add (has_Inf pos))) := sorry --non-trivial
lemma new_lemma_102059 (h0 : semiring (semigroup (has_neg (finset Type)))) : is_noetherian_ring (semigroup (has_neg (finset Type))) := sorry --non-trivial
lemma new_lemma_102060 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @loc_path_connected_space.{0} (non_assoc_semiring.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (non_assoc_semiring.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_102061 (h0 : functor.add_const (ring (has_add linarith.comp)) environment.implicit_infer_kind) : @is_principal_ideal_ring.{0} (has_add.{0} linarith.comp) (@functor.add_const.run.{0 0} (ring.{0} (has_add.{0} linarith.comp)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_102062 (h0 : topological_space (simple_graph (has_Inf linarith.comp))) : discrete_topology (simple_graph (has_Inf linarith.comp)) := sorry --non-trivial
lemma new_lemma_102063 (h0 : functor.add_const (function.extfun Type topological_space) pos) : @discrete_topology.{0} (boolean_algebra.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) pos h0) (boolean_algebra.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_102064 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_atomistic.{0} real.angle (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) real.angle)  := sorry --non-trivial
lemma new_lemma_102065 (h0 : topological_space (restrict_scalars (linear_ordered_semiring num) linarith.comp_source linarith.comp_source)) : t0_space (restrict_scalars (linear_ordered_semiring num) linarith.comp_source linarith.comp_source) := sorry --non-trivial
lemma new_lemma_102066 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @t0_space.{0} (add_cancel_monoid.{0} ennreal) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (add_cancel_monoid.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_102067 (h0 : ring (boolean_algebra.core (option ennreal))) : strong_rank_condition (boolean_algebra.core (option ennreal)) := sorry --non-trivial
lemma new_lemma_102068 (h0 : filter (random_gen (random_gen (has_emptyc linarith.comp_source)))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_102069 (h0 : topological_space (has_nndist (has_Inf (ring (has_add linarith.comp))))) : t0_space (has_nndist (has_Inf (ring (has_add linarith.comp)))) := sorry --non-trivial
lemma new_lemma_102070 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @complete_space.{0} (add_cancel_monoid.{0} pos) (@function.extfun_app.{2 1} Type uniform_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 uniform_space.{0}) (add_cancel_monoid.{0} pos))  := sorry --non-trivial
lemma new_lemma_102071 (h0 : function.extfun Type uniform_space) : @complete_space.{0} (has_top.{0} unsigned) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (has_top.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_102072 (h0 : topological_space (add_group (semiring (semiring (semiring (semiring congr_arg_kind)))))) : normal_space (add_group (semiring (semiring (semiring (semiring congr_arg_kind))))) := sorry --non-trivial
lemma new_lemma_102073 (h1 : topological_space (has_compl (has_nnnorm reducibility_hints))) : t0_space (has_compl (has_nnnorm reducibility_hints)) := sorry --non-trivial
lemma new_lemma_102074 (h0 : functor.add_const (complete_lattice (cancel_monoid linarith.comp)) pos) : @is_atomistic.{0} (cancel_monoid.{0} linarith.comp) (@functor.add_const.run.{0 0} (complete_lattice.{0} (cancel_monoid.{0} linarith.comp)) pos h0)  := sorry --non-trivial
lemma new_lemma_102075 (h0 : topological_space (omega_complete_partial_order (semiring empty))) : path_connected_space (omega_complete_partial_order (semiring empty)) := sorry --non-trivial
lemma new_lemma_102076 (h0 : not (function.extfun Type complete_lattice -> false)) : @is_compactly_generated.{0} (normed_group.{0} fun_info) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type complete_lattice.{0}) h0) (normed_group.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_102077 (h0 : prod (metric_space empty) (metric_space empty)) : id_rel h0 := sorry --non-trivial
lemma new_lemma_102078 (h0 : semiring (complete_distrib_lattice (has_add name))) : is_noetherian_ring (complete_distrib_lattice (has_add name)) := sorry --non-trivial
lemma new_lemma_102079 (h0 : finset (sub_neg_monoid (boolean_algebra.core (has_add linarith.comp)))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_102080 (h1 : topological_space (normed_field environment.projection_info)) (h2 : preorder (normed_field environment.projection_info)) : order_closed_topology (normed_field environment.projection_info) := sorry --non-trivial
lemma new_lemma_102081 (h3 : topological_space (distrib_lattice to_additive.value_type)) : totally_disconnected_space (distrib_lattice to_additive.value_type) := sorry --non-trivial
lemma new_lemma_102082 (h0 : add_group (has_to_string (ring linarith.comp))) : is_add_cyclic (has_to_string (ring linarith.comp)) := sorry --non-trivial
lemma new_lemma_102083 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @loc_path_connected_space.{1} (ordered_comm_ring.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 topological_space.{1}) (ordered_comm_ring.{1} Type))  := sorry --non-trivial
lemma new_lemma_102084 (h0 : function.extfun (Type 1) topological_space) : @preirreducible_space.{1} (finset.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} h0 (finset.{1} Type))  := sorry --non-trivial
lemma new_lemma_102085 (h0 : not (function.extfun Type topological_space -> false)) : @normal_space.{0} (functor.const.{0 0} empty empty) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (functor.const.{0 0} empty empty))  := sorry --non-trivial
lemma new_lemma_102086 (h0 : functor.add_const (uniform_space Type) (has_neg linarith.comp)) : @separated_space.{1} Type (@functor.add_const.run.{1 0} (uniform_space.{1} Type) (has_neg.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_102087 (h0 : not (topological_space (linear_ordered_comm_ring empty) -> false)) : @path_connected_space.{0} (linear_ordered_comm_ring.{0} empty) (@classical.by_contradiction'.{1} (topological_space.{0} (linear_ordered_comm_ring.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_102088 (h0 : complete_lattice (has_dist (option empty))) : complete_lattice.is_Sup_finite_compact (has_dist (option empty)) := sorry --non-trivial
lemma new_lemma_102089 (h0 : ring (denumerable (has_nnnorm (has_nnnorm string.iterator_imp)))) : rank_condition (denumerable (has_nnnorm (has_nnnorm string.iterator_imp))) := sorry --non-trivial
lemma new_lemma_102090 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @discrete_topology.{0} (filter.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (filter.{0} num))  := sorry --non-trivial
lemma new_lemma_102091 (h0 : functor.add_const (topological_space (semigroup Type)) (has_zero Type)) : @discrete_topology.{1} (semigroup.{1} Type) (@functor.add_const.run.{1 1} (topological_space.{1} (semigroup.{1} Type)) (has_zero.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_102092 (h0 : not (topological_space (linear_ordered_semiring linarith.ineq) -> false)) : @irreducible_space.{0} (linear_ordered_semiring.{0} linarith.ineq) (@classical.by_contradiction'.{1} (topological_space.{0} (linear_ordered_semiring.{0} linarith.ineq)) h0)  := sorry --non-trivial
lemma new_lemma_102093 (h0 : topological_space (add_comm_monoid linarith.comp)) : totally_separated_space (add_comm_monoid linarith.comp) := sorry --non-trivial
lemma new_lemma_102094 (h0 : topological_space (has_to_string (ring Type))) : preirreducible_space (has_to_string (ring Type)) := sorry --non-trivial
lemma new_lemma_102095 (h0 : function.extfun Type filter) : filter.ne_bot (function.extfun_app h0 linarith.comp_source) := sorry --non-trivial
lemma new_lemma_102096 (h1 : complete_lattice (with_one num)) : complete_lattice.is_Sup_finite_compact (with_one num) := sorry --non-trivial
lemma new_lemma_102097 (h0 : ordered_comm_monoid (has_zero (finset pos))) : has_exists_mul_of_le (has_zero (finset pos)) := sorry --non-trivial
lemma new_lemma_102098 (h0 : complete_lattice (has_inv (has_inv fun_info))) : complete_lattice.is_Sup_finite_compact (has_inv (has_inv fun_info)) := sorry --non-trivial
lemma new_lemma_102099 (h9 : prod ereal ereal) : set.diagonal ereal h9 := sorry --non-trivial
lemma new_lemma_102100 (h0 : list (has_star empty)) : palindrome h0 := sorry --non-trivial
lemma new_lemma_102101 (h0 : functor.add_const (topological_space (finset ennreal)) unsigned) : @t1_space.{0} (finset.{0} ennreal) (@functor.add_const.run.{0 0} (topological_space.{0} (finset.{0} ennreal)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_102102 (h0 : functor.add_const (topological_space (has_neg_part unsigned)) pos) : @loc_path_connected_space.{0} (has_neg_part.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (has_neg_part.{0} unsigned)) pos h0)  := sorry --non-trivial
lemma new_lemma_102103 (h0 : list (topological_space (semi_normed_comm_ring linarith.comp_source))) (h1 : nat) (h2 : has_lt.lt h1 (list.length h0)) (h3 : add_group (semi_normed_comm_ring linarith.comp_source)) : @topological_add_group.{0} (semi_normed_comm_ring.{0} linarith.comp_source) (@list.nth_le.{0} (topological_space.{0} (semi_normed_comm_ring.{0} linarith.comp_source)) h0 h1 h2) h3  := sorry --non-trivial
lemma new_lemma_102104 (h0 : topological_space (boolean_algebra (finset (has_Inf pos)))) : t1_space (boolean_algebra (finset (has_Inf pos))) := sorry --non-trivial
lemma new_lemma_102105 (h0 : group (has_one empty)) : is_cyclic (has_one empty) := sorry --non-trivial
lemma new_lemma_102106 (h0 : functor.add_const (add_monoid (has_nndist unsigned)) unsigned) : @add_monoid.fg.{0} (has_nndist.{0} unsigned) (@functor.add_const.run.{0 0} (add_monoid.{0} (has_nndist.{0} unsigned)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_102107 (h0 : topological_space (semilattice_inf (has_add (has_add (has_Inf pos))))) : sequential_space (semilattice_inf (has_add (has_add (has_Inf pos)))) := sorry --non-trivial
lemma new_lemma_102108 (h0 : list (id (has_inv linarith.comp_source))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_102109 (h0 : functor.add_const (complete_lattice (semigroup linarith.comp)) environment.implicit_infer_kind) : @is_compactly_generated.{0} (semigroup.{0} linarith.comp) (@functor.add_const.run.{0 0} (complete_lattice.{0} (semigroup.{0} linarith.comp)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_102110 (h0 : group (has_bot (has_add (has_add (finset (has_Inf (has_Inf pos))))))) : group.fg (has_bot (has_add (has_add (finset (has_Inf (has_Inf pos)))))) := sorry --non-trivial
lemma new_lemma_102111 (h0 : group (semigroup (has_add (semigroup name)))) : group.fg (semigroup (has_add (semigroup name))) := sorry --non-trivial
lemma new_lemma_102112 (h0 : function.extfun Type (prod (has_Sup unsigned))) : id_rel (function.extfun_app h0 (has_Sup unsigned)) := sorry --non-trivial
lemma new_lemma_102113 (h0 : uniform_space (finset ennreal)) : complete_space (finset ennreal) := sorry --non-trivial
lemma new_lemma_102114 (h0 : functor.add_const (topological_space (complete_linear_order congr_arg_kind)) empty) : @locally_compact_space.{0} (complete_linear_order.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (complete_linear_order.{0} congr_arg_kind)) empty h0)  := sorry --non-trivial
lemma new_lemma_102115 (h0 : finset (has_pos_part (comm_semigroup real))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_102116 (h0 : topological_space (add_cancel_comm_monoid (random_gen (random_gen (random_gen reducibility_hints))))) : t0_space (add_cancel_comm_monoid (random_gen (random_gen (random_gen reducibility_hints)))) := sorry --non-trivial
lemma new_lemma_102117 (h0 : topological_space (has_top linarith.comp)) : path_connected_space (has_top linarith.comp) := sorry --non-trivial
lemma new_lemma_102118 (h0 : list (non_assoc_semiring (semiring empty))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_102119 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @discrete_topology.{0} (has_one.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_one.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_102120 (h0 : ring (add_cancel_comm_monoid (add_cancel_monoid (option unsigned)))) : is_domain (add_cancel_comm_monoid (add_cancel_monoid (option unsigned))) := sorry --non-trivial
lemma new_lemma_102121 (h0 : function.extfun Type ring) : @is_domain.{0} (finset.{0} linarith.comp) (@function.extfun_app.{2 1} Type ring.{0} h0 (finset.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_102122 (h0 : ring (has_to_string (has_to_string linarith.comp))) : is_principal_ideal_ring (has_to_string (has_to_string linarith.comp)) := sorry --non-trivial
lemma new_lemma_102123 (h0 : functor.add_const (function.extfun Type topological_space) name) : @t0_space.{0} (has_pos_part.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) name h0) (has_pos_part.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_102124 (h0 : topological_space (has_add (has_add (boolean_algebra.core name)))) : totally_disconnected_space (has_add (has_add (boolean_algebra.core name))) := sorry --non-trivial
lemma new_lemma_102125 (h0 : monoid (has_emptyc linarith.ineq)) : monoid.fg (has_emptyc linarith.ineq) := sorry --non-trivial
lemma new_lemma_102126 (h0 : topological_space (has_inter (option (option unsigned)))) : loc_path_connected_space (has_inter (option (option unsigned))) := sorry --non-trivial
lemma new_lemma_102127 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : is_compactly_generated (measurable_space unsigned) := sorry --non-trivial
lemma new_lemma_102128 (h0 : has_neg (nondiscrete_normed_field (mul_one_class char))) (h1 : measurable_space (nondiscrete_normed_field (mul_one_class char))) : has_measurable_neg (nondiscrete_normed_field (mul_one_class char)) := sorry --non-trivial
lemma new_lemma_102129 (h0 : complete_lattice (has_lt (semi_normed_comm_ring std_gen))) : complete_lattice.is_Sup_finite_compact (has_lt (semi_normed_comm_ring std_gen)) := sorry --non-trivial
lemma new_lemma_102130 (h0 : topological_space (has_add (has_add real))) : preconnected_space (has_add (has_add real)) := sorry --non-trivial
lemma new_lemma_102131 (h0 : fin has_zero.zero) : @path_connected_space.{0} (canonically_linear_ordered_monoid.{0} linarith.comp) (@matrix.vec_empty.{0} (topological_space.{0} (canonically_linear_ordered_monoid.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_102132 (h0 : topological_space (has_to_string num)) : preirreducible_space (has_to_string num) := sorry --non-trivial
lemma new_lemma_102133 (h0 : not (ring (measurable_space fun_info) -> false)) : @strong_rank_condition.{0} (measurable_space.{0} fun_info) (@classical.by_contradiction'.{1} (ring.{0} (measurable_space.{0} fun_info)) h0)  := sorry --non-trivial
lemma new_lemma_102134 (h0 : topological_space (has_emptyc (measurable_space (has_top (has_top empty))))) : path_connected_space (has_emptyc (measurable_space (has_top (has_top empty)))) := sorry --non-trivial
lemma new_lemma_102135 (h0 : topological_space (has_neg (normed_comm_ring Type))) : discrete_topology (has_neg (normed_comm_ring Type)) := sorry --non-trivial
lemma new_lemma_102136 (h0 : filter Type) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_102137 (h0 : filter (measure_theory.measure_space empty)) (h1 : punit) : category_theory.hom_of_element (filter.ne_bot h0) h1 := sorry --non-trivial
lemma new_lemma_102138 (h0 : topological_space (comm_semigroup (sub_neg_monoid (has_bot linarith.comp)))) : topological_space.separable_space (comm_semigroup (sub_neg_monoid (has_bot linarith.comp))) := sorry --non-trivial
lemma new_lemma_102139 (h0 : add_group (with_bot empty)) : is_add_cyclic (with_bot empty) := sorry --non-trivial
lemma new_lemma_102140 (h0 : not (ring (normed_field to_additive.value_type) -> false)) : @strong_rank_condition.{0} (normed_field.{0} to_additive.value_type) (@classical.by_contradiction'.{1} (ring.{0} (normed_field.{0} to_additive.value_type)) h0)  := sorry --non-trivial
lemma new_lemma_102141 (h0 : group (add_left_cancel_monoid string_imp)) : group.fg (add_left_cancel_monoid string_imp) := sorry --non-trivial
lemma new_lemma_102142 (h0 : monoid (semigroup (option (option (has_Sup (option (option (option (option unsigned))))))))) : monoid.fg (semigroup (option (option (has_Sup (option (option (option (option unsigned)))))))) := sorry --non-trivial
lemma new_lemma_102143 (h0 : uniform_space (group_with_zero congr_arg_kind)) : separated_space (group_with_zero congr_arg_kind) := sorry --non-trivial
lemma new_lemma_102144 (h0 : add_monoid (ordered_comm_monoid (has_add (ring (has_pos_part pos))))) : add_monoid.fg (ordered_comm_monoid (has_add (ring (has_pos_part pos)))) := sorry --non-trivial
lemma new_lemma_102145 (h0 : functor.add_const Prop (semigroup (has_add environment.implicit_infer_kind))) : functor.add_const.run h0 := sorry --non-trivial
lemma new_lemma_102146 (h0 : functor.add_const (topological_space (ring name)) Type) : @totally_separated_space.{0} (ring.{0} name) (@functor.add_const.run.{0 1} (topological_space.{0} (ring.{0} name)) Type h0)  := sorry --non-trivial
lemma new_lemma_102147 (h1 : topological_space (normed_field (normed_field linarith.ineq))) (h2 : set (normed_field (normed_field linarith.ineq))) : is_path_connected h2 := sorry --non-trivial
lemma new_lemma_102148 (h0 : filter (boolean_algebra (comm_group Type))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_102149 (h0 : function.extfun ((Type -> Type) -> Type 1) (function.extfun (Type -> Type))) : @is_domain.{0} (random_gen.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) (@function.extfun_app.{3 2} ((Type → Type) → Type 1) (function.extfun.{2 2} (Type → Type)) h0 (function.extfun.{2 1} Type)) ring.{0}) (random_gen.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_102150 (h0 : not (complete_lattice (random_gen linarith.ineq) -> false)) : @is_compactly_generated.{0} (random_gen.{0} linarith.ineq) (@classical.by_contradiction'.{1} (complete_lattice.{0} (random_gen.{0} linarith.ineq)) h0)  := sorry --non-trivial
lemma new_lemma_102151 (h0 : ring (dlist (random_gen (has_top (has_top string_imp))))) : is_domain (dlist (random_gen (has_top (has_top string_imp)))) := sorry --non-trivial
lemma new_lemma_102152 (h0 : topological_space (has_union empty)) : irreducible_space (has_union empty) := sorry --non-trivial
lemma new_lemma_102153 (h0 : functor.add_const (topological_space (normed_comm_ring Type)) pos) : @preirreducible_space.{1} (normed_comm_ring.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (normed_comm_ring.{1} Type)) pos h0)  := sorry --non-trivial
lemma new_lemma_102154 (h0 : function.extfun Type topological_space) : @normal_space.{0} (mul_zero_one_class.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (mul_zero_one_class.{0} empty))  := sorry --non-trivial
lemma new_lemma_102155 (h0 : topological_space (semigroup unsigned)) : totally_disconnected_space (semigroup unsigned) := sorry --non-trivial
lemma new_lemma_102156 (h0 : functor.add_const (topological_space (has_to_string unsigned)) Type) : @regular_space.{0} (has_to_string.{0} unsigned) (@functor.add_const.run.{0 1} (topological_space.{0} (has_to_string.{0} unsigned)) Type h0)  := sorry --non-trivial
lemma new_lemma_102157 (h0 : functor.add_const (topological_space (canonically_ordered_comm_semiring Type)) name) : @t1_space.{1} (canonically_ordered_comm_semiring.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (canonically_ordered_comm_semiring.{1} Type)) name h0)  := sorry --non-trivial
lemma new_lemma_102158 (h0 : list (boolean_algebra.core unsigned)) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_102159 (h0 : list (pseudo_metric_space ennreal)) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_102160 (h0 : group (has_bot (has_add Type))) : group.fg (has_bot (has_add Type)) := sorry --non-trivial
lemma new_lemma_102161 (h0 : list (has_add (option ennreal))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_102162 (h0 : topological_space (nondiscrete_normed_field (add_comm_semigroup ereal))) (h1 : set (nondiscrete_normed_field (add_comm_semigroup ereal))) : is_path_connected h1 := sorry --non-trivial
lemma new_lemma_102163 (h0 : topological_space (add_right_cancel_monoid empty)) : preirreducible_space (add_right_cancel_monoid empty) := sorry --non-trivial
lemma new_lemma_102164 (h0 : function.extfun Type filter) : countable_Inter_filter (function.extfun_app h0 (comm_semigroup real)) := sorry --non-trivial
lemma new_lemma_102165 (h0 : function.extfun (finset Type) (has_mem.mem congr_arg_kind)) : @complete_space.{0} congr_arg_kind (@finset.pi.empty.{1 0} Type uniform_space.{0} congr_arg_kind (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) congr_arg_kind) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_102166 (h0 : complete_lattice (random_gen (metric_space char))) : is_compactly_generated (random_gen (metric_space char)) := sorry --non-trivial
lemma new_lemma_102167 (h0 : function.extfun Type (functor.add_const (topological_space (normed_comm_ring unsigned)))) : @sequential_space.{0} (normed_comm_ring.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (normed_comm_ring.{0} unsigned)) unsigned (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (topological_space.{0} (normed_comm_ring.{0} unsigned))) h0 unsigned))  := sorry --non-trivial
lemma new_lemma_102168 (h0 : topological_space (non_assoc_semiring num)) : topological_space.separable_space (non_assoc_semiring num) := sorry --non-trivial
lemma new_lemma_102169 (h0 : topological_space (has_add (has_nnnorm fun_info))) : t0_space (has_add (has_nnnorm fun_info)) := sorry --non-trivial
lemma new_lemma_102170 (h0 : semiring (has_sub (semiring (semiring (has_norm unsigned))))) : is_noetherian_ring (has_sub (semiring (semiring (has_norm unsigned)))) := sorry --non-trivial
lemma new_lemma_102171 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_add_cyclic.{0} (measurable_space.dynkin_system.{0} empty) (@function.extfun_app.{2 1} Type add_group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 add_group.{0}) (measurable_space.dynkin_system.{0} empty))  := sorry --non-trivial
lemma new_lemma_102172 (h0 : function.extfun Type ring) : @rank_condition.{0} (has_emptyc.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type ring.{0} h0 (has_emptyc.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_102173 (h0 : function.extfun Type topological_space) : @locally_compact_space.{0} (has_ssubset.{0} string_imp) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_ssubset.{0} string_imp))  := sorry --non-trivial
lemma new_lemma_102174 (h0 : topological_space (has_scalar Type (has_to_string linarith.comp))) : t0_space (has_scalar Type (has_to_string linarith.comp)) := sorry --non-trivial
lemma new_lemma_102175 (h0 : ring (add_comm_semigroup char)) : is_field (add_comm_semigroup char) := sorry --non-trivial
lemma new_lemma_102176 (h0 : not (has_mem.mem ring has_emptyc.emptyc -> false)) : @is_domain.{0} (random_gen.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type ring.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) ring.{0} (@classical.by_contradiction'.{0} (@has_mem.mem.{1 1} (Type → Type) (finset.{1} (Type → Type)) (@finset.has_mem.{1} (Type → Type)) ring.{0} (@has_emptyc.emptyc.{1} (finset.{1} (Type → Type)) (@finset.has_emptyc.{1} (Type → Type)))) h0)) (random_gen.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_102177 (h0 : functor.add_const (topological_space congr_arg_kind) empty) : @irreducible_space.{0} congr_arg_kind (@functor.add_const.run.{0 0} (topological_space.{0} congr_arg_kind) empty h0)  := sorry --non-trivial
lemma new_lemma_102178 (h0 : complete_lattice (add_right_cancel_monoid unsigned)) : complete_lattice.is_Sup_finite_compact (add_right_cancel_monoid unsigned) := sorry --non-trivial
lemma new_lemma_102179 (h0 : function.extfun Type group) : @group.fg.{0} (canonically_ordered_comm_semiring.{0} unsigned) (@function.extfun_app.{2 1} Type group.{0} h0 (canonically_ordered_comm_semiring.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_102180 (h0 : function.extfun (Type 1) (functor.comp topological_space add_cancel_monoid)) : @sequential_space.{1} (add_cancel_monoid.{1} Type) (@functor.comp.run.{1 1 1} topological_space.{1} add_cancel_monoid.{1} Type (@function.extfun_app.{3 2} (Type 1) (functor.comp.{1 1 1} topological_space.{1} add_cancel_monoid.{1}) h0 Type))  := sorry --non-trivial
lemma new_lemma_102181 (h0 : ring (ring (has_Inf pos))) : is_domain (ring (has_Inf pos)) := sorry --non-trivial
lemma new_lemma_102182 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @add_monoid.fg.{0} (option.{0} unsigned) (@function.extfun_app.{2 1} Type add_monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 add_monoid.{0}) (option.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_102183 (h0 : ring (add_group (has_top congr_arg_kind))) : strong_rank_condition (add_group (has_top congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_102184 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @strong_rank_condition.{0} (preorder.{0} empty) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (preorder.{0} empty))  := sorry --non-trivial
lemma new_lemma_102185 (h0 : function.extfun Type (functor.add_const (ring ennreal))) : @is_domain.{0} ennreal (@functor.add_const.run.{0 0} (ring.{0} ennreal) num (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (ring.{0} ennreal)) h0 num))  := sorry --non-trivial
lemma new_lemma_102186 (h0 : uniform_space (add_cancel_comm_monoid unsigned)) : separated_space (add_cancel_comm_monoid unsigned) := sorry --non-trivial
lemma new_lemma_102187 (h0 : topological_space (has_union (semiring (semiring empty)))) : discrete_topology (has_union (semiring (semiring empty))) := sorry --non-trivial
lemma new_lemma_102188 (h2 : pfun (add_comm_semigroup (mul_one_class (add_comm_semigroup (add_comm_semigroup ereal)))) Prop) (h3 : coe_sort (pfun.dom h2)) : pfun.as_subtype h2 h3 := sorry --non-trivial
lemma new_lemma_102189 (h0 : function.extfun Type topological_space) : @irreducible_space.{0} (semigroup.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (semigroup.{0} pos))  := sorry --non-trivial
lemma new_lemma_102190 (h0 : topological_space (id (has_top unsigned))) : normal_space (id (has_top unsigned)) := sorry --non-trivial
lemma new_lemma_102191 (h0 : not (topological_space (random_gen string_imp) -> false)) : @t0_space.{0} (random_gen.{0} string_imp) (@classical.by_contradiction'.{1} (topological_space.{0} (random_gen.{0} string_imp)) h0)  := sorry --non-trivial
lemma new_lemma_102192 (h0 : functor.add_const (functor.add_const (group Type) pos) pos) : @is_simple_group.{1} Type (@functor.add_const.run.{1 0} (group.{1} Type) pos (@functor.add_const.run.{1 0} (functor.add_const.{1 0} (group.{1} Type) pos) pos h0))  := sorry --non-trivial
lemma new_lemma_102193 (h0 : functor.add_const (functor.add_const (topological_space Type) linarith.comp) pos) : @regular_space.{1} Type (@functor.add_const.run.{1 0} (topological_space.{1} Type) linarith.comp (@functor.add_const.run.{1 0} (functor.add_const.{1 0} (topological_space.{1} Type) linarith.comp) pos h0))  := sorry --non-trivial
lemma new_lemma_102194 (h0 : finset (has_zero (finset name))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_102195 (h0 : function.extfun Type filter) : filter.ne_bot (function.extfun_app h0 (has_nndist empty)) := sorry --non-trivial
lemma new_lemma_102196 (h1 : group (has_ssubset to_additive.value_type)) : is_cyclic (has_ssubset to_additive.value_type) := sorry --non-trivial
lemma new_lemma_102197 (h0 : cancel_comm_monoid_with_zero (cancel_monoid Type)) : unique_factorization_monoid (cancel_monoid Type) := sorry --non-trivial
lemma new_lemma_102198 (h0 : topological_space (sub_neg_monoid (has_Inf (has_Inf linarith.comp)))) : preirreducible_space (sub_neg_monoid (has_Inf (has_Inf linarith.comp))) := sorry --non-trivial
lemma new_lemma_102199 (h0 : fin has_zero.zero) : @is_simple_group.{0} (has_Inf.{0} pos) (@matrix.vec_empty.{0} (group.{0} (has_Inf.{0} pos)) (@matrix.vec_empty.{0} (fin (@has_zero.zero.{0} nat nat.has_zero)) (@matrix.vec_empty.{0} (fin (@has_zero.zero.{0} nat nat.has_zero)) h0)))  := sorry --non-trivial
lemma new_lemma_102200 (h0 : ordered_comm_monoid (add_cancel_monoid (boolean_algebra name))) : has_exists_mul_of_le (add_cancel_monoid (boolean_algebra name)) := sorry --non-trivial
lemma new_lemma_102201 (h0 : ring (linear_ordered_semiring (random_gen num))) : strong_rank_condition (linear_ordered_semiring (random_gen num)) := sorry --non-trivial
lemma new_lemma_102202 (h0 : has_mem.mem ring has_emptyc.emptyc) : @strong_rank_condition.{0} (complete_semilattice_Sup.{0} num) (@function.extfun_app.{2 1} Type ring.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) ring.{0} h0) (complete_semilattice_Sup.{0} num))  := sorry --non-trivial
lemma new_lemma_102203 (h0 : ring (has_top (has_top fun_info))) : is_domain (has_top (has_top fun_info)) := sorry --non-trivial
lemma new_lemma_102204 (h0 : add_monoid (sub_neg_monoid (finset pos))) : add_monoid.fg (sub_neg_monoid (finset pos)) := sorry --non-trivial
lemma new_lemma_102205 (h0 : topological_space (has_neg (has_pos_part (has_pos_part pos)))) : discrete_topology (has_neg (has_pos_part (has_pos_part pos))) := sorry --non-trivial
lemma new_lemma_102206 (h0 : topological_space (has_to_string (has_to_string unsigned))) : t1_space (has_to_string (has_to_string unsigned)) := sorry --non-trivial
lemma new_lemma_102207 (h0 : add_monoid (option (option pos))) : add_monoid.fg (option (option pos)) := sorry --non-trivial
lemma new_lemma_102208 (h0 : functor.add_const (group (ring name)) name) : @group.fg.{0} (ring.{0} name) (@functor.add_const.run.{0 0} (group.{0} (ring.{0} name)) name h0)  := sorry --non-trivial
lemma new_lemma_102209 (h0 : ring (has_to_string (has_to_string linarith.comp))) : rank_condition (has_to_string (has_to_string linarith.comp)) := sorry --non-trivial
lemma new_lemma_102210 (h0 : list (has_neg congr_arg_kind)) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_102211 (h0 : function.extfun Type topological_space) : @topological_space.separable_space.{0} (has_to_string.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_to_string.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_102212 (h0 : group (option name)) : group.fg (option name) := sorry --non-trivial
lemma new_lemma_102213 (h1 : has_neg (nondiscrete_normed_field fun_info)) (h2 : measurable_space (nondiscrete_normed_field fun_info)) : has_measurable_neg (nondiscrete_normed_field fun_info) := sorry --non-trivial
lemma new_lemma_102214 (h0 : monoid (has_emptyc (random_gen linarith.comp_source))) : monoid.fg (has_emptyc (random_gen linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_102215 (h0 : function.extfun Type group) : @is_simple_group.{0} (has_bot.{0} real) (@function.extfun_app.{2 1} Type group.{0} h0 (has_bot.{0} real))  := sorry --non-trivial
lemma new_lemma_102216 (h0 : functor.add_const (ring (has_zero name)) name) : @is_principal_ideal_ring.{0} (has_zero.{0} name) (@functor.add_const.run.{0 0} (ring.{0} (has_zero.{0} name)) name h0)  := sorry --non-trivial
lemma new_lemma_102217 (h0 : complete_lattice (plift (semiring (semiring empty)))) : is_compactly_generated (plift (semiring (semiring empty))) := sorry --non-trivial
lemma new_lemma_102218 (h0 : multiset (preorder congr_arg_kind)) : multiset.nodup h0 := sorry --non-trivial
lemma new_lemma_102219 (h0 : topological_space (normed_lattice_add_comm_group (finset (has_Inf (has_Inf Type))))) : topological_space.separable_space (normed_lattice_add_comm_group (finset (has_Inf (has_Inf Type)))) := sorry --non-trivial
lemma new_lemma_102220 (h0 : not (topological_space (add_group linarith.comp) -> false)) : @discrete_topology.{0} (add_group.{0} linarith.comp) (@classical.by_contradiction'.{1} (topological_space.{0} (add_group.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_102221 (h0 : ring (ordered_comm_ring (has_add (has_nndist (has_add pos))))) : strong_rank_condition (ordered_comm_ring (has_add (has_nndist (has_add pos)))) := sorry --non-trivial
lemma new_lemma_102222 (h0 : semiring (has_inter empty)) : is_noetherian_ring (has_inter empty) := sorry --non-trivial
lemma new_lemma_102223 (h0 : ring (pseudo_metric_space num)) : rank_condition (pseudo_metric_space num) := sorry --non-trivial
lemma new_lemma_102224 (h0 : has_lt (semi_normed_comm_ring char)) : no_max_order (semi_normed_comm_ring char) := sorry --non-trivial
lemma new_lemma_102225 (h1 : topological_space (has_inv string_imp)) : path_connected_space (has_inv string_imp) := sorry --non-trivial
lemma new_lemma_102226 (h0 : topological_space (has_add (has_neg pos))) : normal_space (has_add (has_neg pos)) := sorry --non-trivial
lemma new_lemma_102227 (h0 : monoid (dlist string_imp)) : monoid.fg (dlist string_imp) := sorry --non-trivial
lemma new_lemma_102228 (h0 : topological_space (boolean_algebra.core (finset Type))) : t0_space (boolean_algebra.core (finset Type)) := sorry --non-trivial
lemma new_lemma_102229 (h0 : uniform_space (complete_distrib_lattice (option unsigned))) : separated_space (complete_distrib_lattice (option unsigned)) := sorry --non-trivial
lemma new_lemma_102230 (h0 : not (function.extfun Type add_group -> false)) : @is_add_cyclic.{0} (@id.{2} Type congr_arg_kind) (@function.extfun_app.{2 1} Type add_group.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type add_group.{0}) h0) (@id.{2} Type congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_102231 (h0 : functor.add_const (topological_space auto.case_option) (option empty)) : @t0_space.{0} auto.case_option (@functor.add_const.run.{0 0} (topological_space.{0} auto.case_option) (option.{0} empty) h0)  := sorry --non-trivial
lemma new_lemma_102232 (h0 : topological_space (semigroup (finset name))) : preirreducible_space (semigroup (finset name)) := sorry --non-trivial
lemma new_lemma_102233 (h0 : topological_space (normed_comm_ring real)) : sequential_space (normed_comm_ring real) := sorry --non-trivial
lemma new_lemma_102234 (h0 : option (functor.add_const (ordered_comm_monoid (has_add unsigned)) pos)) (h1 : functor.add_const (ordered_comm_monoid (has_add unsigned)) pos) : @has_exists_mul_of_le.{0} (has_add.{0} unsigned) (@functor.add_const.run.{0 0} (ordered_comm_monoid.{0} (has_add.{0} unsigned)) pos (@option.get_or_else.{0} (functor.add_const.{0 0} (ordered_comm_monoid.{0} (has_add.{0} unsigned)) pos) h0 h1))  := sorry --non-trivial
lemma new_lemma_102235 (h0 : complete_lattice (has_add (option congr_arg_kind))) : complete_lattice.is_Sup_finite_compact (has_add (option congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_102236 (h0 : complete_lattice (semiring congr_arg_kind)) : is_compactly_generated (semiring congr_arg_kind) := sorry --non-trivial
lemma new_lemma_102237 (h0 : functor.add_const (finset (left_cancel_monoid unsigned)) unsigned) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_102238 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @preirreducible_space.{0} (with_bot.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (with_bot.{0} num))  := sorry --non-trivial
lemma new_lemma_102239 (h0 : topological_space (has_sub (semiring (semiring empty)))) : topological_space.separable_space (has_sub (semiring (semiring empty))) := sorry --non-trivial
lemma new_lemma_102240 (h0 : functor.add_const (functor.add_const (group Type) Type) Type) : @normalizer_condition.{1} Type (@functor.add_const.run.{1 1} (group.{1} Type) Type (@functor.add_const.run.{1 1} (functor.add_const.{1 1} (group.{1} Type) Type) Type h0))  := sorry --non-trivial
lemma new_lemma_102241 (h0 : topological_space (canonically_ordered_comm_semiring (finset (has_add name)))) : locally_compact_space (canonically_ordered_comm_semiring (finset (has_add name))) := sorry --non-trivial
lemma new_lemma_102242 (h0 : not (complete_lattice (has_inf empty) -> false)) : @is_compactly_generated.{0} (has_inf.{0} empty) (@classical.by_contradiction'.{1} (complete_lattice.{0} (has_inf.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_102243 (h0 : filter (boolean_algebra (has_add pos))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_102244 (h0 : filter (boolean_algebra.core congr_arg_kind)) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_102245 (h0 : function.extfun Type topological_space) : @totally_disconnected_space.{0} (has_add.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_add.{0} name))  := sorry --non-trivial
lemma new_lemma_102246 (h0 : fin has_zero.zero) : @is_principal_ideal_ring.{0} (has_Inf.{0} real) (@matrix.vec_empty.{0} (ring.{0} (has_Inf.{0} real)) h0)  := sorry --non-trivial
lemma new_lemma_102247 (h0 : ring (random_gen (random_gen linarith.comp_source))) : rank_condition (random_gen (random_gen linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_102248 (h0 : add_monoid (cancel_monoid (finset name))) : add_monoid.fg (cancel_monoid (finset name)) := sorry --non-trivial
lemma new_lemma_102249 (h0 : topological_space (normed_group (has_norm (has_norm linarith.comp)))) : preirreducible_space (normed_group (has_norm (has_norm linarith.comp))) := sorry --non-trivial
lemma new_lemma_102250 (h0 : topological_space (semigroup (finset (finset environment.implicit_infer_kind)))) : totally_separated_space (semigroup (finset (finset environment.implicit_infer_kind))) := sorry --non-trivial
lemma new_lemma_102251 (h0 : topological_space (comm_group (has_add ennreal))) : sequential_space (comm_group (has_add ennreal)) := sorry --non-trivial
lemma new_lemma_102252 (h0 : not (function.extfun Type topological_space -> false)) : @discrete_topology.{0} (complete_semilattice_Sup.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (complete_semilattice_Sup.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_102253 (h0 : cancel_comm_monoid_with_zero (partial_order num)) : unique_factorization_monoid (partial_order num) := sorry --non-trivial
lemma new_lemma_102254 (h0 : not (topological_space (order_dual unsigned) -> false)) : @discrete_topology.{0} (order_dual.{0} unsigned) (@classical.by_contradiction'.{1} (topological_space.{0} (order_dual.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_102255 (h0 : functor.add_const (topological_space (has_Inf Type)) Type) : @loc_path_connected_space.{1} (has_Inf.{1} Type) (@functor.add_const.run.{1 1} (topological_space.{1} (has_Inf.{1} Type)) Type h0)  := sorry --non-trivial
lemma new_lemma_102256 (h0 : group (has_inner empty congr_arg_kind)) : normalizer_condition (has_inner empty congr_arg_kind) := sorry --non-trivial
lemma new_lemma_102257 (h0 : topological_space ereal) : topological_space.first_countable_topology ereal := sorry --non-trivial
lemma new_lemma_102258 (h0 : fin has_zero.zero) : discrete_topology real := sorry --non-trivial
lemma new_lemma_102259 (h0 : functor.add_const (monoid (has_Sup empty)) (semiring empty)) : @monoid.fg.{0} (has_Sup.{0} empty) (@functor.add_const.run.{0 0} (monoid.{0} (has_Sup.{0} empty)) (semiring.{0} empty) h0)  := sorry --non-trivial
lemma new_lemma_102260 (h0 : functor.add_const (topological_space (has_neg pos)) (ring (has_add Type))) : @path_connected_space.{0} (has_neg.{0} pos) (@functor.add_const.run.{0 1} (topological_space.{0} (has_neg.{0} pos)) (ring.{1} (has_add.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_102261 (h0 : functor.add_const (topological_space (semigroup environment.implicit_infer_kind)) linarith.comp) : @discrete_topology.{0} (semigroup.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (semigroup.{0} environment.implicit_infer_kind)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_102262 (h0 : topological_space (metric_space (measure_theory.measure_space (semiring num)))) : irreducible_space (metric_space (measure_theory.measure_space (semiring num))) := sorry --non-trivial
lemma new_lemma_102263 (h0 : function.extfun (finset Type -> Prop) (function.extfun (finset Type))) : @t0_space.{0} (complete_semilattice_Sup.{0} linarith.comp_source) (@finset.pi.empty.{1 0} Type topological_space.{0} (complete_semilattice_Sup.{0} linarith.comp_source) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (complete_semilattice_Sup.{0} linarith.comp_source)) (@function.extfun_app.{2 0} (finset.{1} Type → Prop) (function.extfun.{2 0} (finset.{1} Type)) h0 (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (complete_semilattice_Sup.{0} linarith.comp_source))) (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_102264 (h0 : topological_space (canonically_linear_ordered_monoid ennreal)) : topological_space.separable_space (canonically_linear_ordered_monoid ennreal) := sorry --non-trivial
lemma new_lemma_102265 (h0 : functor.add_const (uniform_space (semigroup linarith.comp)) linarith.comp) : @separated_space.{0} (semigroup.{0} linarith.comp) (@functor.add_const.run.{0 0} (uniform_space.{0} (semigroup.{0} linarith.comp)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_102266 (h0 : has_lt (has_le reducibility_hints)) : no_max_order (has_le reducibility_hints) := sorry --non-trivial
lemma new_lemma_102267 (h0 : topological_space (ordered_comm_ring (has_neg (has_neg (has_neg name))))) : totally_separated_space (ordered_comm_ring (has_neg (has_neg (has_neg name)))) := sorry --non-trivial
lemma new_lemma_102268 (h0 : ordered_comm_monoid (has_neg_part ennreal)) : has_exists_mul_of_le (has_neg_part ennreal) := sorry --non-trivial
lemma new_lemma_102269 (h0 : cancel_comm_monoid_with_zero (has_zero (boolean_algebra Type))) : unique_factorization_monoid (has_zero (boolean_algebra Type)) := sorry --non-trivial
lemma new_lemma_102270 (h0 : functor.add_const (topological_space auto.case_option) empty) : @t1_space.{0} auto.case_option (@functor.add_const.run.{0 0} (topological_space.{0} auto.case_option) empty h0)  := sorry --non-trivial
lemma new_lemma_102271 (h0 : group (semigroup (has_to_string name))) : is_simple_group (semigroup (has_to_string name)) := sorry --non-trivial
lemma new_lemma_102272 (h0 : topological_space (has_nnnorm linarith.ineq)) (h1 : preorder (has_nnnorm linarith.ineq)) : order_closed_topology (has_nnnorm linarith.ineq) := sorry --non-trivial
lemma new_lemma_102273 (h0 : complete_lattice (has_append (fintype (fintype (comm_ring (with_one char)))))) : complete_lattice.is_Sup_finite_compact (has_append (fintype (fintype (comm_ring (with_one char))))) := sorry --non-trivial
lemma new_lemma_102274 (h2 : has_lt (nondiscrete_normed_field string.iterator_imp)) : no_max_order (nondiscrete_normed_field string.iterator_imp) := sorry --non-trivial
lemma new_lemma_102275 (h0 : complete_lattice (add_semigroup empty)) : is_atomistic (add_semigroup empty) := sorry --non-trivial
lemma new_lemma_102276 (h0 : functor.add_const (ring (has_Inf pos)) Type) : @strong_rank_condition.{0} (has_Inf.{0} pos) (@functor.add_const.run.{0 1} (ring.{0} (has_Inf.{0} pos)) Type h0)  := sorry --non-trivial
lemma new_lemma_102277 (h0 : uniform_space (has_sub (has_norm unsigned))) : complete_space (has_sub (has_norm unsigned)) := sorry --non-trivial
lemma new_lemma_102278 (h0 : functor.add_const (topological_space (semigroup environment.implicit_infer_kind)) linarith.comp) : @regular_space.{0} (semigroup.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (semigroup.{0} environment.implicit_infer_kind)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_102279 (h0 : topological_space (mul_zero_class (add_comm_monoid (finset Type)))) : locally_compact_space (mul_zero_class (add_comm_monoid (finset Type))) := sorry --non-trivial
lemma new_lemma_102280 (h0 : topological_space (linear_ordered_comm_ring empty)) : topological_space.separable_space (linear_ordered_comm_ring empty) := sorry --non-trivial
lemma new_lemma_102281 (h0 : function.extfun (finset (Type -> Type)) (has_mem.mem topological_space)) : @irreducible_space.{0} linarith.comp (@function.extfun_app.{2 1} Type topological_space.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) topological_space.{0} (@function.extfun_app.{2 0} (finset.{1} (Type → Type)) (@has_mem.mem.{1 1} (Type → Type) (finset.{1} (Type → Type)) (@finset.has_mem.{1} (Type → Type)) topological_space.{0}) h0 (@has_emptyc.emptyc.{1} (finset.{1} (Type → Type)) (@finset.has_emptyc.{1} (Type → Type))))) linarith.comp)  := sorry --non-trivial
lemma new_lemma_102282 (h0 : set (add_comm_semigroup enat -> mul_one_class ereal)) : set.separates_points h0 := sorry --non-trivial
lemma new_lemma_102283 (h0 : not (uniform_space (linear_ordered_semiring empty) -> false)) : @complete_space.{0} (linear_ordered_semiring.{0} empty) (@classical.by_contradiction'.{1} (uniform_space.{0} (linear_ordered_semiring.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_102284 (h0 : functor.add_const (monoid (has_Sup empty)) (option unsigned)) : @monoid.fg.{0} (has_Sup.{0} empty) (@functor.add_const.run.{0 0} (monoid.{0} (has_Sup.{0} empty)) (option.{0} unsigned) h0)  := sorry --non-trivial
lemma new_lemma_102285 (h0 : topological_space (finset (has_neg (has_pos_part Type)))) : irreducible_space (finset (has_neg (has_pos_part Type))) := sorry --non-trivial
lemma new_lemma_102286 (h0 : topological_space (has_nndist (option (option (comm_monoid (option empty)))))) : irreducible_space (has_nndist (option (option (comm_monoid (option empty))))) := sorry --non-trivial
lemma new_lemma_102287 (h0 : functor.add_const (complete_lattice (comm_group name)) (has_add (option pos))) : @complete_lattice.is_Sup_finite_compact.{0} (comm_group.{0} name) (@functor.add_const.run.{0 0} (complete_lattice.{0} (comm_group.{0} name)) (has_add.{0} (option.{0} pos)) h0)  := sorry --non-trivial
lemma new_lemma_102288 (h0 : topological_space (normed_comm_ring (option unsigned))) : t1_space (normed_comm_ring (option unsigned)) := sorry --non-trivial
lemma new_lemma_102289 (h0 : function.extfun Type add_group) : @is_add_cyclic.{0} (has_union.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type add_group.{0} h0 (has_union.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_102290 (h0 : filter (has_nndist (comm_group (has_to_string (comm_group pos))))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_102291 (h0 : ring (monoid (option (option (option empty))))) : rank_condition (monoid (option (option (option empty)))) := sorry --non-trivial
lemma new_lemma_102292 (h0 : topological_space (has_add (option num))) : preconnected_space (has_add (option num)) := sorry --non-trivial
lemma new_lemma_102293 (h1 : group (metric_space linarith.comp_source)) : is_cyclic (metric_space linarith.comp_source) := sorry --non-trivial
lemma new_lemma_102294 (h0 : functor.add_const (topological_space (add_group unsigned)) (semiring (semiring (semiring num)))) : @normal_space.{0} (add_group.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (add_group.{0} unsigned)) (semiring.{0} (semiring.{0} (semiring.{0} num))) h0)  := sorry --non-trivial
lemma new_lemma_102295 (h0 : semiring (with_one (has_union linarith.comp))) : is_noetherian_ring (with_one (has_union linarith.comp)) := sorry --non-trivial
lemma new_lemma_102296 (h0 : functor.add_const (topological_space (ordered_comm_ring Type)) (has_neg pos)) : @preirreducible_space.{1} (ordered_comm_ring.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (ordered_comm_ring.{1} Type)) (has_neg.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_102297 (h0 : topological_space (finset (finset (finset (has_Inf linarith.comp))))) : discrete_topology (finset (finset (finset (has_Inf linarith.comp)))) := sorry --non-trivial
lemma new_lemma_102298 (h0 : functor.add_const (topological_space (boolean_algebra pos)) (has_neg (has_neg Type))) : @t0_space.{0} (boolean_algebra.{0} pos) (@functor.add_const.run.{0 1} (topological_space.{0} (boolean_algebra.{0} pos)) (has_neg.{1} (has_neg.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_102299 (h0 : function.extfun Type (functor.add_const (uniform_space (ordered_ring empty)))) : @separated_space.{0} (ordered_ring.{0} empty) (@functor.add_const.run.{0 0} (uniform_space.{0} (ordered_ring.{0} empty)) congr_arg_kind (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (uniform_space.{0} (ordered_ring.{0} empty))) h0 congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_102300 (h0 : topological_space (has_to_string (finset (finset pos)))) : normal_space (has_to_string (finset (finset pos))) := sorry --non-trivial
lemma new_lemma_102301 (h0 : functor.add_const (ring (semigroup name)) unsigned) : @rank_condition.{0} (semigroup.{0} name) (@functor.add_const.run.{0 0} (ring.{0} (semigroup.{0} name)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_102302 (h0 : topological_space (has_Inf pos)) : irreducible_space (has_Inf pos) := sorry --non-trivial
lemma new_lemma_102303 (h0 : uniform_space (simple_graph string.iterator_imp)) : complete_space (simple_graph string.iterator_imp) := sorry --non-trivial
lemma new_lemma_102304 (h0 : topological_space (has_nndist empty)) : loc_path_connected_space (has_nndist empty) := sorry --non-trivial
lemma new_lemma_102305 (h0 : topological_space (canonically_ordered_comm_semiring (option (option (option unsigned))))) : preirreducible_space (canonically_ordered_comm_semiring (option (option (option unsigned)))) := sorry --non-trivial
lemma new_lemma_102306 (h0 : monoid (has_neg (has_to_string environment.implicit_infer_kind))) : monoid.fg (has_neg (has_to_string environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_102307 (h0 : cancel_comm_monoid_with_zero (boolean_algebra.core (has_neg name))) : unique_factorization_monoid (boolean_algebra.core (has_neg name)) := sorry --non-trivial
lemma new_lemma_102308 (h0 : topological_space (add_cancel_monoid (has_neg (has_Inf linarith.comp)))) : loc_path_connected_space (add_cancel_monoid (has_neg (has_Inf linarith.comp))) := sorry --non-trivial
lemma new_lemma_102309 (h0 : topological_space (comm_group name)) : preconnected_space (comm_group name) := sorry --non-trivial
lemma new_lemma_102310 (h0 : function.extfun Type list) : list.nodup (function.extfun_app h0 (monoid_with_zero congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_102311 (h0 : functor.add_const (finset (add_comm_monoid pos)) pos) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_102312 (h0 : function.extfun Type (functor.add_const (topological_space (boolean_algebra.core name)))) : @irreducible_space.{0} (boolean_algebra.core.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (boolean_algebra.core.{0} name)) linarith.comp (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (topological_space.{0} (boolean_algebra.core.{0} name))) h0 linarith.comp))  := sorry --non-trivial
lemma new_lemma_102313 (h1 : topological_space (add_comm_semigroup (add_comm_semigroup char))) (h2 : set (add_comm_semigroup (add_comm_semigroup char))) : is_path_connected h2 := sorry --non-trivial
lemma new_lemma_102314 (h0 : group (complete_distrib_lattice (has_neg name))) : group.fg (complete_distrib_lattice (has_neg name)) := sorry --non-trivial
lemma new_lemma_102315 (h0 : function.extfun ((Type -> Type) -> Type 1) (function.extfun (Type -> Type))) : @loc_path_connected_space.{0} (group_with_zero.{0} ennreal) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) (@function.extfun_app.{3 2} ((Type → Type) → Type 1) (function.extfun.{2 2} (Type → Type)) h0 (function.extfun.{2 1} Type)) topological_space.{0}) (group_with_zero.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_102316 (h0 : topological_space (mul_one_class (add_comm_semigroup std_gen))) : path_connected_space (mul_one_class (add_comm_semigroup std_gen)) := sorry --non-trivial
lemma new_lemma_102317 (h0 : topological_space (linear_order num)) : irreducible_space (linear_order num) := sorry --non-trivial
lemma new_lemma_102318 (h0 : add_group (distrib string_imp)) : is_add_cyclic (distrib string_imp) := sorry --non-trivial
lemma new_lemma_102319 (h0 : topological_space (random_gen (has_nnnorm string.iterator_imp))) : path_connected_space (random_gen (has_nnnorm string.iterator_imp)) := sorry --non-trivial
lemma new_lemma_102320 (h0 : topological_space (ordered_comm_ring (ring Type))) : sequential_space (ordered_comm_ring (ring Type)) := sorry --non-trivial
lemma new_lemma_102321 (h0 : functor.add_const (ordered_comm_monoid (has_nndist environment.implicit_infer_kind)) linarith.comp) : @has_exists_mul_of_le.{0} (has_nndist.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (ordered_comm_monoid.{0} (has_nndist.{0} environment.implicit_infer_kind)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_102322 (h0 : functor.add_const (group (finset Type)) pos) : @normalizer_condition.{1} (finset.{1} Type) (@functor.add_const.run.{1 0} (group.{1} (finset.{1} Type)) pos h0)  := sorry --non-trivial
lemma new_lemma_102323 (h0 : topological_space (semigroup (has_neg (ring Type)))) : loc_path_connected_space (semigroup (has_neg (ring Type))) := sorry --non-trivial
lemma new_lemma_102324 (h0 : not (has_mem.mem (measurable_space num) has_emptyc.emptyc -> false)) : @path_connected_space.{0} (measurable_space.{0} num) (@finset.pi.empty.{1 0} Type topological_space.{0} (measurable_space.{0} num) (@classical.by_contradiction'.{0} (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (measurable_space.{0} num) (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))) h0))  := sorry --non-trivial
lemma new_lemma_102325 (h0 : function.extfun Type topological_space) : @locally_compact_space.{0} (left_cancel_monoid.{0} (semiring.{0} num)) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (left_cancel_monoid.{0} (semiring.{0} num)))  := sorry --non-trivial
lemma new_lemma_102326 (h0 : functor.add_const (function.extfun Type ring) Type) : @is_principal_ideal_ring.{0} (boolean_algebra.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type ring.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type ring.{0}) Type h0) (boolean_algebra.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_102327 (h0 : functor.add_const (topological_space (sub_neg_monoid pos)) linarith.comp) : @loc_path_connected_space.{0} (sub_neg_monoid.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (sub_neg_monoid.{0} pos)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_102328 (h0 : topological_space (has_neg (has_zero (finset linarith.comp)))) : loc_path_connected_space (has_neg (has_zero (finset linarith.comp))) := sorry --non-trivial
lemma new_lemma_102329 (h1 : topological_space (has_top (has_top to_additive.value_type))) : path_connected_space (has_top (has_top to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_102330 (h0 : group (monoid (option (option unsigned)))) : is_cyclic (monoid (option (option unsigned))) := sorry --non-trivial
lemma new_lemma_102331 (h1 : not (ring (add_cancel_comm_monoid string_imp) -> false)) : @is_field.{0} (add_cancel_comm_monoid.{0} string_imp) (@classical.by_contradiction'.{1} (ring.{0} (add_cancel_comm_monoid.{0} string_imp)) h1)  := sorry --non-trivial
lemma new_lemma_102332 (h0 : group (add_left_cancel_monoid (has_add (free_add_monoid to_additive.value_type)))) : is_cyclic (add_left_cancel_monoid (has_add (free_add_monoid to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_102333 (h0 : group (with_one (semiring num))) : is_cyclic (with_one (semiring num)) := sorry --non-trivial
lemma new_lemma_102334 (h0 : not (topological_space (random_gen char) -> false)) : @t0_space.{0} (random_gen.{0} char) (@classical.by_contradiction'.{1} (topological_space.{0} (random_gen.{0} char)) h0)  := sorry --non-trivial
lemma new_lemma_102335 (h0 : function.extfun Type ring) : @rank_condition.{0} (has_sub.{0} unsigned) (@function.extfun_app.{2 1} Type ring.{0} h0 (has_sub.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_102336 (h1 : topological_space (has_nnnorm string.iterator_imp)) (h2 : add_group (has_nnnorm string.iterator_imp)) : topological_add_group (has_nnnorm string.iterator_imp) := sorry --non-trivial
lemma new_lemma_102337 (h0 : not (function.extfun Type group -> false)) : @normalizer_condition.{0} (has_top.{0} linarith.comp) (@function.extfun_app.{2 1} Type group.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type group.{0}) h0) (has_top.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_102338 (h0 : not (ring (distrib (metric_space linarith.comp_source)) -> false)) : @is_domain.{0} (distrib.{0} (metric_space.{0} linarith.comp_source)) (@classical.by_contradiction'.{1} (ring.{0} (distrib.{0} (metric_space.{0} linarith.comp_source))) h0)  := sorry --non-trivial
lemma new_lemma_102339 (h0 : topological_space (finset (has_add (has_add (finset (has_Inf Type)))))) : locally_compact_space (finset (has_add (has_add (finset (has_Inf Type))))) := sorry --non-trivial
lemma new_lemma_102340 (h1 : topological_space (normed_field to_additive.value_type)) : totally_disconnected_space (normed_field to_additive.value_type) := sorry --non-trivial
lemma new_lemma_102341 (h0 : functor.add_const (cancel_comm_monoid_with_zero (has_add pos)) linarith.comp) : @unique_factorization_monoid.{0} (has_add.{0} pos) (@functor.add_const.run.{0 0} (cancel_comm_monoid_with_zero.{0} (has_add.{0} pos)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_102342 (h0 : cancel_comm_monoid_with_zero (comm_group pos)) : unique_factorization_monoid (comm_group pos) := sorry --non-trivial
lemma new_lemma_102343 (h0 : function.extfun Type topological_space) : @totally_disconnected_space.{0} (has_neg.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_neg.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_102344 (h0 : to_additive.value_type -> uniform_space (semi_normed_ring to_additive.value_type)) : @complete_space.{0} (semi_normed_ring.{0} to_additive.value_type) (@infi.{0 1} (uniform_space.{0} (semi_normed_ring.{0} to_additive.value_type)) (@uniform_space.has_Inf.{0} (semi_normed_ring.{0} to_additive.value_type)) to_additive.value_type h0)  := sorry --non-trivial
lemma new_lemma_102345 (h0 : topological_space (add_comm_monoid (finset (has_nndist environment.implicit_infer_kind)))) : path_connected_space (add_comm_monoid (finset (has_nndist environment.implicit_infer_kind))) := sorry --non-trivial
lemma new_lemma_102346 (h3 h4 : multiset (has_div linarith.comp_source)) : multiset.disjoint h3 h4 := sorry --non-trivial
lemma new_lemma_102347 (h0 : function.extfun (finset Type) (has_mem.mem (measurable_space fun_info))) : @locally_compact_space.{0} (measurable_space.{0} fun_info) (@finset.pi.empty.{1 0} Type topological_space.{0} (measurable_space.{0} fun_info) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (measurable_space.{0} fun_info)) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_102348 (h0 : not (complete_lattice (semi_normed_comm_ring linarith.comp_source) -> false)) : @complete_lattice.is_Sup_finite_compact.{0} (semi_normed_comm_ring.{0} linarith.comp_source) (@classical.by_contradiction'.{1} (complete_lattice.{0} (semi_normed_comm_ring.{0} linarith.comp_source)) h0)  := sorry --non-trivial
lemma new_lemma_102349 (h0 : finset (linear_ordered_comm_ring (left_cancel_semigroup num))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_102350 (h0 : functor.add_const (topological_space (boolean_algebra.core name)) Type) : @topological_space.separable_space.{0} (boolean_algebra.core.{0} name) (@functor.add_const.run.{0 1} (topological_space.{0} (boolean_algebra.core.{0} name)) Type h0)  := sorry --non-trivial
lemma new_lemma_102351 (h0 : topological_space (normed_comm_ring (has_neg (has_neg (finset Type))))) : preirreducible_space (normed_comm_ring (has_neg (has_neg (finset Type)))) := sorry --non-trivial
lemma new_lemma_102352 (h0 : function.extfun Type filter) : filter.ne_bot (function.extfun_app h0 (has_dist ennreal)) := sorry --non-trivial
lemma new_lemma_102353 (h0 : ring (has_pos_part (finset pos))) : is_principal_ideal_ring (has_pos_part (finset pos)) := sorry --non-trivial
lemma new_lemma_102354 (h0 : filter (has_zero (finset (finset (ring Type))))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_102355 (h0 : functor.add_const (cancel_comm_monoid_with_zero (has_bot linarith.comp)) pos) : @unique_factorization_monoid.{0} (has_bot.{0} linarith.comp) (@functor.add_const.run.{0 0} (cancel_comm_monoid_with_zero.{0} (has_bot.{0} linarith.comp)) pos h0)  := sorry --non-trivial
lemma new_lemma_102356 (h0 : has_mem.mem (measurable_space num) has_emptyc.emptyc) : @monoid.fg.{0} (measurable_space.{0} num) (@finset.pi.empty.{1 0} Type monoid.{0} (measurable_space.{0} num) h0)  := sorry --non-trivial
lemma new_lemma_102357 (h1 : topological_space (has_norm (has_top (has_top to_additive.value_type)))) : locally_compact_space (has_norm (has_top (has_top to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_102358 (h0 : complete_lattice (with_one to_additive.value_type)) : complete_lattice.is_Sup_finite_compact (with_one to_additive.value_type) := sorry --non-trivial
lemma new_lemma_102359 (h0 : list (has_neg_part (option (option unsigned)))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_102360 (h0 : function.extfun Type topological_space) : @sequential_space.{0} (canonically_ordered_comm_semiring.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (canonically_ordered_comm_semiring.{0} pos))  := sorry --non-trivial
lemma new_lemma_102361 (h0 : functor.add_const (function.extfun Type group) (ring pos)) : @group.fg.{0} (has_Inf.{0} pos) (@function.extfun_app.{2 1} Type group.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type group.{0}) (ring.{0} pos) h0) (has_Inf.{0} pos))  := sorry --non-trivial
lemma new_lemma_102362 (h0 : ring (complete_linear_order (semiring empty))) : strong_rank_condition (complete_linear_order (semiring empty)) := sorry --non-trivial
lemma new_lemma_102363 (h0 : uniform_space (rel unsigned num)) : complete_space (rel unsigned num) := sorry --non-trivial
lemma new_lemma_102364 (h0 : function.extfun Type (functor.comp topological_space comm_group)) : @preirreducible_space.{0} (comm_group.{0} pos) (@functor.comp.run.{0 0 0} topological_space.{0} comm_group.{0} pos (@function.extfun_app.{2 1} Type (functor.comp.{0 0 0} topological_space.{0} comm_group.{0}) h0 pos))  := sorry --non-trivial
lemma new_lemma_102365 (h0 : functor.add_const (group (has_pos_part linarith.comp)) pos) : @group.fg.{0} (has_pos_part.{0} linarith.comp) (@functor.add_const.run.{0 0} (group.{0} (has_pos_part.{0} linarith.comp)) pos h0)  := sorry --non-trivial
lemma new_lemma_102366 (h0 : functor.add_const (complete_lattice (linear_ordered_field unsigned)) (option pos)) : @is_compactly_generated.{0} (linear_ordered_field.{0} unsigned) (@functor.add_const.run.{0 0} (complete_lattice.{0} (linear_ordered_field.{0} unsigned)) (option.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_102367 (h0 : functor.add_const (topological_space (comm_group pos)) Type) : @normal_space.{0} (comm_group.{0} pos) (@functor.add_const.run.{0 1} (topological_space.{0} (comm_group.{0} pos)) Type h0)  := sorry --non-trivial
lemma new_lemma_102368 (h0 : topological_space (has_emptyc (has_norm num))) : t0_space (has_emptyc (has_norm num)) := sorry --non-trivial
lemma new_lemma_102369 (h0 : topological_space (has_add (has_neg (ring (ring (has_neg Type)))))) : topological_space.separable_space (has_add (has_neg (ring (ring (has_neg Type))))) := sorry --non-trivial
lemma new_lemma_102370 (h0 : functor.add_const (filter (normed_comm_ring Type)) pos) : filter.ne_bot (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_102371 (h0 : uniform_space (has_compl (random_gen to_additive.value_type))) : complete_space (has_compl (random_gen to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_102372 (h0 : topological_space (linear_ordered_comm_group_with_zero enat)) : t0_space (linear_ordered_comm_group_with_zero enat) := sorry --non-trivial
lemma new_lemma_102373 (h0 : topological_space (mul_one_class (normed_field (normed_field reducibility_hints)))) : path_connected_space (mul_one_class (normed_field (normed_field reducibility_hints))) := sorry --non-trivial
lemma new_lemma_102374 (h0 : semiring (cancel_monoid ennreal)) : is_noetherian_ring (cancel_monoid ennreal) := sorry --non-trivial
lemma new_lemma_102375 (h0 : ring (mul_one_class (mul_one_class ereal))) : strong_rank_condition (mul_one_class (mul_one_class ereal)) := sorry --non-trivial
lemma new_lemma_102376 (h0 : functor.comp list has_add Type) : palindrome (functor.comp.run h0) := sorry --non-trivial
lemma new_lemma_102377 (h0 : function.extfun Type topological_space) : @irreducible_space.{0} (linear_ordered_cancel_comm_monoid.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (linear_ordered_cancel_comm_monoid.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_102378 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @group.fg.{0} (comm_ring.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (comm_ring.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_102379 (h0 : add_monoid (has_to_string empty)) : add_monoid.fg (has_to_string empty) := sorry --non-trivial
lemma new_lemma_102380 (h0 : add_group (left_cancel_monoid string.iterator_imp)) : is_add_cyclic (left_cancel_monoid string.iterator_imp) := sorry --non-trivial
lemma new_lemma_102381 (h0 : list (add_comm_monoid name)) : palindrome h0 := sorry --non-trivial
lemma new_lemma_102382 (h0 : monoid (with_bot (has_top (semiring congr_arg_kind)))) : monoid.fg (with_bot (has_top (semiring congr_arg_kind))) := sorry --non-trivial
lemma new_lemma_102383 (h0 : topological_space (has_neg (option unsigned))) : discrete_topology (has_neg (option unsigned)) := sorry --non-trivial
lemma new_lemma_102384 (h0 : not (topological_space (measurable_space.dynkin_system unsigned) -> false)) : @locally_compact_space.{0} (measurable_space.dynkin_system.{0} unsigned) (@classical.by_contradiction'.{1} (topological_space.{0} (measurable_space.dynkin_system.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_102385 (h0 : functor.add_const (topological_space (left_cancel_monoid num)) (semiring num)) : @t1_space.{0} (left_cancel_monoid.{0} num) (@functor.add_const.run.{0 0} (topological_space.{0} (left_cancel_monoid.{0} num)) (semiring.{0} num) h0)  := sorry --non-trivial
lemma new_lemma_102386 (h0 : functor.add_const (topological_space (measure_theory.measure_space congr_arg_kind)) empty) : @totally_separated_space.{0} (measure_theory.measure_space.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (measure_theory.measure_space.{0} congr_arg_kind)) empty h0)  := sorry --non-trivial
lemma new_lemma_102387 (h0 : functor.add_const (topological_space (has_bot name)) linarith.comp) : @topological_space.separable_space.{0} (has_bot.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (has_bot.{0} name)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_102388 (h2 : topological_space (semi_normed_ring to_additive.value_type)) : totally_disconnected_space (semi_normed_ring to_additive.value_type) := sorry --non-trivial
lemma new_lemma_102389 (h0 : topological_space (id (random_gen (random_gen string_imp)))) : totally_disconnected_space (id (random_gen (random_gen string_imp))) := sorry --non-trivial
lemma new_lemma_102390 (h1 : has_neg ereal) (h2 : measurable_space ereal) : has_measurable_neg ereal := sorry --non-trivial
lemma new_lemma_102391 (h0 : functor.add_const (topological_space (option unsigned)) pos) : @irreducible_space.{0} (option.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (option.{0} unsigned)) pos h0)  := sorry --non-trivial
lemma new_lemma_102392 (h0 : functor.add_const (function.extfun (Type 1) group) (has_add linarith.comp)) : @is_cyclic.{1} (has_Inf.{1} Type) (@function.extfun_app.{3 2} (Type 1) group.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) group.{1}) (has_add.{0} linarith.comp) h0) (has_Inf.{1} Type))  := sorry --non-trivial
lemma new_lemma_102393 (h0 : function.extfun Type topological_space) : @topological_space.separable_space.{0} (comm_group.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (comm_group.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_102394 (h0 : add_group (linear_ordered_comm_group_with_zero char)) : is_add_cyclic (linear_ordered_comm_group_with_zero char) := sorry --non-trivial
lemma new_lemma_102395 (h0 : topological_space (finset (finset (finset (finset (finset linarith.comp)))))) : discrete_topology (finset (finset (finset (finset (finset linarith.comp))))) := sorry --non-trivial
lemma new_lemma_102396 (h0 : topological_space (mul_zero_class (normed_comm_ring Type))) : preconnected_space (mul_zero_class (normed_comm_ring Type)) := sorry --non-trivial
lemma new_lemma_102397 (h0 : topological_space (pseudo_emetric_space num)) : locally_compact_space (pseudo_emetric_space num) := sorry --non-trivial
lemma new_lemma_102398 (h0 : topological_space (linear_ordered_comm_group_with_zero std_gen)) : t0_space (linear_ordered_comm_group_with_zero std_gen) := sorry --non-trivial
lemma new_lemma_102399 (h0 : add_comm_semigroup enat -> add_comm_semigroup enat -> Prop) : is_total_preorder (add_comm_semigroup enat) h0 := sorry --non-trivial
lemma new_lemma_102400 (h0 : functor.add_const (function.extfun (Type 1) semiring) environment.implicit_infer_kind) : @is_noetherian_ring.{1} (add_comm_monoid.{1} Type) (@function.extfun_app.{3 2} (Type 1) semiring.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) semiring.{1}) environment.implicit_infer_kind h0) (add_comm_monoid.{1} Type))  := sorry --non-trivial
lemma new_lemma_102401 (h0 : functor.add_const (function.extfun (Type 1) group) Type) : @normalizer_condition.{1} (ring.{1} Type) (@function.extfun_app.{3 2} (Type 1) group.{1} (@functor.add_const.run.{2 1} (function.extfun.{3 2} (Type 1) group.{1}) Type h0) (ring.{1} Type))  := sorry --non-trivial
lemma new_lemma_102402 (h0 : monoid (with_bot (random_gen (comm_ring string_imp)))) : monoid.fg (with_bot (random_gen (comm_ring string_imp))) := sorry --non-trivial
lemma new_lemma_102403 (h0 : finset (finset (ring (has_to_string (ring environment.implicit_infer_kind))))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_102404 (h0 : function.extfun (finset Type) (has_mem.mem (with_one congr_arg_kind))) : @complete_space.{0} (with_one.{0} congr_arg_kind) (@finset.pi.empty.{1 0} Type uniform_space.{0} (with_one.{0} congr_arg_kind) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (with_one.{0} congr_arg_kind)) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_102405 (h0 : ordered_add_comm_monoid (ordered_comm_monoid (has_Inf (has_pos_part (has_Inf pos))))) : archimedean (ordered_comm_monoid (has_Inf (has_pos_part (has_Inf pos)))) := sorry --non-trivial
lemma new_lemma_102406 (h0 : filter (finset (has_Inf (has_Inf Type)))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_102407 (h0 : topological_space (with_bot (random_gen (random_gen linarith.ineq)))) : totally_disconnected_space (with_bot (random_gen (random_gen linarith.ineq))) := sorry --non-trivial
lemma new_lemma_102408 (h0 : function.extfun Type topological_space) : @totally_separated_space.{0} (complete_distrib_lattice.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (complete_distrib_lattice.{0} num))  := sorry --non-trivial
lemma new_lemma_102409 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @normal_space.{0} (ordered_comm_ring.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (ordered_comm_ring.{0} pos))  := sorry --non-trivial
lemma new_lemma_102410 (h0 : fin has_zero.zero) : @is_add_cyclic.{0} (finset.{0} real) (@matrix.vec_empty.{0} (add_group.{0} (finset.{0} real)) (@matrix.vec_empty.{0} (fin (@has_zero.zero.{0} nat nat.has_zero)) (@function.extfun_app.{1 1} nat fin (@matrix.vec_empty.{0} (function.extfun.{1 1} nat fin) h0) (@has_zero.zero.{0} nat nat.has_zero))))  := sorry --non-trivial
lemma new_lemma_102411 (h0 : complete_lattice (has_add pos)) : is_atomistic (has_add pos) := sorry --non-trivial
lemma new_lemma_102412 (h1 : complete_lattice (has_lt std_gen)) : is_compactly_generated (has_lt std_gen) := sorry --non-trivial
lemma new_lemma_102413 (h0 : topological_space (linear_ordered_semiring (semiring congr_arg_kind))) : irreducible_space (linear_ordered_semiring (semiring congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_102414 (h0 : topological_space (comm_group (has_add Type))) : regular_space (comm_group (has_add Type)) := sorry --non-trivial
lemma new_lemma_102415 (h0 : has_mem.mem topological_space has_emptyc.emptyc) : @totally_separated_space.{0} linarith.comp (@function.extfun_app.{2 1} Type topological_space.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) topological_space.{0} h0) linarith.comp)  := sorry --non-trivial
lemma new_lemma_102416 (h0 : add_monoid (add_cancel_monoid (has_neg (has_neg Type)))) : add_monoid.fg (add_cancel_monoid (has_neg (has_neg Type))) := sorry --non-trivial
lemma new_lemma_102417 (h0 : function.extfun Type topological_space) : @locally_compact_space.{0} (has_zero.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_zero.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_102418 (h0 : uniform_space (has_sub (semiring (semiring empty)))) : separated_space (has_sub (semiring (semiring empty))) := sorry --non-trivial
lemma new_lemma_102419 (h0 : functor.add_const (filter (has_nndist linarith.comp)) (has_Inf (has_Inf linarith.comp))) : countable_Inter_filter (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_102420 (h0 : functor.add_const (add_group (omega_complete_partial_order empty)) empty) : @is_add_cyclic.{0} (omega_complete_partial_order.{0} empty) (@functor.add_const.run.{0 0} (add_group.{0} (omega_complete_partial_order.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_102421 (h0 : function.extfun (Type 1) finset) : finset.nonempty (function.extfun_app h0 (generalized_boolean_algebra Type)) := sorry --non-trivial
lemma new_lemma_102422 (h0 : set (multiplicative environment.projection_info)) : set.subsingleton h0 := sorry --non-trivial
lemma new_lemma_102423 (h0 : add_monoid (has_top (semiring (semiring empty)))) : add_monoid.fg (has_top (semiring (semiring empty))) := sorry --non-trivial
lemma new_lemma_102424 (h0 : set (add_comm_semigroup (add_comm_semigroup (add_comm_semigroup ereal)) -> enat)) : set.separates_points h0 := sorry --non-trivial
lemma new_lemma_102425 (h0 : functor.add_const (list (bin_tree unsigned)) congr_arg_kind) : list.nodup (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_102426 (h0 : complete_lattice (linear_ordered_comm_monoid_with_zero (option unsigned))) : is_compactly_generated (linear_ordered_comm_monoid_with_zero (option unsigned)) := sorry --non-trivial
lemma new_lemma_102427 (h0 : ring (has_to_string (has_add (has_add (has_add (has_add Type)))))) : rank_condition (has_to_string (has_add (has_add (has_add (has_add Type))))) := sorry --non-trivial
lemma new_lemma_102428 (h0 : uniform_space (ring pos)) : complete_space (ring pos) := sorry --non-trivial
lemma new_lemma_102429 (h0 : functor.add_const (ring (group_with_zero ennreal)) ennreal) : @is_domain.{0} (group_with_zero.{0} ennreal) (@functor.add_const.run.{0 0} (ring.{0} (group_with_zero.{0} ennreal)) ennreal h0)  := sorry --non-trivial
lemma new_lemma_102430 (h0 : linarith.ineq -> Prop) : exists_unique h0 := sorry --non-trivial
lemma new_lemma_102431 (h0 : function.extfun Type monoid) : @monoid.fg.{0} (has_one.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type monoid.{0} h0 (has_one.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_102432 (h0 : fin has_zero.zero) : @t1_space.{0} (complete_distrib_lattice.{0} real) (@matrix.vec_empty.{0} (topological_space.{0} (complete_distrib_lattice.{0} real)) (@matrix.vec_empty.{0} (fin (@has_zero.zero.{0} nat nat.has_zero)) h0))  := sorry --non-trivial
lemma new_lemma_102433 (h0 : list (finset congr_arg_kind)) : palindrome h0 := sorry --non-trivial
lemma new_lemma_102434 (h0 : ring (has_neg_part (has_nndist (has_nndist environment.implicit_infer_kind)))) : rank_condition (has_neg_part (has_nndist (has_nndist environment.implicit_infer_kind))) := sorry --non-trivial
lemma new_lemma_102435 (h0 : function.extfun Type cancel_comm_monoid_with_zero) : @unique_factorization_monoid.{0} (simple_graph.{0} pos) (@function.extfun_app.{2 1} Type cancel_comm_monoid_with_zero.{0} h0 (simple_graph.{0} pos))  := sorry --non-trivial
lemma new_lemma_102436 (h0 : nat -> nat -> Prop) (h1 : well_founded h0) (h2 : Pi (x : nat), (Pi (y : nat), h0 y x -> fin y) -> fin x) : matrix.vec_empty (well_founded.fix h1 h2 has_zero.zero) := sorry --non-trivial
lemma new_lemma_102437 (h0 : not (function.extfun Type topological_space -> false)) : @totally_separated_space.{0} (has_norm.{0} fun_info) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (has_norm.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_102438 (h0 : not (topological_space (semi_normed_ring char) -> false)) : @totally_disconnected_space.{0} (semi_normed_ring.{0} char) (@classical.by_contradiction'.{1} (topological_space.{0} (semi_normed_ring.{0} char)) h0)  := sorry --non-trivial
lemma new_lemma_102439 (h0 : filter (has_union (has_union linarith.comp))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_102440 (h0 : complete_lattice (has_top (has_top fun_info))) : is_atomistic (has_top (has_top fun_info)) := sorry --non-trivial
lemma new_lemma_102441 (h0 : complete_lattice (sub_neg_monoid (has_add (has_Inf pos)))) : is_compactly_generated (sub_neg_monoid (has_add (has_Inf pos))) := sorry --non-trivial
lemma new_lemma_102442 (h0 : not (group (has_top congr_arg_kind) -> false)) : @is_cyclic.{0} (has_top.{0} congr_arg_kind) (@classical.by_contradiction'.{1} (group.{0} (has_top.{0} congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_102443 (h0 : functor.add_const (topological_space (add_group num)) empty) : @path_connected_space.{0} (add_group.{0} num) (@functor.add_const.run.{0 0} (topological_space.{0} (add_group.{0} num)) empty h0)  := sorry --non-trivial
lemma new_lemma_102444 (h0 : add_group (random_gen string.iterator_imp)) : is_add_cyclic (random_gen string.iterator_imp) := sorry --non-trivial
lemma new_lemma_102445 (h0 : ring (linear_ordered_comm_group_with_zero (mul_one_class string.iterator_imp))) : strong_rank_condition (linear_ordered_comm_group_with_zero (mul_one_class string.iterator_imp)) := sorry --non-trivial
lemma new_lemma_102446 (h0 : filter (boolean_algebra.core (ring name))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_102447 (h0 : functor.add_const (topological_space (add_comm_monoid name)) (add_cancel_monoid (boolean_algebra (has_neg Type)))) : @path_connected_space.{0} (add_comm_monoid.{0} name) (@functor.add_const.run.{0 1} (topological_space.{0} (add_comm_monoid.{0} name)) (add_cancel_monoid.{1} (boolean_algebra.{1} (has_neg.{1} Type))) h0)  := sorry --non-trivial
lemma new_lemma_102448 (h0 : topological_space (has_add (has_add Type))) : t0_space (has_add (has_add Type)) := sorry --non-trivial
lemma new_lemma_102449 (h0 : group (add_cancel_monoid (ring linarith.comp))) : is_simple_group (add_cancel_monoid (ring linarith.comp)) := sorry --non-trivial
lemma new_lemma_102450 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @sequential_space.{0} (has_nndist.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_nndist.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_102451 (h0 : has_mem.mem topological_space has_emptyc.emptyc) : @discrete_topology.{0} fun_info (@function.extfun_app.{2 1} Type topological_space.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) topological_space.{0} h0) fun_info)  := sorry --non-trivial
lemma new_lemma_102452 (h0 : topological_space (has_append (fintype linarith.ineq))) : t0_space (has_append (fintype linarith.ineq)) := sorry --non-trivial
lemma new_lemma_102453 (h1 : ring (denumerable to_additive.value_type)) (h2 : ring (ring.positive_cone (denumerable to_additive.value_type))) : strong_rank_condition (ring.positive_cone (denumerable to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_102454 (h0 : group (add_right_cancel_monoid congr_arg_kind)) : normalizer_condition (add_right_cancel_monoid congr_arg_kind) := sorry --non-trivial
lemma new_lemma_102455 (h0 : not (topological_space (has_one (semiring (semiring (semiring (semiring (semiring congr_arg_kind)))))) -> false)) : @path_connected_space.{0} (has_one.{0} (semiring.{0} (semiring.{0} (semiring.{0} (semiring.{0} (semiring.{0} congr_arg_kind)))))) (@classical.by_contradiction'.{1} (topological_space.{0} (has_one.{0} (semiring.{0} (semiring.{0} (semiring.{0} (semiring.{0} (semiring.{0} congr_arg_kind))))))) h0)  := sorry --non-trivial
lemma new_lemma_102456 (h1 : set (linarith.ineq -> add_comm_semigroup char)) : set.separates_points h1 := sorry --non-trivial
lemma new_lemma_102457 (h0 : topological_space (boolean_algebra (has_add pos))) : preirreducible_space (boolean_algebra (has_add pos)) := sorry --non-trivial
lemma new_lemma_102458 (h0 : uniform_space (has_ssubset std_gen)) : complete_space (has_ssubset std_gen) := sorry --non-trivial
lemma new_lemma_102459 (h0 : add_monoid (finset num)) : add_monoid.fg (finset num) := sorry --non-trivial
lemma new_lemma_102460 (h0 : topological_space (add_comm_monoid (has_neg name))) : t1_space (add_comm_monoid (has_neg name)) := sorry --non-trivial
lemma new_lemma_102461 (h0 : ring (ordered_ring (semiring (semiring empty)))) : rank_condition (ordered_ring (semiring (semiring empty))) := sorry --non-trivial
lemma new_lemma_102462 (h0 : prod (with_bot empty) (with_bot empty)) : id_rel h0 := sorry --non-trivial
lemma new_lemma_102463 (h0 : topological_space (boolean_algebra (finset (has_add pos)))) : irreducible_space (boolean_algebra (finset (has_add pos))) := sorry --non-trivial
lemma new_lemma_102464 (h0 : function.extfun Type (functor.comp topological_space finset)) : @discrete_topology.{0} (finset.{0} pos) (@functor.comp.run.{0 0 0} topological_space.{0} finset.{0} pos (@function.extfun_app.{2 1} Type (functor.comp.{0 0 0} topological_space.{0} finset.{0}) h0 pos))  := sorry --non-trivial
lemma new_lemma_102465 (h0 : functor.add_const (functor.comp ring semigroup pos) unsigned) : @strong_rank_condition.{0} (semigroup.{0} pos) (@functor.add_const.run.{0 0} (ring.{0} (semigroup.{0} pos)) name (@functor.comp.run.{0 0 0} ring.{0} semigroup.{0} pos (@functor.add_const.run.{0 0} (functor.comp.{0 0 0} ring.{0} semigroup.{0} pos) unsigned h0)))  := sorry --non-trivial
lemma new_lemma_102466 (h1 : complete_lattice (with_one char)) : is_compactly_generated (with_one char) := sorry --non-trivial
lemma new_lemma_102467 (h0 : uniform_space (random_gen reducibility_hints)) : complete_space (random_gen reducibility_hints) := sorry --non-trivial
lemma new_lemma_102468 (h0 : ring (boolean_algebra (ring (finset linarith.comp)))) : is_principal_ideal_ring (boolean_algebra (ring (finset linarith.comp))) := sorry --non-trivial
lemma new_lemma_102469 (h0 : complete_lattice (monoid ennreal)) : is_atomistic (monoid ennreal) := sorry --non-trivial
lemma new_lemma_102470 (h0 : topological_space (add_comm_semigroup (mul_one_class linarith.ineq))) : t0_space (add_comm_semigroup (mul_one_class linarith.ineq)) := sorry --non-trivial
lemma new_lemma_102471 (h0 : ring (distrib (mul_one_class (mul_one_class reducibility_hints)))) : is_domain (distrib (mul_one_class (mul_one_class reducibility_hints))) := sorry --non-trivial
lemma new_lemma_102472 (h0 : monoid (has_well_founded (option congr_arg_kind))) : monoid.fg (has_well_founded (option congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_102473 (h0 : topological_space (with_zero to_additive.value_type)) : totally_disconnected_space (with_zero to_additive.value_type) := sorry --non-trivial
lemma new_lemma_102474 (h0 : complete_lattice (has_to_string (option (option (option pos))))) : complete_lattice.is_Sup_finite_compact (has_to_string (option (option (option pos)))) := sorry --non-trivial
lemma new_lemma_102475 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @normal_space.{0} (normed_linear_ordered_group.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (normed_linear_ordered_group.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_102476 (h0 : ring (partial_order (semiring num))) : rank_condition (partial_order (semiring num)) := sorry --non-trivial
lemma new_lemma_102477 (h0 : topological_space (with_bot (has_norm linarith.comp))) : preirreducible_space (with_bot (has_norm linarith.comp)) := sorry --non-trivial
lemma new_lemma_102478 (h0 : add_monoid (has_top (metric_space linarith.comp))) : add_monoid.fg (has_top (metric_space linarith.comp)) := sorry --non-trivial
lemma new_lemma_102479 (h1 : uniform_space (has_add (random_gen char))) : complete_space (has_add (random_gen char)) := sorry --non-trivial
lemma new_lemma_102480 (h0 : ring (plift (has_edist (has_edist (option unsigned))))) : is_domain (plift (has_edist (has_edist (option unsigned)))) := sorry --non-trivial
lemma new_lemma_102481 (h0 : ereal -> ereal) (h3 : ereal) : function.is_fixed_pt h0 h3 := sorry --non-trivial
lemma new_lemma_102482 (h0 : monoid (id (semiring linarith.comp))) : monoid.fg (id (semiring linarith.comp)) := sorry --non-trivial
lemma new_lemma_102483 (h0 : function.extfun Type group) : @normalizer_condition.{0} (normed_comm_ring.{0} pos) (@function.extfun_app.{2 1} Type group.{0} h0 (normed_comm_ring.{0} pos))  := sorry --non-trivial
lemma new_lemma_102484 (h0 : topological_space std_gen) (h1 : has_mul std_gen) : subsingleton (has_continuous_mul std_gen) := sorry --non-trivial
lemma new_lemma_102485 (h0 : semiring (measurable_space.dynkin_system (semiring (semiring (semiring congr_arg_kind))))) : is_noetherian_ring (measurable_space.dynkin_system (semiring (semiring (semiring congr_arg_kind)))) := sorry --non-trivial
lemma new_lemma_102486 (h0 : functor.add_const (function.extfun Type add_monoid) empty) : @add_monoid.fg.{0} (has_Sup.{0} empty) (@function.extfun_app.{2 1} Type add_monoid.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type add_monoid.{0}) empty h0) (has_Sup.{0} empty))  := sorry --non-trivial
lemma new_lemma_102487 (h0 : functor.add_const (topological_space (has_add environment.implicit_infer_kind)) name) : @totally_separated_space.{0} (has_add.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (has_add.{0} environment.implicit_infer_kind)) name h0)  := sorry --non-trivial
lemma new_lemma_102488 (h0 : cancel_comm_monoid_with_zero (normed_comm_ring Type)) : unique_factorization_monoid (normed_comm_ring Type) := sorry --non-trivial
lemma new_lemma_102489 (h0 : topological_space (with_bot (has_norm num))) : path_connected_space (with_bot (has_norm num)) := sorry --non-trivial
lemma new_lemma_102490 (h1 : topological_space (encodable (has_nnnorm (has_nnnorm char)))) : totally_disconnected_space (encodable (has_nnnorm (has_nnnorm char))) := sorry --non-trivial
lemma new_lemma_102491 (h1 : complete_lattice (encodable (random_gen string_imp))) : is_compactly_generated (encodable (random_gen string_imp)) := sorry --non-trivial
lemma new_lemma_102492 (h0 : topological_space (complete_distrib_lattice (comm_semigroup linarith.comp))) : path_connected_space (complete_distrib_lattice (comm_semigroup linarith.comp)) := sorry --non-trivial
lemma new_lemma_102493 (h0 : function.extfun Type semiring) : @is_noetherian_ring.{0} (linear_ordered_comm_monoid_with_zero.{0} unsigned) (@function.extfun_app.{2 1} Type semiring.{0} h0 (linear_ordered_comm_monoid_with_zero.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_102494 (h0 : finset (semigroup linarith.comp)) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_102495 (h0 : functor.add_const (topological_space (has_add pos)) name) : @locally_compact_space.{0} (has_add.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (has_add.{0} pos)) name h0)  := sorry --non-trivial
lemma new_lemma_102496 (h0 : functor.add_const (finset (has_neg linarith.comp)) Type) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_102497 (h0 : ring (has_add ennreal)) : rank_condition (has_add ennreal) := sorry --non-trivial
lemma new_lemma_102498 (h0 : topological_space (has_nndist empty)) : irreducible_space (has_nndist empty) := sorry --non-trivial
lemma new_lemma_102499 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @locally_compact_space.{0} (group_with_zero.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (group_with_zero.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_102500 (h1 : topological_space (add_comm_semigroup char)) : regular_space (add_comm_semigroup char) := sorry --non-trivial
lemma new_lemma_102501 (h0 : uniform_space (pseudo_metric_space (option unsigned))) : separated_space (pseudo_metric_space (option unsigned)) := sorry --non-trivial
lemma new_lemma_102502 (h0 : fin has_zero.zero) : matrix.vec_empty (matrix.vec_empty (matrix.vec_empty (matrix.vec_empty h0))) := sorry --non-trivial
lemma new_lemma_102503 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_principal_ideal_ring.{0} (add_cancel_monoid.{0} num) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (add_cancel_monoid.{0} num))  := sorry --non-trivial
lemma new_lemma_102504 (h0 : function.extfun Type ring) : @is_principal_ideal_ring.{0} (sub_neg_monoid.{0} real) (@function.extfun_app.{2 1} Type ring.{0} h0 (sub_neg_monoid.{0} real))  := sorry --non-trivial
lemma new_lemma_102505 (h0 : topological_space (add_group (semiring (semiring (semiring unsigned))))) : totally_separated_space (add_group (semiring (semiring (semiring unsigned)))) := sorry --non-trivial
lemma new_lemma_102506 (h0 : group (has_div linarith.ineq)) (h1 : subgroup (has_div linarith.ineq)) : subgroup.normal h1 := sorry --non-trivial
lemma new_lemma_102507 (h0 : ring (generalized_boolean_algebra (has_neg (has_Inf (has_add (has_add pos)))))) : is_domain (generalized_boolean_algebra (has_neg (has_Inf (has_add (has_add pos))))) := sorry --non-trivial
lemma new_lemma_102508 (h0 : complete_lattice (dlist (random_gen linarith.ineq))) : is_compactly_generated (dlist (random_gen linarith.ineq)) := sorry --non-trivial
lemma new_lemma_102509 (h0 : ordered_add_comm_monoid (has_zero (has_add linarith.comp))) : archimedean (has_zero (has_add linarith.comp)) := sorry --non-trivial
lemma new_lemma_102510 (h0 : not (function.extfun Type ring -> false)) : @rank_condition.{0} (linear_ordered_comm_ring.{0} unsigned) (@function.extfun_app.{2 1} Type ring.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type ring.{0}) h0) (linear_ordered_comm_ring.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_102511 (h0 : ring (boolean_algebra (comm_group (has_to_string (comm_group unsigned))))) : strong_rank_condition (boolean_algebra (comm_group (has_to_string (comm_group unsigned)))) := sorry --non-trivial
lemma new_lemma_102512 (h0 : not (add_group (linear_ordered_add_comm_group char) -> false)) : @is_add_cyclic.{0} (linear_ordered_add_comm_group.{0} char) (@classical.by_contradiction'.{1} (add_group.{0} (linear_ordered_add_comm_group.{0} char)) h0)  := sorry --non-trivial
lemma new_lemma_102513 (h2 : set (simple_graph linarith.comp_source)) : set.finite h2 := sorry --non-trivial
lemma new_lemma_102514 (h0 : group (div_inv_monoid (random_gen string_imp))) : is_cyclic (div_inv_monoid (random_gen string_imp)) := sorry --non-trivial
lemma new_lemma_102515 (h0 : functor.add_const (group (finset Type)) name) : @group.fg.{1} (finset.{1} Type) (@functor.add_const.run.{1 0} (group.{1} (finset.{1} Type)) name h0)  := sorry --non-trivial
lemma new_lemma_102516 (h0 : function.extfun Type ordered_comm_monoid) : @has_exists_mul_of_le.{0} (has_add.{0} linarith.comp) (@function.extfun_app.{2 1} Type ordered_comm_monoid.{0} h0 (has_add.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_102517 (h0 : ring (has_star unsigned)) : rank_condition (has_star unsigned) := sorry --non-trivial
lemma new_lemma_102518 (h0 : function.extfun Type group) : @normalizer_condition.{0} (filter.{0} num) (@function.extfun_app.{2 1} Type group.{0} h0 (filter.{0} num))  := sorry --non-trivial
lemma new_lemma_102519 (h0 : topological_space (has_top (with_bot (with_bot string_imp)))) : totally_separated_space (has_top (with_bot (with_bot string_imp))) := sorry --non-trivial
lemma new_lemma_102520 (h4 : prod ereal ereal) : set.diagonal ereal h4 := sorry --non-trivial
lemma new_lemma_102521 (h0 : has_mem.mem (complete_semilattice_Sup linarith.comp_source) has_emptyc.emptyc) : @monoid.fg.{0} (complete_semilattice_Sup.{0} linarith.comp_source) (@finset.pi.empty.{1 0} Type monoid.{0} (complete_semilattice_Sup.{0} linarith.comp_source) h0)  := sorry --non-trivial
lemma new_lemma_102522 (h0 : functor.add_const (topological_space (boolean_algebra linarith.comp)) (finset linarith.comp)) : @topological_space.separable_space.{0} (boolean_algebra.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (boolean_algebra.{0} linarith.comp)) (finset.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_102523 (h0 : list (linear_ordered_comm_monoid_with_zero unsigned)) : palindrome h0 := sorry --non-trivial
lemma new_lemma_102524 (h0 : monoid (measurable_space (random_gen linarith.comp_source))) : monoid.fg (measurable_space (random_gen linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_102525 (h0 : complete_lattice (comm_ring (random_gen fun_info))) : complete_lattice.is_Sup_finite_compact (comm_ring (random_gen fun_info)) := sorry --non-trivial
lemma new_lemma_102526 (h0 : functor.add_const (uniform_space (semigroup pos)) linarith.comp) : @complete_space.{0} (semigroup.{0} pos) (@functor.add_const.run.{0 0} (uniform_space.{0} (semigroup.{0} pos)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_102527 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @normal_space.{0} (complete_distrib_lattice.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (complete_distrib_lattice.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_102528 (h0 : ring (has_bot (ordered_comm_monoid Type))) : is_principal_ideal_ring (has_bot (ordered_comm_monoid Type)) := sorry --non-trivial
lemma new_lemma_102529 (h0 : functor.add_const (topological_space (complete_linear_order unsigned)) unsigned) : @preirreducible_space.{0} (complete_linear_order.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (complete_linear_order.{0} unsigned)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_102530 (h0 : ordered_add_comm_monoid (ring (complete_distrib_lattice pos))) : archimedean (ring (complete_distrib_lattice pos)) := sorry --non-trivial
lemma new_lemma_102531 (h1 : topological_space (has_compl (random_gen string_imp))) : path_connected_space (has_compl (random_gen string_imp)) := sorry --non-trivial
lemma new_lemma_102532 (h0 : uniform_space (has_zero pos)) : separated_space (has_zero pos) := sorry --non-trivial
lemma new_lemma_102533 (h0 : topological_space (finset congr_arg_kind)) : t1_space (finset congr_arg_kind) := sorry --non-trivial
lemma new_lemma_102534 (h0 : function.extfun (((Type -> Type) -> Type 1) -> Type 1) (function.extfun ((Type -> Type) -> Type 1))) : @group.fg.{0} (distrib_lattice.{0} linarith.ineq) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) (@function.extfun_app.{3 2} ((Type → Type) → Type 1) (function.extfun.{2 2} (Type → Type)) (@function.extfun_app.{3 3} (((Type → Type) → Type 1) → Type 1) (function.extfun.{3 2} ((Type → Type) → Type 1)) h0 (function.extfun.{2 2} (Type → Type))) (function.extfun.{2 1} Type)) group.{0}) (distrib_lattice.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_102535 (h0 : function.extfun Type ring) : @is_domain.{0} (normed_comm_ring.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type ring.{0} h0 (normed_comm_ring.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_102536 (h0 : functor.add_const (uniform_space (has_nndist pos)) name) : @separated_space.{0} (has_nndist.{0} pos) (@functor.add_const.run.{0 0} (uniform_space.{0} (has_nndist.{0} pos)) name h0)  := sorry --non-trivial
lemma new_lemma_102537 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @t1_space.{0} (group_with_zero.{0} ennreal) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (group_with_zero.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_102538 (h0 : filter (has_neg (option ennreal))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_102539 (h0 : functor.add_const (ring (has_Inf real)) pos) : @strong_rank_condition.{0} (has_Inf.{0} real) (@functor.add_const.run.{0 0} (ring.{0} (has_Inf.{0} real)) pos h0)  := sorry --non-trivial
lemma new_lemma_102540 (h0 : filter (normed_comm_ring (finset linarith.comp))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_102541 (h0 : complete_lattice (has_emptyc (has_emptyc (has_inv fun_info)))) : complete_lattice.is_Sup_finite_compact (has_emptyc (has_emptyc (has_inv fun_info))) := sorry --non-trivial
lemma new_lemma_102542 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @has_exists_mul_of_le.{0} (normed_comm_ring.{0} linarith.comp) (@function.extfun_app.{2 1} Type ordered_comm_monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ordered_comm_monoid.{0}) (normed_comm_ring.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_102543 (h2 : not (topological_space (div_inv_monoid to_additive.value_type) -> false)) : @totally_disconnected_space.{0} (div_inv_monoid.{0} to_additive.value_type) (@classical.by_contradiction'.{1} (topological_space.{0} (div_inv_monoid.{0} to_additive.value_type)) h2)  := sorry --non-trivial
lemma new_lemma_102544 (h0 : group (measurable_space linarith.comp)) : is_cyclic (measurable_space linarith.comp) := sorry --non-trivial
lemma new_lemma_102545 (h0 : add_group (random_gen empty)) : is_add_cyclic (random_gen empty) := sorry --non-trivial
lemma new_lemma_102546 (h0 : complete_lattice (has_ssubset linarith.ineq)) : complete_lattice.is_Sup_finite_compact (has_ssubset linarith.ineq) := sorry --non-trivial
lemma new_lemma_102547 (h0 : functor.comp topological_space cancel_monoid name) : @loc_path_connected_space.{0} (cancel_monoid.{0} name) (@functor.comp.run.{0 0 0} topological_space.{0} cancel_monoid.{0} name h0)  := sorry --non-trivial
lemma new_lemma_102548 (h0 : not (topological_space (has_norm linarith.comp_source) -> false)) : @locally_compact_space.{0} (has_norm.{0} linarith.comp_source) (@classical.by_contradiction'.{1} (topological_space.{0} (has_norm.{0} linarith.comp_source)) h0)  := sorry --non-trivial
lemma new_lemma_102549 (h0 : functor.add_const (topological_space (has_neg_part environment.implicit_infer_kind)) name) : @t0_space.{0} (has_neg_part.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (has_neg_part.{0} environment.implicit_infer_kind)) name h0)  := sorry --non-trivial
lemma new_lemma_102550 (h0 : fin has_zero.zero) : @preconnected_space.{1} (has_pos_part.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) (@matrix.vec_empty.{2} (function.extfun.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1))) h0) topological_space.{1}) (has_pos_part.{1} Type))  := sorry --non-trivial
lemma new_lemma_102551 (h0 : not (complete_lattice (metric_space unsigned) -> false)) : @is_compactly_generated.{0} (metric_space.{0} unsigned) (@classical.by_contradiction'.{1} (complete_lattice.{0} (metric_space.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_102552 (h0 : function.extfun Type group) : @is_simple_group.{0} (complete_distrib_lattice.{0} linarith.comp) (@function.extfun_app.{2 1} Type group.{0} h0 (complete_distrib_lattice.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_102553 (h0 : group (ring (finset (finset Type)))) : group.fg (ring (finset (finset Type))) := sorry --non-trivial
lemma new_lemma_102554 (h0 : cancel_comm_monoid_with_zero (add_cancel_monoid (option (option empty)))) : unique_factorization_monoid (add_cancel_monoid (option (option empty))) := sorry --non-trivial
lemma new_lemma_102555 (h0 : not (function.extfun Type ring -> false)) : @is_domain.{0} string_imp (@function.extfun_app.{2 1} Type ring.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type ring.{0}) h0) string_imp)  := sorry --non-trivial
lemma new_lemma_102556 (h0 : monoid (cancel_monoid ennreal)) : monoid.fg (cancel_monoid ennreal) := sorry --non-trivial
lemma new_lemma_102557 (h0 : ordered_add_comm_monoid (has_zero (finset linarith.comp))) : archimedean (has_zero (finset linarith.comp)) := sorry --non-trivial
lemma new_lemma_102558 (h0 : monoid (has_top (random_gen congr_arg_kind))) : monoid.fg (has_top (random_gen congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_102559 (h0 : topological_space (boolean_algebra (comm_group environment.implicit_infer_kind))) : locally_compact_space (boolean_algebra (comm_group environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_102560 (h0 : complete_lattice (div_inv_monoid fun_info)) : complete_lattice.is_Sup_finite_compact (div_inv_monoid fun_info) := sorry --non-trivial
lemma new_lemma_102561 (h0 : group (has_norm unsigned)) : is_cyclic (has_norm unsigned) := sorry --non-trivial
lemma new_lemma_102562 (h0 : ring (has_Inf (has_add (finset real)))) : rank_condition (has_Inf (has_add (finset real))) := sorry --non-trivial
lemma new_lemma_102563 (h0 : functor.add_const (topological_space (ordered_comm_ring pos)) pos) : @preconnected_space.{0} (ordered_comm_ring.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (ordered_comm_ring.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_102564 (h0 : ring (distrib (has_ssubset char))) : strong_rank_condition (distrib (has_ssubset char)) := sorry --non-trivial
lemma new_lemma_102565 (h0 : topological_space (with_bot fun_info)) : totally_separated_space (with_bot fun_info) := sorry --non-trivial
lemma new_lemma_102566 (h0 : function.extfun Type ring) : @rank_condition.{0} (has_sub.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type ring.{0} h0 (has_sub.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_102567 (h3 : pseudo_metric_space (ordered_comm_ring (random_gen (random_gen char)))) (h4 : monoid (ordered_comm_ring (random_gen (random_gen char)))) : has_lipschitz_mul (ordered_comm_ring (random_gen (random_gen char))) := sorry --non-trivial
lemma new_lemma_102568 (h0 : Prop) (h1 : sym2 Prop) : sym2.mem h0 h1 := sorry --non-trivial
lemma new_lemma_102569 (h0 : topological_space (has_neg empty)) : t0_space (has_neg empty) := sorry --non-trivial
lemma new_lemma_102570 (h0 : functor.add_const (filter (add_comm_monoid pos)) name) : filter.ne_bot (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_102571 (h0 : topological_space (boolean_algebra name)) : t1_space (boolean_algebra name) := sorry --non-trivial
lemma new_lemma_102572 (h0 : monoid (linear_ordered_add_comm_group fun_info)) : monoid.fg (linear_ordered_add_comm_group fun_info) := sorry --non-trivial
lemma new_lemma_102573 (h0 : function.extfun Type topological_space) : @normal_space.{0} (generalized_boolean_algebra.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (generalized_boolean_algebra.{0} name))  := sorry --non-trivial
lemma new_lemma_102574 (h0 : finset (has_Inf (has_neg pos))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_102575 (h0 : function.extfun Type topological_space) : @t0_space.{0} (partial_order.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (partial_order.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_102576 (h0 : functor.add_const (function.extfun (Type 1) topological_space) Type) : @loc_path_connected_space.{1} (semigroup.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@functor.add_const.run.{2 1} (function.extfun.{3 2} (Type 1) topological_space.{1}) Type h0) (semigroup.{1} Type))  := sorry --non-trivial
lemma new_lemma_102577 (h0 : uniform_space (denumerable (comm_ring char))) : complete_space (denumerable (comm_ring char)) := sorry --non-trivial
lemma new_lemma_102578 (h0 : functor.add_const (group (option num)) num) : @group.fg.{0} (option.{0} num) (@functor.add_const.run.{0 0} (group.{0} (option.{0} num)) num h0)  := sorry --non-trivial
lemma new_lemma_102579 (h0 : add_group (complete_semilattice_Sup (has_top linarith.comp_source))) : is_add_cyclic (complete_semilattice_Sup (has_top linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_102580 (h6 : set (ereal -> char)) : set.separates_points h6 := sorry --non-trivial
lemma new_lemma_102581 (h0 : uniform_space (ring (has_Inf (has_Inf (has_Inf pos))))) : complete_space (ring (has_Inf (has_Inf (has_Inf pos)))) := sorry --non-trivial
lemma new_lemma_102582 (h0 : topological_space (has_nndist (finset name))) : irreducible_space (has_nndist (finset name)) := sorry --non-trivial
lemma new_lemma_102583 (h0 : list (has_star unsigned)) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_102584 (h0 : topological_space (canonically_ordered_monoid (has_Inf pos))) : topological_space.separable_space (canonically_ordered_monoid (has_Inf pos)) := sorry --non-trivial
lemma new_lemma_102585 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @complete_space.{0} (ordered_comm_ring.{0} real) (@function.extfun_app.{2 1} Type uniform_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 uniform_space.{0}) (ordered_comm_ring.{0} real))  := sorry --non-trivial
lemma new_lemma_102586 (h0 : functor.add_const (function.extfun Type ring) (finset linarith.comp)) : @is_principal_ideal_ring.{0} (simple_graph.{0} pos) (@function.extfun_app.{2 1} Type ring.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type ring.{0}) (finset.{0} linarith.comp) h0) (simple_graph.{0} pos))  := sorry --non-trivial
lemma new_lemma_102587 (h0 : filter (topological_space linarith.ineq)) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_102588 (h0 : uniform_space (has_add (normed_comm_ring pos))) : complete_space (has_add (normed_comm_ring pos)) := sorry --non-trivial
lemma new_lemma_102589 (h0 : uniform_space (metric_space (metric_space num))) : complete_space (metric_space (metric_space num)) := sorry --non-trivial
lemma new_lemma_102590 (h0 : list (left_cancel_monoid (option unsigned))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_102591 (h0 : group (has_add (with_zero linarith.comp_source))) : is_cyclic (has_add (with_zero linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_102592 (h0 : add_group (linear_ordered_field pos)) : is_add_cyclic (linear_ordered_field pos) := sorry --non-trivial
lemma new_lemma_102593 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @totally_separated_space.{0} (has_inter.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_inter.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_102594 (h0 : function.extfun Type list) : palindrome (function.extfun_app h0 (has_Sup congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_102595 (h3 : group (random_gen char)) : is_cyclic (random_gen char) := sorry --non-trivial
lemma new_lemma_102596 (h0 : ring (normed_group (option unsigned))) : strong_rank_condition (normed_group (option unsigned)) := sorry --non-trivial
lemma new_lemma_102597 (h0 : complete_lattice (has_top (random_gen (has_inv (has_inv to_additive.value_type))))) : is_atomistic (has_top (random_gen (has_inv (has_inv to_additive.value_type)))) := sorry --non-trivial
lemma new_lemma_102598 (h0 : ring (normed_comm_ring (finset (finset (finset (finset pos)))))) : rank_condition (normed_comm_ring (finset (finset (finset (finset pos))))) := sorry --non-trivial
lemma new_lemma_102599 (h0 : ring (metric_space (denumerable linarith.comp_source))) : is_domain (metric_space (denumerable linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_102600 (h0 : functor.add_const (topological_space (linear_ordered_cancel_comm_monoid unsigned)) empty) : @locally_compact_space.{0} (linear_ordered_cancel_comm_monoid.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (linear_ordered_cancel_comm_monoid.{0} unsigned)) empty h0)  := sorry --non-trivial
lemma new_lemma_102601 (h0 : ring (has_neg (finset (has_Inf (has_neg (finset (has_pos_part Type))))))) : is_principal_ideal_ring (has_neg (finset (has_Inf (has_neg (finset (has_pos_part Type)))))) := sorry --non-trivial
lemma new_lemma_102602 (h0 : ring (measurable_space (semiring empty))) : is_domain (measurable_space (semiring empty)) := sorry --non-trivial
lemma new_lemma_102603 (h0 : topological_space (has_nndist (has_to_string Type))) : preconnected_space (has_nndist (has_to_string Type)) := sorry --non-trivial
lemma new_lemma_102604 (h0 : monoid (measurable_space.dynkin_system (semiring (semiring empty)))) : monoid.fg (measurable_space.dynkin_system (semiring (semiring empty))) := sorry --non-trivial
lemma new_lemma_102605 (h0 : not (function.extfun Type monoid -> false)) : @monoid.fg.{0} (with_bot.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type monoid.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type monoid.{0}) h0) (with_bot.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_102606 (h0 : group (linear_ordered_comm_ring num)) : normalizer_condition (linear_ordered_comm_ring num) := sorry --non-trivial
lemma new_lemma_102607 (h0 : fin has_zero.zero) : @totally_disconnected_space.{0} (has_Inf.{0} linarith.comp) (@matrix.vec_empty.{0} (topological_space.{0} (has_Inf.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_102608 (h0 : uniform_space (with_bot (semiring (semiring unsigned)))) : complete_space (with_bot (semiring (semiring unsigned))) := sorry --non-trivial
lemma new_lemma_102609 (h0 : functor.add_const (uniform_space (simple_graph linarith.comp)) linarith.comp) : @separated_space.{0} (simple_graph.{0} linarith.comp) (@functor.add_const.run.{0 0} (uniform_space.{0} (simple_graph.{0} linarith.comp)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_102610 (h0 : not (function.extfun Type finset -> false)) : finset.nonempty (function.extfun_app (classical.by_contradiction' h0) (option empty)) := sorry --non-trivial
lemma new_lemma_102611 (h0 : topological_space (has_top (semiring (has_norm (semiring num))))) : totally_disconnected_space (has_top (semiring (has_norm (semiring num)))) := sorry --non-trivial
lemma new_lemma_102612 (h0 : uniform_space (comm_group Type)) : separated_space (comm_group Type) := sorry --non-trivial
lemma new_lemma_102613 (h0 : ordered_comm_monoid (semigroup (has_neg linarith.comp))) : has_exists_mul_of_le (semigroup (has_neg linarith.comp)) := sorry --non-trivial
lemma new_lemma_102614 (h0 : has_mem.mem (normed_group fun_info) has_emptyc.emptyc) : @rank_condition.{0} (normed_group.{0} fun_info) (@finset.pi.empty.{1 0} Type ring.{0} (normed_group.{0} fun_info) h0)  := sorry --non-trivial
lemma new_lemma_102615 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @unique_factorization_monoid.{0} name (@function.extfun_app.{2 1} Type cancel_comm_monoid_with_zero.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 cancel_comm_monoid_with_zero.{0}) name)  := sorry --non-trivial
lemma new_lemma_102616 (h0 : finset (has_Inf (has_neg (ring (ring (ordered_ring Type)))))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_102617 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @locally_compact_space.{1} (has_zero.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 topological_space.{1}) (has_zero.{1} Type))  := sorry --non-trivial
lemma new_lemma_102618 (h0 : topological_space (linear_ordered_add_comm_monoid_with_top name)) : topological_space.separable_space (linear_ordered_add_comm_monoid_with_top name) := sorry --non-trivial
lemma new_lemma_102619 (h0 : cancel_comm_monoid_with_zero (add_group empty)) : unique_factorization_monoid (add_group empty) := sorry --non-trivial
lemma new_lemma_102620 (h0 : function.extfun Type ordered_add_comm_monoid) : @archimedean.{0} (has_to_string.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type ordered_add_comm_monoid.{0} h0 (has_to_string.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_102621 (h3 : semiring (nondiscrete_normed_field linarith.ineq)) (h4 : ideal (nondiscrete_normed_field linarith.ineq)) : ideal.is_prime h4 := sorry --non-trivial
lemma new_lemma_102622 (h0 : group (cancel_monoid (comm_group name))) : is_cyclic (cancel_monoid (comm_group name)) := sorry --non-trivial
lemma new_lemma_102623 (h0 : functor.add_const (topological_space (simple_graph Type)) (has_add Type)) : @path_connected_space.{1} (simple_graph.{1} Type) (@functor.add_const.run.{1 1} (topological_space.{1} (simple_graph.{1} Type)) (has_add.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_102624 (h1 : ring (linear_ordered_add_comm_group (random_gen (random_gen char)))) : rank_condition (linear_ordered_add_comm_group (random_gen (random_gen char))) := sorry --non-trivial
lemma new_lemma_102625 (h0 : not (ring congr_arg_kind -> false)) : @rank_condition.{0} congr_arg_kind (@classical.by_contradiction'.{1} (ring.{0} congr_arg_kind) h0)  := sorry --non-trivial
lemma new_lemma_102626 (h0 : ring (has_inv (has_top (random_gen (random_gen (random_gen (has_norm string_imp))))))) : is_domain (has_inv (has_top (random_gen (random_gen (random_gen (has_norm string_imp)))))) := sorry --non-trivial
lemma new_lemma_102627 (h0 : fin has_zero.zero) : @t1_space.{1} (add_comm_monoid.{1} Type) (@matrix.vec_empty.{1} (topological_space.{1} (add_comm_monoid.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_102628 (h0 : topological_space (finset (has_pos_part (finset (finset linarith.comp))))) : totally_disconnected_space (finset (has_pos_part (finset (finset linarith.comp)))) := sorry --non-trivial
lemma new_lemma_102629 (h0 : group (has_union unsigned)) : normalizer_condition (has_union unsigned) := sorry --non-trivial
lemma new_lemma_102630 (h0 : functor.comp ring boolean_algebra.core environment.implicit_infer_kind) : @is_principal_ideal_ring.{0} (boolean_algebra.core.{0} environment.implicit_infer_kind) (@functor.comp.run.{0 0 0} ring.{0} boolean_algebra.core.{0} environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_102631 (h0 : functor.add_const (topological_space (semiring empty)) empty) : @t0_space.{0} (semiring.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (semiring.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_102632 (h0 : not (function.extfun Type ring -> false)) : @is_domain.{0} (has_top.{0} empty) (@function.extfun_app.{2 1} Type ring.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type ring.{0}) h0) (has_top.{0} empty))  := sorry --non-trivial
lemma new_lemma_102633 (h0 : functor.add_const (function.extfun Type topological_space) name) : @preconnected_space.{0} (boolean_algebra.core.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) name h0) (boolean_algebra.core.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_102634 (h0 : topological_space (finset (has_add (has_add (has_add Type))))) : preirreducible_space (finset (has_add (has_add (has_add Type)))) := sorry --non-trivial
lemma new_lemma_102635 (h0 : ring (linear_ordered_semiring (random_gen linarith.comp_source))) : strong_rank_condition (linear_ordered_semiring (random_gen linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_102636 (h0 : functor.add_const (filter (complete_linear_order num)) unsigned) : filter.ne_bot (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_102637 (h0 : uniform_space (topological_space (random_gen linarith.ineq))) : complete_space (topological_space (random_gen linarith.ineq)) := sorry --non-trivial
lemma new_lemma_102638 (h0 : functor.add_const (cancel_comm_monoid_with_zero (has_Inf pos)) (ring pos)) : @unique_factorization_monoid.{0} (has_Inf.{0} pos) (@functor.add_const.run.{0 0} (cancel_comm_monoid_with_zero.{0} (has_Inf.{0} pos)) (ring.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_102639 (h0 : fin has_zero.zero) : @path_connected_space.{0} (has_nndist.{0} linarith.comp) (@matrix.vec_empty.{0} (topological_space.{0} (has_nndist.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_102640 (h0 : topological_space (add_cancel_monoid (option num))) : path_connected_space (add_cancel_monoid (option num)) := sorry --non-trivial
lemma new_lemma_102641 (h0 : finset (linear_ordered_field (option num))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_102642 (h0 : function.extfun nat fin) : @separated_space.{0} (has_add.{0} pos) (@matrix.vec_empty.{0} (uniform_space.{0} (has_add.{0} pos)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_102643 (h0 : functor.add_const (topological_space (cancel_monoid ennreal)) name) : @preconnected_space.{0} (cancel_monoid.{0} ennreal) (@functor.add_const.run.{0 0} (topological_space.{0} (cancel_monoid.{0} ennreal)) name h0)  := sorry --non-trivial
lemma new_lemma_102644 (h0 : function.extfun Type topological_space) : @locally_compact_space.{0} (cancel_monoid.{0} ennreal) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (cancel_monoid.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_102645 (h0 : finset (canonically_ordered_comm_semiring environment.implicit_infer_kind)) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_102646 (h0 : not (function.extfun Type ring -> false)) : @is_domain.{0} (has_one.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type ring.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type ring.{0}) h0) (has_one.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_102647 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @normal_space.{0} (ordered_cancel_add_comm_monoid.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (ordered_cancel_add_comm_monoid.{0} empty))  := sorry --non-trivial
lemma new_lemma_102648 (h1 : ring (fintype (has_nnnorm (has_nnnorm to_additive.value_type)))) : strong_rank_condition (fintype (has_nnnorm (has_nnnorm to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_102649 (h0 : topological_space (has_one (id environment.implicit_infer_kind))) : locally_compact_space (has_one (id environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_102650 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @totally_disconnected_space.{0} (boolean_algebra.core.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (boolean_algebra.core.{0} pos))  := sorry --non-trivial
lemma new_lemma_102651 (h0 : topological_space (has_add (has_Inf Type))) : path_connected_space (has_add (has_Inf Type)) := sorry --non-trivial
lemma new_lemma_102652 (h0 : topological_space (linear_ordered_cancel_comm_monoid unsigned)) : normal_space (linear_ordered_cancel_comm_monoid unsigned) := sorry --non-trivial
lemma new_lemma_102653 (h0 : topological_space (has_div (mul_one_class enat))) : path_connected_space (has_div (mul_one_class enat)) := sorry --non-trivial
lemma new_lemma_102654 (h1 : group (topological_space (has_nnnorm string_imp))) : is_cyclic (topological_space (has_nnnorm string_imp)) := sorry --non-trivial
lemma new_lemma_102655 (h0 : functor.add_const (topological_space (ordered_comm_group unsigned)) unsigned) : @t1_space.{0} (ordered_comm_group.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (ordered_comm_group.{0} unsigned)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_102656 (h0 : functor.add_const (add_group pos) Type) : @is_add_cyclic.{0} pos (@functor.add_const.run.{0 1} (add_group.{0} pos) Type h0)  := sorry --non-trivial
lemma new_lemma_102657 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : finset.nonempty (function.extfun_app (function.extfun_app h0 finset) (has_inter congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_102658 (h0 : not (ring (linear_ordered_comm_ring empty) -> false)) : @is_principal_ideal_ring.{0} (linear_ordered_comm_ring.{0} empty) (@classical.by_contradiction'.{1} (ring.{0} (linear_ordered_comm_ring.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_102659 (h0 : topological_space (semigroup (finset linarith.comp))) : t0_space (semigroup (finset linarith.comp)) := sorry --non-trivial
lemma new_lemma_102660 (h1 : topological_space ereal) : topological_space.first_countable_topology ereal := sorry --non-trivial
lemma new_lemma_102661 (h0 : functor.add_const (topological_space (has_nndist name)) linarith.comp) : @irreducible_space.{0} (has_nndist.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (has_nndist.{0} name)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_102662 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @rank_condition.{0} (has_bot.{0} pos) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (has_bot.{0} pos))  := sorry --non-trivial
lemma new_lemma_102663 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_cyclic.{0} (has_neg.{0} pos) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (has_neg.{0} pos))  := sorry --non-trivial
lemma new_lemma_102664 (h2 : complete_lattice (distrib linarith.comp_source)) : complete_lattice.is_Sup_finite_compact (distrib linarith.comp_source) := sorry --non-trivial
lemma new_lemma_102665 (h0 : finset (id linarith.comp)) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_102666 (h0 : topological_space (distrib (comm_ring linarith.ineq))) : totally_disconnected_space (distrib (comm_ring linarith.ineq)) := sorry --non-trivial
lemma new_lemma_102667 (h0 : ring (has_star (has_norm empty))) : rank_condition (has_star (has_norm empty)) := sorry --non-trivial
lemma new_lemma_102668 (h0 : functor.add_const (topological_space (boolean_algebra Type)) environment.implicit_infer_kind) : @t1_space.{1} (boolean_algebra.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (boolean_algebra.{1} Type)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_102669 (h0 : fin has_zero.zero) : @preirreducible_space.{0} (ordered_comm_monoid.{0} real) (@matrix.vec_empty.{0} (topological_space.{0} (ordered_comm_monoid.{0} real)) (@matrix.vec_empty.{0} (fin (@has_zero.zero.{0} nat nat.has_zero)) h0))  := sorry --non-trivial
lemma new_lemma_102670 (h0 : uniform_space (mul_one_class string_imp)) : complete_space (mul_one_class string_imp) := sorry --non-trivial
lemma new_lemma_102671 (h0 : topological_space (boolean_algebra (finset (has_neg pos)))) : preirreducible_space (boolean_algebra (finset (has_neg pos))) := sorry --non-trivial
lemma new_lemma_102672 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_compactly_generated.{0} (pseudo_metric_space.{0} pos) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (pseudo_metric_space.{0} pos))  := sorry --non-trivial
lemma new_lemma_102673 (h0 : function.extfun Type topological_space) : @regular_space.{0} (boolean_algebra.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (boolean_algebra.{0} pos))  := sorry --non-trivial
lemma new_lemma_102674 (h0 : topological_space num) : totally_separated_space num := sorry --non-trivial
lemma new_lemma_102675 (h0 : add_group (distrib (has_nnnorm (has_nnnorm linarith.ineq)))) : is_add_cyclic (distrib (has_nnnorm (has_nnnorm linarith.ineq))) := sorry --non-trivial
lemma new_lemma_102676 (h0 : functor.add_const (topological_space (has_edist num)) empty) : @t0_space.{0} (has_edist.{0} num) (@functor.add_const.run.{0 0} (topological_space.{0} (has_edist.{0} num)) empty h0)  := sorry --non-trivial
lemma new_lemma_102677 (h0 : functor.add_const (ordered_comm_monoid (finset linarith.comp)) (has_neg Type)) : @has_exists_mul_of_le.{0} (finset.{0} linarith.comp) (@functor.add_const.run.{0 1} (ordered_comm_monoid.{0} (finset.{0} linarith.comp)) (has_neg.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_102678 (h0 : function.extfun Type ring) : @is_principal_ideal_ring.{0} (option.{0} num) (@function.extfun_app.{2 1} Type ring.{0} h0 (option.{0} num))  := sorry --non-trivial
lemma new_lemma_102679 (h0 : add_group (ring (has_Inf linarith.comp))) : is_add_cyclic (ring (has_Inf linarith.comp)) := sorry --non-trivial
lemma new_lemma_102680 (h0 : function.extfun Type complete_lattice) : @complete_lattice.is_Sup_finite_compact.{0} (boolean_algebra.core.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (boolean_algebra.core.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_102681 (h0 : uniform_space (generalized_boolean_algebra (has_add (has_Inf Type)))) : complete_space (generalized_boolean_algebra (has_add (has_Inf Type))) := sorry --non-trivial
lemma new_lemma_102682 (h0 : semiring (normed_comm_ring (has_to_string (comm_group (has_add unsigned))))) : is_noetherian_ring (normed_comm_ring (has_to_string (comm_group (has_add unsigned)))) := sorry --non-trivial
lemma new_lemma_102683 (h0 : topological_space (simple_graph (finset pos))) : discrete_topology (simple_graph (finset pos)) := sorry --non-trivial
lemma new_lemma_102684 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_principal_ideal_ring.{0} (pseudo_metric_space.{0} pos) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (pseudo_metric_space.{0} pos))  := sorry --non-trivial
lemma new_lemma_102685 (h0 : monoid (canonically_ordered_comm_semiring empty)) : monoid.fg (canonically_ordered_comm_semiring empty) := sorry --non-trivial
lemma new_lemma_102686 (h0 : topological_space (has_Inf (has_add (has_Inf Type)))) : sequential_space (has_Inf (has_add (has_Inf Type))) := sorry --non-trivial
lemma new_lemma_102687 (h0 : semiring (free_add_monoid (has_inner empty congr_arg_kind))) : is_noetherian_ring (free_add_monoid (has_inner empty congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_102688 (h0 : num -> num -> num) : is_right_cancel num h0 := sorry --non-trivial
lemma new_lemma_102689 (h0 : function.extfun Type complete_lattice) : @is_compactly_generated.{0} (has_add.{0} pos) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (has_add.{0} pos))  := sorry --non-trivial
lemma new_lemma_102690 (h1 : uniform_space (non_unital_non_assoc_semiring (uniform_space (mul_one_class string_imp)))) : complete_space (non_unital_non_assoc_semiring (uniform_space (mul_one_class string_imp))) := sorry --non-trivial
lemma new_lemma_102691 (h0 : add_group (id congr_arg_kind)) : is_add_cyclic (id congr_arg_kind) := sorry --non-trivial
lemma new_lemma_102692 (h0 : ring (complete_semilattice_Sup (has_nnnorm (has_nnnorm (random_gen fun_info))))) : is_domain (complete_semilattice_Sup (has_nnnorm (has_nnnorm (random_gen fun_info)))) := sorry --non-trivial
lemma new_lemma_102693 (h0 : not (topological_space (has_emptyc (random_gen fun_info)) -> false)) : @totally_separated_space.{0} (has_emptyc.{0} (random_gen.{0} fun_info)) (@classical.by_contradiction'.{1} (topological_space.{0} (has_emptyc.{0} (random_gen.{0} fun_info))) h0)  := sorry --non-trivial
lemma new_lemma_102694 (h1 : topological_space (with_zero (has_nnnorm char))) : path_connected_space (with_zero (has_nnnorm char)) := sorry --non-trivial
lemma new_lemma_102695 (h0 : topological_space (canonically_linear_ordered_monoid name)) : totally_separated_space (canonically_linear_ordered_monoid name) := sorry --non-trivial
lemma new_lemma_102696 (h0 : ring (has_compl (random_gen linarith.comp_source))) : rank_condition (has_compl (random_gen linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_102697 (h0 : add_group (ordered_comm_ring (has_add Type))) : is_add_cyclic (ordered_comm_ring (has_add Type)) := sorry --non-trivial
lemma new_lemma_102698 (h0 : ring (has_compl (has_nnnorm enat))) : strong_rank_condition (has_compl (has_nnnorm enat)) := sorry --non-trivial
lemma new_lemma_102699 (h0 : not (complete_lattice (semi_normed_comm_ring fun_info) -> false)) : @is_compactly_generated.{0} (semi_normed_comm_ring.{0} fun_info) (@classical.by_contradiction'.{1} (complete_lattice.{0} (semi_normed_comm_ring.{0} fun_info)) h0)  := sorry --non-trivial
lemma new_lemma_102700 (h0 : functor.add_const (topological_space (complete_distrib_lattice unsigned)) num) : @locally_compact_space.{0} (complete_distrib_lattice.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (complete_distrib_lattice.{0} unsigned)) num h0)  := sorry --non-trivial
lemma new_lemma_102701 (h0 : topological_space environment.implicit_infer_kind) : regular_space environment.implicit_infer_kind := sorry --non-trivial
lemma new_lemma_102702 (h0 : complete_lattice (has_one (semiring (semiring empty)))) : is_atomistic (has_one (semiring (semiring empty))) := sorry --non-trivial
lemma new_lemma_102703 (h0 : functor.add_const (function.extfun Type monoid) Type) : @monoid.fg.{0} (comm_group.{0} pos) (@function.extfun_app.{2 1} Type monoid.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type monoid.{0}) Type h0) (comm_group.{0} pos))  := sorry --non-trivial
lemma new_lemma_102704 (h0 : functor.add_const (list (monoid_with_zero unsigned)) pos) : palindrome (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_102705 (h0 : functor.comp ring has_ssubset string_imp) : @rank_condition.{0} (has_ssubset.{0} string_imp) (@functor.comp.run.{0 0 0} ring.{0} has_ssubset.{0} string_imp h0)  := sorry --non-trivial
lemma new_lemma_102706 (h0 : functor.add_const (topological_space (omega_complete_partial_order unsigned)) unsigned) : @topological_space.separable_space.{0} (omega_complete_partial_order.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (omega_complete_partial_order.{0} unsigned)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_102707 (h0 : topological_space (has_neg (has_add ennreal))) : preirreducible_space (has_neg (has_add ennreal)) := sorry --non-trivial
lemma new_lemma_102708 (h0 : add_monoid (is_R_or_C (option unsigned))) : add_monoid.fg (is_R_or_C (option unsigned)) := sorry --non-trivial
lemma new_lemma_102709 (h0 : group (comm_group (semigroup environment.implicit_infer_kind))) : is_simple_group (comm_group (semigroup environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_102710 (h0 : functor.add_const (topological_space (boolean_algebra name)) name) : @preconnected_space.{0} (boolean_algebra.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (boolean_algebra.{0} name)) name h0)  := sorry --non-trivial
lemma new_lemma_102711 (h0 : uniform_space (normed_group empty)) : separated_space (normed_group empty) := sorry --non-trivial
lemma new_lemma_102712 (h1 : add_group (has_emptyc num)) : is_add_cyclic (has_emptyc num) := sorry --non-trivial
lemma new_lemma_102713 (h0 : topological_space (denumerable to_additive.value_type)) : totally_disconnected_space (denumerable to_additive.value_type) := sorry --non-trivial
lemma new_lemma_102714 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @regular_space.{0} (cancel_monoid.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (cancel_monoid.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_102715 (h0 : topological_space (add_cancel_monoid (has_neg (has_neg (has_neg linarith.comp))))) : path_connected_space (add_cancel_monoid (has_neg (has_neg (has_neg linarith.comp)))) := sorry --non-trivial
lemma new_lemma_102716 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : list.nodup (function.extfun_app (function.extfun_app h0 list) (add_cancel_monoid linarith.comp)) := sorry --non-trivial
lemma new_lemma_102717 (h1 : topological_space (has_compl char)) : t0_space (has_compl char) := sorry --non-trivial
lemma new_lemma_102718 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @archimedean.{0} (has_add.{0} name) (@function.extfun_app.{2 1} Type ordered_add_comm_monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ordered_add_comm_monoid.{0}) (has_add.{0} name))  := sorry --non-trivial
lemma new_lemma_102719 (h0 : not (function.extfun Type group -> false)) : @normalizer_condition.{0} (has_top.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type group.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type group.{0}) h0) (has_top.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_102720 (h0 : function.extfun Type group) : @normalizer_condition.{0} (mul_zero_class.{0} empty) (@function.extfun_app.{2 1} Type group.{0} h0 (mul_zero_class.{0} empty))  := sorry --non-trivial
lemma new_lemma_102721 (h0 : functor.add_const Prop (finset Type)) : functor.add_const.run h0 := sorry --non-trivial
lemma new_lemma_102722 (h0 : topological_space (boolean_algebra name)) : discrete_topology (boolean_algebra name) := sorry --non-trivial
lemma new_lemma_102723 (h0 : group (generalized_boolean_algebra linarith.comp)) : normalizer_condition (generalized_boolean_algebra linarith.comp) := sorry --non-trivial
lemma new_lemma_102724 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_noetherian_ring.{0} (canonically_linear_ordered_monoid.{0} pos) (@function.extfun_app.{2 1} Type semiring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 semiring.{0}) (canonically_linear_ordered_monoid.{0} pos))  := sorry --non-trivial
lemma new_lemma_102725 (h4 : topological_space (add_cancel_comm_monoid char)) : totally_disconnected_space (add_cancel_comm_monoid char) := sorry --non-trivial
lemma new_lemma_102726 (h0 : functor.add_const (topological_space (has_neg unsigned)) pos) : @loc_path_connected_space.{0} (has_neg.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (has_neg.{0} unsigned)) pos h0)  := sorry --non-trivial
lemma new_lemma_102727 (h0 : function.extfun Type add_group) : @is_add_cyclic.{0} empty (@function.extfun_app.{2 1} Type add_group.{0} h0 empty)  := sorry --non-trivial
lemma new_lemma_102728 (h0 : ring (normed_group (semiring (semiring (semiring (semiring linarith.comp)))))) : rank_condition (normed_group (semiring (semiring (semiring (semiring linarith.comp))))) := sorry --non-trivial
lemma new_lemma_102729 (h0 : functor.add_const (complete_lattice (semigroup unsigned)) unsigned) : @complete_lattice.is_Sup_finite_compact.{0} (semigroup.{0} unsigned) (@functor.add_const.run.{0 0} (complete_lattice.{0} (semigroup.{0} unsigned)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_102730 (h0 : complete_lattice (measurable_space fun_info)) : complete_lattice.is_Sup_finite_compact (measurable_space fun_info) := sorry --non-trivial
lemma new_lemma_102731 (h0 : ordered_comm_monoid (ordered_comm_ring (has_add real))) : has_exists_mul_of_le (ordered_comm_ring (has_add real)) := sorry --non-trivial
lemma new_lemma_102732 (h0 : has_mem.mem (semiring linarith.comp_source) has_emptyc.emptyc) : @group.fg.{0} (semiring.{0} linarith.comp_source) (@finset.pi.empty.{1 0} Type group.{0} (semiring.{0} linarith.comp_source) h0)  := sorry --non-trivial
lemma new_lemma_102733 (h0 : topological_space (has_to_string (has_add unsigned))) : irreducible_space (has_to_string (has_add unsigned)) := sorry --non-trivial
lemma new_lemma_102734 (h0 : function.extfun Type group) : @is_cyclic.{0} (semiring.{0} unsigned) (@function.extfun_app.{2 1} Type group.{0} h0 (semiring.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_102735 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @unique_factorization_monoid.{0} (linear_ordered_semiring.{0} empty) (@function.extfun_app.{2 1} Type cancel_comm_monoid_with_zero.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 cancel_comm_monoid_with_zero.{0}) (linear_ordered_semiring.{0} empty))  := sorry --non-trivial
lemma new_lemma_102736 (h0 : group (boolean_algebra (boolean_algebra.core environment.implicit_infer_kind))) : group.fg (boolean_algebra (boolean_algebra.core environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_102737 (h0 h1 : multiset (mul_one_class (mul_one_class string_imp))) : multiset.disjoint h0 h1 := sorry --non-trivial
lemma new_lemma_102738 (h0 : set (normed_field (normed_field (normed_field (normed_field string_imp))) -> reducibility_hints)) : set.separates_points h0 := sorry --non-trivial
lemma new_lemma_102739 (h0 : functor.add_const (topological_space (boolean_algebra name)) (has_neg (semigroup linarith.comp))) : @sequential_space.{0} (boolean_algebra.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (boolean_algebra.{0} name)) (has_neg.{0} (semigroup.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_102740 (h0 : semiring (option empty)) : is_noetherian_ring (option empty) := sorry --non-trivial
lemma new_lemma_102741 (h0 : functor.add_const (prod (ordered_cancel_add_comm_monoid name) (ordered_cancel_add_comm_monoid name)) unsigned) : id_rel (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_102742 (h0 : not (complete_lattice (measurable_space fun_info) -> false)) : is_atomistic (measurable_space fun_info) := sorry --non-trivial
lemma new_lemma_102743 (h0 : group (ordered_comm_monoid name)) : group.fg (ordered_comm_monoid name) := sorry --non-trivial
lemma new_lemma_102744 (h0 : function.extfun Type topological_space) : @preirreducible_space.{0} (has_neg_part.{0} (has_nndist.{0} name)) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_neg_part.{0} (has_nndist.{0} name)))  := sorry --non-trivial
lemma new_lemma_102745 (h0 : function.extfun nat fin) : @t1_space.{0} (ordered_comm_ring.{0} name) (@matrix.vec_empty.{0} (topological_space.{0} (ordered_comm_ring.{0} name)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_102746 (h0 : topological_space (generalized_boolean_algebra (has_neg Type))) : t1_space (generalized_boolean_algebra (has_neg Type)) := sorry --non-trivial
lemma new_lemma_102747 (h0 : functor.add_const (ordered_add_comm_monoid (ring linarith.comp)) name) : @archimedean.{0} (ring.{0} linarith.comp) (@functor.add_const.run.{0 0} (ordered_add_comm_monoid.{0} (ring.{0} linarith.comp)) name h0)  := sorry --non-trivial
lemma new_lemma_102748 (h0 : complete_lattice (semi_normed_ring (has_ssubset reducibility_hints))) : complete_lattice.is_Sup_finite_compact (semi_normed_ring (has_ssubset reducibility_hints)) := sorry --non-trivial
lemma new_lemma_102749 (h0 : topological_space (normed_lattice_add_comm_group (finset pos))) : topological_space.separable_space (normed_lattice_add_comm_group (finset pos)) := sorry --non-trivial
lemma new_lemma_102750 (h0 : function.extfun (finset Type) (has_mem.mem (complete_semilattice_Sup linarith.comp_source))) : @is_cyclic.{0} (complete_semilattice_Sup.{0} linarith.comp_source) (@finset.pi.empty.{1 0} Type group.{0} (complete_semilattice_Sup.{0} linarith.comp_source) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (complete_semilattice_Sup.{0} linarith.comp_source)) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_102751 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @strong_rank_condition.{0} (semiring.{0} empty) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (semiring.{0} empty))  := sorry --non-trivial
lemma new_lemma_102752 (h0 : not (filter (denumerable (has_inv (linear_ordered_add_comm_group linarith.comp_source))) -> false)) : filter.ne_bot (classical.by_contradiction' h0) := sorry --non-trivial
lemma new_lemma_102753 (h0 : topological_space (plift (option unsigned))) : t0_space (plift (option unsigned)) := sorry --non-trivial
lemma new_lemma_102754 (h0 : ring (ring linarith.comp)) : rank_condition (ring linarith.comp) := sorry --non-trivial
lemma new_lemma_102755 (h0 : functor.add_const (filter (has_pos_part linarith.comp)) (finset (ring pos))) : countable_Inter_filter (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_102756 (h0 : functor.add_const (cancel_comm_monoid_with_zero (free_add_monoid unsigned)) congr_arg_kind) : @unique_factorization_monoid.{0} (free_add_monoid.{0} unsigned) (@functor.add_const.run.{0 0} (cancel_comm_monoid_with_zero.{0} (free_add_monoid.{0} unsigned)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_102757 (h0 : function.extfun Type uniform_space) : @complete_space.{0} (ordered_comm_group.{0} unsigned) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (ordered_comm_group.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_102758 (h0 : group (generalized_boolean_algebra (has_neg (has_neg (has_neg (has_neg (has_bot Type))))))) : group.fg (generalized_boolean_algebra (has_neg (has_neg (has_neg (has_neg (has_bot Type)))))) := sorry --non-trivial
lemma new_lemma_102759 (h0 : functor.add_const (topological_space (normed_comm_ring name)) Type) : @irreducible_space.{0} (normed_comm_ring.{0} name) (@functor.add_const.run.{0 1} (topological_space.{0} (normed_comm_ring.{0} name)) Type h0)  := sorry --non-trivial
lemma new_lemma_102760 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @strong_rank_condition.{0} (has_to_string.{0} unsigned) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (has_to_string.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_102761 (h0 : filter (has_nndist (has_to_string (has_to_string name)))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_102762 (h0 : topological_space (semiring (random_gen congr_arg_kind))) : irreducible_space (semiring (random_gen congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_102763 (h0 : not (function.extfun Type group -> false)) : @is_cyclic.{0} (normed_group.{0} empty) (@function.extfun_app.{2 1} Type group.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type group.{0}) h0) (normed_group.{0} empty))  := sorry --non-trivial
lemma new_lemma_102764 (h0 : uniform_space (has_bot (has_Inf (has_pos_part (has_Inf linarith.comp))))) : complete_space (has_bot (has_Inf (has_pos_part (has_Inf linarith.comp)))) := sorry --non-trivial
lemma new_lemma_102765 (h0 : ring (semi_normed_ring (has_nnnorm enat))) : strong_rank_condition (semi_normed_ring (has_nnnorm enat)) := sorry --non-trivial
lemma new_lemma_102766 (h0 : ring (has_add (has_add (has_Inf (has_Inf real))))) : strong_rank_condition (has_add (has_add (has_Inf (has_Inf real)))) := sorry --non-trivial
lemma new_lemma_102767 (h0 : topological_space (cancel_monoid environment.implicit_infer_kind)) : loc_path_connected_space (cancel_monoid environment.implicit_infer_kind) := sorry --non-trivial
lemma new_lemma_102768 (h0 : ordered_comm_monoid (boolean_algebra unsigned)) : has_exists_mul_of_le (boolean_algebra unsigned) := sorry --non-trivial
lemma new_lemma_102769 (h0 : functor.add_const (function.extfun (Type 1) ring) name) : @strong_rank_condition.{1} (comm_group.{1} Type) (@function.extfun_app.{3 2} (Type 1) ring.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) ring.{1}) name h0) (comm_group.{1} Type))  := sorry --non-trivial
lemma new_lemma_102770 (h0 : functor.add_const (function.extfun Type uniform_space) linarith.comp) : @separated_space.{0} (has_Inf.{0} linarith.comp) (@function.extfun_app.{2 1} Type uniform_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type uniform_space.{0}) linarith.comp h0) (has_Inf.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_102771 (h0 : ring (encodable char)) : strong_rank_condition (encodable char) := sorry --non-trivial
lemma new_lemma_102772 (h0 : functor.add_const (ring (has_pos_part name)) Type) : @is_domain.{0} (has_pos_part.{0} name) (@functor.add_const.run.{0 1} (ring.{0} (has_pos_part.{0} name)) Type h0)  := sorry --non-trivial
lemma new_lemma_102773 (h0 : complete_lattice (semi_normed_comm_ring (mul_one_class linarith.comp_source))) : complete_lattice.is_Sup_finite_compact (semi_normed_comm_ring (mul_one_class linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_102774 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @complete_space.{0} (has_neg_part.{0} unsigned) (@function.extfun_app.{2 1} Type uniform_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 uniform_space.{0}) (has_neg_part.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_102775 (h0 : functor.add_const (topological_space (as_linear_order congr_arg_kind)) congr_arg_kind) : @irreducible_space.{0} (as_linear_order.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (as_linear_order.{0} congr_arg_kind)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_102776 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @path_connected_space.{1} (comm_group.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 topological_space.{1}) (comm_group.{1} Type))  := sorry --non-trivial
lemma new_lemma_102777 (h0 : functor.add_const (topological_space (has_add pos)) Type) : @locally_compact_space.{0} (has_add.{0} pos) (@functor.add_const.run.{0 1} (topological_space.{0} (has_add.{0} pos)) Type h0)  := sorry --non-trivial
lemma new_lemma_102778 (h0 : functor.add_const (function.extfun Type topological_space) pos) : @irreducible_space.{0} (boolean_algebra.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) pos h0) (boolean_algebra.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_102779 (h0 : add_group (with_one (linear_ordered_semiring num))) : is_add_cyclic (with_one (linear_ordered_semiring num)) := sorry --non-trivial
lemma new_lemma_102780 (h0 : functor.add_const (topological_space (ring pos)) linarith.comp) : @regular_space.{0} (ring.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (ring.{0} pos)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_102781 (h0 : add_monoid (mul_zero_class Type)) : add_monoid.fg (mul_zero_class Type) := sorry --non-trivial
lemma new_lemma_102782 (h0 : functor.add_const (function.extfun Type topological_space) environment.implicit_infer_kind) : @irreducible_space.{0} (has_nndist.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) environment.implicit_infer_kind h0) (has_nndist.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_102783 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @t1_space.{0} (add_group.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (add_group.{0} empty))  := sorry --non-trivial
lemma new_lemma_102784 (h2 : complete_lattice (distrib char) -> char) (h3 : coe_sort (set.range h2)) : @is_compactly_generated.{0} (distrib.{0} char) (@set.range_splitting.{0 0} (complete_lattice.{0} (distrib.{0} char)) char h2 h3)  := sorry --non-trivial
lemma new_lemma_102785 (h0 : list (topological_space (has_to_string num))) : @irreducible_space.{0} (has_to_string.{0} num) (@list.head.{0} (topological_space.{0} (has_to_string.{0} num)) (@inhabited_topological_space.{0} (has_to_string.{0} num)) h0)  := sorry --non-trivial
lemma new_lemma_102786 (h1 : topological_space (has_top (random_gen string_imp))) : t0_space (has_top (random_gen string_imp)) := sorry --non-trivial
lemma new_lemma_102787 (h0 : has_mem.mem (semiring unsigned) has_emptyc.emptyc) : @rank_condition.{0} (semiring.{0} unsigned) (@finset.pi.empty.{1 0} Type ring.{0} (semiring.{0} unsigned) h0)  := sorry --non-trivial
lemma new_lemma_102788 (h0 : ordered_comm_monoid (normed_comm_ring (has_nndist pos))) : has_exists_mul_of_le (normed_comm_ring (has_nndist pos)) := sorry --non-trivial
lemma new_lemma_102789 (h0 : not (uniform_space (semi_normed_ring string.iterator_imp) -> false)) : @complete_space.{0} (semi_normed_ring.{0} string.iterator_imp) (@classical.by_contradiction'.{1} (uniform_space.{0} (semi_normed_ring.{0} string.iterator_imp)) h0)  := sorry --non-trivial
lemma new_lemma_102790 (h0 : group (has_star (semiring (semiring num)))) : is_cyclic (has_star (semiring (semiring num))) := sorry --non-trivial
lemma new_lemma_102791 (h0 : function.extfun Type topological_space) : @locally_compact_space.{0} (normed_group.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (normed_group.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_102792 (h1 : topological_space (has_top (random_gen (has_ssubset string_imp)))) : t0_space (has_top (random_gen (has_ssubset string_imp))) := sorry --non-trivial
lemma new_lemma_102793 (h2 : measurable_space (add_comm_semigroup linarith.ineq)) (h3 : set (add_comm_semigroup linarith.ineq)) : measurable_set h3 := sorry --non-trivial
lemma new_lemma_102794 (h1 : has_lt (simple_graph std_gen)) : no_max_order (simple_graph std_gen) := sorry --non-trivial
lemma new_lemma_102795 (h0 : topological_space (has_bot linarith.comp)) : preconnected_space (has_bot linarith.comp) := sorry --non-trivial
lemma new_lemma_102796 (h0 : topological_space (finset (option (option (option (option (option ennreal))))))) : preirreducible_space (finset (option (option (option (option (option ennreal)))))) := sorry --non-trivial
lemma new_lemma_102797 (h0 : add_group (topological_space (has_lt (random_gen char)))) : is_add_cyclic (topological_space (has_lt (random_gen char))) := sorry --non-trivial
lemma new_lemma_102798 (h0 : rat) : rat.nonneg h0 := sorry --non-trivial
lemma new_lemma_102799 (h0 : list (semi_normed_comm_ring linarith.comp_source)) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_102800 (h0 : complete_lattice (has_emptyc (has_inv fun_info))) : complete_lattice.is_Sup_finite_compact (has_emptyc (has_inv fun_info)) := sorry --non-trivial
lemma new_lemma_102801 (h0 : function.extfun Type topological_space) : @locally_compact_space.{0} (has_emptyc.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_emptyc.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_102802 (h0 : function.extfun Type cancel_comm_monoid_with_zero) : @unique_factorization_monoid.{0} (pseudo_metric_space.{0} num) (@function.extfun_app.{2 1} Type cancel_comm_monoid_with_zero.{0} h0 (pseudo_metric_space.{0} num))  := sorry --non-trivial
lemma new_lemma_102803 (h0 : add_group empty) : add_group.fg empty := sorry --non-trivial
lemma new_lemma_102804 (h0 : ring (random_gen (random_gen (random_gen (random_gen char))))) : is_domain (random_gen (random_gen (random_gen (random_gen char)))) := sorry --non-trivial
lemma new_lemma_102805 (h0 : uniform_space (has_pos_part (sub_neg_monoid real))) : complete_space (has_pos_part (sub_neg_monoid real)) := sorry --non-trivial
lemma new_lemma_102806 (h0 : functor.add_const (functor.add_const (functor.add_const Prop Type) linarith.comp) linarith.comp) : functor.add_const.run (functor.add_const.run (functor.add_const.run h0)) := sorry --non-trivial
lemma new_lemma_102807 (h0 : topological_space (mul_zero_class (semiring num))) : irreducible_space (mul_zero_class (semiring num)) := sorry --non-trivial
lemma new_lemma_102808 (h0 : functor.add_const (cancel_comm_monoid_with_zero (has_nndist pos)) Type) : @unique_factorization_monoid.{0} (has_nndist.{0} pos) (@functor.add_const.run.{0 1} (cancel_comm_monoid_with_zero.{0} (has_nndist.{0} pos)) Type h0)  := sorry --non-trivial
lemma new_lemma_102809 (h0 : list (linear_ordered_comm_group (has_bot (complete_distrib_lattice unsigned)))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_102810 (h0 : function.extfun (finset Type) (has_mem.mem num)) : @normalizer_condition.{0} num (@finset.pi.empty.{1 0} Type group.{0} num (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) num) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_102811 (h0 : group (semigroup (has_neg (finset (comm_group (finset linarith.comp)))))) : group.fg (semigroup (has_neg (finset (comm_group (finset linarith.comp))))) := sorry --non-trivial
lemma new_lemma_102812 (h0 : not (ring (has_compl linarith.comp_source) -> false)) : @is_domain.{0} (has_compl.{0} linarith.comp_source) (@classical.by_contradiction'.{1} (ring.{0} (has_compl.{0} linarith.comp_source)) h0)  := sorry --non-trivial
lemma new_lemma_102813 (h0 : ring (left_cancel_semigroup unsigned)) : is_principal_ideal_ring (left_cancel_semigroup unsigned) := sorry --non-trivial
lemma new_lemma_102814 (h0 : functor.add_const (function.extfun Type topological_space) name) : @irreducible_space.{0} (ordered_comm_ring.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) name h0) (ordered_comm_ring.{0} name))  := sorry --non-trivial
lemma new_lemma_102815 (h0 : topological_space (has_one num)) : totally_disconnected_space (has_one num) := sorry --non-trivial
lemma new_lemma_102816 (h0 : function.extfun Type uniform_space) : @separated_space.{0} (with_bot.{0} num) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (with_bot.{0} num))  := sorry --non-trivial
lemma new_lemma_102817 (h1 : add_group (measurable_space to_additive.value_type)) : is_add_cyclic (measurable_space to_additive.value_type) := sorry --non-trivial
lemma new_lemma_102818 (h0 : functor.add_const (topological_space (has_pos_part pos)) (has_add (has_add (ordered_ring linarith.comp)))) : @preconnected_space.{0} (has_pos_part.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (has_pos_part.{0} pos)) (has_add.{0} (has_add.{0} (ordered_ring.{0} linarith.comp))) h0)  := sorry --non-trivial
lemma new_lemma_102819 (h0 : functor.add_const (semiring (mul_zero_class pos)) name) : @is_noetherian_ring.{0} (mul_zero_class.{0} pos) (@functor.add_const.run.{0 0} (semiring.{0} (mul_zero_class.{0} pos)) name h0)  := sorry --non-trivial
lemma new_lemma_102820 (h0 : function.extfun Type cancel_comm_monoid_with_zero) : @unique_factorization_monoid.{0} (linear_ordered_comm_group.{0} ennreal) (@function.extfun_app.{2 1} Type cancel_comm_monoid_with_zero.{0} h0 (linear_ordered_comm_group.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_102821 (h0 : function.extfun (finset (Type -> Type)) (has_mem.mem complete_lattice)) : @is_compactly_generated.{0} linarith.comp_source (@function.extfun_app.{2 1} Type complete_lattice.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) complete_lattice.{0} (@function.extfun_app.{2 0} (finset.{1} (Type → Type)) (@has_mem.mem.{1 1} (Type → Type) (finset.{1} (Type → Type)) (@finset.has_mem.{1} (Type → Type)) complete_lattice.{0}) h0 (@has_emptyc.emptyc.{1} (finset.{1} (Type → Type)) (@finset.has_emptyc.{1} (Type → Type))))) linarith.comp_source)  := sorry --non-trivial
lemma new_lemma_102822 (h1 : uniform_space (has_compl enat)) : complete_space (has_compl enat) := sorry --non-trivial
lemma new_lemma_102823 (h0 : function.extfun Type topological_space) : @preirreducible_space.{0} (pseudo_metric_space.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (pseudo_metric_space.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_102824 (h0 : has_mem.mem group has_emptyc.emptyc) : @normalizer_condition.{0} (@id.{2} Type num) (@function.extfun_app.{2 1} Type group.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) group.{0} h0) (@id.{2} Type num))  := sorry --non-trivial
lemma new_lemma_102825 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @preirreducible_space.{0} (preorder.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (preorder.{0} empty))  := sorry --non-trivial
lemma new_lemma_102826 (h0 : topological_space (boolean_algebra (has_add unsigned))) : topological_space.separable_space (boolean_algebra (has_add unsigned)) := sorry --non-trivial
lemma new_lemma_102827 (h0 : uniform_space (has_top (has_top to_additive.value_type))) : separated_space (has_top (has_top to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_102828 (h0 : uniform_space (mul_zero_class (ring (finset pos)))) : separated_space (mul_zero_class (ring (finset pos))) := sorry --non-trivial
lemma new_lemma_102829 (h0 : functor.add_const (topological_space (has_pos_part Type)) linarith.comp) : @t1_space.{1} (has_pos_part.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (has_pos_part.{1} Type)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_102830 (h0 : functor.add_const (semiring (has_nndist pos)) (has_nndist linarith.comp)) : @is_noetherian_ring.{0} (has_nndist.{0} pos) (@functor.add_const.run.{0 0} (semiring.{0} (has_nndist.{0} pos)) (has_nndist.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_102831 (h0 : ring (normed_comm_ring (finset (finset pos)))) : is_principal_ideal_ring (normed_comm_ring (finset (finset pos))) := sorry --non-trivial
lemma new_lemma_102832 (h0 : functor.add_const (add_group (has_neg_part Type)) name) : @is_add_cyclic.{1} (has_neg_part.{1} Type) (@functor.add_const.run.{1 0} (add_group.{1} (has_neg_part.{1} Type)) name h0)  := sorry --non-trivial
lemma new_lemma_102833 (h0 : functor.add_const (function.extfun Type topological_space) linarith.comp) : @discrete_topology.{0} (has_neg.{0} (ring.{0} linarith.comp)) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) linarith.comp h0) (has_neg.{0} (ring.{0} linarith.comp)))  := sorry --non-trivial
lemma new_lemma_102834 (h0 : finset Prop) (h1 : finset.nonempty h0) : @finset.max'.{0} Prop Prop.linear_order h0 h1  := sorry --non-trivial
lemma new_lemma_102835 (h0 : topological_space (has_bot (has_add pos))) : preconnected_space (has_bot (has_add pos)) := sorry --non-trivial
lemma new_lemma_102836 (h0 : ring (normed_group (with_bot empty))) : rank_condition (normed_group (with_bot empty)) := sorry --non-trivial
lemma new_lemma_102837 (h0 : topological_space (has_zero (has_to_string (has_to_string (has_to_string pos))))) : loc_path_connected_space (has_zero (has_to_string (has_to_string (has_to_string pos)))) := sorry --non-trivial
lemma new_lemma_102838 (h0 : has_mem.mem (has_union num) has_emptyc.emptyc) : @rank_condition.{0} (has_union.{0} num) (@finset.pi.empty.{1 0} Type ring.{0} (has_union.{0} num) h0)  := sorry --non-trivial
lemma new_lemma_102839 (h0 : ring (semigroup (has_to_string (finset Type)))) : is_domain (semigroup (has_to_string (finset Type))) := sorry --non-trivial
lemma new_lemma_102840 (h0 : topological_space (ordered_comm_ring (sub_neg_monoid (has_bot (has_bot pos))))) : totally_separated_space (ordered_comm_ring (sub_neg_monoid (has_bot (has_bot pos)))) := sorry --non-trivial
lemma new_lemma_102841 (h0 : functor.add_const (filter (add_comm_monoid name)) linarith.comp) : countable_Inter_filter (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_102842 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @normal_space.{0} real.angle (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) real.angle)  := sorry --non-trivial
lemma new_lemma_102843 (h0 : complete_lattice (free_add_monoid (semiring (semiring unsigned)))) : is_compactly_generated (free_add_monoid (semiring (semiring unsigned))) := sorry --non-trivial
lemma new_lemma_102844 (h0 : measurable_space (add_comm_semigroup enat)) (h1 : has_sub (add_comm_semigroup enat)) : has_measurable_sub₂ (add_comm_semigroup enat) := sorry --non-trivial
lemma new_lemma_102845 (h0 : topological_space (free_add_monoid (semiring (semiring (semiring (semiring unsigned))))) -> Prop) : @totally_disconnected_space.{0} (free_add_monoid.{0} (semiring.{0} (semiring.{0} (semiring.{0} (semiring.{0} unsigned))))) (@classical.epsilon.{1} (topological_space.{0} (free_add_monoid.{0} (semiring.{0} (semiring.{0} (semiring.{0} (semiring.{0} unsigned)))))) (@nonempty_of_inhabited.{1} (topological_space.{0} (free_add_monoid.{0} (semiring.{0} (semiring.{0} (semiring.{0} (semiring.{0} unsigned)))))) (@inhabited_topological_space.{0} (free_add_monoid.{0} (semiring.{0} (semiring.{0} (semiring.{0} (semiring.{0} unsigned))))))) h0)  := sorry --non-trivial
lemma new_lemma_102846 (h0 : functor.add_const (topological_space (has_neg pos)) environment.implicit_infer_kind) : @t0_space.{0} (has_neg.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (has_neg.{0} pos)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_102847 (h0 : functor.comp filter has_neg pos) : filter.ne_bot (functor.comp.run h0) := sorry --non-trivial
lemma new_lemma_102848 (h1 : complete_lattice (comm_ring (random_gen linarith.ineq))) : complete_lattice.is_Sup_finite_compact (comm_ring (random_gen linarith.ineq)) := sorry --non-trivial
lemma new_lemma_102849 (h0 : functor.add_const (complete_lattice environment.implicit_infer_kind) linarith.comp) : @complete_lattice.is_Sup_finite_compact.{0} environment.implicit_infer_kind (@functor.add_const.run.{0 0} (complete_lattice.{0} environment.implicit_infer_kind) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_102850 (h0 : topological_space (has_bot num)) : discrete_topology (has_bot num) := sorry --non-trivial
lemma new_lemma_102851 (h0 : functor.add_const (functor.add_const Prop (semigroup linarith.comp)) (has_neg pos)) : functor.add_const.run (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_102852 (h0 : functor.add_const (topological_space (boolean_algebra.core environment.implicit_infer_kind)) pos) : @t0_space.{0} (boolean_algebra.core.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (boolean_algebra.core.{0} environment.implicit_infer_kind)) pos h0)  := sorry --non-trivial
lemma new_lemma_102853 (h0 : not (topological_space (id empty) -> false)) : @path_connected_space.{0} (@id.{2} Type empty) (@classical.by_contradiction'.{1} (topological_space.{0} (@id.{2} Type empty)) h0)  := sorry --non-trivial
lemma new_lemma_102854 (h0 : ring (has_nndist (cancel_monoid environment.implicit_infer_kind))) : is_principal_ideal_ring (has_nndist (cancel_monoid environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_102855 (h0 : functor.add_const (filter linarith.comp) Type) : countable_Inter_filter (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_102856 (h0 : function.extfun Type semiring) : @is_noetherian_ring.{0} (ordered_comm_group.{0} empty) (@function.extfun_app.{2 1} Type semiring.{0} h0 (ordered_comm_group.{0} empty))  := sorry --non-trivial
lemma new_lemma_102857 (h1 : add_group fun_info) : is_add_cyclic fun_info := sorry --non-trivial
lemma new_lemma_102858 (h0 : ring (has_norm empty)) : rank_condition (has_norm empty) := sorry --non-trivial
lemma new_lemma_102859 (h0 : has_mem.mem congr_arg_kind has_emptyc.emptyc) : @locally_compact_space.{0} congr_arg_kind (@finset.pi.empty.{1 0} Type topological_space.{0} congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_102860 (h1 : has_mem.mem (with_one num) has_emptyc.emptyc) : @t0_space.{0} (with_one.{0} num) (@finset.pi.empty.{1 0} Type topological_space.{0} (with_one.{0} num) h1)  := sorry --non-trivial
lemma new_lemma_102861 (h0 : topological_space (comm_ring (random_gen linarith.ineq))) : totally_disconnected_space (comm_ring (random_gen linarith.ineq)) := sorry --non-trivial
lemma new_lemma_102862 (h0 : function.extfun Type topological_space) : @totally_separated_space.{0} (filter.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (filter.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_102863 (h0 : topological_space (left_cancel_semigroup congr_arg_kind)) : locally_compact_space (left_cancel_semigroup congr_arg_kind) := sorry --non-trivial
lemma new_lemma_102864 (h0 : topological_space (add_right_cancel_monoid (semiring empty))) : preirreducible_space (add_right_cancel_monoid (semiring empty)) := sorry --non-trivial
lemma new_lemma_102865 (h0 : ring (non_unital_non_assoc_semiring (mul_one_class fun_info))) (h1 : complete_lattice (ring.positive_cone (non_unital_non_assoc_semiring (mul_one_class fun_info)))) : is_compactly_generated (ring.positive_cone (non_unital_non_assoc_semiring (mul_one_class fun_info))) := sorry --non-trivial
lemma new_lemma_102866 (h0 : functor.add_const (filter (has_add environment.implicit_infer_kind)) (has_neg Type)) : filter.ne_bot (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_102867 (h0 : functor.add_const (function.extfun Type topological_space) pos) : @discrete_topology.{0} (boolean_algebra.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) pos h0) (boolean_algebra.{0} pos))  := sorry --non-trivial
lemma new_lemma_102868 (h0 : functor.add_const Prop (has_nndist (option (option pos)))) : functor.add_const.run h0 := sorry --non-trivial
lemma new_lemma_102869 (h0 : functor.add_const (topological_space (boolean_algebra Type)) pos) : @locally_compact_space.{1} (boolean_algebra.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (boolean_algebra.{1} Type)) pos h0)  := sorry --non-trivial
lemma new_lemma_102870 (h1 : ring (simple_graph linarith.comp_source)) : rank_condition (simple_graph linarith.comp_source) := sorry --non-trivial
lemma new_lemma_102871 (h0 : ordered_add_comm_monoid (has_zero congr_arg_kind)) : archimedean (has_zero congr_arg_kind) := sorry --non-trivial
lemma new_lemma_102872 (h0 : topological_space (ordered_comm_monoid (ring (ring (has_neg (ordered_comm_ring (ring Type))))))) : t1_space (ordered_comm_monoid (ring (ring (has_neg (ordered_comm_ring (ring Type)))))) := sorry --non-trivial
lemma new_lemma_102873 (h0 : filter (normed_group (semiring (semiring unsigned)))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_102874 (h0 : uniform_space (random_gen (has_nnnorm (has_nnnorm linarith.ineq)))) : complete_space (random_gen (has_nnnorm (has_nnnorm linarith.ineq))) := sorry --non-trivial
lemma new_lemma_102875 (h0 : topological_space (random_gen (has_norm linarith.ineq))) : totally_separated_space (random_gen (has_norm linarith.ineq)) := sorry --non-trivial
lemma new_lemma_102876 (h0 : topological_space (normed_linear_ordered_group (option (option unsigned)))) : topological_space.separable_space (normed_linear_ordered_group (option (option unsigned))) := sorry --non-trivial
lemma new_lemma_102877 (h0 : functor.add_const (prod (has_neg_part name) (has_neg_part name)) name) : id_rel (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_102878 (h0 : complete_lattice (ring (has_zero (has_zero Type)))) : is_compactly_generated (ring (has_zero (has_zero Type))) := sorry --non-trivial
lemma new_lemma_102879 (h0 : topological_space (has_to_string (finset (has_add Type)))) : regular_space (has_to_string (finset (has_add Type))) := sorry --non-trivial
lemma new_lemma_102880 (h0 : list (normed_comm_ring (ring (ring (ring (finset linarith.comp)))))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_102881 (h0 : ring (has_add (has_neg pos))) : rank_condition (has_add (has_neg pos)) := sorry --non-trivial
lemma new_lemma_102882 (h0 : not (topological_space (add_left_cancel_monoid to_additive.value_type) -> false)) : @t0_space.{0} (add_left_cancel_monoid.{0} to_additive.value_type) (@classical.by_contradiction'.{1} (topological_space.{0} (add_left_cancel_monoid.{0} to_additive.value_type)) h0)  := sorry --non-trivial
lemma new_lemma_102883 (h0 : topological_space (distrib_lattice (has_ssubset (has_ssubset fun_info)))) : totally_disconnected_space (distrib_lattice (has_ssubset (has_ssubset fun_info))) := sorry --non-trivial
lemma new_lemma_102884 (h0 : function.extfun Type (functor.add_const (topological_space pos))) : @sequential_space.{0} pos (@functor.add_const.run.{0 0} (topological_space.{0} pos) pos (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (topological_space.{0} pos)) h0 pos))  := sorry --non-trivial
lemma new_lemma_102885 (h0 : not (topological_space (complete_linear_order unsigned) -> false)) : @normal_space.{0} (complete_linear_order.{0} unsigned) (@classical.by_contradiction'.{1} (topological_space.{0} (complete_linear_order.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_102886 (h0 : topological_space (cancel_monoid (boolean_algebra.core name))) : discrete_topology (cancel_monoid (boolean_algebra.core name)) := sorry --non-trivial
lemma new_lemma_102887 (h0 : functor.add_const (ordered_add_comm_monoid (boolean_algebra.core unsigned)) empty) : @archimedean.{0} (boolean_algebra.core.{0} unsigned) (@functor.add_const.run.{0 0} (ordered_add_comm_monoid.{0} (boolean_algebra.core.{0} unsigned)) empty h0)  := sorry --non-trivial
lemma new_lemma_102888 (h0 : add_monoid (cancel_monoid (complete_distrib_lattice unsigned))) : add_monoid.fg (cancel_monoid (complete_distrib_lattice unsigned)) := sorry --non-trivial
lemma new_lemma_102889 (h0 : has_lt reducibility_hints) : no_max_order reducibility_hints := sorry --non-trivial
lemma new_lemma_102890 (h0 : function.extfun Type complete_lattice) : @is_compactly_generated.{0} (normed_linear_ordered_group.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (normed_linear_ordered_group.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_102891 (h0 : set (add_comm_semigroup (add_comm_semigroup char) -> linarith.ineq)) : set.separates_points h0 := sorry --non-trivial
lemma new_lemma_102892 (h0 : function.extfun Type filter) : countable_Inter_filter (function.extfun_app h0 (add_comm_monoid ennreal)) := sorry --non-trivial
lemma new_lemma_102893 (h0 : functor.add_const (cancel_comm_monoid_with_zero (semigroup Type)) (comm_group name)) : @unique_factorization_monoid.{1} (semigroup.{1} Type) (@functor.add_const.run.{1 0} (cancel_comm_monoid_with_zero.{1} (semigroup.{1} Type)) (comm_group.{0} name) h0)  := sorry --non-trivial
lemma new_lemma_102894 (h0 : function.extfun Type topological_space) : @path_connected_space.{0} (linear_ordered_comm_monoid_with_zero.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (linear_ordered_comm_monoid_with_zero.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_102895 (h0 : uniform_space (has_star (semiring num))) : separated_space (has_star (semiring num)) := sorry --non-trivial
lemma new_lemma_102896 (h0 : function.extfun Type uniform_space) : @separated_space.{0} (ordered_ring.{0} unsigned) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (ordered_ring.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_102897 (h0 : ring (has_emptyc (random_gen fun_info))) : rank_condition (has_emptyc (random_gen fun_info)) := sorry --non-trivial
lemma new_lemma_102898 (h0 : uniform_space (canonically_ordered_comm_semiring (option (option congr_arg_kind)))) : complete_space (canonically_ordered_comm_semiring (option (option congr_arg_kind))) := sorry --non-trivial
lemma new_lemma_102899 (h0 : function.extfun Type (functor.comp filter finset)) : countable_Inter_filter (functor.comp.run (function.extfun_app h0 ennreal)) := sorry --non-trivial
lemma new_lemma_102900 (h0 : functor.add_const (group (finset pos)) linarith.comp) : @normalizer_condition.{0} (finset.{0} pos) (@functor.add_const.run.{0 0} (group.{0} (finset.{0} pos)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_102901 (h0 : semiring (nondiscrete_normed_field (linear_ordered_semiring (normed_field std_gen)))) (h1 : ideal (nondiscrete_normed_field (linear_ordered_semiring (normed_field std_gen)))) : ideal.is_prime h1 := sorry --non-trivial
lemma new_lemma_102902 (h0 : function.extfun Type ring) : @rank_condition.{0} (add_comm_monoid.{0} pos) (@function.extfun_app.{2 1} Type ring.{0} h0 (add_comm_monoid.{0} pos))  := sorry --non-trivial
lemma new_lemma_102903 (h0 : topological_space (has_Sup (semiring empty))) : loc_path_connected_space (has_Sup (semiring empty)) := sorry --non-trivial
lemma new_lemma_102904 (h1 : topological_space (with_zero (has_nnnorm (has_nnnorm fun_info)))) : totally_disconnected_space (with_zero (has_nnnorm (has_nnnorm fun_info))) := sorry --non-trivial
lemma new_lemma_102905 (h0 : functor.add_const (topological_space (has_zero pos)) linarith.comp) : @regular_space.{0} (has_zero.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (has_zero.{0} pos)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_102906 (h0 : topological_space (normed_group (has_union linarith.comp))) : preirreducible_space (normed_group (has_union linarith.comp)) := sorry --non-trivial
lemma new_lemma_102907 (h0 : functor.add_const (ordered_comm_monoid (add_comm_monoid environment.implicit_infer_kind)) linarith.comp) : @has_exists_mul_of_le.{0} (add_comm_monoid.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (ordered_comm_monoid.{0} (add_comm_monoid.{0} environment.implicit_infer_kind)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_102908 (h0 : filter (as_linear_order (option empty))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_102909 (h0 : functor.add_const (group Type) (has_pos_part Type)) : @group.fg.{1} Type (@functor.add_const.run.{1 1} (group.{1} Type) (has_pos_part.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_102910 (h0 : function.extfun Type cancel_comm_monoid_with_zero) : @unique_factorization_monoid.{0} (has_zero.{0} pos) (@function.extfun_app.{2 1} Type cancel_comm_monoid_with_zero.{0} h0 (has_zero.{0} pos))  := sorry --non-trivial
lemma new_lemma_102911 (h0 : ring (denumerable (random_gen (random_gen (random_gen linarith.comp_source))))) : is_domain (denumerable (random_gen (random_gen (random_gen linarith.comp_source)))) := sorry --non-trivial
lemma new_lemma_102912 (h0 : measurable_space (has_nnnorm (nondiscrete_normed_field char))) (h1 : filter (has_nnnorm (nondiscrete_normed_field char))) : filter.is_measurably_generated h1 := sorry --non-trivial
lemma new_lemma_102913 (h0 : cancel_comm_monoid_with_zero (ordered_comm_ring (ring (ring (has_pos_part (ring (ring pos))))))) : unique_factorization_monoid (ordered_comm_ring (ring (ring (has_pos_part (ring (ring pos)))))) := sorry --non-trivial
lemma new_lemma_102914 (h0 : function.extfun ((Type -> Type) -> Type 1) (function.extfun (Type -> Type))) : @is_atomistic.{0} (linear_ordered_semiring.{0} empty) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) (@function.extfun_app.{3 2} ((Type → Type) → Type 1) (function.extfun.{2 2} (Type → Type)) h0 (function.extfun.{2 1} Type)) complete_lattice.{0}) (linear_ordered_semiring.{0} empty))  := sorry --non-trivial
lemma new_lemma_102915 (h0 : not (topological_space (normed_field (mul_one_class char)) -> false)) : @path_connected_space.{0} (normed_field.{0} (mul_one_class.{0} char)) (@classical.by_contradiction'.{1} (topological_space.{0} (normed_field.{0} (mul_one_class.{0} char))) h0)  := sorry --non-trivial
lemma new_lemma_102916 (h0 : finset (canonically_ordered_comm_semiring (boolean_algebra (boolean_algebra pos)))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_102917 (h0 : topological_space (ordered_comm_ring (has_add (has_add real)))) : discrete_topology (ordered_comm_ring (has_add (has_add real))) := sorry --non-trivial
lemma new_lemma_102918 (h2 : ring name) : is_domain name := sorry --non-trivial
lemma new_lemma_102919 (h0 : complete_lattice (option (semiring (semiring (semiring (semiring (semiring unsigned))))))) : is_atomistic (option (semiring (semiring (semiring (semiring (semiring unsigned)))))) := sorry --non-trivial
lemma new_lemma_102920 (h0 : function.extfun (Type 1) ordered_add_comm_monoid) : @archimedean.{1} (has_neg.{1} Type) (@function.extfun_app.{3 2} (Type 1) ordered_add_comm_monoid.{1} h0 (has_neg.{1} Type))  := sorry --non-trivial
lemma new_lemma_102921 (h0 : topological_space (linear_ordered_comm_ring (semiring num))) : preirreducible_space (linear_ordered_comm_ring (semiring num)) := sorry --non-trivial
lemma new_lemma_102922 (h0 : not (uniform_space Type -> false)) : @separated_space.{1} Type (@classical.by_contradiction'.{2} (uniform_space.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_102923 (h0 : function.extfun Type topological_space) : @loc_path_connected_space.{0} (has_add.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_add.{0} name))  := sorry --non-trivial
lemma new_lemma_102924 (h0 : function.extfun Type cancel_comm_monoid_with_zero) : @unique_factorization_monoid.{0} (cancel_monoid.{0} num) (@function.extfun_app.{2 1} Type cancel_comm_monoid_with_zero.{0} h0 (cancel_monoid.{0} num))  := sorry --non-trivial
lemma new_lemma_102925 (h0 : function.extfun Type ring) : @rank_condition.{0} (canonically_ordered_comm_semiring.{0} pos) (@function.extfun_app.{2 1} Type ring.{0} h0 (canonically_ordered_comm_semiring.{0} pos))  := sorry --non-trivial
lemma new_lemma_102926 (h0 : not (topological_space (semiring linarith.comp) -> false)) : @t0_space.{0} (semiring.{0} linarith.comp) (@classical.by_contradiction'.{1} (topological_space.{0} (semiring.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_102927 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @normalizer_condition.{0} (has_to_string.{0} ennreal) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (has_to_string.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_102928 (h0 : not (ring (plift congr_arg_kind) -> false)) : @is_principal_ideal_ring.{1} (plift.{1} congr_arg_kind) (@classical.by_contradiction'.{2} (ring.{1} (plift.{1} congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_102929 (h0 : functor.add_const (ring (normed_comm_ring Type)) pos) : @is_principal_ideal_ring.{1} (normed_comm_ring.{1} Type) (@functor.add_const.run.{1 0} (ring.{1} (normed_comm_ring.{1} Type)) pos h0)  := sorry --non-trivial
lemma new_lemma_102930 (h0 : topological_space (add_cancel_comm_monoid (random_gen (random_gen (measurable_space char))))) : t0_space (add_cancel_comm_monoid (random_gen (random_gen (measurable_space char)))) := sorry --non-trivial
lemma new_lemma_102931 (h0 : function.extfun Type complete_lattice) : @is_compactly_generated.{0} (random_gen.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (random_gen.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_102932 (h0 : not (function.extfun Type topological_space -> false)) : @preirreducible_space.{0} (metric_space.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (metric_space.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_102933 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @monoid.fg.{0} (with_bot.{0} fun_info) (@function.extfun_app.{2 1} Type monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 monoid.{0}) (with_bot.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_102934 (h0 : uniform_space (add_cancel_monoid (has_add name))) : complete_space (add_cancel_monoid (has_add name)) := sorry --non-trivial
lemma new_lemma_102935 (h0 : ring (has_div (has_nnnorm (uniform_space reducibility_hints)))) : rank_condition (has_div (has_nnnorm (uniform_space reducibility_hints))) := sorry --non-trivial
lemma new_lemma_102936 (h0 : functor.add_const (monoid (has_zero unsigned)) pos) : @monoid.fg.{0} (has_zero.{0} unsigned) (@functor.add_const.run.{0 0} (monoid.{0} (has_zero.{0} unsigned)) pos h0)  := sorry --non-trivial
lemma new_lemma_102937 (h0 : functor.add_const (topological_space (ordered_comm_ring Type)) pos) : @irreducible_space.{1} (ordered_comm_ring.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (ordered_comm_ring.{1} Type)) pos h0)  := sorry --non-trivial
lemma new_lemma_102938 (h0 : add_group (semi_normed_comm_ring fun_info)) : is_add_cyclic (semi_normed_comm_ring fun_info) := sorry --non-trivial
lemma new_lemma_102939 (h0 : topological_space (group_with_zero empty)) : irreducible_space (group_with_zero empty) := sorry --non-trivial
lemma new_lemma_102940 (h0 : functor.add_const (ordered_comm_monoid (semigroup linarith.comp)) (ring Type)) : @has_exists_mul_of_le.{0} (semigroup.{0} linarith.comp) (@functor.add_const.run.{0 1} (ordered_comm_monoid.{0} (semigroup.{0} linarith.comp)) (ring.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_102941 (h0 : complete_lattice (semigroup (comm_group (comm_group (comm_group name))))) : is_atomistic (semigroup (comm_group (comm_group (comm_group name)))) := sorry --non-trivial
lemma new_lemma_102942 (h0 : semiring (normed_comm_ring (has_scalar ennreal Type))) : is_noetherian_ring (normed_comm_ring (has_scalar ennreal Type)) := sorry --non-trivial
lemma new_lemma_102943 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @monoid.fg.{1} (add_comm_monoid.{1} Type) (@function.extfun_app.{3 2} (Type 1) monoid.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 monoid.{1}) (add_comm_monoid.{1} Type))  := sorry --non-trivial
lemma new_lemma_102944 (h0 : complete_lattice (has_norm linarith.comp_source)) : complete_lattice.is_Sup_finite_compact (has_norm linarith.comp_source) := sorry --non-trivial
lemma new_lemma_102945 (h0 : topological_space (semigroup (option unsigned))) : path_connected_space (semigroup (option unsigned)) := sorry --non-trivial
lemma new_lemma_102946 (h0 : monoid (has_pos_part (has_neg (has_neg real)))) : monoid.fg (has_pos_part (has_neg (has_neg real))) := sorry --non-trivial
lemma new_lemma_102947 (h0 : function.extfun Type topological_space) : @totally_separated_space.{0} (has_emptyc.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_emptyc.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_102948 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @normalizer_condition.{0} (ordered_comm_group.{0} empty) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (ordered_comm_group.{0} empty))  := sorry --non-trivial
lemma new_lemma_102949 (h0 : topological_space (has_emptyc fun_info)) : totally_disconnected_space (has_emptyc fun_info) := sorry --non-trivial
lemma new_lemma_102950 (h0 : functor.add_const (function.extfun Type filter) linarith.comp) : countable_Inter_filter (function.extfun_app (functor.add_const.run h0) (has_zero pos)) := sorry --non-trivial
lemma new_lemma_102951 (h0 : topological_space (generalized_boolean_algebra (ring Type))) : t0_space (generalized_boolean_algebra (ring Type)) := sorry --non-trivial
lemma new_lemma_102952 (h0 : topological_space (normed_group (has_top (random_gen linarith.comp_source)))) : totally_separated_space (normed_group (has_top (random_gen linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_102953 (h0 : set (linear_ordered_comm_group_with_zero (mul_one_class char))) : set.finite h0 := sorry --non-trivial
lemma new_lemma_102954 (h0 : ring (distrib_lattice (random_gen char))) : strong_rank_condition (distrib_lattice (random_gen char)) := sorry --non-trivial
lemma new_lemma_102955 (h0 : function.extfun Type (functor.add_const (topological_space (semigroup unsigned)))) : @irreducible_space.{0} (semigroup.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (semigroup.{0} unsigned)) unsigned (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (topological_space.{0} (semigroup.{0} unsigned))) h0 unsigned))  := sorry --non-trivial
lemma new_lemma_102956 (h0 : ring (has_Inf Type)) : is_domain (has_Inf Type) := sorry --non-trivial
lemma new_lemma_102957 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @separated_space.{0} (has_union.{0} unsigned) (@function.extfun_app.{2 1} Type uniform_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 uniform_space.{0}) (has_union.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_102958 (h0 : ring (dlist (topological_space (add_left_cancel_monoid (fintype to_additive.value_type))))) : is_domain (dlist (topological_space (add_left_cancel_monoid (fintype to_additive.value_type)))) := sorry --non-trivial
lemma new_lemma_102959 (h0 : complete_lattice (id linarith.comp_source)) : is_atomistic (id linarith.comp_source) := sorry --non-trivial
lemma new_lemma_102960 (h0 : ring (has_append to_additive.value_type)) : strong_rank_condition (has_append to_additive.value_type) := sorry --non-trivial
lemma new_lemma_102961 (h0 : function.extfun Type topological_space) : @irreducible_space.{0} (cancel_monoid.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (cancel_monoid.{0} empty))  := sorry --non-trivial
lemma new_lemma_102962 (h0 : complete_lattice (has_neg_part (has_add environment.implicit_infer_kind))) : is_compactly_generated (has_neg_part (has_add environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_102963 (h0 : complete_lattice (add_cancel_comm_monoid empty)) : is_atomistic (add_cancel_comm_monoid empty) := sorry --non-trivial
lemma new_lemma_102964 (h0 : functor.add_const (functor.add_const (ordered_comm_monoid ordering) pos) pos) : @has_exists_mul_of_le.{0} ordering (@functor.add_const.run.{0 0} (ordered_comm_monoid.{0} ordering) pos (@functor.add_const.run.{0 0} (functor.add_const.{0 0} (ordered_comm_monoid.{0} ordering) pos) pos h0))  := sorry --non-trivial
lemma new_lemma_102965 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_domain.{0} (has_inv.{0} string_imp) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (has_inv.{0} string_imp))  := sorry --non-trivial
lemma new_lemma_102966 (h0 : functor.add_const (topological_space (semiring num)) (semiring empty)) : @normal_space.{0} (semiring.{0} num) (@functor.add_const.run.{0 0} (topological_space.{0} (semiring.{0} num)) (semiring.{0} empty) h0)  := sorry --non-trivial
lemma new_lemma_102967 (h0 : semiring (linear_ordered_comm_monoid_with_zero congr_arg_kind)) (h1 : ideal (linear_ordered_comm_monoid_with_zero congr_arg_kind)) : ideal.fg h1 := sorry --non-trivial
lemma new_lemma_102968 (h0 : add_monoid (measurable_space.dynkin_system (semiring (semiring (semiring (semiring empty)))))) : add_monoid.fg (measurable_space.dynkin_system (semiring (semiring (semiring (semiring empty))))) := sorry --non-trivial
lemma new_lemma_102969 (h0 : function.extfun Type ordered_add_comm_monoid) : @archimedean.{0} (mul_one_class.{0} unsigned) (@function.extfun_app.{2 1} Type ordered_add_comm_monoid.{0} h0 (mul_one_class.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_102970 (h0 : functor.add_const (complete_lattice (semigroup name)) environment.implicit_infer_kind) : @is_compactly_generated.{0} (semigroup.{0} name) (@functor.add_const.run.{0 0} (complete_lattice.{0} (semigroup.{0} name)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_102971 (h0 : functor.add_const (function.extfun Type add_monoid) name) : @add_monoid.fg.{0} (mul_zero_class.{0} name) (@function.extfun_app.{2 1} Type add_monoid.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type add_monoid.{0}) name h0) (mul_zero_class.{0} name))  := sorry --non-trivial
lemma new_lemma_102972 (h0 : topological_space (canonically_ordered_comm_semiring (comm_group ennreal))) : regular_space (canonically_ordered_comm_semiring (comm_group ennreal)) := sorry --non-trivial
lemma new_lemma_102973 (h1 : ring (has_ssubset (mul_one_class string_imp))) : is_domain (has_ssubset (mul_one_class string_imp)) := sorry --non-trivial
lemma new_lemma_102974 (h0 : functor.add_const (group (boolean_algebra Type)) linarith.comp) : @is_cyclic.{1} (boolean_algebra.{1} Type) (@functor.add_const.run.{1 0} (group.{1} (boolean_algebra.{1} Type)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_102975 (h0 : functor.add_const (topological_space (has_nndist ennreal)) name) : @locally_compact_space.{0} (has_nndist.{0} ennreal) (@functor.add_const.run.{0 0} (topological_space.{0} (has_nndist.{0} ennreal)) name h0)  := sorry --non-trivial
lemma new_lemma_102976 (h0 : functor.comp ordered_add_comm_monoid canonically_ordered_comm_semiring name) : @archimedean.{0} (canonically_ordered_comm_semiring.{0} name) (@functor.comp.run.{0 0 0} ordered_add_comm_monoid.{0} canonically_ordered_comm_semiring.{0} name h0)  := sorry --non-trivial
lemma new_lemma_102977 (h0 : uniform_space (has_one num)) : complete_space (has_one num) := sorry --non-trivial
lemma new_lemma_102978 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_domain.{0} (simple_graph.{0} empty) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (simple_graph.{0} empty))  := sorry --non-trivial
lemma new_lemma_102979 (h0 : function.extfun Type topological_space) : @path_connected_space.{0} (normed_group.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (normed_group.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_102980 (h0 : filter (has_nndist (comm_group pos))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_102981 (h1 : complete_lattice (has_norm (semiring empty))) : is_atomistic (has_norm (semiring empty)) := sorry --non-trivial
lemma new_lemma_102982 (h0 : function.extfun Type topological_space) : @loc_path_connected_space.{0} (has_nndist.{0} ennreal) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_nndist.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_102983 (h0 : function.extfun Type (functor.add_const (topological_space (semigroup unsigned)))) : @t0_space.{0} (semigroup.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (semigroup.{0} unsigned)) empty (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (topological_space.{0} (semigroup.{0} unsigned))) h0 empty))  := sorry --non-trivial
lemma new_lemma_102984 (h0 : monoid (has_Inf (has_Inf (has_Inf pos)))) : monoid.fg (has_Inf (has_Inf (has_Inf pos))) := sorry --non-trivial
lemma new_lemma_102985 (h0 : function.extfun Type topological_space) : @preirreducible_space.{0} (left_cancel_monoid.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (left_cancel_monoid.{0} empty))  := sorry --non-trivial
lemma new_lemma_102986 (h0 : ring (ring name)) : is_domain (ring name) := sorry --non-trivial
lemma new_lemma_102987 (h0 : function.extfun Type topological_space) : @topological_space.separable_space.{0} (left_cancel_semigroup.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (left_cancel_semigroup.{0} num))  := sorry --non-trivial
lemma new_lemma_102988 (h0 : topological_space (has_compl (has_ssubset fun_info))) : path_connected_space (has_compl (has_ssubset fun_info)) := sorry --non-trivial
lemma new_lemma_102989 (h0 : topological_space (has_neg congr_arg_kind)) : loc_path_connected_space (has_neg congr_arg_kind) := sorry --non-trivial
lemma new_lemma_102990 (h0 : group (has_zero (has_nndist (finset Type)))) : normalizer_condition (has_zero (has_nndist (finset Type))) := sorry --non-trivial
lemma new_lemma_102991 (h0 : not (ring (denumerable linarith.ineq) -> false)) : @strong_rank_condition.{0} (denumerable.{0} linarith.ineq) (@classical.by_contradiction'.{1} (ring.{0} (denumerable.{0} linarith.ineq)) h0)  := sorry --non-trivial
lemma new_lemma_102992 (h0 : topological_space (add_right_cancel_monoid (semiring (semiring congr_arg_kind)))) : discrete_topology (add_right_cancel_monoid (semiring (semiring congr_arg_kind))) := sorry --non-trivial
lemma new_lemma_102993 (h2 : ring (linear_ordered_add_comm_group fun_info)) : is_domain (linear_ordered_add_comm_group fun_info) := sorry --non-trivial
lemma new_lemma_102994 (h0 : topological_space (complete_distrib_lattice (boolean_algebra.core Type))) : irreducible_space (complete_distrib_lattice (boolean_algebra.core Type)) := sorry --non-trivial
lemma new_lemma_102995 (h0 : function.extfun (Type 1) (functor.comp topological_space boolean_algebra.core)) : @preirreducible_space.{1} (boolean_algebra.core.{1} Type) (@functor.comp.run.{1 1 1} topological_space.{1} boolean_algebra.core.{1} Type (@function.extfun_app.{3 2} (Type 1) (functor.comp.{1 1 1} topological_space.{1} boolean_algebra.core.{1}) h0 Type))  := sorry --non-trivial
lemma new_lemma_102996 (h0 : topological_space (metric_space num)) : normal_space (metric_space num) := sorry --non-trivial
lemma new_lemma_102997 (h2 : set (char -> ereal)) : set.separates_points h2 := sorry --non-trivial
lemma new_lemma_102998 (h0 : function.extfun (finset Type) (has_mem.mem real.angle)) : is_add_cyclic real.angle := sorry --non-trivial
lemma new_lemma_102999 (h0 : topological_space (ordered_comm_group (option (option unsigned)))) : t1_space (ordered_comm_group (option (option unsigned))) := sorry --non-trivial
lemma new_lemma_103000 (h0 : filter (random_gen (semiring (has_top (semiring congr_arg_kind))))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_103001 (h0 : functor.add_const (cancel_comm_monoid_with_zero (finset linarith.comp)) (add_comm_monoid name)) : @unique_factorization_monoid.{0} (finset.{0} linarith.comp) (@functor.add_const.run.{0 0} (cancel_comm_monoid_with_zero.{0} (finset.{0} linarith.comp)) (add_comm_monoid.{0} name) h0)  := sorry --non-trivial
lemma new_lemma_103002 (h0 : topological_space (monoid (option (option unsigned)))) : t1_space (monoid (option (option unsigned))) := sorry --non-trivial
lemma new_lemma_103003 (h0 : topological_space (distrib_lattice (has_top fun_info))) : t0_space (distrib_lattice (has_top fun_info)) := sorry --non-trivial
lemma new_lemma_103004 (h0 : functor.add_const (list (boolean_algebra linarith.comp)) (has_Inf pos)) : list.nodup (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_103005 (h0 : complete_lattice (preorder (semiring num))) : complete_lattice.is_Sup_finite_compact (preorder (semiring num)) := sorry --non-trivial
lemma new_lemma_103006 (h0 : topological_space (normed_comm_ring (option unsigned))) : t0_space (normed_comm_ring (option unsigned)) := sorry --non-trivial
lemma new_lemma_103007 (h0 : functor.add_const (function.extfun Type topological_space) Type) : @sequential_space.{0} (comm_group.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type topological_space.{0}) Type h0) (comm_group.{0} pos))  := sorry --non-trivial
lemma new_lemma_103008 (h0 : functor.add_const (group (boolean_algebra Type)) (ring (has_to_string linarith.comp))) : @is_simple_group.{1} (boolean_algebra.{1} Type) (@functor.add_const.run.{1 0} (group.{1} (boolean_algebra.{1} Type)) (ring.{0} (has_to_string.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_103009 (h0 : group (has_neg (has_neg_part (has_add name)))) : is_simple_group (has_neg (has_neg_part (has_add name))) := sorry --non-trivial
lemma new_lemma_103010 (h0 : not (topological_space (linear_ordered_cancel_comm_monoid fun_info) -> false)) : @totally_disconnected_space.{0} (linear_ordered_cancel_comm_monoid.{0} fun_info) (@classical.by_contradiction'.{1} (topological_space.{0} (linear_ordered_cancel_comm_monoid.{0} fun_info)) h0)  := sorry --non-trivial
lemma new_lemma_103011 (h1 : char) (h2 : sym2 char) : sym2.mem h1 h2 := sorry --non-trivial
lemma new_lemma_103012 (h0 : functor.add_const (complete_lattice (cancel_monoid empty)) num) : @is_compactly_generated.{0} (cancel_monoid.{0} empty) (@functor.add_const.run.{0 0} (complete_lattice.{0} (cancel_monoid.{0} empty)) num h0)  := sorry --non-trivial
lemma new_lemma_103013 (h0 : fin has_zero.zero) : @irreducible_space.{0} (sub_neg_monoid.{0} name) (@matrix.vec_empty.{0} (topological_space.{0} (sub_neg_monoid.{0} name)) h0)  := sorry --non-trivial
lemma new_lemma_103014 (h0 : not (has_mem.mem (normed_group linarith.comp_source) has_emptyc.emptyc -> false)) : @monoid.fg.{0} (normed_group.{0} linarith.comp_source) (@finset.pi.empty.{1 0} Type monoid.{0} (normed_group.{0} linarith.comp_source) (@classical.by_contradiction'.{0} (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (normed_group.{0} linarith.comp_source) (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))) h0))  := sorry --non-trivial
lemma new_lemma_103015 (h0 : filter (distrib (has_inv linarith.ineq))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_103016 (h0 : function.extfun Type topological_space) : @path_connected_space.{0} (non_assoc_semiring.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (non_assoc_semiring.{0} num))  := sorry --non-trivial
lemma new_lemma_103017 (h0 : has_coe char Prop) (h1 : char) : @coe_b.{1 1} char Prop h0 h1  := sorry --non-trivial
lemma new_lemma_103018 (h0 : topological_space (with_bot (has_top congr_arg_kind))) : irreducible_space (with_bot (has_top congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_103019 (h0 : functor.add_const (ring (canonically_ordered_comm_semiring linarith.comp)) pos) : @rank_condition.{0} (canonically_ordered_comm_semiring.{0} linarith.comp) (@functor.add_const.run.{0 0} (ring.{0} (canonically_ordered_comm_semiring.{0} linarith.comp)) pos h0)  := sorry --non-trivial
lemma new_lemma_103020 (h0 : topological_space (has_zero (comm_group (has_neg_part (has_add Type))))) : topological_space.separable_space (has_zero (comm_group (has_neg_part (has_add Type)))) := sorry --non-trivial
lemma new_lemma_103021 (h0 : function.extfun (finset Type) (has_mem.mem (random_gen num))) : @add_monoid.fg.{0} (random_gen.{0} num) (@finset.pi.empty.{1 0} Type add_monoid.{0} (random_gen.{0} num) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (random_gen.{0} num)) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_103022 (h0 : topological_space (comm_semigroup (sub_neg_monoid linarith.comp))) : t0_space (comm_semigroup (sub_neg_monoid linarith.comp)) := sorry --non-trivial
lemma new_lemma_103023 (h0 : functor.add_const (group (linear_ordered_field ennreal)) unsigned) : @normalizer_condition.{0} (linear_ordered_field.{0} ennreal) (@functor.add_const.run.{0 0} (group.{0} (linear_ordered_field.{0} ennreal)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_103024 (h0 : topological_space (boolean_algebra (has_add pos))) : discrete_topology (boolean_algebra (has_add pos)) := sorry --non-trivial
lemma new_lemma_103025 (h0 : ring (has_star (option unsigned))) : strong_rank_condition (has_star (option unsigned)) := sorry --non-trivial
lemma new_lemma_103026 (h0 : ring (finset (has_neg_part (has_neg_part pos)))) : is_principal_ideal_ring (finset (has_neg_part (has_neg_part pos))) := sorry --non-trivial
lemma new_lemma_103027 (h0 : not (function.extfun Type ring -> false)) : @rank_condition.{0} (bin_tree.{0} unsigned) (@function.extfun_app.{2 1} Type ring.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type ring.{0}) h0) (bin_tree.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_103028 (h0 : topological_space (generalized_boolean_algebra (has_add Type))) : preirreducible_space (generalized_boolean_algebra (has_add Type)) := sorry --non-trivial
lemma new_lemma_103029 (h0 : fin has_zero.zero) : @is_principal_ideal_ring.{0} (ordered_comm_monoid.{0} pos) (@matrix.vec_empty.{0} (ring.{0} (ordered_comm_monoid.{0} pos)) h0)  := sorry --non-trivial
lemma new_lemma_103030 (h0 : function.extfun Type topological_space) : @normal_space.{0} (has_pos_part.{0} ennreal) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_pos_part.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_103031 (h0 : functor.add_const (group (complete_distrib_lattice linarith.comp)) (finset Type)) : @normalizer_condition.{0} (complete_distrib_lattice.{0} linarith.comp) (@functor.add_const.run.{0 1} (group.{0} (complete_distrib_lattice.{0} linarith.comp)) (finset.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_103032 (h0 : functor.add_const (topological_space (cancel_monoid environment.implicit_infer_kind)) pos) : @totally_separated_space.{0} (cancel_monoid.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (cancel_monoid.{0} environment.implicit_infer_kind)) pos h0)  := sorry --non-trivial
lemma new_lemma_103033 (h0 : ordered_add_comm_monoid (finset (ring linarith.comp))) : archimedean (finset (ring linarith.comp)) := sorry --non-trivial
lemma new_lemma_103034 (h0 : complete_lattice (finset (option congr_arg_kind))) : complete_lattice.is_Sup_finite_compact (finset (option congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_103035 (h0 : functor.add_const (topological_space (canonically_ordered_comm_semiring name)) linarith.comp) : @preconnected_space.{0} (canonically_ordered_comm_semiring.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (canonically_ordered_comm_semiring.{0} name)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_103036 (h0 : functor.add_const (monoid (add_cancel_monoid linarith.comp)) pos) : @monoid.fg.{0} (add_cancel_monoid.{0} linarith.comp) (@functor.add_const.run.{0 0} (monoid.{0} (add_cancel_monoid.{0} linarith.comp)) pos h0)  := sorry --non-trivial
lemma new_lemma_103037 (h0 : complete_lattice (has_neg (normed_comm_ring Type))) : is_compactly_generated (has_neg (normed_comm_ring Type)) := sorry --non-trivial
lemma new_lemma_103038 (h0 : not (filter (has_norm linarith.comp) -> false)) : filter.ne_bot (classical.by_contradiction' h0) := sorry --non-trivial
lemma new_lemma_103039 (h0 : functor.add_const (ring (comm_group pos)) pos) : @is_domain.{0} (comm_group.{0} pos) (@functor.add_const.run.{0 0} (ring.{0} (comm_group.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_103040 (h0 : add_monoid (normed_comm_ring (has_to_string (has_add unsigned)))) : add_monoid.fg (normed_comm_ring (has_to_string (has_add unsigned))) := sorry --non-trivial
lemma new_lemma_103041 (h0 : cancel_comm_monoid_with_zero (sub_neg_monoid (has_add Type))) : unique_factorization_monoid (sub_neg_monoid (has_add Type)) := sorry --non-trivial
lemma new_lemma_103042 (h0 : function.extfun Type list) : list.nodup (function.extfun_app h0 (as_linear_order unsigned)) := sorry --non-trivial
lemma new_lemma_103043 (h0 : not (function.extfun (Type -> Type) (function.extfun Type) -> false)) : @strong_rank_condition.{0} to_additive.value_type (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) (@classical.by_contradiction'.{2} (function.extfun.{2 2} (Type → Type) (function.extfun.{2 1} Type)) h0) ring.{0}) to_additive.value_type)  := sorry --non-trivial
lemma new_lemma_103044 (h0 : ring (normed_field linarith.ineq)) : rank_condition (normed_field linarith.ineq) := sorry --non-trivial
lemma new_lemma_103045 (h0 : functor.comp ring cancel_monoid linarith.comp) : @is_principal_ideal_ring.{0} (cancel_monoid.{0} linarith.comp) (@functor.comp.run.{0 0 0} ring.{0} cancel_monoid.{0} linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_103046 (h0 : group (with_one (random_gen linarith.ineq))) : group.fg (with_one (random_gen linarith.ineq)) := sorry --non-trivial
lemma new_lemma_103047 (h0 : not (list (complete_semilattice_Sup unsigned) -> false)) : list.nodup (classical.by_contradiction' h0) := sorry --non-trivial
lemma new_lemma_103048 (h0 : topological_space (has_nndist environment.implicit_infer_kind)) : t0_space (has_nndist environment.implicit_infer_kind) := sorry --non-trivial
lemma new_lemma_103049 (h0 : topological_space (has_neg Type)) : path_connected_space (has_neg Type) := sorry --non-trivial
lemma new_lemma_103050 (h0 : list (has_top (with_bot congr_arg_kind))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_103051 (h0 : functor.comp topological_space boolean_algebra.core Type) : @t1_space.{1} (boolean_algebra.core.{1} Type) (@functor.comp.run.{1 1 1} topological_space.{1} boolean_algebra.core.{1} Type h0)  := sorry --non-trivial
lemma new_lemma_103052 (h0 : has_mem.mem (metric_space congr_arg_kind) has_emptyc.emptyc) : @add_monoid.fg.{0} (metric_space.{0} congr_arg_kind) (@finset.pi.empty.{1 0} Type add_monoid.{0} (metric_space.{0} congr_arg_kind) h0)  := sorry --non-trivial
lemma new_lemma_103053 (h0 : not (topological_space (normed_field (mul_one_class string.iterator_imp)) -> false)) : @t0_space.{0} (normed_field.{0} (mul_one_class.{0} string.iterator_imp)) (@classical.by_contradiction'.{1} (topological_space.{0} (normed_field.{0} (mul_one_class.{0} string.iterator_imp))) h0)  := sorry --non-trivial
lemma new_lemma_103054 (h0 : not (topological_space (topological_space linarith.ineq) -> false)) : @totally_disconnected_space.{0} (topological_space.{0} linarith.ineq) (@classical.by_contradiction'.{1} (topological_space.{0} (topological_space.{0} linarith.ineq)) h0)  := sorry --non-trivial
lemma new_lemma_103055 (h0 : cancel_comm_monoid_with_zero (normed_comm_ring (option (option ennreal)))) : unique_factorization_monoid (normed_comm_ring (option (option ennreal))) := sorry --non-trivial
lemma new_lemma_103056 (h0 : filter (measurable_space (has_top fun_info))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_103057 (h0 : functor.add_const (topological_space (has_add name)) (has_neg linarith.comp)) : @totally_separated_space.{0} (has_add.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (has_add.{0} name)) (has_neg.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_103058 (h0 : uniform_space (has_top (random_gen (random_gen to_additive.value_type)))) : complete_space (has_top (random_gen (random_gen to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_103059 (h0 : functor.add_const (function.extfun Type topological_space) real) : @loc_path_connected_space.{0} (canonically_ordered_monoid.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) real h0) (canonically_ordered_monoid.{0} name))  := sorry --non-trivial
lemma new_lemma_103060 (h0 : topological_space (add_left_cancel_semigroup (semiring num))) : irreducible_space (add_left_cancel_semigroup (semiring num)) := sorry --non-trivial
lemma new_lemma_103061 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @t0_space.{0} (linear_order.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (linear_order.{0} empty))  := sorry --non-trivial
lemma new_lemma_103062 (h0 : topological_space (comm_group (has_add environment.implicit_infer_kind))) : totally_disconnected_space (comm_group (has_add environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_103063 (h0 : function.extfun Type group) (h1 : topological_space (filter congr_arg_kind)) (h2 : measurable_space (filter congr_arg_kind)) (h3 : measure_theory.measure (filter congr_arg_kind)) : @measure_theory.measure.is_haar_measure.{0} (filter.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type group.{0} h0 (filter.{0} congr_arg_kind)) h1 h2 h3  := sorry --non-trivial
lemma new_lemma_103064 (h0 : complete_lattice (add_comm_monoid (semigroup (cancel_monoid environment.implicit_infer_kind)))) : is_atomistic (add_comm_monoid (semigroup (cancel_monoid environment.implicit_infer_kind))) := sorry --non-trivial
lemma new_lemma_103065 (h0 : functor.add_const (function.extfun (Type 1) ordered_comm_monoid) Type) : @has_exists_mul_of_le.{1} (ring.{1} Type) (@function.extfun_app.{3 2} (Type 1) ordered_comm_monoid.{1} (@functor.add_const.run.{2 1} (function.extfun.{3 2} (Type 1) ordered_comm_monoid.{1}) Type h0) (ring.{1} Type))  := sorry --non-trivial
lemma new_lemma_103066 (h0 : ring (random_gen (has_top fun_info))) : strong_rank_condition (random_gen (has_top fun_info)) := sorry --non-trivial
lemma new_lemma_103067 (h0 : not (topological_space (mul_zero_class congr_arg_kind) -> false)) : @totally_disconnected_space.{0} (mul_zero_class.{0} congr_arg_kind) (@classical.by_contradiction'.{1} (topological_space.{0} (mul_zero_class.{0} congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_103068 (h0 h1 : multiset (nondiscrete_normed_field char)) : multiset.disjoint h0 h1 := sorry --non-trivial
lemma new_lemma_103069 (h0 : topological_space (ordered_comm_ring (has_Inf (has_add Type)))) : totally_disconnected_space (ordered_comm_ring (has_Inf (has_add Type))) := sorry --non-trivial
lemma new_lemma_103070 (h0 : add_group (complete_semilattice_Sup (random_gen string_imp))) : is_add_cyclic (complete_semilattice_Sup (random_gen string_imp)) := sorry --non-trivial
lemma new_lemma_103071 (h0 : not (topological_space (linear_ordered_comm_ring unsigned) -> false)) : @preirreducible_space.{0} (linear_ordered_comm_ring.{0} unsigned) (@classical.by_contradiction'.{1} (topological_space.{0} (linear_ordered_comm_ring.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_103072 (h0 : semiring (normed_lattice_add_comm_group (has_add (has_Inf Type)))) : is_noetherian_ring (normed_lattice_add_comm_group (has_add (has_Inf Type))) := sorry --non-trivial
lemma new_lemma_103073 (h1 : group (topological_space (random_gen (random_gen string_imp)))) : group.fg (topological_space (random_gen (random_gen string_imp))) := sorry --non-trivial
lemma new_lemma_103074 (h0 : option (option num) -> option (option num) -> Prop) : is_antisymm (option (option num)) h0 := sorry --non-trivial
lemma new_lemma_103075 (h1 : has_lt (simple_graph linarith.ineq)) : no_max_order (simple_graph linarith.ineq) := sorry --non-trivial
lemma new_lemma_103076 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @rank_condition.{0} (with_one.{0} (random_gen.{0} (comm_ring.{0} (random_gen.{0} fun_info)))) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (with_one.{0} (random_gen.{0} (comm_ring.{0} (random_gen.{0} fun_info)))))  := sorry --non-trivial
lemma new_lemma_103077 (h0 : function.extfun Type topological_space) : @irreducible_space.{0} (ordered_cancel_comm_monoid.{0} ennreal) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (ordered_cancel_comm_monoid.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_103078 (h1 : function.extfun Type complete_lattice) : @complete_lattice.is_Sup_finite_compact.{0} congr_arg_kind (@function.extfun_app.{2 1} Type complete_lattice.{0} h1 congr_arg_kind)  := sorry --non-trivial
lemma new_lemma_103079 (h0 : topological_space (monoid (option num))) : preirreducible_space (monoid (option num)) := sorry --non-trivial
lemma new_lemma_103080 (h0 : functor.add_const (topological_space (omega_complete_partial_order unsigned)) empty) : @t0_space.{0} (omega_complete_partial_order.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (omega_complete_partial_order.{0} unsigned)) empty h0)  := sorry --non-trivial
lemma new_lemma_103081 (h0 : monoid (has_norm (has_norm linarith.comp))) : monoid.fg (has_norm (has_norm linarith.comp)) := sorry --non-trivial
lemma new_lemma_103082 (h0 : has_mem.mem (semiring empty) has_emptyc.emptyc) : @separated_space.{0} (semiring.{0} empty) (@finset.pi.empty.{1 0} Type uniform_space.{0} (semiring.{0} empty) h0)  := sorry --non-trivial
lemma new_lemma_103083 (h0 : functor.add_const (uniform_space Type) linarith.comp) : @separated_space.{1} Type (@functor.add_const.run.{1 0} (uniform_space.{1} Type) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_103084 (h0 : functor.add_const (list ennreal) (option (option (option num)))) : list.nodup (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_103085 (h0 : topological_space (option (option pos))) : sequential_space (option (option pos)) := sorry --non-trivial
lemma new_lemma_103086 (h2 : not (topological_space (encodable fun_info) -> false)) : @path_connected_space.{0} (encodable.{0} fun_info) (@classical.by_contradiction'.{1} (topological_space.{0} (encodable.{0} fun_info)) h2)  := sorry --non-trivial
lemma new_lemma_103087 (h1 : not (ring (denumerable reducibility_hints) -> false)) : @is_domain.{0} (denumerable.{0} reducibility_hints) (@classical.by_contradiction'.{1} (ring.{0} (denumerable.{0} reducibility_hints)) h1)  := sorry --non-trivial
lemma new_lemma_103088 (h1 : semiring char) (h2 : char) : even h2 := sorry --non-trivial
lemma new_lemma_103089 (h0 : topological_space (has_pos_part linarith.comp)) : totally_disconnected_space (has_pos_part linarith.comp) := sorry --non-trivial
lemma new_lemma_103090 (h0 : group (has_zero (add_semigroup (finset (finset linarith.comp))))) : group.fg (has_zero (add_semigroup (finset (finset linarith.comp)))) := sorry --non-trivial
lemma new_lemma_103091 (h0 : topological_space (has_zero (has_add unsigned))) : sequential_space (has_zero (has_add unsigned)) := sorry --non-trivial
lemma new_lemma_103092 (h0 : topological_space to_additive.value_type) : path_connected_space to_additive.value_type := sorry --non-trivial
lemma new_lemma_103093 (h1 : ring (comm_ring (random_gen (random_gen char)))) : rank_condition (comm_ring (random_gen (random_gen char))) := sorry --non-trivial
lemma new_lemma_103094 (h0 : topological_space (sub_neg_monoid (sub_neg_monoid pos))) : loc_path_connected_space (sub_neg_monoid (sub_neg_monoid pos)) := sorry --non-trivial
lemma new_lemma_103095 (h0 : function.extfun Type ring) : @is_domain.{0} (ordered_comm_group.{0} empty) (@function.extfun_app.{2 1} Type ring.{0} h0 (ordered_comm_group.{0} empty))  := sorry --non-trivial
lemma new_lemma_103096 (h0 : topological_space (random_gen (random_gen char))) : t0_space (random_gen (random_gen char)) := sorry --non-trivial
lemma new_lemma_103097 (h0 : topological_space (denumerable (has_nnnorm linarith.ineq))) : totally_disconnected_space (denumerable (has_nnnorm linarith.ineq)) := sorry --non-trivial
lemma new_lemma_103098 (h0 : topological_space (has_add (has_neg (has_zero name)))) : locally_compact_space (has_add (has_neg (has_zero name))) := sorry --non-trivial
lemma new_lemma_103099 (h1 : not (topological_space (random_gen char) -> false)) : @totally_disconnected_space.{0} (random_gen.{0} char) (@classical.by_contradiction'.{1} (topological_space.{0} (random_gen.{0} char)) h1)  := sorry --non-trivial
lemma new_lemma_103100 (h3 : not (topological_space (distrib_lattice to_additive.value_type) -> false)) : @path_connected_space.{0} (distrib_lattice.{0} to_additive.value_type) (@classical.by_contradiction'.{1} (topological_space.{0} (distrib_lattice.{0} to_additive.value_type)) h3)  := sorry --non-trivial
lemma new_lemma_103101 (h0 : function.extfun Type topological_space) : @t0_space.{0} (complete_distrib_lattice.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (complete_distrib_lattice.{0} empty))  := sorry --non-trivial
lemma new_lemma_103102 (h0 : ring (fintype (random_gen (has_nnnorm char)))) : strong_rank_condition (fintype (random_gen (has_nnnorm char))) := sorry --non-trivial
lemma new_lemma_103103 (h0 : has_mem.mem group has_emptyc.emptyc) : @is_cyclic.{0} (normed_group.{0} fun_info) (@function.extfun_app.{2 1} Type group.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) group.{0} h0) (normed_group.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_103104 (h1 : finset ereal) : finset.nonempty h1 := sorry --non-trivial
lemma new_lemma_103105 (h0 : ring (normed_group (has_ssubset string_imp))) : is_domain (normed_group (has_ssubset string_imp)) := sorry --non-trivial
lemma new_lemma_103106 (h0 : group (has_bot (has_add (has_add (has_Inf Type))))) : normalizer_condition (has_bot (has_add (has_add (has_Inf Type)))) := sorry --non-trivial
lemma new_lemma_103107 (h0 : ring (normed_group (has_nnnorm (random_gen fun_info)))) : strong_rank_condition (normed_group (has_nnnorm (random_gen fun_info))) := sorry --non-trivial
lemma new_lemma_103108 (h0 : fin has_zero.zero) : @is_cyclic.{0} (generalized_boolean_algebra.{0} pos) (@matrix.vec_empty.{0} (group.{0} (generalized_boolean_algebra.{0} pos)) h0)  := sorry --non-trivial
lemma new_lemma_103109 (h0 : topological_space (linear_order congr_arg_kind)) : path_connected_space (linear_order congr_arg_kind) := sorry --non-trivial
lemma new_lemma_103110 (h0 : function.extfun Type topological_space) : @normal_space.{0} (cancel_monoid.{0} (option.{0} congr_arg_kind)) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (cancel_monoid.{0} (option.{0} congr_arg_kind)))  := sorry --non-trivial
lemma new_lemma_103111 (h1 : uniform_space (with_one (random_gen (with_bot linarith.comp_source)))) : complete_space (with_one (random_gen (with_bot linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_103112 (h0 : function.extfun (Type 1) uniform_space) : @complete_space.{1} (has_nndist.{1} Type) (@function.extfun_app.{3 2} (Type 1) uniform_space.{1} h0 (has_nndist.{1} Type))  := sorry --non-trivial
lemma new_lemma_103113 (h0 : group (non_assoc_semiring num)) : is_cyclic (non_assoc_semiring num) := sorry --non-trivial
lemma new_lemma_103114 (h0 : ring (add_comm_monoid (cancel_monoid (option Type)))) : rank_condition (add_comm_monoid (cancel_monoid (option Type))) := sorry --non-trivial
lemma new_lemma_103115 (h1 : topological_space (with_one congr_arg_kind)) : totally_disconnected_space (with_one congr_arg_kind) := sorry --non-trivial
lemma new_lemma_103116 (h0 : has_lt (has_compl (mul_one_class std_gen))) : no_max_order (has_compl (mul_one_class std_gen)) := sorry --non-trivial
lemma new_lemma_103117 (h0 : function.extfun Type topological_space) : @loc_path_connected_space.{0} (semigroup.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (semigroup.{0} pos))  := sorry --non-trivial
lemma new_lemma_103118 (h0 : filter (boolean_algebra (has_add (has_Inf linarith.comp)))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_103119 (h0 : topological_space (has_append fun_info)) : totally_disconnected_space (has_append fun_info) := sorry --non-trivial
lemma new_lemma_103120 (h0 : functor.add_const (topological_space (has_Sup congr_arg_kind)) unsigned) : @totally_separated_space.{0} (has_Sup.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (has_Sup.{0} congr_arg_kind)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_103121 (h0 : topological_space (filter (option (option (option empty))))) : path_connected_space (filter (option (option (option empty)))) := sorry --non-trivial
lemma new_lemma_103122 (h0 : ring (metric_space to_additive.value_type)) : strong_rank_condition (metric_space to_additive.value_type) := sorry --non-trivial
lemma new_lemma_103123 (h0 : uniform_space (has_neg_part pos)) : separated_space (has_neg_part pos) := sorry --non-trivial
lemma new_lemma_103124 (h0 : function.extfun (Type 1) uniform_space) : @separated_space.{1} (plift.{1} congr_arg_kind) (@function.extfun_app.{3 2} (Type 1) uniform_space.{1} h0 (plift.{1} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_103125 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : palindrome (function.extfun_app (function.extfun_app h0 list) (pseudo_metric_space empty)) := sorry --non-trivial
lemma new_lemma_103126 (h0 : topological_space (has_sub (semiring (semiring congr_arg_kind)))) : path_connected_space (has_sub (semiring (semiring congr_arg_kind))) := sorry --non-trivial
lemma new_lemma_103127 (h0 : functor.add_const (finset auto.case_option) unsigned) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_103128 (h0 : function.extfun Type topological_space) : @topological_space.separable_space.{0} (boolean_algebra.{0} (add_comm_monoid.{0} name)) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (boolean_algebra.{0} (add_comm_monoid.{0} name)))  := sorry --non-trivial
lemma new_lemma_103129 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @normal_space.{0} (has_top.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_top.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_103130 (h0 : functor.add_const (functor.add_const (cancel_comm_monoid_with_zero pos) unsigned) unsigned) : @unique_factorization_monoid.{0} pos (@functor.add_const.run.{0 0} (cancel_comm_monoid_with_zero.{0} pos) unsigned (@functor.add_const.run.{0 0} (functor.add_const.{0 0} (cancel_comm_monoid_with_zero.{0} pos) unsigned) unsigned h0))  := sorry --non-trivial
lemma new_lemma_103131 (h0 : fin has_zero.zero) : @Lim.{0} Prop sierpinski_space (@nonempty_of_inhabited.{1} Prop sort.inhabited.{0}) (@list.head.{0} (filter.{0} Prop) (@filter.inhabited.{0} Prop) (@matrix.vec_empty.{0} (list.{0} (filter.{0} Prop)) (@matrix.vec_empty.{0} (fin (@has_zero.zero.{0} nat nat.has_zero)) (@matrix.vec_empty.{0} (fin (@has_zero.zero.{0} nat nat.has_zero)) (@id.{1} (fin (@has_zero.zero.{0} nat nat.has_zero)) h0)))))  := sorry --non-trivial
lemma new_lemma_103132 (h0 : functor.add_const (topological_space (has_add Type)) environment.implicit_infer_kind) : @regular_space.{1} (has_add.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (has_add.{1} Type)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_103133 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @path_connected_space.{0} (add_right_cancel_monoid.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (add_right_cancel_monoid.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_103134 (h0 : functor.add_const (function.extfun Type topological_space) pos) : @t0_space.{0} (has_add.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) pos h0) (has_add.{0} pos))  := sorry --non-trivial
lemma new_lemma_103135 (h0 : not (semiring (metric_space congr_arg_kind) -> false)) : @is_noetherian_ring.{0} (metric_space.{0} congr_arg_kind) (@classical.by_contradiction'.{1} (semiring.{0} (metric_space.{0} congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_103136 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_noetherian_ring.{0} (semiring.{0} num) (@function.extfun_app.{2 1} Type semiring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 semiring.{0}) (semiring.{0} num))  := sorry --non-trivial
lemma new_lemma_103137 (h0 : functor.add_const (ring (normed_comm_ring Type)) environment.implicit_infer_kind) : @is_domain.{1} (normed_comm_ring.{1} Type) (@functor.add_const.run.{1 0} (ring.{1} (normed_comm_ring.{1} Type)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_103138 (h0 : functor.add_const (ordered_add_comm_monoid (has_zero name)) Type) : @archimedean.{0} (has_zero.{0} name) (@functor.add_const.run.{0 1} (ordered_add_comm_monoid.{0} (has_zero.{0} name)) Type h0)  := sorry --non-trivial
lemma new_lemma_103139 (h0 : function.extfun Type ring) : @rank_condition.{0} (monoid.{0} empty) (@function.extfun_app.{2 1} Type ring.{0} h0 (monoid.{0} empty))  := sorry --non-trivial
lemma new_lemma_103140 (h0 : monoid (has_zero (has_add Type))) : monoid.fg (has_zero (has_add Type)) := sorry --non-trivial
lemma new_lemma_103141 (h0 : function.extfun (Type 1) topological_space) : @path_connected_space.{1} (has_Inf.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} h0 (has_Inf.{1} Type))  := sorry --non-trivial
lemma new_lemma_103142 (h0 : topological_space (complete_semilattice_Sup (has_nnnorm fun_info))) : locally_compact_space (complete_semilattice_Sup (has_nnnorm fun_info)) := sorry --non-trivial
lemma new_lemma_103143 (h3 : add_group (normed_field char)) : is_add_cyclic (normed_field char) := sorry --non-trivial
lemma new_lemma_103144 (h0 : topological_space (add_cancel_comm_monoid unsigned)) : loc_path_connected_space (add_cancel_comm_monoid unsigned) := sorry --non-trivial
lemma new_lemma_103145 (h1 : topological_space (normed_group linarith.comp_source)) : totally_disconnected_space (normed_group linarith.comp_source) := sorry --non-trivial
lemma new_lemma_103146 (h0 : add_group (finset unsigned)) : is_add_cyclic (finset unsigned) := sorry --non-trivial
lemma new_lemma_103147 (h0 : functor.add_const (ordered_comm_monoid (boolean_algebra pos)) (finset pos)) : @has_exists_mul_of_le.{0} (boolean_algebra.{0} pos) (@functor.add_const.run.{0 0} (ordered_comm_monoid.{0} (boolean_algebra.{0} pos)) (finset.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_103148 (h0 : functor.add_const Prop (has_pos_part (has_Inf (has_add (has_Inf Type))))) : functor.add_const.run h0 := sorry --non-trivial
lemma new_lemma_103149 (h0 : functor.add_const (finset (ordered_comm_ring linarith.comp)) linarith.comp) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_103150 (h0 : group (ordered_comm_ring (has_Inf pos))) : group.fg (ordered_comm_ring (has_Inf pos)) := sorry --non-trivial
lemma new_lemma_103151 (h0 : complete_lattice (with_bot empty)) : is_atomistic (with_bot empty) := sorry --non-trivial
lemma new_lemma_103152 (h0 : function.extfun Type (functor.add_const (topological_space (measurable_space.dynkin_system unsigned)))) : @t1_space.{0} (measurable_space.dynkin_system.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (measurable_space.dynkin_system.{0} unsigned)) empty (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (topological_space.{0} (measurable_space.dynkin_system.{0} unsigned))) h0 empty))  := sorry --non-trivial
lemma new_lemma_103153 (h0 : not (add_monoid (with_bot num) -> false)) : @add_monoid.fg.{0} (with_bot.{0} num) (@classical.by_contradiction'.{1} (add_monoid.{0} (with_bot.{0} num)) h0)  := sorry --non-trivial
lemma new_lemma_103154 (h0 : functor.add_const (ring (plift empty)) (semiring num)) : @rank_condition.{1} (plift.{1} empty) (@functor.add_const.run.{1 0} (ring.{1} (plift.{1} empty)) (semiring.{0} num) h0)  := sorry --non-trivial
lemma new_lemma_103155 (h0 : ring (mul_zero_class congr_arg_kind)) : rank_condition (mul_zero_class congr_arg_kind) := sorry --non-trivial
lemma new_lemma_103156 (h0 : topological_space (comm_ring (has_nnnorm (has_nnnorm string.iterator_imp)))) : t0_space (comm_ring (has_nnnorm (has_nnnorm string.iterator_imp))) := sorry --non-trivial
lemma new_lemma_103157 (h0 : functor.add_const (topological_space (has_zero pos)) linarith.comp) : @sequential_space.{0} (has_zero.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (has_zero.{0} pos)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_103158 (h0 : functor.add_const Prop (has_neg_part (mul_zero_class (mul_zero_class unsigned)))) : functor.add_const.run h0 := sorry --non-trivial
lemma new_lemma_103159 (h0 : function.extfun (Type 1) topological_space) : @totally_disconnected_space.{1} (complete_distrib_lattice.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} h0 (complete_distrib_lattice.{1} Type))  := sorry --non-trivial
lemma new_lemma_103160 (h0 : ring (linear_ordered_comm_group_with_zero reducibility_hints)) : strong_rank_condition (linear_ordered_comm_group_with_zero reducibility_hints) := sorry --non-trivial
lemma new_lemma_103161 (h0 : not (ring (complete_linear_order congr_arg_kind) -> false)) : @is_principal_ideal_ring.{0} (complete_linear_order.{0} congr_arg_kind) (@classical.by_contradiction'.{1} (ring.{0} (complete_linear_order.{0} congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_103162 (h0 : function.extfun Type list) : list.nodup (function.extfun_app h0 (has_add pos)) := sorry --non-trivial
lemma new_lemma_103163 (h0 : fin has_zero.zero) : @is_compactly_generated.{0} (normed_lattice_add_comm_group.{0} pos) (@matrix.vec_empty.{0} (complete_lattice.{0} (normed_lattice_add_comm_group.{0} pos)) h0)  := sorry --non-trivial
lemma new_lemma_103164 (h0 : topological_space (comm_semigroup (sub_neg_monoid real))) : topological_space.separable_space (comm_semigroup (sub_neg_monoid real)) := sorry --non-trivial
lemma new_lemma_103165 (h0 : monoid (complete_semilattice_Sup to_additive.value_type)) : monoid.fg (complete_semilattice_Sup to_additive.value_type) := sorry --non-trivial
lemma new_lemma_103166 (h0 : fin has_zero.zero) : @normal_space.{0} (sub_neg_monoid.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@matrix.vec_empty.{1} (function.extfun.{2 1} Type topological_space.{0}) h0) (sub_neg_monoid.{0} pos))  := sorry --non-trivial
lemma new_lemma_103167 (h0 : finset (add_group (semiring num))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_103168 (h0 : topological_space (has_to_string Type)) : t1_space (has_to_string Type) := sorry --non-trivial
lemma new_lemma_103169 (h0 : functor.add_const (topological_space (has_neg Type)) (ordered_ring name)) : @irreducible_space.{1} (has_neg.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (has_neg.{1} Type)) (ordered_ring.{0} name) h0)  := sorry --non-trivial
lemma new_lemma_103170 (h2 : preorder (mul_one_class (mul_one_class char))) (h3 : set (mul_one_class (mul_one_class char))) : set.is_pwo h3 := sorry --non-trivial
lemma new_lemma_103171 (h0 : ring (topological_space (comm_ring (comm_ring char)))) : rank_condition (topological_space (comm_ring (comm_ring char))) := sorry --non-trivial
lemma new_lemma_103172 (h0 : not (ring (semiring empty) -> false)) : @strong_rank_condition.{0} (semiring.{0} empty) (@classical.by_contradiction'.{1} (ring.{0} (semiring.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_103173 (h0 : fin has_zero.zero) : @is_noetherian_ring.{1} (normed_lattice_add_comm_group.{1} Type) (@matrix.vec_empty.{1} (semiring.{1} (normed_lattice_add_comm_group.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_103174 (h3 : prod (add_comm_semigroup linarith.ineq) (add_comm_semigroup linarith.ineq)) : set.diagonal (add_comm_semigroup linarith.ineq) h3 := sorry --non-trivial
lemma new_lemma_103175 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @unique_factorization_monoid.{0} (boolean_algebra.core.{0} linarith.comp) (@function.extfun_app.{2 1} Type cancel_comm_monoid_with_zero.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 cancel_comm_monoid_with_zero.{0}) (boolean_algebra.core.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_103176 (h2 : uniform_space (linear_ordered_add_comm_group fun_info)) : complete_space (linear_ordered_add_comm_group fun_info) := sorry --non-trivial
lemma new_lemma_103177 (h0 : functor.add_const (group (bin_tree empty)) empty) : @group.fg.{0} (bin_tree.{0} empty) (@functor.add_const.run.{0 0} (group.{0} (bin_tree.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_103178 (h0 : ordered_add_comm_monoid (plift (free_add_monoid (option unsigned)))) : archimedean (plift (free_add_monoid (option unsigned))) := sorry --non-trivial
lemma new_lemma_103179 (h0 : monoid (linear_ordered_comm_ring (semiring unsigned))) : monoid.fg (linear_ordered_comm_ring (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_103180 (h0 : topological_space (linear_ordered_comm_ring to_additive.value_type)) : totally_disconnected_space (linear_ordered_comm_ring to_additive.value_type) := sorry --non-trivial
lemma new_lemma_103181 (h0 : topological_space (boolean_algebra.core empty)) : preconnected_space (boolean_algebra.core empty) := sorry --non-trivial
lemma new_lemma_103182 (h0 : functor.comp topological_space normed_comm_ring pos) : @totally_disconnected_space.{0} (normed_comm_ring.{0} pos) (@functor.comp.run.{0 0 0} topological_space.{0} normed_comm_ring.{0} pos h0)  := sorry --non-trivial
lemma new_lemma_103183 (h0 : topological_space (boolean_algebra.core (boolean_algebra.core linarith.comp))) : irreducible_space (boolean_algebra.core (boolean_algebra.core linarith.comp)) := sorry --non-trivial
lemma new_lemma_103184 (h0 : fin has_zero.zero) : @totally_disconnected_space.{0} (comm_semigroup.{0} linarith.comp) (@matrix.vec_empty.{0} (topological_space.{0} (comm_semigroup.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_103185 (h0 : functor.add_const (monoid (add_cancel_monoid Type)) pos) : @monoid.fg.{1} (add_cancel_monoid.{1} Type) (@functor.add_const.run.{1 0} (monoid.{1} (add_cancel_monoid.{1} Type)) pos h0)  := sorry --non-trivial
lemma new_lemma_103186 (h0 : list (boolean_algebra (normed_comm_ring name))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_103187 (h0 : finset (comm_group (boolean_algebra Type))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_103188 (h0 : function.extfun Type topological_space) : @t1_space.{0} (normed_comm_ring.{0} (option.{0} pos)) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (normed_comm_ring.{0} (option.{0} pos)))  := sorry --non-trivial
lemma new_lemma_103189 (h0 : add_group (finset (finset (has_to_string environment.implicit_infer_kind)))) : is_add_cyclic (finset (finset (has_to_string environment.implicit_infer_kind))) := sorry --non-trivial
lemma new_lemma_103190 (h0 : topological_space (has_norm (semiring (semiring congr_arg_kind)))) : normal_space (has_norm (semiring (semiring congr_arg_kind))) := sorry --non-trivial
lemma new_lemma_103191 (h1 : not (topological_space (complete_semilattice_Sup congr_arg_kind) -> false)) : @totally_disconnected_space.{0} (complete_semilattice_Sup.{0} congr_arg_kind) (@classical.by_contradiction'.{1} (topological_space.{0} (complete_semilattice_Sup.{0} congr_arg_kind)) h1)  := sorry --non-trivial
lemma new_lemma_103192 (h2 : pfun num linarith.ineq) (h3 : num) : pfun.dom h2 h3 := sorry --non-trivial
lemma new_lemma_103193 (h0 : semiring (semiring linarith.comp)) : is_noetherian_ring (semiring linarith.comp) := sorry --non-trivial
lemma new_lemma_103194 (h0 : ring (has_zero pos)) : is_domain (has_zero pos) := sorry --non-trivial
lemma new_lemma_103195 (h0 : function.extfun Type filter) : filter.ne_bot (function.extfun_app h0 (linear_ordered_field (option ennreal))) := sorry --non-trivial
lemma new_lemma_103196 (h0 : functor.add_const (filter (has_neg linarith.comp)) pos) : filter.ne_bot (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_103197 (h0 : not (function.extfun Type complete_lattice -> false)) : @complete_lattice.is_Sup_finite_compact.{0} (normed_group.{0} fun_info) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type complete_lattice.{0}) h0) (normed_group.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_103198 (h2 : add_group (has_ssubset (add_comm_semigroup reducibility_hints))) : is_add_cyclic (has_ssubset (add_comm_semigroup reducibility_hints)) := sorry --non-trivial
lemma new_lemma_103199 (h0 : ring (has_one linarith.comp)) : strong_rank_condition (has_one linarith.comp) := sorry --non-trivial
lemma new_lemma_103200 (h0 : functor.add_const (add_monoid (plift unsigned)) num) : @add_monoid.fg.{1} (plift.{1} unsigned) (@functor.add_const.run.{1 0} (add_monoid.{1} (plift.{1} unsigned)) num h0)  := sorry --non-trivial
lemma new_lemma_103201 (h1 : function.extfun (set string_imp) (fun (x : set string_imp), Prop)) : is_countably_spanning (function.extfun_app h1) := sorry --non-trivial
lemma new_lemma_103202 (h0 : add_monoid (has_zero (has_add Type))) : add_monoid.fg (has_zero (has_add Type)) := sorry --non-trivial
lemma new_lemma_103203 (h0 : filter (has_neg (has_neg_part Type))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_103204 (h0 : not (function.extfun Type monoid -> false)) : @monoid.fg.{0} (add_group.{0} empty) (@function.extfun_app.{2 1} Type monoid.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type monoid.{0}) h0) (add_group.{0} empty))  := sorry --non-trivial
lemma new_lemma_103205 (h0 : topological_space (with_bot (semiring (semiring unsigned)))) : normal_space (with_bot (semiring (semiring unsigned))) := sorry --non-trivial
lemma new_lemma_103206 (h0 : topological_space (has_sub (semiring (semiring (semiring empty))))) : locally_compact_space (has_sub (semiring (semiring (semiring empty)))) := sorry --non-trivial
lemma new_lemma_103207 (h0 : topological_space linarith.comp) : regular_space linarith.comp := sorry --non-trivial
lemma new_lemma_103208 (h0 : functor.add_const (add_group (normed_comm_ring Type)) (has_neg linarith.comp)) : @is_add_cyclic.{1} (normed_comm_ring.{1} Type) (@functor.add_const.run.{1 0} (add_group.{1} (normed_comm_ring.{1} Type)) (has_neg.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_103209 (h0 : function.extfun Type ring) : @is_principal_ideal_ring.{0} (add_cancel_monoid.{0} name) (@function.extfun_app.{2 1} Type ring.{0} h0 (add_cancel_monoid.{0} name))  := sorry --non-trivial
lemma new_lemma_103210 (h0 : cancel_comm_monoid_with_zero (add_cancel_monoid (comm_group pos))) : unique_factorization_monoid (add_cancel_monoid (comm_group pos)) := sorry --non-trivial
lemma new_lemma_103211 (h0 : topological_space (has_Inf (has_add (ring linarith.comp)))) : totally_disconnected_space (has_Inf (has_add (ring linarith.comp))) := sorry --non-trivial
lemma new_lemma_103212 (h0 : group (has_bot unsigned)) : group.fg (has_bot unsigned) := sorry --non-trivial
lemma new_lemma_103213 (h0 : list (has_norm (random_gen char))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_103214 (h0 : not (function.extfun Type topological_space -> false)) : @normal_space.{0} (has_top.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (has_top.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_103215 (h0 : fin has_zero.zero) : @topological_space.separable_space.{0} (complete_distrib_lattice.{0} linarith.comp) (@matrix.vec_empty.{0} (topological_space.{0} (complete_distrib_lattice.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_103216 (h0 : topological_space (normed_comm_ring (normed_comm_ring name))) : regular_space (normed_comm_ring (normed_comm_ring name)) := sorry --non-trivial
lemma new_lemma_103217 (h0 : uniform_space string.iterator) : complete_space string.iterator := sorry --non-trivial
lemma new_lemma_103218 (h0 : monoid (boolean_algebra (has_to_string (ring Type)))) : monoid.fg (boolean_algebra (has_to_string (ring Type))) := sorry --non-trivial
lemma new_lemma_103219 (h0 : not (topological_space (topological_space to_additive.value_type) -> false)) : @totally_disconnected_space.{0} (topological_space.{0} to_additive.value_type) (@classical.by_contradiction'.{1} (topological_space.{0} (topological_space.{0} to_additive.value_type)) h0)  := sorry --non-trivial
lemma new_lemma_103220 (h0 : function.extfun (Type 1) complete_lattice) : @is_compactly_generated.{1} (finset.{1} Type) (@function.extfun_app.{3 2} (Type 1) complete_lattice.{1} h0 (finset.{1} Type))  := sorry --non-trivial
lemma new_lemma_103221 (h0 : topological_space (mul_zero_class (option pos))) : loc_path_connected_space (mul_zero_class (option pos)) := sorry --non-trivial
lemma new_lemma_103222 (h0 : functor.add_const (group (add_cancel_monoid pos)) environment.implicit_infer_kind) : @group.fg.{0} (add_cancel_monoid.{0} pos) (@functor.add_const.run.{0 0} (group.{0} (add_cancel_monoid.{0} pos)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_103223 (h0 : functor.add_const (complete_lattice (add_comm_monoid Type)) (comm_group pos)) : @complete_lattice.is_Sup_finite_compact.{1} (add_comm_monoid.{1} Type) (@functor.add_const.run.{1 0} (complete_lattice.{1} (add_comm_monoid.{1} Type)) (comm_group.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_103224 (h0 : group (semi_normed_comm_ring (has_nnnorm fun_info))) : group.fg (semi_normed_comm_ring (has_nnnorm fun_info)) := sorry --non-trivial
lemma new_lemma_103225 (h0 : list (left_cancel_semigroup (semiring (semiring empty)))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_103226 (h0 : functor.add_const (complete_lattice (semigroup environment.implicit_infer_kind)) (finset linarith.comp)) : @complete_lattice.is_Sup_finite_compact.{0} (semigroup.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (complete_lattice.{0} (semigroup.{0} environment.implicit_infer_kind)) (finset.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_103227 (h0 : topological_space (cancel_monoid (has_add (boolean_algebra.core pos)))) : locally_compact_space (cancel_monoid (has_add (boolean_algebra.core pos))) := sorry --non-trivial
lemma new_lemma_103228 (h0 : group (boolean_algebra (has_add (has_to_string name)))) : is_cyclic (boolean_algebra (has_add (has_to_string name))) := sorry --non-trivial
lemma new_lemma_103229 (h0 : functor.add_const (topological_space (generalized_boolean_algebra linarith.comp)) name) : @preirreducible_space.{0} (generalized_boolean_algebra.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (generalized_boolean_algebra.{0} linarith.comp)) name h0)  := sorry --non-trivial
lemma new_lemma_103230 (h0 : set (has_compl (mul_one_class (mul_one_class string_imp)))) : set.subsingleton h0 := sorry --non-trivial
lemma new_lemma_103231 (h0 : group (add_right_cancel_monoid (semiring empty))) : normalizer_condition (add_right_cancel_monoid (semiring empty)) := sorry --non-trivial
lemma new_lemma_103232 (h0 : functor.add_const (finset (sub_neg_monoid linarith.comp)) linarith.comp) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_103233 (h0 : functor.add_const (add_group (semigroup unsigned)) linarith.comp) : @is_add_cyclic.{0} (semigroup.{0} unsigned) (@functor.add_const.run.{0 0} (add_group.{0} (semigroup.{0} unsigned)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_103234 (h0 : functor.add_const (list (finset Type)) Type) : palindrome (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_103235 (h0 : ring (normed_comm_ring (mul_one_class linarith.comp))) : rank_condition (normed_comm_ring (mul_one_class linarith.comp)) := sorry --non-trivial
lemma new_lemma_103236 (h0 : functor.add_const (group (boolean_algebra linarith.comp)) (has_to_string pos)) : @group.fg.{0} (boolean_algebra.{0} linarith.comp) (@functor.add_const.run.{0 0} (group.{0} (boolean_algebra.{0} linarith.comp)) (has_to_string.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_103237 (h0 : function.extfun Type add_group) : @is_add_cyclic.{0} (normed_comm_ring.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type add_group.{0} h0 (normed_comm_ring.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_103238 (h0 : not (function.extfun Type ring -> false)) : @is_domain.{0} (has_top.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type ring.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type ring.{0}) h0) (has_top.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_103239 (h5 : ring (nondiscrete_normed_field string.iterator_imp)) : is_domain (nondiscrete_normed_field string.iterator_imp) := sorry --non-trivial
lemma new_lemma_103240 (h0 : topological_space (has_nndist (option unsigned))) : topological_space.separable_space (has_nndist (option unsigned)) := sorry --non-trivial
lemma new_lemma_103241 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : filter.ne_bot (function.extfun_app (function.extfun_app h0 filter) (left_cancel_semigroup unsigned)) := sorry --non-trivial
lemma new_lemma_103242 (h0 : ring (has_neg pos)) : rank_condition (has_neg pos) := sorry --non-trivial
lemma new_lemma_103243 (h0 : semiring (linear_ordered_comm_monoid_with_zero congr_arg_kind)) : is_noetherian_ring (linear_ordered_comm_monoid_with_zero congr_arg_kind) := sorry --non-trivial
lemma new_lemma_103244 (h0 : topological_space (add_group (semiring empty))) : irreducible_space (add_group (semiring empty)) := sorry --non-trivial
lemma new_lemma_103245 (h0 : ordered_comm_monoid (has_to_string (has_to_string Type))) : has_exists_mul_of_le (has_to_string (has_to_string Type)) := sorry --non-trivial
lemma new_lemma_103246 (h0 : not (filter (plift unsigned) -> false)) : filter.ne_bot (classical.by_contradiction' h0) := sorry --non-trivial
lemma new_lemma_103247 (h0 : ordered_comm_monoid (has_pos_part (ring pos))) : has_exists_mul_of_le (has_pos_part (ring pos)) := sorry --non-trivial
lemma new_lemma_103248 (h0 : with_bot (group (add_group unsigned))) (h1 : ne h0 has_bot.bot) : @is_cyclic.{0} (add_group.{0} unsigned) (@with_bot.unbot.{0} (group.{0} (add_group.{0} unsigned)) h0 h1)  := sorry --non-trivial
lemma new_lemma_103249 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_principal_ideal_ring.{0} (has_top.{0} unsigned) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (has_top.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_103250 (h0 : finset char) (h1 : char -> Prop) : @finset.sup.{0 0} Prop char (@lattice.to_semilattice_sup.{0} Prop (@conditionally_complete_lattice.to_lattice.{0} Prop (@complete_lattice.to_conditionally_complete_lattice.{0} Prop Prop.complete_lattice))) (@generalized_boolean_algebra.to_order_bot.{0} Prop (@boolean_algebra.to_generalized_boolean_algebra.{0} Prop Prop.boolean_algebra)) h0 h1  := sorry --non-trivial
lemma new_lemma_103251 (h0 : functor.add_const (finset (has_nndist name)) (option name)) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_103252 (h0 : topological_space (has_bot (has_Inf name))) : loc_path_connected_space (has_bot (has_Inf name)) := sorry --non-trivial
lemma new_lemma_103253 (h0 : ordered_add_comm_monoid (has_dist (option empty))) : archimedean (has_dist (option empty)) := sorry --non-trivial
lemma new_lemma_103254 (h0 : monoid (linear_ordered_semiring (semiring (semiring num)))) : monoid.fg (linear_ordered_semiring (semiring (semiring num))) := sorry --non-trivial
lemma new_lemma_103255 (h0 : topological_space (measurable_space.dynkin_system (option (option num)))) : locally_compact_space (measurable_space.dynkin_system (option (option num))) := sorry --non-trivial
lemma new_lemma_103256 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : list.nodup (function.extfun_app (function.extfun_app h0 list) (monoid unsigned)) := sorry --non-trivial
lemma new_lemma_103257 (h0 : uniform_space (multiplicative linarith.ineq)) : complete_space (multiplicative linarith.ineq) := sorry --non-trivial
lemma new_lemma_103258 (h0 : monoid (semigroup (ring linarith.comp))) : monoid.fg (semigroup (ring linarith.comp)) := sorry --non-trivial
lemma new_lemma_103259 (h0 : function.extfun Type (prod (has_dist unsigned))) : id_rel (function.extfun_app h0 (has_dist unsigned)) := sorry --non-trivial
lemma new_lemma_103260 (h0 : functor.add_const (topological_space (semigroup name)) Type) : @irreducible_space.{0} (semigroup.{0} name) (@functor.add_const.run.{0 1} (topological_space.{0} (semigroup.{0} name)) Type h0)  := sorry --non-trivial
lemma new_lemma_103261 (h0 : functor.add_const (list (ring unsigned)) environment.implicit_infer_kind) : list.nodup (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_103262 (h0 : set (add_comm_semigroup linarith.ineq -> ereal)) : set.separates_points h0 := sorry --non-trivial
lemma new_lemma_103263 (h0 : functor.add_const (add_monoid (has_neg name)) name) : @add_monoid.fg.{0} (has_neg.{0} name) (@functor.add_const.run.{0 0} (add_monoid.{0} (has_neg.{0} name)) name h0)  := sorry --non-trivial
lemma new_lemma_103264 (h0 : cancel_comm_monoid_with_zero (has_to_string (comm_group (comm_group (comm_group unsigned))))) : unique_factorization_monoid (has_to_string (comm_group (comm_group (comm_group unsigned)))) := sorry --non-trivial
lemma new_lemma_103265 (h0 : prod (canonically_ordered_comm_semiring (option ennreal)) (canonically_ordered_comm_semiring (option ennreal))) : id_rel h0 := sorry --non-trivial
lemma new_lemma_103266 (h0 : topological_space (has_neg_part (boolean_algebra Type))) : preirreducible_space (has_neg_part (boolean_algebra Type)) := sorry --non-trivial
lemma new_lemma_103267 (h0 : topological_space (has_dist (has_dist (comm_monoid unsigned)))) : locally_compact_space (has_dist (has_dist (comm_monoid unsigned))) := sorry --non-trivial
lemma new_lemma_103268 (h1 : complete_lattice (with_bot string_imp)) : is_compactly_generated (with_bot string_imp) := sorry --non-trivial
lemma new_lemma_103269 (h0 : functor.add_const (function.extfun Type semiring) pos) : @is_noetherian_ring.{0} (has_to_string.{0} linarith.comp) (@function.extfun_app.{2 1} Type semiring.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type semiring.{0}) pos h0) (has_to_string.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_103270 (h0 : functor.add_const (topological_space (has_to_string environment.implicit_infer_kind)) linarith.comp) : @t1_space.{0} (has_to_string.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (has_to_string.{0} environment.implicit_infer_kind)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_103271 (h0 : function.extfun Type topological_space) : @discrete_topology.{0} (boolean_algebra.core.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (boolean_algebra.core.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_103272 (h0 : functor.add_const (topological_space (add_cancel_monoid name)) linarith.comp) : @totally_disconnected_space.{0} (add_cancel_monoid.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (add_cancel_monoid.{0} name)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_103273 (h0 : complete_lattice (has_neg_part (finset pos))) : is_compactly_generated (has_neg_part (finset pos)) := sorry --non-trivial
lemma new_lemma_103274 (h0 : function.extfun Type topological_space) : @normal_space.{0} (pseudo_metric_space.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (pseudo_metric_space.{0} num))  := sorry --non-trivial
lemma new_lemma_103275 (h1 : topological_space (has_ssubset (has_nnnorm char))) : path_connected_space (has_ssubset (has_nnnorm char)) := sorry --non-trivial
lemma new_lemma_103276 (h0 : ring (has_union (has_norm (with_bot linarith.comp)))) : rank_condition (has_union (has_norm (with_bot linarith.comp))) := sorry --non-trivial
lemma new_lemma_103277 (h0 : has_mem.mem (with_one linarith.comp_source) has_emptyc.emptyc) : @complete_lattice.is_Sup_finite_compact.{0} (with_one.{0} linarith.comp_source) (@finset.pi.empty.{1 0} Type complete_lattice.{0} (with_one.{0} linarith.comp_source) h0)  := sorry --non-trivial
lemma new_lemma_103278 (h0 : topological_space (comm_group (has_add name))) : preconnected_space (comm_group (has_add name)) := sorry --non-trivial
lemma new_lemma_103279 (h0 : functor.add_const (complete_lattice (semigroup congr_arg_kind)) congr_arg_kind) : @is_compactly_generated.{0} (semigroup.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (complete_lattice.{0} (semigroup.{0} congr_arg_kind)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_103280 (h0 : add_monoid (has_to_string (finset linarith.comp))) : add_monoid.fg (has_to_string (finset linarith.comp)) := sorry --non-trivial
lemma new_lemma_103281 (h0 : semiring (has_add (finset Type))) : is_noetherian_ring (has_add (finset Type)) := sorry --non-trivial
lemma new_lemma_103282 (h0 : ring (random_gen linarith.comp)) : is_domain (random_gen linarith.comp) := sorry --non-trivial
lemma new_lemma_103283 (h0 : topological_space (dlist (has_ssubset fun_info))) : path_connected_space (dlist (has_ssubset fun_info)) := sorry --non-trivial
lemma new_lemma_103284 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @preirreducible_space.{0} (boolean_algebra.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (boolean_algebra.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_103285 (h0 : topological_space (canonically_ordered_monoid (has_neg name))) : loc_path_connected_space (canonically_ordered_monoid (has_neg name)) := sorry --non-trivial
lemma new_lemma_103286 (h0 : topological_space (partial_order (semiring empty))) : totally_separated_space (partial_order (semiring empty)) := sorry --non-trivial
lemma new_lemma_103287 (h0 : function.extfun Type topological_space) : @normal_space.{0} (partial_order.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (partial_order.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_103288 (h0 : not (topological_space (semiring empty) -> false)) : @topological_space.separable_space.{0} (semiring.{0} empty) (@classical.by_contradiction'.{1} (topological_space.{0} (semiring.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_103289 (h0 : pnat) (h1 : thunk (ulower pnat)) : pnat.coprime h0 (@ulower.up.{0} pnat encodable.pnat (@trace_call_stack.{0} (@ulower.{0} pnat encodable.pnat) h1))  := sorry --non-trivial
lemma new_lemma_103290 (h0 : function.extfun Type topological_space) : @totally_separated_space.{0} (add_comm_monoid.{0} ennreal) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (add_comm_monoid.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_103291 (h0 : ring (sub_neg_monoid (has_Inf (has_Inf real)))) : strong_rank_condition (sub_neg_monoid (has_Inf (has_Inf real))) := sorry --non-trivial
lemma new_lemma_103292 (h0 : functor.add_const (topological_space (measurable_space.dynkin_system num)) congr_arg_kind) : @t1_space.{0} (measurable_space.dynkin_system.{0} num) (@functor.add_const.run.{0 0} (topological_space.{0} (measurable_space.dynkin_system.{0} num)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_103293 (h0 : semiring (ordered_comm_monoid (boolean_algebra.core Type))) : is_noetherian_ring (ordered_comm_monoid (boolean_algebra.core Type)) := sorry --non-trivial
lemma new_lemma_103294 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @discrete_topology.{0} congr_arg_kind (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) congr_arg_kind)  := sorry --non-trivial
lemma new_lemma_103295 (h0 : list (boolean_algebra.core congr_arg_kind)) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_103296 (h0 : topological_space (has_one (has_top (semiring linarith.comp)))) : irreducible_space (has_one (has_top (semiring linarith.comp))) := sorry --non-trivial
lemma new_lemma_103297 (h0 : not (topological_space (normed_group congr_arg_kind) -> false)) : @totally_separated_space.{0} (normed_group.{0} congr_arg_kind) (@classical.by_contradiction'.{1} (topological_space.{0} (normed_group.{0} congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_103298 (h0 : filter (has_pos_part (has_pos_part linarith.comp))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_103299 (h0 : function.extfun Type ring) : @is_domain.{0} (div_inv_monoid.{0} fun_info) (@function.extfun_app.{2 1} Type ring.{0} h0 (div_inv_monoid.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_103300 (h0 : topological_space (random_gen (has_top (has_top num)))) : irreducible_space (random_gen (has_top (has_top num))) := sorry --non-trivial
lemma new_lemma_103301 (h0 : topological_space (has_neg_part (finset name))) : totally_separated_space (has_neg_part (finset name)) := sorry --non-trivial
lemma new_lemma_103302 (h0 : group (has_zero (has_add Type))) : normalizer_condition (has_zero (has_add Type)) := sorry --non-trivial
lemma new_lemma_103303 (h0 : topological_space (has_add (has_neg environment.implicit_infer_kind))) : irreducible_space (has_add (has_neg environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_103304 (h0 : topological_space (boolean_algebra unsigned)) : t0_space (boolean_algebra unsigned) := sorry --non-trivial
lemma new_lemma_103305 (h0 : functor.add_const (topological_space ennreal) num) : locally_compact_space ennreal := sorry --non-trivial
lemma new_lemma_103306 (h0 : ring (has_neg (has_pos_part linarith.comp))) : is_domain (has_neg (has_pos_part linarith.comp)) := sorry --non-trivial
lemma new_lemma_103307 (h0 : functor.add_const (group (comm_group linarith.comp)) name) : @is_simple_group.{0} (comm_group.{0} linarith.comp) (@functor.add_const.run.{0 0} (group.{0} (comm_group.{0} linarith.comp)) name h0)  := sorry --non-trivial
lemma new_lemma_103308 (h0 : function.extfun Type group) : @group.fg.{0} (has_norm.{0} char) (@function.extfun_app.{2 1} Type group.{0} h0 (has_norm.{0} char))  := sorry --non-trivial
lemma new_lemma_103309 (h1 : complete_lattice (uniform_space (random_gen (metric_space char)))) : is_compactly_generated (uniform_space (random_gen (metric_space char))) := sorry --non-trivial
lemma new_lemma_103310 (h0 : not (ring (semi_normed_ring linarith.comp_source) -> false)) : @rank_condition.{0} (semi_normed_ring.{0} linarith.comp_source) (@classical.by_contradiction'.{1} (ring.{0} (semi_normed_ring.{0} linarith.comp_source)) h0)  := sorry --non-trivial
lemma new_lemma_103311 (h0 : topological_space (id unsigned)) : discrete_topology (id unsigned) := sorry --non-trivial
lemma new_lemma_103312 (h2 : uniform_space (denumerable fun_info)) : complete_space (denumerable fun_info) := sorry --non-trivial
lemma new_lemma_103313 (h0 : topological_space (with_one string_imp)) : t0_space (with_one string_imp) := sorry --non-trivial
lemma new_lemma_103314 (h1 : topological_space (linear_ordered_cancel_add_comm_monoid ereal)) : path_connected_space (linear_ordered_cancel_add_comm_monoid ereal) := sorry --non-trivial
lemma new_lemma_103315 (h0 : group (omega_complete_partial_order unsigned)) : is_cyclic (omega_complete_partial_order unsigned) := sorry --non-trivial
lemma new_lemma_103316 (h0 : complete_lattice (non_assoc_semiring (semiring (semiring (semiring (semiring unsigned)))))) : is_compactly_generated (non_assoc_semiring (semiring (semiring (semiring (semiring unsigned))))) := sorry --non-trivial
lemma new_lemma_103317 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @t0_space.{0} (has_zero.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_zero.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_103318 (h0 : function.extfun ((Type -> Type) -> Type 1) (function.extfun (Type -> Type))) : @path_connected_space.{0} (has_norm.{0} linarith.ineq) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) (@function.extfun_app.{3 2} ((Type → Type) → Type 1) (function.extfun.{2 2} (Type → Type)) (@id.{3} (function.extfun.{3 2} ((Type → Type) → Type 1) (function.extfun.{2 2} (Type → Type))) h0) (function.extfun.{2 1} Type)) topological_space.{0}) (has_norm.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_103319 (h0 : functor.add_const (function.extfun (Type 1) uniform_space) Type) : @complete_space.{1} (has_nndist.{1} Type) (@function.extfun_app.{3 2} (Type 1) uniform_space.{1} (@functor.add_const.run.{2 1} (function.extfun.{3 2} (Type 1) uniform_space.{1}) Type h0) (has_nndist.{1} Type))  := sorry --non-trivial
lemma new_lemma_103320 (h2 : ring (add_comm_semigroup fun_info)) : rank_condition (add_comm_semigroup fun_info) := sorry --non-trivial
lemma new_lemma_103321 (h0 : topological_space (has_bot (has_Inf real))) : sequential_space (has_bot (has_Inf real)) := sorry --non-trivial
lemma new_lemma_103322 (h0 : topological_space (distrib_lattice (has_top (has_top (has_top fun_info))))) : totally_disconnected_space (distrib_lattice (has_top (has_top (has_top fun_info)))) := sorry --non-trivial
lemma new_lemma_103323 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @preirreducible_space.{0} (canonically_linear_ordered_monoid.{0} ennreal) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (canonically_linear_ordered_monoid.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_103324 (h0 : cancel_comm_monoid_with_zero (semigroup (option (option unsigned)))) : unique_factorization_monoid (semigroup (option (option unsigned))) := sorry --non-trivial
lemma new_lemma_103325 (h0 : topological_space (linear_ordered_comm_monoid_with_zero unsigned)) : irreducible_space (linear_ordered_comm_monoid_with_zero unsigned) := sorry --non-trivial
lemma new_lemma_103326 (h0 : topological_space (generalized_boolean_algebra Type)) : locally_compact_space (generalized_boolean_algebra Type) := sorry --non-trivial
lemma new_lemma_103327 (h0 : monoid (has_add (finset name))) : monoid.fg (has_add (finset name)) := sorry --non-trivial
lemma new_lemma_103328 (h0 : function.extfun Type group) : @group.fg.{0} (has_nnnorm.{0} char) (@function.extfun_app.{2 1} Type group.{0} h0 (has_nnnorm.{0} char))  := sorry --non-trivial
lemma new_lemma_103329 (h0 : functor.add_const (ordered_add_comm_monoid (comm_monoid empty)) empty) : @archimedean.{0} (comm_monoid.{0} empty) (@functor.add_const.run.{0 0} (ordered_add_comm_monoid.{0} (comm_monoid.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_103330 (h0 : functor.add_const (list (has_pos_part name)) (has_neg pos)) : palindrome (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_103331 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : filter.ne_bot (function.extfun_app (function.extfun_app h0 filter) (ordered_comm_group empty)) := sorry --non-trivial
lemma new_lemma_103332 (h0 : functor.add_const (function.extfun Type add_group) name) : @is_add_cyclic.{0} (add_cancel_monoid.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type add_group.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type add_group.{0}) name h0) (add_cancel_monoid.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_103333 (h0 : ring (has_append (random_gen linarith.comp_source))) : strong_rank_condition (has_append (random_gen linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_103334 (h1 : ring (normed_field enat)) : strong_rank_condition (normed_field enat) := sorry --non-trivial
lemma new_lemma_103335 (h0 : monoid (add_group unsigned)) : monoid.fg (add_group unsigned) := sorry --non-trivial
lemma new_lemma_103336 (h0 : functor.add_const (topological_space (mul_zero_class Type)) name) : @preirreducible_space.{1} (mul_zero_class.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (mul_zero_class.{1} Type)) name h0)  := sorry --non-trivial
lemma new_lemma_103337 (h0 : ring (has_zero (has_add pos))) : rank_condition (has_zero (has_add pos)) := sorry --non-trivial
lemma new_lemma_103338 (h0 : function.extfun Type monoid) : @monoid.fg.{0} (canonically_linear_ordered_monoid.{0} pos) (@function.extfun_app.{2 1} Type monoid.{0} h0 (canonically_linear_ordered_monoid.{0} pos))  := sorry --non-trivial
lemma new_lemma_103339 (h1 : topological_space (has_norm linarith.comp)) : irreducible_space (has_norm linarith.comp) := sorry --non-trivial
lemma new_lemma_103340 (h0 : group (has_norm (measurable_space congr_arg_kind))) : is_cyclic (has_norm (measurable_space congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_103341 (h0 : topological_space (has_add (option unsigned))) : preconnected_space (has_add (option unsigned)) := sorry --non-trivial
lemma new_lemma_103342 (h0 : ring (comm_semigroup Type)) : rank_condition (comm_semigroup Type) := sorry --non-trivial
lemma new_lemma_103343 (h0 : functor.add_const (topological_space (semigroup environment.implicit_infer_kind)) name) : @loc_path_connected_space.{0} (semigroup.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (semigroup.{0} environment.implicit_infer_kind)) name h0)  := sorry --non-trivial
lemma new_lemma_103344 (h0 : functor.add_const (topological_space (add_cancel_monoid pos)) unsigned) : @discrete_topology.{0} (add_cancel_monoid.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (add_cancel_monoid.{0} pos)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_103345 (h0 : not (topological_space (measurable_space to_additive.value_type) -> false)) : @path_connected_space.{0} (measurable_space.{0} to_additive.value_type) (@classical.by_contradiction'.{1} (topological_space.{0} (measurable_space.{0} to_additive.value_type)) h0)  := sorry --non-trivial
lemma new_lemma_103346 (h0 : function.extfun Type group) : @group.fg.{0} (complete_distrib_lattice.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type group.{0} h0 (complete_distrib_lattice.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_103347 (h0 : function.extfun Type monoid) : @monoid.fg.{0} (preorder.{0} empty) (@function.extfun_app.{2 1} Type monoid.{0} h0 (preorder.{0} empty))  := sorry --non-trivial
lemma new_lemma_103348 (h0 : function.extfun Type filter) : countable_Inter_filter (function.extfun_app h0 (normed_comm_ring name)) := sorry --non-trivial
lemma new_lemma_103349 (h0 : function.extfun nat fin) : @unique_factorization_monoid.{0} (has_pos_part.{0} real) (@function.extfun_app.{2 1} Type cancel_comm_monoid_with_zero.{0} (@matrix.vec_empty.{1} (function.extfun.{2 1} Type cancel_comm_monoid_with_zero.{0}) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero))) (has_pos_part.{0} real))  := sorry --non-trivial
lemma new_lemma_103350 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @preconnected_space.{0} (linear_order.{0} ennreal) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (linear_order.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_103351 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_domain.{0} (monoid_with_zero.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (monoid_with_zero.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_103352 (h0 : topological_space (ordered_comm_ring linarith.comp)) : path_connected_space (ordered_comm_ring linarith.comp) := sorry --non-trivial
lemma new_lemma_103353 (h0 : monoid (finset Type)) : monoid.fg (finset Type) := sorry --non-trivial
lemma new_lemma_103354 (h0 : functor.add_const (topological_space (boolean_algebra Type)) Type) : @t0_space.{1} (boolean_algebra.{1} Type) (@functor.add_const.run.{1 1} (topological_space.{1} (boolean_algebra.{1} Type)) Type h0)  := sorry --non-trivial
lemma new_lemma_103355 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @totally_separated_space.{0} (comm_group.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (comm_group.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_103356 (h0 : functor.add_const (topological_space (semigroup (comm_group (comm_group pos)))) Type) : @t1_space.{0} (semigroup.{0} (comm_group.{0} (comm_group.{0} pos))) (@functor.add_const.run.{0 1} (topological_space.{0} (semigroup.{0} (comm_group.{0} (comm_group.{0} pos)))) Type h0)  := sorry --non-trivial
lemma new_lemma_103357 (h0 : not (function.extfun Type topological_space -> false)) : @irreducible_space.{0} (has_union.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (has_union.{0} empty))  := sorry --non-trivial
lemma new_lemma_103358 (h0 : ordered_add_comm_monoid (ordered_cancel_add_comm_monoid congr_arg_kind)) : archimedean (ordered_cancel_add_comm_monoid congr_arg_kind) := sorry --non-trivial
lemma new_lemma_103359 (h0 : measurable_space unsigned) (h1 : has_div unsigned) : has_measurable_div₂ unsigned := sorry --non-trivial
lemma new_lemma_103360 (h0 : functor.add_const (topological_space (generalized_boolean_algebra pos)) pos) : @discrete_topology.{0} (generalized_boolean_algebra.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (generalized_boolean_algebra.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_103361 (h0 : topological_space (add_comm_monoid (has_bot (has_Inf linarith.comp)))) : sequential_space (add_comm_monoid (has_bot (has_Inf linarith.comp))) := sorry --non-trivial
lemma new_lemma_103362 (h0 : finset (canonically_ordered_comm_semiring (option unsigned))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_103363 (h0 : topological_space (metric_space congr_arg_kind)) : normal_space (metric_space congr_arg_kind) := sorry --non-trivial
lemma new_lemma_103364 (h0 : topological_space (has_lt (with_bot (uniform_space string.iterator_imp)))) (h1 : preorder (has_lt (with_bot (uniform_space string.iterator_imp)))) : order_topology (has_lt (with_bot (uniform_space string.iterator_imp))) := sorry --non-trivial
lemma new_lemma_103365 (h0 : not (function.extfun Type add_group -> false)) : @is_add_cyclic.{0} (has_emptyc.{0} fun_info) (@function.extfun_app.{2 1} Type add_group.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type add_group.{0}) h0) (has_emptyc.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_103366 (h0 : has_coe (mul_one_class (add_comm_semigroup fun_info)) Prop) (h1 : mul_one_class (add_comm_semigroup fun_info)) : @coe_b.{1 1} (mul_one_class.{0} (add_comm_semigroup.{0} fun_info)) Prop h0 h1  := sorry --non-trivial
lemma new_lemma_103367 (h1 : has_lt (has_nnnorm (mul_one_class (mul_one_class (mul_one_class string_imp))))) : no_max_order (has_nnnorm (mul_one_class (mul_one_class (mul_one_class string_imp)))) := sorry --non-trivial
lemma new_lemma_103368 (h0 : functor.add_const (function.extfun (Type 1) topological_space) linarith.comp) : @t1_space.{1} (normed_comm_ring.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) topological_space.{1}) linarith.comp h0) (normed_comm_ring.{1} Type))  := sorry --non-trivial
lemma new_lemma_103369 (h0 : functor.add_const (list (cancel_monoid name)) (ring environment.implicit_infer_kind)) : palindrome (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_103370 (h0 : uniform_space (ordered_cancel_add_comm_monoid unsigned)) : complete_space (ordered_cancel_add_comm_monoid unsigned) := sorry --non-trivial
lemma new_lemma_103371 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_principal_ideal_ring.{0} (has_neg_part.{0} unsigned) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (has_neg_part.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_103372 (h0 : prod (normed_comm_ring unsigned) (normed_comm_ring unsigned)) : id_rel h0 := sorry --non-trivial
lemma new_lemma_103373 (h0 : functor.add_const (prod nnreal nnreal) (option unsigned)) : id_rel (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_103374 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @group.fg.{0} (with_bot.{0} real.angle) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (with_bot.{0} real.angle))  := sorry --non-trivial
lemma new_lemma_103375 (h0 : cancel_comm_monoid_with_zero (canonically_ordered_monoid (has_Inf linarith.comp))) : unique_factorization_monoid (canonically_ordered_monoid (has_Inf linarith.comp)) := sorry --non-trivial
lemma new_lemma_103376 (h0 : functor.add_const (ordered_add_comm_monoid (boolean_algebra.core linarith.comp)) name) : @archimedean.{0} (boolean_algebra.core.{0} linarith.comp) (@functor.add_const.run.{0 0} (ordered_add_comm_monoid.{0} (boolean_algebra.core.{0} linarith.comp)) name h0)  := sorry --non-trivial
lemma new_lemma_103377 (h0 : functor.add_const (group (plift congr_arg_kind)) unsigned) : @normalizer_condition.{1} (plift.{1} congr_arg_kind) (@functor.add_const.run.{1 0} (group.{1} (plift.{1} congr_arg_kind)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_103378 (h0 : group (has_zero (comm_group Type))) : is_cyclic (has_zero (comm_group Type)) := sorry --non-trivial
lemma new_lemma_103379 (h0 : ring (uniform_space (mul_one_class to_additive.value_type))) : is_domain (uniform_space (mul_one_class to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_103380 (h0 : topological_space (has_neg (has_nndist pos))) : normal_space (has_neg (has_nndist pos)) := sorry --non-trivial
lemma new_lemma_103381 (h0 : not (add_group (has_compl string_imp) -> false)) : @is_add_cyclic.{0} (has_compl.{0} string_imp) (@classical.by_contradiction'.{1} (add_group.{0} (has_compl.{0} string_imp)) h0)  := sorry --non-trivial
lemma new_lemma_103382 (h0 : topological_space (plift (semiring (semiring (semiring (semiring unsigned)))))) : totally_separated_space (plift (semiring (semiring (semiring (semiring unsigned))))) := sorry --non-trivial
lemma new_lemma_103383 (h0 : functor.add_const (topological_space (cancel_monoid name)) environment.implicit_infer_kind) : @locally_compact_space.{0} (cancel_monoid.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (cancel_monoid.{0} name)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_103384 (h0 : group (complete_distrib_lattice (has_add pos))) : group.fg (complete_distrib_lattice (has_add pos)) := sorry --non-trivial
lemma new_lemma_103385 (h0 : set (has_lt (mul_one_class fun_info))) : set.finite h0 := sorry --non-trivial
lemma new_lemma_103386 (h0 : functor.add_const Prop (cancel_monoid (option empty))) : functor.add_const.run h0 := sorry --non-trivial
lemma new_lemma_103387 (h0 : functor.comp topological_space has_neg_part pos) : @normal_space.{0} (has_neg_part.{0} pos) (@functor.comp.run.{0 0 0} topological_space.{0} has_neg_part.{0} pos h0)  := sorry --non-trivial
lemma new_lemma_103388 (h0 : topological_space (comm_ring (has_sub (comm_ring linarith.ineq)))) : locally_compact_space (comm_ring (has_sub (comm_ring linarith.ineq))) := sorry --non-trivial
lemma new_lemma_103389 (h0 : functor.add_const (group (has_Inf name)) linarith.comp) : @normalizer_condition.{0} (has_Inf.{0} name) (@functor.add_const.run.{0 0} (group.{0} (has_Inf.{0} name)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_103390 (h0 : function.extfun Type add_group) : @is_add_cyclic.{0} (has_ssubset.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type add_group.{0} h0 (has_ssubset.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_103391 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @irreducible_space.{0} (canonically_ordered_add_monoid.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (canonically_ordered_add_monoid.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_103392 (h0 : ordered_comm_monoid (boolean_algebra (has_neg Type))) : has_exists_mul_of_le (boolean_algebra (has_neg Type)) := sorry --non-trivial
lemma new_lemma_103393 (h0 : functor.add_const (filter (has_add linarith.comp)) environment.implicit_infer_kind) : countable_Inter_filter (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_103394 (h0 : topological_space (add_group congr_arg_kind)) : t1_space (add_group congr_arg_kind) := sorry --non-trivial
lemma new_lemma_103395 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @discrete_topology.{0} (with_one.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (with_one.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_103396 (h0 : add_group (normed_group (random_gen fun_info))) : is_add_cyclic (normed_group (random_gen fun_info)) := sorry --non-trivial
lemma new_lemma_103397 (h0 : set (set enat)) (h1 : set enat) : filter.generate_sets h0 h1 := sorry --non-trivial
lemma new_lemma_103398 (h0 : function.extfun Type topological_space) : @irreducible_space.{0} (comm_monoid.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (comm_monoid.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_103399 (h0 : topological_space (has_union (has_union (has_union (metric_space (has_union empty)))))) : irreducible_space (has_union (has_union (has_union (metric_space (has_union empty))))) := sorry --non-trivial
lemma new_lemma_103400 (h0 : topological_space (comm_group (has_add (has_add (has_add linarith.comp))))) : totally_separated_space (comm_group (has_add (has_add (has_add linarith.comp)))) := sorry --non-trivial
lemma new_lemma_103401 (h0 : function.extfun Type complete_lattice) : @is_atomistic.{0} congr_arg_kind (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 congr_arg_kind)  := sorry --non-trivial
lemma new_lemma_103402 (h0 : cancel_comm_monoid_with_zero (has_to_string num)) : unique_factorization_monoid (has_to_string num) := sorry --non-trivial
lemma new_lemma_103403 (h0 : functor.add_const (ring (cancel_monoid Type)) environment.implicit_infer_kind) : @is_principal_ideal_ring.{1} (cancel_monoid.{1} Type) (@functor.add_const.run.{1 0} (ring.{1} (cancel_monoid.{1} Type)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_103404 (h0 : group (partial_order (semiring (semiring empty)))) : group.fg (partial_order (semiring (semiring empty))) := sorry --non-trivial
lemma new_lemma_103405 (h0 : set (has_ssubset fun_info)) : set.subsingleton h0 := sorry --non-trivial
lemma new_lemma_103406 (h0 : functor.add_const (complete_lattice (normed_comm_ring name)) linarith.comp) : @is_atomistic.{0} (normed_comm_ring.{0} name) (@functor.add_const.run.{0 0} (complete_lattice.{0} (normed_comm_ring.{0} name)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_103407 (h0 : not (topological_space (has_union congr_arg_kind) -> false)) : @totally_separated_space.{0} (has_union.{0} congr_arg_kind) (@classical.by_contradiction'.{1} (topological_space.{0} (has_union.{0} congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_103408 (h0 : functor.add_const (topological_space (has_add pos)) linarith.comp) : @topological_space.separable_space.{0} (has_add.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (has_add.{0} pos)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_103409 (h0 : functor.add_const (topological_space (has_zero pos)) unsigned) : @locally_compact_space.{0} (has_zero.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (has_zero.{0} pos)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_103410 (h0 : functor.add_const (add_monoid (cancel_monoid environment.implicit_infer_kind)) name) : @add_monoid.fg.{0} (cancel_monoid.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (add_monoid.{0} (cancel_monoid.{0} environment.implicit_infer_kind)) name h0)  := sorry --non-trivial
lemma new_lemma_103411 (h0 : ring (distrib_lattice (has_nnnorm (has_nnnorm (has_lt (has_nnnorm linarith.ineq)))))) : is_domain (distrib_lattice (has_nnnorm (has_nnnorm (has_lt (has_nnnorm linarith.ineq))))) := sorry --non-trivial
lemma new_lemma_103412 (h0 : function.extfun Type add_monoid) : @add_monoid.fg.{0} (@id.{2} Type unsigned) (@function.extfun_app.{2 1} Type add_monoid.{0} h0 (@id.{2} Type unsigned))  := sorry --non-trivial
lemma new_lemma_103413 (h0 : functor.add_const (topological_space (boolean_algebra.core name)) linarith.comp) : @t0_space.{0} (boolean_algebra.core.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (boolean_algebra.core.{0} name)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_103414 (h0 : linear_ordered_field (ring unsigned) -> linear_ordered_field (ring unsigned) -> Prop) : is_symm (linear_ordered_field (ring unsigned)) h0 := sorry --non-trivial
lemma new_lemma_103415 (h0 : not (function.extfun Type monoid -> false)) : @monoid.fg.{0} (@id.{2} Type num) (@function.extfun_app.{2 1} Type monoid.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type monoid.{0}) h0) (@id.{2} Type num))  := sorry --non-trivial
lemma new_lemma_103416 (h0 : functor.comp topological_space complete_distrib_lattice name) : @totally_separated_space.{0} (complete_distrib_lattice.{0} name) (@functor.comp.run.{0 0 0} topological_space.{0} complete_distrib_lattice.{0} name h0)  := sorry --non-trivial
lemma new_lemma_103417 (h0 : filter (with_one num)) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_103418 (h0 : complete_lattice (with_bot (has_norm linarith.comp_source))) : is_atomistic (with_bot (has_norm linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_103419 (h0 : topological_space (has_inv (random_gen (random_gen string_imp)))) : t0_space (has_inv (random_gen (random_gen string_imp))) := sorry --non-trivial
lemma new_lemma_103420 (h0 : cancel_comm_monoid_with_zero (cancel_monoid ennreal)) : unique_factorization_monoid (cancel_monoid ennreal) := sorry --non-trivial
lemma new_lemma_103421 (h1 : uniform_space (semi_normed_comm_ring (denumerable char))) : complete_space (semi_normed_comm_ring (denumerable char)) := sorry --non-trivial
lemma new_lemma_103422 (h0 : list (has_Inf (ring name))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_103423 (h0 : not (topological_space (measurable_space linarith.comp_source) -> false)) : @path_connected_space.{0} (measurable_space.{0} linarith.comp_source) (@classical.by_contradiction'.{1} (topological_space.{0} (measurable_space.{0} linarith.comp_source)) h0)  := sorry --non-trivial
lemma new_lemma_103424 (h0 : topological_space (boolean_algebra (ring Type))) : regular_space (boolean_algebra (ring Type)) := sorry --non-trivial
lemma new_lemma_103425 (h0 : functor.add_const (function.extfun Type complete_lattice) unsigned) : @is_atomistic.{0} (pseudo_metric_space.{0} pos) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type complete_lattice.{0}) unsigned h0) (pseudo_metric_space.{0} pos))  := sorry --non-trivial
lemma new_lemma_103426 (h0 : topological_space (nondiscrete_normed_field linarith.ineq)) : t0_space (nondiscrete_normed_field linarith.ineq) := sorry --non-trivial
lemma new_lemma_103427 (h0 : functor.add_const (uniform_space (bin_tree unsigned)) unsigned) : @complete_space.{0} (bin_tree.{0} unsigned) (@functor.add_const.run.{0 0} (uniform_space.{0} (bin_tree.{0} unsigned)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_103428 (h0 : functor.add_const (group (boolean_algebra environment.implicit_infer_kind)) pos) : @group.fg.{0} (boolean_algebra.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (group.{0} (boolean_algebra.{0} environment.implicit_infer_kind)) pos h0)  := sorry --non-trivial
lemma new_lemma_103429 (h0 : functor.comp (prod (semigroup name)) semigroup name) : id_rel (functor.comp.run h0) := sorry --non-trivial
lemma new_lemma_103430 (h0 : function.extfun Type topological_space) : @normal_space.{0} (simple_graph.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (simple_graph.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_103431 (h0 : function.extfun Type topological_space) : @normal_space.{0} (has_union.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_union.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_103432 (h0 : functor.add_const (add_monoid (left_cancel_monoid congr_arg_kind)) congr_arg_kind) : @add_monoid.fg.{0} (left_cancel_monoid.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (add_monoid.{0} (left_cancel_monoid.{0} congr_arg_kind)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_103433 (h0 : group (ring (finset Type))) : normalizer_condition (ring (finset Type)) := sorry --non-trivial
lemma new_lemma_103434 (h0 : topological_space (semi_normed_comm_ring linarith.comp_source)) : totally_disconnected_space (semi_normed_comm_ring linarith.comp_source) := sorry --non-trivial
lemma new_lemma_103435 (h0 : complete_lattice (has_to_string (option pos))) : is_compactly_generated (has_to_string (option pos)) := sorry --non-trivial
lemma new_lemma_103436 (h0 : functor.add_const (topological_space (comm_group Type)) environment.implicit_infer_kind) : @regular_space.{1} (comm_group.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (comm_group.{1} Type)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_103437 (h0 : function.extfun (Type 1) finset) : finset.nonempty (function.extfun_app h0 (has_neg Type)) := sorry --non-trivial
lemma new_lemma_103438 (h0 : functor.add_const (ring (simple_graph pos)) Type) : @is_domain.{0} (simple_graph.{0} pos) (@functor.add_const.run.{0 1} (ring.{0} (simple_graph.{0} pos)) Type h0)  := sorry --non-trivial
lemma new_lemma_103439 (h0 : not (ring (option unsigned) -> false)) : @is_principal_ideal_ring.{0} (option.{0} unsigned) (@classical.by_contradiction'.{1} (ring.{0} (option.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_103440 (h0 : uniform_space (free_add_monoid congr_arg_kind)) : complete_space (free_add_monoid congr_arg_kind) := sorry --non-trivial
lemma new_lemma_103441 (h0 : topological_space (cancel_monoid environment.implicit_infer_kind)) : regular_space (cancel_monoid environment.implicit_infer_kind) := sorry --non-trivial
lemma new_lemma_103442 (h0 : function.extfun Type group) : @normalizer_condition.{0} (ring.{0} unsigned) (@function.extfun_app.{2 1} Type group.{0} h0 (ring.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_103443 (h0 : topological_space (boolean_algebra.core congr_arg_kind)) : irreducible_space (boolean_algebra.core congr_arg_kind) := sorry --non-trivial
lemma new_lemma_103444 (h0 : functor.add_const (complete_lattice (plift num)) empty) : @is_compactly_generated.{1} (plift.{1} num) (@functor.add_const.run.{1 0} (complete_lattice.{1} (plift.{1} num)) empty h0)  := sorry --non-trivial
lemma new_lemma_103445 (h0 : functor.add_const (function.extfun Type uniform_space) pos) : @separated_space.{0} (finset.{0} pos) (@function.extfun_app.{2 1} Type uniform_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type uniform_space.{0}) pos h0) (finset.{0} pos))  := sorry --non-trivial
lemma new_lemma_103446 (h0 : group (canonically_linear_ordered_monoid pos)) : normalizer_condition (canonically_linear_ordered_monoid pos) := sorry --non-trivial
lemma new_lemma_103447 (h0 : function.extfun Type add_monoid) : @add_monoid.fg.{0} (uniform_space.{0} unsigned) (@function.extfun_app.{2 1} Type add_monoid.{0} h0 (uniform_space.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_103448 (h0 : ring (normed_field string_imp)) : rank_condition (normed_field string_imp) := sorry --non-trivial
lemma new_lemma_103449 (h0 : functor.add_const (semiring (ordered_comm_ring pos)) pos) : @is_noetherian_ring.{0} (ordered_comm_ring.{0} pos) (@functor.add_const.run.{0 0} (semiring.{0} (ordered_comm_ring.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_103450 (h0 : topological_space (linear_ordered_field name)) : topological_space.separable_space (linear_ordered_field name) := sorry --non-trivial
lemma new_lemma_103451 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_domain.{0} (add_cancel_monoid.{0} name) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (add_cancel_monoid.{0} name))  := sorry --non-trivial
lemma new_lemma_103452 (h0 : functor.comp add_group complete_distrib_lattice Type) : @is_add_cyclic.{1} (complete_distrib_lattice.{1} Type) (@functor.comp.run.{1 1 1} add_group.{1} complete_distrib_lattice.{1} Type h0)  := sorry --non-trivial
lemma new_lemma_103453 (h0 : ring (semigroup (has_add environment.implicit_infer_kind))) : strong_rank_condition (semigroup (has_add environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_103454 (h0 : not (function.extfun Type group -> false)) : @group.fg.{0} (has_ssubset.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type group.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type group.{0}) h0) (has_ssubset.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_103455 (h0 : ring (metric_space (metric_space to_additive.value_type))) : strong_rank_condition (metric_space (metric_space to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_103456 (h0 : monoid (comm_group (has_add environment.implicit_infer_kind))) : monoid.fg (comm_group (has_add environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_103457 (h0 : topological_space (has_star (semiring (semiring unsigned)))) : t1_space (has_star (semiring (semiring unsigned))) := sorry --non-trivial
lemma new_lemma_103458 (h0 : not (complete_lattice (measure_theory.measure_space unsigned) -> false)) : @is_atomistic.{0} (measure_theory.measure_space.{0} unsigned) (@classical.by_contradiction'.{1} (complete_lattice.{0} (measure_theory.measure_space.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_103459 (h0 : topological_space (mul_zero_class (has_to_string (has_add name)))) : t0_space (mul_zero_class (has_to_string (has_add name))) := sorry --non-trivial
lemma new_lemma_103460 (h2 : ring (add_monoid (has_ssubset to_additive.value_type))) : rank_condition (add_monoid (has_ssubset to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_103461 (h0 : functor.add_const (function.extfun Type topological_space) pos) : @sequential_space.{0} (has_Inf.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) pos h0) (has_Inf.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_103462 (h0 : topological_space (finset (has_Inf (has_to_string (sub_neg_monoid (has_pos_part real)))))) : irreducible_space (finset (has_Inf (has_to_string (sub_neg_monoid (has_pos_part real))))) := sorry --non-trivial
lemma new_lemma_103463 (h0 : functor.add_const (function.extfun Type topological_space) Type) : @irreducible_space.{0} (finset.{0} real) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type topological_space.{0}) Type h0) (finset.{0} real))  := sorry --non-trivial
lemma new_lemma_103464 (h0 : functor.add_const (topological_space (complete_distrib_lattice Type)) (has_add pos)) (h1 : set (complete_distrib_lattice Type)) : @is_totally_separated.{1} (complete_distrib_lattice.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (complete_distrib_lattice.{1} Type)) (has_add.{0} pos) h0) h1  := sorry --non-trivial
lemma new_lemma_103465 (h0 : list (has_top (has_top linarith.ineq))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_103466 (h0 : ulower Prop) (h1 : ulower punit) : @ulower.up.{0} Prop encodable.Prop (@category_theory.hom_of_element.{0} (@ulower.{0} Prop encodable.Prop) (@id.{1} (@ulower.{0} Prop encodable.Prop) h0) (@ulower.up.{0} punit.{1} encodable.unit.{0} (@id.{1} (@ulower.{0} punit.{1} encodable.unit.{0}) (@id.{1} (@ulower.{0} punit.{1} encodable.unit.{0}) (@id.{1} (@ulower.{0} punit.{1} encodable.unit.{0}) h1)))))  := sorry --non-trivial
lemma new_lemma_103467 (h0 : functor.comp topological_space has_compl (mul_one_class char)) : @t0_space.{0} (has_compl.{0} (mul_one_class.{0} char)) (@functor.comp.run.{0 0 0} topological_space.{0} has_compl.{0} (mul_one_class.{0} char) h0)  := sorry --non-trivial
lemma new_lemma_103468 (h0 : ring (linear_ordered_comm_ring (semiring congr_arg_kind))) : strong_rank_condition (linear_ordered_comm_ring (semiring congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_103469 (h0 : ordered_add_comm_monoid (semigroup (option (option ennreal)))) : archimedean (semigroup (option (option ennreal))) := sorry --non-trivial
lemma new_lemma_103470 (h0 : not (function.extfun Type list -> false)) : list.head (function.extfun_app (classical.by_contradiction' h0) Prop) := sorry --non-trivial
lemma new_lemma_103471 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : finset.nonempty (function.extfun_app (function.extfun_app h0 finset) (has_Inf name)) := sorry --non-trivial
lemma new_lemma_103472 (h0 : group (comm_ring (has_inv to_additive.value_type))) : is_cyclic (comm_ring (has_inv to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_103473 (h0 : complete_lattice (has_zero Type)) : complete_lattice.is_Sup_finite_compact (has_zero Type) := sorry --non-trivial
lemma new_lemma_103474 (h0 : not (group (preorder empty) -> false)) : @group.fg.{0} (preorder.{0} empty) (@classical.by_contradiction'.{1} (group.{0} (preorder.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_103475 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @irreducible_space.{0} (simple_graph.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (simple_graph.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_103476 (h0 : ordered_comm_monoid (has_add linarith.comp)) : has_exists_mul_of_le (has_add linarith.comp) := sorry --non-trivial
lemma new_lemma_103477 (h0 : functor.add_const (cancel_comm_monoid_with_zero (ring Type)) Type) : @unique_factorization_monoid.{1} (ring.{1} Type) (@functor.add_const.run.{1 1} (cancel_comm_monoid_with_zero.{1} (ring.{1} Type)) Type h0)  := sorry --non-trivial
lemma new_lemma_103478 (h0 : functor.add_const (function.extfun Type topological_space) linarith.comp) : @topological_space.separable_space.{0} (boolean_algebra.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) linarith.comp h0) (boolean_algebra.{0} pos))  := sorry --non-trivial
lemma new_lemma_103479 (h0 : functor.add_const (list (normed_linear_ordered_group num)) num) : palindrome (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_103480 (h0 : functor.add_const (ordered_comm_monoid (semigroup environment.implicit_infer_kind)) pos) : @has_exists_mul_of_le.{0} (semigroup.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (ordered_comm_monoid.{0} (semigroup.{0} environment.implicit_infer_kind)) pos h0)  := sorry --non-trivial
lemma new_lemma_103481 (h0 : functor.add_const (complete_lattice (comm_group pos)) name) : @complete_lattice.is_Sup_finite_compact.{0} (comm_group.{0} pos) (@functor.add_const.run.{0 0} (complete_lattice.{0} (comm_group.{0} pos)) name h0)  := sorry --non-trivial
lemma new_lemma_103482 (h0 : ring (linear_ordered_comm_group (option (option (comm_monoid empty))))) : strong_rank_condition (linear_ordered_comm_group (option (option (comm_monoid empty)))) := sorry --non-trivial
lemma new_lemma_103483 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @discrete_topology.{0} (ordered_cancel_add_comm_monoid.{0} (option.{0} unsigned)) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (ordered_cancel_add_comm_monoid.{0} (option.{0} unsigned)))  := sorry --non-trivial
lemma new_lemma_103484 (h0 : complete_lattice (distrib (fintype char))) : complete_lattice.is_Sup_finite_compact (distrib (fintype char)) := sorry --non-trivial
lemma new_lemma_103485 (h0 : measurable_space (mul_one_class (nondiscrete_normed_field (mul_one_class (add_comm_semigroup ereal))))) (h1 : measure_theory.measure (mul_one_class (nondiscrete_normed_field (mul_one_class (add_comm_semigroup ereal))))) : measure_theory.is_finite_measure h1 := sorry --non-trivial
lemma new_lemma_103486 (h0 : list (boolean_algebra (has_nndist name))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_103487 (h0 : topological_space (has_nndist (option (option (option empty))))) : preirreducible_space (has_nndist (option (option (option empty)))) := sorry --non-trivial
lemma new_lemma_103488 (h0 : uniform_space (has_top (random_gen (with_bot (random_gen string_imp))))) : complete_space (has_top (random_gen (with_bot (random_gen string_imp)))) := sorry --non-trivial
lemma new_lemma_103489 (h0 : function.extfun Type topological_space) : @locally_compact_space.{0} (boolean_algebra.core.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (boolean_algebra.core.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_103490 (h0 : group (has_zero (finset pos))) : group.fg (has_zero (finset pos)) := sorry --non-trivial
lemma new_lemma_103491 (h0 : functor.add_const (function.extfun Type ring) (has_nndist (canonically_ordered_comm_semiring name))) : @rank_condition.{0} (add_comm_monoid.{0} name) (@function.extfun_app.{2 1} Type ring.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type ring.{0}) (has_nndist.{0} (canonically_ordered_comm_semiring.{0} name)) h0) (add_comm_monoid.{0} name))  := sorry --non-trivial
lemma new_lemma_103492 (h1 : add_group (has_le (mul_one_class (simple_graph (simple_graph (has_le reducibility_hints)))))) : is_add_cyclic (has_le (mul_one_class (simple_graph (simple_graph (has_le reducibility_hints))))) := sorry --non-trivial
lemma new_lemma_103493 (h0 : topological_space (finset (has_neg_part unsigned))) : regular_space (finset (has_neg_part unsigned)) := sorry --non-trivial
lemma new_lemma_103494 (h0 : not (function.extfun Type topological_space -> false)) : @discrete_topology.{0} (with_one.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (with_one.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_103495 (h0 : not (function.extfun Type topological_space -> false)) : @path_connected_space.{0} (complete_semilattice_Sup.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (complete_semilattice_Sup.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_103496 (h0 : functor.add_const (function.extfun Type add_monoid) linarith.comp) : @add_monoid.fg.{0} (has_add.{0} pos) (@function.extfun_app.{2 1} Type add_monoid.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type add_monoid.{0}) linarith.comp h0) (has_add.{0} pos))  := sorry --non-trivial
lemma new_lemma_103497 (h0 : not (function.extfun Type semiring -> false)) : @is_noetherian_ring.{0} unsigned (@function.extfun_app.{2 1} Type semiring.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type semiring.{0}) h0) unsigned)  := sorry --non-trivial
lemma new_lemma_103498 (h0 : topological_space (boolean_algebra (has_to_string pos))) : loc_path_connected_space (boolean_algebra (has_to_string pos)) := sorry --non-trivial
lemma new_lemma_103499 (h0 : functor.add_const (topological_space (ring pos)) linarith.comp) : @totally_disconnected_space.{0} (ring.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (ring.{0} pos)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_103500 (h0 : group (ordered_comm_ring (finset Type))) : normalizer_condition (ordered_comm_ring (finset Type)) := sorry --non-trivial
lemma new_lemma_103501 (h0 : topological_space (has_neg Type)) : sequential_space (has_neg Type) := sorry --non-trivial
lemma new_lemma_103502 (h0 : semiring (has_neg (finset environment.implicit_infer_kind))) : is_noetherian_ring (has_neg (finset environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_103503 (h0 : ring (semi_normed_comm_ring reducibility_hints)) : is_domain (semi_normed_comm_ring reducibility_hints) := sorry --non-trivial
lemma new_lemma_103504 (h0 : uniform_space (has_pos_part (has_Inf (canonically_linear_ordered_monoid (has_Inf pos))))) : complete_space (has_pos_part (has_Inf (canonically_linear_ordered_monoid (has_Inf pos)))) := sorry --non-trivial
lemma new_lemma_103505 (h0 : function.extfun Type topological_space) : @normal_space.{0} (complete_distrib_lattice.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (complete_distrib_lattice.{0} name))  := sorry --non-trivial
lemma new_lemma_103506 (h0 : topological_space (has_bot (has_neg (has_neg name)))) : discrete_topology (has_bot (has_neg (has_neg name))) := sorry --non-trivial
lemma new_lemma_103507 (h0 : ring (comm_group (add_cancel_monoid name))) : strong_rank_condition (comm_group (add_cancel_monoid name)) := sorry --non-trivial
lemma new_lemma_103508 (h0 : functor.add_const (ring (option unsigned)) unsigned) : @is_domain.{0} (option.{0} unsigned) (@functor.add_const.run.{0 0} (ring.{0} (option.{0} unsigned)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_103509 (h0 : ring (random_gen (mul_one_class (mul_one_class fun_info)))) : rank_condition (random_gen (mul_one_class (mul_one_class fun_info))) := sorry --non-trivial
lemma new_lemma_103510 (h0 : metric_space (random_gen linarith.comp_source)) (h1 : function.extfun (random_gen linarith.comp_source) (fun (x : random_gen linarith.comp_source), Prop)) : euclidean_geometry.cospherical (function.extfun_app h1) := sorry --non-trivial
lemma new_lemma_103511 (h0 : group (has_inter (option empty))) : group.fg (has_inter (option empty)) := sorry --non-trivial
lemma new_lemma_103512 (h0 : functor.add_const (function.extfun (Type 1) semiring) name) : @is_noetherian_ring.{1} (ordered_comm_ring.{1} Type) (@function.extfun_app.{3 2} (Type 1) semiring.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) semiring.{1}) name h0) (ordered_comm_ring.{1} Type))  := sorry --non-trivial
lemma new_lemma_103513 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @monoid.fg.{0} unsigned (@function.extfun_app.{2 1} Type monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 monoid.{0}) unsigned)  := sorry --non-trivial
lemma new_lemma_103514 (h0 : add_group (canonically_linear_ordered_monoid unsigned)) : is_add_cyclic (canonically_linear_ordered_monoid unsigned) := sorry --non-trivial
lemma new_lemma_103515 (h0 : topological_space (boolean_algebra.core (comm_group (comm_group (comm_group unsigned))))) : discrete_topology (boolean_algebra.core (comm_group (comm_group (comm_group unsigned)))) := sorry --non-trivial
lemma new_lemma_103516 (h0 : function.extfun Type topological_space) : @irreducible_space.{0} (has_pos_part.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_pos_part.{0} pos))  := sorry --non-trivial
lemma new_lemma_103517 (h0 : function.extfun (Type 1) add_monoid) : @add_monoid.fg.{1} (plift.{1} empty) (@function.extfun_app.{3 2} (Type 1) add_monoid.{1} h0 (plift.{1} empty))  := sorry --non-trivial
lemma new_lemma_103518 (h0 : list (with_bot (has_inv (has_top (has_top linarith.ineq))))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_103519 (h0 : complete_lattice (option (semiring (semiring num)))) : is_atomistic (option (semiring (semiring num))) := sorry --non-trivial
lemma new_lemma_103520 (h0 : topological_space (comm_group (option name))) : totally_separated_space (comm_group (option name)) := sorry --non-trivial
lemma new_lemma_103521 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @loc_path_connected_space.{0} (has_zero.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_zero.{0} pos))  := sorry --non-trivial
lemma new_lemma_103522 (h0 : topological_space (linear_ordered_cancel_comm_monoid unsigned)) : locally_compact_space (linear_ordered_cancel_comm_monoid unsigned) := sorry --non-trivial
lemma new_lemma_103523 (h2 : uniform_space string_imp) : complete_space string_imp := sorry --non-trivial
lemma new_lemma_103524 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @locally_compact_space.{0} (has_zero.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_zero.{0} pos))  := sorry --non-trivial
lemma new_lemma_103525 (h0 : function.extfun Type list) : palindrome (function.extfun_app h0 (monoid num)) := sorry --non-trivial
lemma new_lemma_103526 (h0 : functor.add_const (add_group (has_neg_part name)) unsigned) : @is_add_cyclic.{0} (has_neg_part.{0} name) (@functor.add_const.run.{0 0} (add_group.{0} (has_neg_part.{0} name)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_103527 (h0 : topological_space (semigroup (has_neg pos))) : t0_space (semigroup (has_neg pos)) := sorry --non-trivial
lemma new_lemma_103528 (h0 : functor.add_const (complete_lattice (comm_group name)) pos) : @complete_lattice.is_Sup_finite_compact.{0} (comm_group.{0} name) (@functor.add_const.run.{0 0} (complete_lattice.{0} (comm_group.{0} name)) pos h0)  := sorry --non-trivial
lemma new_lemma_103529 (h0 : complete_lattice (with_bot (has_inv (has_inv (random_gen to_additive.value_type))))) : is_atomistic (with_bot (has_inv (has_inv (random_gen to_additive.value_type)))) := sorry --non-trivial
lemma new_lemma_103530 (h0 : functor.add_const (ordered_comm_monoid (generalized_boolean_algebra Type)) Type) : @has_exists_mul_of_le.{1} (generalized_boolean_algebra.{1} Type) (@functor.add_const.run.{1 1} (ordered_comm_monoid.{1} (generalized_boolean_algebra.{1} Type)) Type h0)  := sorry --non-trivial
lemma new_lemma_103531 (h0 : topological_space (random_gen char)) (h1 : not (preorder (random_gen char) -> false)) : @order_topology.{0} (random_gen.{0} char) h0 (@classical.by_contradiction'.{1} (preorder.{0} (random_gen.{0} char)) h1)  := sorry --non-trivial
lemma new_lemma_103532 (h0 : finset (has_add (has_neg linarith.comp))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_103533 (h0 : function.extfun Type ring) : @strong_rank_condition.{0} (has_add.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type ring.{0} h0 (has_add.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_103534 (h0 : not (add_group (distrib reducibility_hints) -> false)) : @is_add_cyclic.{0} (distrib.{0} reducibility_hints) (@classical.by_contradiction'.{1} (add_group.{0} (distrib.{0} reducibility_hints)) h0)  := sorry --non-trivial
lemma new_lemma_103535 (h0 : add_group (nondiscrete_normed_field linarith.ineq)) : is_add_cyclic (nondiscrete_normed_field linarith.ineq) := sorry --non-trivial
lemma new_lemma_103536 (h2 : topological_space char) : totally_disconnected_space char := sorry --non-trivial
lemma new_lemma_103537 (h4 : function.extfun Type add_group) : @is_add_cyclic.{0} (has_emptyc.{0} linarith.comp) (@function.extfun_app.{2 1} Type add_group.{0} h4 (has_emptyc.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_103538 (h0 : functor.add_const (ordered_comm_monoid (has_zero linarith.comp)) (has_add name)) : @has_exists_mul_of_le.{0} (has_zero.{0} linarith.comp) (@functor.add_const.run.{0 0} (ordered_comm_monoid.{0} (has_zero.{0} linarith.comp)) (has_add.{0} name) h0)  := sorry --non-trivial
lemma new_lemma_103539 (h0 : not (complete_lattice (with_one (semiring (has_norm fun_info))) -> false)) : @complete_lattice.is_Sup_finite_compact.{0} (with_one.{0} (semiring.{0} (has_norm.{0} fun_info))) (@classical.by_contradiction'.{1} (complete_lattice.{0} (with_one.{0} (semiring.{0} (has_norm.{0} fun_info)))) h0)  := sorry --non-trivial
lemma new_lemma_103540 (h0 : topological_space (add_comm_monoid (has_neg_part Type))) : irreducible_space (add_comm_monoid (has_neg_part Type)) := sorry --non-trivial
lemma new_lemma_103541 (h0 : ring (normed_comm_ring num)) : strong_rank_condition (normed_comm_ring num) := sorry --non-trivial
lemma new_lemma_103542 (h0 : functor.add_const (topological_space (has_neg_part name)) Type) : @t1_space.{0} (has_neg_part.{0} name) (@functor.add_const.run.{0 1} (topological_space.{0} (has_neg_part.{0} name)) Type h0)  := sorry --non-trivial
lemma new_lemma_103543 (h0 : functor.add_const (fin has_zero.zero) Type) : @is_noetherian_ring.{0} (has_add.{0} real) (@function.extfun_app.{2 1} Type semiring.{0} (@matrix.vec_empty.{1} (function.extfun.{2 1} Type semiring.{0}) (@functor.add_const.run.{0 1} (fin (@has_zero.zero.{0} nat nat.has_zero)) Type h0)) (has_add.{0} real))  := sorry --non-trivial
lemma new_lemma_103544 (h0 : complete_lattice (boolean_algebra.core ennreal)) : is_compactly_generated (boolean_algebra.core ennreal) := sorry --non-trivial
lemma new_lemma_103545 (h0 : topological_space (linear_ordered_field congr_arg_kind)) : t1_space (linear_ordered_field congr_arg_kind) := sorry --non-trivial
lemma new_lemma_103546 (h0 : topological_space (cancel_monoid congr_arg_kind)) : preirreducible_space (cancel_monoid congr_arg_kind) := sorry --non-trivial
lemma new_lemma_103547 (h0 : list (finset linarith.comp)) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_103548 (h0 : group (measurable_space.dynkin_system (semiring num))) : normalizer_condition (measurable_space.dynkin_system (semiring num)) := sorry --non-trivial
lemma new_lemma_103549 (h0 : add_group (mul_one_class (add_comm_semigroup fun_info))) : is_add_cyclic (mul_one_class (add_comm_semigroup fun_info)) := sorry --non-trivial
lemma new_lemma_103550 (h0 : function.extfun Type topological_space) : @irreducible_space.{0} (measurable_space.dynkin_system.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (measurable_space.dynkin_system.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_103551 (h0 : filter (has_top num)) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_103552 (h1 : complete_lattice (has_ssubset (random_gen linarith.comp_source))) : is_compactly_generated (has_ssubset (random_gen linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_103553 (h0 : function.extfun Type ring) : @is_domain.{0} (comm_group.{0} ennreal) (@function.extfun_app.{2 1} Type ring.{0} h0 (comm_group.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_103554 (h0 : monoid (with_bot (has_inv (has_inv linarith.ineq)))) : monoid.fg (with_bot (has_inv (has_inv linarith.ineq))) := sorry --non-trivial
lemma new_lemma_103555 (h1 : not (complete_lattice (div_inv_monoid char) -> false)) : @complete_lattice.is_Sup_finite_compact.{0} (div_inv_monoid.{0} char) (@classical.by_contradiction'.{1} (complete_lattice.{0} (div_inv_monoid.{0} char)) h1)  := sorry --non-trivial
lemma new_lemma_103556 (h0 : group (has_top (random_gen linarith.comp_source))) : is_cyclic (has_top (random_gen linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_103557 (h0 : not (has_mem.mem (has_top linarith.comp_source) has_emptyc.emptyc -> false)) : @irreducible_space.{0} (has_top.{0} linarith.comp_source) (@finset.pi.empty.{1 0} Type topological_space.{0} (has_top.{0} linarith.comp_source) (@classical.by_contradiction'.{0} (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (has_top.{0} linarith.comp_source) (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))) h0))  := sorry --non-trivial
lemma new_lemma_103558 (h0 : uniform_space (linear_ordered_semiring (semiring unsigned))) : complete_space (linear_ordered_semiring (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_103559 (h0 : topological_space (has_append (has_nnnorm fun_info))) : totally_disconnected_space (has_append (has_nnnorm fun_info)) := sorry --non-trivial
lemma new_lemma_103560 (h0 : functor.add_const (topological_space (finset Type)) environment.implicit_infer_kind) : @sequential_space.{1} (finset.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (finset.{1} Type)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_103561 (h0 : topological_space (nondiscrete_normed_field enat)) : t0_space (nondiscrete_normed_field enat) := sorry --non-trivial
lemma new_lemma_103562 (h0 : topological_space (measurable_space (has_top fun_info))) : path_connected_space (measurable_space (has_top fun_info)) := sorry --non-trivial
lemma new_lemma_103563 (h0 : has_lt (has_le linarith.ineq)) : no_max_order (has_le linarith.ineq) := sorry --non-trivial
lemma new_lemma_103564 (h0 : set (non_unital_non_assoc_semiring enat)) : set.subsingleton h0 := sorry --non-trivial
lemma new_lemma_103565 (h0 : topological_space (distrib (random_gen string.iterator_imp))) : totally_disconnected_space (distrib (random_gen string.iterator_imp)) := sorry --non-trivial
lemma new_lemma_103566 (h0 : functor.add_const (topological_space (plift empty)) num) : @discrete_topology.{1} (plift.{1} empty) (@functor.add_const.run.{1 0} (topological_space.{1} (plift.{1} empty)) num h0)  := sorry --non-trivial
lemma new_lemma_103567 (h0 : functor.add_const (function.extfun (Type 1) uniform_space) (has_add (has_to_string name))) : @complete_space.{1} (has_to_string.{1} Type) (@function.extfun_app.{3 2} (Type 1) uniform_space.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) uniform_space.{1}) (has_add.{0} (has_to_string.{0} name)) h0) (has_to_string.{1} Type))  := sorry --non-trivial
lemma new_lemma_103568 (h0 : topological_space (has_compl (has_ssubset fun_info))) : t0_space (has_compl (has_ssubset fun_info)) := sorry --non-trivial
lemma new_lemma_103569 (h0 : complete_lattice (linear_ordered_add_comm_group linarith.comp_source)) : is_atomistic (linear_ordered_add_comm_group linarith.comp_source) := sorry --non-trivial
lemma new_lemma_103570 (h0 : functor.add_const (ordered_comm_monoid (normed_comm_ring name)) environment.implicit_infer_kind) : @has_exists_mul_of_le.{0} (normed_comm_ring.{0} name) (@functor.add_const.run.{0 0} (ordered_comm_monoid.{0} (normed_comm_ring.{0} name)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_103571 (h0 : topological_space (normed_lattice_add_comm_group (sub_neg_monoid Type))) : normal_space (normed_lattice_add_comm_group (sub_neg_monoid Type)) := sorry --non-trivial
lemma new_lemma_103572 (h0 : function.extfun Type (functor.comp group semigroup)) : @is_simple_group.{0} (semigroup.{0} pos) (@functor.comp.run.{0 0 0} group.{0} semigroup.{0} pos (@function.extfun_app.{2 1} Type (functor.comp.{0 0 0} group.{0} semigroup.{0}) h0 pos))  := sorry --non-trivial
lemma new_lemma_103573 (h0 : topological_space (has_one (semiring num))) : locally_compact_space (has_one (semiring num)) := sorry --non-trivial
lemma new_lemma_103574 (h0 : functor.add_const (function.extfun Type ordered_comm_monoid) pos) : @has_exists_mul_of_le.{0} (add_cancel_monoid.{0} linarith.comp) (@function.extfun_app.{2 1} Type ordered_comm_monoid.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type ordered_comm_monoid.{0}) pos h0) (add_cancel_monoid.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_103575 (h0 : ennreal -> has_zero num -> Prop) : relator.right_total h0 := sorry --non-trivial
lemma new_lemma_103576 (h0 : functor.add_const (semiring (add_cancel_monoid name)) name) : @is_noetherian_ring.{0} (add_cancel_monoid.{0} name) (@functor.add_const.run.{0 0} (semiring.{0} (add_cancel_monoid.{0} name)) name h0)  := sorry --non-trivial
lemma new_lemma_103577 (h0 : functor.add_const (ring (boolean_algebra.core name)) linarith.comp) : @strong_rank_condition.{0} (boolean_algebra.core.{0} name) (@functor.add_const.run.{0 0} (ring.{0} (boolean_algebra.core.{0} name)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_103578 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @totally_separated_space.{0} (has_add.{0} real) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_add.{0} real))  := sorry --non-trivial
lemma new_lemma_103579 (h0 : function.extfun Type filter) : filter.ne_bot (function.extfun_app h0 (has_compl to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_103580 (h0 : functor.add_const (topological_space (add_cancel_monoid num)) congr_arg_kind) : @loc_path_connected_space.{0} (add_cancel_monoid.{0} num) (@functor.add_const.run.{0 0} (topological_space.{0} (add_cancel_monoid.{0} num)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_103581 (h0 : uniform_space (ring (option (has_neg unsigned)))) : separated_space (ring (option (has_neg unsigned))) := sorry --non-trivial
lemma new_lemma_103582 (h0 : not (topological_space (has_top congr_arg_kind) -> false)) : @totally_separated_space.{0} (has_top.{0} congr_arg_kind) (@classical.by_contradiction'.{1} (topological_space.{0} (has_top.{0} congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_103583 (h0 : functor.add_const (topological_space (ring Type)) name) : @locally_compact_space.{1} (ring.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (ring.{1} Type)) name h0)  := sorry --non-trivial
lemma new_lemma_103584 (h0 : list (ordered_comm_ring (has_pos_part Type))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_103585 (h0 : ring (with_bot (semiring (semiring (semiring unsigned))))) : strong_rank_condition (with_bot (semiring (semiring (semiring unsigned)))) := sorry --non-trivial
lemma new_lemma_103586 (h1 : has_mem.mem fun_info has_emptyc.emptyc) : @discrete_topology.{0} fun_info (@finset.pi.empty.{1 0} Type topological_space.{0} fun_info h1)  := sorry --non-trivial
lemma new_lemma_103587 (h0 : list (has_top (random_gen (has_ssubset (random_gen (random_gen fun_info)))))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_103588 (h0 : functor.add_const (ring (has_neg_part pos)) Type) : @strong_rank_condition.{0} (has_neg_part.{0} pos) (@functor.add_const.run.{0 1} (ring.{0} (has_neg_part.{0} pos)) Type h0)  := sorry --non-trivial
lemma new_lemma_103589 (h0 : not (ring (with_bot linarith.comp_source) -> false)) : @rank_condition.{0} (with_bot.{0} linarith.comp_source) (@classical.by_contradiction'.{1} (ring.{0} (with_bot.{0} linarith.comp_source)) h0)  := sorry --non-trivial
lemma new_lemma_103590 (h0 : uniform_space (pseudo_metric_space (option (option unsigned)))) : complete_space (pseudo_metric_space (option (option unsigned))) := sorry --non-trivial
lemma new_lemma_103591 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @group.fg.{0} (comm_ring.{0} string_imp) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (comm_ring.{0} string_imp))  := sorry --non-trivial
lemma new_lemma_103592 (h0 : functor.add_const (cancel_comm_monoid_with_zero (left_cancel_semigroup empty)) empty) : @unique_factorization_monoid.{0} (left_cancel_semigroup.{0} empty) (@functor.add_const.run.{0 0} (cancel_comm_monoid_with_zero.{0} (left_cancel_semigroup.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_103593 (h0 : fin has_zero.zero) : @is_principal_ideal_ring.{0} (canonically_linear_ordered_monoid.{0} pos) (@function.extfun_app.{2 1} Type ring.{0} (@matrix.vec_empty.{1} (function.extfun.{2 1} Type ring.{0}) (@matrix.vec_empty.{0} (fin (@has_zero.zero.{0} nat nat.has_zero)) h0)) (canonically_linear_ordered_monoid.{0} pos))  := sorry --non-trivial
lemma new_lemma_103594 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @totally_separated_space.{0} (linear_ordered_field.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (linear_ordered_field.{0} empty))  := sorry --non-trivial
lemma new_lemma_103595 (h0 : functor.add_const (semiring (has_pos_part linarith.comp)) (has_add (has_add pos))) : @is_noetherian_ring.{0} (has_pos_part.{0} linarith.comp) (@functor.add_const.run.{0 0} (semiring.{0} (has_pos_part.{0} linarith.comp)) (has_add.{0} (has_add.{0} pos)) h0)  := sorry --non-trivial
lemma new_lemma_103596 (h0 : topological_space (normed_field (has_nnnorm string.iterator_imp))) (h1 : preorder (normed_field (has_nnnorm string.iterator_imp))) : order_topology (normed_field (has_nnnorm string.iterator_imp)) := sorry --non-trivial
lemma new_lemma_103597 (h0 : not (topological_space (add_right_cancel_monoid unsigned) -> false)) : @topological_space.separable_space.{0} (add_right_cancel_monoid.{0} unsigned) (@classical.by_contradiction'.{1} (topological_space.{0} (add_right_cancel_monoid.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_103598 (h0 : add_monoid (has_one linarith.comp)) : add_monoid.fg (has_one linarith.comp) := sorry --non-trivial
lemma new_lemma_103599 (h0 : ring (finset (has_pos_part pos))) : is_principal_ideal_ring (finset (has_pos_part pos)) := sorry --non-trivial
lemma new_lemma_103600 (h1 : not (has_mem.mem num has_emptyc.emptyc -> false)) : @is_domain.{0} num (@finset.pi.empty.{1 0} Type ring.{0} num (@classical.by_contradiction'.{0} (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) num (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))) h1))  := sorry --non-trivial
lemma new_lemma_103601 (h0 : functor.add_const (topological_space (canonically_ordered_comm_semiring name)) Type) : @loc_path_connected_space.{0} (canonically_ordered_comm_semiring.{0} name) (@functor.add_const.run.{0 1} (topological_space.{0} (canonically_ordered_comm_semiring.{0} name)) Type h0)  := sorry --non-trivial
lemma new_lemma_103602 (h0 : uniform_space (has_neg (has_add unsigned))) : complete_space (has_neg (has_add unsigned)) := sorry --non-trivial
lemma new_lemma_103603 (h2 : ring (normed_field (denumerable char))) : strong_rank_condition (normed_field (denumerable char)) := sorry --non-trivial
lemma new_lemma_103604 (h0 : list (has_to_string (has_add pos))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_103605 (h0 : complete_lattice (with_one (random_gen (random_gen to_additive.value_type)))) : is_atomistic (with_one (random_gen (random_gen to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_103606 (h0 : group (comm_semigroup Type)) : is_simple_group (comm_semigroup Type) := sorry --non-trivial
lemma new_lemma_103607 (h0 : function.extfun Type semiring) : @is_noetherian_ring.{0} (ordered_comm_monoid.{0} real) (@function.extfun_app.{2 1} Type semiring.{0} h0 (ordered_comm_monoid.{0} real))  := sorry --non-trivial
lemma new_lemma_103608 (h0 : uniform_space (has_norm (semiring congr_arg_kind))) : complete_space (has_norm (semiring congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_103609 (h0 : not (topological_space (has_emptyc fun_info) -> false)) : @totally_disconnected_space.{0} (has_emptyc.{0} fun_info) (@classical.by_contradiction'.{1} (topological_space.{0} (has_emptyc.{0} fun_info)) h0)  := sorry --non-trivial
lemma new_lemma_103610 (h0 : ring (boolean_algebra (has_to_string linarith.comp))) : is_principal_ideal_ring (boolean_algebra (has_to_string linarith.comp)) := sorry --non-trivial
lemma new_lemma_103611 (h0 : function.extfun Type topological_space) : @totally_disconnected_space.{0} (add_group.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (add_group.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_103612 (h0 : functor.add_const (topological_space (add_cancel_monoid name)) pos) : @preirreducible_space.{0} (add_cancel_monoid.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (add_cancel_monoid.{0} name)) pos h0)  := sorry --non-trivial
lemma new_lemma_103613 (h0 : function.extfun Type filter) : countable_Inter_filter (function.extfun_app h0 (has_neg_part name)) := sorry --non-trivial
lemma new_lemma_103614 (h0 : pnat) (h1 : list pnat) (h2 : pnat) : pnat.coprime (list.ilast' h0 h1) h2 := sorry --non-trivial
lemma new_lemma_103615 (h0 : ring (add_comm_monoid empty)) : strong_rank_condition (add_comm_monoid empty) := sorry --non-trivial
lemma new_lemma_103616 (h0 : functor.add_const (function.extfun Type semiring) (has_neg Type)) : @is_noetherian_ring.{0} (has_zero.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type semiring.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type semiring.{0}) (has_neg.{1} Type) h0) (has_zero.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_103617 (h0 : add_monoid (boolean_algebra environment.implicit_infer_kind)) : add_monoid.fg (boolean_algebra environment.implicit_infer_kind) := sorry --non-trivial
lemma new_lemma_103618 (h0 : functor.add_const (ordered_add_comm_monoid (has_add pos)) linarith.comp) : @archimedean.{0} (has_add.{0} pos) (@functor.add_const.run.{0 0} (ordered_add_comm_monoid.{0} (has_add.{0} pos)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_103619 (h0 : topological_space (canonically_linear_ordered_monoid (has_to_string pos))) : t1_space (canonically_linear_ordered_monoid (has_to_string pos)) := sorry --non-trivial
lemma new_lemma_103620 (h0 : not (ring (with_bot (has_norm linarith.comp_source)) -> false)) : @is_domain.{0} (with_bot.{0} (has_norm.{0} linarith.comp_source)) (@classical.by_contradiction'.{1} (ring.{0} (with_bot.{0} (has_norm.{0} linarith.comp_source))) h0)  := sorry --non-trivial
lemma new_lemma_103621 (h0 : function.extfun Type topological_space) : @normal_space.{0} (has_zero.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_zero.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_103622 (h0 : ring (uniform_space enat)) : is_domain (uniform_space enat) := sorry --non-trivial
lemma new_lemma_103623 (h0 : functor.add_const (function.extfun Type topological_space) pos) : @discrete_topology.{0} (has_to_string.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) pos h0) (has_to_string.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_103624 (h0 : ring (add_cancel_monoid name)) : is_principal_ideal_ring (add_cancel_monoid name) := sorry --non-trivial
lemma new_lemma_103625 (h0 : group (has_to_string (has_add (boolean_algebra.core Type)))) : normalizer_condition (has_to_string (has_add (boolean_algebra.core Type))) := sorry --non-trivial
lemma new_lemma_103626 (h0 : cancel_comm_monoid_with_zero (has_zero (has_add Type))) : unique_factorization_monoid (has_zero (has_add Type)) := sorry --non-trivial
lemma new_lemma_103627 (h0 : not (prod (non_assoc_semiring empty) (non_assoc_semiring empty) -> false)) : id_rel (classical.by_contradiction' h0) := sorry --non-trivial
lemma new_lemma_103628 (h0 : functor.comp topological_space has_nndist ennreal) : @t1_space.{0} (has_nndist.{0} ennreal) (@functor.comp.run.{0 0 0} topological_space.{0} has_nndist.{0} ennreal h0)  := sorry --non-trivial
lemma new_lemma_103629 (h0 : topological_space (canonically_linear_ordered_monoid pos)) : totally_disconnected_space (canonically_linear_ordered_monoid pos) := sorry --non-trivial
lemma new_lemma_103630 (h0 : ring (non_unital_non_assoc_semiring char)) : strong_rank_condition (non_unital_non_assoc_semiring char) := sorry --non-trivial
lemma new_lemma_103631 (h0 : functor.add_const (topological_space (preorder num)) num) : @topological_space.separable_space.{0} (preorder.{0} num) (@functor.add_const.run.{0 0} (topological_space.{0} (preorder.{0} num)) num h0)  := sorry --non-trivial
lemma new_lemma_103632 (h0 : ring (has_to_string (has_neg linarith.comp))) : is_principal_ideal_ring (has_to_string (has_neg linarith.comp)) := sorry --non-trivial
lemma new_lemma_103633 (h0 : ordered_add_comm_monoid (canonically_ordered_monoid (boolean_algebra name))) : archimedean (canonically_ordered_monoid (boolean_algebra name)) := sorry --non-trivial
lemma new_lemma_103634 (h0 : complete_lattice (has_compl (mul_one_class (mul_one_class enat)))) : complete_lattice.is_Sup_finite_compact (has_compl (mul_one_class (mul_one_class enat))) := sorry --non-trivial
lemma new_lemma_103635 (h0 : topological_space (has_to_string name)) : topological_space.separable_space (has_to_string name) := sorry --non-trivial
lemma new_lemma_103636 (h0 : functor.add_const (group (normed_comm_ring Type)) environment.implicit_infer_kind) : @normalizer_condition.{1} (normed_comm_ring.{1} Type) (@functor.add_const.run.{1 0} (group.{1} (normed_comm_ring.{1} Type)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_103637 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @has_exists_mul_of_le.{0} (cancel_monoid.{0} pos) (@function.extfun_app.{2 1} Type ordered_comm_monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ordered_comm_monoid.{0}) (cancel_monoid.{0} pos))  := sorry --non-trivial
lemma new_lemma_103638 (h0 : function.extfun Type topological_space) : @t0_space.{0} (is_R_or_C.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (is_R_or_C.{0} empty))  := sorry --non-trivial
lemma new_lemma_103639 (h0 : function.extfun Type (functor.add_const (functor.add_const Prop unsigned))) : functor.add_const.run (functor.add_const.run (function.extfun_app h0 unsigned)) := sorry --non-trivial
lemma new_lemma_103640 (h0 : uniform_space (has_zero (has_pos_part (semigroup pos)))) : complete_space (has_zero (has_pos_part (semigroup pos))) := sorry --non-trivial
lemma new_lemma_103641 (h0 : group (has_ssubset (comm_ring char))) : is_cyclic (has_ssubset (comm_ring char)) := sorry --non-trivial
lemma new_lemma_103642 (h0 : functor.add_const (topological_space (option empty)) num) : @preirreducible_space.{0} (option.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (option.{0} empty)) num h0)  := sorry --non-trivial
lemma new_lemma_103643 (h0 : ring (fintype (has_lt linarith.comp_source))) : strong_rank_condition (fintype (has_lt linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_103644 (h0 : group (div_inv_monoid (random_gen (random_gen fun_info)))) : group.fg (div_inv_monoid (random_gen (random_gen fun_info))) := sorry --non-trivial
lemma new_lemma_103645 (h0 : functor.add_const (topological_space (add_cancel_monoid environment.implicit_infer_kind)) (normed_comm_ring name)) : @sequential_space.{0} (add_cancel_monoid.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (add_cancel_monoid.{0} environment.implicit_infer_kind)) (normed_comm_ring.{0} name) h0)  := sorry --non-trivial
lemma new_lemma_103646 (h0 : monoid (left_cancel_monoid congr_arg_kind)) : monoid.fg (left_cancel_monoid congr_arg_kind) := sorry --non-trivial
lemma new_lemma_103647 (h0 : topological_space (simple_graph unsigned)) : t0_space (simple_graph unsigned) := sorry --non-trivial
lemma new_lemma_103648 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @monoid.fg.{0} (has_neg.{0} empty) (@function.extfun_app.{2 1} Type monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 monoid.{0}) (has_neg.{0} empty))  := sorry --non-trivial
lemma new_lemma_103649 (h0 : function.extfun Type filter) : filter.ne_bot (function.extfun_app h0 (has_top to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_103650 (h0 : not (topological_space (has_inv fun_info) -> false)) : @t0_space.{0} (has_inv.{0} fun_info) (@classical.by_contradiction'.{1} (topological_space.{0} (has_inv.{0} fun_info)) h0)  := sorry --non-trivial
lemma new_lemma_103651 (h0 : topological_space (option empty)) : discrete_topology (option empty) := sorry --non-trivial
lemma new_lemma_103652 (h0 : ring (random_gen (has_inv (has_inv to_additive.value_type)))) : is_domain (random_gen (has_inv (has_inv to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_103653 (h0 : filter (pseudo_metric_space num)) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_103654 (h0 : complete_lattice (has_ssubset (random_gen linarith.ineq))) : is_compactly_generated (has_ssubset (random_gen linarith.ineq)) := sorry --non-trivial
lemma new_lemma_103655 (h0 : ring (has_norm (comm_ring to_additive.value_type))) : rank_condition (has_norm (comm_ring to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_103656 (h0 : function.extfun (Type 1) topological_space) : @t0_space.{1} (normed_comm_ring.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} h0 (normed_comm_ring.{1} Type))  := sorry --non-trivial
lemma new_lemma_103657 (h0 : topological_space (with_one (semiring (semiring congr_arg_kind)))) : path_connected_space (with_one (semiring (semiring congr_arg_kind))) := sorry --non-trivial
lemma new_lemma_103658 (h0 : functor.add_const (ring (has_neg_part environment.implicit_infer_kind)) name) : @rank_condition.{0} (has_neg_part.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (ring.{0} (has_neg_part.{0} environment.implicit_infer_kind)) name h0)  := sorry --non-trivial
lemma new_lemma_103659 (h0 : topological_space (has_emptyc (random_gen (random_gen (random_gen num))))) : irreducible_space (has_emptyc (random_gen (random_gen (random_gen num)))) := sorry --non-trivial
lemma new_lemma_103660 (h0 : topological_space (semigroup (finset (ring linarith.comp)))) : discrete_topology (semigroup (finset (ring linarith.comp))) := sorry --non-trivial
lemma new_lemma_103661 (h0 : ring (has_neg (option (option ennreal)))) : is_domain (has_neg (option (option ennreal))) := sorry --non-trivial
lemma new_lemma_103662 (h0 : function.extfun (finset (Type -> Type)) (has_mem.mem uniform_space)) : @complete_space.{0} (measurable_space.{0} (has_top.{0} (has_top.{0} (has_top.{0} (has_top.{0} (has_top.{0} num)))))) (@function.extfun_app.{2 1} Type uniform_space.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) uniform_space.{0} (@function.extfun_app.{2 0} (finset.{1} (Type → Type)) (@has_mem.mem.{1 1} (Type → Type) (finset.{1} (Type → Type)) (@finset.has_mem.{1} (Type → Type)) uniform_space.{0}) h0 (@has_emptyc.emptyc.{1} (finset.{1} (Type → Type)) (@finset.has_emptyc.{1} (Type → Type))))) (measurable_space.{0} (has_top.{0} (has_top.{0} (has_top.{0} (has_top.{0} (has_top.{0} num)))))))  := sorry --non-trivial
lemma new_lemma_103663 (h0 : functor.add_const (uniform_space (has_nndist Type)) name) : @separated_space.{1} (has_nndist.{1} Type) (@functor.add_const.run.{1 0} (uniform_space.{1} (has_nndist.{1} Type)) name h0)  := sorry --non-trivial
lemma new_lemma_103664 (h0 : functor.add_const (add_monoid (boolean_algebra Type)) Type) : @add_monoid.fg.{1} (boolean_algebra.{1} Type) (@functor.add_const.run.{1 1} (add_monoid.{1} (boolean_algebra.{1} Type)) Type h0)  := sorry --non-trivial
lemma new_lemma_103665 (h0 : topological_space (random_gen (has_norm (semiring (semiring empty))))) : locally_compact_space (random_gen (has_norm (semiring (semiring empty)))) := sorry --non-trivial
lemma new_lemma_103666 (h2 : add_group (add_comm_semigroup environment.projection_info)) : is_add_cyclic (add_comm_semigroup environment.projection_info) := sorry --non-trivial
lemma new_lemma_103667 (h0 : functor.add_const (finset (boolean_algebra environment.implicit_infer_kind)) pos) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_103668 (h0 : fin has_zero.zero) : @is_principal_ideal_ring.{0} (ring.{0} pos) (@matrix.vec_empty.{0} (ring.{0} (ring.{0} pos)) h0)  := sorry --non-trivial
lemma new_lemma_103669 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @sequential_space.{1} (simple_graph.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 topological_space.{1}) (simple_graph.{1} Type))  := sorry --non-trivial
lemma new_lemma_103670 (h0 : functor.add_const Prop (has_norm empty)) : functor.add_const.run h0 := sorry --non-trivial
lemma new_lemma_103671 (h0 : not (group (has_inv char) -> false)) : @is_cyclic.{0} (has_inv.{0} char) (@classical.by_contradiction'.{1} (group.{0} (has_inv.{0} char)) h0)  := sorry --non-trivial
lemma new_lemma_103672 (h0 : filter (has_to_string (normed_comm_ring linarith.comp))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_103673 (h0 : not (function.extfun Type complete_lattice -> false)) : @is_atomistic.{0} (normed_group.{0} linarith.ineq) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type complete_lattice.{0}) h0) (normed_group.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_103674 (h0 : functor.add_const (topological_space (linear_ordered_field pos)) pos) : @loc_path_connected_space.{0} (linear_ordered_field.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (linear_ordered_field.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_103675 (h0 : functor.add_const (list (has_to_string name)) (has_add pos)) : list.nodup (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_103676 (h0 : function.extfun Type complete_lattice) : @complete_lattice.is_Sup_finite_compact.{0} (cancel_monoid.{0} empty) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (cancel_monoid.{0} empty))  := sorry --non-trivial
lemma new_lemma_103677 (h0 : not (group (complete_semilattice_Sup linarith.ineq) -> false)) : @is_cyclic.{0} (complete_semilattice_Sup.{0} linarith.ineq) (@classical.by_contradiction'.{1} (group.{0} (complete_semilattice_Sup.{0} linarith.ineq)) h0)  := sorry --non-trivial
lemma new_lemma_103678 (h0 : functor.add_const (topological_space (measurable_space.dynkin_system empty)) num) : @path_connected_space.{0} (measurable_space.dynkin_system.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (measurable_space.dynkin_system.{0} empty)) num h0)  := sorry --non-trivial
lemma new_lemma_103679 (h0 : functor.add_const (complete_lattice (has_pos_part Type)) (has_pos_part Type)) : @complete_lattice.is_Sup_finite_compact.{1} (has_pos_part.{1} Type) (@functor.add_const.run.{1 1} (complete_lattice.{1} (has_pos_part.{1} Type)) (has_pos_part.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_103680 (h0 : functor.add_const (function.extfun Type monoid) environment.implicit_infer_kind) : @monoid.fg.{0} (semigroup.{0} pos) (@function.extfun_app.{2 1} Type monoid.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type monoid.{0}) environment.implicit_infer_kind h0) (semigroup.{0} pos))  := sorry --non-trivial
lemma new_lemma_103681 (h0 : not (complete_lattice (dlist fun_info) -> false)) : @complete_lattice.is_Sup_finite_compact.{0} (dlist.{0} fun_info) (@classical.by_contradiction'.{1} (complete_lattice.{0} (dlist.{0} fun_info)) h0)  := sorry --non-trivial
lemma new_lemma_103682 (h1 : not (uniform_space (uniform_space char) -> false)) : @complete_space.{0} (uniform_space.{0} char) (@classical.by_contradiction'.{1} (uniform_space.{0} (uniform_space.{0} char)) h1)  := sorry --non-trivial
lemma new_lemma_103683 (h0 : topological_space (has_inv (has_nnnorm fun_info))) : totally_disconnected_space (has_inv (has_nnnorm fun_info)) := sorry --non-trivial
lemma new_lemma_103684 (h0 : empty -> id empty -> id empty) : left_commutative h0 := sorry --non-trivial
lemma new_lemma_103685 (h1 : fun_info -> Prop) : @infi.{0 1} Prop (@conditionally_complete_lattice.to_has_Inf.{0} Prop (@complete_lattice.to_conditionally_complete_lattice.{0} Prop Prop.complete_lattice)) fun_info h1  := sorry --non-trivial
lemma new_lemma_103686 (h0 : add_group (partial_order (semiring num))) : is_add_cyclic (partial_order (semiring num)) := sorry --non-trivial
lemma new_lemma_103687 (h0 : cancel_comm_monoid_with_zero (has_add (has_neg_part (mul_zero_class name)))) : unique_factorization_monoid (has_add (has_neg_part (mul_zero_class name))) := sorry --non-trivial
lemma new_lemma_103688 (h0 : functor.add_const (topological_space (boolean_algebra name)) pos) : @path_connected_space.{0} (boolean_algebra.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (boolean_algebra.{0} name)) pos h0)  := sorry --non-trivial
lemma new_lemma_103689 (h0 : functor.add_const (add_group (has_zero name)) linarith.comp) : @is_add_cyclic.{0} (has_zero.{0} name) (@functor.add_const.run.{0 0} (add_group.{0} (has_zero.{0} name)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_103690 (h0 : fin has_zero.zero) : @is_cyclic.{0} (has_nndist.{0} linarith.comp) (@matrix.vec_empty.{0} (group.{0} (has_nndist.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_103691 (h0 : function.extfun Type ordered_add_comm_monoid) : @archimedean.{0} (has_dist.{0} unsigned) (@function.extfun_app.{2 1} Type ordered_add_comm_monoid.{0} h0 (has_dist.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_103692 (h0 : mul_one_class char) (h1 : set (metric_space enat -> monoid.End char)) : set.separates_points h1 := sorry --non-trivial
lemma new_lemma_103693 (h0 : functor.add_const (topological_space (add_cancel_monoid Type)) pos) : @preirreducible_space.{1} (add_cancel_monoid.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (add_cancel_monoid.{1} Type)) pos h0)  := sorry --non-trivial
lemma new_lemma_103694 (h0 : list (topological_space (has_nnnorm to_additive.value_type))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_103695 (h0 : functor.add_const (ordered_add_comm_monoid Type) (ring Type)) : @archimedean.{1} Type (@functor.add_const.run.{1 1} (ordered_add_comm_monoid.{1} Type) (ring.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_103696 (h0 : topological_space (measurable_space (has_norm congr_arg_kind))) : preirreducible_space (measurable_space (has_norm congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_103697 (h0 : not (function.extfun Type ring -> false)) : @strong_rank_condition.{0} (has_norm.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type ring.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type ring.{0}) h0) (has_norm.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_103698 (h0 : topological_space (normed_field std_gen)) : totally_disconnected_space (normed_field std_gen) := sorry --non-trivial
lemma new_lemma_103699 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : filter.ne_bot (function.extfun_app (function.extfun_app h0 filter) (with_one string_imp)) := sorry --non-trivial
lemma new_lemma_103700 (h0 : topological_space (has_to_string (has_pos_part linarith.comp))) : irreducible_space (has_to_string (has_pos_part linarith.comp)) := sorry --non-trivial
lemma new_lemma_103701 (h0 : monoid (has_one num)) : monoid.fg (has_one num) := sorry --non-trivial
lemma new_lemma_103702 (h0 : functor.comp topological_space mul_zero_class ennreal) : @sequential_space.{0} (mul_zero_class.{0} ennreal) (@functor.comp.run.{0 0 0} topological_space.{0} mul_zero_class.{0} ennreal h0)  := sorry --non-trivial
lemma new_lemma_103703 (h0 : function.extfun Type topological_space) : @t0_space.{0} (has_norm.{0} linarith.ineq) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_norm.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_103704 (h0 : function.extfun nat fin) : @is_cyclic.{1} (canonically_ordered_monoid.{1} Type) (@matrix.vec_empty.{1} (group.{1} (canonically_ordered_monoid.{1} Type)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_103705 (h0 : functor.add_const (function.extfun Type topological_space) pos) : @t1_space.{0} (has_zero.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) pos h0) (has_zero.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_103706 (h0 : ring (has_norm (random_gen to_additive.value_type))) : is_domain (has_norm (random_gen to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_103707 (h0 : not (function.extfun Type add_group -> false)) : @is_add_cyclic.{0} (semiring.{0} fun_info) (@function.extfun_app.{2 1} Type add_group.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type add_group.{0}) h0) (semiring.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_103708 (h0 : function.extfun Type list) : list.nodup (function.extfun_app h0 (monoid congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_103709 (h0 : not (add_group (plift congr_arg_kind) -> false)) : @is_add_cyclic.{1} (plift.{1} congr_arg_kind) (@classical.by_contradiction'.{2} (add_group.{1} (plift.{1} congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_103710 (h0 : functor.add_const (topological_space (comm_group environment.implicit_infer_kind)) linarith.comp) : @totally_separated_space.{0} (comm_group.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (comm_group.{0} environment.implicit_infer_kind)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_103711 (h0 : functor.add_const (group (complete_distrib_lattice congr_arg_kind)) unsigned) : @normalizer_condition.{0} (complete_distrib_lattice.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (group.{0} (complete_distrib_lattice.{0} congr_arg_kind)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_103712 (h0 : not (ring (measurable_space.dynkin_system empty) -> false)) : @is_domain.{0} (measurable_space.dynkin_system.{0} empty) (@classical.by_contradiction'.{1} (ring.{0} (measurable_space.dynkin_system.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_103713 (h0 : prod (canonically_linear_ordered_monoid ennreal) (canonically_linear_ordered_monoid ennreal)) : set.diagonal (canonically_linear_ordered_monoid ennreal) h0 := sorry --non-trivial
lemma new_lemma_103714 (h0 : functor.add_const (topological_space (boolean_algebra linarith.comp)) pos) : @preconnected_space.{0} (boolean_algebra.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (boolean_algebra.{0} linarith.comp)) pos h0)  := sorry --non-trivial
lemma new_lemma_103715 (h0 : functor.add_const (topological_space (sub_neg_monoid linarith.comp)) (has_neg linarith.comp)) : @locally_compact_space.{0} (sub_neg_monoid.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (sub_neg_monoid.{0} linarith.comp)) (has_neg.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_103716 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : is_compactly_generated (measurable_space linarith.comp_source) := sorry --non-trivial
lemma new_lemma_103717 (h0 : ring (ordered_cancel_add_comm_monoid (option (option (option unsigned))))) : is_domain (ordered_cancel_add_comm_monoid (option (option (option unsigned)))) := sorry --non-trivial
lemma new_lemma_103718 (h0 : topological_space (canonically_ordered_monoid (has_add (has_bot (has_add pos))))) : regular_space (canonically_ordered_monoid (has_add (has_bot (has_add pos)))) := sorry --non-trivial
lemma new_lemma_103719 (h0 : function.extfun Type complete_lattice) : @is_compactly_generated.{0} (semiring.{0} empty) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (semiring.{0} empty))  := sorry --non-trivial
lemma new_lemma_103720 (h0 : topological_space (with_one (random_gen fun_info))) : t0_space (with_one (random_gen fun_info)) := sorry --non-trivial
lemma new_lemma_103721 (h0 : functor.add_const (ring (omega_complete_partial_order unsigned)) empty) : @is_principal_ideal_ring.{0} (omega_complete_partial_order.{0} unsigned) (@functor.add_const.run.{0 0} (ring.{0} (omega_complete_partial_order.{0} unsigned)) empty h0)  := sorry --non-trivial
lemma new_lemma_103722 (h0 : function.extfun Type semiring) : @is_noetherian_ring.{0} (has_add.{0} unsigned) (@function.extfun_app.{2 1} Type semiring.{0} h0 (has_add.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_103723 (h0 : fin has_zero.zero) : @locally_compact_space.{0} (boolean_algebra.{0} linarith.comp) (@matrix.vec_empty.{0} (topological_space.{0} (boolean_algebra.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_103724 (h0 : add_group (has_add (has_neg linarith.comp))) : is_add_cyclic (has_add (has_neg linarith.comp)) := sorry --non-trivial
lemma new_lemma_103725 (h0 : function.extfun Type topological_space) : @t0_space.{0} (measurable_space.{0} linarith.ineq) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (measurable_space.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_103726 (h0 : Prop) (h1 : thunk Prop) : yyy_to h0 (@trace_call_stack.{0} Prop h1)  := sorry --non-trivial
lemma new_lemma_103727 (h0 : ordered_add_comm_monoid (has_neg (option (option (option (option ennreal)))))) : archimedean (has_neg (option (option (option (option ennreal))))) := sorry --non-trivial
lemma new_lemma_103728 (h0 : topological_space (normed_lattice_add_comm_group (has_add pos))) : locally_compact_space (normed_lattice_add_comm_group (has_add pos)) := sorry --non-trivial
lemma new_lemma_103729 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @unique_factorization_monoid.{0} (comm_semigroup.{0} pos) (@function.extfun_app.{2 1} Type cancel_comm_monoid_with_zero.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 cancel_comm_monoid_with_zero.{0}) (comm_semigroup.{0} pos))  := sorry --non-trivial
lemma new_lemma_103730 (h0 : has_mem.mem (with_one fun_info) has_emptyc.emptyc) : @complete_lattice.is_Sup_finite_compact.{0} (with_one.{0} fun_info) (@finset.pi.empty.{1 0} Type complete_lattice.{0} (with_one.{0} fun_info) h0)  := sorry --non-trivial
lemma new_lemma_103731 (h3 : add_group (random_gen to_additive.value_type)) : is_add_cyclic (random_gen to_additive.value_type) := sorry --non-trivial
lemma new_lemma_103732 (h0 : topological_space (add_comm_semigroup std_gen)) (h1 : preorder (add_comm_semigroup std_gen)) : order_topology (add_comm_semigroup std_gen) := sorry --non-trivial
lemma new_lemma_103733 (h0 : functor.add_const (list (has_Inf name)) Type) : palindrome (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_103734 (h0 : function.extfun Type add_monoid) : @add_monoid.fg.{0} (has_Inf.{0} pos) (@function.extfun_app.{2 1} Type add_monoid.{0} h0 (has_Inf.{0} pos))  := sorry --non-trivial
lemma new_lemma_103735 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : list.nodup (function.extfun_app (function.extfun_app h0 list) (ordered_ring empty)) := sorry --non-trivial
lemma new_lemma_103736 (h0 : complete_lattice (add_left_cancel_monoid string_imp)) : complete_lattice.is_Sup_finite_compact (add_left_cancel_monoid string_imp) := sorry --non-trivial
lemma new_lemma_103737 (h0 : functor.add_const (ring (semigroup name)) (comm_group name)) : @is_domain.{0} (semigroup.{0} name) (@functor.add_const.run.{0 0} (ring.{0} (semigroup.{0} name)) (comm_group.{0} name) h0)  := sorry --non-trivial
lemma new_lemma_103738 (h0 : function.extfun Type complete_lattice) : @is_atomistic.{0} (with_one.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (with_one.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_103739 (h0 : function.extfun Type topological_space) : @path_connected_space.{0} (has_union.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_union.{0} num))  := sorry --non-trivial
lemma new_lemma_103740 (h0 : group (has_inv (random_gen (random_gen (random_gen (random_gen char)))))) : group.fg (has_inv (random_gen (random_gen (random_gen (random_gen char))))) := sorry --non-trivial
lemma new_lemma_103741 (h0 : group (linear_ordered_cancel_comm_monoid congr_arg_kind)) : is_cyclic (linear_ordered_cancel_comm_monoid congr_arg_kind) := sorry --non-trivial
lemma new_lemma_103742 (h0 : functor.add_const (complete_lattice (normed_comm_ring pos)) Type) : @is_compactly_generated.{0} (normed_comm_ring.{0} pos) (@functor.add_const.run.{0 1} (complete_lattice.{0} (normed_comm_ring.{0} pos)) Type h0)  := sorry --non-trivial
lemma new_lemma_103743 (h0 : function.extfun Type (functor.add_const (monoid auto.case_option))) : @monoid.fg.{0} auto.case_option (@functor.add_const.run.{0 0} (monoid.{0} auto.case_option) ennreal (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (monoid.{0} auto.case_option)) h0 ennreal))  := sorry --non-trivial
lemma new_lemma_103744 (h0 : ordered_add_comm_monoid (finset (finset (finset pos)))) : archimedean (finset (finset (finset pos))) := sorry --non-trivial
lemma new_lemma_103745 (h0 : fin has_zero.zero) : @path_connected_space.{0} (has_pos_part.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@matrix.vec_empty.{1} (function.extfun.{2 1} Type topological_space.{0}) h0) (has_pos_part.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_103746 (h0 : topological_space (cancel_monoid (has_add (boolean_algebra.core Type)))) : path_connected_space (cancel_monoid (has_add (boolean_algebra.core Type))) := sorry --non-trivial
lemma new_lemma_103747 (h0 : functor.add_const (monoid (comm_group Type)) Type) : @monoid.fg.{1} (comm_group.{1} Type) (@functor.add_const.run.{1 1} (monoid.{1} (comm_group.{1} Type)) Type h0)  := sorry --non-trivial
lemma new_lemma_103748 (h0 : group (with_one (has_nnnorm linarith.ineq))) : is_cyclic (with_one (has_nnnorm linarith.ineq)) := sorry --non-trivial
lemma new_lemma_103749 (h0 : topological_space (has_pos_part (has_add pos))) : preirreducible_space (has_pos_part (has_add pos)) := sorry --non-trivial
lemma new_lemma_103750 (h0 : topological_space (semigroup (has_neg linarith.comp))) : totally_separated_space (semigroup (has_neg linarith.comp)) := sorry --non-trivial
lemma new_lemma_103751 (h0 : topological_space (linear_ordered_field empty)) : discrete_topology (linear_ordered_field empty) := sorry --non-trivial
lemma new_lemma_103752 (h0 : not (function.extfun Type cancel_comm_monoid_with_zero -> false)) : @unique_factorization_monoid.{0} (has_one.{0} unsigned) (@function.extfun_app.{2 1} Type cancel_comm_monoid_with_zero.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type cancel_comm_monoid_with_zero.{0}) h0) (has_one.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_103753 (h0 : functor.add_const (semiring (has_nndist Type)) name) : @is_noetherian_ring.{1} (has_nndist.{1} Type) (@functor.add_const.run.{1 0} (semiring.{1} (has_nndist.{1} Type)) name h0)  := sorry --non-trivial
lemma new_lemma_103754 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_noetherian_ring.{0} (canonically_ordered_comm_semiring.{0} pos) (@function.extfun_app.{2 1} Type semiring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 semiring.{0}) (canonically_ordered_comm_semiring.{0} pos))  := sorry --non-trivial
lemma new_lemma_103755 (h0 : ring (has_union (has_union (add_group linarith.comp)))) : rank_condition (has_union (has_union (add_group linarith.comp))) := sorry --non-trivial
lemma new_lemma_103756 (h0 : functor.add_const (filter (has_nndist empty)) empty) : filter.ne_bot (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_103757 (h0 : function.extfun Type group) : @normalizer_condition.{0} (encodable.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type group.{0} h0 (encodable.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_103758 (h0 : not (complete_lattice (with_one linarith.ineq) -> false)) : @complete_lattice.is_Sup_finite_compact.{0} (with_one.{0} linarith.ineq) (@classical.by_contradiction'.{1} (complete_lattice.{0} (with_one.{0} linarith.ineq)) h0)  := sorry --non-trivial
lemma new_lemma_103759 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @archimedean.{0} (has_nndist.{0} linarith.comp) (@function.extfun_app.{2 1} Type ordered_add_comm_monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ordered_add_comm_monoid.{0}) (has_nndist.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_103760 (h0 : functor.add_const (list (semigroup linarith.comp)) (boolean_algebra pos)) : palindrome (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_103761 (h0 : ring (measurable_space (random_gen fun_info))) : strong_rank_condition (measurable_space (random_gen fun_info)) := sorry --non-trivial
lemma new_lemma_103762 (h0 : functor.add_const (monoid (normed_comm_ring Type)) linarith.comp) : @monoid.fg.{1} (normed_comm_ring.{1} Type) (@functor.add_const.run.{1 0} (monoid.{1} (normed_comm_ring.{1} Type)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_103763 (h0 : functor.add_const (function.extfun (Type 1) topological_space) pos) : @t0_space.{1} (generalized_boolean_algebra.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) topological_space.{1}) pos h0) (generalized_boolean_algebra.{1} Type))  := sorry --non-trivial
lemma new_lemma_103764 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : is_noetherian_ring nnreal := sorry --non-trivial
lemma new_lemma_103765 (h0 : with_bot pnat) (h1 : ne h0 has_bot.bot) (h2 : ulower pnat) : pnat.coprime (with_bot.unbot h0 h1) (ulower.up h2) := sorry --non-trivial
lemma new_lemma_103766 (h0 : ring (mul_zero_class (finset (has_to_string Type)))) : is_domain (mul_zero_class (finset (has_to_string Type))) := sorry --non-trivial
lemma new_lemma_103767 (h0 : ring (normed_lattice_add_comm_group (has_add (has_add real)))) : rank_condition (normed_lattice_add_comm_group (has_add (has_add real))) := sorry --non-trivial
lemma new_lemma_103768 (h0 : uniform_space (has_add (boolean_algebra.core linarith.comp))) : complete_space (has_add (boolean_algebra.core linarith.comp)) := sorry --non-trivial
lemma new_lemma_103769 (h0 : functor.add_const (function.extfun Type ring) environment.implicit_infer_kind) : @strong_rank_condition.{0} (has_zero.{0} linarith.comp) (@function.extfun_app.{2 1} Type ring.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type ring.{0}) environment.implicit_infer_kind h0) (has_zero.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_103770 (h3 : add_group fun_info) : is_add_cyclic fun_info := sorry --non-trivial
lemma new_lemma_103771 (h0 : topological_space (ordered_comm_ring (ring (has_add (ring (has_Inf Type)))))) : preirreducible_space (ordered_comm_ring (ring (has_add (ring (has_Inf Type))))) := sorry --non-trivial
lemma new_lemma_103772 (h0 : ring (has_repr (random_gen empty))) : rank_condition (has_repr (random_gen empty)) := sorry --non-trivial
lemma new_lemma_103773 (h0 : functor.add_const (function.extfun (Type 1) ring) (ring (has_Inf Type))) : @is_domain.{1} Type (@function.extfun_app.{3 2} (Type 1) ring.{1} (@functor.add_const.run.{2 1} (function.extfun.{3 2} (Type 1) ring.{1}) (ring.{1} (has_Inf.{1} Type)) h0) Type)  := sorry --non-trivial
lemma new_lemma_103774 (h0 : ring (has_ssubset ereal)) : is_domain (has_ssubset ereal) := sorry --non-trivial
lemma new_lemma_103775 (h0 : topological_space (normed_comm_ring (has_neg pos))) : preirreducible_space (normed_comm_ring (has_neg pos)) := sorry --non-trivial
lemma new_lemma_103776 (h0 : filter (has_star empty)) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_103777 (h0 : functor.add_const (complete_lattice (add_left_cancel_semigroup unsigned)) (semiring (semiring (semiring empty)))) : @complete_lattice.is_Sup_finite_compact.{0} (add_left_cancel_semigroup.{0} unsigned) (@functor.add_const.run.{0 0} (complete_lattice.{0} (add_left_cancel_semigroup.{0} unsigned)) (semiring.{0} (semiring.{0} (semiring.{0} empty))) h0)  := sorry --non-trivial
lemma new_lemma_103778 (h0 : functor.add_const (topological_space (normed_comm_ring environment.implicit_infer_kind)) name) : @t1_space.{0} (normed_comm_ring.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (normed_comm_ring.{0} environment.implicit_infer_kind)) name h0)  := sorry --non-trivial
lemma new_lemma_103779 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @totally_separated_space.{1} (generalized_boolean_algebra.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 topological_space.{1}) (generalized_boolean_algebra.{1} Type))  := sorry --non-trivial
lemma new_lemma_103780 (h0 : ring (distrib linarith.comp_source)) : rank_condition (distrib linarith.comp_source) := sorry --non-trivial
lemma new_lemma_103781 (h0 : functor.add_const (ordered_add_comm_monoid (ring pos)) linarith.comp) : @archimedean.{0} (ring.{0} pos) (@functor.add_const.run.{0 0} (ordered_add_comm_monoid.{0} (ring.{0} pos)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_103782 (h0 : topological_space (has_pos_part (ring (finset linarith.comp)))) : t0_space (has_pos_part (ring (finset linarith.comp))) := sorry --non-trivial
lemma new_lemma_103783 (h0 : ring (dlist (comm_ring (random_gen (random_gen (random_gen fun_info)))))) : is_domain (dlist (comm_ring (random_gen (random_gen (random_gen fun_info))))) := sorry --non-trivial
lemma new_lemma_103784 (h0 : function.extfun Type topological_space) : @regular_space.{0} (complete_distrib_lattice.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (complete_distrib_lattice.{0} name))  := sorry --non-trivial
lemma new_lemma_103785 (h0 : functor.add_const (function.extfun Type add_group) (has_Inf linarith.comp)) : @is_add_cyclic.{0} pos (@function.extfun_app.{2 1} Type add_group.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type add_group.{0}) (has_Inf.{0} linarith.comp) h0) pos)  := sorry --non-trivial
lemma new_lemma_103786 (h0 : functor.add_const (topological_space (linear_ordered_field empty)) unsigned) : @t0_space.{0} (linear_ordered_field.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (linear_ordered_field.{0} empty)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_103787 (h0 : function.extfun (Type 1) topological_space) : @topological_space.separable_space.{1} (add_cancel_monoid.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} h0 (add_cancel_monoid.{1} Type))  := sorry --non-trivial
lemma new_lemma_103788 (h0 : list (linear_ordered_add_comm_group (has_ssubset fun_info))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_103789 (h0 : functor.add_const (ring (ring name)) environment.implicit_infer_kind) : @strong_rank_condition.{0} (ring.{0} name) (@functor.add_const.run.{0 0} (ring.{0} (ring.{0} name)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_103790 (h0 : topological_space (measurable_space.dynkin_system empty)) : locally_compact_space (measurable_space.dynkin_system empty) := sorry --non-trivial
lemma new_lemma_103791 (h0 : ring (boolean_algebra.core (comm_group environment.implicit_infer_kind))) : rank_condition (boolean_algebra.core (comm_group environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_103792 (h0 : uniform_space (has_top (metric_space num))) : complete_space (has_top (metric_space num)) := sorry --non-trivial
lemma new_lemma_103793 (h0 : topological_space (has_pos_part (has_Inf (has_Inf (has_Inf pos))))) : totally_disconnected_space (has_pos_part (has_Inf (has_Inf (has_Inf pos)))) := sorry --non-trivial
lemma new_lemma_103794 (h0 : ring (has_append (semigroup (has_nnnorm (has_nnnorm linarith.comp_source))))) : strong_rank_condition (has_append (semigroup (has_nnnorm (has_nnnorm linarith.comp_source)))) := sorry --non-trivial
lemma new_lemma_103795 (h0 : group (has_norm (has_inv (random_gen (random_gen (random_gen (random_gen char))))))) : group.fg (has_norm (has_inv (random_gen (random_gen (random_gen (random_gen char)))))) := sorry --non-trivial
lemma new_lemma_103796 (h0 : ring (has_union (semiring (semiring empty)))) : strong_rank_condition (has_union (semiring (semiring empty))) := sorry --non-trivial
lemma new_lemma_103797 (h0 : function.extfun (finset (Type -> Type)) (has_mem.mem ring)) : @rank_condition.{0} (linear_ordered_semiring.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type ring.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) ring.{0} (@function.extfun_app.{2 0} (finset.{1} (Type → Type)) (@has_mem.mem.{1 1} (Type → Type) (finset.{1} (Type → Type)) (@finset.has_mem.{1} (Type → Type)) ring.{0}) h0 (@has_emptyc.emptyc.{1} (finset.{1} (Type → Type)) (@finset.has_emptyc.{1} (Type → Type))))) (linear_ordered_semiring.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_103798 (h0 : function.extfun Type monoid) : @monoid.fg.{0} (simple_graph.{0} pos) (@function.extfun_app.{2 1} Type monoid.{0} h0 (simple_graph.{0} pos))  := sorry --non-trivial
lemma new_lemma_103799 (h0 : group (canonically_linear_ordered_monoid (has_Inf name))) : group.fg (canonically_linear_ordered_monoid (has_Inf name)) := sorry --non-trivial
lemma new_lemma_103800 (h0 : topological_space (mul_zero_class empty)) : preirreducible_space (mul_zero_class empty) := sorry --non-trivial
lemma new_lemma_103801 (h1 : group (has_compl char)) : group.fg (has_compl char) := sorry --non-trivial
lemma new_lemma_103802 (h1 : topological_space (has_append (random_gen fun_info))) : totally_disconnected_space (has_append (random_gen fun_info)) := sorry --non-trivial
lemma new_lemma_103803 (h0 : group (boolean_algebra (has_to_string (has_zero (finset linarith.comp))))) : group.fg (boolean_algebra (has_to_string (has_zero (finset linarith.comp)))) := sorry --non-trivial
lemma new_lemma_103804 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @strong_rank_condition.{0} (measurable_space.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (measurable_space.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_103805 (h0 : fin has_zero.zero) : @discrete_topology.{0} (has_Inf.{0} pos) (@matrix.vec_empty.{0} (topological_space.{0} (has_Inf.{0} pos)) h0)  := sorry --non-trivial
lemma new_lemma_103806 (h0 : functor.add_const (filter (boolean_algebra.core Type)) name) : filter.ne_bot (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_103807 (h2 : filter (has_ssubset fun_info)) : filter.ne_bot h2 := sorry --non-trivial
lemma new_lemma_103808 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : finset.nonempty (function.extfun_app (function.extfun_app h0 finset) (id to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_103809 (h0 : not (topological_space (measure_theory.measure_space congr_arg_kind) -> false)) : @normal_space.{0} (measure_theory.measure_space.{0} congr_arg_kind) (@classical.by_contradiction'.{1} (topological_space.{0} (measure_theory.measure_space.{0} congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_103810 (h0 : function.extfun Type topological_space) : @loc_path_connected_space.{0} (complete_distrib_lattice.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (complete_distrib_lattice.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_103811 (h0 : ring (nondiscrete_normed_field ereal)) : is_domain (nondiscrete_normed_field ereal) := sorry --non-trivial
lemma new_lemma_103812 (h0 : function.extfun Type complete_lattice) : @complete_lattice.is_Sup_finite_compact.{0} (has_union.{0} unsigned) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (has_union.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_103813 (h0 : uniform_space (has_nndist (finset (finset (finset (has_add pos)))))) : separated_space (has_nndist (finset (finset (finset (has_add pos))))) := sorry --non-trivial
lemma new_lemma_103814 (h0 : not (function.extfun Type topological_space -> false)) : @discrete_topology.{0} (normed_group.{0} fun_info) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (normed_group.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_103815 (h0 : function.extfun Type add_monoid) : @add_monoid.fg.{0} (normed_linear_ordered_group.{0} (option.{0} empty)) (@function.extfun_app.{2 1} Type add_monoid.{0} h0 (normed_linear_ordered_group.{0} (option.{0} empty)))  := sorry --non-trivial
lemma new_lemma_103816 (h0 : topological_space (is_R_or_C unsigned)) : preirreducible_space (is_R_or_C unsigned) := sorry --non-trivial
lemma new_lemma_103817 (h0 : topological_space (mul_zero_class (finset pos))) : irreducible_space (mul_zero_class (finset pos)) := sorry --non-trivial
lemma new_lemma_103818 (h0 : add_comm_semigroup fun_info -> add_comm_semigroup fun_info) (h1 : add_comm_semigroup fun_info) : function.is_fixed_pt h0 h1 := sorry --non-trivial
lemma new_lemma_103819 (h0 : topological_space (normed_comm_ring (has_add (finset pos)))) : preirreducible_space (normed_comm_ring (has_add (finset pos))) := sorry --non-trivial
lemma new_lemma_103820 (h0 : topological_space (has_one (semiring (semiring empty)))) : normal_space (has_one (semiring (semiring empty))) := sorry --non-trivial
lemma new_lemma_103821 (h0 : uniform_space (complete_linear_order (semiring congr_arg_kind))) : separated_space (complete_linear_order (semiring congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_103822 (h0 : ereal -> ereal -> Prop) : irreflexive h0 := sorry --non-trivial
lemma new_lemma_103823 (h0 : function.extfun Type ordered_add_comm_monoid) : @archimedean.{0} (has_bot.{0} real) (@function.extfun_app.{2 1} Type ordered_add_comm_monoid.{0} h0 (has_bot.{0} real))  := sorry --non-trivial
lemma new_lemma_103824 (h0 : monoid (monoid_with_zero pos)) : monoid.fg (monoid_with_zero pos) := sorry --non-trivial
lemma new_lemma_103825 (h0 : function.extfun Type group) : @normalizer_condition.{0} (linear_ordered_comm_monoid_with_zero.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type group.{0} h0 (linear_ordered_comm_monoid_with_zero.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_103826 (h0 : functor.add_const (topological_space (canonically_ordered_monoid linarith.comp)) linarith.comp) : @irreducible_space.{0} (canonically_ordered_monoid.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (canonically_ordered_monoid.{0} linarith.comp)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_103827 (h0 : not (uniform_space char -> false)) : @complete_space.{0} char (@classical.by_contradiction'.{1} (uniform_space.{0} char) h0)  := sorry --non-trivial
lemma new_lemma_103828 (h0 : not (function.extfun (Type -> Type) (function.extfun Type) -> false)) : @locally_compact_space.{0} fun_info (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) (@classical.by_contradiction'.{2} (function.extfun.{2 2} (Type → Type) (function.extfun.{2 1} Type)) h0) topological_space.{0}) fun_info)  := sorry --non-trivial
lemma new_lemma_103829 (h0 : fin has_zero.zero) : @complete_space.{0} (canonically_linear_ordered_monoid.{0} pos) (@matrix.vec_empty.{0} (uniform_space.{0} (canonically_linear_ordered_monoid.{0} pos)) h0)  := sorry --non-trivial
lemma new_lemma_103830 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @group.fg.{0} (has_nndist.{0} pos) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (has_nndist.{0} pos))  := sorry --non-trivial
lemma new_lemma_103831 (h0 : functor.add_const (ring (complete_distrib_lattice linarith.comp)) name) : @rank_condition.{0} (complete_distrib_lattice.{0} linarith.comp) (@functor.add_const.run.{0 0} (ring.{0} (complete_distrib_lattice.{0} linarith.comp)) name h0)  := sorry --non-trivial
lemma new_lemma_103832 (h0 : topological_space (complete_distrib_lattice pos)) : preconnected_space (complete_distrib_lattice pos) := sorry --non-trivial
lemma new_lemma_103833 (h0 : function.extfun Type topological_space) : @locally_compact_space.{0} (bin_tree.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (bin_tree.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_103834 (h0 : topological_space (has_to_string (finset linarith.comp))) : totally_separated_space (has_to_string (finset linarith.comp)) := sorry --non-trivial
lemma new_lemma_103835 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @complete_space.{0} (generalized_boolean_algebra.{0} real) (@function.extfun_app.{2 1} Type uniform_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 uniform_space.{0}) (generalized_boolean_algebra.{0} real))  := sorry --non-trivial
lemma new_lemma_103836 (h0 : multiset (has_compl string_imp)) (h1 : not (multiset (has_compl string_imp) -> false)) : multiset.disjoint h0 (classical.by_contradiction' h1) := sorry --non-trivial
lemma new_lemma_103837 (h0 : functor.add_const (topological_space (ring Type)) linarith.comp) : @loc_path_connected_space.{1} (ring.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (ring.{1} Type)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_103838 (h0 : fin has_zero.zero) : @regular_space.{0} (has_bot.{0} linarith.comp) (@matrix.vec_empty.{0} (topological_space.{0} (has_bot.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_103839 (h0 : functor.add_const (ordered_add_comm_monoid (as_linear_order empty)) congr_arg_kind) : @archimedean.{0} (as_linear_order.{0} empty) (@functor.add_const.run.{0 0} (ordered_add_comm_monoid.{0} (as_linear_order.{0} empty)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_103840 (h0 : topological_space (topological_space (has_inv (random_gen fun_info)))) : path_connected_space (topological_space (has_inv (random_gen fun_info))) := sorry --non-trivial
lemma new_lemma_103841 (h0 : topological_space (generalized_boolean_algebra (has_neg Type))) : normal_space (generalized_boolean_algebra (has_neg Type)) := sorry --non-trivial
lemma new_lemma_103842 (h0 : group (normed_group (random_gen num))) : group.fg (normed_group (random_gen num)) := sorry --non-trivial
lemma new_lemma_103843 (h0 : topological_space (has_add (has_add (has_add (option (option ennreal)))))) : irreducible_space (has_add (has_add (has_add (option (option ennreal))))) := sorry --non-trivial
lemma new_lemma_103844 (h0 : not (topological_space (metric_space congr_arg_kind) -> false)) : @normal_space.{0} (metric_space.{0} congr_arg_kind) (@classical.by_contradiction'.{1} (topological_space.{0} (metric_space.{0} congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_103845 (h0 : functor.add_const (ordered_add_comm_monoid (semilattice_inf linarith.comp)) pos) : @archimedean.{0} (semilattice_inf.{0} linarith.comp) (@functor.add_const.run.{0 0} (ordered_add_comm_monoid.{0} (semilattice_inf.{0} linarith.comp)) pos h0)  := sorry --non-trivial
lemma new_lemma_103846 (h0 : topological_space (has_dist unsigned)) : loc_path_connected_space (has_dist unsigned) := sorry --non-trivial
lemma new_lemma_103847 (h0 : ring (has_nndist (has_neg Type))) : is_principal_ideal_ring (has_nndist (has_neg Type)) := sorry --non-trivial
lemma new_lemma_103848 (h0 : function.extfun Type topological_space) : @preirreducible_space.{0} (semiring.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (semiring.{0} empty))  := sorry --non-trivial
lemma new_lemma_103849 (h0 : topological_space (canonically_ordered_comm_semiring (option (option (option (option empty)))))) : preirreducible_space (canonically_ordered_comm_semiring (option (option (option (option empty))))) := sorry --non-trivial
lemma new_lemma_103850 (h0 : semiring (has_pos_part (has_neg name))) : is_noetherian_ring (has_pos_part (has_neg name)) := sorry --non-trivial
lemma new_lemma_103851 (h0 : set (has_nnnorm enat -> string.iterator_imp)) : set.separates_points h0 := sorry --non-trivial
lemma new_lemma_103852 (h0 : functor.add_const (topological_space (finset ennreal)) name) : @preirreducible_space.{0} (finset.{0} ennreal) (@functor.add_const.run.{0 0} (topological_space.{0} (finset.{0} ennreal)) name h0)  := sorry --non-trivial
lemma new_lemma_103853 (h0 : topological_space (measure_theory.measure_space congr_arg_kind)) : t1_space (measure_theory.measure_space congr_arg_kind) := sorry --non-trivial
lemma new_lemma_103854 (h0 : not (topological_space (non_unital_non_assoc_semiring (has_lt char)) -> false)) : @t0_space.{0} (non_unital_non_assoc_semiring.{0} (has_lt.{0} char)) (@classical.by_contradiction'.{1} (topological_space.{0} (non_unital_non_assoc_semiring.{0} (has_lt.{0} char))) h0)  := sorry --non-trivial
lemma new_lemma_103855 (h0 : topological_space (has_ssubset (has_nnnorm fun_info))) : path_connected_space (has_ssubset (has_nnnorm fun_info)) := sorry --non-trivial
lemma new_lemma_103856 (h0 : semiring (boolean_algebra.core (option nnreal))) : is_noetherian_ring (boolean_algebra.core (option nnreal)) := sorry --non-trivial
lemma new_lemma_103857 (h0 : topological_space (id (has_norm (has_top unsigned)))) : locally_compact_space (id (has_norm (has_top unsigned))) := sorry --non-trivial
lemma new_lemma_103858 (h0 : topological_space (has_lt (mul_one_class char))) : totally_disconnected_space (has_lt (mul_one_class char)) := sorry --non-trivial
lemma new_lemma_103859 (h0 : ordered_comm_monoid (canonically_linear_ordered_monoid (has_add linarith.comp))) : has_exists_mul_of_le (canonically_linear_ordered_monoid (has_add linarith.comp)) := sorry --non-trivial
lemma new_lemma_103860 (h0 : functor.add_const (list (generalized_boolean_algebra linarith.comp)) name) : list.nodup (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_103861 (h2 : ring (add_left_cancel_monoid char)) : rank_condition (add_left_cancel_monoid char) := sorry --non-trivial
lemma new_lemma_103862 (h0 : ring (normed_group empty)) : is_domain (normed_group empty) := sorry --non-trivial
lemma new_lemma_103863 (h2 : has_lt (add_comm_semigroup char)) : no_max_order (add_comm_semigroup char) := sorry --non-trivial
lemma new_lemma_103864 (h0 : function.extfun nat fin) : @irreducible_space.{1} (simple_graph.{1} Type) (@matrix.vec_empty.{1} (topological_space.{1} (simple_graph.{1} Type)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_103865 (h0 : functor.add_const (topological_space (left_cancel_monoid num)) empty) : @topological_space.separable_space.{0} (left_cancel_monoid.{0} num) (@functor.add_const.run.{0 0} (topological_space.{0} (left_cancel_monoid.{0} num)) empty h0)  := sorry --non-trivial
lemma new_lemma_103866 (h0 : measurable_space (uniform_space char)) (h1 : not (filter (uniform_space char) -> false)) : filter.is_measurably_generated (classical.by_contradiction' h1) := sorry --non-trivial
lemma new_lemma_103867 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @archimedean.{0} (linear_ordered_comm_group.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type ordered_add_comm_monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ordered_add_comm_monoid.{0}) (linear_ordered_comm_group.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_103868 (h0 : functor.add_const (filter (boolean_algebra pos)) (add_cancel_monoid Type)) : filter.ne_bot (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_103869 (h0 : topological_space (has_norm (semiring (semiring (semiring (semiring unsigned)))))) : locally_compact_space (has_norm (semiring (semiring (semiring (semiring unsigned))))) := sorry --non-trivial
lemma new_lemma_103870 (h0 : functor.comp group has_zero name) : @group.fg.{0} (has_zero.{0} name) (@functor.comp.run.{0 0 0} group.{0} has_zero.{0} name (@functor.comp.run.{0 0 0} group.{0} has_zero.{0} name (@functor.comp.run.{0 0 0} group.{0} has_zero.{0} name (@functor.comp.run.{0 0 0} group.{0} has_zero.{0} name (@functor.comp.run.{0 0 0} group.{0} has_zero.{0} name h0)))))  := sorry --non-trivial
lemma new_lemma_103871 (h0 : topological_space (canonically_ordered_comm_semiring (has_Sup name))) : regular_space (canonically_ordered_comm_semiring (has_Sup name)) := sorry --non-trivial
lemma new_lemma_103872 (h0 : topological_space (group_with_zero ennreal)) : locally_compact_space (group_with_zero ennreal) := sorry --non-trivial
lemma new_lemma_103873 (h0 : complete_lattice (ordered_comm_ring pos)) : is_atomistic (ordered_comm_ring pos) := sorry --non-trivial
lemma new_lemma_103874 (h0 : ordered_add_comm_monoid (boolean_algebra.core (has_add (has_add (has_add environment.implicit_infer_kind))))) : archimedean (boolean_algebra.core (has_add (has_add (has_add environment.implicit_infer_kind)))) := sorry --non-trivial
lemma new_lemma_103875 (h0 : complete_lattice (has_to_string (option (cancel_monoid name)))) : is_atomistic (has_to_string (option (cancel_monoid name))) := sorry --non-trivial
lemma new_lemma_103876 (h1 : topological_space (normed_group string_imp)) : totally_separated_space (normed_group string_imp) := sorry --non-trivial
lemma new_lemma_103877 (h0 : group (semiring empty)) : group.fg (semiring empty) := sorry --non-trivial
lemma new_lemma_103878 (h0 : topological_space (linear_ordered_field (option pos))) : irreducible_space (linear_ordered_field (option pos)) := sorry --non-trivial
lemma new_lemma_103879 (h0 : prod (finset name) (finset name)) : id_rel h0 := sorry --non-trivial
lemma new_lemma_103880 (h0 : functor.add_const (function.extfun Type complete_lattice) unsigned) : @is_atomistic.{0} (has_zero.{0} ennreal) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type complete_lattice.{0}) unsigned h0) (has_zero.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_103881 (h0 : not (complete_lattice (measurable_space fun_info) -> false)) : complete_lattice.is_Sup_finite_compact (measurable_space fun_info) := sorry --non-trivial
lemma new_lemma_103882 (h0 : functor.add_const (topological_space (complete_distrib_lattice name)) linarith.comp) : @loc_path_connected_space.{0} (complete_distrib_lattice.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (complete_distrib_lattice.{0} name)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_103883 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @strong_rank_condition.{0} (canonically_ordered_comm_semiring.{0} unsigned) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (canonically_ordered_comm_semiring.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_103884 (h2 : uniform_space ereal) : complete_space ereal := sorry --non-trivial
lemma new_lemma_103885 (h0 : functor.add_const (function.extfun Type topological_space) pos) : @irreducible_space.{0} (normed_comm_ring.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) pos h0) (normed_comm_ring.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_103886 (h0 : function.extfun nat fin) : @monoid.fg.{0} (has_to_string.{0} linarith.comp) (@matrix.vec_empty.{0} (monoid.{0} (has_to_string.{0} linarith.comp)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_103887 (h1 : uniform_space (has_le std_gen)) : complete_space (has_le std_gen) := sorry --non-trivial
lemma new_lemma_103888 (h0 : group (add_cancel_comm_monoid (has_nnnorm (has_nnnorm (comm_ring reducibility_hints))))) : is_cyclic (add_cancel_comm_monoid (has_nnnorm (has_nnnorm (comm_ring reducibility_hints)))) := sorry --non-trivial
lemma new_lemma_103889 (h0 : functor.add_const (topological_space (has_star empty)) num) : @topological_space.separable_space.{0} (has_star.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (has_star.{0} empty)) num h0)  := sorry --non-trivial
lemma new_lemma_103890 (h0 : functor.add_const (function.extfun Type add_group) linarith.comp) : @is_add_cyclic.{0} (add_cancel_monoid.{0} linarith.comp) (@function.extfun_app.{2 1} Type add_group.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type add_group.{0}) linarith.comp h0) (add_cancel_monoid.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_103891 (h0 : group (measurable_space.dynkin_system num)) : group.fg (measurable_space.dynkin_system num) := sorry --non-trivial
lemma new_lemma_103892 (h0 : function.extfun (finset Type) (has_mem.mem (with_one to_additive.value_type))) : @path_connected_space.{0} (with_one.{0} to_additive.value_type) (@finset.pi.empty.{1 0} Type topological_space.{0} (with_one.{0} to_additive.value_type) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (with_one.{0} to_additive.value_type)) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_103893 (h0 : topological_space (has_union (semiring (semiring unsigned)))) : totally_separated_space (has_union (semiring (semiring unsigned))) := sorry --non-trivial
lemma new_lemma_103894 (h0 : function.extfun Type filter) : filter.ne_bot (function.extfun_app h0 (metric_space empty)) := sorry --non-trivial
lemma new_lemma_103895 (h0 : list (option (option ennreal))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_103896 (h0 : function.extfun Type filter) : filter.ne_bot (function.extfun_app h0 (has_ssubset linarith.ineq)) := sorry --non-trivial
lemma new_lemma_103897 (h0 : topological_space (has_union (has_top congr_arg_kind))) : preirreducible_space (has_union (has_top congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_103898 (h0 : topological_space (has_top (random_gen fun_info))) : totally_disconnected_space (has_top (random_gen fun_info)) := sorry --non-trivial
lemma new_lemma_103899 (h0 : complete_lattice (has_top (has_nnnorm string_imp))) : complete_lattice.is_Sup_finite_compact (has_top (has_nnnorm string_imp)) := sorry --non-trivial
lemma new_lemma_103900 (h1 : topological_space (mul_one_class enat)) : totally_disconnected_space (mul_one_class enat) := sorry --non-trivial
lemma new_lemma_103901 (h0 : function.extfun Type topological_space) : @discrete_topology.{0} (has_dist.{0} ennreal) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_dist.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_103902 (h0 : uniform_space (normed_comm_ring (has_add (has_add (has_nndist Type))))) : separated_space (normed_comm_ring (has_add (has_add (has_nndist Type)))) := sorry --non-trivial
lemma new_lemma_103903 (h0 : function.extfun Type (functor.add_const (add_group (has_nndist linarith.comp)))) : @is_add_cyclic.{0} (has_nndist.{0} linarith.comp) (@functor.add_const.run.{0 0} (add_group.{0} (has_nndist.{0} linarith.comp)) linarith.comp (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (add_group.{0} (has_nndist.{0} linarith.comp))) h0 linarith.comp))  := sorry --non-trivial
lemma new_lemma_103904 (h0 : complete_lattice (with_bot (random_gen (random_gen linarith.comp_source)))) : complete_lattice.is_Sup_finite_compact (with_bot (random_gen (random_gen linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_103905 (h0 : topological_space (has_to_string (finset Type))) : totally_disconnected_space (has_to_string (finset Type)) := sorry --non-trivial
lemma new_lemma_103906 (h0 : ordered_add_comm_monoid (simple_graph num)) : archimedean (simple_graph num) := sorry --non-trivial
lemma new_lemma_103907 (h0 : function.extfun Type complete_lattice) : @is_atomistic.{0} (cancel_monoid.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (cancel_monoid.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_103908 (h0 : functor.add_const (ring (ring name)) Type) : @rank_condition.{0} (ring.{0} name) (@functor.add_const.run.{0 1} (ring.{0} (ring.{0} name)) Type h0)  := sorry --non-trivial
lemma new_lemma_103909 (h0 : functor.add_const (topological_space (boolean_algebra.core name)) (has_neg name)) : @totally_disconnected_space.{0} (boolean_algebra.core.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (boolean_algebra.core.{0} name)) (has_neg.{0} name) h0)  := sorry --non-trivial
lemma new_lemma_103910 (h0 : topological_space (has_pos_part (has_add (has_pos_part (complete_distrib_lattice real))))) : t1_space (has_pos_part (has_add (has_pos_part (complete_distrib_lattice real)))) := sorry --non-trivial
lemma new_lemma_103911 (h0 : has_coe string.iterator_imp Prop) (h1 : string.iterator_imp) : @coe_b.{1 1} string.iterator_imp Prop h0 h1  := sorry --non-trivial
lemma new_lemma_103912 (h0 : complete_lattice (linear_ordered_semiring (semiring fun_info))) : is_atomistic (linear_ordered_semiring (semiring fun_info)) := sorry --non-trivial
lemma new_lemma_103913 (h0 : cancel_comm_monoid_with_zero (has_neg ennreal)) : unique_factorization_monoid (has_neg ennreal) := sorry --non-trivial
lemma new_lemma_103914 (h0 : ordered_add_comm_monoid (add_semigroup num)) : archimedean (add_semigroup num) := sorry --non-trivial
lemma new_lemma_103915 (h0 : has_lt (normed_field string_imp)) : no_max_order (normed_field string_imp) := sorry --non-trivial
lemma new_lemma_103916 (h0 : filter (pseudo_metric_space (ring pos))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_103917 (h0 : cancel_comm_monoid_with_zero pos) : unique_factorization_monoid pos := sorry --non-trivial
lemma new_lemma_103918 (h0 : not (group (distrib (has_nnnorm linarith.ineq)) -> false)) : @is_cyclic.{0} (distrib.{0} (has_nnnorm.{0} linarith.ineq)) (@classical.by_contradiction'.{1} (group.{0} (distrib.{0} (has_nnnorm.{0} linarith.ineq))) h0)  := sorry --non-trivial
lemma new_lemma_103919 (h0 : topological_space (complete_distrib_lattice (semigroup (has_add (cancel_monoid (has_add Type)))))) : irreducible_space (complete_distrib_lattice (semigroup (has_add (cancel_monoid (has_add Type))))) := sorry --non-trivial
lemma new_lemma_103920 (h0 : complete_lattice (has_div (semi_normed_ring (distrib (has_nnnorm fun_info))))) : is_compactly_generated (has_div (semi_normed_ring (distrib (has_nnnorm fun_info)))) := sorry --non-trivial
lemma new_lemma_103921 (h0 : uniform_space (normed_field fun_info)) : complete_space (normed_field fun_info) := sorry --non-trivial
lemma new_lemma_103922 (h0 : topological_space (with_one fun_info)) : locally_compact_space (with_one fun_info) := sorry --non-trivial
lemma new_lemma_103923 (h0 : topological_space unsigned) : loc_path_connected_space unsigned := sorry --non-trivial
lemma new_lemma_103924 (h0 : ring (has_add (sub_neg_monoid real))) : strong_rank_condition (has_add (sub_neg_monoid real)) := sorry --non-trivial
lemma new_lemma_103925 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @rank_condition.{0} (linear_ordered_semiring.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (linear_ordered_semiring.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_103926 (h1 : ring (has_emptyc congr_arg_kind)) : strong_rank_condition (has_emptyc congr_arg_kind) := sorry --non-trivial
lemma new_lemma_103927 (h0 : ring (has_neg (finset (finset (has_neg linarith.comp))))) : is_principal_ideal_ring (has_neg (finset (finset (has_neg linarith.comp)))) := sorry --non-trivial
lemma new_lemma_103928 (h0 : function.extfun Type ring) : @is_principal_ideal_ring.{0} (canonically_ordered_comm_semiring.{0} pos) (@function.extfun_app.{2 1} Type ring.{0} h0 (canonically_ordered_comm_semiring.{0} pos))  := sorry --non-trivial
lemma new_lemma_103929 (h0 : complete_lattice (add_cancel_comm_monoid (mul_one_class string_imp))) : complete_lattice.is_Sup_finite_compact (add_cancel_comm_monoid (mul_one_class string_imp)) := sorry --non-trivial
lemma new_lemma_103930 (h0 : functor.add_const (ordered_comm_monoid (normed_comm_ring environment.implicit_infer_kind)) (has_add Type)) : @has_exists_mul_of_le.{0} (normed_comm_ring.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 1} (ordered_comm_monoid.{0} (normed_comm_ring.{0} environment.implicit_infer_kind)) (has_add.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_103931 (h0 : functor.add_const (ordered_comm_monoid environment.implicit_infer_kind) linarith.comp) : @has_exists_mul_of_le.{0} environment.implicit_infer_kind (@functor.add_const.run.{0 0} (ordered_comm_monoid.{0} environment.implicit_infer_kind) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_103932 (h0 : functor.add_const (topological_space (boolean_algebra pos)) Type) : @topological_space.separable_space.{0} (boolean_algebra.{0} pos) (@functor.add_const.run.{0 1} (topological_space.{0} (boolean_algebra.{0} pos)) Type h0)  := sorry --non-trivial
lemma new_lemma_103933 (h0 : function.extfun nat fin) : @discrete_topology.{0} (ordered_comm_ring.{0} pos) (@matrix.vec_empty.{0} (topological_space.{0} (ordered_comm_ring.{0} pos)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_103934 (h0 : functor.add_const (topological_space (has_add ennreal)) unsigned) : @irreducible_space.{0} (has_add.{0} ennreal) (@functor.add_const.run.{0 0} (topological_space.{0} (has_add.{0} ennreal)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_103935 (h0 : group (comm_group (cancel_monoid name))) : normalizer_condition (comm_group (cancel_monoid name)) := sorry --non-trivial
lemma new_lemma_103936 (h0 : function.extfun Type topological_space) : @regular_space.{0} (has_neg.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_neg.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_103937 (h0 : complete_lattice (non_unital_non_assoc_semiring fun_info)) : complete_lattice.is_Sup_finite_compact (non_unital_non_assoc_semiring fun_info) := sorry --non-trivial
lemma new_lemma_103938 (h0 : not (complete_lattice (has_inv to_additive.value_type) -> false)) : @complete_lattice.is_Sup_finite_compact.{0} (has_inv.{0} to_additive.value_type) (@classical.by_contradiction'.{1} (complete_lattice.{0} (has_inv.{0} to_additive.value_type)) h0)  := sorry --non-trivial
lemma new_lemma_103939 (h0 : functor.add_const (finset (finset linarith.comp)) pos) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_103940 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @monoid.fg.{0} (has_star.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 monoid.{0}) (has_star.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_103941 (h0 : functor.add_const (topological_space (sub_neg_monoid linarith.comp)) linarith.comp) : @preconnected_space.{0} (sub_neg_monoid.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (sub_neg_monoid.{0} linarith.comp)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_103942 (h0 : topological_space (generalized_boolean_algebra (has_Inf (has_add (ring pos))))) : preirreducible_space (generalized_boolean_algebra (has_Inf (has_add (ring pos)))) := sorry --non-trivial
lemma new_lemma_103943 (h0 : functor.add_const (topological_space (has_Inf pos)) linarith.comp) : @t1_space.{0} (has_Inf.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (has_Inf.{0} pos)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_103944 (h0 : functor.add_const (ring (ring linarith.comp)) (finset linarith.comp)) : @is_principal_ideal_ring.{0} (ring.{0} linarith.comp) (@functor.add_const.run.{0 0} (ring.{0} (ring.{0} linarith.comp)) (finset.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_103945 (h0 : cancel_comm_monoid_with_zero (ring (option (option (option (option (option empty))))))) : unique_factorization_monoid (ring (option (option (option (option (option empty)))))) := sorry --non-trivial
lemma new_lemma_103946 (h0 : cancel_comm_monoid_with_zero (normed_lattice_add_comm_group (has_pos_part (has_bot (has_bot pos))))) : unique_factorization_monoid (normed_lattice_add_comm_group (has_pos_part (has_bot (has_bot pos)))) := sorry --non-trivial
lemma new_lemma_103947 (h0 : semiring (has_union (semiring (semiring unsigned)))) : is_noetherian_ring (has_union (semiring (semiring unsigned))) := sorry --non-trivial
lemma new_lemma_103948 (h0 : functor.add_const (group (canonically_ordered_comm_semiring name)) name) : @group.fg.{0} (canonically_ordered_comm_semiring.{0} name) (@functor.add_const.run.{0 0} (group.{0} (canonically_ordered_comm_semiring.{0} name)) name h0)  := sorry --non-trivial
lemma new_lemma_103949 (h0 : functor.add_const (topological_space (semigroup environment.implicit_infer_kind)) pos) : @loc_path_connected_space.{0} (semigroup.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (semigroup.{0} environment.implicit_infer_kind)) pos h0)  := sorry --non-trivial
lemma new_lemma_103950 (h0 : ring enat) (h1 : has_lt (has_nnnorm (mul_one_class (has_nnnorm (ring.positive_cone enat))))) : no_max_order (has_nnnorm (mul_one_class (has_nnnorm (ring.positive_cone enat)))) := sorry --non-trivial
lemma new_lemma_103951 (h0 : function.extfun (finset (Type -> Type)) (has_mem.mem topological_space)) : @totally_disconnected_space.{0} (with_one.{0} (has_top.{0} empty)) (@function.extfun_app.{2 1} Type topological_space.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) topological_space.{0} (@function.extfun_app.{2 0} (finset.{1} (Type → Type)) (@has_mem.mem.{1 1} (Type → Type) (finset.{1} (Type → Type)) (@finset.has_mem.{1} (Type → Type)) topological_space.{0}) h0 (@has_emptyc.emptyc.{1} (finset.{1} (Type → Type)) (@finset.has_emptyc.{1} (Type → Type))))) (with_one.{0} (has_top.{0} empty)))  := sorry --non-trivial
lemma new_lemma_103952 (h0 : semiring (boolean_algebra (finset (finset pos)))) : is_noetherian_ring (boolean_algebra (finset (finset pos))) := sorry --non-trivial
lemma new_lemma_103953 (h0 : topological_space (normed_group (random_gen (random_gen num)))) : totally_disconnected_space (normed_group (random_gen (random_gen num))) := sorry --non-trivial
lemma new_lemma_103954 (h0 : set (add_comm_semigroup (mul_one_class (mul_one_class auto.case_option)) -> std_gen)) : set.separates_points h0 := sorry --non-trivial
lemma new_lemma_103955 (h0 : function.extfun Type semiring) : @is_noetherian_ring.{0} (add_comm_monoid.{0} real) (@function.extfun_app.{2 1} Type semiring.{0} h0 (add_comm_monoid.{0} real))  := sorry --non-trivial
lemma new_lemma_103956 (h0 : ring (cancel_monoid (has_add (has_nndist (has_add name))))) : is_domain (cancel_monoid (has_add (has_nndist (has_add name)))) := sorry --non-trivial
lemma new_lemma_103957 (h0 : ring (dlist (has_inv (random_gen linarith.ineq)))) : is_domain (dlist (has_inv (random_gen linarith.ineq))) := sorry --non-trivial
lemma new_lemma_103958 (h0 : functor.add_const (complete_lattice (semigroup Type)) Type) : @complete_lattice.is_Sup_finite_compact.{1} (semigroup.{1} Type) (@functor.add_const.run.{1 1} (complete_lattice.{1} (semigroup.{1} Type)) Type h0)  := sorry --non-trivial
lemma new_lemma_103959 (h1 : monoid (measurable_space linarith.comp)) : monoid.fg (measurable_space linarith.comp) := sorry --non-trivial
lemma new_lemma_103960 (h0 : topological_space (has_zero (has_Inf Type))) : t0_space (has_zero (has_Inf Type)) := sorry --non-trivial
lemma new_lemma_103961 (h0 : topological_space environment.projection_info) (h1 : has_lt (topological_space.opens environment.projection_info)) : no_max_order (topological_space.opens environment.projection_info) := sorry --non-trivial
lemma new_lemma_103962 (h2 : topological_space (nondiscrete_normed_field fun_info)) (h3 : set (nondiscrete_normed_field fun_info)) : is_path_connected h3 := sorry --non-trivial
lemma new_lemma_103963 (h0 : topological_space (comm_semigroup (ordered_comm_monoid pos))) : t1_space (comm_semigroup (ordered_comm_monoid pos)) := sorry --non-trivial
lemma new_lemma_103964 (h0 : functor.add_const (topological_space (finset Type)) pos) : @sequential_space.{1} (finset.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (finset.{1} Type)) pos h0)  := sorry --non-trivial
lemma new_lemma_103965 (h0 : function.extfun Type uniform_space) : @complete_space.{0} (canonically_ordered_comm_semiring.{0} linarith.comp) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (canonically_ordered_comm_semiring.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_103966 (h0 : functor.add_const (topological_space (ordered_ring congr_arg_kind)) num) : @loc_path_connected_space.{0} (ordered_ring.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (ordered_ring.{0} congr_arg_kind)) num h0)  := sorry --non-trivial
lemma new_lemma_103967 (h0 : group (group_with_zero (has_to_string congr_arg_kind))) : is_simple_group (group_with_zero (has_to_string congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_103968 (h0 : function.extfun Type group) : @normalizer_condition.{0} (ordered_cancel_add_comm_monoid.{0} name) (@function.extfun_app.{2 1} Type group.{0} h0 (ordered_cancel_add_comm_monoid.{0} name))  := sorry --non-trivial
lemma new_lemma_103969 (h0 : uniform_space (has_norm (has_emptyc num))) : separated_space (has_norm (has_emptyc num)) := sorry --non-trivial
lemma new_lemma_103970 (h0 : topological_space (has_neg_part (option unsigned))) : totally_disconnected_space (has_neg_part (option unsigned)) := sorry --non-trivial
lemma new_lemma_103971 (h0 : functor.add_const (functor.add_const (complete_lattice Type) Type) linarith.comp) : @complete_lattice.is_Sup_finite_compact.{1} Type (@functor.add_const.run.{1 1} (complete_lattice.{1} Type) Type (@functor.add_const.run.{1 0} (functor.add_const.{1 1} (complete_lattice.{1} Type) Type) linarith.comp h0))  := sorry --non-trivial
lemma new_lemma_103972 (h0 : topological_space (has_add (has_add (has_add (has_add pos))))) : discrete_topology (has_add (has_add (has_add (has_add pos)))) := sorry --non-trivial
lemma new_lemma_103973 (h0 : topological_space (distrib fun_info)) : path_connected_space (distrib fun_info) := sorry --non-trivial
lemma new_lemma_103974 (h1 : not (group (id linarith.comp) -> false)) : @group.fg.{0} (@id.{2} Type linarith.comp) (@classical.by_contradiction'.{1} (group.{0} (@id.{2} Type linarith.comp)) h1)  := sorry --non-trivial
lemma new_lemma_103975 (h0 : functor.add_const (group (add_semigroup unsigned)) empty) : @is_cyclic.{0} (add_semigroup.{0} unsigned) (@functor.add_const.run.{0 0} (group.{0} (add_semigroup.{0} unsigned)) empty h0)  := sorry --non-trivial
lemma new_lemma_103976 (h0 : functor.add_const (function.extfun Type topological_space) name) : @locally_compact_space.{0} (has_pos_part.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) name h0) (has_pos_part.{0} pos))  := sorry --non-trivial
lemma new_lemma_103977 (h0 : not (prod (has_one num) (has_one num) -> false)) : id_rel (classical.by_contradiction' h0) := sorry --non-trivial
lemma new_lemma_103978 (h0 : not (filter (has_one unsigned) -> false)) : filter.ne_bot (classical.by_contradiction' h0) := sorry --non-trivial
lemma new_lemma_103979 (h0 : complete_lattice (normed_group (denumerable (has_nnnorm char)))) : is_compactly_generated (normed_group (denumerable (has_nnnorm char))) := sorry --non-trivial
lemma new_lemma_103980 (h0 : has_lt (has_lt (mul_one_class linarith.ineq))) : no_max_order (has_lt (mul_one_class linarith.ineq)) := sorry --non-trivial
lemma new_lemma_103981 (h0 : topological_space (complete_distrib_lattice ennreal)) : preirreducible_space (complete_distrib_lattice ennreal) := sorry --non-trivial
lemma new_lemma_103982 (h1 : ring (add_cancel_comm_monoid reducibility_hints)) : strong_rank_condition (add_cancel_comm_monoid reducibility_hints) := sorry --non-trivial
lemma new_lemma_103983 (h0 : not (complete_lattice (normed_group fun_info) -> false)) : @is_compactly_generated.{0} (normed_group.{0} fun_info) (@classical.by_contradiction'.{1} (complete_lattice.{0} (normed_group.{0} fun_info)) h0)  := sorry --non-trivial
lemma new_lemma_103984 (h0 : functor.add_const (topological_space (has_to_string linarith.comp)) name) : @t0_space.{0} (has_to_string.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (has_to_string.{0} linarith.comp)) name h0)  := sorry --non-trivial
lemma new_lemma_103985 (h0 : functor.add_const (topological_space (has_edist num)) congr_arg_kind) : @t0_space.{0} (has_edist.{0} num) (@functor.add_const.run.{0 0} (topological_space.{0} (has_edist.{0} num)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_103986 (h0 : topological_space (boolean_algebra.core congr_arg_kind)) : normal_space (boolean_algebra.core congr_arg_kind) := sorry --non-trivial
lemma new_lemma_103987 (h1 : ring (add_comm_semigroup char)) : strong_rank_condition (add_comm_semigroup char) := sorry --non-trivial
lemma new_lemma_103988 (h0 : set (has_nnnorm (mul_one_class char))) : set.finite h0 := sorry --non-trivial
lemma new_lemma_103989 (h0 : function.extfun (Type 1) topological_space) : @loc_path_connected_space.{1} (simple_graph.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} h0 (simple_graph.{1} Type))  := sorry --non-trivial
lemma new_lemma_103990 (h0 : topological_space (normed_group (has_inv linarith.comp_source))) : locally_compact_space (normed_group (has_inv linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_103991 (h0 : not (function.extfun Type complete_lattice -> false)) : @is_atomistic.{0} (has_norm.{0} fun_info) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type complete_lattice.{0}) h0) (has_norm.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_103992 (h0 : functor.add_const (topological_space (has_dist num)) congr_arg_kind) : @discrete_topology.{0} (has_dist.{0} num) (@functor.add_const.run.{0 0} (topological_space.{0} (has_dist.{0} num)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_103993 (h0 : group (normed_comm_ring (has_neg pos))) : group.fg (normed_comm_ring (has_neg pos)) := sorry --non-trivial
lemma new_lemma_103994 (h0 : ring (add_comm_monoid (normed_comm_ring pos))) : strong_rank_condition (add_comm_monoid (normed_comm_ring pos)) := sorry --non-trivial
lemma new_lemma_103995 (h0 : topological_space (semigroup (add_comm_monoid (comm_group unsigned)))) : preirreducible_space (semigroup (add_comm_monoid (comm_group unsigned))) := sorry --non-trivial
lemma new_lemma_103996 (h0 : functor.add_const (ordered_add_comm_monoid (semiring empty)) empty) : @archimedean.{0} (semiring.{0} empty) (@functor.add_const.run.{0 0} (ordered_add_comm_monoid.{0} (semiring.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_103997 (h0 : functor.add_const (group (sub_neg_monoid pos)) linarith.comp) : @normalizer_condition.{0} (sub_neg_monoid.{0} pos) (@functor.add_const.run.{0 0} (group.{0} (sub_neg_monoid.{0} pos)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_103998 (h0 : functor.add_const (function.extfun Type group) ennreal) : @group.fg.{0} (has_neg.{0} pos) (@function.extfun_app.{2 1} Type group.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type group.{0}) ennreal h0) (has_neg.{0} pos))  := sorry --non-trivial
lemma new_lemma_103999 (h0 : function.extfun (nat -> Type) (function.extfun nat)) : topological_space.separable_space real := sorry --non-trivial
